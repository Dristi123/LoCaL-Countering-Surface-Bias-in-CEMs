{"id": "p03371_u732870425", "golden_code": "A, B, C, X, Y = list(map(int, input().split()))\n\n\n\nans = 5000 * 2 * 10 ** 5\n\nfor i in range(10 ** 5 + 1):\n\n    s = i * 2 * C + max(0, X - i) * A + max(0, Y - i) * B\n\n    ans = min(ans, s)\n\n\n\nprint(ans)", "generated_code": "A, B, C, X, Y = list(map(int, input().split()))\n\n\n\nif X > Y:\n\n    v = A\n\nelse:\n\n    v = B\n\n\n\nans = min(A*X+B*Y, C*max(X, Y)*2, C*min(X,Y)*2+(max(X,Y)-min(X,Y))*v)\n\n\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.6942916993977482}
{"id": "p02612_u102461423", "golden_code": "import sys\n\n\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\nN = int(read())\n\nx = N + (-N) % 1000\n\nprint((x - N))", "generated_code": "import math\n\nN = int(eval(input()))\n\nx = math.ceil(N/1000) * 1000\n\nprint((x-N))", "score": 1.0, "surface_similarity": 0.5324461722488039}
{"id": "p03013_u105210954", "golden_code": "import numpy as np\n\ndef resolve():\n\n    MOD = 10 ** 9 + 7\n\n    n, m = list(map(int, input().split()))\n\n    a = [int(eval(input())) for _ in range(m)]\n\n\n\n    dp = np.array([1] * (n + 1))\n\n    dp[a] = 0\n\n\n\n    for i in range(2, n + 1):\n\n        if dp[i] != 0:\n\n            dp[i] = np.sum(dp[i - 2:i]) % MOD\n\n\n\n    print((dp[n]))\n\n    \n\nresolve()", "generated_code": "def resolve():\n\n    MOD = 10 ** 9 + 7\n\n    n, m = list(map(int, input().split()))\n\n\n\n    # i段目に到達するまでのルートの総数\n\n    dp = [1] * (n + 1)\n\n\n\n    for _ in range(m):\n\n        dp[int(eval(input()))] = 0\n\n\n\n    for i in range(2, n + 1):\n\n        if dp[i] == 0:\n\n            continue\n\n\n\n        dp[i] = (dp[i - 1] + dp[i - 2]) % MOD\n\n\n\n    print((dp[n]))\n\n    \n\nresolve()", "score": 1.0, "surface_similarity": 0.7711218836565097}
{"id": "p02596_u952708174", "golden_code": "def c_repsept():\n\n    K = int(eval(input()))\n\n\n\n    L = 9 * K // 7 if K % 7 == 0 else 9 * K\n\n    if L % 2 == 0 or L % 5 == 0:\n\n        return -1\n\n\n\n    remainder = 1\n\n    for n in range(1, L + 1):\n\n        remainder = (10 * remainder) % L\n\n        if remainder == 1:\n\n            return n\n\n    return -1\n\n\n\nprint((c_repsept()))", "generated_code": "def c_repsept_totient():\n\n    def euler_phi(n):\n\n        \"\"\"正整数 n に対して、n と互いに素な n 以下の正整数の個数\"\"\"\n\n        ret = n\n\n        for i in range(2, int(n**0.5) + 1):\n\n            if n % i == 0:\n\n                ret = ret // i * (i - 1)\n\n                while n % i == 0:\n\n                    n //= i\n\n        if n > 1:\n\n            ret -= ret // n\n\n        return ret\n\n\n\n    def divisor_list(n):\n\n        \"\"\"n の正の約数のリスト\"\"\"\n\n        ret = set()\n\n        for k in range(1, int(n**0.5) + 1):\n\n            if n % k == 0:\n\n                ret.update({k, n // k})\n\n        return sorted(ret)\n\n\n\n    K = int(eval(input()))\n\n    L = 9 * (K // 7 if K % 7 == 0 else K)\n\n\n\n    for d in divisor_list(euler_phi(L)):\n\n        if pow(10, d, L) == 1:\n\n            return d\n\n    return -1\n\n\n\nprint((c_repsept_totient()))", "score": 1.0, "surface_similarity": 0.6438248988626822}
{"id": "p03039_u075012704", "golden_code": "H, W, K = list(map(int, input().split()))\n\nMOD = 10 ** 9 + 7\n\n\n\nHd = sum([d * (H - d) * (W ** 2) for d in range(H)])\n\nWd = sum([d * (W - d) * (H ** 2) for d in range(W)])\n\n\n\n\n\n# 階乗 & 逆元計算\n\nfactorial = [1]\n\ninverse = [1]\n\nfor i in range(1, H * W + 2):\n\n    factorial.append(factorial[-1] * i % MOD)\n\n    inverse.append(pow(factorial[-1], MOD - 2, MOD))\n\n\n\n\n\nans = (Hd + Wd) * factorial[H * W - 2] * inverse[K - 2] * inverse[H * W - K] % MOD\n\nprint(ans)\n", "generated_code": "H, W, K = list(map(int, input().split()))\n\nMOD = 10 ** 9 + 7\n\n\n\nfactorial = [1, 1]  # 元テーブル\n\ninverse = [1, 1]  # 逆元テーブル\n\ninverse_from = [0, 1]  # 逆元テーブル計算用テーブル\n\n\n\nfor i in range(2, H * W + 1):\n\n    factorial.append((factorial[-1] * i) % MOD)\n\n    inverse_from.append((-inverse_from[MOD % i] * (MOD // i)) % MOD)\n\n    inverse.append((inverse[-1] * inverse_from[-1]) % MOD)\n\n\n\n\n\ndef nCr(n, r):\n\n    if n < r or r < 0:\n\n        return 0\n\n    elif r == 0:\n\n        return 1\n\n    return factorial[n] * inverse[r] * inverse[n - r] % MOD\n\n\n\n\n\nans = 0\n\n# Hについて\n\nfor d in range(1, H):\n\n    ans += d * (H - d) * pow(W, 2, MOD) * nCr(H * W - 2, K - 2) % MOD\n\n    ans %= MOD\n\n# Wについて\n\nfor d in range(1, W):\n\n    ans += d * (W - d) * pow(H, 2, MOD) * nCr(H * W - 2, K - 2) % MOD\n\n    ans %= MOD\n\n\n\nprint((ans % MOD))\n", "score": 1.0, "surface_similarity": 0.5791873963515755}
{"id": "p03078_u056277698", "golden_code": "# -*- coding: utf-8 -*-\n\nx, y, z, k = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\nb = list(map(int, input().split()))\n\nc = list(map(int, input().split()))\n\n\n\na.sort(reverse=True)\n\nb.sort(reverse=True)\n\nc.sort(reverse=True)\n\n\n\nabc = []\n\n\n\nfor i, _a in enumerate(a):\n\n    for j, _b in enumerate(b):\n\n        if (i+1) * (j+1) > k:\n\n            break\n\n        for l, _c in enumerate(c):\n\n            if (i+1) * (j+1) * (l+1) > k:\n\n                break\n\n            abc.append(_a + _b + _c)\n\n\n\nabc.sort(reverse=True)\n\nfor x in abc[:k]:\n\n    print(x)\n", "generated_code": "# -*- coding: utf-8 -*-\n\nimport heapq\n\n\n\nx, y, z, k = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\nb = list(map(int, input().split()))\n\nc = list(map(int, input().split()))\n\n\n\nla, lb, lc = len(a), len(b), len(c)\n\n\n\na.sort(reverse=True)\n\nb.sort(reverse=True)\n\nc.sort(reverse=True)\n\n\n\nfix = set()\n\n\n\nq = [(-(a[0]+b[0]+c[0]), 0, 0, 0)]\n\n\n\nfor _ in range(k):\n\n    abc, i, j, l = heapq.heappop(q)\n\n    print((-abc))\n\n\n\n    if i+1 < la and (i+1, j, l) not in fix:\n\n        heapq.heappush(q, (-(a[i+1]+b[j]+c[l]), i+1, j, l))\n\n        fix.add((i+1, j, l))\n\n\n\n    if j+1 < lb and (i, j+1, l) not in fix:\n\n        heapq.heappush(q, (-(a[i]+b[j+1]+c[l]), i, j+1, l))\n\n        fix.add((i, j+1, l))\n\n\n\n    if l+1 < lc and (i, j, l+1) not in fix:\n\n        heapq.heappush(q, (-(a[i]+b[j]+c[l+1]), i, j, l+1))\n\n        fix.add((i, j, l+1))\n", "score": 1.0, "surface_similarity": 0.5830198715756678}
{"id": "p03559_u761320129", "golden_code": "N = int(eval(input()))\n\nA = list(map(int,input().split()))\n\nB = list(map(int,input().split()))\n\nC = list(map(int,input().split()))\n\nA.sort()\n\nC.sort()\n\n\n\nans = 0\n\nfrom bisect import bisect, bisect_left\n\nfor b in B:\n\n    i = bisect_left(A, b)\n\n    j = bisect(C, b)\n\n    ans += i * (N-j)\n\nprint(ans)", "generated_code": "N = int(eval(input()))\n\nA = list(map(int,input().split()))\n\nB = list(map(int,input().split()))\n\nC = list(map(int,input().split()))\n\nA.sort()\n\nC.sort()\n\n\n\nfrom bisect import bisect_left, bisect\n\nans = 0\n\nfor b in B:\n\n    i = bisect_left(A,b)\n\n    j = bisect(C,b)\n\n    ans += i * (N-j)\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.9713804713804715}
{"id": "p03674_u984276646", "golden_code": "n = int(eval(input()))\n\na = list(map(int, input().split()))\n\nD = {i: [0] for i in range(1, n+1)}\n\nfor i in range(n+1):\n\n  D[a[i]][0] += 1\n\n  D[a[i]].append(i)\n\npl, pr = 0, 0\n\nfor i in D:\n\n  if D[i][0] == 2:\n\n    pl = D[i][1]\n\n    pr = D[i][2]\n\n    break\n\nL = pl\n\nM = pr - pl - 1\n\nN = n - pr\n\nmod = int(1e9) + 7 # <-- input modulo\n\nmaxf = n+11          # <-- input factional limitation\n\n\n\ndef make_fact(n, k):\n\n    tmp = n\n\n    perm = [i for i in range(k)]\n\n    L = [0 for _ in range(k)]\n\n    for i in range(k):\n\n        L[i] = tmp % (i + 1)\n\n        tmp //= i + 1\n\n    LL = [0 for _ in range(k)]\n\n    for i in range(k):\n\n        LL[i] = perm[L[-i-1]]\n\n        for j in range(L[-i-1]+1, k):\n\n            perm[j-1] = perm[j]\n\n    return LL\n\n\n\ndef doubling(n, m, modulo=mod):\n\n    y = 1\n\n    base = n\n\n    tmp = m\n\n    while tmp != 0:\n\n        if tmp % 2 == 1:\n\n            y *= base\n\n            if modulo > 0:\n\n                y %= modulo\n\n        base *= base\n\n        if modulo > 0:\n\n            base %= modulo\n\n        tmp //= 2\n\n    return y\n\n\n\ndef inved(a, modulo=mod):\n\n    x, y, u, v, k, l = 1, 0, 0, 1, a, modulo\n\n    while l != 0:\n\n        x, y, u, v = u, v, x - u * (k // l), y - v * (k // l)\n\n        k, l = l, k % l\n\n    return x % modulo\n\n\n\nfact = [1 for _ in range(maxf+1)]\n\ninvf = [1 for _ in range(maxf+1)]\n\n\n\nfor i in range(maxf):\n\n    fact[i+1] = (fact[i] * (i+1)) % mod\n\ninvf[-1] = inved(fact[-1])\n\nfor i in range(maxf, 0, -1):\n\n    invf[i-1] = (invf[i] * i) % mod\n\n\n\nfor i in range(1, n+2):\n\n  S = fact[n]*invf[i-1]*invf[n-i+1]%mod\n\n  if i <= n-1:\n\n    S += fact[n-1]*invf[i]*invf[n-1-i]%mod\n\n    S %= mod\n\n  if i <= n-M:\n\n    S -= fact[n-1-M]*invf[i-1]*invf[n-M-i]%mod\n\n    S %= mod\n\n  if i <= n:\n\n    S += fact[n-1]*invf[i-1]*invf[n-i]%mod\n\n    S %= mod\n\n  print(S)", "generated_code": "n = int(eval(input()))\n\na = list(map(int, input().split()))\n\nD = {i: [0] for i in range(1, n+1)}\n\nfor i in range(n+1):\n\n  D[a[i]][0] += 1\n\n  D[a[i]].append(i)\n\npl, pr = 0, 0\n\nfor i in D:\n\n  if D[i][0] == 2:\n\n    pl = D[i][1]\n\n    pr = D[i][2]\n\n    break\n\nL = pl\n\nM = pr - pl - 1\n\nN = n - pr\n\nmod = int(1e9) + 7 # <-- input modulo\n\nmaxf = n+11          # <-- input factional limitation\n\n\n\ndef make_fact(n, k):\n\n    tmp = n\n\n    perm = [i for i in range(k)]\n\n    L = [0 for _ in range(k)]\n\n    for i in range(k):\n\n        L[i] = tmp % (i + 1)\n\n        tmp //= i + 1\n\n    LL = [0 for _ in range(k)]\n\n    for i in range(k):\n\n        LL[i] = perm[L[-i-1]]\n\n        for j in range(L[-i-1]+1, k):\n\n            perm[j-1] = perm[j]\n\n    return LL\n\n\n\ndef doubling(n, m, modulo=mod):\n\n    y = 1\n\n    base = n\n\n    tmp = m\n\n    while tmp != 0:\n\n        if tmp % 2 == 1:\n\n            y *= base\n\n            if modulo > 0:\n\n                y %= modulo\n\n        base *= base\n\n        if modulo > 0:\n\n            base %= modulo\n\n        tmp //= 2\n\n    return y\n\n\n\ndef inved(a, modulo=mod):\n\n    x, y, u, v, k, l = 1, 0, 0, 1, a, modulo\n\n    while l != 0:\n\n        x, y, u, v = u, v, x - u * (k // l), y - v * (k // l)\n\n        k, l = l, k % l\n\n    return x % modulo\n\n\n\nfact = [1 for _ in range(maxf+1)]\n\ninvf = [1 for _ in range(maxf+1)]\n\n\n\nfor i in range(maxf):\n\n    fact[i+1] = (fact[i] * (i+1)) % mod\n\ninvf[-1] = inved(fact[-1])\n\nfor i in range(maxf, 0, -1):\n\n    invf[i-1] = (invf[i] * i) % mod\n\n\n\nfor i in range(1, n+2):\n\n  S = fact[n+1]*invf[i]*invf[n-i+1]%mod\n\n  if i <= n-M:\n\n    S -= fact[n-1-M]*invf[i-1]*invf[n-M-i]%mod\n\n    S %= mod\n\n  print(S)\n", "score": 1.0, "surface_similarity": 0.9694848824188129}
{"id": "p02952_u671060652", "golden_code": "n = int(eval(input()))\n\n\n\n\n\ndef countKeta(num):\n\n    count = 1\n\n    while num / 10 >= 1:\n\n        count += 1\n\n        num = num // 10\n\n    return count\n\n\n\n\n\ncount = 0\n\n\n\nfor i in range(1, n+1):\n\n    if(countKeta(i) % 2 == 1):\n\n        count += 1\n\n\n\nprint(count)", "generated_code": "n = int(eval(input()))\n\n\n\nif n < 10:\n\n    print(n)\n\nelif n < 100:\n\n    print((9))\n\nelif n < 1000:\n\n    print((n-90))\n\nelif n < 10000:\n\n    print((909))\n\nelif n < 100000:\n\n    print((n-9090))\n\nelif n < 1000000:\n\n    print((90909))", "score": 1.0, "surface_similarity": 0.47015915119363394}
{"id": "p03721_u598016178", "golden_code": "import numpy as np\n\n\n\nn, k = list(map(int, input().split()))\n\nz = np.zeros(10**5 + 1)\n\nfor i in range(n):\n\n  a, b = list(map(int, input().split()))\n\n  z[a] += b\n\n\n\na = 0\n\nfor i in range(1, 10**5 + 1):\n\n  if k <= z[i]:\n\n    a = i\n\n    break\n\n  k -= z[i]\n\n\n\nprint((int(a)))\n", "generated_code": "n, k = list(map(int, input().split()))\n\nd = {}\n\nfor i in range(n):\n\n  a, b = list(map(int, input().split()))\n\n  d[a] = d[a] + b if a in d else b\n\n \n\na = 0\n\nfor i in range(1, 10**5+1):\n\n  if i in d and k <= d[i]:\n\n    a = i\n\n    break\n\n  k -= d[i] if i in d else 0\n\n \n\nprint(a)", "score": 1.0, "surface_similarity": 0.7452523738130934}
{"id": "p02996_u837286475", "golden_code": "\n\n\n\nn = int(eval(input()))\n\n\n\nabn = [list(map(int,input().split())) for _ in range(n)]\n\n\n\n\n\nabn.sort()\n\nabn.sort(key = lambda x:x[1])\n\n\n\n\n\n#print(abn)\n\n\n\nts = 0 # time_stamp\n\nenable = True\n\nfor abi in abn:\n\n    a, b = abi\n\n\n\n    if not ts + a <= b:\n\n        enable = False\n\n        break\n\n    else:\n\n        ts += a\n\n\n\nprint(('Yes' if enable else 'No'))", "generated_code": "\n\nn = int(eval(input()))\n\n\n\nabn = [list(map(int,input().split())) for _ in range(n)]\n\n\n\n\n\n#abn.sort()\n\nabn.sort(key = lambda x:x[1])\n\n\n\n\n\n#print(abn)\n\n\n\nts = 0 # time_stamp\n\nenable = True\n\nfor abi in abn:\n\n    a, b = abi\n\n\n\n    if not ts + a <= b:\n\n        enable = False\n\n        break\n\n    else:\n\n        ts += a\n\n\n\nprint(('Yes' if enable else 'No'))", "score": 1.0, "surface_similarity": 0.9844192634560907}
{"id": "p00053_u546285759", "golden_code": "def isPrime(x):\n\n    if x == 2:\n\n        return True\n\n    if x < 2 or x % 2 == 0:\n\n        return False\n\n    i, root_x = 3, int(pow(x, 0.5))\n\n    while i <= root_x:\n\n        if x % i == 0:\n\n            return False\n\n        i += 2\n\n    return True\n\n\n\nprimes = [2]\n\nfor i in range(3, 104730):\n\n    if isPrime(i):\n\n        primes.append(primes[-1]+i)\n\nwhile True:\n\n    n = int(eval(input()))\n\n    if n == 0:\n\n        break\n\n    print((primes[n-1]))", "generated_code": "primes = [0, 0] + [1] * 150000\n\nfor i in range(2, 388):\n\n    if primes[i]:\n\n        for j in range(i*i, 150001, i):\n\n            primes[j] = 0\n\n\n\nvalues = [i for i, v in enumerate(primes) if v]\n\nwhile True:\n\n    n = int(eval(input()))\n\n    if n == 0:\n\n        break\n\n    print((sum(values[:n])))", "score": 1.0, "surface_similarity": 0.5636063252301156}
{"id": "p03162_u773686010", "golden_code": "# https://atcoder.jp/contests/dp/tasks/dp_c\n\nimport numpy as np\n\nN = int(eval(input()))\n\nMax_List=[]\n\nN_List=[i for i in range(3)]\n\nfor i in range(N):\n\n    Current_List=list(map(int,input().split())) \n\n    if i == 0:\n\n        Max_List.append(Current_List)\n\n    else:\n\n        Current_Max_List = []\n\n        for j in range(3):\n\n            Index_List=np.array(Max_List[i-1])\n\n            ind = np.ones(3, dtype=bool)\n\n            ind[j] = False\n\n            Current_Max_List.append(max(Index_List[ind])+Current_List[j])\n\n            \n\n        Max_List.append(Current_Max_List)\n\n        \n\n    \n\nprint((max(Max_List[-1])))", "generated_code": "# https://atcoder.jp/contests/dp/tasks/dp_c\n\nN = int(eval(input()))\n\nMax_List=[]\n\nN_List=[i for i in range(3)]\n\nfor i in range(N):\n\n    Current_List=list(map(int,input().split())) \n\n    if i == 0:\n\n        Max_List.append(Current_List)\n\n    else:\n\n        Current_Max_List = []\n\n        Search_List=Max_List[i-1]\n\n        for j in range(3):\n\n            Current_Search_List=Search_List[1:3]\n\n            Current_Max_List.append(max(Current_Search_List)+Current_List[j])\n\n            Search_List.append(Search_List[0])\n\n            del Search_List[0]\n\n        Max_List.append(Current_Max_List)\n\n        \n\n    \n\nprint((max(Max_List[-1])))", "score": 1.0, "surface_similarity": 0.7794133593580568}
{"id": "p03835_u714300041", "golden_code": "import sys\n\ninput = sys.stdin.readline\n\nsys.setrecursionlimit(10 ** 7)\n\n\n\nK, S = list(map(int, input().split()))\n\n\n\nans = 0\n\nfor z in range(K+1):\n\n    for y in range(K+1):\n\n        x = S - (z + y)\n\n        if x >= 0 and x <= K:\n\n            ans += 1\n\nprint(ans)", "generated_code": "import sys\n\ninput = sys.stdin.readline\n\nsys.setrecursionlimit(10 ** 7)\n\n\n\nK, S = list(map(int, input().split()))\n\n\n\nans = 0\n\nfor z in range(K+1):\n\n    for y in range(K+1):\n\n        x = S - (z + y)\n\n        if 0 <= x <= K:\n\n            ans += 1\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.9260057471264368}
{"id": "p02996_u994988729", "golden_code": "n=int(eval(input()))\n\ntask=[] \n\nfor _ in range(n):\n\n    a,b=list(map(int,input().split()))\n\n    task.append((b, -a))\n\n\n\ntask.sort()\n\n\n\ntime=0\n\nflag=True\n\nfor i in task:\n\n    time-=i[1]\n\n    if time>i[0]:\n\n        flag=False\n\n        break\n\n\n\nif flag:\n\n    print(\"Yes\")\n\nelse:\n\n    print(\"No\")\n\n\n", "generated_code": "import sys\n\nfrom collections import defaultdict\n\nfrom operator import itemgetter\n\ninput = sys.stdin.readline\n\n\n\nN = int(eval(input()))\n\nd = defaultdict(int)\n\nfor _ in range(N):\n\n    a, b = list(map(int, input().split()))\n\n    d[b] += a\n\ntask = list(d.items())\n\ntask.sort()\n\n\n\nnow = 0\n\nans = \"Yes\"\n\nfor limit, time in task:\n\n    now += time\n\n    if now > limit:\n\n        ans = \"No\"\n\n        break\n\n\n\nprint(ans)\n", "score": 1.0, "surface_similarity": 0.5888367729831144}
{"id": "p02767_u883040023", "golden_code": "import numpy as np\n\n\n\nn = int(eval(input()))\n\nx = list(map(int,input().split()))\n\nx2 = np.power(x,2)\n\n\n\np1 = sum(x)//n\n\np2 = -(-sum(x)//n)\n\n\n\nw1 = n*(p1**2) -2*sum(x)*p1 +sum(x2)\n\nw2 = n*(p2**2) -2*sum(x)*p2 +sum(x2)\n\n\n\nprint((min(w1,w2)))", "generated_code": "n = int(eval(input()))\n\nX = sorted(map(int,input().split()))\n\nans = 10**6\n\n\n\nfor i in range(X[0],X[-1]+1):\n\n    HP = 0\n\n    \n\n    for j in X:\n\n        HP += (j - i) ** 2\n\n        \n\n    ans = min(ans,HP)\n\n    \n\nprint(ans)", "score": 1.0, "surface_similarity": 0.5541204293250864}
{"id": "p03038_u645250356", "golden_code": "from collections import Counter,defaultdict,deque\n\nfrom heapq import heapify,heappop,heappush\n\nfrom bisect import bisect_left,bisect_right\n\nimport sys,math,itertools,string,queue\n\nsys.setrecursionlimit(10**8)\n\nmod = 10**9+7\n\ndef inp(): return int(sys.stdin.readline())\n\ndef inpl(): return list(map(int, sys.stdin.readline().split()))\n\ndef inpl_str(): return list(sys.stdin.readline().split())\n\ndef inpln(n): return list(int(sys.stdin.readline()) for i in range(n))\n\n\n\nn,m = inpl()\n\na = inpl()\n\nb = [0] * m\n\nfor i in range(m):\n\n    x,y = inpl()\n\n    b[i] = [x,y]\n\na.sort()\n\nb.sort(key=lambda x:x[1], reverse = True)\n\nres = sum(a)\n\ni = 0\n\nj = 0\n\nwhile True:\n\n    # print(i,j)\n\n    if a[i] < b[j][1]:\n\n        res += b[j][1] - a[i]\n\n        i += 1\n\n    else:\n\n        break\n\n    b[j][0] -= 1\n\n    if b[j][0] == 0:\n\n        j += 1\n\n    if i >= n or j >= m:\n\n        break\n\nprint(res)\n", "generated_code": "from collections import Counter,defaultdict,deque\n\nfrom heapq import heappop,heappush,heapify\n\nfrom bisect import bisect_left,bisect_right \n\nimport sys,math,itertools,fractions,pprint\n\nsys.setrecursionlimit(10**8)\n\nmod = 10**9+7\n\nINF = float('inf')\n\ndef inp(): return int(sys.stdin.readline())\n\ndef inpl(): return list(map(int, sys.stdin.readline().split()))\n\n\n\nn,m = inpl()\n\na = inpl()\n\na.sort()\n\nbc = [inpl() for _ in range(m)]\n\nbc.sort(key = lambda x:x[1], reverse = True)\n\nlm = sum(x[1] for x in bc)\n\nnow = 0\n\nalt = 0\n\nwhile now < n and alt < m:\n\n    c,b = bc[alt]\n\n    if a[now] > b:\n\n        break\n\n    else:\n\n        a[now] = b\n\n    bc[alt][0] -= 1\n\n    if bc[alt][0] == 0:\n\n        alt += 1\n\n    now += 1\n\nprint((sum(a)))\n", "score": 1.0, "surface_similarity": 0.7410676532769556}
{"id": "p02891_u287132915", "golden_code": "s = eval(input())\n\nk = int(eval(input()))\n\n\n\nif len(set(s)) == 1:\n\n    print(((len(s)*k)//2))\n\n    exit()\n\n\n\nss = s + s\n\n\n\nshoko = 0\n\nprev = ''\n\ncnt = 0\n\nfor i in range(len(s)):\n\n    if s[i] == prev:\n\n        cnt += 1\n\n    else:\n\n        shoko += cnt // 2\n\n        cnt = 1\n\n    prev = s[i]\n\nshoko += cnt // 2\n\n\n\nkosa = 0\n\nprev = ''\n\ncnt = 0\n\nfor i in range(len(ss)):\n\n    if ss[i] == prev:\n\n        cnt += 1\n\n    else:\n\n        kosa += cnt // 2\n\n        cnt = 1\n\n    prev = ss[i]\n\nkosa += cnt // 2\n\nkosa -= shoko\n\n\n\nprint((shoko + (k-1)*kosa))", "generated_code": "s = eval(input())\n\nk = int(eval(input()))\n\nn = len(s)\n\n\n\nif len(set(s)) == 1:\n\n    print((n*k//2))\n\n    exit()\n\n\n\nss = s + s\n\ncnts = 0\n\nnow = s[0]\n\ntemp = 1\n\nfor i in range(1, n):\n\n    if s[i] == now:\n\n        temp += 1\n\n    else:\n\n        cnts += temp // 2\n\n        temp = 1\n\n        now = s[i]\n\ncnts += temp // 2\n\n\n\ncntss = 0\n\nnow = ss[0]\n\ntemp = 1\n\nfor i in range(1, 2*n):\n\n    if ss[i] == now:\n\n        temp += 1\n\n    else:\n\n        cntss += temp // 2\n\n        temp = 1\n\n        now = ss[i]\n\ncntss += temp // 2\n\n\n\nkousa = cntss - cnts\n\nprint((cnts + kousa*(k-1)))", "score": 1.0, "surface_similarity": 0.86331569664903}
{"id": "p03081_u367130284", "golden_code": "n,q=list(map(int,input().split()));s=\"_\"+eval(input())+\"_\";l,r=0,n+1\n\nfor(m,h)in[input().split()for i in range(q)][::-1]:L=h==\"L\";R=h==\"R\";l,r=[l,l-1,l+1][(m==s[l]and R)-(m==s[l+1]and L)],[r,r-1,r+1][(m==s[r-1]and R)-(m==s[r]and L)]\n\nprint((max(0,r-l-1)))", "generated_code": "n,q=list(map(int,input().split()));s=\"_\"+eval(input())+\"_\";l,r=0,n+1\n\nfor(m,h)in[input().split()for i in range(q)][::-1]:\n\n    L=h==\"L\";R=h==\"R\";\n\n    l+=(m==s[l+1]and L)-(m==s[l]and R)\n\n    r+=(m==s[r]and L)-(m==s[r-1]and R)\n\nprint((max(0,r-l-1)))", "score": 1.0, "surface_similarity": 0.8845315904139434}
{"id": "p03325_u884982181", "golden_code": "import numpy as np\n\nN = int(eval(input()))\n\na = list(map(int,input().split()))\n\nans = 0\n\na = np.array(a)\n\nwhile a.size > 0:\n\n    a = a[a%2 == 0]\n\n    ans += len(a)\n\n    a = a//2\n\nprint(ans)", "generated_code": "n = int(eval(input()))\n\na = list(map(int,input().split()))\n\nans = 0\n\nfor i in range(n):\n\n    while a[i]%2 == 0:\n\n        a[i] //=2\n\n        ans+=1\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.7648953301127215}
{"id": "p03013_u377989038", "golden_code": "import numpy as np\n\n\n\nn, m = list(map(int, input().split()))\n\na = [int(eval(input())) for _ in range(m)] + [0]\n\nmod = 10 ** 9 + 7\n\n\n\ndp = np.zeros(n + 1, dtype=np.int64)\n\ndp[0] = 1\n\nb = a[0]\n\nj = 1\n\nfor i in range(1, n + 1):\n\n    if i == b:\n\n        b = a[j]\n\n        j += 1\n\n    else:\n\n        tmp = dp[i - 2] + dp[i - 1]\n\n        if tmp >= mod:\n\n            tmp -= mod\n\n        dp[i] = tmp\n\nprint((int(dp[-1])))", "generated_code": "n, m = list(map(int, input().split()))\n\na = [int(eval(input())) for _ in range(m)] + [0]\n\nmod = 10 ** 9 + 7\n\n\n\ndp = [0] * (n + 1)\n\ndp[0] = 1\n\nb = a[0]\n\nj = 1\n\nfor i in range(1, n + 1):\n\n    if i == b:\n\n        b = a[j]\n\n        j += 1\n\n    else:\n\n        tmp = dp[i - 2] + dp[i - 1]\n\n        if tmp >= mod:\n\n            tmp -= mod\n\n        dp[i] = tmp\n\nprint((int(dp[-1])))", "score": 1.0, "surface_similarity": 0.8882683745997032}
{"id": "p03013_u093739220", "golden_code": "N, M = list(map(int, input().split(\" \")))\n\nA = {int(eval(input())) for _ in range(M)}\n\n\n\nmemo = [0] * (N + 1)\n\nmemo[0] = 1\n\nmemo[1] = 0 if 1 in A else 1\n\n\n\nif N == 1:\n\n    print((memo[1]))\n\nelse:\n\n    for i in range(2, N + 1):\n\n        if i in A:\n\n            continue\n\n        memo[i] = (memo[i - 2] + memo[i - 1]) % 1000000007\n\n\n\n    print((memo[N]))\n", "generated_code": "N, M = list(map(int, input().split(\" \")))\n\nA = {int(input()) for _ in range(M)}\n\n\n\nmemo = [0] * (N + 1)\n\nmemo[0] = 1\n\nmemo[1] = 0 if 1 in A else 1\n\n\n\nif N == 1:\n\n    print((memo[1]))\n\nelse:\n\n    for i in range(2, N + 1):\n\n        if i in A:\n\n            continue\n\n        memo[i] = (memo[i - 2] + memo[i - 1]) % 1000000007\n\n    print((memo[N]))\n", "score": 1.0, "surface_similarity": 0.9915014164305949}
{"id": "p03796_u134019875", "golden_code": "import math\n\n\n\nn = int(eval(input()))\n\nprint((math.factorial(n) % (10 ** 9 + 7)))", "generated_code": "n = int(eval(input()))\n\np = 1\n\nfor i in range(1, n + 1):\n\n  p = p * i % (10 ** 9 + 7)\n\nprint(p)", "score": 1.0, "surface_similarity": 0.6160990712074303}
{"id": "p02883_u852690916", "golden_code": "N, K = list(map(int, input().split()))\n\nA = list(map(int, input().split()))\n\nF = list(map(int, input().split()))\n\n\n\nA.sort()\n\nF.sort(reverse=True)\n\n\n\n#積をx以下にするために必要な修行回数\n\ndef f(x):\n\n    r = 0\n\n    for i in range(N):\n\n        a, f = A[i], F[i]\n\n        m = a * f\n\n        if m > x:\n\n            r += (m - x + f - 1) // f\n\n    return r\n\n\n\nunder = -1\n\nr = 10**18\n\nwhile r - under > 1:\n\n    m = (under + r) // 2\n\n    if f(m) > K: under = m\n\n    else: r = m\n\nprint(r)", "generated_code": "# でつoO(YOU PLAY WITH THE CARDS YOU'RE DEALT..)\n\nimport sys\n\ndef main(N, K, A, F):\n\n    A.sort()\n\n    F.sort(reverse=True)\n\n\n\n    def f(x):\n\n        sy = 0\n\n        for a, f in zip(A, F):\n\n            m = a * f\n\n            if m > x:\n\n                sy += (m - x + f - 1) // f\n\n        return sy\n\n\n\n    under = -1\n\n    hi = 10**12 + 1\n\n    while hi - under > 1:\n\n        m = (hi + under) // 2\n\n        if f(m) <= K: hi = m\n\n        else: under = m\n\n    print(hi)\n\n\n\nif __name__ == '__main__':\n\n    input = sys.stdin.readline\n\n    N, K = list(map(int, input().split()))\n\n    *A, = list(map(int, input().split()))\n\n    *F, = list(map(int, input().split()))\n\n    main(N, K, A, F)\n", "score": 1.0, "surface_similarity": 0.6782578368619727}
{"id": "p03035_u597374218", "golden_code": "a,b=list(map(int,input().split()))\n\nprint((b if 13<=a else b//2 if 6<=a else 0))", "generated_code": "a,b=list(map(int,input().split()))\n\nprint((b if 12<a else b//2 if 5<a else 0))", "score": 1.0, "surface_similarity": 0.9125}
{"id": "p02688_u708556844", "golden_code": "N,K=list(map(int,input().split()))\n\n\n\ncon = 0\n\nans = list(int() for _ in range(100000))\n\npre = 0\n\n\n\n\n\nfor _ in range(K):\n\n\n\n    D = int(eval(input()))\n\n    arr = list(map(int,input().split()))\n\n\n\n    for j in range(D):\n\n\n\n        ans[pre+j]=arr[j]\n\n\n\n    pre += D\n\n\n\n        \n\nfin = (N+1) - len(set(ans))\n\n\n\nprint(fin)", "generated_code": "N,K=list(map(int,input().split()))\n\n\n\ncon = 0\n\nans = list(int() for _ in range(10001))\n\npre = 0\n\n\n\n\n\nfor _ in range(K):\n\n\n\n    D = int(eval(input()))\n\n    arr = list(map(int,input().split()))\n\n\n\n    for j in range(D):\n\n\n\n        ans[pre+j]=arr[j]\n\n\n\n    pre += D\n\n\n\n        \n\nfin = (N+1) - len(set(ans))\n\n\n\nprint(fin)", "score": 1.0, "surface_similarity": 0.9968553459119497}
{"id": "p03162_u186206732", "golden_code": "def main():\n\n  n = int(eval(input()))\n\n  a = [0]\n\n  b = [0]\n\n  c = [0]\n\n\n\n  for i in range(n):\n\n      aa,bb,cc = list(map(int,input().split()))\n\n      a.append(max(b[i] + aa, c[i] + aa))\n\n      b.append(max(a[i] + bb, c[i] + bb))\n\n      c.append(max(a[i] + cc, b[i] + cc))\n\n\n\n  print((max(a[-1], b[-1], c[-1])))\n\n\n\nmain()", "generated_code": "def main():\n\n    n = int(eval(input()))\n\n    a = 0\n\n    b = 0\n\n    c = 0\n\n\n\n    for i in range(n):\n\n        aa,bb,cc = list(map(int,input().split()))\n\n        a,b,c = max(b,c)+aa, max(a,c)+bb, max(a,b)+cc\n\n\n\n    print((max(a,b,c)))\n\n\n\nmain()\n", "score": 1.0, "surface_similarity": 0.7519470404984423}
{"id": "p03078_u863442865", "golden_code": "def main():\n\n    import sys\n\n    input = sys.stdin.readline\n\n    sys.setrecursionlimit(10**7)\n\n    from collections import Counter, deque\n\n    #from collections import defaultdict\n\n    from itertools import combinations, permutations, accumulate, groupby\n\n    #from itertools import product\n\n    from bisect import bisect_left,bisect_right\n\n    import heapq\n\n    from math import floor, ceil\n\n    #from operator import itemgetter\n\n\n\n    #inf = 10**17\n\n    #mod = 10**9 + 7\n\n\n\n    x,y,z,k = list(map(int, input().split()))\n\n    a = list(map(int, input().split()))\n\n    b = list(map(int, input().split()))\n\n    c = list(map(int, input().split()))\n\n    ab = []\n\n    for i in a:\n\n        for j in b:\n\n            ab.append(i+j)\n\n    ab.sort(reverse=1)\n\n    ab = ab[:k]\n\n    abc = []\n\n    for i in ab:\n\n        for j in c:\n\n            abc.append(i+j)\n\n    abc.sort(reverse=1)\n\n    for i in range(k):\n\n        print((abc[i]))\n\n\n\nif __name__ == '__main__':\n\n    main()", "generated_code": "#xyzの全通り調べると間に合わない\n\n#まず問題を分けよう\n\n#先にxyだけ考えてみる\n\n#xyの和をとってからそれとzの和をとるとき\n\n#xyの和においてk番目以降の値を使うことは無い\n\n#\n\n\n\ndef main():\n\n    import sys\n\n    input = sys.stdin.readline\n\n    sys.setrecursionlimit(10**7)\n\n    from collections import Counter, deque\n\n    #from collections import defaultdict\n\n    from itertools import combinations, permutations, accumulate, groupby\n\n    #from itertools import product\n\n    from bisect import bisect_left,bisect_right\n\n    import heapq\n\n    from math import floor, ceil\n\n    #from operator import itemgetter\n\n\n\n    #inf = 10**17\n\n    #mod = 10**9 + 7\n\n\n\n    x,y,z,k = list(map(int, input().split()))\n\n    a = list(map(int, input().split()))\n\n    b = list(map(int, input().split()))\n\n    c = list(map(int, input().split()))\n\n    a.sort(reverse=1)\n\n    b.sort(reverse=1)\n\n    c.sort(reverse=1)\n\n    abc = []\n\n    for i in range(x):\n\n        for j in range(y):\n\n            if i*j>k:\n\n                continue\n\n            for t in range(z):\n\n                if i*j*t>k:\n\n                    continue\n\n                abc.append(a[i]+b[j]+c[t])\n\n    abc.sort(reverse=1)\n\n    for i in range(k):\n\n        print((abc[i]))\n\n\n\nif __name__ == '__main__':\n\n    main()", "score": 1.0, "surface_similarity": 0.8833333333333333}
{"id": "p02414_u150984829", "golden_code": "import sys\n\ne=[list(map(int,e.split()))for e in sys.stdin]\n\nn=e[0][0]+1\n\nfor c in e[1:n]:\n\n t=''\n\n for l in zip(*e[n:]):t+=f'{sum(s*t for s,t in zip(c,l))} '\n\n print((t[:-1]))\n", "generated_code": "import sys\n\ne=[list(map(int,e.split()))for e in sys.stdin]\n\nn=e[0][0]+1\n\nt=''\n\nfor c in e[1:n]:\n\n for l in zip(*e[n:]):t+=f'{sum(s*t for s,t in zip(c,l))} '\n\n t=t[:-1]+'\\n'\n\nprint((t[:-1]))\n", "score": 1.0, "surface_similarity": 0.9368421052631579}
{"id": "p02814_u057109575", "golden_code": "from functools import reduce\n\nfrom fractions import gcd\n\n\n\nN, M, *A = list(map(int, open(0).read().split()))\n\n\n\ndef lcm(x, y):\n\n    return x * y // gcd(x, y)\n\n\n\ndef sub_by_2(n):\n\n    cnt = 0\n\n    while n % 2 == 0:\n\n        n //= 2\n\n        cnt += 1\n\n    return cnt\n\n\n\nlcm_2 = [sub_by_2(n // 2) for n in A]\n\nif all(lcm_2[0] == v for v in lcm_2):\n\n    num = reduce(lcm, [v // 2 for v in A])\n\n    res = M // num\n\n    print((res // 2 + res % 2))\n\nelse:\n\n    print((0))\n", "generated_code": "from math import gcd\n\nfrom functools import reduce\n\n\n\nN, M, *A = list(map(int, open(0).read().split()))\n\n\n\ndef lcm(x, y):\n\n    return x * y // gcd(x, y)\n\n\n\ndef lcm_list(numbers):\n\n    return reduce(lcm, numbers, 1)\n\n\n\ndef even_count(n):\n\n    res = 0\n\n    while n % 2 == 0:\n\n        res += 1\n\n        n //= 2\n\n    return res\n\n\n\n\n\nx = [v // 2 for v in A]\n\nif all(even_count(v) == even_count(x[0]) for v in x):\n\n    num = lcm_list(x)\n\n    print((-(-(M // num) // 2)))\n\nelse:\n\n    print((0))\n\n\n", "score": 1.0, "surface_similarity": 0.7899759903961585}
{"id": "p02886_u576917603", "golden_code": "n=int(eval(input()))\n\na=list(map(int,input().split()))\n\nimport itertools as it\n\nimport numpy as np\n\nal=list(it.combinations(a,2))\n\ntotal=0\n\nfor i in al:\n\n    total+=np.prod(i)\n\nprint(total)", "generated_code": "n=int(eval(input()))\n\na=list(map(int,input().split()))\n\nans=0\n\nfor i in range(n-1):\n\n    for j in range(i+1,n):\n\n        ans+=a[i]*a[j]\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.5776942355889725}
{"id": "p02552_u453634104", "golden_code": "x = int(eval(input()))\n\nif x == 0:\n\n  print((1))\n\nelse:\n\n  print((0))", "generated_code": "x = int(eval(input()))\n\nprint((x^1))\n", "score": 1.0, "surface_similarity": 0.6192865105908585}
{"id": "p03325_u102461423", "golden_code": "import numpy as np\n\n\n\nN = int(eval(input()))\n\nA = np.array(input().split(),dtype=np.int32)\n\n\n\ndef ord(n):\n\n  cnt = 0\n\n  while not n&1:\n\n    n >>= 1\n\n    cnt += 1\n\n  return cnt\n\n\n\nnp_ord = np.frompyfunc(ord,1,1)\n\nanswer = np_ord(A).sum()\n\nprint(answer)", "generated_code": "import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\nimport numpy as np\n\n\n\nN = int(readline())\n\nA = np.array(read().split(),np.int32)\n\n\n\nanswer = 0\n\nfor _ in range(32):\n\n    A = A[A%2 == 0]\n\n    answer += len(A)\n\n    A >>= 1\n\n\n\nprint(answer)", "score": 1.0, "surface_similarity": 0.45}
{"id": "p02994_u043236471", "golden_code": "import numpy as np\n\n\n\nn,l = [int(x) for x in input().split()] \n\nx = np.arange(l,l+n)\n\ny = np.abs(x)\n\nx = np.delete(x, np.argmin(y))\n\nprint((np.sum(x)))", "generated_code": "N, L = list(map(int, input().split()))\n\napples = [i for i in range(L, L+N)]\n\napples_abs = [abs(i) for i in apples]\n\nmin_idx = apples_abs.index(min(apples_abs))\n\n\n\nprint((sum(apples) - apples[min_idx]))", "score": 1.0, "surface_similarity": 0.5451907131011609}
{"id": "p02792_u079022693", "golden_code": "N=int(eval(input()))\n\nC=[[0]*9  for i in range(9)]\n\ncount=0\n\n\n\nfor n in range(1,N+1):\n\n   if str(n)[-1]!=\"0\":\n\n      left=int(str(n)[0])-1\n\n      right=int(str(n)[-1])-1\n\n      C[left][right]+=1\n\n      \n\nfor i in range(1,10):\n\n   for j in range(1,10):\n\n      count+=C[i-1][j-1]*C[j-1][i-1]\n\n\n\nprint(count)", "generated_code": "from sys import stdin\n\ndef main():\n\n    #入力\n\n    readline=stdin.readline\n\n    N=int(readline())\n\n    d=dict()\n\n    for i in range(1,N+1):\n\n        i=str(i)\n\n        head=i[0]\n\n        tail=i[-1]\n\n        if tail==\"0\":\n\n            continue\n\n        if (head,tail) not in d:\n\n            d[(head,tail)]=1\n\n        else:\n\n            d[(head,tail)]+=1\n\n\n\n    ans=0\n\n    s=set()\n\n    for k in list(d.keys()):\n\n        m,l=k[0],k[1]\n\n        if (m,l) in s:\n\n            continue\n\n        if (l,m) in d:\n\n            ans+=d[(m,l)]*d[(l,m)]\n\n            if (m,l)!=(l,m):\n\n                ans+=d[(m,l)]*d[(l,m)]\n\n        s.add((m,l))\n\n        s.add((l,m))\n\n\n\n    print(ans)\n\n\n\nif __name__==\"__main__\":\n\n    main()", "score": 1.0, "surface_similarity": 0.5653641059823362}
{"id": "p03696_u867069435", "golden_code": "import numpy as np\n\nn = int(eval(input()))\n\ns = list(eval(input()))\n\nj = []\n\nnow = 0\n\nunclosen = 0\n\nopened = 0\n\nfor i in s:\n\n    if i == \")\":\n\n        now -= 1\n\n        if opened:\n\n            opened -= 1\n\n        else:\n\n            unclosen += 1\n\n    else:\n\n        now += 1\n\n        opened += 1\n\nj = np.array(j)\n\nprint((\"(\" * unclosen + \"\".join(s) + \")\" * opened))", "generated_code": "n = int(eval(input()))\n\ns = list(eval(input()))\n\nnow = 0\n\nunclosen = 0\n\nopened = 0\n\nfor i in s:\n\n    if i == \")\":\n\n        now -= 1\n\n        if opened:\n\n            opened -= 1\n\n        else:\n\n            unclosen += 1\n\n    else:\n\n        now += 1\n\n        opened += 1\n\nprint((\"(\" * unclosen + \"\".join(s) + \")\" * opened))", "score": 1.0, "surface_similarity": 0.8807572209211554}
{"id": "p03254_u860002137", "golden_code": "import numpy as np\n\nN, x = list(map(int, input().split()))\n\na = np.array(list(map(int, input().split())))\n\n\n\ncs = np.sort(a).cumsum()\n\n\n\nif cs[-1]<x:\n\n    print((N-1))\n\nelif cs[-1]==x:\n\n    print(N)\n\nelse:\n\n    print((np.where(cs<=x)[0].shape[0]))", "generated_code": "from bisect import bisect_right\n\nfrom itertools import accumulate\n\n\n\nn, x = list(map(int, input().split()))\n\narr = list(map(int, input().split()))\n\n\n\narr.sort()\n\narr = list(accumulate(arr))\n\n\n\n\n\nhappy = bisect_right(arr, x)\n\n\n\nif happy == n:\n\n    if arr[-1] != x:\n\n        happy -= 1\n\n\n\nprint(happy)", "score": 1.0, "surface_similarity": 0.6011705685618729}
{"id": "p02959_u353919145", "golden_code": "from sys import stdin,stdout\n\n\n\nif __name__==\"__main__\":\n\n    n=int(stdin.readline())\n\n\n\n    a=[int(x) for x in stdin.readline().split()]\n\n    b=[int(x) for x in stdin.readline().split()]\n\n\n\n    cnt=0\n\n\n\n    for i in range(n):\n\n        if(a[i]>=b[i]):\n\n            cnt+=b[i]\n\n        else:\n\n            cnt+=a[i]\n\n            d=b[i]-a[i]\n\n            cnt+=min(a[i+1],d)\n\n            if(d>a[i+1]):\n\n                a[i+1]=0\n\n            else: a[i+1]-=d\n\n            \n\n    stdout.write(str(cnt)+\"\\n\")\n", "generated_code": "n = int(eval(input()))\n\nA = list(map(int, input().split()))\n\nB = list(map(int, input().split()))\n\na1 = sum(A)\n\nfor i in range(n):\n\n  b = B[i]\n\n  if A[i] >= b:A[i] -= b\n\n  else:\n\n    if A[i+1]+A[i] >= b:\n\n      A[i+1] = A[i+1]+A[i]-b\n\n      A[i] = 0\n\n    else:A[i], A[i+1] = 0, 0\n\na2 = sum(A)\n\nprint((a1-a2))", "score": 1.0, "surface_similarity": 0.6559657777092647}
{"id": "p03608_u127499732", "golden_code": "def main():\n\n    from itertools import permutations\n\n\n\n    n, m, r, *x = list(map(int, open(0).read().split()))\n\n    to = x[:r]\n\n\n\n    dis = [[float(\"Inf\")] * (n + 1) for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n\n        dis[i][i] = 0\n\n\n\n    for a, b, c in zip(*[iter(x[r:])] * 3):\n\n        dis[a][b] = c\n\n        dis[b][a] = c\n\n\n\n    for k in range(1, n + 1):\n\n        for i in range(1, n + 1):\n\n            for j in range(1, n + 1):\n\n                dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])\n\n\n\n    ans = float(\"Inf\")\n\n    for p in permutations(to):\n\n        tmp = 0\n\n        nw = p[0]\n\n        for nx in p[1:]:\n\n            tmp += dis[nw][nx]\n\n            nw = nx\n\n\n\n        ans = min(ans, tmp)\n\n\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "generated_code": "def main():\n\n    from itertools import permutations\n\n\n\n    n, m, r, *x = list(map(int, open(0).read().split()))\n\n    to = x[:r]\n\n\n\n    dis = [[10 ** 8] * (n + 1) for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n\n        dis[i][i] = 0\n\n\n\n    for a, b, c in zip(*[iter(x[r:])] * 3):\n\n        dis[a][b] = c\n\n        dis[b][a] = c\n\n\n\n    for k in range(1, n + 1):\n\n        for i in range(1, n + 1):\n\n            for j in range(1, n + 1):\n\n                dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])\n\n\n\n    ans = 10 ** 8\n\n    for p in permutations(to):\n\n        tmp = 0\n\n        nw = p[0]\n\n        for nx in p[1:]:\n\n            tmp += dis[nw][nx]\n\n            nw = nx\n\n\n\n        ans = min(ans, tmp)\n\n\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 1.0, "surface_similarity": 0.9678893178893179}
{"id": "p03416_u732159958", "golden_code": "counter = 0\n\nc = list(map(int, input().split(' ')))\n\nfor i in range(c[0], c[1] + 1):\n\n  if str(i)[0] != str(i)[4]:\n\n    continue\n\n  if str(i)[1] != str(i)[3]:\n\n    continue\n\n  counter += 1\n\n\n\nprint(counter)", "generated_code": "a = list(map(int, input().split()))\n\ncounter = 0\n\nfor i in range(a[0], a[1] + 1):\n\n  stri = str(i)\n\n  if (stri[0] == stri[4] and stri[1] == stri[3]):\n\n    counter += 1\n\n    \n\nprint(counter)", "score": 1.0, "surface_similarity": 0.7285966460723742}
{"id": "p03038_u089230684", "golden_code": "I=lambda:list(map(int,input().split()))\n\nn,m=I()\n\na=I()\n\na.sort(reverse=True)\n\nqq=[I() for i in range(m)]\n\nqq.sort(key=lambda x:x[1],reverse=True)\n\nans=0\n\nfor x,y in qq:\n\n    for j in range(x):\n\n        if not a:\n\n            break\n\n        aa=a.pop()\n\n        ans+=max(aa,y)\n\nans+=sum(a)\n\nprint(ans)\n\n        ", "generated_code": "I=lambda : list(map(int,input().split()))\n\nn,m = I()\n\nl=I();s=sum(l);l.sort();d=[]\n\nfor _ in range(m):\n\n    b,c=I()\n\n    d.append([c,b])\n\np=s=0    \n\nfor i in sorted(d,reverse=True):\n\n    while i[1]:\n\n        if p>=n or l[p]>=i[0]:\n\n            break\n\n        i[1]-=1\n\n        s+=i[0]\n\n        p+=1\n\n    if p>=n:\n\n        break\n\ns+=sum(l[p:])\n\nprint(s)", "score": 1.0, "surface_similarity": 0.6064491064491064}
{"id": "p02780_u127499732", "golden_code": "import numpy as np\n\nn,k=list(map(int,input().split()))\n\nexp=tuple([(int(x)+1)/2 for x in input().split()])\n\nl=np.cumsum(exp)\n\n\n\nans=l[k-1]\n\nfor i in range(0,n-k):\n\n  x=l[i+k]-l[i]\n\n  ans=max(ans,x)\n\nprint(ans)", "generated_code": "def main():\n\n    from itertools import accumulate\n\n    n, k = list(map(int, input().split()))\n\n    *exp, = [(int(x) + 1) / 2 for x in input().split()]\n\n    l = accumulate(exp)\n\n    l = list(l)\n\n    ans = l[k - 1]\n\n    for i in range(0, n - k):\n\n        x = l[i + k] - l[i]\n\n        ans = max(ans, x)\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 1.0, "surface_similarity": 0.7321428571428572}
{"id": "p03494_u202406075", "golden_code": "import numpy as np\n\nimport sys\n\n\n\nn = int(eval(input()))\n\na = np.array(list(map(int, input().split())))\n\n\n\ncnt = 1\n\n\n\nif np.any(a%2==1):\n\n    print((0))\n\n    sys.exit()\n\n\n\nwhile True:\n\n    a2 = a % 2**cnt\n\n    if np.all(a2==0):\n\n        cnt += 1\n\n        continue\n\n    else:\n\n        print((cnt-1))\n\n        break", "generated_code": "N = int(eval(input()))\n\na = list(map(int,input().split()))\n\nans = 0\n\nwhile all(A%2 == 0 for A in a):\n\n\ta = [i/2 for i in a ]\n\n\tans += 1\n\nprint(ans)\n", "score": 1.0, "surface_similarity": 0.5854336764879896}
{"id": "p03723_u062691227", "golden_code": "a,b,c=list(map(int,input().split()))\n\ne=(a-b)|(b-c)\n\nprint((bool(e|(a|b|c)%2)*(e^~-e).bit_length()-1))", "generated_code": "a,b,c=list(map(int,input().split()))\n\ne=(a-b)|(b-c)\n\nprint((bool(e|b%2)*(e^~-e).bit_length()-1))", "score": 1.0, "surface_similarity": 0.9705882352941176}
{"id": "p02970_u531220228", "golden_code": "import numpy as np\n\nN, D = list(map(int, input().split()))\n\nprint((int(np.ceil(N/(2*D+1)))))", "generated_code": "N, D = list(map(int, input().split()))\n\nimport math\n\nprint((math.ceil(N/(2*D+1))))", "score": 1.0, "surface_similarity": 0.8260869565217391}
{"id": "p03037_u298297089", "golden_code": "N, M =list(map(int, input().split()))\n\nL = [0 for i in range(N+1)]\n\nR = [0 for i in range(N+1)]\n\nfor i in range(M):\n\n    l,r = list(map(int, input().split()))\n\n    L[l] += 1\n\n    R[r] += 1\n\ncnt = 0\n\ntmp = 0\n\nfor i in range(N+1):\n\n    tmp += L[i]\n\n    if tmp == M:\n\n        cnt += 1\n\n    tmp -= R[i]\n\nprint(cnt)\n", "generated_code": "n,m = list(map(int, input().split()))\n\nll = 1\n\nrr = n\n\nfor i in range(m):\n\n    l,r = list(map(int,input().split()))\n\n    if l > ll:\n\n        ll = l\n\n    if r < rr:\n\n        rr = r\n\nprint((max(rr - ll + 1, 0)))\n", "score": 1.0, "surface_similarity": 0.6436227224008575}
{"id": "p03457_u652057333", "golden_code": "import numpy as np\n\n\n\nn = int(eval(input()))\n\ninput_X = [[int(i) for i in input().split()] for i in range(n)]\n\nX = np.array(input_X)\n\n\n\npre_t = 0\n\npre_x = 0\n\npre_y = 0\n\nfor i in range(n):\n\n    x_move = abs(X[i][1] - pre_x)\n\n    y_move = abs(X[i][2] - pre_y)\n\n    xy_sum = x_move + y_move\n\n    spend_time = X[i][0]-pre_t\n\n    if xy_sum%2 == spend_time%2 and spend_time >= xy_sum:\n\n        pre_t = X[i][0]\n\n        pre_x = X[i][1]\n\n        pre_y = X[i][2]\n\n        if i+1 == n:\n\n            print('Yes')\n\n        else:\n\n            continue\n\n    else:\n\n        print('No')\n\n        break", "generated_code": "# C\n\nimport copy\n\nn = int(eval(input()))\n\npreX = [0,0,0]\n\nans = True\n\nfor i in range(n):\n\n    curX = list(map(int, input().split()))\n\n    dt = curX[0] - preX[0]\n\n    dx = abs(curX[1] - preX[1])\n\n    dy = abs(curX[2] - preX[2])\n\n    if dt < dx + dy  or (dt % 2) != ((dx + dy) % 2):\n\n        ans = False\n\n    preX = copy.copy(curX)\n\nif ans:\n\n    print('Yes')\n\nelse:\n\n    print('No')", "score": 1.0, "surface_similarity": 0.6084668803418803}
{"id": "p03558_u075012704", "golden_code": "from collections import deque\n\nK = int(eval(input()))\n\nG = [[] for i in range(K)]\n\n\n\nfor n in range(K):\n\n    G[n].append([(n + 1) % K, 1])\n\n    G[n].append([(10 * n) % K, 0])\n\n\n\nque = deque([[1, 1]])\n\ndist = [float('inf')] * K\n\n\n\nwhile que:\n\n    node, cost = que.pop()\n\n    dist[node] = min(cost, dist[node])\n\n    for e, e_cost in G[node]:\n\n        if dist[e] != float('inf'):\n\n            continue\n\n\n\n        if e_cost == 0:\n\n            que.append([e, cost + 0])\n\n\n\n        if e_cost == 1:\n\n            que.appendleft([e, cost + 1])\n\n\n\nprint((dist[0]))\n", "generated_code": "from collections import deque\n\nK = int(eval(input()))\n\nG = [[] for i in range(K)]\n\nfor i in range(K):\n\n    G[i].append(((10 * i) % K, 0))\n\n    G[i].append(((i + 1) % K, 1))\n\n\n\ndist = [float('inf')] * K\n\ndist[1] = 1\n\nque = deque()\n\nque.append(1)\n\n\n\nwhile que:\n\n    n = que.pop()\n\n    for v, c in G[n]:\n\n        if dist[v] > dist[n] + c:\n\n            dist[v] = dist[n] + c\n\n            if c == 0:\n\n                que.append(v)\n\n            else:\n\n                que.appendleft(v)\n\n\n\nprint((dist[0]))\n", "score": 1.0, "surface_similarity": 0.807735321528425}
{"id": "p03307_u305366205", "golden_code": "import fractions\n\n\n\n\n\ndef lcm(x, y):\n\n    return (x * y) // fractions.gcd(x, y)\n\n\n\n\n\nN = int(eval(input()))\n\nprint((lcm(N, 2)))", "generated_code": "N = int(eval(input()))\n\nif N % 2 == 0:\n\n    print(N)\n\nelse:\n\n    print((2 * N))", "score": 1.0, "surface_similarity": 0.4359341445955619}
{"id": "p03720_u379692329", "golden_code": "import numpy as np\n\n\n\nN, M = [int(x) for x in input().split()]\n\nL = [[int (y) for y in input().split()] for _ in range(M)]\n\nL = sum(L, [])\n\n\n\nfor i in np.arange(1, N+1):\n\n    print((L.count(i)))", "generated_code": "N, M = [int(x) for x in input().split()]\n\nL = [[int (y) for y in input().split()] for _ in range(M)]\n\nL = sum(L, [])\n\n\n\nfor i in range(1, N+1):\n\n    print((L.count(i)))", "score": 1.0, "surface_similarity": 0.8928980526918671}
{"id": "p02881_u638456847", "golden_code": "import numpy as np\n\n\n\ndef main():\n\n    N = int(eval(input()))\n\n\n\n    INF = 10**6 + 100\n\n\n\n    x = np.arange(1,INF,dtype=np.int64)\n\n    div = x[N % x == 0]\n\n    #print(div)\n\n    #print(N // div)\n\n    \n\n    ans = (div + N//div).min() - 2\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "generated_code": "import sys\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\nreadlines = sys.stdin.readlines\n\n\n\nfrom math import sqrt\n\n\n\ndef divisor_enumeration(n):\n\n    div = []\n\n    for i in range(1, int(sqrt(n))+1):\n\n        if n % i == 0:\n\n            if n // i != i:\n\n                div.append((i, n // i))\n\n            else:\n\n                div.append((i, i))\n\n        \n\n    return div\n\n\n\n\n\ndef main():\n\n    N = int(readline())\n\n\n\n    d = divisor_enumeration(N)\n\n    \n\n    ans = 10**15\n\n    for x, y in d:\n\n        ans = min(ans, x + y - 2)\n\n\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "score": 1.0, "surface_similarity": 0.6145833333333334}
{"id": "p02555_u507456172", "golden_code": "from math import factorial as fac\n\n\n\nS = int(eval(input()))\n\nans = 0\n\n\n\nif S == 1 or S == 2:\n\n  print((0))\n\nelif S == 3:\n\n  print((1))\n\nelse:\n\n  for k in range(1,S):\n\n    if S-2*k-1 >= 0 and S-3*k >= 0:\n\n      ans += fac(S-2*k-1)//(fac(k-1)*fac(S-3*k))\n\n  print((ans%1000000007))", "generated_code": "S = int(eval(input()))\n\n\n\nif S == 1 or S ==2:\n\n  print((0))\n\nelif S == 3 or S == 4 or S == 5:\n\n  print((1))\n\nelse:\n\n  #初期化\n\n  dp = [0]*S\n\n  dp[2] = 1\n\n  dp[3] = 1\n\n  dp[4] = 1\n\n  dp_S = 0\n\n  #dp\n\n  for i in range(5,S):\n\n    dp_S += dp[i-3] \n\n    dp[i] = 1+dp_S\n\n\n\n  print((dp[S-1]%1000000007))", "score": 1.0, "surface_similarity": 0.628473915163335}
{"id": "p03287_u439396449", "golden_code": "from collections import defaultdict\n\n\n\nfrom scipy.misc import comb\n\n\n\nN, M = list(map(int, input().split()))\n\nA = [int(x) for x in input().split()]\n\n\n\nB = [0] * N\n\nB[0] = A[0]\n\nfor i in range(1, N):\n\n    B[i] = B[i - 1] + A[i]\n\nB = [0] + B\n\n\n\nc = defaultdict(int)\n\nfor i in range(N + 1):\n\n    c[B[i] % M] += 1\n\n\n\nans = 0\n\nfor k, v in list(c.items()):\n\n    if v >= 2:\n\n        ans += comb(v, 2, exact=True)\n\nprint(ans)", "generated_code": "from collections import defaultdict\n\n\n\nN, M = list(map(int, input().split()))\n\nA = [int(x) for x in input().split()]\n\n\n\nB = [0] * N\n\nB[0] = A[0]\n\nfor i in range(1, N):\n\n    B[i] = B[i - 1] + A[i]\n\nB = [0] + B\n\n\n\nc = defaultdict(int)\n\nfor i in range(N + 1):\n\n    c[B[i] % M] += 1\n\n\n\nans = 0\n\nfor k, v in list(c.items()):\n\n    if v >= 2:\n\n        ans += v * (v - 1) // 2\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.9139584883817085}
{"id": "p02555_u279493135", "golden_code": "import sys, re\n\nfrom collections import deque, defaultdict, Counter\n\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, radians, gcd\n\nfrom itertools import accumulate, permutations, combinations, product, groupby, combinations_with_replacement\n\nfrom operator import itemgetter, mul\n\nfrom copy import deepcopy\n\nfrom string import ascii_lowercase, ascii_uppercase, digits\n\nfrom bisect import bisect, bisect_left\n\nfrom heapq import heappush, heappop\n\nfrom functools import reduce, lru_cache\n\ndef input(): return sys.stdin.readline().strip()\n\ndef INT(): return int(eval(input()))\n\ndef MAP(): return list(map(int, input().split()))\n\ndef LIST(): return list(map(int, input().split()))\n\ndef ZIP(n): return list(zip(*(MAP() for _ in range(n))))\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = float('inf')\n\nmod = 10 ** 9 + 7\n\n\n\nS = INT()\n\n\n\n@lru_cache(maxsize=None)\n\ndef rec(x):\n\n    if x == 0: return 1\n\n\n\n    ret = 0\n\n    for i in range(x-2):\n\n        ret += rec(i)\n\n        ret %= mod\n\n    return ret\n\n\n\nprint((rec(S)))\n", "generated_code": "import sys, re\n\nfrom collections import deque, defaultdict, Counter\n\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, radians, gcd\n\nfrom itertools import accumulate, permutations, combinations, product, groupby, combinations_with_replacement\n\nfrom operator import itemgetter, mul\n\nfrom copy import deepcopy\n\nfrom string import ascii_lowercase, ascii_uppercase, digits\n\nfrom bisect import bisect, bisect_left\n\nfrom heapq import heappush, heappop\n\nfrom functools import reduce, lru_cache\n\ndef input(): return sys.stdin.readline().strip()\n\ndef INT(): return int(eval(input()))\n\ndef MAP(): return list(map(int, input().split()))\n\ndef LIST(): return list(map(int, input().split()))\n\ndef ZIP(n): return list(zip(*(MAP() for _ in range(n))))\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = float('inf')\n\nmod = 10 ** 9 + 7\n\n\n\nS = INT()\n\n\n\n@lru_cache(maxsize=None)\n\ndef rec(x):\n\n    if x == 0: return 1\n\n\n\n    ret = 0\n\n    if x >= 3:\n\n        return (rec(x-1)+rec(x-3))%mod\n\n    else:\n\n        return 0\n\n\n\nprint((rec(S)))\n", "score": 1.0, "surface_similarity": 0.9334042418084836}
{"id": "p03250_u143173995", "golden_code": "# インポート\n\nimport numpy as np\n\n# A,B,Cの値の獲得\n\nnum = list(map(int, input().split()))\n\n# numリストの最大値を10倍\n\nnum[num.index(max(num))] = max(num) * 10\n\n# npで要素の和を計算し、出力\n\nprint((np.sum(num)))", "generated_code": "# A,B,Cの値の獲得\n\nnum = list(map(int, input().split()))\n\n# numリストの最大値を10倍\n\nnum[num.index(max(num))] *= 10\n\n# npで要素の和を計算し、出力\n\nprint((sum(num)))\n", "score": 1.0, "surface_similarity": 0.7944444444444445}
{"id": "p03037_u254871849", "golden_code": "import sys\n\n\n\nn, m, *lr = list(map(int, sys.stdin.read().split()))\n\nlr = list(zip(*[iter(lr)] * 2))\n\n\n\ndef main():\n\n    cnt = [0] * (n + 1)\n\n    for l, r in lr:\n\n        cnt[l-1] += 1\n\n        cnt[r] -= 1\n\n    \n\n    for i in range(n):\n\n        cnt[i+1] += cnt[i]\n\n    \n\n    res = 0\n\n    for i in range(n):\n\n        res += (cnt[i] == m) & 1\n\n    \n\n    return res\n\n\n\nif __name__ == '__main__':\n\n    ans = main()\n\n    print(ans)", "generated_code": "import sys\n\n\n\nn, m, *lr = list(map(int, sys.stdin.read().split()))\n\nl, r = lr[::2], lr[1::2]\n\n\n\ndef main():\n\n    ans = max(min(r) - max(l) + 1, 0)\n\n    return ans\n\n\n\nif __name__ == '__main__':\n\n    ans = main()\n\n    print(ans)", "score": 1.0, "surface_similarity": 0.7303921568627452}
{"id": "p01438_u633068244", "golden_code": "from collections import defaultdict\n\nwhile 1:\n\n    n = int(input())\n\n    if n == 0: break\n\n    L = [0]*n\n\n    D = [0]*n\n\n    for man in range(n):\n\n        m,l = list(map(int,input().split()))\n\n        L[man] = l\n\n        t = 0\n\n        for date in range(m):\n\n            s,e = list(map(int,input().split()))\n\n            for s in range(s-6,e-6):\n\n                t |= 1 << s\n\n        D[man] = t\n\n\n\n    dp = [defaultdict(int) for i in range(n)]\n\n    dp[0][D[0]] = L[0]\n\n    for i in range(1,n):\n\n        for bit in list(dp[i-1].keys()):\n\n            if bit&D[i] == 0:\n\n                dp[i][bit|D[i]] = max(dp[i][bit|D[i]], dp[i-1][bit]+L[i])\n\n            dp[i][bit] = max(dp[i][bit],dp[i-1][bit])\n\n        dp[i][D[i]] = max(dp[i][D[i]], L[i])\n\n        \n\n    ans = max(max(dp[i].values()) for i in range(n))\n\n    print(ans)", "generated_code": "from collections import defaultdict\n\nwhile 1:\n\n    n = int(input())\n\n    if n == 0: break\n\n    L = [0]*n\n\n    T = [0]*n\n\n    for man in range(n):\n\n        m,l = list(map(int,input().split()))\n\n        L[man] = l\n\n        t = 0\n\n        for date in range(m):\n\n            s,e = list(map(int,input().split()))\n\n            t |= 2**(e-6)-2**(s-6)\n\n        T[man] = t\n\n\n\n    dp = defaultdict(int)\n\n    dp[T[0]] = L[0]\n\n    for i in range(1,n):\n\n        for bit in list(dp.keys()):\n\n            if bit&T[i] == 0:\n\n                dp[bit|T[i]] = max(dp[bit|T[i]], dp[bit]+L[i])\n\n        dp[T[i]] = max(dp[T[i]], L[i])\n\n        \n\n    print(max(dp.values()))", "score": 1.0, "surface_similarity": 0.834218093342181}
{"id": "p02767_u186974762", "golden_code": "import numpy as np\n\nN = int(eval(input()))\n\nX = np.array(input().split()).astype(int)\n\nP = round(np.average(X))\n\nprint((int(np.sum((P-X)**2))))", "generated_code": "n = int(eval(input()))\n\nx = [int(i) for i in input().split()]\n\nmin_x = round(sum(x) / n)\n\nans = sum([(min_x - i)**2 for i in x])\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.548745372274784}
{"id": "p02780_u873616440", "golden_code": "N, K = list(map(int, input().split()))\n\nA = list(map(int, input().split()))\n\ns = [0] * 1000000\n\nfor i in range(N):\n\n    s[i+1] = s[i] + A[i]\n\n\n\nmax_s = 0\n\nfor i in range(N):\n\n    if max_s < s[i+K] - s[i]:\n\n        max_s = s[i+K] - s[i]\n\n\n\n\n\nprint(((max_s+K) / 2))", "generated_code": "N, K = list(map(int, input().split()))\n\np = list(map(int, input().split()))\n\n\n\nm = [(e + 1) / 2 for e in p]\n\n\n\nt = sum(m[0:K])\n\nresult = t\n\nfor i in range(N - K):\n\n    t -= m[i]\n\n    t += m[i + K]\n\n    if t > result:\n\n        result = t\n\nprint(result)", "score": 1.0, "surface_similarity": 0.6769469088860725}
{"id": "p03208_u392319141", "golden_code": "N, K = list(map(int, input().split()))\n\n\n\nheight = []\n\nfor _ in range(N) :\n\n    height.append(int(eval(input())))\n\n\n\nheight.sort()\n\nans = float('inf')\n\n\n\nfor i in range(N-K+1) :\n\n    diff = height[i + K - 1] - height[i]\n\n    ans = min(ans, diff)\n\n\n\nprint(ans)", "generated_code": "N, K = list(map(int, input().split()))\n\nH = [int(eval(input())) for _ in range(N)]\n\nH.sort()\n\n\n\nans = 10**18\n\nfor i in range(N - K + 1):\n\n    ans = min(ans, H[i + K - 1] - H[i])\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.705019305019305}
{"id": "p03032_u380524497", "golden_code": "from collections import deque\n\n\n\nn, k = list(map(int, input().split()))\n\nV = list(map(int, input().split()))\n\n\n\nans = 0\n\nfor t in range(k//2 + 1):\n\n    hand = deque(V[:k-t])\n\n    rest = deque(V[k-t:])\n\n    cur_sum = sum(hand)\n\n\n\n    for j in range(k-t+1):\n\n        put_back = 0\n\n        rev_hand = sorted(hand)\n\n\n\n        for i in range(t):\n\n            jewel = rev_hand[i]\n\n            if jewel < 0:\n\n                put_back -= jewel\n\n            else:\n\n                break\n\n\n\n        candidate = cur_sum + put_back\n\n        ans = max(candidate, ans)\n\n\n\n        to_rest = hand.pop()\n\n        rest.appendleft(to_rest)\n\n        to_hand = rest.pop()\n\n        hand.appendleft(to_hand)\n\n\n\n        cur_sum += to_hand - to_rest\n\n\n\nprint(ans)", "generated_code": "n, k = list(map(int, input().split()))\n\nV = list(map(int, input().split()))\n\n\n\n\n\ndef get_jewelries(box, left_pop, right_pop):\n\n    if left_pop + right_pop >= len(box):\n\n        return box[:]\n\n\n\n    left = box[:left_pop]\n\n    right = box[-right_pop:] if right_pop else []\n\n\n\n    return left + right\n\n\n\n\n\ncandidates = []\n\npop_max = min(k, n)\n\nfor pop_count in range(pop_max+1):\n\n    residue = k - pop_count\n\n\n\n    for left_pop in range(pop_count+1):\n\n        right_pop = pop_count - left_pop\n\n        jewelries = get_jewelries(V, left_pop, right_pop)\n\n        jewelries.sort(reverse=True)\n\n\n\n        for _ in range(residue):\n\n            if not jewelries:\n\n                break\n\n            if jewelries[-1] < 0:\n\n                jewelries.pop()\n\n\n\n        value = sum(jewelries)\n\n        candidates.append(value)\n\n\n\nprint((max(candidates)))\n", "score": 1.0, "surface_similarity": 0.5229389615537059}
{"id": "p02863_u227082700", "golden_code": "n,t=list(map(int,input().split()))\n\nab=[list(map(int,input().split()))for _ in range(n)]\n\nab.sort()\n\ndp=[(6007)*[0]for _ in range(n+1)]\n\ndp[0][0]=0\n\nans=0\n\nfor i in range(n):\n\n  for j in range(6007):\n\n    dp[i+1][j]=max(dp[i+1][j],dp[i][j])\n\n    if j<t:dp[i+1][j+ab[i][0]]=max(dp[i][j]+ab[i][1],dp[i][j+ab[i][0]])\n\n    ans=max(ans,dp[i+1][j])\n\nprint(ans)\n", "generated_code": "n,t=list(map(int,input().split()))\n\ndp=[[0]*(t+3001)for _ in range(n+1)]\n\nans=0\n\nab=[list(map(int,input().split()))for _ in range(n)]\n\nab.sort()\n\nfor i in range(1,n+1):\n\n    a,b=ab[i-1]\n\n    for j in range(t):\n\n        dp[i][j]=max(dp[i-1][j],dp[i][j])\n\n        dp[i][j+a]=dp[i-1][j]+b\n\n        ans=max(dp[i][j],dp[i][j+a],ans)\n\nprint(ans)   ", "score": 1.0, "surface_similarity": 0.7017758726270668}
{"id": "p00447_u408260374", "golden_code": "board = [[False]*1000001]*1000001\n\nwhile True:\n\n    m = int(eval(input()))\n\n    if m == 0: break\n\n    star = list({tuple(map(int, input().split())) for i in range(m)})\n\n    sx, sy = star[0]\n\n    \n\n    n = int(eval(input()))\n\n    starlist = list({tuple(map(int, input().split())) for i in range(n)})\n\n    for i in range(len(starlist)):\n\n        board[starlist[i][0]][starlist[i][1]] = True\n\n    for i in range(n):\n\n        flag = True\n\n        for j in range(len(star)-1):\n\n            dx = starlist[i][0] + star[j+1][0] - sx\n\n            dy = starlist[i][1] + star[j+1][1] - sy\n\n            if dx < 0 or 1000000 < dx or dy < 0 or 1000000 < dy or board[dx][dy] == False:\n\n                flag = False\n\n                break\n\n\n\n        if flag == True:\n\n            print((\"{} {}\".format(starlist[i][0] - sx, starlist[i][1] -sy)))\n\n            break\n\n    ", "generated_code": "while True:\n\n    m = int(eval(input()))\n\n    if m == 0: break\n\n    star = list({tuple(map(int, input().split())) for i in range(m)})\n\n    sx, sy = star[0]\n\n    \n\n    n = int(eval(input()))\n\n    starset = {tuple(map(int, input().split())) for i in range(n)}\n\n    for x, y in starset:\n\n        flag = True\n\n        for j in range(len(star)-1):\n\n            dx = x + star[j+1][0] - sx\n\n            dy = y + star[j+1][1] - sy\n\n            if (dx, dy) not in starset:\n\n                flag = False\n\n                break\n\n\n\n        if flag == True:\n\n            print((x - sx, y - sy))\n\n            break\n\n    ", "score": 1.0, "surface_similarity": 0.7582164369163601}
{"id": "p02647_u824144553", "golden_code": "import copy\n\nfrom functools import lru_cache\n\nimport numpy as np\n\nfrom numba import njit\n\n\n\n#@njit\n\n# @njit('(i8[::1],)', cache=True)\n\n# def func(A):\n\n#     N = len(A)\n\n#     B = np.zeros_like(A)\n\n#     for i in range(N):\n\n#         l = max(0, i - A[i])\n\n#         r = min(i + A[i], N-1)\n\n#         B[l] += 1\n\n#         if r+1 < N:\n\n#             B[r+1] -= 1\n\n\n\n#     B = np.cumsum(B)\n\n#     return B\n\n\n\ndef resolve():\n\n    N, K = list(map(int, input().split()))\n\n    A = np.array(list(map(int, input().split())))\n\n\n\n    # N = 2 * 10**5\n\n    # K = 2 * 10**5\n\n    # A = np.array([0] *  N)\n\n\n\n    @njit\n\n    def func(A):\n\n        #N = len(A)\n\n        B = np.zeros_like(A)\n\n        for i in range(N):\n\n            l = max(0, i - A[i])\n\n            r = min(i + A[i], N-1)\n\n            B[l] += 1\n\n            if r+1 < N:\n\n                B[r+1] -= 1\n\n\n\n        B = np.cumsum(B)\n\n        return B\n\n\n\n    for k in range(K):\n\n        #print(k)\n\n        A = func(A)\n\n        if k >= 50:\n\n            break\n\n\n\n    print((\" \".join(map(str, A))))\n\n\n\nif __name__ == \"__main__\":\n\n    resolve()", "generated_code": "import copy\n\nfrom functools import lru_cache\n\n#import numpy as np\n\n#from numba import njit\n\n\n\ndef resolve():\n\n    N, K = list(map(int, input().split()))\n\n    #A = np.array(list(map(int, input().split())))\n\n    A = list(map(int, input().split()))\n\n\n\n    #N = 2 * 10**5\n\n    #K = 2 * 10**5\n\n    #A = np.array([0] *  N)\n\n\n\n    def func(A):\n\n        B = [0] * N\n\n        for i in range(N):\n\n            l = max(0, i - A[i])\n\n            r = min(i + A[i], N-1)\n\n            B[l] += 1\n\n            if r+1 < N:\n\n                B[r+1] -= 1\n\n\n\n        for i in range(1, N):\n\n            B[i] += B[i-1]\n\n        return B\n\n\n\n    for k in range(K):\n\n        #print(k)\n\n        A = func(A)\n\n        if k >= 50:\n\n            break\n\n\n\n    print((\" \".join(map(str, A))))\n\n\n\nif __name__ == \"__main__\":\n\n    resolve()", "score": 1.0, "surface_similarity": 0.9242643651529194}
{"id": "p03399_u867069435", "golden_code": "a, b, c, d = int(eval(input())), int(eval(input())), int(eval(input())), int(eval(input())),\n\nprint((min(a, b)+min(c, d)))", "generated_code": "print((min(int(eval(input())), int(eval(input()))) + min(int(eval(input())), int(eval(input())))))", "score": 1.0, "surface_similarity": 0.6778688524590164}
{"id": "p02837_u021019433", "golden_code": "def popcount(x):\n\n  r = 0\n\n  while x:\n\n    if x & 1:\n\n      r += 1\n\n    x >>= 1\n\n  return r\n\n\n\nn = int(eval(input()))\n\nr = list(range(n))\n\na = [[0, 0] for _ in r]\n\nfor i in r:\n\n  for _ in range(int(eval(input()))):\n\n    x, y = list(map(int, input().split()))\n\n    a[i][y] |= 1 << (x - 1)\n\n\n\nm = 0\n\nl = (1 << n) - 1\n\nfor x in range(1, l + 1):\n\n  if all(a[i][0] & x == a[i][1] & l - x == 0 for i in r if x >> i & 1):\n\n    m = max(m, popcount(x))\n\nprint(m)\n", "generated_code": "from itertools import combinations\n\n \n\nn = int(eval(input()))\n\nr = list(range(n))\n\na = [(set(), set()) for _ in r]\n\nfor i in r:\n\n  for _ in range(int(eval(input()))):\n\n    x, y = list(map(int, input().split()))\n\n    a[i][y].add(x - 1)\n\n \n\nfail = lambda x: not all(a[i][0].isdisjoint(x) and a[i][1] < x for i in x)\n\n \n\nwhile all(map(fail, list(map(set, combinations(r, n))))):\n\n  n -= 1\n\nprint(n)", "score": 1.0, "surface_similarity": 0.6020737079617493}
{"id": "p03039_u893063840", "golden_code": "n, m, k = list(map(int, input().split()))\n\nmod = 10 ** 9 + 7\n\nMAX = n * m\n\n\n\n\n\nclass ModInt:\n\n    def __init__(self, num):\n\n        self.num = num\n\n\n\n    def __str__(self):\n\n        return str(self.num)\n\n\n\n    def __repr__(self):\n\n        return \"ModInt(num: {}, mod: {}\".format(self.num, mod)\n\n\n\n    def __add__(self, other):\n\n        ret = self.num + other.num\n\n        ret %= mod\n\n        return ModInt(ret)\n\n\n\n    def __sub__(self, other):\n\n        ret = self.num - other.num\n\n        ret %= mod\n\n        return ModInt(ret)\n\n\n\n    def __mul__(self, other):\n\n        ret = self.num * other.num\n\n        ret %= mod\n\n        return ModInt(ret)\n\n\n\n    def pow(self, times):\n\n        pw = pow(self.num, times, mod)\n\n        return ModInt(pw)\n\n\n\n    def inverse(self):\n\n        return ModInt(inv[self.num])\n\n\n\n    def __truediv__(self, other):\n\n        num = self * other.inverse()\n\n        return ModInt(num)\n\n\n\n\n\ndef comb(n, k):\n\n    return fact[n] * inv[n-k] * inv[k]\n\n\n\n\n\nfact = [None] * (MAX + 1)\n\nfact[0] = ModInt(1)\n\nfor i in range(1, MAX + 1):\n\n    fact[i] = fact[i-1] * ModInt(i)\n\n\n\ninv = [None] * (MAX + 1)\n\ninv[MAX] = fact[MAX].pow(mod - 2)\n\nfor i in range(MAX, 0, -1):\n\n    inv[i-1] = inv[i] * ModInt(i)\n\n\n\nans = ModInt(0)\n\nfor i in range(n):\n\n    for j in range(m):\n\n        add = ModInt(n - i) * ModInt(m - j) * ModInt(i + j)\n\n        if i != 0 and j != 0:\n\n            add *= ModInt(2)\n\n\n\n        ans += add\n\n\n\nans *= comb(n * m - 2, k - 2)\n\nprint(ans)\n", "generated_code": "n, m, k = list(map(int, input().split()))\n\n\n\nmod = 10 ** 9 + 7\n\nMAX = n * m\n\n\n\nfact = [1] * (MAX + 1)\n\nfor i in range(1, MAX + 1):\n\n    fact[i] = (fact[i-1] * i) % mod\n\n\n\ninv = [1] * (MAX + 1)\n\ninv[MAX] = pow(fact[MAX], mod - 2, mod)\n\nfor i in range(MAX, 0, -1):\n\n    inv[i-1] = (inv[i] * i) % mod\n\n\n\n\n\ndef comb(n, k):\n\n    return fact[n] * inv[n-k] * inv[k] % mod\n\n\n\n\n\nans = 0\n\nfor i in range(n):\n\n    for j in range(m):\n\n        add = (n - i) * (m - j) * (i + j) % mod\n\n        if i != 0 and j != 0:\n\n            add *= 2\n\n            add %= mod\n\n\n\n        ans += add\n\n        ans %= mod\n\n\n\nans *= comb(MAX - 2, k - 2)\n\nans %= mod\n\nprint(ans)\n", "score": 1.0, "surface_similarity": 0.7338252924883211}
{"id": "p02792_u600402037", "golden_code": "import sys\n\nimport numpy as np\n\n\n\nsr = lambda: sys.stdin.readline().rstrip()\n\nir = lambda: int(sr())\n\nlr = lambda: list(map(int, sr().split()))\n\n\n\nN = ir()\n\n# Aの先頭の桁と末尾の桁の組み合わせは9*10=90通りだけ\n\ntable = [[0] * 10 for i in range(10)]\n\nfor x in range(1, N+1):\n\n    x = str(x)\n\n    i = int(x[0])\n\n    j = int(x[-1])\n\n    table[i][j] += 1\n\n\n\ntable = np.array(table)\n\nanswer = (table * table.T).sum()\n\nprint(answer)\n", "generated_code": "import sys\n\n\n\nsr = lambda: sys.stdin.readline().rstrip()\n\nir = lambda: int(sr())\n\nlr = lambda: list(map(int, sr().split()))\n\n\n\nN = ir()\n\ncount = [[0] * 10 for _ in range(10)] # dp[head][tail]\n\nfor i in range(1, N+1):\n\n    s = str(i)\n\n    head = int(s[0]); tail = int(s[-1])\n\n    count[head][tail] += 1\n\n\n\nanswer = 0\n\nfor h in range(10):\n\n    for t in range(10):\n\n        answer += count[h][t] * count[t][h]\n\nprint(answer)\n", "score": 1.0, "surface_similarity": 0.8767772511848342}
{"id": "p03241_u644907318", "golden_code": "N,M = list(map(int,input().split()))\n\nif N==1:\n\n    nmax=M\n\nelse:\n\n    nmax = 1\n\n    for i in range(2,int(M**0.5)+1):\n\n        if M%i==0 and M//i>=N:\n\n            nmax = max(nmax,i)\n\n        if M%i==0 and i>=N:\n\n            nmax = max(nmax,M//i)\n\nprint(nmax)", "generated_code": "N,M = list(map(int,input().split()))\n\namax = 1\n\nfor i in range(1,int(M**0.5)+1):\n\n    if M%i==0:\n\n        a = i\n\n        b = M//i\n\n        if b>=N:\n\n            amax = max(amax,a)\n\n        a,b = b,a\n\n        if b>=N:\n\n            amax = max(amax,a)\n\nprint(amax)", "score": 1.0, "surface_similarity": 0.8510971786833856}
{"id": "p03162_u628335443", "golden_code": "import numpy as np\n\n\n\nN = int(eval(input()))\n\na = np.array([input().split() for i in range(N)], dtype=int)\n\n\n\ndp = np.zeros((N, 3), dtype=int)\n\ndp[0] = a[0]\n\n\n\nfor i in range(1, N):\n\n    dp[i] = [\n\n        a[i][0] + max(dp[i - 1][1], dp[i - 1][2]),\n\n        a[i][1] + max(dp[i - 1][2], dp[i - 1][0]),\n\n        a[i][2] + max(dp[i - 1][0], dp[i - 1][1]),\n\n    ]\n\n\n\nprint((np.max(dp[-1])))\n", "generated_code": "N = int(eval(input()))\n\na = [list(map(int, input().split())) for _ in range(N)]\n\n\n\ndp = [[0, 0, 0] for _ in range(N+1)]\n\n\n\nfor i in range(N):\n\n    for j in range(3):\n\n        for k in range(3):\n\n            if j == k:\n\n                continue\n\n            dp[i+1][k] = max(dp[i+1][k], dp[i][j] + a[i][k])\n\n\n\nprint((max(dp[-1])))\n", "score": 1.0, "surface_similarity": 0.6273994093761536}
{"id": "p02596_u543954314", "golden_code": "import sys\n\n\n\nreadline = sys.stdin.readline\n\nreadall = sys.stdin.read\n\nns = lambda: readline().rstrip()\n\nni = lambda: int(readline().rstrip())\n\nnm = lambda: map(int, readline().split())\n\nnl = lambda: list(map(int, readline().split()))\n\nprn = lambda x: print(*x, sep='\\n')\n\n\n\ndef solve():\n\n    d = dict()\n\n    k = ni()\n\n    c = 7 % k\n\n    x = d[c] = 1\n\n    while True:\n\n        c = (c * 10 + 7) % k\n\n        if c in d:\n\n            break\n\n        x += 1\n\n        d[c] = x\n\n    print(d.get(0, -1))\n\n    return\n\n\n\nsolve()\n", "generated_code": "import sys\n\n\n\nreadline = sys.stdin.readline\n\nreadall = sys.stdin.read\n\nns = lambda: readline().rstrip()\n\nni = lambda: int(readline().rstrip())\n\nnm = lambda: map(int, readline().split())\n\nnl = lambda: list(map(int, readline().split()))\n\nprn = lambda x: print(*x, sep='\\n')\n\n\n\ndef solve():\n\n    k = ni()\n\n    c = 0\n\n    for i in range(k):\n\n        c = (c * 10 + 7) % k\n\n        if c == 0:\n\n            print(i+1)\n\n            break\n\n    else:\n\n        print(-1)\n\n    return\n\n\n\nsolve()\n", "score": 1.0, "surface_similarity": 0.8402187464581208}
{"id": "p02959_u561083515", "golden_code": "import sys\n\ninput = sys.stdin.readline\n\nsys.setrecursionlimit(10 ** 7)\n\n\n\nN = int(eval(input()))\n\nA = [int(i) for i in input().split()]\n\nB = [int(i) for i in input().split()]\n\nbefore = sum(A)\n\n\n\nfor i in range(N):\n\n    nokori = B[i]\n\n    for j in range(i,i+2):\n\n        if nokori >= A[j]:\n\n            nokori -= A[j]\n\n            A[j] = 0\n\n        else:\n\n            A[j] -= nokori\n\n            nokori = 0\n\nafter = sum(A)\n\n\n\nprint((before - after))", "generated_code": "N = int(eval(input()))\n\nA = [int(i) for i in input().split()]\n\nB = [int(i) for i in input().split()]\n\n\n\ncnt = 0\n\nfor i in range(N):\n\n    if B[i] >= A[i]:\n\n        cnt += A[i]\n\n        B[i] -= A[i]\n\n    else:\n\n        cnt += B[i]\n\n        B[i] = 0\n\n    if B[i] == 0:\n\n        continue\n\n    if B[i] >= A[i+1]:\n\n        cnt += A[i+1]\n\n        A[i+1] = 0\n\n    else:\n\n        cnt += B[i]\n\n        A[i+1] -= B[i]\n\n\n\nprint(cnt)", "score": 1.0, "surface_similarity": 0.6795157967032968}
{"id": "p03457_u144913062", "golden_code": "N = int(eval(input()))\n\ntxy = [(0, 0, 0)] + [tuple(map(int, input().split())) for _ in range(N)]\n\nfor i in range(N):\n\n    t1, x1, y1 = txy[i]\n\n    t2, x2, y2 = txy[i+1]\n\n    if abs(x2-x1) + abs(y2-y1) <= t2 - t1 and (x1+y1+x2+y2) % 2 == (t2-t1) % 2:\n\n        continue\n\n    else:\n\n        print('No')\n\n        exit()\n\nprint('Yes')", "generated_code": "N = int(eval(input()))\n\nt0 = x0 = y0 = 0\n\nfor _ in range(N):\n\n    t1, x1, y1 = list(map(int, input().split()))\n\n    d = abs(x1 - x0) + abs(y1 - y0)\n\n    if d > t1 - t0 or d % 2 != (t1 - t0) % 2:\n\n        print('No')\n\n        exit()\n\n    t0, x0, y0 = t1, x1, y1\n\nprint('Yes')\n", "score": 1.0, "surface_similarity": 0.5781155015197568}
{"id": "p02834_u227082700", "golden_code": "n,u,v=list(map(int,input().split()))\n\nanss=0\n\nu-=1\n\nv-=1\n\nd=[[]for _ in range(n)]\n\ninf=float('inf')\n\naoki=[inf]*n\n\nfor i in range(n-1):\n\n  a,b=list(map(int,input().split()))\n\n  a-=1\n\n  b-=1\n\n  d[a].append(b)\n\n  d[b].append(a)\n\nQ=d[v]\n\naoki[v]=0\n\ndis=1\n\nvisited={v}\n\nwhile Q:\n\n  P=[]\n\n  for i in Q:\n\n    visited.add(i)\n\n    for j in d[i]:\n\n      if j not in visited:P.append(j)\n\n    aoki[i]=dis\n\n  dis+=1\n\n  Q=P\n\nQ=d[u]\n\nchokudai=[-1]*n\n\nchokudai[u]=0\n\ndis=1\n\nvisited={u}\n\npoint=-1\n\nwhile Q:\n\n  P=[]\n\n  for i in Q:\n\n    visited.add(i)\n\n    for j in d[i]:\n\n      if aoki[j]<=dis+1:\n\n        if aoki[j]==dis+1:anss=1\n\n        if point<0:point=i\n\n        continue\n\n      if j not in visited:P.append(j)\n\n    chokudai[i]=dis\n\n  dis+=1\n\n  Q=P\n\nQ=d[point]\n\ndis=chokudai[point]+1\n\nvisited={point}\n\nwhile Q:\n\n  P=[]\n\n  for i in Q:\n\n    visited.add(i)\n\n    if chokudai[i]==-1:continue\n\n    chokudai[i]=max(dis,chokudai[i])\n\n    for j in d[i]:\n\n      if j not in visited:P.append(j)\n\n  dis+=1\n\n  Q=P\n\nans=0\n\nfor i in range(n):\n\n  if aoki[i]>chokudai[i]:ans=max(ans,chokudai[i])\n\nprint((ans+anss))\n\n#print(aoki)\n\n#print(chokudai)", "generated_code": "n,u,v=list(map(int,input().split()))\n\nu-=1\n\nv-=1\n\ne=[[]for _ in range(n)]\n\nfor i in range(n-1):\n\n  a,b=list(map(int,input().split()))\n\n  a-=1\n\n  b-=1\n\n  e[a].append(b)\n\n  e[b].append(a)\n\ncho=[u]\n\ncho_dis=[10**7]*n\n\ncho_dis[u]=0\n\ncho_visited={u}\n\ncountt=1\n\nwhile cho:\n\n  CHO=[]\n\n  for i in cho:\n\n    for j in e[i]:\n\n      if j in cho_visited:continue\n\n      cho_visited.add(j)\n\n      CHO.append(j)\n\n      cho_dis[j]=countt\n\n  countt+=1\n\n  cho=CHO\n\naok=[v]\n\naok_dis=[10**7]*n\n\naok_dis[v]=0\n\naok_visited={v}\n\ncountt=1\n\nwhile aok:\n\n  AOK=[]\n\n  for i in aok:\n\n    for j in e[i]:\n\n      if j in aok_visited:continue\n\n      aok_visited.add(j)\n\n      AOK.append(j)\n\n      aok_dis[j]=countt\n\n  countt+=1\n\n  aok=AOK\n\nans=0\n\nfor i in range(n):\n\n  if cho_dis[i]<aok_dis[i]:ans=max(ans,aok_dis[i]-1)\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.6699577951144648}
{"id": "p02624_u102461423", "golden_code": "import sys\n\nimport numpy as np\n\n\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\ndef prime_table(N):\n\n    is_prime = np.zeros(N, np.int64)\n\n    is_prime[2:3] = 1\n\n    is_prime[3::2] = 1\n\n    for p in range(3, N, 2):\n\n        if p * p >= N:\n\n            break\n\n        if is_prime[p]:\n\n            is_prime[p * p::p + p] = 0\n\n    return is_prime, np.where(is_prime)[0]\n\n\n\ndef main(N, primes):\n\n    div = np.ones(N + 1, dtype=np.int64)\n\n    for p in primes:\n\n        for i in range(N // p + 1):\n\n            div[p * i] += div[i]\n\n    div *= np.arange(N + 1)\n\n    return div.sum()\n\n\n\nif sys.argv[-1] == 'ONLINE_JUDGE':\n\n    import numba\n\n    from numba.pycc import CC\n\n    i8 = numba.int64\n\n    cc = CC('my_module')\n\n\n\n    def cc_export(f, signature):\n\n        cc.export(f.__name__, signature)(f)\n\n        return numba.njit(f)\n\n\n\n    main = cc_export(main, (i8, i8[:]))\n\n    cc.compile()\n\n\n\nfrom my_module import main\n\n\n\nN = int(read())\n\nis_prime, primes = prime_table(N + 1)\n\nprint((main(N, primes)))", "generated_code": "N = int(eval(input()))\n\n\n\ndef f(x):\n\n  return x * (x+1) // 2\n\n\n\nans = 0\n\nfor x in range(1, N+1):\n\n  if x * x > N:\n\n    break\n\n  # x = y\n\n  ans += x * x\n\n  # x < y の 2 倍\n\n  y_high = N//x\n\n  ans += 2 * x * (f(y_high) - f(x))\n\n\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.4707430097392397}
{"id": "p02537_u729133443", "golden_code": "d=[0]*6**8\n\nn,k,*a=list(map(int,open(0).read().split()+d))\n\nfor i in range(n):d[i]=max(d[j]for j in range(i-99,i+1)if abs(a[i]-a[j])<=k)+1\n\nprint((max(d)))", "generated_code": "d=[0]*6**8\n\nn,k,*a=list(map(int,open(0).read().split()))\n\na=d+a\n\nwhile n:d[n]=max(d[j]for j in range(n,n+99)if abs(a[-n]-a[-j])<=k)+1;n-=1\n\nprint((max(d)))", "score": 1.0, "surface_similarity": 0.8139400921658986}
{"id": "p02899_u437638594", "golden_code": "import numpy as np\n\n\n\nN = int(input())\n\nAs = list(map(int, input().split()))\n\n\n\n# for i in range(N):\n\n#   print(As.index(i+1) + 1, end = \" \")\n\n\n\nfor item in np.argsort(As):\n\n  print(item+1, end=\" \")\n", "generated_code": "N = int(eval(input()))\n\nAs = list(map(int, input().split()))\n\n\n\nans = [0] * N\n\n\n\nfor i, A in enumerate(As):\n\n  ans[A-1] = i+1\n\n  \n\nprint((*ans))", "score": 1.0, "surface_similarity": 0.6119232526267702}
{"id": "p03494_u028260664", "golden_code": "import numpy as np\n\n# Me\n\n\n\n\n\ndef f():\n\n    i = int(eval(input()))\n\n    nums = np.array(list(map(int, input().split())))\n\n    # nums = [int(x) for x in input().split()]\n\n    c = 0\n\n    while True:\n\n        if any(nums % 2 == 1):\n\n            break\n\n        c += 1\n\n        nums = nums / 2\n\n    print(c)\n\n\n\n\n\nf()\n\n\n\n\n\n# Other\n", "generated_code": "def divide_all(a):\n\n    success = True\n\n    for i, n in enumerate(a):\n\n        if n % 2 != 0:\n\n            success = False\n\n            break\n\n        a[i] = n / 2\n\n    if success is False:\n\n        return (a, False)\n\n    return (a, True)\n\n\n\nn = int(eval(input()))\n\na = list(map(int, input().split()))\n\nc = 0\n\nwhile True:\n\n    a, r = divide_all(a)\n\n    if r is False:\n\n        break\n\n    c += 1\n\n\n\n\n\nprint(c)\n", "score": 1.0, "surface_similarity": 0.6037542392933197}
{"id": "p02690_u163829702", "golden_code": "X = int(eval(input()))\n\nfor A in range(-200, 200):\n\n    for B in range(-200, 200):\n\n        if A**5 - B**5 == X:\n\n            print((A, B))\n\n            break\n\n    else:\n\n        continue\n\n    break", "generated_code": "X = int(eval(input()))\n\nfor A in range(-150, 150):\n\n    for B in range(-150, 150):\n\n        if A**5 - B**5 == X:\n\n            print((A, B))\n\n            break\n\n    else:\n\n        continue\n\n    break", "score": 1.0, "surface_similarity": 0.9797979797979798}
{"id": "p02873_u185948224", "golden_code": "S = eval(input())\n\n\n\nlst = [1 if S[0]=='<' else -1]\n\nfor i in range(1, len(S)):\n\n    if S[i] == S[i - 1]:\n\n        lst[-1] += 1 if S[i]=='<' else -1\n\n    else:\n\n        lst.append(-1 if S[i]=='>' else 1)\n\n        \n\nans = [0]\n\n\n\nfor i in range(len(lst)):\n\n    if lst[i] > 0:\n\n        ans += list(range(1,lst[i]+1))\n\n    else:\n\n        ans[-1] = max(ans[-1], -lst[i])\n\n        ans += list(range(-lst[i]-1,-1, -1))\n\n\n\nprint((sum(ans)))\n", "generated_code": "S = eval(input())\n\n\n\nlst = [1 if S[0]=='<' else -1]\n\nfor i in range(1, len(S)):\n\n    if S[i] == S[i - 1]:\n\n        lst[-1] += 1 if S[i]=='<' else -1\n\n    else:\n\n        lst.append(-1 if S[i]=='>' else 1)\n\n        \n\nans = [0]\n\n\n\nfor i in lst:\n\n    if i > 0:\n\n        ans += list(range(1,i+1))\n\n    else:\n\n        ans[-1] = max(ans[-1], -i)\n\n        ans += list(range(-i-1,-1, -1))\n\n\n\n\n\nprint((sum(ans)))", "score": 1.0, "surface_similarity": 0.9630484988452657}
{"id": "p03253_u231095456", "golden_code": "from math import floor, sqrt\n\nfrom collections import defaultdict\n\ndef factors(n):\n\n    d = defaultdict(int)\n\n    for i in range(2,floor(sqrt(n))+1):\n\n        while n % i == 0:\n\n            n //= i\n\n            d[i] += 1\n\n        if n == 1:\n\n            break\n\n    if n != 1:\n\n        d[n] += 1\n\n    return d\n\ndef inv(x, mod):\n\n    k = mod - 2\n\n    ret = 1\n\n    while k > 0:\n\n        if k&1:\n\n            ret = (ret*x) % mod\n\n        x = (x*x) % mod\n\n        k >>= 1\n\n    return ret\n\nN, M = list(map(int,input().split()))\n\nmod = 10**9+7\n\ndic = factors(M)\n\nK = len(dic)\n\nSIZE = N+max(dic.values()) if list(dic.values()) else N\n\nfact = [None]*(SIZE+1)\n\nfinv = [None]*(SIZE+1)\n\nfact[0] = 1\n\nfor i in range(1,SIZE+1):\n\n    fact[i] = (fact[i-1]*i) % mod\n\nfinv[SIZE] = inv(fact[SIZE], mod=mod)\n\nfor i in range(SIZE, 0, -1):\n\n    finv[i-1] = (finv[i]*i) % mod\n\ndef comb(n,k):\n\n    tmp = (finv[k]*finv[n-k]) % mod\n\n    return (fact[n]*tmp) % mod\n\nans = 1\n\nfor p in dic:\n\n    ans = (ans*comb(dic[p]+N-1, dic[p])) % mod\n\nprint(ans)", "generated_code": "from math import floor, sqrt\n\nfrom collections import defaultdict\n\nN,M = list(map(int,input().split()))\n\nd = defaultdict(int)\n\nfor i in range(2, floor(sqrt(M))+1):\n\n    while M % i == 0:\n\n        d[i] += 1\n\n        M //= i\n\nif M != 1:\n\n    d[M] += 1\n\ndef comb(n,k):\n\n    if k == 0:\n\n        return 1\n\n    return comb(n-1,k-1) * n // k\n\nans = 1\n\nfor e in list(d.values()):\n\n    ans *= comb(N+e-1, e)\n\nprint((ans % (10**9+7)))", "score": 1.0, "surface_similarity": 0.6419579083156159}
{"id": "p03416_u118019047", "golden_code": "a , b = input().split()\n\na = int(a)\n\nb = int(b)\n\ncount=0\n\nfor i in range(a,b+1):\n\n    test = list(str(i))\n\n    if (test[0] == test[4]) and (test[1]==test[3]):\n\n        count=count+1\n\nprint(count)", "generated_code": "A,B=list(map(int,input().split()))\n\nct=0\n\nfor i in range(A,B+1):\n\n    s=str(i)\n\n    if s==s[::-1]:\n\n        ct+=1\n\nprint(ct)", "score": 1.0, "surface_similarity": 0.6362179487179487}
{"id": "p03034_u102461423", "golden_code": "import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\nimport numpy as np\n\n\n\nN = int(readline())\n\nS = np.array(read().split(),np.int64)\n\n\n\ndef F(d):\n\n    # 公差を固定\n\n    L = S[:-d:d].cumsum()\n\n    R = S[::-1][:-d:d].cumsum()\n\n    if (N-1)%d == 0:\n\n        n = (N-1)//d\n\n        x = np.arange(1,n+1)\n\n        bl = (x+x <= n+1)\n\n        L = L[bl]; R = R[bl]\n\n    return (L+R).max()\n\n\n\ndef G(n):\n\n    # 項数n+1を固定\n\n    D = (N-1-n)//n\n\n    L = np.zeros(D+1,np.int64)\n\n    R = np.zeros(D+1,np.int64)\n\n    for i in range(1,n+1):\n\n        L += S[:i*(D+1):i]\n\n        R += S[::-1][:i*(D+1):i]\n\n    ok = np.ones(D+1,np.bool)\n\n    overlap = (np.arange(D+1) * (n+n) >= N-1)\n\n    overlap[1:] &= ((N-1)%np.arange(1,D+1) == 0)\n\n    x = L+R\n\n    x[overlap] = 0\n\n    return x.max()\n\n\n\nL = int((N-1)**.5 + 10)\n\nL = min(N-1,L)\n\n\n\nx = max(F(n) for n in range(1,L+1))\n\ny = max(G(n) for n in range(1,L+1))\n\nanswer = max(x,y)\n\nprint(answer)", "generated_code": "import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\nimport itertools\n\n\n\nN = int(readline())\n\nS = list(map(int,read().split()))\n\n\n\nanswer = 0\n\nfor d in range(1,N):\n\n    n = (N-1)//d\n\n    if (N-1)%d == 0:\n\n        n = ((N-1)//d+1)//2\n\n    if n <= 1:\n\n        continue\n\n    x = max(itertools.accumulate(x+y for x,y in zip(S[d:d*n:d],S[N-1-d:N-1-d*n:-d])))\n\n    if answer < x:\n\n        answer = x\n\n\n\nprint(answer)", "score": 1.0, "surface_similarity": 0.6153061224489795}
{"id": "p03835_u562016607", "golden_code": "K,S=list(map(int,input().split()))\n\nO=0\n\nfor X in range(K+1):\n\n  for Y in range(K+1):\n\n    Z=S-X-Y\n\n    if 0<=Z<=K:\n\n      O+=1\n\nprint(O)\n", "generated_code": "K,S=list(map(int,input().split()))\n\nans=0\n\nfor X in range(K+1):\n\n    for Y in range(K+1):\n\n        Z=S-X-Y\n\n        if 0<=Z<=K:\n\n            ans+=1\n\nprint(ans)\n", "score": 1.0, "surface_similarity": 0.971875}
{"id": "p04020_u631277801", "golden_code": "import sys\n\nstdin = sys.stdin\n\n \n\nsys.setrecursionlimit(10**8) \n\n \n\ndef li(): return list(map(int, stdin.readline().split()))\n\ndef li_(): return [int(x)-1 for x in stdin.readline().split()]\n\ndef lf(): return list(map(float, stdin.readline().split()))\n\ndef ls(): return stdin.readline().split()\n\ndef ns(): return stdin.readline().rstrip()\n\ndef lc(): return list(ns())\n\ndef ni(): return int(stdin.readline())\n\ndef nf(): return float(stdin.readline())\n\n\n\n\n\nn = ni()\n\na = [ni() for _ in range(n)]\n\n\n\ncnt = {i+1: ai for i, ai in enumerate(a)}\n\n\n\nprev = -100\n\ncur = 0\n\nans = 0\n\nfor key in sorted(cnt.keys()):\n\n    if cnt[key] == 0:\n\n        continue\n\n    \n\n    if prev == -100:\n\n        prev = key\n\n    \n\n    if (key-prev) < 2:\n\n        cur += cnt[key]\n\n    else:\n\n        cur = cnt[key]\n\n        \n\n    ans += cur // 2\n\n    cur -= 2 * (cur//2)\n\n    \n\n    prev = key\n\n        \n\nprint(ans)", "generated_code": "import sys\n\nstdin = sys.stdin\n\n\n\nsys.setrecursionlimit(10 ** 7)\n\n\n\ndef li(): return list(map(int, stdin.readline().split()))\n\ndef li_(): return [int(x) - 1 for x in stdin.readline().split()]\n\ndef lf(): return list(map(float, stdin.readline().split()))\n\ndef ls(): return stdin.readline().split()\n\ndef ns(): return stdin.readline().rstrip()\n\ndef lc(): return list(ns())\n\ndef ni(): return int(stdin.readline())\n\ndef nf(): return float(stdin.readline())\n\n\n\nn = ni()\n\n\n\nans = 0\n\nplus = 0\n\na = [ni() for _ in range(n)]\n\n\n\nfor ai in a:\n\n    ans += ((ai+plus) // 2)\n\n    plus = (ai+plus) % 2 if ai > 0 else 0\n\n\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.7028496325945397}
{"id": "p03164_u761529120", "golden_code": "def main():\n\n    N, W = list(map(int, input().split()))\n\n    w = [0] * N\n\n    v = [0] * N\n\n    for i in range(N):\n\n        w[i], v[i] = list(map(int, input().split()))\n\n\n\n    max_v = max(v)\n\n    dp = [[float('inf')] * (max_v * N + 5) for _ in range(N + 5)]\n\n\n\n    dp[0][0] = 0\n\n\n\n    for i in range(N):\n\n        for j in range(max_v * N):\n\n            if j + v[i] <= max_v * N:\n\n                dp[i+1][j + v[i]] = min(dp[i+1][j + v[i]], dp[i][j] + w[i])\n\n            dp[i+1][j] = min(dp[i+1][j], dp[i][j]) \n\n\n\n    ans = 0\n\n    for j in range(max_v * N + 1):\n\n        if dp[N][j] <= W:\n\n            ans = j\n\n\n\n    print(ans)\n\n\n\nif __name__ == \"__main__\":\n\n    main()", "generated_code": "def main():\n\n    N, W = list(map(int, input().split()))\n\n    weight = [0] * N\n\n    value = [0] * N\n\n    for i in range(N):\n\n        weight[i], value[i] = list(map(int, input().split()))\n\n    V = sum(value)\n\n    dp = [[float('inf')] * (V + 5) for _ in range(N + 5)]\n\n    dp[0][0] = 0\n\n    for i in range(N):\n\n        for v in range(V+1):\n\n            if v - value[i] >= 0:\n\n                dp[i+1][v] = min(dp[i][v-value[i]] + weight[i], dp[i][v])\n\n            else:\n\n                dp[i+1][v] = dp[i][v]\n\n    ans = 0\n\n    for v in range(V+1):\n\n        if dp[N][v] <= W:\n\n            ans = v\n\n    print(ans)\n\n\n\nif __name__ == \"__main__\":\n\n    main()", "score": 1.0, "surface_similarity": 0.8826326326326326}
{"id": "p03038_u208713671", "golden_code": "import numpy as np\n\nNM = list(map(int,input().split()))\n\nN = NM[0]\n\nM = NM[1]\n\nA = list(map(int,input().split()))\n\nlistBC =[]\n\nwhile True:\n\n    try:\n\n        listBC.append(list(map(int,input().split())))\n\n    except:\n\n        break;\n\nBC = np.array(listBC)\n\nBCnum = np.argsort(BC[:,1])[::-1]\n\nBC = BC[BCnum,:]\n\n\n\nA.sort()\n\nj=0\n\nfor i in range(len(A)):\n\n    times = BC[j,0]\n\n    if BC[j,0]==0:\n\n        j+=1\n\n        if j == BC.shape[0]:\n\n            break\n\n        times = BC[j,0]\n\n    if A[i]<BC[j,1]:\n\n        A[i]=BC[j,1]\n\n        BC[j,0] += -1\n\noutput = sum(A)\n\nprint(output)", "generated_code": "N,M = list(map(int,input().split()))\n\nA = list(map(int,input().split()))\n\n\n\nfrom collections import Counter\n\nD = dict(Counter(A))\n\n\n\nfor i in range(M):\n\n    B,C = list(map(int,input().split()))\n\n    D[C]=D.get(C,0)+B\n\n\n\nK = sorted(list(D.keys()),reverse=True)\n\n\n\nout = 0\n\ncnt = 0\n\nnow = 0\n\nwhile cnt<=N-1:\n\n    if D[K[now]]>0:\n\n        out += K[now]\n\n        D[K[now]] += -1\n\n        cnt+=1\n\n    else:\n\n        now+=1\n\nprint(out)", "score": 1.0, "surface_similarity": 0.5408016147635525}
{"id": "p03309_u812576525", "golden_code": "n = int(eval(input()))\n\na = list(map(int,input().split()))\n\naa = []\n\nfor i in range(n):\n\n    aa.append(a[i]-(i+1))\n\nb = (sorted(aa)[n//2])\n\n\n\nans = 0\n\nfor i in range(n):\n\n    ans += abs(a[i]-(b+i+1))\n\nprint(ans)", "generated_code": "N= int(eval(input()))\n\nA = list(map(int,input().split()))\n\n\n\nB = []\n\nfor i in range(N):\n\n    B.append(A[i]-(i+1))\n\n#print(B)\n\nb= (sorted(B)[N//2])\n\n#print(b)\n\nans = 0\n\nfor i in range(N):\n\n    ans += abs(B[i]-b)\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.9572072072072072}
{"id": "p02794_u864197622", "golden_code": "N = int(eval(input()))\n\nX = [[] for i in range(N)]\n\nfor i in range(N-1):\n\n    x, y = list(map(int, input().split()))\n\n    X[x-1].append(y-1)\n\n    X[y-1].append(x-1)\n\n\n\nP = [-1] * N\n\nDE = [0] * N\n\nQ = [0]\n\nwhile Q:\n\n    i = Q.pop()\n\n    for a in X[i][::-1]:\n\n        if a != P[i]:\n\n            P[a] = i\n\n            DE[a] = DE[i] + 1\n\n            X[a].remove(i)\n\n            Q.append(a)\n\n\n\ndef lp(u, v):\n\n    t = 0\n\n    while u != v:\n\n        if DE[u] > DE[v]:\n\n            t += 1 << u-1\n\n            u = P[u]\n\n        elif DE[u] < DE[v]:\n\n            t += 1 << v-1\n\n            v = P[v]\n\n        else:\n\n            t += 1 << u-1\n\n            t += 1 << v-1\n\n            u = P[u]\n\n            v = P[v]\n\n    \n\n    return t\n\n\n\nY = []\n\nM = int(eval(input()))\n\nfor _ in range(M):\n\n    a, b = list(map(int, input().split()))\n\n    a, b = a-1, b-1\n\n    Y.append(lp(a, b))\n\n\n\nD = {1<<i: i for i in range(50)}\n\nZ = [0] * (1<<M)\n\nans = 0\n\nCC = [0] * N\n\nBC = [0] * (1<<17)\n\nfor m in range(1, 1<<17):\n\n    a = m & (-m)\n\n    BC[m] = BC[m^a] + 1\n\nfor m in range(1<<M):\n\n    a = m & (-m)\n\n    if a == m:\n\n        if a == 0:\n\n            Z[m] = 0\n\n        else:\n\n            Z[m] = Y[D[a]]\n\n    else:\n\n        Z[m] = Z[m^a] | Y[D[a]]\n\n    \n\n    aa = Z[m]\n\n    bc = BC[aa % (1<<17)]\n\n    aa >>= 17\n\n    bc += BC[aa % (1<<17)]\n\n    aa >>= 17\n\n    bc += BC[aa]\n\n    CC[N - 1 - bc] += (1 if BC[m%1024] + BC[m>>10] & 1 == 0 else -1)\n\n\n\nprint((sum([2 ** i * CC[i] for i in range(N)])))", "generated_code": "N = int(eval(input()))\n\nX = [[] for i in range(N)]\n\nfor i in range(N-1):\n\n    x, y = list(map(int, input().split()))\n\n    X[x-1].append(y-1)\n\n    X[y-1].append(x-1)\n\n\n\nP = [-1] * N\n\nDE = [0] * N\n\nQ = [0]\n\nwhile Q:\n\n    i = Q.pop()\n\n    for a in X[i][::-1]:\n\n        if a != P[i]:\n\n            P[a] = i\n\n            DE[a] = DE[i] + 1\n\n            X[a].remove(i)\n\n            Q.append(a)\n\n\n\ndef lp(u, v):\n\n    t = 0\n\n    while u != v:\n\n        if DE[u] > DE[v]:\n\n            t += 1 << u-1\n\n            u = P[u]\n\n        elif DE[u] < DE[v]:\n\n            t += 1 << v-1\n\n            v = P[v]\n\n        else:\n\n            t += 1 << u-1\n\n            t += 1 << v-1\n\n            u = P[u]\n\n            v = P[v]\n\n    \n\n    return t\n\n\n\nY = []\n\nM = int(eval(input()))\n\nfor _ in range(M):\n\n    a, b = list(map(int, input().split()))\n\n    a, b = a-1, b-1\n\n    Y.append(lp(a, b))\n\n\n\ndef popcnt(n):\n\n    c = (n & 0x5555555555555555) + ((n>>1) & 0x5555555555555555)\n\n    c = (c & 0x3333333333333333) + ((c>>2) & 0x3333333333333333)\n\n    c = (c & 0x0f0f0f0f0f0f0f0f) + ((c>>4) & 0x0f0f0f0f0f0f0f0f)\n\n    c = (c & 0x00ff00ff00ff00ff) + ((c>>8) & 0x00ff00ff00ff00ff)\n\n    c = (c & 0x0000ffff0000ffff) + ((c>>16) & 0x0000ffff0000ffff)\n\n    c = (c & 0x00000000ffffffff) + ((c>>32) & 0x00000000ffffffff)\n\n    return c\n\n\n\nD = {1<<i: i for i in range(50)}\n\nZ = [0] * (1<<M)\n\nans = 0\n\nCC = [0] * N\n\nfor m in range(1<<M):\n\n    a = m & (-m)\n\n    if a == m:\n\n        if a == 0:\n\n            Z[m] = 0\n\n        else:\n\n            Z[m] = Y[D[a]]\n\n    else:\n\n        Z[m] = Z[m^a] | Y[D[a]]\n\n    \n\n    CC[N - 1 - popcnt(Z[m])] += (1 if popcnt(m) & 1 == 0 else -1)\n\n\n\nprint((sum([2 ** i * CC[i] for i in range(N)])))", "score": 1.0, "surface_similarity": 0.8535173160173161}
{"id": "p03720_u638282348", "golden_code": "import numpy as np\n\n\n\nncity, nlines = list(map(int, input().rstrip(\"\\n\").split()))\n\nmatrix = np.zeros((ncity, ncity), dtype=int)\n\nfor _ in range(nlines):\n\n    l, c = [int(x) - 1 for x in input().rstrip(\"\\n\").split()]\n\n    matrix[l][c] += 1\n\n    matrix[c][l] += 1\n\n\n\nfor list_ in matrix:\n\n    print((sum(list_)))", "generated_code": "n, m = map(int, input().split())\n\nroads = [0] * n\n\n[exec(\"roads[%d] += 1; roads[%d] += 1\" % tuple(map(lambda c: int(c) - 1, input().split()))) for _ in range(m)]\n\nprint(*roads, sep=\"\\n\", end=\"\")\n", "score": 1.0, "surface_similarity": 0.4515467346712496}
{"id": "p03273_u732061897", "golden_code": "H, W = list(map(int, input().split()))\n\nHW_list = [list(eval(input())) for i in range(H)]\n\nimport copy\n\n\n\ntmp = copy.deepcopy(HW_list)\n\nh_index = 0\n\nfor i, HW in enumerate(HW_list):\n\n    is_all_shiro = True\n\n    for hw in HW:\n\n        if hw == '#':\n\n            is_all_shiro = False\n\n            h_index += 1\n\n            break\n\n    if is_all_shiro:\n\n        tmp.pop(h_index)\n\nw_index = 0\n\nans = copy.deepcopy(tmp)\n\nfor w in range(W):\n\n    is_all_shiro = True\n\n    for t in tmp:\n\n        if t[w] == '#':\n\n            is_all_shiro = False\n\n            w_index += 1\n\n            break\n\n    if is_all_shiro:\n\n        for a in ans:\n\n            a.pop(w_index)\n\nfor A in ans:\n\n    print((''.join(A)))\n", "generated_code": "H, W = list(map(int, input().split()))\n\nHW_list = [list(eval(input())) for i in range(H)]\n\nimport copy\n\n\n\ntate = [False] * H\n\nyoko = [False] * W\n\n\n\nfor h in range(H):\n\n    for w in range(W):\n\n        if HW_list[h][w] == '#':\n\n            tate[h] = True\n\n            yoko[w] = True\n\n\n\nfor h in range(H):\n\n    tmp = ''\n\n    for w in range(W):\n\n        if tate[h] and yoko[w]:\n\n            tmp += HW_list[h][w]\n\n    if tmp == '':\n\n        continue\n\n    print(tmp)\n", "score": 1.0, "surface_similarity": 0.6760057471264368}
{"id": "p03078_u057109575", "golden_code": "\n\nfrom heapq import heappop, heappush\n\n\n\nX, Y, Z, K = list(map(int, input().split()))\n\nA = list(map(int, input().split()))\n\nB = list(map(int, input().split()))\n\nC = list(map(int, input().split()))\n\n\n\nA.sort(reverse=True)\n\nB.sort(reverse=True)\n\nC.sort(reverse=True)\n\n\n\npq = []\n\nheappush(pq, (-A[0] - B[0] - C[0], 0, 0, 0))\n\nappeared = set((0, 0, 0))\n\n\n\nfor _ in range(K):\n\n    # Pop maximum value\n\n    val, i, j, k = heappop(pq)\n\n    print((-val))\n\n\n\n    # Add next value\n\n    if i + 1 < X and (i + 1, j, k) not in appeared:\n\n        heappush(pq, (-A[i + 1] - B[j] - C[k], i + 1, j, k))\n\n        appeared.add((i + 1, j, k))\n\n\n\n    if j + 1 < Y and (i, j + 1, k) not in appeared:\n\n        heappush(pq, (-A[i] - B[j + 1] - C[k], i, j + 1, k))\n\n        appeared.add((i, j + 1, k))\n\n\n\n    if k + 1 < Z and (i, j, k + 1) not in appeared:\n\n        heappush(pq, (-A[i] - B[j] - C[k + 1], i, j, k + 1))\n\n        appeared.add((i, j, k + 1))\n", "generated_code": "\n\nX, Y, Z, K = list(map(int, input().split()))\n\nA = list(map(int, input().split()))\n\nB = list(map(int, input().split()))\n\nC = list(map(int, input().split()))\n\n\n\nA.sort(reverse=True)\n\nB.sort(reverse=True)\n\nC.sort(reverse=True)\n\n\n\nres = []\n\nfor i in range(X):\n\n    for j in range(Y):\n\n        for k in range(Z):\n\n            if (i + 1) * (j + 1) * (k + 1) <= K:\n\n                res.append(A[i] + B[j] + C[k])\n\n            else:\n\n                break\n\n\n\nres.sort(reverse=True)\n\nfor i in range(K):\n\n    print((res[i]))\n", "score": 1.0, "surface_similarity": 0.613111118810852}
{"id": "p02773_u944325914", "golden_code": "import collections\n\nn = int(eval(input()))\n\na=[eval(input()) for _ in range(n)]\n\nanslist=[]\n\nb=collections.Counter(a)\n\nc=max(list(b.values()))\n\nfor i in b:\n\n    if b[i]==c:\n\n        anslist.append(i)\n\nd=sorted(anslist)\n\nfor i in tuple(d):\n\n    print(i)", "generated_code": "from collections import Counter\n\nn=int(eval(input()))\n\na=[]\n\nfor i in range(n):\n\n  a.append(eval(input()))\n\nac=Counter(a)\n\nacs=sorted(list(ac.items()),key=lambda x:x[1],reverse=1)\n\nz=len(acs)\n\ni=0\n\ntemp=[]\n\n\n\nwhile i<=z-1 and acs[i][1]==acs[0][1] :\n\n  temp.append(acs[i][0])\n\n  i+=1\n\ntemp.sort()\n\nfor i in temp:\n\n  print(i)", "score": 1.0, "surface_similarity": 0.4486349563748945}
{"id": "p03371_u857759499", "golden_code": "a,b,c,x,y = list(map(int,input().split()))\n\nxy = max(x,y)*2+1\n\nprint((min([c*i + max(0,a*(x-i//2)) +max(0,b*(y-i//2)) for i in range(0,xy,2)])))", "generated_code": "a,b,c,x,y = list(map(int,input().split()))\n\nif x < y:\n\n    a, b, x, y = b, a, y, x\n\nprint((min(a*x+b*y,2*c*y + a*(x-y),2*c*x)))", "score": 1.0, "surface_similarity": 0.6243055555555556}
{"id": "p02412_u628732336", "golden_code": "while True:\n\n    n, x = [int(i) for i in input().split()]\n\n\n\n    if n == x == 0:\n\n        break\n\n\n\n    count = 0\n\n    for s in range(1, n - 1):\n\n        for m in range(s + 1, n):\n\n            for e in range(m + 1, n + 1):\n\n                if x == sum([s, m, e]):\n\n                    count += 1\n\n\n\n    print(count)", "generated_code": "while True:\n\n    n, x = [int(i) for i in input().split()]\n\n\n\n    if n == x == 0:\n\n        break\n\n\n\n    count = 0\n\n    for s in range(1, n - 1):\n\n        for m in range(s + 1, n):\n\n            for e in range(m + 1, n + 1):\n\n                if x == s+m+e:\n\n                    count += 1\n\n\n\n    print(count)", "score": 1.0, "surface_similarity": 0.9639296593741347}
{"id": "p02837_u867826040", "golden_code": "n = int(eval(input()))\n\nv = [[tuple(map(int, input().split()))for i in range(int(eval(input())))]\n\n     for i in range(n)]\n\n\n\nans = 0\n\nfor i in range(2**n):\n\n    f = [False] * n\n\n    xy = []\n\n    for j in range(n):\n\n        if (i >> j) & 1:\n\n            f[j] = True\n\n            xy.append(v[j])\n\n    flag = True\n\n    for xyi in xy:\n\n        for x, y in xyi:\n\n            if f[x - 1] is not bool(y):\n\n                flag = False\n\n                break\n\n    if flag:\n\n        ans = max(ans, len(xy))\n\nprint(ans)\n", "generated_code": "n = int(eval(input()))\n\nv = [[tuple(map(int, input().split()))for i in range(int(eval(input())))]\n\n     for i in range(n)]\n\n\n\nans = 0\n\nfor i in range(2**n):\n\n    f = [0] * n\n\n    xy = []\n\n    for j in range(n):\n\n        if (i >> j) & 1:\n\n            f[j] = 1\n\n            xy.append(v[j])\n\n    flag = True\n\n    for xyi in xy:\n\n        for x, y in xyi:\n\n            #print(f,x,y,bin(i))\n\n            if (i>>(x-1))&1 != y:\n\n                flag = False\n\n                break\n\n    if flag:\n\n        ans = max(ans, len(xy))\n\nprint(ans)\n", "score": 1.0, "surface_similarity": 0.938526872737399}
{"id": "p03000_u102461423", "golden_code": "N,X = list(map(int,input().split()))\n\nL = [0] + [int(x) for x in input().split()]\n\n\n\nD = [0] * (N+2)\n\nanswer = 1\n\nfor n in range(2,N+2):\n\n  D[n] = D[n-1] + L[n-1]\n\n  if D[n] <= X:\n\n    answer += 1\n\n    \n\nprint(answer)", "generated_code": "import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\nimport itertools\n\n\n\nN,X,*L = list(map(int,read().split()))\n\n\n\nanswer = sum(x <= X for x in itertools.accumulate([0]+L))\n\nprint(answer)", "score": 1.0, "surface_similarity": 0.4400111607142857}
{"id": "p02983_u133936772", "golden_code": "mod = 2019\n\nl, r = list(map(int, input().split()))\n\n\n\nif r//mod - l//mod > 0:\n\n  print((0))\n\nelse:\n\n  l %= mod\n\n  r %= mod\n\n  ans = mod\n\n  for i in range(l+1, r+1):\n\n    for j in range(l, i):\n\n      ans = min(i*j%mod, ans)\n\n    if ans == 0:\n\n      break\n\n  print(ans)", "generated_code": "mod = 2019\n\nl, r = list(map(int, input().split()))\n\n\n\nif r//mod - l//mod > 0:\n\n  print((0))\n\nelse:\n\n  l %= mod\n\n  r %= mod\n\n  ans = mod\n\n  for i in range(l, r):\n\n    for j in range(i+1, r+1):\n\n      ans = min(i*j%mod, ans)\n\n    if ans == 0:\n\n      break\n\n  print(ans)", "score": 1.0, "surface_similarity": 0.9812734082397003}
{"id": "p03425_u998741086", "golden_code": "#!/usr/bin/env python3\n\n\n\nn = int(eval(input()))\n\ns = [eval(input()) for _ in range(n)]\n\n\n\nc = [0 for _ in range(5)]\n\nt = 'MARCH'\n\n\n\nfor i in range(n):\n\n    for j in range(5):\n\n        if s[i][0] == t[j]:\n\n            c[j] += 1\n\nans = 0 \n\nfor i in range(5):\n\n    for j in range(i+1, 5): \n\n        for k in range(j+1, 5): \n\n            ans += c[i]*c[k]*c[j]\n\nprint(ans)\n", "generated_code": "#!/usr/bin/env python3\n\n\n\nn = int(eval(input()))\n\ns = [eval(input()) for _ in range(n)]\n\nd = {}\n\n\n\nfor c in s:\n\n    if c[0] not in d:\n\n        d[c[0]] = 1 \n\n    else:\n\n        d[c[0]] += 1\n\n\n\ntmp = d.copy()\n\nt = ['M', 'A', 'R', 'C', 'H']\n\nfor c in tmp:\n\n    if c not in t:\n\n        d.pop(c)\n\n\n\nans = 0 \n\ndlist = list(d.items())\n\nfor i in range(len(dlist)):\n\n    for j in range(i+1, len(dlist)):\n\n        for k in range(j+1, len(dlist)):\n\n            ans += dlist[i][1]*dlist[j][1]*dlist[k][1]\n\nprint(ans)\n", "score": 1.0, "surface_similarity": 0.7176155115511551}
{"id": "p00053_u661290476", "golden_code": "prim=[True]*1000000\n\nprim[0],prim[1]=False,False\n\nfor i in range(2,1000):\n\n    if prim[i]:\n\n        for j in range(i*2,1000000,i):\n\n            prim[j]=False\n\nprime=[i for i,j in enumerate(prim) if j==True]\n\n\n\nwhile True:\n\n    n=int(eval(input()))\n\n    if n==0:\n\n        break\n\n    print((sum(prime[:n])))", "generated_code": "prim=[True]*1000000\n\nprim[0]=prim[1]=False\n\nfor i in range(2,350):\n\n    if prim[i]:\n\n        for j in range(i*2,110000,i):\n\n            prim[j]=False\n\nprime=[i for i,j in enumerate(prim) if j==True]\n\n\n\nwhile True:\n\n    n=int(eval(input()))\n\n    if n==0:\n\n        break\n\n    print((sum(prime[:n])))", "score": 1.0, "surface_similarity": 0.980327868852459}
{"id": "p03162_u113971909", "golden_code": "import sys\n\ninput = sys.stdin.readline\n\nimport numpy as np\n\nN = int(eval(input()))\n\ndp = np.zeros((N+1,3), dtype=np.int)\n\nX = list(map(int, input().split()))\n\nfor _ in range(3):\n\n  dp[1][_] = X[_]\n\nfor n in range(2,N+1):\n\n  X = list(map(int, input().split()))\n\n  dp[n][0] = max(dp[n-1][1],dp[n-1][2]) + X[0]\n\n  dp[n][1] = max(dp[n-1][2],dp[n-1][0]) + X[1]\n\n  dp[n][2] = max(dp[n-1][0],dp[n-1][1]) + X[2]\n\nprint((max(dp[N])))", "generated_code": "#!/usr/bin python3\n\n# -*- coding: utf-8 -*-\n\n\n\ndef main():\n\n    N = int(eval(input()))\n\n    dp = [[0]*3 for i in range(N+1)]\n\n    #dp[i][j] iまでで、j=0はaを選ぶ,j=1はbを選ぶ,j=2はcを選ぶ\n\n    for i in range(1,N+1):\n\n        a, b, c=list(map(int,input().split()))\n\n        dp[i][0] = max(dp[i-1][1]+a, dp[i-1][2]+a, dp[i][0])\n\n        dp[i][1] = max(dp[i-1][2]+b, dp[i-1][0]+b, dp[i][1])\n\n        dp[i][2] = max(dp[i-1][0]+c, dp[i-1][1]+c, dp[i][2])\n\n\n\n    print((max(dp[N])))\n\n\n\nif __name__ == '__main__':\n\n    main()", "score": 1.0, "surface_similarity": 0.5815310187820147}
{"id": "p03037_u347600233", "golden_code": "n, m = list(map(int, input().split()))\n\ngate = []\n\nl, r = list(map(int, input().split()))\n\nfor i in range(1, m):\n\n    m, s = list(map(int, input().split()))\n\n    if l < m:\n\n        l = m\n\n    if s < r:\n\n        r = s\n\nprint((len([i for i in range(l, r + 1)])))", "generated_code": "n, m = list(map(int, input().split()))\n\nl, r = [0] * m, [0] * m\n\nfor i in range(m):\n\n    l[i], r[i] = list(map(int, input().split()))\n\nprint((max(min(r) - max(l) + 1, 0)))", "score": 1.0, "surface_similarity": 0.6408862876254181}
{"id": "p02596_u585963734", "golden_code": "K=int(eval(input()))\n\n\n\nif K%2==0:\n\n    print((-1))\n\n    exit(0)\n\n    \n\nans=[0]*(pow(10,6)+1)\n\nans[0]=0\n\n\n\nfor i in range(1,pow(10,6)):\n\n    ans[i]=(ans[i-1]*10+7)%K\n\n    if ans[i]==0:\n\n        print(i)\n\n        exit(0)\n\n\n\nprint((-1))", "generated_code": "import functools\n\n\n\nK=int(eval(input()))\n\n \n\nif K%2==0:\n\n    print((-1))\n\n    exit(0)\n\n\n\nmod=0\n\n\n\nfor i in range(1,pow(10,6)):\n\n    mod=(mod*10+7)%K\n\n    if mod==0:\n\n        print(i)\n\n        exit(0)\n\n        \n\nprint((-1))", "score": 1.0, "surface_similarity": 0.7403846153846154}
{"id": "p02537_u311379832", "golden_code": "def segfunc(x, y): return max(x, y)\n\n\n\nclass SegmentTree:\n\n    def __init__(self, arr):\n\n        size = len(arr)\n\n        n = 2 ** (size - 1).bit_length()\n\n        self.n = n\n\n        self.node = [0] * (2*n)\n\n        for i in range(size):\n\n            self.node[i+n-1] = arr[i]\n\n        for i in reversed(list(range(n-2))):\n\n            self.node[i] = segfunc(self.node[2*i+1], self.node[2*i+2])\n\n\n\n    def update(self, i, x):\n\n        i += self.n - 1\n\n        self.node[i] = x\n\n        while i > 0:\n\n            i = (i - 1) // 2\n\n            self.node[i] = segfunc(self.node[i * 2 + 1], self.node[i * 2 + 2])\n\n\n\n    def update(self, x, val):\n\n        x += (self.n - 1)\n\n        self.node[x] = val\n\n        while x > 0:\n\n            x = (x - 1) // 2\n\n            self.node[x] = segfunc(self.node[2 * x + 1], self.node[2 * x + 2])\n\n\n\n    def query(self, a, b):\n\n        res = 0\n\n        l = self.n - 1 + a\n\n        r = self.n - 1 + (b - 1)\n\n\n\n        while l <= r:\n\n            if l == r:\n\n                res = segfunc(res, self.node[l])\n\n                break\n\n\n\n            if l % 2 == 0:\n\n                res = segfunc(res, self.node[l])\n\n            if r % 2 == 1:\n\n                res = segfunc(res, self.node[r])\n\n            l = l // 2\n\n            r = r // 2 - 1\n\n\n\n        return res\n\n\n\nN, K = list(map(int, input().split()))\n\nINF = 0\n\nseg = SegmentTree([0] * 300000)\n\nfor i in range(N):\n\n    a = int(eval(input()))\n\n    tmp = seg.query(max(a - K, 0), min(a + K, 300000) + 1) + 1\n\n    seg.update(a, tmp)\n\nprint((seg.query(0, 300000)))\n", "generated_code": "def segfunc(x, y): return max(x, y)\n\ndef update(i, x):\n\n    i += MAX_N-1\n\n    node[i] = x\n\n    while i:\n\n        i = (i-1)//2\n\n        node[i] = segfunc(node[i*2+1], node[i*2+2])\n\n\n\ndef query(l, r):\n\n    L = l + MAX_N\n\n    R = r + MAX_N\n\n    s = INF\n\n    while L < R:\n\n        if R & 1:\n\n            R -= 1\n\n            s = segfunc(s, node[R - 1])\n\n        if L & 1:\n\n            s = segfunc(s, node[L - 1])\n\n            L += 1\n\n        L >>= 1\n\n        R >>= 1\n\n    return s\n\n\n\nN, K = list(map(int, input().split()))\n\nMAX_N = 2**(300005).bit_length()\n\na = [int(eval(input())) for _ in range(N)]\n\nnode = [0] * (2 * MAX_N)\n\nINF = 0\n\nans = 0\n\n\n\n#for i in range(N):\n\n#    update(i, a[i])\n\n\n\nfor i in a:\n\n    tmp = query(max(i - K, 0), min(300005, i + K) + 1)\n\n    update(i, tmp + 1)\n\n    ans = max(ans, tmp + 1)\n\nprint(ans)\n", "score": 1.0, "surface_similarity": 0.6416816128603693}
{"id": "p02899_u461833298", "golden_code": "import numpy as np\n\nN = int(eval(input()))\n\nA = [int(x) for x in input().split()]\n\n\n\ntmp = [x for x in zip(A, list(range(1, N+1)))]\n\ntmp = np.array(sorted(tmp))\n\nprint((*tmp[:,1]))", "generated_code": "N = int(eval(input()))\n\nA = [int(x) for x in input().split()]\n\nB = [0 for _ in range(N)]\n\nfor i in range(N):\n\n    B[A[i]-1] = i+1\n\nprint((*B))", "score": 1.0, "surface_similarity": 0.6608585858585858}
{"id": "p03037_u188827677", "golden_code": "N,M = list(map(int, input().split()))\n\nL = []\n\nR = []\n\nfor _ in range(M):\n\n  l,r = list(map(int, input().split()))\n\n  L.append(l)\n\n  R.append(r)\n\n\n\nans = min(R)-max(L)+1\n\nif ans < 0:\n\n  print((0))\n\nelse:\n\n  print(ans)\n\n  ", "generated_code": "n,m = list(map(int, input().split()))\n\nmax_l = float(\"-inf\")\n\nmin_r = float(\"inf\")\n\nfor _ in range(m):\n\n  l,r = list(map(int, input().split()))\n\n  max_l = max(max_l, l)\n\n  min_r = min(min_r, r)\n\nans = min_r - max_l + 1\n\nif ans > 0:\n\n  print(ans)\n\nelse:\n\n  print((0))", "score": 1.0, "surface_similarity": 0.768796992481203}
{"id": "p03273_u989345508", "golden_code": "import numpy as np\n\nh,w=input().split()\n\nh,w=int(h),int(w)\n\nx3=[]\n\nfor i in range(h):\n\n    x1=input()\n\n    if x1 !=  w*\".\":\n\n        x3.append(list(x1))\n\n\n\nx3=np.array(x3).T.tolist()\n\nx4=[]\n\nfor i in range(w):\n\n    if x3[i] != [\".\" for i in range(len(x3[i]))]:\n\n        x4.append(x3[i])\n\n\n\nx4=np.array(x4).T.tolist()\n\nfor i in range(len(x4)):\n\n    for j in range(len(x4[0])):\n\n        print(x4[i][j],end=\"\")\n\n    print()\n", "generated_code": "h,w=list(map(int,input().split()))\n\na=[]\n\nfor i in range(h):\n\n    k=eval(input())\n\n    if k!=\".\"*w:\n\n        a.append(k)\n\nl=len(a)\n\n#print(a)\n\nans=[[] for i in range(l)]\n\nfor i in range(w):\n\n    for j in range(l):\n\n        if a[j][i]==\"#\":\n\n            for k in range(l):\n\n                ans[k].append(a[k][i])\n\n            break\n\nfor i in range(l):\n\n    print((\"\".join(ans[i])))", "score": 1.0, "surface_similarity": 0.6698794080029234}
{"id": "p02595_u945359338", "golden_code": "from decimal import *\n\ngetcontext().prec = 14\n\n\n\nN, D = list(map(int, input().split()))\n\n\n\n\n\ndef distance(x1, x2, y1, y2):\n\n    dx = x2-x1\n\n    dy = y2-y1\n\n    return (dx*dx + dy*dy).sqrt()\n\n\n\n\n\nX = [0] * N\n\nY = [0] * N\n\nans = 0\n\nfor i in range(N):\n\n    X[i], Y[i] = list(map(Decimal, input().split()))\n\n    if (distance(0, X[i], 0, Y[i]) <= D):\n\n        ans += 1\n\n\n\nprint(ans)\n", "generated_code": "from decimal import *\n\ngetcontext().prec = 14  # あんまり大きいと計算遅いかも\n\n\n\nN, D = list(map(int, input().split()))\n\n\n\ndef distance(x1, x2, y1, y2):\n\n    dx = x2-x1\n\n    dy = y2-y1\n\n    return (dx*dx + dy*dy).sqrt()\n\n\n\nans = 0\n\nfor i in range(N):\n\n    X, Y = list(map(Decimal, input().split()))\n\n    if (distance(0, X, 0, Y) <= D):\n\n        ans += 1\n\n\n\nprint(ans)\n", "score": 1.0, "surface_similarity": 0.9093915343915344}
{"id": "p03325_u803617136", "golden_code": "N = int(eval(input()))\n\n\n\nseq = list(map(int, input().split()))\n\n\n\ncnt = 0\n\n\n\nfor num in seq:\n\n    while num % 2 == 0:\n\n        cnt += 1\n\n        num /= 2\n\n\n\nprint(cnt)\n", "generated_code": "n = int(eval(input()))\n\na = list(map(int, input().split()))\n\nans = 0\n\nfor num in a:\n\n    ans += format(num, 'b')[::-1].find('1')\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.6484669176976869}
{"id": "p03371_u564589929", "golden_code": "import sys\n\nsys.setrecursionlimit(10 ** 6)\n\n# input = sys.stdin.readline    ####\n\nint1 = lambda x: int(x) - 1\n\ndef II(): return int(eval(input()))\n\n\n\ndef MI(): return list(map(int, input().split()))\n\ndef MI1(): return list(map(int1, input().split()))\n\n\n\ndef LI(): return list(map(int, input().split()))\n\ndef LI1(): return list(map(int1, input().split()))\n\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\n\n\n\ndef printlist(lst, k='\\n'): print((k.join(list(map(str, lst)))))\n\nINF = float('inf')\n\n\n\ndef solve():\n\n    a, b, c, x, y = MI()\n\n\n\n    ans = INF\n\n    for k in range(100001):\n\n        yen = 2 * c * k + max(0, x-k) * a + max(0, y-k) * b\n\n        ans = min(ans, yen)\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    solve()\n", "generated_code": "import sys\n\nsys.setrecursionlimit(10 ** 6)\n\n# input = sys.stdin.readline    ####\n\nint1 = lambda x: int(x) - 1\n\ndef II(): return int(eval(input()))\n\n\n\ndef MI(): return list(map(int, input().split()))\n\ndef MI1(): return list(map(int1, input().split()))\n\n\n\ndef LI(): return list(map(int, input().split()))\n\ndef LI1(): return list(map(int1, input().split()))\n\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\n\n\n\ndef printlist(lst, k='\\n'): print((k.join(list(map(str, lst)))))\n\nINF = float('inf')\n\n\n\ndef solve():\n\n    a, b, c, x, y = MI()\n\n\n\n    ans = 0\n\n    if a + b <= 2 * c:\n\n        mn = min(x, y)\n\n        ans = a * mn + b * mn + max(0, x-mn) * min(a, 2*c) + max(0, y-mn) * min(b, 2*c)\n\n\n\n    else:\n\n        mn = min(x, y)\n\n        ans = mn * 2 * c + max(0, x-mn) * min(a, 2*c) + max(0, y-mn) * min(b, 2*c)\n\n\n\n    print(ans)\n\n\n\n\n\n\n\nif __name__ == '__main__':\n\n    solve()\n", "score": 1.0, "surface_similarity": 0.8990757999378689}
{"id": "p03796_u186838327", "golden_code": "import math\n\nn = int(eval(input()))\n\nprint((math.factorial(n)%(10**9+7)))", "generated_code": "n = int(eval(input()))\n\nans = 1\n\nmod = 10**9+7\n\nfor i in range(1, n+1):\n\n    ans *= i\n\n    ans %= mod\n\n\n\nans %= mod\n\nprint(ans)\n", "score": 1.0, "surface_similarity": 0.5442708333333333}
{"id": "p03845_u014333473", "golden_code": "n,t=int(input()),list(map(int,input().split()));T=sum(t)\n\nprint(*[T-t[i-1]+j for i,j in [list(map(int,input().split())) for _ in range(int(input()))]],sep='\\n')\n", "generated_code": "input();t=list(map(int,input().split()));T=sum(t)\n\nprint(*[T-t[i-1]+j for i,j in [list(map(int,input().split())) for _ in range(int(input()))]],sep='\\n')\n", "score": 1.0, "surface_similarity": 0.9658385093167702}
{"id": "p03363_u906501980", "golden_code": "n = int(eval(input()))\n\nA = [int(i) for i in input().split()]\n\nS = [0]*(n+1)\n\nnum={}\n\nfor i in range(n):\n\n    S[i+1] = S[i] + A[i]\n\nfor i in S:\n\n    if str(i) in list(num.keys()):\n\n        num[str(i)] += 1\n\n    else:\n\n        num[str(i)] = 1\n\nout = [i*(i-1)//2 for i in list(num.values()) if i>1]\n\nprint((sum(out)))", "generated_code": "n = int(eval(input()))\n\nA = [int(i) for i in input().split()]\n\nS = [0]*(n+1)\n\nnum = {}\n\nfor i in range(n):\n\n    S[i+1] = S[i] + A[i]\n\nfor i in S:\n\n    s = str(i)\n\n    num[s] = 1 if s not in list(num.keys()) else num[s]+1\n\nout = [i*(i-1)//2 for i in list(num.values()) if i > 1]\n\nprint((sum(out)))", "score": 1.0, "surface_similarity": 0.8456349206349206}
{"id": "p02555_u805332733", "golden_code": "def resolve():\n\n  base = 10**9+7\n\n  S = int(eval(input()))\n\n  dp = [0] * (S+1)\n\n  dp[0] = 1\n\n\n\n  for i in range(1, S+1):\n\n    for u in range(i-2):\n\n      dp[i] += dp[u]\n\n      dp[i] %= base\n\n  # print(dp)\n\n  print((dp[S]%base))\n\n\n\nif __name__ == \"__main__\":\n\n  resolve()\n", "generated_code": "def resolve():\n\n  base = 10**9+7\n\n  S = int(eval(input()))\n\n  dp = [0] * (S+1)\n\n  dp[0] = 1\n\n\n\n  for i in range(3, S+1):\n\n    dp[i] = dp[i-1] + dp[i-3]\n\n  # print(dp)\n\n  print((dp[S]%base))\n\n\n\nif __name__ == \"__main__\":\n\n  resolve()", "score": 1.0, "surface_similarity": 0.9219710947109472}
{"id": "p02604_u340781749", "golden_code": "import os\n\nimport sys\n\n\n\nimport numpy as np\n\n\n\n\n\ndef solve(n, precalc_x, precalc_y):\n\n    ans = np.full(n + 1, 10 ** 18, dtype=np.int64)\n\n\n\n    def get_cost(v, bit):\n\n        cost = 0\n\n        pcx = precalc_x[v]\n\n        pcy = precalc_y[v ^ bit]\n\n        for i in range(n):\n\n            if v & (1 << i):\n\n                continue\n\n            cost += min(pcx[i], pcy[i])\n\n        return cost\n\n\n\n    for bit in range(1 << n):\n\n        k = (bit & 0x5555) + (bit >> 1 & 0x5555)\n\n        k = (k & 0x3333) + (k >> 2 & 0x3333)\n\n        k = (k & 0x0f0f) + (k >> 4 & 0x0f0f)\n\n        k = (k & 0x00ff) + (k >> 8 & 0x00ff)\n\n        v = bit\n\n        while v:\n\n            ans[k] = min(ans[k], get_cost(v, bit))\n\n            v = (v - 1) & bit\n\n        ans[k] = min(ans[k], get_cost(0, bit))\n\n\n\n    return ans\n\n\n\n\n\nif sys.argv[-1] == 'ONLINE_JUDGE':\n\n    from numba.pycc import CC\n\n\n\n    cc = CC('my_module')\n\n    cc.export('solve', '(i8, i8[:,:], i8[:,:])')(solve)\n\n    cc.compile()\n\n    exit()\n\n\n\nif os.name == 'posix':\n\n    # noinspection PyUnresolvedReferences\n\n    from my_module import solve\n\nelse:\n\n    from numba import njit\n\n\n\n    solve = njit('(i8, i8[:,:], i8[:,:])', cache=True)(solve)\n\n    print('compiled', file=sys.stderr)\n\n\n\ninp = np.fromstring(sys.stdin.read(), dtype=np.int64, sep=' ')\n\nn = inp[0]\n\nxxx = inp[1::3]\n\nyyy = inp[2::3]\n\nppp = inp[3::3]\n\n\n\nbit_d = (((np.arange(1 << n)[:, None] & (1 << np.arange(n)))) > 0).astype(np.int64)\n\nprecalc_x = abs((xxx[None, :] * bit_d)[..., None] - xxx[None, None, :]).min(axis=1) * ppp[None, :]\n\nprecalc_y = abs((yyy[None, :] * bit_d)[..., None] - yyy[None, None, :]).min(axis=1) * ppp[None, :]\n\n\n\nans = solve(n, precalc_x, precalc_y)\n\nprint('\\n'.join(map(str, ans)))\n", "generated_code": "import os\n\nimport sys\n\n\n\nimport numpy as np\n\n\n\n\n\ndef solve(n, precalc_x, precalc_y):\n\n    ans = np.full(n + 1, 10 ** 18, dtype=np.int64)\n\n\n\n    def get_cost(v, bit):\n\n        cost = 0\n\n        pcx = precalc_x[v]\n\n        pcy = precalc_y[v ^ bit]\n\n        for i in range(n):\n\n            cost += min(pcx[i], pcy[i])\n\n        return cost\n\n\n\n    for bit in range(1 << n):\n\n        k = (bit & 0x5555) + (bit >> 1 & 0x5555)\n\n        k = (k & 0x3333) + (k >> 2 & 0x3333)\n\n        k = (k & 0x0f0f) + (k >> 4 & 0x0f0f)\n\n        k = (k & 0x00ff) + (k >> 8 & 0x00ff)\n\n        v = bit\n\n        while v:\n\n            ans[k] = min(ans[k], get_cost(v, bit))\n\n            v = (v - 1) & bit\n\n        ans[k] = min(ans[k], get_cost(0, bit))\n\n\n\n    return ans\n\n\n\n\n\nif sys.argv[-1] == 'ONLINE_JUDGE':\n\n    from numba.pycc import CC\n\n\n\n    cc = CC('my_module')\n\n    cc.export('solve', '(i8, i8[:,:], i8[:,:])')(solve)\n\n    cc.compile()\n\n    exit()\n\n\n\nif os.name == 'posix':\n\n    # noinspection PyUnresolvedReferences\n\n    from my_module import solve\n\nelse:\n\n    from numba import njit\n\n\n\n    solve = njit('(i8, i8[:,:], i8[:,:])', cache=True)(solve)\n\n    print('compiled', file=sys.stderr)\n\n\n\ninp = np.fromstring(sys.stdin.read(), dtype=np.int64, sep=' ')\n\nn = inp[0]\n\nxxx = inp[1::3]\n\nyyy = inp[2::3]\n\nppp = inp[3::3]\n\n\n\nbit_d = (((np.arange(1 << n)[:, None] & (1 << np.arange(n)))) > 0).astype(np.int64)\n\nprecalc_x = abs((xxx[None, :] * bit_d)[..., None] - xxx[None, None, :]).min(axis=1) * ppp[None, :]\n\nprecalc_y = abs((yyy[None, :] * bit_d)[..., None] - yyy[None, None, :]).min(axis=1) * ppp[None, :]\n\n\n\nans = solve(n, precalc_x, precalc_y)\n\nprint('\\n'.join(map(str, ans)))\n", "score": 1.0, "surface_similarity": 0.9816788570452799}
{"id": "p03494_u490552503", "golden_code": "import numpy as np\n\nN = int(eval(input()))\n\nA = list(map(int, input().split()))\n\nA = np.array(A)\n\ncount = 0\n\nwhile 1:\n\n    x = 0\n\n    for i in range(N):\n\n        if A[i] % 2 == 1:\n\n            x = 1\n\n    if x == 1:\n\n        break\n\n    else:\n\n        A = A / 2\n\n        count+=1\n\nprint(count)", "generated_code": "import math\n\nn = eval(input())\n\na = list(map(int, input().split()))\n\nans = float('inf')\n\nfor i in a:\n\n    ans = min(ans, len(bin(i)) - bin(i).rfind('1') - 1)\n\nprint((round(ans)))", "score": 1.0, "surface_similarity": 0.5761512027491409}
{"id": "p02792_u922449550", "golden_code": "N = int(eval(input()))\n\n\n\ntable = [[0]*10 for i in range(10)]\n\n\n\nfor i in range(1, N+1):\n\n  s = str(i)\n\n  id1 = int(s[0])\n\n  id2 = int(s[-1])\n\n  table[id1][id2] += 1\n\n\n\nans = 0\n\nfor i in range(10):\n\n  for j in range(10):\n\n    ans += table[i][j]*table[j][i]\n\n\n\nprint(ans)", "generated_code": "N = eval(input())\n\nm = len(N)\n\n\n\na0 = int(N[0])\n\na1 = int(N[-1])\n\n\n\nans = 0\n\nif m == 1:\n\n  ans = int(N)\n\nelse:\n\n  mid = (int(N[1:]) - a1)//10\n\n  t = 10**(m-2)\n\n  ans = 9\n\n  ans += ((a0-1)*t) * 2\n\n  ans += (mid + (a1>=a0)) * 2\n\n  ans += ((a0-1)*t)**2\n\n  ans += ((mid*(a0-1) + min(a0-1, a1))*t) * 2\n\n  ans += (mid + (a1>=a0))**2\n\n  if m >= 3:\n\n    ans += (t - 1) * 2\n\n    ans += ((a0-1)*(t - 1)*t) * 2\n\n    ans += (mid * (t - 1)) * 2\n\n    ans += (a1 * (t - 1)//9) * 2\n\n    ans += (t - 1)**2\n\n\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.5257541263517359}
{"id": "p03796_u450904670", "golden_code": "n = int(eval(input()))\n\nres = 1\n\nfor num in range(1, n+1):\n\n  res = res * num\n\n  res = res % (pow(10,9) + 7)\n\nprint(res)", "generated_code": "n = int(eval(input()))\n\nres = 1\n\nfor num in range(1, n+1):\n\n    res = res * num\n\n    res = res % (10**9 + 7)\n\nprint(res)\n", "score": 1.0, "surface_similarity": 0.9353600944510035}
{"id": "p03371_u333190709", "golden_code": "#!/usr/bin/env python3\n\nimport sys, math, fractions, itertools\n\n\n\n\n\ndef solve(A: int, B: int, C: int, X: int, Y: int):\n\n    mn = 1e9\n\n    for i in range(0, 2*(max(X, Y)+1), 2):\n\n        mn = min(mn, C*i+A*max(X-i//2, 0)+B*max(Y-i//2, 0))\n\n    print((int(mn)))\n\n    return\n\n\n\n\n\n# Generated by 1.1.4 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)\n\ndef main():\n\n    def iterate_tokens():\n\n        for line in sys.stdin:\n\n            for word in line.split():\n\n                yield word\n\n    tokens = iterate_tokens()\n\n    A = int(next(tokens))  # type: int\n\n    B = int(next(tokens))  # type: int\n\n    C = int(next(tokens))  # type: int\n\n    X = int(next(tokens))  # type: int\n\n    Y = int(next(tokens))  # type: int\n\n    solve(A, B, C, X, Y)\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "generated_code": "#!/usr/bin/env python3\n\nimport sys\n\n\n\n\n\ndef solve(A: int, B: int, C: int, X: int, Y: int):\n\n    c = 0\n\n    if (A + B < 2 * C):\n\n        c += min(X, Y) * (A + B)\n\n    else:\n\n        c += min(X, Y) * 2 * C\n\n    if X > Y:\n\n        c += (X - Y) * min(A, 2 * C)\n\n    else:\n\n        c += (Y - X) * min(B, 2 * C)\n\n    print(c)\n\n    return\n\n\n\n\n\n# Generated by 1.1.5 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)\n\ndef main():\n\n    def iterate_tokens():\n\n        for line in sys.stdin:\n\n            for word in line.split():\n\n                yield word\n\n    tokens = iterate_tokens()\n\n    A = int(next(tokens))  # type: int\n\n    B = int(next(tokens))  # type: int\n\n    C = int(next(tokens))  # type: int\n\n    X = int(next(tokens))  # type: int\n\n    Y = int(next(tokens))  # type: int\n\n    solve(A, B, C, X, Y)\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 1.0, "surface_similarity": 0.8669348717170183}
{"id": "p03038_u597455618", "golden_code": "import sys\n\nfrom operator import itemgetter\n\n\n\nn, m = list(map(int, input().split()))\n\na = list(map(int, sys.stdin.readline().split()))\n\nbc = [ tuple(map(int, x.split())) for x in sys.stdin.readlines()]\n\nbc.sort(key = itemgetter(1), reverse=True)\n\nbc.append((n,0))\n\ndiff = []\n\nfor b, c in bc:\n\n    diff += [c] * b\n\n    if len(diff) > n:\n\n        break\n\n\n\na += diff\n\na.sort()\n\nprint((sum(a[-n:])))\n", "generated_code": "import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nfrom operator import itemgetter\n\n\n\nn, m = list(map(int, readline().split()))\n\na = list(map(int, readline().split()))\n\nm = list(map(int, read().split()))\n\nbc = list(zip(m,m))\n\n\n\nbc.sort(key = itemgetter(1), reverse=True)\n\nbc.append((n,0))\n\ndiff = []\n\nfor b, c in bc:\n\n    diff += [c] * b\n\n    if len(diff) > n:\n\n        break\n\n\n\na += diff\n\na.sort()\n\nprint((sum(a[-n:])))\n", "score": 1.0, "surface_similarity": 0.8344444444444444}
{"id": "p02917_u498487134", "golden_code": "N = int(eval(input()))\n\nB =list(map(int,input().split()))\n\nA=[0]*N\n\n\n\nA[0]=B[0]\n\nfor i in range(1,N-1):\n\n    A[i]=min(B[i],B[i-1])\n\nA[-1]=B[-1]\n\nprint((sum(A)))", "generated_code": "import sys\n\ninput = sys.stdin.readline\n\n\n\ndef I(): return int(eval(input()))\n\ndef MI(): return list(map(int, input().split()))\n\ndef LI(): return list(map(int, input().split()))\n\n\n\ndef main():\n\n    mod=10**9+7\n\n    N=I()\n\n    B=LI()\n\n    A=[0]*N\n\n    A[0]=B[0]\n\n    A[-1]=B[-1]\n\n    for i in range(N-2):\n\n        A[i+1]=min(B[i],B[i+1])\n\n        \n\n    print((sum(A)))\n\n\n\nmain()\n", "score": 1.0, "surface_similarity": 0.6225994694960212}
{"id": "p02700_u047796752", "golden_code": "import sys\n\ninput = sys.stdin.readline\n\nfrom collections import *\n\n\n\nA, B, C, D = list(map(int, input().split()))\n\n\n\nwhile True:\n\n    C -= B\n\n    \n\n    if C<=0:\n\n        print('Yes')\n\n        exit()\n\n    \n\n    A -= D\n\n    \n\n    if A<=0:\n\n        print('No')\n\n        exit()", "generated_code": "A, B, C, D = list(map(int, input().split()))\n\nc1 = (C+B-1)//B\n\nc2 = (A+D-1)//D\n\n\n\nif c1<=c2:\n\n    print('Yes')\n\nelse:\n\n    print('No')", "score": 1.0, "surface_similarity": 0.6148851148851149}
{"id": "p03575_u576432509", "golden_code": "icase=0\n\nif icase==0:\n\n    n,m=list(map(int, input().split()))\n\n    a=[]\n\n    b=[]\n\n    for i in range(m):\n\n        ai,bi=list(map(int, input().split()))\n\n        a.append(ai)\n\n        b.append(bi)\n\nelif icase==1:\n\n    n=6\n\n    m=5\n\n#    a=[[1],[2],[3],[4],[5]]\n\n#    b=[[2],[3],[4],[5],[6]]\n\n    a=[1,2,3,4,5]\n\n    b=[2,3,4,5,6]\n\nelif icase==2:\n\n    n=7\n\n    m=7\n\n    a=[1,2,3,4,4,5,6]\n\n    b=[3,7,4,5,6,6,7]\n\n\n\n    \n\nvtx=[]\n\nfor i in range(n):\n\n    vtx.append([i+1])\n\nicnt=0\n\n\n\nfor j in range(m):    \n\n    vtx1=vtx.copy()\n\n    a1=a.copy()\n\n    b1=b.copy()\n\n    del a1[j]\n\n    del b1[j]\n\n    \n\n    for i in range(m-1):\n\n        for v1 in vtx1:\n\n            if a1[i] in v1:\n\n                if not b1[i] in v1:\n\n                    for v2 in vtx1:\n\n                        if v1!=v2:\n\n                            if b1[i] in v2:\n\n                                break\n\n                    vtx1.remove(v1)\n\n                    vtx1.remove(v2)\n\n                    v3=v1+v2\n\n                    vtx1.append(v3)\n\n#        print(a[i],b[i],len(vtx1),vtx1)\n\n#    print(len(vtx1),vtx1)\n\n    if len(vtx1)!=1:\n\n        icnt=icnt+1\n\nprint(icnt)        ", "generated_code": "limit=50\n\ngraph=[[False]*limit for i in range(limit)]\n\nvisited=[]*limit\n\n\n\ndef dfs(v,n,graph,visited):\n\n    visited[v]=True\n\n    for v2 in range(n):\n\n        if graph[v][v2]==False:\n\n            continue\n\n        if visited[v2]==True:\n\n            continue\n\n        dfs(v2,n,graph,visited)\n\n\n\nn,m=list(map(int,input().split()))\n\na=[0]*m\n\nb=[0]*m\n\nfor i in range(m):\n\n    ai,bi=list(map(int,input().split()))\n\n    a[i]=ai-1\n\n    b[i]=bi-1\n\n    graph[a[i]][b[i]]=True\n\n    graph[b[i]][a[i]]=True\n\n    \n\nans=0 \n\nfor i in range(m):\n\n    graph[a[i]][b[i]]=False\n\n    graph[b[i]][a[i]]=False\n\n    visited=[False]*n\n\n    dfs(0,n,graph,visited)\n\n    bridge=False\n\n    for j in range(n):\n\n        if visited[j]==False:\n\n            bridge=True\n\n    if bridge:\n\n        ans+=1\n\n    graph[a[i]][b[i]]=True\n\n    graph[b[i]][a[i]]=True\n\n    \n\nprint(ans)", "score": 1.0, "surface_similarity": 0.5632974731048286}
{"id": "p02814_u086503932", "golden_code": "#!/usr/bin/env python3\n\nimport sys\n\nfrom fractions import gcd\n\nimport math\n\n\n\ndef main():\n\n    N, M = list(map(int, input().split()))\n\n    a = list(map(int, input().split()))\n\n    tmp = 1\n\n    count = None\n\n    for i in range(N):\n\n      tmp = (tmp * a[i]//2) // gcd(tmp,a[i]//2)\n\n      c = 0\n\n      n = a[i]//2\n\n      while n % 2 == 0:\n\n        c += 1\n\n        n //= 2\n\n      if i == 0:\n\n        count = c\n\n      elif count != c:\n\n        print((0))\n\n        exit()\n\n    print(((M//tmp +1)//2))\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "generated_code": "from math import gcd\n\n\n\nN, M = list(map(int, input().split()))\n\nA = list(map(int, input().split()))\n\nB = [a//2 for a in A]\n\nLCM = 1\n\nfor i in range(N):\n\n    LCM = LCM * B[i] // gcd(LCM, B[i])\n\nfor i in range(N):\n\n    if LCM // B[i] % 2 == 0:\n\n        print((0))\n\n        exit()\n\nprint(((M//LCM + 1)//2))", "score": 1.0, "surface_similarity": 0.7136120622334354}
{"id": "p03060_u098982053", "golden_code": "import numpy as np\n\nN = int(eval(input()))\n\nV = np.array([int(i) for i in input().split(\" \")])\n\nC = np.array([int(i) for i in input().split(\" \")])\n\n\n\nvc = V-C\n\n\n\nval = 0\n\n\n\nfor i in range(N):\n\n    if vc[i]>0:\n\n        val+=vc[i]\n\nprint(val)", "generated_code": "N = int(eval(input()))\n\nV = [int(i) for i in input().split(\" \")]\n\nC = [int(i) for i in input().split(\" \")]\n\n\n\nval = 0\n\n\n\nfor i in range(N):\n\n    vc=V[i]-C[i]\n\n    if vc>0:\n\n        val+=vc\n\nprint(val)", "score": 1.0, "surface_similarity": 0.833605072463768}
{"id": "p02394_u433181015", "golden_code": "a=input().split()\n\nb=list(map(int,a))\n\nW=b[0]\n\nH=b[1]\n\nx=b[2]\n\ny=b[3]\n\nr=b[4]\n\nif (r <= x <= (W - r)) and (r <= y <= (H - r)):\n\n  print('Yes')\n\nelse:\n\n  print('No')", "generated_code": "W,H,x,y,r = [int(i) for i in input().split()]\n\nif (r <= x <= (W - r)) and (r <= y <= (H - r)):\n\n  print('Yes')\n\nelse:\n\n  print('No')", "score": 1.0, "surface_similarity": 0.6858304297328688}
{"id": "p02394_u454022848", "golden_code": "ia = [int(i) for i in input().split(\" \")]\n\nW=ia[0]\n\nH=ia[1]\n\nx=ia[2]\n\ny=ia[3]\n\nr=ia[4]\n\nprint((\"Yes\" if 0<=x-r and x+r<=W and 0<=y-r and y+r<=H else \"No\"))", "generated_code": "# encoding:utf-8\n\n\n\ninput = list(map(int, input().split()))\n\nW, H, x, y, r = input\n\n\n\nif x - r < 0 or x + r > W:\n\n\tprint(\"No\")\n\nelif y - r < 0 or y + r > H:\n\n\tprint(\"No\")\n\nelse:\n\n\tprint(\"Yes\")", "score": 1.0, "surface_similarity": 0.5140224358974359}
{"id": "p03457_u310381103", "golden_code": "N=eval(input())\n\na=[]\n\nt=True\n\nfor _ in range(int(N)):\n\n    a+=[list(map(int,input().split()))]\n\nfor i in range(int(N)):\n\n    if a[i][0]%2==0:\n\n        if abs(a[i][1]+a[i][2])<=a[i][0] and (a[i][1]+a[i][2])%2==0:\n\n            continue\n\n        else:\n\n            print('No')\n\n            t=False\n\n            break\n\n    else:\n\n        if abs(a[i][1]+a[i][2]<=a[i][0]) and (a[i][1]+a[i][2])%2==1:\n\n            continue\n\n        else:\n\n            print('No')\n\n            t=False\n\n            break\n\nif t:\n\n    print('Yes')", "generated_code": "import sys\n\nn=int(eval(input()))\n\nt=[]\n\nfor i in range(n):\n\n    t.append(list(map(int,input().split())))\n\nfor i,d in enumerate(t):\n\n    if i>0:\n\n        b=d[0]-a\n\n        c=abs(d[1]+d[2]-aa)\n\n    a=d[0]\n\n    aa=d[1]+d[2]\n\n    if i==0:\n\n        if not (a >= aa and a % 2 == aa % 2):\n\n            print('No')\n\n            sys.exit()\n\n        else:\n\n            continue\n\n    if not (b>=c and b%2==c%2):\n\n        print('No')\n\n        sys.exit()\n\nprint('Yes')", "score": 1.0, "surface_similarity": 0.6388888888888888}
{"id": "p04012_u633450100", "golden_code": "import numpy as np\n\n\n\nw = eval(input())\n\nanal = np.array([])\n\n\n\nfor i in range(ord('a'),ord('z')+1):\n\n    anal = np.append(anal,w.count(chr(i)))\n\nif np.all(anal % 2 == 0):\n\n    #ans = np.sum(anal)\n\n    print(\"Yes\")\n\nelse:\n\n    print(\"No\")", "generated_code": "w = str(eval(input()))\n\ncount = int()\n\n\n\nfor i in range(len(w)):\n\n    if w.count(w[i]) % 2 == 0:\n\n        count += 1\n\n\n\nif count == len(w):\n\n    print('Yes')\n\nelse:\n\n    print('No')", "score": 1.0, "surface_similarity": 0.6556531703590527}
{"id": "p03436_u620868411", "golden_code": "# -*- coding: utf-8 -*-\n\nfrom queue import Queue\n\nh,w = list(map(int, input().split()))\n\nd = []\n\nfor _ in range(h):\n\n    d.append(eval(input()))\n\ncost = [[0]*w for _ in range(h)]\n\n\n\nq = Queue()\n\nq.put((0,0))\n\nwhile not q.empty():\n\n    hi,wi = q.get()\n\n    if hi==h-1 and wi==w-1:\n\n        break\n\n\n\n    for dh,dw in [[0,1],[1,0],[0,-1],[-1,0]]:\n\n        if h>dh+hi>=0 and w>dw+wi>=0 and d[dh+hi][dw+wi]==\".\":\n\n            if cost[dh+hi][dw+wi]==0 or cost[dh+hi][dw+wi]>cost[hi][wi]+1:\n\n                cost[dh+hi][dw+wi] = cost[hi][wi]+1\n\n                q.put((dh+hi, dw+wi))\n\n\n\nif cost[h-1][w-1]==0:\n\n    print((-1))\n\n    exit()\n\n\n\nres = 0\n\nfor hi in range(h):\n\n    for wi in range(w):\n\n        if (hi==0 and wi==0) or (hi==h-1 and wi==-1):\n\n            continue\n\n        if d[hi][wi]==\".\":\n\n            res += 1\n\n\n\nprint((res - cost[h-1][w-1]))\n", "generated_code": "# -*- coding: utf-8 -*-\n\nfrom collections import deque\n\nh,w = list(map(int, input().split()))\n\nm = [\"#\"*(w+2)] + [\"#\"+eval(input())+\"#\" for _ in range(h)] + [\"#\"*(w+2)]\n\n\n\ncnt = 0\n\nfor hi in range(1,h+1):\n\n    for wi in range(1,w+1):\n\n        if m[hi][wi]==\".\":\n\n            cnt += 1\n\n\n\ninf = 10**9\n\nd = [[inf]*(w+2) for _ in range(h+2)]\n\nq = deque([(1,1,1)])\n\nd[1][1] = 1\n\nwhile len(q):\n\n    ch,cw,r = q.popleft()\n\n\n\n    for hi,wi in [[ch+1,cw],[ch,cw+1],[ch-1,cw],[ch,cw-1]]:\n\n        if m[hi][wi]==\".\" and d[hi][wi]>r+1:\n\n            d[hi][wi]=r+1\n\n            q.append((hi,wi,r+1))\n\n\n\nif d[h][w]==inf:\n\n    print((-1))\n\nelse:\n\n    print((cnt-d[h][w]))", "score": 1.0, "surface_similarity": 0.6713477909650158}
{"id": "p03371_u576432509", "golden_code": "a,b,c,x,y=list(map(int,input().split()))\n\n\n\nyenmin=a*x+b*y\n\nfor zz in range(2*10**5+1):\n\n    xx=max(x-zz//2,0)\n\n    yy=max(y-zz//2,0)\n\n    yen=a*xx+b*yy+c*zz\n\n    if yen<yenmin:\n\n        yenmin=yen\n\nprint(yenmin)\n\n#print(xx,yy,zz)", "generated_code": "a,b,c,x,y=list(map(int,input().split()))\n\n\n\ncmax=max(x,y)*2\n\nzmin=(a+b)*10**5\n\nfor nc in range(0,cmax+1,2):\n\n    na=max(x-nc//2,0)\n\n    nb=max(y-nc//2,0)\n\n    z=a*na+b*nb+c*nc\n\n    zmin=min(zmin,z)\n\n    \n\nprint(zmin)\n", "score": 1.0, "surface_similarity": 0.7684782608695653}
{"id": "p02772_u116348130", "golden_code": "import sys\n\nimport numpy as np\n\nn = int(eval(input()))\n\ninput = sys.stdin.readline\n\na = np.array(list(map(int, input().split())))\n\nfor i in a:\n\n    if i % 2 == 0:\n\n        if i % 3 != 0 and i % 5 != 0:\n\n            print('DENIED')\n\n            exit()\n\nprint('APPROVED')\n", "generated_code": "#import sys\n\n#import numpy as np\n\nn = int(eval(input()))\n\n#input = sys.stdin.readline\n\n#a = np.array(list(map(int, input().split())))\n\na = list(map(int, input().split()))\n\nfor i in a:\n\n    if i % 2 == 0:\n\n        if i % 3 != 0 and i % 5 != 0:\n\n            print('DENIED')\n\n            exit()\n\nprint('APPROVED')\n", "score": 1.0, "surface_similarity": 0.8519292604501607}
{"id": "p03837_u696805736", "golden_code": "import queue\n\n\n\nINF = 123456789\n\n\n\ndef main():\n\n    n,m = list(map(int,input().split()))\n\n\n\n    G = [[] for _ in range(n)]\n\n    for _ in range(m):\n\n        a,b,c = list(map(int,input().split()))\n\n        a -= 1\n\n        b -= 1\n\n        G[a].append((b,c))\n\n        G[b].append((a,c))\n\n\n\n    used = set()\n\n    for i in range(n):\n\n        d = [INF for _ in range(n)]\n\n        par = [-1 for _ in range(n)]\n\n\n\n        # dijkstra\n\n        que = queue.PriorityQueue()\n\n        d[i] = 0\n\n        que.put((0,i))\n\n        while not que.empty():\n\n            p = que.get()\n\n            v = p[1]\n\n            if d[v] < p[0]:\n\n                continue\n\n            for (to,cost) in G[v]:\n\n                if d[to] > d[v]+cost:\n\n                    d[to] = d[v]+cost\n\n                    par[to] = v\n\n                    que.put((d[to],to))\n\n\n\n        for j in range(n):\n\n            if i != j:\n\n                a,b = j,par[j]\n\n                if a>b:\n\n                    a,b = b,a\n\n                used.add((a,b))\n\n\n\n    print((m - len(used)))\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "generated_code": "INF = 123456789\n\n\n\ndef main():\n\n    n,m = list(map(int,input().split()))\n\n\n\n    d = [ [INF for i in range(n)] for j in range(n) ]\n\n    for i in range(n):\n\n        d[i][i] = 0\n\n\n\n    a = [0 for _ in range(m)]\n\n    b = [0 for _ in range(m)]\n\n    c = [0 for _ in range(m)]\n\n    for i in range(m):\n\n        a[i],b[i],c[i] = list(map(int,input().split()))\n\n        a[i] -= 1\n\n        b[i] -= 1\n\n        d[a[i]][b[i]] = min(d[a[i]][b[i]], c[i])\n\n        d[b[i]][a[i]] = min(d[b[i]][a[i]], c[i])\n\n\n\n    # Warshall-Floyd\n\n    for k in range(n):\n\n        for i in range(n):\n\n            for j in range(n):\n\n                d[i][j] = min(d[i][j], d[i][k]+d[k][j])\n\n\n\n    ans = 0\n\n    for i in range(m):\n\n        found = 1\n\n        for j in range(n):\n\n            if d[j][a[i]] + c[i] == d[j][b[i]]:\n\n                found = 0\n\n                break\n\n        ans += found\n\n    print(ans)\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 1.0, "surface_similarity": 0.6573556797020483}
{"id": "p03575_u581187895", "golden_code": "# 全部試す\n\n# 1つあたりO(M)\n\n# O(M^2) = 10^6くらい\n\nimport numpy as np\n\nfrom scipy.sparse.csgraph import dijkstra\n\n\n\nN,M = list(map(int,input().split()))\n\nedge = [list(map(int, input().split())) for _ in range(M)]\n\n\n\ngraph = np.zeros((N+1, N+1))\n\n\n\nfor a, b in edge:\n\n  graph[a, b] = 1\n\n  \n\nans = 0\n\nfor a, b in edge:\n\n  graph[a, b] = np.inf \n\n  # directed=False -> 無向グラフ\n\n  dist = dijkstra(graph, indices=a, directed=False)\n\n  if dist[b] == np.inf:\n\n    ans += 1\n\n  graph[a, b] = 1 # 元に戻す\n\n  \n\nprint(ans)  ", "generated_code": "class UnionFind():\n\n    def __init__(self, N):\n\n        \"\"\" N個のノードのUnion-Find木を作成する \"\"\"\n\n        # 親の番号を格納する。自分が親だった場合は、自分の番号になり、それがそのグループの番号になる\n\n        self.parent = [n for n in range(0, N)]\n\n        # グループの深さ\n\n        self.depth = [1] * N\n\n \n\n    def find(self, x):\n\n        \"\"\" 木の根(どのグループか)を求める \"\"\"\n\n        if self.parent[x] == x: return x\n\n        self.parent[x] = self.find(self.parent[x]) # 縮約\n\n        return self.parent[x]\n\n \n\n    def unite(self, x, y):\n\n        \"\"\" xとyの属する集合を併合する \"\"\"\n\n        gx = self.find(x)\n\n        gy = self.find(y)\n\n        if gx == gy: return\n\n \n\n        # 小さい方を大きい方に併合させる（木の偏りが減るので）\n\n        if self.depth[gx] < self.depth[gy]:\n\n            self.parent[gx] = gy\n\n        else:\n\n            self.parent[gy] = gx\n\n            if self.depth[gx] == self.depth[gy]: self.depth[gx] += 1\n\n \n\n    def is_same_group(self, x, y):\n\n        \"\"\" xとyが同じ集合に属するか否か \"\"\"\n\n        return self.find(x) == self.find(y)\n\n      \n\nN, M = list(map(int, input().split()))\n\nE = [[int(x)-1 for x in input().split()] for _ in range(M)]\n\n\n\n# 各辺について、その辺が存在しない時、aとbが連結になるかをUnion-Findで判定する\n\nans = 0\n\nfor i in range(M):\n\n  uf = UnionFind(N)\n\n  for j, e in enumerate(E):\n\n    if i==j: continue\n\n        \n\n    a, b = e\n\n    uf.unite(a, b)\n\n      \n\n  # i番目の辺を除くすべての辺をつないだあとで、i番目の辺(a, b)がつながるかを判定する\n\n  # つながらないならば、そのi番目の辺は橋である\n\n  a, b = E[i]\n\n  if not uf.is_same_group(a, b):\n\n    ans += 1\n\n\n\nprint(ans)      \n", "score": 1.0, "surface_similarity": 0.5502848483685957}
{"id": "p03416_u282228874", "golden_code": "a,b = list(map(int,input().split()))\n\ncount = 0\n\nfor i in range(a,b+1):\n\n    s = str(i)\n\n    l = len(s)\n\n    if all(s[j] == s[l-j-1] for j in range(l)):\n\n            count += 1\n\nprint(count)", "generated_code": "a,b = list(map(int,input().split()))\n\ncount = 0\n\nfor i in range(a,b+1):\n\n    s = str(i)\n\n    if s == s[::-1]:\n\n         count += 1\n\nprint(count)", "score": 1.0, "surface_similarity": 0.7705263157894737}
{"id": "p03575_u375616706", "golden_code": "\n\nclass UnionFind:\n\n    def __init__(self, size):\n\n        self.table = [i for i in range(size)]\n\n\n\n    def find(self, x):\n\n        return self.table[x]\n\n\n\n    def union(self, x, y):\n\n        x1 = self.find(x)\n\n        y1 = self.find(y)\n\n\n\n        if x1 == y1:\n\n            return False\n\n\n\n        for i in range(len(self.table)):\n\n            if self.table[i] == y1:\n\n                self.table[i] = x1\n\n        return True\n\n\n\n\n\nN, M = list(map(int, input().split()))\n\n\n\nedges = []\n\nfor _ in range(M):\n\n    a, b = list(map(int, input().split()))\n\n    edges.append([a-1, b-1])\n\n\n\nmat = [[0]*N for _ in range(N)]\n\nfor s, g in edges:\n\n    mat[s][g] = 1\n\n    mat[g][s] = 1\n\n\n\nans = 0\n\n\n\nfor i in range(M):\n\n    uni = UnionFind(N)\n\n\n\n    for j in range(M):\n\n        if i != j:\n\n            uni.union(edges[j][0], edges[j][1])\n\n\n\n    if not all(uni.find(0) == uni.find(x) for x in range(N)):\n\n        ans += 1\n\nprint(ans)\n", "generated_code": "# python template for atcoder1\n\nimport sys\n\nsys.setrecursionlimit(10**9)\n\ninput = sys.stdin.readline\n\n\n\n\n\nclass UnionFind:\n\n    def __init__(self, size):\n\n        \"\"\"\n\n        size:頂点の数\n\n        \"\"\"\n\n        self.parent = [i for i in range(size)]\n\n        self.rank = [0 for _ in range(size)]\n\n\n\n    def find(self, x):\n\n        \"\"\"\n\n        xのrootを返す\n\n        \"\"\"\n\n        if self.parent[x] == x:\n\n            return x\n\n        else:\n\n            return self.find(self.parent[x])\n\n\n\n    def union(self, x, y):\n\n        \"\"\"\n\n        x,yを同じグループとしてまとめる\n\n        \"\"\"\n\n        x = self.find(x)\n\n        y = self.find(y)\n\n        if x == y:\n\n            return\n\n\n\n        if self.rank[x] < self.rank[y]:\n\n            self.parent[x] = y\n\n        else:\n\n            self.parent[y] = x\n\n            if self.rank[x] == self.rank[y]:\n\n                self.rank[x] += 1\n\n\n\n    def same(self, x, y):\n\n        \"\"\"\n\n        xとyが同じグループならTrue\n\n        \"\"\"\n\n        return self.find(x) == self.find(y)\n\n\n\n    def component(self):\n\n        \"\"\"\n\n        各連結成分のrootの集合を返す\n\n        len()をとれば連結成分の数が求められる\n\n        return-> set()\n\n        \"\"\"\n\n        comp = set()\n\n        for i in self.parent:\n\n            p = self.find(i)\n\n            comp.add(p)\n\n        return comp\n\n\n\n    def __str__(self):\n\n        \"\"\"\n\n        for debug\n\n        クラスのlistの情報を出力\n\n        \"\"\"\n\n        ret = \"parents\\n\"\n\n        ret += \" \".join(map(str, self.parent))\n\n        ret += '\\n'\n\n        ret += \" \".join(map(str, self.rank))\n\n        return ret\n\n\n\n\n\nN, M = list(map(int, input().split()))\n\nedges = []\n\n\n\nfor _ in range(M):\n\n    a, b = [int(x)-1 for x in input().split()]\n\n    edges.append([a, b])\n\n\n\nans = 0\n\nfor e in edges:\n\n    Un = UnionFind(N)\n\n    for g in edges:\n\n        if e == g:\n\n            continue\n\n        else:\n\n            Un.union(g[0], g[1])\n\n    if not Un.same(e[0], e[1]):\n\n        ans += 1\n\nprint(ans)\n", "score": 1.0, "surface_similarity": 0.6846996673840735}
{"id": "p02688_u060896757", "golden_code": "import numpy as np\n\nN, K = list(map(int, input().split()))\n\n \n\nA = np.zeros(N, dtype=int)\n\n \n\nfor _ in range(K):\n\n    eval(input())\n\n    for i in input().split():\n\n        A[int(i) - 1] += 1\n\n \n\nans = 0\n\nfor i in A:\n\n    if i == 0:\n\n        ans += 1\n\nprint(ans)\n\n ", "generated_code": "N, K = list(map(int, input().split()))\n\n\n\nA = [0] * N\n\n\n\nfor _ in range(K):\n\n    eval(input())\n\n    for i in map(int, input().split()):\n\n        A[i - 1] += 1\n\n\n\nprint((A.count(0)))\n", "score": 1.0, "surface_similarity": 0.6828030303030304}
{"id": "p02921_u156815136", "golden_code": "import itertools\n\nimport fractions\n\ndef main():\n\n  s = eval(input())\n\n  t = eval(input())\n\n  cnt = 0\n\n  for i in range(3):\n\n    if s[i] == t[i]:\n\n      cnt += 1\n\n  print(cnt)\n\nif __name__ == '__main__':\n\n  main()", "generated_code": "s = eval(input())\n\nt = eval(input())\n\nans = 0\n\nfor i in range(3):\n\n    if s[i] == t[i]:\n\n        ans += 1\n\nprint(ans)\n", "score": 1.0, "surface_similarity": 0.713679245283019}
{"id": "p03575_u190405389", "golden_code": "import numpy as np\n\n\n\nn,m = list(map(int, input().split()))\n\n\n\nconnect = np.zeros((n,n))\n\n\n\nfor i in range(m):\n\n    a, b = list(map(int, input().split()))\n\n    connect[a-1, b-1] = 1\n\n    connect[b-1, a-1] = 1\n\n\n\nnotbridge = 0\n\n\n\n\n\nfor i in range(n):\n\n    for j in range(n):\n\n        if connect[i,j] == 1:\n\n            connect[i,j] = 0\n\n            connect[j,i] = 0\n\n            stack =[1]\n\n            visited = [1]\n\n            while stack:\n\n                p = stack.pop()\n\n                for k in range(n):\n\n                    if connect[p,k] == 1:\n\n                        if k not in visited:\n\n                            stack.append(k)\n\n                            visited.append(k)\n\n            if len(visited) == n:\n\n                notbridge += 1\n\n            connect[i,j] = 1\n\n            connect[j,i] = 1\n\n\n\n\n\n\n\nprint((m-notbridge//2))\n\n\n\n\n", "generated_code": "n,m = list(map(int, input().split()))\n\n\n\nconnect = [[0 for i in range(n)] for j in range(n)]\n\n\n\nfor i in range(m):\n\n    a, b = list(map(int, input().split()))\n\n    connect[a-1][b-1] = 1\n\n    connect[b-1][a-1] = 1\n\n\n\nnotbridge = 0\n\n\n\n\n\nfor i in range(n):\n\n    for j in range(n):\n\n        if connect[i][j] == 1:\n\n            connect[i][j] = 0\n\n            connect[j][i] = 0\n\n            stack =[1]\n\n            visited = [1]\n\n            while stack:\n\n                p = stack.pop()\n\n                for k in range(n):\n\n                    if connect[p][k] == 1:\n\n                        if k not in visited:\n\n                            stack.append(k)\n\n                            visited.append(k)\n\n            if len(visited) == n:\n\n                notbridge += 1\n\n            connect[i][j] = 1\n\n            connect[j][i] = 1\n\n\n\n\n\n\n\nprint((m-notbridge//2))\n\n\n\n\n", "score": 1.0, "surface_similarity": 0.89442791005291}
{"id": "p03579_u057109575", "golden_code": "import sys\n\nsys.setrecursionlimit(100000)\n\nN, M = list(map(int, input().split()))\n\nedges = [list(map(int, input().split())) for _ in range(M)]\n\n\n\ngraph = [[] for _ in range(N)]\n\nfor x, y in edges:\n\n    graph[x - 1].append(y - 1)\n\n    graph[y - 1].append(x - 1)\n\n\n\ndef dfs(v, c):\n\n    # c: color = 1 or -1\n\n    node[v] = c\n\n    for i in graph[v]:\n\n        if node[i] == c:\n\n            return False\n\n        \n\n        if node[i] == 0 and not dfs(i, -c):\n\n            return False\n\n        \n\n    return True\n\n\n\nnode = [0] * N\n\nif dfs(0, 1):\n\n    x = sum(v + 1 for v in node) // 2\n\n    print((x * (N - x) - M))\n\nelse:\n\n    print((N * (N - 1) // 2 - M))\n", "generated_code": "from collections import deque\n\nN, M = list(map(int, input().split()))\n\nedges = [list(map(int, input().split())) for _ in range(M)]\n\n\n\ngraph = [[] for _ in range(N)]\n\nfor x, y in edges:\n\n    graph[x - 1].append(y - 1)\n\n    graph[y - 1].append(x - 1)\n\n\n\ndef dfs(s, c):\n\n    q = deque()\n\n    q.append(s)\n\n    visited[s] = True\n\n    color[s] = c\n\n    \n\n    while len(q) > 0:\n\n        v = q.pop()\n\n        for i in graph[v]:\n\n            if visited[i] and color[i] == color[v]:\n\n                return False\n\n            \n\n            if not visited[i]:\n\n                visited[i] = True\n\n                color[i] = -color[v]\n\n                q.append(i)\n\n                \n\n    return True\n\n\n\nvisited = [False] * N\n\ncolor = [0] * N\n\n\n\nif dfs(0, 1):\n\n    x = sum(v + 1 for v in color) // 2\n\n    print((x * (N - x) - M))\n\nelse:\n\n    print((N * (N - 1) // 2 - M))\n\n    \n\n    ", "score": 1.0, "surface_similarity": 0.8375428335105755}
{"id": "p02248_u426534722", "golden_code": "def kmpTable(w):\n\n    lw = len(w)\n\n    nx = [-1] * (lw + 1)\n\n    j = -1\n\n    for i in range(lw):\n\n        while j >= 0 and w[i] != w[j]:\n\n            j = nx[j]\n\n        j += 1\n\n        nx[i + 1] = j\n\n    return nx\n\ndef kmpSearch(s, w):\n\n    ls = len(s)\n\n    start = 0\n\n    w_idx = 0\n\n    ret = []\n\n    nx = kmpTable(w)\n\n    while start + w_idx < ls:\n\n        if s[start + w_idx] == w[w_idx]:\n\n            w_idx += 1\n\n            if w_idx == len(w):\n\n                ret.append(start)\n\n                start = start + w_idx - nx[w_idx]\n\n                w_idx = nx[w_idx]\n\n        else:\n\n            if w_idx == 0:\n\n                start += 1\n\n            else:\n\n                start = start + w_idx - nx[w_idx]\n\n                w_idx = nx[w_idx]\n\n    return ret\n\nT = eval(input())\n\nP = eval(input())\n\nans = kmpSearch(T, P)\n\nif ans:\n\n    print((\"\\n\".join(map(str, ans))))\t\n\n\n", "generated_code": "def kmpTable(w):\n\n    lw = len(w)\n\n    nx = [-1] * (lw + 1)\n\n    j = -1\n\n    for i in range(lw):\n\n        while j >= 0 and w[i] != w[j]:\n\n            j = nx[j]\n\n        j += 1\n\n        nx[i + 1] = j\n\n    return tuple(nx)\n\ndef kmpSearch(s, w):\n\n    ls = len(s)\n\n    start = 0\n\n    w_idx = 0\n\n    ret = []\n\n    nx = kmpTable(w)\n\n    while start + w_idx < ls:\n\n        if s[start + w_idx] == w[w_idx]:\n\n            w_idx += 1\n\n            if w_idx == len(w):\n\n                ret.append(start)\n\n                start = start + w_idx - nx[w_idx]\n\n                w_idx = nx[w_idx]\n\n        else:\n\n            if w_idx == 0:\n\n                start += 1\n\n            else:\n\n                start = start + w_idx - nx[w_idx]\n\n                w_idx = nx[w_idx]\n\n    return ret\n\nT = eval(input())\n\nP = eval(input())\n\nans = kmpSearch(T, P)\n\nif ans:\n\n    print((\"\\n\".join(map(str, ans))))\t\n\n\n", "score": 1.0, "surface_similarity": 0.9960272417707151}
{"id": "p02537_u326609687", "golden_code": "import sys\n\nif sys.argv[-1] == 'ONLINE_JUDGE':\n\n    import os\n\n    import re\n\n    with open(__file__) as f:\n\n        source = f.read().split('###''nbacl')\n\n    for s in source[1:]:\n\n        s = re.sub(\"'''.*\", '', s)\n\n        sp = s.split(maxsplit=1)\n\n        if os.path.dirname(sp[0]):\n\n            os.makedirs(os.path.dirname(sp[0]), exist_ok=True)\n\n        with open(sp[0], 'w') as f:\n\n            f.write(sp[1])\n\n    from nbmodule import cc\n\n    cc.compile()\n\nimport numpy as np\n\nfrom numpy import int64\n\nfrom nbmodule import solve\n\n\n\n\n\nf = open(0)\n\nN, K = [int(x) for x in f.readline().split()]\n\nA = np.fromstring(f.read(), dtype=int64, sep=' ')\n\nans = solve(N, K, A)\n\nprint(ans)\n\n\n\n'''\n\n###nbacl nbmodule.py\n\nimport numpy as np\n\nfrom numpy import int64\n\nfrom numba import njit\n\nfrom numba.types import i8\n\nfrom numba.pycc import CC\n\nimport nbacl.segtree as seg\n\ncc = CC('my_module')\n\n\n\n\n\n@cc.export('solve', (i8, i8, i8[:]))\n\n@njit\n\ndef solve(N, K, A):\n\n    dp = np.zeros(300_001, dtype=int64)\n\n    d = seg.segtree(dp, max, 0)\n\n    for i in range(N):\n\n        x = seg.prod(d, max, (A[i] - K) if A[i] > K else 0, (A[i] + K + 1) if A[i] + K < 300_000 else 300_001) + 1\n\n        seg.set(d, max, A[i], x)\n\n    return seg.all_prod(d)\n\n\n\n\n\nif __name__ == '__main__':\n\n    cc.compile()\n\n###nbacl nbacl/segtree.py\n\nimport numpy as np\n\nfrom numba import njit\n\nfrom numba.types import i8\n\n\n\n\n\n@njit\n\ndef ceil_pow2(n):\n\n    x = 0\n\n    while (1 << x) < n:\n\n        x += 1\n\n    return x\n\n\n\n\n\n@njit\n\ndef segtree(a, op, e):\n\n    log = ceil_pow2(a.shape[0])\n\n    size = 1 << log\n\n    d = np.empty(size * 2, dtype=a.dtype)\n\n    d[size:size + len(a)] = a\n\n    d[size + len(a):] = e\n\n    # e\n\n    d[0] = e\n\n    for i in range(size - 1, 0, -1):\n\n        update(d, i, op)\n\n    return d\n\n\n\n\n\n@njit\n\ndef update(d, k, op):\n\n    d[k] = op(d[2 * k], d[2 * k + 1])\n\n\n\n\n\n@njit\n\ndef set(d, op, p, x):\n\n    p += d.shape[0] // 2\n\n    d[p] = x\n\n    while p > 1:\n\n        p >>= 1\n\n        update(d, p, op)\n\n\n\n\n\n@njit\n\ndef get(d, p):\n\n    return d[p + d.shape[0] // 2]\n\n\n\n\n\n@njit\n\ndef prod(d, op, left, right):\n\n    size = d.shape[0] // 2\n\n    sml = d[0]\n\n    smr = d[0]\n\n    left += size\n\n    right += size\n\n\n\n    while left < right:\n\n        if left & 1:\n\n            sml = op(sml, d[left])\n\n            left += 1\n\n        if right & 1:\n\n            right -= 1\n\n            smr = op(d[right], smr)\n\n        left >>= 1\n\n        right >>= 1\n\n\n\n    return op(sml, smr)\n\n\n\n\n\n@njit\n\ndef all_prod(d):\n\n    return d[1]\n\n\n\n'''\n", "generated_code": "import sys\n\nif sys.argv[-1] == 'ONLINE_JUDGE':\n\n    import os\n\n    import re\n\n    with open(__file__) as f:\n\n        source = f.read().split('###''nbacl')\n\n    for s in source[1:]:\n\n        s = re.sub(\"'''.*\", '', s)\n\n        sp = s.split(maxsplit=1)\n\n        if os.path.dirname(sp[0]):\n\n            os.makedirs(os.path.dirname(sp[0]), exist_ok=True)\n\n        with open(sp[0], 'w') as f:\n\n            f.write(sp[1])\n\n    from nbmodule import cc\n\n    cc.compile()\n\nimport numpy as np\n\nfrom numpy import int64\n\nfrom nbmodule import solve\n\n\n\n\n\nf = open(0)\n\nN, K = [int(x) for x in f.readline().split()]\n\nA = np.fromstring(f.read(), dtype=int64, sep=' ')\n\nans = solve(N, K, A)\n\nprint(ans)\n\n\n\n'''\n\n###nbacl nbmodule.py\n\nimport numpy as np\n\nfrom numpy import int64\n\nfrom numba import njit\n\nfrom numba.types import i8\n\nfrom numba.pycc import CC\n\nimport nbacl.segtree as seg\n\ncc = CC('nbmodule')\n\n\n\n\n\n@cc.export('solve', (i8, i8, i8[:]))\n\n@njit\n\ndef solve(N, K, A):\n\n    dp = np.zeros(300_001, dtype=int64)\n\n    d = seg.segtree(dp, max, 0)\n\n    for i in range(N):\n\n        x = seg.prod(d, max, (A[i] - K) if A[i] > K else 0, (A[i] + K + 1) if A[i] + K < 300_000 else 300_001) + 1\n\n        seg.set(d, max, A[i], x)\n\n    return seg.all_prod(d)\n\n\n\n\n\nif __name__ == '__main__':\n\n    cc.compile()\n\n###nbacl nbacl/segtree.py\n\nimport numpy as np\n\nfrom numba import njit\n\nfrom numba.types import i8\n\n\n\n\n\n@njit\n\ndef ceil_pow2(n):\n\n    x = 0\n\n    while (1 << x) < n:\n\n        x += 1\n\n    return x\n\n\n\n\n\n@njit\n\ndef segtree(a, op, e):\n\n    log = ceil_pow2(a.shape[0])\n\n    size = 1 << log\n\n    d = np.empty(size * 2, dtype=a.dtype)\n\n    d[size:size + len(a)] = a\n\n    d[size + len(a):] = e\n\n    # e\n\n    d[0] = e\n\n    for i in range(size - 1, 0, -1):\n\n        update(d, i, op)\n\n    return d\n\n\n\n\n\n@njit\n\ndef update(d, k, op):\n\n    d[k] = op(d[2 * k], d[2 * k + 1])\n\n\n\n\n\n@njit\n\ndef set(d, op, p, x):\n\n    p += d.shape[0] // 2\n\n    d[p] = x\n\n    while p > 1:\n\n        p >>= 1\n\n        update(d, p, op)\n\n\n\n\n\n@njit\n\ndef get(d, p):\n\n    return d[p + d.shape[0] // 2]\n\n\n\n\n\n@njit\n\ndef prod(d, op, left, right):\n\n    size = d.shape[0] // 2\n\n    sml = d[0]\n\n    smr = d[0]\n\n    left += size\n\n    right += size\n\n\n\n    while left < right:\n\n        if left & 1:\n\n            sml = op(sml, d[left])\n\n            left += 1\n\n        if right & 1:\n\n            right -= 1\n\n            smr = op(d[right], smr)\n\n        left >>= 1\n\n        right >>= 1\n\n\n\n    return op(sml, smr)\n\n\n\n\n\n@njit\n\ndef all_prod(d):\n\n    return d[1]\n\n\n\n'''\n", "score": 1.0, "surface_similarity": 0.9993983152827919}
{"id": "p03457_u312025627", "golden_code": "def main():\n\n    import sys\n\n    input = sys.stdin.buffer.readline\n\n    N = int(input())\n\n    TXY = [[int(i) for i in input().split()] for j in range(N)]\n\n    time, px, py = 0, 0, 0\n\n    for t, x, y in TXY:\n\n        move = abs(x-px) + abs(y-py)\n\n        # print(move, t-time)\n\n        if (t - time) % 2 != move % 2 or t - time < move:\n\n            return print(\"No\")\n\n        time, px, py = t, x, y\n\n    print(\"Yes\")\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "generated_code": "def main():\n\n    import sys\n\n    input = sys.stdin.buffer.readline\n\n    N = int(input())\n\n    TXY = [[int(i) for i in input().split()] for j in range(N)]\n\n    time = 0\n\n    px = 0\n\n    py = 0\n\n    for t, x, y in TXY:\n\n        move = abs(py-y) + abs(px - x)\n\n        if (t-time) < move or (t - time) % 2 != move % 2:\n\n            return print(\"No\")\n\n        time = t\n\n        px = x\n\n        py = y\n\n    print(\"Yes\")\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 1.0, "surface_similarity": 0.955531453362256}
{"id": "p02624_u102461423", "golden_code": "import sys\n\nimport numpy as np\n\n\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\ndef main(N):\n\n    div = np.zeros(N+1, np.int64)\n\n    for n in range(1, N+1):\n\n      for m in range(n, N+1, n):\n\n        div[m] += m\n\n    return div.sum()\n\n\n\nif sys.argv[-1] == 'ONLINE_JUDGE':\n\n    import numba\n\n    from numba.pycc import CC\n\n    i8 = numba.int64\n\n    cc = CC('my_module')\n\n\n\n    def cc_export(f, signature):\n\n        cc.export(f.__name__, signature)(f)\n\n        return numba.njit(f)\n\n\n\n    main = cc_export(main, (i8, ))\n\n    cc.compile()\n\n\n\nfrom my_module import main\n\n\n\nN = int(read())\n\nprint((main(N)))\n", "generated_code": "import sys\n\nimport numpy as np\n\n\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\ndef main(N):\n\n    x = 0\n\n    for a in range(1, N+1):\n\n        for b in range(1, N//a+1):\n\n            x += a*b\n\n    return x\n\n\n\nif sys.argv[-1] == 'ONLINE_JUDGE':\n\n    import numba\n\n    from numba.pycc import CC\n\n    i8 = numba.int64\n\n    cc = CC('my_module')\n\n\n\n    def cc_export(f, signature):\n\n        cc.export(f.__name__, signature)(f)\n\n        return numba.njit(f)\n\n\n\n    main = cc_export(main, (i8, ))\n\n    cc.compile()\n\n\n\nfrom my_module import main\n\n\n\nN = int(read())\n\nprint((main(N)))\n", "score": 1.0, "surface_similarity": 0.9284357821089455}
{"id": "p03309_u683134447", "golden_code": "import numpy as np\n\nn = int(eval(input()))\n\nal = list(map(int,input().split()))\n\n\n\nfor i in range(n):\n\n    al[i] -= i + 1\n\n\n\nmed = np.median(np.array(al))\n\n\n\nans = 0\n\nfor a in al:\n\n    ans += abs(a-med)\n\nprint((int(ans)))", "generated_code": "import statistics\n\nn = int(eval(input()))\n\nal = list(map(int,input().split()))\n\n\n\nfor i in range(n):\n\n    al[i] -= i + 1\n\n\n\nmedian = statistics.median(al)\n\n\n\nans = 0\n\nfor a in al:\n\n    ans += abs(median - a)\n\n\n\nprint((int(ans)))\n", "score": 1.0, "surface_similarity": 0.9235807860262009}
{"id": "p03287_u404676457", "golden_code": "import numpy as np\n\n(n, m) = list(map(int, input().split()))\n\na = np.array(list(map(int, input().split()))).astype(\"int64\") \n\na = np.cumsum(a)\n\na %= m\n\ncount = np.sum(a == 0)\n\na.sort()\n\ntc = 1\n\nfor i in range(1, n):\n\n    if a[i - 1] == a[i]:\n\n        tc += 1\n\n    else:\n\n        count += tc * (tc - 1) // 2\n\n        tc = 1\n\nelse:\n\n    count += tc * (tc - 1) // 2\n\nprint(count)", "generated_code": "(n, m) = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\nunique_a = {a[0] % m: 1}\n\nfor i in range(1, n):\n\n    a[i] += a[i - 1]\n\n    a[i] %= m\n\n    if a[i] in unique_a:\n\n        unique_a[a[i]] += 1\n\n    else:\n\n        unique_a[a[i]] = 1\n\ncount = 0\n\nif 0 in unique_a:\n\n    count += unique_a[0]\n\nfor k in unique_a:\n\n    count += unique_a[k] * (unique_a[k] - 1) // 2\n\nprint(count)", "score": 1.0, "surface_similarity": 0.6662013772566536}
{"id": "p03273_u080364835", "golden_code": "import numpy as np\n\n\n\nh, w = map(int, input().split())\n\nal = list(list(input()) for _ in range(h))\n\nal_n = np.array(al)\n\nrow = [0]*w\n\ncol = [0]*h\n\nfor i in range(h):\n\n    for j in range(w):\n\n        if al_n[i][j] == '.':\n\n            row[j] += 1\n\n            col[i] += 1\n\nrow_ = []\n\ncol_ = []\n\nfor i in range(w):\n\n    if row[i] == h:\n\n        row_.append(i)\n\n\n\nfor j in range(h):\n\n    if col[j] == w:\n\n        col_.append(j)\n\n\n\nif len(col_) > 0:\n\n    al_n = np.delete(al_n, col_, axis=0)\n\n\n\nif len(row_) > 0:\n\n    al_n = np.delete(al_n, row_, axis=1)\n\n\n\nfor a in al_n:\n\n    print(*a, sep='')\n", "generated_code": "h, w = map(int, input().split())\n\nal = list(list(input()) for _ in range(h))\n\nrow = [0]*w\n\ncol = [0]*h\n\n\n\nfor i in range(h):\n\n    for j in range(w):\n\n        if al[i][j] == '#':\n\n            col[i] += 1\n\n            row[j] += 1\n\nans = []\n\nw_len = len(row) - row.count(0)\n\nfor i in range(h):\n\n    tmp = ''\n\n    if col[i] != 0:\n\n        for j in range(w):\n\n            if row[j] != 0:\n\n                tmp += al[i][j]\n\n        ans.append(tmp)\n\n\n\nfor a in ans:\n\n    print(*a, sep='')\n", "score": 1.0, "surface_similarity": 0.7561936936936937}
{"id": "p03553_u637175065", "golden_code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\n\n\nsys.setrecursionlimit(10**7)\n\ninf = 10**20\n\neps = 1.0 / 10**15\n\nmod = 10**9+7\n\n\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\n\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\n\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\n\ndef LS(): return sys.stdin.readline().split()\n\ndef I(): return int(sys.stdin.readline())\n\ndef F(): return float(sys.stdin.readline())\n\ndef S(): return input()\n\ndef pf(s): return print(s, flush=True)\n\ndef divisions(n):\n\n    sq = int(math.sqrt(n)+1)\n\n    d = collections.defaultdict(int)\n\n    while n % 2 == 0:\n\n        n //= 2\n\n        d[2] += 1\n\n    i = 3\n\n    while n > 1 and sq >= i:\n\n        if n % i == 0:\n\n            n //= i\n\n            d[i] += 1\n\n        else:\n\n            i += 2\n\n\n\n    if n > 1:\n\n        d[n] += 1\n\n\n\n    r = [1]\n\n    for k, v in d.items():\n\n        for c in r[:]:\n\n            for i in range(1,v+1):\n\n                r.append(c*(k**i))\n\n\n\n    return sorted(r)\n\n\n\ndef main():\n\n    n = I()\n\n    a = LI()\n\n    s = set()\n\n    for i in range(n,0,-1):\n\n        d = divisions(i)\n\n        ld = len(d)\n\n        for j in range(1,2**ld):\n\n            c = []\n\n            ff = True\n\n            for k in range(ld):\n\n                if j & (1<<k):\n\n                    f = True\n\n                    for e in c:\n\n                        if d[k] % e == 0:\n\n                            f = False\n\n                            ff = False\n\n                            break\n\n                    if f:\n\n                        c.append(d[k])\n\n                if not ff:\n\n                    break\n\n            if ff:\n\n                s.add(tuple(c + [n+1]))\n\n    b = sorted(list(s), reverse=True)\n\n    for c in b:\n\n        t = 0\n\n        for j in range(1,n+1):\n\n            f = False\n\n            for e in c:\n\n                if j%e == 0:\n\n                    f = True\n\n                    break\n\n            if f:\n\n                t += a[j-1]\n\n        if t < 0:\n\n            for j in range(1,n+1):\n\n                f = False\n\n                for e in c:\n\n                    if j%e == 0:\n\n                        f = True\n\n                        break\n\n                if f:\n\n                    a[j-1] = 0\n\n\n\n    return sum(a)\n\n\n\n\n\n\n\nprint(main())\n\n\n\n\n", "generated_code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,copy,functools\n\nimport time,random\n\n\n\nsys.setrecursionlimit(10**7)\n\ninf = 10**20\n\neps = 1.0 / 10**10\n\nmod = 10**9+7\n\nmod2 = 998244353\n\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\n\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\n\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\n\ndef LLI(): return [list(map(int, l.split())) for l in sys.stdin.readlines()]\n\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\n\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\n\ndef LS(): return sys.stdin.readline().split()\n\ndef I(): return int(sys.stdin.readline())\n\ndef F(): return float(sys.stdin.readline())\n\ndef S(): return input()\n\ndef pf(s): return print(s, flush=True)\n\ndef pe(s): return print(str(s), file=sys.stderr)\n\ndef JA(a, sep): return sep.join(map(str, a))\n\ndef JAA(a, s, t): return s.join(t.join(map(str, b)) for b in a)\n\n\n\n\n\nclass Flow():\n\n    def __init__(self, e, N):\n\n        self.E = e\n\n        self.N = N\n\n\n\n    def max_flow(self, s, t):\n\n        r = 0\n\n        e = self.E\n\n\n\n        def f(c, cap):\n\n            v = self.v\n\n            v[c] = 1\n\n            if c == t:\n\n                return cap\n\n            for i in range(self.N):\n\n                if v[i] or e[c][i] <= 0:\n\n                    continue\n\n                cp = min(cap, e[c][i])\n\n                k = f(i, cp)\n\n                if k > 0:\n\n                    e[c][i] -= k\n\n                    e[i][c] += k\n\n                    return k\n\n            return 0\n\n\n\n        while True:\n\n            self.v = [None] * self.N\n\n            fs = f(s, inf)\n\n            if fs == 0:\n\n                break\n\n            r += fs\n\n\n\n        return r\n\n\n\n\n\ndef main():\n\n    n = I()\n\n    a = LI()\n\n\n\n    s = n\n\n    t = n + 1\n\n    e = [[0] * (n+2) for _ in range(n+2)]\n\n    for i in range(n):\n\n        c = a[i]\n\n        if c < 0:\n\n            e[s][i] = -c\n\n            ii = i + 1\n\n            for j in range(ii*2, n+1, ii):\n\n                e[i][j-1] = inf\n\n        else:\n\n            e[i][t] = c\n\n\n\n\n\n    fl = Flow(e, n+2)\n\n    r = fl.max_flow(s,t)\n\n\n\n    return sum(map(lambda x: max(0,x), a)) - r\n\n\n\n# start = time.time()\n\nprint(main())\n\n# pe(time.time() - start)\n\n\n\n\n\n\n", "score": 1.0, "surface_similarity": 0.6972525481670526}
{"id": "p02881_u096128910", "golden_code": "N = int(eval(input()))\n\nans = N - 1\n\np = 1\n\nfor i in range(2, int((N ** 0.5) + 1)):\n\n    if p % 2 == 1 and i > (N ** 0.5):\n\n        break\n\n    if N % i == 0:\n\n        p = i\n\n        j = N // i\n\n        m = i + j - 2\n\n        if m < ans:\n\n            ans = m\n\n        else:\n\n            continue\n\n    else:\n\n        continue\n\nprint(ans)\n", "generated_code": "N = int(eval(input()))\n\nans = N - 1\n\nfor i in range(2, int((N ** 0.5) + 1)):\n\n    if N % i == 0:\n\n        j = N // i\n\n        m = i + j - 2\n\n        ans = min(ans, m)\n\nprint(ans)\n", "score": 1.0, "surface_similarity": 0.7663690476190477}
{"id": "p03078_u408071652", "golden_code": "import sys\n\nimport heapq\n\n\n\n\n\n# \\n\n\ndef input():\n\n    return sys.stdin.readline().rstrip()\n\n\n\n\n\ndef main():\n\n    X, Y, Z, K = list(map(int, input().split()))\n\n    A = list(map(int, input().split()))\n\n    B = list(map(int, input().split()))\n\n    C = list(map(int, input().split()))\n\n\n\n    A.sort(reverse=True)\n\n    B.sort(reverse=True)\n\n    C.sort(reverse=True)\n\n\n\n    Q = []\n\n    S = set()\n\n    heapq.heapify(Q)\n\n    heapq.heappush(Q, (-A[0] - B[0] - C[0], 0, 0, 0))\n\n    for i in range(K):\n\n        m, a, b, c = heapq.heappop(Q)\n\n        print((-m))\n\n        if (a + 1, b, c) not in S and a + 1 < X:\n\n            heapq.heappush(Q, (-A[a + 1] - B[b] - C[c], a + 1, b, c))\n\n            S.add((a + 1, b, c))\n\n        if (a, b + 1, c) not in S and b + 1 < Y:\n\n            heapq.heappush(Q, (-A[a] - B[b + 1] - C[c], a, b + 1, c))\n\n            S.add((a, b + 1, c))\n\n        if (a, b, c + 1) not in S and c + 1 < Z:\n\n            heapq.heappush(Q, (-A[a ] - B[b] - C[c+1], a, b, c + 1))\n\n            S.add((a, b, c + 1))\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "generated_code": "import sys\n\n\n\n\n\n# \\n\n\ndef input():\n\n    return sys.stdin.readline().rstrip()\n\n\n\n\n\ndef main():\n\n    X, Y, Z, K = list(map(int, input().split()))\n\n    A = list(map(int, input().split()))\n\n    B = list(map(int, input().split()))\n\n    C = list(map(int, input().split()))\n\n\n\n    A.sort(reverse=True)\n\n    B.sort(reverse=True)\n\n    C.sort(reverse=True)\n\n\n\n    L = []\n\n\n\n    for i in range(X):\n\n        for j in range(min(Y, K // (i + 1) + 1)):\n\n            for k in range(min(Z, K // (i + 1) // (j + 1) + 1)):\n\n                L.append(A[i] + B[j] + C[k])\n\n\n\n    L.sort(reverse=True)\n\n\n\n    for i in range(K):\n\n        print((L[i]))\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "score": 1.0, "surface_similarity": 0.7243969439436861}
{"id": "p03494_u599547273", "golden_code": "def two_count(x):\n\n\tif int(str(x)[-1]) % 2 == 0:\n\n\t\treturn 1 + two_count(x//2)\n\n\telse:\n\n\t\treturn 0\n\n\n\nn = int(eval(input()))\n\nn_list = [int(n) for n in input().split(\" \")]\n\n\n\nn_two_count_list = [two_count(n) for n in n_list]\n\n\n\nprint((min(n_two_count_list)))", "generated_code": "def two_count(x):\n\n\tif x % 2 == 0:\n\n\t\treturn 1 + two_count(x//2)\n\n\telse:\n\n\t\treturn 0\n\n\n\nn = int(eval(input()))\n\nn_list = [int(n) for n in input().split(\" \")]\n\n\n\nn_two_count_list = [two_count(n) for n in n_list]\n\n\n\nprint((min(n_two_count_list)))", "score": 1.0, "surface_similarity": 0.8959451401311866}
{"id": "p02814_u648881683", "golden_code": "from functools import reduce\n\nimport fractions\n\nimport numpy as np\n\n\n\nN, M = list(map(int, input().split()))\n\na = np.array(list(map(int, input().split())))\n\n\n\na = a // 2\n\n\n\ndef lcm_base(x, y):\n\n    return (x * y) // fractions.gcd(x, y)\n\n\n\ndef lcm(*numbers):\n\n    return reduce(lcm_base, numbers, 1)\n\n\n\nl = lcm(*a)\n\nexist = not 0 in ((l//a)%2)\n\n\n\nif exist:\n\n    print(((M // l + 1 ) // 2))\n\nelse:\n\n    print((0))", "generated_code": "import sys, fractions, functools\n\ninput = lambda: sys.stdin.readline().rstrip() \n\nsys.setrecursionlimit(10**7)\n\nINF = 10**20\n\ndef I(): return int(eval(input()))\n\ndef F(): return float(eval(input()))\n\ndef S(): return eval(input())\n\ndef LI(): return [int(x) for x in input().split()]\n\ndef LI_(): return [int(x)-1 for x in input().split()]\n\ndef LF(): return [float(x) for x in input().split()]\n\ndef LS(): return input().split()\n\n\n\ndef lcm_base(x, y):\n\n    return (x * y) // fractions.gcd(x, y)\n\n\n\ndef lcm_list(numbers):\n\n    return functools.reduce(lcm_base, numbers, 1)\n\n\n\ndef resolve():\n\n    N, M = LI()\n\n    a = LI()\n\n\n\n    a_half = [i//2 for i in a]\n\n    a_half_lcm = lcm_list(a_half)\n\n    has_scm = not 0 in [a_half_lcm//i%2 for i in a_half]\n\n\n\n    if has_scm:\n\n        print(((M-a_half_lcm)//(2*a_half_lcm)+1))\n\n    else:\n\n        print((0))\n\n\n\nif __name__ == '__main__':\n\n    resolve()", "score": 1.0, "surface_similarity": 0.6185734136174155}
{"id": "p02883_u260216890", "golden_code": "import numpy as np\n\nN, K= list(map(int, input().split()))\n\nA=[int(i) for i in input().split()]\n\nF=[int(i) for i in input().split()]\n\n\n\nA=np.array(sorted(A, reverse=True))\n\nF=np.array(sorted(F))\n\n\n\nlower_bound=0\n\nupper_bound=np.max(A*F)\n\nK_tmp=0\n\n\n\nwhile upper_bound>=lower_bound:\n\n    mid=(lower_bound+upper_bound)//2\n\n    K_tmp=np.sum(np.maximum(A-mid//F, 0))\n\n    if K_tmp<=K:\n\n        upper_bound=mid-1\n\n    else:\n\n        lower_bound=mid+1\n\n\n\nprint(lower_bound)", "generated_code": "n,k=list(map(int,input().split()))\n\n*a,= list(map(int,input().split()))\n\n*f,= list(map(int,input().split()))\n\na=sorted(a)\n\nf=sorted(f, reverse=True)\n\n\n\ndef is_ok(arg):\n\n    cnt=0\n\n    for i in range(n):\n\n        cnt+=max(a[i]-arg//f[i], 0)\n\n    return cnt<=k\n\n\n\ndef meguru_bisect(ng, ok):\n\n    while (abs(ok - ng) > 1):\n\n        mid = (ok + ng) // 2\n\n        if is_ok(mid):\n\n            ok = mid\n\n        else:\n\n            ng = mid\n\n    return ok\n\n\n\nprint((meguru_bisect(-1, 10**12)))", "score": 1.0, "surface_similarity": 0.4778350515463918}
{"id": "p02635_u532966492", "golden_code": "def main():\n\n    mod = 998244353\n\n    s, k = input().split()\n\n    k = int(k)\n\n    n = len(s)\n\n\n\n    one = s.count(\"1\")\n\n\n\n    cnt = 0\n\n    zero_list = []\n\n    for i in range(n):\n\n        if s[i] == \"0\":\n\n            zero_list.append(cnt)\n\n            cnt = 0\n\n        else:\n\n            cnt += 1\n\n\n\n    z = 0\n\n    mm = min(one, k)\n\n\n\n    dp = [[0]*(one+1) for _ in [0]*(one+1)]\n\n    dp[0][0] = 1\n\n\n\n    for i in range(len(zero_list)):\n\n        dp2 = [[0]*(mm+1) for _ in [0]*(one+1)]\n\n        base = zero_list[i]\n\n        # j:何個今までに入れたか\n\n        for j in range(one+1):\n\n            # l:何個入れるか\n\n            for l in range(one+1-j):\n\n                if l < z+base-j:\n\n                    continue\n\n                ml = max(l-base, 0)\n\n                # p:これまでのペナルティ\n\n                for p in range(min(one, k)+1):\n\n                    q = p+ml\n\n                    if q <= mm:\n\n                        dp2[j+l][q] = (dp2[j+l][q]+dp[j][p]) % mod\n\n                    else:\n\n                        break\n\n        z += base\n\n        dp = dp2\n\n    print((sum([sum(i) for i in dp]) % mod))\n\n\n\n\n\nmain()", "generated_code": "def main():\n\n    mod = 998244353\n\n    s, k = input().split()\n\n    k, n, one, cnt, z, zero_list = int(k), len(s), s.count(\"1\")+1, 0, 0, []\n\n    for i in range(n):\n\n        if s[i] == \"0\":\n\n            zero_list.append(cnt)\n\n            cnt = 0\n\n        else:\n\n            cnt += 1\n\n    mm = min(one-1, k)\n\n\n\n    dp = [[0]*(mm+1) for _ in [0]*one]\n\n    dp[0][0] = 1\n\n\n\n    for i in zero_list:\n\n        dp2 = [[0]*(mm+1) for _ in [0]*one]\n\n        for j in range(one):\n\n            for l in range(max(z+i-j, 0), one-j):\n\n                ml = max(l-i, 0)\n\n                for p in range(min(j, mm-ml)+1):\n\n                    dp2[j+l][p+ml] = (dp2[j+l][p+ml]+dp[j][p]) % mod\n\n        z += i\n\n        dp = dp2\n\n    print((sum([sum(i) for i in dp]) % mod))\n\n\n\n\n\nmain()", "score": 1.0, "surface_similarity": 0.8569450581823539}
{"id": "p02386_u150984829", "golden_code": "n=int(eval(input()))\n\na=[list(map(int,input().split()))for _ in range(n)]\n\ndef f():\n\n for i in range(n-1):\n\n  d=a[i][:];d[3],d[4]=d[4],d[3]\n\n  for j in range(i+1,n):\n\n   e=a[j][:];e[3],e[4]=e[4],e[3]\n\n   for p in('012345','152043','215304','302541','410352','514320'):\n\n    f=[d[int(k)]for k in p]\n\n    g=f[1:5]*2\n\n    for k in range(4):\n\n     if(g[k:k+4]==e[1:5])*(f[0]==e[0])*(f[5]==e[5]):return 'No'\n\n return 'Yes'\n\nprint((f()))\n", "generated_code": "n=int(eval(input()))\n\na=[list(map(int,input().split()))for _ in range(n)]\n\ndef f():\n\n for i in range(n-1):\n\n  d=a[i][:];d[3],d[4]=d[4],d[3]\n\n  for j in range(i+1,n):\n\n   e=a[j][:];e[3],e[4]=e[4],e[3]\n\n   for p in('012345','152043','215304','302541','410352','514320'):\n\n    f=[d[int(k)]for k in p]\n\n    g=f[1:5]*2\n\n    for k in range(4):\n\n     if g[k:k+4]==e[1:5]:\n\n      if f[0]==e[0]:\n\n       if f[5]==e[5]:return 'No'\n\n return 'Yes'\n\nprint((f()))\n", "score": 1.0, "surface_similarity": 0.9888888888888889}
{"id": "p02814_u923270446", "golden_code": "from fractions import gcd\n\nn, m = list(map(int, input().split()))\n\na = [int(i) // 2 for i in input().split()]\n\nx = 1\n\nfor i in range(n):\n\n    x *= a[i] // gcd(x, a[i])\n\nfor i in a:\n\n    if x // i % 2 == 0:\n\n        print((0))\n\n        exit()\n\nprint(((m // x + 1) // 2))", "generated_code": "from math import gcd, ceil\n\nn, m = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\na = [i // 2 for i in a]\n\nl = 1\n\nfor i in a:\n\n    l *= i // gcd(l, i)\n\nfor i in a:\n\n    if l // i % 2 == 0:\n\n        print((0))\n\n        exit()\n\nprint((ceil((m // l) / 2)))", "score": 1.0, "surface_similarity": 0.8081723027375202}
{"id": "p03038_u716530146", "golden_code": "import sys\n\ninput = lambda: sys.stdin.readline()[:-1]\n\nn,m=list(map(int,input().split()))\n\na0=list(map(int,input().split()))\n\ndata=[list(map(int,input().split())) for i in range(m)]\n\nfor i in a0:\n\n\tdata.append([1,i])\n\ndata.sort(key=lambda tup:-tup[1])\n\nans=0\n\nfor num,val in data:\n\n\tif n>=num:\n\n\t\tn-=num\n\n\t\tans+=val*num\n\n\telse:\n\n\t\tans+=val*n\n\n\t\tbreak\n\nprint(ans)\n", "generated_code": "#!/usr/bin/env python3\n\nimport sys\n\nfrom collections import Counter\n\ninput = lambda: sys.stdin.readline()[:-1]\n\nsys.setrecursionlimit(10**8)\n\n\n\nans=0\n\nn,m=list(map(int,input().split()))\n\nA=list(map(int,input().split()))\n\nbc=[]\n\nfor i in range(m):\n\n    b,c=list(map(int,input().split()))\n\n    bc.append((c,b))\n\nC=Counter(A)\n\nbc+=list(C.items())\n\nbc.sort(key=lambda tup:-tup[0])\n\n# print(bc)\n\nfor c,b in bc:\n\n    if n>=b:\n\n        n-=b\n\n        ans+=c*b\n\n    else:\n\n        ans+=c*n\n\n        break\n\nprint(ans)\n\n\n", "score": 1.0, "surface_similarity": 0.7777777777777778}
{"id": "p03434_u860002137", "golden_code": "import numpy as np\n\n\n\nN = int(eval(input()))\n\na = np.array(list(map(int, input().split())))\n\n\n\na.sort()\n\na = a[::-1]\n\n\n\nprint((a[0::2].sum() - a[1::2].sum()))", "generated_code": "n = int(eval(input()))\n\narr = list(map(int, input().split()))\n\n\n\narr.sort(reverse=True)\n\n\n\nprint((sum(arr[0::2]) - sum(arr[1::2])))", "score": 1.0, "surface_similarity": 0.6838959212376934}
{"id": "p03200_u846634344", "golden_code": "import sys\n\nsys.setrecursionlimit(10**6)\n\nif sys.platform in (['ios','darwin','win32']):\n\n\tsys.stdin=open('Untitled.txt')\n\ninput = sys.stdin.readline\n\ndef INT(): return int(eval(input()))\n\ndef MAP(): return [int(s) for s in input().split()]\n\n\n\ndef main():\n\n\tS = input().rstrip()\n\n\tbcnt = 0\n\n\tA = []\n\n\tfor i in range(len(S)):\n\n\t\tif S[i] == 'B': bcnt += 1\n\n\t\tif S[i] == 'W': A.append(bcnt)\n\n\t\n\n\tprint((sum(A)))\n\n\n\nif __name__ == '__main__':\n\n\tmain()", "generated_code": "import sys\n\nsys.setrecursionlimit(10**6)\n\nif sys.platform in (['ios','darwin','win32']):\n\n\tsys.stdin=open('Untitled.txt')\n\ninput = sys.stdin.readline\n\ndef INT(): return int(eval(input()))\n\ndef MAP(): return [int(s) for s in input().split()]\n\n\n\ndef main():\n\n\tS = input().rstrip()\n\n\tbcnt = 0\n\n\tans = 0\n\n\tfor i in range(len(S)):\n\n\t\tif S[i] == 'B': bcnt += 1\n\n\t\tif S[i] == 'W': ans += bcnt\n\n\t\n\n\tprint(ans)\n\n\n\nif __name__ == '__main__':\n\n\tmain()", "score": 1.0, "surface_similarity": 0.9753914988814318}
{"id": "p02873_u981931040", "golden_code": "import numpy as np\n\nS = list(eval(input()))\n\nS_len = len(S)\n\nnum_lst = np.zeros(S_len + 1)\n\nfor i in range(S_len):\n\n    if S[i] == \"<\":\n\n        num_lst[i + 1] = max(num_lst[i] + 1, num_lst[i + 1])\n\n\n\n\n\nfor i in range(S_len - 1, -1 , -1):\n\n    if S[i] == \">\":\n\n        num_lst[i] = max(num_lst[i], num_lst[i + 1] + 1)\n\nprint((int(np.sum(num_lst))))", "generated_code": "S = list(eval(input()))\n\nnumList = [0] * (len(S) + 1)\n\nfor i in range(len(S)):\n\n    if S[i] == '<':\n\n        numList[i + 1] = numList[i] + 1\n\n\n\nfor i in range(len(S) - 1 , -1 , -1):\n\n    if S[i] == '>':\n\n        numList[i] = max(numList[i + 1] + 1 ,numList[i])\n\nprint((sum(numList)))", "score": 1.0, "surface_similarity": 0.7478448275862069}
{"id": "p02780_u813098295", "golden_code": "class SegmentTree:\n\n    seg_len = 1\n\n    node = []\n\n    def __init__(self, n):\n\n        while self.seg_len < n:\n\n            self.seg_len <<= 1\n\n        self.node = [ 0 for _ in range(self.seg_len*2) ]\n\n\n\n    def add(self, idx, v):\n\n        idx += self.seg_len\n\n        self.node[idx] += v\n\n        while True:\n\n            idx //= 2\n\n            if idx == 0:\n\n                break\n\n            self.node[idx] = self.node[idx*2] + self.node[idx*2+1]\n\n\n\n    def sum(self, l, r):\n\n        l += self.seg_len\n\n        r += self.seg_len\n\n        ret = 0\n\n        while l < r:\n\n            if l & 1 == 1:\n\n                ret += self.node[l]\n\n                l += 1\n\n            if r & 1 == 1:\n\n                ret += self.node[r-1]\n\n                r -= 1\n\n            l //= 2; r //= 2;\n\n        return ret\n\n\n\n\n\nn, k = list(map(int, input().split()))\n\np = [ int(x) for x in input().split() ]\n\n\n\nseg_tree = SegmentTree(n)\n\nfor i in range(n):\n\n    seg_tree.add(i, (1+p[i])/2)\n\n\n\nans = 0\n\nfor i in range(n-k+1):\n\n    ans = max(ans, seg_tree.sum(i, i+k))\n\n\n\nprint(ans)\n", "generated_code": "class SegmentTree:\n\n    seg_len = 1\n\n    node = []\n\n    def __init__(self, n):\n\n        while self.seg_len < n:\n\n            self.seg_len <<= 1\n\n        self.node = [ 0 for _ in range(self.seg_len*2) ]\n\n\n\n    def add(self, idx, v):\n\n        idx += self.seg_len\n\n        self.node[idx] += v\n\n        while True:\n\n            idx >>= 1\n\n            if idx == 0:\n\n                break\n\n            self.node[idx] = self.node[idx*2] + self.node[idx*2+1]\n\n\n\n    def sum(self, l, r):\n\n        l += self.seg_len\n\n        r += self.seg_len\n\n        ret = 0\n\n        while l < r:\n\n            if l & 1 == 1:\n\n                ret += self.node[l]\n\n                l += 1\n\n            if r & 1 == 1:\n\n                ret += self.node[r-1]\n\n                r -= 1\n\n            l >>= 1; r >>= 1;\n\n        return ret\n\n\n\n\n\nn, k = list(map(int, input().split()))\n\np = [ int(x) for x in input().split() ]\n\n\n\nseg_tree = SegmentTree(n)\n\nfor i in range(n):\n\n    seg_tree.add(i, (1+p[i])/2)\n\n\n\nans = 0\n\nfor i in range(n-k+1):\n\n    ans = max(ans, seg_tree.sum(i, i+k))\n\n\n\nprint(ans)\n", "score": 1.0, "surface_similarity": 0.9687316911633594}
{"id": "p03723_u930705402", "golden_code": "import time\n\nt=time.time()\n\nA,B,C=list(map(int,input().split()))\n\ncnt=0\n\nwhile(A%2==B%2==C%2==0):\n\n    a,b,c=A,B,C\n\n    A=b//2+c//2;B=a//2+c//2;C=a//2+b//2\n\n    cnt+=1\n\n    if(time.time()-t>=1):\n\n        print((-1))\n\n        exit()\n\nprint(cnt)", "generated_code": "A,B,C=list(map(int,input().split()))\n\ncnt=0\n\nif(A==B==C):\n\n    if A%2!=0:\n\n        print((0))\n\n    else:\n\n        print((-1))\n\n    exit()\n\nwhile(A%2==B%2==C%2==0):\n\n    a,b,c=A,B,C\n\n    A=b//2+c//2;B=a//2+c//2;C=a//2+b//2\n\n    cnt+=1\n\nprint(cnt)", "score": 1.0, "surface_similarity": 0.6630298273155416}
{"id": "p03416_u780475861", "golden_code": "a,b = list(map(int, input().split()))\n\nn = 0\n\nfor i in range(a, b + 1):\n\n    f = True\n\n    s = str(i)\n\n    l = len(s)\n\n    for j in range(l//2 + 1):\n\n        if s[j] != s[- j - 1]:\n\n            f = False\n\n            break\n\n    if f:\n\n        n += 1\n\nprint(n)", "generated_code": "a,b = list(map(int, input().split()))\n\nn = 0\n\nfor i in range(1, 10):\n\n    for j in range(10):\n\n        for k in range(10):\n\n            s = 10000 * i + 1000 * j + 100 * k + 10 * j + i\n\n            if a <= s <= b:\n\n                n += 1\n\nprint(n)", "score": 1.0, "surface_similarity": 0.6802791802791803}
{"id": "p03723_u021548497", "golden_code": "import numpy as np\n\ncookies = np.array([int(x) for x in input().split()])\n\n\n\nif any(cookies%2):\n\n  ans = 0\n\nelif cookies[0] == cookies[1] == cookies[2]:\n\n  ans = -1\n\nelse:\n\n  ans = 0\n\n  while True:\n\n    if not any(cookies%2):\n\n      cookies = cookies//2\n\n      ans += 1\n\n      continue\n\n    if all(cookies%2):\n\n      ans += 1\n\n    break\n\nprint(ans)", "generated_code": "a, b, c = list(map(int, input().split()))\n\nif a == b == c and a%2 == 0:\n\n  print((-1))\n\nelif a%2 or b%2 or c%2:\n\n  print((0))\n\nelse:\n\n  ans = 0\n\n  while a%2 == b%2 == c%2 == 0:\n\n    a, b, c = (b+c)//2, (a+c)//2, (a+b)//2\n\n    ans += 1\n\n  print(ans)", "score": 1.0, "surface_similarity": 0.5559038662486939}
{"id": "p03752_u968166680", "golden_code": "import sys\n\n\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\nreadlines = sys.stdin.readlines\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = 1 << 60\n\n\n\n\n\ndef main():\n\n    N, K, *A = list(map(int, read().split()))\n\n\n\n    ans = INF\n\n    for bit in range(1 << N):\n\n        if (not (bit & 1)) or bin(bit).count('1') != K:\n\n            continue\n\n\n\n        total = 0\n\n        max_height = A[0]\n\n        for i, a in enumerate(A[1:], 1):\n\n            if a <= max_height:\n\n                if bit & (1 << i):\n\n                    total += max_height - a + 1\n\n                    max_height += 1\n\n            else:\n\n                max_height = a\n\n\n\n        if ans > total:\n\n            ans = total\n\n\n\n    print(ans)\n\n\n\n    return\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "generated_code": "import sys\n\nfrom itertools import combinations\n\n\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\nreadlines = sys.stdin.readlines\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = 1 << 60\n\n\n\n\n\ndef main():\n\n    N, K, *A = list(map(int, read().split()))\n\n\n\n    ans = INF\n\n    for comb in combinations(list(range(1, N)), K - 1):\n\n        included = [False] * N\n\n        for i in comb:\n\n            included[i] = True\n\n\n\n        total = 0\n\n        max_height = A[0]\n\n        for i, a in enumerate(A[1:], 1):\n\n            if a <= max_height:\n\n                if included[i]:\n\n                    total += max_height - a + 1\n\n                    max_height += 1\n\n            else:\n\n                max_height = a\n\n\n\n        if ans > total:\n\n            ans = total\n\n\n\n    print(ans)\n\n\n\n    return\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 1.0, "surface_similarity": 0.8105789009697326}
{"id": "p02952_u347600233", "golden_code": "import math\n\nn = int(eval(input()))\n\ncnt = 0\n\nfor i in range(1, n + 1):\n\n    if math.floor(math.log10(i) + 1) % 2:\n\n        cnt += 1\n\nprint(cnt)", "generated_code": "n = int(eval(input()))\n\ncnt = 0\n\nfor i in range(1, n + 1):\n\n    if len(str(i)) % 2:\n\n        cnt += 1\n\nprint(cnt)", "score": 1.0, "surface_similarity": 0.804125816993464}
{"id": "p02773_u423966555", "golden_code": "from collections import defaultdict\n\nn = int(eval(input()))\n\n\n\nd = defaultdict(int)\n\nfor _ in range(n):\n\n    key = eval(input())\n\n    d[key] += 1\n\n\n\ndict = sorted(list(d.items()), key=lambda x:x[1], reverse=True)\n\nmax_v = max(d.values())\n\n\n\ndict_li = []\n\nfor a in dict:\n\n    if a[1]==max_v:\n\n        dict_li.append(a[0])\n\n\n\ndict_li.sort()\n\nfor s in dict_li:\n\n    print(s)\n", "generated_code": "from collections import defaultdict\n\nn = int(input())\n\n\n\nd = defaultdict(int)\n\nfor _ in range(n):\n\n    key = input()\n\n    d[key] += 1\n\n\n\ndict = sorted(d.items(), key=lambda x:x[1], reverse=True)\n\nmax_v = max(d.values())\n\n\n\ndict_li = []\n\nfor a in dict:\n\n    if a[1]==max_v:\n\n        dict_li.append(a[0])\n\n\n\ndict_li.sort()\n\nprint(*dict_li, sep='\\n')\n", "score": 1.0, "surface_similarity": 0.9356451612903225}
{"id": "p03273_u933622697", "golden_code": "# Use numpy if you use column operation\n\nimport numpy as np\n\nh, w =  list(map(int, input().split()))\n\n\n\n# Get grid colors\n\ngird_colors = np.array([])\n\nfor _ in range(h):\n\n    tmp_row = np.array(list(eval(input())))\n\n    if \"#\" in tmp_row: # If the row includes black\n\n        gird_colors = np.concatenate((gird_colors, tmp_row))\n\ngird_colors = gird_colors.reshape(-1, w)\n\n\n\n# Search and delete white line\n\ndel_count = 0\n\nfor wi in range(w):\n\n    if \"#\" not in gird_colors[:, wi - del_count]:\n\n        gird_colors = np.delete(gird_colors, wi - del_count, 1)\n\n        del_count += 1\n\n\n\n# Print result\n\nfor line_val in gird_colors:\n\n    print((\"\".join(line_val))) ", "generated_code": "h, w = list(map(int, input().split()))\n\ngrid = [list(eval(input())) for _ in range(h)]\n\n\n\n# Filtering the data if any \"#\" are existed in the each row or col\n\n# Usage: filter(lambda row: <filtering condition>, grid or zip(*grid)) \n\n# If true, the row is not be deleted\n\n# (Do not use if statement!)\n\nrow_compressed_grid = list([row for row in grid if any(x == \"#\" for x in row)])\n\ncompressed_grid = list([col for col in zip(*row_compressed_grid) if any(x == \"#\" for x in col)])\n\n# list -> string and out\n\nfor row in zip(*compressed_grid):\n\n    print((\"\".join(row)))", "score": 1.0, "surface_similarity": 0.4692614495942787}
{"id": "p03721_u867826040", "golden_code": "n,k = list(map(int,input().split()))\n\nl = [0]*(10**5+1)\n\nfor i in range(n):\n\n    ai,bi = list(map(int,input().split()))\n\n    l[ai]+=bi\n\nfor index,i in enumerate(l):\n\n    if i:\n\n        k-=i\n\n        if k<=0:\n\n            break\n\nprint(index)", "generated_code": "from collections import defaultdict\n\nfrom sys import stdin\n\ninput = stdin.readline\n\nd = defaultdict(int)\n\nn,k = list(map(int,input().split()))\n\nfor _ in range(n):\n\n    a,b = list(map(int,input().split()))\n\n    d[a]+=b\n\nfor key in sorted(d.keys()):\n\n    v = d[key]\n\n    k-=v\n\n    if k <= 0:\n\n        break\n\nprint(key)", "score": 1.0, "surface_similarity": 0.6615141187925999}
{"id": "p03416_u271934630", "golden_code": "A, B = list(map(int, input().split()))\n\ncnt = 0\n\nfor i in range(A, B+1):\n\n    l = list(str(i))\n\n\n\n    if l == list(reversed(l)):\n\n        cnt += 1\n\n\n\nprint(cnt)\n", "generated_code": "A, B = list(map(int, input().split()))\n\ncnt = 0\n\nfor i in range(A, B+1):\n\n    l = str(i)\n\n    if l == l[::-1]:\n\n        cnt += 1\n\n\n\nprint(cnt)\n", "score": 1.0, "surface_similarity": 0.8364389233954451}
{"id": "p03363_u680851063", "golden_code": "n = int(eval(input()))\n\nary = list(map(int, input().split()))\n\n#print(n,ary)\n\n\n\nary_2 = [ary[0]]\n\nfor i in range(1, n):\n\n    ary_2.append(ary[i] + ary_2[i-1])\n\nary_2 = [0] + ary_2\n\n#print(ary_2)\n\n\n\nfrom collections import Counter\n\nc = Counter(ary_2)\n\nv = (list(c.values()))\n\n#print(v)\n\n\n\nfrom math import factorial\n\ndef combinations_count(n, r):\n\n    return factorial(n) // (factorial(n - r) * factorial(r))\n\n\n\nans = 0\n\nfor j in v:\n\n    if j >1:\n\n        ans += combinations_count(j,2)\n\n\n\nprint(ans)", "generated_code": "n = int(eval(input()))\n\nary = list(map(int, input().split()))\n\n#print(n,ary)\n\n\n\nary_2 = [ary[0]]\n\nfor i in range(1, n):\n\n    ary_2.append(ary[i] + ary_2[i-1])\n\nary_2 = [0] + ary_2\n\n#print(ary_2)\n\n\n\nfrom collections import Counter\n\nc = Counter(ary_2)\n\nv = (list(c.values()))\n\n#print(v)\n\n\n\nans = 0\n\nfor j in v:\n\n    if j >1:\n\n        ans += j * (j-1) // 2\n\n\n\nprint(ans)\n", "score": 1.0, "surface_similarity": 0.8043229315774405}
{"id": "p02983_u437215432", "golden_code": "import numpy as np\n\n\n\ndef ABC133C(l, r):\n\n    Min = np.inf\n\n    for i in range(l, r):\n\n        for j in range(i+1, r+1):\n\n            a = (i * j) % 2019\n\n            if a < Min:\n\n                Min = a\n\n                if a == 0: # ここに注目\n\n                    print(Min)\n\n                    return\n\n    print(Min)\n\n\n\nl, r = list(map(int, input().split()))\n\nABC133C(l, r)\n", "generated_code": "def ABC133C(l, r):\n\n    Min = 1e10\n\n    for i in range(l, r):\n\n        for j in range(i+1, r+1):\n\n            a = (i * j) % 2019\n\n            if a < Min:\n\n                Min = a\n\n                if a == 0: # ここに注目\n\n                    print(Min)\n\n                    return\n\n    print(Min)\n\n\n\nl, r = list(map(int, input().split()))\n\nABC133C(l, r)\n", "score": 1.0, "surface_similarity": 0.9304301075268817}
{"id": "p02792_u761320129", "golden_code": "N = int(eval(input()))\n\nmem = [[0]*10 for i in range(10)]\n\n\n\nfor i in range(1,N+1):\n\n    a = int(str(i)[0])\n\n    b = int(str(i)[-1])\n\n    mem[a][b] += 1\n\n\n\nans = 0\n\nfor i in range(1,N+1):\n\n    a = int(str(i)[0])\n\n    b = int(str(i)[-1])\n\n    ans += mem[b][a]\n\nprint(ans)", "generated_code": "N = int(eval(input()))\n\n\n\nd = [[0]*10 for i in range(10)]\n\nfor n in range(1,N+1):\n\n    s = str(n)\n\n    d[int(s[0])][int(s[-1])] += 1\n\nans = 0\n\nfor i in range(10):\n\n    for j in range(10):\n\n        ans += d[i][j] * d[j][i]\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.8611111111111112}
{"id": "p03796_u790012205", "golden_code": "N = int(eval(input()))\n\np = 1\n\nfor i in range(N):\n\n    p *= (i + 1)\n\n    p %= (1e9 + 7)\n\nprint((int(p)))", "generated_code": "N = int(eval(input()))\n\np = 1\n\nfor i in range(N):\n\n    p = p * (i + 1) % (1e9 + 7)\n\nprint((int(p)))", "score": 1.0, "surface_similarity": 0.9354395604395604}
{"id": "p02725_u771634798", "golden_code": "k, n = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\n\n\ndiff = []\n\n\n\nfor i in range(n - 1):\n\n    diff.append(a[i + 1] - a[i])\n\ndiff.append(k - a[-1] + a[0])\n\n\n\nprint((k - max(diff)))\n", "generated_code": "k, n = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\n\n\na.append(k + a[0])\n\ndiff = [a1 - a0 for a0, a1 in zip(a, a[1:])]\n\n\n\nprint((k - max(diff)))\n", "score": 1.0, "surface_similarity": 0.6952780229479258}
{"id": "p03253_u562935282", "golden_code": "class Calc:\n\n    def __init__(self, max_value, mod):\n\n        \"\"\"combination(max_value, all)\"\"\"\n\n        fact = [-1] * (max_value + 1)\n\n        fact[0] = 1\n\n        fact[1] = 1\n\n        for x in range(2, max_value + 1):\n\n            fact[x] = x * fact[x - 1] % mod\n\n\n\n        invs = [1] * (max_value + 1)\n\n        invs[max_value] = pow(fact[max_value], mod - 2, mod)\n\n        for x in range(max_value - 1, 0, -1):\n\n            invs[x] = invs[x + 1] * (x + 1) % mod\n\n\n\n        self.fact = fact\n\n        self.invs = invs\n\n        self.mod = mod\n\n\n\n    def combination(self, n, r):\n\n        if n - r < r:\n\n            return self.combination(n, n - r)\n\n        if r < 0:\n\n            return 0\n\n        if r == 0:\n\n            return 1\n\n        if r == 1:\n\n            return n\n\n        return self.fact[n] * self.invs[r] * self.invs[n - r] % self.mod\n\n\n\n\n\ndef gen(n):\n\n    x = n\n\n    d = 2\n\n    cnt = 0\n\n    while x % d == 0:\n\n        x //= d\n\n        cnt += 1\n\n    yield cnt\n\n\n\n    d = 3\n\n    ma = d * d\n\n    while ma <= n:\n\n        cnt = 0\n\n        while x % d == 0:\n\n            x //= d\n\n            cnt += 1\n\n        yield cnt\n\n        ma += d * 4 + 4\n\n        d += 2\n\n\n\n    if x > 1:\n\n        yield 1\n\n\n\n\n\ndef main():\n\n    MOD = 10 ** 9 + 7\n\n\n\n    N, M = list(map(int, input().split()))\n\n\n\n    cal = Calc(max_value=N + 30, mod=MOD)\n\n\n\n    ans = 1\n\n    for cnt in gen(M):\n\n        ans = (ans * cal.combination(N + cnt - 1, cnt)) % MOD\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "generated_code": "def gen(n):\n\n    x = n\n\n    d = 2\n\n    cnt = 0\n\n    while x % d == 0:\n\n        x //= d\n\n        cnt += 1\n\n    yield cnt\n\n\n\n    d = 3\n\n    while d * d <= n:\n\n        cnt = 0\n\n        while x % d == 0:\n\n            x //= d\n\n            cnt += 1\n\n        yield cnt\n\n        d += 2\n\n\n\n    if x > 1:\n\n        yield 1\n\n\n\n\n\ndef main():\n\n    MOD = 10 ** 9 + 7\n\n\n\n    N, M = list(map(int, input().split()))\n\n\n\n    ans = 1\n\n    for cnt in gen(M):\n\n        for d in range(cnt):\n\n            ans = (ans * (N - 1 + cnt - d) % MOD) * pow(d + 1, MOD - 2, MOD) % MOD\n\n            \n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 1.0, "surface_similarity": 0.6793730650154799}
{"id": "p02983_u952708174", "golden_code": "def c_remainder_minimization_2019(L, R):\n\n    ans = float('inf')\n\n    for i in range(L, min(R, L + 2019)):\n\n        for j in range(i + 1, min(R + 1, L + 2020)):\n\n            ans = min(ans, (i * j) % 2019)\n\n    return ans\n\n\n\nL, R = [int(i) for i in input().split()]\n\nprint((c_remainder_minimization_2019(L, R)))", "generated_code": "def c_remainder_minimization_2019(L, R):\n\n    ans = float('inf')\n\n    for i in range(L, min(R, L + 2019)):\n\n        for j in range(i + 1, min(R + 1, L + 2020)):\n\n            ans = min(ans, (i * j) % 2019)\n\n            if ans == 0:\n\n                return 0\n\n    return ans\n\n\n\nL, R = [int(i) for i in input().split()]\n\nprint((c_remainder_minimization_2019(L, R)))", "score": 1.0, "surface_similarity": 0.9126381215469613}
{"id": "p03371_u562935282", "golden_code": "a, b, c, x, y = list(map(int, input().split()))\n\nval = float('inf')\n\nfor k in range(10 ** 5 + 1):\n\n    val = min(val, 2 * c * k + max(x - k, 0) * a + max(y - k, 0) * b)\n\nprint(val)", "generated_code": "A, B, C, X, Y = list(map(int, input().split()))\n\n\n\nans = 0\n\nans += min(A + B, 2 * C) * min(X, Y)\n\nif X > Y:\n\n    ans += min(A, 2 * C) * (X - Y)\n\nelif X < Y:\n\n    ans += min(B, 2 * C) * (Y - X)\n\nprint(ans)\n", "score": 1.0, "surface_similarity": 0.6382113821138211}
{"id": "p02690_u163320134", "golden_code": "x=int(eval(input()))\n\ndic={}\n\nfor i in range(10**5):\n\n  dic[i**5]=i\n\n  dic[(-i)**5]=-i\n\nfor i in range(10**5):\n\n    if i**5+x in dic:\n\n      print((dic[i**5+x],i))\n\n      break\n\n    if (-i)**5+x in dic:\n\n      print((dic[(-i)**5+x],-i))\n\n      break", "generated_code": "x=int(eval(input()))\n\nfor a in range(-118,120):\n\n  for b in range(-119,119):\n\n    if a**5-b**5==x:\n\n      print((a,b))\n\n      exit()", "score": 1.0, "surface_similarity": 0.5903614457831325}
{"id": "p03796_u869919400", "golden_code": "from math import factorial as f\n\nn = int(eval(input()))\n\nprint((f(n) % (10 ** 9 + 7)))", "generated_code": "n = int(eval(input()))\n\np = 1\n\nfor i in range(n):\n\n    p = (p * (i+1)) % (10 ** 9 + 7)\n\nprint(p)", "score": 1.0, "surface_similarity": 0.5885416666666667}
{"id": "p02649_u102461423", "golden_code": "import sys\n\nimport numpy as np\n\nfrom numba import njit\n\n\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\n@njit('(i4[::1],i4,i8[::1])', cache=True)\n\ndef main(A, B, C):\n\n    counts = np.zeros(1 << 18, np.int32)\n\n    popcount = np.zeros(1 << B, np.int32)\n\n    for i in range(B):\n\n        popcount[1 << i:1 << i + 1] = popcount[:1 << i] + 1\n\n\n\n    answer = 0\n\n    for i in range(1 << B):\n\n        k = popcount[i]\n\n        t = 0\n\n        for x in A & i:\n\n            n = counts[x]\n\n            counts[x] += 1\n\n            t -= C[n]\n\n            t += C[n + 1]\n\n        for x in A & i:\n\n            counts[x] = 0\n\n        if k & 1:\n\n            t = -t\n\n        answer += t\n\n    return answer\n\n\n\nN, K, S, T = list(map(int, readline().split()))\n\nA = np.array(readline().split(), np.int32)\n\n\n\ndef convert_problem(S, T, A):\n\n    ng = np.zeros(len(A), np.bool)\n\n    B = np.zeros_like(A)\n\n    n = 0\n\n    for i in range(18):\n\n        s, t = (S >> i) & 1, (T >> i) & 1\n\n        if (s, t) == (0, 0):\n\n            ng |= ((A >> i) & 1) == 1\n\n        elif (s, t) == (1, 1):\n\n            ng |= ((A >> i) & 1) == 0\n\n        elif (s, t) == (1, 0):\n\n            print((0))\n\n            exit()\n\n        else:\n\n            B += ((A >> i) & 1) << n\n\n            n += 1\n\n    return B[~ng], n\n\n\n\nA, B = convert_problem(S, T, A)\n\n\n\nC = np.zeros((100, 100), np.int64)\n\nC[0, 0] = 1\n\nfor n in range(1, 100):\n\n    C[n, :-1] += C[n - 1, :-1]\n\n    C[n, 1:] += C[n - 1, :-1]\n\nC = C[:, 1:K + 1].sum(axis=1)\n\n\n\nprint((main(A, B, C)))", "generated_code": "import sys\n\nimport numpy as np\n\nfrom numba import njit\n\n\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\n@njit('(i4[::1],i4,i8[::1])', cache=True)\n\ndef main(A, B, C):\n\n    counts = np.zeros(1 << 18, np.int32)\n\n    popcount = np.zeros(1 << B, np.int32)\n\n    for i in range(B):\n\n        popcount[1 << i:1 << i + 1] = popcount[:1 << i] + 1\n\n\n\n    answer = 0\n\n    for i in range(1 << B):\n\n        k = popcount[i]\n\n        t = 0\n\n        for x in A & i:\n\n            n = counts[x]\n\n            counts[x] += 1\n\n            t -= C[n]\n\n            t += C[n + 1]\n\n        for x in A & i:\n\n            counts[x] = 0\n\n        if k & 1:\n\n            t = -t\n\n        answer += t\n\n    return answer\n\n  \n\nif sys.argv[-1] == 'ONLINE_JUDGE':\n\n    from numba.pycc import CC\n\n    cc = CC('my_module')\n\n    cc.export('main', '(i4[::1],i4,i8[::1])')(main)\n\n    cc.compile()\n\n    exit()\n\nfrom my_module import main\n\n\n\nN, K, S, T = list(map(int, readline().split()))\n\nA = np.array(readline().split(), np.int32)\n\n\n\ndef convert_problem(S, T, A):\n\n    ng = np.zeros(len(A), np.bool)\n\n    B = np.zeros_like(A)\n\n    n = 0\n\n    for i in range(18):\n\n        s, t = (S >> i) & 1, (T >> i) & 1\n\n        if (s, t) == (0, 0):\n\n            ng |= ((A >> i) & 1) == 1\n\n        elif (s, t) == (1, 1):\n\n            ng |= ((A >> i) & 1) == 0\n\n        elif (s, t) == (1, 0):\n\n            print((0))\n\n            exit()\n\n        else:\n\n            B += ((A >> i) & 1) << n\n\n            n += 1\n\n    return B[~ng], n\n\n\n\nA, B = convert_problem(S, T, A)\n\n\n\nC = np.zeros((100, 100), np.int64)\n\nC[0, 0] = 1\n\nfor n in range(1, 100):\n\n    C[n, :-1] += C[n - 1, :-1]\n\n    C[n, 1:] += C[n - 1, :-1]\n\nC = C[:, 1:K + 1].sum(axis=1)\n\n\n\nprint((main(A, B, C)))", "score": 1.0, "surface_similarity": 0.9532842582106456}
{"id": "p03039_u227082700", "golden_code": "n,m,k=list(map(int,input().split()))\n\nmod=10**9+7\n\nf=[1]\n\nfor i in range(2*10**5+7):f+=[f[-1]*(i+1)%mod]\n\ndef comb(a,b):return f[a]*pow(f[b],mod-2,mod)*pow(f[a-b],mod-2,mod)%mod\n\nans=0\n\nfor i in range(1,n):\n\n  ans+=(i*(n-i)*m**2)*(comb(n*m-2,k-2))\n\n  ans%=mod\n\nfor i in range(1,m):\n\n  ans+=(i*(m-i)*n**2)*(comb(n*m-2,k-2))\n\n  ans%=mod\n\nprint(ans)", "generated_code": "n,m,k=list(map(int,input().split()))\n\n\n\nmod = 10**9+7\n\nf = [1]\n\nfor i in range(n*m):\n\n  f += [f[-1]*(i+1) % mod]\n\ndef comb(a, b):\n\n  return f[a]*pow(f[b], mod-2, mod)*pow(f[a-b], mod-2, mod) % mod\n\n\n\nans=0\n\nfor dist in range(1,n):\n\n  c=n-dist\n\n  p=(c*m*m)%mod\n\n  ans+=p*dist\n\nfor dist in range(1,m):\n\n  c=m-dist\n\n  p=(c*n*n)%mod\n\n  ans+=p*dist\n\nans%=mod\n\nprint((ans*comb(n*m-2,k-2)%mod))", "score": 1.0, "surface_similarity": 0.8656330749354005}
{"id": "p03273_u987164499", "golden_code": "from sys import stdin\n\nimport numpy as np\n\n\n\nh,w= [int(x) for x in stdin.readline().rstrip().split()]\n\n\n\nli = [[\"\" for i in range(w)]for j in range(h)]\n\n\n\nfor i in range(h):\n\n    s = stdin.readline().rstrip()\n\n    for j in range(w):\n\n        li[i][j] = s[j]\n\n\n\nli = np.asarray([s for s in li if s != ['.']*w]).T.tolist()\n\nli = np.asarray([s for s in li if s != ['.']*len(li[0])]).T.tolist()\n\n\n\nfor i in li:\n\n    s = \"\"\n\n    for j in range(len(li[0])):\n\n        s += i[j]\n\n    print(s)", "generated_code": "from sys import stdin,setrecursionlimit\n\nsetrecursionlimit(10 ** 7)\n\nh,w = list(map(int,stdin.readline().rstrip().split()))\n\nli = [[\"\" for i in range(w)]for j in range(h)]\n\nfor i in range(h):\n\n    s = stdin.readline().rstrip()\n\n    for j in range(w):\n\n        li[i][j] = s[j]\n\nlin = []\n\nfor i in li:\n\n    if i != [\".\"]*w:\n\n        lin.append(i)\n\nout = []\n\nfor i in range(w):\n\n    flag = True\n\n    for j in range(len(lin)):\n\n        if lin[j][i] == \"#\":\n\n            flag = False\n\n    if flag:\n\n        out.append(i)\n\n\n\nlis = []\n\nfor i in lin:\n\n    case = []\n\n    for j,k in enumerate(i):\n\n        if j in out:\n\n            continue\n\n        case.append(k)\n\n    lis.append(case)\n\n\n\nfor i in lis:\n\n    print((\"\".join(i)))", "score": 1.0, "surface_similarity": 0.6886416318961521}
{"id": "p03796_u617203831", "golden_code": "import math\n\nprint((math.factorial(int(eval(input())))%(10**9+7)))", "generated_code": "ans=1\n\nn=int(eval(input()))\n\nfor i in range(1,n+1):\n\n  ans*=i\n\n  ans=ans%(10**9+7)\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.4479905437352246}
{"id": "p03371_u844789719", "golden_code": "A, B, C, X, Y = [int(_) for _ in input().split()]\n\nans = A * X + B * Y\n\nfor i in range(max(X, Y) + 1):\n\n    cost = 2 * C * i\n\n    if X > i:\n\n        cost += A * (X - i)\n\n    if Y > i:\n\n        cost += B * (Y - i)\n\n    ans = min(ans, cost)\n\nprint(ans)", "generated_code": "A, B, C, X, Y = [int(_) for _ in input().split()]\n\nM = max(X, Y)\n\nprint((min(2 * C * M, 2 * C * (X + Y - M) + A *\n\n          (M - Y) + B * (M - X), A * X + B * Y)))\n", "score": 1.0, "surface_similarity": 0.696952380952381}
{"id": "p02899_u678167152", "golden_code": "import numpy\n\nN = int(input())\n\nA = list(map(int, input().split()))\n\ninds = numpy.argsort(A)\n\ninds+=1\n\nfor ind in inds:\n\n  print(ind, end=' ')\n", "generated_code": "N = int(eval(input()))\n\nA = list(map(int, input().split()))\n\nans = [0]*N\n\nfor i,a in enumerate(A):\n\n  ans[a-1] = i+1\n\nprint((*ans))", "score": 1.0, "surface_similarity": 0.5013681970203709}
{"id": "p03945_u691018832", "golden_code": "s = eval(input())\n\nlen_s = len(s)\n\ncnt = [0, 0]\n\nfor i in range(1, len(s)):\n\n    memo_0 = s[i - 1]\n\n    memo_1 = s[len_s - i]\n\n    if s[i] != memo_0:\n\n        cnt[0] += 1\n\n    if s[len_s - i - 1] != memo_1:\n\n        cnt[1] += 1\n\nprint((min(cnt)))\n", "generated_code": "s = eval(input())\n\nlen_s = len(s)\n\ncnt = 0\n\nfor i in range(1, len(s)):\n\n    memo_0 = s[i - 1]\n\n    if s[i] != memo_0:\n\n        cnt += 1\n\nprint(cnt)\n", "score": 1.0, "surface_similarity": 0.8400809716599189}
{"id": "p03371_u832039789", "golden_code": "import math\n\n\n\na,b,c,x,y = list(map(int,input().split()))\n\n\n\n# cを全探索？\n\nres = float('inf')\n\nfor i in range(max(x,y)*2+1):\n\n    money = i * c\n\n    if i/2<x:\n\n        money += math.ceil(x-i/2) * a\n\n    if i/2<y:\n\n        money += math.ceil(y-i/2) * b\n\n    res = min(res,money)\n\n\n\nprint(res)\n", "generated_code": "res = 10**30\n\na,b,c,x,y = list(map(int,input().split()))\n\nfor i in range(0,max(x,y)+1):\n\n    # ABを2*iまい買う\n\n    tmp = 2 * i * c\n\n    xx,yy = x - i, y - i\n\n    tmp += max(0,xx) * a\n\n    tmp += max(0,yy) * b\n\n    res = min(res, tmp)\n\nprint(res)\n", "score": 1.0, "surface_similarity": 0.6828955314009661}
{"id": "p03640_u644907318", "golden_code": "H,W = list(map(int,input().split()))\n\nN = int(eval(input()))\n\nA = list(map(int,input().split()))\n\nA.insert(0,0)\n\nC = [[0 for _ in range(W)] for _ in range(H)]\n\ncur = [0,0,\"R\"]\n\nfor k in range(1,N+1):\n\n#     ipdb.set_trace()\n\n    a = A[k]\n\n    cnt = 0\n\n    y,x,d = cur\n\n    for i in range(y,H):\n\n        y = i\n\n        if d==\"R\":\n\n            for j in range(x,W):\n\n                C[i][j]=str(k)\n\n                cnt += 1\n\n                if j+1<W:\n\n                    x = j+1\n\n                else:\n\n                    x = j\n\n                if cnt==a:break\n\n            if cnt==a:break\n\n            d=\"L\"\n\n        else:\n\n            for j in range(x,-1,-1):\n\n                C[i][j]=str(k)\n\n                cnt += 1\n\n                if j>=1:\n\n                    x = j-1\n\n                else:\n\n                    x = 0\n\n                if cnt==a:break\n\n            if cnt==a:break\n\n            d=\"R\"\n\n    if x==W-1:\n\n        if C[y][x]!=0:\n\n            y += 1\n\n            d=\"L\"\n\n    elif x==0:\n\n        if C[y][x]!=0:\n\n            y += 1\n\n            d=\"R\"\n\n    cur = [y,x,d]                \n\nfor i in range(H):\n\n    print((*C[i]))", "generated_code": "H,W = list(map(int,input().split()))\n\nN = int(eval(input()))\n\nA = list(map(int,input().split()))\n\nA.insert(0,0)\n\nB = [[0 for _ in range(W)] for _ in range(H)]\n\ncol = 1\n\ncnt = 0\n\ny = 0\n\nx = 0\n\nd = \"R\"\n\nwhile y<H:\n\n    if cnt<A[col]:\n\n        B[y][x] = col\n\n        cnt += 1\n\n    else:\n\n        col += 1\n\n        cnt = 0\n\n        B[y][x] = col\n\n        cnt += 1\n\n    if x<W-1 and d==\"R\":\n\n        x += 1\n\n    elif x==W-1 and d==\"R\":\n\n        y += 1\n\n        d = \"L\"\n\n    elif d==\"L\" and x>0:\n\n        x -= 1\n\n    elif d==\"L\" and x==0:\n\n        y += 1\n\n        d = \"R\"\n\nfor i in range(H):\n\n    print((*B[i]))", "score": 1.0, "surface_similarity": 0.7328884060220395}
{"id": "p03000_u095021077", "golden_code": "import numpy as np\n\n\n\ntemp=list(map(int, input().split()))\n\n\n\nN=temp[0]\n\nX=temp[1]\n\n\n\nL=list(map(int, input().split()))\n\n\n\nind=1\n\nwhile np.sum(L[:ind])<=X and ind<=N:\n\n  ind+=1\n\n  \n\nprint(ind)", "generated_code": "N, X=list(map(int, input().split()))\n\nL=list(map(int, input().split()))\n\nL=[0]+L\n\n \n\nl=int(0)\n\ncounter=int(0)\n\nwhile l+L[counter]<=X and counter<=N:\n\n  l+=L[counter]\n\n  counter+=int(1)\n\n  if counter==N+1:\n\n    break\n\n  \n\nprint(counter)", "score": 1.0, "surface_similarity": 0.5503546099290779}
{"id": "p02988_u492447501", "golden_code": "import copy\n\nimport numpy as np\n\n\n\nS = eval(input())\n\n\n\nN = int(S)\n\n\n\nS = eval(input())\n\n\n\nP = list(map(int, S.split()))\n\n\n\ncheck = []\n\n\n\ncount = 0\n\n\n\nfor i in range(0, N-2, 1):\n\n\n\n    check = P[i:i+3]\n\n    check = np.array(check)\n\n    check = check.argsort()\n\n    if check[1] == 1:\n\n        count = count + 1\n\n\n\nprint(count)\n", "generated_code": "n = int(eval(input()))\n\nP = list(map(int, input().split()))\n\ncount = 0\n\nfor i in range(n-2):\n\n\n\n    P_temp = [P[i], P[i+1], P[i+2]]\n\n    P_temp.sort()\n\n    if P_temp[1] == P[i+1]:\n\n        count = count + 1\n\n\n\nprint(count)\n", "score": 1.0, "surface_similarity": 0.7401003904071388}
{"id": "p03558_u562016607", "golden_code": "import heapq\n\nK=int(eval(input()))\n\ndist=[10**15 for i in range(K)]\n\ndist[1]=1\n\nq=[]\n\nheapq.heappush(q,(0,1))\n\nwhile (len(q)!=0):\n\n    prc,src=heapq.heappop(q)\n\n    if dist[src]<prc:\n\n        continue\n\n    if dist[(src+1)%K]>dist[src]+1:\n\n        dist[(src+1)%K]=dist[src]+1\n\n        heapq.heappush(q,(dist[(src+1)%K],(src+1)%K))\n\n    if dist[(10*src)%K]>dist[src]:\n\n        dist[(10*src)%K]=dist[src]\n\n        heapq.heappush(q,(dist[(src*10)%K],(src*10)%K))\n\nprint((dist[0]))\n", "generated_code": "from collections import deque\n\nK=int(eval(input()))\n\ndist=[10**15 for i in range(K)]\n\ndist[1]=1\n\nq=deque([1])\n\nwhile(len(q)>0):\n\n    r=q.popleft()\n\n    s=(r+1)%K\n\n    if dist[r]+1<dist[s]:\n\n        dist[s]=dist[r]+1\n\n        q.append(s)\n\n    t=(r*10)%K\n\n    if dist[r]<dist[t]:\n\n        dist[t]=dist[r]\n\n        q.appendleft(t)\n\nprint((dist[0]))\n", "score": 1.0, "surface_similarity": 0.7091194968553459}
{"id": "p02994_u531220228", "golden_code": "import numpy as np\n\nN,L = list(map(int, input().split()))\n\ntaste = np.array([L+i-1 for i in range(1,N+1)])\n\nif taste[-1] < 0:\n\n  print((sum(taste) + min(np.abs(taste))))\n\nelse:\n\n  print((sum(taste) - min(np.abs(taste))))", "generated_code": "N,L = list(map(int, input().split()))\n\ntaste = [L+i-1 for i in range(1,N+1)]\n\nif taste[-1] < 0:\n\n  print((sum(taste) + min([abs(x) for x in taste])))\n\nelse:\n\n  print((sum(taste) - min([abs(x) for x in taste])))", "score": 1.0, "surface_similarity": 0.8446969696969697}
{"id": "p02899_u645250356", "golden_code": "from collections import Counter,defaultdict,deque\n\nimport sys,heapq,bisect,math,itertools,string,queue\n\nsys.setrecursionlimit(10**8)\n\nmod = 10**9+7\n\ndef inp(): return int(sys.stdin.readline())\n\ndef inpl(): return list(map(int, sys.stdin.readline().split()))\n\ndef inpl_str(): return list(sys.stdin.readline().split())\n\ndef inpln(n): return list(int(sys.stdin.readline()) for i in range(n))\n\n\n\nn = inp()\n\na = inpl()\n\naa = []\n\nfor i in range(n):\n\n    aa.append([i+1,a[i]])\n\naa.sort(key=lambda x:x[1])\n\nfor i in range(n):\n\n    print((aa[i][0]))\n\n\n", "generated_code": "from collections import Counter,defaultdict,deque\n\nfrom heapq import heappop,heappush\n\nfrom bisect import bisect_left,bisect_right \n\nimport sys,math,itertools,fractions\n\nsys.setrecursionlimit(10**8)\n\nmod = 10**9+7\n\nINF = float('inf')\n\ndef inp(): return int(sys.stdin.readline())\n\ndef inpl(): return list(map(int, sys.stdin.readline().split()))\n\n\n\nn = inp()\n\na = inpl()\n\nres = [0] * n\n\nfor i,x in enumerate(a):\n\n    res[x-1] = i+1\n\nprint((*res))\n", "score": 1.0, "surface_similarity": 0.6071407354601082}
{"id": "p03371_u049979154", "golden_code": "a, b, c, x, y = list(map(int, input().split()))\n\n\n\nans = float('inf')\n\n\n\nfor i in range(2 * 10**5 + 1):\n\n    ans = min(ans, a * max(x - i, 0) + b * max(y - i, 0) + 2 * c * i)\n\n\n\nprint(ans)", "generated_code": "A,B,C,X,Y = list(map(int,input().split()))\n\nmin_xy = min(X,Y)\n\nmax_xy = max(X,Y)\n\nans1 = 2 * C * min_xy + A * (X-min_xy) + B * (Y-min_xy) # 無駄にならない範囲でABピザを買い、残りを買う\n\nans2 = A*X + B*Y # ABピザを買わない\n\nans3 = 2 * C * max_xy # ABピザだけを買う\n\nprint((min(ans1,ans2,ans3)))", "score": 1.0, "surface_similarity": 0.7262596899224807}
{"id": "p02792_u287132915", "golden_code": "n = int(eval(input()))\n\n\n\ncnt = 0\n\nfor i in range(1, n+1):\n\n    i_str = str(i)\n\n    if len(i_str) == 1:\n\n        cnt += 1\n\n        continue\n\n    if len(i_str) == 2:\n\n        if int(i_str[0]) == int(i_str[1]):\n\n            cnt += 3\n\n        elif int(i_str[1]) != 0 and int(i_str[0]) > int(i_str[1]):\n\n            cnt += 2\n\n        continue\n\n    if len(i_str) == 3:\n\n        if int(i_str[0]) == int(i_str[2]):\n\n            cnt += 4 + (2 * (int(i_str[1])+1) - 1)\n\n        elif int(i_str[2]) != 0 and int(i_str[0]) > int(i_str[2]):\n\n            cnt += 22\n\n        elif int(i_str[0]) < int(i_str[2]):\n\n            cnt += 2\n\n        continue\n\n    if len(i_str) == 4:\n\n        if int(i_str[0]) == int(i_str[3]):\n\n            cnt += 24 + 20 * int(i_str[1]) + 2 * (int(i_str[2])+1) - 1\n\n        elif int(i_str[3]) != 0 and int(i_str[0]) > int(i_str[3]):\n\n            cnt += 222\n\n        elif int(i_str[0]) < int(i_str[3]):\n\n            cnt += 22\n\n        continue\n\n    if len(i_str) == 5:\n\n        if int(i_str[0]) == int(i_str[4]):\n\n            cnt += 224 + 200 * int(i_str[1]) + 20 * int(i_str[2]) + 2 * (int(i_str[3])+1) - 1\n\n        elif int(i_str[4]) != 0 and int(i_str[0]) > int(i_str[4]):\n\n            cnt += 2222\n\n        elif int(i_str[0]) < int(i_str[4]):\n\n            cnt += 222\n\n        continue\n\n    if len(i_str) == 6:\n\n        if int(i_str[0]) == int(i_str[5]):\n\n            cnt += 2224 + 2000 * int(i_str[1]) + 200 * int(i_str[2]) + 20 * int(i_str[3]) + 2 * (int(i_str[4])+1) - 1\n\n        elif int(i_str[5]) != 0 and int(i_str[0]) > int(i_str[5]):\n\n            cnt += 22222\n\n        elif int(i_str[0]) < int(i_str[5]):\n\n            cnt += 2222\n\n        continue\n\n\n\nprint(cnt)", "generated_code": "n = int(eval(input()))\n\n\n\nc = [[0 for _ in range(10)] for __ in range(10)]\n\nfor i in range(1, n+1):\n\n    str_i = str(i)\n\n    head = int(str_i[0])\n\n    tail = int(str_i[-1])\n\n    c[head][tail] += 1\n\n\n\ncnt = 0\n\nfor i in range(10):\n\n    for j in range(10):\n\n        cnt += c[i][j] * c[j][i]\n\n\n\nprint(cnt)", "score": 1.0, "surface_similarity": 0.4827586206896552}
{"id": "p03796_u285681431", "golden_code": "import math\n\n\n\nN = int(eval(input()))\n\nans = math.factorial(N) % (10**9 + 7)\n\nprint(ans)", "generated_code": "N = int(eval(input()))\n\nmod = 10**9 + 7\n\nans = 1\n\nfor i in range(1, N + 1):\n\n    ans *= i\n\n    ans %= mod\n\nprint(ans)\n", "score": 1.0, "surface_similarity": 0.6045197740112994}
{"id": "p03038_u562935282", "golden_code": "from heapq import heappop, heappush\n\n\n\nn, m = list(map(int, input().split()))\n\na = tuple(map(int, input().split()))\n\n\n\nhq = []\n\nfor aa in a:\n\n    heappush(hq, (-aa, 1))\n\n\n\nfor _ in range(m):\n\n    b, c = list(map(int, input().split()))\n\n    heappush(hq, (-c, b))\n\n\n\nrest = n\n\nans = 0\n\nwhile rest > 0:\n\n    num, cnt = heappop(hq)\n\n\n\n    num *= (-1)\n\n    use = min(rest, cnt)\n\n    ans += use * num\n\n    rest -= use\n\n\n\nprint(ans)\n", "generated_code": "def main():\n\n    from collections import Counter\n\n    from operator import itemgetter\n\n\n\n    import sys\n\n    input = sys.stdin.readline\n\n\n\n    N, M = list(map(int, input().split()))\n\n    a = list(map(int, input().split()))\n\n\n\n    ctr = Counter(a)\n\n    for _ in range(M):\n\n        b, c = list(map(int, input().split()))\n\n        ctr[c] += b\n\n\n\n    ans = 0\n\n    rest = N\n\n    for integer, count in sorted(list(ctr.items()), key=itemgetter(0), reverse=True):\n\n        take = min(rest, count)\n\n        ans += take * integer\n\n        rest -= take\n\n        if not rest:\n\n            break\n\n\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n\n\n\n# import sys\n\n# input = sys.stdin.readline\n\n# \n\n# sys.setrecursionlimit(10 ** 7)\n\n# \n\n# (int(x)-1 for x in input().split())\n\n# rstrip()\n", "score": 1.0, "surface_similarity": 0.6238370348139255}
{"id": "p03837_u808806124", "golden_code": "import numpy as np\n\n\n\nn, m = list(map(int, input().split()))\n\n\n\nd = np.ones((n, n)) * 1001\n\n\n\nes = []\n\nfor i in range(m):\n\n    es.append(list(map(int, input().split())))\n\n\n\nfor (i, j, w) in es:\n\n    d[i - 1][j - 1] = w\n\n    d[j - 1][i - 1] = w\n\n\n\n\n\nfor k in range(n):\n\n    for i in range(n):\n\n        for j in range(n):\n\n            l = d[i][k] + d[k][j]\n\n            if d[i][j] > l:\n\n                d[i][j] = l\n\n\n\nc = 0\n\nfor (i, j, w) in es:\n\n    if d[i - 1][j - 1] < w:\n\n        c += 1\n\n\n\nprint(c)\n", "generated_code": "n, m = list(map(int, input().split()))\n\n\n\nd = [[1001] * n for i in range(n)]\n\n\n\nes = []\n\nfor i in range(m):\n\n    es.append(list(map(int, input().split())))\n\n\n\nfor (i, j, w) in es:\n\n    d[i - 1][j - 1] = w\n\n    d[j - 1][i - 1] = w\n\n\n\n\n\nfor k in range(n):\n\n    for i in range(n):\n\n        for j in range(n):\n\n            l = d[i][k] + d[k][j]\n\n            if d[i][j] > l:\n\n                d[i][j] = l\n\n\n\nc = 0\n\nfor (i, j, w) in es:\n\n    if d[i - 1][j - 1] < w:\n\n        c += 1\n\n\n\nprint(c)", "score": 1.0, "surface_similarity": 0.8880017742293191}
{"id": "p03371_u170201762", "golden_code": "A,B,C,X,Y = list(map(int,input().split()))\n\nl = []\n\nfor i in range(max(X,Y)+1):\n\n    T = i * C * 2\n\n    if i < X: \n\n        T += (X-i)*A\n\n    if i < Y:\n\n        T += (Y-i)*B\n\n    l.append(T)\n\nl.sort()\n\nprint((l[0]))", "generated_code": "A,B,C,X,Y = list(map(int,input().split()))\n\nans = 0\n\nif 2*C <= A+B:\n\n    Z = min(X,Y)\n\n    ans = 2*C*Z\n\n    X -= Z\n\n    Y -= Z\n\nans += min(2*C*X,A*X)\n\nans += min(2*C*Y,B*Y)\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.6765419615773508}
{"id": "p02983_u426764965", "golden_code": "# 参考 https://atcoder.jp/contests/abc133/submissions/7966658\n\n\n\nimport numpy as np\n\n\n\ndef abc133_c():\n\n    L, R = list(map(int, input().split()))\n\n    if R - L > 673: return 0\n\n    x = np.arange(L, R+1, dtype=np.int64)\n\n    #y = x[:, None] * x[None, :] % 2019\n\n    y = x.reshape(-1, 1) * x.reshape(1, -1)  # 区間内のすべての組合せの積\n\n    y %= 2019\n\n    np.fill_diagonal(y, 2019)  # 対角成分は無視する (同じ数を2回選べない) のでinf値で埋める\n\n    return y.min()\n\n\n\nprint((abc133_c()))", "generated_code": "def abc133_c():\n\n    L, R = list(map(int, input().split()))\n\n    # 区間の幅が673あれば、673の倍数と3の倍数が含まれて、2019の倍数が作れる\n\n    if R - L > 673: return 0\n\n    # それ以外は試す\n\n    ans = 2019\n\n    for i in range(L, R+1):\n\n        for j in range(L, i):\n\n            m = i * j % 2019\n\n            ans = min(m, ans)\n\n    return ans\n\n\n\nprint((abc133_c()))", "score": 1.0, "surface_similarity": 0.7617713004484306}
{"id": "p04012_u708211626", "golden_code": "import collections\n\nimport sys\n\na=eval(input())\n\nb=[]\n\n\n\nfor i in a:\n\n  b.append(i)\n\n  \n\nb.sort()\n\nc=collections.Counter(b)\n\nc=list(c.values())\n\n\n\nfor i in range(len(c)):\n\n  if int(c[i])%2==0:\n\n    q=0\n\n  else:\n\n    q=1\n\n    print('No')\n\n    sys.exit()\n\n    \n\nprint('Yes')\n", "generated_code": "w = list(eval(input()))\n\ns = set(w)\n\nfor i in s:\n\n  if w.count(i)%2 != 0:\n\n    print(\"No\")\n\n    break\n\nelse:\n\n  print(\"Yes\")\n\n  ", "score": 1.0, "surface_similarity": 0.5507825507825508}
{"id": "p03835_u379959788", "golden_code": "#ABC951B/Sum_of_Three_Integers\n\n\n\nK, S = list(map(int, input().split()))\n\nans = 0\n\nfor x in range(0, K+1):\n\n    for y in range(0, K+1):\n\n        z = S - x - y\n\n        if 0 <= z and z <= K:\n\n            ans += 1\n\nprint(ans)", "generated_code": "K, S = list(map(int, input().split()))\n\nans = 0\n\nfor X in range(K+1):\n\n    for Y in range(K+1):\n\n        Z = S - X - Y\n\n        if Z >= 0 and Z <= K:\n\n            ans += 1\n\nprint(ans)       ", "score": 1.0, "surface_similarity": 0.9470424941276959}
{"id": "p02276_u150984829", "golden_code": "n=int(eval(input()))-1\n\nA=list(map(int,input().split()))\n\ni=0\n\nfor j in range(n):\n\n if A[j]<=A[-1]:A[i],A[j]=A[j],A[i];i+=1\n\nA[i],A[n]=A[n],A[i]\n\nprint((\" \".join(map(str,A[:i]))+\" [\"+str(A[i])+\"] \"+\" \".join(map(str,A[i+1:]))))\n", "generated_code": "def s():\n\n n=int(eval(input()))-1\n\n A=list(map(int,input().split()))\n\n i=0\n\n for j in range(n):\n\n  if A[j]<=A[-1]:A[i],A[j]=A[j],A[i];i+=1\n\n A[i],A[n]=A[n],A[i]\n\n print((\" \".join(map(str,A[:i]))+\" [\"+str(A[i])+\"] \"+\" \".join(map(str,A[i+1:]))))\n\nif'__main__'==__name__:s()\n", "score": 1.0, "surface_similarity": 0.8779694570135747}
{"id": "p02792_u580404776", "golden_code": "N = int(eval(input()))\n\nmem = [[0]*10 for _ in range(10)]\n\n\n\nfor i in range(1,N+1):\n\n    a = int(str(i)[0])\n\n    b = int(str(i)[-1])\n\n    mem[a][b] += 1\n\n\n\nans = 0\n\nfor i in range(1,N+1):\n\n    a = int(str(i)[0])\n\n    b = int(str(i)[-1])\n\n    ans += mem[b][a]\n\nprint(ans)\n", "generated_code": "N = int(eval(input()))\n\nmem=[[0] * 10 for _ in range(10)]\n\n\n\nfor i in range(1, N+1):\n\n    s = str(i)\n\n    mem[int(s[0])][int(s[-1])] += 1 \n\n    \n\nans = 0\n\nfor i in range(1, 10):\n\n    for j in range(1, 10):\n\n        ans += mem[i][j] * mem[j][i]\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.8763837638376384}
{"id": "p04012_u107077660", "golden_code": "w = eval(input())\n\nfor l in w:\n\n\tif w.count(l) % 2 == 1:\n\n\t\tprint(\"No\")\n\n\t\tbreak\n\nelse:\n\n\tprint(\"Yes\")", "generated_code": "from collections import Counter\n\ns = eval(input())\n\nc = list(Counter(s).values())\n\nfor n in c:\n\n\tif n & 1 == 1:\n\n\t\tprint(\"No\")\n\n\t\tbreak\n\nelse:\n\n\tprint(\"Yes\")\n\n\n", "score": 1.0, "surface_similarity": 0.6884868421052632}
{"id": "p03416_u391875425", "golden_code": "a, b = list(map(int, input().split()))\n\ntmp=str(a)\n\nc=0\n\nfor i in range(a,b+1):\n\n    tmp=str(i)\n\n    tmp2=\"\"\n\n    for s in range(len(tmp)):\n\n        tmp2=tmp2+tmp[len(tmp)-1-s]\n\n    if tmp==tmp2:\n\n        c=c+1\n\nprint(c)", "generated_code": "def main():\n\n    #1. input\n\n    a, b = list(map(int, input().split()))\n\n\n\n    ans = 0\n\n\n\n    #2. from A to B\n\n    for i in range(a, b+1):\n\n        #2.1. judge if the number is palindromic\n\n        if (str(i)[0]==str(i)[4]) and (str(i)[1]==str(i)[3]):\n\n            ans = ans+1\n\n\n\n    #3. output\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()", "score": 1.0, "surface_similarity": 0.7454119965512995}
{"id": "p03835_u505420467", "golden_code": "k,s=list(map(int,input().split()))\n\nans=0\n\nfor i in range(k+1):\n\n    for j in range(k+1):\n\n        z=s-i-j\n\n        if 0<=z<=k:\n\n            ans+=1\n\nprint(ans)\n", "generated_code": "k,s=list(map(int,input().split()))\n\nans=0\n\nfor i in range(k+1):\n\n    for j in range(k+1):\n\n        if 0<=s-i-j<=k:\n\n            ans+=1\n\nprint(ans)\n", "score": 1.0, "surface_similarity": 0.965625}
{"id": "p03078_u285891772", "golden_code": "import sys, re\n\nfrom collections import deque, defaultdict, Counter\n\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, tan, asin, acos, atan, radians, degrees, log2, gcd\n\nfrom itertools import accumulate, permutations, combinations, combinations_with_replacement, product, groupby\n\nfrom operator import itemgetter, mul\n\nfrom copy import deepcopy\n\nfrom string import ascii_lowercase, ascii_uppercase, digits\n\nfrom bisect import bisect, bisect_left, insort, insort_left\n\nfrom heapq import heappush, heappop\n\nfrom functools import reduce, lru_cache\n\ndef input(): return sys.stdin.readline().strip()\n\ndef INT(): return int(input())\n\ndef MAP(): return map(int, input().split())\n\ndef LIST(): return list(map(int, input().split()))\n\ndef TUPLE(): return tuple(map(int, input().split()))\n\ndef ZIP(n): return zip(*(MAP() for _ in range(n)))\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = float('inf')\n\nmod = 10 ** 9 + 7 \n\n#mod = 998244353\n\nfrom decimal import *\n\n#import numpy as np\n\n#decimal.getcontext().prec = 10\n\n\n\nX, Y, Z, K = MAP()\n\nA = sorted(LIST(), reverse = True)\n\nB = sorted(LIST(), reverse = True)\n\nC = sorted(LIST(), reverse = True)\n\n\n\nAB = []\n\nfor i in range(X):\n\n\tfor j in range(Y):\n\n\t\tAB.append(A[i]+B[j])\n\n\n\nAB.sort(reverse = True)\n\nAB = AB[:3000]\n\nABC = sorted([C[0]+AB[i] for i in range(min(3000, X*Y))], reverse = True)\n\n\n\nfor j in range(1, Z):\n\n\tABC_tmp = sorted([C[j]+AB[i] for i in range(min(3000, X*Y))])\n\n\tABC += ABC_tmp\n\n\tABC.sort(reverse = True)\n\n\tABC = ABC[:3000]\n\n\n\nprint(*ABC[:K], sep= \"\\n\")\n\n\n", "generated_code": "import sys, re\n\nfrom collections import deque, defaultdict, Counter\n\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, tan, asin, acos, atan, radians, degrees, log2, gcd\n\nfrom itertools import accumulate, permutations, combinations, combinations_with_replacement, product, groupby\n\nfrom operator import itemgetter, mul\n\nfrom copy import deepcopy\n\nfrom string import ascii_lowercase, ascii_uppercase, digits\n\nfrom bisect import bisect, bisect_left, insort, insort_left\n\nfrom heapq import heappush, heappop\n\nfrom functools import reduce, lru_cache\n\ndef input(): return sys.stdin.readline().strip()\n\ndef INT(): return int(eval(input()))\n\ndef MAP(): return list(map(int, input().split()))\n\ndef LIST(): return list(map(int, input().split()))\n\ndef TUPLE(): return tuple(map(int, input().split()))\n\ndef ZIP(n): return list(zip(*(MAP() for _ in range(n))))\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = float('inf')\n\nmod = 10 ** 9 + 7 \n\n#mod = 998244353\n\nfrom decimal import *\n\n#import numpy as np\n\n#decimal.getcontext().prec = 10\n\n\n\nX, Y, Z, K = MAP()\n\nA = sorted(LIST(), reverse = True)\n\nB = sorted(LIST(), reverse = True)\n\nC = sorted(LIST(), reverse = True)\n\n\n\nans = []\n\nfor i in range(X):\n\n\tfor j in range(Y):\n\n\t\tfor k in range(Z):\n\n\t\t\tif (i+1)*(j+1)*(k+1) <= K:\n\n\t\t\t\tans.append(A[i]+B[j]+C[k])\n\n\t\t\telse:\n\n\t\t\t\tbreak\n\n\n\nfor a in sorted(ans)[::-1][:K]:\n\n\tprint(a)\n", "score": 1.0, "surface_similarity": 0.8143149568053291}
{"id": "p02814_u498487134", "golden_code": "import fractions\n\nimport sys\n\ninput = sys.stdin.readline\n\n\n\nN,M=list(map(int,input().split()))\n\na = list(map(int, input().split()))\n\n\n\n\n\nlcm = a[0]\n\nfor i in range(1, N):\n\n    g= fractions.gcd(lcm, a[i])\n\n    lcm = lcm * a[i] // g\n\n\n\n\n\ng=a[0]\n\nfor i in range(N):\n\n    g=fractions.gcd(g,a[i])\n\n\n\nfor i in range(N):\n\n    if (a[i]//g)%2==0:\n\n        lcm=0\n\n        break    \n\n    \n\n    \n\nans=0\n\nl=lcm//2\n\nif l:\n\n    ans=(M//l)-(M//(l+l))\n\nprint(ans)\n\n\n", "generated_code": "import sys\n\ninput = sys.stdin.readline\n\n\n\ndef I(): return int(eval(input()))\n\ndef MI(): return list(map(int, input().split()))\n\ndef LI(): return list(map(int, input().split()))\n\n\n\n\"\"\"\n\n2X = ak * (2p+1)\n\n基本的には最小公倍数/2を基本とし，これの奇数倍か．\n\n\n\nX  = (ak//2) * (2p+1)\n\nと書ける．第二項が奇数なので，各akが2で割り切れれう回数が同じでなければならない\n\na=[2,4]だと無理\n\n\"\"\"\n\ndef main():\n\n    from math import gcd\n\n    N,M=MI()\n\n    A=LI()\n\n    \n\n    def count(X):\n\n        cnt=0\n\n        while X%2==0:\n\n            cnt+=1\n\n            X=X//2\n\n        return cnt\n\n    \n\n    C=count(A[0])\n\n    for i in range(1,N):\n\n        if count(A[i])!=C:\n\n            print((0))\n\n            exit()\n\n            \n\n    lca=1\n\n    for i in range(N):\n\n        g=gcd(lca,A[i])\n\n        lca=(lca*A[i])//g\n\n        \n\n    lca2=lca//2\n\n    ans=M//lca2 - M//lca\n\n    \n\n    print(ans)\n\n    \n\n            \n\n    \n\n\n\nmain()\n", "score": 1.0, "surface_similarity": 0.6365803445660418}
{"id": "p00744_u408260374", "golden_code": "import collections\n\nimport math\n\n\n\n\n\nclass Dinic:\n\n    \"\"\"Dinic Algorithm: find max-flow\n\n       complexity: O(EV^2)\n\n       used in GRL6A(AOJ)\n\n    \"\"\"\n\n    class edge:\n\n        def __init__(self, to, cap, rev):\n\n            self.to, self.cap, self.rev = to, cap, rev\n\n\n\n    def __init__(self, V, E, source, sink):\n\n        \"\"\" V: the number of vertexes\n\n            E: adjacency list\n\n            source: start point\n\n            sink: goal point\n\n        \"\"\"\n\n        self.V = V\n\n        self.E = [[] for _ in range(V)]\n\n        for fr in range(V):\n\n            for to, cap in E[fr]:\n\n                self.E[fr].append(self.edge(to, cap, len(self.E[to])))\n\n                self.E[to].append(self.edge(fr, 0, len(self.E[fr])-1))\n\n        self.maxflow = self.dinic(source, sink)\n\n\n\n    def dinic(self, source, sink):\n\n        \"\"\"find max-flow\"\"\"\n\n        INF = float('inf')\n\n        maxflow = 0\n\n        while True:\n\n            self.bfs(source)\n\n            if self.level[sink] < 0:\n\n                return maxflow\n\n            self.itr = [0] * self.V\n\n            while True:\n\n                flow = self.dfs(source, sink, INF)\n\n                if flow > 0:\n\n                    maxflow += flow\n\n                else:\n\n                    break\n\n\n\n    def dfs(self, vertex, sink, flow):\n\n        \"\"\"find augmenting path\"\"\"\n\n        if vertex == sink:\n\n            return flow\n\n        for i in range(self.itr[vertex], len(self.E[vertex])):\n\n            self.itr[vertex] = i\n\n            e = self.E[vertex][i]\n\n            if e.cap > 0 and self.level[vertex] < self.level[e.to]:\n\n                d = self.dfs(e.to, sink, min(flow, e.cap))\n\n                if d > 0:\n\n                    e.cap -= d\n\n                    self.E[e.to][e.rev].cap += d\n\n                    return d\n\n        return 0\n\n\n\n    def bfs(self, start):\n\n        \"\"\"find shortest path from start\"\"\"\n\n        que = collections.deque()\n\n        self.level = [-1] * self.V\n\n        que.append(start)\n\n        self.level[start] = 0\n\n\n\n        while que:\n\n            fr = que.popleft()\n\n            for e in self.E[fr]:\n\n                if e.cap > 0 and self.level[e.to] < 0:\n\n                    self.level[e.to] = self.level[fr] + 1\n\n                    que.append(e.to)\n\n\n\nwhile True:\n\n    M, N = list(map(int, input().split()))\n\n    if M == 0 and N == 0:\n\n        break\n\n    blue, red = [], []\n\n    while True:\n\n        for x in input().split():\n\n            blue.append(int(x))\n\n        if len(blue) == M:\n\n            break\n\n    while True:\n\n        for x in input().split():\n\n            red.append(int(x))\n\n        if len(red) == N:\n\n            break\n\n    V = M + N + 2\n\n    edge = [set() for _ in range(V)]\n\n    for i, b in enumerate(blue):\n\n        if b != 1:\n\n            for j, r in enumerate(red):\n\n                if r % b == 0:\n\n                    edge[i].add((M+j, 1))\n\n        for j in range(2, int(math.sqrt(b)) + 1):\n\n            if b % j == 0:\n\n                for k, r in enumerate(red):\n\n                    if r % j == 0 or r % (b // j) == 0:\n\n                        edge[i].add((M+k, 1))\n\n    for i in range(M):\n\n        edge[M+N].add((i, 1))\n\n    for j in range(N):\n\n        edge[M+j].add((M+N+1, 1))\n\n    d = Dinic(V, edge, M+N, M+N+1)\n\n    print((d.maxflow))", "generated_code": "import collections\n\nimport math\n\nrange = xrange; input = raw_input\n\n\n\n\n\nclass Dinic:\n\n    \"\"\"Dinic Algorithm: find max-flow\n\n       complexity: O(EV^2)\n\n       used in GRL6A(AOJ)\n\n    \"\"\"\n\n    class edge:\n\n        def __init__(self, to, cap, rev):\n\n            self.to, self.cap, self.rev = to, cap, rev\n\n\n\n    def __init__(self, V, E, source, sink):\n\n        \"\"\" V: the number of vertexes\n\n            E: adjacency list\n\n            source: start point\n\n            sink: goal point\n\n        \"\"\"\n\n        self.V = V\n\n        self.E = [[] for _ in range(V)]\n\n        for fr in range(V):\n\n            for to, cap in E[fr]:\n\n                self.E[fr].append(self.edge(to, cap, len(self.E[to])))\n\n                self.E[to].append(self.edge(fr, 0, len(self.E[fr])-1))\n\n        self.maxflow = self.dinic(source, sink)\n\n\n\n    def dinic(self, source, sink):\n\n        \"\"\"find max-flow\"\"\"\n\n        INF = float('inf')\n\n        maxflow = 0\n\n        while True:\n\n            self.bfs(source)\n\n            if self.level[sink] < 0:\n\n                return maxflow\n\n            self.itr = [0] * self.V\n\n            while True:\n\n                flow = self.dfs(source, sink, INF)\n\n                if flow > 0:\n\n                    maxflow += flow\n\n                else:\n\n                    break\n\n\n\n    def dfs(self, vertex, sink, flow):\n\n        \"\"\"find augmenting path\"\"\"\n\n        if vertex == sink:\n\n            return flow\n\n        for i in range(self.itr[vertex], len(self.E[vertex])):\n\n            self.itr[vertex] = i\n\n            e = self.E[vertex][i]\n\n            if e.cap > 0 and self.level[vertex] < self.level[e.to]:\n\n                d = self.dfs(e.to, sink, min(flow, e.cap))\n\n                if d > 0:\n\n                    e.cap -= d\n\n                    self.E[e.to][e.rev].cap += d\n\n                    return d\n\n        return 0\n\n\n\n    def bfs(self, start):\n\n        \"\"\"find shortest path from start\"\"\"\n\n        que = collections.deque()\n\n        self.level = [-1] * self.V\n\n        que.append(start)\n\n        self.level[start] = 0\n\n\n\n        while que:\n\n            fr = que.popleft()\n\n            for e in self.E[fr]:\n\n                if e.cap > 0 and self.level[e.to] < 0:\n\n                    self.level[e.to] = self.level[fr] + 1\n\n                    que.append(e.to)\n\n\n\nwhile True:\n\n    M, N = list(map(int, input().split()))\n\n    if M == 0 and N == 0:\n\n        break\n\n    blue, red = [], []\n\n    while True:\n\n        for x in input().split():\n\n            blue.append(int(x))\n\n        if len(blue) == M:\n\n            break\n\n    while True:\n\n        for x in input().split():\n\n            red.append(int(x))\n\n        if len(red) == N:\n\n            break\n\n    V = M + N + 2\n\n    edge = [set() for _ in range(V)]\n\n    for i, b in enumerate(blue):\n\n        if b != 1:\n\n            for j, r in enumerate(red):\n\n                if r % b == 0:\n\n                    edge[i].add((M+j, 1))\n\n        for j in range(2, int(math.sqrt(b)) + 1):\n\n            if b % j == 0:\n\n                for k, r in enumerate(red):\n\n                    if r % j == 0 or r % (b // j) == 0:\n\n                        edge[i].add((M+k, 1))\n\n    for i in range(M):\n\n        edge[M+N].add((i, 1))\n\n    for j in range(N):\n\n        edge[M+j].add((M+N+1, 1))\n\n    d = Dinic(V, edge, M+N, M+N+1)\n\n    print((d.maxflow))", "score": 1.0, "surface_similarity": 0.9955953827460511}
{"id": "p00174_u759934006", "golden_code": "while True:\n\n    try:\n\n        for i in range(3):\n\n            line = input().strip()\n\n            if line == '0':\n\n                raise Exception\n\n\n\n            a = b = 0\n\n            for i, s in enumerate(line):\n\n                if i != 0:\n\n                    if s == 'A':\n\n                        a += 1\n\n                    else:\n\n                        b += 1\n\n            if a > b:\n\n                a += 1\n\n            else:\n\n                b += 1\n\n            print(a, b)\n\n\n\n    except:\n\n        break", "generated_code": "while True:\n\n    try:\n\n        for i in range(3):\n\n            line = input().strip()\n\n            if line == '0':\n\n                raise Exception\n\n\n\n            if line[0] == 'A':\n\n                a = -1\n\n                b = 0\n\n            else:\n\n                a = 0\n\n                b = -1\n\n            for i, s in enumerate(line):\n\n                if s == 'A':\n\n                    a += 1\n\n                else:\n\n                    b += 1\n\n            if a > b:\n\n                a += 1\n\n            else:\n\n                b += 1\n\n            print(a, b)\n\n\n\n    except:\n\n        break", "score": 1.0, "surface_similarity": 0.8718141870684244}
{"id": "p03559_u867848444", "golden_code": "from bisect import *\n\nn = int(eval(input()))\n\na = list(map(int,input().split()))\n\nb = list(map(int,input().split()))\n\nc = list(map(int,input().split()))\n\n\n\na = sorted(a)\n\nc = sorted(c)\n\n\n\nrec = 0\n\nfor i in range(n):\n\n    temp = b[i]\n\n    l = bisect_left(a, temp)\n\n    r = bisect_right(c, temp)\n\n    rec += l * (n - r)\n\nprint(rec)", "generated_code": "from bisect import *\n\nn = int(eval(input()))\n\na = list(map(int,input().split()))\n\nb = list(map(int,input().split()))\n\nc = list(map(int,input().split()))\n\n\n\na.sort()\n\nc.sort()\n\nres = 0\n\nfor i in b:\n\n    temp_a = bisect_left(a, i)\n\n    temp_c = n - bisect_right(c, i)\n\n    res += temp_a*temp_c\n\nprint(res)", "score": 1.0, "surface_similarity": 0.8713805791073428}
{"id": "p02837_u784022244", "golden_code": "N=int(eval(input()))\n\n\n\nS=[[-1]*N for _ in range(N)]\n\nfor i in range(N):\n\n  A=int(eval(input()))\n\n  for _ in range(A):\n\n    x, y=list(map(int, input().split()))\n\n    S[i][x-1]=y\n\nans=0   \n\nfor s in range(2**N):\n\n  ok=True\n\n  for i in range(N):\n\n    #正直者について見ていく\n\n    if (s>>i&1)==1:\n\n      for j in range(N):\n\n        #それぞれ正直者の証言が矛盾ないか\n\n        if S[i][j]!=-1 and (s>>j&1)!=S[i][j]:\n\n          ok=False\n\n  if ok:\n\n    ans=max(ans, bin(s).count(\"1\"))\n\n    \n\nprint(ans)\n", "generated_code": "N=int(eval(input()))\n\n\n\nA=[[-1]*N for _ in range(N)]\n\nfor i in range(N):\n\n  a=int(eval(input()))\n\n  for j in range(a):\n\n    x,y=list(map(int, input().split()))\n\n    A[i][x-1]=y\n\n#正直者が正直者に不親切と言われていない\n\n#→正直ものが不親切を正直者と言っていないか\n\nans=0\n\nfor i in range(2**N):\n\n  ok=True\n\n  for j in range(N):\n\n    if (i>>j&1)==1:\n\n      for k in range(N):\n\n        if A[j][k]!=-1 and (i>>k&1)!=A[j][k]:\n\n          ok=False\n\n  if ok:\n\n    ans=max(ans, bin(i).count(\"1\"))\n\n  \n\nprint(ans)", "score": 1.0, "surface_similarity": 0.9797008547008548}
{"id": "p02899_u842747358", "golden_code": "import numpy as np\n\nfrom copy import deepcopy\n\n\n\nN = int(eval(input()))\n\nA = []\n\nA.append(list(map(int, input().split())))\n\na = deepcopy(A[0])\n\na.sort()\n\nA.append(a)\n\nA_t = np.array(A).T.tolist()\n\nA_t.sort()\n\n\n\nout = []\n\nfor i in range(N):\n\n    out.append(str(A_t[i][1]))\n\nprint((\" \".join(out)))\n", "generated_code": "N = int(eval(input()))\n\nA = list(map(int, input().split()))\n\n\n\nrev = [\"\"] * N\n\nfor i in range(N):\n\n    rev[A[i]-1] = str(i+1)\n\nprint((\" \".join(rev)))\n", "score": 1.0, "surface_similarity": 0.5648648648648649}
{"id": "p03592_u761320129", "golden_code": "N,M,K = list(map(int,input().split()))\n\n\n\nfor i in range(N+1):\n\n    for j in range(M+1):\n\n        t = i*M + j*N - i*j*2\n\n        if t==K:\n\n            print('Yes')\n\n            exit()\n\nprint('No')", "generated_code": "N,M,K = list(map(int,input().split()))\n\n\n\nfor i in range(N+1):\n\n    for j in range(M+1):\n\n        if i*(M-j) + j*(N-i) == K:\n\n            print('Yes')\n\n            exit()\n\nprint('No')", "score": 1.0, "surface_similarity": 0.9642857142857143}
{"id": "p00542_u078042885", "golden_code": "a,b,c,d,e,f=[int(eval(input())) for _ in range(6)]\n\nprint((sum([a,b,c,d,max(e,f)])-min([a,b,c,d])))", "generated_code": "print((sum(sorted(int(eval(input())) for _ in range(4))[1:])+max([int(eval(input())) for _ in range(2)])))", "score": 1.0, "surface_similarity": 0.49947589098532497}
{"id": "p03371_u135454978", "golden_code": "# AtCoder Beginner Contest 095 C - Half and Half\n\nimport sys\n\n\n\nA, B, C, X, Y = list(map(int, sys.stdin.readline().strip().split()))\n\n\n\nans = A * X + B * Y\n\nfor z in range(2, 2 * 10 ** 5 + 1, 2):\n\n    x = max(X - int(z / 2), 0)\n\n    y = max(Y - int(z / 2), 0)\n\n\n\n    price = A * x + B * y + C * z\n\n    ans = min(price, ans)\n\n\n\nprint(ans)\n", "generated_code": "# AtCoder Beginner Contest 095 C - Half and Half\n\nimport sys\n\n\n\nA, B, C, X, Y = list(map(int, sys.stdin.readline().strip().split()))\n\n\n\n\"\"\"\n\nans = A * X + B * Y\n\nfor z in range(2, 2 * 10 ** 5 + 1, 2):\n\n    x = max(X - int(z / 2), 0)\n\n    y = max(Y - int(z / 2), 0)\n\n\n\n    price = A * x + B * y + C * z\n\n    ans = min(price, ans)\n\n\n\nprint(ans)\n\n\"\"\"\n\n\n\nprice1 = A * X + B * Y\n\nprice2 = C * 2 * X + B * max(Y - X, 0)\n\nprice3 = A * max(X - Y, 0) + C * 2 * Y\n\nprint((min(price1, price2, price3)))\n\n\n", "score": 1.0, "surface_similarity": 0.7570850202429149}
{"id": "p02773_u545368057", "golden_code": "from collections import defaultdict\n\nN = int(eval(input()))\n\nd = defaultdict(int)\n\n\n\nfor i in range(N):\n\n    S = eval(input())\n\n    d[S] += 1\n\n\n\nm = 0\n\nfor k in list(d.keys()):\n\n    m = max(d[k],m)\n\n\n\nli = []\n\nfor k in list(d.keys()):\n\n    if d[k] == m:\n\n        li.append(k)\n\n\n\nli.sort()\n\nfor l in li:\n\n    print(l)", "generated_code": "from collections import defaultdict\n\nN = int(eval(input()))\n\nSs = [eval(input()) for i in range(N)]\n\n\n\nd = defaultdict(int)\n\nfor S in Ss:\n\n    d[S] += 1\n\n\n\nmx = max([d[k] for k in list(d.keys())])\n\n\n\nans = []\n\nfor k in list(d.keys()):\n\n    if d[k] == mx:\n\n       ans.append(k)\n\n       \n\nfor a in sorted(ans):\n\n    print(a)", "score": 1.0, "surface_similarity": 0.8272162619988708}
{"id": "p03037_u600402037", "golden_code": "N,M = list(map(int,input().split()))\n\nL,R = [],[]\n\nfor i in range(M):\n\n    l,r = list(map(int,input().split()))\n\n    L.append(l)\n\n    R.append(r)\n\nans = min(R)-max(L)+1\n\nprint((ans if ans >= 0 else 0))", "generated_code": "# coding: utf-8\n\nimport sys\n\n\n\nsr = lambda: sys.stdin.readline().rstrip()\n\nir = lambda: int(sr())\n\nlr = lambda: list(map(int, sr().split()))\n\n\n\nN, M = lr()\n\nL = 0; R = 10 ** 6\n\nfor _ in range(M):\n\n    l, r = lr()\n\n    if l > L:\n\n        L = l\n\n    if r < R:\n\n        R = r\n\n\n\nanswer = max(0, R - L + 1)\n\nprint(answer)\n", "score": 1.0, "surface_similarity": 0.5431785195936139}
{"id": "p02555_u554953477", "golden_code": "MOD = 1000000007\n\n\n\n\n\nS = int(eval(input()))\n\n\n\n#dp[i]:=i桁の数列で条件を満たすものの数\n\ndp = [0]*(S+1)\n\n\n\nfor i in range(3,S+1):\n\n    #dp[i]=sum(dp[0],..,dp[i-3])+1\n\n    for j in range(i-3+1):\n\n        dp[i] = (dp[i]+dp[j])%MOD\n\n    dp[i] = (dp[i]+1)%MOD\n\n\n\nprint((dp[S]))", "generated_code": "MOD = 1000000007\n\n\n\n\n\nS = int(eval(input()))\n\n\n\n#dp[i]:=i桁の数列で条件を満たすものの数\n\ndp = [0]*(S+1)\n\ndp_sum = [0]*(S+1)\n\n\n\nfor i in range(3,S+1):\n\n    #dp[i]=sum(dp[0],..,dp[i-3])+1\n\n    \n\n    dp[i] = (dp_sum[i-3]+1)%MOD\n\n    dp_sum[i] = (dp[i]+dp_sum[i-1])%MOD\n\n\n\nprint((dp[S]))", "score": 1.0, "surface_similarity": 0.9216417910447761}
{"id": "p03273_u952708174", "golden_code": "import numpy\n\nH, W = [int(i) for i in input().split()]\n\nA = numpy.array([list(input().strip()) for _ in range(H)])\n\n\n\nrow_space = []\n\ncol_space = []\n\n\n\nfor k, row in enumerate(A):\n\n    if '#' not in row:\n\n        row_space.append(k)\n\n\n\nA_rot = numpy.rot90(A, k=-1)\n\nfor k, row in enumerate(A_rot):\n\n    if '#' not in row:\n\n        col_space.append(k)\n\n\n\nA = numpy.delete(A, row_space, axis=0)\n\nA = numpy.delete(A, col_space, axis=1)\n\nans = '\\n'.join([''.join(row) for row in A])\n\nprint(ans)", "generated_code": "def rotate_clockwise(matrix):\n\n    tmp = list(map(list, list(zip(*matrix))))[::-1]\n\n    return list(''.join(row) for row in tmp)\n\n    # 文字列のリストを入れるので文字列のリストで返す\n\n\n\n\n\ndef rotate_counterclockwise(matrix):\n\n    tmp = list([list(x[::-1]) for x in zip(*matrix)])\n\n    return list(''.join(row) for row in tmp)\n\n    # 文字列のリストを入れるので文字列のリストで返す\n\n\n\n\n\nH, W = [int(i) for i in input().split()]\n\nA = [eval(input()) for _ in range(H)]\n\n\n\nrow_remove_count = 0\n\nwhile '.' * W in A:\n\n    A.remove('.' * W)  # 行まるごと白なら、回数を記録して除く\n\n    row_remove_count += 1\n\n\n\nA = rotate_clockwise(A)  # 反時計回りに回す\n\nwhile '.' * (H - row_remove_count) in A:\n\n    A.remove('.' * (H - row_remove_count))\n\n\n\nA = rotate_counterclockwise(A)  # 時計回りに回して元に戻す\n\nprint(('\\n'.join(A)))", "score": 1.0, "surface_similarity": 0.4339441760997014}
{"id": "p02881_u175590965", "golden_code": "n = int(eval(input()))\n\nl = []\n\nfor i in range(1,1000001):\n\n    a = n / i\n\n    if a.is_integer():\n\n        l.append(i+n/i)\n\nprint((int(min(l)-2)))", "generated_code": "n = int(eval(input()))\n\na = 10**20\n\nfor i in range(1,int(n**0.5)+1):\n\n    if n%i==0:\n\n        a = min(a,i+n//i)\n\nprint((a-2))", "score": 1.0, "surface_similarity": 0.6211676451402479}
{"id": "p03640_u597455618", "golden_code": "import sys\n\nimport numpy as np\n\n\n\n\n\ndef main():\n\n    h, w = list(map(int, sys.stdin.buffer.readline().split()))\n\n    n = int(sys.stdin.buffer.readline())\n\n    a = list(map(int, sys.stdin.buffer.readline().split()))\n\n    ans = np.zeros(w*h, np.int64)\n\n    now = 0\n\n    for i, x in enumerate(a):\n\n        for j in range(x):\n\n            ans[now + j] = i+1\n\n        now += x\n\n\n\n    ans = ans.reshape(h, w)\n\n    for i in range(h):\n\n        if i % 2:\n\n            print((*ans[i, ::-1]))\n\n        else:\n\n            print((*ans[i]))\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "generated_code": "import sys\n\n\n\n\n\ndef main():\n\n    h, w = list(map(int, sys.stdin.buffer.readline().split()))\n\n    n = int(sys.stdin.buffer.readline())\n\n    a = list(map(int, sys.stdin.buffer.readline().split()))\n\n    ans = [0]*(w*h)\n\n    now = 0\n\n    for i, x in enumerate(a):\n\n        for j in range(x):\n\n            ans[now + j] = i+1\n\n        now += x\n\n\n\n    for i in range(h):\n\n        if i % 2:\n\n            print((*reversed(ans[i*w:(i+1)*w])))\n\n        else:\n\n            print((*ans[i*w:(i+1)*w]))\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "score": 1.0, "surface_similarity": 0.8636800180780747}
{"id": "p02881_u186838327", "golden_code": "n = int(eval(input()))\n\nimport math\n\nm = int(math.sqrt(n))+1\n\nanss = []\n\nfor x in range(1, m+1):\n\n  y = n//x\n\n  z = n%x\n\n  if z == 0:\n\n    anss.append(abs(x-1)+abs(y-1))\n\nprint((min(anss)))\n", "generated_code": "n = int(eval(input()))\n\ndef make_divisors(n):\n\n    divisors = []\n\n    for i in range(1, int(n**0.5)+1):\n\n        if n % i == 0:\n\n            divisors.append(i)\n\n            if i != n // i:\n\n                divisors.append(n//i)\n\n\n\n    #divisors.sort(reverse=True)\n\n    return divisors\n\n\n\nl = make_divisors(n)\n\nmin_ = float('inf')\n\nfor i in range(len(l)):\n\n    min_ = min(min_, l[i]-1+n//l[i]-1)\n\nprint(min_)\n", "score": 1.0, "surface_similarity": 0.6045469912102772}
{"id": "p02994_u348868667", "golden_code": "import numpy as np\n\nN,L = list(map(int,input().split()))\n\napple = np.array(list(range(N))) + 1\n\ntaste = apple + L - 1\n\ntaste_applepie = sum(taste)\n\nif L <= 0 and abs(N) > abs(L):\n\n    print(taste_applepie)\n\nelif L > 0:\n\n    print((taste_applepie - L))\n\nelse:\n\n    print((taste_applepie - (N+L-1)))", "generated_code": "N,L = list(map(int,input().split()))\n\nt = [L+i-1 for i in range(1,N+1)]\n\nabst = list(map(abs,t))\n\nminind = abst.index(min(abst))\n\nprint((sum(t)-t[minind]))", "score": 1.0, "surface_similarity": 0.488956228956229}
{"id": "p02850_u104282757", "golden_code": "from collections import deque\n\n\n\nn = int(eval(input()))\n\n\n\ng = {i: dict() for i in range(n)}\n\n\n\na_list = [0] * (n - 1)\n\nb_list = [0] * (n - 1)\n\nfor i in range(n - 1):\n\n    a, b = list(map(int, input().split()))\n\n    a_list[i] = a - 1\n\n    b_list[i] = b - 1\n\n    g[a - 1][b - 1] = -1\n\n    g[b - 1][a - 1] = -1\n\n\n\nk = max([len(g[a]) for a in range(n)])\n\n\n\nused_color = [-1] * n\n\nused_color[0] = k - 1\n\n# BFS\n\nqueue = deque([0])\n\nwhile len(queue) > 0:\n\n    p = queue.popleft()\n\n    c = used_color[p]\n\n    for q in list(g[p].keys()):\n\n        if used_color[q] != -1:\n\n            continue\n\n        c += 1\n\n        c %= k\n\n        # print(p, q, c)\n\n        g[p][q] = c\n\n        g[q][p] = c\n\n        used_color[q] = c\n\n        queue.append(q)\n\n\n\nprint(k)\n\nfor i in range(n - 1):\n\n    print((g[a_list[i]][b_list[i]] + 1))\n", "generated_code": "from collections import deque\n\n\n\n\n\ndef solve(n, a_list, b_list):\n\n\n\n    # create graph\n\n    g = {i: dict() for i in range(n)}\n\n    for i in range(n - 1):\n\n        a, b = a_list[i] - 1, b_list[i] - 1\n\n        g[a][b] = -1\n\n        g[b][a] = -1\n\n\n\n    k = max([len(g[a]) for a in range(n)])\n\n\n\n    used_color = [-1] * n\n\n    used_color[0] = k - 1\n\n    # BFS\n\n    queue = deque([0])\n\n    while len(queue) > 0:\n\n        p = queue.popleft()\n\n        c = used_color[p]\n\n        for q in list(g[p].keys()):\n\n            if used_color[q] != -1:\n\n                continue\n\n            c += 1\n\n            c %= k\n\n            # print(p, q, c)\n\n            g[p][q] = c\n\n            g[q][p] = c\n\n            used_color[q] = c\n\n            queue.append(q)\n\n\n\n    res_list = [0] * (n - 1)\n\n    for i in range(n - 1):\n\n        res_list[i] = g[a_list[i] - 1][b_list[i] - 1] + 1\n\n\n\n    return k, res_list\n\n\n\n\n\ndef main():\n\n    n = int(eval(input()))\n\n    a_list = [0] * (n - 1)\n\n    b_list = [0] * (n - 1)\n\n    for i in range(n - 1):\n\n        a, b = list(map(int, input().split()))\n\n        a_list[i] = a\n\n        b_list[i] = b\n\n\n\n    k, res_list = solve(n, a_list, b_list)\n\n    print(k)\n\n    for i in range(n - 1):\n\n        print((res_list[i]))\n\n\n\n\n\ndef test():\n\n    print((solve(3, [1, 2], [2, 3])))\n\n    print((solve(8, [1, 2, 2, 2, 4, 5, 6], [2, 3, 4, 5, 7, 6, 8])))\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    # test()\n\n    main()\n", "score": 1.0, "surface_similarity": 0.7614059937378859}
{"id": "p03774_u784022244", "golden_code": "import numpy as np\n\nN,M=list(map(int, input().split()))\n\nhuman=[]\n\nfor i in range(N):\n\n  a,b=list(map(int, input().split()))\n\n  human.append((a,b))\n\nC=[]\n\nfor i in range(M):\n\n  c,d=list(map(int, input().split()))\n\n  C.append((c,d))\n\n  \n\nfor h in human:\n\n  a,b=h\n\n  now=0\n\n  mini=np.inf\n\n  for i,ch in enumerate(C):\n\n    c,d=ch\n\n    L=abs(a-c)+abs(b-d)\n\n    if mini>L:\n\n      mini=L\n\n      now=i+1\n\n  print(now)", "generated_code": "N,M=list(map(int, input().split()))\n\nS=[]\n\nfor i in range(N):\n\n    a,b=list(map(int, input().split()))\n\n    S.append((a,b))\n\n\n\nC=[]\n\nfor i in range(M):\n\n    c,d=list(map(int, input().split()))\n\n    C.append((c,d,i+1))\n\n#print(C)\n\nfor s in S:\n\n    a,b=s\n\n    now=0\n\n    dis=10**9\n\n\n\n    for t in C:\n\n        c,d,n=t\n\n        D=abs(c-a)+abs(d-b)\n\n        \n\n        if D<dis:\n\n            dis=D\n\n            now=n\n\n    print(now)", "score": 1.0, "surface_similarity": 0.7901195049082372}
{"id": "p03455_u850516963", "golden_code": "a, b = list(map(int, input().split()))\n\nif a*b%2 == 1:\n\n    print(\"Odd\")\n\nelse:\n\n    print(\"Even\")", "generated_code": "a, b = list(map(int, input().split()))\n\nprint(('Odd'if a&b&1 else 'Even'))", "score": 1.0, "surface_similarity": 0.6422902494331066}
{"id": "p02555_u634079249", "golden_code": "import sys, os, math, bisect, itertools, collections, heapq, queue, copy, array\n\n\n\n# from scipy.sparse.csgraph import csgraph_from_dense, floyd_warshall\n\n# from decimal import Decimal\n\n# from collections import defaultdict, deque\n\n\n\nsys.setrecursionlimit(10000000)\n\n\n\nii = lambda: int(sys.stdin.buffer.readline().rstrip())\n\nil = lambda: list(map(int, sys.stdin.buffer.readline().split()))\n\nfl = lambda: list(map(float, sys.stdin.buffer.readline().split()))\n\niln = lambda n: [int(sys.stdin.buffer.readline().rstrip()) for _ in range(n)]\n\n\n\niss = lambda: sys.stdin.buffer.readline().decode().rstrip()\n\nsl = lambda: list(map(str, sys.stdin.buffer.readline().decode().split()))\n\nisn = lambda n: [sys.stdin.buffer.readline().decode().rstrip() for _ in range(n)]\n\n\n\nlcm = lambda x, y: (x * y) // math.gcd(x, y)\n\n\n\nMOD = 10 ** 9 + 7\n\nINF = float('inf')\n\n\n\n\n\ndef main():\n\n    if os.getenv(\"LOCAL\"):\n\n        sys.stdin = open(\"input.txt\", \"r\")\n\n\n\n    S = ii()\n\n    dp = [0] * (S + 1)\n\n\n\n    dp[0] = 1\n\n    # 0 <= i <= Sの範囲を探索\n\n    for i in range(1, S + 1):\n\n        # 0 <= j <= i - 3の範囲で、\n\n        # 間仕切りを置くことができる個数の合計を集計\n\n        for j in range(0, i - 3 + 1):\n\n            dp[i] += dp[j]\n\n            dp[i] %= MOD\n\n    print((dp[-1]))\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "generated_code": "import sys, os, math, bisect, itertools, collections, heapq, queue, copy, array\n\n\n\n# from scipy.sparse.csgraph import csgraph_from_dense, floyd_warshall\n\n# from decimal import Decimal\n\n# from collections import defaultdict, deque\n\n\n\nsys.setrecursionlimit(10000000)\n\n\n\nii = lambda: int(sys.stdin.buffer.readline().rstrip())\n\nil = lambda: list(map(int, sys.stdin.buffer.readline().split()))\n\nfl = lambda: list(map(float, sys.stdin.buffer.readline().split()))\n\niln = lambda n: [int(sys.stdin.buffer.readline().rstrip()) for _ in range(n)]\n\n\n\niss = lambda: sys.stdin.buffer.readline().decode().rstrip()\n\nsl = lambda: list(map(str, sys.stdin.buffer.readline().decode().split()))\n\nisn = lambda n: [sys.stdin.buffer.readline().decode().rstrip() for _ in range(n)]\n\n\n\nlcm = lambda x, y: (x * y) // math.gcd(x, y)\n\n\n\nMOD = 10 ** 9 + 7\n\nINF = float('inf')\n\n\n\n\n\ndef main():\n\n    if os.getenv(\"LOCAL\"):\n\n        sys.stdin = open(\"input.txt\", \"r\")\n\n\n\n    S = ii()\n\n    dp = [0] * (S + 1)\n\n\n\n    dp[0] = 1\n\n    # 0 <= i <= Sの範囲を探索\n\n    for i in range(1, S + 1):\n\n        # 0 <= j <= i - 3の範囲で、\n\n        # 間仕切りを置くことができる個数の合計を集計\n\n        if i > 2:\n\n            dp[i] = sum(dp[0:i - 2])\n\n            dp[i] %= MOD\n\n    print((dp[-1]))\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 1.0, "surface_similarity": 0.9608138823323717}
{"id": "p02555_u503228842", "golden_code": "n = int(eval(input()))\n\nm = 10**9 + 7\n\n# ans = [0] * (n + 1)\n\nans = [0] * 2200\n\nans[0] = 1\n\n# ans[3] = 1\n\n# ans[4] = 1\n\n# ans[5] = 1\n\nfor i in range(3, n + 1):\n\n    for j in range(i - 2):\n\n        ans[i] += ans[j]\n\n        ans[i] %= m\n\nprint((ans[n]))\n\n# print(ans[:10])\n", "generated_code": "n = int(eval(input()))\n\nm = 10**9 + 7\n\n# ans = [0] * (n + 1)\n\nans = [0] * 2200\n\nans[0] = 1\n\n# ans[3] = 1\n\n# ans[4] = 1\n\n# ans[5] = 1\n\nfor i in range(3, n + 1):\n\n    ans[i] = ans[i - 1] + ans[i - 3]\n\n    ans[i] %= m\n\n    # for j in range(i - 2):\n\n    #     ans[i] += ans[j]\n\n    #     ans[i] %= m\n\nprint((ans[n]))\n\n# print(ans[:10])\n", "score": 1.0, "surface_similarity": 0.9683734939759037}
{"id": "p03608_u678167152", "golden_code": "N, M, R = list(map(int, input().split()))\n\nr = list(map(int, input().split()))\n\nd = [[float('inf')]*N for _ in range(N)]\n\nfor i in range(M): #ひとまず枝があるペアは枝の長さをセット\n\n  a,b,t = list(map(int, input().split()))\n\n  d[a-1][b-1] = t\n\n  d[b-1][a-1] = t\n\n\n\nfor i in range(N):\n\n  d[i][i] = 0 #自身への最短経路は0\n\n#三重ループ\n\nfor k in range(N):\n\n  for i in range(N):\n\n    for j in range(N):\n\n      d[i][j] = min(d[i][j], d[i][k]+d[k][j])\n\n\n\nfrom itertools import groupby, accumulate, product, permutations, combinations\n\n\n\nans = float('inf')\n\nfor p in permutations(r,R):\n\n  cnt = 0\n\n  for i in range(1,R):\n\n    cnt += d[p[i-1]-1][p[i]-1]\n\n  ans = min(ans,cnt)\n\nprint(ans)", "generated_code": "N, M, r = list(map(int, input().split()))\n\nR = list([int(x)-1 for x in input().split()])\n\nd = [[1<<30]*N for _ in range(N)]\n\nfor i in range(M): #ひとまず枝があるペアは枝の長さをセット\n\n  a,b,t = list(map(int, input().split()))\n\n  d[a-1][b-1] = t\n\n  d[b-1][a-1] = t\n\n\n\nfor i in range(N):\n\n  d[i][i] = 0 #自身への最短経路は0\n\n#三重ループ\n\nfor k in range(N):\n\n  for i in range(N):\n\n    for j in range(N):\n\n      d[i][j] = min(d[i][j], d[i][k]+d[k][j])\n\nfrom itertools import groupby, accumulate, product, permutations, combinations\n\nans = 1<<30\n\nfor per in permutations(R,r):\n\n  cnt = 0\n\n  for i in range(r-1):\n\n    cnt += d[per[i]][per[i+1]]\n\n  ans = min(ans, cnt)\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.9335010319917441}
{"id": "p02982_u046187684", "golden_code": "from scipy.spatial import distance\n\n\n\n\n\ndef solve(string):\n\n    n, d, *x = list(map(int, string.split()))\n\n    x = [tuple(c) for c in zip(*[iter(x)] * d)]\n\n    dist = distance.cdist(x, x)\n\n    return str(((dist == dist.astype(\"int32\")).sum() - n) // 2)\n\n\n\n\n\nif __name__ == '__main__':\n\n    n, m = list(map(int, input().split()))\n\n    print((solve('{} {}\\n'.format(n, m)+'\\n'.join([eval(input()) for _ in range(n)]))))\n", "generated_code": "import math\n\nN,D = list(map(int,input().split()))\n\nX = [list(map(float, input().split())) for i in range(N)]\n\ncounter = 0\n\nfor i, x0 in enumerate(X): \n\n    for x1 in X[i+1:]:\n\n        if math.sqrt(sum([(a-b)**2 for a, b in zip(x0,x1)])).is_integer():\n\n            counter+=1\n\nprint(counter)\n", "score": 1.0, "surface_similarity": 0.44138755980861244}
{"id": "p02615_u219494936", "golden_code": "import numpy as np\n\nimport heapq\n\n\n\nN = int(eval(input()))\n\nA =  np.sort([int(x) for x in input().split(\" \")])[::-1]\n\n\n\nq = [(-A[1], (0, 1)), (-A[1], (0, 1))]\n\nconfort = A[0]\n\nheapq.heapify(q)\n\n\n\ni = 2\n\nwhile N > i:\n\n    m = heapq.heappop(q)\n\n    # print(f\"{m[1][0]}と{m[1][1]}の間に割り込む. 気持ち良さ {-m[0]}\")\n\n    confort -= m[0]\n\n    heapq.heappush(q, (-A[i], (i, m[1][0])))\n\n    heapq.heappush(q, (-A[i], (i, m[1][1])))\n\n    i += 1\n\nprint(confort)\n", "generated_code": "N = int(eval(input()))\n\nA = sorted([int(x) for x in input().split(\" \")])[::-1]\n\n\n\nN -= 2\n\nS = A[0]\n\n\n\ni = 1\n\nwhile 1:\n\n    if N == 0:\n\n        break \n\n    if N == 1:\n\n        S += A[i]\n\n        break\n\n    S += 2 * A[i]\n\n    N -= 2\n\n    i += 1\n\nprint(S)", "score": 1.0, "surface_similarity": 0.6237775507225223}
{"id": "p04021_u754022296", "golden_code": "import sys\n\ninput = sys.stdin.readline\n\nread = sys.stdin.read\n\n\n\nn = int(eval(input()))\n\nA = list(map(int, read().split()))\n\nL = sorted([(j, i) for i, j in enumerate(A)])\n\ncount = 0\n\nfor i in range(n):\n\n  if (L[i][1]-i)%2:\n\n    count += 1\n\nans = (count+1) // 2\n\nprint(ans)", "generated_code": "import sys\n\ninput = sys.stdin.readline\n\nread = sys.stdin.read\n\n\n\nn = int(eval(input()))\n\nA = list(map(int, read().split()))\n\nL = sorted([(j, i) for i, j in enumerate(A)])\n\ncount = 0\n\nfor i in range(n):\n\n  count += (L[i][1]-i)%2\n\nans = (count+1) // 2\n\nprint(ans)\n", "score": 1.0, "surface_similarity": 0.9479166666666667}
{"id": "p02378_u072053884", "golden_code": "# Acceptance of input\n\n\n\nimport sys\n\n\n\nfile_input = sys.stdin\n\n\n\nX, Y, E = list(map(int, file_input.readline().split()))\n\n\n\nv_num = X + Y + 2\n\n\n\nadj_mat = [[0] * (v_num) for i in range(v_num)]\n\n\n\nfor line in file_input:\n\n    x, y = list(map(int, line.split()))\n\n    adj_mat[x][X + y] = 1\n\n\n\ns = X + Y\n\nt = s + 1\n\n\n\nfor i in range(X):\n\n    adj_mat[s][i] = 1\n\n\n\nfor i in range(X, s):\n\n    adj_mat[i][t] = 1\n\n\n\n# Dinic's algorithm\n\n\n\nimport collections\n\n\n\n# BFS for residual capacity network to construct level graph\n\ndef bfs(start, goal, parent):\n\n    unvisited = [True] * v_num\n\n    queue = collections.deque()\n\n    queue.append(start)\n\n    unvisited[start] = False\n\n    while queue:\n\n        u = queue.popleft()\n\n        for v, r_capacity in enumerate(adj_mat[u]):\n\n            if unvisited[v] and (r_capacity > 0):\n\n                parent[v].append(u)\n\n                queue.append(v)\n\n                unvisited[v] = False\n\n    return unvisited[goal]\n\n\n\n# DFS for level graph and construct blocking flow\n\ndef dfs(goal, path, parent, blocking_flow):\n\n    v = path[-1]\n\n    if v == goal:\n\n        aug_path_flow = 10000\n\n        for x, y in zip(path[1:], path[:-1]):\n\n            aug_path_flow = min(aug_path_flow, adj_mat[x][y])\n\n        for x, y in zip(path[1:], path[:-1]):\n\n            adj_mat[x][y] -= aug_path_flow\n\n            adj_mat[y][x] += aug_path_flow\n\n        blocking_flow[0] += aug_path_flow\n\n    else:\n\n        for u in parent[v]:\n\n            path.append(u)\n\n            dfs(goal, path, parent, blocking_flow)\n\n            path.pop()\n\n\n\ndef dinic(source, sink):\n\n    max_flow = 0\n\n    parent = [[] for i in range(v_num)]\n\n    while not bfs(source, sink, parent):\n\n        blocking_flow = [0]\n\n        path = [sink]\n\n        # search in reverse direction from sink\n\n        dfs(source, path, parent, blocking_flow)\n\n        max_flow += blocking_flow[0]\n\n        parent = [[] for i in range(v_num)]\n\n    return max_flow\n\n\n\n# output\n\nprint((dinic(s, t)))", "generated_code": "# Acceptance of input\n\n\n\nimport sys\n\n\n\nfile_input = sys.stdin\n\n\n\nX, Y, E = list(map(int, file_input.readline().split()))\n\n\n\nv_num = X + Y + 2\n\n\n\nadj_mat = [[0] * (v_num) for i in range(v_num)]\n\n\n\nfor line in file_input:\n\n    x, y = list(map(int, line.split()))\n\n    adj_mat[x][X + y] = 1\n\n\n\ns = X + Y\n\nt = s + 1\n\n\n\nfor i in range(X):\n\n    adj_mat[s][i] = 1\n\n\n\nfor i in range(X, s):\n\n    adj_mat[i][t] = 1\n\n\n\n# Dinic's algorithm\n\n\n\nimport collections\n\n\n\n# BFS for residual capacity network to construct level graph\n\ndef bfs(start, goal, parent):\n\n    level = [v_num] * v_num\n\n    unvisited = [True] * v_num\n\n    queue = collections.deque()\n\n    queue.append(start)\n\n    level[start] = 0\n\n    unvisited[start] = False\n\n    while queue:\n\n        u = queue.popleft()\n\n        next_level = level[u] + 1\n\n        for v, r_capacity in enumerate(adj_mat[u]):\n\n            if (level[v] >= next_level) and (r_capacity > 0):\n\n                level[v] = next_level\n\n                parent[v].append(u)\n\n                if unvisited[v]:\n\n                    queue.append(v)\n\n                    unvisited[v] = False\n\n    return level[goal]\n\n\n\n# DFS for level graph and construct blocking flow\n\ndef dfs(goal, path, parent, blocking_flow):\n\n    v = path[-1]\n\n    if v == goal:\n\n        aug_path_flow = 10000\n\n        for x, y in zip(path[1:], path[:-1]):\n\n            aug_path_flow = min(aug_path_flow, adj_mat[x][y])\n\n        for x, y in zip(path[1:], path[:-1]):\n\n            adj_mat[x][y] -= aug_path_flow\n\n            adj_mat[y][x] += aug_path_flow\n\n        blocking_flow[0] += aug_path_flow\n\n    else:\n\n        for u in parent[v]:\n\n            path.append(u)\n\n            dfs(goal, path, parent, blocking_flow)\n\n            path.pop()\n\n\n\ndef dinic(source, sink):\n\n    max_flow = 0\n\n    parent = [[] for i in range(v_num)]\n\n    while bfs(source, sink, parent) != v_num:\n\n        blocking_flow = [0]\n\n        path = [sink]\n\n        # search in reverse direction from sink\n\n        dfs(source, path, parent, blocking_flow)\n\n        max_flow += blocking_flow[0]\n\n        parent = [[] for i in range(v_num)]\n\n    return max_flow\n\n\n\n# output\n\nprint((dinic(s, t)))", "score": 1.0, "surface_similarity": 0.9324580810433163}
{"id": "p02837_u285891772", "golden_code": "import sys, re\n\nfrom collections import deque, defaultdict, Counter\n\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, tan, asin, acos, atan, radians, degrees#, log2, log\n\nfrom itertools import accumulate, permutations, combinations, combinations_with_replacement, product, groupby\n\nfrom operator import itemgetter, mul\n\nfrom copy import deepcopy\n\nfrom string import ascii_lowercase, ascii_uppercase, digits\n\nfrom bisect import bisect, bisect_left, insort, insort_left\n\nfrom fractions import gcd\n\nfrom heapq import heappush, heappop\n\nfrom functools import reduce\n\nfrom decimal import Decimal\n\ndef input(): return sys.stdin.readline().strip()\n\ndef INT(): return int(eval(input()))\n\ndef MAP(): return list(map(int, input().split()))\n\ndef LIST(): return list(map(int, input().split()))\n\ndef ZIP(n): return list(zip(*(MAP() for _ in range(n))))\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = float('inf')\n\nmod = 10**9 + 7\n\nfrom decimal import *\n\n\n\nN = INT()\n\nxy = []\n\n\n\nfor i in range(N):\n\n\tA = INT()\n\n\txy.append([LIST() for _ in range(A)])\n\n\n\nans = 0\n\nfor i in range(1<<N):\n\n\ti = list(\"{:b}\".format(i).zfill(N))\n\n\tfor j in range(N):\n\n\t\tif i[j] == \"1\":\n\n\t\t\tfor x, y in xy[j]:\n\n\t\t\t\tif y != int(i[x-1]):\n\n\t\t\t\t\tbreak\n\n\t\t\telse:\n\n\t\t\t\tcontinue\n\n\t\t\tbreak\n\n\telse:\n\n\t\ttmp = sum([int(x) for x in i])\n\n\t\tans = max(ans, tmp)\n\nprint(ans)\n", "generated_code": "import sys, re\n\nfrom collections import deque, defaultdict, Counter\n\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, tan, asin, acos, atan, radians, degrees#, log2, log\n\nfrom itertools import accumulate, permutations, combinations, combinations_with_replacement, product, groupby\n\nfrom operator import itemgetter, mul\n\nfrom copy import deepcopy\n\nfrom string import ascii_lowercase, ascii_uppercase, digits\n\nfrom bisect import bisect, bisect_left, insort, insort_left\n\nfrom fractions import gcd\n\nfrom heapq import heappush, heappop\n\nfrom functools import reduce\n\nfrom decimal import Decimal\n\ndef input(): return sys.stdin.readline().strip()\n\ndef INT(): return int(eval(input()))\n\ndef MAP(): return list(map(int, input().split()))\n\ndef LIST(): return list(map(int, input().split()))\n\ndef ZIP(n): return list(zip(*(MAP() for _ in range(n))))\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = float('inf')\n\nmod = 10**9 + 7\n\nfrom decimal import *\n\n\n\nN = INT()\n\nxy = []\n\n\n\nfor i in range(N):\n\n\tA = INT()\n\n\txy.append([LIST() for _ in range(A)])\n\n\n\nans = 0\n\nfor X in product((0, 1), repeat=N):\n\n\tfor j in range(N):\n\n\t\tif X[j] == 1:\n\n\t\t\tfor x, y in xy[j]:\n\n\t\t\t\tif X[x-1] != y:\n\n\t\t\t\t\tbreak\n\n\t\t\telse:\n\n\t\t\t\tcontinue\n\n\t\t\tbreak\n\n\telse:\n\n\t\tans = max(ans, sum(X))\n\n\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.9408732750877766}
{"id": "p04012_u357751375", "golden_code": "w = eval(input())\n\ny = list(set(w))\n\n\n\nfor i in range(len(y)):\n\n    if w.count(y[i]) % 2 != 0:\n\n        print('No')\n\n        exit(0)\n\n\n\nprint('Yes')", "generated_code": "w = list(eval(input()))\n\nx = list(set(w))\n\nfor i in x:\n\n    y = w.count(i)\n\n    if y % 2 != 0:\n\n        print('No')\n\n        exit(0)\n\nprint('Yes')", "score": 1.0, "surface_similarity": 0.849960254372019}
{"id": "p03752_u775681539", "golden_code": "import numpy as np\n\nfrom itertools import combinations \n\nINF = int(1e9)*15\n\ndef main():\n\n    n, k = list(map(int, input().split())) \n\n    a = np.array(input().split(), np.int32)\n\n    c = np.array([int(i) for i in range(1, n)])\n\n    ans = INF\n\n    for comb in combinations(c, k-1):\n\n        s = set(comb)\n\n        mx = a[0]\n\n        cost = 0\n\n        for i in range(n):\n\n            if i in s:\n\n                if a[i] > mx:\n\n                    mx = a[i]\n\n                    continue\n\n                else:\n\n                    mx += 1\n\n                    cost += mx-a[i] \n\n                    continue\n\n            mx = max(mx, a[i])\n\n        ans = min(cost, ans)\n\n    print(ans)\n\nif __name__ == '__main__':\n\n    main()\n", "generated_code": "from itertools import combinations \n\nINF = int(1e9)*15\n\ndef main():\n\n    n, k = list(map(int, input().split())) \n\n    a = [int(i) for i in input().split()]\n\n    c = [int(i) for i in range(1, n)]\n\n    ans = INF\n\n    for comb in combinations(c, k-1):\n\n        s = set(comb)\n\n        mx = a[0]\n\n        cost = 0\n\n        for i in range(n):\n\n            if i in s:\n\n                if a[i] > mx:\n\n                    mx = a[i]\n\n                    continue\n\n                else:\n\n                    mx += 1\n\n                    cost += mx-a[i] \n\n                    continue\n\n            mx = max(mx, a[i])\n\n        ans = min(cost, ans)\n\n    print(ans)\n\nif __name__ == '__main__':\n\n    main()\n", "score": 1.0, "surface_similarity": 0.9513675099272744}
{"id": "p02772_u600402037", "golden_code": "import sys\n\nimport numpy as np\n\n\n\nsr = lambda: sys.stdin.readline().rstrip()\n\nir = lambda: int(sr())\n\nlr = lambda: list(map(int, sr().split()))\n\n\n\nN = ir()\n\nA = np.array(lr())\n\nA = A[A%2==0].tolist()\n\nbool = True\n\nfor a in A:\n\n    if a%3 != 0 and a%5 != 0:\n\n        bool = False\n\n\n\nprint(('APPROVED' if bool else 'DENIED'))\n", "generated_code": "# coding: utf-8\n\nimport sys\n\n\n\nsr = lambda: sys.stdin.readline().rstrip()\n\nir = lambda: int(sr())\n\nlr = lambda: list(map(int, sr().split()))\n\n\n\nN = ir()\n\nA = lr()\n\nbl = all(x % 3 == 0 or x % 5 == 0 for x in A if x % 2 == 0)\n\nprint(('APPROVED' if bl else 'DENIED'))\n", "score": 1.0, "surface_similarity": 0.7142857142857143}
{"id": "p02851_u057109575", "golden_code": "from collections import defaultdict\n\n\n\nN, K, *A = list(map(int, open(0).read().split()))\n\n\n\nS = [0] * (N + 1)\n\nfor i in range(N):\n\n    S[i + 1] = S[i] + A[i]\n\n\n\nd = defaultdict(int)\n\nans = 0\n\nfor j in range(N + 1):\n\n    v = (S[j] - j) % K\n\n    ans += d[v]\n\n    d[v] += 1\n\n    if j >= K - 1:\n\n        d[(S[j - K + 1] - (j - K + 1)) % K] -= 1\n\n        \n\nprint(ans)\n", "generated_code": "from collections import defaultdict\n\n\n\nN, K, *A = list(map(int, open(0).read().split()))\n\n\n\nx = [0] * (N + 1)\n\nfor i in range(N):\n\n    x[i + 1] = x[i] + A[i]\n\n    \n\ny = [(x[i] - i) % K for i in range(N + 1)]\n\n\n\nctr = defaultdict(int)\n\nans = 0\n\nfor j in range(N + 1):\n\n    ans += ctr[y[j]]\n\n    ctr[y[j]] += 1\n\n    if j - K + 1 >= 0:\n\n        ctr[y[j - K + 1]] -= 1\n\nprint(ans)\n", "score": 1.0, "surface_similarity": 0.8542061386888973}
{"id": "p02767_u576432509", "golden_code": "n=int(eval(input()))\n\nx=list(map(int,input().split()))\n\n\n\nx.sort()\n\n\n\nfor p in range(x[0],x[len(x)-1]+1):\n\n    psum=0\n\n    for i in range(len(x)):\n\n        psum=psum+(x[0]-x[i])**2\n\n#    print(psum)\n\n    pmin=psum    \n\n    for j in range(x[0]+1,x[len(x)-1]):\n\n        psum=0\n\n        for i in range(len(x)):\n\n            psum=psum+(j-x[i])**2\n\n#        print(psum)\n\n        if pmin>psum:\n\n            pmin=psum\n\nprint(pmin)    ", "generated_code": "n=int(eval(input()))\n\nx=list(map(int,input().split()))\n\n\n\nx.sort()\n\n\n\npsum=0\n\nfor i in range(len(x)):\n\n    psum=psum+(x[0]-x[i])**2\n\n#    print(psum)\n\npmin=psum    \n\nfor j in range(x[0]+1,x[len(x)-1]):\n\n    psum=0\n\n    for i in range(len(x)):\n\n        psum=psum+(j-x[i])**2\n\n#        print(psum)\n\n    if pmin>psum:\n\n        pmin=psum\n\nprint(pmin)            \n", "score": 1.0, "surface_similarity": 0.9613583138173303}
{"id": "p02880_u797106134", "golden_code": "N = int(eval(input()))\n\n# N>81のときはn*nで表せないので不敵\n\nif N>81:\n\n    print('No')\n\nelse:\n\n    import numpy as np\n\n    n=np.array([1,2,3,4,5,6,7,8,9])\n\n    amari=N%n\n\n    shou=N//n\n\n    if np.any((amari==0)*(shou<=9)):\n\n        print('Yes')\n\n    else:\n\n        print('No')\n", "generated_code": "N = int(eval(input()))\n\nfor i in range(1,10):\n\n    if not N%i == 0:\n\n        continue\n\n    rest = N/i\n\n    if rest<10:\n\n        print('Yes')\n\n        exit()\n\n\n\nprint('No')", "score": 1.0, "surface_similarity": 0.539983164983165}
{"id": "p02880_u542605091", "golden_code": "import numpy as np\n\nimport math\n\n\n\ndef bigger_devisor(n):\n\n  s = np.sqrt(n)\n\n  i = math.ceil(s)\n\n  while(n % i != 0):\n\n    i += 1\n\n  return i\n\n\n\nn = int(eval(input()))\n\nif bigger_devisor(n) > 9:\n\n  print('No')\n\nelse:\n\n  print('Yes')", "generated_code": "n = int(eval(input()))\n\nans = 0\n\nfor i in range(1, 10):\n\n  if n % i == 0:\n\n    if n / i < 10:\n\n      ans = 1\n\nif ans == 0:\n\n  print('No')\n\nelse:\n\n  print('Yes')", "score": 1.0, "surface_similarity": 0.46213054187192115}
{"id": "p03172_u682672120", "golden_code": "n, k = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\nmod = 10 ** 9 + 7\n\n\n\ndp = [[0] * (k + 1) for _ in range(n + 1)]\n\ndp[0][0] = 1\n\nfor i in range(n):\n\n    dp[i + 1][0] = dp[i][0]\n\n    for j in range(1, k+1):\n\n        dp[i + 1][j] = (dp[i + 1][j - 1] + dp[i][j]) % mod\n\n    for j in range(k, a[i], -1):\n\n        dp[i + 1][j] = (dp[i + 1][j] - dp[i + 1][j - a[i] - 1]) % mod\n\nprint((dp[n][-1]))", "generated_code": "n, k = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\nmod = 10 ** 9 + 7\n\n\n\nf = [0] * (k + 1)\n\nf[0] = 1\n\nfor i in range(n):\n\n    for j in range(1, k+1):\n\n        f[j] = (f[j] + f[j - 1]) % mod # 1/(1-x):累積和\n\n    for j in range(k, a[i], -1): # 1-x^(a[i]+1) a[i]+1次したの項を引く\n\n        f[j] = (f[j] - f[j - a[i] - 1]) % mod\n\nprint((f[-1]))", "score": 1.0, "surface_similarity": 0.8468225419664268}
{"id": "p03086_u438662618", "golden_code": "import re\n\n\n\nS = eval(input())\n\nmax = 0\n\n\n\nfor i in range(len(S)) :\n\n    for j in range(i + 1, len(S) + 1) :\n\n        pattern = re.compile(r'[A|T|C|G]{%d}' % int(j - i))\n\n        subStr = S[i:j]\n\n\n\n        if pattern.match(subStr) and j - i > max :\n\n            max = j - i\n\n\n\nprint(max)\n", "generated_code": "S = eval(input())\n\n\n\nans = 0\n\n\n\nfor i in range(len(S)) :\n\n    for j in range(i, len(S)) :\n\n        if all('ACGT'.count(c) == 1 for c in S[i : j + 1]) :\n\n            ans = max(ans, j - i + 1)\n\n\n\n\n\nprint(ans)\n", "score": 1.0, "surface_similarity": 0.6550480769230769}
{"id": "p02792_u207097826", "golden_code": "import itertools\n\nN = int(eval(input()))\n\nNketa = len(str(N))\n\n\n\nrange_count = [[0 for j in range(10)]for i in range(10)]\n\n\n\n\n\nfor p in range(1,N+1):\n\n    mae = int(str(p)[0])\n\n    ato = int(str(p)[-1])\n\n    range_count[mae][ato] += 1\n\n\n\n    \n\n\n\ncount = 0\n\nfor j in range(1,N+1):\n\n    a_mae = int(str(j)[0])\n\n    a_ato = int(str(j)[-1])\n\n    \n\n    b_mae = a_ato\n\n    b_ato = a_mae\n\n    \n\n    if b_mae == 0:\n\n        continue\n\n    else:\n\n        count += range_count[b_mae][b_ato]\n\nprint(count)\n\n  ", "generated_code": "n = int(eval(input()))\n\n\n\nall_count = 0\n\noptions = [str(i) for i in range(10)]\n\n\n\nmaeato = [[0 for i in range(10)] for j in range(10)]\n\n\n\nfor i in range(n+1):\n\n    checking = str(i)\n\n    maeato[int(checking[0])][int(checking[-1])]+=1\n\nall_count = 0\n\nfor i in range(1,10):\n\n    for j in range(1,10):\n\n        for k in range(1,10):\n\n            for p in range(1,10):\n\n                if i == p and j == k:\n\n                    all_count+=maeato[i][j]*maeato[k][p]\n\nprint(all_count)", "score": 1.0, "surface_similarity": 0.6796333556896936}
{"id": "p03436_u074220993", "golden_code": "H, W = list(map(int, input().split()))\n\nimport numpy as np\n\nGrid = np.array([[0 if x == '.' else -1 for x in eval(input())] for _ in range(H)],dtype='int64')\n\n\n\ndef solveMase(Grid, start, goal): #bfsで迷路を解き、スタート-ゴール間の最低必要白マス数を返す\n\n    seen = {start}\n\n    V = [start]\n\n    while len(V) != 0: #bfs\n\n        v = V.pop(0)\n\n        if v == goal:\n\n            return Grid[goal]\n\n        #移動先nvをリストにまとめる\n\n        y,x = v\n\n        nV = []\n\n        if x > 0: nV.append((y,x-1))\n\n        if y > 0: nV.append((y-1,x))\n\n        if x < W-1: nV.append((y,x+1))\n\n        if y < H-1: nV.append((y+1,x))\n\n        #bfs\n\n        for nv in nV:\n\n            if Grid[nv] == -1 or nv in seen:\n\n                continue\n\n            Grid[nv] = Grid[v] + 1\n\n            V.append(nv)\n\n            seen.add(nv)\n\n    return 0\n\n\n\nwhite = len(Grid[Grid == 0])-1\n\nnes_white = solveMase(Grid, (0,0), (H-1,W-1))\n\nprint((white-nes_white if nes_white > 0 else -1))", "generated_code": "from collections import deque, Counter\n\n\n\ndef main():\n\n    with open(0) as f:\n\n        H, W = list(map(int, f.readline().split()))\n\n        maze = [list(line) for line in f.readlines()]\n\n\n\n    rank = [[None]*W for _ in range(H)]\n\n    rank[0][0] = 0\n\n    #bfs\n\n    reserved = deque([(0,0)])\n\n    while len(reserved) > 0:\n\n        x, y = reserved.popleft()\n\n        for u,v in [(s,t) for s,t in [(x-1,y), (x+1,y), (x,y-1), (x,y+1)] if 0<=s<H and 0<=t<W]:\n\n            if rank[u][v] is not None:\n\n                continue\n\n            if maze[u][v] == '.':\n\n                rank[u][v] = rank[x][y] + 1\n\n                reserved.append((u,v))\n\n\n\n    if rank[H-1][W-1] is None:\n\n        print((-1))\n\n    else:\n\n        counter = Counter()\n\n        for line in maze:\n\n            counter.update(line)\n\n        print((counter['.'] - rank[H-1][W-1]-1))\n\n\n\nmain()", "score": 1.0, "surface_similarity": 0.5665521872179292}
{"id": "p02916_u671446913", "golden_code": "import numpy as np\n\nN = int(eval(input()))\n\nA = list(map(int, input().split()))\n\nA = list(np.array(A) - 1)\n\nB = list(map(int, input().split()))\n\nC = list(map(int, input().split()))\n\n\n\nsum_ = 0\n\ndiff = list(np.array(A[1:]) - np.array(A[:-1]))\n\ndiff.insert(0, -1)\n\nfor i in range(N):\n\n  sum_ += B[A[i]]\n\n  \n\n  if diff[i] == 1:\n\n    sum_ += C[A[i-1]]\n\n  \n\nprint(sum_)", "generated_code": "N = int(eval(input()))\n\nA = list(map(int, input().split()))\n\nB = list(map(int, input().split()))\n\nC = list(map(int, input().split()))\n\n\n\nans = 0\n\nfor i in range(len(A)):\n\n  ans += B[A[i]-1]\n\n\n\n  if i != 0:\n\n    if A[i-1] + 1 == A[i]:\n\n      ans += C[A[i-1]-1]\n\n\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.6986813186813187}
{"id": "p02863_u075012704", "golden_code": "N, W = list(map(int, input().split()))\n\nitems = sorted([list(map(int, input().split())) for i in range(N)])\n\n\n\n# dp1[i][j] := 商品0 ~ i が対象\n\ndp = [[0] * (W + 1) for i in range(N + 1)]\n\n\n\n# dpテーブルを埋める\n\nfor i in range(N):\n\n    wi, vi = items[i]\n\n    for j in range(W + 1):\n\n        if j + wi <= W:\n\n            dp[i + 1][j + wi] = max(dp[i + 1][j + wi], dp[i][j] + vi)\n\n        dp[i + 1][j] = max(dp[i][j], dp[i + 1][j])\n\n\n\n\n\nans = 0\n\nfor i, (wi, vi) in enumerate(items):\n\n    for j in range(W):\n\n        ans = max(ans, dp[i][j] + vi)\n\n\n\nprint(ans)\n", "generated_code": "N, W = list(map(int, input().split()))\n\nitems = sorted([list(map(int, input().split())) for i in range(N)])\n\n\n\n# dp1[i][j] := 商品0 ~ i が対象\n\ndp = [[0] * (W + 1) for i in range(N + 1)]\n\n\n\n# dpテーブルを埋める\n\nfor i in range(N):\n\n    wi, vi = items[i]\n\n    for j in range(W + 1):\n\n        if j + wi <= W:\n\n            dp[i + 1][j + wi] = max(dp[i + 1][j + wi], dp[i][j] + vi)\n\n        dp[i + 1][j] = max(dp[i][j], dp[i + 1][j])\n\n\n\n\n\nans = 0\n\nfor i, (wi, vi) in enumerate(items):\n\n    ans = max(ans, dp[i][W - 1] + vi)\n\n\n\nprint(ans)\n", "score": 1.0, "surface_similarity": 0.9608296769046669}
{"id": "p02690_u971091945", "golden_code": "x = int(eval(input()))\n\n\n\nfor a in range(-118, 120):\n\n    for b in range(-119, 119):\n\n        if a**5-b**5 == x:\n\n            print((a, b))\n\n            exit()", "generated_code": "x = int(eval(input()))\n\n\n\nfor a in range(1, 120):\n\n    for b in range(-119, 119):\n\n        if a**5-b**5 == x:\n\n            print((a, b))\n\n            exit()", "score": 1.0, "surface_similarity": 0.9905660377358491}
{"id": "p02921_u379136995", "golden_code": "s=eval(input())\n\nt=eval(input())\n\nans=0\n\nif s[0]==t[0]:\n\n    ans+=1\n\nif s[1]==t[1]:\n\n    ans+=1\n\nif s[2]==t[2]:\n\n    ans+=1\n\nprint(ans)\n", "generated_code": "s=eval(input())\n\nt=eval(input())\n\nans=0\n\nfor i in range(0,3):\n\n    if s[i]==t[i]:\n\n        ans+=1\n\nprint(ans)\n", "score": 1.0, "surface_similarity": 0.8253676470588236}
{"id": "p03013_u179169725", "golden_code": "# https://atcoder.jp/contests/abc129/tasks/abc129_c\n\n# 典型的なDP\n\n\n\nMOD = 10**9 + 7\n\nimport numpy as np\n\n# dp[i]をi段目までの通りの数とする。\n\nN, M = list(map(int, input().split()))\n\nto_zero = np.full((N + 1), False, dtype=bool)\n\nfor _ in range(M):\n\n    to_zero[int(eval(input()))] = True  # 床が抜けているところ\n\n\n\n# dpテーブルの用意\n\ndp = np.full((N + 1), -1, dtype='int64')\n\ndp[0] = 1\n\ndp[1] = 0 if to_zero[1] else 1\n\nfor i in range(2, N + 1):\n\n    dp[i] = 0 if to_zero[i] else dp[i - 2] + dp[i - 1]\n\n    if dp[i] > MOD:\n\n        dp[i] %= MOD\n\n\n\nprint((dp[-1]))\n", "generated_code": "# https://atcoder.jp/contests/abc129/tasks/abc129_c\n\n# 典型的なDP\n\n\n\nMOD = 10**9 + 7\n\nimport numpy as np\n\n# dp[i]をi段目までの通りの数とする。\n\nN, M = list(map(int, input().split()))\n\nto_zero = np.full((N + 1), False).tolist()\n\nfor _ in range(M):\n\n    to_zero[int(eval(input()))] = True  # 床が抜けているところ\n\n\n\n# dpテーブルの用意\n\ndp = np.full((N + 1), -1).tolist()\n\ndp[0] = 1\n\ndp[1] = 0 if to_zero[1] else 1\n\nfor i in range(2, N + 1):\n\n    dp[i] = 0 if to_zero[i] else dp[i - 2] + dp[i - 1]\n\n    if dp[i] > MOD:\n\n        dp[i] %= MOD\n\n\n\nprint((dp[-1]))\n", "score": 1.0, "surface_similarity": 0.9623688458434221}
{"id": "p03494_u735069283", "golden_code": "import numpy as np\n\neval(input())\n\nx = np.array(input().split(),dtype=np.int32)\n\n\n\nans = 0\n\nwhile (x%2 == 0).all():\n\n  x = x//2\n\n  ans += 1\n\nprint(ans)", "generated_code": "N = int(eval(input()))\n\nA = [int(x) for x in input().split()]\n\nresult = float('inf')\n\nfor i in range(N):\n\n  r=0\n\n  while A[i]%2==0:\n\n    A[i]=A[i]/2\n\n    r +=1\n\n  result=min(result,r)\n\nprint(result)", "score": 1.0, "surface_similarity": 0.5425407925407926}
{"id": "p03416_u074220993", "golden_code": "N = {} #10000以上key以下の回文数の個数\n\ncnt = 0\n\nfor i in range(10000, 100000):\n\n    L = list(str(i))\n\n    if L == list(reversed(L)):\n\n        cnt += 1\n\n    N[i] = cnt\n\nA, B = list(map(int, input().split()))\n\nprint((N[B]-N[A-1] if A > 10000 else N[B]))", "generated_code": "A, B =list(map(int, input().split()))\n\nnum_palin = [0] * (B+1)\n\nfor i in range(1,B+1):\n\n    if str(i) == str(i)[::-1]:\n\n        num_palin[i] = num_palin[i-1] + 1\n\n    else:\n\n        num_palin[i] = num_palin[i-1]\n\nprint((num_palin[B]-num_palin[A-1]))\n", "score": 1.0, "surface_similarity": 0.5172857142857143}
{"id": "p03835_u263753244", "golden_code": "k,s=list(map(int,input().split()))\n\ncnt=0\n\nfor i in range(k+1):\n\n    for j in range(k+1):\n\n        if 0 <= s-i-j <= k:\n\n            cnt+=1\n\nprint(cnt)", "generated_code": "k,s=list(map(int,input().split()))\n\na=0\n\nfor i in range(0,k+1):\n\n    for j in range(0,k+1):\n\n        if 0<=s-i-j<=k:\n\n            a+=1\n\nprint(a)", "score": 1.0, "surface_similarity": 0.9566666666666667}
{"id": "p03806_u761529120", "golden_code": "N,Ma,Mb = list(map(int, input().split()))\n\narr=[list(map(int,input().split())) for _ in range(N)]\n\ndp=[[[5000]*401 for _ in range(401)] for _ in range(41)]\n\ndp[0][0][0] = 0\n\nfor i in range(N):\n\n    a,b,c=arr[i]\n\n    for j in range(10*N+1):\n\n        for k in range(10*N+1):\n\n            if dp[i][j][k] == 5000:\n\n                continue\n\n            dp[i+1][j][k]=min(dp[i+1][j][k],dp[i][j][k])\n\n            dp[i+1][j+a][k+b]=min(dp[i+1][j+a][k+b],dp[i][j][k]+c)\n\n\n\nans=5000\n\nfor i in range(1,401):\n\n        if i*Ma>400 or i*Mb>400:\n\n            break\n\n        ans = min(ans, dp[N][i*Ma][i*Mb])\n\nif ans == 5000:\n\n    print((-1))\n\nelse:\n\n    print(ans)", "generated_code": "def calc():\n\n    N,Ma,Mb = list(map(int, input().split()))\n\n    arr=[list(map(int,input().split())) for _ in range(N)]\n\n    dp=[[[5000]*401 for _ in range(401)] for _ in range(41)]\n\n    dp[0][0][0] = 0\n\n    for i in range(N):\n\n        a,b,c=arr[i]\n\n        for j in range(10*N+1):\n\n            for k in range(10*N+1):\n\n                if dp[i][j][k] == 5000:\n\n                    continue\n\n                dp[i+1][j][k]=min(dp[i+1][j][k],dp[i][j][k])\n\n                dp[i+1][j+a][k+b]=min(dp[i+1][j+a][k+b],dp[i][j][k]+c)\n\n\n\n    ans=5000\n\n    for i in range(1,401):\n\n            if i*Ma>400 or i*Mb>400:\n\n                break\n\n            ans = min(ans, dp[N][i*Ma][i*Mb])\n\n    if ans == 5000:\n\n        print((-1))\n\n    else:\n\n        print(ans)\n\n\n\ncalc()", "score": 1.0, "surface_similarity": 0.9558528998167639}
{"id": "p03608_u936985471", "golden_code": "# ワーシャルフロイドで、各町間の最短距離の更新は200^3 = 8,000,000\n\n# 訪れるべき町Rはたかだか8個なので、順番の全通りを試して8! = 約40000通り\n\n\n\nimport numpy as np\n\nfrom scipy.sparse.csgraph import shortest_path, floyd_warshall\n\nfrom scipy.sparse import csr_matrix\n\n\n\nN,M,R = list(map(int,input().split()))\n\nr = list(map(int,input().split()))\n\nr = list([x-1 for x in r])\n\n\n\nE = [[0 for j in range(N)] for i in range(N)]\n\nfor i in range(M):\n\n  a,b,c = list(map(int,input().split()))\n\n  E[a-1][b-1] = c\n\n  E[b-1][a-1] = c\n\n\n\nE = np.array(E)\n\nE = shortest_path(E,method = \"FW\")\n\n\n\n# DFSですべての数を試す\n\nstack = []\n\nfor i in range(len(r)):\n\n  stack.append([r[i],[],0])\n\nans = 10 ** 18\n\nwhile stack:\n\n  v,visited,dist = stack.pop()\n\n  if len(visited) != 0:\n\n    dist += E[visited[-1]][v]\n\n  visited2 = visited.copy()\n\n  visited2.append(v)\n\n  if len(visited2) == len(r):\n\n    if dist < ans:\n\n      ans = dist\n\n    continue\n\n  for i in range(len(r)):\n\n    if r[i] not in visited2:\n\n      stack.append([r[i],visited2,dist])\n\n    \n\nprint((int(ans)))", "generated_code": "import sys\n\nreadline = sys.stdin.readline\n\n\n\nN,M,R = list(map(int,readline().split()))\n\nr = list(map(int,readline().split()))\n\nINF = 10 ** 10\n\n\n\nG = [[INF] * N for i in range(N)]\n\nfor i in range(M):\n\n  a,b,c = list(map(int,readline().split()))\n\n  G[a - 1][b - 1] = c\n\n  G[b - 1][a - 1] = c\n\n  \n\nfor i in range(N):\n\n  G[i][i] = 0\n\n  \n\nfor k in range(N):\n\n  for i in range(N):\n\n    for j in range(N):\n\n      G[i][j] = min(G[i][j], G[i][k] + G[k][j])\n\n      \n\nimport itertools\n\nans = INF\n\nfor perm in itertools.permutations(list(range(R))):\n\n  dist = 0\n\n  for i in range(1, len(perm)):\n\n    dist += G[r[perm[i - 1]] - 1][r[perm[i]] - 1]\n\n  if ans > dist:\n\n    ans = dist\n\n    \n\nprint(ans)\n", "score": 1.0, "surface_similarity": 0.6164092664092664}
{"id": "p02690_u750990077", "golden_code": "def main():\n\n    x = int(eval(input()))\n\n    for a in range(-120, 121):\n\n        for b in range(-120, 121):\n\n            if a**5 - b**5 == x:\n\n                print((a, b))\n\n                return\n\n\n\nif __name__ == \"__main__\":\n\n    main()", "generated_code": "def main():\n\n    x = int(eval(input()))\n\n    for i in range(-120, 121):\n\n        for j in range(-120, 121):\n\n            if i**5 - j**5 == x:\n\n                print((i, j))\n\n                return\n\n\n\nif __name__ == \"__main__\":\n\n    main()", "score": 1.0, "surface_similarity": 0.9873949579831933}
{"id": "p02814_u457901067", "golden_code": "from fractions import gcd\n\nN, M = list(map(int, input().split()))\n\nA = list([int(x) for x in input().split()])\n\n\n\ncnt = [0 for _ in range(N)]\n\nfor i in range(N):\n\n  a = A[i]\n\n  while a%2 == 0:\n\n    a = a // 2\n\n    cnt[i] += 1\n\n\n\nif max(cnt) > min(cnt):\n\n  print((0))\n\n  exit(0)\n\nC = max(cnt)\n\n\n\nA = list([x // pow(2,C) for x in A])\n\ndef gcd(a,b):\n\n  if a<b:\n\n    a,b = b,a\n\n  while a%b > 0:\n\n    a,b = b,a%b\n\n  return b\n\n\n\ndef lcm(a,b):\n\n  return a*b//gcd(a,b)\n\n\n\nx = A[0]\n\nfor a in A[1:]:\n\n  x = lcm(x,a)\n\nx = x * pow(2,C-1)\n\n\n\nprint(((M // x + 1) // 2))", "generated_code": "N, M = list(map(int, input().split()))\n\nA = list([int(x) for x in input().split()])\n\n\n\ncnt = [0 for _ in range(N)]\n\nfor i in range(N):\n\n  a = A[i]\n\n  while a%2 == 0:\n\n    a = a // 2\n\n    cnt[i] += 1\n\n\n\nif max(cnt) > min(cnt):\n\n  print((0))\n\n  exit(0)\n\nC = max(cnt)\n\n\n\nA = list([x // pow(2,C) for x in A])\n\ndef gcd(a,b):\n\n  if a<b:\n\n    a,b = b,a\n\n  while a%b > 0:\n\n    a,b = b,a%b\n\n  return b\n\n\n\ndef lcm(a,b):\n\n  return a*b//gcd(a,b)\n\n\n\nx = A[0]\n\nfor a in A[1:]:\n\n  x = lcm(x,a)\n\nx = x * pow(2,C-1)\n\n\n\nprint(((M // x + 1) // 2))", "score": 1.0, "surface_similarity": 0.9507078507078507}
{"id": "p03038_u027685417", "golden_code": "from heapq import *\n\n\n\n\n\nn, m = list(map(int, input().split()))\n\nPAIRS = [[-a, -1] for a in map(int, input().split())]\n\nheapify(PAIRS)\n\n\n\nfor _ in range(m):\n\n    b, c = list(map(int, input().split()))\n\n    heappush(PAIRS, [-c, -b])\n\n\n\nanswer = 0\n\nfor _ in range(n):\n\n    pair = heappop(PAIRS)\n\n    answer += -pair[0]\n\n    pair[1] += 1\n\n    if pair[1] != 0:\n\n        heappush(PAIRS, pair)\n\n\n\nprint(answer)\n", "generated_code": "n, m = list(map(int, input().split()))\n\nPAIRS = [(a, 1) for a in map(int, input().split())]\n\n\n\nfor _ in range(m):\n\n    b, c = list(map(int, input().split()))\n\n    PAIRS.append((c, b))\n\nPAIRS.sort(reverse = True)\n\n\n\nanswer, count = 0, 0\n\nfor pair in PAIRS:\n\n    answer += pair[0] * pair[1]\n\n    count += pair[1]\n\n    if count > n:\n\n        answer -= pair[0] * (count - n)\n\n        break\n\n\n\nprint(answer)\n", "score": 1.0, "surface_similarity": 0.6286738351254479}
{"id": "p04012_u277448038", "golden_code": "import numpy as np\n\nimport sys\n\nw = eval(input())\n\ncountn = np.zeros(26)\n\new = \"abcdefghijklmnopqrstuvwxyz\"\n\ni = 0\n\nwhile i < 26:\n\n    countn[i] = w.count(ew[i])\n\n    if countn[i] %2 != 0:\n\n        print(\"No\")\n\n        sys.exit()\n\n    i +=1\n\n  \n\nprint(\"Yes\")\n\n    \n\n    ", "generated_code": "#ABC044B\n\nw = eval(input())\n\nl = len(w)\n\nsig = 0\n\n\n\nfor i in range(l):\n\n    if w.count(w[i])%2 !=0:\n\n        sig = 1\n\n        break\n\n\n\nif sig == 1:\n\n    print(\"No\")\n\nelse:\n\n    print(\"Yes\")", "score": 1.0, "surface_similarity": 0.5885185185185184}
{"id": "p03796_u803617136", "golden_code": "import math\n\n\n\nn = int(eval(input()))\n\nans = math.factorial(n) % (pow(10, 9) + 7)\n\nprint(ans)", "generated_code": "n = int(eval(input()))\n\nans = 1\n\nmod = 10 ** 9 + 7\n\nfor i in range(1, n + 1):\n\n    ans = (ans * i % mod) % mod\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.6022179363548699}
{"id": "p02596_u991567869", "golden_code": "k = int(eval(input()))\n\nx = 1\n\n\n\nif k%7 != 0:\n\n    mod = 9*k\n\nelse:\n\n    mod = 9*k//7\n\n\n\nfor i in range(10**6):\n\n    x = x*10%mod\n\n    if x == 1:\n\n        print((i + 1))\n\n        exit()\n\n\n\nprint((-1))", "generated_code": "k = int(eval(input()))\n\na = 0\n\n\n\nfor i in range(k + 10):\n\n    a = (a*10 + 7)%k\n\n    if a == 0:\n\n        print((i + 1))\n\n        exit()\n\nprint((-1))", "score": 1.0, "surface_similarity": 0.8010714285714285}
{"id": "p03200_u562935282", "golden_code": "s = eval(input())\n\n\n\ncnt = 0\n\nans = 0\n\nfor c in s:\n\n    if c == 'B':\n\n        cnt += 1\n\n    elif c == 'W':\n\n        ans += cnt\n\nprint(ans)\n", "generated_code": "s = eval(input())\n\n\n\nans = 0\n\nb = 0\n\nfor ss in s:\n\n    if ss == 'W':\n\n        ans += b\n\n    else:\n\n        b += 1\n\nprint(ans)\n", "score": 1.0, "surface_similarity": 0.9028776978417266}
{"id": "p00053_u744114948", "golden_code": "import math\n\ndef pri(n):\n\n    if n < 2:\n\n        return False\n\n    elif n == 2:\n\n        return True\n\n    elif n % 2 == 0:\n\n        return False\n\n\n\n    i = 3\n\n    while i <= math.sqrt(n):\n\n        if n % i == 0:\n\n            return False\n\n        i += 2\n\n    return True\n\n\n\nl=[i for i in range(110000)if pri(i) ]\n\n\n\nwhile True:\n\n    n = int(eval(input()))\n\n    if n == 0: break\n\n    print((sum(l[:n])))", "generated_code": "import math\n\ndef pri(n):\n\n    l =[True] * n\n\n    l[0] = l[1] = False\n\n    for i in range(2,n):\n\n        if l[i]:\n\n            for j in range(i*2, n, i):\n\n                l[j] = False\n\n    return l\n\nn=105000\n\ns=pri(n)\n\nl=[i for i in range(n) if s[i]]\n\nwhile True:\n\n    n = int(eval(input()))\n\n    if n == 0: break\n\n    print((sum(l[:n])))", "score": 1.0, "surface_similarity": 0.7123939127889962}
{"id": "p02988_u133936772", "golden_code": "n = int(eval(input()))\n\nl = list(map(int, input().split()))\n\nprint((sum(l[i]<l[i+1]<l[i+2] or l[i]>l[i+1]>l[i+2] for i in range(n-2))))", "generated_code": "n=int(eval(input()))\n\nl=list(map(int,input().split()))\n\na=0\n\nfor i in range(n-2):\n\n  p,q,r=l[i:i+3]\n\n  if p<q<r or r<q<p: a+=1\n\nprint(a)", "score": 1.0, "surface_similarity": 0.6026583710407241}
{"id": "p02661_u729133443", "golden_code": "from numpy import*\n\na,b=median(t:=loadtxt(open(0),skiprows=1),0)\n\nprint((int((a-b)*~(~len(t)%2))+1))", "generated_code": "from statistics import*\n\n(n,),*t=[list(map(int,t.split()))for t in open(0)]\n\na,b=list(map(median,list(zip(*t))))\n\nprint((int((b-a)*(2-n%2))+1))", "score": 1.0, "surface_similarity": 0.5466200466200466}
{"id": "p04021_u102461423", "golden_code": "import sys\n\ninput = sys.stdin.readline\n\nsys.setrecursionlimit(10 ** 7)\n\n\n\n\"\"\"\n\n奇数番目集合、偶数番目集合の中で自由にできるのが操作2．\n\n操作1で集合間のやりとりをする\n\n\"\"\"\n\n\n\nimport numpy as np\n\n\n\nN = int(eval(input()))\n\nA = np.fromstring(sys.stdin.read(),dtype=np.int64,sep='\\n')\n\n\n\nB = np.sort(A)\n\n\n\nanswer = len(np.setdiff1d(A[::2],B[::2]))\n\nprint(answer)", "generated_code": "import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\n\"\"\"\n\n・偶数番号、奇数番号の中では入れ替え放題\n\n・偶、奇の間：並べてからスワップ。操作2を1回で、正しいものを2つ増やせる\n\n\"\"\"\n\n\n\nN,*A = list(map(int,read().split()))\n\n\n\nx_to_i = {x:i for i,x in enumerate(sorted(A))}\n\nrank = [x_to_i[x] for x in A]\n\n\n\nanswer = sum((x^i) & 1 for i,x in enumerate(rank)) // 2\n\nprint(answer)", "score": 1.0, "surface_similarity": 0.4430051813471503}
{"id": "p03494_u379716238", "golden_code": "import numpy as np\n\n\n\nx = int(eval(input()))\n\ny = input().split()\n\ny = [int(i) for i in y]\n\ny = np.array(y)\n\ncount = 0\n\nwhile sum([y[i] % 2 for i in range(len(y))]) == 0:\n\n    y = y/2\n\n    count += 1\n\nprint(count)", "generated_code": "N = int(eval(input()))\n\nA = input().split()\n\nA = [int(i) for i in A]\n\n\n\nc = 0 \n\n\n\nwhile True:\n\n  exist_odd = False\n\n  for a in A:\n\n    if a % 2 != 0:\n\n      exist_odd = True\n\n    \n\n  if exist_odd: break\n\n\n\n  for i in range(N):\n\n    A[i] = A[i] / 2\n\n  \n\n  c = c + 1\n\nprint(c)", "score": 1.0, "surface_similarity": 0.6401730197350636}
{"id": "p03363_u813098295", "golden_code": "N = int(input())\n\nA = list(map(int, input().split()))\n\n\n\nans, s = 0, 0\n\nd = {0:1}\n\n\n\nfor i in A:\n\n    s += i\n\n    ans += d.get(s, 0)\n\n    d[s] = d.get(s, 0) + 1\n\n\n\nprint(ans)", "generated_code": "#!/usr/bin/env python3\n\n\n\nfrom collections import defaultdict\n\n\n\nN = int(eval(input()))\n\nA = list(map(int, input().split()))\n\n\n\nd = defaultdict(int)\n\nd[0] = 1\n\n\n\ns, ans = 0, 0\n\n\n\nfor a in A:\n\n    s += a\n\n    ans += d[s]\n\n    d[s] += 1\n\n\n\nprint (ans)", "score": 1.0, "surface_similarity": 0.70999788628197}
{"id": "p03162_u625963200", "golden_code": "import numpy as np\n\nn=int(eval(input()))\n\nABC=[list(map(int,input().split())) for _ in range(n)]\n\n\n\ndp=np.zeros((n,3),int)\n\nfor i in range(3):\n\n  dp[0][i]=ABC[0][i]\n\nfor i in range(n-1):\n\n  for j in range(3):\n\n    dp[i+1][j]=max(dp[i][(j+1)%3]+ABC[i+1][j], dp[i][(j+2)%3]+ABC[i+1][j])\n\nprint((max(dp[-1])))", "generated_code": "import numpy as np\n\nn=int(eval(input()))\n\nABC=[list(map(int,input().split())) for _ in range(n)]\n\n\n\ndp=np.zeros((n,3),int)\n\nfor i in range(3):\n\n  dp[0,i]=ABC[0][i]\n\nfor i in range(1,n):\n\n  for j in range(3):\n\n    dp[i,j]=max(dp[i-1,(j+1)%3]+ABC[i][j],dp[i-1,(j+2)%3]+ABC[i][j])\n\nprint((max(dp[-1])))", "score": 1.0, "surface_similarity": 0.9689542483660131}
{"id": "p03162_u120865944", "golden_code": "N = int(eval(input()))\n\nl = [list(map(int, input().split())) for _ in range(N)]\n\n\n\ndp = [[0 for i in range(3)] for j in range(N+1)]\n\n\n\n\n\nfor i in range(1, N+1):\n\n    for j in range(3):\n\n        for k in range(3):\n\n            if j != k:\n\n                dp[i][j] = max(dp[i][j], dp[i-1][k]+l[i-1][k])\n\n\n\nprint((max(dp[N][0], dp[N][1], dp[N][2])))\n\n\n", "generated_code": "N = int(eval(input()))\n\ndp = [[0 for i in range(3)] for j in range(N+1)]\n\n\n\nfor i in range(1, N+1):\n\n    hapiness = list(map(int, input().split()))\n\n    for j in range(3):\n\n        for k in range(3):\n\n            if j != k:\n\n                dp[i][j] = max(dp[i][j], dp[i-1][k] + hapiness[k])\n\n\n\nprint((max(dp[N][0], dp[N][1], dp[N][2])))", "score": 1.0, "surface_similarity": 0.8796561604584527}
{"id": "p02899_u394731058", "golden_code": "import sys\n\n\n\ninput = sys.stdin.readline\n\n\n\ndef main():\n\n    ans = 0\n\n    n = int(input())\n\n    o = list(map(int, input().split()))\n\n    l = [0]*n\n\n    for i in range(n):\n\n        l[o[i]-1] = i+1\n\n    for i in range(len(l)):\n\n        if  i != len(l)-1:\n\n            print(\"{} \".format(l[i]), end='')\n\n        else:\n\n            print(l[i])\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "generated_code": "import sys\n\n\n\ninput = sys.stdin.readline\n\n\n\ndef main():\n\n    ans = 0\n\n    n = int(eval(input()))\n\n    o = list(map(int, input().split()))\n\n    l = [0]*n\n\n    for i in range(n):\n\n        l[o[i]-1] = i+1\n\n    print((\" \".join(map(str,l))))\n\nif __name__ == '__main__':\n\n    main()", "score": 1.0, "surface_similarity": 0.8620620217478856}
{"id": "p02994_u531220228", "golden_code": "N,L = list(map(int, input().split()))\n\ntaste = [L+i-1 for i in range(1,N+1)]\n\nif taste[-1] < 0:\n\n  print((sum(taste) + min([abs(x) for x in taste])))\n\nelse:\n\n  print((sum(taste) - min([abs(x) for x in taste])))", "generated_code": "N, L = list(map(int, input().split()))\n\n\n\ntaste = [L+i-1 for i in range(1, N+1)]\n\n\n\nif 0 in taste:\n\n    select = 0\n\nelse:\n\n    select_with_ind = min(enumerate(taste), key = lambda x: abs(x[1]))\n\n    select = select_with_ind[1]\n\n    \n\nprint((sum(taste) - select))", "score": 1.0, "surface_similarity": 0.6571953633022336}
{"id": "p03416_u077291787", "golden_code": "# ABC090B - Palindromic Numbers\n\na, b = list(map(int, input().rstrip().split()))\n\ncount = 0\n\nfor i in range(a, b + 1):\n\n    lst = list(map(int, list(str(i))))\n\n    if lst[0] == lst[4] and lst[1] == lst[3]:\n\n        count += 1\n\nprint(count)", "generated_code": "# ABC090B - Palindromic Numbers\n\ndef main():\n\n    a, b = list(map(int, input().rstrip().split()))\n\n    cnt = 0\n\n    for i in range(a, b + 1):\n\n        s = str(i)\n\n        if s == s[::-1]:\n\n            cnt += 1\n\n    print(cnt)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()", "score": 1.0, "surface_similarity": 0.688161281098084}
{"id": "p03720_u977389981", "golden_code": "n, m = list(map(int, input().split()))\n\ndp = [0] * n\n\nfor i in range(m):\n\n    x, y = list(map(int, input().split()))\n\n    dp[x - 1] += 1\n\n    dp[y - 1] += 1\n\nfor i in range(n):\n\n    print((dp[i]))", "generated_code": "n, m = list(map(int, input().split()))\n\nA = [0] * n\n\nfor i in range(m):\n\n    a, b = list(map(int, input().split()))\n\n    A[a - 1] += 1\n\n    A[b - 1] += 1\n\n    \n\nfor i in range(n):\n\n    print((A[i]))", "score": 1.0, "surface_similarity": 0.9696969696969697}
{"id": "p03558_u440566786", "golden_code": "import sys\n\nsys.setrecursionlimit(2147483647)\n\nINF=float(\"inf\")\n\nMOD=10**9+7\n\ninput=lambda :sys.stdin.readline().rstrip()\n\n\n\nfrom collections import deque\n\ndef resolve():\n\n    k=int(eval(input()))\n\n    E=[[] for _ in range(k)]\n\n    for i in range(k):\n\n        E[i].append(((i+1)%k,1))\n\n        E[i].append(((10*i)%k,0))\n\n\n\n    # 0-1 BFS\n\n    dist=[INF]*k\n\n    dist[1]=0\n\n    Q=deque([1])\n\n    while(Q):\n\n        v=Q.popleft()\n\n        for nv,w in E[v]:\n\n            if(dist[nv]<=dist[v]+w): continue\n\n            dist[nv]=dist[v]+w\n\n            if(w==0): Q.appendleft(nv)\n\n            else: Q.append(nv)\n\n    print((dist[0]+1))\n\nresolve()", "generated_code": "import sys\n\nINF = 1 << 60\n\nMOD = 10**9 + 7 # 998244353\n\nsys.setrecursionlimit(2147483647)\n\ninput = lambda:sys.stdin.readline().rstrip()\n\nfrom collections import deque\n\ndef resolve():\n\n    k = int(eval(input()))\n\n    dist = [INF] * k\n\n    dist[1] = 1\n\n    queue = deque([1])\n\n\n\n    while queue:\n\n        v = queue.pop()\n\n        if dist[10 * v % k] > dist[v]:\n\n            dist[10 * v % k] = dist[v]\n\n            queue.appendleft(10 * v % k)\n\n        if dist[(v + 1) % k] > dist[v] + 1:\n\n            dist[(v + 1) % k] = dist[v] + 1\n\n            queue.append((v + 1) % k)\n\n\n\n    print((dist[0]))\n\nresolve()", "score": 1.0, "surface_similarity": 0.6841244961934617}
{"id": "p03796_u171065106", "golden_code": "import math\n\n\n\nn = int(eval(input()))\n\n\n\nprint((math.factorial(n) % (10**9 + 7)))\n", "generated_code": "n = int(eval(input()))\n\n\n\nans = 1\n\n\n\nfor i in range(1, n+1):\n\n    ans *= i\n\n    ans %= 10**9 + 7\n\n\n\nprint(ans)\n", "score": 1.0, "surface_similarity": 0.5990990990990991}
{"id": "p03839_u761320129", "golden_code": "N,K = list(map(int,input().split()))\n\nsrc = list(map(int,input().split()))\n\n\n\ncums = [0]\n\ncump = [0]\n\nfor a in src:\n\n    cums.append(cums[-1] + a)\n\n    cump.append(cump[-1] + max(0,a))\n\n\n\nans = 0\n\nfor i in range(N-K+1):\n\n    tmp = cump[i]\n\n    tmp += max(0, cums[i+K] - cums[i])\n\n    tmp += cump[N] - cump[i+K]\n\n    ans = max(tmp, ans)\n\nprint(ans)\n", "generated_code": "N,K = list(map(int,input().split()))\n\nA = list(map(int,input().split()))\n\n\n\ncums = [0]\n\ncums_p = [0]\n\nfor a in A:\n\n    cums.append(cums[-1] + a)\n\n    cums_p.append(cums_p[-1] + max(0,a))\n\n\n\nans = -float('inf')\n\nfor l in range(N-K+1):\n\n    free = cums_p[l] + cums_p[-1] - cums_p[l+K]\n\n    cont = cums[l+K] - cums[l]\n\n    ans = max(ans, free, free+cont)\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.8606749311294766}
{"id": "p03796_u488127128", "golden_code": "def factorial(N):\n\n    power_r = 1\n\n    for n in range(2,N+1):\n\n        power_r *= n\n\n        power_r %= 10**9+7\n\n    return power_r\n\n\n\nif __name__ == '__main__':\n\n    N = int(eval(input()))\n\n    print((factorial(N)))", "generated_code": "def factorial(N):\n\n    power_r = 1\n\n    for n in range(2,N+1):\n\n        power_r = power_r*n % (10**9+7)\n\n    return power_r\n\n\n\nif __name__ == '__main__':\n\n    N = int(eval(input()))\n\n    print((factorial(N)))", "score": 1.0, "surface_similarity": 0.9611436950146628}
{"id": "p02596_u189479417", "golden_code": "import sys\n\nK = int(eval(input()))\n\n\n\npower = 7\n\nSUM = 0\n\n\n\nfor i in range(1, 10 ** 6):\n\n    SUM += power\n\n    if SUM % K == 0:\n\n        print(i)\n\n        sys.exit()\n\n    power *= 10\n\n    power %= K\n\n\n\nprint((-1))", "generated_code": "import sys\n\nK = int(eval(input()))\n\n\n\nL = 9 * K\n\n\n\nif K % 7 == 0:\n\n    L //= 7\n\n\n\npower = 1\n\n\n\nfor i in range(1, 10 ** 6):\n\n    power *= 10\n\n    power %= L\n\n    if power == 1:\n\n        print(i)\n\n        sys.exit()\n\n\n\nprint((-1))", "score": 1.0, "surface_similarity": 0.8223684210526316}
{"id": "p02780_u581187895", "golden_code": "import numpy as np\n\nimport sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\nN, K = list(map(int, readline().split()))\n\nA = np.array(readline().split(), dtype=np.int64) + 1\n\n\n\n\n\nAcum = np.zeros(N+1, np.float64)\n\nAcum[1:] = A.cumsum()\n\n\n\nx = Acum[K:] - Acum[:-K]\n\nprint((x.max()/2))\n", "generated_code": "import sys\n\nsys.setrecursionlimit(10 ** 7)\n\nread = sys.stdin.buffer.read \n\ninput = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines  \n\n\n\nfrom itertools import accumulate\n\n\n\nN, K = list(map(int, input().split()))\n\nP = list(map(int, input().split()))\n\nPcum = list(accumulate([0] + [(1+p)/2 for p in P]))\n\n\n\nans = max(right - left for left, right in zip(Pcum, Pcum[K:]))\n\nprint(ans)  ", "score": 1.0, "surface_similarity": 0.595896147403685}
{"id": "p02982_u519939795", "golden_code": "import numpy as np\n\nn,d=list(map(int,input().split()))\n\nx=[list(map(int,input().split())) for i in range(n)]\n\ncount=0\n\nfor i in range(n-1):\n\n    for j in range(i+1,n):\n\n        a=np.array(x[i])\n\n        b=np.array(x[j])\n\n        ab=sum(np.power((a-b),2))**0.5\n\n        if ab%1==0:\n\n            count+=1\n\nprint(count)", "generated_code": "n,d=list(map(int,input().split()))\n\nL=[list(map(int,input().split())) for i in range(n)]\n\nans=0\n\nfor i in range(n-1):\n\n    for j in range(i+1,n):\n\n        a=0\n\n        for k in range(d):\n\n            a+=(L[i][k]-L[j][k])**2\n\n        if int(a**0.5)==a**0.5:\n\n            ans+=1\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.8014849074975657}
{"id": "p00003_u912237403", "golden_code": "for n in range(eval(input())):\n\n  a,b,c=sorted(map(int,input().split()))\n\n  s=\"YES\" if a*a+b*b==c*c else \"NO\"\n\n  print(s)", "generated_code": "for n in range(eval(input())):\n\n  a,b,c=sorted(map(int,input().split()))\n\n  print(\"YES\" if a*a + b*b == c*c else \"NO\")", "score": 1.0, "surface_similarity": 0.9421487603305785}
{"id": "p02690_u764215612", "golden_code": "x=int(eval(input()))\n\nfor i in range(-118,120):\n\n  for j in range(-119,129):\n\n    if i**5-j**5==x:\n\n      print((i,j))\n\n      exit()", "generated_code": "x = int(eval(input()))\n\nfor i in range(120):\n\n  for j in range(-119,129):\n\n    if i**5 - j**5 == x:\n\n      print((i, j))\n\n      exit()", "score": 1.0, "surface_similarity": 0.9813432835820896}
{"id": "p02821_u766684188", "golden_code": "#E\n\nfrom itertools import accumulate\n\nfrom bisect import bisect_left\n\ndef main():\n\n    n,m=list(map(int,input().split()))\n\n    A=list(map(int,input().split()))\n\n    A.sort()\n\n    \n\n    def count(k):\n\n        cnt=0\n\n        for a in A:\n\n            cnt+=bisect_left(A,k-a)\n\n        return cnt\n\n    \n\n    ok=0\n\n    ng=10**10+1\n\n    while ng-ok>1:\n\n        mid=(ok+ng)//2\n\n        if count(mid)<n**2-m:\n\n            ok=mid\n\n        else:\n\n            ng=mid\n\n    border=ok\n\n    \n\n    k=n**2-count(border)\n\n    Acc=[0]+list(accumulate(A))\n\n    s=Acc[-1]\n\n    ans=0\n\n    for a in A:\n\n        idx=bisect_left(A,border-a)\n\n        ans+=a*(n-idx)+(s-Acc[idx])\n\n    ans-=border*(k-m)\n\n    print(ans)\n\n    \n\nif __name__=='__main__':\n\n    main()", "generated_code": "from itertools import accumulate\n\nfrom bisect import bisect_left\n\ndef main():\n\n    n,m=list(map(int,input().split()))\n\n    A=list(map(int,input().split()))\n\n    A.sort()\n\n    \n\n    def count(k):\n\n        cnt=0\n\n        for a in A:\n\n            cnt+=bisect_left(A,k-a)\n\n        return cnt\n\n    \n\n    ok=0\n\n    ng=2*10**5+1\n\n    while ng-ok>1:\n\n        mid=(ok+ng)//2\n\n        if count(mid)<n**2-m:\n\n            ok=mid\n\n        else:\n\n            ng=mid\n\n    border=ok\n\n    \n\n    k=n**2-count(border)\n\n    Acc=[0]+list(accumulate(A))\n\n    s=Acc[-1]\n\n    ans=0\n\n    for a in A:\n\n        idx=bisect_left(A,border-a)\n\n        ans+=a*(n-idx)+(s-Acc[idx])\n\n    ans-=border*(k-m)\n\n    print(ans)\n\n    \n\nif __name__=='__main__':\n\n    main()", "score": 1.0, "surface_similarity": 0.9972752043596731}
{"id": "p03634_u738898077", "golden_code": "import sys\n\ninput = sys.stdin.readline\n\nn = int(eval(input()))\n\nv = [[0]+[]*(n+1) for i in range(n+1)]\n\nfor i in range(n-1):\n\n    a,b,c = list(map(int,input().split()))\n\n    v[a].append([b,c])\n\n    v[b].append([a,c])\n\n\n\nq,k = list(map(int,input().split()))\n\nl = [k]\n\nwhile l:\n\n    now = l.pop()\n\n    for i in v[now][1:]:\n\n        if v[i[0]][0] == 0:\n\n            v[i[0]][0] = i[1]+v[now][0]\n\n            l.append(i[0])\n\n\n\nfor i in range(q):\n\n    x,y = list(map(int,input().split()))\n\n    print((v[x][0]+v[y][0]))", "generated_code": "import sys\n\ndef main():\n\n    input = sys.stdin.readline\n\n    n = int(eval(input()))\n\n    v = [[0]+[]*(n+1) for i in range(n+1)]\n\n    for i in range(n-1):\n\n        a,b,c = list(map(int,input().split()))\n\n        v[a].append([b,c])\n\n        v[b].append([a,c])\n\n\n\n    q,k = list(map(int,input().split()))\n\n    l = [k]\n\n    while l:\n\n        now = l.pop()\n\n        for i in v[now][1:]:\n\n            if v[i[0]][0] == 0:\n\n                v[i[0]][0] = i[1]+v[now][0]\n\n                l.append(i[0])\n\n\n\n    for i in range(q):\n\n        x,y = list(map(int,input().split()))\n\n        print((v[x][0]+v[y][0]))\n\n\n\nif __name__ == '__main__':\n\n    main()", "score": 1.0, "surface_similarity": 0.932653391614052}
{"id": "p02767_u977193988", "golden_code": "import numpy as np\n\n\n\nN = int(eval(input()))\n\nX = np.array(list(map(int, input().split())))\n\ncost = float(\"inf\")\n\nfor i in range(max(X) - min(X) + 1):\n\n    p = min(X) + i\n\n    cost = min(np.sum((X - p) ** 2), cost)\n\nprint(cost)", "generated_code": "N = int(eval(input()))\n\nX = sorted(list(map(int, input().split())))\n\nif N == 1:\n\n    print((0))\n\nelse:\n\n    r = X[-1] - X[0]\n\n    ans = float(\"inf\")\n\n    for i in range(r + 1):\n\n        R = X[0] + i\n\n        hp = 0\n\n        for j in range(N):\n\n            hp = hp + (R - X[j]) ** 2\n\n\n\n        ans = min(hp, ans)\n\n\n\n    print(ans)\n", "score": 1.0, "surface_similarity": 0.6164690382081687}
{"id": "p03568_u497046426", "golden_code": "from functools import reduce\n\nfrom itertools import product\n\n\n\nN = int(eval(input()))\n\n*A, = list(map(int, input().split()))\n\nans = 0\n\nfor t in product([-1, 0, 1], repeat=N):\n\n    prod = reduce(lambda x, y: x*y, [a + t[i] for i, a in enumerate(A)])\n\n    if prod % 2 == 0: ans += 1\n\nprint(ans)", "generated_code": "N = int(eval(input()))\n\n*A, = list(map(int, input().split()))\n\nevens = 0\n\nfor a in A:\n\n    if a % 2 == 0: evens += 1\n\nans = 3**N - 2**evens\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.5162915851272015}
{"id": "p02748_u628707847", "golden_code": "a, b, m = list(map(int,input().split()))\n\ndr = list(map(int,input().split()))\n\nwa = list(map(int,input().split()))\n\nxyc = [list(map(int,input().split())) for i in range(m)]\n\nlow = 200001\n\n\n\nfor i in range(m):\n\n    f = xyc[i][0] - 1\n\n    d = xyc[i][1] - 1\n\n    if low >= dr[f]+wa[d]-xyc[i][2]:\n\n        low = dr[f]+wa[d]-xyc[i][2]\n\n\n\ndr.sort()\n\nwa.sort()\n\n\n\nif low >= (dr[0] + wa[0]):\n\n    print((dr[0] + wa[0]))\n\nelse:\n\n    print(low)", "generated_code": "a, b, m = list(map(int,input().split()))\n\nal = list(map(int,input().split()))\n\nbl = list(map(int,input().split()))\n\nlow = min(al)+min(bl)\n\nx = [0] * m\n\ny = [0] * m\n\nc = [0] * m\n\n\n\nfor i in range(m):\n\n    x[i],y[i],c[i] = list(map(int, input().split()))\n\n    x[i] -= 1\n\n    y[i] -= 1\n\n \n\nfor i in range(m):\n\n    low = min(low,al[x[i]]+bl[y[i]]-c[i])\n\n\n\nprint(low)", "score": 1.0, "surface_similarity": 0.6340245775729647}
{"id": "p02690_u428199834", "golden_code": "X=int(eval(input()))\n\na=[]\n\nfor i in range(-100,200):\n\n  for j in range(-100,200):\n\n    if i**5-j**5==X:\n\n      a.append(str(i))\n\n      a.append(str(j))\n\n      break\n\nprint((' '.join(a[0:2])))\n\n\n\n    ", "generated_code": "X=int(eval(input()))\n\na=[]\n\nfor i in range(-100,200):\n\n  for j in range(-100,200):\n\n    if i**5-j**5==X:\n\n      a.append(str(i))\n\n      a.append(str(j))\n\n      break\n\n  else:\n\n    continue\n\n  break  \n\nprint((' '.join(a[0:2])))\n\n\n\n    \n", "score": 1.0, "surface_similarity": 0.9335800185013876}
{"id": "p03835_u624689667", "golden_code": "K, S = [int(i) for i in input().split()]\n\n\n\nc = 0\n\nfor X in range(K + 1):\n\n    for Y in range(K + 1):\n\n        Z = S - X - Y\n\n        if 0 <= Z <= K:\n\n            c += 1\n\n\n\nprint(c)", "generated_code": "K, S = [int(i) for i in input().split()]\n\n\n\nans = 0\n\n# X <= Y <= Zとしても一般性を失わない\n\nfor x in range(K + 1):\n\n    for y in range(x, K + 1):\n\n        z = S - x - y\n\n        if z < y:\n\n            break\n\n        if z <= K:\n\n            if x == y == z:\n\n                ans += 1\n\n            elif x == y or y == z or z == x:\n\n                ans += 3\n\n            else:\n\n                ans += 6\n\nprint(ans)\n", "score": 1.0, "surface_similarity": 0.7972431077694235}
{"id": "p03126_u580697892", "golden_code": "import numpy as np\n\nN, M = list(map(int, input().split()))\n\nmenu = np.array([])\n\nfor i in range(N):\n\n  a = np.array(input().split())\n\n  menu = np.append(menu, a[1:])\n\nmenu = np.array(menu).astype(int).ravel()\n\ncount = 0\n\nfor i in range(1, M+1):\n\n  if np.sum(menu == i) == N:\n\n    count += 1\n\nprint(count)", "generated_code": "# coding: utf-8\n\nn, m = list(map(int, input().split()))\n\nll = [0] * m\n\nfor i in range(n):\n\n    l = list(map(int, input().split()))\n\n    for j in range(l[0]):\n\n        ll[l[j+1] - 1] += 1\n\nprint((ll.count(max(ll)) if max(ll)==n else 0))", "score": 1.0, "surface_similarity": 0.5879301619433198}
{"id": "p02983_u306664745", "golden_code": "l, r=list(map(int, input().split()))\n\nif r-l>672:\n\n\tp=0\n\nelse:\n\n\tp=2019\n\n\tfor i in range(l, r):\n\n\t\tfor j in range(i+1, r+1):\n\n\t\t\tp=min(p, (((i%2019)*(j%2019))%2019))\n\n\t\t\tif not p:\n\n\t\t\t\tbreak\n\n\t\tif not p:\n\n\t\t\tbreak\n\nprint(p)", "generated_code": "l, r=list(map(int, input().split()))\n\nif r-l>672:\n\n\tp=0\n\nelse:\n\n\tp=2019\n\n\tfor i in range(l, r):\n\n\t\tfor j in range(i+1, r+1):\n\n\t\t\tp=min(p, (i*j%2019))\n\n\t\t\tif not p:\n\n\t\t\t\tbreak\n\n\t\tif not p:\n\n\t\t\tbreak\n\nprint(p)", "score": 1.0, "surface_similarity": 0.9641255605381166}
{"id": "p03371_u046592970", "golden_code": "a,b,c,x,y = list(map(int,input().split()))\n\nprice = 10**10\n\nfor k in range(10**5+1):\n\n    re = 2*c*k + max(0,x-k)*a + max(0,y-k)*b\n\n    price = min(re,price)\n\nprint(price)", "generated_code": "a,b,c,x,y = list(map(int,input().split()))\n\na1 = a*x + b*y\n\na2 = max(x,y) * 2*c\n\nif y >= x:\n\n    a3 = 2*c*x + (y-x)*b\n\nelse:\n\n    a3 = 2*c*y + (x-y)*a\n\nprint((min(a1,a2,a3)))", "score": 1.0, "surface_similarity": 0.6299153055051421}
{"id": "p04021_u562016607", "golden_code": "import numpy as np\n\nN=int(eval(input()))\n\nA=[int(eval(input())) for i in range(N)]\n\nB=list(np.argsort(np.array(A)))\n\nX=[[0,0],[0,0]]\n\nfor i in range(N):\n\n    X[i%2][B[i]%2]+=1\n\nprint((X[0][1]))\n", "generated_code": "N=int(eval(input()))\n\nA=[int(eval(input())) for i in range(N)]\n\nAT=[(A[i],i) for i in range(N)]\n\nAT.sort()\n\nB=[AT[i][1] for i in range(N)]\n\nX=[[0,0],[0,0]]\n\nfor i in range(N):\n\n    X[i%2][B[i]%2]+=1\n\nY=[X[0][1],X[1][0]]\n\nprint((min(Y)))\n", "score": 1.0, "surface_similarity": 0.733505945531262}
{"id": "p03796_u597374218", "golden_code": "import math\n\nprint((math.factorial(int(eval(input())))%(10**9+7)))", "generated_code": "ans=1\n\nn=int(eval(input()))\n\nfor i in range(1,n+1):\n\n    ans*=i\n\n    ans=ans%(10**9+7)\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.4614512471655329}
{"id": "p02996_u222668979", "golden_code": "import sys\n\ninput = sys.stdin.readline\n\n\n\nn = int(eval(input()))\n\nab = sorted([list(map(int, input().split()))[::-1] for _ in range(n)])\n\n\n\ncnt = 0\n\nfor b, a in ab:\n\n    cnt += a\n\n    if cnt > b:\n\n        print('No')\n\n        break\n\nelse:\n\n    print('Yes')\n", "generated_code": "n = int(eval(input()))\n\nab = [list(map(int, input().split())) for _ in range(n)]\n\nab = sorted(ab, key=lambda x: x[1])\n\n\n\nt = 0\n\nfor a, b in ab:\n\n    t += a\n\n    if t > b:\n\n        print('No')\n\n        break\n\nelse:\n\n    print('Yes')\n", "score": 1.0, "surface_similarity": 0.6660181582360571}
{"id": "p02777_u927807968", "golden_code": "S, T = input().split()\n\nA, B= list(map(int, input().split()))\n\nU = eval(input())\n\nif S == U:\n\n    print((A - 1, B))\n\nelse:\n\n    print((A, B - 1))", "generated_code": "S, T = input().split()\n\nA, B= list(map(int, input().split()))\n\nU = eval(input())\n\nif S == U:\n\n    A-=1\n\nelse:\n\n    B-=1\n\nprint((A,B))", "score": 1.0, "surface_similarity": 0.8719827586206896}
{"id": "p03828_u281303342", "golden_code": "from collections import Counter\n\nN = int(eval(input()))\n\ndiv = []\n\nfor i in range(2,N+1):\n\n    while i != 1:\n\n        for d in range(2,i+1):\n\n            while i%d==0:\n\n                i = i//d\n\n                div.append(d)\n\nC = Counter(div).most_common()\n\nAns = 1\n\nfor k,v in C:\n\n    Ans = Ans*(v+1) % (10**9+7)\n\n\n\nprint(Ans)\n", "generated_code": "from collections import defaultdict\n\nN = int(eval(input()))\n\n\n\nF = [True]*(N+1)\n\nF[0]=F[1]=False\n\nP = []\n\n\n\nfor i in range(2,N+1):\n\n    if F[i]==True:\n\n        P.append(i)\n\n        for j in range(i*2,N+1,i):\n\n            F[j]=False\n\n\n\ndic = defaultdict(int)\n\nfor i in range(2,N+1):\n\n    for p in P:\n\n        while i%p==0:\n\n            dic[p] += 1\n\n            i = i//p\n\n        if i==1:\n\n            break\n\n\n\nans = 1\n\nmodulo = 10**9+7\n\nfor v in list(dic.values()):\n\n    ans *= (v+1)\n\n    ans %= modulo\n\n\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.6754268496819551}
{"id": "p02245_u426534722", "golden_code": "from collections import deque\n\nfrom copy import deepcopy, copy\n\ndy = [-1, 0, 0, 1]\n\ndx = [0, -1, 1, 0]\n\nN = 3\n\ndef g(i, j, a):\n\n    t = a // (10 ** j) % 10\n\n    return a - t * (10 ** j) + t * (10 ** i)\n\ndef MAIN():\n\n    m = {8:{7, 5}, 7:{8, 6, 4}, 6:{7, 3}, 5:{8, 4, 2}, 4:{7, 5, 3, 1}, 3:{6, 4, 0}, 2:{5, 1}, 1:{4, 2, 0}, 0:{3, 1}}\n\n    MAP = \"\".join(input().replace(\" \", \"\") for _ in range(N))\n\n    start = 8 - MAP.find(\"0\")\n\n    MAP = int(MAP)\n\n    goal = ('1', '2', '3', '4', '5', '6', '7', '8', '0')\n\n    goal = 123456780\n\n    dp = deque([(0, start, MAP)])\n\n    LOG = {MAP}\n\n    while dp:\n\n        cnt, yx, M = dp.popleft()\n\n        if M == goal:\n\n            print(cnt)\n\n            break\n\n        cnt += 1\n\n        for nyx in m[yx]:\n\n            CM = g(yx, nyx, M)\n\n            if not CM in LOG:\n\n                dp.append((cnt, nyx, CM))\n\n                LOG.add(CM)\n\nMAIN()\n\n\n", "generated_code": "from collections import deque\n\nfrom copy import deepcopy, copy\n\nN = 3\n\ndef g(i, j, a):\n\n    if i > j:\n\n        i, j = j, i\n\n    return a[:i] + a[j] + a[i + 1:j] + a[i] + a[j + 1:]\n\ndef MAIN():\n\n    m = {8:{7, 5}, 7:{8, 6, 4}, 6:{7, 3}, 5:{8, 4, 2}, 4:{7, 5, 3, 1}, 3:{6, 4, 0}, 2:{5, 1}, 1:{4, 2, 0}, 0:{3, 1}}\n\n    MAP = \"\".join(input().replace(\" \", \"\") for _ in range(N))\n\n    start = MAP.find(\"0\")\n\n    goal = \"123456780\"\n\n    dp = deque([(0, start, MAP)])\n\n    LOG = {MAP}\n\n    while dp:\n\n        cnt, yx, M = dp.popleft()\n\n        if M == goal:\n\n            print(cnt)\n\n            break\n\n        cnt += 1\n\n        for nyx in m[yx]:\n\n            CM = g(yx, nyx, M)\n\n            if not CM in LOG:\n\n                dp.append((cnt, nyx, CM))\n\n                LOG.add(CM)\n\nMAIN()\n\n\n", "score": 1.0, "surface_similarity": 0.8346603600052556}
{"id": "p03416_u556358547", "golden_code": "# vim: fileencoding=utf-8\n\n\n\n\n\ndef main():\n\n    a, b = list(map(int, input().split()))\n\n    c = 0\n\n    for i in range(a, b + 1):\n\n        s = str(i)\n\n        r = \"\".join(reversed(list(s)))\n\n        if s == r:\n\n            c += 1\n\n    print(c)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "generated_code": "# vim: fileencoding=utf-8\n\n\n\n\n\ndef main():\n\n    a, b = list(map(int, input().split()))\n\n    c = 0\n\n    for i in range(a, b + 1):\n\n        #     s = str(i)\n\n        #     r = \"\".join(reversed(list(s)))\n\n        #     if s == r:\n\n        #         c += 1\n\n        if (i % 10) == (i // 10000 % 10) and (i // 10 % 10) == (i // 1000 % 10):\n\n            c += 1\n\n    print(c)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "score": 1.0, "surface_similarity": 0.8585640593746711}
{"id": "p03371_u764401543", "golden_code": "A, B, C, X, Y = list(map(int, input().split()))\n\n\n\nans = float('inf')\n\n\n\nfor i in range(10 ** 5 + 1):\n\n    ans = min(ans, A * max(X - i, 0) + B * max(Y - i, 0) + 2 * C * i)\n\nprint(ans)", "generated_code": "A, B, C, X, Y = list(map(int, input().split()))\n\n\n\n# ans = float('inf')\n\n\n\n# for i in range(10 ** 5 + 1):\n\n#     ans = min(ans, A * max(X - i, 0) + B * max(Y - i, 0) + 2 * C * i)\n\n# print(ans)\n\n\n\nmin_xy = min(X, Y)\n\nmax_xy = max(X, Y)\n\nans1 = 2 * C * min_xy + A * (X - min_xy) + B * (Y - min_xy)\n\nans2 = A * X + B * Y\n\nans3 = 2 * C * max_xy\n\nprint((min(ans1, ans2, ans3)))", "score": 1.0, "surface_similarity": 0.801747311827957}
{"id": "p02555_u145231176", "golden_code": "def getN():\n\n    return int(eval(input()))\n\ndef getNM():\n\n    return list(map(int, input().split()))\n\ndef getList():\n\n    return list(map(int, input().split()))\n\ndef getArray(intn):\n\n    return [int(eval(input())) for i in range(intn)]\n\ndef input():\n\n    return sys.stdin.readline().rstrip()\n\ndef rand_N(ran1, ran2):\n\n    return random.randint(ran1, ran2)\n\ndef rand_List(ran1, ran2, rantime):\n\n    return [random.randint(ran1, ran2) for i in range(rantime)]\n\ndef rand_ints_nodup(ran1, ran2, rantime):\n\n  ns = []\n\n  while len(ns) < rantime:\n\n    n = random.randint(ran1, ran2)\n\n    if not n in ns:\n\n      ns.append(n)\n\n  return sorted(ns)\n\n\n\ndef rand_query(ran1, ran2, rantime):\n\n  r_query = []\n\n  while len(r_query) < rantime:\n\n    n_q = rand_ints_nodup(ran1, ran2, 2)\n\n    if not n_q in r_query:\n\n      r_query.append(n_q)\n\n  return sorted(r_query)\n\n\n\nfrom collections import defaultdict, deque, Counter\n\nfrom sys import exit\n\nfrom decimal import *\n\nfrom heapq import heapify, heappop, heappush\n\nimport math\n\nimport random\n\nimport string\n\nfrom copy import deepcopy\n\nfrom itertools import combinations, permutations, product\n\nfrom operator import mul, itemgetter\n\nfrom functools import reduce\n\nfrom bisect import bisect_left, bisect_right\n\n\n\nimport sys\n\nsys.setrecursionlimit(1000000000)\n\nmod = 10 ** 9 + 7\n\n\n\n#############\n\n# Main Code #\n\n#############\n\n\n\nS = getN()\n\n\n\n# 逆元事前処理ver\n\n# nが小さい場合に\n\nlim = 10 ** 5 + 1\n\nfact = [1, 1]\n\nfactinv = [1, 1]\n\ninv = [0, 1]\n\n\n\nfor i in range(2, lim + 1):\n\n    fact.append((fact[-1] * i) % mod)\n\n    inv.append((-inv[mod % i] * (mod // i)) % mod)\n\n    # 累計\n\n    factinv.append((factinv[-1] * inv[-1]) % mod)\n\n\n\ndef cmb(n, r):\n\n    if (r < 0) or (n < r):\n\n        return 0\n\n    r = min(r, n - r)\n\n    return fact[n] * factinv[r] * factinv[n - r] % mod\n\n\n\nans = 0\n\n# 長さNの時最低でも3 * N使う\n\n# 残りは分配する\n\nfor i in range(1, 2001):\n\n    s = S - (3 * i)\n\n    if s < 0:\n\n        break\n\n    # sをN個に分配する通りがいくつあるか\n\n    # 重複組み合わせ\n\n    # 仕切りの数はi - 1個\n\n    ans += cmb(s + i - 1, i - 1)\n\nprint((ans % mod))", "generated_code": "def getN():\n\n    return int(eval(input()))\n\ndef getNM():\n\n    return list(map(int, input().split()))\n\ndef getList():\n\n    return list(map(int, input().split()))\n\ndef getArray(intn):\n\n    return [int(eval(input())) for i in range(intn)]\n\ndef input():\n\n    return sys.stdin.readline().rstrip()\n\ndef rand_N(ran1, ran2):\n\n    return random.randint(ran1, ran2)\n\ndef rand_List(ran1, ran2, rantime):\n\n    return [random.randint(ran1, ran2) for i in range(rantime)]\n\ndef rand_ints_nodup(ran1, ran2, rantime):\n\n  ns = []\n\n  while len(ns) < rantime:\n\n    n = random.randint(ran1, ran2)\n\n    if not n in ns:\n\n      ns.append(n)\n\n  return sorted(ns)\n\n\n\ndef rand_query(ran1, ran2, rantime):\n\n  r_query = []\n\n  while len(r_query) < rantime:\n\n    n_q = rand_ints_nodup(ran1, ran2, 2)\n\n    if not n_q in r_query:\n\n      r_query.append(n_q)\n\n  return sorted(r_query)\n\n\n\nfrom collections import defaultdict, deque, Counter\n\nfrom sys import exit\n\nfrom decimal import *\n\nfrom heapq import heapify, heappop, heappush\n\nimport math\n\nimport random\n\nimport string\n\nfrom copy import deepcopy\n\nfrom itertools import combinations, permutations, product\n\nfrom operator import mul, itemgetter\n\nfrom functools import reduce\n\nfrom bisect import bisect_left, bisect_right\n\n\n\nimport sys\n\nsys.setrecursionlimit(1000000000)\n\nmod = 10 ** 9 + 7\n\n\n\n#############\n\n# Main Code #\n\n#############\n\n\n\nN = getN()\n\nlogk = N.bit_length()\n\n\n\n# 漸化式にできるなら行列計算に落とし込める\n\n# A[n] = A[n - 1] + A[n - 3]なので\n\n# [a2, a1, a0] = [0, 0, 1]\n\n# [[1, 1, 0], [0, 0, 1], [1, 0, 0]]のN乗をすれば\n\n# [an+2, an+1, an] が出る\n\n\n\ndp = [[[0, 0, 0] for i in range(3)] for i in range(logk)]\n\ndp[0] = [\n\n[1, 1, 0],\n\n[0, 0, 1],\n\n[1, 0, 0]\n\n]\n\n\n\n# 行列掛け算 O(n3)かかる\n\ndef array_cnt(ar1, ar2):\n\n    h = len(ar1)\n\n    w = len(ar2[0])\n\n    row = ar1\n\n    col = []\n\n    for j in range(w):\n\n        opt = []\n\n        for i in range(len(ar2)):\n\n            opt.append(ar2[i][j])\n\n        col.append(opt)\n\n\n\n    res = [[[0, 0] for i in range(w)] for i in range(h)]\n\n    for i in range(h):\n\n        for j in range(w):\n\n            cnt = 0\n\n            for x, y in zip(row[i], col[j]):\n\n                cnt += x * y\n\n            res[i][j] = cnt\n\n            res[i][j] %= mod\n\n    return res\n\n\n\nfor i in range(1, logk):\n\n    dp[i] = array_cnt(dp[i - 1], dp[i - 1])\n\n\n\nans = [[0, 0, 1]]\n\nfor i in range(logk):\n\n    if N & (1 << i):\n\n        ans = array_cnt(ans, dp[i])\n\nprint((ans[0][2] % mod))", "score": 1.0, "surface_similarity": 0.8233885679537853}
{"id": "p03037_u896741788", "golden_code": "k,m=list(map(int,input().split()))\n\nl=[0 for i in range(k+1)]\n\nfor i in range(m):\n\n  a,s=list(map(int,input().split()))\n\n  l[a-1]+=1;l[s]-=1\n\nans=0\n\nf=0\n\nfor j in range(k):\n\n  l[j]+=f\n\n  f=l[j]\n\nprint((len([1 for i in l if i==m])))", "generated_code": "n,m=list(map(int,input().split()))\n\ntable=[0]*(n+2)\n\nfor i in range(m):\n\n    l,r=list(map(int,input().split()))\n\n    table[l]+=1\n\n    table[r+1]-=1\n\nfrom itertools import accumulate\n\nfrom collections import Counter as co\n\nvar=co((accumulate(table)))\n\n\n\nif m not in var:print((0))\n\nelse:print((var[m]))\n\n\n\n\n", "score": 1.0, "surface_similarity": 0.5964052287581699}
{"id": "p02982_u969850098", "golden_code": "import numpy as np\n\n\n\nN, D = list(map(int, input().split()))\n\npoints = [list(map(int, input().split())) for _ in range(N)]\n\ncount = 0\n\nfor i in range(N):\n\n    for j in range(N):\n\n        if j == i:\n\n            continue\n\n        dist = np.sqrt(sum([(points[i][d] - points[j][d]) ** 2 for d in range(D)]))\n\n        if dist.is_integer():\n\n            count += 1\n\nprint((count // 2))", "generated_code": "import sys\n\nsys.setrecursionlimit(10 ** 6)\n\n\n\n\n\ndef calc_dist(x, y):\n\n    dist = 0\n\n    for xi, yi in zip(x, y):\n\n        dist += (yi - xi) ** 2\n\n    return dist ** (1/2)\n\n\n\n\n\ndef main():\n\n    N, D = list(map(int, sys.stdin.readline().rstrip().split()))\n\n    X = [list(map(int, sys.stdin.readline().rstrip().split())) for _ in range(N)]\n\n\n\n    ans = 0\n\n    for i in range(N):\n\n        for j in range(i+1, N):\n\n            dist = calc_dist(X[i], X[j])\n\n            if dist.is_integer():\n\n                ans += 1\n\n    \n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()", "score": 1.0, "surface_similarity": 0.6462575823223571}
{"id": "p02983_u426764965", "golden_code": "def abc133_c():\n\n    L, R = list(map(int, input().split()))\n\n    # 区間の幅が673あれば、673の倍数と3の倍数が含まれて、2019の倍数が作れる\n\n    if R - L > 673: return 0\n\n    # それ以外は試す\n\n    ans = 2019\n\n    for i in range(L, R+1):\n\n        for j in range(L, i):\n\n            m = i * j % 2019\n\n            ans = min(m, ans)\n\n    return ans\n\n\n\nprint((abc133_c()))", "generated_code": "def abc133_c():\n\n    L, R = list(map(int, input().split()))\n\n    # 区間の幅が673あれば、673の倍数と3の倍数が含まれて、2019の倍数が作れる\n\n    if R - L > 673: return 0\n\n    # それ以外は試す\n\n    ans = 2019\n\n    for i in range(L, R+1):\n\n        for j in range(L, i):\n\n            m = i * j % 2019\n\n            ans = min(m, ans)\n\n            if ans == 1: return 1\n\n    return ans\n\n\n\nprint((abc133_c()))", "score": 1.0, "surface_similarity": 0.9548448916037848}
{"id": "p02792_u025501820", "golden_code": "N = int(eval(input()))\n\ncount = [[0 for _ in range(9)] for _ in range(9)]\n\nfor i in range(1, N + 1):\n\n    if str(i)[0] != \"0\" and str(i)[-1] != \"0\":\n\n        count[int(str(i)[0]) - 1][int(str(i)[-1]) - 1] += 1\n\nans = 0\n\nfor i in range(0, 9):\n\n    for k in range(0, 9):\n\n        ans += count[i][k] * count[k][i]\n\nprint(ans)", "generated_code": "N = int(eval(input()))\n\nnums = [0 for i in range(100)]\n\nfor i in range(1, N + 1):\n\n    i = str(i)\n\n    nums[int(i[0] + i[-1])] += 1\n\nans = 0\n\nfor i in range(1, 10):\n\n    for j in range(i, 10):\n\n        i = str(i)\n\n        j = str(j)\n\n        if i != j:\n\n            ans += nums[int(i + j)] * nums[int(j + i)] * 2\n\n        else:\n\n            n = nums[int(i + j)]\n\n            ans += n * (n - 1)\n\n            ans += n\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.7667915690866511}
{"id": "p02690_u934442292", "golden_code": "import sys\n\n\n\ninput = sys.stdin.readline\n\n\n\n\n\ndef main():\n\n    X = int(eval(input()))\n\n\n\n    for A in range(-200, 201):\n\n        for B in range(-200, 201):\n\n            if A ** 5 - B ** 5 == X:\n\n                print((A, B))\n\n                exit()\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "generated_code": "import sys\n\n\n\ninput = sys.stdin.readline\n\n\n\n\n\ndef main():\n\n    X = int(eval(input()))\n\n\n\n    for A in range(-119, 120 + 1):\n\n        for B in range(-119, 120 + 1):\n\n            if A ** 5 - B ** 5 == X:\n\n                print((A, B))\n\n                exit()\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "score": 1.0, "surface_similarity": 0.9625553709856036}
{"id": "p03078_u588341295", "golden_code": "# -*- coding: utf-8 -*-\n\n\n\nimport sys\n\n\n\ndef input(): return sys.stdin.readline().strip()\n\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\n\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\n\ndef ceil(x, y=1): return int(-(-x // y))\n\ndef INT(): return int(eval(input()))\n\ndef MAP(): return list(map(int, input().split()))\n\ndef LIST(): return list(map(int, input().split()))\n\ndef Yes(): print('Yes')\n\ndef No(): print('No')\n\ndef YES(): print('YES')\n\ndef NO(): print('NO')\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = float('inf')\n\nMOD = 10 ** 9 + 7\n\n\n\nX,Y,Z,K=MAP()\n\nA=sorted(LIST(), reverse=True)\n\nB=sorted(LIST(), reverse=True)\n\nC=sorted(LIST(), reverse=True)\n\n\n\nABC=[]\n\nfor i in range(X):\n\n    for j in range(Y):\n\n        if (i+1)*(j+1)>K:\n\n            break\n\n        for k in range(Z):\n\n            if (i+1)*(j+1)*(k+1)>K:\n\n                break\n\n            ABC.append(A[i]+B[j]+C[k])\n\nABC.sort(reverse=True)\n\nfor i in range(K):\n\n    print((ABC[i]))\n\n\n", "generated_code": "# -*- coding: utf-8 -*-\n\n\n\nimport sys\n\nfrom heapq import heappush, heappop\n\n\n\ndef input(): return sys.stdin.readline().strip()\n\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\n\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\n\ndef ceil(x, y=1): return int(-(-x // y))\n\ndef INT(): return int(eval(input()))\n\ndef MAP(): return list(map(int, input().split()))\n\ndef LIST(): return list(map(int, input().split()))\n\ndef Yes(): print('Yes')\n\ndef No(): print('No')\n\ndef YES(): print('YES')\n\ndef NO(): print('NO')\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = float('inf')\n\nMOD = 10 ** 9 + 7\n\n\n\nX,Y,Z,K=MAP()\n\nA=sorted(LIST(), reverse=True)\n\nB=sorted(LIST(), reverse=True)\n\nC=sorted(LIST(), reverse=True)\n\n\n\n\n\nque=[]\n\nheappush(que, (-(A[0]+B[0]+C[0]), 0, 0, 0))\n\nS={(0,0,0)}\n\nfor i in range(K):\n\n    ans=heappop(que)\n\n    print((-ans[0]))\n\n    a,b,c=ans[1:]\n\n    if a+1<X and (a+1,b,c) not in S:\n\n        heappush(que, (-(A[a+1]+B[b]+C[c]), a+1, b, c))\n\n        S.add((a+1,b,c))\n\n    if b+1<Y and (a,b+1,c) not in S:\n\n        heappush(que, (-(A[a]+B[b+1]+C[c]), a, b+1, c))\n\n        S.add((a,b+1,c))\n\n    if c+1<Z and (a,b,c+1) not in S:\n\n        heappush(que, (-(A[a]+B[b]+C[c+1]), a, b, c+1))\n\n        S.add((a,b,c+1))\n", "score": 1.0, "surface_similarity": 0.756696034377882}
{"id": "p02560_u216928054", "golden_code": "#!/usr/bin/env python3\n\nimport sys\n\nsys.setrecursionlimit(10**6)\n\nINF = 10 ** 9 + 1  # sys.maxsize # float(\"inf\")\n\nMOD = 10 ** 9 + 7\n\n\n\n\n\ndef floor_sum(n, m, a, b):\n\n    ret = 0\n\n    if a >= m:\n\n        ret += (n - 1) * n * (a // m) // 2\n\n        a %= m\n\n    if b >= m:\n\n        ret += n * (b // m)\n\n        b %= m\n\n    y_max = (a * n + b) // m\n\n    x_max = y_max * m - b\n\n    if y_max == 0:\n\n        return ret\n\n    ret += (n - (x_max + a - 1) // a) * y_max\n\n    ret += floor_sum(y_max, a, m, (a - x_max % a) % a)\n\n    return ret\n\n\n\n\n\ndef debug(*x):\n\n    print(*x, file=sys.stderr)\n\n\n\n\n\ndef solve(SOLVE_PARAMS):\n\n    pass\n\n\n\n\n\ndef main():\n\n    # parse input\n\n    T = int(input())\n\n    for _t in range(T):\n\n        N, M, A, B = map(int, input().split())\n\n        print(floor_sum(N, M, A, B))\n\n\n\n\n\n# tests\n\nT1 = \"\"\"\n\n5\n\n4 10 6 3\n\n6 5 4 3\n\n1 1 0 0\n\n31415 92653 58979 32384\n\n1000000000 1000000000 999999999 999999999\n\n\"\"\"\n\nTEST_T1 = \"\"\"\n\n>>> as_input(T1)\n\n>>> main()\n\n3\n\n13\n\n0\n\n314095480\n\n499999999500000000\n\n\"\"\"\n\n\n\n\n\ndef _test():\n\n    import doctest\n\n    doctest.testmod()\n\n    g = globals()\n\n    for k in sorted(g):\n\n        if k.startswith(\"TEST_\"):\n\n            doctest.run_docstring_examples(g[k], g, name=k)\n\n\n\n\n\ndef as_input(s):\n\n    \"use in test, use given string as input file\"\n\n    import io\n\n    f = io.StringIO(s.strip())\n\n    g = globals()\n\n    g[\"input\"] = lambda: bytes(f.readline(), \"ascii\")\n\n    g[\"read\"] = lambda: bytes(f.read(), \"ascii\")\n\n\n\n\n\ninput = sys.stdin.buffer.readline\n\nread = sys.stdin.buffer.read\n\n\n\nif sys.argv[-1] == \"-t\":\n\n    print(\"testing\")\n\n    _test()\n\n    sys.exit()\n\n\n\nmain()\n", "generated_code": "#!/usr/bin/env python3\n\nimport sys\n\nsys.setrecursionlimit(10**6)\n\nINF = 10 ** 9 + 1  # sys.maxsize # float(\"inf\")\n\nMOD = 10 ** 9 + 7\n\n\n\n\n\ndef floor_sum_1(n, m, a, b):\n\n    ret = 0\n\n    if a >= m:\n\n        ret += (n - 1) * n * (a // m) // 2\n\n        a %= m\n\n    if b >= m:\n\n        ret += n * (b // m)\n\n        b %= m\n\n    y_max = (a * n + b) // m\n\n    x_max = y_max * m - b\n\n    if y_max == 0:\n\n        return ret\n\n    ret += (n - (x_max + a - 1) // a) * y_max\n\n    ret += floor_sum(y_max, a, m, (a - x_max % a) % a)\n\n    return ret\n\n\n\n\n\ndef floor_sum(n, m, a, b):\n\n    ret = 0\n\n    while True:\n\n        if a >= m:\n\n            ret += (n - 1) * n * (a // m) // 2\n\n            a %= m\n\n        if b >= m:\n\n            ret += n * (b // m)\n\n            b %= m\n\n        y_max = (a * n + b) // m\n\n        x_max = y_max * m - b\n\n        if y_max == 0:\n\n            return ret\n\n        ret += (n - (x_max + a - 1) // a) * y_max\n\n        n = y_max\n\n        m, a, b = a, m, (a - x_max % a) % a\n\n\n\n\n\ndef debug(*x):\n\n    print(*x, file=sys.stderr)\n\n\n\n\n\ndef solve(SOLVE_PARAMS):\n\n    pass\n\n\n\n\n\ndef main():\n\n    # parse input\n\n    T = int(input())\n\n    for _t in range(T):\n\n        N, M, A, B = map(int, input().split())\n\n        print(floor_sum(N, M, A, B))\n\n\n\n\n\n# tests\n\nT1 = \"\"\"\n\n5\n\n4 10 6 3\n\n6 5 4 3\n\n1 1 0 0\n\n31415 92653 58979 32384\n\n1000000000 1000000000 999999999 999999999\n\n\"\"\"\n\nTEST_T1 = \"\"\"\n\n>>> as_input(T1)\n\n>>> main()\n\n3\n\n13\n\n0\n\n314095480\n\n499999999500000000\n\n\"\"\"\n\n\n\n\n\ndef _test():\n\n    import doctest\n\n    doctest.testmod()\n\n    g = globals()\n\n    for k in sorted(g):\n\n        if k.startswith(\"TEST_\"):\n\n            doctest.run_docstring_examples(g[k], g, name=k)\n\n\n\n\n\ndef as_input(s):\n\n    \"use in test, use given string as input file\"\n\n    import io\n\n    f = io.StringIO(s.strip())\n\n    g = globals()\n\n    g[\"input\"] = lambda: bytes(f.readline(), \"ascii\")\n\n    g[\"read\"] = lambda: bytes(f.read(), \"ascii\")\n\n\n\n\n\ninput = sys.stdin.buffer.readline\n\nread = sys.stdin.buffer.read\n\n\n\nif sys.argv[-1] == \"-t\":\n\n    print(\"testing\")\n\n    _test()\n\n    sys.exit()\n\n\n\nmain()\n", "score": 1.0, "surface_similarity": 0.93311509655067}
{"id": "p03060_u595289165", "golden_code": "import numpy as np\n\nn = int(eval(input()))\n\nvalue = np.array(tuple(map(int, input().split())))\n\ncost = np.array(tuple(map(int, input().split())))\n\nxy = value - cost\n\nans = 0\n\nfor i in range(n):\n\n    if xy[i] < 0:\n\n        continue\n\n    else:\n\n        ans += xy[i]\n\nprint(ans)", "generated_code": "n = int(eval(input()))\n\nvalue = tuple(map(int, input().split()))\n\ncost = tuple(map(int, input().split()))\n\n# iこめまでのxーyの最大値\n\ninf = -100\n\ndp = [inf] * (n+1)\n\ndp[1] = max(0, value[0]-cost[0])\n\nfor i in range(2, n+1):\n\n    dp[i] = max(dp[i-1], dp[i-1]+value[i-1]-cost[i-1])\n\n\n\nprint((dp[n]))\n", "score": 1.0, "surface_similarity": 0.5679754273504274}
{"id": "p02881_u442877951", "golden_code": "import math\n\nN = int(eval(input()))\n\nans = 10**12\n\nfor i in range(1,10**6+1):\n\n  j = math.ceil(N/(i+1))\n\n  if (1+i)*j == N:\n\n    ans = min(i+j-1,ans)\n\n  if i == 10**6 and ans == 10**12:\n\n    ans = N-1\n\n    break\n\nprint(ans)", "generated_code": "N = int(eval(input()))\n\nans = 10**12\n\nfor i in range(1,10**6+1):\n\n  j = N//i\n\n  if i*j == N:\n\n    ans = min(i+j-2,ans)\n\n  if i == 10**6 and ans == 10**12:\n\n    ans = N-1\n\n    break\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.8304932735426009}
{"id": "p03434_u951601135", "golden_code": "import numpy as np\n\nN = int(eval(input()))\n\nvalue = list(map(int,input().split()))\n\nvalue=np.sort(value)[::-1]\n\n#print(N,value)\n\na = np.sum(value[::2])\n\nb = np.sum(value[1::2])\n\nprint((a-b))", "generated_code": "n = int(eval(input()))\n\na = sorted(list(map(int, input().split())), reverse=True)\n\nprint((sum(a[::2]) - sum(a[1::2])))\n", "score": 1.0, "surface_similarity": 0.6584795321637427}
{"id": "p02758_u864197622", "golden_code": "mod = 998244353\n\nN = int(eval(input()))\n\nX = []\n\nfor _ in range(N):\n\n    x, d = list(map(int, input().split()))\n\n    X.append((x, x + d))\n\n\n\nX = sorted(X, key = lambda x: x[0])\n\nL = [(0, -(10**9+1), 10**9+1)]\n\nP = [-1] * (N+1)\n\nfor i, (x, y) in enumerate(X):\n\n    while L[-1][2] <= y:\n\n        if L[-1][2] > x and P[i+1] < 0:\n\n            P[i+1] = L[-1][0]\n\n        L.pop()\n\n    if P[i+1] < 0:\n\n        P[i+1] = L[-1][0]\n\n    L.append((i+1, x, y))\n\n\n\nC = [[] for _ in range(N+1)]\n\nfor i, p in enumerate(P):\n\n    if p >= 0:\n\n        C[p].append(i)\n\n\n\nY = [1] * (N+1)\n\nfor i in range(N+1)[::-1]:\n\n    s = 1\n\n    for j in C[i]:\n\n        s = s * (Y[j] + 1) % mod\n\n    Y[i] = s\n\n\n\nprint((Y[0]))", "generated_code": "import sys\n\ninput = sys.stdin.readline\n\n\n\nmod = 998244353\n\nN = int(eval(input()))\n\nX = []\n\nfor _ in range(N):\n\n    x, d = list(map(int, input().split()))\n\n    X.append((x, x + d))\n\n\n\nX = sorted(X, key = lambda x: x[0])\n\nL = [(0, -(10**9+1), 10**9+1)]\n\nP = [-1] * (N+1)\n\nfor i, (x, y) in enumerate(X):\n\n    while L[-1][2] <= y:\n\n        if L[-1][2] > x and P[i+1] < 0:\n\n            P[i+1] = L[-1][0]\n\n        L.pop()\n\n    if P[i+1] < 0:\n\n        P[i+1] = L[-1][0]\n\n    L.append((i+1, x, y))\n\n\n\nC = [[] for _ in range(N+1)]\n\nfor i, p in enumerate(P):\n\n    if p >= 0:\n\n        C[p].append(i)\n\n\n\nY = [1] * (N+1)\n\nfor i in range(N+1)[::-1]:\n\n    s = 1\n\n    for j in C[i]:\n\n        s = s * (Y[j] + 1) % mod\n\n    Y[i] = s\n\n\n\nprint((Y[0]))", "score": 1.0, "surface_similarity": 0.9504191658774421}
{"id": "p02622_u539692012", "golden_code": "print((sum(si != ti for si, ti in zip(eval(input()), eval(input())))))\n", "generated_code": "print((sum(a!=b for a,b in zip(*open(0)))))", "score": 1.0, "surface_similarity": 0.7118093174431203}
{"id": "p02994_u739959951", "golden_code": "n,a=list(map(int,input().split()))\n\n\n\nl=[a+i-1 for i in range(1,n+1)]\n\n\n\nimport numpy as np\n\nb=min(np.abs(l))\n\n\n\nif b==0:\n\n  l.remove(0)\n\nelif b in l:\n\n  l.remove(b)\n\nelif -b in l:\n\n  l.remove(-b)\n\n  \n\nprint((sum(l)))", "generated_code": "n,a=list(map(int,input().split()))\n\n\n\napples=[a+i for i in range(n)]\n\neat=min(apples,key=lambda x:abs(x))\n\nres=sum(apples)-eat\n\n\n\nprint(res)", "score": 1.0, "surface_similarity": 0.5311486601809182}
{"id": "p02767_u540631540", "golden_code": "n = int(eval(input()))\n\nx = [int(i) for i in input().split()]\n\np = 10000000\n\nfor i in range(100):\n\n    pi = 0\n\n    for j in range(n):\n\n        pi += (x[j] - (i + 1))**2\n\n    if pi < p:\n\n        p = pi\n\n    # else:\n\n    #     break\n\n        # p[i] += (x[j]-(i+1))**2\n\nprint(p)", "generated_code": "n = int(eval(input()))\n\nx = [int(i) for i in input().split()]\n\np = 10000000\n\nfor i in range(100):\n\n    pi = 0\n\n    for j in range(n):\n\n        pi += (x[j] - (i + 1))**2\n\n    if pi < p:\n\n        p = pi\n\n    else:\n\n        break\n\n        # p[i] += (x[j]-(i+1))**2\n\nprint(p)", "score": 1.0, "surface_similarity": 0.9564426877470356}
{"id": "p03575_u994988729", "golden_code": "from scipy.sparse.csgraph import floyd_warshall\n\nimport numpy as np\n\nimport sys\n\n\n\ninput = sys.stdin.readline\n\n\n\nN, M = list(map(int, input().split()))\n\nAB = []\n\nedge = np.zeros((N, N), dtype=int)\n\nfor _ in range(M):\n\n    a, b = list(map(int, input().split()))\n\n    a -= 1\n\n    b -= 1\n\n    AB.append((a, b))\n\n    edge[a][b] = 1\n\n    edge[b][a] = 1\n\n\n\nans = 0\n\nfor i in range(M):\n\n    graph = np.copy(edge)\n\n    a, b = AB[i]\n\n    graph[a][b] = 0\n\n    graph[b][a] = 0\n\n    fw = floyd_warshall(graph)\n\n    if fw.max() > 10000:\n\n        ans += 1\n\n\n\nprint(ans)\n", "generated_code": "import sys\n\ninput = sys.stdin.buffer.readline\n\nsys.setrecursionlimit(10 ** 7)\n\n\n\n\n\nclass UF_tree:\n\n    def __init__(self, n):\n\n        self.root = [-1] * (n + 1)  # -1ならそのノードが根,で絶対値が木の要素数\n\n        self.rank = [0] * (n + 1)\n\n\n\n    def find(self, x):  # xの根となる要素番号を返す\n\n        if self.root[x] < 0:\n\n            return x\n\n        else:\n\n            self.root[x] = self.find(self.root[x])\n\n            return self.root[x]\n\n\n\n    def isSame(self, x, y):\n\n        return self.find(x) == self.find(y)\n\n\n\n    def unite(self, x, y):\n\n        x = self.find(x)\n\n        y = self.find(y)\n\n        if x == y:\n\n            return\n\n        elif self.rank[x] < self.rank[y]:\n\n            self.root[y] += self.root[x]\n\n            self.root[x] = y\n\n        else:\n\n            self.root[x] += self.root[y]\n\n            self.root[y] = x\n\n            if self.rank[x] == self.rank[y]:\n\n                self.rank[x] += 1\n\n\n\n    def getNodeLen(self, x):\n\n        return -self.root[self.find(x)]\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    N, M = list(map(int, input().split()))\n\n    AB = tuple(tuple(map(int, input().split())) for _ in range(M))\n\n\n\n    ans = 0\n\n    for i in range(M):\n\n        uf = UF_tree(N)\n\n        for j, (a, b) in enumerate(AB):\n\n            if i == j:\n\n                continue\n\n            uf.unite(a, b)\n\n        a, b = AB[i]\n\n        if not uf.isSame(a, b):\n\n            ans += 1\n\n    print(ans)", "score": 1.0, "surface_similarity": 0.5088066139468008}
{"id": "p03680_u314837274", "golden_code": "N=int(eval(input()))\n\n\n\n\n\na = []\n\n\n\nfor i in range(N):\n\n    a.append(int(eval(input())))\n\n# a=[0]*N\n\n# for i in range(N):\n\n#   a[i]=int(input())\n\ncount=0\n\n\n\n#loopの定義→同じインデックスを使用したらloop判定\n\n#in の処理を爆速で実行するためにsetを使用する\n\n#loop=[]\n\nloop=set()\n\n\n\ntmp=1\n\nwhile True:  \n\n  tmp=a[tmp-1]\n\n  count+=1\n\n  if tmp==2:\n\n    print(count)\n\n    exit()\n\n  if tmp-1 in loop:\n\n    print((-1))\n\n    exit()\n\n  #loop.append(tmp-1)\n\n  loop.add(tmp-1)", "generated_code": "N=int(eval(input()))\n\n#複数行の入力を高速化\n\n#a=[0]*N\n\n#for i in range(N):\n\n#  a[i]=int(input())\n\nimport sys\n\na=[int(i) for i in sys.stdin]\n\n\n\ncount=0\n\n\n\n#loopの定義→同じインデックスを使用したらloop判定\n\n#in の処理を爆速で実行するためにsetを使用する\n\n#loop=[]\n\nloop=set()\n\n\n\ntmp=1\n\nwhile True:  \n\n  tmp=a[tmp-1]\n\n  count+=1\n\n  if tmp==2:\n\n    print(count)\n\n    exit()\n\n  if tmp-1 in loop:\n\n    print((-1))\n\n    exit()\n\n  #loop.append(tmp-1)\n\n  loop.add(tmp-1)", "score": 1.0, "surface_similarity": 0.8445080862533693}
{"id": "p03494_u867069435", "golden_code": "import numpy as np\n\nn = int(eval(input()))\n\nballs = np.array(list(map(int, input().split())))\n\ntime = 0\n\nwhile np.all(balls % 2 == 0) and np.all(balls > 0):\n\n    time += 1\n\n    balls = balls / 2\n\nprint(time)", "generated_code": "import math\n\nn = eval(input())\n\na = list(map(int, input().split()))\n\nans = float(\"inf\")\n\nfor i in a:\n\n    ans = min(ans, len(bin(i)) - bin(i).rfind(\"1\") - 1)\n\nprint((round(ans)))", "score": 1.0, "surface_similarity": 0.49879227053140096}
{"id": "p03608_u316386814", "golden_code": "n, m, r = list(map(int, input().split()))\n\nrs = list(map(int, input().split()))\n\n# construct map\n\nimport numpy as np\n\ndists = np.ones((n + 1, n + 1)) * float('inf')\n\nfor _ in range(m):\n\n    a, b, c = list(map(int, input().split()))\n\n    dists[a, b] = dists[b, a] = c\n\nfor i in range(1, n + 1):\n\n    dists[i, i] = 0\n\n\n\nfrom itertools import product, permutations\n\nfor i, j in product(list(range(1, 1 + n)), repeat=2):\n\n    dists[j] = np.minimum(dists[j], dists[i] + dists[j, i])\n\n\n\nans = float('inf')\n\nfor path in permutations(rs):\n\n    val = sum(dists[i, j] for i, j in zip(path, path[1:]))\n\n    val = int(val)\n\n    if val < ans:\n\n        ans = val\n\n\n\nprint(ans)", "generated_code": "n, m, r = list(map(int, input().split()))\n\nrs = list(map(int, input().split()))\n\n# construct map\n\nimport numpy as np\n\ndists = np.ones((n + 1, n + 1)) * float('inf')\n\nfor _ in range(m):\n\n    a, b, c = list(map(int, input().split()))\n\n    dists[a, b] = dists[b, a] = c\n\nfor i in range(1, n + 1):\n\n    dists[i, i] = 0\n\n\n\nfrom itertools import permutations\n\nfor i in range(1, 1 + n):\n\n    dists = np.minimum(dists, dists[i: i + 1] + dists[:, i: i + 1])\n\n\n\nans = float('inf')\n\nfor path in permutations(rs):\n\n    val = sum(dists[i, j] for i, j in zip(path, path[1:]))\n\n    val = int(val)\n\n    if val < ans:\n\n        ans = val\n\n\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.9259538995188542}
{"id": "p02792_u297574184", "golden_code": "def solve():\n\n    N = int(eval(input()))\n\n\n\n    numss = [[0]*(10) for _ in range(10)]\n\n    for x in range(1, 10):\n\n        for y in range(1, 10):\n\n            num = 0\n\n            for d in range(1, 5):\n\n                for i in range(10**d):\n\n                    j = x*10**(d+1) + i*10 + y\n\n                    if 1 <= j <= N:\n\n                        num += 1\n\n                    else:\n\n                        break\n\n            j = x*10 + y\n\n            if 1 <= j <= N:\n\n                num += 1\n\n            if x == y:\n\n                j = x\n\n                if 1 <= j <= N:\n\n                    num += 1\n\n            numss[x][y] = num\n\n\n\n    ans = 0\n\n    for A in range(1, N+1):\n\n        ss = str(A)\n\n        ans += numss[int(ss[-1])][int(ss[0])]\n\n\n\n    print(ans)\n\n\n\n\n\nsolve()\n", "generated_code": "def solve():\n\n    strN = eval(input())\n\n    N = int(strN)\n\n\n\n    maxD = len(strN)\n\n\n\n    numss = [[0]*(10) for _ in range(10)]\n\n    for x in range(1, 10):\n\n        for y in range(1, 10):\n\n            num = 0\n\n            for d in range(1, maxD-2):\n\n                num += 10**d\n\n            if maxD-2 > 0:\n\n                if x < int(strN[0]):\n\n                    num += 10**(maxD-2)\n\n                elif x == int(strN[0]):\n\n                    num += int(strN[1:-1]) + 1\n\n                    if y > int(strN[-1]):\n\n                        num -= 1\n\n            j = x*10 + y\n\n            if 1 <= j <= N:\n\n                num += 1\n\n            if x == y:\n\n                j = x\n\n                if 1 <= j <= N:\n\n                    num += 1\n\n            numss[x][y] = num\n\n\n\n    ans = 0\n\n    for i in range(1, 10):\n\n        for j in range(1, 10):\n\n            ans += numss[i][j]*numss[j][i]\n\n\n\n    print(ans)\n\n\n\n\n\nsolve()\n", "score": 1.0, "surface_similarity": 0.82653372156013}
{"id": "p03086_u777923818", "golden_code": "# -*- coding: utf-8 -*-\n\nfrom collections import deque\n\ndef inpl(): return list(map(int, input().split()))\n\n\n\nS = eval(input())\n\nA = set(\"ATCG\")\n\nans = 0\n\nmode = 0\n\nfor i, s in enumerate(S):\n\n    if s in A:\n\n        if mode == 0:\n\n            mode = 1\n\n            start = i\n\n    else:\n\n        if mode == 1:\n\n            ans = max(i - start, ans)\n\n            mode = 0\n\nif mode == 1:\n\n    ans = max(len(S) - start, ans)\n\nprint(ans)", "generated_code": "def inpl(): return list(map(int, input().split()))\n\nS = eval(input())\n\nC = set(\"ACGT\")\n\n\n\ntmp = 0\n\nans = 0\n\n\n\nfor s in S:\n\n    if s in C:\n\n        tmp += 1\n\n    else:\n\n        ans = max(ans, tmp)\n\n        tmp = 0\n\nans = max(ans, tmp)\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.6944444444444444}
{"id": "p02574_u678167152", "golden_code": "import numpy as np\n\nimport numba\n\nfrom numba import njit, b1, i4, i8, f8\n\n\n\n@njit((i8, i8[:]), cache=True)\n\ndef main(N,A):\n\n  Amax = np.max(A)\n\n  lis = np.zeros(Amax+1, np.int64)\n\n  for i in range(N):\n\n    lis[A[i]] += 1\n\n  setwise = False\n\n  for t in range(2,Amax+1):\n\n    cnt = np.sum(lis[t:Amax+1:t])\n\n    if cnt==N:\n\n      return 'not'\n\n    if 2<=cnt<N:\n\n      setwise=True\n\n  if setwise==True:\n\n    return 'setwise'\n\n  return 'pairwise'\n\n\n\nN = int(eval(input()))\n\nA = np.array(list(map(int, input().split())))\n\nprint((main(N,A)+' coprime'))\n\n\n", "generated_code": "def sieve(n):\n\n  is_prime = [True for _ in range(n+1)]\n\n  is_prime[0] = False\n\n  for i in range(2, n+1):\n\n    if is_prime[i-1]:\n\n      j = 2 * i\n\n      while j <= n:\n\n        is_prime[j-1] = False\n\n        j += i\n\n  table = [i for i in range(1, n+1) if is_prime[i-1]]\n\n  return table\n\n\n\nN = int(eval(input()))\n\nA = list(map(int, input().split()))\n\nAmax = max(A)\n\nlis = [0]*(Amax+1)\n\nfor i in range(N):\n\n  lis[A[i]] += 1\n\ntable = sieve(Amax)\n\nsetwise = False\n\nfor t in table:\n\n  cnt = sum(lis[t:Amax+1:t])\n\n  if cnt==N:\n\n    print('not coprime')\n\n    break\n\n  if 2<=cnt<N:\n\n    setwise=True\n\nelse:\n\n  if setwise==True:\n\n    print('setwise coprime')\n\n  else:\n\n    print('pairwise coprime')\n", "score": 1.0, "surface_similarity": 0.5645820238843495}
{"id": "p02952_u854690176", "golden_code": "N = int(eval(input()))\n\nans = 0\n\nfor i in range(1, N + 1):\n\n    if len(str(i)) % 2 == 1:\n\n        ans += 1\n\nprint(ans)", "generated_code": "N = int(eval(input()))\n\nprint((len(list([x for x in range(1, N + 1) if len(str(x)) % 2 == 1]))))", "score": 1.0, "surface_similarity": 0.7000941619585688}
{"id": "p03353_u282228874", "golden_code": "S = eval(input())\n\nk = int(eval(input()))\n\nA = set()\n\nfor l in range(k+1):\n\n\tfor i in range(len(S)-l):\n\n\t\t\tA.add(S[i:i+l+1])\n\nA = sorted(list(A))\n\nprint((A[k-1]))", "generated_code": "S = eval(input())\n\nl = len(S)\n\nd = set()\n\nK = int(eval(input()))\n\nfor i in range(5):\n\n    for j in range(l-i):\n\n        d.add(S[j:j+i+1])\n\nD = sorted(list(d))\n\nprint((D[K-1]))", "score": 1.0, "surface_similarity": 0.8714285714285714}
{"id": "p02693_u047796752", "golden_code": "import sys\n\ninput = sys.stdin.readline\n\nfrom collections import *\n\n\n\nK = int(eval(input()))\n\nA, B = list(map(int, input().split()))\n\n\n\nfor i in range(A, B+1):\n\n    if i%K==0:\n\n        print('OK')\n\n        exit()\n\n    \n\nprint('NG')", "generated_code": "K = int(eval(input()))\n\nA, B = list(map(int, input().split()))\n\n\n\nif (A-1)//K!=B//K:\n\n    print('OK')\n\nelse:\n\n    print('NG')", "score": 1.0, "surface_similarity": 0.5956521739130434}
{"id": "p03162_u829203929", "golden_code": "# coding: utf-8\n\nimport numpy as np\n\n\n\nn = int(eval(input()))\n\ndp = np.zeros((n+10, 3))\n\n\n\ndef cmax(a,b):\n\n    if a>b:\n\n        return a\n\n    else: \n\n        return b\n\n        \n\nfor i in range(1, n+1):\n\n    a, b, c = list(map(int, input().split()))\n\n    # a\n\n    dp[i][0] = cmax(dp[i-1][1]+a, dp[i-1][2]+a)\n\n    # b\n\n    dp[i][1] = cmax(dp[i-1][0]+b, dp[i-1][2]+b)\n\n    # c\n\n    dp[i][2] = cmax(dp[i-1][0]+c, dp[i-1][1]+c)\n\n\n\nprint((int(max(dp[i,:]))))", "generated_code": "# coding: utf-8\n\n# Your code here!\n\n\n\n\n\nN = int(eval(input()))\n\n\n\ndp = [[0]*3 for _ in range(N+1)]\n\n\n\nfor i in range(1, N+1):\n\n    a, b, c = list(map(int, input().split()))\n\n    dp[i][0] = max(dp[i-1][1], dp[i-1][2]) + a\n\n    dp[i][1] = max(dp[i-1][0], dp[i-1][2]) + b\n\n    dp[i][2] = max(dp[i-1][0], dp[i-1][1]) + c\n\n    \n\nprint((max(dp[N])))", "score": 1.0, "surface_similarity": 0.6518698258635456}
{"id": "p03060_u762420987", "golden_code": "import numpy as np\n\nN = int(eval(input()))\n\nVlist = np.array(list(map(int,input().split())))\n\nClist = np.array(list(map(int,input().split())))\n\n\n\nDlist = Vlist-Clist\n\n\n\nsum_ = 0\n\nfor d in Dlist:\n\n    if d >= 0:\n\n        sum_ += d\n\n\n\nprint(sum_)\n", "generated_code": "# 入力\n\nN = int(eval(input()))\n\nVlist = list(map(int, input().split()))\n\nClist = list(map(int, input().split()))\n\n\n\nans = 0\n\nfor i in range(N):\n\n    Z = Vlist[i] - Clist[i]\n\n    if Z > 0:\n\n        ans += Z\n\n\n\nprint(ans)\n", "score": 1.0, "surface_similarity": 0.6983302411873841}
{"id": "p02780_u506858457", "golden_code": "import numpy as np\n\nN,K=list(map(int,input().split()))\n\nP=list(map(int,input().split()))\n\nQ=[0]\n\ndef ex(A):\n\n  return (1+A)/2.0\n\nfor i in range(N):\n\n  Q.append(ex(P[i]))\n\nQ=np.array(Q)\n\nR=Q.cumsum()\n\nans=0\n\nfor i in range(K,N+1):\n\n  S=R[i]-R[i-K]\n\n  if ans<S:\n\n    ans=S\n\nprint(ans)", "generated_code": "#ika tako\n\nn, k = list(map(int, input().split()))\n\nppp = list(map(int, input().split()))\n\ntot = sum(ppp[:k])#まず、先頭K個の合計を求める\n\nans = tot#仮の答としておく\n\nfor i in range(k, n):#for文で0-indexでk+1番目から最後までチェック\n\n    tot += ppp[i] - ppp[i - k]#新しくi番目を足して、一番古いものを引く\n\n    ans = max(ans, tot)#新しい答が大きいなら更新する\n\nprint(((ans + k) / 2))#K個分のサイコロの期待値を出力する", "score": 1.0, "surface_similarity": 0.5764367816091953}
{"id": "p03806_u754022296", "golden_code": "n, ma, mb = list(map(int, input().split()))\n\nU = 400\n\ndp = [[[float(\"inf\")]*(U+1) for _ in range(U+1)] for i in range(n+1)]\n\ndp[0][0][0] = 0\n\nfor i in range(n):\n\n  a, b, c = list(map(int, input().split()))\n\n  for j in range(U+1):\n\n    for k in range(U+1):\n\n      if j<a or k<b:\n\n        dp[i+1][j][k] = dp[i][j][k]\n\n      else:\n\n        dp[i+1][j][k] = min(dp[i][j][k], dp[i][j-a][k-b]+c)\n\nans = float(\"inf\")\n\nfor i in range(1, 1+U//max(ma, mb)):\n\n  na, nb = i*ma, i*mb\n\n  ans = min(ans, dp[-1][na][nb])\n\nif ans == float(\"inf\"):\n\n  print((-1))\n\nelse:\n\n  print(ans)", "generated_code": "import numpy as np\n\n\n\nn, ma, mb = list(map(int, input().split()))\n\nU = 400\n\ndp = np.full((U+1, U+1), float(\"inf\"))\n\ndp[0, 0] = 0\n\nfor i in range(n):\n\n  a, b, c = list(map(int, input().split()))\n\n  np.minimum(dp[a:, b:], dp[:-a, :-b]+c, out=dp[a:, b:])\n\nans = float(\"inf\")\n\nfor i in range(1, 1+U//max(ma, mb)):\n\n  na, nb = i*ma, i*mb\n\n  ans = min(ans, dp[na, nb])\n\nif ans == float(\"inf\"):\n\n  print((-1))\n\nelse:\n\n  print((int(ans)))", "score": 1.0, "surface_similarity": 0.6604088443888194}
{"id": "p02767_u130900604", "golden_code": "n,*x=list(map(int,open(0).read().split()))\n\n\n\nimport numpy as np\n\n\n\nxar=np.array(x)\n\n\n\nans=float(\"inf\")\n\nfor p in range(0,101):\n\n    tmp=sum((xar-p)**2)\n\n    ans=min(ans,tmp)\n\n    \n\nprint((int(ans)))", "generated_code": "n,*x=list(map(int,open(0).read().split()))\n\nans=float(\"inf\")\n\nfor p in range(0,101):\n\n  s=0\n\n  for xi in x:\n\n    s+=(xi-p)**2\n\n  ans=min(ans,s)\n\nprint((int(ans)))\n", "score": 1.0, "surface_similarity": 0.7565458873313938}
{"id": "p03164_u497046426", "golden_code": "import numpy as np\n\n\n\nN, W = list(map(int, input().split()))\n\nitems = []\n\nfor _ in range(N):\n\n    items.append(tuple(map(int, input().split())))\n\nv_max = sum([i[1] for i in items])\n\nINF = 10**12\n\ndp = np.array([[INF for j in range(v_max+1)] for _ in range(N+1)])\n\ndp[0, 0] = 0\n\nfor i in range(1, N+1):\n\n    w, v = items[i-1]\n\n    dp[i, :v] = dp[i-1, :v]\n\n    dp[i, v:] = np.minimum(dp[i-1, :-v] + w, dp[i-1, v:])\n\nans = 0\n\nfor v in range(v_max, -1, -1):\n\n    if dp[N][v] <= W:\n\n        ans = v\n\n        break\n\nprint(ans)", "generated_code": "N, W = list(map(int, input().split()))\n\nitems = []\n\nINF = 10**12\n\nfor _ in range(N):\n\n    items.append(tuple(map(int, input().split())))\n\nMAX_V = sum([v for _, v in items])\n\ndp = [[INF for j in range(MAX_V+1)] for i in range(N+1)]\n\ndp[0][0] = 0\n\nfor i in range(1, N+1):\n\n    w, v = items[i-1]\n\n    for j in range(MAX_V+1):\n\n        if j - v >= 0:\n\n            dp[i][j] = min(dp[i-1][j-v] + w, dp[i-1][j])\n\n        else:\n\n            dp[i][j] = dp[i-1][j]\n\nfor v in range(MAX_V, -1, -1):\n\n    if dp[N][v] <= W:\n\n        break\n\nprint(v)", "score": 1.0, "surface_similarity": 0.7807780596834601}
{"id": "p02850_u372144784", "golden_code": "import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\nN = int(readline())\n\nAB = [list(map(int,readline().split())) for i in range(N-1)]\n\n\n\ngraph = [[] for _ in range(N+1)] #隣接リスト\n\nfor a,b in AB:\n\n    graph[a].append(b)\n\n    graph[b].append(a)\n\n\n\n#親のノードに子を入れてくdfs\n\nstack = [1]\n\nparent = [0]*(N+1)\n\norder = []\n\nwhile stack:\n\n    x = stack.pop()\n\n    order.append(x)\n\n    for i in graph[x]:\n\n        if i == parent[x]:\n\n            continue\n\n        parent[i] = x\n\n        stack.append(i)\n\n\n\n#各子の色を決めていく。\n\ncolor = [-1]*(N+1)\n\nfor x in order:\n\n    ng = color[x]\n\n    c = 1\n\n    for y in graph[x]:\n\n        if parent[x] == y:\n\n            continue\n\n        if c == ng:\n\n            c += 1\n\n        color[y] = c\n\n        c += 1\n\n\n\nans = []\n\nfor a,b in AB:\n\n    if parent[a] == b: #子の頂点の色を入れる\n\n        ans.append(color[a])\n\n    else:\n\n        ans.append(color[b])\n\n\n\nprint((max(ans)))\n\nfor i in ans:\n\n    print(i)\n\n        \n", "generated_code": "import sys\n\nfrom collections import deque\n\nreadline = sys.stdin.buffer.readline\n\ndef even(n): return 1 if n%2==0 else 0\n\nn = int(readline())\n\ng = [[] for _ in range(n)] #隣接リスト\n\nab = []\n\nfor i in range(n-1):\n\n    a,b = list(map(int,readline().split()))\n\n    a,b = a-1,b-1\n\n    ab.append((a,b))\n\n    g[a].append(b)\n\n    g[b].append(a)\n\n\n\nroot = 0\n\nparent = [0]*n\n\ndeq = deque([root])\n\norder = [root]\n\n\n\ncolor = [-1]*n\n\ndeq = deque([root])\n\nwhile deq:\n\n    fr = deq.pop()\n\n    ng = color[fr]\n\n    c = 0\n\n    for go in g[fr]:\n\n        if go == parent[fr]:\n\n            continue\n\n        if c == ng:\n\n            c += 1\n\n        parent[go] = fr\n\n        color[go] = c\n\n        c += 1\n\n        deq.append(go)\n\n        order.append(go)\n\nrank = [0]*n\n\nfor i,j in enumerate(order):\n\n    rank[j] = i\n\nprint((max(color)+1))\n\nfor a,b in ab:\n\n    if rank[a] < rank[b]:\n\n        print((color[b]+1))\n\n    else:\n\n        print((color[a]+1))", "score": 1.0, "surface_similarity": 0.6708789740849586}
{"id": "p03575_u094191970", "golden_code": "from copy import deepcopy\n\nfrom scipy.sparse.csgraph import floyd_warshall\n\n\n\nn,m=list(map(int,input().split()))\n\nl=[list(map(int,input().split())) for i in range(m)]\n\n\n\ncnt=0\n\nfor i in range(m):\n\n  ll=deepcopy(l)\n\n  del ll[i]\n\n\n\n  d=[[float('inf')]*n for i in range(n)]\n\n  for i in range(n):\n\n    d[i][i]=0\n\n\n\n  for a,b in ll:\n\n    a-=1\n\n    b-=1\n\n    d[a][b]=1\n\n    d[b][a]=1\n\n\n\n  s=floyd_warshall(d)\n\n  for i in s:\n\n    if float('inf') in i:\n\n      cnt+=1\n\n      break\n\n\n\nprint(cnt)", "generated_code": "from collections import deque\n\nfrom copy import deepcopy\n\n\n\nn,m=list(map(int,input().split()))\n\nl=[list(map(int,input().split())) for i in range(m)]\n\n\n\ndef BFS(m):\n\n  t_l=deepcopy(l)\n\n  del t_l[m]\n\n\n\n  tree=[[] for j in range(n)]\n\n  for a,b in t_l:\n\n    a-=1\n\n    b-=1\n\n    tree[a].append(b)\n\n    tree[b].append(a)\n\n\n\n  dist=[-1 for i in range(n)]\n\n  dist[0]=0\n\n\n\n  que=deque()\n\n  que.append(0)\n\n\n\n  while que:\n\n    x=que.popleft()\n\n    for i in tree[x]:\n\n      if dist[i]==-1:\n\n        que.append(i)\n\n        dist[i]=dist[x]+1\n\n\n\n  return dist\n\n\n\nans=0\n\nfor i in range(m):\n\n  d=BFS(i)\n\n  if -1 in d:\n\n    ans+=1\n\n\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.637229082117261}
{"id": "p03013_u104442591", "golden_code": "n, m = list(map(int, input().split()))\n\na = []\n\nfor i in range(m):\n\n  a.append(int(eval(input())))\n\nans = 0\n\nflag = 0\n\na = set(a)\n\n\n\n#フィボナッチ数列の初期値を調節\n\ndp = [0] * (n+1)\n\ndp[0] = 1\n\nif 1 in a:\n\n  dp[1] = 0\n\nelse:\n\n  dp[1] = 1\n\n  \n\nfor i in range(2, n+1):\n\n  if dp[i-2] == 0 and dp[i-1] == 0:\n\n    ans = 0\n\n    flag = 1\n\n    break\n\n  elif i in a:\n\n    continue\n\n  else:\n\n    dp[i] = dp[i-1] + dp[i-2]\n\nif flag == 0:\n\n  ans = dp[n]\n\nprint((ans%(10**9+7)))", "generated_code": "n, m = list(map(int, input().split()))\n\na = []\n\nfor i in range(m):\n\n  a.append(int(eval(input())))\n\nans = 0\n\nflag = 0\n\na = set(a)\n\n\n\n#フィボナッチ数列の初期値を調節\n\ndp = [0] * (n+1)\n\ndp[0] = 1\n\nif 1 in a:\n\n  dp[1] = 0\n\nelse:\n\n  dp[1] = 1\n\n  \n\nfor i in range(2, n+1):\n\n  if dp[i-2] == 0 and dp[i-1] == 0:\n\n    ans = 0\n\n    flag = 1\n\n    break\n\n  elif i in a:\n\n    continue\n\n  else:\n\n    dp[i] = dp[i-1] + dp[i-2]\n\n    dp[i] = dp[i] % (10**9+7)\n\nif flag == 0:\n\n  ans = dp[n]\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.9638297872340426}
{"id": "p02780_u325956328", "golden_code": "import numpy as np\n\n\n\nN, K = list(map(int, input().split()))\n\np = np.array(list(map(int, input().split())))\n\n\n\ns = np.cumsum(p)\n\n# print(p, s)\n\n\n\nm = []\n\n\n\n\n\ndef partsum(s, x):\n\n    global K\n\n    if x == K - 1:\n\n        return s[x]\n\n    return s[x] - s[x - K]\n\n\n\n\n\nfor i in range(K - 1, N):\n\n    m.append(partsum(s, i))\n\n# print(m)\n\n\n\nidx = m.index(max(m))\n\n# print(idx)\n\n\n\nans = 0\n\nfor j in range(idx, idx + K):\n\n    ans += (p[j] + 1) / 2\n\nprint(ans)\n", "generated_code": "from collections import deque\n\n\n\nN, K = list(map(int, input().split()))\n\np = list(map(int, input().split()))\n\n\n\nmx = 0\n\ns = 0\n\nq = deque()\n\n\n\nfor i in range(N):\n\n    p[i] += 1\n\n\n\nfor i in range(N):\n\n    s += p[i]\n\n    q.append(p[i])\n\n    if len(q) > K:\n\n        s -= q.popleft()\n\n    if len(q) == K:\n\n        mx = max(mx, s)\n\n\n\nprint((mx / 2))\n\n\n", "score": 1.0, "surface_similarity": 0.6557236654296318}
{"id": "p03126_u263188345", "golden_code": "import numpy as np\n\n\n\nN, M = list(map(int, input().split()))\n\n\n\nlike_total = np.zeros(M)\n\ncnt = 0\n\nfor _ in range(N):\n\n    l = [v for v in map(int, input().split())]\n\n    #print(l)\n\n    for i in range(1, l[0]+1, 1):\n\n        like_total[l[i]-1] += 1\n\n\n\n#print(like_total, N)\n\n#print(like_total[4], like_total[9], like_total[-1])\n\nans = len(np.where(like_total==N)[0])\n\n\n\nprint(ans)\n", "generated_code": "N, M = list(map(int, input().split()))\n\n\n\nlike_total = [0]*M\n\ncnt = 0\n\nfor _ in range(N):\n\n    l = list(map(int, input().split()))\n\n    for i in range(1, l[0]+1, 1):\n\n        like_total[l[i]-1] += 1\n\n\n\nfor v in like_total:\n\n    cnt += v==N\n\nprint(cnt)\n", "score": 1.0, "surface_similarity": 0.796010498687664}
{"id": "p03200_u600402037", "golden_code": "import sys\n\nimport numpy as np\n\n\n\nstdin = sys.stdin\n\n \n\nri = lambda: int(rs())\n\nrl = lambda: list(map(int, stdin.readline().split()))\n\nrs = lambda: stdin.readline().rstrip()  # ignore trailing spaces\n\n\n\nS = list(rs())\n\nW = [0] * len(S)\n\nfor i in range(len(S)):\n\n    if S[i] == 'W':\n\n        W[i] = 1\n\nW = np.array(W[::-1])\n\nW_cum = W.cumsum()[::-1]\n\nW_cum = W_cum.tolist()\n\nanswer = 0\n\nfor i in range(len(S)):\n\n    if S[i] == 'B':\n\n        answer += W_cum[i]\n\n\n\nprint(answer)", "generated_code": "import sys\n\nimport numpy as np\n\n\n\nstdin = sys.stdin\n\n \n\nri = lambda: int(rs())\n\nrl = lambda: list(map(int, stdin.readline().split()))\n\nrs = lambda: stdin.readline().rstrip()  # ignore trailing spaces\n\n\n\nS = list(rs())\n\ncnt_B = 0\n\nanswer = 0\n\nfor s in S:\n\n    if s == 'B':\n\n        cnt_B += 1\n\n    else:\n\n        answer += cnt_B\n\nprint(answer)\n", "score": 1.0, "surface_similarity": 0.7002729044834308}
{"id": "p03126_u712975113", "golden_code": "import numpy as np\n\nN,M=list(map(int,input().split()))\n\nA=np.zeros((N+1,M+1))\n\nA[0]=np.ones(M+1)\n\nfor i in range(1,N+1):\n\n    B=list(map(int,input().split()))\n\n    for m in range(1,B[0]+1):\n\n        A[i][B[m]]=A[i-1][B[m]]\n\na=sum(A[N])\n\nprint((int(a)))", "generated_code": "N,M=list(map(int,input().split()))\n\nA = [[1 for _ in range(M)]]+[[0 for _ in range(M)] for _ in range(N)]\n\nfor i in range(1,N+1):\n\n    B=list(map(int,input().split()))\n\n    Ai=B[1:]\n\n    for m in Ai:\n\n        A[i][m-1]=A[i-1][m-1]\n\na=sum(A[N])\n\nprint((int(a)))", "score": 1.0, "surface_similarity": 0.6905594405594406}
{"id": "p03126_u894258749", "golden_code": "import numpy as np\n\n\n\n(N,M) = list(map(int,input().split()))\n\nB = np.ones(M,dtype=np.int)\n\n\n\nfor _ in range(N):\n\n    A = np.array(list(map(int,input().split())))[1:]\n\n    for i in range(M):\n\n        if not i+1 in A:\n\n            B[i] = 0\n\nprint((B.sum()))", "generated_code": "(N,M) = list(map(int,input().split()))\n\nr = int(-1)\n\nfor i in range(N):\n\n  A = list(map(int,input().split()))\n\n  A.pop(0)\n\n  c = 0\n\n  for a in A:\n\n    c |= (1 << (a-1))\n\n  r &= c\n\n\n\nans = sum([(r>>n)&1 for n in range(M)])\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.46951871657754013}
{"id": "p03558_u803848678", "golden_code": "from heapq import heappush, heappop\n\nk = int(eval(input()))\n\n\n\nheap = [(1,1)]\n\ndist = [float(\"inf\")]*k\n\nwhile heap:\n\n    cost, cur = heappop(heap)\n\n    if dist[cur] <= cost:\n\n        continue\n\n    dist[cur] = cost\n\n    # +1\n\n    nxt = (cur+1)%k\n\n    heappush(heap, (cost+1, nxt))\n\n    # *10\n\n    nxt = cur*10 % k\n\n    heappush(heap, (cost, nxt))\n\n\n\nprint((dist[0]))", "generated_code": "from collections import deque\n\nk = int(eval(input()))\n\n\n\nque = deque()\n\nque.append((1,1))\n\ndist = [float(\"inf\")]*k\n\nwhile que:\n\n    cost, cur = que.popleft()\n\n    if dist[cur] <= cost:\n\n        continue\n\n    dist[cur] = cost\n\n    # +1\n\n    nxt = (cur+1)%k\n\n    que.append((cost+1,nxt))\n\n    # *10\n\n    nxt = cur*10 % k\n\n    que.appendleft((cost, nxt))\n\nprint((dist[0]))", "score": 1.0, "surface_similarity": 0.8721205962059622}
{"id": "p02690_u164727245", "golden_code": "# coding: utf-8\n\n\n\n\n\ndef solve(*args: str) -> str:\n\n    x = int(args[0])\n\n\n\n    ret = None\n\n    for a in range(120):\n\n        for b in range(120):\n\n            a5, b5 = pow(a, 5), pow(b, 5)\n\n            if a5-b5 == x:\n\n                ret = (a, b)\n\n            elif a5+b5 == x:\n\n                ret = (a, -b)\n\n\n\n    return ' '.join(map(str, ret))\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    print((solve(*(open(0).read().splitlines()))))\n", "generated_code": "# coding: utf-8\n\n\n\n\n\ndef solve(*args: str) -> str:\n\n    x = int(args[0])\n\n\n\n    ret = None\n\n    for b in range(120):\n\n        for a in range(b, 120):\n\n            a5, b5 = pow(a, 5), pow(b, 5)\n\n            if a5-b5 == x:\n\n                ret = (a, b)\n\n            elif a5+b5 == x:\n\n                ret = (a, -b)\n\n\n\n    return ' '.join(map(str, ret))\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    print((solve(*(open(0).read().splitlines()))))\n", "score": 1.0, "surface_similarity": 0.9953917050691244}
{"id": "p02921_u853010060", "golden_code": "S = eval(input())\n\nT = eval(input())\n\n\n\nl = len(S)\n\nres = 0\n\nfor n in range(l):\n\n    if S[n] == T[n]:\n\n        res += 1\n\nprint(res)", "generated_code": "S = eval(input())\n\nT = eval(input())\n\nl = len(S)\n\nans = 0\n\nfor n in range(l):\n\n    if S[n] == T[n]:\n\n        ans += 1\n\nprint(ans)\n", "score": 1.0, "surface_similarity": 0.9770992366412214}
{"id": "p03371_u884323674", "golden_code": "A, B, C, X, Y = list(map(int, input().split()))\n\n\n\nmax_iter = max(X, Y) * 2\n\nans = float(\"inf\")\n\nfor i in range(max_iter):\n\n    a = max(X - i, 0)\n\n    b = max(Y - i, 0)\n\n    price = 2*C * i + A * a + B * b\n\n    ans = min(ans, price)\n\n\n\nprint(ans)", "generated_code": "A, B, C, X, Y = list(map(int, input().split()))\n\n\n\nans = float(\"inf\")\n\nfor i in range(max(X, Y)+1):\n\n    x = max(X - i, 0)\n\n    y = max(Y - i, 0)\n\n    cost = 2*C * i + A * x + B * y\n\n    ans = min(ans, cost)\n\n\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.9166666666666667}
{"id": "p02780_u755801379", "golden_code": "import numpy as np\n\nn,k=list(map(int, input().split()))\n\nexp=list([(int(x)+1)/2 for x in input().split()]) # 入力と同時に期待値計算\n\n\n\nl=np.cumsum(exp) # 累積和の計算\n\n\n\nans=l[k-1]\n\nfor i in range(n-k):\n\n    ans=max(ans,l[i+k]-l[i])\n\n    \n\nprint(ans)", "generated_code": "n,k=list(map(int, input().split()))\n\nexp=list([(int(x)+1)/2 for x in input().split()]) # 入力と同時に期待値計算\n\n\n\nl=[0]*n\n\nsum1=0\n\nfor i in range(n):# 累積和の計算\n\n    sum1+=exp[i]\n\n    l[i]=sum1 \n\n\n\nans=l[k-1]\n\nfor i in range(n-k):\n\n    ans=max(ans,l[i+k]-l[i])\n\n    \n\nprint(ans)", "score": 1.0, "surface_similarity": 0.7845125786163523}
{"id": "p03309_u020390084", "golden_code": "import math\n\nimport statistics\n\nn = int(eval(input()))\n\na = list(map(int,input().split()))\n\na = [aa-i-1 for i, aa in enumerate(a)]\n\nanswer = n*10**20\n\nmedian_low = statistics.median_low(a)\n\nmedian_high = statistics.median_high(a)\n\n\n\nfor m in (median_low,median_high):\n\n  ans=0\n\n  for aa in a:\n\n    ans += abs(aa-m)\n\n  answer = min(ans,answer)\n\nprint(answer)\n", "generated_code": "#!/usr/bin/env python3\n\nimport sys\n\n\n\n\n\ndef solve(N: int, A: \"List[int]\"):\n\n    difA = [0]*N\n\n\n\n    for i in range(N):\n\n        difA[i] = A[i]-(i+1)\n\n\n\n    difA.sort()\n\n    if N%2 == 0:\n\n        g1 = difA[N//2]\n\n        g2 = difA[N//2-1]\n\n        a1 = 0\n\n        a2 = 0\n\n        for i in range(N):\n\n            a1 += abs(difA[i]-g1)\n\n            a2 += abs(difA[i]-g2)\n\n        print((min(a1,a2)))\n\n            \n\n    else:\n\n        g = difA[N//2]\n\n        a = 0\n\n        for i in range(N):\n\n            a += abs(difA[i]-g)\n\n        print(a)\n\n    return\n\n\n\n\n\ndef main():\n\n    def iterate_tokens():\n\n        for line in sys.stdin:\n\n            for word in line.split():\n\n                yield word\n\n    tokens = iterate_tokens()\n\n    N = int(next(tokens))  # type: int\n\n    A = [int(next(tokens)) for _ in range(N)]  # type: \"List[int]\"\n\n    solve(N, A)\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 1.0, "surface_similarity": 0.558807061458402}
{"id": "p03170_u060938295", "golden_code": "# -*- coding: utf-8 -*-\n\n\"\"\"\n\nCreated on Sat Apr 25 18:20:35 2020\n\n\"\"\"\n\n\n\nimport sys\n\nimport numpy as np\n\n\n\nsys.setrecursionlimit(10 ** 9)\n\ndef input():\n\n    return sys.stdin.readline()[:-1]\n\nmod = 10**9+7\n\n\n\n#N = int(input())\n\nN, K = list(map(int,input().split()))\n\nA = np.array(list(map(int,input().split())))\n\n#N, K, *A = map(int, open(0).read().split())\n\n\n\ndp = [True for i in range(K + A[-1] + 1)]\n\nfor i in range(K):\n\n    if dp[i]:\n\n        for a in A:\n\n            dp[i + a] = False\n\n\n\n#    print(i, dp[i],A+i,dp[A+i])\n\n#print(dp)\n\n\n\nif dp[K]:\n\n    ans = 'Second'\n\nelse:\n\n    ans = 'First'\n\nprint(ans)", "generated_code": "# -*- coding: utf-8 -*-\n\n\"\"\"\n\nCreated on Sat Apr 25 18:20:35 2020\n\n\"\"\"\n\n\n\nimport sys\n\nimport numpy as np\n\n\n\nsys.setrecursionlimit(10 ** 9)\n\n#def input():\n\n#    return sys.stdin.readline()[:-1]\n\nmod = 10**9+7\n\n\n\n#N = int(input())\n\nN, K = list(map(int,input().split()))\n\n#A = np.array(list(map(int,input().split())))\n\nA = list(map(int,input().split()))\n\n\n\ndp = [True for i in range(K + A[-1] + 1)]\n\nfor i in range(K):\n\n    if dp[i]:\n\n        for a in A:\n\n            dp[i + a] = False\n\n\n\n#    print(i, dp[i],A+i,dp[A+i])\n\n#print(dp)\n\n\n\nif dp[K]:\n\n    ans = 'Second'\n\nelse:\n\n    ans = 'First'\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.8815180311890838}
{"id": "p02837_u562935282", "golden_code": "def main():\n\n    from itertools import product\n\n\n\n    N = int(eval(input()))\n\n\n\n    g = []\n\n    for _ in range(N):\n\n        a = int(eval(input()))\n\n        t = []\n\n        for _ in range(a):\n\n            x, y = list(map(int, input().split()))\n\n            x -= 1\n\n            t.append((x, y))\n\n        g.append(t)\n\n\n\n    def is_ok(prd):\n\n        for j, bl in enumerate(prd):\n\n            if bl:\n\n                for x, y in g[j]:\n\n                    if prd[x] != y:\n\n                        return False\n\n        return True\n\n\n\n    ans = 0\n\n    for prd in product([0, 1], repeat=N):\n\n        *prd, = prd  # list化\n\n        if is_ok(prd):\n\n            ans = max(ans, prd.count(1))\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n\n\n\n# bit演算しようとしてはまった\n", "generated_code": "def main():\n\n    from itertools import product\n\n\n\n    N = int(eval(input()))\n\n\n\n    g = []\n\n    for _ in range(N):\n\n        a = int(eval(input()))\n\n        t = []\n\n        for _ in range(a):\n\n            x, y = list(map(int, input().split()))\n\n            t.append((x - 1, y))\n\n        g.append(t)\n\n\n\n    def is_ok(prd):\n\n        for j, bl in enumerate(prd):\n\n            if bl:\n\n                for x, y in g[j]:\n\n                    if prd[x] != y:\n\n                        return False\n\n        return True\n\n\n\n    ans = 0\n\n    for prd in product([0, 1], repeat=N):\n\n        if is_ok(prd):\n\n            ans = max(ans, prd.count(1))\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n\n\n\n# bit演算しようとしてはまった\n", "score": 1.0, "surface_similarity": 0.9371063482713309}
{"id": "p03371_u982896977", "golden_code": "a,b,c,x,y = list(map(int,input().split()))\n\nans = a*x + b*y\n\nfor i in range(max(x,y) + 1):\n\n\tmoney = max(0,(x-i)*a) + max(0,(y-i)*b) + 2*i*c\n\n\tif money <= ans:\n\n\t\tans = money\n\nprint(ans)", "generated_code": "a,b,c,x,y = list(map(int,input().split()))\n\nif a + b >= 2*c:\n\n\tif x >= y:\n\n\t\tans = 2*y*c + (x-y)*min(a,2*c)\n\n\telse:\n\n\t\tans = 2*x*c + (y-x)*min(b,2*c)\n\nelse:\n\n\tans = (x*a + y*b)\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.6976483762597985}
{"id": "p02680_u340781749", "golden_code": "import sys\n\n# from itertools import chain, accumulate\n\n\n\nn, m, *abcdef = list(map(int, sys.stdin.buffer.read().split()))\n\n\n\nver_lines = []\n\nhor_lines = []\n\nx_list = set()\n\ny_list = set()\n\nn3 = n * 3\n\nfor a, b, c in zip(abcdef[0:n3:3], abcdef[1:n3:3], abcdef[2:n3:3]):\n\n    y_list.add(a)\n\n    y_list.add(b)\n\n    x_list.add(c)\n\n    ver_lines.append((a, b, c))\n\n\n\nfor d, e, f in zip(abcdef[n3 + 0::3], abcdef[n3 + 1::3], abcdef[n3 + 2::3]):\n\n    y_list.add(d)\n\n    x_list.add(e)\n\n    x_list.add(f)\n\n    hor_lines.append((d, e, f))\n\nx_list.add(0)\n\ny_list.add(0)\n\n\n\nx_list = sorted(x_list)\n\ny_list = sorted(y_list)\n\nx_dict = {x: i for i, x in enumerate(x_list, start=1)}\n\ny_dict = {y: i for i, y in enumerate(y_list, start=1)}\n\nrow_real = len(x_list)\n\ncol_real = len(y_list)\n\nrow = row_real + 2\n\ncol = col_real + 2\n\nbanned_up_ij = [[0] * row for _ in range(col)]\n\nbanned_down_ij = [[0] * row for _ in range(col)]\n\nbanned_left_ij = [[0] * col for _ in range(row)]\n\nbanned_right_ij = [[0] * col for _ in range(row)]\n\nfor a, b, c in ver_lines:\n\n    if a > b:\n\n        a, b = b, a\n\n    ai = y_dict[a]\n\n    bi = y_dict[b]\n\n    j = x_dict[c]\n\n    banned_left_ij[j][ai] += 1\n\n    banned_left_ij[j][bi] -= 1\n\n    banned_right_ij[j - 1][ai] += 1\n\n    banned_right_ij[j - 1][bi] -= 1\n\nfor d, e, f in hor_lines:\n\n    if e > f:\n\n        e, f = f, e\n\n    i = y_dict[d]\n\n    ej = x_dict[e]\n\n    fj = x_dict[f]\n\n    banned_up_ij[i][ej] += 1\n\n    banned_up_ij[i][fj] -= 1\n\n    banned_down_ij[i - 1][ej] += 1\n\n    banned_down_ij[i - 1][fj] -= 1\n\n\n\nbanned_up = [0] * (row * col)\n\nbanned_down = [0] * (row * col)\n\nbanned_left = [0] * (row * col)\n\nbanned_right = [0] * (row * col)\n\nfor i in range(col):\n\n    ru = banned_up_ij[i]\n\n    rd = banned_down_ij[i]\n\n    ri = row * i\n\n    banned_up[ri] = ru[0]\n\n    banned_down[ri] = rd[0]\n\n    for j in range(1, row):\n\n        banned_up[ri + j] = banned_up[ri + j - 1] + ru[j]\n\n        banned_down[ri + j] = banned_down[ri + j - 1] + rd[j]\n\nfor j in range(row):\n\n    rl = banned_left_ij[j]\n\n    rr = banned_right_ij[j]\n\n    banned_left[j] = rl[0]\n\n    banned_right[j] = rr[0]\n\n    for i in range(1, col):\n\n        ri0 = (i - 1) * row\n\n        ri1 = i * row\n\n        banned_left[ri1 + j] = banned_left[ri0 + j] + rl[i]\n\n        banned_right[ri1 + j] = banned_right[ri0 + j] + rr[i]\n\n\n\n# banned_up = list(chain.from_iterable(map(accumulate, banned_up_ij)))\n\n# banned_down = list(chain.from_iterable(map(accumulate, banned_down_ij)))\n\n# banned_left = list(chain.from_iterable(zip(*map(accumulate, banned_left_ij))))\n\n# banned_right = list(chain.from_iterable(zip(*map(accumulate, banned_right_ij))))\n\n\n\n# for i in range(col):\n\n#     print(walls[i * row:(i + 1) * row])\n\n\n\ns = row * y_dict[0] + x_dict[0]\n\nenable = [-1] * row + ([-1] + [0] * (row - 2) + [-1]) * (col - 2) + [-1] * row\n\n\n\n# for i in range(col):\n\n#     print(enable[i * row:(i + 1) * row])\n\n\n\nq = [s]\n\nmoves = [(-row, banned_up), (-1, banned_left), (1, banned_right), (row, banned_down)]\n\nwhile q:\n\n    c = q.pop()\n\n    if enable[c] == 1:\n\n        continue\n\n    elif enable[c] == -1:\n\n        print('INF')\n\n        exit()\n\n    enable[c] = 1\n\n    for dc, banned in moves:\n\n        if banned[c]:\n\n            continue\n\n        nc = c + dc\n\n        if enable[nc] == 1:\n\n            continue\n\n        q.append(nc)\n\n# for i in range(col):\n\n#     print(enable[i * row:(i + 1) * row])\n\n\n\n\n\nans = 0\n\nfor i in range(col):\n\n    ri = i * row\n\n    for j in range(row):\n\n        if enable[ri + j] != 1:\n\n            continue\n\n        t = y_list[i - 1]\n\n        b = y_list[i]\n\n        l = x_list[j - 1]\n\n        r = x_list[j]\n\n        ans += (b - t) * (r - l)\n\nprint(ans)\n", "generated_code": "import sys\n\n\n\n# from itertools import chain, accumulate\n\n\n\nn, m, *abcdef = list(map(int, sys.stdin.buffer.read().split()))\n\n\n\nver_lines = []\n\nhor_lines = []\n\nx_list = set()\n\ny_list = set()\n\nn3 = n * 3\n\nfor a, b, c in zip(abcdef[0:n3:3], abcdef[1:n3:3], abcdef[2:n3:3]):\n\n    y_list.add(a)\n\n    y_list.add(b)\n\n    x_list.add(c)\n\n    ver_lines.append((a, b, c))\n\n\n\nfor d, e, f in zip(abcdef[n3 + 0::3], abcdef[n3 + 1::3], abcdef[n3 + 2::3]):\n\n    y_list.add(d)\n\n    x_list.add(e)\n\n    x_list.add(f)\n\n    hor_lines.append((d, e, f))\n\nx_list.add(0)\n\ny_list.add(0)\n\n\n\nx_list = sorted(x_list)\n\ny_list = sorted(y_list)\n\nx_dict = {x: i for i, x in enumerate(x_list, start=1)}\n\ny_dict = {y: i for i, y in enumerate(y_list, start=1)}\n\nrow_real = len(x_list)\n\ncol_real = len(y_list)\n\nrow = row_real + 2\n\ncol = col_real + 2\n\n\n\nbanned_up = [0] * (row * col)\n\nbanned_down = [0] * (row * col)\n\nbanned_left = [0] * (row * col)\n\nbanned_right = [0] * (row * col)\n\nfor a, b, c in ver_lines:\n\n    if a > b:\n\n        a, b = b, a\n\n    ai = y_dict[a] * row\n\n    bi = y_dict[b] * row\n\n    j = x_dict[c]\n\n    banned_left[ai + j] += 1\n\n    banned_left[bi + j] -= 1\n\n    banned_right[ai + j - 1] += 1\n\n    banned_right[bi + j - 1] -= 1\n\nfor d, e, f in hor_lines:\n\n    if e > f:\n\n        e, f = f, e\n\n    ri = y_dict[d] * row\n\n    ej = x_dict[e]\n\n    fj = x_dict[f]\n\n    banned_up[ri + ej] += 1\n\n    banned_up[ri + fj] -= 1\n\n    banned_down[ri - row + ej] += 1\n\n    banned_down[ri - row + fj] -= 1\n\n\n\nfor i in range(1, col):\n\n    ri0 = row * (i - 1)\n\n    ri1 = row * i\n\n    for j in range(1, row):\n\n        banned_up[ri1 + j] += banned_up[ri1 + j - 1]\n\n        banned_down[ri1 + j] += banned_down[ri1 + j - 1]\n\n        banned_left[ri1 + j] += banned_left[ri0 + j]\n\n        banned_right[ri1 + j] += banned_right[ri0 + j]\n\n\n\n# banned_up = list(chain.from_iterable(map(accumulate, banned_up_ij)))\n\n# banned_down = list(chain.from_iterable(map(accumulate, banned_down_ij)))\n\n# banned_left = list(chain.from_iterable(zip(*map(accumulate, banned_left_ij))))\n\n# banned_right = list(chain.from_iterable(zip(*map(accumulate, banned_right_ij))))\n\n\n\n# for i in range(col):\n\n#     print(walls[i * row:(i + 1) * row])\n\n\n\ns = row * y_dict[0] + x_dict[0]\n\nenable = [-1] * row + ([-1] + [0] * (row - 2) + [-1]) * (col - 2) + [-1] * row\n\n\n\n# for i in range(col):\n\n#     print(enable[i * row:(i + 1) * row])\n\n\n\nq = [s]\n\nmoves = [(-row, banned_up), (-1, banned_left), (1, banned_right), (row, banned_down)]\n\nwhile q:\n\n    c = q.pop()\n\n    if enable[c] == 1:\n\n        continue\n\n    elif enable[c] == -1:\n\n        print('INF')\n\n        exit()\n\n    enable[c] = 1\n\n    for dc, banned in moves:\n\n        if banned[c]:\n\n            continue\n\n        nc = c + dc\n\n        if enable[nc] == 1:\n\n            continue\n\n        q.append(nc)\n\n# for i in range(col):\n\n#     print(enable[i * row:(i + 1) * row])\n\n\n\n\n\nans = 0\n\nfor i in range(col):\n\n    ri = i * row\n\n    for j in range(row):\n\n        if enable[ri + j] != 1:\n\n            continue\n\n        t = y_list[i - 1]\n\n        b = y_list[i]\n\n        l = x_list[j - 1]\n\n        r = x_list[j]\n\n        ans += (b - t) * (r - l)\n\nprint(ans)\n", "score": 1.0, "surface_similarity": 0.915979097909791}
{"id": "p02555_u476068053", "golden_code": "def main():\n\n    s = int(eval(input()))\n\n    mod = 10**9 + 7\n\n\n\n    dp = [0] * (s+1)\n\n    dp[0] = 1\n\n    for i in range(1, s+1):\n\n        for j in range(0, (i-3)+1):\n\n            dp[i] += dp[j]\n\n            dp[i] %= mod\n\n    print((dp[-1]))\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "generated_code": "def main():\n\n    s = int(eval(input()))\n\n    mod = 10**9 + 7\n\n\n\n    dp = [0] * (s+1)\n\n    dp[0] = 1\n\n#    for i in range(1, s+1):\n\n#        for j in range(0, (i-3)+1):\n\n#            dp[i] += dp[j]\n\n#            dp[i] %= mod\n\n    for i in range(1, s+1):\n\n        if i < 3:\n\n            dp[i] = 0\n\n        else:\n\n            dp[i] = dp[i-1] + dp[i-3]\n\n            dp[i] %= mod\n\n\n\n    print((dp[-1]))\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "score": 1.0, "surface_similarity": 0.9464136081783141}
{"id": "p02792_u546338822", "golden_code": "def main():\n\n    n = int(eval(input()))\n\n    import numpy as np\n\n    ans = np.zeros((10,10))\n\n    for i in range(1,n+1):\n\n        h,t = str(i)[0],str(i)[-1]\n\n        ans[int(h)-1][int(t)-1]+=1\n\n    s = 0\n\n    for i in range(10):\n\n        for j in range(10):\n\n            s += ans[i][j]*ans[j][i]\n\n\n\n    print((int(s)))\n\nif __name__ == \"__main__\":\n\n    main()", "generated_code": "def main():\n\n    n = int(eval(input()))\n\n    dp = [[0 for i in range(10)] for i in range(10)]\n\n    for i in range(1,n+1):\n\n        h,t = int(str(i)[0]), int(str(i)[-1])\n\n        dp[h][t] += 1\n\n    ans = 0\n\n    for i in range(10):\n\n        for j in range(10):\n\n            ans += dp[i][j] * dp[j][i]\n\n    print(ans)\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "score": 1.0, "surface_similarity": 0.790406472741283}
{"id": "p02850_u606045429", "golden_code": "from collections import deque\n\n\n\nN, *AB = list(map(int, open(0).read().split()))\n\n\n\nE = [set() for _ in range(N + 1)]\n\nfor i, (a, b) in enumerate(zip(*[iter(AB)] * 2)):\n\n    E[a].add((b, i))\n\n    E[b].add((a, i))\n\n\n\nA = [0] * (N - 1)\n\nQ = deque([(0, 1)])\n\nwhile Q:\n\n    p, v = Q.popleft()\n\n    c = 0\n\n    for u, i in E[v]:\n\n        E[u].remove((v, i))\n\n        c += 1 + (c + 1 == p)\n\n        Q.append((c, u))\n\n        A[i] = c\n\n\n\nprint((max(A), *A))", "generated_code": "from collections import deque\n\n\n\nN, *AB = list(map(int, open(0).read().split()))\n\n\n\nE = [set() for _ in range(N + 1)]\n\nfor i, (a, b) in enumerate(zip(*[iter(AB)] * 2)):\n\n    E[a].add((b, i))\n\n    E[b].add((a, i))\n\n\n\nA = [0] * (N - 1)\n\nQ = deque([1])\n\nwhile Q:\n\n    p, v = divmod(Q.popleft(), N + 1)\n\n    c = 0\n\n    for u, i in E[v]:\n\n        E[u].remove((v, i))\n\n        c += 1 + (c + 1 == p)\n\n        Q.append(c * (N + 1) + u)\n\n        A[i] = c\n\n\n\nprint((max(A)))\n\nprint((\"\\n\".join(map(str, A))))", "score": 1.0, "surface_similarity": 0.9466800804828974}
{"id": "p03078_u753803401", "golden_code": "def slove():\n\n    import sys\n\n    import heapq\n\n    import collections\n\n    input = sys.stdin.readline\n\n    x, y, z, k = list(map(int, input().rstrip('\\n').split()))\n\n    a = list(map(int, input().rstrip('\\n').split()))\n\n    a.sort(reverse=True)\n\n    b = list(map(int, input().rstrip('\\n').split()))\n\n    b.sort(reverse=True)\n\n    c = list(map(int, input().rstrip('\\n').split()))\n\n    c.sort(reverse=True)\n\n    q = [[-(a[0] + b[0] + c[0]), 0, 0, 0]]\n\n    heapq.heapify(q)\n\n    fq = collections.defaultdict(list)\n\n    fq[(-(a[0] + b[0] + c[0]), 0, 0, 0), 1] = 1\n\n    t = 0\n\n    for _ in range(k):\n\n        if len(q) != 0:\n\n            p = heapq.heappop(q)\n\n            t = p[0]\n\n            aq = p[1]\n\n            bq = p[2]\n\n            cq = p[3]\n\n            if aq + 1 < len(a):\n\n                if (-(a[aq+1] + b[bq] + c[cq]), aq+1, bq, cq) not in fq:\n\n                    heapq.heappush(q, [-(a[aq+1] + b[bq] + c[cq]), aq+1, bq, cq])\n\n                    fq[(-(a[aq+1] + b[bq] + c[cq]), aq+1, bq, cq)] = 1\n\n            if bq + 1 < len(b):\n\n                if (-(a[aq] + b[bq+1] + c[cq]), aq, bq+1, cq) not in fq:\n\n                    heapq.heappush(q, [-(a[aq] + b[bq+1] + c[cq]), aq, bq+1, cq])\n\n                    fq[(-(a[aq] + b[bq+1] + c[cq]), aq, bq+1, cq)] = 1\n\n            if cq + 1 < len(c):\n\n                if (-(a[aq] + b[bq] + c[cq+1]), aq, bq, cq+1) not in fq:\n\n                    heapq.heappush(q, [-(a[aq] + b[bq] + c[cq+1]), aq, bq, cq+1])\n\n                    fq[(-(a[aq] + b[bq] + c[cq+1]), aq, bq, cq+1)] = 1\n\n        print((-t))\n\n\n\n\n\nif __name__ == '__main__':\n\n    slove()\n", "generated_code": "import sys\n\nimport collections\n\nimport heapq\n\n\n\n\n\ndef solve():\n\n    input = sys.stdin.readline\n\n    mod = 10 ** 9 + 7\n\n    x, y, z, k = list(map(int, input().rstrip('\\n').split()))\n\n    a = list(map(int, input().rstrip('\\n').split()))\n\n    b = list(map(int, input().rstrip('\\n').split()))\n\n    c = list(map(int, input().rstrip('\\n').split()))\n\n    a.sort(reverse=True)\n\n    b.sort(reverse=True)\n\n    c.sort(reverse=True)\n\n    ql = [[-(a[0] + b[0] + c[0]), 0, 0, 0]]\n\n    heapq.heapify(ql)\n\n    fq = collections.defaultdict(int)\n\n    fq[0, 0, 0]\n\n    for i in range(k):\n\n        s, ap, bp, cp = heapq.heappop(ql)\n\n        for app, bpp, cpp in ([[ap+1, bp, cp], [ap, bp+1, cp], [ap, bp, cp+1]]):\n\n            if app < x and bpp < y and cpp < z:\n\n                if (app, bpp, cpp) not in fq:\n\n                    heapq.heappush(ql, [-(a[app] + b[bpp] + c[cpp]), app, bpp, cpp])\n\n                    fq[app, bpp, cpp]\n\n        print((-s))\n\n\n\n\n\nif __name__ == '__main__':\n\n    solve()\n", "score": 1.0, "surface_similarity": 0.761968085106383}
{"id": "p00500_u546285759", "golden_code": "N = int(input())\n\nscore = [list(map(int, input().split())) for _ in range(N)]\n\nplayers = [0 for _ in range(N)]\n\nfor play in list(zip(*score)):\n\n    for i, p in enumerate(play):\n\n        if play.count(p) == 1:\n\n            players[i] += p\n\nprint(*players, sep='\\n')\n", "generated_code": "N = int(input())\n\nscore = [input().split() for _ in range(N)]\n\nplayers = [0]*N\n\nfor play in list(zip(*score)):\n\n    for i, p in enumerate(play):\n\n        if play.count(p) == 1:\n\n            players[i] += int(p)\n\nprint(*players, sep='\\n')\n", "score": 1.0, "surface_similarity": 0.8758490566037735}
{"id": "p02690_u363074342", "golden_code": "x = int(eval(input()))\n\n\n\npoypoyo = 'po'\n\nfor i in range(10000):\n\n    for j in range(10000):\n\n        if i**5 - j**5 == x:\n\n            print((i,j))\n\n            quit()\n\n            break\n\n        if i**5 - (-j)**5 ==x:\n\n            print((i,-j))\n\n            quit()\n\n            break\n\n        po = 'po'\n\n        poypoyo += po\n\n\n", "generated_code": "x = int(eval(input()))\n\n\n\nfor i in range(10000):\n\n    for j in range(1000):\n\n        if i**5 - j**5 == x:\n\n            print((i,j))\n\n            quit()\n\n            break\n\n        if i**5 - (-j)**5 ==x:\n\n            print((i,-j))\n\n            quit()\n\n            break\n\n\n\n\n", "score": 1.0, "surface_similarity": 0.9008658008658008}
{"id": "p03170_u419963262", "golden_code": "n,k = list(map(int,input().split()))\n\narr = list(map(int,input().split()))\n\n\n\ndp = [False]*(k+1)\n\n\n\nfor stones in range(k+1):\n\n    for x in arr:\n\n        if stones >= x and dp[stones-x] == False:\n\n            dp[stones] = True\n\n\n\nif dp[k]:\n\n    print(\"First\")\n\nelse:\n\n    print(\"Second\")\n", "generated_code": "N,K = list(map(int,input().split()))\n\nA = list(map(int,input().split()))\n\n\n\ndp = [False]*(K+1)\n\n\n\nfor i in range(K+1):\n\n    for j in range(N):\n\n        if i-A[j]>=0 and dp[i-A[j]] == False:\n\n            dp[i] = True\n\n\n\n        \n\nif dp[K]:\n\n    print(\"First\")\n\nelse:\n\n    print(\"Second\")", "score": 1.0, "surface_similarity": 0.9253472222222222}
{"id": "p02780_u179169725", "golden_code": "import sys\n\nread = sys.stdin.readline\n\n\n\n\n\ndef read_ints():\n\n    return list(map(int, read().split()))\n\n\n\n\n\ndef read_a_int():\n\n    return int(read())\n\n\n\n\n\ndef read_matrix(H):\n\n    '''\n\n    H is number of rows\n\n    '''\n\n    return [list(map(int, read().split())) for _ in range(H)]\n\n\n\n\n\ndef read_map(H):\n\n    '''\n\n    H is number of rows\n\n    文字列で与えられた盤面を読み取る用\n\n    '''\n\n    return [read()[:-1] for _ in range(H)]\n\n\n\n\n\ndef read_tuple(H):\n\n    '''\n\n    H is number of rows\n\n    '''\n\n    ret = []\n\n    for _ in range(H):\n\n        ret.append(tuple(map(int, read().split())))\n\n    return ret\n\n\n\n\n\ndef read_col(H, n_cols):\n\n    '''\n\n    H is number of rows\n\n    n_cols is number of cols\n\n\n\n    A列、B列が与えられるようなとき\n\n    '''\n\n    ret = [[] for _ in range(n_cols)]\n\n    for _ in range(H):\n\n        tmp = list(map(int, read().split()))\n\n        for col in range(n_cols):\n\n            ret[col].append(tmp[col])\n\n\n\n    return ret\n\n\n\n\n\nN, K = read_ints()\n\nP = read_ints()\n\n\n\n\n\ndef ret_mean(X):\n\n    return (X + 1) / 2\n\n\n\n\n\n\n\n\n\nimport numpy as np\n\nP_mean = np.array([ret_mean(p) for p in P])\n\nP_accum = np.zeros(N+1)\n\nP_accum[1:] = P_mean.cumsum()\n\n\n\nans = 0\n\n# print(P_accum)\n\nfor i in range(N - K + 1):\n\n    j = i + K\n\n    ans = max(ans, P_accum[j] - P_accum[i])\n\nprint(ans)\n", "generated_code": "import sys\n\nread = sys.stdin.readline\n\n\n\n\n\ndef read_ints():\n\n    return list(map(int, read().split()))\n\n\n\n\n\ndef read_a_int():\n\n    return int(read())\n\n\n\n\n\ndef read_matrix(H):\n\n    '''\n\n    H is number of rows\n\n    '''\n\n    return [list(map(int, read().split())) for _ in range(H)]\n\n\n\n\n\ndef read_map(H):\n\n    '''\n\n    H is number of rows\n\n    文字列で与えられた盤面を読み取る用\n\n    '''\n\n    return [read()[:-1] for _ in range(H)]\n\n\n\n\n\ndef read_tuple(H):\n\n    '''\n\n    H is number of rows\n\n    '''\n\n    ret = []\n\n    for _ in range(H):\n\n        ret.append(tuple(map(int, read().split())))\n\n    return ret\n\n\n\n\n\ndef read_col(H, n_cols):\n\n    '''\n\n    H is number of rows\n\n    n_cols is number of cols\n\n\n\n    A列、B列が与えられるようなとき\n\n    '''\n\n    ret = [[] for _ in range(n_cols)]\n\n    for _ in range(H):\n\n        tmp = list(map(int, read().split()))\n\n        for col in range(n_cols):\n\n            ret[col].append(tmp[col])\n\n\n\n    return ret\n\n\n\n\n\nN, K = read_ints()\n\nP = read_ints()\n\n\n\n\n\ndef ret_mean(X):\n\n    return (X + 1) / 2\n\n\n\n\n\n\n\nclass cumsum1d:\n\n    def __init__(self, ls: list):\n\n        '''\n\n        1次元リストを受け取る\n\n        '''\n\n        from itertools import accumulate\n\n        self.ls_accum = [0] + list(accumulate(ls))\n\n\n\n    def total(self, i, j):\n\n        # もとの配列lsにおける[i,j)の中合計\n\n        return self.ls_accum[j] - self.ls_accum[i]\n\n      \n\nP_mean = [ret_mean(p) for p in P]\n\nP_accum = cumsum1d(P_mean)\n\n\n\nans = 0\n\n# print(P_accum)\n\nfor i in range(N - K + 1):\n\n    j = i + K\n\n    ans = max(ans, P_accum.total(i,j))\n\nprint(ans)\n", "score": 1.0, "surface_similarity": 0.8972121341593676}
{"id": "p02419_u579833671", "golden_code": "W = input().lower()\n\ns = []\n\nwhile True:\n\n    T = list(map(str, input().split()))\n\n    if(T[0] == \"END_OF_TEXT\"):\n\n        break\n\n    else:\n\n        for i in range(len(T)):\n\n            s.append(T[i].lower())\n\nans = 0\n\nfor i in range(len(s)):\n\n    if(s[i] == W):\n\n        ans += 1\n\nprint(ans)", "generated_code": "W = input().lower()\n\ns = []\n\nans = 0\n\nwhile True:\n\n    T = list(map(str, input().split()))\n\n    if(T[0] == \"END_OF_TEXT\"):\n\n        break\n\n    else:\n\n        for i in range(len(T)):\n\n            if(W == T[i].lower()):\n\n                ans += 1\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.9075342465753424}
{"id": "p02702_u860002137", "golden_code": "import numpy as np\n\n\n\ns = input()[::-1]\n\nlength = len(s)\n\na = np.zeros(length, dtype=int)\n\nd = np.zeros(length, dtype=int)\n\nans = np.zeros(2019, dtype=int)\n\nx = 10\n\n\n\na[0] = int(s[0])\n\nd[0] = a[0]\n\nans[d[0]] += 1\n\n\n\nfor i in range(1, length):\n\n    a[i] = int(s[i]) * x % 2019\n\n    d[i] = (d[i-1] + a[i]) % 2019\n\n    ans[d[i]] += 1\n\n    x = x * 10 % 2019\n\n\n\nans_c = ans[np.nonzero(ans)]\n\n\n\nprint((int(sum([ans_c[i] * (ans_c[i]-1) for i in range(ans_c.shape[0])]) / 2) + ans[0]))", "generated_code": "s = input()[::-1]\n\nlength = len(s)\n\na = [0] * length\n\nd = [0] * length\n\nans = [0] * 2019\n\nx = 10\n\n\n\na[0] = int(s[0])\n\nd[0] = a[0]\n\nans[d[0]] += 1\n\n\n\nfor i in range(1, length):\n\n    a[i] = int(s[i]) * x % 2019\n\n    d[i] = (d[i-1] + a[i]) % 2019\n\n    ans[d[i]] += 1\n\n    x = x * 10 % 2019\n\n\n\nprint((int(sum([ans[i] * (ans[i]-1) for i in range(2019)]) / 2) + ans[0]))", "score": 1.0, "surface_similarity": 0.783879904162923}
{"id": "p03273_u353797797", "golden_code": "import numpy as np\n\nh,w=map(int,input().split())\n\nt=[list(input()) for _ in range(h)]\n\nfor i in range(h):\n\n    t[i]=[(tij==\"#\")*1 for tij in t[i]]\n\nt=np.array(t,dtype=\"i2\")\n\nrows=[]\n\ncolumns=[]\n\nfor i in range(h):\n\n    if np.sum(t[i])==0:\n\n        rows+=[i]\n\nfor j in range(w):\n\n    if np.sum(t[:,j])==0:\n\n        columns+=[j]\n\nt=np.delete(t,rows,0)\n\nt=np.delete(t,columns,1)\n\nfor i in range(h-len(rows)):\n\n    print(*[\"#\" if tij else \".\" for tij in t[i]],sep=\"\")\n", "generated_code": "h,w=map(int,input().split())\n\nt=[list(input()) for _ in range(h)]\n\nfor i in range(h):\n\n    t[i]=[(tij==\"#\")*1 for tij in t[i]]\n\nrows=[]\n\ncolumns=[]\n\nfor i,ti in enumerate(t):\n\n    if sum(ti)==0:\n\n        rows+=[i]\n\nfor j,tj in enumerate(zip(*t)):\n\n    if sum(tj)==0:\n\n        columns+=[j]\n\nnt=[]\n\nfor i,ti in enumerate(t):\n\n    if i in rows:continue\n\n    nti=[]\n\n    for j,tij in enumerate(ti):\n\n        if j in columns:continue\n\n        nti+=[\"#\" if tij else \".\"]\n\n    print(*nti,sep=\"\")\n", "score": 1.0, "surface_similarity": 0.7139802937348949}
{"id": "p03796_u919633157", "golden_code": "import math\n\nprint((math.factorial(int(eval(input())))%(10**9+7)))", "generated_code": "n=int(eval(input()))\n\nans=1\n\nfor i in range(1,n+1):\n\n    ans*=i\n\n    ans%=10**9+7\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.460573476702509}
{"id": "p02773_u414980766", "golden_code": "import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\nN = int(readline())\n\nS = read().split()\n\n\n\nS = sorted(S)\n\nls = [[] for i in range(N + 1)]\n\nmax_num = 0\n\nleft = 0\n\nright = 0\n\nwhile right < N:\n\n    while right < N and S[left] == S[right]:\n\n        right += 1\n\n    if (right  - left) >= max_num:\n\n        ls[right - left].append(S[left].decode())\n\n        max_num = right - left\n\n    left = right\n\n    \n\nprint(('\\n'.join(ls[max_num])))\n", "generated_code": "from collections import Counter\n\n\n\nimport sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\nN = int(readline())\n\nS = read().split()\n\n\n\nres = []\n\nc = Counter(S)\n\nmax_num = c.most_common(1)[0][1]\n\nfor i, j in list(c.items()):\n\n    if j == max_num:\n\n        res.append(i)\n\n        \n\nres.sort()\n\n\n\n        \n\nprint(('\\n'.join(list([x.decode() for x in res]))))\n", "score": 1.0, "surface_similarity": 0.6030785970302099}
{"id": "p03164_u077291787", "golden_code": "# temp\n\nn,w = list(map(int,input().split()))\n\nwv = [tuple(map(int,input().split())) for i in range(n)]\n\n\n\ndp = [0] + [float(\"inf\")]*(10**5)\n\nfor i in range(n):\n\n    for j in range(10**5,wv[i][1]-1,-1):\n\n        dp[j] = min(dp[j],dp[j-wv[i][1]]+wv[i][0])\n\n\n\nres = 0\n\nfor v,e in enumerate(dp):\n\n    if e <= w:\n\n        res = v\n\nprint(res)", "generated_code": "# dpE - Knapsack 2\n\nimport sys\n\ninput = sys.stdin.readline\n\n\n\ndef main():\n\n    n, W = tuple(map(int, input().rstrip().split()))\n\n    A = tuple(tuple(map(int, input().rstrip().split())) for _ in range(n))\n\n    _, v = list(zip(*A))\n\n    lim = sum(v)\n\n    dp = [0] + [float(\"inf\")] * lim\n\n    for i in range(n):\n\n        for j in range(lim, A[i][1] - 1, -1):\n\n            dp[j] = min(dp[j], dp[j - A[i][1]] + A[i][0])\n\n    ans = max(v for v, w in enumerate(dp) if w <= W)\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()", "score": 1.0, "surface_similarity": 0.6998106060606061}
{"id": "p02555_u021548497", "golden_code": "def main():\n\n  n = int(eval(input()))\n\n  \n\n  dp = [0]*(n+1)\n\n  dp[0] = 1\n\n  mod = pow(10, 9) + 7\n\n  for i in range(n+1):\n\n    for j in range(i-2):\n\n      dp[i] += dp[j]\n\n      dp[i] %= mod\n\n  \n\n  print((dp[n]))\n\n\n\nif __name__ == \"__main__\":\n\n  main()", "generated_code": "def main():\n\n  n = int(eval(input()))\n\n  \n\n  dp = [0]*(n+1)\n\n  dp[0] = 1\n\n  mod = pow(10, 9) + 7\n\n  for i in range(3, n+1):\n\n    dp[i] = dp[i-1] + dp[i-3]\n\n    dp[i] %= mod\n\n  \n\n  print((dp[n]))\n\n\n\nif __name__ == \"__main__\":\n\n  main()", "score": 1.0, "surface_similarity": 0.952}
{"id": "p03253_u588341295", "golden_code": "# -*- coding: utf-8 -*-\n\n\n\n\"\"\"\n\n参考：http://drken1215.hatenablog.com/entry/2018/09/23/224100\n\n　　　http://tutuz.hateblo.jp/entry/2018/09/24/121248\n\n・素因数分解と重複組み合わせ\n\n・毎回階乗やると死ぬから階乗と逆元のテーブル作る(忘れてた)\n\n\"\"\"\n\n\n\nfrom collections import defaultdict\n\nfrom math import sqrt\n\n\n\nMOD = 10 ** 9 + 7\n\n\n\ndef fact_prime(num):\n\n    d = defaultdict(int)\n\n    # 終点はルート切り捨て+1\n\n    end = int(sqrt(num)) + 1\n\n    for i in range(2, end+1):\n\n        cnt = 0\n\n        # 素因数分解：小さい方から割れるだけ割って素数をカウント\n\n        while num % i == 0:\n\n            num //= i\n\n            d[i] += 1\n\n        # 1まで来たら終了\n\n        if num == 1:\n\n            break\n\n    # 最後までそのまま来たやつはnumが素数(ただし1^1は1^0なので数に入れない)\n\n    if num != 1:\n\n        d[num] += 1\n\n    return d\n\n\n\n# とりあえずv+N-1が収まればいいはず\n\nMAX = 10 ** 5 * 2\n\n# 予め組み合わせ計算に必要な階乗と逆元のテーブルを作っておく\n\nfactorial = [1] * (MAX)\n\nfactorial[0] = factorial[1] = 1\n\nfor i in range(2, MAX):\n\n    factorial[i] = factorial[i-1] * i % MOD\n\n\n\ninverse = [1] * (MAX)\n\n# powに第三引数入れると冪乗のmod付計算を高速にやってくれる\n\ninverse[MAX-1] = pow(factorial[MAX-1], MOD-2, MOD)\n\nfor i in range(MAX-2, 0, -1):\n\n    # 最後から戻っていくこのループならH+W回powするより処理が速い\n\n    inverse[i] = inverse[i+1] * (i+1) % MOD\n\n\n\n# 組み合わせの数\n\ndef nCr(n, r):\n\n    # 10C7 = 10C3\n\n    r = min(r, n-r)\n\n    # 分子の計算\n\n    numerator = factorial[n]\n\n    # 分母の計算\n\n    denominator = inverse[r] * inverse[n-r] % MOD\n\n    return numerator * denominator % MOD\n\n\n\nN, M = list(map(int, input().split()))\n\n\n\n# d = fact_prime(M)\n\n# print(d)\n\nans = 1\n\nfor k, v in list(fact_prime(M).items()):\n\n    # 重複組み合わせ\n\n    # v個のkとN-1個の仕切りから、v個を並べる(v+N-1個のマスからv個を選び出す組み合わせ)\n\n    ans = (ans * nCr(v+N-1, v)) % MOD\n\nprint(ans)\n", "generated_code": "# -*- coding: utf-8 -*-\n\n\n\nimport sys\n\n\n\ndef input(): return sys.stdin.readline().strip()\n\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\n\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\n\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\n\ndef ceil(x, y=1): return int(-(-x // y))\n\ndef INT(): return int(eval(input()))\n\ndef MAP(): return list(map(int, input().split()))\n\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\n\ndef Yes(): print('Yes')\n\ndef No(): print('No')\n\ndef YES(): print('YES')\n\ndef NO(): print('NO')\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = float('inf')\n\nMOD = 10 ** 9 + 7\n\n\n\ndef factorize(num: int) -> dict:\n\n    \"\"\" 素因数分解 \"\"\"\n\n    from math import sqrt\n\n    from collections import Counter\n\n\n\n    d = Counter()\n\n    # 終点はルート切り捨て+1\n\n    for i in range(2, int(sqrt(num))+1):\n\n        # 素因数分解：小さい方から割れるだけ割って素数をカウント\n\n        while num % i == 0:\n\n            num //= i\n\n            d[i] += 1\n\n        # 1まで分解したら終了\n\n        if num == 1:\n\n            break\n\n    # 最後に残ったnumは素数(ただし1^1は1^0なので数に入れない)\n\n    if num != 1:\n\n        d[num] += 1\n\n    return d\n\n\n\nclass FactInvMOD:\n\n    \"\"\" 階乗たくさん使う時用のテーブル準備 \"\"\"\n\n\n\n    def __init__(self, MAX, MOD):\n\n        \"\"\" MAX：階乗に使う数値の最大以上まで作る \"\"\"\n\n        \n\n        MAX += 1\n\n        self.MAX = MAX\n\n        self.MOD = MOD\n\n        # 階乗テーブル\n\n        factorial = [1] * MAX\n\n        factorial[0] = factorial[1] = 1\n\n        for i in range(2, MAX):\n\n            factorial[i] = factorial[i-1] * i % MOD\n\n        # 階乗の逆元テーブル\n\n        inverse = [1] * MAX\n\n        # powに第三引数入れると冪乗のmod付計算を高速にやってくれる\n\n        inverse[MAX-1] = pow(factorial[MAX-1], MOD-2, MOD)\n\n        for i in range(MAX-2, 0, -1):\n\n            # 最後から戻っていくこのループならMAX回powするより処理が速い\n\n            inverse[i] = inverse[i+1] * (i+1) % MOD\n\n        self.fact = factorial\n\n        self.inv = inverse\n\n    \n\n    def nCr(self, n, r):\n\n        \"\"\" 組み合わせの数 (必要な階乗と逆元のテーブルを事前に作っておく) \"\"\"\n\n\n\n        if n < r: return 0\n\n        # 10C7 = 10C3\n\n        r = min(r, n-r)\n\n        # 分子の計算\n\n        numerator = self.fact[n]\n\n        # 分母の計算\n\n        denominator = self.inv[r] * self.inv[n-r] % self.MOD\n\n        return numerator * denominator % self.MOD\n\n\n\n    def nPr(self, n, r):\n\n        \"\"\" 順列 \"\"\"\n\n\n\n        if n < r: return 0\n\n        return self.fact[n] * self.inv[n-r] % self.MOD\n\n\n\n    def nHr(self, n, r):\n\n        \"\"\" 重複組み合わせ \"\"\"\n\n\n\n        # r個選ぶところにN-1個の仕切りを入れる\n\n        return self.nCr(r+n-1, r)\n\n\n\nN, M = MAP()\n\n\n\nd = factorize(M)\n\n\n\n# 例外処理\n\nif not d:\n\n    print((1))\n\n    exit()\n\n\n\nMAX = N + max(d.values())\n\nfim = FactInvMOD(MAX, MOD)\n\nans = 1\n\nfor k, v in list(d.items()):\n\n    ans *= fim.nHr(N, v)\n\n    ans %= MOD\n\nprint(ans)\n", "score": 1.0, "surface_similarity": 0.7098920744223003}
{"id": "p03436_u254871849", "golden_code": "import sys\n\nimport numpy as np\n\nfrom heapq import heappop, heappush\n\n\n\n# Dijikstra\n\ndef main():\n\n    H, W = list(map(int, sys.stdin.readline().split()))\n\n\n\n    grid = np.array([list(sys.stdin.readline().rstrip()) for _ in range(H)])\n\n    grid = np.pad(grid, 1, 'constant')\n\n    # atcoderではnp.pad() のargにconstant_valuesを指定できない\n\n    q = []\n\n    heappush(q, (0, 1, 1))\n\n    visited = set()\n\n    cost = np.full((H + 1, W + 1), np.inf)\n\n    cost[1][1] = 0\n\n    while q:\n\n        c, i, j = heappop(q)\n\n        if (i, j) in visited:\n\n            continue\n\n        visited.add((i, j))\n\n        cost[i][j] = c\n\n        if i == H and j == W:\n\n            break\n\n        for dy, dx in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n\n            y = i + dy\n\n            x = j + dx\n\n            if grid[y][x] == '.' and not (y, x) in visited:\n\n                heappush(q, (c + 1, y, x))\n\n    \n\n\n\n    if cost[H][W] != np.inf:\n\n        ans = int(np.sum(grid == '.') - (cost[H][W] + 1))\n\n    else:\n\n        ans = -1\n\n\n\n    print(ans)  \n\n\n\nif __name__ == \"__main__\":\n\n    main()", "generated_code": "import sys\n\nfrom heapq import heappop, heappush\n\n\n\nH, W = list(map(int, sys.stdin.readline().split()))\n\ngrid = ['#' * (W + 2)]\n\ngrid += ['#' + sys.stdin.readline().rstrip() + '#' for _ in range(H)]\n\ngrid += ['#' * (W + 2)]\n\n\n\ndef heuristic_cost(y, x):\n\n    return abs(H - y) + abs(W - x)\n\n\n\ndef main():\n\n    h = heuristic_cost(1, 1)\n\n    c = 0\n\n    s = h + c\n\n    hq = [(s, c, 1, 1)]\n\n    nex = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    cost = [[None] * (W+1) for _ in range(H+1)]\n\n    while hq:\n\n        s, c, y, x = heappop(hq)\n\n        if not cost[y][x] is None:\n\n            continue\n\n        cost[y][x] = c\n\n        for dy, dx in nex:\n\n            i = y + dy\n\n            j = x + dx\n\n            if grid[i][j] == '.' and cost[i][j] is None:\n\n                h = heuristic_cost(i, j)\n\n                s = h + (c + 1)\n\n                heappush(hq, (s, c+1, i, j))\n\n\n\n    white_cnt = 0\n\n    for i in range(1, H+1):\n\n        for j in range(1, W+1):\n\n            white_cnt += (grid[i][j] == '.') & 1\n\n    \n\n    ans = white_cnt - (cost[H][W] + 1) if not cost[H][W] is None else -1\n\n    return ans \n\n\n\nif __name__ == '__main__':\n\n    ans = main()\n\n    print(ans)", "score": 1.0, "surface_similarity": 0.6838593185743445}
{"id": "p02690_u062560908", "golden_code": "def sol(n):\n\n    d = {}\n\n    N = 100000\n\n    for i in range(-N, N+1):\n\n        d[i**5]=i\n\n    for i in d:\n\n        j = n+i\n\n        if j in d:\n\n            print(d[j], d[i])\n\n            return\n\n\n\ndef main():\n\n    n = eval(input())\n\n    sol(n)\n\nif __name__ == '__main__':\n\n    main()", "generated_code": "def sol(n):\n\n    d = {}\n\n    N = 1000\n\n    for i in range(-N, N+1):\n\n        d[i**5]=i\n\n    for i in d:\n\n        j = n+i\n\n        if j in d:\n\n            print(d[j], d[i])\n\n            return\n\n\n\ndef main():\n\n    n = eval(input())\n\n    sol(n)\n\nif __name__ == '__main__':\n\n    main()", "score": 1.0, "surface_similarity": 0.9964664310954063}
{"id": "p02264_u881590806", "golden_code": "class Queue:\n\n    def __init__(self,values):\n\n        self.values = values\n\n\n\n    def empty(self):\n\n        if len(self.values) == 0:\n\n            return True\n\n        else:\n\n            return False\n\n\n\n    def enqueue(self,v):\n\n        self.values.append(v)\n\n\n\n    def dequeue(self):\n\n        if len(self.values) <= 0:\n\n            raise\n\n        else:\n\n            v = self.values[0]\n\n            del self.values[0]\n\n            return v\n\n\n\nn,q = list(map(int,input().split(' ')))\n\nprocesses = []\n\nfor i in range(n):\n\n    n,t = input().split(' ')\n\n    processes.append((n,int(t)))\n\n\n\nqueue = Queue(processes)\n\n\n\nclock = 0\n\ndone = []\n\nwhile not queue.empty():\n\n    p = queue.dequeue()\n\n    n = p[0]\n\n    t = p[1]\n\n    if t <= q:\n\n        clock+=t\n\n        done.append((n,clock))\n\n    else:\n\n        queue.enqueue((n,t-q))\n\n        clock+=q\n\n\n\nfor p in done:\n\n    print(p[0],p[1])", "generated_code": "class Queue:\n\n    def __init__(self,l):\n\n        self.values = []\n\n        self.l = l\n\n        for _ in range(l):\n\n            self.values.append(None)\n\n        self.head = 0\n\n        self.tail = 0\n\n    def inc(self,n):\n\n        if n+1 >= self.l:\n\n            return 0\n\n        else:\n\n            return n+1\n\n    def enqueue(self,v):\n\n        if self.inc(self.head) == self.tail:\n\n            print('overflow')\n\n            exit()\n\n        self.values[self.head] = v\n\n        self.head = self.inc(self.head)\n\n    def dequeue(self):\n\n        if self.head == self.tail:\n\n            print('underflow')\n\n            exit()\n\n        v = self.values[self.tail]\n\n        self.tail = self.inc(self.tail)\n\n        return v\n\n    def size(self):\n\n        if self.head >= self.tail:\n\n            return self.head-self.tail\n\n        else:\n\n            self.head + (self.l-self.tail)\n\n\n\nn,q = list(map(int,input().split(' ')))\n\nqueue = Queue(200000)\n\nfor _ in range(n):\n\n    n,t = input().split(' ')\n\n    t = int(t)\n\n    queue.enqueue((n,t))\n\n\n\nc = 0\n\nwhile queue.size()>0:\n\n    n,t = queue.dequeue()\n\n    if t <= q:\n\n        c += t\n\n        print(n,c)\n\n    else:\n\n        queue.enqueue((n,t-q))\n\n        c += q", "score": 1.0, "surface_similarity": 0.6934056761268781}
{"id": "p03371_u581187895", "golden_code": "A, B, C, X, Y = list(map(int, input().split()))\n\n\n\n# Cを買った個数とA、B単品で買った場合のコストを愚直に試す\n\ntotal = 1<<60\n\nfor i in range(10**5+1):\n\n  cost = 2*C*i + max(X-i, 0)*A + max(Y-i, 0)*B\n\n  total = min(cost, total)\n\n\n\nprint(total)", "generated_code": "A, B, C, X, Y = list(map(int, input().split()))\n\n\n\nif (A+B) <= 2*C: # 単品だけで購入\n\n  print((X*A + Y*B))\n\nelse:\n\n  # ABを買い残りを単品で補う\n\n  if X >= Y:\n\n    # ABでYは賄える\n\n    print((min(X*2*C, Y*2*C + A*(X-Y))))\n\n  else:\n\n    # ABでXは賄える\n\n    print((min(Y*2*C, X*(2*C)+B*(Y-X))))", "score": 1.0, "surface_similarity": 0.6477272727272727}
{"id": "p02690_u709304134", "golden_code": "import sys\n\ninput = sys.stdin.readline\n\nsys.setrecursionlimit(10**7)\n\nINF = 10**10\n\nMOD = 10**9 + 7\n\nX = int(eval(input()))\n\nfor i in range(1000):\n\n    for j in range(-1000,1000):\n\n        #print (i**5 - j**5)\n\n        if i**5 - j**5 == X:\n\n            print((i,j))\n\n            exit()\n\n   ", "generated_code": "import sys\n\ninput = sys.stdin.readline\n\nsys.setrecursionlimit(10**7)\n\nINF = 10**10\n\nMOD = 10**9 + 7\n\nX = int(eval(input()))\n\nMAX_X = 10**9\n\nn = 0\n\nwhile(1):\n\n    n+=1\n\n    if n**5 - (n-1)**5 > MAX_X:\n\n        break\n\nfor i in range(n):\n\n    for j in range(-n+1,n-1):\n\n        if i**5 - j**5 == X:\n\n            print((i,j))\n\n            exit()\n\n   ", "score": 1.0, "surface_similarity": 0.8190306803023566}
{"id": "p02983_u672220554", "golden_code": "l,r = list(map(int,input().split()))\n\n\n\nif r - l > 2019:\n\n    print((0))\n\nelse:\n\n    tres = 2019\n\n    for i in range(l,r):\n\n        for j in range(i+1,r+1):\n\n            mod = (i % 2019) * (j % 2019) % 2019\n\n            tres = min(tres,mod)\n\n    print(tres)\n", "generated_code": "l,r = list(map(int,input().split()))\n\n\n\nif r - l > 2019:\n\n    print((0))\n\nelse:\n\n    tres = 2019\n\n    for i in range(l,r):\n\n        for j in range(i+1,r+1):\n\n            mod = (i % 2019) * (j % 2019) % 2019\n\n            tres = min(tres,mod)\n\n            if tres == 0:\n\n                break\n\n        if tres == 0:\n\n            break\n\n    print(tres)\n", "score": 1.0, "surface_similarity": 0.9038095238095238}
{"id": "p03086_u254871849", "golden_code": "# 2019-11-12 22:21:08(JST)\n\nimport sys\n\n# import collections\n\n# import math\n\n# from string import ascii_lowercase, ascii_uppercase, digits\n\n# from bisect import bisect_left as bi_l, bisect_right as bi_r\n\nimport itertools\n\n# from functools import reduce\n\n# import operator as op\n\n# from scipy.misc import comb # float\n\n# import numpy as np \n\n\n\ndef main():\n\n    s = sys.stdin.readline().rstrip()\n\n    \n\n    all_words = []\n\n    for i in range(1, len(s) + 1):\n\n        for letters in itertools.product('ATCG', repeat=i):\n\n            word = ''.join(letters)\n\n            all_words.append(word)\n\n    \n\n    for i in range(len(all_words)-1, 0-1, -1):\n\n        if all_words[i] in s:\n\n            print((len(all_words[i])))\n\n            sys.exit()\n\n    print((0))\n\n\n\n\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "generated_code": "# 2019-11-12 22:21:08(JST)\n\nimport sys\n\n# import collections\n\n# import math\n\n# from string import ascii_lowercase, ascii_uppercase, digits\n\n# from bisect import bisect_left as bi_l, bisect_right as bi_r\n\n# import itertools\n\n# from functools import reduce\n\n# import operator as op\n\n# from scipy.misc import comb # float\n\n# import numpy as np \n\n\n\ndef main():\n\n    s = sys.stdin.readline().rstrip()\n\n    \n\n    permitted = 'ACGT'\n\n    continuous_count = []\n\n    count = 0\n\n\n\n    for i in range(len(s)):\n\n        char = s[i]\n\n        if char in permitted:\n\n            count += 1\n\n        else:\n\n            continuous_count.append(count)\n\n            count = 0\n\n        if i == len(s) - 1:\n\n            continuous_count.append(count)\n\n    \n\n    if not continuous_count:\n\n        print((len(s)))\n\n    else:\n\n        print((max(continuous_count)))\n\n\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "score": 1.0, "surface_similarity": 0.8026561043802423}
{"id": "p03425_u591503175", "golden_code": "def resolve():\n\n    '''\n\n    code here\n\n    '''\n\n    import collections\n\n    import itertools\n\n    import numpy as np\n\n    N = int(eval(input()))\n\n    Ss = [input()[0] for _ in range(N)]\n\n\n\n    march_letter = [item for item in Ss if item in ['M', 'A', 'R', 'C', 'H']]\n\n    march_cnt = collections.Counter(march_letter)\n\n\n\n    if len(march_cnt) < 3:\n\n        res = 0\n\n    else:\n\n        res_list = itertools.combinations(list(march_cnt.values()),3)\n\n\n\n        res = 0\n\n        for element in res_list:\n\n            res += np.prod(np.array(element))\n\n    print(res)\n\n\n\nif __name__ == \"__main__\":\n\n    resolve()\n", "generated_code": "def resolve():\n\n    '''\n\n    code here\n\n    '''\n\n    import collections\n\n    import itertools\n\n    N = int(eval(input()))\n\n    Ss = [input()[0] for _ in range(N)]\n\n\n\n    march_letter = [item for item in Ss if item in ['M', 'A', 'R', 'C', 'H']]\n\n    march_cnt = collections.Counter(march_letter)\n\n\n\n    if len(march_cnt) < 3:\n\n        res = 0\n\n    else:\n\n        res_list = itertools.combinations(list(march_cnt.values()),3)\n\n\n\n        res = 0\n\n        for element in res_list:\n\n            res += element[0]*element[1]*element[2]\n\n    print(res)\n\n\n\nif __name__ == \"__main__\":\n\n    resolve()\n", "score": 1.0, "surface_similarity": 0.9314449917898193}
{"id": "p03309_u254871849", "golden_code": "#                         author:  kagemeka \n\n#                         created: 2019-11-08 14:51:29(JST)\n\n## internal modules\n\nimport sys\n\n# import collections\n\n# import math\n\n# import string\n\n# import bisect\n\n# import re\n\n# import itertools\n\nimport statistics\n\n# import functools\n\n# import operator\n\n## external modules\n\n# import scipy.special   # if use comb function on AtCoder, \n\n# import scipy.misc      # select scipy.misc.comb (old version) \n\n\n\ndef main():\n\n    n, *a = (int(x) for x in sys.stdin.read().split())\n\n    \n\n    for i in range(n):\n\n        a[i] -= (i + 1)\n\n\n\n    if n % 2 != 0:\n\n        b = statistics.median(a)\n\n    else:\n\n        if a.count(statistics.median_high(a)) >= a.count(statistics.median_low(a)):\n\n            b = statistics.median_high(a)\n\n        else:\n\n            b = statistics.median_low(a)\n\n    \n\n    ans = sum([abs(a[i] - b) for i in range(n)])\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    # execute only if run as a script\n\n    main()\n\n\n\n\n", "generated_code": "import sys\n\n\n\nn, *a = list(map(int, sys.stdin.read().split()))\n\n\n\ndef main():\n\n    for i in range(n):\n\n        a[i] -= (i + 1)\n\n    a.sort()\n\n    b = a[n // 2]\n\n    res = 0\n\n    for i in range(n):\n\n        res += abs(a[i] - b)\n\n    \n\n    return res\n\n    \n\nif __name__ == '__main__':\n\n    ans = main()\n\n    print(ans)", "score": 1.0, "surface_similarity": 0.7541678179976052}
{"id": "p02690_u371409687", "golden_code": "x = int(eval(input()))\n\nfor i in range(-118, 120):\n\n    for j in range(-119, 119):\n\n        if i**5 - j**5 == x:\n\n            print(('{} {}'.format(i,j)))\n\n            break\n\n    else:\n\n        continue\n\n    break", "generated_code": "def make_divisors(n):\n\n    divisors = []\n\n    for i in range(1, int(n**0.5)+1):\n\n        if n % i == 0:\n\n            divisors.append(i)\n\n            if i != n // i:\n\n                divisors.append(n//i)\n\n\n\n    divisors.sort()\n\n    return divisors\n\nx = int(eval(input()))\n\nL = make_divisors(x)\n\nfor i in L:\n\n    for a in range(-118,120):\n\n        if a**5 - (a-i)**5 == x:\n\n            print(('{} {}'.format(a,a-i)))\n\n            break\n\n    else:\n\n        continue\n\n    break", "score": 1.0, "surface_similarity": 0.6401862359959261}
{"id": "p03416_u416758623", "golden_code": "def findSumDigit(num):\n\n    global total\n\n    total = \"\"\n\n    while num > 0:\n\n        total += str(num % 10)\n\n        num //= 10\n\n    return total\n\n\n\ndef main():\n\n    a,b = list(map(int, input().split()))\n\n    ans = 0\n\n    for i in range(a,b+1):\n\n        tmp = str(findSumDigit(i))\n\n        if tmp == str(i):\n\n            ans += 1\n\n    print(ans)\n\n\n\nif __name__ == '__main__':\n\n    main()", "generated_code": "a, b = list(map(int, input().split()))\n\nans = 0\n\n\n\nfor i in range(a,b+1):\n\n    seki_gyaku = str(i)\n\n    if seki_gyaku == seki_gyaku[::-1]:\n\n        ans += 1\n\n\n\nprint(ans)\n", "score": 1.0, "surface_similarity": 0.559106529209622}
{"id": "p03680_u759412327", "golden_code": "N = int(eval(input()))\n\na = [int(eval(input())) for i in range(N)]\n\nnow = a[0]\n\ncount = 1\n\nc = 0\n\nfor i in range(10**6):\n\n    if now != 2:\n\n        count += 1\n\n        now = a[now - 1]\n\n    else:\n\n        print(count)\n\n        c = 1\n\n        break\n\nif c == 0:\n\n    print((-1))\n", "generated_code": "N = int(eval(input()))\n\na = [0] + [int(eval(input())) for _ in range(N)]\n\nx = 1\n\nvisited = set([1])\n\nanswer = 0\n\n\n\nwhile True:\n\n  x = a[x]\n\n  if x in visited:\n\n    answer = -1\n\n    break\n\n  visited.add(x)\n\n  answer += 1\n\n  if x == 2:\n\n    break\n\n    \n\nprint(answer)\n", "score": 1.0, "surface_similarity": 0.6671231171417902}
{"id": "p02690_u620238824", "golden_code": "X = int(eval(input()))#数字\n\n\n\nfor i in range(10 ** 8):\n\n    for j in range(-10000,10 ** 4):\n\n        if i ** 5 - j ** 5 == X:\n\n            print((i, j))\n\n            exit()", "generated_code": "x = int(eval(input()))\n\ny = 10**4\n\n\n\nfor i in range(y):\n\n    for j in range(-y,y):\n\n        if i ** 5 - j ** 5 == x:\n\n            print((i, j))\n\n            exit()", "score": 1.0, "surface_similarity": 0.9269005847953217}
{"id": "p02386_u150984829", "golden_code": "n=int(eval(input()))\n\na=[list(map(int,input().split()))for _ in range(n)]\n\ndef f():\n\n for i in range(n-1):\n\n  d=a[i][:];d[3],d[4]=d[4],d[3]\n\n  for j in range(i+1,n):\n\n   e=a[j][:];e[3],e[4]=e[4],e[3]\n\n   for p in([0,1,2,3,4,5],[1,5,2,0,4,3],[2,1,5,3,0,4],[3,0,2,5,4,1],[4,1,0,3,5,2],[5,1,4,3,2,0]):\n\n    f=[d[k]for k in p]\n\n    if f[0]==e[0]and f[5]==e[5]:\n\n     f=f[1:5]*2\n\n     for k in range(4):\n\n      if f[k:k+4]==e[1:5]:return'No'\n\n return'Yes'\n\nprint((f()))\n", "generated_code": "n=int(eval(input()))\n\na=[[int(s)for s in input().split()]for _ in range(n)]\n\ndef f():\n\n for i in range(n-1):\n\n  d=a[i][:];d[3],d[4]=d[4],d[3]\n\n  for j in range(i+1,n):\n\n   e=a[j][:];e[3],e[4]=e[4],e[3]\n\n   for p in([0,1,2,3,4,5],[1,5,2,0,4,3],[2,1,5,3,0,4],[3,0,2,5,4,1],[4,1,0,3,5,2],[5,1,4,3,2,0]):\n\n    f=[d[k]for k in p]\n\n    if f[0]==e[0]and f[5]==e[5]:\n\n     f=f[1:5]*2\n\n     for k in range(4):\n\n      if f[k:k+4]==e[1:5]:return'No'\n\n return'Yes'\n\nprint((f()))\n", "score": 1.0, "surface_similarity": 0.987152034261242}
{"id": "p03273_u456353530", "golden_code": "import numpy as np\n\nH, W = list(map(int, input().split()))\n\n\n\na = np.array([list(eval(input())) for i in range(H)])\n\n\n\nat = np.all(a == '.', axis = 1)\n\nfor i in reversed(list(range(len(at)))):\n\n  if at[i]:\n\n    a = np.delete(a, i, 0)\n\n\n\nat = np.all(a == '.', axis = 0)\n\nfor i in reversed(list(range(len(at)))):\n\n  if at[i]:\n\n    a = np.delete(a, i, 1)\n\nfor i in a:\n\n  print((''.join(i)))", "generated_code": "H, W = list(map(int, input().split()))\n\n\n\na = [list(eval(input())) for i in range(H)]\n\n\n\nfor i in reversed(list(range(len(a)))):\n\n  if '#' not in a[i]:\n\n    del a[i]\n\n\n\na = list(zip(*a))\n\nfor i in reversed(list(range(len(a)))):\n\n  if '#' not in a[i]:\n\n    del a[i]\n\n\n\na = list(zip(*a))\n\n         \n\nfor i in a:\n\n  print((''.join(i)))", "score": 1.0, "surface_similarity": 0.6849612403100775}
{"id": "p02952_u860002137", "golden_code": "N = int(eval(input()))\n\n\n\nans = 0\n\n\n\nfor i in range(1, N+1):\n\n    if len(str(i))%2==1:\n\n        ans += 1\n\n\n\nprint(ans)", "generated_code": "import sys\n\n\n\n\n\ndef rec(length):\n\n    if length == 1:\n\n        return 9\n\n    else:\n\n        return 9 * 10**(length - 1) + rec(length - 2)\n\n\n\n\n\nn = eval(input())\n\nlength = len(n)\n\n\n\nif length == 1:\n\n    print(n)\n\n    sys.exit()\n\n\n\nif length % 2 == 0:\n\n    ans = rec(length - 1)\n\nelse:\n\n    ans = rec(length - 2) + int(n) - int(\"1\" + \"0\" * (length - 1)) + 1\n\n\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.49687304565353346}
{"id": "p03568_u252828980", "golden_code": "import numpy as np\n\nfrom itertools import product\n\n\n\nn = int(eval(input()))\n\na = list(map(int,input().split()))\n\n\n\na = np.array(a)\n\n\n\nli = [-1,0,1]\n\ncnt = 0\n\nfor v in product(li,repeat = n):\n\n    v = np.array(v)\n\n    L =a+v\n\n    cum = L.cumprod()\n\n    if cum[-1]%2 ==0 :\n\n        cnt +=1\n\nprint(cnt)\n\n        ", "generated_code": "n = int(eval(input()))\n\na = list(map(int,input().split()))\n\n\n\nfrom itertools import product\n\n\n\nli = [-1,0,1]\n\ncnt = 0\n\nfor v in product(li,repeat = n):\n\n    L = []\n\n    for i in range(n):\n\n        L.append(v[i]+a[i])\n\n    if any(x%2==0 for x in L):\n\n        cnt +=1\n\n\n\nprint(cnt)", "score": 1.0, "surface_similarity": 0.7619625520110958}
{"id": "p03425_u761320129", "golden_code": "import itertools\n\nfrom collections import Counter\n\nN = int(eval(input()))\n\nsrc = [eval(input()) for i in range(N)]\n\nctr = Counter()\n\nfor s in src:\n\n    ctr[s[0]] += 1\n\n\n\nans = 0\n\nfor ptn in itertools.combinations('MARCH',3):\n\n    a,b,c = ptn\n\n    ans += ctr[a]*ctr[b]*ctr[c]\n\nprint(ans)", "generated_code": "N = int(eval(input()))\n\nS = [eval(input()) for i in range(N)]\n\nfrom collections import Counter\n\nctr = Counter([s[0] for s in S])\n\n\n\nans = 0\n\nimport itertools\n\nfor ptn in itertools.combinations('MARCH', 3):\n\n    t = 1\n\n    for c in ptn:\n\n        t *= ctr[c]\n\n    ans += t\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.7220279720279721}
{"id": "p02952_u047102107", "golden_code": "N = int(eval(input()))\n\n\n\ncount = 0\n\nfor i in range(1, N + 1):\n\n    num_dig = 0\n\n    ii = i\n\n    while ii > 0:\n\n        ii = int(ii / 10)\n\n        num_dig += 1\n\n    if num_dig % 2 != 0:\n\n        count += 1\n\n\n\nprint(count)", "generated_code": "N = int(eval(input()))\n\n\n\ncount = 0\n\nfor i in range(1, N + 1):\n\n    if len(str(i)) % 2 != 0:\n\n        count += 1\n\nprint(count)", "score": 1.0, "surface_similarity": 0.7988806858775899}
{"id": "p02801_u372550522", "golden_code": "from string import ascii_lowercase as lower\n\nprint((lower[lower.find(eval(input()))+1]))", "generated_code": "print((chr(ord(eval(input()))+1)))", "score": 1.0, "surface_similarity": 0.5122377622377623}
{"id": "p03575_u759412327", "golden_code": "from scipy.sparse import *\n\nN,M,*A=list(map(int,open(0).read().split()));g=csr_matrix(([1]*M,(A[::2],A[1::2])),shape=(N+1,N+1)).tolil()\n\nc = 0\n\n\n\nfor a,b in zip(*g.nonzero()):\n\n  g[a,b]=0\n\n  n,_=csgraph.connected_components(g)\n\n  c+=n!=2\n\n  g[a,b]=1\n\n\n\nprint(c)", "generated_code": "N,M=list(map(int,input().split()))\n\nedges=[list(map(int,input().split())) for i in range(M)]\n\nans=0\n\nfor x in edges:\n\n    l=list(range(N))\n\n    for y in edges:\n\n        if y!=x:l=[l[y[0]-1] if l[i]==l[y[1]-1] else l[i] for i in range(N)]\n\n    if len(set(l))!=1:ans+=1\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.456989247311828}
{"id": "p03634_u585482323", "golden_code": "#!usr/bin/env python3\n\nfrom collections import defaultdict\n\nfrom collections import deque\n\nfrom heapq import heappush, heappop\n\nimport sys\n\nimport math\n\nimport bisect\n\nimport random\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\n\ndef I(): return int(sys.stdin.readline())\n\ndef LS():return list(map(list, sys.stdin.readline().split()))\n\ndef S(): return list(sys.stdin.readline())[:-1]\n\ndef IR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = I()\n\n    return l\n\ndef LIR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = LI()\n\n    return l\n\ndef SR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = S()\n\n    return l\n\ndef LSR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = SR()\n\n    return l\n\nmod = 1000000007\n\n\n\n#A\n\n\"\"\"\n\ndef gcd(a,b):\n\n    if a == 0:\n\n        return b\n\n    return gcd(b%a,a)\n\nn = I()\n\na = IR(n)\n\nl = a[0]\n\nfor i in range(1,n):\n\n    g = gcd(l,a[i])\n\n    l *= a[i]//g\n\nprint(l)\n\n\"\"\"\n\n\n\n#B\n\nn = I()\n\nv = [[] for i in range(n)]\n\nfor i in range(n-1):\n\n    a,b,c = LI()\n\n    a -= 1\n\n    b -= 1\n\n    v[a].append([b,c])\n\n    v[b].append([a,c])\n\nQ,k = LI()\n\nd = [-1 for i in range(n)]\n\nd[k-1] = 0\n\nq = deque()\n\nq.append(k-1)\n\nwhile q:\n\n    x = q.pop()\n\n    for y,c in v[x]:\n\n        if d[y] == -1:\n\n            d[y] = d[x]+c\n\n            q.append(y)\n\nfor i in range(Q):\n\n    x,y = LI()\n\n    x -= 1\n\n    y -= 1\n\n    print((d[x]+d[y]))\n\n#C\n\n\n\n#D\n\n\n\n#E\n\n\n\n#F\n\n\n\n#G\n\n\n\n#H\n\n\n\n#I\n\n\n\n#J\n\n\n\n#K\n\n\n\n#L\n\n\n\n#M\n\n\n\n#N\n\n\n\n#O\n\n\n\n#P\n\n\n\n#Q\n\n\n\n#R\n\n\n\n#S\n\n\n\n#T\n", "generated_code": "#!usr/bin/env python3\n\nfrom collections import defaultdict\n\nfrom collections import deque\n\nfrom heapq import heappush, heappop\n\nimport sys\n\nimport math\n\nimport bisect\n\nimport random\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\n\ndef I(): return int(sys.stdin.readline())\n\ndef LS():return list(map(list, sys.stdin.readline().split()))\n\ndef S(): return list(sys.stdin.readline())[:-1]\n\ndef IR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = I()\n\n    return l\n\ndef LIR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = LI()\n\n    return l\n\ndef SR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = S()\n\n    return l\n\ndef LSR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = SR()\n\n    return l\n\nmod = 1000000007\n\n\n\n#A\n\n\"\"\"\n\ndef gcd(a,b):\n\n    if a == 0:\n\n        return b\n\n    return gcd(b%a,a)\n\nn = I()\n\na = IR(n)\n\nl = a[0]\n\nfor i in range(1,n):\n\n    g = gcd(l,a[i])\n\n    l *= a[i]//g\n\nprint(l)\n\n\"\"\"\n\n\n\n#B\n\nn = I()\n\nv = [[] for i in range(n)]\n\nfor i in range(n-1):\n\n    a,b,c = LI()\n\n    a -= 1\n\n    b -= 1\n\n    v[a].append([b,c])\n\n    v[b].append([a,c])\n\nQ,k = LI()\n\nd = [-1 for i in range(n)]\n\nd[k-1] = 0\n\nq = deque()\n\nq.append(k-1)\n\nwhile q:\n\n    x = q.popleft()\n\n    for y,c in v[x]:\n\n        if d[y] == -1:\n\n            d[y] = d[x]+c\n\n            q.append(y)\n\nfor i in range(Q):\n\n    x,y = LI()\n\n    x -= 1\n\n    y -= 1\n\n    print((d[x]+d[y]))\n\n#C\n\n\n\n#D\n\n\n\n#E\n\n\n\n#F\n\n\n\n#G\n\n\n\n#H\n\n\n\n#I\n\n\n\n#J\n\n\n\n#K\n\n\n\n#L\n\n\n\n#M\n\n\n\n#N\n\n\n\n#O\n\n\n\n#P\n\n\n\n#Q\n\n\n\n#R\n\n\n\n#S\n\n\n\n#T\n", "score": 1.0, "surface_similarity": 0.9987021414665802}
{"id": "p02837_u764860452", "golden_code": "from itertools import product\n\nN=int(eval(input()))\n\ndata=[]\n\nfor i in range(N):\n\n    for j in range(int(eval(input()))):\n\n        x,y=list(map(int,input().split()))\n\n        data.append((i,x-1,y))\n\n#print(data)\n\n\n\nans=0\n\nfor i in product([1,0],repeat=N):\n\n    #print(i)\n\n    s=True\n\n    for k in data:\n\n        if i[k[0]]==1 and i[k[1]]!=k[2]:\n\n            s=False\n\n            break\n\n    if s:\n\n        ans=max(ans,sum(i))\n\nprint(ans)\n", "generated_code": "from itertools import product\n\n\n\nN=int(eval(input()))\n\ndata=[]\n\nfor i in range(N):\n\n    for j in range(int(eval(input()))):\n\n        x,y=list(map(int,input().split()))\n\n        data.append((i,x-1,y)) #iさんがx-1さんに嘘(0)or正直(1)\n\n\n\n\n\nans=0\n\nfor i in product([0,1],repeat=N):\n\n    ok=True\n\n    for j in data:\n\n        if i[j[0]]==1 and i[j[1]]!=j[2]:\n\n            ok = False\n\n            break\n\n    if ok:\n\n        ans=max(ans,sum(i))\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.9863325740318907}
{"id": "p04012_u419874471", "golden_code": "import string\n\nw = eval(input())\n\nfor a in string.ascii_lowercase:\n\n    cnt = 0\n\n    for t in w:\n\n        if t == a:\n\n            cnt = cnt + 1\n\n    if cnt % 2 == 1:\n\n        print(\"No\")\n\n        exit()\n\n\n\nprint(\"Yes\")", "generated_code": "w = eval(input())\n\nm = [0] * 26\n\nfor t in w:\n\n    m[ord(t) - ord('a')] += 1\n\n\n\nfor cnt in m:\n\n    if cnt % 2 == 1:\n\n        print(\"No\")\n\n        exit()\n\n\n\nprint(\"Yes\")", "score": 1.0, "surface_similarity": 0.6611238532110092}
{"id": "p03013_u133936772", "golden_code": "mod = 10**9+7\n\nn, m = list(map(int, input().split()))\n\nl = [0]*n\n\nfor _ in range(m):\n\n  l[int(eval(input()))-1] = 1\n\n\n\ns = 0\n\nt = 1\n\n\n\nfor i in range(n):\n\n  if l[i] > 0:\n\n    t, s = 0, t\n\n  else:\n\n    t, s = (s+t)%mod, t\n\n\n\nprint(t)", "generated_code": "import sys\n\ninput = sys.stdin.readline\n\n\n\nmod = 10**9+7\n\nn, m = list(map(int, input().split()))\n\nl = [0]*n\n\nfor _ in range(m):\n\n  l[int(eval(input()))-1] = 1\n\n\n\nt, s = 1, 0\n\n\n\nfor i in range(n):\n\n  if l[i]:\n\n    t, s = 0, t\n\n  else:\n\n    t, s = (s+t)%mod, t\n\n\n\nprint(t)", "score": 1.0, "surface_similarity": 0.8382156133828996}
{"id": "p03774_u911856499", "golden_code": "N,M = [int(c) for c in input().split()]\n\nab = [list(map(int,input().split())) for c in range(N)]\n\ncd = [list(map(int,input().split())) for c in range(M)]\n\nfor i in range(N):\n\n    mi = 2*10**9\n\n    for j in range(M):\n\n        tmp = abs(ab[i][0]-cd[j][0])+abs(ab[i][1]-cd[j][1])\n\n        if mi > tmp:\n\n            mi = tmp\n\n            ans = j+1\n\n    print(ans)\n", "generated_code": "N,M = [int(c) for c in input().split()]\n\nab = [list(map(int,input().split())) for c in range(N)]\n\ncd = [list(map(int,input().split())) for c in range(M)]\n\nfor i in range(N):\n\n    mi = 10**9\n\n    for j in range(M):\n\n        tmp = abs(ab[i][0]-cd[j][0])+abs(ab[i][1]-cd[j][1])\n\n        if mi > tmp:\n\n            mi = tmp\n\n            ans = j+1\n\n    print(ans)\n", "score": 1.0, "surface_similarity": 0.9754830917874396}
{"id": "p02690_u638456847", "golden_code": "from bisect import bisect_right\n\nimport sys\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\nreadlines = sys.stdin.readlines\n\n\n\ndef main():\n\n    x = int(readline())\n\n\n\n    for a in range(-120, 120):\n\n        for b in range(-120, 120):\n\n            if a**5 - b**5 == x:\n\n                print((a, b))\n\n                exit()\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "generated_code": "# AC: 33 msec(Python3)\n\nfrom itertools import combinations_with_replacement\n\nimport sys\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\nreadlines = sys.stdin.readlines\n\n\n\ndef main():\n\n    x = int(readline())\n\n\n\n    ab = [i**5 for i in range(200)]\n\n\n\n    C = combinations_with_replacement(ab, 2)\n\n    for a, b in C:\n\n        if a + b == x:\n\n            print((int(pow(b, 0.2)), -int(pow(a, 0.2))))\n\n            break\n\n        \n\n        if b - a == x:\n\n            print((int(pow(b, 0.2)), int(pow(a, 0.2))))\n\n            break\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "score": 1.0, "surface_similarity": 0.7786580836840802}
{"id": "p03416_u187857228", "golden_code": "def test():\n\n    a,b = list(map(int,input().split()))\n\n    count = 0\n\n    for i in range(a,b+1):\n\n        j = list(map(int,list(str(i))))\n\n        if j[0] == j[4] and j[1] == j[3]:\n\n            count += 1\n\n    print(count)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    test()\n", "generated_code": "def test():\n\n    a,b = list(map(int,input().split()))\n\n    count = 0\n\n    for i in range(a,b+1):\n\n        if str(i)[0] == str(i)[4] and str(i)[1] == str(i)[3]:\n\n            count += 1\n\n    print(count)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    test()\n", "score": 1.0, "surface_similarity": 0.9250936329588015}
{"id": "p02725_u285891772", "golden_code": "import sys, re\n\nfrom collections import deque, defaultdict, Counter\n\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, radians\n\nfrom itertools import accumulate, permutations, combinations, product, groupby\n\nfrom operator import itemgetter, mul\n\nfrom copy import deepcopy\n\nfrom string import ascii_lowercase, ascii_uppercase, digits\n\nfrom bisect import bisect, bisect_left\n\nfrom fractions import gcd\n\nfrom heapq import heappush, heappop\n\nfrom functools import reduce\n\ndef input(): return sys.stdin.readline().strip()\n\ndef INT(): return int(eval(input()))\n\ndef MAP(): return list(map(int, input().split()))\n\ndef LIST(): return list(map(int, input().split()))\n\ndef ZIP(n): return list(zip(*(MAP() for _ in range(n))))\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = float('inf')\n\nmod = 10 ** 9 + 7\n\nimport numpy as np\n\n\n\nK, N = MAP()\n\nA = LIST()\n\nA.append(A[0]+K)\n\n\n\nB = np.zeros(N)\n\nfor i in range(N):\n\n  \t\tB[i] = A[i+1] - A[i]\n\n\n\nprint((int(K - max(B))))", "generated_code": "import sys, re\n\nfrom collections import deque, defaultdict, Counter\n\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, radians\n\nfrom itertools import accumulate, permutations, combinations, product, groupby\n\nfrom operator import itemgetter, mul\n\nfrom copy import deepcopy\n\nfrom string import ascii_lowercase, ascii_uppercase, digits\n\nfrom bisect import bisect, bisect_left\n\nfrom fractions import gcd\n\nfrom heapq import heappush, heappop\n\nfrom functools import reduce\n\ndef input(): return sys.stdin.readline().strip()\n\ndef INT(): return int(eval(input()))\n\ndef MAP(): return list(map(int, input().split()))\n\ndef LIST(): return list(map(int, input().split()))\n\ndef ZIP(n): return list(zip(*(MAP() for _ in range(n))))\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = float('inf')\n\nmod = 10 ** 9 + 7\n\n\n\nK, N = MAP()\n\nA = LIST()\n\ndiff = abs(K - A[-1] + A[0])\n\nd = abs(K - A[-1] + A[0])\n\nif N == 2:\n\n  print((min(d, A[1] - A[0])))\n\n  exit()\n\nfor i in range(1, N):\n\n  d += abs(A[i] - A[i-1])\n\n  diff = max(diff, abs(A[i] - A[i-1]))\n\nprint((d - diff))", "score": 1.0, "surface_similarity": 0.8430622009569377}
{"id": "p02821_u906428167", "golden_code": "from bisect import bisect_left\n\nfrom bisect import bisect_right\n\n\n\nn,m = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\na = sorted(a)\n\n\n\na_count = [0]*100010\n\na_sum = [0]*100010\n\n\n\nfor i in range(n):\n\n    a_count[a[i]] += 1\n\n    a_sum[a[i]] += a[i]\n\n\n\nfor i in range(100005,-1,-1):\n\n    a_count[i] += a_count[i+1]\n\n    a_sum[i] += a_sum[i+1]\n\n\n\ndef chk(x):\n\n    case = 0\n\n    for i in range(n):\n\n        if 0<= x-a[i]<= 10**5+5:\n\n            case += a_count[x-a[i]]\n\n        elif x-a[i] < 0:\n\n            case += n\n\n    if case >= m:\n\n        ch = True\n\n    else:\n\n        ch = False\n\n    return ch\n\n\n\nl = 2*a[-1]+1    #NG\n\nr = 1 #OK\n\n\n\nwhile abs(r-l) > 1:\n\n    kk = (r+l)//2\n\n    if chk(kk):\n\n        r = kk\n\n    else:\n\n        l = kk\n\n\n\nans = 0\n\nsm = sum(a)\n\n\n\nl = r\n\n\n\ncase = 0\n\nfor i in range(n):\n\n    num = n-bisect_right(a,l-a[i]-1)\n\n    case += num\n\n    ans += num*a[i]*2\n\n\n\nans -= (case-m)*l\n\n\n\nprint(ans)", "generated_code": "n, m = list(map(int, input().split()))\n\na = [int(x) for x in input().split()]\n\n\n\naa = [0]*(10**5+1)\n\naa_sum = [0]*(10**5+1)\n\n\n\nfor x in a:\n\n    aa[x] += 1\n\n    aa_sum[x] += x\n\n\n\nfor i in range(10**5)[::-1]:\n\n    aa[i] = aa[i] + aa[i+1]\n\n    aa_sum[i] = aa_sum[i] + aa_sum[i+1]\n\n\n\n\n\ndef count(x):\n\n    cnt = 0\n\n    sm = 0\n\n    for i in range(n):\n\n        if x-a[i] < 0:\n\n            cnt += n\n\n            sm += aa_sum[0]+n*a[i]\n\n        elif x-a[i] > 10**5:\n\n            continue\n\n        else:\n\n            cnt += aa[x-a[i]]\n\n            sm += aa_sum[x-a[i]]+aa[x-a[i]]*a[i]\n\n\n\n    return cnt, sm\n\n\n\n\n\nbottom = 0\n\ntop = 10**6\n\n\n\nwhile top - bottom > 1:\n\n    mid = (top+bottom) // 2\n\n    cnt, sm = count(mid)\n\n    if cnt < m:\n\n        top = mid\n\n    else:\n\n        bottom = mid\n\n\n\ncnt, sm = count(bottom)\n\nans = sm - (cnt-m)*bottom\n\n\n\nprint(ans)\n", "score": 1.0, "surface_similarity": 0.6836538461538462}
{"id": "p03548_u624475441", "golden_code": "X, Y, Z = list(map(int, input().split()))\n\nfor n in range(10 ** 5, 0, -1):\n\n    if X >= n * (Y + Z) + Z:\n\n        break\n\nprint(n)", "generated_code": "X, Y, Z = list(map(int, input().split()))\n\nprint(((X - Z) // (Y + Z)))", "score": 1.0, "surface_similarity": 0.5724637681159421}
{"id": "p02576_u465961647", "golden_code": "array = list(map(int, input().split()))\n\nif array[0] % array[1] > 0:\n\n    print(((array[0] // array[1] + 1) * array[2]))\n\nelse:\n\n    print(((array[0] // array[1]) * array[2]))", "generated_code": "n, x, t = list(map(int, input().split()))\n\n\n\nprint((0--n//x*t))", "score": 1.0, "surface_similarity": 0.47801242236024843}
{"id": "p02268_u153665391", "golden_code": "N = int(eval(input()))\n\nS = list(map(int, input().split()))\n\nQ = int(eval(input()))\n\nT = list(map(int, input().split()))\n\n\n\ndef binary_search(target_num, head, tail):\n\n    idx = int((head+tail)/2)\n\n    if target_num == S[idx]:\n\n        return True\n\n    elif target_num < S[idx]:\n\n        if head == idx:\n\n            return False\n\n        return binary_search(target_num, head, idx-1)\n\n    else:\n\n        if tail == idx:\n\n            return False\n\n        return binary_search(target_num, idx+1, tail)\n\n\n\n\n\nmatch_count = 0\n\nfor target_num in T:\n\n    if binary_search(target_num, 0, len(S)-1):\n\n        match_count += 1\n\n\n\nprint((str(match_count)))\n", "generated_code": "N = int(eval(input()))\n\nS = list(map(int, input().split()))\n\nQ = int(eval(input()))\n\nT = list(map(int, input().split()))\n\n\n\ndef binary_search(target_num, head, tail):\n\n    while head <= tail:\n\n        idx = int((head+tail)/2)\n\n        if target_num == S[idx]:\n\n            return True\n\n        elif target_num < S[idx]:\n\n            tail = idx - 1\n\n        else:\n\n            head = idx + 1\n\n    return False\n\n\n\n\n\nmatch_count = 0\n\nfor target_num in T:\n\n    if binary_search(target_num, 0, len(S)-1):\n\n        match_count += 1\n\n\n\nprint((str(match_count)))\n", "score": 1.0, "surface_similarity": 0.8649691358024691}
{"id": "p03796_u924353076", "golden_code": "n=eval(input())\n\nn=int(n)\n\na=1\n\nfor i in range(n):\n\n    a=a*(i+1)\n\n    if a>=pow(10,9)+7:\n\n        a=a%(pow(10,9)+7)\n\nprint(a)", "generated_code": "n=int(eval(input()))\n\na=1\n\nfor i in range(1,n+1):\n\n    a*=i\n\n    a %= (10**9+7)\n\nprint(a)", "score": 1.0, "surface_similarity": 0.6746031746031746}
{"id": "p02537_u724687935", "golden_code": "class SegmentTree():\n\n    \"\"\"\n\n    update, get を提供するSegmentTree\n\n\n\n    Attributes\n\n    ----------\n\n    __n : int\n\n        葉の数。2 ^ i - 1\n\n    __dot :\n\n        Segment function\n\n    __e: int\n\n        単位元\n\n    __node: list\n\n        Segment Tree\n\n    \"\"\"\n\n    def __init__(self, A, dot, e):\n\n        \"\"\"\n\n        Parameters\n\n        ----------\n\n        A : list\n\n            対象の配列\n\n        dot :\n\n            Segment function\n\n        e : int\n\n            単位元\n\n        \"\"\"\n\n        n = 2 ** (len(A) - 1).bit_length()\n\n        self.__n = n\n\n        self.__dot = dot\n\n        self.__e = e\n\n        self.__node = [e] * (2 * n)\n\n        for i in range(len(A)):\n\n            self.__node[i + n] = A[i]\n\n        for i in range(n - 1, 0, -1):\n\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[2 * i + 1])\n\n    \n\n    def update(self, i, c):\n\n        i += self.__n\n\n        node = self.__node\n\n        node[i] = c\n\n        while i > 1:\n\n            i //= 2\n\n            node[i] = self.__dot(node[2 * i], node[2 * i + 1])\n\n\n\n    def get(self, l, r):\n\n        vl, vr = self.__e, self.__e\n\n        l += self.__n\n\n        r += self.__n\n\n        while (l < r):\n\n            if l & 1:\n\n                vl = self.__dot(vl, self.__node[l])\n\n                l += 1\n\n            l //= 2\n\n            if r & 1:\n\n                r -= 1\n\n                vr = self.__dot(vr, self.__node[r])\n\n            r //= 2\n\n        return self.__dot(vl, vr)\n\n\n\n\n\nN, K = list(map(int, input().split()))\n\nA = [int(eval(input())) for _ in range(N)]\n\nmax_A = max(A)\n\n\n\nst = SegmentTree([N] * (max_A + 1), min, N)\n\nedge = [set() for _ in range(N)]\n\nfor i, a in enumerate(reversed(A)):\n\n    j = N - 1 - i\n\n    p1 = st.get(a, min(max_A + 1, a + K + 1))\n\n    if p1 < N:\n\n        edge[j].add(p1)\n\n    p2 = st.get(max(0, a - K), a)\n\n    if p2 < N:\n\n        edge[j].add(p2)\n\n    p0 = st.get(a, a + 1)\n\n    if p0 < N:\n\n        edge[j].add(p0)\n\n    st.update(a, j)\n\n\n\ndp = [1] * N\n\nfor i in range(N - 1):\n\n    here = dp[i]\n\n    for ni in edge[i]:\n\n        if ni < N:\n\n            dp[ni] = max(dp[ni], dp[i] + 1)\n\n\n\nprint((max(dp)))\n", "generated_code": "class SegmentTree():\n\n    \"\"\"\n\n    update, get を提供するSegmentTree\n\n\n\n    Attributes\n\n    ----------\n\n    __n : int\n\n        葉の数。2 ^ i - 1\n\n    __dot :\n\n        Segment function\n\n    __e: int\n\n        単位元\n\n    __node: list\n\n        Segment Tree\n\n    \"\"\"\n\n    def __init__(self, A, dot, e):\n\n        \"\"\"\n\n        Parameters\n\n        ----------\n\n        A : list\n\n            対象の配列\n\n        dot :\n\n            Segment function\n\n        e : int\n\n            単位元\n\n        \"\"\"\n\n        n = 2 ** (len(A) - 1).bit_length()\n\n        self.__n = n\n\n        self.__dot = dot\n\n        self.__e = e\n\n        self.__node = [e] * (2 * n)\n\n        for i in range(len(A)):\n\n            self.__node[i + n] = A[i]\n\n        for i in range(n - 1, 0, -1):\n\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[2 * i + 1])\n\n    \n\n    def update(self, i, c):\n\n        i += self.__n\n\n        node = self.__node\n\n        node[i] = c\n\n        while i > 1:\n\n            i //= 2\n\n            node[i] = self.__dot(node[2 * i], node[2 * i + 1])\n\n\n\n    def get(self, l, r):\n\n        vl, vr = self.__e, self.__e\n\n        l += self.__n\n\n        r += self.__n\n\n        while (l < r):\n\n            if l & 1:\n\n                vl = self.__dot(vl, self.__node[l])\n\n                l += 1\n\n            l //= 2\n\n            if r & 1:\n\n                r -= 1\n\n                vr = self.__dot(vr, self.__node[r])\n\n            r //= 2\n\n        return self.__dot(vl, vr)\n\n\n\n\n\nN, K = list(map(int, input().split()))\n\nA = [int(eval(input())) for _ in range(N)]\n\nmax_A = max(A)\n\n\n\nst = SegmentTree([N] * (max_A + 1), min, N)\n\nedge = [set() for _ in range(N)]\n\nfor i, a in enumerate(reversed(A)):\n\n    j = N - 1 - i\n\n    p1 = st.get(a, min(max_A + 1, a + K + 1))\n\n    if p1 < N:\n\n        edge[j].add(p1)\n\n    p2 = st.get(max(0, a - K), a)\n\n    if p2 < N:\n\n        edge[j].add(p2)\n\n    st.update(a, j)\n\n\n\ndp = [1] * N\n\nfor i in range(N - 1):\n\n    here = dp[i]\n\n    for ni in edge[i]:\n\n        if ni < N:\n\n            dp[ni] = max(dp[ni], dp[i] + 1)\n\n\n\nprint((max(dp)))\n", "score": 1.0, "surface_similarity": 0.9902520209224916}
{"id": "p00003_u935184340", "golden_code": "import sys\n\nr = []\n\nn = int(eval(input()))\n\nl = sys.stdin.readlines()\n\nfor i in l:\n\n  x, y, z = sorted([x*x for x in list(map(int, i.split()))])\n\n  if x + y == z:\n\n      print(\"YES\")\n\n  else:\n\n      print(\"NO\")", "generated_code": "import sys\n\n\n\nn = int(input())\n\nl = sys.stdin.readlines()\n\ns = \"\"\n\nfor i in l:\n\n  x, y, z = sorted(map(lambda x:x*x,map(int, i.split())))\n\n  if x + y == z:\n\n      s += \"YES\\n\"\n\n  else:\n\n      s += \"NO\\n\"\n\n\n\nprint(s,end=\"\")\n", "score": 1.0, "surface_similarity": 0.7195648563361567}
{"id": "p03086_u887207211", "golden_code": "import re\n\nptn = re.compile(r\"(A|C|G|T)*\")\n\n\n\nS = eval(input())\n\n\n\nans = 0\n\nfor i in range(len(S)):\n\n  for j in range(len(S)):\n\n    x = ptn.match(S[i:i+j+1]).group(0)\n\n    if(x):\n\n      ans = max(ans, len(x))\n\nprint(ans)", "generated_code": "import sys\n\n\n\nstdin = sys.stdin\n\n\n\nns = lambda : stdin.readline().rstrip()\n\nni = lambda : int(ns())\n\nna = lambda : list(map(int, stdin.readline().split()))\n\nsys.setrecursionlimit(10 ** 7)\n\n\n\ndef check(In):\n\n    return In != \"A\" and In != \"C\" and In != \"G\" and In != \"T\"\n\n\n\ndef main():\n\n    s = ns()\n\n\n\n    count = 0\n\n    ans = 0\n\n    for i in range(len(s)):\n\n        if check(s[i]):\n\n            count = 0\n\n        else:\n\n            count += 1\n\n            ans = max(ans, count)\n\n    print(ans)\n\n\n\nif __name__ == '__main__':\n\n    main()", "score": 1.0, "surface_similarity": 0.5050279329608939}
{"id": "p03371_u489959379", "golden_code": "a, b, c, x, y = list(map(int, input().split()))\n\nab = c * 2\n\n\n\nres = float(\"inf\")\n\nif a + b <= ab:\n\n    res = x * a + y * b\n\nelse:\n\n    if x == y:\n\n        res = x * ab\n\n    elif x > y:\n\n        for i in range(y, x + 1):\n\n            cost = i * ab + (x - i) * a\n\n            res = min(res, cost)\n\n    else:\n\n        for i in range(x, y + 1):\n\n            cost = i * ab + (y - i) * b\n\n            res = min(res, cost)\n\nprint(res)\n", "generated_code": "import sys\n\n\n\nsys.setrecursionlimit(10 ** 7)\n\ninput = sys.stdin.readline\n\nf_inf = float('inf')\n\nmod = 10 ** 9 + 7\n\n\n\n\n\ndef resolve():\n\n    a, b, c, x, y = list(map(int, input().split()))\n\n    c *= 2\n\n    if a + b > c:\n\n        cost1 = max(x, y) * c\n\n        cost2 = min(x, y) * c\n\n        plus = ((y - x) * b) if x < y else (x - y) * a\n\n        res = min(cost1, cost2 + plus)\n\n    else:\n\n        res = x * a + y * b\n\n    print(res)\n\n\n\nif __name__ == '__main__':\n\n    resolve()\n", "score": 1.0, "surface_similarity": 0.5709044624138964}
{"id": "p03371_u243699903", "golden_code": "a,b,c,x,y=list(map(int,input().split()))\n\n\n\nans=a*x+b*y\n\nfor ci in range(max(x,y)+1):\n\n    sumc = 2*ci*c\n\n    sumc += (x-ci)*a if (x-ci)>0 else 0\n\n    sumc += (y-ci)*b if (y-ci)>0 else 0\n\n    ans=min(ans,sumc)\n\n\n\nprint(ans)", "generated_code": "a,b,c,x,y=list(map(int,input().split()))\n\nans=a*x+b*y\n\nif x==y:\n\n    ans=min(ans,2*x*c)\n\nelif x>y:\n\n    ans=min(ans,a*(x-y)+2*y*c)\n\n    ans=min(ans,2*x*c)\n\nelse:\n\n    ans=min(ans,b*(y-x)+2*x*c)\n\n    ans=min(ans,2*y*c)\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.6735288001663547}
{"id": "p01105_u260980560", "golden_code": "a=65280; b=61680; c=52428; d=43690; e=65535\n\nfrom heapq import heappush, heappop\n\nbase = [a, b, c, d, e, 0]\n\nQ = [(1, el) for el in base]\n\nL = {el: 1 for el in base}\n\nH = []\n\nget = L.get\n\npush = H.append\n\nwhile Q:\n\n    l, p = heappop(Q)\n\n    if L[p] < l: continue\n\n    if l+1 < get(p ^ e, 17):\n\n        L[p ^ e] = l+1\n\n        if l+1 < 16: heappush(Q, (l+1, p ^ e))\n\n    if l+3 < 16:\n\n        for q, r in H:\n\n            if l+r+3 <= 16:\n\n                if l+r+3 < get(p & q, 17):\n\n                    L[p & q] = l+r+3\n\n                    if l+r+3 < 16: heappush(Q, (l+r+3, p & q))\n\n                if l+r+3 < get(p ^ q, 17):\n\n                    L[p ^ q] = l+r+3\n\n                    if l+r+3 < 16: heappush(Q, (l+r+3, p ^ q))\n\n            else: break\n\n    if l < 7: push((p, l))\n\nprint(*map(L.__getitem__, eval(\"e&%s\"%\",e&\".join(open(0).read().replace(*\"-~\").replace(*\"*&\").replace(*\"1e\").split()[:-1]))),sep='\\n')\n", "generated_code": "a=65280; b=61680; c=52428; d=43690; e=65535\n\nfrom heapq import heappush, heappop\n\nQ = [(1, a), (1, b), (1, c), (1, d)]\n\nL = {a: 1, b: 1, c: 1, d: 1, e: 1, e: 1, 0: 1}\n\nH = []\n\nget = L.get\n\npush = H.append\n\nwhile Q:\n\n    l, p = heappop(Q)\n\n    if L[p] < l: continue\n\n    if l+1 < get(p ^ e, 17):\n\n        L[p ^ e] = l+1\n\n        l < 15 and heappush(Q, (l+1, p ^ e))\n\n    if l < 13:\n\n        li = 13-l; l3 = 3+l\n\n        for q, r in H:\n\n            if r <= li:\n\n                k = p & q\n\n                if r < get(k, 17)-l3:\n\n                    L[k] = l3+r\n\n                    r < li and heappush(Q, (l3+r, k))\n\n                k = p ^ q\n\n                if r < get(k, 17)-l3:\n\n                    L[k] = l3+r\n\n                    r < li and heappush(Q, (l3+r, k))\n\n            else: break\n\n    if l < 7: push((p, l))\n\nprint(*map(L.__getitem__, eval(\"e&\"+\",e&\".join(open(0).read().replace(*\"-~\").replace(*\"*&\").replace(*\"1e\").split()[:-1]))),sep='\\n')\n", "score": 1.0, "surface_similarity": 0.8171907756813417}
{"id": "p03273_u940568210", "golden_code": "import numpy as np\n\n\n\nh, w = tuple(map(int, input().split()))\n\nmatrix = np.zeros((h, w), dtype=bool)\n\nfor i in range(h):\n\n    row = np.array(list(input()))\n\n    matrix[i, :] = row == \".\"\n\n\n\nfor i in range(h)[::-1]:\n\n    if np.all(matrix[i, :]):\n\n        matrix = np.delete(matrix, i, 0)\n\n\n\nfor i in range(w)[::-1]:\n\n    if np.all(matrix[:, i]):\n\n        matrix = np.delete(matrix, i, 1)\n\n\n\nmatrix = np.where(matrix, \".\", \"#\")\n\nfor row in matrix:\n\n    for e in row:\n\n        print(e, end=\"\")\n\n    print()\n", "generated_code": "# h wの読み込み\n\nh, w = list(map(int, input().split()))\n\n# 行列作成\n\nmat = [eval(input()) for _ in range(h)]\n\n\n\n# #が含まれていない行を削除\n\n[mat.remove(row) for row in mat[::-1] if (\"#\" not in row)]\n\n# #が含まれている列のインデックスを取得\n\nshowCol = [i for i in range(w) if \"#\" in [row[i] for row in mat]]\n\n\n\n# 表示\n\nprint((\"\\n\".join([\"\".join([row[c] for c in showCol]) for row in mat])))\n", "score": 1.0, "surface_similarity": 0.5383597883597884}
{"id": "p03273_u579699847", "golden_code": "import numpy as np,sys\n\ndef LI(): return list(map(int,sys.stdin.readline().rstrip().split()))\n\ndef S(): return sys.stdin.readline().rstrip()\n\nH,W = LI()\n\na = np.array([[s for s in S()] for _ in range(H)])\n\na = a[(a=='#').any(axis=1)]\n\na = a.T\n\na = a[(a=='#').any(axis=1)]\n\na = a.T.tolist()\n\nfor x in a:\n\n    print(*x,sep='')\n", "generated_code": "import sys\n\ndef LI(): return list(map(int,sys.stdin.readline().rstrip().split()))\n\ndef S(): return sys.stdin.readline().rstrip()\n\nH,W = LI()\n\na = [S() for _ in range(H)]\n\na2,a3 = [],[]\n\nfor x in a:\n\n    if '#' in x:\n\n        a2.append(x)\n\nfor y in zip(*a2):\n\n    if '#' in y:\n\n        a3.append(y)\n\nfor z in zip(*a3):\n\n    print(*z,sep='')\n", "score": 1.0, "surface_similarity": 0.7315359477124184}
{"id": "p04020_u638795007", "golden_code": "def examB():\n\n    N = I(); A = [I() for _ in range(N)]\n\n    ans = 0; cur= 0\n\n    for i in A:\n\n        if i==0:\n\n            ans += cur//2\n\n            cur = 0\n\n        else:\n\n            cur += i\n\n    ans += cur // 2\n\n    print(ans)\n\n    return\n\n\n\nimport sys,copy,bisect,itertools,heapq,math\n\nfrom heapq import heappop,heappush,heapify\n\nfrom collections import Counter,defaultdict,deque\n\ndef I(): return int(sys.stdin.readline())\n\ndef LI(): return list(map(int,sys.stdin.readline().split()))\n\ndef LSI(): return list(map(str,sys.stdin.readline().split()))\n\ndef LS(): return sys.stdin.readline().split()\n\ndef SI(): return sys.stdin.readline().strip()\n\nmod = 10**9 + 7\n\ninf = float('inf')\n\n\n\nif __name__ == '__main__':\n\n    examB()\n", "generated_code": "def examA():\n\n    S = SI()\n\n    if \"W\" in S and not \"E\" in S:\n\n        print(\"No\")\n\n    elif \"E\" in S and not \"W\" in S:\n\n        print(\"No\")\n\n    elif \"N\" in S and not \"S\" in S:\n\n        print(\"No\")\n\n    elif \"S\" in S and not \"N\" in S:\n\n        print(\"No\")\n\n    else:\n\n        print(\"Yes\")\n\n    return\n\n\n\ndef examB():\n\n    N = I()\n\n    A = [I()for _ in range(N)]\n\n    ans = 0\n\n    for i in range(N-1):\n\n        ans += A[i]//2\n\n        if A[i]%2 and A[i+1]>=1:\n\n            ans += 1\n\n            A[i+1] -= 1\n\n    ans += A[N-1]//2\n\n    print(ans)\n\n    return\n\n\n\ndef examC():\n\n    ans = 0\n\n    print(ans)\n\n    return\n\n\n\ndef examD():\n\n    N = I()\n\n    S = [I()for _ in range(N)]\n\n\n\n    ans = 0\n\n    print(ans)\n\n    return\n\n\n\ndef examE():\n\n    ans = 0\n\n    print(ans)\n\n    return\n\n\n\ndef examF():\n\n    ans = 0\n\n    print(ans)\n\n    return\n\n\n\nimport sys,bisect,itertools,heapq,math,random\n\nfrom copy import deepcopy\n\nfrom heapq import heappop,heappush,heapify\n\nfrom collections import Counter,defaultdict,deque\n\ndef I(): return int(sys.stdin.readline())\n\ndef LI(): return list(map(int,sys.stdin.readline().split()))\n\ndef LSI(): return list(map(str,sys.stdin.readline().split()))\n\ndef LS(): return sys.stdin.readline().split()\n\ndef SI(): return sys.stdin.readline().strip()\n\nglobal mod,mod2,inf,alphabet,_ep\n\nmod = 10**9 + 7\n\nmod2 = 998244353\n\ninf = 10**18\n\n_ep = 10**(-12)\n\nalphabet = [chr(ord('a') + i) for i in range(26)]\n\n\n\nsys.setrecursionlimit(10**6)\n\n\n\nif __name__ == '__main__':\n\n    examB()\n\n\n\n\"\"\"\n\n\n\n\"\"\"", "score": 1.0, "surface_similarity": 0.6496185610302352}
{"id": "p03544_u193598069", "golden_code": "N = int(eval(input()))\n\nL = [ 0 ] * 1000000\n\n\n\nL[0] = 2\n\nL[1] = 1\n\n\n\nfor i in range(2, N+1):\n\n  L[i] = L[i-2] + L[i-1]\n\n\n\nprint((L[N]))\n", "generated_code": "N = int(eval(input()))\n\nL = [ 0 ] * (N+1)\n\n\n\nL[0] = 2\n\nL[1] = 1\n\n\n\nfor i in range(2, N+1):\n\n  L[i] = L[i-2] + L[i-1]\n\n\n\nprint((L[N]))\n", "score": 1.0, "surface_similarity": 0.9742647058823529}
{"id": "p03013_u218834617", "golden_code": "import sys\n\nN,M=list(map(int,input().split()))\n\nS=set(map(int,sys.stdin))\n\n\n\na,b=0,1\n\nfor i in range(1,N+1):\n\n    if i in S:\n\n        a,b=b,0\n\n    else:\n\n        a,b=b,a+b\n\n\n\nprint((b%(10**9+7)))\n", "generated_code": "import sys\n\n\n\nN,M=list(map(int,input().split()))\n\nbad=set(map(int,sys.stdin))\n\nMOD=10**9+7\n\n\n\na,b=0,1\n\nfor i in range(1,N+1):\n\n    if i in bad:\n\n        a,b=b,0\n\n        if a==0:\n\n            break\n\n    else:\n\n        a,b=b,(a+b)%MOD\n\n\n\nprint(b)\n", "score": 1.0, "surface_similarity": 0.8529194382852919}
{"id": "p02982_u094191970", "golden_code": "import numpy as np\n\nimport itertools\n\n\n\nn, d = list(map(int, input().split()))\n\nx = [list(map(int, input().split())) for i in range(n)]\n\n\n\ncnt = 0\n\nfor i1, i2 in itertools.product(list(range(n)), list(range(n))):\n\n    if i1 == i2:\n\n        continue\n\n    x1 = np.array(x[i1])\n\n    x2 = np.array(x[i2])\n\n    d = sum(list([x ** 2 for x in list(x1 - x2)])) ** 0.5\n\n    if d == int(d):\n\n        cnt += 1\n\n\n\nprint((int(cnt / 2)))", "generated_code": "n,d=list(map(int,input().split()))\n\nl=[list(map(int,input().split())) for i in range(n)]\n\n\n\ncnt=0\n\nfor i in range(n-1):\n\n for j in range(i+1,n):\n\n  l1=l[i]\n\n  l2=l[j]\n\n  sum=0\n\n  for y,z in zip(l1,l2):\n\n   sum+=(y-z)**2\n\n  dist=sum**0.5\n\n  if dist==int(dist):\n\n   cnt+=1\n\nprint(cnt)", "score": 1.0, "surface_similarity": 0.7332545311268716}
{"id": "p01138_u813384600", "golden_code": "import re\n\n\n\nwhile True:\n\n    n = int(input())\n\n    if n == 0:\n\n        break\n\n    l = [0] * (24*60*60+1)\n\n    for _ in range(n):\n\n        h1,m1,s1,h2,m2,s2 = list(map(int, re.split(':| ', input())))\n\n        l[h1*60*60 + m1*60 + s1] += 1\n\n        l[h2*60*60 + m2*60 + s2] -= 1\n\n    r = 0\n\n    for i in range(24*60*60):\n\n        l[i+1] += l[i]\n\n        r = max(r, l[i+1])\n\n    print(r)", "generated_code": "while True:\n\n    n = int(input())\n\n    if n == 0:\n\n        break\n\n    l = []\n\n    for _ in range(n):\n\n        hms1, hms2 = input().split()\n\n        l.append((hms1, True))\n\n        l.append((hms2, False))\n\n    l.sort()\n\n    r, t = 0, 0\n\n    for i in range(len(l)):\n\n        if l[i][1]:\n\n            t += 1\n\n        else:\n\n            t -= 1\n\n        r = max(r, t)\n\n    print(r)", "score": 1.0, "surface_similarity": 0.7438561438561438}
{"id": "p02690_u188827677", "golden_code": "x = int(eval(input()))\n\n\n\nfor a in range(-118,119):\n\n  for b in range(-119,118):\n\n    if a**5 - b**5 == x:\n\n      print((a,b))\n\n      exit()", "generated_code": "x = int(eval(input()))\n\n\n\nfor i in range(0, 120):\n\n  for j in range(-119, 120):\n\n    if (i**5 - j**5) == x:\n\n      print((i,j))\n\n      exit()\n", "score": 1.0, "surface_similarity": 0.943661971830986}
{"id": "p03074_u291766461", "golden_code": "N, K = list(map(int, input().split()))\n\nS = eval(input())\n\nnums = []\n\nnow = 1\n\ncnt = 0\n\nfor i in range(N):\n\n    if S[i] == str(now):\n\n        cnt += 1\n\n    else:\n\n        nums.append(cnt)\n\n        now = 1 - now\n\n        cnt = 1\n\nif cnt != 0:\n\n    nums.append(cnt)\n\nif len(nums) % 2 == 0:\n\n    nums.append(0)\n\n\n\nadd = 2 * K + 1\n\nans = 0\n\nleft = 0\n\nright = 0\n\ntmp = 0\n\nfor i in range(0, len(nums), 2):\n\n\n\n    next_left = i\n\n    next_right = min(i + add, len(nums))\n\n\n\n    while next_left > left:\n\n        tmp -= nums[left]\n\n        left += 1\n\n\n\n    while next_right > right:\n\n        tmp += nums[right]\n\n        right += 1\n\n\n\n    ans = max(ans, tmp)\n\nprint(ans)", "generated_code": "N, K = list(map(int, input().split()))\n\nS = eval(input())\n\nnums = []\n\nnow = 1\n\ncnt = 0\n\nfor i in range(N):\n\n    if S[i] == str(now):\n\n        cnt += 1\n\n    else:\n\n        nums.append(cnt)\n\n        now = 1 - now\n\n        cnt = 1\n\nif cnt != 0:\n\n    nums.append(cnt)\n\nif len(nums) % 2 == 0:\n\n    nums.append(0)\n\n\n\ncsum = [0] * (len(nums) + 1)\n\nfor i in range(len(nums)):\n\n    csum[i + 1] = csum[i] + nums[i]\n\n\n\nadd = 2 * K + 1\n\nans = 0\n\ntmp = 0\n\nfor i in range(0, len(nums), 2):\n\n    left = i\n\n    right = min(i + add, len(nums))\n\n    tmp = csum[right] - csum[left]\n\n    ans = max(ans, tmp)\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.8500058363487802}
{"id": "p03038_u598229387", "golden_code": "import numpy as np\n\nn,m=list(map(int,input().split()))\n\na=np.array([int(i) for i in input().split()])\n\nbc=np.array([[int(i) for i in input().split()] for j in range(m)])\n\n\n\na.sort()\n\nb=bc[:,0]\n\nc=bc[:,1]\n\n\n\nidx=np.argsort(c)\n\nb=b[idx][::-1]\n\nc=c[idx][::-1]\n\n\n\np=0\n\nfor b,c in zip(b,c):\n\n    a[p:p+b]=np.maximum(a[p:p+b],c)\n\n    p+=b\n\n    \n\n    \n\nprint((a.sum()))", "generated_code": "from heapq import heappop,heappush\n\nn,m=list(map(int,input().split()))\n\na=[int(i) for i in input().split()]\n\na.sort()\n\nbc=[[int(i) for i in input().split()]for j in range(m)]\n\nbc=sorted(bc, key=lambda x:x[1],reverse=True)\n\n\n\nans=[]\n\nfor b,c in bc:    \n\n    while b>0 and a: \n\n        x = heappop(a)\n\n        if x<c:\n\n            ans.append(c)\n\n            b-=1\n\n        else:\n\n            ans.append(x)\n\nprint((sum(ans)+sum(a)))", "score": 1.0, "surface_similarity": 0.5467289719626168}
{"id": "p02414_u150984829", "golden_code": "n,m,l=list(map(int,input().split()))\n\ne=[input().split()for _ in[0]*(n+m)]\n\nfor c in e[:n]:print((*[sum(int(s)*int(t)for s,t in zip(c,l))for l in zip(*e[n:])]))\n", "generated_code": "import sys\n\nn,m,l=list(map(int,input().split()))\n\ne=[list(map(int,e.split()))for e in sys.stdin]\n\nfor c in e[:n]:print((*[sum(s*t for s,t in zip(c,l))for l in zip(*e[n:])]))\n", "score": 1.0, "surface_similarity": 0.7677411294352824}
{"id": "p03424_u242518667", "golden_code": "n=int(eval(input()))\n\ns=list(map(str,input().split()))\n\ntotal=[]\n\nfor i in range(n):\n\n    if s[i] not in total:\n\n        total.append(s[i])\n\nprint(('Three' if len(total)==3 else 'Four'))", "generated_code": "eval(input())\n\nl=list(map(str,input().split()))\n\nprint(('Three' if len(set(l))==3 else 'Four'))", "score": 1.0, "surface_similarity": 0.6344086021505376}
{"id": "p03608_u298297089", "golden_code": "from scipy.sparse.csgraph import dijkstra as di\n\nfrom itertools import permutations\n\nN,M,R = list(map(int, input().split()))\n\nr = list(map(int, input().split()))\n\n\n\nroute = [[0 for i in range(N)] for j in range(N)]\n\nfor i in range(M):\n\n    a,b,c = list(map(int, input().split()))\n\n    route[a-1][b-1] = route[b-1][a-1] = c\n\n# for i in range(N):\n\n#     print(route[i])\n\n\n\n\n\np_route = di(route)\n\n# print(p_route)\n\n\n\nmn = float('INF')\n\nfor tmp in permutations(r):\n\n    t_sum = 0\n\n    for i in range(len(tmp)-1):\n\n        t_sum += p_route[tmp[i]-1][tmp[i+1]-1]\n\n    if t_sum < mn:\n\n        mn = t_sum\n\n\n\nprint((int(mn)))", "generated_code": "from itertools import permutations as perm\n\nfrom scipy.sparse.csgraph import dijkstra as di\n\n\n\ndef warshall(d, n):\n\n    for k in range(n):\n\n        for i in range(n):\n\n            for j in range(n):\n\n                if d[i][k] + d[k][j] < d[i][j]:\n\n                    d[i][j] = d[i][k] + d[k][j]\n\n\n\nn,m,r = list(map(int, input().split()))\n\nrr = [i-1 for i in map(int, input().split())]\n\n\n\ninf = float('INF')\n\nroute = [[0 for j in range(n)] for i in range(n)]\n\nfor _ in range(m):\n\n    a,b,c = list(map(int, input().split()))\n\n    route[a-1][b-1] = route[b-1][a-1] = c\n\n\n\nroute = di(route, n)\n\n\n\nans = inf\n\nfor tmp in perm(rr):\n\n    cost = 0\n\n    for i in range(r-1):\n\n        cost += route[tmp[i]][tmp[i+1]]\n\n    if cost < ans:\n\n        ans = cost\n\nprint((int(ans)))\n", "score": 1.0, "surface_similarity": 0.7873388381862958}
{"id": "p03164_u607865971", "golden_code": "import sys\n\nfrom collections import Counter, deque, defaultdict\n\nfrom itertools import accumulate, permutations, combinations, takewhile, compress, cycle\n\nfrom functools import reduce\n\nfrom math import ceil, floor, log10, log2, factorial\n\nfrom pprint import pprint\n\n\n\nsys.setrecursionlimit(1000000)\n\n# MOD = 10 ** 9 + 7\n\n# N = int(input())\n\n# A = [int(x) for x in input().split()]\n\n# V = [[0] * 100 for _ in range(100)]\n\n# A = [int(input()) for _ in range(N)]\n\n\n\nN, W = [int(x) for x in input().split()]\n\n\n\ndp = [float('inf')] * 1000 * 100*10\n\nvs = set()\n\nvs.add(0)\n\ndp[0] = 0\n\n\n\nfor i in range(N):\n\n    w, v = [int(x) for x in input().split()]\n\n\n\n    tmpDP = dp.copy()\n\n    for vv in list(vs):\n\n        if dp[vv + v] > dp[vv] + w:\n\n            tmpDP[vv + v] = dp[vv] + w\n\n            vs.add(vv + v)\n\n    dp = tmpDP\n\n\n\n\n\nans = 0\n\nfor v in list(vs):\n\n    if dp[v] <= W:\n\n        ans = max(ans, v)\n\nprint(ans)\n", "generated_code": "import sys\n\nfrom collections import Counter, deque, defaultdict\n\nfrom itertools import accumulate, permutations, combinations, takewhile, compress, cycle\n\nfrom functools import reduce\n\nfrom math import ceil, floor, log10, log2, factorial\n\nfrom pprint import pprint\n\n\n\nsys.setrecursionlimit(1000000)\n\n# MOD = 10 ** 9 + 7\n\n# N = int(input())\n\n# A = [int(x) for x in input().split()]\n\n# V = [[0] * 100 for _ in range(100)]\n\n# A = [int(input()) for _ in range(N)]\n\n\n\nN, W = [int(x) for x in input().split()]\n\n\n\ndp = defaultdict(lambda: float('inf'))\n\ndp[0] = 0\n\n\n\nfor i in range(N):\n\n    w, v = [int(x) for x in input().split()]\n\n\n\n    add = defaultdict(lambda: float('inf'))\n\n    for vv in list(dp.keys()):\n\n        if dp[vv + v] > dp[vv] + w:\n\n            add[vv + v] = dp[vv] + w\n\n    dp.update(add)\n\n\n\nprint((max([i for i in list(dp.items()) if i[1] <= W], key=lambda x:x[0])[0]))\n", "score": 1.0, "surface_similarity": 0.8196035242290749}
{"id": "p03796_u882209234", "golden_code": "from math import factorial\n\nN = int(eval(input()))\n\nprint((factorial(N) % (10**9 + 7)))", "generated_code": "from math import factorial\n\nN = int(eval(input()))\n\nans = 1\n\nfor i in range(1,N+1):\n\n    ans *= i % (10**9 + 7)\n\n    ans %= 10**9 + 7\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.7393509127789046}
{"id": "p02702_u402629484", "golden_code": "import sys\n\nsys.setrecursionlimit(1000000000)\n\nimport math\n\nfrom math import gcd\n\ndef lcm(a, b): return a * b // gcd(a, b)\n\nfrom itertools import count, permutations, chain\n\nfrom functools import lru_cache\n\nfrom collections import deque, defaultdict\n\nfrom pprint import pprint\n\nii = lambda: int(eval(input()))\n\nmis = lambda: list(map(int, input().split()))\n\nlmis = lambda: list(mis())\n\nINF = float('inf')\n\nN1097 = 10**9 + 7\n\n\n\ndef meg(f, ok, ng):\n\n    while abs(ok-ng)>1:\n\n        mid = (ok+ng)//2\n\n        if f(mid):\n\n            ok=mid\n\n        else:\n\n            ng=mid\n\n    return ok\n\n\n\ndef get_inv(n, modp):\n\n    return pow(n, modp-2, modp)\n\n\n\ndef factorials_list(n, modp):    # 10**6\n\n    fs = [1]\n\n    for i in range(1, n+1):\n\n        fs.append(fs[-1] * i % modp)\n\n    return fs\n\n\n\ndef invs_list(n, fs, modp):     # 10**6\n\n    invs = [get_inv(fs[-1], modp)]\n\n    for i in range(n, 1-1, -1):\n\n        invs.append(invs[-1] * i % modp)\n\n    invs.reverse()\n\n    return invs\n\n\n\ndef comb(n, k, modp):\n\n    num = 1\n\n    for i in range(n, n-k, -1):\n\n        num = num * i % modp\n\n    den = 1\n\n    for i in range(2, k+1):\n\n        den = den * i % modp\n\n    return num * get_inv(den, modp) % modp\n\n\n\ndef comb_from_list(n, k, modp, fs, invs):   \n\n    return fs[n] * invs[n-k] * invs[k] % modp\n\n\n\n#\n\n\n\nclass UnionFindEx:\n\n    def __init__(self, size):\n\n        #正なら根の番号、負ならグループサイズ\n\n        self.roots = [-1] * size\n\n    def getRootID(self, i):\n\n        r = self.roots[i]\n\n        if r < 0:   #負なら根\n\n            return i\n\n        else:\n\n            r = self.getRootID(r)\n\n            self.roots[i] = r\n\n            return r\n\n    def getGroupSize(self, i):\n\n        return -self.roots[self.getRootID(i)]\n\n    def connect(self, i, j):\n\n        r1, r2 = self.getRootID(i), self.getRootID(j)\n\n        if r1 == r2:\n\n            return False\n\n        if self.getGroupSize(r1) < self.getGroupSize(r2):\n\n            r1, r2 = r2, r1\n\n        self.roots[r1] += self.roots[r2]    #サイズ更新\n\n        self.roots[r2] = r1\n\n        return True\n\n\n\nYes = 'Yes'\n\nNo = 'No'\n\n\n\n\n\ndef main():\n\n    S = eval(input())\n\n    d = [0]*2019\n\n    dn = [0]*2019\n\n    ans = 0\n\n    for s in S:\n\n        sn = int(s)\n\n        dn[sn] += 1\n\n        for i in range(2019):\n\n            dn[(i*10+sn)%2019] += d[i]\n\n        d, dn = dn, d\n\n        for i in range(2019):\n\n            dn[i] = 0\n\n        ans += d[0]\n\n    print(ans)\n\n\n\n\n\n\n\n\n\n\n\n\n\nmain()\n\n\n", "generated_code": "'''\n\n[point 1]\n\n1817181712114 の部分 \"18171\"について考える...\n\n\n\n    181710000 / 10000 ≡ 0 (MOD 2019) ならば、2019の倍数\n\n    181710000 ≡ 0 (MOD 2019) でよい\n\n\n\n[point 2]\n\n    181710000\n\n    =\n\n    181712114\n\n    -\n\n         2114\n\n\n\n    なので、特定区間の値 は 累積和の差 から瞬時に求められる。\n\n    さらに、181710000 ≡ 0 (MOD 2019) を考えると、\n\n\n\n    0 ≡ 181712114 - 2114\n\n    → 181712114 ≡ 2114\n\n\n\n    となる。\n\n    結局の所、MOD2019において合同な累積和のペアの数の数え上げ。\n\n'''\n\n\n\nfrom collections import defaultdict\n\n\n\ndef gen_10exp_mod(n, mod):\n\n    a = 1\n\n    yield a\n\n    for _ in range(1, n):\n\n        a = (a*10) % mod\n\n        yield a\n\n\n\ndef main():\n\n    MOD = 2019\n\n    S = input()[::-1]\n\n    # 桁ごとの実際の値を計算 (MOD)\n\n    A = [int(s)*n % MOD for s, n in zip(S, gen_10exp_mod(len(S), MOD))]\n\n    # 累積和を計算\n\n    ACC = [0]\n\n    for a in A:\n\n        ACC.append((ACC[-1] + a) % MOD)\n\n    # ペア数え上げ\n\n    d = defaultdict(int)\n\n    for acc in ACC:\n\n        d[acc] += 1\n\n    ans = sum(v*(v-1)//2 for v in list(d.values()))\n\n    print(ans)\n\n\n\n\n\nmain()\n", "score": 1.0, "surface_similarity": 0.535917038831277}
{"id": "p03013_u680851063", "golden_code": "import sys\n\ninput = sys.stdin.readline\n\n\n\nn, m = list(map(int, input().split()))\n\nbroken = set([int(eval(input())) for _ in range(m)]) # ここが'list'だとPypyでも通らない\n\n\n\ndef ptn_num(x): # 'x'stepまでのパターン数\n\n    dp = [0] * (x+1) # DP枠_including step'0'\n\n    if 1 in broken: # in case, step'1' broken \n\n        dp[:2] = 1, 0\n\n    else:\n\n        dp[:2] = 1, 1 # Usually\n\n\n\n    for i in range(2, x+1):\n\n        if i not in broken: # 階段が壊れてない場合...\n\n            dp[i] = (dp[i-1] + dp[i-2]) % (10**9+7) # -1段目と-2段目の合計\n\n    print((dp[-1]))\n\n\n\nptn_num(n)\n", "generated_code": "import sys\n\ninput = sys.stdin.readline\n\n\n\nn, m = list(map(int, input().split()))\n\nbroken = set([int(eval(input())) for _ in range(m)]) # ここが'list'だとPypyでも通らない\n\n\n\ndef ptn_num(x): # 'x'stepまでのパターン数\n\n    dp = [0] * (x+1) # DP枠_including step'0'\n\n    if 1 in broken: # 固定部分_in case, step'1' broken \n\n        dp[:2] = 1, 0\n\n    else:\n\n        dp[:2] = 1, 1 # 固定部分_Usually\n\n\n\n    for i in range(2, x+1):\n\n        if i not in broken: # 階段が壊れてない場合...\n\n            dp[i] = (dp[i-1] + dp[i-2]) % (10**9+7) # -1段目と-2段目の合計\n\n    print((dp[-1]))\n\n\n\nptn_num(n)", "score": 1.0, "surface_similarity": 1.0}
{"id": "p00005_u146816547", "golden_code": "import fractions\n\nwhile True:\n\n\ttry:\n\n\t\tx,y = list(map(int,input().split()))\n\n\t\tprint('%d %d' % (fractions.gcd(x,y),x/fractions.gcd(x,y)*y))\n\n\texcept EOFError:\n\n\t\tbreak", "generated_code": "def gcd(x, y):\n\n    if y == 0:\n\n        return x\n\n    else:\n\n        return gcd(y, x%y)\n\n\n\n\n\ndef lcm(x,y):\n\n    return x/gcd(x, y)*y\n\n\n\n\n\nwhile True:\n\n    try:\n\n        x, y = list(map(int, input().split()))\n\n    except EOFError:\n\n        break\n\n\n\n    print(\"%d %d\" % (gcd(x, y), lcm(x, y)))", "score": 1.0, "surface_similarity": 0.5841924398625429}
{"id": "p03000_u815878613", "golden_code": "import sys\n\nimport numpy as np\n\n\n\nN, X  = list(map(int, input().split()))\n\n\n\nL = np.array(list(map(int, input().split())))\n\n\n\nx = np.zeros(N+1)\n\n\n\nfor n in range(1,N+1):\n\n    x[n] = x[n-1] + L[n-1]\n\n    if x[n] > X:\n\n        print(n)\n\n        sys.exit()\n\n\n\nprint((N+1))\n\n\n", "generated_code": "N, X = list(map(int, input().split()))\n\nL = list(map(int, input().split()))\n\n\n\ncnt = 1\n\nsum_L = 0\n\nfor l in L:\n\n    sum_L += l\n\n    if sum_L <= X:\n\n        cnt += 1\n\n    else:\n\n        break\n\n\n\nprint(cnt)\n", "score": 1.0, "surface_similarity": 0.5931372549019609}
{"id": "p02881_u111365362", "golden_code": "n = int(eval(input()))\n\nr = int(n**.5)\n\nfor i in range(r):\n\n  if n % (r-i) == 0:\n\n    print(( (r-i) + n//(r-i) - 2 ))\n\n    break", "generated_code": "n = int(eval(input()))\n\ns = int(n**.5)\n\nfor i in range(s):\n\n  if n % (s-i) == 0:\n\n    print(((s-i) + n // (s-i) - 2))\n\n    break", "score": 1.0, "surface_similarity": 0.98046875}
{"id": "p03253_u670180528", "golden_code": "from collections import Counter\n\ndef factorization(n) -> list:\n\n\tif n==1:\n\n\t\treturn [1]\n\n\tret = []\n\n\ti = 2\n\n\twhile i*i<=n:\n\n\t\twhile n%i==0:\n\n\t\t\tn //= i\n\n\t\t\tret.append(i)\n\n\t\ti += 1\n\n\tif n!=1:\n\n\t\tret.append(n)\n\n\treturn ret\n\n\n\nn,m = list(map(int,input().split()))\n\nmod = 10**9+7\n\nif m==1:\n\n\tprint((1));exit()\n\n\n\nfactors = Counter(factorization(m))\n\nmx = n+max(factors.values())\n\n\n\nfac = [1]*(mx+1)\n\ninv = [1]*(mx+1)\n\nfor i in range(1,mx+1):\n\n\tfac[i] = fac[i-1] * i % mod\n\ninv[-1] = pow(fac[-1], mod - 2, mod)\n\nfor i in range(mx-1, -1, -1):\n\n\tinv[i] = inv[i+1] * (i+1) % mod\n\ndef cmb(n,r):\n\n\tassert n >= r >= 0\n\n\treturn fac[n] * inv[n-r] * inv[r] % mod\n\n\t\n\nans=1\n\nfor v in list(factors.values()):\n\n\tans*=cmb(n+v-1,v)\n\n\tans%=mod\n\n\n\nprint(ans)", "generated_code": "from collections import Counter\n\ndef factorization(n) -> list:\n\n\tif n==1:return [1]\n\n\tret = []\n\n\ti = 2\n\n\twhile i*i<=n:\n\n\t\twhile n%i==0:\n\n\t\t\tn //= i\n\n\t\t\tret.append(i)\n\n\t\ti += 1\n\n\tif n!=1:ret.append(n)\n\n\treturn ret\n\n\t\n\nfrom operator import mul\n\nfrom functools import reduce\n\ndef cmb(n,r):\n\n\tif n < r:return 0\n\n\tr = min(n-r,r)\n\n\tif r==0:return 1\n\n\tu = reduce(mul, list(range(n, n-r, -1)))\n\n\td = reduce(mul, list(range(1,r+1)))\n\n\treturn u//d\n\n\n\ndef main():\n\n\tn,m = list(map(int,input().split()))\n\n\tmod = 10**9+7\n\n\tif m==1:\n\n\t\tprint((1))\n\n\t\texit()\n\n\tans=1\n\n\tfor v in list(Counter(factorization(m)).values()):\n\n\t\tans*=cmb(n+v-1,v)\n\n\t\tans%=mod\n\n\tprint(ans)\n\n\t\n\nif __name__==\"__main__\":main()", "score": 1.0, "surface_similarity": 0.7052325783669067}
{"id": "p02725_u346812984", "golden_code": "K, N = list(map(int, input().split()))\n\nA = list(map(int, input().split()))\n\n\n\ndiff = A[0] + K - A[-1]\n\nans = A[-1] - A[0]\n\nfor i in range(1, N):\n\n    dist = K - A[i] + A[i - 1]\n\n    if dist < ans:\n\n        ans = dist\n\n\n\nprint(ans)\n", "generated_code": "import sys\n\n\n\n\n\ndef input():\n\n    return sys.stdin.readline().strip()\n\n\n\n\n\ndef main():\n\n    K, N = list(map(int, input().split()))\n\n    A = list(map(int, input().split()))\n\n\n\n    ans = [K - A[i] + A[i - 1] for i in range(1, N)]\n\n    print((min(min(ans), A[-1] - A[0])))\n\n\n\n\n\nmain()\n", "score": 1.0, "surface_similarity": 0.5695288753799392}
{"id": "p02837_u254871849", "golden_code": "import sys\n\nimport numpy as np\n\n\n\nn = int(sys.stdin.readline().rstrip())\n\nx = []\n\ny = []\n\nfor i in range(n):\n\n    a = int(sys.stdin.readline().rstrip())\n\n    xy = [sys.stdin.readline().split() for _ in range(a)]\n\n    if not xy:\n\n        x.append(None)\n\n        y.append(None)\n\n        continue\n\n    xi, yi = np.array(xy, np.int64).T\n\n    x.append(xi-1)\n\n    y.append(yi)\n\n\n\ndef main():\n\n\n\n    ans = 0\n\n    for comb in range(2 ** n):\n\n        cnt = 0\n\n        for i in range(n):\n\n            if not comb >> i & 1:\n\n                continue\n\n            if x[i] is None:\n\n                cnt += 1\n\n                continue\n\n            if np.count_nonzero(comb >> x[i] & 1 ^ y[i]):\n\n                break\n\n            cnt += 1\n\n        else:\n\n            ans = max(ans, cnt)\n\n    return ans\n\n                \n\nif __name__ == '__main__':\n\n    ans = main()\n\n    print(ans)", "generated_code": "import sys\n\n\n\nn = int(sys.stdin.readline().rstrip())\n\nxy = [[] for _ in range(n)]\n\nfor i in range(n):\n\n    a = int(sys.stdin.readline().rstrip())\n\n    for j in range(a):\n\n        x, y = list(map(int, sys.stdin.readline().split()))\n\n        xy[i].append((x-1, y))\n\n\n\ndef main():\n\n    ans = 0\n\n    for comb in range(2 ** n):\n\n        cnt = 0\n\n        for i in range(n):\n\n            if comb >> i & 1 ^ 1:\n\n                continue\n\n            for x, y in xy[i]:\n\n                if comb >> x & 1 ^ y:\n\n                    break\n\n            else:\n\n                cnt += 1\n\n                continue\n\n            break\n\n        else:\n\n            ans = max(ans, cnt)\n\n    return ans\n\n                \n\nif __name__ == '__main__':\n\n    ans = main()\n\n    print(ans)", "score": 1.0, "surface_similarity": 0.8333073857267406}
{"id": "p03837_u392319141", "golden_code": "from scipy.sparse.csgraph import csgraph_from_dense, floyd_warshall\n\n\n\nINF = float('inf')\n\n\n\ndef sol():\n\n    N, M = list(map(int, input().split()))\n\n\n\n    edges = []\n\n\n\n    for _ in range(M):\n\n        fr, to, cost = list(map(int, input().split()))\n\n        fr -= 1\n\n        to -= 1\n\n        edges.append((fr, to, cost))\n\n\n\n    graph = [[INF] * N for _ in range(N)]\n\n    for fr, to, cost in edges:\n\n        graph[fr][to] = cost\n\n\n\n    graph = csgraph_from_dense(graph, null_value=INF)\n\n\n\n    dist = floyd_warshall(graph, directed=False)\n\n    ans = (graph > dist).sum()\n\n    print(ans)\n\n\n\nsol()", "generated_code": "N, M = list(map(int, input().split()))\n\nINF = 10**18\n\n\n\nminDist = [[INF] * N for _ in range(N)]\n\nfor i in range(N):\n\n    minDist[i][i] = 0\n\n\n\nedges = []\n\nfor _ in range(M):\n\n    fr, to, d = list(map(int, input().split()))\n\n    fr -= 1\n\n    to -= 1\n\n    edges.append((fr, to, d))\n\n    minDist[fr][to] = d\n\n    minDist[to][fr] = d\n\n\n\nfor k in range(N):\n\n    for i in range(N):\n\n        for j in range(N):\n\n            d = minDist[i][k] + minDist[k][j]\n\n            if minDist[i][j] > d:\n\n                minDist[i][j] = d\n\n\n\nans = 0\n\nfor fr, to, d in edges:\n\n    if minDist[fr][to] < d:\n\n        ans += 1\n\nprint(ans)\n", "score": 1.0, "surface_similarity": 0.6190663519538422}
{"id": "p03371_u648881683", "golden_code": "import sys\n\ninput = lambda: sys.stdin.readline().rstrip() \n\n\n\ndef resolve():\n\n    A, B, C, X, Y = list(map(int, input().split()))\n\n\n\n    ans = float('inf')\n\n    for i in range(0, max(X, Y)*2+1, 2):\n\n        ans = min(A*max(X-i//2, 0)+B*max(Y-i//2, 0)+C*i, ans)\n\n    print(ans)\n\n\n\nif __name__ == '__main__':\n\n    resolve()\n", "generated_code": "import sys\n\ninput = lambda: sys.stdin.readline().rstrip() \n\n\n\ndef resolve():\n\n    A, B, C, X, Y = list(map(int, input().split()))\n\n\n\n    ans = 0\n\n    if A+B > 2*C:\n\n        ans = 2*C*min(X, Y)+min((A if X>Y else B)*abs(X-Y), 2*C*abs(X-Y))\n\n    else:\n\n        ans = A*X+B*Y\n\n    \n\n    print(ans)\n\n\n\nif __name__ == '__main__':\n\n    resolve()\n", "score": 1.0, "surface_similarity": 0.8069004524886878}
{"id": "p03416_u556589653", "golden_code": "A,B = list(map(int,input().split()))\n\nans = 0\n\nfor i in range(A,B+1):\n\n    i = str(i)\n\n    if i[0] == i[4]:\n\n        if i[1] == i[3]:\n\n            ans += 1\n\n        else:\n\n            ans += 0\n\n    else:\n\n        ans += 0\n\nprint(ans)", "generated_code": "A,B = list(map(int,input().split()))\n\nans = 0\n\nfor i in range(A,B+1):\n\n    k = str(i)\n\n    if k[0] == k[4] and k[1] == k[3]:\n\n        ans += 1\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.8772736562436133}
{"id": "p03568_u312025627", "golden_code": "def main():\n\n    N = int(input())\n\n    A = [int(i) for i in input().split()]\n\n    if N == 1:\n\n        return print(1 if A[0] % 2 == 0 else 2)\n\n    ans = 0\n\n    d = (-1, 0, 1)\n\n    from itertools import product\n\n    for i in product(range(3), repeat=N):\n\n        cur = 1\n\n        for j in range(N):\n\n            cur *= (A[j] + d[i[j]])\n\n        if cur % 2 == 0:\n\n            ans += 1\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "generated_code": "def main():\n\n    N = int(eval(input()))\n\n    A = [int(i) for i in input().split()]\n\n    ans = 3**N\n\n    cnt = len([a for a in A if a % 2 == 0])\n\n    ans -= 2**cnt\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 1.0, "surface_similarity": 0.5988248572566724}
{"id": "p02982_u893063840", "golden_code": "import numpy as\tnp\n\n\n\nn, d = list(map(int, input().split()))\n\nx = []\n\nfor i in range(n):\n\n    x.append(list(map(int, input().split())))\n\n\n\nx = np.array(x)\n\n\n\ncount =\t0\n\nfor i in range(n):\n\n    for j in range(i+1, n):\n\n        dist = np.linalg.norm(x[i] - x[j])\n\n        if dist == int(dist):\n\n            count += 1\n\n\n\nprint(count)", "generated_code": "n, d = list(map(int, input().split()))\n\nx = [list(map(int, input().split())) for _ in range(n)]\n\n\n\n\n\ndef dist(a, b):\n\n    sm = 0\n\n    for ea, eb in zip(a, b):\n\n        sm += (ea - eb) ** 2\n\n\n\n    return sm ** 0.5\n\n\n\n\n\nans = 0\n\nfor i in range(n):\n\n    for j in range(i + 1, n):\n\n        dst = dist(x[i], x[j])\n\n        for k in range(int(16000 ** 0.5) + 1):\n\n            if k == dst:\n\n                ans += 1\n\n                break\n\n\n\nprint(ans)\n", "score": 1.0, "surface_similarity": 0.6432084478518734}
{"id": "p03254_u102461423", "golden_code": "import numpy as np\n\nN,x = list(map(int,input().split()))\n\nA = np.array(input().split(), dtype = np.int64)\n\nA.sort()\n\nnp.cumsum(A, out = A)\n\nanswer = (A <= x).sum()\n\n\n\nif answer == N and A[-1] != x:\n\n  answer -= 1\n\nprint(answer)\n", "generated_code": "import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\nfrom bisect import bisect_right\n\nimport itertools\n\n\n\nN,X,*A = list(map(int,read().split()))\n\n\n\nA.sort()\n\nAcum = list(itertools.accumulate(A))\n\n\n\nanswer = bisect_right(Acum,X)\n\nif answer == N:\n\n    if Acum[-1] < X:\n\n        answer -= 1\n\nprint(answer)", "score": 1.0, "surface_similarity": 0.5857886420671066}
{"id": "p03425_u777923818", "golden_code": "# -*- coding: utf-8 -*-\n\nfrom collections import defaultdict\n\nfrom itertools import combinations\n\nN = int(eval(input()))\n\nC = [0, 0, 0, 0, 0, 0]\n\nD = defaultdict(int)\n\nfor i, m in enumerate(\"MARCH\", start=1):\n\n    D[m] = i\n\n\n\nfor _ in range(N):\n\n    C[D[input()[0]]] += 1\n\n\n\nans = 0\n\nfor a, b, c in combinations(list(range(1, 6)), r=3):\n\n    ans += C[a]*C[b]*C[c]\n\nprint(ans)", "generated_code": "from collections import defaultdict\n\nfrom itertools import combinations\n\ndef inpl(): return list(map(int, input().split()))\n\n\n\nC = defaultdict(int)\n\nN = int(eval(input()))\n\nfor _ in range(N):\n\n    C[input()[0]] += 1\n\n\n\nres = 0\n\nfor H in combinations(\"MARCH\", r=3):\n\n    res += C[H[0]] * C[H[1]] * C[H[2]]\n\nprint(res)", "score": 1.0, "surface_similarity": 0.719}
{"id": "p03796_u964904181", "golden_code": "import math\n\n\n\nN = int(eval(input()))\n\n\n\nprint((math.factorial(N) % (1000000000 + 7)))\n", "generated_code": "import math\n\n\n\nN = int(eval(input()))\n\n\n\np = 1\n\nfor i in range(2, N+1):\n\n  p *= i\n\n  p = p % (1000000000 + 7)\n\n  \n\nprint(p)\n", "score": 1.0, "surface_similarity": 0.7412239089184061}
{"id": "p03309_u127499732", "golden_code": "def main():\n\n    from statistics import median\n\n\n\n    n, *a, = list(map(int, open(0).read().split()))\n\n    a = [x - i for i, x in enumerate(a, 1)]\n\n    a.sort()\n\n    m = int(median(a))\n\n\n\n    ans = sum([abs(x - m) for x in a])\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "generated_code": "def main():\n\n    n, *a, = list(map(int, open(0).read().split()))\n\n    a = [x - i for i, x in enumerate(a, 1)]\n\n    a.sort()\n\n    if n % 2 == 0:\n\n        ans = sum(a[n // 2:]) - sum(a[:n // 2])\n\n    else:\n\n        ans = sum(a[n // 2 + 1:]) - sum(a[:n // 2])\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 1.0, "surface_similarity": 0.7331463956069634}
{"id": "p02690_u578323547", "golden_code": "x = int(eval(input()))\n\n\n\nfor a in range(10**4):\n\n    for b in range(10**4):\n\n        if(a**5 + b**5 == x):\n\n            print((a, -b))\n\n            break\n\n        elif(a**5 - b**5 == x):\n\n            print((a, b))\n\n            break\n\n    else:\n\n        continue\n\n    break", "generated_code": "x = int(eval(input()))\n\n\n\nfor a in range(10**3):\n\n    for b in range(10**3):\n\n        if(a**5 + b**5 == x):\n\n            print((a, -b))\n\n            break\n\n        elif(a**5 - b**5 == x):\n\n            print((a, b))\n\n            break\n\n    else:\n\n        continue\n\n    break\n", "score": 1.0, "surface_similarity": 0.9963503649635037}
{"id": "p03037_u159994501", "golden_code": "N, M = list(map(int, input().split()))\n\nL, R = [], []\n\nlow = -float('INF')\n\nhigh = float('INF')\n\nfor i in range(M):\n\n    l, r = list(map(int, input().split()))\n\n    L.append(l)\n\n    R.append(r)\n\n    if l > low:\n\n        low = l\n\n    if r < high:\n\n        high = r\n\nprint((max(0, high - low + 1)))\n", "generated_code": "N, M = list(map(int, input().split()))\n\nlow = -float('INF')\n\nhigh = float('INF')\n\nfor i in range(M):\n\n    l, r = list(map(int, input().split()))\n\n    if l > low:\n\n        low = l\n\n    if r < high:\n\n        high = r\n\nprint((max(0, high - low + 1)))\n", "score": 1.0, "surface_similarity": 0.918951418951419}
{"id": "p03837_u070201429", "golden_code": "def main():\n\n    from sys import stdin\n\n    def input():\n\n        return stdin.readline().strip()\n\n\n\n    n, m = list(map(int, input().split()))\n\n    tree = [[] for _ in range(n)]\n\n    for _ in range(m):\n\n        i, j, k = list(map(int, input().split()))\n\n        i -= 1\n\n        j -= 1\n\n        tree[i].append((k, j))\n\n        tree[j].append((k, i))\n\n\n\n    # dijkstra\n\n    import heapq\n\n    from numpy import zeros\n\n\n\n    ans = 0\n\n    for i in range(n):\n\n        for j in tree[i]:\n\n            seen = zeros(n)\n\n            goal = j[1]\n\n            base = j[0]\n\n            seen[i] = 1\n\n            todo = []\n\n            heapq.heapify(todo)\n\n            for k in tree[i]:\n\n                if k[0] < base and k != j:\n\n                    heapq.heappush(todo, k)\n\n            while len(todo) > 0:\n\n                k = heapq.heappop(todo)\n\n                if k[1] == goal:\n\n                    if k[0] < base:\n\n                        ans += 1\n\n                    break\n\n                seen[k[1]] = 1\n\n                for l in tree[k[1]]:\n\n                    if seen[l[1]] == 0 and k[0] + l[0] < base:\n\n                        heapq.heappush(todo, (k[0] + l[0], l[1]))\n\n\n\n    print((ans // 2))\n\n\n\nmain()", "generated_code": "def main():\n\n    from sys import stdin\n\n    def input():\n\n        return stdin.readline().strip()\n\n\n\n    n, m = list(map(int, input().split()))\n\n    tree = [[] for _ in range(n)]\n\n    for _ in range(m):\n\n        i, j, k = list(map(int, input().split()))\n\n        i -= 1\n\n        j -= 1\n\n        tree[i].append((k, j))\n\n        tree[j].append((k, i))\n\n\n\n    # dijkstra\n\n    import heapq\n\n\n\n    ans = 0\n\n    for i in range(n):\n\n        for j in tree[i]:\n\n            seen = [0] * n\n\n            goal = j[1]\n\n            base = j[0]\n\n            seen[i] = 1\n\n            todo = []\n\n            heapq.heapify(todo)\n\n            for k in tree[i]:\n\n                if k[0] < base and k != j:\n\n                    heapq.heappush(todo, k)\n\n            while len(todo) > 0:\n\n                k = heapq.heappop(todo)\n\n                if k[1] == goal:\n\n                    if k[0] < base:\n\n                        ans += 1\n\n                    break\n\n                seen[k[1]] = 1\n\n                for l in tree[k[1]]:\n\n                    if seen[l[1]] == 0 and k[0] + l[0] < base:\n\n                        heapq.heappush(todo, (k[0] + l[0], l[1]))\n\n\n\n    print((ans // 2))\n\n\n\nmain()", "score": 1.0, "surface_similarity": 0.9752045325283283}
{"id": "p03197_u707498674", "golden_code": "import numpy as np\n\n \n\ndef main():\n\n    stdin = np.fromstring(open(0).read(), dtype=np.int64, sep=' ')\n\n    A = stdin[1:]\n\n    A = np.mod(A, 2)\n\n    print(\"first\") if np.count_nonzero(A) else print(\"second\")\n\nif __name__ == \"__main__\":\n\n    main()\n", "generated_code": "import sys\n\ndef input(): return sys.stdin.readline().strip()\n\ndef main():\n\n    N = int(input())\n\n    A = (int(input()) for _ in range(N))\n\n    print(\"second\") if all(( a%2==0 for a in A)) else print(\"first\")\n\nif __name__ == \"__main__\":\n\n    main()\n", "score": 1.0, "surface_similarity": 0.6141935483870968}
{"id": "p02555_u729133443", "golden_code": "a,b,c=1,0,0\n\nexec('a,b,c=b,c,(a+c)%(10**9+7);'*(int(eval(input()))-2))\n\nprint(c)", "generated_code": "a,b,c=1,0,0\n\nexec('a,b,c=b,c,a+c;'*(int(eval(input()))-2))\n\nprint((c%(10**9+7)))", "score": 1.0, "surface_similarity": 0.75}
{"id": "p02615_u416011173", "golden_code": "# -*- coding: utf-8 -*-\n\n# モジュールのインポート\n\nimport math\n\nimport numpy as np\n\n\n\n# 標準入力を取得\n\nN = int(eval(input()))\n\nA = list(map(int, input().split()))\n\n\n\n# 求解処理\n\nA = sorted(A, reverse=True)\n\nA = np.array(A)\n\nans = 2 * np.sum(A[:(N // 2)]) - A[0] + (N % 2) * A[math.floor(N / 2)]\n\n\n\n# 結果出力\n\nprint(ans)\n", "generated_code": "# -*- coding: utf-8 -*-\n\n# モジュールのインポート\n\nimport math\n\n\n\n# 標準入力を取得\n\nN = int(eval(input()))\n\nA = list(map(int, input().split()))\n\n\n\n# 求解処理\n\nA = sorted(A, reverse=True)\n\nans = 0\n\nfor n in range(1, N + 1):\n\n    if n == 1:\n\n        continue\n\n    ans += A[math.ceil(n / 2) - 1]\n\n\n\n# 結果出力\n\nprint(ans)\n", "score": 1.0, "surface_similarity": 0.7014961389961389}
{"id": "p03371_u768896740", "golden_code": "a, b, c, x, y = list(map(int, input().split()))\n\n\n\nz = max(x,y) * 2\n\nmin_sum = c * z\n\n\n\nfor i in range(z):\n\n    r = max(0, y - i) * b\n\n    t = max(0, x - i) * a\n\n    sum = c * i * 2 + r + t\n\n    if sum < min_sum:\n\n        min_sum = sum\n\n\n\nprint(min_sum)", "generated_code": "a,b,c,x,y = list(map(int, input().split()))\n\n\n\nplan_a = c * (2*x) + max(0, y-x) * b\n\nplan_b = c * (2*y) + max(0, x-y) * a\n\nplan_c = a * x + b * y\n\n\n\nprint((min(plan_a, plan_b, plan_c)))", "score": 1.0, "surface_similarity": 0.7031181379007465}
{"id": "p03796_u488127128", "golden_code": "N = int(eval(input()))\n\na = 1\n\nfor n in range(2,N+1):\n\n    a = a*n % (10**9+7)\n\nprint(a)", "generated_code": "def factorial(N):\n\n    a = 1\n\n    for n in range(2,N+1):\n\n        a = a*n % (10**9 + 7)\n\n    return a\n\n\n\nif __name__ == '__main__':\n\n    N = int(eval(input()))\n\n    print((factorial(N)))", "score": 1.0, "surface_similarity": 0.6102150537634408}
{"id": "p03371_u047102107", "golden_code": "# -*- coding: utf-8 -*-\n\n\n\nA, B, C, X, Y = list(map(int, input().split()))\n\n\n\ncost = int(1e10)\n\nfor num_ac in range(0, int(1e5) + 1):\n\n    num_A = max(0, X - num_ac)\n\n    num_B = max(0, Y - num_ac)\n\n    c = 2 * C * num_ac + A * num_A + B * num_B\n\n    cost = min(c, cost)\n\nprint(cost)", "generated_code": "A, B, C, X, Y = list(map(int, input().split()))\n\n\n\nans = 0\n\nif A + B > 2 * C:\n\n    z = min(X, Y)\n\n    X -= z\n\n    Y -= z\n\n    ans += 2 * z * C\n\n\n\n# 偏り分\n\nif 2 * C < A:\n\n    k = X\n\n    X -= k\n\n    Y -= k\n\n    ans += 2 * C * k\n\nif 2 * C < B:\n\n    k = Y\n\n    X -= k\n\n    Y -= k\n\n    ans += 2 * C * k\n\n\n\n# あまり分\n\nans += A * max(0, X) + B * max(0, Y)\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.6669014084507042}
{"id": "p03170_u102461423", "golden_code": "import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\nfrom operator import xor\n\nfrom functools import reduce\n\n\n\nN,K,*A = list(map(int,read().split()))\n\n\n\na = reduce(xor,(1<<a for a in A))\n\n\n\ndp = 0 # bitset\n\nfor n in range(K):\n\n    if not(dp&(1<<n)):\n\n        dp |= (a<<n)\n\n\n\nanswer = 'First' if dp&(1<<K) else 'Second'\n\nprint(answer)", "generated_code": "import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\nN,K,*A = list(map(int,read().split()))\n\n\n\ndp = [0]*(K+1) # bitset\n\nfor n in range(K):\n\n    if not dp[n]:\n\n        for a in A:\n\n            if n+a>K:\n\n                break\n\n            dp[n+a]=1\n\n\n\nanswer = 'First' if dp[-1] else 'Second'\n\nprint(answer)", "score": 1.0, "surface_similarity": 0.6259061833688699}
{"id": "p03060_u186206732", "golden_code": "import numpy as np\n\n\n\nn = int(eval(input()))\n\n\n\nv_list = np.array(list(map(int,input().split())))\n\nc_list = np.array(list(map(int,input().split())))\n\ne_list = list(v_list - c_list)\n\n\n\nans = 0\n\n\n\nfor i in range(n):\n\n    if e_list[i] > 0:\n\n        ans += e_list[i]\n\n\n\nprint(ans)\n", "generated_code": "n = int(eval(input()))\n\n\n\nv_list = list(map(int,input().split()))\n\nc_list = list(map(int,input().split()))\n\n\n\ne_list = [v-c if (v-c > 0) else 0 for v,c in zip(v_list, c_list)]\n\n\n\nprint((sum(e_list)))\n", "score": 1.0, "surface_similarity": 0.5831046931407943}
{"id": "p02624_u102960641", "golden_code": "n = int(eval(input()))\n\nans = 0\n\nSQRT = int(n ** 0.5)\n\nfor m in range(1,SQRT + 1):\n\n    b = int(n/m)\n\n    ans += m * (m + b) * (b + 1 - m)\n\nans -= SQRT * (SQRT+1) * (2*SQRT+1) // 6\n\nprint(ans)", "generated_code": "def main():\n\n  n = int(eval(input()))\n\n  ans = 0\n\n  SQRT = int(n ** 0.5)\n\n  for m in range(1,SQRT + 1):\n\n    b = int(n/m)\n\n    ans += m * (m + b) * (b + 1 - m)\n\n  ans -= SQRT * (SQRT+1) * (2*SQRT+1) // 6\n\n  print(ans)\n\nmain()\n", "score": 1.0, "surface_similarity": 0.907545412203074}
{"id": "p03173_u263830634", "golden_code": "import numpy as np\n\n\n\nN = int(eval(input()))\n\nA = [0] + list(map(int, input().split()))\n\n\n\nA = np.array(A, dtype = np.int64)\n\nA = np.cumsum(A)\n\n\n\ndp = np.zeros((N, N), dtype = np.int64)\n\n\n\nfor j in range(1, N):\n\n    for i in range(N - j):\n\n        # print (dp[i, i:i + j], dp[i + 1:i + j + 1, i + j])\n\n        tmp = min(dp[i, i:i + j] + dp[i + 1:i + j + 1, i + j])\n\n        dp[i][i + j] = tmp + A[i + j + 1] - A[i]\n\n\n\nprint((dp[0][N - 1]))", "generated_code": "N = int(eval(input()))\n\nA = [0] + list(map(int, input().split()))\n\n\n\nINF = 10 ** 18\n\n\n\ndp = [[0] * (N) for _ in range(N)]\n\n\n\nfor i in range(N):\n\n    A[i + 1] += A[i]\n\n\n\nfor j in range(1, N):\n\n    for i in range(N - j):\n\n        tmp = INF\n\n        for k in range(i, i + j):\n\n            # print (i, i + j, k + 1)\n\n            tmp = min(tmp, dp[i][k] + dp[k + 1][i + j])\n\n        dp[i][i + j] = tmp + A[i + j + 1] - A[i]\n\n\n\nprint((dp[0][N - 1]))\n", "score": 1.0, "surface_similarity": 0.6577827827827828}
{"id": "p03828_u513081876", "golden_code": "import math\n\nimport collections\n\n\n\nN = int(eval(input()))\n\na = math.factorial(N)\n\ncheck = []\n\nans = 1\n\ni = 2\n\n\n\nwhile a != 1:\n\n    if a % i == 0:\n\n        a //= i\n\n        check.append(i)\n\n    else:\n\n        i += 1\n\n        \n\ncheck = list(collections.Counter(check).values())\n\nfor i in check:\n\n    ans *= (i+1)\n\n    ans %= 10**9+7\n\nprint(ans)", "generated_code": "from math import factorial\n\n\n\nN = factorial(int(eval(input())))\n\n\n\ni = 2\n\ncheck = 1\n\nans = 1\n\nwhile N != 1:\n\n    if N % i == 0:\n\n        N //= i\n\n        check += 1\n\n    else:\n\n        ans *= check\n\n        check = 1\n\n        i += 1\n\nprint(((ans*check)%(10**9+7)))", "score": 1.0, "surface_similarity": 0.7094017094017094}
{"id": "p02988_u600402037", "golden_code": "import sys\n\nimport numpy as np\n\n\n\nsr = lambda: sys.stdin.readline().rstrip()\n\nir = lambda: int(sr())\n\nlr = lambda: list(map(int, sr().split()))\n\n\n\nN = ir()\n\nP = np.array(lr())\n\n\n\nP_diff = np.diff(P)\n\nP_diff = P_diff > 0\n\nseries = P_diff[:-1] == P_diff[1:]\n\nanswer = series.sum()\n\nprint(answer)\n\n# 23", "generated_code": "N = int(eval(input()))\n\nP = list(map(int, input().split()))\n\nanswer = sum(x>y>z or x<y<z for x, y, z in zip(P[:-2], P[1:-1], P[2:]))\n\nprint(answer)\n\n    ", "score": 1.0, "surface_similarity": 0.48745819397993306}
{"id": "p02982_u369133448", "golden_code": "import numpy as np\n\nn,d=list(map(int,input().split()))\n\nnda=np.empty((0,d),int)\n\nans=0\n\nfor i in range(0,n):\n\n  a=np.array([list(map(int,input().split()))])\n\n  for j in range(i):\n\n    chklen=np.linalg.norm(a-nda[j])\n\n    if chklen==chklen//1:\n\n      ans+=1\n\n  nda=np.append(nda,a,axis=0)\n\nprint(ans)", "generated_code": "import math\n\nn,d=list(map(int,input().split()))\n\na=[0]*n\n\nfor i in range(n):\n\n  a[i]=list(map(int,input().split()))\n\nans=0\n\nfor i in range(n-1):\n\n  for j in range(i+1,n):\n\n    chklen=0\n\n    wk=0\n\n    for k in range(d):\n\n      wk+=abs(a[i][k]-a[j][k])**2\n\n    chklen=math.sqrt(wk)\n\n    if chklen==chklen//1:\n\n      ans+=1\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.715528781793842}
{"id": "p03371_u693694535", "golden_code": "A,B,C,X,Y=list(map(int,input().split()))\n\n\n\nK=10**9\n\nfor i in range(10**5+1):\n\n    S=i*2*C+max(0,X-i)*A+max(0,Y-i)*B\n\n    K=min(K,S)\n\nprint(K)", "generated_code": "A,B,C,X,Y=list(map(int,input().split()))\n\n\n\na=min(X,Y)*min(A+B,2*C)\n\n\n\na+=max(0,X-Y)*min(A,2*C)\n\na+=max(0,Y-X)*min(B,2*C)\n\n\n\n\n\nprint(a)", "score": 1.0, "surface_similarity": 0.7251449875724938}
{"id": "p03032_u600402037", "golden_code": "N, K = list(map(int, input().split()))\n\nV = list(map(int, input().split()))\n\n\n\nanswer = 0\n\nlimit = min(N, K)\n\nfor a in range(limit+1): #左から取り出す\n\n    for b in range(limit-a+1): #右から取り出す\n\n        for c in range(K-(a+b)+1):\n\n            use = V[:a] + V[N-b:]\n\n            use.sort()\n\n            s = sum(use[c:])\n\n            answer = max(answer, s)\n\n\n\nprint(answer)", "generated_code": "import sys\n\nsys.setrecursionlimit(10 ** 9)\n\n\n\nN, K = list(map(int, input().split()))\n\nV = list(map(int, input().split()))\n\nV2 = V * 2\n\nanswer = 0\n\nfor i in range(1, min(N, K)+1): # iは宝石を取り出す個数\n\n    for j in range(0, min(i, K-i)+1): # jは何個の宝石を手離すか\n\n        for k in range(max(0, N-i), N+1): # V2の中で何番目から取り出すか\n\n            use = V2[k:k+i]\n\n            use.sort()\n\n            s = sum(use[j:])\n\n            if s > answer:\n\n                answer = s\n\n\n\nprint(answer)\n", "score": 1.0, "surface_similarity": 0.7260588455772115}
{"id": "p02390_u365686736", "golden_code": "S = int(input())\n\n\n\nif S >= 3600:\n\n    h=S//3600\n\n    m=S%3600//60\n\n    s=S%60\n\nelif 3600 > S >= 60:\n\n    h=0\n\n    m=S//60\n\n    s=S%60\n\nelse:\n\n    h=m=0\n\n    s=S\n\nprint(h, m, s, sep=\":\")\n", "generated_code": "s = int(input())\n\nh = s // 3600\n\nm = (s - h * 3600) // 60\n\ns = s -  h * 3600 - m * 60\n\nprint(h, m, s, sep=\":\")\n", "score": 1.0, "surface_similarity": 0.6264111705288176}
{"id": "p03806_u670180528", "golden_code": "def main():\n\n\tn, ma, mb, *L = list(map(int, open(0).read().split()))\n\n\tM = 1<<30\n\n\tdp = [[M] * 420 for _ in range(420)]\n\n\tdp[0][0] = 0\n\n\tfor a, b, c in zip(*[iter(L)] * 3):\n\n\t\tfor i in range(400, -1, -1):\n\n\t\t\tfor j in range(400, -1, -1):\n\n\t\t\t\tt = dp[i][j] + c\n\n\t\t\t\tif dp[i + a][j + b] > t:\n\n\t\t\t\t\tdp[i + a][j + b] = t\n\n\tans = M\n\n\t_ma, _mb = ma, mb\n\n\twhile _ma < 410 > _mb:\n\n\t\tans = min(ans, dp[_ma][_mb])\n\n\t\t_ma += ma\n\n\t\t_mb += mb\n\n\tprint((ans if ans < M else -1))\n\n\n\nif __name__==\"__main__\":\n\n\tmain()", "generated_code": "def main():\n\n\tn, ma, mb, *L = list(map(int, open(0).read().split()))\n\n\tM = 1 << 30\n\n\tdp = [[M] * 420 for _ in range(420)]\n\n\tdp[0][0] = 0\n\n\tua = ub = 15\n\n\tfor a, b, c in zip(*[iter(L)] * 3):\n\n\t\tfor i in range(ua, -1, -1):\n\n\t\t\tfor j in range(ub, -1, -1):\n\n\t\t\t\tt = dp[i][j] + c\n\n\t\t\t\tif dp[i + a][j + b] > t:\n\n\t\t\t\t\tdp[i + a][j + b] = t\n\n\t\t\t\t\tif ua < i + a:\n\n\t\t\t\t\t\tua = i + a\n\n\t\t\t\t\tif ub < j + b:\n\n\t\t\t\t\t\tub = j + b\n\n\tans = M\n\n\t_ma, _mb = ma, mb\n\n\twhile _ma < 410 > _mb:\n\n\t\tans = min(ans, dp[_ma][_mb])\n\n\t\t_ma += ma\n\n\t\t_mb += mb\n\n\tprint((ans if ans < M else -1))\n\n\n\n\n\nif __name__ == \"__main__\":\n\n\tmain()\n", "score": 1.0, "surface_similarity": 0.9590301003344481}
{"id": "p03494_u556594202", "golden_code": "import numpy as np\n\n\n\nn = int(eval(input()))\n\na = np.array(list(map(int,input().split())))\n\n\n\ncount = 0\n\nwhile np.all(a%2==0):\n\n    count+=1\n\n    a=a/2\n\nprint(count)\n", "generated_code": "N=int(eval(input()))\n\na = [int(i) for i in input().split()]\n\n\n\ncount=0\n\nwhile 1:\n\n    if sum([i%2 for i in a]) == 0:\n\n        a = [i/2 for i in a]\n\n        count=count+1\n\n    else:\n\n        print(count)\n\n        break\n", "score": 1.0, "surface_similarity": 0.6391104906262465}
{"id": "p03434_u729133443", "golden_code": "_,s=open(c:=0)\n\nfor a in sorted(map(int,s.split())):c=a-c\n\nprint(c)", "generated_code": "for a in sorted(map(int,[*open(c:=0)][1].split())):c=a-c\n\nprint(c)", "score": 1.0, "surface_similarity": 0.6297678275290215}
{"id": "p02883_u168139048", "golden_code": "import sys\n\nsys.setrecursionlimit(10000000)\n\nimport heapq\n\nimport math\n\n \n\ndef main():\n\n    N, K = list(map(int, input().split()))\n\n    A = [int(c) for c in input().split()]\n\n    F = [int(c) for c in input().split()]\n\n    \n\n    A.sort()\n\n    F.sort(reverse=True)\n\n \n\n    num = 0\n\n    sum_ = []\n\n    for i in range(N):\n\n      sum_.append(A[i] * F[i])\n\n    left = 0\n\n    right = 10 ** 12\n\n    while(num < 90):\n\n        number = 0\n\n        mid = (left + right) // 2\n\n        # print(mid)\n\n        for i in range(len(A)):\n\n            if sum_[i] <= mid:\n\n                continue\n\n            else:\n\n                number += math.ceil((sum_[i] - mid) / F[i])\n\n            # print(number)\n\n        if number > K:\n\n            # 最大値をmidより小さくできない -> 最大値はもっとでかい\n\n            left = mid + 1\n\n        else:\n\n            right = mid\n\n        num += 1\n\n    print(mid)\n\n                \n\n        \n\n \n\n \n\n \n\nif __name__ == '__main__':\n\n    main()", "generated_code": "import sys\n\nsys.setrecursionlimit(10000000)\n\nimport heapq\n\nimport math\n\n\n\ndef main():\n\n    N, K = list(map(int, input().split()))\n\n    A = [int(c) for c in input().split()]\n\n    F = [int(c) for c in input().split()]\n\n    \n\n    A.sort()\n\n    F.sort(reverse=True)\n\n\n\n    num = 0\n\n    sum_ = []\n\n    for i in range(len(A)):\n\n        sum_.append(A[i] * F[i])\n\n    left = 0\n\n    right = 10 ** 12\n\n    while(num < 50):\n\n        number = 0\n\n        mid = (left + right) // 2\n\n        # print(mid)\n\n        for i in range(len(A)):\n\n            if sum_[i] <= mid:\n\n                continue\n\n            else:\n\n                number += math.ceil((sum_[i] - mid) / F[i])\n\n            # print(number)\n\n        if number > K:\n\n            # 最大値をmidより小さくできない -> 最大値はもっとでかい\n\n            left = mid + 1\n\n        else:\n\n            right = mid\n\n        num += 1\n\n    print(mid)\n\n                \n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 1.0, "surface_similarity": 0.9962486602357985}
{"id": "p03854_u738622346", "golden_code": "s = eval(input())\n\nt = \"\"\n\nwhile len(t) < len(s):\n\n    target_len = len(s) - len(t)\n\n\n\n    if s[len(t)] == 'd':\n\n        if target_len == 5:\n\n            t += \"dream\"\n\n        elif target_len == 7:\n\n            t += \"dreamer\"\n\n        elif target_len > 7:\n\n            if s[len(t) + 5] != 'd' and s[len(t) + 5:len(t) + 7 + 1] != \"era\":\n\n                t += \"dreamer\"\n\n            else:\n\n                t += \"dream\"\n\n        else:\n\n            break\n\n    else:\n\n        if target_len == 5:\n\n            t += \"erase\"\n\n        elif target_len == 6:\n\n            t += \"eraser\"\n\n        elif target_len > 6:\n\n            if s[len(t) + 5] != 'd' and s[len(t) + 5:len(t) + 6 + 2] != \"era\":\n\n                t += \"eraser\"\n\n            else:\n\n                t += \"erase\"\n\n        else:\n\n            break\n\n\n\n    if s[0:len(t)] != t:\n\n        break\n\n\n\nprint((\"YES\" if s == t else \"NO\"))\n", "generated_code": "s = eval(input())\n\ndiv = [\"dream\", \"dreamer\", \"erase\", \"eraser\"]\n\nrev = []\n\nt = \"\"\n\ns_rev = s[::-1]\n\nfor d in div:\n\n    rev.append(d[::-1])\n\n\n\nresult = True\n\ni = 0\n\nwhile i < len(s):\n\n    can_divide = False\n\n    for d in rev:\n\n        if len(s_rev) - i >= len(d) and s_rev[i:i + len(d)] == d:\n\n            can_divide = True\n\n            i += len(d)\n\n            break\n\n    if not can_divide:\n\n        result = False\n\n        break\n\n\n\nprint((\"YES\" if result else \"NO\"))\n", "score": 1.0, "surface_similarity": 0.6535984848484848}
{"id": "p00134_u808429775", "golden_code": "from statistics import mean\n\n\n\ninputCount = int(eval(input()))\n\nprices = [int(eval(input())) for lp in range(inputCount)]\n\naverage = mean(prices)\n\nprint((int(average)))\n\n\n", "generated_code": "inputCount = int(eval(input()))\n\nprices = [int(eval(input())) for lp in range(inputCount)]\n\naverage = sum(prices) // inputCount\n\nprint(average)\n\n\n", "score": 1.0, "surface_similarity": 0.7204228520017993}
{"id": "p03559_u645250356", "golden_code": "from collections import Counter,defaultdict,deque\n\nfrom heapq import heappop,heappush,heapify\n\nimport sys,bisect,math,itertools,fractions,pprint\n\nsys.setrecursionlimit(10**8)\n\nmod = 10**9+7\n\nINF = float('inf')\n\ndef inp(): return int(sys.stdin.readline())\n\ndef inpl(): return list(map(int, sys.stdin.readline().split()))\n\n\n\nn = inp()\n\nA = sorted(inpl())\n\nB = sorted(inpl())\n\nC = sorted(inpl())\n\ncnt = [0] * n\n\nres = 0\n\nfor i,b in enumerate(B):\n\n    c = bisect.bisect_left(C,b+1)\n\n    cnt[i] = n-c\n\n\n\nacc = [0]\n\nfor x in cnt:\n\n    acc += [acc[-1] + x]\n\nsu = sum(cnt) \n\nfor i,a in enumerate(A):\n\n    c = bisect.bisect_left(B,a+1)\n\n    res += su - acc[c]\n\nprint(res)", "generated_code": "from collections import Counter,defaultdict,deque\n\nfrom heapq import heappop,heappush,heapify\n\nimport sys,bisect,math,itertools,fractions,pprint\n\nsys.setrecursionlimit(10**8)\n\nmod = 10**9+7\n\nINF = float('inf')\n\ndef inp(): return int(sys.stdin.readline())\n\ndef inpl(): return list(map(int, sys.stdin.readline().split()))\n\n\n\nn = inp()\n\na = inpl()\n\nb = inpl()\n\nc = inpl()\n\na.sort()\n\nb.sort()\n\nc.sort()\n\nlb = [0] * n\n\nres = 0\n\nfor i in range(n):\n\n    tmp = bisect.bisect_right(b,a[i])\n\n    if tmp == n: continue\n\n    lb[tmp] += 1\n\nllb = list(itertools.accumulate(lb))\n\n# print(lb,llb)\n\nrr = [0] * n\n\nfor i in range(n):\n\n    tmp = bisect.bisect_right(c,b[i])\n\n    if tmp == n: continue\n\n    rr[tmp] += llb[i]\n\nprint((sum(list(itertools.accumulate(rr)))))", "score": 1.0, "surface_similarity": 0.7354806408544726}
{"id": "p02690_u194472175", "golden_code": "X=int(eval(input()))\n\nx=0\n\nlist=[]\n\nfor i in range(-118,120,1):\n\n\n\n    for j in range(-119,119,1):\n\n        x=i**5-j**5\n\n        if x==X:\n\n            list.append((str(i)+' '+str(j)))\n\n\n\nprint((list[0]))", "generated_code": "X=int(eval(input()))\n\nx=0\n\nlist=[]\n\nfor i in range(-118,120,1):\n\n    for j in range(-119,119,1):\n\n        x=i**5-j**5\n\n        if x==X:\n\n            print((str(i)+' '+str(j)))\n\n            break\n\n    else:\n\n        continue\n\n    break\n", "score": 1.0, "surface_similarity": 0.8277482269503547}
{"id": "p00144_u811733736", "golden_code": "# -*- coding: utf-8 -*-\n\n\"\"\"\n\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0144\n\n\n\n\"\"\"\n\nimport sys\n\nfrom sys import stdin\n\ninput = stdin.readline\n\nfrom enum import Enum\n\n\n\n\n\nclass Graph(object):\n\n    \"\"\" single source shortest path \"\"\"\n\n    class Status(Enum):\n\n        \"\"\" ?????????????¨??????¶??? \"\"\"\n\n        white = 1  # ????¨????\n\n        gray = 2  # ?¨???????\n\n        black = 3  #?¨???????\n\n\n\n    def __init__(self, n, data):\n\n        self.num_of_nodes = n+1\n\n        self.color = [Graph.Status.white] * self.num_of_nodes  # ????????????????¨??????¶???\n\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n\n        for i in range(self.num_of_nodes):\n\n            self.M[i][i] = 0\n\n        self._make_matrix(data)  # data????????????????????£??\\??????(?????\\?¶???¨???????????????????????§????????????)\n\n        self.d = [float('inf')] * self.num_of_nodes  # ?§???????????????????(?????????)\n\n        self.p = [-1] * self.num_of_nodes  # ????????????????????????????¨?????????????????????????\n\n\n\n    def _make_matrix(self, data):\n\n        for d in data:\n\n            r = d[0]\n\n            for t in d[2:]:\n\n                self.M[r][t] = 1\n\n\n\n    def dijkstra(self, start):\n\n        self.d[start] = 0\n\n        self.p[start] = -1\n\n        while True:\n\n            mincost = float('inf')\n\n            # ??\\??????????????§??????????????¨?????????????????????u???????????????\n\n            for i in range(len(self.d)):\n\n                if self.color[i] != Graph.Status.black and self.d[i] < mincost:  # S????±???????????????????S??¨??\\?¶?????????????????????????????????????????°???????????????????\n\n                    mincost = self.d[i]\n\n                    u = i  # u??????????????????ID\n\n            if mincost == float('inf'):\n\n                break\n\n            self.color[u] = Graph.Status.black  # ?????????u???S????±???????????????´???\n\n            for v in range(len(self.d)):\n\n                if self.color[v] != Graph.Status.black and self.M[u][v] != float('inf'):\n\n                    # v????????????????????????????????°??????S???????????£???u????????????????????????????????????????????°??????????????±??§??´??°??????\n\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n\n                        self.d[v] = self.d[u] + self.M[u][v]\n\n                        self.p[v] = u\n\n                        self.color[v] = Graph.Status.gray\n\n\n\n    def warshallFloyd(self):\n\n        V = self.num_of_nodes\n\n        for k in range(V):\n\n            for i in range(V):\n\n                for j in range(V):\n\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\n\n\n\n\n\n\n\ndef main(args):\n\n    n = int(eval(input()))\n\n    network = []\n\n    for _ in range(n):\n\n        network.append([int(x) for x in input().split()])\n\n\n\n    packets = []\n\n    p = int(eval(input()))\n\n    for _ in range(p):\n\n        packets.append([int(x) for x in input().split()])\n\n\n\n    g = Graph(n, network)\n\n    g.warshallFloyd()\n\n\n\n    for s, d, v in packets:\n\n        if g.M[s][d] < v:\n\n            print((g.M[s][d]+1))\n\n        else:\n\n            print('NA')\n\n\n\n\n\n\n\nif __name__ == '__main__':\n\n    main(sys.argv[1:])", "generated_code": "# -*- coding: utf-8 -*-\n\n\"\"\"\n\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0144\n\n\n\n\"\"\"\n\nimport sys\n\nfrom sys import stdin\n\ninput = stdin.readline\n\nfrom enum import Enum\n\n\n\n\n\nclass Graph(object):\n\n    \"\"\" single source shortest path \"\"\"\n\n    class Status(Enum):\n\n        \"\"\" ?????????????¨??????¶??? \"\"\"\n\n        white = 1  # ????¨????\n\n        gray = 2  # ?¨???????\n\n        black = 3  #?¨???????\n\n\n\n    def __init__(self, n, data):\n\n        self.num_of_nodes = n+1\n\n        self.color = [Graph.Status.white] * self.num_of_nodes  # ????????????????¨??????¶???\n\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n\n        for i in range(self.num_of_nodes):\n\n            self.M[i][i] = 0\n\n        self._make_matrix(data)  # data????????????????????£??\\??????(?????\\?¶???¨???????????????????????§????????????)\n\n        self.d = [float('inf')] * self.num_of_nodes  # ?§???????????????????(?????????)\n\n        self.p = [-1] * self.num_of_nodes  # ????????????????????????????¨?????????????????????????\n\n\n\n    def _make_matrix(self, data):\n\n        for d in data:\n\n            r = d[0]\n\n            for t in d[2:]:\n\n                self.M[r][t] = 1\n\n\n\n    def dijkstra(self, start):\n\n        self.d[start] = 0\n\n        self.p[start] = -1\n\n        while True:\n\n            mincost = float('inf')\n\n            # ??\\??????????????§??????????????¨?????????????????????u???????????????\n\n            for i in range(len(self.d)):\n\n                if self.color[i] != Graph.Status.black and self.d[i] < mincost:  # S????±???????????????????S??¨??\\?¶?????????????????????????????????????????°???????????????????\n\n                    mincost = self.d[i]\n\n                    u = i  # u??????????????????ID\n\n            if mincost == float('inf'):\n\n                break\n\n            self.color[u] = Graph.Status.black  # ?????????u???S????±???????????????´???\n\n            for v in range(len(self.d)):\n\n                if self.color[v] != Graph.Status.black and self.M[u][v] != float('inf'):\n\n                    # v????????????????????????????????°??????S???????????£???u????????????????????????????????????????????°??????????????±??§??´??°??????\n\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n\n                        self.d[v] = self.d[u] + self.M[u][v]\n\n                        self.p[v] = u\n\n                        self.color[v] = Graph.Status.gray\n\n\n\n    def warshallFloyd(self):\n\n        for k in range(self.num_of_nodes):\n\n            for i in range(self.num_of_nodes):\n\n                for j in range(self.num_of_nodes):\n\n                    if self.M[i][k] + self.M[k][j] < self.M[i][j]: \n\n                        self.M[i][j] = self.M[i][k] + self.M[k][j]\n\n\n\n\n\ndef main(args):\n\n    n = int(eval(input()))\n\n    network = []\n\n    for _ in range(n):\n\n        network.append([int(x) for x in input().split()])\n\n\n\n    packets = []\n\n    p = int(eval(input()))\n\n    for _ in range(p):\n\n        packets.append([int(x) for x in input().split()])\n\n\n\n    g = Graph(n, network)\n\n    g.warshallFloyd()\n\n\n\n    for s, d, v in packets:\n\n        if g.M[s][d] < v:\n\n            print((g.M[s][d]+1))\n\n        else:\n\n            print('NA')\n\n\n\n\n\n\n\nif __name__ == '__main__':\n\n    main(sys.argv[1:])", "score": 1.0, "surface_similarity": 0.9878011117974058}
{"id": "p03553_u102461423", "golden_code": "import sys\n\ninput = sys.stdin.readline\n\nfrom scipy.sparse.csgraph import dijkstra\n\nimport numpy as np\n\n\n\n\"\"\"\n\n最小カット\n\n\"\"\"\n\n\n\nN = int(eval(input()))\n\nstart = 0\n\ngoal = N+1\n\n\n\nA = [0] + [int(x) for x in input().split()]\n\n\n\nINF = 10 ** 12\n\ngraph = np.zeros((N+2,N+2),dtype=np.int64)\n\nfor i,a in enumerate(A[1:],1):\n\n    if a >= 0:\n\n        graph[start,i] = a\n\n    else:\n\n        graph[i,goal] = -a\n\nfor i in range(1,N+1):\n\n    for j in range(2*i,N+1,i):\n\n        if A[i] < 0 and A[j] > 0:\n\n            graph[j][i] = INF\n\n\n\ndef max_flow(graph):\n\n    flow = 0\n\n    while True:\n\n        dist,pred = dijkstra(graph, indices = start, return_predecessors = True, unweighted = True)\n\n        if dist[goal] == np.inf:\n\n            return flow\n\n        path = []\n\n        v = goal\n\n        while True:\n\n            path.append((pred[v],v))\n\n            v = pred[v]\n\n            if v == start:\n\n                break\n\n        add_flow = min(graph[x][y] for x,y in path)\n\n        for x,y in path:\n\n            graph[x][y] -= add_flow\n\n            graph[y][x] += add_flow\n\n        flow += add_flow\n\n\n\nanswer = sum(x for x in A if x > 0) - max_flow(graph)\n\nprint(answer)", "generated_code": "import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\nfrom collections import deque\n\n\n\nN,*A = list(map(int,read().split()))\n\n\n\nclass Dinic:\n\n    def __init__(self, N, source, sink):\n\n        self.N = N\n\n        self.G = [[] for _ in range(N)]\n\n        self.source = source\n\n        self.sink = sink\n\n\n\n    def add_edge(self, fr, to, cap):\n\n        n1 = len(self.G[fr])\n\n        n2 = len(self.G[to])\n\n        self.G[fr].append([to, cap, n2])\n\n        self.G[to].append([fr, 0, n1]) # 逆辺を cap 0 で追加\n\n        \n\n    def add_edge_undirected(self, fr, to, cap):\n\n        n1 = len(self.G[fr])\n\n        n2 = len(self.G[to])\n\n        self.G[fr].append([to, cap, n2])\n\n        self.G[to].append([fr, cap, n1])\n\n        \n\n    def bfs(self):\n\n        level = [0] * self.N\n\n        G = self.G; source = self.source; sink = self.sink\n\n        q = deque([source])\n\n        level[source] = 1\n\n        pop = q.popleft; append = q.append\n\n        while q:\n\n            v = pop()\n\n            lv = level[v] + 1\n\n            for to, cap, rev in G[v]:\n\n                if not cap:\n\n                    continue\n\n                if level[to]:\n\n                    continue\n\n                level[to] = lv\n\n                if to == sink:\n\n                    self.level = level\n\n                    return\n\n                append(to)\n\n        self.level = level\n\n        \n\n    def dfs(self,v,f):\n\n        if v == self.sink:\n\n            return f\n\n        G = self.G\n\n        prog = self.progress\n\n        level = self.level\n\n        lv = level[v]\n\n        E = G[v]\n\n        for i in range(prog[v],len(E)):\n\n            to, cap, rev = E[i]\n\n            prog[v] = i\n\n            if not cap:\n\n                continue\n\n            if level[to] <= lv:\n\n                continue\n\n            x = f if f < cap else cap\n\n            ff = self.dfs(to, x)\n\n            if ff:\n\n                E[i][1] -= ff\n\n                G[to][rev][1] += ff\n\n                return ff\n\n        return 0\n\n    \n\n    def max_flow(self):\n\n        INF = 10**18\n\n        flow = 0\n\n        while True:\n\n            self.bfs()\n\n            if not self.level[self.sink]:\n\n                return flow\n\n            self.progress = [0] * self.N\n\n            while True:\n\n                f = self.dfs(self.source, INF)\n\n                if not f:\n\n                    break\n\n                flow += f\n\n        return flow\n\n\n\nsource = 0; sink = N+1; INF = 10 ** 18\n\ndinic = Dinic(N+2,source,sink)\n\nadd = dinic.add_edge\n\n\n\nfor i,x in enumerate(A,1):\n\n    if x < 0:\n\n        # source側：割るものを表現。sink側にうつすときにカット-xが必要。\n\n        add(source,i,-x)\n\n    else:\n\n        # sink側：割らないものを表現。source側にうつすときにカットxが必要。\n\n        add(i,sink,x)\n\n\n\nfor i in range(1,N+1):\n\n    for j in range(i+i,N+1,i):\n\n        # iを割るならjも割る。iを割ってjを割らないのは禁止\n\n        # iがsourceでjがsinkなのは禁止\n\n        add(i,j,INF)\n\n\n\nf = dinic.max_flow()\n\nx = sum(x for x in A if x >= 0)\n\nanswer = x - f\n\n\n\nprint(answer)", "score": 1.0, "surface_similarity": 0.6754496463455709}
{"id": "p02814_u600402037", "golden_code": "import sys\n\nimport numpy as np\n\nfrom fractions import gcd\n\nfrom functools import reduce\n\n\n\nsr = lambda: sys.stdin.readline().rstrip()\n\nir = lambda: int(sr())\n\nlr = lambda: list(map(int, sr().split()))\n\n\n\nN, M = lr()\n\nA = np.array(lr())\n\nB = A // 2\n\n# Bの要素が全て2の同じ冪乗\n\n# Bの最小公倍数を求める\n\ndef merge(a, b):\n\n    g = gcd(a, b)\n\n    a, b = a // g, b // g\n\n    if a%2 == 0 or b%2 == 0:\n\n        return 0\n\n    ret = a * b * g\n\n    if ret > 10 ** 9:\n\n        return 0\n\n    return ret\n\n\n\nx = reduce(merge, B)\n\nif x == 0:\n\n    answer = 0\n\nelse:\n\n    answer = M // x - M // (2*x)\n\n\n\nprint(answer)\n\n# 56", "generated_code": "import sys\n\nfrom fractions import gcd\n\n\n\nsr = lambda: sys.stdin.readline().rstrip()\n\nir = lambda: int(sr())\n\nlr = lambda: list(map(int, sr().split()))\n\n\n\n# A が2で何回割れるか\n\nN, M = lr()\n\nA = lr()\n\nA = [x // 2 for x in A]\n\ncnt = 0\n\nwhile all(x%2 == 0 for x in A):\n\n    cnt += 1\n\n    A = [x // 2 for x in A]\n\n\n\nif any(x%2 == 0 for x in A):\n\n    print((0)); exit()\n\n\n\nlcm = 1\n\nfor a in A:\n\n    lcm *= a // gcd(lcm, a)\n\n\n\nanswer = M // (2 ** cnt * lcm) - M // (2 ** (cnt+1) * lcm)\n\nprint(answer)\n\n# 21\n", "score": 1.0, "surface_similarity": 0.643982443982444}
{"id": "p02552_u145950990", "golden_code": "x = int(eval(input()))\n\nprint((0 if x==1 else 1))", "generated_code": "s = eval(input())\n\nif s == '0':\n\n  print((1))\n\nelse:\n\n  print((0))", "score": 1.0, "surface_similarity": 0.6742424242424243}
{"id": "p02268_u600065151", "golden_code": "def binarySearch():\n\n    n = int(eval(input()))\n\n    S = set(map(int, input().split()))\n\n    q = int(eval(input()))\n\n    T = set(map(int, input().split()))\n\n    print((len(S.intersection(T))))\n\n    \n\n\n\nbinarySearch()", "generated_code": "def binarySearch():\n\n    n = int(eval(input()))\n\n    S = set(input().split())\n\n    q = int(eval(input()))\n\n    T = set(input().split())\n\n    print((len(S.intersection(T))))\n\n    \n\n\n\nbinarySearch()", "score": 1.0, "surface_similarity": 0.9583333333333333}
{"id": "p03416_u996434204", "golden_code": "a,b=list(map(int,input().split()))\n\n\n\nans=0\n\n\n\nfor i in range(a,b+1):\n\n    buf=str(i)\n\n    #print(buf[0:int(len(buf)/2)],buf[int(len(buf)/2+1):])\n\n    str1=buf[0:int(len(buf)/2)]\n\n    str2=buf[int(len(buf)/2+1):]\n\n    if str1[0]==str2[1] and str1[1]==str2[0]:\n\n        ans+=1\n\n\n\nprint(ans)\n", "generated_code": "a,b=list(map(int,input().split()))\n\n\n\nans=0\n\n\n\nfor i in range(a,b+1):\n\n    buf=str(i)\n\n    str1=buf[::-1]\n\n    if buf==str1:\n\n        ans+=1\n\n\n\nprint(ans)\n", "score": 1.0, "surface_similarity": 0.7558620689655172}
{"id": "p02725_u490553751", "golden_code": "#template\n\ndef inputlist(): return [int(j) for j in input().split()]\n\n#template\n\n#issueから始める\n\nK,N = inputlist()\n\nA = inputlist()\n\nlia = [0]*N\n\nfor i in range(1,N):\n\n    k = A[i] - A[i-1]\n\n    lia[i] = k\n\nlia[0] = (K+A[0]-A[-1])\n\nlia.sort()\n\nans = 0\n\nfor i in range(N-1):\n\n    ans += lia[i]\n\nprint(ans)", "generated_code": "#template\n\ndef inputlist(): return [int(j) for j in input().split()]\n\ndef listinput(): return input().split()\n\n#template\n\nK,N = inputlist()\n\nA = inputlist()\n\ndis = [0]*(N)\n\nfor i in range(N):\n\n    if i == N-1:\n\n        dis[i] = K+A[0] - A[i]\n\n        continue\n\n    dis[i] = A[i+1] - A[i]\n\ndis.sort()\n\nprint((sum(dis[:-1])))", "score": 1.0, "surface_similarity": 0.7159193049036252}
{"id": "p03000_u600402037", "golden_code": "import sys\n\nimport numpy as np\n\n\n\nsr = lambda: sys.stdin.readline().rstrip()\n\nir = lambda: int(sr())\n\nlr = lambda: list(map(int, sr().split()))\n\n\n\nN, X = lr()\n\nL = np.array([0] + lr())\n\nLcum = L.cumsum()\n\ni = np.searchsorted(Lcum, X, side='right')\n\nprint(i)\n\n# ", "generated_code": "# coding: utf-8\n\nimport sys\n\n\n\nsr = lambda: sys.stdin.readline().rstrip()\n\nir = lambda: int(sr())\n\nlr = lambda: list(map(int, sr().split()))\n\n\n\nN, X = lr()\n\nL = lr()\n\ncnt = 1\n\ncur = 0\n\nfor l in L:   \n\n    cur += l\n\n    if cur > X:\n\n        break\n\n    cnt += 1\n\n\n\nanswer = cnt\n\nprint(answer)\n", "score": 1.0, "surface_similarity": 0.6664518900343642}
{"id": "p02767_u624696727", "golden_code": "import sys\n\nimport numpy as np\n\n\n\nsys.setrecursionlimit(10 ** 6)\n\nint1 = lambda x: int(x) - 1\n\nprintV = lambda x: print(*x, sep=\"\\n\")\n\nprintH = lambda x: print(\" \".join(map(str,x)))\n\ndef IS(): return sys.stdin.readline()[:-1]\n\ndef II(): return int(sys.stdin.readline())\n\ndef MI(): return map(int, sys.stdin.readline().split())\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\n\ndef LI1(): return list(map(int1, sys.stdin.readline().split()))\n\ndef LII(rows_number): return [II() for _ in range(rows_number)]\n\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\n\ndef LLI1(rows_number): return [LI1() for _ in range(rows_number)]\n\n\n\ndef main():\n\n\tN = II()\n\n\tX = LI()\n\n\tX = np.array(X)\n\n\tm = round(np.sum(X) / N)\n\n\tprint(int(np.sum((X-m)**2)))\n\n\n\nif __name__ == '__main__':\n\n\tmain()\n", "generated_code": "import sys\n\n\n\nsys.setrecursionlimit(10 ** 6)\n\nint1 = lambda x: int(x) - 1\n\nprintV = lambda x: print(*x, sep=\"\\n\")\n\nprintH = lambda x: print(\" \".join(map(str,x)))\n\ndef IS(): return sys.stdin.readline()[:-1]\n\ndef II(): return int(sys.stdin.readline())\n\ndef MI(): return map(int, sys.stdin.readline().split())\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\n\ndef LI1(): return list(map(int1, sys.stdin.readline().split()))\n\ndef LII(rows_number): return [II() for _ in range(rows_number)]\n\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\n\ndef LLI1(rows_number): return [LI1() for _ in range(rows_number)]\n\n\n\ndef main():\n\n\tN = II()\n\n\tX = LI()\n\n\tm = round(sum(X) / N)\n\n\tans = 0\n\n\tfor x in X:\n\n\t\tans += ((x-m)**2)\n\n\tprint(ans)\n\n\n\nif __name__ == '__main__':\n\n\tmain()\n", "score": 1.0, "surface_similarity": 0.9179470295580918}
{"id": "p03720_u537976628", "golden_code": "n, m = list(map(int, input().split()))\n\nRD = list(list(map(int, input().split())) for _ in range(m))\n\nfor i in range(1, n + 1):\n\n    ans = 0\n\n    for j in RD:\n\n        ans += j.count(i)\n\n    print(ans)", "generated_code": "n, m = list(map(int, input().split()))\n\nNRD = list(0 for i in range(n))\n\nfor i in range(m):\n\n    r1, r2 = list(map(int, input().split()))\n\n    NRD[r1 - 1] += 1\n\n    NRD[r2 - 1] += 1\n\nfor i in range(n):\n\n    print((NRD[i]))", "score": 1.0, "surface_similarity": 0.7025841631104789}
{"id": "p03371_u393253137", "golden_code": "a,b,c,x,y=list(map(int,input().split()))\n\nans=a*x+b*y\n\nfor HaH in range(0,2*max(x,y)+1,2):\n\n    ans = min(ans, c*HaH+max(0, a*(x-HaH//2))+max(0, b*(y-HaH//2)))\n\nprint(ans)", "generated_code": "a,b,c,x,y=list(map(int,input().split()))\n\nans=0\n\nm=min(x,y)\n\nif a+b>=2*c: #Half and Half購入で安くなる可能性あるパターン\n\n    # HaHをm枚買って残りHaH購入,または全部HaH購入,このいずれかしかあり得ない\n\n    ans = min(2*c*m+a*(x-m)+b*(y-m), 2*c*max(x,y))\n\nelse:\n\n    ans = a*x+b*y\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.7058696123023609}
{"id": "p02994_u600402037", "golden_code": "import sys\n\nimport numpy as np\n\n\n\nsr = lambda: sys.stdin.readline().rstrip()\n\nir = lambda: int(sr())\n\nlr = lambda: list(map(int, sr().split()))\n\n\n\nN, L = lr()\n\nA = np.arange(1, N+1)\n\nA += (L - 1)\n\nanswer = A.sum() - A[np.argmin(np.abs(A))]\n\nprint(answer)", "generated_code": "import sys\n\n\n\nsr = lambda: sys.stdin.readline().rstrip()\n\nir = lambda: int(sr())\n\nlr = lambda: list(map(int, sr().split()))\n\n\n\nN, L = lr()\n\ntotal = sum(range(L, L+N))\n\nsub = min(list(range(L, L+N)), key=abs)\n\nprint((total-sub))\n", "score": 1.0, "surface_similarity": 0.7274090738657668}
{"id": "p03078_u892487306", "golden_code": "import numpy as np\n\n\n\n\n\ndef main():\n\n    X, Y, Z, K = list(map(int, input().split(' ')))\n\n    A = np.array(list(map(int, input().split(' '))))\n\n    B = np.array(list(map(int, input().split(' '))))\n\n    C = np.array(list(map(int, input().split(' '))))\n\n    AB = np.array(np.meshgrid(A, B)).T.reshape(-1, 2).sum(axis=1)\n\n    AB[::-1].sort()\n\n    AB = AB[:min([K, X * Y])]\n\n    ABC = np.array(np.meshgrid(AB, C)).T.reshape(-1, 2).sum(axis=1)\n\n    ABC[::-1].sort()\n\n    for ans in ABC[:K]:\n\n        print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()", "generated_code": "from heapq import heappush, heappop\n\nfrom collections import defaultdict\n\n\n\n\n\ndef main():\n\n    X, Y, Z, K = list(map(int, input().split(' ')))\n\n    A = list(map(int, input().split(' ')))\n\n    B = list(map(int, input().split(' ')))\n\n    C = list(map(int, input().split(' ')))\n\n    A.sort(reverse=True)\n\n    B.sort(reverse=True)\n\n    C.sort(reverse=True)\n\n    que = [(- A[0] - B[0] - C[0], 0, 0, 0)]  # multiply -1 to change min to max\n\n    already_inserted = defaultdict(int)\n\n    answer = list()\n\n    for _ in range(K):\n\n        q, i, j, k = heappop(que)\n\n        answer.append(-q)\n\n        if i + 1 < X:\n\n            item_a = (- A[i + 1] - B[j] - C[k], i + 1, j, k)\n\n            if already_inserted[item_a] == 0:\n\n                heappush(que, item_a)\n\n                already_inserted[item_a] = 1\n\n        if j + 1 < Y:\n\n            item_b = (- A[i] - B[j + 1] - C[k], i, j + 1, k)\n\n            if already_inserted[item_b] == 0:\n\n                heappush(que, item_b)\n\n                already_inserted[item_b] = 1\n\n        if k + 1 < Z:\n\n            item_c = (- A[i] - B[j] - C[k + 1], i, j, k + 1)\n\n            if already_inserted[item_c] == 0:\n\n                heappush(que, item_c)\n\n                already_inserted[item_c] = 1\n\n    for ans in answer:\n\n        print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()", "score": 1.0, "surface_similarity": 0.65202834799609}
{"id": "p03325_u298297089", "golden_code": "N = int(eval(input()))\n\nx = list(map(int, input().split()))\n\ncnt = 0\n\nfor i in x:\n\n  while i % 2 == 0:\n\n    cnt += 1\n\n    i /= 2\n\nprint(cnt)", "generated_code": "n = int(eval(input()))\n\nans = 0\n\nfor i in map(int, input().split()):\n\n    cnt = 0\n\n    while i % 2 == 0:\n\n        i >>= 1\n\n        cnt += 1\n\n    ans += cnt\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.8365899779388591}
{"id": "p03273_u600402037", "golden_code": "# coding: utf-8\n\nimport sys\n\nimport numpy as np\n\n\n\nsr = lambda: sys.stdin.readline().rstrip()\n\nir = lambda: int(sr())\n\nlr = lambda: list(map(int, sr().split()))\n\n\n\nH, W = lr()\n\nB = np.array([list(sr()) for _ in range(H)])\n\nA = [[1 if x == '#' else 0 for x in b] for b in B]\n\nrow = np.sum(A, axis=1)\n\ncolumn = np.sum(A, axis=0)\n\nr = row != 0\n\nc = column != 0\n\nanswer = B[r]\n\nanswer = answer[:, c].tolist()\n\nfor a in answer:\n\n    print((''.join(a)))\n", "generated_code": "# coding: utf-8\n\nimport sys\n\n\n\nsr = lambda: sys.stdin.readline().rstrip()\n\nir = lambda: int(sr())\n\nlr = lambda: list(map(int, sr().split()))\n\n\n\nH, W = lr()\n\nA = [sr() for _ in range(H)]\n\nB = []\n\nfor a in A:\n\n    if '#' in a:\n\n        B.append(a)\n\n\n\nB = zip(*[b for b in zip(*B) if '#' in b])\n\nfor b in B:\n\n    print(*b, sep='')\n", "score": 1.0, "surface_similarity": 0.6280505952380953}
{"id": "p02649_u488401358", "golden_code": "def popcount(x):\n\n    x = x - ((x >> 1) & 0x55555555)\n\n    x = (x & 0x33333333) + ((x >> 2) & 0x33333333)\n\n    x = (x + (x >> 4)) & 0x0f0f0f0f\n\n    x = x + (x >> 8)\n\n    x = x + (x >> 16)\n\n    return x & 0x0000007f\n\n\n\ncmb=[[0 for i in range(51)] for j in range(51)]\n\ncmb[0][0]=1\n\nfor i in range(51):\n\n    for j in range(51):\n\n        if i!=50 and j!=50:\n\n            cmb[i+1][j+1]+=cmb[i][j]\n\n        if i!=50:\n\n            cmb[i+1][j]+=cmb[i][j]\n\n\n\nfor i in range(1,51):\n\n    for j in range(2,51):\n\n        cmb[i][j]+=cmb[i][j-1]\n\n\n\nN,K,T,S=list(map(int,input().split()))\n\na=list(map(int,input().split()))\n\n\n\nmust0=[i for i in range(18) if S>>i &1==0]\n\nmust1=[i for i in range(18) if T>>i &1==1]\n\n\n\nA=[]\n\nfor val in a:\n\n    check=True\n\n    for j in must0:\n\n        check=check&(val>>j &1==0)\n\n    for j in must1:\n\n        check=check&(val>>j &1==1)\n\n    if check:\n\n        A.append(val)\n\n\n\nif not A:\n\n    print((0))\n\n    exit()\n\n\n\nbit=[]\n\nfor i in range(18):\n\n    if i not in must0 and i not in must1:\n\n        bit.append(i)\n\n\n\nfor i in range(len(A)):\n\n    temp=0\n\n    for j in range(len(bit)):\n\n        temp+=(A[i]>>bit[j] &1==1)*2**j\n\n    A[i]=temp\n\n\n\nans=0\n\nn=len(bit)\n\ndata=[0]*(2**n)\n\nfor i in range(2**n):\n\n    t=set([])\n\n    for a in A:\n\n        data[a&i]+=1\n\n        t.add(a&i)\n\n    temp=0\n\n    for val in t:\n\n        temp+=cmb[data[val]][min(K,data[val])]\n\n    ans+=temp*(-1)**popcount(i)\n\n    for val in t:\n\n        data[val]=0\n\n\n\nprint(ans)\n", "generated_code": "def popcount(x):\n\n    x = x - ((x >> 1) & 0x55555555)\n\n    x = (x & 0x33333333) + ((x >> 2) & 0x33333333)\n\n    x = (x + (x >> 4)) & 0x0f0f0f0f\n\n    x = x + (x >> 8)\n\n    x = x + (x >> 16)\n\n    return x & 0x0000007f\n\n\n\ncmb=[[0 for i in range(51)] for j in range(51)]\n\ncmb[0][0]=1\n\nfor i in range(51):\n\n    for j in range(51):\n\n        if i!=50:\n\n            cmb[i+1][j]+=cmb[i][j]\n\n        if j!=50 and i!=50:\n\n            cmb[i+1][j+1]+=cmb[i][j]\n\n\n\n\n\nfor i in range(1,51):\n\n    for j in range(2,51):\n\n        cmb[i][j]+=cmb[i][j-1]\n\n\n\nimport random\n\nN,K,T,S=list(map(int,input().split()))\n\na=list(map(int,input().split()))\n\n\n\nmust0=[i for i in range(18) if S>>i &1==0]\n\nmust1=[i for i in range(18) if T>>i &1==1]\n\n\n\nA=[]\n\nfor val in a:\n\n    check=True\n\n    for j in must0:\n\n        check=check&(val>>j &1==0)\n\n    for j in must1:\n\n        check=check&(val>>j &1==1)\n\n    if check:\n\n        A.append(val)\n\n\n\nif not A:\n\n    print((0))\n\n    exit()\n\n\n\nbit=[]\n\nfor i in range(18):\n\n    if i not in must0 and i not in must1:\n\n        bit.append(i)\n\n\n\nfor i in range(len(A)):\n\n    temp=0\n\n    for j in range(len(bit)):\n\n        temp+=(A[i]>>bit[j] &1==1)*2**j\n\n    A[i]=temp\n\n\n\nans=0\n\nn=len(bit)\n\ndata=[0]*(2**n)\n\npc=[popcount(i) for i in range(2**n)]\n\nfor i in range(2**n):\n\n    for a in A:\n\n        data[a&i]+=1\n\n    for a in A:\n\n        if data[a&i]:\n\n            ans+=cmb[data[a&i]][min(K,data[a&i])]*(-1)**pc[i]\n\n            data[a&i]=0\n\n\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.9302649690295939}
{"id": "p03078_u324314500", "golden_code": "import sys\n\n#import numpy as np\n\n\n\ns2nn = lambda s: [int(c) for c in s.split(' ')]\n\nss2nn = lambda ss: [int(s) for s in ss]\n\nss2nnn = lambda ss: [s2nn(s) for s in ss]\n\ni2s = lambda: sys.stdin.readline().rstrip()\n\ni2n = lambda: int(i2s())\n\ni2nn = lambda: s2nn(i2s())\n\nii2ss = lambda n: [sys.stdin.readline().rstrip() for _ in range(n)]\n\nii2nn = lambda n: ss2nn(ii2ss(n))\n\nii2nnn = lambda n: ss2nnn(ii2ss(n))\n\n\n\nN = 10000\n\ndef tokey(i, j, k):\n\n    return i*N*N + j*N + k\n\ndef dekey(n):\n\n    i = int(n / N / N)\n\n    j = int(n / N) % N\n\n    k = n % N\n\n    return i, j, k\n\n\n\ndef main():\n\n    X, Y, Z, K = i2nn()\n\n    A = i2nn()\n\n    B = i2nn()\n\n    C = i2nn()\n\n    A.sort()\n\n    A.reverse()\n\n    B.sort()\n\n    B.reverse()\n\n    C.sort()\n\n    C.reverse()\n\n    Q = [(A[0] + B[0] + C[0], 0, 0, 0)]\n\n    loop = 0\n\n    stored = set()\n\n    def next(i, j, k):\n\n        if i >= X or j >= Y or k >= Z:\n\n            return\n\n        key = tokey(i, j, k)\n\n        if key not in stored:\n\n            stored.add(key)\n\n            n = A[i] + B[j] + C[k]\n\n            Q.append((n, i, j, k))\n\n    while True:\n\n        v = max(Q, key=lambda v: v[0])\n\n        Q.remove(v)\n\n        print((v[0]))\n\n        loop += 1\n\n        if loop >= K:\n\n            break\n\n        next(v[1]+1, v[2], v[3])\n\n        next(v[1], v[2]+1, v[3])\n\n        next(v[1], v[2], v[3]+1)\n\n\n\nmain()\n", "generated_code": "import sys\n\nfrom collections import deque  # 双方向キュー\n\nfrom collections import defaultdict  # 初期化済み辞書\n\nfrom heapq import heapify, heappush, heappop, heappushpop  # プライオリティキュー\n\nfrom bisect import bisect_left, bisect_right  # 二分探索\n\n#import numpy as np  # 1.8.2\n\n#import scipy  # 0.13.3\n\n#sys.setrecursionlimit(int(1e+6))\n\ns2nn = lambda s: [int(c) for c in s.split(' ')]\n\nss2nn = lambda ss: [int(s) for s in ss]\n\nss2nnn = lambda ss: [s2nn(s) for s in ss]\n\ni2s = lambda: sys.stdin.readline().rstrip()\n\ni2n = lambda: int(i2s())\n\ni2nn = lambda: s2nn(i2s())\n\nii2ss = lambda n: [sys.stdin.readline().rstrip() for _ in range(n)]\n\nii2sss = lambda n: [list(sys.stdin.readline().rstrip()) for _ in range(n)]\n\nii2nn = lambda n: ss2nn(ii2ss(n))\n\nii2nnn = lambda n: ss2nnn(ii2ss(n))\n\nMOD = int(1e+9) + 7\n\n\n\ndef main():\n\n    X, Y, Z, K = i2nn()\n\n    A = i2nn()\n\n    B = i2nn()\n\n    C = i2nn()\n\n    A.sort()\n\n    A.reverse()\n\n    B.sort()\n\n    B.reverse()\n\n    C.sort()\n\n    C.reverse()\n\n    s = set()\n\n    hq = []\n\n    n = 0\n\n    heappush(hq, ((A[0] + B[0] + C[0]) * -1, (0, 0, 0)))\n\n    while n < K:\n\n        t, abc = heappop(hq)\n\n        if abc in s:\n\n            continue\n\n        s.add(abc)\n\n        (a, b, c) = abc\n\n        if a+1 < X:\n\n            heappush(hq, ((A[a+1] + B[b] + C[c]) * -1, (a+1, b, c)))\n\n        if b+1 < Y:\n\n            heappush(hq, ((A[a] + B[b+1] + C[c]) * -1, (a, b+1, c)))\n\n        if c+1 < Z:\n\n            heappush(hq, ((A[a] + B[b] + C[c+1]) * -1, (a, b, c+1)))\n\n        print((-t))\n\n        n += 1\n\n\n\nmain()\n", "score": 1.0, "surface_similarity": 0.639313327017694}
{"id": "p02814_u968166680", "golden_code": "import sys\n\nfrom fractions import gcd\n\n\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\nreadlines = sys.stdin.readlines\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = 1 << 60\n\n\n\n\n\ndef lcm(x, y):\n\n    return x * y // gcd(x, y)\n\n\n\n\n\ndef main():\n\n    N, M = list(map(int, input().split()))\n\n    A = list(set(map(int, input().split(\" \"))))\n\n    A = [a // 2 for a in A]\n\n    semi_lcm = 1\n\n    for a in A:\n\n        semi_lcm = lcm(semi_lcm, a)\n\n        if semi_lcm > M:\n\n            print((0))\n\n            return\n\n\n\n    for a in A:\n\n        if semi_lcm // a % 2 == 0:\n\n            print((0))\n\n            return\n\n\n\n    print(((M // semi_lcm + 1) // 2))\n\n    return\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "generated_code": "import sys\n\n\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\nreadlines = sys.stdin.readlines\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = 1 << 60\n\n\n\n\n\ndef gcd(a, b):\n\n    while b:\n\n        a, b = b, a % b\n\n    return a\n\n\n\n\n\ndef lcm(a, b):\n\n    return a * b // gcd(a, b)\n\n\n\n\n\ndef main():\n\n    N, M, *A = list(map(int, read().split()))\n\n    A = list(set(A))\n\n    B = A.copy()\n\n\n\n    while not any(b % 2 for b in B):\n\n        B = [b // 2 for b in B]\n\n\n\n    if not all(b % 2 for b in B):\n\n        print((0))\n\n        return\n\n\n\n    semi_lcm = 1\n\n    for a in A:\n\n        semi_lcm = lcm(semi_lcm, a // 2)\n\n\n\n    print(((M // semi_lcm + 1) // 2))\n\n    return\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 1.0, "surface_similarity": 0.7624643874643875}
{"id": "p02702_u268210555", "golden_code": "import numpy as np\n\ns = eval(input())\n\ny = 2019\n\ndp = np.zeros(y, dtype=\"int64\")\n\ntmp = np.zeros(y, dtype=\"int64\")\n\nk = 1\n\nr = 0\n\nfor c in s[::-1]:\n\n    i = int(c)*k%y\n\n    tmp[i:] = dp[:y-i]\n\n    tmp[:i] = dp[y-i:]\n\n    tmp[i] += 1\n\n    dp, tmp = tmp, dp\n\n    r += dp[0]\n\n    k *= 10\n\n    k %= y\n\nprint(r)", "generated_code": "y=2019\n\na=[0]*y\n\nk=1\n\nr=p=0\n\nfor c in input()[::-1]:\n\n    a[p]+=1\n\n    p-=int(c)*k\n\n    p%=y\n\n    r+=a[p]\n\n    k*=10\n\n    k%=y\n\nprint(r)\n\n\n", "score": 1.0, "surface_similarity": 0.6297134238310709}
{"id": "p02761_u636251914", "golden_code": "import sys\n\nimport numpy as np\n\n\n\nN, M = [int(_) for _ in input().split()]\n\n\n\nif M == 0:\n\n    if N == 1:\n\n        print(\"0\")\n\n    else:\n\n        ans = [0] * N\n\n        ans[0] = 1\n\n        print((\"\".join(map(str, ans))))\n\n    sys.exit()\n\n\n\nS, C = np.array([[int(_) for _ in input().split()] for i in range(M)]).T\n\n\n\nans = [-1] * N\n\n\n\nfor i in range(M):\n\n    j = int(S[i]) - 1\n\n    if ans[j] == -1 or ans[j] == C[i]:\n\n        ans[j] = C[i]\n\n    else:\n\n        print(\"-1\")\n\n        sys.exit()\n\n\n\nif N >= 2 and ans[0] == 0:\n\n    print(\"-1\")\n\n    sys.exit()\n\n\n\nif N >= 2 and ans[0] == -1:\n\n    ans[0] = 1\n\n\n\nfor i in range(1, N):\n\n    if ans[i] == -1:\n\n        ans[i] = 0\n\n\n\ns = \"\".join(map(str, ans))\n\nprint(s)\n", "generated_code": "import sys\n\n\n\nN, M = [int(_) for _ in input().split()]\n\nSC = [[int(_) for _ in input().split()] for i in range(M)]\n\n\n\nif N == 1:\n\n    start = 0\n\n    end = 10\n\nelse:\n\n    start = 10 ** (N - 1)\n\n    end = 10 ** N\n\n\n\nfor i in range(start, end):\n\n    ans = list(map(int, str(i)))\n\n    valid = True\n\n    for s, c in SC:\n\n        if ans[s-1] != c:\n\n            valid = False\n\n            break\n\n    if valid:\n\n        print(i)\n\n        sys.exit()\n\n\n\nprint((-1))\n", "score": 1.0, "surface_similarity": 0.6330847370451331}
{"id": "p03363_u572142121", "golden_code": "import numpy\n\nN=int(eval(input()))\n\nA=list(map(int,input().split()))\n\nB=list(numpy.cumsum(A))+[0]\n\nC=sorted(B)\n\nd=C[0]\n\ncnt=1\n\nans=0\n\nfor i in range(N):\n\n  if C[i+1]==d:\n\n    cnt+=1\n\n  else:\n\n    ans+=cnt*(cnt-1)//2\n\n    cnt=1\n\n    d=C[i+1]\n\nans+=cnt*(cnt-1)//2\n\nprint(ans)    ", "generated_code": "N=int(eval(input()))\n\nA=list(map(int, input().split()))\n\nD=[0]\n\nd=0\n\nfor i in A:\n\n  d+=i\n\n  D.append(d)\n\nD=sorted(D)\n\nans=0\n\nd=-10**9+1\n\nD.append(10**9+1)\n\ncnt=0\n\nfor i in range(N+2):\n\n  if D[i]==d:\n\n    cnt+=1\n\n  else:\n\n    if cnt>1:\n\n      ans+=cnt*(cnt-1)//2\n\n      cnt=1\n\n    else:\n\n      cnt=1\n\n    d=D[i]\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.7142857142857142}
{"id": "p03634_u761529120", "golden_code": "import sys\n\nsys.setrecursionlimit(10**6)\n\ndef dfs(v,p,d):\n\n    for i, j in tree[v]:\n\n        if i != p:\n\n            depth[i] = d + j\n\n            dfs(i,v,d+j)\n\n\n\nN = int(eval(input()))\n\n\n\ntree = [[] for _ in range(N)]\n\n\n\nfor i in range(N-1):\n\n    a, b, c = list(map(int, input().split()))\n\n    a -= 1\n\n    b -= 1\n\n    tree[a].append((b,c))\n\n    tree[b].append((a,c))\n\n\n\nQ, K = list(map(int, input().split()))\n\n\n\ndepth = [0 for i in range(N)]\n\ndepth[K-1] = 0\n\n\n\ndfs(K-1,-1,0)\n\n\n\nfor _ in range(Q):\n\n    x, y = list(map(int, input().split()))\n\n    print((depth[x-1] + depth[y-1]))", "generated_code": "import heapq\n\nimport sys\n\n\n\ninput = sys.stdin.readline\n\n\n\ndef dijkstra(s, edge, N):\n\n    d = [float('inf')] * N\n\n    used = [True] * N\n\n    d[s] = 0\n\n    used[s] = False\n\n    edgelist = []\n\n    for a, b in edge[s]:\n\n        heapq.heappush(edgelist, a * (10 ** 6) + b)\n\n    while len(edgelist):\n\n        minedge = heapq.heappop(edgelist)\n\n\n\n        if not used[minedge%(10 ** 6)]:\n\n            continue\n\n        v = minedge % (10 ** 6)\n\n        d[v] = minedge // (10 ** 6)\n\n        used[v] = False\n\n        for e in edge[v]:\n\n            if used[e[1]]:\n\n                heapq.heappush(edgelist, (e[0] + d[v]) * (10 ** 6) + e[1])\n\n    return d\n\n\n\ndef main():\n\n    N = int(eval(input()))\n\n    edge = [[] for _ in range(N)]\n\n    for _ in range(N-1):\n\n        a, b, c = list(map(int, input().split()))\n\n        a -= 1\n\n        b -= 1\n\n        edge[a].append([c,b])\n\n        edge[b].append([c,a])\n\n    Q, K = list(map(int, input().split()))\n\n    K -= 1\n\n    d = dijkstra(K, edge, N)\n\n    for _ in range(Q):\n\n        x, y = list(map(int, input().split()))\n\n        x -= 1\n\n        y -= 1\n\n        print((d[x] + d[y]))\n\n\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()", "score": 1.0, "surface_similarity": 0.668940200514595}
{"id": "p03796_u230717961", "golden_code": "import math\n\nn = int(eval(input()))\n\n\n\npower = math.factorial(n)\n\n\n\nprint((power % (10**9 + 7)))\n", "generated_code": "import math\n\nn = int(eval(input()))\n\n\n\npower = 1\n\n\n\nfor i in range(1, n+1):\n\n    power = i * power % (10**9 + 7)\n\n\n\nprint(power)\n", "score": 1.0, "surface_similarity": 0.7644778841769265}
{"id": "p02883_u947883560", "golden_code": "#!/usr/bin/env python3\n\nimport sys\n\nINF = float(\"inf\")\n\nfrom bisect import bisect_left\n\n\n\n\n\ndef solve(N: int, K: int, A: \"List[int]\", F: \"List[int]\"):\n\n    A.sort()\n\n    F.sort(reverse=True)\n\n    h = []\n\n    for a, f in zip(A, F):\n\n        h.append((a*f, a, f))\n\n    h.sort()\n\n    maxtime = h[-1][0]\n\n\n\n    def isOK(y):\n\n        i = bisect_left(h, (y+1, -1, -1))\n\n        counter = 0\n\n        # print(h[i:])\n\n        for p, a, f in h[i:]:\n\n            counter += a-y//f\n\n        return counter <= K\n\n\n\n    def binary_search(x):\n\n        ng = -1\n\n        ok = len(x)\n\n        while abs(ok - ng) > 1:\n\n            mid = (ok + ng)//2\n\n            # print(\"mid: {}, in ({}, {})\".format(mid, ng, ok))\n\n            if isOK(mid):\n\n                ok = mid\n\n            else:\n\n                ng = mid\n\n        return ng, ok\n\n\n\n    ng, ok = binary_search(list(range(maxtime)))\n\n    print(ok)\n\n\n\n    # while k > 0:\n\n    #     p1, a1, f1 = heapq.heappop(h)\n\n    #     p2, a2, f2 = heapq.heappop(h)\n\n    #     p1, p2 = -p1, -p2\n\n    #     sub = min(a1 - math.ceil((p2/f1)-1), k)\n\n    #     a1 -= sub\n\n    #     k -= sub\n\n    #     heapq.heappush(h, (-a1*f1, a1, f1))\n\n    #     heapq.heappush(h, (-a2*f2, a2, f2))\n\n    # # print(h)\n\n    # p, a, f = heapq.heappop(h)\n\n    # print(-p)\n\n\n\n    return\n\n\n\n\n\ndef main():\n\n\n\n    def iterate_tokens():\n\n        for line in sys.stdin:\n\n            for word in line.split():\n\n                yield word\n\n    tokens = iterate_tokens()\n\n    N = int(next(tokens))  # type: int\n\n    K = int(next(tokens))  # type: int\n\n    A = [int(next(tokens)) for _ in range(N)]  # type: \"List[int]\"\n\n    F = [int(next(tokens)) for _ in range(N)]  # type: \"List[int]\"\n\n    solve(N, K, A, F)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "generated_code": "#!/usr/bin/env python3\n\nimport sys\n\nINF = float(\"inf\")\n\nimport numpy as np\n\n\n\n\n\ndef solve(N: int, K: int, A: \"List[int]\", F: \"List[int]\"):\n\n    A.sort()\n\n    F.sort(reverse=True)\n\n    A = np.asarray(A, dtype=np.int)\n\n    F = np.asarray(F, dtype=np.int)\n\n\n\n    Asum = A.sum()\n\n\n\n    def isOK(y):\n\n        return Asum-np.minimum(A, y//F).sum() <= K\n\n\n\n    def binary_search(x):\n\n        ng = -1\n\n        ok = len(x)\n\n        while abs(ok - ng) > 1:\n\n            mid = (ok + ng)//2\n\n            # print(\"mid: {}, in ({}, {})\".format(mid, ng, ok))\n\n            if isOK(mid):\n\n                ok = mid\n\n            else:\n\n                ng = mid\n\n        return ng, ok\n\n\n\n    ng, ok = binary_search(list(range(A.max()*F.max())))\n\n    print(ok)\n\n\n\n    # while k > 0:\n\n    #     p1, a1, f1 = heapq.heappop(h)\n\n    #     p2, a2, f2 = heapq.heappop(h)\n\n    #     p1, p2 = -p1, -p2\n\n    #     sub = min(a1 - math.ceil((p2/f1)-1), k)\n\n    #     a1 -= sub\n\n    #     k -= sub\n\n    #     heapq.heappush(h, (-a1*f1, a1, f1))\n\n    #     heapq.heappush(h, (-a2*f2, a2, f2))\n\n    # # print(h)\n\n    # p, a, f = heapq.heappop(h)\n\n    # print(-p)\n\n\n\n    return\n\n\n\n\n\ndef main():\n\n\n\n    def iterate_tokens():\n\n        for line in sys.stdin:\n\n            for word in line.split():\n\n                yield word\n\n    tokens = iterate_tokens()\n\n    N = int(next(tokens))  # type: int\n\n    K = int(next(tokens))  # type: int\n\n    A = [int(next(tokens)) for _ in range(N)]  # type: \"List[int]\"\n\n    F = [int(next(tokens)) for _ in range(N)]  # type: \"List[int]\"\n\n    solve(N, K, A, F)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 1.0, "surface_similarity": 0.8777220630372493}
{"id": "p03575_u863442865", "golden_code": "'''\n\n無向グラフの橋の数を調べる\n\nループ無し/2重辺無し\n\n'''\n\n\n\ndef main():\n\n    import sys\n\n    #input = sys.stdin.readline\n\n    sys.setrecursionlimit(10000000)\n\n    from collections import Counter, deque\n\n    #from collections import defaultdict\n\n    from itertools import combinations\n\n    #from itertools import accumulate, product, permutations\n\n    from math import floor, ceil\n\n\n\n    #mod = 1000000007\n\n\n\n    node,m =list(map(int, input().split()))\n\n    edge = [list(map(int, input().split())) for _ in range(m)]\n\n    res = 0\n\n\n\n    def dfs(num):\n\n        flag[num-1] = 1\n\n        for x, y in edge:\n\n            if x==num:\n\n                if not flag[y-1]:\n\n                    dfs(y)\n\n            if y==num:\n\n                if not flag[x-1]:\n\n                    dfs(x)\n\n    \n\n    for i in range(m):\n\n        bridge = edge.pop(i)\n\n        flag = [0]*node\n\n        s = edge[0][0]\n\n        dfs(s)\n\n        if not all(flag):\n\n            res += 1\n\n        edge.insert(i, bridge)\n\n    print(res)\n\n\n\nif __name__ == '__main__':\n\n    main()", "generated_code": "'''\n\nhttps://atcoder.jp/contests/abc075/tasks/abc075_c?lang=ja\n\n深さ優先探索でも解ける\n\n'''\n\ndef main():\n\n    import sys\n\n    #input = sys.stdin.readline\n\n    sys.setrecursionlimit(10000000)\n\n    from collections import Counter, deque\n\n    #from collections import defaultdict\n\n    from itertools import combinations, permutations\n\n    #from itertools import accumulate, product\n\n    from bisect import bisect_left,bisect_right\n\n    from math import floor, ceil\n\n    #from operator import itemgetter\n\n\n\n    #mod = 1000000007\n\n\n\n    class UnionFind():\n\n        #n個の要素を番号0~n-1で管理する\n\n        #parents:要素の親(1つ上), 要素が根の場合サイズを表す\n\n        def __init__(self, n):\n\n            self.n = n\n\n            self.parents = [-1] * n\n\n    \n\n        #要素xの根を返す, その過程で経路圧縮も行う\n\n        def find(self, x):\n\n            if self.parents[x] < 0:\n\n                return x\n\n            else:\n\n                self.parents[x] = self.find(self.parents[x])\n\n                return self.parents[x]\n\n    \n\n        def union(self, x, y):\n\n            x = self.find(x)\n\n            y = self.find(y)\n\n            if x == y:\n\n                return\n\n            #それぞれのsizeで比べる\n\n            if self.parents[x] > self.parents[y]:\n\n                x, y = y, x\n\n            self.parents[x] += self.parents[y]\n\n            self.parents[y] = x #根をくっつける(片方を親にする)\n\n    \n\n        #xが属するグループのsize\n\n        def size(self, x):\n\n            return -self.parents[self.find(x)]\n\n    \n\n        #xとyが同じグループかどうか\n\n        def same(self, x, y):\n\n            return self.find(x) == self.find(y)\n\n    \n\n        #xが属するグループの要素全てを返す\n\n        def members(self, x):\n\n            root = self.find(x)\n\n            return [i for i in range(self.n) if self.find(i) == root]\n\n    \n\n        #全ての根の要素を返す\n\n        def roots(self):\n\n            return [i for i, x in enumerate(self.parents) if x < 0]\n\n    \n\n        #各グループの要素を辞書で返す\n\n        def all_group_members(self):\n\n            return {r: self.members(r) for r in self.roots()}\n\n    \n\n        #print(uf)\n\n        def __str__(self):\n\n            return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n    n,m = list(map(int, input().split()))\n\n    edge = [list(map(int, input().split())) for _ in range(m)]\n\n    res = 0\n\n    for i in range(m):\n\n        uf = UnionFind(n)\n\n        for j in range(m):\n\n            if i==j:\n\n                continue\n\n            a,b = edge[j]\n\n            uf.union(a-1,b-1)\n\n        if uf.size(0)!=n:\n\n            res += 1\n\n    print(res)\n\n\n\nif __name__ == '__main__':\n\n    main()", "score": 1.0, "surface_similarity": 0.6935439881555365}
{"id": "p03796_u077898957", "golden_code": "import math\n\nn = int(eval(input()))\n\nprint((math.factorial(n)%(10**9+7)))\n", "generated_code": "n = int(eval(input()))\n\npw = 1\n\nfor i in range(n):\n\n  pw *= (i+1)\n\n  pw %= 10**9+7\n\nprint(pw)", "score": 1.0, "surface_similarity": 0.5698924731182795}
{"id": "p03634_u391731808", "golden_code": "import heapq\n\n\n\nN = int(eval(input()))\n\nabc = [list(map(int,input().split())) for _ in range(N-1)]\n\nQ,K = list(map(int,input().split()))\n\nxy = [list(map(int,input().split())) for _ in range(Q)]\n\n\n\nconnect = [[] for _ in range(N)]\n\nINFTY = 10**15\n\nfor a,b,c in abc:\n\n    connect[a-1].append([b-1,c])\n\n    connect[b-1].append([a-1,c])\n\n\n\ncost = [[INFTY,False] for _  in range(N)]\n\ncost[K-1][0] = 0\n\nq = [(0,K-1)]\n\nwhile q:\n\n    _,i = heapq.heappop(q)\n\n    if cost[i][1]:\n\n        continue\n\n    cost[i][1] = True\n\n    ci0 = cost[i][0]\n\n    for j,c in connect[i]:\n\n        if cost[j][1]:\n\n            continue\n\n        tmp_cost = ci0+c\n\n        if tmp_cost < cost[j][0]:\n\n            cost[j][0] = tmp_cost\n\n            heapq.heappush(q,(tmp_cost,j))\n\n\n\nfor x,y in xy:\n\n    print((cost[x-1][0] + cost[y-1][0]))", "generated_code": "N = int(eval(input()))\n\nABC = [list(map(int,input().split())) for _ in [0]*(N-1)]\n\nQ,K = list(map(int,input().split()))\n\nXY = [list(map(int,input().split())) for _ in [0]*Q]\n\n\n\nE = [{} for _ in [0]*N]\n\nfor a,b,c in ABC:\n\n    E[a-1][b-1] = c\n\n    E[b-1][a-1] = c\n\n\n\ndef dist_dfs_tree(N,E,start):\n\n    d = [-1]*N\n\n    d[start] = 0\n\n    q = [start]\n\n    while q:\n\n        i = q.pop()\n\n        ci = d[i]\n\n        for j,cj in list(E[i].items()):\n\n            if d[j] !=-1:continue\n\n            d[j] = ci+cj\n\n            q.append(j)\n\n    return d\n\n\n\nd = dist_dfs_tree(N,E,K-1)\n\nfor x,y in XY:\n\n    print((d[x-1]+d[y-1]))", "score": 1.0, "surface_similarity": 0.625655624568668}
{"id": "p03416_u467041847", "golden_code": "A,B = list(map(int,input().split()))\n\n\n\n\n\ndef kaibun(n):\n\n\tkey = 0\n\n\tfor i in range(1,n+1):\n\n\t\tif str(i) == str(i)[::-1]:\n\n\t\t\tkey += 1\n\n\treturn key\n\n\n\nprint((kaibun(B)-kaibun(A-1)))", "generated_code": "A,B = list(map(int,input().split()))\n\n\n\n\n\ndef kaibun(m, n):\n\n\tkey = 0\n\n\tfor i in range(m,n+1):\n\n\t\tif str(i) == str(i)[::-1]:\n\n\t\t\tkey += 1\n\n\treturn key\n\n\n\nprint((kaibun(A,B)))", "score": 1.0, "surface_similarity": 0.939332766680833}
{"id": "p03575_u802963389", "golden_code": "from scipy.sparse.csgraph import dijkstra\n\nN, M = list(map(int, input().split()))\n\nedge = [list(map(int, input().split())) for _ in range(M)]\n\n\n\n# 隣接行列\n\ngraph = [[0] * (N + 1) for _ in range(N + 1)]\n\n\n\nfor i, j in edge:\n\n  graph[i][j] = 1\n\n  \n\nans = 0\n\nINF = 10 ** 9\n\nfor a, b in edge:\n\n  # 辺を取り除く-> INF\n\n  graph[a][b] = INF\n\n  dist = dijkstra(graph, indices=a, directed=False) # directed=False -> 無効グラフ用\n\n  if dist[b] >= INF:\n\n    ans += 1\n\n  # 元に戻す -> 1\n\n  graph[a][b] = 1\n\n\n\nprint(ans)", "generated_code": "# C - Bridge\n\n# https://atcoder.jp/contests/abc075/tasks/abc075_c\n\n\n\nfrom collections import deque\n\n\n\ndef dfs(n, start, graph):\n\n  visited = [False] * n\n\n  stack = deque()\n\n  stack.append(start)\n\n  visited[start] = True\n\n  while stack:\n\n    q = stack.popleft()\n\n    nxts = graph[q]\n\n    for nxt in nxts:\n\n      if not visited[nxt]:\n\n        visited[nxt] = True\n\n        stack.append(nxt)\n\n  return visited\n\n\n\nn, m = list(map(int, input().split()))\n\nedge = [list(map(int, input().split())) for _ in range(m)]\n\n\n\nans = 0\n\nfor i in range(m):\n\n  graph = [[] for _ in range(n)]\n\n  for itr, (a, b) in enumerate(edge):\n\n    if itr != i:\n\n      graph[a - 1].append(b - 1)\n\n      graph[b - 1].append(a - 1)\n\n\n\n  if not all(dfs(n, 0, graph)):\n\n    ans += 1\n\n\n\nprint(ans)\n", "score": 1.0, "surface_similarity": 0.5922032413491021}
{"id": "p02555_u868628468", "golden_code": "from sys import stdin\n\ndef solve():\n\n    s = int(stdin.readline())\n\n    mod = 10**9+7\n\n    if s < 3: return 0\n\n    dp = [0]*(s+1)\n\n    dp[0] = 1\n\n    for i in range(3,s+1):\n\n        for x in range(3,i+1):\n\n            if x in [i-1,i-2]:\n\n                continue\n\n            dp[i] += dp[i-x]\n\n    return dp[s]%mod\n\nprint((solve()))", "generated_code": "from sys import stdin\n\ndef solve():\n\n    s = int(stdin.readline())\n\n    mod = 10**9+7\n\n    if s < 3: return 0\n\n    dp = [0]*(s+1)\n\n    dp[0] = 1\n\n    for i in range(3,s+1):\n\n        dp[i] = dp[i-1] + dp[i-3]\n\n    return dp[s]%mod\n\nprint((solve()))", "score": 1.0, "surface_similarity": 0.880722891566265}
{"id": "p02780_u595289165", "golden_code": "import numpy as np\n\nn, k = list(map(int, input().split()))\n\np = np.array(list(map(int, input().split())))\n\np += 1\n\nsum_E = np.cumsum(p)\n\nsum_e = np.append([0], sum_E)\n\nans = -1\n\nfor i in range(n-k+1):\n\n    ans = max(ans, sum_e[i+k] - sum_e[i])\n\nprint((ans/2))", "generated_code": "n, k = list(map(int, input().split()))\n\np = list(map(int, input().split()))\n\n\n\ndef calc(x):\n\n    return (x + 1) / 2\n\n\n\n\n\nw = 0\n\n\n\nfor i in range(k):\n\n    w += calc(p[i])\n\n\n\nans = w\n\nfor i in range(k, n):\n\n    w += calc(p[i]) - calc(p[i - k])\n\n    ans = max(ans, w)\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.6141304347826086}
{"id": "p03013_u606878291", "golden_code": "import numpy as np\n\n\n\n\n\ndef main(n, m, a):\n\n    dp = np.zeros(n + 1, dtype=int)\n\n    dp[0] = 1\n\n    dp[1] = 1 if 1 not in a else 0\n\n\n\n    for i in range(2, len(dp)):\n\n        dp[i] = dp[i - 1] + dp[i - 2] if i not in a else 0\n\n        dp[i] %= 1000000007\n\n\n\n    return dp[-1]\n\n\n\n\n\nif __name__ == '__main__':\n\n    N, M = list(map(int, input().split()))\n\n    A = set()\n\n    for _ in range(M):\n\n        A.add(int(eval(input())))\n\n\n\n    print((main(N, M, A)))\n", "generated_code": "import math\n\n\n\nMOD = int(math.pow(10, 9)) + 7\n\nN, M = list(map(int, input().split(' ')))\n\nbroken_steps = {int(eval(input())) for _ in range(M)}\n\n\n\ndp = [0] * (N + 1)\n\n\n\ndp[0] = 1\n\nif 1 not in broken_steps:\n\n    dp[1] = 1\n\n\n\nfor step in range(2, N + 1):\n\n    if step not in broken_steps:\n\n        dp[step] = (dp[step - 1] + dp[step - 2]) % MOD\n\n\n\nprint((dp[N]))\n", "score": 1.0, "surface_similarity": 0.5380116959064327}
{"id": "p02690_u813993459", "golden_code": "import numpy as np\n\nx = int(eval(input()))\n\ntmp_list=[]\n\nc=0\n\ntmp_2=0\n\nwhile(1):\n\n    tmp_1=c**5\n\n    if (tmp_1 - tmp_2)<=x:\n\n        tmp_list+=[tmp_1]\n\n    else:\n\n        break\n\n    tmp_2=tmp_1\n\n    c+=1\n\n \n\ndef せいがわ(target:list,x) -> list:\n\n    for i in np.flipud(target):\n\n        for j in target:\n\n            tmp=i+j\n\n            if tmp==x:\n\n                return [int(i**(1/5)),int(j**(1/5))*-1]\n\n            if tmp>x:\n\n                break\n\n    return 0\n\n \n\ndef ふがわ(target:list,x) -> list:\n\n    for i in np.flipud(target):\n\n        for j in target:\n\n            tmp=i-j\n\n            if tmp==x:\n\n                return [int(i**(1/5)),int(j**(1/5))]\n\n            if tmp<x:\n\n                break\n\n    return 0\n\n  \n\nans=ふがわ(tmp_list,x)\n\nif ans==0:\n\n    ans=せいがわ(tmp_list,x)\n\nprint((ans[0],ans[1]))", "generated_code": "X = int(eval(input()))\n\nfor a in range(0, 121):\n\n    for b in range(0, 121):\n\n        if X == a**5 - b**5:\n\n            print((a, b))\n\n            exit()\n\n        elif X == a**5 + b**5:\n\n            print((a, -b))\n\n            exit()\n\n        elif X == -a**5 - (10**4 - b)**5:\n\n            print((-a, 10**4 - b))\n\n            exit()", "score": 1.0, "surface_similarity": 0.4952374541415637}
{"id": "p03038_u172035535", "golden_code": "n,m = list(map(int,input().split()))\n\nA = list(map(int,input().split()))\n\nA.sort()\n\nbc = [list(map(int,input().split())) for _ in range(m)]\n\n\n\nbc.sort(key=lambda x:x[1],reverse=1)\n\n\n\ni = 0#bcの添え字\n\nj = 0#Aの添え字\n\nwhile 1:\n\n\tif i >= m or j >= n:\n\n\t\t#print('iかjが超えた！')\n\n\t\tbreak\n\n\tif bc[i][1] < A[j]:\n\n\t\t#print('Aでっか')\n\n\t\tbreak\n\n\tfor k in range(bc[i][0]):\n\n\t\t#print(i,j,k)\n\n\t\tA[j] = bc[i][1]\n\n\t\tj+=1\n\n\t\tif j >= n:\n\n\t\t\t#print('for文内、jが超えた')\n\n\t\t\tbreak\n\n\t\tif A[j] > bc[i][1]:\n\n\t\t\t#print('for文内、Aでっか')\n\n\t\t\tbreak\n\n\ti+=1\n\n# print(A)\n\nprint((sum(A)))", "generated_code": "from heapq import heapify,heappop,heappush\n\nn,m = list(map(int,input().split()))\n\nA = list(map(int,input().split()))\n\nheapify(A)\n\nbc = [list(map(int,input().split())) for i in range(m)]\n\nbc.sort(key=lambda x:x[1],reverse=1)\n\n\n\nflag = 0\n\n# print(A)\n\nfor b,c in bc:\n\n\tif flag:\n\n\t\tbreak\n\n\tfor i in range(b):\n\n\t\ta = heappop(A)\n\n\t\tif c <= a:\n\n\t\t\theappush(A,a)\n\n\t\t\tflag = 1\n\n\t\t\tbreak\n\n\t\telse:\n\n\t\t\theappush(A,c)\n\nprint((sum(A)))", "score": 1.0, "surface_similarity": 0.6871508379888267}
{"id": "p02773_u678167152", "golden_code": "N = int(eval(input()))\n\ns_list = {}\n\nfor i in range(N):\n\n  S = eval(input())\n\n  if S in list(s_list.keys()):\n\n    s_list[S] += 1\n\n  else:\n\n    s_list[S] = 0\n\nmax = 0\n\nmaxs = []\n\nfor s,c in list(s_list.items()):\n\n  if c > max:\n\n    maxs = [s]\n\n    max = c\n\n  elif c == max:\n\n    maxs.append(s)\n\nmaxs.sort()\n\nfor m in maxs:\n\n  print(m)", "generated_code": "from collections import Counter\n\ndef solve():\n\n  N = int(input())\n\n  S = [input() for _ in range(N)]\n\n  c = Counter(S)\n\n  M = max(c.values())\n\n  ans = []\n\n  for k,v in c.items():\n\n    if v==M:\n\n      ans.append(k)\n\n  ans.sort()\n\n  return ans\n\nprint(*solve(),sep='\\n')\n", "score": 1.0, "surface_similarity": 0.4806742226097065}
{"id": "p02874_u164727245", "golden_code": "# coding: utf-8\n\nimport numpy as np\n\n\n\n\n\ndef solve(*args: str) -> str:\n\n    n = int(args[0])\n\n    LR = [tuple(map(int, a.split())) for a in args[1:]]\n\n    L, R = list(zip(*LR))\n\n\n\n    ret = 0\n\n\n\n    p, q = np.argmax(L), np.argmin(R)\n\n    lp, rq = L[p], R[q]\n\n\n\n    ret = max(0, 1+rq-lp) + max(0, max(1+r-l for l, r in LR))\n\n\n\n    AB = [[max(0, 1+r-lp), max(0, 1+rq-l)] for l, r in LR]\n\n    AB.sort(key=lambda x: (x[0], -x[1]))\n\n    A, B = list(map(list, list(zip(*AB))))\n\n\n\n    # for i in range(1, n):\n\n    #     ret = max(ret, min(A[i:]) + min(B[:i]))\n\n    b_min = 1+10**9\n\n    for i in range(n-1):\n\n        b_min = min(b_min, B[i])\n\n        ret = max(ret, b_min + A[i+1])\n\n\n\n    return str(ret)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    print((solve(*(open(0).read().splitlines()))))\n", "generated_code": "# coding: utf-8\n\n\n\n\n\ndef solve(*args: str) -> str:\n\n    n = int(args[0])\n\n    LR = [tuple(map(int, a.split())) for a in args[1:]]\n\n    L, R = list(zip(*LR))\n\n\n\n    ret = 0\n\n\n\n    # lp, rq = max(L), min(R)\n\n    lp, rq = 0, 1+10**9\n\n    for l, r in LR:\n\n        lp, rq = max(lp, l), min(rq, r)\n\n\n\n    ret = max(0, 1+rq-lp) + max(0, max(1+r-l for l, r in LR))\n\n\n\n    AB = [[max(0, 1+r-lp), max(0, 1+rq-l)] for l, r in LR]\n\n    AB.sort(key=lambda x: (x[0], -x[1]))\n\n    A, B = list(map(list, list(zip(*AB))))\n\n\n\n    # for i in range(1, n):\n\n    #     ret = max(ret, min(A[i:]) + min(B[:i]))\n\n    b_min = 1+10**9\n\n    for i in range(n-1):\n\n        b_min = min(b_min, B[i])\n\n        ret = max(ret, b_min + A[i+1])\n\n\n\n    return str(ret)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    print((solve(*(open(0).read().splitlines()))))\n", "score": 1.0, "surface_similarity": 0.9384798909338786}
{"id": "p03164_u324197506", "golden_code": "import sys\n\ninput = sys.stdin.readline\n\nimport numpy as np\n\n \n\nN,W = list(map(int, input().split()))\n\n \n\ndp = [10 ** 10] * N * (10 ** 4)\n\ndp[0] = 0\n\ndp = np.array(dp)\n\n \n\n \n\nfor i in range(N):\n\n    w,v = list(map(int, input().split()))\n\n    dp[v:] = np.minimum(dp[v:] , dp[:-v] + w)\n\n  \n\nfor i,count in enumerate(dp):\n\n    if dp[i] <= W:\n\n        ans = i\n\nprint(ans)", "generated_code": "import sys\n\ninput = sys.stdin.readline\n\nimport numpy as np\n\n \n\nN,W = list(map(int, input().split()))\n\n \n\ndp = [10 ** 10] * (N * (10 ** 3) + 1)\n\ndp[0] = 0\n\ndp = np.array(dp)\n\n \n\n \n\nfor i in range(N):\n\n    w,v = list(map(int, input().split()))\n\n    dp[v:] = np.minimum(dp[v:] , dp[:-v] + w)\n\n  \n\nfor i,count in enumerate(dp):\n\n    if dp[i] <= W:\n\n        ans = i\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.9932795698924731}
{"id": "p03796_u018679195", "golden_code": "import math\n\nx = int(eval(input()))\n\nprint((math.factorial(x) % (10**9 + 7)))", "generated_code": "M = 1000000007\n\nn=int(eval(input()))\n\nf = 1\n\nfor i in range(1, n + 1):  \n\n    f = (f * i) % M \n\nprint(f)", "score": 1.0, "surface_similarity": 0.5831447963800904}
{"id": "p02730_u926412290", "golden_code": "S = eval(input())\n\nN = len(S)\n\nleft = S[:int(N/2)]\n\nright = S[int((N+2)/2):]\n\nS_reversed = \"\".join(reversed(list(S)))\n\nleft_reversed = \"\".join(reversed(list(left)))\n\nright_reversed = \"\".join(reversed(list(right)))\n\n\n\nif S == S_reversed and left == left_reversed and right == right_reversed:\n\n    print(\"Yes\")\n\nelse:\n\n    print(\"No\")", "generated_code": "S = eval(input())\n\nN = len(S)\n\nleft = S[:int(N/2)]\n\nright = S[int((N+2)/2):]\n\n\n\nif S == S[::-1] and left == left[::-1] and right == right[::-1]:\n\n    print(\"Yes\")\n\nelse:\n\n    print(\"No\")", "score": 1.0, "surface_similarity": 0.6951376936316696}
{"id": "p03416_u896741788", "golden_code": "a,b=list(map(int,input().split()))\n\nans=0\n\nfor i in range(b+1)[a:]:\n\n  if len(str(i))%2==0:\n\n    p=list(str(i))[:len(str(i))//2]\n\n    q=list(reversed(list(str(i))[len(str(i))//2:]))\n\n    if p==q:\n\n      ans+=1\n\n  else:\n\n    s=list(str(i))[:len(str(i))//2+1]\n\n    d=list(reversed(list(str(i))[len(str(i))//2:]))\n\n    if s==d:\n\n      ans += 1\n\nprint(ans)", "generated_code": "a,s=list(map(int,input().split()))\n\nad=0\n\nfor i in range(a,s+1):\n\n  if str(i)==str(i)[::-1]:ad+=1\n\nprint(ad)", "score": 1.0, "surface_similarity": 0.6246912055335969}
{"id": "p02814_u036104576", "golden_code": "import sys\n\nimport itertools\n\n# import numpy as np\n\nimport time\n\nimport math\n\n \n\nsys.setrecursionlimit(10 ** 7)\n\n \n\nfrom collections import defaultdict\n\n \n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n \n\n \n\nfrom functools import reduce\n\n# from math import *\n\nfrom fractions import *\n\nN, M = list(map(int, readline().split()))\n\nA = list(sorted([int(x) // 2 for x in readline().split()]))\n\nmin_cm = reduce(lambda a, b: (a * b) // gcd(a, b), A)\n\n \n\n# print(all(map(lambda x: (min_cm // x) % 2 == 1, A)))\n\nif not all([(min_cm // x) % 2 == 1 for x in A]):\n\n    print((0))\n\n    exit(0)\n\nif min_cm > M:\n\n    print((0))\n\n    exit(0)\n\nans = (M // min_cm + 1) // 2\n\nprint(ans)", "generated_code": "import sys\n\nimport itertools\n\n# import numpy as np\n\nimport time\n\nimport math\n\nimport heapq\n\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10 ** 7)\n\n \n\nINF = 10 ** 9 + 7\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\n# map(int, input().split())\n\n\n\nN, M = list(map(int, input().split()))\n\nA = list([int(x) // 2 for x in input().split()])\n\n\n\ndef f(n):\n\n    res = 0\n\n    while n % 2 == 0:\n\n        n //= 2\n\n        res += 1\n\n    return res\n\n\n\ndef gcd(a, b):\n\n    if b == 0:\n\n        return a\n\n    return gcd(b, a % b)\n\n\n\nx = f(A[0])\n\nfor a in A:\n\n    y = f(a)\n\n    if y != x:\n\n        print((0))\n\n        exit()\n\n\n\nlcm = A[0]\n\nfor i in range(1, N):\n\n    lcm = lcm * A[i] //  gcd(lcm, A[i])\n\n\n\nprint(((M // lcm + 1) // 2))", "score": 1.0, "surface_similarity": 0.6538181095055018}
{"id": "p00447_u150984829", "golden_code": "import operator\n\nfor e in iter(input,'0'):\n\n    target = [[*list(map(int,input().split()))]for _ in[0]*int(e)]\n\n    bx, by = target[0]\n\n    target = {(x - bx, y - by) for x, y in target}\n\n    max_tx = max(list(map(operator.itemgetter(0), target)))\n\n    b = {tuple(map(int,input().split()))for _ in[0]*int(eval(input()))}\n\n    max_sx = max(list(map(operator.itemgetter(0), b)))\n\n    lim_x = max_sx - max_tx\n\n    for x,y in b:\n\n        if x > lim_x:continue\n\n        for u,v in target:\n\n            if (x + u, y + v) not in b:break\n\n        else:\n\n            print((x - bx, y - by))\n\n            break\n", "generated_code": "import operator\n\nfor e in iter(input,'0'):\n\n    target = [[*list(map(int,input().split()))]for _ in[0]*int(e)]\n\n    bx, by = min(target)\n\n    target = {(x - bx, y - by) for x, y in target}\n\n    max_tx = max(list(map(operator.itemgetter(0), target)))\n\n    b = {tuple(map(int,input().split()))for _ in[0]*int(eval(input()))}\n\n    max_sx = max(list(map(operator.itemgetter(0), b)))\n\n    lim_x = max_sx - max_tx\n\n    for x,y in b:\n\n        if x > lim_x:continue\n\n        for u,v in target:\n\n            if (x + u, y + v) not in b:break\n\n        else:\n\n            print((x - bx, y - by))\n\n            break\n", "score": 1.0, "surface_similarity": 0.9608623548922057}
{"id": "p03718_u102461423", "golden_code": "import sys\n\ninput = sys.stdin.readline\n\n\n\nfrom scipy.sparse.csgraph import dijkstra\n\n\n\nH,W = list(map(int,input().split()))\n\n\n\n# start = 0\n\n# rows = 1,2,...,H\n\n# cols = H+1,...,H+W\n\n# goal = H+W+1\n\n\n\nINF = 10 ** 9\n\nstart = 0\n\ngoal = H+W+1\n\nV = H+W+2\n\ngraph = [[0] * V for _ in range(V)]\n\nedges = [] # 隣接リスト\n\nfor i in range(H):\n\n    row = eval(input())\n\n    for j,cell in enumerate(row):\n\n        if cell == 'o':\n\n            graph[1+i][1+H+j] = 1\n\n            graph[1+H+j][1+i] = 1\n\n    s = row.find('S')\n\n    t = row.find('T')\n\n    if s != -1:\n\n        graph[start][1+i] = INF\n\n        graph[start][1+H+s] = INF\n\n    if t != -1:\n\n        graph[1+i][goal] = INF\n\n        graph[1+H+t][goal] = INF\n\n\n\n# あとは max flow を求めればよい\n\n\n\ndef max_flow(graph):\n\n    f = 0\n\n    while True:\n\n        if f > 200:\n\n            return -1\n\n        dist,pred = dijkstra(graph, indices = start, unweighted = True, return_predecessors = True)\n\n        if dist[goal] > INF:\n\n            return f\n\n        f += 1\n\n        after = goal\n\n        while after != start:\n\n            before = pred[after]\n\n            graph[before][after] -= 1\n\n            graph[after][before] += 1\n\n            after = before\n\n\n\nanswer = max_flow(graph)\n\nprint(answer)", "generated_code": "import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\nfrom collections import defaultdict\n\n\n\nH,W = list(map(int,readline().split()))\n\nA = [line.rstrip().decode('utf-8') for line in readlines()]\n\n\n\nsource = 0\n\nsink = H+W+1\n\n\n\ngraph = [defaultdict(int) for _ in range(H+W+2)]\n\n\n\nINF = 10 ** 18\n\nfor h in range(1,H+1):\n\n    for w,ox in enumerate(A[h-1],1):\n\n        if ox == 'x':\n\n            continue\n\n        elif ox == 'o':\n\n            graph[h][H+w] = 1\n\n            graph[H+w][h] = 1\n\n        elif ox == 'S':\n\n            graph[source][h] = INF\n\n            graph[h][source] = INF\n\n            graph[source][H+w] = INF\n\n            graph[H+w][source] = INF\n\n        elif ox == 'T':\n\n            graph[sink][h] = INF\n\n            graph[h][sink] = INF\n\n            graph[sink][H+w] = INF\n\n            graph[H+w][sink] = INF\n\n\n\n\n\nclass Dinic():\n\n    def __init__(self,graph,V,source,sink):\n\n        self.graph = graph\n\n        self.sink = sink\n\n        self.source = source\n\n        self.V = V\n\n#        self.compress()\n\n        self.N = len(V)\n\n    \n\n    def compress(self):\n\n        self.N = len(self.V)\n\n        v_to_i = {x:i for i,x in enumerate(self.V)}\n\n        self.sink = v_to_i[self.sink]\n\n        self.source = v_to_i[self.source]\n\n        g = [dict() for _ in range(self.N)]\n\n        for v,e in list(self.graph.items()):\n\n            vn = v_to_i[v]\n\n            g[vn] = {v_to_i[w]:c for w,c in list(e.items())}\n\n        self.graph = g\n\n        \n\n    def bfs(self):\n\n        level = [0]*self.N\n\n        q = [self.source]\n\n        level[self.source] = 1\n\n        d = 1\n\n        while q:\n\n            if level[self.sink]:\n\n                break\n\n            qq = []\n\n            d += 1\n\n            for v in q:\n\n                for w,cap in list(self.graph[v].items()):\n\n                    if cap == 0:\n\n                        continue\n\n                    if level[w]:\n\n                        continue\n\n                    level[w] = d\n\n                    qq.append(w)\n\n            q = qq\n\n        self.level = level\n\n        \n\n    def dfs(self,v,f):\n\n        if v == self.sink:\n\n            return f\n\n        for w,cap in self.itr[v]:\n\n            if cap == 0 or self.level[w] != self.level[v] + 1:\n\n                continue\n\n            d = self.dfs(w,min(f,cap))\n\n            if d:\n\n                self.graph[v][w] -= d\n\n                self.graph[w][v] += d\n\n                return d\n\n        return 0\n\n    \n\n    def max_flow(self):\n\n        INF = 10**18\n\n        flow = 0\n\n        while True:\n\n            self.bfs()\n\n            if self.level[self.sink] == 0:\n\n                break\n\n            self.itr = [iter(list(e.items())) for e in self.graph]\n\n            while True:\n\n                f = self.dfs(self.source,INF)\n\n                if f == 0:\n\n                    break\n\n                flow += f\n\n        return flow\n\n\n\nanswer = Dinic(graph=graph,V=list(range(H+W+2)),source=0,sink=H+W+1).max_flow()\n\nif answer >= INF:\n\n    answer = -1\n\nprint(answer)", "score": 1.0, "surface_similarity": 0.6865543153133435}
{"id": "p01093_u590871958", "golden_code": "while int(eval(input())) > 0:\n\n    s = sorted(map(int, input().split()))\n\n    print((min(abs(a - b) for (a, b) in zip(s, s[1:]))))", "generated_code": "while True:\n\n    if int(eval(input())) == 0:\n\n        break\n\n    s = sorted(map(int, input().split()))\n\n    r = min(abs(x - y) for (x, y) in zip(s, s[1:]))\n\n    print(r)", "score": 1.0, "surface_similarity": 0.8084991931145777}
{"id": "p02814_u970197315", "golden_code": "# ABC150 D\n\nsi = lambda: eval(input())\n\nni = lambda: int(eval(input()))\n\nnm = lambda: list(map(int, input().split()))\n\nnl = lambda: list(map(int, input().split()))\n\nfrom fractions import gcd\n\nfrom math import ceil\n\ndef lcm(x, y):\n\n    return (x * y) // gcd(x, y)\n\nn,m=nm()\n\na=nl()\n\nans=0\n\na=[x//2 for x in a] \n\n\n\nlcm_v=a[0]\n\nfor i in range(n):\n\n    lcm_v=lcm(lcm_v,a[i])\n\nok_flg=[(lcm_v//i)%2==1 for i in a]\n\nif all(ok_flg):\n\n    ans=((m//lcm_v)+1)//2\n\nprint(ans)\n\n\n", "generated_code": "from math import gcd, ceil\n\n\n\n\n\ndef lcm(a, b):\n\n    return (a*b)//gcd(a, b)\n\n\n\n\n\nn, m = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\n\n\nfor i in range(n):\n\n    a[i] = a[i]//2\n\n\n\nlcm_v = a[0]\n\nfor i in range(1, n):\n\n    lcm_v = lcm(lcm_v, a[i])\n\n\n\nok = True\n\nfor aa in a:\n\n    if (lcm_v//aa) % 2 != 1:\n\n        ok = False\n\n        break\n\nans = 0\n\nif ok:\n\n    ans = ((m//lcm_v)+1)//2\n\nprint(ans)\n", "score": 1.0, "surface_similarity": 0.6830740343347639}
{"id": "p02412_u400765446", "golden_code": "def main():\n\n\n\n    while True:\n\n        n, x = tuple(map(int, input().split()))\n\n        pattern = 0\n\n\n\n        if n == x == 0:\n\n            break\n\n        else:\n\n            for a in range(1, n+1):\n\n                for b in range(1, a):\n\n                    for c in range(1, b):\n\n                        pattern += 1 if a + b + c == x and a > b > c else 0\n\n            print(pattern)\n\n                            \n\n\n\nif __name__ == '__main__':\n\n    main()\n", "generated_code": "def divide_two(c, z):\n\n    min_b = z // 2 + 1\n\n    max_b = min(c-1, z-1)\n\n    return max(max_b-min_b+1, 0)\n\n    \n\n\n\nnum_set = []\n\ncnt = 0\n\nwhile True:\n\n    n, x = list(map(int, input().split()))\n\n    if (n, x) == (0, 0):\n\n        break\n\n    else:\n\n        num_set.append((n, x))\n\n        cnt += 1\n\n\n\nfor i in range(cnt):\n\n    num_count = 0\n\n    (n, x) = num_set[i]\n\n    for c in range(x//3, n+1):\n\n        num_count += divide_two(c, x-c)\n\n    print(num_count)\n", "score": 1.0, "surface_similarity": 0.5911684782608696}
{"id": "p03416_u392029857", "golden_code": "A, B = list(map(int, input().split()))\n\nnumbers = list(range(A, B+1))\n\ncount = 0\n\nfor i in numbers:\n\n    m = str(i)\n\n    rm = ''.join(list(reversed(m)))\n\n    if m == rm:\n\n        count += 1\n\nprint(count)", "generated_code": "A, B = list(map(int, input().split()))\n\nx = list(range(1,10))\n\ny = list(range(10))\n\ncount = 0\n\nfor p in x:\n\n    for q in y:\n\n        for r in y:\n\n            sakasama = int(str(p)+str(q)+str(r)+str(q)+str(p))\n\n            if A <= sakasama <= B:\n\n                count += 1\n\nprint(count)", "score": 1.0, "surface_similarity": 0.7871017871017871}
{"id": "p02863_u634461820", "golden_code": "import sys\n\nfrom operator import itemgetter\n\nfrom heapq import heapify, heappop, heappush\n\nMAX_INT = int(10e15)\n\nMIN_INT = -MAX_INT\n\nmod = 1000000007\n\nsys.setrecursionlimit(1000000)\n\ndef IL(): return list(map(int,input().split()))\n\ndef SL(): return input().split()\n\ndef I(): return int(sys.stdin.readline())\n\ndef S(): return eval(input())\n\n\n\nN, T = IL()\n\nab = [IL() for i in range(N)]\n\nab.sort(key=itemgetter(0))\n\n#print(ab)\n\n\n\ndp = [[0]*(T+1+3000+1) for _ in range(N+1)]\n\nans = 0\n\nfor i in range(N):\n\n  for j in range(T+1+3000+1):\n\n    time, deli = ab[i]\n\n    if 0 <= j-time < T:\n\n      dp[i + 1][j] = max(dp[i][j], dp[i][j - time] + deli)\n\n    else:\n\n      dp[i + 1][j] = dp[i][j]\n\n    ans = max(ans, dp[i + 1][j])\n\nprint(ans)\n\n\n\n#print(dp)\n", "generated_code": "import sys\n\nfrom collections import deque\n\nMAX_INT = int(10e10)\n\nMIN_INT = -MAX_INT\n\nmod = 1000000007\n\nsys.setrecursionlimit(1000000)\n\ndef IL(): return list(map(int,input().split()))\n\ndef SL(): return input().split()\n\ndef I(): return int(sys.stdin.readline())\n\ndef S(): return eval(input())\n\n\n\nN,T = IL()\n\nab = [IL() for i in range(N)]\n\nab.sort()\n\n\n\nans = 0\n\ndp = [[0]*T for i in range(N+1)]\n\nfor i in range(1,N+1):\n\n  a,b = ab[i-1]\n\n  for j in range(T):\n\n    if 0 <= j-a < T:\n\n      dp[i][j] = max(dp[i-1][j], dp[i-1][j-a] + b)\n\n    else:\n\n      dp[i][j] = dp[i-1][j]\n\n  else:\n\n    ans = max(ans, dp[i-1][-1] + b)\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.8758309882132225}
{"id": "p02792_u562935282", "golden_code": "from functools import lru_cache\n\nimport sys\n\n\n\nsys.setrecursionlimit(10 ** 7)\n\n\n\n\n\n@lru_cache(maxsize=None)\n\ndef check(l, r, n, k=1):\n\n    t = l + '0' * k + r\n\n    e = l + '9' * k + r\n\n\n\n    if int(e) <= n:\n\n        return pow(10, k) + check(l, r, n, k + 1)\n\n\n\n    if int(t) <= n < int(e):\n\n        x = int(str(n)[1:-1])\n\n        if int(str(n)[-1]) < int(r):\n\n            x -= 1\n\n        return x + 1\n\n\n\n    if n < int(t):\n\n        return 0\n\n\n\n\n\ndef main():\n\n    n = int(eval(input()))\n\n\n\n    ret = 0\n\n    for x in range(1, n + 1):\n\n        if x % 10 == 0:\n\n            continue\n\n        s = str(x)\n\n        t = s[-1] + s[0]\n\n        if s[0] == s[-1]:\n\n            ret += 1\n\n        if int(t) <= n:\n\n            ret += 1\n\n        ret += check(s[-1], s[0], n, k=1)\n\n\n\n    print(ret)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "generated_code": "# 解説放送\n\n\n\ndef main():\n\n    from collections import defaultdict\n\n\n\n    n = int(eval(input()))\n\n\n\n    d = defaultdict(int)\n\n    for x in range(1, n + 1):\n\n        if x % 10 == 0:\n\n            continue\n\n\n\n        tail = x % 10\n\n        head = 0\n\n        while x:\n\n            head = x\n\n            x //= 10\n\n\n\n        d[head, tail] += 1\n\n\n\n    ret = 0\n\n    for (head, tail), cnt in tuple(d.items()):\n\n        # RuntimeError: dictionary changed size during iteration\n\n        # defaultdictの未定義(?)のkeyにアクセスするせいで、REになる\n\n        # d.items()をtuple化して回避\n\n        ret += d[head, tail] * d[tail, head]\n\n        # (head,tail)の出現数を辞書で管理する\n\n        # (head,tail)*(tail,head)の組み合わせがある\n\n\n\n    print(ret)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 1.0, "surface_similarity": 0.603805798721053}
{"id": "p03325_u699089116", "golden_code": "import math\n\nn = int(eval(input()))\n\na = list(map(int, input().split()))\n\n\n\n\n\ndef trial_division(n):\n\n    factor = []\n\n    tmp = int(math.sqrt(n)) + 1\n\n    for _ in range(2,tmp):\n\n        while n % 2 == 0:\n\n            n //= 2\n\n            factor.append(2)\n\n    if not factor:\n\n        return [n]\n\n    else:\n\n        factor.append(n)\n\n        return factor\n\n\n\n\n\ncount = 0\n\nfor i in a:\n\n    temp = trial_division(i)\n\n    count += temp.count(2)\n\n\n\nprint(count)", "generated_code": "n = int(eval(input()))\n\na = list(map(int, input().split()))\n\n\n\n\n\ndef trial_division(n):\n\n    #２で割った因数を格納するリスト\n\n    factor = []\n\n    #2で割れなくなった時点でストップ\n\n    while n % 2 == 0:\n\n        n //= 2    # ２で割った商を切り捨てて代入\n\n        factor.append(2)\n\n    #nが一度も２で割れなかったらそのまま返す\n\n    if not factor:\n\n        return [n]\n\n    else:\n\n        factor.append(n)\n\n        return factor\n\n\n\n\n\ncount = 0\n\nfor i in a:\n\n    temp = trial_division(i)\n\n    count += temp.count(2)\n\n\n\nprint(count)", "score": 1.0, "surface_similarity": 0.9050184729064039}
{"id": "p03164_u433532588", "golden_code": "\n\n\n\n# N個の荷物、ナップザックの容量はW\n\nN, W = list(map(int, input().split()))\n\nw = [0] * N\n\nv = [0] * N\n\n\n\nfor i in range(N):\n\n    a, b = list(map(int, input().split()))\n\n    w[i] = a\n\n    v[i] = b\n\n\n\n# 1 <= W <= 10^9なので横軸をWにするとテーブルがでかすぎる\n\n# そのかわりにVの方を横軸にする\n\n\n\n# 価値の総合計はまだ不明なので、適当にでかい値にしとく\n\n# 最上部と最左部に0が入るので、その分を+1\n\nV = N*1000+1\n\ndp = [ [float('inf') for _ in range(V+1)] for _ in range(N+1) ]\n\n\n\n# 最小値を求めるので、上記でinfが入ってるので、初期値は0をいれる必要がある\n\ndp[0][0] = 0\n\n\n\n# dp[i][sum_v] = これまで(i-1)番目までの品物から価値がsum_v以上になるように選んだときの、重さの総和の最小値\n\nfor i in range(N):\n\n    for sum_v in range(V):\n\n        if sum_v - v[i] >= 0:\n\n            dp[i+1][sum_v] = min(dp[i+1][sum_v], dp[i][sum_v-v[i]]+w[i])\n\n\n\n        dp[i+1][sum_v] = min(dp[i+1][sum_v], dp[i][sum_v])\n\n\n\n\n\n# 中身がWなので、W以下であるうちのsum_vの最大値を求めればいい\n\nfor sum_v in range(V):\n\n    # 最終行だけ見ればいいので、端からsum_vの最大値をなめるだけ\n\n    if dp[N][sum_v] <= W:\n\n        ans = sum_v\n\n\n\nprint(ans)", "generated_code": "\n\n\n\nimport sys\n\ninput = sys.stdin.readline\n\nsys.setrecursionlimit(2147483647)\n\nINF=float(\"inf\")\n\nMOD=10**9+7\n\n# A = [ int(input()) for _ in range(N) ]\n\n##############################\n\n\n\nN, W = list(map(int, input().split()))\n\nw = []\n\nv = []\n\nfor i in range(N):\n\n    a, b = list(map(int, input().split()))\n\n    w.append(a)\n\n    v.append(b)\n\n\n\nV = sum(v)\n\n\n\ndp = [ [INF for _ in range(V+1)] for _ in range(N+1) ]\n\n\n\ndp[0][0] = 0\n\n\n\nfor i in range(N):\n\n    for j in range(V+1):\n\n        if j - v[i] < 0:\n\n            dp[i+1][j] = dp[i][j]\n\n        else:\n\n            dp[i+1][j] = min(dp[i][j], dp[i][j-v[i]]+w[i])\n\n\n\n#print(dp[N])\n\n\n\nans = 0\n\nfor v in range(V+1):\n\n    if dp[N][v] <= W:\n\n        ans = v\n\n\n\nprint(ans)\n", "score": 1.0, "surface_similarity": 0.7595613048368954}
{"id": "p02599_u968166680", "golden_code": "import sys\n\n\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\nreadlines = sys.stdin.readlines\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = 1 << 60\n\nMOD = 1000000007\n\n\n\n# Reference: https://www.geeksforgeeks.org/queries-number-distinct-elements-subarray/\n\n# Python3 code to find number of\n\n# distinct numbers in a subarray\n\nMAX = 1000001\n\n\n\n# structure to store queries\n\nclass Query:\n\n    def __init__(self, l, r, idx):\n\n        self.l = l\n\n        self.r = r\n\n        self.idx = idx\n\n\n\n\n\n# updating the bit array\n\ndef update(idx, val, bit, n):\n\n    while idx <= n:\n\n        bit[idx] += val\n\n        idx += idx & -idx\n\n\n\n\n\n# querying the bit array\n\ndef query(idx, bit, n):\n\n    summ = 0\n\n    while idx:\n\n        summ += bit[idx]\n\n        idx -= idx & -idx\n\n    return summ\n\n\n\n\n\ndef answeringQueries(arr, n, queries, q):\n\n\n\n    # initialising bit array\n\n    bit = [0] * (n + 1)\n\n\n\n    # holds the rightmost index of\n\n    # any number as numbers of a[i]\n\n    # are less than or equal to 10^6\n\n    last_visit = [-1] * MAX\n\n\n\n    # answer for each query\n\n    ans = [0] * q\n\n\n\n    query_counter = 0\n\n    for i in range(n):\n\n\n\n        # If last visit is not -1 update -1 at the\n\n        # idx equal to last_visit[arr[i]]\n\n        if last_visit[arr[i]] != -1:\n\n            update(last_visit[arr[i]] + 1, -1, bit, n)\n\n\n\n        # Setting last_visit[arr[i]] as i and\n\n        # updating the bit array accordingly\n\n        last_visit[arr[i]] = i\n\n        update(i + 1, 1, bit, n)\n\n\n\n        # If i is equal to r of any query store answer\n\n        # for that query in ans[]\n\n        while query_counter < q and queries[query_counter].r == i:\n\n            ans[queries[query_counter].idx] = query(queries[query_counter].r + 1, bit, n) - query(\n\n                queries[query_counter].l, bit, n\n\n            )\n\n            query_counter += 1\n\n\n\n    # print answer for each query\n\n    for i in range(q):\n\n        print((ans[i]))\n\n\n\n\n\n# This code is contributed by\n\n# sanjeev2552\n\n\n\n\n\ndef main():\n\n    N, Q = list(map(int, readline().split()))\n\n    C = list(map(int, readline().split()))\n\n    (*LR,) = list(map(int, read().split()))\n\n\n\n    queries = [0] * Q\n\n    for i, (l, r) in enumerate(zip(*[iter(LR)] * 2)):\n\n        queries[i] = Query(l - 1, r - 1, i)\n\n\n\n    queries.sort(key=lambda x: x.r)\n\n    answeringQueries(C, N, queries, Q)\n\n\n\n    return\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n\n\n", "generated_code": "import sys\n\n\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\nreadlines = sys.stdin.readlines\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = 1 << 60\n\nMOD = 1000000007\n\n\n\n\n\nclass BIT:\n\n    def __init__(self, n):\n\n        self.n = n\n\n        self.data = [0] * (n + 1)\n\n\n\n    def add(self, i, x=1):\n\n        i += 1\n\n        while i <= self.n:\n\n            self.data[i] += x\n\n            i += i & -i\n\n\n\n    def get_sum(self, i):\n\n        i += 1\n\n        x = 0\n\n        while i > 0:\n\n            x += self.data[i]\n\n            i -= i & -i\n\n        return x\n\n\n\n    # Return sum for [l, r)\n\n    def get_sum_range(self, l, r):\n\n        return self.get_sum(r - 1) - self.get_sum(l - 1)\n\n\n\n\n\ndef main():\n\n    N, Q = map(int, readline().split())\n\n    C = list(map(int, readline().split()))\n\n    LR = map(int, read().split())\n\n\n\n    prev = [-1] * (N + 1)\n\n    ps = [[] for _ in range(N)]\n\n    for i, c in enumerate(C):\n\n        if prev[c] != -1:\n\n            ps[prev[c]].append(i)\n\n        prev[c] = i\n\n\n\n    qs = [[] for _ in range(N + 1)]\n\n    for i, (l, r) in enumerate(zip(*[iter(LR)] * 2)):\n\n        l -= 1\n\n        r -= 1\n\n        qs[l].append((r, i))\n\n\n\n    ans = [0] * Q\n\n    bit = BIT(N)\n\n\n\n    for l in range(N - 1, -1, -1):\n\n        for r in ps[l]:\n\n            bit.add(r)\n\n        for r, i in qs[l]:\n\n            ans[i] = (r - l + 1) - bit.get_sum(r)\n\n\n\n    print(*ans, sep='\\n')\n\n\n\n    return\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 1.0, "surface_similarity": 0.7814760686883448}
{"id": "p02596_u855831834", "golden_code": "k = int(eval(input()))\n\nnum = 0\n\nif not k%2:\n\n    print((-1))\n\nelse:\n\n    for i in range(k):\n\n        num = (num*10+7)%k\n\n        if num == 0:\n\n            print((i+1))\n\n            break\n\n    else:\n\n        print((-1))", "generated_code": "K = int(eval(input()))\n\n\n\nans = 1\n\nnum = 0\n\nseven = 7\n\n\n\nif not K%2:\n\n    print((-1))\n\nelse:\n\n    for i in range(K):\n\n        num = num + seven\n\n        seven = seven*10%K\n\n        num = num%K\n\n        if num == 0:\n\n            print(ans)\n\n            break\n\n        ans += 1\n\n    else:\n\n        print((-1))", "score": 1.0, "surface_similarity": 0.8800992709787498}
{"id": "p02886_u488636998", "golden_code": "N=int(eval(input()))\n\nd=list(map(int, input().split()))\n\n\n\nimport numpy as np\n\nd = np.array(d)\n\n\n\nprint(( ( (np.sum(d))**2 - np.sum(d**2) ) // 2 ))\n", "generated_code": "N=int(eval(input()))\n\nd=list(map(int, input().split()))\n\n\n\ncumsum = 0\n\nfor n in range(N):\n\n    cumsum += d[n]\n\nsub_cumsum = 0\n\nans = 0\n\nfor n in range(N):\n\n    sub_cumsum += d[n]\n\n    ans += d[n] * (cumsum-sub_cumsum)\n\nprint(ans)\n", "score": 1.0, "surface_similarity": 0.5314699792960662}
{"id": "p02596_u444560129", "golden_code": "k = int(eval(input()))\n\ncount = 1\n\nn = 0\n\nif k % 2 == 0 or k % 5 == 0:\n\n    print((-1))\n\nelse:\n\n  while 1:\n\n      n = (n * 10 + 7) % k  \n\n      if n == 0:\n\n        break \n\n      count += 1\n\n  print(count)", "generated_code": "def main(h):\n\n  count = 1\n\n  n = 0\n\n  for i in range (k):\n\n    n = (n * 10 + 7) % k  \n\n    if n == 0: \n\n      print(count)\n\n      return 0\n\n    count += 1\n\n  print((-1))\n\n  \n\nif __name__ == '__main__':\n\n  k = int(eval(input()))\n\n  main(k)", "score": 1.0, "surface_similarity": 0.604341736694678}
{"id": "p03250_u089376182", "golden_code": "a, b, c = sorted(map(int, input().split()))\n\n\n\nprint((c*10 + b + a))", "generated_code": "a, b, c = list(map(int, input().split()))\n\n\n\nprint((max(a, b, c)*9 + (a + b + c)))", "score": 1.0, "surface_similarity": 0.8780487804878049}
{"id": "p03371_u813098295", "golden_code": "a, b, c, x, y = list(map(int, input().split()))\n\nans = float('inf')\n\n\n\nfor i in range(200005):\n\n    tmp = i * 2 * c\n\n    tmp += max(0, x-i) * a\n\n    tmp += max(0, y-i) * b\n\n    ans = min(ans, tmp)\n\n\n\nprint(ans)", "generated_code": "a, b, c, x, y = list(map(int, input().split()))\n\nans = float('inf')\n\n\n\nfor i in range(100005):\n\n    tmp = i * 2 * c\n\n    tmp += max(0, x-i) * a\n\n    tmp += max(0, y-i) * b\n\n    ans = min(ans, tmp)\n\n\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.9976190476190476}
{"id": "p02574_u179169725", "golden_code": "import sys\n\nsys.setrecursionlimit(1 << 25)\n\nreadline = sys.stdin.buffer.readline\n\nread = sys.stdin.readline  # 文字列読み込む時はこっち\n\nra = range\n\nenu = enumerate\n\n\n\n\n\ndef exit(*argv, **kwarg):\n\n    print(*argv, **kwarg)\n\n    sys.exit()\n\n\n\n\n\ndef mina(*argv, sub=1): return list(map(lambda x: x - sub, argv))\n\n# 受け渡されたすべての要素からsubだけ引く.リストを*をつけて展開しておくこと\n\n\n\n\n\ndef a_int(): return int(readline())\n\n\n\n\n\ndef ints(): return list(map(int, readline().split()))\n\n\n\n\n\ndef _make_minimum_prime(N: int):\n\n    # xの最小の素因数表を作成\n\n    min_prime = [x for x in range(N + 1)]\n\n    # min_prime[0] = 0  # 0と1は素数ではない\n\n    # min_prime[1] = 1\n\n    for i in range(2, int(N ** 0.5) + 1):\n\n        if min_prime[i] == i:  # 素数だったら更新\n\n            for j in range(2 * i, N + 1, i):  # iの倍数は素数でない\n\n                if min_prime[j] == j:\n\n                    min_prime[j] = i\n\n    return min_prime\n\n\n\n\n\nmin_prime = _make_minimum_prime(10**6)\n\n\n\n\n\nfrom collections import Counter\n\n\n\n\n\ndef fast_factorization(N: int):\n\n    # -> List[Tuple[int,int]] (素数,冪数)を格納\n\n    # 最小素数配列min_primeを使ってO(log N)で因数分解\n\n    if N == 1:\n\n        return Counter()  # 1は素数ではない\n\n    # 素因数分解\n\n    arr = []\n\n    tmp = N\n\n    while tmp != 1:\n\n        p = min_prime[tmp]\n\n        tmp //= p\n\n        arr.append(p)\n\n\n\n    return Counter(arr)\n\n\n\n\n\nMOD = 10**9 + 7\n\nINF = 2**31  # 2147483648 > 10**9\n\n# default import\n\nfrom collections import defaultdict, Counter, deque\n\nimport random\n\nfrom math import gcd\n\n\n\n\n\nN = a_int()\n\nA = ints()\n\nrandom.shuffle(A)\n\n\n\n# setかはすぐわかる\n\n# setでなければ not coprime\n\n# pairは互いに素かをみればいいのか\n\n# つまり因数分解して足してったときにすべての素数のべき数が1以下であれば良い\n\n\n\ng_set = 0\n\ncnt = defaultdict(lambda: 0)\n\nflg = 1  # pairwiseであるフラグ\n\nfor a in A:\n\n    g_set = gcd(g_set, a)\n\n    if flg:\n\n        for p, n in fast_factorization(a).items():\n\n            if cnt[p] != 0:\n\n                flg = 0\n\n            cnt[p] += n\n\n\n\n\n\n# print(cnt)\n\n# for v in cnt.values():\n\n#     if v > 1:\n\n#         flg = 0\n\n#         break\n\n\n\nif g_set > 1:\n\n    print('not coprime')\n\nelif flg:\n\n    print('pairwise coprime')\n\nelse:\n\n    print('setwise coprime')\n", "generated_code": "import sys\n\nsys.setrecursionlimit(1 << 25)\n\nreadline = sys.stdin.buffer.readline\n\nread = sys.stdin.readline  # 文字列読み込む時はこっち\n\nra = range\n\nenu = enumerate\n\n\n\n\n\ndef exit(*argv, **kwarg):\n\n    print(*argv, **kwarg)\n\n    sys.exit()\n\n\n\n\n\ndef mina(*argv, sub=1): return list(map(lambda x: x - sub, argv))\n\n# 受け渡されたすべての要素からsubだけ引く.リストを*をつけて展開しておくこと\n\n\n\n\n\ndef a_int(): return int(readline())\n\n\n\n\n\ndef ints(): return list(map(int, readline().split()))\n\n\n\n\n\nfrom collections import Counter\n\n\n\n\n\nclass FastFactorization:\n\n    def __init__(self, N: int):\n\n        '''構築O(NloglogN)、クエリO(logN)'''\n\n        self.N = N\n\n        self.min_prime = self._make_minimum_prime()\n\n\n\n    def _make_minimum_prime(self):\n\n        # xの最小の素因数表を作成\n\n        min_prime = [x for x in range(self.N + 1)]\n\n        # min_prime[0] = 0  # 0と1は素数ではない\n\n        # min_prime[1] = 1\n\n        for i in range(2, int(self.N ** 0.5) + 1):\n\n            if min_prime[i] == i:  # 素数だったら更新\n\n                for j in range(2 * i, self.N + 1, i):  # iの倍数は素数でない\n\n                    if min_prime[j] == j:\n\n                        min_prime[j] = i\n\n        return min_prime\n\n\n\n    def query(self, x: int):\n\n        # -> Counter[p,n] (素数,冪数) を格納\n\n        # 最小素数配列min_primeを使ってO(log N)で因数分解\n\n        if x == 1:\n\n            return Counter()  # 1は素数ではない\n\n\n\n        # 素因数分解\n\n        arr = []\n\n        tmp = x\n\n        while tmp != 1:\n\n            p = self.min_prime[tmp]\n\n            tmp //= p\n\n            arr.append(p)\n\n        return Counter(arr)\n\n\n\n\n\nMOD = 10**9 + 7\n\nINF = 2**31  # 2147483648 > 10**9\n\n# default import\n\nfrom collections import defaultdict, Counter, deque\n\nfrom math import gcd\n\n\n\n\n\nN = a_int()\n\nA = ints()\n\n\n\nfact = FastFactorization(max(A))\n\n\n\n# setかはすぐわかる\n\n# setでなければ not coprime\n\n# pairは互いに素かをみればいいのか\n\n# つまり因数分解して足してったときにすべての素数のべき数が1以下であれば良い\n\n\n\ng_set = 0\n\ncnt = defaultdict(lambda: 0)\n\nflg = 1  # pairwiseであるフラグ\n\nfor a in A:\n\n    g_set = gcd(g_set, a)\n\n    if flg:\n\n        for p, n in fact.query(a).items():\n\n            if cnt[p] != 0:\n\n                flg = 0\n\n            cnt[p] += n\n\n\n\n\n\n# print(cnt)\n\n# for v in cnt.values():\n\n#     if v > 1:\n\n#         flg = 0\n\n#         break\n\n\n\nif g_set > 1:\n\n    print('not coprime')\n\nelif flg:\n\n    print('pairwise coprime')\n\nelse:\n\n    print('setwise coprime')\n", "score": 1.0, "surface_similarity": 0.9177916680091504}
{"id": "p03844_u499259667", "golden_code": "print((eval(input())))", "generated_code": "print(eval(input()))", "score": 1.0, "surface_similarity": 0.9545454545454546}
{"id": "p03568_u576434377", "golden_code": "N = int(eval(input()))\n\nAs = list(map(int,input().split()))\n\n\n\n\n\ndef dfs(A_s, index,Bss):\n\n    if index == N:\n\n        tmp = 1\n\n        for b in Bss:\n\n            tmp *= b\n\n        return 1 if tmp % 2 == 0 else 0\n\n    b_mi = Bss.copy()\n\n    b_mi.append(A_s[index] - 1)\n\n\n\n    b = Bss.copy()\n\n    b.append(A_s[index])\n\n\n\n    b_pl = Bss.copy()\n\n    b_pl.append(A_s[index] + 1)\n\n    return dfs(A_s,index + 1, b_mi) + dfs(A_s,index + 1,b) + dfs(A_s,index + 1,b_pl)\n\n\n\n\n\nprint((dfs(As,0,[])))\n", "generated_code": "N = int(eval(input()))\n\nAs = list(map(int,input().split()))\n\n\n\ntmp = 1\n\nfor i in range(N):\n\n    if As[i] % 2 == 0:\n\n       tmp *= 2\n\n\n\nprint((3 ** N - tmp))", "score": 1.0, "surface_similarity": 0.5968969555035128}
{"id": "p02767_u638456847", "golden_code": "import numpy as np\n\nimport sys\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\nreadlines = sys.stdin.readlines\n\n\n\ndef main():\n\n    N = int(readline())\n\n    X = [int(i) for i in readline().split()]\n\n    X = np.array(X)\n\n\n\n    ans = np.min(np.sum((X - np.arange(1,101).reshape(100, 1))**2, axis=1))\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "generated_code": "import sys\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\nreadlines = sys.stdin.readlines\n\n\n\ndef main():\n\n    N = int(readline())\n\n    X = [int(i) for i in readline().split()]\n\n\n\n    ans = float('inf')\n\n    for i in range(1,101):\n\n        tmp = 0\n\n        for x in X:\n\n            tmp += (x - i)**2\n\n        \n\n        if tmp < ans:\n\n            ans = tmp\n\n\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "score": 1.0, "surface_similarity": 0.7979638009049774}
{"id": "p03796_u414877092", "golden_code": "import math\n\nn=int(eval(input()))\n\nprint((math.factorial(n)%(10**9+7)))", "generated_code": "N=int(eval(input()))\n\ndef fact(n):\n\n    val=1\n\n    for i in range(2,n+1):\n\n        val*=i\n\n        val%=1000000007\n\n    return val\n\nprint((fact(N)))", "score": 1.0, "surface_similarity": 0.46959459459459457}
{"id": "p02555_u503227287", "golden_code": "from sys import stdin\n\nfrom math import factorial\n\n\n\n\n\ndef combinations_count(n, r):\n\n    return factorial(n) // (factorial(n - r) * factorial(r))\n\n\n\n\n\ndef combinations_with_replacement_count(n, r):\n\n    return combinations_count(n + r - 1, r)\n\n\n\n\n\ndef main():\n\n    _in = [_.rstrip() for _ in stdin.readlines()]\n\n    S = int(_in[0])  # type:int\n\n    # vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv\n\n    min_ = 1\n\n    max_ = S // 3\n\n    ans = 0\n\n    for i in range(min_, max_ + 1):\n\n        mod = S - i * 3\n\n        ans += combinations_with_replacement_count(mod + 1, i - 1) % (10**9 + 7)\n\n    ans %= (10**9 + 7)\n\n    # ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "generated_code": "from sys import stdin\n\n\n\n\n\nclass ModComb():\n\n    def __init__(self, n_max, mod):\n\n        self.fac = None\n\n        self.mod = mod\n\n        self.make_fac_table(n_max)\n\n\n\n    def make_fac_table(self, n_max):\n\n        self.fac = [1] + [0] * n_max\n\n        for i in range(1, n_max + 1):\n\n            self.fac[i] = self.fac[i - 1] * i % self.mod\n\n\n\n    def mod_comb(self, n, k):\n\n        if n == 0 and k == 0:\n\n            return 1\n\n        elif n < k or k < 0:\n\n            return 0\n\n        else:\n\n            return self.fac[n] * pow(self.fac[n - k], self.mod - 2, self.mod) * \\\n\n                pow(self.fac[k], self.mod - 2, self.mod) % self.mod\n\n\n\n    def mod_comb_with_rep(self, n, k):\n\n        return self.mod_comb(n + k - 1, k)\n\n\n\n\n\ndef main():\n\n    _in = [_.rstrip() for _ in stdin.readlines()]\n\n    S = int(_in[0])  # type:int\n\n    # vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv\n\n    ans = 0\n\n    MOD = 10**9 + 7\n\n    modcomb = ModComb(S + 1, MOD)\n\n    min_ = 1\n\n    max_ = S // 3\n\n    for i in range(min_, max_ + 1):\n\n        res = S - i * 3\n\n        ans += modcomb.mod_comb_with_rep(res + 1, i - 1)\n\n        ans %= MOD\n\n    # ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "score": 1.0, "surface_similarity": 0.3156424581005587}
{"id": "p03309_u970308980", "golden_code": "N = int(eval(input()))\n\nA = list(map(int, input().split()))\n\n# 中央値\n\nB = []\n\nfor i in range(N):\n\n    B.append(A[i] - (i+1))\n\nb = sorted(B)[N//2]\n\n\n\nans = 0\n\nfor i in range(N):\n\n    ans += abs(A[i] - (i + 1) - b)\n\n\n\nprint(ans)\n\n\n", "generated_code": "from statistics import median_low\n\n\n\nN = int(eval(input()))\n\nA = list(map(int, input().split()))\n\n\n\nD = []\n\nfor i in range(N):\n\n    D.append(A[i] - (i+1))\n\n\n\nm = median_low(D)\n\nans = 0\n\nfor d in D:\n\n    ans += abs(d - m)\n\n\n\nprint(ans)\n", "score": 1.0, "surface_similarity": 0.7803191489361703}
{"id": "p03801_u893063840", "golden_code": "n = int(input())\n\na = list(map(int, input().split()))\n\n\n\ntmp = [[e, n - i] for i, e in enumerate(a)]\n\ntmp.sort(reverse=True)\n\n\n\naa = [[e, n - i] for e, i in tmp] + [[0, -1]]\n\n\n\nv_prev, i_prev = aa[0]\n\ni = 0\n\nans = [0] * n\n\nsm = 0\n\nwhile i < n:\n\n    while aa[i][1] >= i_prev:\n\n        sm += aa[i][0]\n\n        i += 1\n\n\n\n    ans[i_prev] += sm - aa[i][0] * i\n\n    sm = aa[i][0] * i\n\n    v_prev, i_prev = aa[i]\n\n\n\nprint(*ans, sep=\"\\n\")\n", "generated_code": "from bisect import bisect_right\n\n\n\nn = int(input())\n\na = list(map(int, input().split()))\n\n\n\nli = [[0, -1]]\n\nfor i, e in enumerate(a):\n\n    if e > li[-1][0]:\n\n        li.append([e, i])\n\n\n\nli = li[::-1]\n\n\n\na.sort()\n\nacc = [0] * (n + 1)\n\nfor i in range(n - 1, -1, -1):\n\n    acc[i] = acc[i+1] + a[i]\n\n\n\nans = [0] * n\n\nsub = 0\n\nans_prev = 0\n\nfor (ep, ip), (e, i) in zip(li, li[1:]):\n\n    j = bisect_right(a, e)\n\n    ans[ip] = acc[j] - e * (n - j)\n\n\n\ni_prev = 0\n\nfor i in range(1, n):\n\n    if ans[i]:\n\n        ans[i_prev] -= ans[i]\n\n        i_prev = i\n\n\n\nprint(*ans, sep=\"\\n\")\n", "score": 1.0, "surface_similarity": 0.6193211084784176}
{"id": "p03013_u970197315", "golden_code": "N, M = list(map(int, input().split()))\n\nA_ = [int(eval(input())) for _ in range(M)]\n\nA = [0] * (N+3)\n\nfor a in A_:\n\n    A[a] = 1\n\ndp = [0] * (N+3)\n\ndp[0] = 1\n\n\n\nmod = 10**9+7\n\n\n\nfor i in range(1, N+1):\n\n    if A[i-1] == 0:\n\n        dp[i] += dp[i-1]\n\n    if A[i-2] == 0:\n\n        dp[i] += dp[i-2]\n\n    dp[i] %= mod\n\nprint((dp[N]))", "generated_code": "n,m=list(map(int,input().split()))\n\ndp=[0]*(n+3)\n\na=[int(eval(input())) for i in range(m)]\n\nmod=10**9+7\n\nfor i in range(m):\n\n    dp[a[i]]=-1\n\n\n\ndp[0]=1\n\nif dp[1]!=-1:\n\n    dp[1]+=dp[0]\n\n\n\nfor i in range(n+1):\n\n    if dp[i+2]==-1:\n\n        continue\n\n    if dp[i]!=-1:\n\n        dp[i+2]+=dp[i]\n\n    if dp[i+1]!=-1:\n\n        dp[i+2]+=dp[i+1]\n\n    dp[i+2]%=mod\n\nprint((dp[n]%mod))", "score": 1.0, "surface_similarity": 0.7593333333333334}
{"id": "p02635_u875291233", "golden_code": "# coding: utf-8\n\n# Your code here!\n\nimport sys\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\n\n\n#a,b,c,d = map(int,readline().split())\n\ns,k = readline().split()\n\n\n\n\n\na = [len(i) for i in s.split(\"0\")]\n\nwhile a and a[-1] == 0: a.pop()\n\n\n\nif not a:\n\n    print((1))\n\n    exit()\n\n\n\nMOD = 998244353\n\n\n\nM = sum(a)+1\n\nk = min(int(k),M)\n\n\n\n\n\ndp = [[0]*M for _ in range(k+1)] # j 使って（上限 k）、l 余ってる\n\ndp[0][0] = 1\n\n\n\n#print(a)\n\nfor ai in a[::-1]:\n\n    ndp = [[0]*M for _ in range(k+1)] # j 使って（上限 k）、l 余ってる\n\n    for j in range(k+1):\n\n        for l in range(M):\n\n            for ll in range(l):\n\n                ndp[j][ll] += dp[j][l]\n\n                ndp[j][ll] %= MOD\n\n            \n\n            V = min(M-l,k-j+1,ai+1)\n\n            for i in range(V):\n\n                #if j+i > k: break\n\n                ndp[j+i][l+i] += dp[j][l]\n\n                ndp[j+i][l+i] %= MOD\n\n    \n\n    dp = ndp\n\n    #print(dp)\n\n\n\nans = 0\n\nfor jj in range(k+1):\n\n    ans += dp[jj][0]\n\n\n\nprint((ans%MOD))\n\n\n\n\n\n\n\n\n\n\n", "generated_code": "# coding: utf-8\n\n# Your code here!\n\nimport sys\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\n\n\n#a,b,c,d = map(int,readline().split())\n\ns,k = readline().split()\n\n\n\n\n\na = [len(i) for i in s.split(\"0\")]\n\nwhile a and a[-1] == 0: a.pop()\n\n\n\nif not a:\n\n    print((1))\n\n    exit()\n\n\n\nMOD = 998244353\n\n\n\nM = sum(a)+1\n\nk = min(int(k),M)\n\n\n\n\n\ndp = [[0]*M for _ in range(k+1)] # j 使って（上限 k）、l 余ってる\n\ndp[0][0] = 1\n\n\n\n#print(a)\n\nfor ai in a[::-1]:\n\n    ndp = [[0]*M for _ in range(k+1)] # j 使って（上限 k）、l 余ってる\n\n    for j in range(k+1):\n\n        for l in range(M):\n\n            if dp[j][l]:\n\n                for ll in range(l):\n\n                    ndp[j][ll] += dp[j][l]\n\n                    ndp[j][ll] %= MOD\n\n\n\n                V = min(M-l,k-j+1,ai+1)\n\n                for i in range(V):\n\n                    #if j+i > k: break\n\n                    ndp[j+i][l+i] += dp[j][l]\n\n                    ndp[j+i][l+i] %= MOD\n\n    \n\n    dp = ndp\n\n    #print(dp)\n\n\n\nans = 0\n\nfor jj in range(k+1):\n\n    ans += dp[jj][0]\n\n\n\nprint((ans%MOD))\n\n\n\n\n\n\n\n\n\n\n", "score": 1.0, "surface_similarity": 0.9941916747337851}
{"id": "p02792_u573754721", "golden_code": "n=int(eval(input()))\n\nD={}\n\nDD={}\n\nfor i in range(1,n+1):\n\n   s=(str(i)[0],str(i)[-1])\n\n   t=(str(i)[-1],str(i)[0])\n\n   if s not in D:\n\n      D[s]=1\n\n   else:\n\n      D[s]+=1\n\n   if t not in DD:\n\n      DD[t]=1\n\n   else:\n\n      DD[t]+=1\n\nans=0\n\nfor i in D:\n\n   if i in DD:\n\n      ans+=D[i]*DD[i]\n\nprint(ans)\n\n      ", "generated_code": "n=int(eval(input()))\n\nD={}\n\nfor i in range(1,n+1):\n\n   s=(str(i)[0],str(i)[-1])\n\n   if s in D:\n\n      D[s]+=1\n\n   else:\n\n      D[s]=1\n\n\n\nans=0\n\nfor aj,bj in D:\n\n   if (bj,aj) in D:\n\n      ans+=D[(aj,bj)]*D[(bj,aj)]\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.8217113487984442}
{"id": "p03013_u092301301", "golden_code": "n,m=[int(i) for i in input().split()]\n\ndp=[1,1] ;a=set() ; mod=(10**9+7)\n\nfor i in range(m):\n\n    a.add(int(eval(input())))\n\nif 1 in a: dp[1]=0\n\nfor i in range(2,n+1):\n\n    if i not in a:\n\n        dp.append((dp[-1]+dp[-2])%mod)\n\n    else:\n\n        dp.append(0)\n\nprint((dp[-1]))\n\n    \n", "generated_code": "import sys\n\ninput = lambda: sys.stdin.readline().rstrip()\n\nn,m=[int(i) for i in input().split()]\n\ndp=[1,1] ;a=set() ; mod=(10**9+7)\n\nfor i in range(m):\n\n    a.add(int(eval(input())))\n\nif 1 in a: dp[1]=0\n\nfor i in range(2,n+1):\n\n    if i not in a:\n\n        dp.append((dp[-1]+dp[-2])%mod)\n\n    else:\n\n        dp.append(0)\n\nprint((dp[-1]))\n\n    \n", "score": 1.0, "surface_similarity": 0.8560738581146745}
{"id": "p03013_u546338822", "golden_code": "from functools import lru_cache\n\n\n\ndef main():\n\n    n,m = list(map(int,input().split()))\n\n    import numpy as np\n\n    ans = np.ones(n+1,dtype=int)*-1\n\n    ans[0] = 1\n\n    mod = 10**9+7\n\n    for _ in range(m):\n\n        a = int(eval(input()))\n\n        ans[a]=0\n\n    if ans[1]!=0:\n\n        ans[1]=1\n\n    for i in range(2,n+1):\n\n        if ans[i]!=0:\n\n            ans[i] = (ans[i-1]+ans[i-2])%mod\n\n    print((ans[-1]))\n\n        \n\n\n\nif __name__ == \"__main__\":\n\n    main()", "generated_code": "def main():\n\n    n,m = list(map(int,input().split()))\n\n    dp = [0 for i in range(n+1)]\n\n    mod = 10**9+7\n\n    for i in range(m):\n\n        a = int(eval(input()))\n\n        dp[a] = -1\n\n    dp[0] = 1\n\n    if dp[1]!=-1:\n\n        dp[1] = 1\n\n    for i in range(2,n+1):\n\n        if dp[i]==-1:\n\n            continue\n\n        if dp[i-1]!=-1 and dp[i-2]!=-1:\n\n            dp[i] = dp[i-1] + dp[i-2]\n\n            dp[i] = dp[i]%mod\n\n        elif dp[i-1]!=-1 and dp[i-2]==-1:\n\n            dp[i] = dp[i-1]\n\n        elif dp[i-1]==-1 and dp[i-2]!=-1:\n\n            dp[i] = dp[i-2]\n\n        else:\n\n            dp[i] = 0\n\n    print((dp[-1]))\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "score": 1.0, "surface_similarity": 0.6671261487050961}
{"id": "p03796_u486297080", "golden_code": "import math\n\n\n\nN = int(eval(input()))\n\nans = 0\n\n\n\nans =math.factorial(N) % (10**9 +7)\n\n\n\nprint(ans)", "generated_code": "N = int(eval(input()))\n\npower = 1\n\n\n\nfor i in range(N):\n\n    power = ((i+1) * power) % 1000000007\n\n\n\nprint(power)", "score": 1.0, "surface_similarity": 0.5536179073399272}
{"id": "p03078_u023958502", "golden_code": "X,Y,Z,K = list(map(int,input().split()))\n\nA = list(map(int,input().split()))\n\nB = list(map(int,input().split()))\n\nC = list(map(int,input().split()))\n\nasort,bsort,csort = sorted(A,reverse=True),sorted(B,reverse=True),sorted(C,reverse=True)\n\nprint((asort[0] + bsort[0] + csort[0]))\n\nalready = [[0,0,0]]\n\nx,y,z = 0,0,0\n\nplace_sum = []\n\ncheck = []\n\nfor k in range(K - 1):\n\n    if [x + 1,y,z] not in already and x + 1 < X:\n\n        already.append([x + 1,y,z])\n\n        place_sum.append([x + 1,y,z])\n\n        check.append(asort[x + 1] + bsort[y] + csort[z])\n\n    if [x,y + 1,z] not in already and y + 1 < Y:\n\n        already.append([x,y + 1,z])\n\n        place_sum.append([x,y + 1,z])\n\n        check.append(asort[x] + bsort[y + 1] + csort[z])\n\n    if [x,y,z + 1] not in already and z + 1 < Z:\n\n        already.append([x,y,z + 1])\n\n        place_sum.append([x,y,z + 1])\n\n        check.append(asort[x] + bsort[y] + csort[z + 1])\n\n    print((max(check)))\n\n    x,y,z = place_sum[check.index(max(check))][0],place_sum[check.index(max(check))][1],place_sum[check.index(max(check))][2]\n\n    place_sum.pop(check.index(max(check)))\n\n    check.remove(max(check))", "generated_code": "import heapq\n\nX,Y,Z,K = list(map(int,input().split()))\n\nA = list(map(int,input().split()))\n\nB = list(map(int,input().split()))\n\nC = list(map(int,input().split()))\n\nasort,bsort,csort = sorted(A,reverse=True),sorted(B,reverse=True),sorted(C,reverse=True)\n\nalready = [[0,0,0]]\n\nprint((asort[0] + bsort[0] + csort[0]))\n\nx,y,z = 0,0,0\n\ncheck = []\n\nfor k in range(K - 1):\n\n    if [x + 1,y,z] not in already and x + 1 < X:\n\n        already.append([x + 1,y,z])\n\n        heapq.heappush(check,(-(asort[x + 1] + bsort[y] + csort[z]),x + 1,y,z))\n\n    if [x,y + 1,z] not in already and y + 1 < Y:\n\n        already.append([x,y + 1,z])\n\n        heapq.heappush(check,(-(asort[x] + bsort[y + 1] + csort[z]),x,y + 1,z))\n\n    if [x,y,z + 1] not in already and z + 1 < Z:\n\n        already.append([x,y,z + 1])\n\n        heapq.heappush(check,(-(asort[x] + bsort[y] + csort[z + 1]),x,y,z + 1))\n\n    maxsum = heapq.heappop(check)\n\n    print((-maxsum[0]))\n\n    x,y,z = maxsum[1],maxsum[2],maxsum[3]", "score": 1.0, "surface_similarity": 0.782719900187149}
{"id": "p02725_u589913372", "golden_code": "import numpy as np\n\nk,n = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\nb = np.zeros(n)\n\nfor i in range(0,n-1):\n\n  b[i] = a[i+1] -a[i]\n\n  \n\nb[n-1] = k - a[n-1] + a[0]\n\nans = k - max(b)\n\nprint((int(ans)))", "generated_code": "k,n = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\nb = [0 for i in range(n)]\n\nfor i in range(0,n-1):\n\n  b[i] = a[i+1] -a[i]\n\n\n\nb[n-1] = k - a[n-1] + a[0]\n\nans = k - max(b)\n\nprint((int(ans)))", "score": 1.0, "surface_similarity": 0.8361233480176211}
{"id": "p02996_u652656291", "golden_code": "import numpy as np\n\n# 締切が早いものから処理\n\nN = int(eval(input()))\n\nAB = np.array([[int(x) for x in input().split()] for _ in range(N)])\n\nA = AB[:,0]\n\nB = AB[:,1]\n\nidx = B.argsort()\n\nA = A[idx]\n\nB = B[idx]\n\nnp.cumsum(A, out = A)\n\nbl = (A <= B).all()\n\nanswer = 'Yes' if bl else 'No'\n\nprint(answer)\n", "generated_code": "def main():\n\n    N = int(eval(input()))\n\n    A = []\n\n    for _ in range(N):\n\n        a, b = list(map(int, input().split()))\n\n        A.append((a, b))\n\n\n\n    A = sorted(A, key=lambda x: x[1])\n\n    time = 0\n\n    for a, b in A:\n\n        time += a\n\n        if time > b:\n\n            return 'No'\n\n\n\n    return 'Yes'\n\n\n\nif __name__ == '__main__':\n\n    print((main()))\n", "score": 1.0, "surface_similarity": 0.4605134871628209}
{"id": "p03371_u969190727", "golden_code": "a,b,c,x,y=list(map(int,input().split()))\n\nans=a*x+b*y\n\nn=max(x,y)\n\nfor i in range(1,n+1):\n\n  ans=min(ans,2*i*c+a*max(0,x-i)+b*max(0,y-i))\n\nprint(ans)\n\n\n\n\n", "generated_code": "a,b,c,x,y=list(map(int,input().split()))\n\nans1=a*x+b*y\n\nans2=2*c*max(x,y)\n\nans3=2*c*min(x,y)+a*(x-min(x,y))+b*(y-min(x,y))\n\nprint((min(ans1,ans2,ans3)))", "score": 1.0, "surface_similarity": 0.7393939393939394}
{"id": "p03325_u879870653", "golden_code": "answer = 0\n\nN = int(eval(input()))\n\nA = list(map(int,input().split()))\n\nfor i in range(N) :\n\n    while A[i] % 2 == 0 :\n\n        A[i] = A[i] / 2\n\n        answer += 1\n\nprint(answer)\n\n\n", "generated_code": "N = int(eval(input()))\n\nL = list(map(int,input().split()))\n\n\n\nans = 0\n\nfor i in range(N) :\n\n    flag = 0\n\n    while flag == 0 :\n\n        if (L[i] % 2) == 0 :\n\n            ans += 1\n\n            L[i] = L[i]//2\n\n        else :\n\n            flag = 1\n\nprint(ans)\n", "score": 1.0, "surface_similarity": 0.8174770965468641}
{"id": "p02647_u390193191", "golden_code": "import sys\n\nfrom collections import defaultdict, Counter, namedtuple, deque\n\nimport itertools\n\nimport functools\n\nimport bisect\n\nimport heapq\n\nimport math\n\n# from fractions import gcd\n\n\n\nMOD = 10 ** 9 + 7\n\n# MOD = 998244353\n\n# sys.setrecursionlimit(10**8)\n\n\n\nN, k = list(map(int, input().split()))\n\nprev_arr = list(map(int, input().split()))\n\n\n\n# N = k = 200000\n\n# prev_arr = [0]*N\n\n\n\ncount = 0\n\nfor i in range(min(k, 3*int(math.log(N))+5)):\n\n    que = []\n\n    arr = [0]*N\n\n    for j in range(N):\n\n        heapq.heappush(que, j+prev_arr[j])\n\n        while que[0] < j:\n\n            heapq.heappop(que)\n\n        arr[j] += len(que)\n\n    # print(arr)\n\n\n\n    que = []\n\n    for j in reversed(list(range(N))):\n\n        heapq.heappush(que, -(j-prev_arr[j]))\n\n        while -que[0] > j:\n\n            heapq.heappop(que)\n\n        arr[j] += len(que) - 1\n\n\n\n    prev_arr = arr\n\n    count += 1\n\n\n\n# print(count)\n\nprint((*prev_arr))\n", "generated_code": "import sys\n\nfrom collections import defaultdict, Counter, namedtuple, deque\n\nimport itertools\n\nimport functools\n\nimport bisect\n\nimport heapq\n\nimport math\n\n# from fractions import gcd\n\n\n\nMOD = 10 ** 9 + 7\n\n# MOD = 998244353\n\n# sys.setrecursionlimit(10**8)\n\n\n\nN, k = list(map(int, input().split()))\n\nprev_arr = list(map(int, input().split()))\n\n\n\ncount = 0\n\nfor i in range(min(k, 3*int(math.log(N))+10)):\n\n    arr = [0]*N\n\n    for j in range(N):\n\n        left = max(0, j-prev_arr[j])\n\n        right = min(N-1, j+prev_arr[j])\n\n        arr[left] += 1\n\n        if right < N-1:\n\n            arr[right+1] -= 1\n\n\n\n    # print(arr)\n\n    for j in range(1, N):\n\n        arr[j] += arr[j-1]\n\n\n\n    # print(arr)\n\n    prev_arr = arr\n\n    count += 1\n\n\n\n# print(count)\n\nprint((*prev_arr))\n", "score": 1.0, "surface_similarity": 0.8281976334695027}
{"id": "p03034_u619458041", "golden_code": "import sys\n\n\n\ndef main():\n\n    input = sys.stdin.readline\n\n    N = int(eval(input()))\n\n    S = list(map(int, input().split()))\n\n\n\n    ans = 0\n\n    for C in range(1, N//2):\n\n        n = N // C\n\n        point = 0\n\n        used = set([0])\n\n        for k in range(1, n):\n\n            A = N - 1 - k*C\n\n\n\n            if A in used or k*C in used or A == k*C:\n\n                break\n\n            used.add(A)\n\n            used.add(k*C)\n\n\n\n            point += S[A] + S[k*C]\n\n            ans = max(ans, point)\n\n\n\n    return ans\n\n\n\n\n\nif __name__ == '__main__':\n\n    print((main()))\n", "generated_code": "import sys\n\n\n\ndef main():\n\n    input = sys.stdin.readline\n\n    N = int(eval(input()))\n\n    S = list(map(int, input().split()))\n\n\n\n    ans = 0\n\n    # C = A - B\n\n    for C in range(1, N//2):\n\n        n = (N-1) // C\n\n        point = 0\n\n        for k in range(1, n):\n\n            A = N-1 - k*C\n\n\n\n            # Check A and B are positive integer, and S_i is not used twice.\n\n            #\n\n            # B = A - C and B >= 0, so A must be over C (A > C).\n\n            #\n\n            # If C is aliquot of N-1 (N-1 % C = 0), A is also aliquot of N-1\n\n            # (N-1 % A = 0) because A + kC = N-1. Therefore when A is less than\n\n            # or equal kC, the A's value is already used by kC.\n\n            if A < C or ((N-1) % C == 0 and A <= k*C):\n\n                break\n\n\n\n            point += S[A] + S[k*C]\n\n            ans = max(ans, point)\n\n\n\n    return ans\n\n\n\n\n\nif __name__ == '__main__':\n\n    print((main()))\n", "score": 1.0, "surface_similarity": 0.8792364262243781}
{"id": "p03038_u498487134", "golden_code": "import sys\n\ninput = sys.stdin.readline\n\n\n\ndef I(): return int(eval(input()))\n\ndef MI(): return list(map(int, input().split()))\n\ndef LI(): return list(map(int, input().split()))\n\n\n\ndef main():\n\n    mod=10**9+7\n\n    N,M=MI()\n\n    A=LI()\n\n    CB=[[0,0]for _ in range(M)]\n\n    A.sort()\n\n    for i in range(M):\n\n        CB[i][1],CB[i][0]=MI()\n\n        \n\n    CB.sort(reverse=True)\n\n    now=0\n\n    \n\n    for i in range(N):\n\n        if CB[now][1]<=0:\n\n            now+=1\n\n        \n\n        if now>=M:\n\n            break    \n\n        \n\n        ch=CB[now][0]\n\n        if A[i]<ch:\n\n            A[i]=ch\n\n            CB[now][1]-=1\n\n        else:\n\n            break\n\n        \n\n    print((sum(A)))\n\n    \n\n\n\nmain()\n", "generated_code": "import sys\n\ninput = sys.stdin.readline\n\n\n\ndef I(): return int(eval(input()))\n\ndef MI(): return list(map(int, input().split()))\n\ndef LI(): return list(map(int, input().split()))\n\n\n\ndef main():\n\n    mod=10**9+7\n\n    N,M=MI()\n\n    A=LI()\n\n    B=[0]*M\n\n    C=[0]*M\n\n    for i in range(M):\n\n        B[i],C[i]=MI()\n\n    \n\n    C,B=list(zip(*sorted(zip(C,B))))\n\n    B=B[::-1]\n\n    C=C[::-1]\n\n    \n\n    import heapq\n\n    heapq.heapify(A)\n\n    \n\n    for i in range(M):\n\n        b=B[i]\n\n        c=C[i]\n\n        for _ in range(b):\n\n            a=heapq.heappop(A)\n\n            if a>=c:\n\n                heapq.heappush(A,a)\n\n                break\n\n            else:\n\n                heapq.heappush(A,c)\n\n                \n\n    ans=0\n\n    for i in range(N):\n\n        a=heapq.heappop(A)\n\n        ans+=a\n\n        \n\n    print(ans)\n\n\n\nmain()\n", "score": 1.0, "surface_similarity": 0.7135356639774619}
{"id": "p03828_u396211450", "golden_code": "from math import factorial\n\n\n\nn = int(eval(input()))\n\nf = factorial(n)\n\n\n\nmod = 10 ** 9 + 7\n\n\n\ndef primes(n):\n\n    is_prime = [True] * (n + 1)\n\n    is_prime[0] = False\n\n    is_prime[1] = False\n\n    for i in range(2, int(n ** 0.5) + 1):\n\n        if not is_prime[i]:\n\n            continue\n\n        for j in range(i * 2, n + 1, i):\n\n            is_prime[j] = False\n\n    return [i for i in range(n + 1) if is_prime[i]]\n\n\n\nans = 1\n\nfor p in primes(n):\n\n    temp = 1\n\n    while f % p == 0:\n\n        temp += 1\n\n        f //= p\n\n    ans = (ans * temp) % mod\n\nprint(ans)\n", "generated_code": "n=int(eval(input()))\n\nm=10**9+7\n\np=[1 for i in range(10000)]\n\np[0]=0\n\np[1]=0\n\nfor i in range(2,n+1):\n\n  if p[i]==1:\n\n    for j in range(i*i,n+1,i):\n\n        p[j]=0\n\nans=1\n\nfor i in range(2,n+1):\n\n  if p[i]:\n\n    c=0\n\n    k=i\n\n    while n//k>0:\n\n      c=c+(n//k)%m\n\n      k=k*i\n\n    ans=(ans*((c+1)%m))%m\n\nprint((ans%m))\n\n    \n\n    \n\n      \n\n      \n", "score": 1.0, "surface_similarity": 0.6346212506354856}
{"id": "p02690_u116038906", "golden_code": "# 初期入力\n\nimport sys\n\nimport math\n\n#input = sys.stdin.readline\n\nX = int(eval(input()))\n\nlimit =10**5\n\na=0\n\nb=0\n\nfor b in range(-1*limit ,limit):\n\n    a5 =X+pow(b,5)\n\n    if 0 <= a5: \n\n        a=math.pow(a5,0.2)\n\n        a_int =int(a)\n\n        dif =a_int**5 -b**5 -X\n\n        if abs(dif)<10**(-5):\n\n            break\n\n    else:\n\n        continue\n\nprint((a_int,b))", "generated_code": "X = int(eval(input()))\n\ny =120\n\na ={i**5 for i in range(-y,y)}\n\nans_a =0\n\nans_b =0\n\nfor b in range(-y,y):\n\n    if X +b**5 in a:\n\n        #ans_a =int( (X +b**5 +1)**0.2 )\n\n        if X +b**5 >0:\n\n            ans_a =int( (X +b**5 )**0.2 )\n\n        else:\n\n            ans_a = -int( abs(X +b**5 )**0.2 )\n\n        ans_b =b\n\n        break\n\nprint((ans_a,ans_b))\n", "score": 1.0, "surface_similarity": 0.5722222222222222}
{"id": "p02883_u648212584", "golden_code": "import sys\n\ninput = sys.stdin.buffer.readline\n\nimport numpy as np\n\n\n\ndef main():\n\n    N,K = list(map(int,input().split()))\n\n    a = list(map(int,input().split()))\n\n    f = list(map(int,input().split()))\n\n    a.sort()\n\n    f.sort(reverse=True)\n\n\n\n    if sum(a) <= K:\n\n        print((0))\n\n    else:\n\n        a = np.array(a)\n\n        f = np.array(f)\n\n        left,right = 0,max(a)*max(f)\n\n        while right-left > 1:\n\n            mid = (left+right)//2\n\n            pra = a-mid//f\n\n            pra[pra<0] = 0\n\n            if np.sum(pra) > K:\n\n                left = mid\n\n            else:\n\n                right = mid\n\n        print(right)\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "generated_code": "import sys\n\ninput = sys.stdin.buffer.readline\n\n\n\ndef main():\n\n    N,K = list(map(int,input().split()))\n\n    a = list(map(int,input().split()))\n\n    f = list(map(int,input().split()))\n\n    \n\n    a.sort()\n\n    f.sort(reverse=True)\n\n    \n\n    l,r = -1,max(a)*max(f)+1\n\n    \n\n    while r-l>1:\n\n        mid = (r+l)//2\n\n        count = 0\n\n        for cost,dif in zip(a,f):\n\n            if mid >= cost*dif:\n\n                continue\n\n            rest = cost*dif-mid\n\n            count += -(-rest//dif)\n\n        if count <= K:\n\n            r = mid\n\n        else:\n\n            l = mid\n\n            \n\n    print(r)\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "score": 1.0, "surface_similarity": 0.7464285714285714}
{"id": "p02937_u670180528", "golden_code": "from collections import defaultdict\n\nfrom bisect import bisect_left\n\n\n\ns = eval(input())\n\nn = len(s)\n\ns = s + s\n\nt = eval(input())\n\nif set(t) - set(s):\n\n\tprint((-1))\n\n\texit()\n\nd = defaultdict(list)\n\nfor i in range(2 * n):\n\n\td[s[i]] += [i]\n\ncur = tot = 0\n\nfor c in t:\n\n\tx = d[c][bisect_left(d[c], cur)]\n\n\tif x < n:\n\n\t\tcur = x + 1\n\n\telse:\n\n\t\tcur = x - n + 1\n\n\t\ttot += n\n\ntot += cur\n\nprint(tot)\n", "generated_code": "from collections import defaultdict\n\nfrom bisect import bisect_left\n\n\n\n\n\ndef main():\n\n\ts = eval(input())\n\n\tn = len(s)\n\n\ts = s + s\n\n\tt = eval(input())\n\n\tif set(t) - set(s):\n\n\t\tprint((-1))\n\n\t\texit()\n\n\td = defaultdict(list)\n\n\tfor i in range(2 * n):\n\n\t\td[s[i]] += [i]\n\n\tcur = ncnt = 0\n\n\n\n\tfor c in t:\n\n\t\tx = d[c][bisect_left(d[c], cur)]\n\n\t\tif x < n:\n\n\t\t\tcur = x + 1\n\n\t\telse:\n\n\t\t\tcur = x - n + 1\n\n\t\t\tncnt += 1\n\n\tprint((ncnt*n + cur))\n\n\n\n\n\nif __name__ == \"__main__\":\n\n\tmain()", "score": 1.0, "surface_similarity": 0.8815446576640606}
{"id": "p02996_u631277801", "golden_code": "import sys\n\nstdin = sys.stdin\n\n\n\nsys.setrecursionlimit(10 ** 7)\n\n\n\ndef li(): return list(map(int, stdin.readline().split()))\n\ndef li_(): return [int(x) - 1 for x in stdin.readline().split()]\n\ndef lf(): return list(map(float, stdin.readline().split()))\n\ndef ls(): return stdin.readline().split()\n\ndef ns(): return stdin.readline().rstrip()\n\ndef lc(): return list(ns())\n\ndef ni(): return int(stdin.readline())\n\ndef nf(): return float(stdin.readline())\n\n\n\nn = ni()\n\nab = [list(li()) for _ in range(n)]\n\n\n\nab.sort(key=lambda x: x[1])\n\n\n\ncur = 0\n\n\n\nans = True\n\n\n\nfor ai, bi in ab:\n\n    cur += ai\n\n    if cur > bi:\n\n        ans = False\n\n\n\nprint((\"Yes\" if ans else \"No\"))", "generated_code": "import sys\n\nstdin = sys.stdin\n\n\n\nsys.setrecursionlimit(10 ** 7)\n\n\n\ndef li(): return list(map(int, stdin.readline().split()))\n\ndef li_(): return [int(x) - 1 for x in stdin.readline().split()]\n\ndef lf(): return list(map(float, stdin.readline().split()))\n\ndef ls(): return stdin.readline().split()\n\ndef ns(): return stdin.readline().rstrip()\n\ndef lc(): return list(ns())\n\ndef ni(): return int(stdin.readline())\n\ndef nf(): return float(stdin.readline())\n\n\n\nn = ni()\n\nab = [tuple(li()) for _ in range(n)]\n\n\n\nab.sort(key=lambda x: x[1])\n\ncur = 0\n\nok = True\n\n\n\nfor ai, bi in ab:\n\n    cur += ai\n\n    if cur > bi:\n\n        ok = False\n\n        break\n\n\n\nprint((\"Yes\" if ok else \"No\"))\n", "score": 1.0, "surface_similarity": 0.9700116895962594}
{"id": "p03416_u728498511", "golden_code": "n, m = list(map(int, input().split()))\n\nans = 0\n\nfor i in range(n, m+1):\n\n    if str(i)[0]+str(i)[1] == str(i)[-1]+str(i)[-2]: ans += 1\n\nprint(ans)", "generated_code": "a, b = list(map(int, input().split()))\n\nans = 0\n\nfor n in range(a, b+1):\n\n    if str(n) == str(n)[::-1]: ans += 1\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.8457019171304885}
{"id": "p00001_u498511622", "golden_code": "ans=[]\n\nfor i in range (0,10):\n\n    ans.append(int(eval(input())))\n\nans.sort(reverse=True)\n\nfor i in range (0,3):\n\n    print((ans[i]))", "generated_code": "mountain=[]\n\nfor s in range(0,10):\n\n    mountain.append(int(eval(input())))\n\nmountain.sort(reverse=True)\n\nfor s in range(0,3):\n\n print((mountain[s]))", "score": 1.0, "surface_similarity": 0.8959731543624161}
{"id": "p03273_u609061751", "golden_code": "import sys\n\ninput = sys.stdin.readline\n\nH, W = [int(x) for x in input().split()]\n\na = []\n\nfor _ in range(H):\n\n    a.append(list(input().rstrip()))\n\nimport numpy as np\n\na = np.array(a, np.object)\n\na = a.T\n\nretsu = []\n\ngyou = []\n\nfor i in range(W):\n\n    if \"#\" not in a[i]:\n\n        retsu.append(i)\n\na = a.T\n\nfor i in range(H):\n\n    if \"#\" not in a[i]:\n\n        gyou.append(i)\n\na = np.delete(a, retsu, 1)\n\na = np.delete(a, gyou, 0)\n\nfor j in a:\n\n    j = list(j)\n\n    print((\"\".join(j)))", "generated_code": "import sys\n\ninput = sys.stdin.readline\n\n\n\nh, w = [int(x) for x in input().split()]\n\na = []\n\nfor _ in range(h):\n\n    b = list(input().rstrip())\n\n    if '#' in b:\n\n        a.append(b)\n\nh = len(a)\n\nc = [1]*w\n\nfor i in range(w):\n\n    flag = 1\n\n    for j in range(h):\n\n        if a[j][i] == \"#\":\n\n            flag = 0\n\n            break\n\n    if flag:\n\n        c[i] = 0\n\nans = []\n\nfor i in range(h):\n\n    res = []\n\n    for j in range(w):\n\n        if c[j]:\n\n            res.append(a[i][j])\n\n    ans.append(\"\".join(res))\n\nfor i in ans:\n\n    print(i)\n\n\n", "score": 1.0, "surface_similarity": 0.7035492081447965}
{"id": "p02555_u530383736", "golden_code": "# -*- coding: utf-8 -*-\n\nimport sys\n\n\n\n\n\ndef main():\n\n    S = int( sys.stdin.readline() )\n\n\n\n    dp = [0]*(S+1)\n\n    dp[0] = 1\n\n    mod = 10**9 + 7\n\n\n\n    for i in range(3, S+1):\n\n        cnt = 0\n\n\n\n        for j in range(3, i+1):\n\n            cnt += dp[i-j]\n\n            cnt %= mod\n\n        \n\n        dp[i] = cnt\n\n\n\n\n\n    print((dp[-1]))\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "generated_code": "# -*- coding: utf-8 -*-\n\nimport sys\n\n\n\n\n\ndef main():\n\n    S = int( sys.stdin.readline() )\n\n\n\n    dp = [0]*(S+1)\n\n    dp[0] = 1\n\n    mod = 10**9 + 7\n\n\n\n    for i in range(3, S+1):\n\n        dp[i] = dp[i-3] + dp[i-1]\n\n        dp[i] %= mod\n\n    \n\n\n\n    print((dp[-1]))\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "score": 1.0, "surface_similarity": 0.9451697127937337}
{"id": "p03363_u102461423", "golden_code": "from collections import Counter\n\nimport numpy as np\n\n\n\nN = int(eval(input()))\n\nA = np.array(input().split(), dtype = np.int64)\n\n\n\nc = Counter(A.cumsum())\n\nc[0] += 1\n\nanswer = sum(x*(x-1)//2 for x in list(c.values()))\n\nprint(answer)", "generated_code": "import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\nimport itertools\n\nfrom collections import defaultdict\n\n\n\nN,*A = list(map(int,read().split()))\n\n\n\nAcum = [0] + list(itertools.accumulate(A))\n\n\n\ncounter = defaultdict(int)\n\nanswer = 0\n\nfor x in Acum:\n\n    answer += counter[x]\n\n    counter[x] += 1\n\n\n\nprint(answer)", "score": 1.0, "surface_similarity": 0.4975824388357026}
{"id": "p02731_u903005414", "golden_code": "import numpy as np\n\nL = np.array(int(eval(input())), dtype='float128')\n\nans = (L / 3)**3\n\nprint(ans)\n", "generated_code": "import numpy as np\n\nL = int(eval(input()))\n\nans = (L / 3)**3\n\nprint(ans)\n", "score": 1.0, "surface_similarity": 0.7996699669966997}
{"id": "p02785_u678167152", "golden_code": "def solve():\n\n  N, K = list(map(int, input().split()))\n\n  H = list(map(int, input().split()))\n\n  if K>=N:\n\n    return 0\n\n  H.sort()\n\n  ans = sum(H[:N-K])\n\n  return ans\n\nprint((solve()))", "generated_code": "def solve():\n\n  N, K = list(map(int, input().split()))\n\n  H = list(map(int, input().split()))\n\n  H.sort()\n\n  ans = sum(H[:max(N-K,0)])\n\n  return ans\n\nprint((solve()))", "score": 1.0, "surface_similarity": 0.8628378378378379}
{"id": "p03835_u583507988", "golden_code": "k, s = list(map(int, input().split()))\n\n\n\nans = 0\n\nfor x in range(k+1):\n\n  for y in range(k+1):\n\n    if 0<=s-x-y<=k:\n\n      ans += 1\n\n      \n\nprint(ans)", "generated_code": "k,s=list(map(int,input().split()))\n\nans=0\n\nfor i in range(k+1):\n\n  num=s-i\n\n  for j in range(min(num+1,k+1)):\n\n    if 0<=num-j<=k:\n\n      ans+=1\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.9198717948717949}
{"id": "p03680_u528470578", "golden_code": "import sys\n\n\n\nN = int(eval(input()))\n\na = [int(eval(input())) for _ in range(N)]\n\n\n\nl = 1\n\np = a[0] - 1\n\n\n\nif a[0] == 2:\n\n    print(l)\n\n    sys.exit()\n\n\n\nwhile l < int(1e6):\n\n    l += 1\n\n    if a[p] == 2:\n\n        print(l)\n\n        break\n\n    else:\n\n        p = a[p] - 1\n\nelse:\n\n    print((-1))", "generated_code": "import sys\n\n\n\nN = int(eval(input()))\n\na = [int(eval(input())) for _ in range(N)]\n\n\n\nl = 1\n\np = a[0] - 1\n\n\n\nif a[0] == 2:\n\n    print(l)\n\n    sys.exit()\n\n\n\nwhile l < int(2e5):\n\n    l += 1\n\n    if a[p] == 2:\n\n        print(l)\n\n        break\n\n    else:\n\n        p = a[p] - 1\n\nelse:\n\n    print((-1))", "score": 1.0, "surface_similarity": 0.9965986394557823}
{"id": "p02760_u285891772", "golden_code": "import sys, re\n\nfrom collections import deque, defaultdict, Counter\n\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, radians\n\nfrom itertools import accumulate, permutations, combinations, product, groupby\n\nfrom operator import itemgetter, mul\n\nfrom copy import deepcopy\n\nfrom string import ascii_lowercase, ascii_uppercase, digits\n\nfrom bisect import bisect, bisect_left\n\nfrom fractions import gcd\n\nfrom heapq import heappush, heappop\n\nfrom functools import reduce\n\ndef input(): return sys.stdin.readline().strip()\n\ndef INT(): return int(eval(input()))\n\ndef MAP(): return list(map(int, input().split()))\n\ndef LIST(): return list(map(int, input().split()))\n\ndef ZIP(n): return list(zip(*(MAP() for _ in range(n))))\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = float('inf')\n\nmod = 10 ** 9 + 7\n\nimport numpy as np\n\n\n\nA1 = LIST()\n\nA2 = LIST()\n\nA3 = LIST()\n\nN = INT()\n\nB = np.ones(N)\n\nfor i in range(N):\n\n  B[i] = INT()\n\n  \n\nB = list(B)\n\n\n\ndef bingo_array(A, B):\n\n  for i in range(3):\n\n    for x in B:\n\n      if A[i] == x:\n\n        A[i] *= 0\n\n       \n\nbingo_array(A1, B)\n\nbingo_array(A2, B)\n\nbingo_array(A3, B)\n\n\n\nif sum(A1) == 0 or sum(A2) == 0 or sum(A3) == 0:\n\n  print(\"Yes\")\n\nelif A1[0]+A2[0]+A3[0] == 0 or A1[1]+A2[1]+A3[1] == 0 or A1[2]+A2[2]+A3[2] == 0:\n\n  print(\"Yes\")\n\nelif A1[0]+A2[1]+A3[2] == 0 or A1[2]+A2[1]+A3[0] == 0:\n\n  print(\"Yes\")\n\nelse:\n\n  print(\"No\")", "generated_code": "import sys, re\n\nfrom collections import deque, defaultdict, Counter\n\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, radians\n\nfrom itertools import accumulate, permutations, combinations, product\n\nfrom operator import itemgetter, mul\n\nfrom copy import deepcopy\n\nfrom string import ascii_lowercase, ascii_uppercase, digits\n\nfrom bisect import bisect, bisect_left\n\nfrom fractions import gcd\n\nfrom heapq import heappush, heappop\n\nfrom functools import reduce\n\ndef input(): return sys.stdin.readline().strip()\n\ndef INT(): return int(eval(input()))\n\ndef MAP(): return list(map(int, input().split()))\n\ndef LIST(): return list(map(int, input().split()))\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = float('inf')\n\nmod = 10 ** 9 + 7\n\n\n\nA = [LIST() for _ in range(3)]\n\nN = INT()\n\nb = [INT() for _ in range(N)]\n\n\n\ncheck = [[0]*3 for _ in range(3)]\n\n\n\nfor n in b:\n\n  for i in range(3):\n\n    for j in range(3):\n\n      if A[i][j] == n:\n\n        check[i][j] = 1\n\n\n\nfor i in range(3):\n\n  if sum(check[i]) == 3:\n\n    print(\"Yes\")\n\n    exit()\n\n\n\nfor i in range(3):\n\n  if check[0][i] and check[1][i] and check[2][i]:\n\n    print(\"Yes\")\n\n    exit()\n\n    \n\nif check[0][0] and check[1][1] and check[2][2]:\n\n  print(\"Yes\")\n\n  exit()\n\n  \n\nif check[0][2] and check[1][1] and check[2][0]:\n\n  print(\"Yes\")\n\n  exit()\n\n  \n\nprint(\"No\")", "score": 1.0, "surface_similarity": 0.7545189504373178}
{"id": "p03752_u477977638", "golden_code": "import sys\n\ninput = sys.stdin.readline\n\ninput = sys.stdin.buffer.readline\n\n\n\n\n\ndef RD(): return sys.stdin.read()\n\ndef II(): return int(eval(input()))\n\ndef MI(): return list(map(int,input().split()))\n\ndef LI(): return list(map(int,input().split()))\n\ndef TI(): return tuple(map(int,input().split()))\n\n\n\n# mod=10**9+7\n\n# rstrip().decode('utf-8')\n\n\n\nimport numpy as np\n\nfrom itertools import combinations\n\n\n\ndef main():\n\n\tn,k=MI()\n\n\tans=10**18\n\n\n\n\tA=LI()\n\n\tA=[A[0]-1]+A\n\n\tA=np.array(A)\n\n\n\n\tfor t in combinations(list(range(n)),k):\n\n\t\tB=A.copy()\n\n\t\ttmp=0\n\n\t\tfor i in t:\n\n\t\t\ti+=1\n\n\t\t\tB[i]=max(B[:i].max()+1,A[i])\n\n\t\t\ttmp+=B[i]-A[i]\n\n\t\tans=min(ans,tmp)\n\n\tprint(ans)\n\n\n\nif __name__ == \"__main__\":\n\n\tmain()\n", "generated_code": "import sys\n\ninput = sys.stdin.readline\n\ninput = sys.stdin.buffer.readline\n\n\n\n\n\ndef RD(): return sys.stdin.read()\n\ndef II(): return int(eval(input()))\n\ndef MI(): return list(map(int,input().split()))\n\ndef LI(): return list(map(int,input().split()))\n\ndef TI(): return tuple(map(int,input().split()))\n\n\n\n# mod=10**9+7\n\n# rstrip().decode('utf-8')\n\n\n\n#import numpy as np\n\nfrom itertools import combinations\n\n\n\ndef main():\n\n\tn,k=MI()\n\n\tans=10**18\n\n\n\n\tA=LI()\n\n\tA=[A[0]-1]+A\n\n\n\n\tfor t in combinations(list(range(n)),k):\n\n\t\tB=A.copy()\n\n\t\ttmp=0\n\n\t\tfor i in t:\n\n\t\t\ti+=1\n\n\t\t\tB[i]=max(max(B[:i])+1,A[i])\n\n\t\t\ttmp+=B[i]-A[i]\n\n\t\tans=min(ans,tmp)\n\n\tprint(ans)\n\n\n\nif __name__ == \"__main__\":\n\n\tmain()\n", "score": 1.0, "surface_similarity": 0.9720630372492837}
{"id": "p03434_u933622697", "golden_code": "import numpy as np\n\n\n\nn = int(eval(input()))\n\na_list = list(map(int, input().split()))\n\n\n\nalice_point = 0\n\nbob_point = 0\n\nfor i in range(n):\n\n    argmax_a = np.argmax(a_list)\n\n    max_a = np.max(a_list)\n\n    if i % 2 == 0: # If Alice takes a card\n\n        alice_point += max_a\n\n    else: # If Bob takes a card\n\n        bob_point += max_a\n\n    del a_list[argmax_a] # No confidence -> Review how to delete list element!\n\n\n\nprint((alice_point - bob_point))", "generated_code": "n = int(eval(input()))\n\na_list = list(map(int, input().split()))\n\na_list = sorted(a_list, reverse=True)\n\n\n\nalice_point = 0\n\nbob_point = 0\n\nfor i in range(n):\n\n    if i % 2 == 0:\n\n        alice_point += a_list[i]\n\n    else:\n\n        bob_point += a_list[i]\n\n\n\nprint((alice_point - bob_point))", "score": 1.0, "surface_similarity": 0.7741721854304636}
{"id": "p03796_u359358631", "golden_code": "import math\n\n\n\n\n\ndef main():\n\n    N = int(eval(input()))\n\n    power = math.factorial(N)\n\n    print((power % (10 ** 9 + 7)))\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "generated_code": "def main():\n\n    N = int(eval(input()))\n\n    power = 1\n\n    for i in range(1, N + 1):\n\n        power *= i\n\n        power %= 10 ** 9 + 7\n\n    print(power)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "score": 1.0, "surface_similarity": 0.7407773386034255}
{"id": "p02282_u072053884", "golden_code": "def post_from_pre_in(preorder_elements, inorder_elements):\n\n    if preorder_elements:\n\n        global cnt\n\n        root = preorder_elements[0]\n\n        root_index = inorder_elements.index(root)\n\n        preorder_left = preorder_elements[1:root_index+1]\n\n        inorder_left = inorder_elements[:root_index]\n\n        preorder_right = preorder_elements[root_index+1:]\n\n        inorder_right = inorder_elements[root_index+1:]\n\n        post_from_pre_in(preorder_left, inorder_left)\n\n        post_from_pre_in(preorder_right, inorder_right)\n\n        if cnt:\n\n            print(root, end = ' ')\n\n            cnt -= 1\n\n        else:\n\n            print(root)\n\n\n\n\n\ncnt = int(input()) - 1\n\n\n\na = list(map(int, input().split()))\n\nb = list(map(int, input().split()))\n\n\n\npost_from_pre_in(a, b)\n", "generated_code": "postorder_elements = []\n\n\n\ndef post_from_pre_in(preorder_elements, inorder_elements):\n\n    if preorder_elements:\n\n        root = preorder_elements[0]\n\n        root_index = inorder_elements.index(root)\n\n        preorder_left = preorder_elements[1:root_index+1]\n\n        inorder_left = inorder_elements[:root_index]\n\n        preorder_right = preorder_elements[root_index+1:]\n\n        inorder_right = inorder_elements[root_index+1:]\n\n        post_from_pre_in(preorder_left, inorder_left)\n\n        post_from_pre_in(preorder_right, inorder_right)\n\n        postorder_elements.append(root)\n\n\n\n\n\n\n\nn = int(eval(input()))\n\n\n\na = list(map(int, input().split()))\n\nb = list(map(int, input().split()))\n\n\n\npost_from_pre_in(a, b)\n\n\n\nprint((*postorder_elements))", "score": 1.0, "surface_similarity": 0.8070512820512821}
{"id": "p03078_u167751176", "golden_code": "def main():\n\n\tx, y, z, k = list(map(int, input().split()))\n\n\ta = list(map(int, input().split()))\n\n\tb = list(map(int, input().split()))\n\n\tc = list(map(int, input().split()))\n\n\td = [0]*x*y\n\n\tfor i in range(x):\n\n\t\tfor j in range(y):\n\n\t\t\td[i*y+j] = a[i]+b[j]\n\n\td.sort(reverse=True)\n\n\tc.sort(reverse=True)\n\n\n\n\tc_len = min(k, z)\n\n\td_len = min(k, x*y)\n\n\te = [0]*d_len*c_len\n\n\tfor i in range(d_len):\n\n\t\tfor j in range(c_len):\n\n\t\t\te[i*c_len+j] = d[i] + c[j]\n\n\te.sort(reverse=True)\n\n\tfor i in range(k):\n\n\t\tprint((e[i]))\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()", "generated_code": "def main():\n\n\tx, y, z, k = list(map(int, input().split()))\n\n\ta = list(map(int, input().split()))\n\n\tb = list(map(int, input().split()))\n\n\tc = list(map(int, input().split()))\n\n\n\n\tsolve(a, b, c, x, y, z, k)\n\n\n\ndef solve(a, b, c, x, y, z, k):\n\n\ta.sort(reverse=True)\n\n\tb.sort(reverse=True)\n\n\tc.sort(reverse=True)\n\n\tstack = list()\n\n\tfor p in range(x):\n\n\t\tfor q in range(y):\n\n\t\t\tif (p+1)*(q+1) > k:\n\n\t\t\t\tbreak\n\n\t\t\tfor r in range(z):\n\n\t\t\t\tif (p+1)*(q+1)*(r+1) > k:\n\n\t\t\t\t\tbreak\n\n\t\t\t\tstack.append(a[p]+b[q]+c[r])\n\n\tstack.sort(reverse=True)\n\n\tfor i in range(k):\n\n\t\tprint((stack[i]))\n\n\n\nif __name__ == '__main__':\n\n    main()", "score": 1.0, "surface_similarity": 0.7787049818044924}
{"id": "p00713_u260980560", "golden_code": "from math import sqrt\n\nfrom bisect import bisect_left\n\ndef circle_center(x1, y1, x2, y2):\n\n    xd = x2 - x1; yd = y2 - y1\n\n    d = xd**2 + yd**2\n\n    k = sqrt((4.0 - d) / d) / 2.0\n\n    xc = (x1 + x2) / 2.0\n\n    yc = (y1 + y2) / 2.0\n\n    return [[xc - k*yd, yc + k*xd], [xc + k*yd, yc - k*xd]]\n\nwhile 1:\n\n    n = int(input())\n\n    if n==0: break\n\n    p = [list(map(float, input().split())) for i in range(n)]\n\n    p.sort()\n\n    prev = 0\n\n    ans = 1\n\n    for i in range(n):\n\n        bx, by = p[i]\n\n        while bx - p[prev][0] >= 2.0: prev += 1\n\n        for j in range(i+1, n):\n\n            cx, cy = p[j]\n\n            if cx - bx >= 2.0: break\n\n            if (bx - cx)**2 + (by - cy)**2 <= 4.0:\n\n                for ex, ey in circle_center(bx, by, cx, cy):\n\n                    count = 2\n\n                    for k in range(prev, n):\n\n                        if k==i or k==j: continue\n\n                        dx, dy = p[k]\n\n                        if dx - bx >= 2.0: break\n\n                        if (ex - dx)**2 + (ey - dy)**2 <= 1.0:\n\n                            count += 1\n\n                    ans = max(ans, count)\n\n    print(ans)", "generated_code": "from math import sqrt\n\nfrom bisect import bisect_left\n\ndef circle_center(x1, y1, x2, y2):\n\n    xd = x2 - x1; yd = y2 - y1\n\n    d = xd**2 + yd**2\n\n    k = sqrt((4.0 - d) / d) / 2.0\n\n    xc = (x1 + x2) / 2.0; yc = (y1 + y2) / 2.0\n\n    xd *= k; yd *= k\n\n    return [[xc - yd, yc + xd], [xc + yd, yc - xd]]\n\nwhile 1:\n\n    n = int(input())\n\n    if n==0: break\n\n    p = sorted(list(map(float, input().split())) for i in range(n))\n\n    prev = 0\n\n    ans = 1\n\n    for i in range(n):\n\n        bx, by = p[i]\n\n        while bx - p[prev][0] >= 2.0: prev += 1\n\n        for j in range(i+1, n):\n\n            cx, cy = p[j]\n\n            if cx - bx >= 2.0: break\n\n            if (bx - cx)**2 + (by - cy)**2 <= 4.0:\n\n                for ex, ey in circle_center(bx, by, cx, cy):\n\n                    count = 2\n\n                    for k in range(prev, n):\n\n                        if k==i or k==j: continue\n\n                        dx, dy = p[k]\n\n                        if dx - ex >= 1.0: break\n\n                        if (ex - dx)**2 + (ey - dy)**2 <= 1.0:\n\n                            count += 1\n\n                    ans = max(ans, count)\n\n    print(ans)", "score": 1.0, "surface_similarity": 0.9578646748681898}
{"id": "p02690_u849229491", "golden_code": "x = int(eval(input()))\n\nfor i in range(-200,200,1):\n\n    for j in range(-200,200,1):\n\n        if i**5-j**5==x:\n\n          print((i,j))\n\n          exit()", "generated_code": "import sys\n\nx = int(eval(input()))\n\nfor i in range(-159,159,1):\n\n    for j in range(-159,159,1):\n\n        if i**5 - j**5 == x:\n\n            print((str(i)+' '+str(j)))\n\n            sys.exit()", "score": 1.0, "surface_similarity": 0.7784688995215311}
{"id": "p03545_u185249212", "golden_code": "\n\n# import numpy as np\n\n# import numpypy as np\n\nimport sys\n\ninput = sys.stdin.readline\n\n\n\ndef eprint(*args, **kwargs):\n\n    print(*args, file=sys.stderr, **kwargs)\n\n    return\n\n\n\nimport math\n\nimport string\n\nimport fractions\n\nfrom fractions import Fraction\n\nfrom fractions import gcd\n\n\n\ndef lcm(n,m):\n\n    return int(n*m/gcd(n,m))\n\n\n\nimport re\n\nimport array\n\nimport copy\n\nimport functools\n\nimport operator\n\n\n\nimport collections\n\nimport itertools\n\nimport bisect\n\nimport heapq\n\n\n\n\n\nfrom heapq import heappush\n\nfrom heapq import heappop\n\nfrom heapq import heappushpop\n\nfrom heapq import heapify\n\nfrom heapq import heapreplace\n\n\n\nfrom queue import PriorityQueue as pq\n\n\n\ndef reduce(p, q):\n\n    common = fractions.gcd(p, q)\n\n    return (p//common , q//common )\n\n# from itertools import accumulate\n\n# from collections import deque\n\n\n\nimport random\n\n\n\n\n\ndef main():\n\n    # l = list(map(int, input().split()))\n\n    ll=input().strip()\n\n    l=[0 for i in range(4)]\n\n    for i in range(len(l)):\n\n        l[i]=int(ll[i])\n\n    NUM_CASE=3\n\n\n\n    for case in range(2**NUM_CASE):\n\n        # eprint(\"case : \" + str(case))\n\n        sum=l[0]\n\n        \n\n        stack=[]\n\n        S=\"\"\n\n        for index in range(NUM_CASE):\n\n            if (case>>index) & 1 == 1:\n\n                # eprint(\"l[%d] : %d\" % (index+1,l[index+1]) )\n\n                sum+=l[index+1]\n\n                stack.append(\"+\")\n\n            else:\n\n                # eprint(\"l[%d] : %d\" % (index+1,l[index+1]) )\n\n                sum-=l[index+1]\n\n                stack.append(\"-\")\n\n        # eprint(\"sum : \" + str(sum))\n\n        if sum==7:\n\n            for i in range(4):\n\n                S+=str(l[i])\n\n                if i!=3:\n\n                    S+=str(stack[i])\n\n            S+=\"=7\"\n\n            print(S)\n\n            return\n\n    return\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "generated_code": "\n\n# import numpy as np\n\n# import numpypy as np\n\nimport sys\n\ninput = sys.stdin.readline\n\n\n\ndef eprint(*args, **kwargs):\n\n    print(*args, file=sys.stderr, **kwargs)\n\n    return\n\n\n\n# import math\n\n# import string\n\n# import fractions\n\n# from fractions import Fraction\n\n# from fractions import gcd\n\n\n\n# def lcm(n,m):\n\n#     return int(n*m/gcd(n,m))\n\n\n\n# import re\n\n# import array\n\n# import copy\n\n# import functools\n\n# import operator\n\n\n\n# import collections\n\n# import itertools\n\n# import bisect\n\n# import heapq\n\n\n\n\n\n# from heapq import heappush\n\n# from heapq import heappop\n\n# from heapq import heappushpop\n\n# from heapq import heapify\n\n# from heapq import heapreplace\n\n\n\n# from queue import PriorityQueue as pq\n\n\n\n# def reduce(p, q):\n\n#     common = fractions.gcd(p, q)\n\n#     return (p//common , q//common )\n\n# # from itertools import accumulate\n\n# # from collections import deque\n\n\n\n# from operator import mul\n\n# from functools import reduce\n\n\n\n# def combinations_count(n, r):\n\n#     r = min(r, n - r)\n\n#     numer = reduce(mul, range(n, n - r, -1), 1)\n\n#     denom = reduce(mul, range(1, r + 1), 1)\n\n#     return numer // denom\n\n\n\n# import random\n\n\n\n\n\ndef main():\n\n    # a,b,c,d = map(int, input().strip().split())\n\n    l_abcd = list(map(int,input().strip()))\n\n    eprint(\"l_abcd \",end=\": \")\n\n    eprint(l_abcd)\n\n    for case in range(2 ** 3):     # 場合ループ # nは人とかモノとかの個数\n\n        l_op_bin = list(map(int,(format(case,'b').zfill(3))))\n\n        # eprint(\"l_op_bin \",end=\": \")\n\n        # eprint(l_op_bin)\n\n        \n\n        #flag=0\n\n        sum_x=l_abcd[0]\n\n        l_op=[]\n\n        for index_location in range(3):      # 人とかモノとかループ\n\n            if l_op_bin[index_location]==1:                   # その桁がyesだと仮定している場合\n\n               sum_x += l_abcd[1+index_location]\n\n               l_op.append(\"+\")\n\n            else:                                 # その桁がnoだと仮定している場合\n\n               sum_x -= l_abcd[1+index_location]\n\n               l_op.append(\"-\")\n\n        if sum_x==7:\n\n            print(l_abcd[0], end=\"\")\n\n            print(l_op[0],end=\"\")\n\n            print(l_abcd[1], end=\"\")    \n\n            print(l_op[1],end=\"\")\n\n            print(l_abcd[2], end=\"\")    \n\n            print(l_op[2],end=\"\")\n\n            print(l_abcd[3], end=\"=7\\n\")\n\n            return\n\nif __name__ == '__main__':\n\n    main()\n", "score": 1.0, "surface_similarity": 0.7232520270797783}
{"id": "p03371_u057964173", "golden_code": "import sys\n\ndef input(): return sys.stdin.readline().strip()\n\n\n\ndef resolve():\n\n    import math\n\n    a,b,c,x,y=list(map(int, input().split()))\n\n    cmax=max(x,y)*2\n\n    l=[]\n\n    for i in range(cmax+1):\n\n        amai = max(math.ceil(x - 0.5 * i),0)\n\n        bmai = max(math.ceil(y - 0.5 * i),0)\n\n        l.append(amai*a+bmai*b+i*c)\n\n    print((min(l)))\n\nresolve()", "generated_code": "import sys\n\ndef input(): return sys.stdin.readline().strip()\n\n\n\ndef resolve():\n\n    import math\n\n    a,b,c,x,y=list(map(int, input().split()))\n\n    # ABピザを奇数枚買っても1枚無駄になるから、ABピザは2枚を1枚だと考える\n\n    # cの値段を2倍にして枚数を半分に\n\n    cmax=max(x,y) # ABピザの最大枚数(2枚を1枚と考えたとき)\n\n    c=2*c\n\n    l=[]\n\n    for i in range(cmax+1):\n\n        amai = max(x - i,0)\n\n        bmai = max(y - i,0)\n\n        l.append(amai*a+bmai*b+i*c)\n\n    print((min(l)))\n\nresolve()", "score": 1.0, "surface_similarity": 0.9594907407407407}
{"id": "p03074_u286955577", "golden_code": "def solve():\n\n  N, K = list(map(int, input().split()))\n\n  _S = eval(input())\n\n  S = []\n\n  b = _S[0]\n\n  s = 0\n\n  if b == '0': S.append(0)\n\n  for _s in _S:\n\n    if b == _s:\n\n      s = s + 1\n\n    else:\n\n      b = _s\n\n      S.append(s)\n\n      s = 1\n\n  S.append(s)\n\n  if b == '0': S.append(0)\n\n\n\n  num = min(len(S), 2 * K + 1)\n\n  # n = sum(S[0:num if _S[0] == '1' else (num - 1)])\n\n  n = sum(S[0:num])\n\n  m = n\n\n  # for i in range(0 if _S[0] == '1' else -1, len(S) - num, 2):\n\n  for i in range(0, len(S) - num, 2):\n\n    n = n - sum(S[i:i+2])\n\n    n = n + sum(S[i + num:i + num + 2])\n\n    m = max(m, n)\n\n\n\n  return m\n\n\n\nprint((solve()))", "generated_code": "def solve():\n\n  N, K = list(map(int, input().split()))\n\n  s = eval(input())\n\n  S = []\n\n  b = s[0]\n\n  cnt = 0\n\n\n\n  if s[0] == '0': S.append(0)\n\n  for c in s:\n\n    if b == c: cnt = cnt + 1\n\n    else:\n\n      b = c\n\n      S.append(cnt)\n\n      cnt = 1\n\n  S.append(cnt)\n\n  if s[-1] == '0': S.append(0)\n\n\n\n  num = min(len(S), 2 * K + 1)\n\n  part = sum(S[0:num])\n\n  ans = part\n\n\n\n  for i in range(0, len(S) - num, 2):\n\n    part = part - sum(S[i:i+2]) + sum(S[i + num:i + num + 2])\n\n    ans = max(ans, part)\n\n\n\n  return ans\n\n\n\nprint((solve()))\n", "score": 1.0, "surface_similarity": 0.9034391534391535}
{"id": "p03796_u259738923", "golden_code": "import math\n\nN = int(eval(input()))\n\nans = math.factorial(N) % (10 ** 9 + 7)\n\nprint(ans)", "generated_code": "n = int(eval(input()))\n\nfrom functools import reduce\n\nprint((reduce(lambda x,y:x*y%1000000007,list(range(1,n+1)))))", "score": 1.0, "surface_similarity": 0.4478260869565217}
{"id": "p03371_u775681539", "golden_code": "#python3\n\nINF = int(1e9)\n\ndef main():\n\n    a, b, c, x, y = list(map(int, input().split()))\n\n    ans = INF\n\n    for i in range(2*10**5+100):\n\n        t = 2*c*i + max(x-i, 0) * a + max(y-i, 0) * b\n\n        ans = min(ans, t)\n\n    print(ans)\n\nmain()", "generated_code": "INF = int(1e5)+5\n\n\n\ndef main():\n\n    a, b, c, x, y = list(map(int, input().split()))\n\n    ans = INF*INF\n\n    for i in range(INF):\n\n        tmp = 2*i*c + a*max(x-i, 0) + b*max(y-i, 0) \n\n        ans = min(tmp, ans)\n\n    print(ans)\n\nmain()\n", "score": 1.0, "surface_similarity": 0.9007936507936508}
{"id": "p03828_u575431498", "golden_code": "from functools import reduce\n\nN = int(eval(input()))\n\n\n\nprime_table = [1] * (N+1)\n\n\n\nfor x in range(2, N+1):\n\n    for t in range(2, x+1):\n\n        while x % t == 0:\n\n            prime_table[t] += 1\n\n            x //= t\n\nprint((reduce(lambda x, y: x * y % (int(1e9) + 7), prime_table)))", "generated_code": "def prime_factorize(n):\n\n    while n % 2 == 0:\n\n        a[2] += 1\n\n        n //= 2\n\n    f = 3\n\n    while f * f <= n:\n\n        if n % f == 0:\n\n            a[f] += 1\n\n            n //= f\n\n        else:\n\n            f += 2\n\n    if n != 1:\n\n        a[n] += 1\n\n\n\nN = int(eval(input()))\n\na = [0]*(N+1)\n\nfor i in range(2, N+1):\n\n    prime_factorize(i)\n\nans = 1\n\nfor i in a:\n\n    if i > 0:\n\n        ans *= (i+1)\n\nbig = 10**9 + 7\n\nprint((ans % big))", "score": 1.0, "surface_similarity": 0.6321022727272727}
{"id": "p03457_u394853232", "golden_code": "import numpy as np\n\nn = int(eval(input()))\n\nT = []\n\nX = []\n\nY = []\n\nt1 = 0\n\nx1 = 0\n\ny1 = 0\n\nfor i in range(n):\n\n    m = input().split()\n\n    T.append(int(m[0]) - t1)\n\n    t1 = int(m[0])\n\n    X.append(abs(int(m[1]) - x1))\n\n    x1 = int(m[1])\n\n    Y.append(abs(int(m[2]) - y1))\n\n    y1 = int(m[2])\n\nT = np.array(T)\n\nX = np.array(X)\n\nY = np.array(Y)\n\nfor i in range(n):\n\n    if X[i] + Y[i] > T[i] or (X[i] + Y[i] + T[i]) % 2 == 1:\n\n        print('No')\n\n        break\n\nelse:\n\n    print('Yes')", "generated_code": "n = int(eval(input()))\n\nt1 = 0\n\nx1 = 0\n\ny1 = 0\n\nboolean = True\n\n\n\nfor __ in range(n):\n\n    t, x, y = [int(_) for _ in input().split()]\n\n    if boolean:\n\n        temp1 = x\n\n        temp2 = t\n\n        x = abs(x - x1) + abs(y - y1)\n\n        t -= t1\n\n        x1 = temp1\n\n        y1 = y\n\n        t1 = temp2\n\n        if x > t or (x + t) % 2 == 1:\n\n            boolean = False\n\nif boolean:\n\n    print('Yes')\n\nelse:\n\n    print('No')", "score": 1.0, "surface_similarity": 0.5833333333333333}
{"id": "p03835_u925364229", "golden_code": "K,S = list(map(int,input().split(\" \")))\n\nans = 0\n\nfor i in range(K+1):\n\n\tfor j in range(K+1):\n\n\t\tif (S - i - j) <= K and (S-i-j) >= 0:\n\n\t\t\tans += 1\n\n\n\nprint(ans)\n", "generated_code": "K, S = list(map(int,input().split(\" \")))\n\nans = 0\n\nfor X in range(K+1):\n\n    for Y in range(K+1):\n\n        if 0 <= (S - X - Y) <= K:\n\n            ans += 1\n\n\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.8779761904761905}
{"id": "p02412_u140201022", "golden_code": "while 1:\n\n    ans=0\n\n    n,x=list(map(int,input().split()))\n\n    if n:\n\n        for i in range(1,n-1):\n\n            for j in range(i+1,n):\n\n                for k in range(j+1,n+1):\n\n                    if i+j+k==x:ans+=1\n\n    else:break\n\n    print(ans)", "generated_code": "while 1:\n\n    a=0\n\n    n,x=list(map(int,input().split()))\n\n    if n==0:break\n\n    for i in range(1,n-1):\n\n        for j in range(i+1,n):\n\n            c=x-i-j\n\n            if c>j and c<=n:a+=1\n\n    print(a)", "score": 1.0, "surface_similarity": 0.8134920634920635}
{"id": "p02690_u390727364", "golden_code": "x = int(eval(input()))\n\na = 0\n\nb = 0\n\nfor i in range(-200, 200):\n\n    for j in range(-200, 200):\n\n        if i ** 5 - j ** 5 == x:\n\n            a = i\n\n            b = j\n\nprint((a, b))\n", "generated_code": "x = int(eval(input()))\n\na = 0\n\nb = 0\n\nfor i in range(-120, 120):\n\n    for j in range(-120, 120):\n\n        if i ** 5 - j ** 5 == x:\n\n            a = i\n\n            b = j\n\nprint((a, b))\n", "score": 1.0, "surface_similarity": 0.9782608695652174}
{"id": "p02767_u072717685", "golden_code": "def main():\n\n  from statistics import mean\n\n  from math import floor,ceil\n\n\n\n  n = int(eval(input()))\n\n  x = list(map(int, input().split()))\n\n  x_mean = mean(x) \n\n  if x_mean == 0.5:\n\n      greater_than_x = len([i for i in x if i > x_mean])\n\n      if greater_than_x * 2 >= n:\n\n          x_mean = ceil(x_mean)\n\n      else:\n\n          x_mean = floor(x_mean)\n\n  elif x_mean % 1 > 0.5:\n\n      x_mean = ceil(x_mean)\n\n  else:\n\n      x_mean = floor(x_mean)\n\n  x2 = [(num - x_mean)**2 for num in x]\n\n  print((sum(x2)))\n\n\n\nmain()", "generated_code": "import sys\n\nread = sys.stdin.read\n\ndef main():\n\n    n, *x = list(map(int, read().split()))\n\n    r = float('inf')\n\n    for i1 in range(1, 101):\n\n        rt = 0\n\n        for xe in x:\n\n            rt += (xe - i1)**2\n\n        r = min(r, rt)\n\n    print(r)\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 1.0, "surface_similarity": 0.5220533498759306}
{"id": "p03854_u190086340", "golden_code": "import sys\n\nsys.setrecursionlimit(10 ** 6)\n\n\n\n\n\ndef solve():\n\n    S = eval(input())\n\n    # print(S, len(S))\n\n\n\n    words = {0: \"dream\", 1: \"dreamer\", 2: \"erase\", 3: \"eraser\"}\n\n\n\n    TABLE = [[-1 for x in range(len(S) + 1)] for y in range(len(words) + 1)]\n\n\n\n    def recur(i, w):\n\n        if not TABLE[w][i] == -1:\n\n            return TABLE[w][i]\n\n\n\n        if i >= len(S):\n\n            # print(\"jey\", log)\n\n            return True\n\n\n\n        r1, r2, r3, r4 = False, False, False, False\n\n        if S[i:i + 5] == words[0]:\n\n            r1 = recur(i + 5, 0)\n\n        if S[i:i + 7] == words[1]:\n\n            r2 = recur(i + 7, 1)\n\n        if S[i:i + 5] == words[2]:\n\n            r3 = recur(i + 5, 2)\n\n        if S[i:i + 6] == words[3]:\n\n            r4 = recur(i + 6, 3)\n\n\n\n        TABLE[w][i] = r1 or r2 or r3 or r4 or False\n\n\n\n        return TABLE[w][i]\n\n\n\n    ans = recur(0, 0)\n\n\n\n    return ans\n\n\n\n\n\nif __name__ == '__main__':\n\n    res = solve()\n\n    if res:\n\n        print(\"YES\")\n\n    else:\n\n        print(\"NO\")\n", "generated_code": "import sys\n\nsys.setrecursionlimit(10 ** 6)\n\n\n\ndef solve():\n\n    S = eval(input())\n\n    # print(S, len(S))\n\n\n\n    S = S[::-1]\n\n    words = (\"dream\"[::-1], \"dreamer\"[::-1], \"erase\"[::-1], \"eraser\"[::-1])\n\n\n\n    def recur(i):\n\n        if i >= len(S):\n\n            return True\n\n\n\n        for word in words:\n\n            if S[i:i + len(word)] == word:\n\n                if recur(i + len(word)):\n\n                    return True\n\n        return False\n\n\n\n    ans = recur(0)\n\n\n\n    return ans\n\n\n\n\n\nif __name__ == '__main__':\n\n    res = solve()\n\n    if res:\n\n        print(\"YES\")\n\n    else:\n\n        print(\"NO\")\n", "score": 1.0, "surface_similarity": 0.7345285149632976}
{"id": "p03494_u794910686", "golden_code": "import numpy as np\n\n\n\neval(input())\n\nA = np.array(list(map(int, input().split())))\n\n\n\nans = 0\n\nwhile(all(A%2==0)):\n\n    A = A/2\n\n    ans += 1\n\n\n\nprint(ans)\n", "generated_code": "eval(input())\n\nA = list(map(int, input().split()))\n\n\n\nans = 0\n\nwhile all(a%2==0 for a in A):\n\n    A=[a/2 for a in A]\n\n    ans += 1\n\n\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.7421328671328671}
{"id": "p02773_u112317104", "golden_code": "from collections import defaultdict\n\n\n\nN = int(eval(input()))\n\nA = [eval(input()) for _ in range(N)]\n\nA.sort()\n\nd = defaultdict(int)\n\nfor a in A:\n\n    d[a] += 1\n\n\n\nl = sorted(d.items())\n\nmax_v = 0\n\n\n\nfor _, v in l:\n\n    if v > max_v:\n\n        max_v = v\n\n    \n\nfor k, v in l:\n\n    if v == max_v:\n\n        print(k)\n\n    else:\n\n        continue\n", "generated_code": "from collections import defaultdict\n\n\n\ndef solve():\n\n    N = int(eval(input()))\n\n    d = defaultdict(int)\n\n    for _ in range(N):\n\n        a = eval(input())\n\n        d[a] += 1\n\n\n\n    m = 0\n\n    for k, v in list(d.items()):\n\n        m = max(m, v)\n\n    \n\n    l = []\n\n    for k, v in list(d.items()):\n\n        if m == v:\n\n            l.append(k)\n\n    l.sort()\n\n    for ans in l:\n\n        print(ans)\n\n    \n\nsolve()", "score": 1.0, "surface_similarity": 0.6984191508581752}
{"id": "p02921_u657901243", "golden_code": "import numpy as np\n\ns = np.array(list(eval(input())))\n\nt = np.array(list(eval(input())))\n\nprint((len(s[s==t])))\n", "generated_code": "s = eval(input())\n\nt = eval(input())\n\nans = 0\n\nfor i in range(len(s)):\n\n    if s[i] == t[i]:\n\n        ans += 1\n\nprint(ans)\n", "score": 1.0, "surface_similarity": 0.472400513478819}
{"id": "p02691_u038408819", "golden_code": "n = int(eval(input()))\n\na = list(map(int, input().split()))\n\na_index = []\n\nfor i in range(n):\n\n    a_index.append((i, a[i]))\n\ndic1 = {}\n\ndic2 = {}\n\nfor i in range(n):\n\n    one = a_index[i][0] + a_index[i][1]\n\n    two = a_index[i][0] - a_index[i][1]\n\n    if one not in dic1:\n\n        dic1[one] = 1\n\n    else:\n\n        dic1[one] += 1\n\n    if two not in dic2:\n\n        dic2[two] = 1\n\n    else:\n\n        dic2[two] += 1\n\nans = 0\n\nfor i in list(dic1.keys()):\n\n    if i in dic2:\n\n        ans += dic2[i] * dic1[i]\n\nfor i in list(dic2.keys()):\n\n    if i in dic1:\n\n        ans += dic1[i] * dic2[i]\n\n        #print(i)\n\nprint((ans // 2))\n", "generated_code": "n = int(eval(input()))\n\na = list(map(int, input().split()))\n\nimport collections\n\nans = 0\n\ndic = collections.defaultdict(int)\n\nfor i in range(1, n + 1):\n\n    ans += dic[i - a[i - 1]]\n\n    dic[i + a[i - 1]] += 1\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.5574784049224943}
{"id": "p03835_u123756661", "golden_code": "k,s=list(map(int,input().split()))\n\nans=chk=0\n\nfor i in range(k+1):\n\n    for j in range(k+1):\n\n        if (0<=s-i-j<=k): ans+=1\n\nprint(ans)", "generated_code": "k,s=list(map(int,input().split()))\n\nans=0\n\nx=min(k+1,s+1)\n\ny=max(0,s-k-k)\n\nfor i in range(y,x):\n\n    for j in range(y,x):\n\n        if i+j>s: break\n\n        if 0<=s-i-j<=k:\n\n            ans+=1\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.8268472906403941}
{"id": "p03564_u761320129", "golden_code": "N,K = int(eval(input())), int(eval(input()))\n\nnow = 1\n\nfor i in range(N):\n\n    if now*2 < now + K:\n\n        now *= 2\n\n    else:\n\n        now += K\n\nprint(now)\n", "generated_code": "N = int(eval(input()))\n\nK = int(eval(input()))\n\nans = 1\n\nfor i in range(N):\n\n    if ans < K:\n\n        ans *= 2\n\n    else:\n\n        ans += K\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.8588979895755771}
{"id": "p02850_u029000441", "golden_code": "#d3と同一解法\n\nn=int(eval(input()))\n\nimport sys\n\n#再帰関数の再帰回数を変更\n\nsys.setrecursionlimit(10**6)\n\ns=[[] for _ in range(n)]\n\n\n\nfor i in range(n-1):\n\n    a,b=list(map(int,input().split()))\n\n    s[a-1].append((b-1,i))\n\n    s[b-1].append((a-1,i))\n\n\n\nl=[0]*(n-1)\n\n\n\ndef dfs(node,pre_col,par):\n\n    col=1\n\n    for nei,i in s[node]:\n\n        if nei==par:\n\n            continue\n\n        if col==pre_col:\n\n            col+=1\n\n        l[i]=col\n\n        dfs(nei,col,node)\n\n        col+=1\n\ndfs(0,-1,-1)\n\nprint((max(l)))\n\nfor i in l:\n\n    print(i)\n", "generated_code": "import sys\n\nsys.setrecursionlimit(500000)\n\nN = int(eval(input()))\n\nE = [[] for _ in range(N+1)]\n\nfor i in range(N-1):\n\n    a, b = list(map(int, input().split()))\n\n    E[a].append((b, i))\n\n    E[b].append((a, i))\n\nK = max(len(e) for e in E)\n\nprint(K)\n\nAns = [-1] * (N-1)\n\ndef dfs(v=1, p=0, p_col=-1):\n\n    col = 1\n\n    for u, idx in E[v]:\n\n        if u!=p: #木構造の逆向きの矢印を除くための条件\n\n            if col == p_col:\n\n                col += 1\n\n            Ans[idx] = col\n\n            #print(p_col)\n\n            dfs(u, v, col) #u;調べる頂点 v;直前に調べた辺で、調べる頂点と結ばれている頂点　col;直前に調べた辺の色番号\n\n            col += 1 #最深部まで調べたら デフォルトの色=最後に調べた辺の色+1とする\n\n            #最深部に繋がった辺の色+1してやれば、次の辺の色は必ず条件を満たしてくれる\n\n\n\ndfs()\n\nprint((\"\\n\".join(map(str, Ans))))\n", "score": 1.0, "surface_similarity": 0.8182053322721846}
{"id": "p03494_u055875839", "golden_code": "eval(input())\n\n\n\nimport numpy as np\n\nA = np.array(list(map(int, input().split(\" \"))))\n\na = 0\n\n\n\nwhile np.sum(A%2) == 0:\n\n  A = A/2\n\n  a = a + 1\n\n\n\nprint(a)", "generated_code": "eval(input())\n\n\n\nA = list(map(int, input().split(\" \")))\n\nB = 0\n\n\n\nwhile all(a%2 == 0 for a in A):\n\n  A = [a/2 for a in A]\n\n  B += 1\n\n  \n\nprint(B)\n\n    ", "score": 1.0, "surface_similarity": 0.682991202346041}
{"id": "p02881_u177388368", "golden_code": "import math\n\nn=int(eval(input()))\n\nans=n\n\ni=1\n\nwhile(i<=math.sqrt(n)):\n\n    if n%i==0:\n\n        d=i+n/i-2\n\n        ans=min(ans,d)\n\n    i+=1\n\nprint((int(ans)))", "generated_code": "from math import floor\n\nfrom math import sqrt\n\nn=int(eval(input()))\n\nnn=floor(sqrt(n))\n\nrest=n%nn\n\nwhile rest!=0:\n\n    nn-=1\n\n    rest=n%nn\n\nnnn=n/nn\n\nprint((int(nn+nnn-2)))", "score": 1.0, "surface_similarity": 0.5796001926782274}
{"id": "p03796_u275934251", "golden_code": "import math\n\n\n\nN = int(eval(input()))\n\n\n\npower = math.factorial(N)\n\n\n\nprint((power % 1000000007))\n\n\n", "generated_code": "n=int(eval(input()))\n\nans=1\n\nfor i in range(n):\n\n    ans=(ans*(i+1))%(10**9+7)\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.47911764705882354}
{"id": "p03170_u353797797", "golden_code": "n, k = list(map(int, input().split()))\n\na_s = list(map(int, input().split()))\n\ndp = [\"Second\"] * (k + 1)\n\nfor i in range(k + 1):\n\n    if dp[i] == \"Second\":\n\n        for a in a_s:\n\n            ii = i + a\n\n            if ii <= k:\n\n                dp[ii] = \"First\"\n\nprint((dp[-1]))\n", "generated_code": "n, k = list(map(int, input().split()))\n\na_s = list(map(int, input().split()))\n\ndp = [\"Second\"] * (k + 1)\n\nfor i in range(k + 1):\n\n    if dp[i] == \"Second\":\n\n        for a in a_s:\n\n            ii = i + a\n\n            if ii > k:break\n\n            dp[ii] = \"First\"\n\nprint((dp[-1]))\n", "score": 1.0, "surface_similarity": 0.9274551971326165}
{"id": "p02622_u604839890", "golden_code": "S, T = [list(eval(input())) for _ in range(2)]\n\ncnt = 0\n\nfor i in range(len(S)):\n\n    if S[i] != T[i]:\n\n        cnt += 1\n\nprint(cnt)\n", "generated_code": "s, t = [eval(input()) for i in range(2)]\n\nans = 0\n\nfor i in range(len(s)):\n\n  if s[i] != t[i]:\n\n    ans += 1\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.9323308270676691}
{"id": "p02886_u644907318", "golden_code": "N = int(eval(input()))\n\nD = list(map(int,input().split()))\n\ncnt = 0\n\nfor i in range(N-1):\n\n    for j in range(i+1,N):\n\n        cnt += D[i]*D[j]\n\nprint(cnt)", "generated_code": "N = int(eval(input()))\n\nD = list(map(int,input().split()))\n\ncnt = 0\n\nfor i in range(N):\n\n    cnt += D[i]**2\n\ntot = 0\n\nfor i in range(N):\n\n    tot += D[i]\n\ntot = tot**2\n\ntot -= cnt\n\nprint((tot//2))", "score": 1.0, "surface_similarity": 0.783297529538131}
{"id": "p02691_u257162238", "golden_code": "from collections import deque\n\nfrom itertools import product\n\nimport sys\n\nimport math\n\nimport numpy as np\n\nimport bisect\n\n\n\nsys.setrecursionlimit(200000)\n\ninput = sys.stdin.readline\n\n\n\n\n\ndef read():\n\n    N = int(input().strip())\n\n    A = list(map(int, input().strip().split()))\n\n    return N, A\n\n\n\n\n\ndef argsort(seq):\n\n    return sorted(list(range(len(seq))), key=seq.__getitem__)\n\n\n\ndef solve(N, A):\n\n    # x: i-A[i]の列\n\n    X = np.array([i-A[i] for i in range(N)], dtype=np.int)\n\n    # y: i+A[i]の列\n\n    Y = np.array([i+A[i] for i in range(N)], dtype=np.int)\n\n    keys = np.argsort(X)\n\n    X = X[keys]  # x[i] <= x[i+1]\n\n    Y = Y[keys]\n\n    ans = 0\n\n    for y in Y:\n\n        l = bisect.bisect_left(X, y)\n\n        r = bisect.bisect_left(X, y+1)\n\n        ans += r - l\n\n    return ans\n\n\n\n\n\nif __name__ == '__main__':\n\n    inputs = read()\n\n    outputs = solve(*inputs)\n\n    print((\"{}\".format(outputs)))\n", "generated_code": "from collections import defaultdict\n\nfrom itertools import product\n\nimport sys\n\nimport math\n\nimport bisect\n\n\n\nsys.setrecursionlimit(200000)\n\ninput = sys.stdin.readline\n\n\n\n\n\ndef read():\n\n    N = int(input().strip())\n\n    A = list(map(int, input().strip().split()))\n\n    return N, A\n\n\n\n\n\ndef solve(N, A):\n\n    # x: i-A[i]の列\n\n    X = [i-A[i] for i in range(N)]\n\n    # y: i+A[i]の列\n\n    Y = [i+A[i] for i in range(N)]\n\n    z = defaultdict(int)\n\n    for y in Y:\n\n        z[y] += 1\n\n    return sum([z[x] for x in X])\n\n\n\n\n\nif __name__ == '__main__':\n\n    inputs = read()\n\n    outputs = solve(*inputs)\n\n    print((\"{}\".format(outputs)))\n", "score": 1.0, "surface_similarity": 0.8468010454333894}
{"id": "p02899_u094191970", "golden_code": "import numpy as np\n\nn=int(eval(input()))\n\ns=np.argsort(np.array(list(map(int,input().split()))))+1\n\nprint((*s))", "generated_code": "n=int(eval(input()))\n\na=list(map(int,input().split()))\n\nl=sorted([[inx+1,j] for inx,j in enumerate(a)],key=lambda x:x[1])\n\nans=[i for i,j in l]\n\nprint((*ans))", "score": 1.0, "surface_similarity": 0.4240506329113924}
{"id": "p03078_u337765821", "golden_code": "import numpy as np\n\nimport itertools\n\n\n\nX, Y, Z, K = tuple([int(x) for x in str(eval(input())).split(' ')])\n\n\n\nA = np.array(sorted([int(x) for x in str(eval(input())).split(' ')], reverse=True))\n\nB = np.array(sorted([int(x) for x in str(eval(input())).split(' ')], reverse=True))\n\nC = np.array(sorted([int(x) for x in str(eval(input())).split(' ')], reverse=True))\n\n\n\ntmp = {(0, 0, 0) : A[0] + B[0] + C[0]}\n\ntmp_keys = [(0, 0 ,0)]\n\nout = []\n\n\n\nfor i in range(K):\n\n    (a, b, c),  p = max(list(tmp.items()), key=lambda x : x[1])\n\n    out.append(tmp.pop((a, b, c)))\n\n\n\n    keys = []\n\n    if a < X - 1:\n\n        keys.append((a+1, b, c))\n\n    if b < Y - 1:\n\n        keys.append((a, b+1, c))\n\n    if c < Z - 1:\n\n        keys.append((a, b, c+1))\n\n    \n\n    for key in keys:\n\n        if key not in tmp_keys:\n\n            tmp[key] = A[key[0]] + B[key[1]] + C[key[2]]\n\n            tmp_keys.append(key)\n\n\n\nfor x in out:\n\n    print(x)", "generated_code": "import itertools\n\n\n\nX, Y, Z, K = tuple([int(x) for x in str(eval(input())).split(' ')])\n\n\n\nA = sorted([int(x) for x in str(eval(input())).split(' ')], reverse=True)\n\nB = sorted([int(x) for x in str(eval(input())).split(' ')], reverse=True)\n\nC = sorted([int(x) for x in str(eval(input())).split(' ')], reverse=True)\n\n\n\ntmp = {(0, 0, 0) : A[0] + B[0] + C[0]}\n\ntmp_keys = [(0, 0 ,0)]\n\nout = []\n\n\n\nfor i in range(K):\n\n    (a, b, c),  p = max(list(tmp.items()), key=lambda x : x[1])\n\n    out.append(tmp.pop((a, b, c)))\n\n\n\n    keys = []\n\n    if a < X - 1:\n\n        keys.append((a+1, b, c))\n\n    if b < Y - 1:\n\n        keys.append((a, b+1, c))\n\n    if c < Z - 1:\n\n        keys.append((a, b, c+1))\n\n    \n\n    for key in keys:\n\n        if key not in tmp_keys:\n\n            tmp[key] = A[key[0]] + B[key[1]] + C[key[2]]\n\n            tmp_keys.append(key)\n\n\n\nfor x in out:\n\n    print(x)", "score": 1.0, "surface_similarity": 0.9750812567713976}
{"id": "p02792_u609061751", "golden_code": "import sys\n\ninput = sys.stdin.readline\n\nN = int(eval(input()))\n\nketa = len(str(N))\n\nif keta == 1:\n\n    print(N)\n\n    sys.exit()\n\nans = {}\n\nfor i in [1,2,3,4,5,6,7,8,9]:\n\n    for j in [1,2,3,4,5,6,7,8,9]:\n\n        ans[(i, j)] = 0\n\nfor i in range(1, N+1):\n\n    maxdigit = int(str(i)[0])\n\n    mindigit = int(str(i)[-1])\n\n    if mindigit != 0:\n\n        ans[(maxdigit, mindigit)] += 1\n\ncnt = 0\n\nfor i in range(1, 10):\n\n    for j in range(1, 10):\n\n        if i == j:\n\n            cnt += ans[(i, i)] ** 2\n\n        else:\n\n            cnt += ans[(i, j)] * ans[(j, i)] * 2\n\n            ans[(i, j)] = 0\n\n            ans[(j, i)] = 0\n\nprint(cnt)\n\n\n\n        \n\n\n\n    ", "generated_code": "import sys\n\ninput = sys.stdin.readline\n\n\n\nn = int(eval(input()))\n\n\n\nfrom collections import defaultdict\n\n\n\nd = defaultdict(int) # d[(a, b)] : 先頭a, 末尾b\n\n\n\nfor i in range(1, n + 1):\n\n    i_str = str(i)\n\n    d[(i_str[0], i_str[-1])] += 1\n\n\n\nans = 0\n\n\n\nfor i in range(1, 10):\n\n    for j in range(10):\n\n        ans += d[(str(i), str(j))] * d[(str(j), str(i))]\n\n\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.6703511741061985}
{"id": "p02555_u161164709", "golden_code": "from math import factorial\n\n\n\ns = int(eval(input()))\n\nmod = pow(10, 9) + 7\n\n\n\n\n\ndef nCr(n, r):\n\n    return int(factorial(n) // factorial(r) // factorial (n - r) % mod)\n\n\n\nans = 0\n\nseq_len = s // 3\n\n\n\nfor i in range(1, seq_len + 1):\n\n    ans += nCr(s - 3 * i + (i - 1), i - 1)\n\n\n\nprint((ans % mod))", "generated_code": "# 動的計画法による解法\n\n\n\ns = int(eval(input()))\n\nmod = pow(10, 9) + 7\n\n\n\nA = [0] * (s + 1)\n\n\n\nif s >= 3:\n\n    A[3] = 1\n\n\n\nfor i in range(4, s + 1):\n\n    A[i] = (A[i - 3] + A[i - 1]) % mod\n\n\n\nprint((A[s]))", "score": 1.0, "surface_similarity": 0.5176767676767677}
{"id": "p03370_u258073778", "golden_code": "N, X = list(map(int, input().split()))\n\n\n\nmn = [0]*N\n\nfor i in range(N):\n\n  mn[i] = int(eval(input()))\n\n  \n\nans = N\n\nx = X - sum(mn)\n\n\n\nwhile(x >= min(mn)):\n\n  if x // min(mn) == 0:\n\n    mn[mn.index(min(mn))] = 1000000\n\n  else:\n\n    if x >= min(mn):\n\n      x -= min(mn)\n\n      ans += 1\n\n      \n\nprint(ans)", "generated_code": "N, X = list(map(int, input().split()))\n\n\n\nmn = [0]*N\n\nfor i in range(N):\n\n  mn[i] = int(eval(input()))\n\n  \n\nans = N\n\nx = X - sum(mn)\n\n\n\nwhile(x >= min(mn)):\n\n  if x // min(mn) == 0:\n\n    mn[mn.index(min(mn))] = 1000000\n\n  else:\n\n    x -= min(mn)\n\n    ans += 1\n\n      \n\nprint(ans)", "score": 1.0, "surface_similarity": 0.9770491803278689}
{"id": "p03644_u597374218", "golden_code": "import numpy as np\n\nN=int(eval(input()))\n\nprint((2**int(np.log2(N))))", "generated_code": "import math\n\nN=int(eval(input()))\n\nprint((2**int(math.log2(N))))", "score": 1.0, "surface_similarity": 0.9202898550724637}
{"id": "p02596_u961683878", "golden_code": "#! /usr/bin/env python3\n\n\n\nimport sys\n\nint1 = lambda x: int(x) - 1\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\nsys.setrecursionlimit(500000)\n\n\n\n\n\ndef isMultiple(s, m):\n\n    tmp = 0\n\n    for i in range(len(s)):\n\n        tmp = (tmp * 10 + int(s[i])) % m\n\n        if tmp == 0:\n\n            return i\n\n    return -1\n\n\n\n\n\nk = int(readline())\n\nacc = \"7\" * 50000000\n\nif k % 2 == 0:\n\n    ans = -1\n\nelse:\n\n\n\n    ans = isMultiple(acc, k)\n\n    if ans != -1:\n\n        ans += 1\n\n\n\nprint(ans)\n", "generated_code": "#! /usr/bin/env python3\n\n\n\nimport sys\n\nint1 = lambda x: int(x) - 1\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\nsys.setrecursionlimit(500000)\n\n\n\nk = int(readline())\n\n\n\nans = -1\n\nacc = 7 % k\n\nfor n in range(1, k + 10):\n\n    if acc == 0:\n\n        ans = n\n\n        break\n\n    acc = (10 * acc + 7) % k\n\n\n\nprint(ans)\n", "score": 1.0, "surface_similarity": 0.750661832412523}
{"id": "p03253_u297574184", "golden_code": "from math import floor, sqrt\n\nfrom collections import Counter\n\n\n\nMOD = 10 ** 9 + 7\n\n\n\n# xを素因数分解する\n\ndef getPrimeFactor(x):\n\n    ans = []\n\n    for d in range(2, floor(sqrt(x)) + 1):\n\n        while x % d == 0:\n\n            ans.append(d)\n\n            x //= d\n\n\n\n    if x != 1:\n\n        ans.append(x)\n\n\n\n    return ans\n\n\n\n# xのn乗（二分累乗法）\n\ndef power(x, n):\n\n    ans = 1\n\n    while n:\n\n        if n % 2 == 1:\n\n            ans = (ans * x) % MOD\n\n        x = (x * x) % MOD\n\n        n //= 2\n\n    return ans\n\n\n\n\n\nN, M = list(map(int, input().split()))\n\n\n\nPFs = getPrimeFactor(M)\n\ncnt = Counter(PFs)\n\n\n\nN2 = N\n\nif len(cnt):\n\n    N2 += max(cnt.values())\n\n\n\n# facts[x]: xの階乗\n\nfacts = [1] + [0] * N2\n\nfor x in range(1, N2 + 1):\n\n    facts[x] = (facts[x - 1] * x) % MOD\n\n\n\n# invFs[x]: xの階乗の逆元\n\ninvFs = [0] * N2 + [power(facts[N2], MOD - 2)]\n\nfor x in reversed(list(range(N2))):\n\n    invFs[x] = (invFs[x + 1] * (x + 1)) % MOD\n\n\n\ndef comb(n, k):\n\n    return ((facts[n] * invFs[k]) % MOD * invFs[n - k]) % MOD\n\n\n\n\n\nans = 1\n\nfor num in list(cnt.values()):\n\n    ans = (ans * comb(N + num - 1, num)) % MOD\n\nprint(ans)\n", "generated_code": "from math import floor, sqrt\n\nfrom collections import Counter\n\n\n\nMOD = 10 ** 9 + 7\n\n\n\n# xを素因数分解する\n\ndef getPrimeFactor(x):\n\n    ans = []\n\n    for d in range(2, floor(sqrt(x)) + 1):\n\n        while x % d == 0:\n\n            ans.append(d)\n\n            x //= d\n\n    if x != 1:\n\n        ans.append(x)\n\n    return ans\n\n\n\ndef comb(n, k):\n\n    k = min(k, n - k)\n\n    ans = 1\n\n    for i in range(n, n - k, -1):\n\n        ans *= i\n\n    for i in range(1, k + 1):\n\n        ans //= i \n\n    return ans\n\n\n\n\n\nN, M = list(map(int, input().split()))\n\n\n\nPFs = getPrimeFactor(M)\n\ncnt = Counter(PFs)\n\n\n\nans = 1\n\nfor num in list(cnt.values()):\n\n    ans *= comb(N + num - 1, num)\n\nprint((ans % MOD))\n", "score": 1.0, "surface_similarity": 0.7838077827108906}
{"id": "p02690_u810356688", "golden_code": "import sys\n\ndef input(): return sys.stdin.readline().rstrip()\n\ndef main():\n\n    x=int(eval(input()))\n\n    for i in range(-300,300):\n\n        for j in range(-300,300):\n\n            if i**5-j**5==x:\n\n                print((i,j))\n\n                sys.exit()\n\n\n\nif __name__=='__main__':\n\n    main()", "generated_code": "import sys\n\ndef input(): return sys.stdin.readline().rstrip()\n\ndef main():\n\n    x=int(eval(input()))\n\n    for a in range(-118,120):\n\n        for diff in range(238):\n\n            if a**5-(a-diff)**5>10**9:\n\n                break\n\n            if a**5-(a-diff)**5==x:\n\n                print((a,a-diff))\n\n                sys.exit()\n\n\n\nif __name__=='__main__':\n\n    main()", "score": 1.0, "surface_similarity": 0.8797945923286523}
{"id": "p02615_u133936772", "golden_code": "n,*l=list(map(int,open(0).read().split()));print((sum(sorted(l*2)[-2:~n:-1])))", "generated_code": "n,*l=list(map(int,open(0).read().split()))\n\nl.sort(reverse=1)\n\nprint((sum(l[i//2] for i in range(1,n))))", "score": 1.0, "surface_similarity": 0.5854933110367893}
{"id": "p03796_u130900604", "golden_code": "import numpy as np\n\nmod=10**9+7\n\nd=np.zeros(100100,dtype=np.int64)\n\nd[0]=1\n\nfor i in range(1,10**5+1):\n\n  d[i]=d[i-1]*i%mod\n\nprint((d[int(eval(input()))]))", "generated_code": "d,mod=[1]+[0]*100100,10**9+7\n\nfor i in range(1,10**5+1):d[i]=d[i-1]*i%mod\n\nprint((d[int(eval(input()))]))", "score": 1.0, "surface_similarity": 0.6856942496493689}
{"id": "p02881_u727072969", "golden_code": "import math\n\nN = int(eval(input()))\n\nfor i in range(int(math.sqrt(N))):\n\n    if N % (int(math.sqrt(N))-i) == 0:\n\n        print((int(N/(int(math.sqrt(N))-i)+int(math.sqrt(N))-i-2)))\n\n        break", "generated_code": "import math\n\nN = int(eval(input()))\n\nM = int(math.sqrt(N))\n\nfor i in range(M):\n\n    if N % (M-i) == 0:\n\n        print((int(N/(M-i)+M-i-2)))\n\n        break\n", "score": 1.0, "surface_similarity": 0.8282051282051281}
{"id": "p02690_u530383736", "golden_code": "# -*- coding: utf-8 -*-\n\nimport sys\n\n\n\nX = int(input().strip())\n\n#-----\n\n\n\nfor a in range(-118,120):\n\n    for b in range(-118,120):\n\n        if (a**5 - b**5) == X:\n\n            print((a,b))\n\n            sys.exit()\n", "generated_code": "# -*- coding: utf-8 -*-\n\nimport sys\n\n\n\nX = int(input().strip())\n\n#-----\n\ncalc = {}\n\n\n\nfor i in range(-118,120):\n\n    calc[i] = i**5\n\n\n\n\n\nfor a in range(-118,120):\n\n    for b in range(-118,120):\n\n        if (calc[a] - calc[b]) == X:\n\n            print((a,b))\n\n            sys.exit()\n", "score": 1.0, "surface_similarity": 0.836436170212766}
{"id": "p02994_u753589982", "golden_code": "N, L = [int(i) for i in input().split()]\n\n\n\nmin_ = L\n\nmax_ = L + N -1\n\n\n\ndef eat_apple():\n\n    if max_<0:\n\n        return max_ \n\n    if L < 0:\n\n        return 0\n\n    return L\n\n\n\nprint(((min_+max_)*(max_-min_+1)//2 - eat_apple()))", "generated_code": "N, L = [int(i) for i in input().split()]\n\n\n\nmin_ = L\n\nmax_ = L + N -1\n\n\n\ndef eat_apple(N, L, max_):\n\n    if max_<0:\n\n        return max_ \n\n    if L < 0:\n\n        return 0\n\n    return L\n\n\n\nprint(((min_+max_)*(max_-min_+1)//2 - eat_apple(N, L, max_)))", "score": 1.0, "surface_similarity": 0.9470381526104418}
{"id": "p03363_u787562674", "golden_code": "from collections import Counter\n\n\n\nN = int(eval(input()))\n\ninputs = [int(i) for i in input().split()]\n\n\n\nans = 0\n\nruisekiwa = [0] * (N+1)\n\n\n\nfor i in range(N):\n\n    ruisekiwa[i+1] = ruisekiwa[i] + inputs[i]\n\n\n\nruisekiwa = ruisekiwa[1:]\n\nruisekiwa.sort()\n\ncounter_ruiseki = Counter(ruisekiwa)\n\n\n\nfor key, value in list(counter_ruiseki.items()):\n\n    if key == 0 and value == 1:\n\n        ans += value\n\n        continue\n\n    elif key == 0 and value > 1:\n\n        ans += value\n\n    if value > 1:\n\n        ans += sum(list(range(value)))\n\n\n\nprint(ans)\n", "generated_code": "from collections import Counter\n\nfrom itertools import accumulate\n\n\n\nN = int(eval(input()))\n\ninputs = [int(i) for i in input().split()]\n\n\n\nans = 0\n\n\n\nruisekiwa = list(accumulate(inputs))\n\nruisekiwa.sort()\n\ncounter_ruiseki = Counter(ruisekiwa)\n\n\n\nfor key, value in list(counter_ruiseki.items()):\n\n    if key == 0 and value == 1:\n\n        ans += value\n\n        continue\n\n    elif key == 0 and value > 1:\n\n        ans += value\n\n    if value > 1:\n\n        ans += sum(list(range(value)))\n\n\n\nprint(ans)\n", "score": 1.0, "surface_similarity": 0.802930402930403}
{"id": "p03457_u868701750", "golden_code": "import sys\n\n_input = sys.stdin.readline\n\n\n\n\n\ndef resolve():\n\n    N = int(_input())\n\n    T = [list(map(int, _input().split())) for _ in range(N)]\n\n    t, x, y = 0, 0, 0\n\n    for next_t, next_x, next_y in T:\n\n        diff_xy = abs(x - next_x) + abs(y - next_y)\n\n        diff_t = next_t - t\n\n        if diff_xy > diff_t or (diff_xy % 2 != diff_t % 2):\n\n            print('No')\n\n            exit(0)\n\n    print('Yes')\n\n\n\n\n\nif __name__ == '__main__':\n\n    resolve()", "generated_code": "import sys\n\n_input = sys.stdin.readline\n\n\n\n\n\ndef resolve():\n\n    N = int(_input())\n\n    t, x, y = 0, 0, 0\n\n    for _ in range(N):\n\n        next_t, next_x, next_y = list(map(int, _input().split()))\n\n        diff_xy = abs(x - next_x) + abs(y - next_y)\n\n        diff_t = next_t - t\n\n        if diff_xy > diff_t or (diff_xy % 2 != diff_t % 2):\n\n            print('No')\n\n            exit(0)\n\n    print('Yes')\n\n\n\n\n\nif __name__ == '__main__':\n\n    resolve()", "score": 1.0, "surface_similarity": 0.883675692499222}
{"id": "p03107_u280978334", "golden_code": "S = [int(_) for _ in eval(input())]\n\nlength = len(S)\n\ntemp = [S[0]]\n\nfor x in S[1:]:\n\n    if(len(temp) == 0):\n\n        temp.append(x)\n\n    elif( temp[-1] == x):\n\n        temp.append(x)\n\n    else:\n\n        temp.pop(-1)\n\nprint((length-len(temp)))\n\n        ", "generated_code": "def main():\n\n    A = eval(input())\n\n    print((2*min(A.count(\"0\"),A.count(\"1\"))))\n\n    \n\nif __name__ == \"__main__\":\n\n    main()", "score": 1.0, "surface_similarity": 0.4744094488188976}
{"id": "p02596_u423966555", "golden_code": "K = int(eval(input()))\n\n\n\nflg = [False]*K\n\n\n\ntmp = 7 % K\n\ncnt = 1\n\nif tmp == 0:\n\n    print(cnt)\n\n    exit()\n\nwhile True:\n\n    tmp = (tmp*10+7)%K\n\n    if flg[tmp]:\n\n        print((-1))\n\n        break\n\n    else:\n\n        cnt += 1\n\n        if tmp == 0:\n\n            print(cnt)\n\n            break\n\n        flg[tmp] = True\n", "generated_code": "K = int(eval(input()))\n\nt = 7\n\nt %= K\n\n\n\nfor i in range(K+1):\n\n    if t == 0:\n\n        print((i+1))\n\n        exit()\n\n    t = (t*10+7)%K\n\nprint((-1))\n", "score": 1.0, "surface_similarity": 0.684748427672956}
{"id": "p03796_u239981649", "golden_code": "from math import factorial\n\nprint((factorial(int(eval(input()))) % (10**9+7)))", "generated_code": "ans = 1\n\nfor k in range(1, int(eval(input()))+1):\n\n    ans = ans*k % (10**9+7)\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.49583333333333335}
{"id": "p03822_u761320129", "golden_code": "import sys\n\nsys.setrecursionlimit(202020)\n\n\n\nN = int(eval(input()))\n\nwon = [[] for i in range(N)]\n\nfor i in range(1,N):\n\n    a = int(eval(input())) - 1\n\n    won[a].append(i)\n\n\n\ndef height(v):\n\n    if not won[v]: return 0\n\n    hs = [height(op) for op in won[v]]\n\n    ret = 0\n\n    for i,h in enumerate(sorted(hs)):\n\n        ret = max(ret, h + len(hs) - i)\n\n    return ret\n\n\n\nprint((height(0)))", "generated_code": "import sys\n\nsys.setrecursionlimit(10**8)\n\nN = int(eval(input()))\n\nA = [int(eval(input()))-1 for i in range(N-1)]\n\nwins = [[] for _ in range(N)]\n\n\n\nfor i,a in enumerate(A):\n\n    wins[a].append(i+1)\n\n\n\ndepth = [-1] * N\n\ndef dep(v):\n\n    if len(wins[v])==0: return 0\n\n    if depth[v] >= 0:\n\n        return depth[v]\n\n    ds = []\n\n    for w in wins[v]:\n\n        ds.append(dep(w))\n\n    ds.sort(reverse=True)\n\n    ret = 0\n\n    for i,d in enumerate(ds):\n\n        ret = max(ret, i+d+1)\n\n    depth[v] = ret\n\n    return ret\n\nprint((dep(0)))", "score": 1.0, "surface_similarity": 0.6995139076424521}
{"id": "p02595_u263737105", "golden_code": "N, D = list(map(int, input().split()))\n\ncount = 0\n\nfor i in range(N):\n\n    a, b = list(map(int, input().split()))\n\n    if (a**2 + b**2) <= D**2:\n\n        count += 1\n\nprint(count)\n", "generated_code": "N, D = list(map(int, input().split()))\n\ncount = 0\n\nfor i in range(N):\n\n    a, b = list(map(int, input().split()))\n\n    if (a*a + b*b) <= D*D:\n\n        count += 1\n\nprint(count)\n", "score": 1.0, "surface_similarity": 0.9306086445163188}
{"id": "p03309_u077291787", "golden_code": "# ABC102C - Linear Approximation (ARC100C)\n\nfrom statistics import median\n\n\n\n\n\ndef main():\n\n    n = int(eval(input()))\n\n    A = tuple(map(int, input().rstrip().split()))\n\n    A = tuple(j - i for i, j in enumerate(A, start=1))\n\n    b = median(A)\n\n    ans = sum(abs(a - b) for a in A)\n\n    print((int(ans)))\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()", "generated_code": "# ABC102C - Linear Approximation (ARC100C)\n\ndef main():\n\n    n = int(eval(input()))\n\n    A = tuple(map(int, input().rstrip().split()))\n\n    A = sorted(j - i for i, j in enumerate(A, start=1))\n\n    b = A[n // 2]\n\n    ans = sum(abs(a - b) for a in A)\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()", "score": 1.0, "surface_similarity": 0.8312320916905445}
{"id": "p01105_u260980560", "golden_code": "a=65280; b=61680; c=52428; d=43690; e=65535\n\nL = {el: 1 for el in [a, b, c, d, e, 0]}\n\nfor i in range(6):\n\n    R = sorted(L.items(), key=lambda x: x[1])\n\n    for p, l in R:\n\n        if l < 16:\n\n            L[p ^ e] = min(L.get(p ^ e, 16), l+1)\n\n            if l+3 < 16:\n\n                for q, r in R:\n\n                    if l+r+3 <= 16:\n\n                        L[p & q] = min(L.get(p & q, 16), l+r+3)\n\n                        L[p ^ q] = min(L.get(p ^ q, 16), l+r+3)\n\n                    else: break\n\n        else: break\n\nprint(*(L[e & eval(s)] for s in open(0).read().replace(*\"-~\").replace(*\"*&\").replace(*\"1e\").split()[:-1]),sep='\\n')\n", "generated_code": "a=65280; b=61680; c=52428; d=43690; e=65535\n\nfrom heapq import heappush, heappop\n\nbase = [a, b, c, d, e, 0]\n\nQ = [(1, el) for el in base]\n\nL = {el: 1 for el in base}\n\nH = []\n\nwhile Q:\n\n    l, p = heappop(Q)\n\n    if L[p] < l: continue\n\n    if l+1 < L.get(p ^ e, 17):\n\n        L[p^e] = l+1\n\n        if l+1 < 16: heappush(Q, (l+1, p^e))\n\n    if l+3 < 16:\n\n        for q, r in H:\n\n            if l+r+3 <= 16:\n\n                if l+r+3 < L.get(p & q, 17):\n\n                    L[p & q] = l+r+3\n\n                    if l+r+3 < 16: heappush(Q, (l+r+3, p & q))\n\n                if l+r+3 < L.get(p ^ q, 17):\n\n                    L[p ^ q] = l+r+3\n\n                    if l+r+3 < 16: heappush(Q, (l+r+3, p ^ q))\n\n            else: break\n\n    if l < 7: H.append((p, l))\n\nprint(*(L[e & eval(s)] for s in open(0).read().replace(*\"-~\").replace(*\"*&\").replace(*\"1e\").split()[:-1]),sep='\\n')\n", "score": 1.0, "surface_similarity": 0.7448644688644688}
{"id": "p02792_u775681539", "golden_code": "#python3\n\nfrom collections import defaultdict\n\nfrom collections import namedtuple\n\n\n\nP = namedtuple('P', ['front', 'end'])\n\n\n\ndef f(x):\n\n    return P(str(x)[0], str(x)[-1]) \n\n\n\ndef main():\n\n\n\n    n = int(eval(input()))\n\n    freq = defaultdict(int)\n\n\n\n    for i in range(1, n+1):\n\n        p = f(i)\n\n        freq[p]+=1\n\n\n\n\n\n    ans = 0\n\n    for i in range(1, n + 1):\n\n        p = f(i)\n\n        q = (p.end, p.front)\n\n        ans += freq[q]\n\n\n\n    print(ans)\n\n\n\nmain()", "generated_code": "import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\nfrom collections import defaultdict\n\n\n\ndef f(x):\n\n    return (int(str(x)[0]), int(str(x)[-1])) \n\ndef main():\n\n    N = int(readline())\n\n    df = defaultdict(int)\n\n    for i in range(1, N+1):\n\n        df[f(i)] += 1\n\n    ans = 0\n\n    for i in range(1, 10):\n\n        for j in range(1, 10):\n\n            ans +=  df[(i, j)]*df[(j, i)]\n\n    print(ans)\n\nif __name__ == '__main__':\n\n    main()\n", "score": 1.0, "surface_similarity": 0.6899408284023669}
{"id": "p03038_u893063840", "golden_code": "n, m = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\nbc = [list(map(int, input().split())) for _ in range(m)]\n\n\n\nbc.sort(key=lambda x: x[1], reverse=True)\n\na.sort()\n\n\n\ni = 0\n\nfor b, c in bc:\n\n    for _ in range(b):\n\n        if i < n and a[i] < c:\n\n            a[i] = c\n\n            i += 1\n\n        else:\n\n            break\n\n\n\nans = sum(a)\n\nprint(ans)\n", "generated_code": "n, m = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\nbc = [list(map(int, input().split())) for _ in range(m)]\n\n\n\nbc.sort(reverse=True, key=lambda x: x[1])\n\n\n\nli = []\n\nl = 0\n\ni = 0\n\nwhile i < m and l < n:\n\n    b, c = bc[i]\n\n    li += [c] * b\n\n    i += 1\n\n    l += b\n\n\n\na += li\n\na.sort(reverse=True)\n\nans = sum(a[:n])\n\nprint(ans)\n", "score": 1.0, "surface_similarity": 0.747}
{"id": "p02837_u475584892", "golden_code": "import itertools\n\nimport numpy as np\n\n\n\nN = int(eval(input()))\n\nstl = []\n\nfor i in range(N):\n\n    a = int(eval(input()))\n\n    for _ in range(a):\n\n        x, y = list(map(int, input().split()))\n\n        stl.append((i, x-1, y))\n\ndl = np.array(list(itertools.product([0, 1], repeat=N)), np.bool)\n\nfor i, x, y in stl:\n\n    bl = (dl[:, i] == False) | (dl[:, x] == bool(y))\n\n    dl = dl[bl]\n\nres = dl.sum(axis=1).max()\n\nprint(res)\n", "generated_code": "import sys\n\nimport itertools\n\nimport collections\n\n\n\n\n\ndef solve():\n\n    readline = sys.stdin.buffer.readline\n\n    mod = 10 ** 9 + 7\n\n    n = int(readline())\n\n    xy = []\n\n    for i in range(n):\n\n        a = int(readline())\n\n        for j in range(a):\n\n            x, y = list(map(int, readline().split()))\n\n            xy.append([i, x-1, y])\n\n    ls = collections.deque([v for v in itertools.product([True, False], repeat=n)])\n\n    for i, x, y in xy:\n\n        for j in range(len(ls)):\n\n            lsv = ls.pop()\n\n            if not lsv[i] or lsv[x] == bool(y):\n\n                ls.appendleft(lsv)\n\n    t = 0\n\n    for i in range(len(ls)):\n\n        t = max(t, ls[i].count(True))\n\n    print(t)\n\n\n\n\n\nif __name__ == '__main__':\n\n    solve()\n", "score": 1.0, "surface_similarity": 0.6039348710990502}
{"id": "p02901_u297574184", "golden_code": "INF = 10**10\n\n\n\nN, M = list(map(int, input().split()))\n\ncosts = []\n\nkeys = []\n\nfor _ in range(M):\n\n    A, B = list(map(int, input().split()))\n\n    cs = list(map(int, input().split()))\n\n    costs.append(A)\n\n    # 鍵を2進数化する\n\n    key = 0\n\n    for c in cs:\n\n        key |= 1<<(c-1)\n\n    keys.append(key)\n\n\n\n# [1]の個数で分類する\n\nmaskss = [[] for _ in range(N+1)]\n\nnum1s = [0] * (2**N)\n\nfor S in range(2**N):\n\n    num = bin(S).count('1')\n\n    maskss[num].append(S)\n\n    num1s[S] = num\n\n\n\ndpAll = [INF] * (2**N)\n\nfor S in range(2**N):\n\n    for cost, key in zip(costs, keys):\n\n        if S & key == S:\n\n            if cost < dpAll[S]:\n\n                dpAll[S] = cost\n\n\n\ndp = [INF] * (2**N)\n\nfor S in range(2**N):\n\n    cost = dpAll[S]\n\n    num1 = num1s[S]\n\n    for k in range(1, (num1+1)//2+1):\n\n        for mask in maskss[k]:\n\n            if mask & S == mask:\n\n                m2 = S^mask\n\n                c2 = dp[mask] + dp[m2]\n\n                if c2 < cost:\n\n                    cost = c2\n\n    dp[S] = cost\n\n\n\nif dp[2**N-1] == INF:\n\n    print((-1))\n\nelse:\n\n    print((dp[2**N-1]))\n", "generated_code": "import sys\n\ninput = sys.stdin.readline\n\n\n\ndef solve():\n\n    INF = 10**10\n\n\n\n    N, M = list(map(int, input().split()))\n\n    keys = []\n\n    costs = []\n\n    for _ in range(M):\n\n        a, b = list(map(int, input().split()))\n\n        costs.append(a)\n\n        cs = list(map(int, input().split()))\n\n        key = 0\n\n        for c in cs:\n\n            key |= 1<<(c-1)\n\n        keys.append(key)\n\n\n\n    dp = [INF] * (1<<N)\n\n    dp[0] = 0\n\n    for S in range(1<<N):\n\n        for key, cost in zip(keys, costs):\n\n            S2 = S | key\n\n            c2 = dp[S] + cost\n\n            if c2 < dp[S2]:\n\n                dp[S2] = c2\n\n\n\n    if dp[-1] == INF:\n\n        print((-1))\n\n    else:\n\n        print((dp[-1]))\n\n\n\n\n\nsolve()\n", "score": 1.0, "surface_similarity": 0.6721108386215964}
{"id": "p03575_u703950586", "golden_code": "import sys,queue,math,numpy as np,scipy as sc\n\nsys.setrecursionlimit(10**7)\n\ninput = sys.stdin.readline\n\nINF = 10**18\n\nMOD = 10**9 + 7\n\nLI = lambda : [int(x) for x in input().split()]\n\nN,M = LI()\n\nE = [LI() for _ in range(M)]\n\nans = 0\n\nfor i in range(M):\n\n    g = np.array([i for i in range(N+1)])\n\n\n\n    def root(x):\n\n        if g[x] != x:\n\n            g[x] = root(g[x])\n\n        return g[x]\n\n\n\n    for j in range(M):\n\n        if i != j: g[root(E[j][0])] = root(E[j][1])\n\n\n\n    ans += (root(E[i][0]) != root(E[i][1]))\n\n\n\nprint (ans)", "generated_code": "import sys,queue,math,numpy as np,scipy as sc\n\nsys.setrecursionlimit(10**7)\n\ninput = sys.stdin.readline\n\nINF = 10**18\n\nMOD = 10**9 + 7\n\nLI = lambda : [int(x) for x in input().split()]\n\nN,M = LI()\n\nE = [LI() for _ in range(M)]\n\nans = 0\n\nfor i in range(M):\n\n    g = [i for i in range(N+1)]\n\n\n\n    def root(x):\n\n        if g[x] != x:\n\n            g[x] = root(g[x])\n\n        return g[x]\n\n\n\n    for j in range(M):\n\n        if i != j: g[root(E[j][0])] = root(E[j][1])\n\n\n\n    ans += (root(E[i][0]) != root(E[i][1]))\n\n\n\nprint (ans)", "score": 1.0, "surface_similarity": 0.9906191369606003}
{"id": "p01138_u078042885", "golden_code": "def f(s):\n\n    s=list(map(int,s.split(':')))\n\n    return (s[0]*60+s[1])*60+s[2]\n\na=86401\n\nwhile 1:\n\n    t=[0]*a\n\n    n=int(eval(input()))\n\n    if n==0:break\n\n    for _ in range(n):\n\n        b,c=input().split()\n\n        t[f(b)]+=1;t[f(c)]-=1\n\n    d=0\n\n    for i in range(1,a):\n\n        t[i]+=t[i-1]\n\n        d=max(d,t[i])\n\n    print(d)", "generated_code": "def f(s):\n\n    return (s[0]*60+s[1])*60+s[2]\n\na=86400\n\nwhile 1:\n\n    t=[0]*a\n\n    n=int(eval(input()))\n\n    if n==0:break\n\n    for _ in range(n):\n\n        b,c = [list(map(int,x.split(':'))) for x in input().split()]\n\n        t[f(b)]+=1;t[f(c)]-=1\n\n    d=0\n\n    for i in range(1,a):\n\n        t[i]+=t[i-1]\n\n        if d<t[i]:d=t[i]\n\n    print(d)", "score": 1.0, "surface_similarity": 0.8408257312141446}
{"id": "p03436_u562935282", "golden_code": "from collections import deque\n\n\n\nINF = float('inf')\n\n\n\ndr = (-1, 0, 0, 1)\n\ndc = (0, -1, 1, 0)\n\n\n\nH, W = list(map(int, input().split()))\n\n\n\ns = []\n\ntotal_white_count = 0\n\nfor _ in range(H):\n\n    t = eval(input())\n\n    s.append(t)\n\n    total_white_count += t.count('.')\n\np = [[INF for _ in range(W)] for _ in range(H)]\n\n\n\nans = -1\n\n\n\ndq = deque()\n\ndq.append((0, 0, 1))\n\nwhile dq:\n\n    r, c, d = dq.popleft() # 直した\n\n\n\n    nd = d + 1\n\n    for i in range(4):\n\n        nr = r + dr[i]\n\n        nc = c + dc[i]\n\n        if not (0 <= nr < H and 0 <= nc < W): continue\n\n        if s[nr][nc] == '#' : continue\n\n        if p[nr][nc] <= nd: continue\n\n        p[nr][nc] = nd\n\n        if nr == H - 1 and nc == W - 1:\n\n            ans = total_white_count - nd\n\n            break\n\n        dq.append((nr, nc, nd))\n\n    else:\n\n        continue\n\n    break\n\n\n\nprint(ans)\n", "generated_code": "def main():\n\n    from collections import deque\n\n    import sys\n\n\n\n    input = sys.stdin.readline\n\n\n\n    h, w = list(map(int, input().split()))\n\n    s = [eval(input()) for _ in range(h)]\n\n\n\n    bk = 0\n\n    for row in s:\n\n        bk += row.count('#')\n\n\n\n    def coods(r, c):\n\n        if r > 0: yield r - 1, c\n\n        if r < h - 1: yield r + 1, c\n\n        if c > 0: yield r, c - 1\n\n        if c < w - 1: yield r, c + 1\n\n\n\n    q = deque()\n\n    q.append((0, 0))\n\n    count = [[-1] * w for _ in range(h)]\n\n    count[0][0] = 1\n\n    while q:\n\n        r, c = q.popleft()\n\n        k = count[r][c]\n\n        for nr, nc in coods(r, c):\n\n            nchar = s[nr][nc]\n\n            if nchar == '#': continue\n\n            if count[nr][nc] != -1: continue\n\n            count[nr][nc] = k + 1\n\n            if (nr, nc) == (h - 1, w - 1):\n\n                print((h * w - (k + 1) - bk))\n\n                return\n\n            q.append((nr, nc))\n\n    print((-1))\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 1.0, "surface_similarity": 0.6430454083048183}
{"id": "p03796_u189326411", "golden_code": "import math\n\nn = int(eval(input()))\n\nprint((math.factorial(n)%(10**9+7)))\n", "generated_code": "n = int(eval(input()))\n\nmod = 10**9 + 7\n\n\n\npow = 1\n\nfor i in range(n):\n\n    pow = pow*(i+1)%mod\n\n\n\nprint(pow)\n", "score": 1.0, "surface_similarity": 0.5711229946524065}
{"id": "p02982_u579699847", "golden_code": "import numpy\n\nN, D = list(map(int, input().split()))\n\nlistx = []\n\ncount = 0\n\nfor i in range(N):\n\n    x = list(map(int, input().split()))\n\n    listx.append(x)\n\n\n\nfor j in range(0, N):\n\n    for k in range(j+1,N):\n\n        a = numpy.array(listx[j])\n\n        b = numpy.array(listx[k])\n\n        u = b - a\n\n        c = float(numpy.linalg.norm(u))\n\n        if c.is_integer() :\n\n            count += 1\n\nprint(count)", "generated_code": "def LI(): return list(map(int,input().split()))\n\nN,D = LI()\n\nX = [LI() for _ in range(N)]\n\nans = 0\n\nfor i in range(N):\n\n    for j in range(i+1,N):\n\n        temp = 0\n\n        for k in range(D):\n\n            temp += (X[j][k]-X[i][k])**2\n\n        if temp **0.5%1==0:\n\n            ans += 1\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.5813267813267813}
{"id": "p02690_u362599643", "golden_code": "X=int(eval(input()))\n\nfor i in range(-200,201):\n\n    for j in range(-200,201):\n\n        if i**5-j**5==X:\n\n            print((i,j))\n\n            exit()", "generated_code": "X=int(eval(input()))\n\nfor i in range(-150,151):\n\n    for j in range(-150,151):\n\n        if i**5-j**5==X:\n\n            print((i,j))\n\n            exit()", "score": 1.0, "surface_similarity": 0.9733333333333334}
{"id": "p03107_u982591663", "golden_code": "S = list(eval(input()))\n\nnum_one = S.count(\"1\")\n\nnum_zero = S.count(\"0\")\n\nans = min(num_one, num_zero) *2\n\nprint(ans)\n", "generated_code": "S = eval(input())\n\n\n\nans = min(S.count(\"0\"), S.count(\"1\")) * 2\n\nprint(ans)\n", "score": 1.0, "surface_similarity": 0.788135593220339}
{"id": "p03457_u624475441", "golden_code": "import sys\n\ncan = True; eval(input())\n\ne = [[0, 0, 0]] + [list(map(int, e.split())) for e in sys.stdin]\n\nfor a, b in zip(e[1:], e):\n\n    t = a[0] - b[0] - abs(a[1] - b[1]) - abs(a[2] - b[2])\n\n    if t < 0 or t % 2 == 1: can = False; break\n\nprint((['No', 'Yes'][can]))", "generated_code": "import sys\n\nans = 'Yes'; eval(input())\n\nfor e in sys.stdin:\n\n    t, x, y = list(map(int, e.split()))\n\n    t = t - x - y\n\n    if t < 0 or t % 2 == 1: ans = 'No'; break\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.6473782771535581}
{"id": "p02901_u936985471", "golden_code": "import sys\n\nreadline = sys.stdin.readline\n\n\n\nN,M = list(map(int,readline().split()))\n\nINF = 10 ** 10\n\ndp = [INF] * (2 ** N)\n\ndp[0] = 0\n\n\n\nfor i in range(M):\n\n  a,b = list(map(int,readline().split()))\n\n  c = list(map(int,readline().split()))\n\n  key = 0\n\n  for j in range(len(c)):\n\n    key += (1 << (c[j] - 1))\n\n  for j in range(len(dp)):\n\n    if dp[j] == INF:\n\n      continue\n\n    if j | key == j:\n\n      continue\n\n    dp[j | key] = min(dp[j | key], dp[j] + a)\n\n\n\nif dp[-1] == INF:\n\n  print((-1))\n\nelse:\n\n  print((dp[-1]))", "generated_code": "import sys\n\nreadline = sys.stdin.readline\n\n\n\nN,M = list(map(int,readline().split()))\n\nINF = 10 ** 10\n\ndp = [INF] * (2 ** N)\n\ndp[0] = 0\n\n\n\nfor i in range(M):\n\n  a,b = list(map(int,readline().split()))\n\n  c = list(map(int,readline().split()))\n\n  key = 0\n\n  for j in range(len(c)):\n\n    key += (1 << (c[j] - 1))\n\n  for j in range(len(dp)):\n\n    if dp[j] == INF:\n\n      continue\n\n    if j | key == j:\n\n      continue\n\n    if dp[j | key] > dp[j] + a:\n\n      dp[j | key] = dp[j] + a\n\n\n\nif dp[-1] == INF:\n\n  print((-1))\n\nelse:\n\n  print((dp[-1]))", "score": 1.0, "surface_similarity": 0.9708598153255786}
{"id": "p02721_u837673618", "golden_code": "N, K, C = list(map(int, input().split()))\n\nS = eval(input())\n\n\n\nlatest = [None]*K\n\ni = len(S)+C\n\nfor j in range(K-1, -1, -1):\n\n  i = S.rindex(\"o\", 0, i-C)\n\n  latest[j] = i\n\n\n\nif i<=C or \"o\" not in S[:i-C]:\n\n  i = -C-1\n\n  for j in latest:\n\n    i = S.index(\"o\", i+C+1)\n\n    if i == j:\n\n      print((i+1))\n", "generated_code": "def solve():\n\n  N, K, C = list(map(int, input().split()))\n\n  workable = [i for i, s in enumerate(eval(input())) if s==\"o\"]\n\n  if len(workable) == K:\n\n    return workable\n\n    \n\n  prev = workable[-1]\n\n  latest = {prev}\n\n  i = len(workable)-1\n\n  while i > 0:\n\n    i -= 1\n\n    if prev - workable[i] > C:\n\n      latest.add(workable[i])\n\n      prev = workable[i]\n\n      if len(latest) > K:\n\n        return []\n\n  must = []\n\n  i = -1\n\n  prev = -C-1\n\n  while i < len(workable)-1:\n\n    i += 1\n\n    if workable[i] - prev > C:\n\n      if workable[i] in latest:\n\n        must.append(workable[i])\n\n      prev = workable[i]\n\n  return must\n\n\n\nfor i in solve():\n\n  print((i+1))", "score": 1.0, "surface_similarity": 0.532051282051282}
{"id": "p03747_u102461423", "golden_code": "import sys\n\ninput = sys.stdin.readline\n\n\n\nN,L,T = list(map(int,input().split()))\n\nXW = [[int(x) for x in input().split()] for _ in range(N)]\n\n\n\nX,W = list(zip(*XW))\n\n\n\nDX = [1 if w == 1 else -1 for w in W]\n\n\n\nY = [(x+dx*T)%L for x,dx in zip(X,DX)]\n\ny0 = Y[0]\n\nY.sort()\n\n\n\n# 番号1がすれ違わず進んだ場所に相当するアリの番号\n\n# すれ違うたびに1増える（W1=1） or 1減る（W1=-1）\n\n# T秒ちょうどもすれ違い終わったと考える\n\n\n\nx = 0\n\nx0,dx0 = X[0],DX[0]\n\nfor y,dy in zip(X[1:],DX[1:]):\n\n    if dx0 == dy:\n\n        continue\n\n    if dx0 == 1 and dy == -1:\n\n        # 正の向きに追い越すので番号がひとつ増える\n\n        x += (2*T-(y-x0)-1)//L + 1\n\n    if dx0 == -1 and dy == 1:\n\n        x -= (2*T-(L+x0-y))//L + 1\n\nx %= N\n\n\n\ni = Y.index(y0)\n\n\n\nY += Y\n\n\n\nanswer = [None] * N\n\nanswer[x:N] = Y[i:i+N-x]\n\nanswer[0:x] = Y[i+N-x:i+N]\n\n\n\nprint(('\\n'.join(map(str,answer))))\n\n\n", "generated_code": "import sys\n\nimport numpy as np\n\n\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\n\"\"\"\n\n・順序が固定されるので、区間だったら簡単\n\n・円のときも、地点 0 をそれぞれの方向に通った人数を見れば計算できる\n\n\"\"\"\n\n\n\nN, L, T = list(map(int, readline().split()))\n\nXW = np.array(read().split(), np.int64)\n\nX = XW[::2]\n\nW = XW[1::2]\n\n\n\nspeed = np.where(W == 1, 1, -1)\n\n\n\nY = X + speed * T\n\n\n\nn = (Y // L - X // L).sum()\n\nn %= N\n\n\n\nY %= L\n\nY.sort()\n\nY = np.concatenate((Y[n:], Y[:n]))\n\n\n\nprint(('\\n'.join(map(str, Y.tolist()))))", "score": 1.0, "surface_similarity": 0.5943264693264694}
{"id": "p02688_u628794221", "golden_code": "N, K = list(map(int, input().split()))\n\nsunuke = [True]*N\n\nfor i in range(K):\n\n    d = int(eval(input()))\n\n    A = list(map(int, input().split()))\n\n    for a in A:\n\n        sunuke[a-1] = False\n\n\n\nans = 0\n\nfor i in range(N):\n\n    if sunuke[i]:\n\n        ans += 1\n\nprint(ans)", "generated_code": "N, K = list(map(int, input().split()))\n\nflag = [True]*N\n\nfor i in range(K):\n\n    d = int(eval(input()))\n\n    A = list(map(int, input().split()))\n\n    for a in A:\n\n        flag[a-1] = False\n\nans = 0\n\nfor i in range(N):\n\n    if flag[i]:\n\n        ans += 1\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.9669117647058824}
{"id": "p02937_u638456847", "golden_code": "import sys\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\nreadlines = sys.stdin.readlines\n\n\n\ndef main():\n\n    S = readline().strip()\n\n    T = readline().strip()\n\n\n\n    idx_in_S = []\n\n    last_idx = 0\n\n    for t in T:\n\n        t_idx = S.find(t, last_idx) + 1\n\n        if t_idx:\n\n            idx_in_S.append(t_idx)\n\n            last_idx = t_idx\n\n        else:\n\n            t_idx = S.find(t, 0, last_idx) + 1\n\n            if not t_idx:\n\n                print((-1))\n\n                exit()\n\n            else:\n\n                idx_in_S.append(t_idx)\n\n                last_idx = t_idx\n\n\n\n    \n\n    rep = 0\n\n    for i in range(len(T) - 1):\n\n        if idx_in_S[i] < idx_in_S[i+1]:\n\n            continue\n\n        else:\n\n            rep += 1\n\n\n\n    ans = len(S) * rep + idx_in_S[-1]\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "generated_code": "# S.find()の部分を高速化する\n\nfrom collections import defaultdict\n\nfrom bisect import bisect_right\n\nimport sys\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\nreadlines = sys.stdin.readlines\n\n\n\ndef main():\n\n    S = readline().strip()\n\n    T = readline().strip()\n\n\n\n    S_idx = defaultdict(list)\n\n    for i, s in enumerate(S):\n\n        S_idx[s].append(i)\n\n    \n\n    rep = 0\n\n    last_idx = -1\n\n    for t in T:\n\n        t_idx_list = S_idx[t]\n\n        if t_idx_list:\n\n            t_idx = bisect_right(t_idx_list, last_idx)\n\n            if t_idx < len(t_idx_list):\n\n                last_idx = t_idx_list[t_idx]\n\n            else:\n\n                last_idx = t_idx_list[0]\n\n                rep += 1\n\n        else:\n\n            print((-1))\n\n            exit()\n\n    \n\n    ans = len(S) * rep + last_idx + 1\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "score": 1.0, "surface_similarity": 0.7405557176196033}
{"id": "p00149_u647766105", "golden_code": "from bisect import bisect\n\nD = [0.2,0.6,1.1]\n\nL = [0,0,0,0]\n\nR = [0,0,0,0]\n\nwhile True:\n\n    try:\n\n        left,right = list(map(float,input().split()))\n\n    except:\n\n        break\n\n    L[bisect(D,left)] += 1\n\n    R[bisect(D,right)] += 1\n\nfor left,right in zip(L,R)[::-1]:\n\n    print(left,right)", "generated_code": "from bisect import bisect\n\nD = [0.2,0.6,1.1]\n\nL = [0]*4\n\nR = [0]*4\n\nwhile True:\n\n    try:\n\n        left,right = list(map(float,input().split()))\n\n    except:\n\n        break\n\n    L[bisect(D,left)] += 1\n\n    R[bisect(D,right)] += 1\n\nfor left,right in zip(L,R)[::-1]:\n\n    print(left,right)", "score": 1.0, "surface_similarity": 0.9392341494036409}
{"id": "p03796_u057964173", "golden_code": "import sys\n\ndef input(): return sys.stdin.readline().strip()\n\n\n\ndef resolve():\n\n    import math\n\n    n=int(eval(input()))\n\n    print((math.factorial(n)%(10**9+7)))\n\nresolve()", "generated_code": "import sys\n\ndef input(): return sys.stdin.readline().strip()\n\n\n\ndef resolve():\n\n    answer=1\n\n    n=int(eval(input()))\n\n    for i in range(1,n+1):\n\n        answer*=i\n\n        answer%=10**9+7\n\n    print(answer)\n\nresolve()", "score": 1.0, "surface_similarity": 0.8103896103896104}
{"id": "p03363_u503228842", "golden_code": "from collections import Counter\n\nimport numpy as np\n\n\n\nN = int(eval(input()))\n\nA = np.array(input().split(), dtype = np.int64)\n\n\n\nc = Counter(A.cumsum())\n\nc[0] += 1\n\nanswer = sum(x*(x-1)//2 for x in list(c.values()))\n\nprint(answer)\n", "generated_code": "N = int(eval(input()))\n\nA = list(map(int,input().split()))\n\ncsum = [0]\n\ntemp = 0\n\nfor a in A:\n\n    temp += a\n\n    csum.append(temp)\n\n# csum.sort()\n\n# print(csum)\n\nfrom collections import Counter\n\nfreq = Counter(csum)\n\nans = 0\n\nfor v in list(freq.values()):\n\n    ans += (v*(v-1))//2\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.5567235494880547}
{"id": "p03494_u955547613", "golden_code": "# -*- coding: utf-8 -*-\n\nimport numpy as np\n\n\n\n\n\nif __name__ == '__main__':\n\n    n = int(eval(input()))\n\n    A = np.array([int(a) for a in input().split()], dtype=np.int)\n\n\n\n    isEven = True\n\n    count = 0\n\n    while isEven:\n\n        if (A%2).any() != 0 :\n\n            isEven = False\n\n            break\n\n        A = A/2\n\n        count+=1\n\n    print(count)", "generated_code": "import math\n\nn = eval(input())\n\na = list(map(int, input().split()))\n\nans = float(\"inf\")\n\nfor i in a:\n\n    ans = min(ans, len(bin(i)) - bin(i).rfind(\"1\") - 1)\n\nprint((round(ans)))", "score": 1.0, "surface_similarity": 0.5157615480649188}
{"id": "p03416_u983918956", "golden_code": "A,B = list(map(int,input().split()))\n\nj = 0\n\nfor i in range(A,B+1):\n\n  l = list(str(i))\n\n  l_reverse = list(reversed(l))\n\n  if l == l_reverse:\n\n    j += 1\n\nprint(j)", "generated_code": "A, B = list(map(int,input().split()))\n\n\n\nans = 0\n\nfor n in range(A, B+1):\n\n    n = str(n)\n\n    if n == n[::-1]:\n\n        ans += 1\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.7340301974448316}
{"id": "p02390_u811841526", "golden_code": "s = int(eval(input()))\n\nm, s = s // 60, s % 60\n\nh, m = m // 60, m % 60\n\nprint((':'.join(map(str, [h,m,s]))))", "generated_code": "s = int(eval(input()))\n\n\n\nsecond = s % 60\n\ns = s // 60\n\nmin = s % 60\n\nhour = s // 60\n\n\n\nprint(f'{hour}:{min}:{second}')\n", "score": 1.0, "surface_similarity": 0.6270833333333333}
{"id": "p03796_u488127128", "golden_code": "import math\n\nN = int(eval(input()))\n\nprint((math.factorial(N)%(10**9+7)))", "generated_code": "import math\n\nN = int(eval(input()))\n\na = 1\n\nfor n in range(2,N+1):\n\n    a = a*n % (10**9+7)\n\nprint(a)", "score": 1.0, "surface_similarity": 0.7434478741991846}
{"id": "p03162_u706786134", "golden_code": "import numpy as np\n\n\n\nn = int(eval(input()))\n\nX = np.array([input().split() for _ in range(n)], np.int64)\n\ndp = np.zeros((n + 1, 3), np.int64)\n\ndp[0, 0] = dp[0, 1] = dp[0, 2] = 0\n\nfor i in range(n):\n\n    for j in range(3):\n\n        dp[i + 1, j] = X[i, j] + max(dp[i, k] for k in range(3) if j != k)\n\nprint((max(dp[n])))", "generated_code": "N = int(eval(input()))\n\nx, y, z = 0, 0, 0\n\nfor _ in range(N):\n\n    a, b, c = list(map(int, input().split()))\n\n    x, y, z = max(y, z) + a, max(z, x) + b, max(x, y) + c\n\nprint((max(x, y, z)))", "score": 1.0, "surface_similarity": 0.5242946708463949}
{"id": "p02690_u659159398", "golden_code": "x = int(eval(input()))\n\n\n\nroot = int(x**(0.2))\n\n\n\nflag = 0\n\nfor i in range(root - 400, root + 400):\n\n    for j in range(-100, root + 400):\n\n        if i!=j:\n\n            if x%(i-j) == 0:\n\n                if i**5-j**5 == x:\n\n                    print((i, j))\n\n                    flag = 1\n\n                    break\n\n    if flag:\n\n        break", "generated_code": "x = int(eval(input()))\n\n\n\nfor a in range(-120, 120):\n\n  for b in range(-120, 120):\n\n    if a**5-b**5 == x:\n\n      print((a, b))\n\n      exit()", "score": 1.0, "surface_similarity": 0.7647760402862445}
{"id": "p03819_u754022296", "golden_code": "import sys\n\ninput = sys.stdin.readline\n\n\n\ndef main():\n\n  n, m = map(int, input().split())\n\n  LR = [list(map(int, input().split())) for _ in range(n)]\n\n  \n\n  BIT = [0]*(m+2)\n\n  def add(i, a):\n\n    while i <= m+1:\n\n      BIT[i] += a\n\n      i += i&(-i)\n\n  def bit_sum(i):\n\n    res = 0\n\n    while i > 0:\n\n      res += BIT[i]\n\n      i -= i&(-i)\n\n    return res\n\n  \n\n  S = sorted([(r-l+1, l, r) for l, r in LR], reverse=True)\n\n  cnt = n\n\n  L = []\n\n  for i in range(1, m+1):\n\n    while S and S[-1][0] == i:\n\n      c, l, r = S.pop()\n\n      cnt -= 1\n\n      add(l, 1)\n\n      add(r+1, -1)\n\n    res = cnt\n\n    for j in range(0, m+1, i):\n\n      res += bit_sum(j)\n\n    L.append(res)\n\n  print(*L, sep=\"\\n\")\n\n\n\nif __name__ == \"__main__\":\n\n  main()\n", "generated_code": "import sys\n\ninput = sys.stdin.readline\n\n\n\ndef main():\n\n  n, m = list(map(int, input().split()))\n\n  S = [[] for _ in range(m+1)]\n\n  for _ in range(n):\n\n    l, r = list(map(int, input().split()))\n\n    S[r-l+1].append((l, r))\n\n  \n\n  BIT = [0]*(m+2)\n\n  def add(i, a):\n\n    while i <= m+1:\n\n      BIT[i] += a\n\n      i += i&(-i)\n\n  def bit_sum(i):\n\n    res = 0\n\n    while i > 0:\n\n      res += BIT[i]\n\n      i -= i&(-i)\n\n    return res\n\n  cnt = n\n\n  for i in range(1, m+1):\n\n    for l, r in S[i]:\n\n      cnt -= 1\n\n      add(l, 1)\n\n      add(r+1, -1)\n\n    res = cnt\n\n    for j in range(0, m+1, i):\n\n      res += bit_sum(j)\n\n    print(res)\n\n\n\nif __name__ == \"__main__\":\n\n  main()", "score": 1.0, "surface_similarity": 0.8331967213114755}
{"id": "p03078_u254871849", "golden_code": "import sys\n\nimport numpy as np\n\n\n\nx, y, z, k = map(int, sys.stdin.readline().split())\n\na, b, c = (np.array(sys.stdin.readline().split(), dtype=np.int64) for _ in range(3))\n\n\n\ndef main():\n\n    res = np.sort(np.ravel(a[:, None] + b))[::-1]\n\n    res = np.sort(np.ravel(c[:, None] + res[:min(k, x*y)]))[::-1]\n\n    return res[:k]\n\n\n\nif __name__ == '__main__':\n\n    ans = main()\n\n    print(*ans, sep='\\n')\n", "generated_code": "import sys\n\n\n\nx, y, z, K = map(int, sys.stdin.readline().split())\n\na, b, c = (sorted(map(int, sys.stdin.readline().split()), reverse=True) for _ in range(3))\n\ndef main():\n\n    res = []\n\n    for i in range(1, min(K, x) + 1):\n\n        for j in range(1, min(K // i, y) + 1):\n\n            for k in range(1, min(K // (i * j), z) + 1):\n\n                res.append(a[i-1] + b[j-1] + c[k-1])\n\n\n\n    return sorted(res, reverse=True)[:K]\n\n\n\nif __name__ == '__main__':\n\n    ans = main()\n\n    print(*ans, sep='\\n')\n", "score": 1.0, "surface_similarity": 0.7330019880715706}
{"id": "p03126_u550574002", "golden_code": "import functools\n\nprint((len(functools.reduce(lambda x, y: x&y,[set(input().split()[1:]) for _ in [0]*int(input().split()[0])]))))", "generated_code": "print((len(set.intersection(*[set(input().split()[1:]) for _ in [0]*int(input().split()[0])]))))", "score": 1.0, "surface_similarity": 0.6785953177257524}
{"id": "p03480_u046187684", "golden_code": "#!/usr/bin/env python3\n\n# coding=utf-8\n\n\n\nimport sys\n\n\n\ns = sys.stdin.readline().strip()\n\nl = [_s is \"1\" for _s in list(s)]\n\nl_r = l[::-1]\n\nindex = 0\n\nfor i, (c, n, c_r, n_r) in enumerate(\n\n        zip(l[:len(s) // 2], l[1:len(s) // 2 + 1], l_r[:len(s) // 2], l_r[1:len(s) // 2 + 1])):\n\n    if c ^ n or c_r ^ n_r:\n\n        index = i + 1\n\nprint((len(s) - index))", "generated_code": "def solve(string):\n\n    l = [s == \"1\" for s in string]\n\n    l_r = l[::-1]\n\n    index = 0\n\n    h = len(string) // 2\n\n    for i, (c, n, c_r, n_r) in enumerate(zip(l[:h], l[1:h + 1], l_r[:h], l_r[1:h + 1])):\n\n        if c ^ n or c_r ^ n_r:\n\n            index = i + 1\n\n    return str(len(string) - index)\n\n\n\n\n\nif __name__ == '__main__':\n\n    print((solve(eval(input()))))\n", "score": 1.0, "surface_similarity": 0.6488970588235294}
{"id": "p03371_u561083515", "golden_code": "# https://atcoder.jp/contests/abc095/tasks/arc096_a\n\n\"\"\"\n\n別解(定数時間)\n\nhttps://atcoder.jp/contests/abc095/submissions/10226556\n\n\"\"\"\n\n\n\nA,B,C,X,Y = list(map(int,input().split()))\n\n\n\nans = float(\"inf\")\n\n\n\n# ABピザを2枚1組で考える -> ABセット\n\n# i: ABセットの個数\n\nfor i in range(10**5 + 1):\n\n    ans = min(ans, i*(2*C) + max(0, X-i)*A + max(0, Y-i)*B)\n\n\n\nprint(ans)", "generated_code": "A,B,C,X,Y = list(map(int,input().split()))\n\n\n\nAB_set = C * 2\n\n\n\nans = min(A*X + B*Y, AB_set*max(X,Y), AB_set*min(X,Y) + A*abs(X-min(X,Y)) + B*abs(Y-min(X,Y)))\n\n\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.7196637426900585}
{"id": "p02748_u130900604", "golden_code": "def mi():return list(map(int,input().split()))\n\nimport numpy as np\n\nA,B,M=mi()\n\na=np.array(list(mi()))\n\nb=np.array(list(mi()))\n\nminab=min(a)+min(b)\n\n\n\nans=float(\"inf\")\n\n\n\nfor i in range(M):\n\n    x,y,c=mi()\n\n    tmp=a[x-1]+b[y-1]-c\n\n    ans=min(ans,tmp)\n\nprint((min(ans,minab)))\n", "generated_code": "def mi():return list(map(int,input().split()))\n\nA,B,M=mi()\n\na=list(mi())\n\nb=list(mi())\n\nans=min(a)+min(b)\n\nfor _ in range(M):\n\n    x,y,c=mi()\n\n    ans=min(ans,a[x-1]+b[y-1]-c)\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.7761219595751969}
{"id": "p02994_u191680842", "golden_code": "import numpy as np\n\nn,l = list(map(int,input().split()))\n\ntaste = np.array([l+i-1 for i in range(1,n+1)])\n\ntaste[np.fabs(taste).argmin()]=0\n\nprint((taste.sum()))", "generated_code": "n,l = list(map(int,input().split()))\n\ntaste = [l+i for i in range(0,n)]\n\ntaste.sort(key=lambda x:abs(x))\n\nprint((sum(taste[1:])))", "score": 1.0, "surface_similarity": 0.6106366459627329}
{"id": "p03325_u801359367", "golden_code": "N = int(eval(input()))\n\nA = list(map(int,input().split()))\n\n\n\nSUM = 0\n\nfor i in A:\n\n    count = 0\n\n    while i%2 == 0:\n\n        i//=2\n\n        count += 1\n\n    SUM+=count\n\nprint(SUM)", "generated_code": "N = int(eval(input()))\n\nA = list(map(int,input().split()))\n\nSUM = 0\n\nfor i in A:\n\n    while i%2 == 0:\n\n        i//=2\n\n        SUM += 1\n\nprint(SUM)", "score": 1.0, "surface_similarity": 0.9392265193370166}
{"id": "p03796_u253681061", "golden_code": "n = int(eval(input()))\n\n\n\nINF = 10**9 + 7\n\n\n\nans = [0] * (10**5 + 1)\n\nans[0] = 1\n\n\n\nfor i in range(1,10**5 + 1):\n\n    ans[i] = ans[i-1] * i % INF\n\n\n\nprint((ans[n]))\n", "generated_code": "n = int(eval(input()))\n\nmod = 10**9 + 7\n\n\n\nans = 1\n\n\n\nfor i in range(1,n+1):\n\n    ans = ans * i % mod\n\n\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.7525252525252526}
{"id": "p03038_u102461423", "golden_code": "import numpy as np\n\n\n\nN,M = list(map(int,input().split()))\n\n\n\nA = np.array([int(x) for x in input().split()],dtype=np.int64)\n\nA.sort()\n\n\n\nBC = np.array([[int(x) for x in input().split()] for _ in range(M)])\n\nB = BC[:,0]\n\nC = BC[:,1]\n\n\n\nidx = C.argsort()\n\nB = B[idx][::-1]\n\nC = C[idx][::-1]\n\n\n\np = 0\n\nfor b,c in zip(B,C):\n\n  A[p:p+b] = np.maximum(A[p:p+b],c)\n\n  p += b\n\n\n\nanswer = A.sum()\n\nprint(answer)\n", "generated_code": "import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\nfrom operator import itemgetter\n\n\n\nN,M = list(map(int,readline().split()))\n\nA = list(map(int,readline().split()))\n\nm = list(map(int,read().split()))\n\nBC = list(zip(m,m))\n\n\n\nBC.sort(key = itemgetter(1),reverse=True)\n\n\n\nBC.append((N,-1))\n\n\n\nchange = []\n\nfor b,c in BC:\n\n    change += [c] * b\n\n    if len(change) > N:\n\n        break\n\n\n\nA += change\n\nA.sort()\n\nanswer = sum(A[-N:])\n\nprint(answer)", "score": 1.0, "surface_similarity": 0.5191581384015594}
{"id": "p03371_u813450984", "golden_code": "a, b, c, x, y = list(map(int, input().split()))\n\nans = a * x + b * y\n\nm = max(x, y)\n\nfor i in range(1, m+1):\n\n  x -= 1\n\n  y -= 1\n\n  if x < 0:\n\n    x = 0\n\n  if y < 0:\n\n    y = 0\n\n  temp = c*(i*2) + x*a + y*b\n\n  if temp < ans:\n\n    ans = temp\n\n\n\nprint(ans)\n", "generated_code": "a, b, c, x, y = list(map(int, input().split()))\n\nans = a * x + b * y\n\nans = min(c * max(x, y) * 2, ans)\n\nif x < y:\n\n    ans = min(c * x * 2 + (y - x) * b, ans)\n\nelse:\n\n    ans = min(c * y * 2 + (x - y) * a, ans)\n\n\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.772858617131063}
{"id": "p03798_u989345508", "golden_code": "n=int(eval(input()))\n\ns=eval(input())\n\nx=[\"SS\",\"SW\",\"WS\",\"WW\"]\n\n\n\ndef check0(i):\n\n    if x[i][0]==\"S\":\n\n        if s[0]==\"o\":\n\n            if x[i][-1]==\"S\":\n\n                return x[i][1]==\"S\"\n\n            else:\n\n                return x[i][1]==\"W\"\n\n        else:\n\n            if x[i][-1]==\"S\":\n\n                return x[i][1]==\"W\"\n\n            else:\n\n                return x[i][1]==\"S\"\n\n    else:\n\n        if s[0]==\"o\":\n\n            if x[i][-1]==\"S\":\n\n                return x[i][1]==\"W\"\n\n            else:\n\n                return x[i][1]==\"S\"\n\n        else:\n\n            if x[i][-1]==\"S\":\n\n                return x[i][1]==\"S\"\n\n            else:\n\n                return x[i][1]==\"W\"\n\ndef check1(i):\n\n    if x[i][n-1]==\"S\":\n\n        if s[n-1]==\"o\":\n\n            if x[i][n-2]==\"S\":\n\n                return x[i][0]==\"S\"\n\n            else:\n\n                return x[i][0]==\"W\"\n\n        else:\n\n            if x[i][n-2]==\"S\":\n\n                return x[i][0]==\"W\"\n\n            else:\n\n                return x[i][0]==\"S\"\n\n    else:\n\n        if s[n-1]==\"o\":\n\n            if x[i][n-2]==\"S\":\n\n                return x[i][0]==\"W\"\n\n            else:\n\n                return x[i][0]==\"S\"\n\n        else:\n\n            if x[i][n-2]==\"S\":\n\n                return x[i][0]==\"S\"\n\n            else:\n\n                return x[i][0]==\"W\"\n\n\n\n\n\nfor i in range(4):\n\n    for j in range(n-2):\n\n        if x[i][j+1]==\"S\":\n\n            if s[j+1]==\"o\":\n\n                if x[i][j]==\"S\":\n\n                    x[i]+=\"S\"\n\n                else:\n\n                    x[i]+=\"W\"\n\n            else:\n\n                if x[i][j]==\"S\":\n\n                    x[i]+=\"W\"\n\n                else:\n\n                    x[i]+=\"S\"\n\n        else:\n\n            if s[j+1]==\"o\":\n\n                if x[i][j]==\"S\":\n\n                    x[i]+=\"W\"\n\n                else:\n\n                    x[i]+=\"S\"\n\n            else:\n\n                if x[i][j]==\"S\":\n\n                    x[i]+=\"S\"\n\n                else:\n\n                    x[i]+=\"W\"\n\n    #print(x[i])\n\n    if check0(i) and check1(i):\n\n        print((x[i]))\n\n        break\n\nelse:\n\n    print((-1))\n", "generated_code": "n=int(eval(input()))\n\ns=eval(input())\n\nx=[\"SS\",\"SW\",\"WS\",\"WW\"]\n\n\n\ndef check0(i):\n\n    if x[i][0]==\"S\":\n\n        if s[0]==\"o\":\n\n            if x[i][-1]==\"S\":\n\n                return x[i][1]==\"S\"\n\n            else:\n\n                return x[i][1]==\"W\"\n\n        else:\n\n            if x[i][-1]==\"S\":\n\n                return x[i][1]==\"W\"\n\n            else:\n\n                return x[i][1]==\"S\"\n\n    else:\n\n        if s[0]==\"o\":\n\n            if x[i][-1]==\"S\":\n\n                return x[i][1]==\"W\"\n\n            else:\n\n                return x[i][1]==\"S\"\n\n        else:\n\n            if x[i][-1]==\"S\":\n\n                return x[i][1]==\"S\"\n\n            else:\n\n                return x[i][1]==\"W\"\n\ndef check1(i):\n\n    if x[i][n-1]==\"S\":\n\n        if s[n-1]==\"o\":\n\n            if x[i][n-2]==\"S\":\n\n                return x[i][0]==\"S\"\n\n            else:\n\n                return x[i][0]==\"W\"\n\n        else:\n\n            if x[i][n-2]==\"S\":\n\n                return x[i][0]==\"W\"\n\n            else:\n\n                return x[i][0]==\"S\"\n\n    else:\n\n        if s[n-1]==\"o\":\n\n            if x[i][n-2]==\"S\":\n\n                return x[i][0]==\"W\"\n\n            else:\n\n                return x[i][0]==\"S\"\n\n        else:\n\n            if x[i][n-2]==\"S\":\n\n                return x[i][0]==\"S\"\n\n            else:\n\n                return x[i][0]==\"W\"\n\n\n\na=[\"S\",\"W\"]\n\nfor i in range(4):\n\n    for j in range(n-2):\n\n        if x[i][j+1]==\"S\":\n\n            if s[j+1]==\"o\":\n\n                x[i]+=a[x[i][j]!=\"S\"]\n\n            else:\n\n                x[i]+=a[x[i][j]==\"S\"]\n\n        else:\n\n            if s[j+1]==\"o\":\n\n                x[i]+=a[x[i][j]==\"S\"]\n\n            else:\n\n                x[i]+=a[x[i][j]!=\"S\"]\n\n    if check0(i) and check1(i):\n\n        print((x[i]))\n\n        break\n\nelse:\n\n    print((-1))\n", "score": 1.0, "surface_similarity": 0.9541190025512304}
{"id": "p02881_u260216890", "golden_code": "import numpy as np\n\nN=int(eval(input()))\n\nroot=int(np.sqrt(N)//1)\n\na=N\n\nb=N\n\nfor i in range(root, 0, -1):\n\n    if N%i==0:\n\n        a=i\n\n        b=N//i\n\n        break\n\nprint((a-1+b-1))", "generated_code": "N=int(eval(input()))\n\nroot=int((N**0.5)//1)\n\na=N\n\nb=N\n\nfor i in range(root, 0, -1):\n\n    if N%i==0:\n\n        a=i\n\n        b=N//i\n\n        break\n\nprint((a-1+b-1))\n", "score": 1.0, "surface_similarity": 0.8483606557377049}
{"id": "p02952_u593934357", "golden_code": "n_str = eval(input())\n\nn_int = int(n_str)\n\n# 1 ~ 50000\n\n# 桁数が奇数= 1桁, 3桁, 5桁\n\n# 1 ~ 9, 100 ~ 999,10000 ~ 99999の90909個しかないので全探索いけるか?\n\nexs_list = []\n\nfor i in range(1, 100000):\n\n    if len(str(i)) % 2 == 1:\n\n        exs_list.append(i)\n\n\n\nexs = {i: i for i in exs_list}\n\n\n\nn_s = []\n\nans = 0\n\nfor i in range(1, n_int + 1):\n\n    if len(str(i)) % 2 == 0:\n\n        continue\n\n    if i in exs:\n\n        ans += 1\n\n\n\nprint(ans)\n\n\n\n\n\n\n\n\n\n\n", "generated_code": "def digit_sum(n):\n\n    # 各桁の和を求める\n\n    # 計算量: O(logN)\n\n    ans = 0\n\n    while n > 0:\n\n        ans += 1\n\n        n //= 10\n\n    return ans\n\n\n\nn = int(eval(input()))\n\ncnt = 0\n\n\n\nfor i in range(1, n+1):\n\n    cnt += digit_sum(i) % 2\n\n\n\nprint(cnt)\n", "score": 1.0, "surface_similarity": 0.5524121741945929}
{"id": "p03162_u318414416", "golden_code": "# coding: utf-8\n\n\n\nimport sys\n\ninput = sys.stdin.readline\n\n\n\ndef f(n, abc):\n\n    dp = [[0] * 3 for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n\n        for j in range(3):\n\n            dp[i][j] = max(dp[i - 1][k] + abc[i - 1][j] \\\n\n                for k in range(3) if k != j)\n\n    return(max(dp[n]))\n\n\n\nn = int(eval(input()))    # 1 <= n <= 10^5\n\nabc = [list(map(int, input().rstrip().split())) for _ in range(n)]\n\n\n\nprint((f(n, abc)))\n", "generated_code": "# coding: utf-8\n\nimport sys\n\ninput = sys.stdin.readline\n\n\n\ndef f(n, abc):\n\n    dp = [0] * 3\n\n    for i in range(1, n + 1):\n\n        a, b, c = abc[i - 1]\n\n        dp = [ max(dp[1] + a, dp[2] + a), \\\n\n               max(dp[0] + b, dp[2] + b), \\\n\n               max(dp[0] + c, dp[1] + c) ]\n\n    return(max(dp))\n\n\n\nn = int(eval(input()))    # 1 <= n <= 10^5\n\nabc = [list(map(int, input().rstrip().split())) for _ in range(n)]\n\n\n\nprint((f(n, abc)))\n", "score": 1.0, "surface_similarity": 0.8353137620379}
{"id": "p03162_u826929627", "golden_code": "N = int(eval(input()))\n\nABC = []\n\n\n\nfor n in range(N):\n\n  ABC.append(list(map(int, input().split())))\n\n\n\nimport numpy as np\n\nABC = np.array(ABC)\n\n\n\n## 「日付」、「選択した行動」ごとの幸福度の最大値を格納するarray\n\nhp=np.zeros((N,3),dtype=int)\n\nhp[0] = ABC[0]\n\n\n\nfor n in range(1,N):# 日単位でのループ\n\n  for c in range(3): # 選択肢ごとのループ\n\n    ## n日にcを選択した場合の幸福度。つまり前日はc以外を選択している\n\n    if c == 0:\n\n      hp[n][0] = max(hp[n-1][1],hp[n-1][2]) + ABC[n][0]\n\n    elif c == 1:\n\n      hp[n][1] = max(hp[n-1][0],hp[n-1][2]) + ABC[n][1]\n\n    elif c == 2:\n\n      hp[n][2] = max(hp[n-1][0],hp[n-1][1]) + ABC[n][2]\n\n\n\n\n\nans = max(hp[-1])\n\nprint(ans)", "generated_code": "N = int(eval(input()))\n\n\n\ndpa,dpb,dpc = 0,0,0\n\nfor n in range(N):\n\n  a,b,c = list(map(int, input().split()))  \n\n  dpa,dpb,dpc = max(dpb+a,dpc+a),max(dpa+b,dpc+b),max(dpa+c,dpb+c)\n\n  \n\nans = max(dpa,dpb,dpc)\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.5288442211055276}
{"id": "p02595_u945199633", "golden_code": "N, D = list(map(int, input().split()))\n\npoint = []\n\nfor i in range(N):\n\n    point.append(list(map(int, input().split())))\n\n\n\nct = 0\n\nD2 = D * D\n\nfor i in point:\n\n    if (i[0]**2 + i[1]**2) <= D2:\n\n        ct += 1\n\n\n\nprint(ct)", "generated_code": "N, D = list(map(int, input().split()))\n\n\n\nct = 0\n\nD2 = D * D\n\nfor i in range(N):\n\n    X, Y = list(map(int, input().split()))\n\n    if (X**2 + Y**2) <= D2:\n\n        ct += 1\n\n\n\nprint(ct)", "score": 1.0, "surface_similarity": 0.8051515151515152}
{"id": "p02767_u624696727", "golden_code": "import sys\n\nimport numpy as np\n\n\n\nsys.setrecursionlimit(10 ** 6)\n\nint1 = lambda x: int(x) - 1\n\nprintV = lambda x: print(*x, sep=\"\\n\")\n\nprintH = lambda x: print(\" \".join(map(str,x)))\n\ndef IS(): return sys.stdin.readline()[:-1]\n\ndef II(): return int(sys.stdin.readline())\n\ndef MI(): return map(int, sys.stdin.readline().split())\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\n\ndef LI1(): return list(map(int1, sys.stdin.readline().split()))\n\ndef LII(rows_number): return [II() for _ in range(rows_number)]\n\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\n\ndef LLI1(rows_number): return [LI1() for _ in range(rows_number)]\n\n\n\ndef main():\n\n\tN = II()\n\n\tX = LI()\n\n\tX = np.array(X, dtype=\"int32\")\n\n\tm = round(np.sum(X) / N)\n\n\tprint(int(np.sum((X-m)**2)))\n\n\n\nif __name__ == '__main__':\n\n\tmain()\n", "generated_code": "import sys\n\nimport numpy as np\n\n\n\nsys.setrecursionlimit(10 ** 6)\n\nint1 = lambda x: int(x) - 1\n\nprintV = lambda x: print(*x, sep=\"\\n\")\n\nprintH = lambda x: print(\" \".join(map(str,x)))\n\ndef IS(): return sys.stdin.readline()[:-1]\n\ndef II(): return int(sys.stdin.readline())\n\ndef MI(): return map(int, sys.stdin.readline().split())\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\n\ndef LI1(): return list(map(int1, sys.stdin.readline().split()))\n\ndef LII(rows_number): return [II() for _ in range(rows_number)]\n\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\n\ndef LLI1(rows_number): return [LI1() for _ in range(rows_number)]\n\n\n\ndef main():\n\n\tN = II()\n\n\tX = LI()\n\n\tX = np.array(X)\n\n\tm = round(np.sum(X) / N)\n\n\tprint(int(np.sum((X-m)**2)))\n\n\n\nif __name__ == '__main__':\n\n\tmain()\n", "score": 1.0, "surface_similarity": 0.9914529914529915}
{"id": "p03162_u698176039", "golden_code": "N = int(eval(input()))\n\na = [list(map(int,input().split())) for _ in range(N)]\n\n\n\ndp = [[0]*3 for _ in range(100010)] \n\n# dp[i][j] : i日目にj番目の活動をしたときの幸福度の総和\n\nidx = [[1,2],[2,0],[0,1]]\n\n\n\nfor i in range(3):\n\n    dp[0][i] = a[0][i]\n\n    \n\nfor i in range(1,N):\n\n    for j in range(3):\n\n        dp[i][j] = max(dp[i-1][idx[j][0]],dp[i-1][idx[j][1]])+a[i][j]\n\n    \n\nprint((max(dp[N-1])))", "generated_code": "import sys\n\ndef input():\n\n    return sys.stdin.readline()[:-1]\n\n\n\nN = int(eval(input()))\n\nABC = [list(map(int,input().split())) for _ in range(N)]\n\n\n\ninf = 10**9+7\n\ndp = [[0] * 3 for _ in range(N+10)]\n\ndp[0] = [ABC[0][0],ABC[0][1],ABC[0][2]]\n\n\n\nfor i in range(N-1):\n\n    for j in range(3):\n\n        for k in range(3):\n\n            if j==k:continue\n\n            dp[i+1][j] = max(dp[i+1][j],dp[i][k]+ABC[i+1][j])\n\n        \n\n    \n\n\n\nprint((max(dp[N-1][:])))\n", "score": 1.0, "surface_similarity": 0.6166552197802198}
{"id": "p02850_u780962115", "golden_code": "n=int(eval(input()))\n\nnode={i:[] for i in range(1,n+1)}\n\nvisited=[False for i in range(n+1)]\n\nq=[]\n\nfor _ in range(n-1):\n\n    a,b=list(map(int,input().split()))\n\n    node[a].append(b)\n\n    node[b].append(a)\n\n    q.append((a,b))\n\n\n\nmother=q[0][0]\n\nvisited[mother]=True\n\n\n\nd=[]\n\ne=[]\n\n\n\n\n\npaint={i:{} for i in range(1,n+1)}\n\n\n\nmother_paint=[0 for i in range(n+1)]\n\n\n\n#使う要素 node visited paint mother_paint の四つのリスト\n\nc=1\n\nfor child in node[mother]:\n\n    visited[child]=True\n\n    paint[mother][child]=c\n\n    paint[child][mother]=c\n\n    mother_paint[child]=c\n\n    c+=1\n\n    d.append(child)\n\n    \n\nwhile d:\n\n    for parent in d:\n\n        p=1 \n\n        for child in node[parent]:\n\n            if visited[child]==False:\n\n                visited[child]=True\n\n                if p!=mother_paint[parent]:\n\n                    paint[parent][child]=p\n\n                    paint[child][parent]=p\n\n                    mother_paint[child]=p\n\n                    p+=1\n\n                    e.append(child)\n\n                else:\n\n                    p+=1\n\n                    paint[parent][child]=p\n\n                    paint[child][parent]=p\n\n                    mother_paint[child]=p\n\n                    p+=1\n\n                    e.append(child)\n\n    if e:\n\n        d=e\n\n        e=[]\n\n    else:\n\n        d=[]\n\n        e=[]\n\nK=0\n\nfor i in range(1,n+1):\n\n    K=max(K,len(node[i]))\n\nprint(K)\n\nfor i in range(n-1):\n\n    s,t=q[i][0],q[i][1]\n\n    print((paint[s][t]))", "generated_code": "#problem1\n\nfrom collections import deque\n\nd=deque()\n\ne=deque()\n\n\n\nN=int(eval(input()))\n\ngraph=[[] for i in range(N+1)]\n\nD=[]\n\nfor _ in range(N-1):\n\n    a,b=list(map(int,input().split()))\n\n    graph[a].append(b)\n\n    graph[b].append(a)\n\n    D.append((a,b))\n\n    \n\n#頂点1からスタート\n\nK=0\n\nd.append(1)\n\nvisited=[False for i in range(N+1)]\n\ncolor=[-1 for i in range(N+1)]\n\nvisited[1]=True\n\ncolor[1]=-1\n\ndic={}\n\nwhile d:\n\n    while d:\n\n        x=d.popleft()\n\n        par_color=color[x]\n\n        c=1\n\n        for node in graph[x]:\n\n            if visited[node]==False:\n\n                visited[node]=True\n\n                e.append(node)                \n\n                if c!=par_color:\n\n                    color[node]=c\n\n                    dic[(x,node)]=c\n\n                elif c==par_color:\n\n                    c+=1\n\n                    color[node]=c\n\n                    dic[(x,node)]=c\n\n                c+=1\n\n    if e:\n\n        d=e\n\n        e=deque()\n\n\n\nA=max(color)\n\nprint(A)\n\nfor que in D:\n\n    a,b=que\n\n    if (a,b) in list(dic.keys()):\n\n        print((dic[que]))\n\n    else:\n\n        print((dic[(b,a)]))\n\n    ", "score": 1.0, "surface_similarity": 0.7123441828254847}
{"id": "p03796_u624689667", "golden_code": "from math import factorial\n\n\n\nmod = 10**9 + 7\n\nn = int(eval(input()))\n\n\n\nans = factorial(n) % mod\n\nprint(ans)", "generated_code": "N = int(eval(input()))\n\nMOD = 10**9 + 7\n\nans = 1\n\nfor i in range(2, N+1):\n\n    ans *= i\n\n    ans %= MOD\n\nprint(ans)\n", "score": 1.0, "surface_similarity": 0.5943204868154158}
{"id": "p02555_u945228737", "golden_code": "# import sys\n\n# sys.setrecursionlimit(10 ** 6)\n\n# import bisect\n\n# from collections import deque\n\n\n\ndef cmb(n, r):\n\n    \"\"\"組み合わせ\"\"\"\n\n    import math\n\n    if n < r:\n\n        return 0\n\n    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\n\n\n\n\n\n# from decorator import stop_watch\n\n#\n\n#\n\n# @stop_watch\n\ndef solve(S):\n\n    mod = 10 ** 9 + 7\n\n    ans = 0\n\n    for i in range(1, S // 3 + 1):\n\n        tama = i + (S - (i * 3))\n\n        tama -= 2\n\n        bo = i - 1\n\n        ans += cmb(tama + 1, bo)\n\n        ans %= mod\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    # S = input()\n\n    S = int(eval(input()))\n\n    # N, M = map(int, input().split())\n\n    # Ai = [int(i) for i in input().split()]\n\n    # Bi = [int(i) for i in input().split()]\n\n    # ABi = [[int(i) for i in input().split()] for _ in range(N)]\n\n    solve(S)\n\n\n\n    # # test\n\n    # from random import randint\n\n    # from func import random_str\n\n    # solve()\n", "generated_code": "# 解説を参考に作成\n\n# import sys\n\n# sys.setrecursionlimit(10 ** 6)\n\n# import bisect\n\n# from collections import deque\n\n# from decorator import stop_watch\n\n#\n\n#\n\n# @stop_watch\n\ndef solve(S):\n\n    mod = 10 ** 9 + 7\n\n    dp = [0] * (S + 1)\n\n    dp[0] = 1\n\n    for i in range(3, S + 1):\n\n        dp[i] = dp[i - 1] + dp[i - 3]\n\n        dp[i] %= mod\n\n    print((dp[S]))\n\n\n\n\n\nif __name__ == '__main__':\n\n    S = int(eval(input()))\n\n    solve(S)\n\n\n\n    # # test\n\n    # from random import randint\n\n    # from func import random_str\n\n    # solve()\n", "score": 1.0, "surface_similarity": 0.7545202383398397}
{"id": "p03078_u816872429", "golden_code": "import heapq\n\n\n\nx, y, z, k = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\nb = list(map(int, input().split()))\n\nc = list(map(int, input().split()))\n\n\n\ndef diff(l):\n\n    m = max(l)\n\n    return sorted(m - v for v in l)[1:]\n\n\n\ns = sum(map(max, [a, b, c]))\n\nsa, sb, sc = list(map(diff, [a, b, c]))\n\nda, db, dc = [0], [0], [0]\n\nq = [0]\n\nwhile k > 0:\n\n    while True:\n\n        if len(sa) > 0 and (len(q) == 0 or q[0] > sa[0]):\n\n            for v in [sa[0] + bb + cc for bb in db for cc in dc]:\n\n                heapq.heappush(q, v)\n\n            da.append(sa[0])\n\n            sa = sa[1:]\n\n        elif len(sb) > 0 and (len(q) == 0 or q[0] > sb[0]):\n\n            for v in [sb[0] + aa + cc for aa in da for cc in dc]:\n\n                heapq.heappush(q, v)\n\n            db.append(sb[0])\n\n            sb = sb[1:]\n\n        elif len(sc) > 0 and (len(q) == 0 or q[0] > sc[0]):\n\n            for v in [sc[0] + aa + bb for aa in da for bb in db]:\n\n                heapq.heappush(q, v)\n\n            dc.append(sc[0])\n\n            sc = sc[1:]\n\n        else:\n\n            break\n\n    v = heapq.heappop(q)\n\n    print(s - v)\n\n    k -= 1\n", "generated_code": "import heapq\n\n\n\nx, y, z, k = list(map(int, input().split()))\n\na = sorted(map(int, input().split()))\n\nb = sorted(map(int, input().split()))\n\nc = sorted(map(int, input().split()))\n\n\n\nq = []\n\nmemo = set()\n\ndef qpush(q, ai, bi, ci):\n\n    t = (-(a[ai] + b[bi] + c[ci]), ai, bi, ci)\n\n    if not t in memo:\n\n        memo.add(t)\n\n        heapq.heappush(q, t)\n\n\n\nqpush(q, len(a) - 1, len(b) - 1, len(c) - 1)\n\nfor _ in range(k):\n\n    s, ai, bi, ci = heapq.heappop(q)\n\n    if ai > 0:\n\n        qpush(q, ai - 1, bi, ci)\n\n    if bi > 0:\n\n        qpush(q, ai, bi - 1, ci)\n\n    if ci > 0:\n\n        qpush(q, ai, bi, ci - 1)\n\n    print(-s)\n", "score": 1.0, "surface_similarity": 0.6056696055087201}
{"id": "p02837_u924691798", "golden_code": "N = int(eval(input()))\n\nA = [0]*N\n\nX = []\n\nY = []\n\nfor i in range(N):\n\n    A[i] = int(eval(input()))\n\n    X.append([])\n\n    Y.append([])\n\n    for j in range(A[i]):\n\n        x, y = list(map(int, input().split()))\n\n        X[i].append(x-1)\n\n        Y[i].append(y)\n\nans = 0\n\nfor bit in range(1<<N):\n\n    honest = 0\n\n    ok = True\n\n    for i in range(N):\n\n        if bit&(1<<i):\n\n            honest += 1\n\n            for j in range(A[i]):\n\n                if Y[i][j] == 0:\n\n                    if bit&(1<<X[i][j]):\n\n                        ok = False\n\n                        break\n\n                else:\n\n                    if not bit&(1<<X[i][j]):\n\n                        ok = False\n\n                        break\n\n            if not ok:\n\n                break\n\n    if ok:\n\n        ans = max(ans, honest)\n\nprint(ans)", "generated_code": "N = int(eval(input()))\n\nXY = [[] for _ in range(N)]\n\nfor i in range(N):\n\n    A = int(eval(input()))\n\n    for _ in range(A):\n\n        x, y = list(map(int, input().split()))\n\n        XY[i].append((x-1,y))\n\nans = 0\n\nfor bit in range(1<<N):\n\n    cnt = bin(bit).count('1')\n\n    ok = True\n\n    for i in range(N):\n\n        if bit&(1<<i):\n\n            for x,y in XY[i]:\n\n                if y == 1:\n\n                    if not bit&(1<<x):\n\n                        ok = False\n\n                        break\n\n                else:\n\n                    if bit&(1<<x):\n\n                        ok = False\n\n                        break\n\n            if not ok:\n\n                break\n\n    if ok:\n\n        ans = max(ans, cnt)\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.8280087897227857}
{"id": "p02773_u297574184", "golden_code": "from collections import Counter\n\nimport sys\n\ninput = sys.stdin.readline\n\n\n\ndef solve():\n\n    N = int(eval(input()))\n\n    Sss = [input().rstrip() for _ in range(N)]\n\n\n\n    cnt = Counter(Sss)\n\n    #print('cnt:', cnt)\n\n\n\n    maxNum = max(cnt.values())\n\n    #print('maxNum:', maxNum)\n\n\n\n    anss = []\n\n    for key, value in list(cnt.items()):\n\n        if value == maxNum:\n\n            anss.append(key)\n\n    #print('anss:', anss)\n\n\n\n    anss.sort()\n\n\n\n    print(('\\n'.join(anss)))\n\n\n\n\n\nsolve()\n", "generated_code": "from collections import Counter\n\nimport sys\n\ninput = sys.stdin.readline\n\n\n\nN = int(eval(input()))\n\nSss = [input().rstrip() for _ in range(N)]\n\n\n\ncnt = Counter(Sss)\n\n\n\nnum = max(cnt.values())\n\n\n\nanss = []\n\nfor key in sorted(cnt.keys()):\n\n    if cnt[key] == num:\n\n        anss.append(key)\n\n\n\nprint(('\\n'.join(anss)))\n", "score": 1.0, "surface_similarity": 0.833461145194274}
{"id": "p03796_u466330895", "golden_code": "import math\n\nn = int(eval(input()))\n\n\n\nans = math.factorial(n)  # nの階乗を計算\n\n\n\nif ans >= (10 ** 9)+7:\n\n    ans = ans % ((10 ** 9)+7)\n\n\n\nprint(ans)\n", "generated_code": "n = int(eval(input()))\n\n\n\nans = 1\n\nfor i in range(1, n+1):\n\n    ans = ans * i\n\n    ans = ans % ((10 ** 9)+7)  # 途中で割り算の余りを求めても、最終結果は同じになる\n\n\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.6609271523178808}
{"id": "p02278_u072053884", "golden_code": "\"\"\"Minimum cost Sort.\"\"\"\n\n\n\ndef min_cost_sort(A):\n\n    \"\"\"Sort list A in ascending order.\n\n \n\n    And return the switching cost in sorting.\n\n    \"\"\"\n\n    B = list(A)\n\n    B.sort()\n\n    cost = 0\n\n    min_w = B[0]\n\n    for i, b in enumerate(B):\n\n        tmp_cost = 0\n\n        bi = A.index(b)\n\n        n = 1\n\n        while bi != i:\n\n            n += 1\n\n            st = B[bi]\n\n            si = A.index(st)\n\n            tmp_cost += b + st\n\n            A[bi], A[si] = st, b\n\n            bi = si\n\n        dec = (n - 1) * (b - min_w)\n\n        inc = 2 * (min_w + b)\n\n        if dec < inc:\n\n            cost += tmp_cost\n\n        else:\n\n            cost += tmp_cost - dec + inc\n\n    return cost\n\n\n\n\n\nn = eval(input())\n\n\n\nA = list(map(int, input().split()))\n\n\n\nans = min_cost_sort(A)\n\n\n\nprint(ans)", "generated_code": "\"\"\"Minimum cost Sort.\"\"\"\n\n\n\ndef min_cost_sort(A):\n\n    \"\"\"Sort list A in ascending order.\n\n \n\n    And return the switching cost in sorting.\n\n    \"\"\"\n\n    B = list(A)\n\n    B.sort()\n\n    cost = 0\n\n    min_w = B[0]\n\n    for i, b in enumerate(B):\n\n        tmp_cost = 0\n\n        bi = A.index(b)\n\n        cnt = 0\n\n        while bi != i:\n\n            cnt += 1\n\n            st = B[bi]\n\n            si = A.index(st)\n\n            tmp_cost += b + st\n\n            A[bi], A[si] = st, b\n\n            bi = si\n\n        if cnt:\n\n            dec = cnt * (b - min_w)\n\n            inc = 2 * (min_w + b)\n\n            if dec < inc:\n\n                cost += tmp_cost\n\n            else:\n\n                cost += tmp_cost - dec + inc\n\n    return cost\n\n\n\n\n\nn = eval(input())\n\n\n\nA = list(map(int, input().split()))\n\n\n\nans = min_cost_sort(A)\n\n\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.9903264812575574}
{"id": "p02982_u328364772", "golden_code": "import math\n\nimport numpy as np\n\n\n\nn, d = list(map(int, input().split()))\n\n\n\nx = np.zeros([n, d])\n\n\n\nfor i in range(n):\n\n    line = list(map(int, input().split()))\n\n    for j in range(d):\n\n        x[i, j] = line[j]\n\n\n\ncnt = 0\n\n\n\nfor i in range(n):\n\n    for j in range(i+1, n):\n\n        xx = (x[i] - x[j]) ** 2\n\n        dist = math.sqrt(xx.sum())\n\n        if dist % 1 == 0:\n\n            cnt += 1\n\n\n\nprint(cnt)", "generated_code": "import math\n\n\n\nn, d = list(map(int, input().split()))\n\n\n\nx = [list(map(int, input().split())) for i in range(n)]\n\n\n\ncnt = 0\n\n\n\nfor i in range(n):\n\n    for j in range(i+1, n):\n\n        dist = 0\n\n        for k in range(d):\n\n            dist += (x[i][k] - x[j][k]) ** 2\n\n        if math.sqrt(dist).is_integer():\n\n            cnt += 1\n\n\n\nprint(cnt)", "score": 1.0, "surface_similarity": 0.735702614379085}
{"id": "p02555_u811436126", "golden_code": "from functools import lru_cache\n\nimport sys\n\n\n\nsys.setrecursionlimit(2000)\n\n\n\ns = int(eval(input()))\n\nmod = 10 ** 9 + 7\n\n\n\n\n\n@lru_cache(maxsize=None)\n\ndef dfs(n):\n\n    if n <= 2:\n\n        return 0\n\n    elif 3<=n<=5:\n\n        return 1\n\n    else:\n\n        count = 1\n\n        for i in range(3, n + 1):\n\n            count += dfs(n - i)\n\n            count %= mod\n\n\n\n        return count % mod\n\n\n\n\n\nans = dfs(s)\n\nprint(ans)\n", "generated_code": "s = int(eval(input()))\n\nmod = 10 ** 9 + 7\n\n\n\ndp = [0] * (s + 1)\n\ndp[0] = 1\n\n\n\nx = 0\n\nfor i in range(3, s + 1):\n\n    x += dp[i - 3]\n\n    dp[i] = x % mod\n\n\n\nans = dp[s] % mod\n\nprint(ans)\n", "score": 1.0, "surface_similarity": 0.5230359623398673}
{"id": "p03457_u820560680", "golden_code": "import numpy as np\n\nN = int(eval(input()))\n\nplan = np.array([[0, 0, 0]] + [list(map(int, input().split())) for i in range(N)])\n\n\n\ndiff = np.diff(plan, axis = 0)\n\n\n\ndef is_possible(t, x, y):\n\n    if (t + x + y) % 2 == 0 and abs(x) + abs(y) <= t:\n\n        return True\n\n    else:\n\n        return False\n\n\n\nfor i in range(N):\n\n    ti, xi, yi = diff[i]\n\n    if not is_possible(ti, xi, yi):\n\n        print('No')\n\n        exit()\n\nprint('Yes')", "generated_code": "N = int(eval(input()))\n\nplan = [[0, 0, 0]] + [list(map(int, input().split())) for _ in range(N)]\n\ndiff = [[plan[i + 1][j] - plan[i][j] for j in range(3)] for i in range(N)]\n\n\n\ndef is_possible(t, x, y):\n\n    if (t + x + y) % 2 == 0 and abs(x) + abs(y) <= t:\n\n        return True\n\n    else:\n\n        return False\n\n\n\nfor i in range(N):\n\n    ti, xi, yi = diff[i]\n\n    if not is_possible(ti, xi, yi):\n\n        print('No')\n\n        exit()\n\nprint('Yes')", "score": 1.0, "surface_similarity": 0.8610185778347212}
{"id": "p03721_u599114793", "golden_code": "n,k = list(map(int,input().split()))\n\nnum = 0\n\nq = []\n\nfor i in range(n):\n\n    a,b = list(map(int,input().split()))\n\n    q.append((a,b))\n\nq.sort()\n\nfor i in range(n):\n\n    a, b = q[i][0], q[i][1]\n\n    num += b\n\n    if num >= k:\n\n        print(a)\n\n        exit()\n\n\n", "generated_code": "n,k = list(map(int,input().split()))\n\ncnt = 0\n\nnum = []\n\nfor i in range(n):\n\n    a,b = list(map(int,input().split()))\n\n    num.append((a,b))\n\nnum.sort()\n\nfor i in range(n):\n\n    cnt += num[i][1]\n\n    if cnt >= k:\n\n        print((num[i][0]))\n\n        exit()", "score": 1.0, "surface_similarity": 0.9128787878787878}
{"id": "p03197_u047796752", "golden_code": "import sys\n\ninput = sys.stdin.readline\n\nfrom collections import *\n\n\n\ndef dfs(x, y):\n\n    if x==0 and y==0:\n\n        t[x][y] = False\n\n        return False\n\n    \n\n    if x>=1:\n\n        t[x][y] |= not dfs(x-1, y)\n\n        \n\n    if y>=1:\n\n        t[x][y] |= not dfs(x, y-1)\n\n        \n\n    if min(x, y)>=1:\n\n        t[x][y] |= not dfs(x-1, y-1)\n\n   \n\n    return t[x][y]\n\n    \n\nt = [[False]*7 for _ in range(7)]\n\n\n\nfor i in range(7):\n\n    for j in range(7):\n\n        dfs(i, j)\n\n\n\n\"\"\"\n\nfor ti in t:\n\n    print(*ti)\n\n\"\"\"\n\n\n\nN = int(eval(input()))\n\nflag = True\n\n\n\nfor _ in range(N):\n\n    a = int(eval(input()))\n\n    \n\n    if a%2==1:\n\n        flag = False\n\n        \n\nif flag:\n\n    print('second')\n\nelse:\n\n    print('first')", "generated_code": "import sys\n\ninput = sys.stdin.readline\n\n\n\n\"\"\"\n\ndef dfs(x, y):\n\n    if x==0 and y==0:\n\n        return False\n\n        \n\n    res = False\n\n    \n\n    if x>0:\n\n        res |= not dfs(x-1, y)\n\n    \n\n    if y>0:\n\n        res |= not dfs(x, y-1)\n\n    \n\n    if min(x, y)>0:\n\n        res |= not dfs(x-1, y-1)\n\n    \n\n    return res\n\n    \n\nt = [[False]*5 for _ in range(5)]\n\n\n\nfor i in range(5):\n\n    for j in range(5):\n\n        t[i][j] = dfs(i, j)\n\n\n\nfor ti in t:\n\n    print(*ti)\n\n\"\"\"\n\n\n\nN = int(eval(input()))\n\na = [int(eval(input())) for _ in range(N)]\n\n\n\nfor ai in a:\n\n    if ai%2==1:\n\n        print('first')\n\n        exit()\n\n\n\nprint('second')", "score": 1.0, "surface_similarity": 0.619428860838398}
{"id": "p03416_u094191970", "golden_code": "a,b=list(map(int, input().split()))\n\ncnt=0\n\nfor i in range(a,b+1):\n\n    n=list(str(i))\n\n    if n==list(reversed(n)):\n\n        cnt+=1\n\nprint(cnt)", "generated_code": "from sys import stdin\n\nnii=lambda:list(map(int,stdin.readline().split()))\n\nlnii=lambda:list(map(int,stdin.readline().split()))\n\n\n\na,b=nii()\n\nans=0\n\nfor i in range(a,b+1):\n\n  s=str(i)\n\n  if s==s[::-1]:\n\n    ans+=1\n\n\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.5523893805309734}
{"id": "p03416_u046187684", "golden_code": "a, b = list(map(int, input().strip().split(\" \")))\n\ncount = 0\n\nfor i in range(a, b + 1):\n\n    if str(i) == str(i)[::-1]:\n\n        count += 1\n\nprint(count)\n", "generated_code": "def solve(string):\n\n    a, b = list(map(int, string.split()))\n\n    count = 0\n\n    for i in range(a, b + 1):\n\n        if str(i) == str(i)[::-1]:\n\n            count += 1\n\n    return str(count)\n\n\n\n\n\nif __name__ == '__main__':\n\n    print((solve(eval(input()))))\n", "score": 1.0, "surface_similarity": 0.7417054263565892}
{"id": "p02624_u257162238", "golden_code": "import sys\n\ninput = sys.stdin.readline\n\nfrom collections import Counter\n\nimport numpy as np\n\nfrom numba import njit\n\n\n\n\n\ndef read():\n\n    N = int(input().strip())\n\n    return N,\n\n\n\n\n\n@njit\n\ndef f(n):\n\n    \"\"\"\n\n    約数の個数を求める\n\n    \"\"\"\n\n    ndivs = np.ones((n+1), dtype=np.int32)\n\n    for i in range(2, n+1):\n\n        for j in range(i, n+1, i):\n\n            ndivs[j] += 1\n\n    return ndivs\n\n\n\n\n\n@njit\n\ndef solve(N):\n\n    fn = f(N)\n\n    ans = 0\n\n    for k in range(1, N+1):\n\n        ans += k * fn[k]\n\n    return ans\n\n\n\n\n\nif __name__ == '__main__':\n\n    inputs = read()\n\n    outputs = solve(*inputs)\n\n    if outputs is not None:\n\n        print((\"%s\" % str(outputs)))\n", "generated_code": "import sys\n\ninput = sys.stdin.readline\n\nimport numpy as np\n\nfrom numba import njit\n\n\n\n\n\ndef read():\n\n    N = int(input().strip())\n\n    return N,\n\n\n\n\n\n@njit\n\ndef solve(N):\n\n    ndivs = 0\n\n    for i in range(1, N+1):\n\n        for j in range(i, N+1, i):\n\n            ndivs += j\n\n    return ndivs\n\n\n\n\n\nif __name__ == '__main__':\n\n    inputs = read()\n\n    outputs = solve(*inputs)\n\n    if outputs is not None:\n\n        print((\"%s\" % str(outputs)))\n", "score": 1.0, "surface_similarity": 0.8101062274632103}
{"id": "p02881_u581187895", "golden_code": "# a+b-2\n\n# N = a*b  よってNの約数を求める\n\nimport numpy as np\n\n\n\nN = int(eval(input()))\n\nU = 10**6+100\n\nx = np.arange(1, U, dtype=np.int64)\n\ndiv = x[N%x==0]\n\nans = (div + N//div).min() - 2\n\nprint(ans)", "generated_code": "import sys\n\nsys.setrecursionlimit(10 ** 7)\n\nread = sys.stdin.buffer.read \n\ninput = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines  \n\n\n\ndef make_divisors(n):\n\n    divisors = []\n\n    for i in range(1, int(n**0.5)+1):\n\n        if n % i == 0:\n\n            divisors.append((i, n//i))\n\n            \n\n    # divisors.sort()\n\n    return divisors\n\n\n\nN = int(eval(input()))\n\ndiv = make_divisors(N)\n\n\n\nans = 10**15\n\nfor a, b in div:\n\n  ans = min(ans, a+b-2)\n\nprint(ans)  \n\n\n", "score": 1.0, "surface_similarity": 0.5360013860013859}
{"id": "p02994_u254871849", "golden_code": "import sys\n\nimport numpy as np \n\n\n\nn, l = list(map(int, sys.stdin.readline().split()))\n\n\n\ndef main():\n\n    f = l + np.arange(1, n+1) - 1\n\n    s = f.sum()\n\n    a = np.absolute(f)\n\n    mi = np.amin(a)\n\n    i = np.argwhere(a == mi)[0, 0]\n\n    return s - f[i]\n\n\n\nif __name__ == '__main__':\n\n    ans = main()\n\n    print(ans)", "generated_code": "import sys\n\n\n\nn, l = list(map(int, sys.stdin.readline().split()))\n\n\n\ndef main():\n\n    s = (l - 1) * n + (1 + n) * n // 2\n\n    res = []\n\n    for i in range(1, n+1):\n\n        f = l + i - 1\n\n        res.append((abs(f), s - f))\n\n    \n\n    res.sort()\n\n    return res[0][1]\n\n\n\nif __name__=='__main__':\n\n    ans = main()\n\n    print(ans)", "score": 1.0, "surface_similarity": 0.7693909715186311}
{"id": "p02982_u580697892", "golden_code": "# coding: utf-8\n\nimport numpy as np\n\nn, d = list(map(int, input().split()))\n\ncnt = 0\n\nX = []\n\nfor i in range(n):\n\n    x = list(map(int, input().split()))\n\n    X.append(x[:])\n\nX = np.array(X)\n\nfor i in range(n):\n\n    X_tmp = X[:]\n\n    X_tmp -= X[i]\n\n    for i in range(n):\n\n        x = X_tmp[i]\n\n        x_sq = x**2\n\n        x_sq = np.sqrt(sum(x_sq))\n\n        if x_sq % 1 == 0:\n\n            cnt += 1\n\nprint(((cnt-n)//2))", "generated_code": "# coding: utf-8\n\nN, D = list(map(int, input().split()))\n\nX = []\n\nans = 0\n\nfor i in range(N):\n\n    X.append(list(map(int, input().split())))\n\nfor i in range(N):\n\n    for j in range(N):\n\n        dist = 0\n\n        if i == j:\n\n            continue\n\n        for d in range(D):\n\n            dist += ((X[i][d] - X[j][d])**2)\n\n        if dist**0.5 == int(dist**0.5):\n\n            ans += 1\n\nprint((ans//2))", "score": 1.0, "surface_similarity": 0.7305233549266962}
{"id": "p02647_u228223940", "golden_code": "import copy\n\nn,k = list(map(int,input().split()))\n\nai = [int(i) for i in input().split()]\n\n\n\nold_ai = ai\n\ncnt = 0\n\n\n\nwhile 1 == 1:\n\n    old_ai = copy.deepcopy(ai)\n\n    li = [0]*(n+1)\n\n    for i in range(n):\n\n        li[max(0,i-ai[i])] += 1\n\n        li[min(n,i+1+ai[i])] -= 1\n\n        #print(li)\n\n    #print(li)\n\n    tmp = 0\n\n    for i in range(n):\n\n        if i == 0:\n\n            ai[i] = li[i]\n\n            tmp += ai[i]\n\n        else:\n\n            ai[i] = li[i] + ai[i-1]\n\n            tmp += ai[i]\n\n    #print(rui)\n\n    if ai == old_ai:\n\n        print((*ai))\n\n        exit()\n\n        break\n\n    cnt += 1\n\n    if cnt == k:\n\n        print((*ai))\n\n        exit()\n\n    old_ai = ai", "generated_code": "import copy\n\nn,k = list(map(int,input().split()))\n\nai = [int(i) for i in input().split()]\n\n\n\n#old_ai = ai\n\ncnt = 0\n\nold_tmp = sum(ai)\n\n\n\nwhile 1 == 1:\n\n    #old_ai = copy.deepcopy(ai)\n\n    li = [0]*(n+1)\n\n    for i in range(n):\n\n        li[max(0,i-ai[i])] += 1\n\n        li[min(n,i+1+ai[i])] -= 1\n\n        #print(li)\n\n    #print(li)\n\n    tmp = 0\n\n    for i in range(n):\n\n        if i == 0:\n\n            ai[i] = li[i]\n\n            tmp += ai[i]\n\n        else:\n\n            ai[i] = li[i] + ai[i-1]\n\n            tmp += ai[i]\n\n    #print(rui)\n\n    if old_tmp == tmp:\n\n        print((*ai))\n\n        exit()\n\n        break\n\n    cnt += 1\n\n    if cnt == k:\n\n        print((*ai))\n\n        exit()\n\n    old_tmp = tmp", "score": 1.0, "surface_similarity": 0.957977207977208}
{"id": "p03078_u952708174", "golden_code": "def d_cake_123_binary_search(X, Y, Z, K, A, B, C):\n\n    # editionalの解法4 O(K^2log(max(P))\n\n    # 参考: https://atcoder.jp/contests/abc123/submissions/4871511\n\n    import bisect\n\n    ab = sorted([e1 + e2 for e2 in B for e1 in A])  # A, Bの要素は全部調べる\n\n\n\n    # rejected 以上の値は、美味しさの合計がそれ以上である個数がK個未満である\n\n    accepted, rejected = -1, 10**11\n\n    while abs(accepted - rejected) > 1:\n\n        mid = (accepted + rejected) // 2\n\n        count = sum([len(ab) - bisect.bisect_left(ab, mid - e) for e in C])\n\n        if count >= K:\n\n            accepted = mid\n\n        else:\n\n            rejected = mid\n\n\n\n    ans = []\n\n    for e in C:\n\n        idx = bisect.bisect_left(ab, accepted - e)\n\n        for i in range(idx, len(ab)):\n\n            ans.append(e + ab[i])\n\n    ans.sort(reverse=True)\n\n    return '\\n'.join(map(str, ans[:K]))\n\n\n\nX, Y, Z, K = [int(i) for i in input().split()]\n\nA = [int(i) for i in input().split()]\n\nB = [int(i) for i in input().split()]\n\nC = [int(i) for i in input().split()]\n\nprint((d_cake_123_binary_search(X, Y, Z, K, A, B, C)))", "generated_code": "def d_cake_123_sort_modified():\n\n    \"\"\"editorial の解法 1.\"\"\"\n\n    import sys\n\n    import numpy as np\n\n    input = sys.stdin.readline\n\n    X, Y, Z, K = [int(i) for i in input().split()]\n\n    A = np.array([int(i) for i in input().split()])\n\n    B = np.array([int(i) for i in input().split()])\n\n    C = np.array([int(i) for i in input().split()])\n\n\n\n    _a, _b = np.meshgrid(A, B)\n\n    ab = np.sort((_a + _b).flatten())[::-1][:K]\n\n    _ab, _c = np.meshgrid(ab, C)\n\n    ans = np.sort((_ab + _c).flatten())[::-1][:K]\n\n    return '\\n'.join(map(str, ans))\n\n\n\nprint((d_cake_123_sort_modified()))", "score": 1.0, "surface_similarity": 0.5904589371980676}
{"id": "p03796_u257974487", "golden_code": "import math\n\nN = int(eval(input()))\n\np = math.factorial(N)\n\nprint((p % 1000000007))", "generated_code": "N = int(eval(input()))\n\np = 1\n\nfor i in range(1,N+1):\n\n    p *= i\n\n    p %= 1000000007\n\nprint(p)\n", "score": 1.0, "surface_similarity": 0.5621588841722256}
{"id": "p03608_u577170763", "golden_code": "import itertools\n\nfrom scipy.sparse.csgraph import floyd_warshall\n\n\n\nN, M, R = list(map(int, input().split()))\n\nr = tuple(map(int, input().split()))\n\n\n\nINF = 10**10\n\n\n\nd = [[INF] * N for _ in range(N)]\n\n\n\nfor i in range(N):\n\n    d[i][i] = 0\n\n\n\nfor _ in range(M):\n\n    a, b, c = list(map(int, input().split()))\n\n    a -= 1\n\n    b -= 1\n\n    if d[a][b] > c:\n\n        d[a][b] = c\n\n        d[b][a] = c\n\n\n\n\n\ndef warshall(d):\n\n    for k in range(N):\n\n        for i in range(N):\n\n            for j in range(N):\n\n                if d[i][j] > d[i][k] + d[k][j]:\n\n                    d[i][j] = d[i][k] + d[k][j]\n\n\n\n\n\n# d = floyd_warshall(d)\n\nwarshall(d)\n\n\n\n\n\nans = INF\n\nfor p in itertools.permutations(r):\n\n    dist = 0\n\n    for i in range(R-1):\n\n        dist += d[p[i]-1][p[i+1]-1]\n\n\n\n    if ans > dist:\n\n        ans = dist\n\n\n\nprint((int(ans)))", "generated_code": "import itertools\n\n\n\nN, M, R = list(map(int, input().split()))\n\nr = tuple(map(int, input().split()))\n\n\n\nINF = 10**10\n\n\n\nd = [[INF] * N for _ in range(N)]\n\n\n\nfor i in range(N):\n\n    d[i][i] = 0\n\n\n\nfor _ in range(M):\n\n    a, b, c = list(map(int, input().split()))\n\n    a -= 1\n\n    b -= 1\n\n    if d[a][b] > c:\n\n        d[a][b] = c\n\n        d[b][a] = c\n\n\n\n\n\ndef warshall(d):\n\n    for k in range(N):\n\n        for i in range(N):\n\n            for j in range(N):\n\n                if d[i][j] > d[i][k] + d[k][j]:\n\n                    d[i][j] = d[i][k] + d[k][j]\n\n\n\n\n\n# d = floyd_warshall(d)\n\nwarshall(d)\n\n\n\n\n\nans = INF\n\nfor p in itertools.permutations(r):\n\n    dist = 0\n\n    for i in range(R-1):\n\n        dist += d[p[i]-1][p[i+1]-1]\n\n\n\n    if ans > dist:\n\n        ans = dist\n\n\n\nprint((int(ans)))\n", "score": 1.0, "surface_similarity": 0.9568925504757484}
{"id": "p02891_u381572531", "golden_code": "import sys\n\ninput = sys.stdin.readline\n\n \n\ns = input().rstrip()\n\nk = int(eval(input()))\n\n    \n\ndef check_count(s):\n\n    cnt_list = [1]\n\n    cnt = 1\n\n    for i in range(1, len(s)):\n\n        if s[i-1] == s[i]:\n\n            cnt_list[-1] += 1\n\n        else:\n\n            cnt_list.append(1)\n\n    return cnt_list\n\n\n\ndef calc_ans(cnt_list, k):\n\n    _ans = 0\n\n    for c in cnt_list:\n\n        _ans += c//2\n\n    return(_ans * k)\n\n\n\nif len(s)==1:\n\n    ans = k//2\n\nelse:\n\n    cnt_list = check_count(s)\n\n    if len(cnt_list)==1:\n\n        ans = (len(s)*k)//2\n\n    else:\n\n        ans = calc_ans(cnt_list, k)\n\n        if s[0]==s[-1]:\n\n            if cnt_list[0]%2==1 and cnt_list[-1]%2==1:\n\n                ans += k - 1\n\n\n\nprint(ans)", "generated_code": "import sys\n\ninput = sys.stdin.readline\n\n \n\ns = input().rstrip()\n\nk = int(eval(input()))\n\n\n\ndef check_count(s):\n\n    cnt_list = []\n\n    cnt = 1\n\n    for i in range(1, len(s)):\n\n        if s[i-1] == s[i]:\n\n            cnt += 1\n\n        else:\n\n            cnt_list.append(cnt)\n\n            cnt = 1\n\n    if cnt>1:\n\n        cnt_list.append(cnt)\n\n    return cnt_list\n\n\n\ndef calc_ans(cnt_list, k):\n\n    _ans = 0\n\n    for c in cnt_list:\n\n        _ans += c//2\n\n    return(_ans * k)\n\n\n\nif len(s)==1:\n\n    ans = k//2\n\nelse:\n\n    cnt_list = check_count(s)\n\n    if len(cnt_list)==1:\n\n        ans = (len(s)*k)//2\n\n    else:\n\n        ans = calc_ans(cnt_list, k)\n\n        if s[0]==s[-1]:\n\n            if cnt_list[0]%2==1 and cnt_list[-1]%2==1:\n\n                ans += k - 1\n\n\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.9593537804226748}
{"id": "p02881_u706929073", "golden_code": "N = int(eval(input()))\n\n\n\n\n\ndef dist(i, j):\n\n    return i + j - 2\n\n\n\n\n\nmin = 10 ** 24\n\ni = 1\n\nwhile (i ** 2) <= N:\n\n    if 0 == N % i:\n\n        j = N // i\n\n        d = dist(i, j)\n\n        if min > d:\n\n            min = d\n\n    i += 1\n\nprint(d)\n", "generated_code": "import math\n\nn = int(eval(input()))\n\n\n\nans = 0\n\nfor i in range(math.ceil(math.sqrt(n) + 1))[:0:-1]:\n\n    if 0 == n % i:\n\n        ans = i\n\n        break\n\nans_partner = n // ans\n\nprint((ans + ans_partner - 2))\n", "score": 1.0, "surface_similarity": 0.5027838295812153}
{"id": "p02690_u127499732", "golden_code": "def main():\n\n    x = int(eval(input()))\n\n    for i in range(150, 0, -1):\n\n        for j in range(i, -150, -1):\n\n            cal = i ** 5 - j ** 5\n\n            if cal == x:\n\n                print((i, j))\n\n                exit()\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "generated_code": "def main():\n\n    x = int(eval(input()))\n\n    for i in range(120):\n\n        for j in range(i, -i, -1):\n\n            cal = i ** 5 - j ** 5\n\n            if cal == x:\n\n                print((i, j))\n\n                exit()\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 1.0, "surface_similarity": 0.9833948339483395}
{"id": "p02552_u222668979", "golden_code": "n = int(eval(input()))\n\nprint((1 if n == 0 else 0))\n", "generated_code": "n = int(eval(input()))\n\nprint((0 if n else 1))\n", "score": 1.0, "surface_similarity": 0.861013986013986}
{"id": "p02792_u564589929", "golden_code": "import sys\n\nsys.setrecursionlimit(10 ** 6)\n\n# input = sys.stdin.readline    ####\n\nint1 = lambda x: int(x) - 1\n\ndef II(): return int(eval(input()))\n\n\n\ndef MI(): return list(map(int, input().split()))\n\ndef MI1(): return list(map(int1, input().split()))\n\n\n\ndef LI(): return list(map(int, input().split()))\n\ndef LI1(): return list(map(int1, input().split()))\n\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\n\n\n\ndef printlist(lst, k='\\n'): print((k.join(list(map(str, lst)))))\n\nINF = float('inf')\n\n\n\nimport numpy as np\n\n\n\ndef solve():\n\n    n = II()\n\n    D = np.zeros((10, 10))\n\n\n\n    for i in range(1, n+1):\n\n        s = list(str(i))\n\n        l = int(s[0])\n\n        r = int(s[-1])\n\n        # print(s, l, r)\n\n        D[l][r] += 1\n\n    # print(D)\n\n\n\n    ans = 0\n\n    for i in range(10):\n\n        for j in range(10):\n\n            ans += D[i][j] * D[j][i]\n\n    print((int(ans)))\n\n\n\nif __name__ == '__main__':\n\n    solve()\n", "generated_code": "import sys\n\nsys.setrecursionlimit(10 ** 6)\n\n# input = sys.stdin.readline    ####\n\nint1 = lambda x: int(x) - 1\n\ndef II(): return int(eval(input()))\n\n\n\ndef MI(): return list(map(int, input().split()))\n\ndef MI1(): return list(map(int1, input().split()))\n\n\n\ndef LI(): return list(map(int, input().split()))\n\ndef LI1(): return list(map(int1, input().split()))\n\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\n\n\n\ndef printlist(lst, k='\\n'): print((k.join(list(map(str, lst)))))\n\nINF = float('inf')\n\n\n\ndef solve():\n\n    n = II()\n\n    D = [[0]*10 for _ in range(10)]\n\n\n\n    for i in range(1, n+1):\n\n        s = list(str(i))\n\n        l = int(s[0])\n\n        r = int(s[-1])\n\n        # print(s, l, r)\n\n        D[l][r] += 1\n\n    # print(D)\n\n\n\n    ans = 0\n\n    for i in range(10):\n\n        for j in range(10):\n\n            ans += D[i][j] * D[j][i]\n\n    print((int(ans)))\n\n\n\nif __name__ == '__main__':\n\n    solve()\n", "score": 1.0, "surface_similarity": 0.9517507756601026}
{"id": "p03039_u747602774", "golden_code": "import sys\n\nreadline = sys.stdin.readline\n\nsys.setrecursionlimit(10**8)\n\nmod = 10**9+7\n\n#mod = 998244353\n\nINF = 10**18\n\neps = 10**-7\n\n\n\nm,n,k = list(map(int,readline().split()))\n\n\n\ndef comb(n, r, mod):\n\n    r = min(r, n-r)\n\n    mol = 1\n\n    deno = 1\n\n    for i in range(1, r+1):\n\n        mol = mol * (n-r+i) % mod\n\n        deno = deno * i % mod\n\n    ret = mol * pow(deno, mod-2, mod) % mod\n\n    return ret\n\n\n\ndef f1(x,y,a,b):\n\n    return (a+b-x-y)*(a-x+1)*(b-y+1)//2\n\n\n\ndef f2(x,a):\n\n    return (a-x)*(a-x+1)//2\n\n\n\nans = 0\n\n\n\nfor x in range(1,n+1):\n\n    for y in range(1,m+1):\n\n        ans += f1(x,y,n,m)+f1(1,1,x,y)+f1(1,y,x,m)+f1(x,1,n,y)\n\n        ans -= f2(x,n) + f2(1,x) + f2(1,y) + f2(y,m)\n\n        ans %= mod\n\n\n\nans = (ans * comb(m*n-2,k-2,mod))%mod\n\nans = ans*pow(2,mod-2,mod)%mod\n\n\n\nprint(ans)\n", "generated_code": "import sys\n\nreadline = sys.stdin.readline\n\nsys.setrecursionlimit(10**8)\n\nmod = 10**9+7\n\n#mod = 998244353\n\nINF = 10**18\n\neps = 10**-7\n\n\n\nm,n,k = list(map(int,readline().split()))\n\n\n\ndef comb(n, r, mod):\n\n    r = min(r, n-r)\n\n    mol = 1\n\n    deno = 1\n\n    for i in range(1, r+1):\n\n        mol = mol * (n-r+i) % mod\n\n        deno = deno * i % mod\n\n    ret = mol * pow(deno, mod-2, mod) % mod\n\n    return ret\n\n\n\ndef f1(x,y,a,b):\n\n    return (a+b-x-y)*(a-x+1)*(b-y+1)//2\n\n\n\ndef f2(x,a):\n\n    return (a-x)*(a-x+1)//2\n\n\n\nans = 0\n\n\n\nfor x in range(1,n+1):\n\n    for y in range(1,m+1):\n\n        a = n-x+1\n\n        b = m-y+1\n\n        c = m*(a*(a-1)+x*(x-1))\n\n        d = n*(b*(b-1)+y*(y-1))\n\n        ans += (c+d)//2\n\n        ans %= mod\n\n\n\nans = (ans * comb(m*n-2,k-2,mod))%mod\n\nans = ans*pow(2,mod-2,mod)%mod\n\n\n\nprint(ans)\n\n\n", "score": 1.0, "surface_similarity": 0.9564417177914111}
{"id": "p02596_u952708174", "golden_code": "def c_repsept():\n\n    K = int(eval(input()))\n\n\n\n    if (K % 2 == 0 or K % 5 == 0):\n\n        return -1  # repsept の因数に 2, 5 はない\n\n\n\n    repsept = 7 % K\n\n    count = 1\n\n    while repsept % K !=0:\n\n        repsept = ((repsept * 10) + 7) % K\n\n        count += 1\n\n    return count\n\n\n\nprint((c_repsept()))", "generated_code": "def c_repsept():\n\n    K = int(eval(input()))\n\n\n\n    L = 9 * K // 7 if K % 7 == 0 else 9 * K\n\n    if L % 2 == 0 or L % 5 == 0:\n\n        return -1\n\n\n\n    remainder = 1\n\n    for n in range(1, L + 1):\n\n        remainder = (10 * remainder) % L\n\n        if remainder == 1:\n\n            return n\n\n    return -1\n\n\n\nprint((c_repsept()))", "score": 1.0, "surface_similarity": 0.7460681520314547}
{"id": "p02886_u821588465", "golden_code": "from itertools import combinations\n\nimport numpy as np\n\nN = int(eval(input()))\n\nD = list(map(int, input().split()))\n\nList = np.array(list(combinations(D,2)))\n\nprint((sum(np.product(List, axis = 1))))\n\n\n\n\n", "generated_code": "N = int(eval(input()))\n\nD = list(map(int, input().split()))\n\nfrom itertools import accumulate\n\nprint((sum(list(d*c for d, c in zip(D[1:], accumulate(D))))))\n", "score": 1.0, "surface_similarity": 0.4931372549019608}
{"id": "p03013_u827885761", "golden_code": "import sys\n\nsys.setrecursionlimit(10**7)\n\ndef lmi(): return list(map(int, input().split()))\n\n\n\nn, m = lmi()\n\n\n\nl = [0] * (n+1)\n\nl[0] = 1\n\n\n\na = 0\n\nif m != 0:\n\n    a = int(eval(input()))\n\nk = 1\n\nfor i in range(n+1):\n\n\n\n    if i != a:\n\n        if i == 1:\n\n            l[i] = 1\n\n        elif i >= 2:\n\n            l[i] = l[i-1] + l[i-2]\n\n            l[i] %= 1000000007\n\n    else:\n\n        k += 1\n\n        if k <= m:\n\n            a = int(eval(input()))\n\n\n\n\n\n\n\n#print(l)\n\nprint((l[n] % 1000000007))\n", "generated_code": "import sys\n\nsys.setrecursionlimit(10**7)\n\ndef lmi(): return list(map(int, input().split()))\n\n\n\nn, m = lmi()\n\na = [1] * (n+1)\n\nfor i in range(m):\n\n    a[int(eval(input()))] = 0\n\nk = [0] * (n+1)\n\nk[0] = 1\n\nfor i in range(1,n+1):\n\n    if i == 1 and a[1]:\n\n        k[1] = 1\n\n    elif i >= 2 and a[i]:\n\n        k[i] = k[i-1] + k[i-2]\n\n        k[i] %= 10 ** 9 + 7\n\n\n\nprint((k[n]))\n", "score": 1.0, "surface_similarity": 0.8194726166328601}
{"id": "p02767_u952708174", "golden_code": "def c_rally():\n\n    import numpy as np\n\n    import math\n\n    N = int(eval(input()))\n\n    X = [int(i) for i in input().split()]\n\n    m = np.average(X)\n\n    ans = float('inf')\n\n    for j in (math.floor(m), math.ceil(m)):\n\n        ans = min(ans, sum([(x - j)**2 for x in X]))\n\n    return ans\n\n\n\nprint((c_rally()))", "generated_code": "def c_rally():\n\n    N = int(eval(input()))\n\n    X = [int(i) for i in input().split()]\n\n\n\n    x_sum = sum(X)\n\n    option = (x_sum // N, (x_sum + N - 1) // N)\n\n    return min(sum([(x - p)**2 for x in X]) for p in option)\n\n\n\nprint((c_rally()))", "score": 1.0, "surface_similarity": 0.7056451612903226}
{"id": "p03013_u282228874", "golden_code": "N,M = list(map(int,input().split()))\n\nMOD = 10**9+7\n\ndp = [0]*(N+1)\n\ndp[0]=1\n\nA = [int(eval(input())) for i in range(M)]\n\nban = [1]*(N+1)\n\nfor a in A:\n\n    ban[a]=0\n\nfor i in range(N):\n\n    if i-1>=0:\n\n        dp[i+1]=dp[i]*ban[i]+dp[i-1]*ban[i-1]\n\n    else:\n\n        dp[i+1]=dp[i]*ban[i]\n\n    dp[i+1] %= MOD \n\nprint((dp[N]))", "generated_code": "N,M = list(map(int,input().split()))\n\nA = [int(eval(input())) for i in range(M)]\n\nMOD = 10**9+7\n\nA = set(A)\n\ndp = [0]*(N+1)\n\ndp[0] = 1\n\nfor i in range(1,N+1):\n\n    if i in A:\n\n        continue\n\n    if i == 1:\n\n        dp[1] = dp[0]\n\n    else:\n\n        dp[i] = (dp[i-1]+dp[i-2])%MOD\n\nprint((dp[N]))", "score": 1.0, "surface_similarity": 0.7307161803713528}
{"id": "p03253_u069838609", "golden_code": "from math import sqrt, ceil, factorial\n\nfrom collections import defaultdict\n\n\n\n\n\ndef prime_factors(n):\n\n    i = 2\n\n    factors = defaultdict(int)\n\n    while i * i <= n:\n\n        if n % i:\n\n            i += 1\n\n        else:\n\n            n //= i\n\n            factors[i] += 1\n\n    if n > 1:\n\n        factors[n] += 1\n\n    return factors\n\n\n\n\n\nN, M = [int(elem) for elem in input().split(' ')]\n\n\n\n# 素因数分解\n\nprime_numbers = prime_factors(M)\n\nsum = 1\n\nfac_N_m1 = factorial(N - 1)\n\n\n\nfor value in list(prime_numbers.values()):\n\n    bunshi = 1\n\n    saisho = value + N - 1\n\n    for _ in range(value):\n\n        bunshi *= saisho\n\n        saisho -= 1\n\n    sum *= (bunshi // factorial(value))\n\nprint((sum % (10**9 + 7)))\n", "generated_code": "from collections import defaultdict\n\n\n\n\n\ndef prime_factorize(num):\n\n    prime_numbers = defaultdict(int)\n\n    i = 2\n\n    while i * i <= num:\n\n        if num % i == 0:\n\n            while num % i == 0:\n\n                prime_numbers[i] += 1\n\n                num //= i\n\n        i += 1\n\n    if num != 1:\n\n        prime_numbers[num] += 1\n\n    return prime_numbers\n\n\n\n\n\nMOD = 10**9 + 7\n\nN, M = [int(elem) for elem in input().split()]\n\n\n\nprime_numbers = prime_factorize(M)\n\n\n\nnum_sequences = 1\n\nfor exponent in list(prime_numbers.values()):\n\n    denomimator = 1\n\n    numerator = 1\n\n    for i in range(1, exponent + 1):\n\n        denomimator *= (N + exponent - i)\n\n        numerator *= i\n\n    num_sequences *= denomimator // numerator\n\n    num_sequences %= MOD\n\n\n\nprint(num_sequences)\n", "score": 1.0, "surface_similarity": 0.7682560137457044}
{"id": "p03371_u562935282", "golden_code": "def main():\n\n    A, B, AB, X, Y = list(map(int, input().split()))\n\n    M = max(X, Y)\n\n\n\n    k = 0\n\n    ans = A * X + B * Y\n\n    while True:\n\n        ans = min(\n\n            ans,\n\n            AB * k * 2 + max(0, X - k) * A + max(0, Y - k) * B\n\n        )\n\n\n\n        if k >= M: break\n\n        k += 1\n\n\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "generated_code": "def main():\n\n    A, B, C, X, Y = list(map(int, input().split()))\n\n\n\n    ans = 1 << 30\n\n    c = 0  # even\n\n    while True:\n\n        j = c // 2\n\n        t = A * max(0, X - j) + B * max(0, Y - j) + C * c\n\n        if ans <= t: break\n\n        ans = t\n\n        c += 2\n\n\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 1.0, "surface_similarity": 0.8353331904863939}
{"id": "p02245_u072053884", "golden_code": "import sys\n\n\n\ninit = ''.join(sys.stdin.read().split())\n\n\n\n# Bidirectional search using breadth-first search\n\ndef solve(start, goal):\n\n    if start == goal:\n\n        return 0\n\n    generated_state = {start: 0, goal: 1}   # 0: foreward, 1: backward\n\n    step = {start: 0, goal: 0}\n\n    s = 0\n\n    c_d = [(start, 0), (goal, 1)] # configure and direction\n\n    while True:\n\n        q = iter(c_d)\n\n        c_d = []\n\n        s += 1\n\n        for c, d in q:\n\n            i = c.find('0')\n\n            if 0 <= i <= 5:\n\n                t = str.maketrans('0' + c[i+3], c[i+3] + '0')\n\n                t_c = c.translate(t)\n\n                if t_c in generated_state:\n\n                    if generated_state[t_c] != d:\n\n                        return s + step[t_c]\n\n                else:\n\n                    generated_state[t_c] = d\n\n                    step[t_c] = s\n\n                    c_d.append((t_c, d))\n\n            if i >= 3:\n\n                t = str.maketrans('0' + c[i-3], c[i-3] + '0')\n\n                t_c = c.translate(t)\n\n                if t_c in generated_state:\n\n                    if generated_state[t_c] != d:\n\n                        return s + step[t_c]\n\n                else:\n\n                    generated_state[t_c] = d\n\n                    step[t_c] = s\n\n                    c_d.append((t_c, d))\n\n            if i == 0 or i == 1 or i == 3 or i == 4 or i == 6 or i == 7:\n\n                t = str.maketrans('0' + c[i+1], c[i+1] + '0')\n\n                t_c = c.translate(t)\n\n                if t_c in generated_state:\n\n                    if generated_state[t_c] != d:\n\n                        return s + step[t_c]\n\n                else:\n\n                    generated_state[t_c] = d\n\n                    step[t_c] = s\n\n                    c_d.append((t_c, d))\n\n            if i == 1 or i == 2 or i == 4 or i == 5 or i == 7 or i == 8:\n\n                t = str.maketrans('0' + c[i-1], c[i-1] + '0')\n\n                t_c = c.translate(t)\n\n                if t_c in generated_state:\n\n                    if generated_state[t_c] != d:\n\n                        return s + step[t_c]\n\n                else:\n\n                    generated_state[t_c] = d\n\n                    step[t_c] = s\n\n                    c_d.append((t_c, d))\n\n\n\nprint((solve(init, '123456780')))", "generated_code": "adjacent = (\n\n    (1, 3),       # 0\n\n    (0, 2, 4),    # 1\n\n    (1, 5),       # 2\n\n    (0, 4, 6),    # 3\n\n    (1, 3, 5, 7), # 4\n\n    (2, 4, 8),    # 5\n\n    (3, 7),       # 6\n\n    (4, 6, 8),    # 7\n\n    (5, 7)        # 8\n\n)\n\n\n\nimport collections\n\n\n\nGOAL = [1, 2, 3, 4, 5, 6, 7, 8, 0]\n\n\n\n# Bidirectional search using breadth-first search\n\ndef solve(start):\n\n    if start == GOAL:\n\n        return 0\n\n    # 0: forward, 1: backward\n\n    generated_state = {tuple(start): 0, tuple(GOAL): 1}\n\n    step = {tuple(start): 0, tuple(GOAL): 0}\n\n    s = 0\n\n    state1 = [(start, 0), (GOAL, 1)]\n\n    while state1:\n\n        state2 = state1[:]\n\n        state1 = []\n\n        s += 1\n\n        for s2, d in state2:\n\n            i = s2.index(0)\n\n            for p in adjacent[i]:\n\n                s1 = s2[:]\n\n                s1[i], s1[p] = s1[p], 0\n\n                key = tuple(s1)\n\n                if key in generated_state:\n\n                    if generated_state[key] != d:\n\n                        return s + step[key]\n\n                    continue\n\n                state1.append((s1, d))\n\n                generated_state[key] = d\n\n                step[key] = s\n\n\n\nimport sys\n\n\n\nstart = list(map(int, sys.stdin.read().split()))\n\n\n\nprint((solve(start)))", "score": 1.0, "surface_similarity": 0.7224839579208511}
{"id": "p03434_u034782764", "golden_code": "import numpy as np\n\n\n\nn=int(eval(input()))\n\na_list=list(map(int,input().split()))\n\na_list_2=sorted(a_list,reverse=True)\n\na=np.array(a_list_2,dtype='uint8')\n\n\n\nalice=0\n\nbob=0\n\nfor i in range(n):\n\n\tif i%2==0:\n\n\t\talice+=a[i]\n\n\telse:\n\n\t\tbob+=a[i]\n\n\n\nprint((alice-bob))\n", "generated_code": "n=int(eval(input()))\n\na=list(map(int,input().split()))\n\na.sort(reverse=True)\n\n\n\nalice=0\n\nbob=0\n\n\n\nfor i in range(n):\n\n    if i%2==0:\n\n        alice+=a[i]\n\n    else:\n\n        bob+=a[i]\n\n        \n\nprint((alice-bob))", "score": 1.0, "surface_similarity": 0.818785890073831}
{"id": "p02837_u021019433", "golden_code": "def popcount(x):\n\n  r, q = 0, x\n\n  while x:\n\n    r += 1\n\n    x &= x - 1\n\n  return r, q\n\n \n\nn = int(eval(input()))\n\nr = list(range(n))\n\na = [[0, 0] for _ in r]\n\nfor i in r:\n\n  for _ in range(int(eval(input()))):\n\n    x, y = list(map(int, input().split()))\n\n    a[i][y] |= 1 << (x - 1)\n\nl = (1 << n) - 1 \n\nb = sorted(map(popcount, list(range(1, l + 1))))\n\nans = next((i for i, x in reversed(b)\n\n           if all(a[j][0] & x == a[j][1] & l - x == 0 for j in r if x >> j & 1)), 0)\n\nprint(ans)\n", "generated_code": "from itertools import combinations, count\n\n \n\nn = int(eval(input()))\n\nr = list(range(n))\n\na = [(set(), set()) for _ in r]\n\nfor i in r:\n\n  for _ in range(int(eval(input()))):\n\n    x, y = list(map(int, input().split()))\n\n    a[i][y].add(x - 1)\n\nr = next(i for i in count(n, - 1) for x in map(set, combinations(r, i))\n\n         if all(a[j][0].isdisjoint(x) and a[j][1] < x for j in x))\n\nprint(r)\n", "score": 1.0, "surface_similarity": 0.5772632129774987}
{"id": "p02555_u836939578", "golden_code": "S = int(eval(input()))\n\nMOD = 10 ** 9 + 7\n\n\n\n#dp[i]最後に切った場所がi　スタートが1なのは、そこまでの切り方が1通りなので\n\n#３以下はダメなので、3個前の結果を見るようにする\n\ndp =  [0] * (S+1)\n\ndp[0] = 1\n\n\n\nfor i in range(1, S+1):\n\n    #たとえばi=6のとき、i=6で初めて切れ目を入れる時で＋１、i=3に切れ目をいれるときで＋１で合計＋２\n\n    for j in range(0, (i-3)+1):\n\n        dp[i] += dp[j]\n\n        dp[i] %= MOD\n\nprint((dp[S]))        ", "generated_code": "S = int(eval(input()))\n\nMOD = 10 ** 9 + 7\n\n\n\n#dp[i]最後に切った場所がi　スタートが1なのは、そこまでの切り方が1通りなので\n\n#３以下はダメなので、3個前の結果を見るようにする\n\ndp =  [0] * (S+1)\n\ndp[0] = 1\n\n\n\n#これまでの和をxに保存しておく\n\nx = 0\n\nfor i in range(1, S+1):\n\n    if i-3 >= 0:\n\n        x += dp[i-3]\n\n        x %= MOD\n\n    dp[i] = x\n\nprint((dp[S]))        ", "score": 1.0, "surface_similarity": 0.8745892661555312}
{"id": "p03634_u562935282", "golden_code": "# bellman_ford : O(V E)\n\n# dijkstra : O(E log V), 負辺は無理\n\n# warshall_floyd : O(V**3)\n\n\n\nimport sys\n\n\n\nsys.setrecursionlimit(10 ** 7)\n\ninput = sys.stdin.readline\n\n\n\n\n\ndef solve():\n\n    inf = 10 ** 14 + 10\n\n\n\n    def dfs(v: 'vertex_index, 0-indexed') -> None:\n\n        for c, t in e[v]:\n\n            if d[t] != inf:\n\n                continue\n\n            d[t] = d[v] + c\n\n            dfs(t)\n\n\n\n    n = int(eval(input()))\n\n    e = tuple(set() for _ in range(n))\n\n    for _ in range(n - 1):\n\n        a, b, c = list(map(int, input().split()))\n\n        a -= 1\n\n        b -= 1\n\n        e[a].add((c, b))\n\n        e[b].add((c, a))\n\n\n\n    q, v = list(map(int, input().split()))\n\n    v -= 1\n\n\n\n    d = [inf] * n\n\n    d[v] = 0\n\n\n\n    dfs(v)\n\n\n\n    for _ in range(q):\n\n        x, y = list(map(int, input().split()))\n\n        x -= 1\n\n        y -= 1\n\n        print((d[x] + d[y]))\n\n\n\n\n\nif __name__ == '__main__':\n\n    solve()\n", "generated_code": "# bellman_ford : O(V E)\n\n# dijkstra : O(E log V), 負辺は無理\n\n# warshall_floyd : O(V**3)\n\n# deque\n\n\n\nfrom collections import deque\n\nimport sys\n\n\n\ninput = sys.stdin.readline\n\n\n\n\n\ndef solve():\n\n    inf = 10 ** 14 + 10\n\n\n\n    n = int(eval(input()))\n\n    e = tuple(set() for _ in range(n))\n\n    for _ in range(n - 1):\n\n        a, b, c = list(map(int, input().split()))\n\n        a -= 1\n\n        b -= 1\n\n        e[a].add((c, b))\n\n        e[b].add((c, a))\n\n\n\n    q, v = list(map(int, input().split()))\n\n    v -= 1\n\n\n\n    d = [inf] * n\n\n    d[v] = 0\n\n\n\n    dq = deque()\n\n    for cost, to in e[v]:\n\n        dq.append((cost, to, v))\n\n        # (cost, to, parent)\n\n\n\n    while dq:\n\n        c, v, p = dq.popleft()\n\n        if d[v] != inf:\n\n            continue\n\n        d[v] = d[p] + c\n\n        for cost, to in e[v]:\n\n            if to == p:\n\n                continue\n\n            dq.append((cost, to, v))\n\n            \n\n    for _ in range(q):\n\n        x, y = list(map(int, input().split()))\n\n        x -= 1\n\n        y -= 1\n\n        print((d[x] + d[y]))\n\n\n\n\n\nif __name__ == '__main__':\n\n    solve()\n", "score": 1.0, "surface_similarity": 0.8181744046971839}
{"id": "p03634_u228223940", "golden_code": "import queue\n\nn = int(eval(input()))\n\n\n\nabc = [[] for i in range(n+1)]\n\n\n\nfor i in range(n-1):\n\n    a,b,c = list(map(int,input().split()))\n\n    abc[a].append([b,c])\n\n    abc[b].append([a,c])\n\n\n\nQ,k = list(map(int,input().split()))\n\nxy = [[int(i) for i in input().split()] for j in range(Q)]\n\n\n\nq = queue.Queue()\n\n\n\nq.put(k)\n\n\n\npath = [-1]*(n+1)\n\npath[k] = 0\n\n\n\nwhile not q.empty():\n\n    tmp = q.get()\n\n    for i in range(len(abc[tmp])):\n\n        #print(abc[tmp])\n\n        #exit()\n\n        num = abc[tmp][i][0]\n\n        if path[num] != -1:\n\n            continue\n\n        else:\n\n            path[num] = path[tmp] + abc[tmp][i][1]\n\n            q.put(num)\n\n            \n\nfor i in range(Q):\n\n    print((path[xy[i][0]]+path[xy[i][1]]))", "generated_code": "import queue\n\nimport sys\n\nsys.setrecursionlimit(10**7)\n\nn = int(eval(input()))\n\n\n\nabc = [[] for i in range(n+1)]\n\n\n\nfor i in range(n-1):\n\n    a,b,c = list(map(int,input().split()))\n\n    abc[a].append([b,c])\n\n    abc[b].append([a,c])\n\n\n\nQ,k = list(map(int,input().split()))\n\nxy = [[int(i) for i in input().split()] for j in range(Q)]\n\n\n\nq = queue.Queue()\n\n\n\nq.put(k)\n\n\n\npath = [-1]*(n+1)\n\npath[k] = 0\n\n\n\ndef dfs(p):\n\n    for i in range(len(abc[p])):\n\n        num = abc[p][i][0]\n\n        if path[num] != -1:\n\n            continue\n\n        else:\n\n            path[num] = path[p] + abc[p][i][1]\n\n            dfs(num)\n\n\n\ndfs(k)\n\n\n\nfor i in range(Q):\n\n    print((path[xy[i][0]]+path[xy[i][1]]))", "score": 1.0, "surface_similarity": 0.8534656661018316}
{"id": "p03000_u488178971", "golden_code": "#ABC 130 B\n\nN,X=list(map(int,input().split()))\n\nL= [int(j) for j in input().split()]\n\ncnt=0\n\nimport numpy as np\n\njump = list(np.cumsum(L))\n\nfor j in jump:\n\n    if j <= X:\n\n        cnt+=1\n\n    else:\n\n        break\n\nprint((cnt+1))", "generated_code": "#ABC 130 B\n\nN,X=list(map(int,input().split()))\n\nL= [int(j) for j in input().split()]\n\ncnt=0\n\nd = 0\n\n\n\nfor l in L :\n\n    d+=l\n\n    if d <= X:\n\n        cnt+=1\n\n    else:\n\n        break\n\nprint((cnt+1))", "score": 1.0, "surface_similarity": 0.8536682615629985}
{"id": "p03309_u033272694", "golden_code": "import numpy as np\n\nN = int(eval(input()))\n\nlist_ai = list(map(int,input().split()))\n\nlist1 = [x-(i+1) for i,x in enumerate(list_ai)]\n\na1 = np.array(list1)\n\nmedian1 = int(np.floor(np.median(a1)))\n\nans = np.sum(np.abs(a1-median1))\n\nprint(ans)", "generated_code": "import numpy as np\n\nN = int(eval(input()))\n\nlist_ai = list(map(int,input().split()))\n\na1 = np.array(list_ai)-np.arange(1,N+1)\n\nmedian1 = int(np.floor(np.median(a1)))\n\nans = np.sum(np.abs(a1-median1))\n\nprint(ans)\n", "score": 1.0, "surface_similarity": 0.8308518428118135}
{"id": "p02690_u046187684", "golden_code": "def solve(string):\n\n    x = int(string)\n\n    a = {i**5: i for i in range(-10000, 10000)}\n\n    for i in range(-10000, 10000):\n\n        if x + i ** 5 in a:\n\n            return str(f\"{a[x+i**5]} {i}\")\n\n\n\n\n\nif __name__ == '__main__':\n\n    import sys\n\n    print((solve(sys.stdin.read().strip())))\n", "generated_code": "def solve(string):\n\n    x = int(string)\n\n    a = {i**5: i for i in range(-120, 121)}\n\n    for i in range(-121, 121):\n\n        if x + i ** 5 in a:\n\n            return str(f\"{a[x+i**5]} {i}\")\n\n\n\n\n\nif __name__ == '__main__':\n\n    import sys\n\n    print((solve(sys.stdin.read().strip())))\n", "score": 1.0, "surface_similarity": 0.9743150684931507}
{"id": "p02394_u227438830", "golden_code": "W,H,x,y,r = [int(i) for i in input().split()]\n\nif x - r >= 0 and x + r <= W and y - r >= 0 and y + r <= H:\n\n    print(\"Yes\")\n\nelse:\n\n    print(\"No\")", "generated_code": "W, H, x, y, r = list(map(int, input().split()))\n\nif r <= x <= W-r and r <= y <= H-r:\n\n    print('Yes')\n\nelse:\n\n    print('No')\n", "score": 1.0, "surface_similarity": 0.7763835263835264}
{"id": "p02690_u945228737", "golden_code": "# 解説を参考に作成\n\n\n\ndef solve():\n\n    X = int(eval(input()))\n\n    A, B = 0, 0\n\n    for a in range(-200, 200):\n\n        for b in range(-200, 200):\n\n            if a ** 5 - b ** 5 == X:\n\n                A, B = a, b\n\n                break\n\n    print((A, B))\n\n\n\n\n\n\n\nif __name__ == '__main__':\n\n    solve()\n", "generated_code": "# 解説を参考に作成\n\n\n\ndef solve():\n\n    X = int(eval(input()))\n\n    A, B = 0, 0\n\n    # A と B の差が最も小さい時(A - B = 1)に, ans < 10**9 となるのは\n\n    # -118 <= A <= 119, -119 <= B <= 118 の場合となる.\n\n    # A - B > 1 の場合でも同じ範囲だけ見れば十分となる.\n\n    # A - B < 1 の場合は答えが負になるので, X >= 1 の制約から検討不要.\n\n    for a in range(-118, 119 + 1):\n\n        for b in range(-119, 118 + 1):\n\n            if a ** 5 - b ** 5 == X:\n\n                A, B = a, b\n\n                break\n\n    print((A, B))\n\n\n\n\n\nif __name__ == '__main__':\n\n    solve()\n", "score": 1.0, "surface_similarity": 0.9610783952889217}
{"id": "p03060_u600402037", "golden_code": "# coding: utf-8\n\nimport sys\n\nimport numpy as np\n\n\n\nsr = lambda: sys.stdin.readline().rstrip()\n\nir = lambda: int(sr())\n\nlr = lambda: list(map(int, sr().split()))\n\n\n\nN = ir()\n\nV = np.array(lr())\n\nC = np.array(lr())\n\nV -= C\n\nV = V[V>0]\n\nanswer = V.sum()\n\nprint(answer)\n", "generated_code": "# coding: utf-8\n\nimport sys\n\n\n\nsr = lambda: sys.stdin.readline().rstrip()\n\nir = lambda: int(sr())\n\nlr = lambda: list(map(int, sr().split()))\n\n\n\nN = ir()\n\nV = lr()\n\nC = lr()\n\ntotal = 0\n\nfor i in range(N):\n\n    result = V[i] - C[i]\n\n    if result > 0:\n\n        total += result\n\n\n\nprint(total)\n", "score": 1.0, "surface_similarity": 0.7687135813536531}
{"id": "p03325_u353895424", "golden_code": "from math import log2\n\nn = int(eval(input()))\n\na = list(map(int, input().split()))\n\nans = 0\n\n\n\nfor _a in a:\n\n    if _a%2 == 0:\n\n        cnt =0\n\n        while _a%2 == 0:\n\n            _a //= 2\n\n            cnt += 1\n\n        ans += cnt\n\n\n\nprint((int(ans)))", "generated_code": "def f(k):\n\n    cnt = 0\n\n    while k%2 == 0:\n\n        k //= 2\n\n        cnt += 1\n\n        # print(k)\n\n        # print(\"-----\")\n\n    return cnt\n\n\n\nn = int(eval(input()))\n\nA = list(map(int, input().split()))\n\nans = 0\n\n\n\nfor a in A:\n\n    if a%2 == 0:\n\n        ans += f(a)\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.7145323741007195}
{"id": "p02685_u164727245", "golden_code": "# coding: utf-8\n\n\n\n\n\ndef solve(*args: str) -> str:\n\n    n, m, k = list(map(int, args[0].split()))\n\n    mod = 998244353\n\n\n\n    if m == 1 and n-1 == k:\n\n        return str(1)\n\n\n\n    ncr = 1\n\n    p = m*pow(m-1, n-1, mod) % mod\n\n    ret = p\n\n    inv = pow(m-1, mod-2, mod)\n\n    for i in range(1, k+1):\n\n        ncr = (ncr * (n-i)*pow(i, mod-2, mod)) % mod\n\n        p = (p*inv) % mod\n\n        ret += p*ncr % mod\n\n\n\n    return str(ret % mod)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    print((solve(*(open(0).read().splitlines()))))\n", "generated_code": "# coding: utf-8\n\n\n\n\n\ndef solve(*args: str) -> str:\n\n    n, m, k = list(map(int, args[0].split()))\n\n    mod = 998244353\n\n\n\n    if m == 1 and n-1 == k:\n\n        return str(1)\n\n\n\n    ncr = 1\n\n    p = m*pow(m-1, n-1, mod) % mod\n\n\n\n    ret = p\n\n    iR = [1]*(k+1)\n\n    im = pow(m-1, mod-2, mod)\n\n\n\n    for i in range(1, k+1):\n\n        iR[i] = max(1, (-(mod//i) * iR[mod % i]) % mod)\n\n        ncr = (ncr * (n-i)*iR[i]) % mod\n\n        p = (p*im) % mod\n\n        ret += p*ncr % mod\n\n\n\n    return str(ret % mod)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    print((solve(*(open(0).read().splitlines()))))\n", "score": 1.0, "surface_similarity": 0.8856396731823353}
{"id": "p02690_u390727364", "golden_code": "x = int(eval(input()))\n\na = 0\n\nb = 0\n\nfor i in range(-120, 120):\n\n    for j in range(-120, 120):\n\n        if i ** 5 - j ** 5 == x:\n\n            a = i\n\n            b = j\n\nprint((a, b))\n", "generated_code": "x = int(eval(input()))\n\nfor i in range(-120, 120):\n\n    for j in range(-120, 120):\n\n        if i ** 5 - j ** 5 == x:\n\n            print((i, j))\n\n            exit()\n", "score": 1.0, "surface_similarity": 0.9320652173913043}
{"id": "p03828_u054556734", "golden_code": "import collections as col\n\n\n\ndef prime(n):\n\n    ans = []\n\n    num = n\n\n    for i in range(2,n+1):\n\n        if i%2==0 and i!=2: continue\n\n        while num%i == 0: num //= i ; ans.append(i)\n\n    return ans\n\n\n\nn = int(eval(input()))\n\nmod = 10**9 + 7\n\n\n\nprimes = []\n\nfor i in range(2,n+1): primes += prime(i)\n\n\n\ncnt = col.Counter(primes)\n\nans = 1\n\nfor key,val in list(cnt.items()): ans *= (val + 1) ; ans %= mod\n\nprint(ans)\n", "generated_code": "import collections as col\n\n\n\ndef prime(n):\n\n    ans = []\n\n    num = n\n\n    for i in range(2,int(n**0.5)+1):\n\n        if i%2==0 and i!=2: continue\n\n        while num%i == 0: num //= i ; ans.append(i)\n\n    if num != 1: ans.append(num)\n\n    return ans\n\n\n\nn = int(eval(input()))\n\nmod = 10**9 + 7\n\n\n\nprimes = []\n\nfor i in range(2,n+1): primes += prime(i)\n\n\n\ncnt = col.Counter(primes)\n\nans = 1\n\nfor key,val in list(cnt.items()): ans *= (val + 1) ; ans %= mod\n\nprint(ans)\n", "score": 1.0, "surface_similarity": 0.9623655913978495}
{"id": "p02794_u852690916", "golden_code": "import sys\n\ndef main():\n\n    input = sys.stdin.readline\n\n    N = int(eval(input()))\n\n    E = [[] for _ in range(N)]\n\n    for i in range(N-1):\n\n        a, b = list(map(int, input().split()))\n\n        a, b = a-1, b-1\n\n        E[a].append((b,i))\n\n        E[b].append((a,i))\n\n    \n\n    def dfs(s, g):\n\n        par = [(-1,-1)] * N\n\n        par[s] = (s,-1)\n\n        stack = [s]\n\n        while stack:\n\n            v = stack.pop()\n\n            for to, i in E[v]:\n\n                if par[to][0] >= 0: continue\n\n                par[to] = (v, i)\n\n                if to == g: break\n\n                stack.append(to)\n\n        r = set()\n\n        v = g\n\n        while v != s:\n\n            v, i = par[v]\n\n            r.add(i)\n\n        return r\n\n    \n\n    M = int(eval(input()))\n\n    path = [None] * M\n\n    for i in range(M):\n\n        u, v = list(map(int, input().split()))\n\n        u, v = u-1, v-1\n\n        path[i] = dfs(u, v)\n\n\n\n    def calc(s): return 1<<(N-1-len(s))\n\n\n\n    i_ans = 0\n\n    for p in range(1, 1<<M):\n\n        is_odd = bin(p).count('1') & 1\n\n        s = set()\n\n        for i in range(M):\n\n            if p&1: s |= path[i]\n\n            p >>= 1\n\n        if is_odd: i_ans += calc(s)\n\n        else: i_ans -= calc(s)\n\n\n\n    print(((1<<(N-1)) - i_ans))\n\n\n\nif __name__ == '__main__':\n\n    main()", "generated_code": "import sys\n\ndef main():\n\n    input = sys.stdin.readline\n\n    N = int(eval(input()))\n\n    E = [[] for _ in range(N)]\n\n    for i in range(N-1):\n\n        a, b = list(map(int, input().split()))\n\n        a, b = a-1, b-1\n\n        E[a].append((b,i))\n\n        E[b].append((a,i))\n\n    \n\n    def dfs(s, g):\n\n        par = [(-1,-1)] * N\n\n        par[s] = (s,-1)\n\n        stack = [s]\n\n        while stack:\n\n            v = stack.pop()\n\n            for to, i in E[v]:\n\n                if par[to][0] >= 0: continue\n\n                par[to] = (v, i)\n\n                if to == g: break\n\n                stack.append(to)\n\n        r = set()\n\n        v = g\n\n        while v != s:\n\n            v, i = par[v]\n\n            r.add(i)\n\n        return r\n\n    \n\n    M = int(eval(input()))\n\n    path = [None] * M\n\n    for i in range(M):\n\n        u, v = list(map(int, input().split()))\n\n        u, v = u-1, v-1\n\n        path[i] = dfs(u, v)\n\n\n\n    def calc(s): return 1<<(N-1-len(s))\n\n\n\n    i_ans = 0\n\n    for p in range(1, 1<<M):\n\n        is_odd = 0\n\n        s = set()\n\n        for i in range(M):\n\n            if p&1:\n\n                s |= path[i]\n\n                is_odd ^= 1\n\n            p >>= 1\n\n        if is_odd: i_ans += calc(s)\n\n        else: i_ans -= calc(s)\n\n\n\n    print(((1<<(N-1)) - i_ans))\n\n\n\nif __name__ == '__main__':\n\n    main()", "score": 1.0, "surface_similarity": 0.9766797129810829}
{"id": "p02899_u729133443", "golden_code": "from numpy import*;_,a=open(0);print((*argsort(int32(a.split()))+1))", "generated_code": "n,a=open(0);a=a.split();print((*sorted(list(range(1,int(n)+1)),key=lambda x:int(a[x-1]))))", "score": 1.0, "surface_similarity": 0.42878787878787883}
{"id": "p03575_u020390084", "golden_code": "import sys\n\nfrom scipy.sparse import csr_matrix\n\nfrom scipy.sparse.csgraph import floyd_warshall\n\n\n\ndef solve(N: int, M: int, a: \"List[int]\", b: \"List[int]\"):\n\n    answer = 0\n\n    for i in range(M): ## iの辺を消す\n\n        matrix = [[0]*(N) for _ in range(N)]\n\n        for j in range(M):\n\n            if j == i:\n\n                continue\n\n            aa = a[j]-1\n\n            bb = b[j]-1\n\n            matrix[aa][bb] = 1\n\n           \n\n        dist_matrix = floyd_warshall(csgraph=csr_matrix(matrix), directed=False)\n\n        \n\n        if dist_matrix[a[i]-1][b[i]-1] == float('inf'):\n\n            answer += 1\n\n            \n\n    print(answer)\n\n    return\n\n\n\n\n\ndef main():\n\n    def iterate_tokens():\n\n        for line in sys.stdin:\n\n            for word in line.split():\n\n                yield word\n\n    tokens = iterate_tokens()\n\n    N = int(next(tokens))  # type: int\n\n    M = int(next(tokens))  # type: int\n\n    a = [int()] * (M)  # type: \"List[int]\"\n\n    b = [int()] * (M)  # type: \"List[int]\"\n\n    for i in range(M):\n\n        a[i] = int(next(tokens))\n\n        b[i] = int(next(tokens))\n\n    solve(N, M, a, b)\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "generated_code": "#!/usr/bin/env python3\n\nimport sys\n\ninput = sys.stdin.readline\n\ndef INT(): return int(eval(input()))\n\ndef MAP(): return list(map(int,input().split()))\n\ndef LI(): return list(map(int,input().split()))\n\n\n\nclass UnionFind():\n\n    def __init__(self, n):\n\n        self.n = n\n\n        self.parents = [-1] * n\n\n        \n\n    def find(self, x): # 根を探す\n\n        if self.parents[x] < 0:\n\n            return x\n\n        else:\n\n            self.parents[x] = self.find(self.parents[x])\n\n            return self.parents[x]\n\n    \n\n    def union(self, x, y):\n\n        x = self.find(x)\n\n        y = self.find(y)\n\n        \n\n        if x == y:\n\n            return\n\n        \n\n        if self.parents[x] > self.parents[y]:\n\n            x, y = y, x\n\n        \n\n        self.parents[x] += self.parents[y]\n\n        self.parents[y] = x\n\n    \n\n    def size(self, x):\n\n        return -self.parents[self.find(x)]\n\n        \n\n    def same(self, x, y):\n\n        return self.find(x) == self.find(y)\n\n    \n\n    def members(self, x):\n\n        root = self.find(x)\n\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    \n\n    def roots(self):\n\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n\n\n    def group_count(self):\n\n        return len(self.roots())\n\n    \n\n    def all_group_members(self):\n\n        return {r: self.members(r) for r in self.roots()}\n\n    \n\n    def __str__(self):\n\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n\n\ndef main():\n\n    N,M=MAP()\n\n    \n\n    edges = []\n\n    for _ in range(M):\n\n        a,b = MAP()\n\n        edges.append((a-1,b-1))\n\n\n\n    answer = 0\n\n    for i in range(M): # i番目の辺を使わない\n\n        uf = UnionFind(N)\n\n\n\n        for j in range(M):\n\n            if i == j:\n\n                continue\n\n\n\n            a,b = edges[j]\n\n            uf.union(a,b)\n\n        if uf.group_count() > 1:\n\n            answer += 1\n\n    print(answer)\n\n    return\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 1.0, "surface_similarity": 0.6271589000576542}
{"id": "p02612_u295361373", "golden_code": "'''\n\n    Auther: ghoshashis545 Ashis Ghosh\n\n    College: jalpaiguri Govt Enggineering College\n\n\n\n'''\n\nfrom os import path\n\nimport sys\n\nfrom functools import cmp_to_key as ctk\n\nfrom collections import deque,defaultdict as dd \n\nfrom bisect import bisect,bisect_left,bisect_right,insort,insort_left,insort_right\n\nfrom itertools import permutations\n\nfrom datetime import datetime\n\nfrom math import ceil,sqrt,log,gcd\n\ndef ii():return int(eval(input()))\n\ndef si():return eval(input())\n\ndef mi():return list(map(int,input().split()))\n\ndef li():return list(mi())\n\nabc='abcdefghijklmnopqrstuvwxyz'\n\nmod=1000000007\n\n#mod=998244353\n\ninf = float(\"inf\")\n\nvow=['a','e','i','o','u']\n\ndx,dy=[-1,1,0,0],[0,0,1,-1]\n\n\n\ndef bo(i):\n\n    return ord(i)-ord('a')\n\n\n\nfile = 0\n\n\n\ndef solve():\n\n    \n\n\n\n\n\n\n\n    # for _ in range(ii()):\n\n\n\n    n=ii()\n\n    n%=1000\n\n    if n!=0:\n\n        n=1000-n\n\n    print(n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nif __name__ ==\"__main__\":\n\n\n\n    if(file):\n\n\n\n        if path.exists('input1.txt'):\n\n            sys.stdin=open('input1.txt', 'r')\n\n            sys.stdout=open('output1.txt','w')\n\n        else:\n\n            input=sys.stdin.readline\n\n    solve()", "generated_code": "'''\n\n    Auther: ghoshashis545 Ashis Ghosh\n\n    College: jalpaiguri Govt Enggineering College\n\n\n\n'''\n\nfrom os import path\n\nimport sys\n\nfrom heapq import heappush,heappop\n\nfrom functools import cmp_to_key as ctk\n\nfrom collections import deque,defaultdict as dd \n\nfrom bisect import bisect,bisect_left,bisect_right,insort,insort_left,insort_right\n\nfrom itertools import permutations\n\nfrom datetime import datetime\n\nfrom math import ceil,sqrt,log,gcd\n\ndef ii():return int(eval(input()))\n\ndef si():return eval(input())\n\ndef mi():return list(map(int,input().split()))\n\ndef li():return list(mi())\n\nabc='abcdefghijklmnopqrstuvwxyz'\n\nmod=1000000007\n\n# mod=998244353\n\ninf = float(\"inf\")\n\nvow=['a','e','i','o','u']\n\ndx,dy=[-1,1,0,0],[0,0,1,-1]\n\n\n\ndef bo(i):\n\n    return ord(i)-ord('a')\n\n\n\nfile=0\n\n\n\n\n\n\n\n\n\n\n\ndef solve():\n\n\n\n\n\n    # for _ in range(ii()):\n\n    \n\n        \n\n\n\n    n=ii()\n\n    n%=1000\n\n    if(n!=0):\n\n        n=1000-n\n\n    print(n)\n\n \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n        \n\nif __name__ ==\"__main__\":\n\n\n\n    if(file):\n\n\n\n        if path.exists('input1.txt'):\n\n            sys.stdin=open('input1.txt', 'r')\n\n            sys.stdout=open('output1.txt','w')\n\n        else:\n\n            input=sys.stdin.readline\n\n    solve()\n", "score": 1.0, "surface_similarity": 0.9859271523178808}
{"id": "p02850_u254871849", "golden_code": "import sys\n\nfrom collections import deque\n\nimport numpy as np\n\n\n\ndef main():\n\n    n = int(sys.stdin.readline().rstrip())\n\n    ab = np.array(sys.stdin.read().split(), dtype=np.int64).reshape(-1, 2)\n\n\n\n    G = [[] for _ in range(n + 1)]\n\n    for a, b in ab:\n\n        G[a].append(b)\n\n        G[b].append(a)\n\n    \n\n    parent = np.zeros(n + 1, dtype=np.int64)\n\n    color = np.zeros(n + 1, dtype=np.int64) # color of the edge(parent[y], y)\n\n\n\n    q = deque([1]) # root = 1\n\n    while q:\n\n        x = q.popleft()\n\n        ng = color[x]\n\n        c = 1\n\n        for y in G[x]:\n\n            if y == parent[x]:\n\n                continue\n\n            parent[y] = x\n\n            if c == ng:\n\n                c += 1\n\n            color[y] = c\n\n            q.append(y)\n\n            c += 1\n\n\n\n    print((np.amax(color)))\n\n\n\n    for a, b in ab:\n\n        if a == parent[b]:\n\n            print((color[b]))\n\n        else:\n\n            print((color[a]))\n\n            \n\nif __name__ == '__main__':\n\n    main()", "generated_code": "import sys\n\nfrom collections import deque\n\n\n\ndef main():\n\n    n = int(sys.stdin.readline().rstrip())\n\n    ab = list(map(int, sys.stdin.read().split()))\n\n    ab = list(zip(ab, ab))\n\n\n\n    G = [[] for _ in range(n + 1)]\n\n    for a, b in ab:\n\n        G[a].append(b)\n\n        G[b].append(a)\n\n    \n\n    q = deque([1]) # root = 1\n\n    parent = [None] * (n + 1)\n\n    color = [0] * (n + 1) # color of the edge(parent[y], y)\n\n\n\n    while q:\n\n        x = q.popleft()\n\n        ng = color[x]\n\n        c = 1\n\n        for y in G[x]:\n\n            if y == parent[x]:\n\n                continue\n\n            parent[y] = x\n\n            if c == ng:\n\n                c += 1\n\n            color[y] = c\n\n            q.append(y)\n\n            c += 1\n\n            \n\n    print((max(color)))\n\n\n\n    for a, b in ab:\n\n        if a == parent[b]:\n\n            print((color[b]))\n\n        else:\n\n            print((color[a]))\n\n\n\nif __name__ == '__main__':\n\n    main()", "score": 1.0, "surface_similarity": 0.8775278136332902}
{"id": "p02685_u133936772", "golden_code": "M=998244353\n\nn,m,k=list(map(int,input().split()))\n\na=0\n\nc=1\n\nfor i in range(k+1):\n\n  a+=c*m*pow(m-1,n-i-1,M)\n\n  c=c*(n-i-1)*pow(i+1,M-2,M)%M\n\nprint((a%M))", "generated_code": "M=998244353\n\nn,m,k=list(map(int,input().split()))\n\na,c=0,1\n\nfor i in range(k+1):\n\n  a+=c*m*pow(m-1,n+~i,M)\n\n  c=c*(n+~i)*pow(i+1,-1,M)%M\n\nprint((a%M))", "score": 1.0, "surface_similarity": 0.8762987012987014}
{"id": "p03680_u038408819", "golden_code": "N = int(eval(input()))\n\na = [int(eval(input())) for _ in range(N)]\n\n\n\ncnt, i = 0, 0\n\nfor j in range(10 ** 6):\n\n    cnt += 1\n\n    if a[i] == 2:\n\n        print(cnt)\n\n        #break\n\n        quit()\n\n    else:\n\n        i = a[i] - 1\n\nprint((-1))", "generated_code": "N = int(eval(input()))\n\na = [int(eval(input())) for _ in range(N)]\n\n\n\ncnt, i = 0, 0\n\nfor j in range(len(a)):\n\n    cnt += 1\n\n    if a[i] == 2:\n\n        print(cnt)\n\n        #break\n\n        quit()\n\n    else:\n\n        i = a[i] - 1\n\nprint((-1))", "score": 1.0, "surface_similarity": 0.9666666666666667}
{"id": "p02555_u581511366", "golden_code": "import math\n\n\n\n\n\ndef combinations_count(n, r):\n\n    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\n\n\n\n\n\ndef combinations_with_replacement_count(n, r):\n\n    return combinations_count(n + r - 1, r)\n\n\n\n\n\ndef main():\n\n    s = int(eval(input()))\n\n    ans = 0\n\n    n = s // 3\n\n\n\n    for i in range(1, n + 1):\n\n        ans += combinations_with_replacement_count(i, 3*(n-i)+s % 3)\n\n\n\n    print((ans % (10**9 + 7)))\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "generated_code": "def main():\n\n    s = int(eval(input()))\n\n    dp = [0] * 3 + [1] * 3 + [0 for _ in range(s)]\n\n\n\n    for i in range(6, s+1):\n\n        dp[i] = dp[i-1] + dp[i-3]\n\n\n\n    print((dp[s] % (10**9+7)))\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 1.0, "surface_similarity": 0.553046218487395}
{"id": "p03806_u001024152", "golden_code": "G_MAX = 40*10\n\nN_MAX = 40\n\nINF = float('inf')\n\n\n\ndp = [[[INF]*(G_MAX+1) for _ in range(G_MAX+1)] \n\n      for _ in range(N_MAX+1)]\n\nN,Ma,Mb = list(map(int, input().split()))\n\na,b,c = [],[],[]\n\nfor _ in range(N):\n\n    ai,bi,ci = list(map(int, input().split()))\n\n    a.append(ai)\n\n    b.append(bi)\n\n    c.append(ci)\n\n\n\ndp[0][0][0] = 0\n\nfrom math import isinf\n\nfor i in range(N):\n\n    for ca in range(G_MAX+1):\n\n        for cb in range(G_MAX+1):\n\n            if isinf(dp[i][ca][cb]): continue\n\n            dp[i+1][ca][cb] = min(dp[i+1][ca][cb],\n\n                                 dp[i][ca][cb])\n\n            dp[i+1][ca+a[i]][cb+b[i]] = min(dp[i+1][ca+a[i]][cb+b[i]],\n\n                                           dp[i][ca][cb]+c[i])\n\n            \n\n    \n\nans = INF\n\nfor ca in range(1,G_MAX+1):\n\n    for cb in range(1,G_MAX+1):\n\n        if ca*Mb==cb*Ma:\n\n            ans = min(ans, dp[N][ca][cb])\n\n            \n\nif isinf(ans): ans = -1\n\nprint(ans)", "generated_code": "from math import isinf\n\n\n\nN, Ma, Mb = list(map(int, input().split()))\n\na = [0]*N\n\nb = [0]*N\n\nc = [0]*N\n\nfor i in range(N):\n\n    a[i],b[i],c[i] = list(map(int, input().split()))\n\n\n\nW_MAX = 40*10\n\ndp = [[float('inf')]*(W_MAX+1) for _ in range(W_MAX+1)]\n\ndp[0][0] = 0\n\n\n\nfor i in range(N):\n\n    for wa in reversed(list(range(W_MAX+1))):\n\n        for wb in reversed(list(range(W_MAX+1))):\n\n            if isinf(dp[wa][wb]): continue\n\n            if wa+a[i]<=W_MAX and wb+b[i]<=W_MAX:\n\n                dp[wa+a[i]][wb+b[i]] = min(dp[wa+a[i]][wb+b[i]],\n\n                                           dp[wa][wb]+c[i])\n\n\n\nans = float('inf')\n\nfor wa in range(1, W_MAX+1):\n\n    for wb in range(1, W_MAX+1):\n\n        if wa*Mb == wb*Ma:\n\n            ans = min(ans, dp[wa][wb])\n\n\n\nif isinf(ans): ans = -1\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.7842217484008529}
{"id": "p03568_u170183831", "golden_code": "from itertools import product\n\n\n\nn = int(eval(input()))\n\nA = list(map(int, input().split()))\n\n\n\ncount = 0\n\nfor C in product((-1, 0, 1), repeat=n):\n\n  total = 1\n\n  for a, c in zip(A, C):\n\n    total *= (a + c)\n\n  if total % 2 == 0:\n\n    count += 1\n\nprint(count)", "generated_code": "n = int(eval(input()))\n\nA = list(map(int, input().split()))\n\n\n\ncount = 1\n\nfor a in A:\n\n  count *= 2 if a % 2 == 0 else 1\n\nprint((3 ** n - count))", "score": 1.0, "surface_similarity": 0.5878020878020878}
{"id": "p02690_u655663334", "golden_code": "X = int(eval(input()))\n\n\n\ngojyous = []\n\n\n\nfor i in range(-200, 201):\n\n    gojyous.append(i ** 5)\n\n\n\n#print(gojyous)\n\n\n\nfor i in range(-200,201):\n\n    for j in range(-200,201):\n\n        if(X == (int(i**5) - int(j**5))):\n\n            print((i, j))\n\n            exit()", "generated_code": "import sys\n\n\n\nX= int(eval(input()))\n\n\n\n#添字の最大値を算出\n\n\n\na = 1\n\nb = 0\n\ndif = 0\n\nwhile dif < 10**9:\n\n    a += 1\n\n    b += 1\n\n\n\n    dif = a ** 5 - b ** 5\n\n\n\nloop_sequence = a - 1\n\n\n\nfor i in range(-(loop_sequence),loop_sequence):\n\n\tfor j in range(-(loop_sequence),loop_sequence):\n\n\t\tif(X == i ** 5 - j ** 5):\n\n\t\t\tprint((i,j))\n\n\t\t\tsys.exit()\n", "score": 1.0, "surface_similarity": 0.6444890929965557}
{"id": "p03164_u440566786", "golden_code": "import sys\n\nsys.setrecursionlimit(2147483647)\n\nINF=float(\"inf\")\n\nMOD=10**9+7\n\ninput=lambda :sys.stdin.readline().rstrip()\n\ndef resolve():\n\n    n,W=list(map(int,input().split()))\n\n    WV=[tuple(map(int,input().split())) for _ in range(n)]\n\n\n\n    V=100000\n\n    dp=[INF]*(V+1)\n\n    dp[0]=0\n\n\n\n    for w,v in WV:\n\n        for x in range(V,-1,-1):\n\n            if(x+v<=V):\n\n                dp[x+v]=min(dp[x+v],dp[x]+w)\n\n\n\n    for x in range(V,-1,-1):\n\n        if(dp[x]<=W):\n\n            print(x)\n\n            return\n\nresolve()", "generated_code": "import sys\n\nINF = 1 << 60\n\nMOD = 10**9 + 7 # 998244353\n\nsys.setrecursionlimit(2147483647)\n\ninput = lambda:sys.stdin.readline().rstrip()\n\ndef resolve():\n\n    n, W = list(map(int, input().split()))\n\n    dp = [INF] * (n * 1001 + 1)\n\n    dp[0] = 0\n\n    for _ in range(n):\n\n        w, v = list(map(int, input().split()))\n\n        for v0 in range(n * 1001, -1, -1):\n\n            if dp[v0] == INF:\n\n                continue\n\n            if v + v0 <= n * 1001:\n\n                dp[v + v0] = min(dp[v + v0], dp[v0] + w)\n\n    for v in range(n * 1001, -1, -1):\n\n        if dp[v] <= W:\n\n            print(v)\n\n            return\n\nresolve()", "score": 1.0, "surface_similarity": 0.7834993422289043}
{"id": "p02691_u764956288", "golden_code": "from collections import defaultdict\n\n\n\n\n\ndef main():\n\n    _ = int(eval(input()))\n\n    heights = list(map(int, input().split()))\n\n\n\n    \"\"\"\n\n    for j>i, j-i = Ai + Aj\n\n    i + Ai = j -Aj\n\n    \"\"\"\n\n\n\n    L = defaultdict(int)\n\n    R = defaultdict(int)\n\n\n\n    for i, height in enumerate(heights):\n\n        L[i + height] += 1\n\n        R[i - height] += 1\n\n\n\n    total_count = 0\n\n    for x, count_l in list(L.items()):\n\n        if x in R:\n\n            count_r = R[x]\n\n            total_count += count_l * count_r\n\n\n\n    print(total_count)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "generated_code": "from collections import defaultdict\n\n\n\n\n\ndef main():\n\n    N = int(eval(input()))\n\n    heights = list(map(int, input().split()))\n\n\n\n    \"\"\"\n\n    for j>i, j-i = Ai + Aj\n\n    i + Ai = j -Aj\n\n    \"\"\"\n\n\n\n    L = defaultdict(int)\n\n    R = defaultdict(int)\n\n\n\n    for i, height in enumerate(heights):\n\n        if i + height < N:\n\n            L[i + height] += 1\n\n        \n\n        if i - height > 0:\n\n            R[i - height] += 1\n\n\n\n    total_count = 0\n\n    for x, count_l in list(L.items()):\n\n        if x in R:\n\n            count_r = R[x]\n\n            total_count += count_l * count_r\n\n\n\n    print(total_count)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "score": 1.0, "surface_similarity": 0.9420122887864824}
{"id": "p03039_u747602774", "golden_code": "import sys\n\nreadline = sys.stdin.readline\n\nsys.setrecursionlimit(10**8)\n\nmod = 10**9+7\n\n#mod = 998244353\n\nINF = 10**18\n\neps = 10**-7\n\n\n\nm,n,k = list(map(int,readline().split()))\n\n\n\ndef comb(n, r, mod):\n\n    r = min(r, n-r)\n\n    mol = 1\n\n    deno = 1\n\n    for i in range(1, r+1):\n\n        mol = mol * (n-r+i) % mod\n\n        deno = deno * i % mod\n\n    ret = mol * pow(deno, mod-2, mod) % mod\n\n    return ret\n\n\n\ndef f1(x,y,a,b):\n\n    return (a+b-x-y)*(a-x+1)*(b-y+1)//2\n\n\n\ndef f2(x,a):\n\n    return (a-x)*(a-x+1)//2\n\n\n\nans = 0\n\n\n\nfor x in range(1,n+1):\n\n    for y in range(1,m+1):\n\n        a = n-x+1\n\n        b = m-y+1\n\n        c = m*(a*(a-1)+x*(x-1))\n\n        d = n*(b*(b-1)+y*(y-1))\n\n        ans += (c+d)//2\n\n        ans %= mod\n\n\n\nans = (ans * comb(m*n-2,k-2,mod))%mod\n\nans = ans*pow(2,mod-2,mod)%mod\n\n\n\nprint(ans)\n\n\n", "generated_code": "import sys\n\nreadline = sys.stdin.readline\n\nsys.setrecursionlimit(10**8)\n\nmod = 10**9+7\n\n#mod = 998244353\n\nINF = 10**18\n\neps = 10**-7\n\n\n\nm,n,k = list(map(int,readline().split()))\n\n\n\ndef comb(n, r, mod):\n\n    r = min(r, n-r)\n\n    mol = 1\n\n    deno = 1\n\n    for i in range(1, r+1):\n\n        mol = mol * (n-r+i) % mod\n\n        deno = deno * i % mod\n\n    ret = mol * pow(deno, mod-2, mod) % mod\n\n    return ret\n\n\n\nans = m*n*(m+n)*(m*n-1)//3\n\n\n\nans = (ans * comb(m*n-2,k-2,mod))%mod\n\nans = ans*pow(2,mod-2,mod)%mod\n\n\n\nprint(ans)\n\n\n", "score": 1.0, "surface_similarity": 0.8612360827084753}
{"id": "p03253_u800396927", "golden_code": "N,M = list(map(int,input().split()))\n\ndiv =[]\n\nfor i in range(2,int(M**(1/2))+2):\n\n    cur = 0\n\n    while M%i==0:\n\n        M = M//i\n\n        cur += 1\n\n    if cur >=1:\n\n        div.append(cur)\n\nif M>1: div.append(1)\n\ndiv.sort()\n\nmod = 10**9+7\n\nfrac = [1]*(N+50)\n\nnum = len(frac)\n\nfor i in range(len(frac)-1):\n\n    frac[i+1] = frac[i]*(i+1)%mod\n\nfinv = [1] * (N+50)\n\nfinv[-1] = pow(frac[-1], mod-2, mod)\n\nfor i in range(1, num):\n\n  finv[num-1-i] = finv[num-i] * (num-i) % mod\n\nans = 1\n\nfor i in div:\n\n    ans = ans * frac[N+i-1]*finv[N-1]*finv[i]%mod\n\nprint(ans)", "generated_code": "N,M = list(map(int,input().split()))\n\ndiv = []\n\nfor i in range(2,int(M**(1/2))+2):\n\n    cur = 0\n\n    while M%i==0:\n\n        M//=i\n\n        cur += 1\n\n    if cur >=1:\n\n        div.append(cur)\n\nif M>1:div.append(1)\n\ndiv.sort()\n\nmod = 10**9+7\n\nfrac = [1]*(N+50)\n\nnum=len(frac)\n\nfor i in range(num-1):\n\n    frac[i+1] = frac[i]*(i+1)%mod\n\nfinv = [1]*(N+50)\n\nfinv[-1] = pow(frac[-1],mod-2,mod)\n\nans = 1\n\nfor i in range(1,num):\n\n    finv[num-1-i] = finv[num-i]*(num-i)%mod\n\nfor i in div:\n\n    ans  =ans*frac[N+i-1]*finv[N-1]*finv[i]%mod\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.9794642857142857}
{"id": "p03371_u290563917", "golden_code": "a, b, c, x, y = list(map(int, input().split()))\n\n# print(a, b, c, x, y)\n\n\n\nans = 10000 * (10 **5) + 7\n\nc_max = 0\n\nif x > y:\n\n  c_max = x * 2\n\nelse:\n\n  c_max = y * 2\n\n\n\nfor cc in range(c_max+1):\n\n  ac = x - (cc // 2)\n\n  bc = y - (cc // 2)\n\n  \n\n  if ac < 0:\n\n    ac = 0\n\n  if bc < 0:\n\n    bc = 0\n\n  price = ac * a + bc * b + cc * c\n\n  # print('price: {}, ac: {}, bc: {}, cc: {}'.format(price, ac, bc, cc))\n\n  ans = min(ans, price)\n\n\n\nprint(ans)", "generated_code": "a, b, c, x, y = list(map(int, input().split()))\n\n# print(a, b, c, x, y)\n\n\n\nans = 10000 * (10 **5) + 7\n\nc_max = 0\n\nif x > y:\n\n  c_max = x * 2\n\nelse:\n\n  c_max = y * 2\n\n\n\nfor cc in range(0, c_max+1, 2):\n\n  ac = x - (cc // 2)\n\n  bc = y - (cc // 2)\n\n  \n\n  if ac < 0:\n\n    ac = 0\n\n  if bc < 0:\n\n    bc = 0\n\n  price = ac * a + bc * b + cc * c\n\n  # print('price: {}, ac: {}, bc: {}, cc: {}'.format(price, ac, bc, cc))\n\n  ans = min(ans, price)\n\n\n\nprint(ans)\n\n  ", "score": 1.0, "surface_similarity": 0.995575221238938}
{"id": "p03425_u887207211", "golden_code": "N = int(eval(input()))\n\nname = {'M':0, 'A':0, 'R':0, 'C':0, 'H':0}\n\nmarch = \"MARCH\"\n\nfor _ in range(N):\n\n  S = eval(input())\n\n  if(S[0] in name):\n\n    name[S[0]] += 1\n\nans = 0\n\nfor i in range(3):\n\n  for j in range(i+1,4):\n\n    for k in range(j+1,5):\n\n      ans += name[march[i]] * name[march[j]] * name[march[k]]\n\nprint(ans)", "generated_code": "N = int(eval(input()))\n\nS = [eval(input()) for _ in range(N)]\n\n\n\nhead = {'M':0, 'A':0, 'R':0, 'C':0, 'H':0}\n\nmarch = \"MARCH\"\n\nfor s in S:\n\n  if(s[0] in head):\n\n    head[s[0]] += 1\n\nans = 0\n\nfor i in range(3):\n\n  for j in range(i+1,4):\n\n    for k in range(j+1,5):\n\n      ans += head[march[i]] * head[march[j]] * head[march[k]]\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.8336865903631483}
{"id": "p02899_u023958502", "golden_code": "n = int(eval(input()))\n\na = list(map(int,input().split()))\n\nans = [i for i in range(n)]\n\na1 = sorted(a)\n\nfor i in range(n):\n\n    num = a[i]\n\n    ans[num - 1] = str(i + 1)\n\n    \n\nprint((' '.join(ans)))", "generated_code": "n = int(eval(input()))\n\n# n,k = map(int,input().split())\n\na = list(map(int,input().split()))\n\nans = [0 for _ in range(n)]\n\nfor i in range(n):\n\n  ans[a[i] - 1] = str(i + 1)\n\nprint((\" \".join(ans)))", "score": 1.0, "surface_similarity": 0.9275}
{"id": "p02574_u981931040", "golden_code": "class prime_factorize_by_osa_k():\n\n    def __init__(self, max_val):\n\n        '''\n\n        割ることが出来る最小の値を格納したリストを返す\n\n        :param max_val:\n\n        :return:\n\n        '''\n\n        self.minFactor = [-1] * (max_val + 1)\n\n        for i in range(2, max_val + 1):\n\n            if self.minFactor[i] == -1:\n\n                self.minFactor[i] = i\n\n                # エラトステネスの篩と同様の処理を行う\n\n                for j in range(i * i, max_val + 1, i):\n\n                    if self.minFactor[j] == -1:\n\n                        self.minFactor[j] = i\n\n\n\n    def osa_k(self, n):\n\n        '''\n\n        preprocessをしたあと、O(logN)で素因数分解を行う。nの最大値をn_maxとする。\n\n        :param n:\n\n        :return:\n\n        '''\n\n        from collections import defaultdict\n\n        d = defaultdict(int)\n\n        now = n\n\n        while now > 1:\n\n            d[self.minFactor[now]] += 1\n\n            now //= self.minFactor[now]\n\n        return d\n\ndef gcd(a, b):\n\n    while b: a, b = b, a % b\n\n    return a\n\n\n\nN = int(eval(input()))\n\nA = list(map(int, input().split()))\n\n# N = 10 ** 6\n\n# A = [10 ** 6] * N\n\nob = prime_factorize_by_osa_k(10 ** 6)\n\npairwise = False\n\nprime_key = set(ob.osa_k(A[-1]).keys())\n\nbreak_flag = False\n\nprime_flags = [False] * (10 ** 6 + 1)\n\nfor i in range(N):\n\n    for key in list(ob.osa_k(A[i]).keys()):\n\n        if prime_flags[key]:\n\n            break_flag = True\n\n            break\n\n        else:\n\n            prime_flags[key] = True\n\n    if break_flag:\n\n        break\n\nelse:\n\n    pairwise = True\n\nif pairwise:\n\n    print('pairwise coprime')\n\n    exit()\n\nwork = gcd(A[0], A[1])\n\nfor i in range(2, N):\n\n    work = gcd(work, A[i])\n\nif work != 1:\n\n    print('not coprime')\n\nelse:\n\n    print('setwise coprime')", "generated_code": "def gcd(a, b):\n\n    while b: a, b = b, a % b\n\n    return a\n\ndef isPrimeMR(n):\n\n    d = n - 1\n\n    d = d // (d & -d)\n\n    L = [2]\n\n    for a in L:\n\n        t = d\n\n        y = pow(a, t, n)\n\n        if y == 1: continue\n\n        while y != n - 1:\n\n            y = (y * y) % n\n\n            if y == 1 or t == n - 1: return 0\n\n            t <<= 1\n\n    return 1\n\ndef findFactorRho(n):\n\n    m = 1 << n.bit_length() // 8\n\n    for c in range(1, 99):\n\n        f = lambda x: (x * x + c) % n\n\n        y, r, q, g = 2, 1, 1, 1\n\n        while g == 1:\n\n            x = y\n\n            for i in range(r):\n\n                y = f(y)\n\n            k = 0\n\n            while k < r and g == 1:\n\n                ys = y\n\n                for i in range(min(m, r - k)):\n\n                    y = f(y)\n\n                    q = q * abs(x - y) % n\n\n                g = gcd(q, n)\n\n                k += m\n\n            r <<= 1\n\n        if g == n:\n\n            g = 1\n\n            while g == 1:\n\n                ys = f(ys)\n\n                g = gcd(abs(x - ys), n)\n\n        if g < n:\n\n            if isPrimeMR(g): return g\n\n            elif isPrimeMR(n // g): return n // g\n\n            return findFactorRho(g)\n\ndef primeFactor(n):\n\n    i = 2\n\n    ret = {}\n\n    rhoFlg = 0\n\n    while i*i <= n:\n\n        k = 0\n\n        while n % i == 0:\n\n            n //= i\n\n            k += 1\n\n        if k: ret[i] = k\n\n        i += 1 + i % 2\n\n        if i == 101 and n >= 2 ** 20:\n\n            while n > 1:\n\n                if isPrimeMR(n):\n\n                    ret[n], n = 1, 1\n\n                else:\n\n                    rhoFlg = 1\n\n                    j = findFactorRho(n)\n\n                    k = 0\n\n                    while n % j == 0:\n\n                        n //= j\n\n                        k += 1\n\n                    ret[j] = k\n\n\n\n    if n > 1: ret[n] = 1\n\n    if rhoFlg: ret = {x: ret[x] for x in sorted(ret)}\n\n    return ret\n\ndef gcd(a, b):\n\n    while b: a, b = b, a % b\n\n    return a\n\n\n\nN = int(eval(input()))\n\nA = list(map(int, input().split()))\n\n# N = 10 ** 6\n\n# A = [10 ** 6] * N\n\npairwise = False\n\nprime_key = set(primeFactor(A[-1]).keys())\n\nbreak_flag = False\n\nprime_flags = [False] * (10 ** 6 + 1)\n\nfor i in range(N):\n\n    for key in list(primeFactor(A[i]).keys()):\n\n        if prime_flags[key]:\n\n            break_flag = True\n\n            break\n\n        else:\n\n            prime_flags[key] = True\n\n    if break_flag:\n\n        break\n\nelse:\n\n    pairwise = True\n\nif pairwise:\n\n    print('pairwise coprime')\n\n    exit()\n\nwork = gcd(A[0], A[1])\n\nfor i in range(2, N):\n\n    work = gcd(work, A[i])\n\nif work != 1:\n\n    print('not coprime')\n\nelse:\n\n    print('setwise coprime')", "score": 1.0, "surface_similarity": 0.69665907365224}
{"id": "p03074_u600402037", "golden_code": "import numpy as np\n\n\n\nN, K = list(map(int, input().split()))\n\nS = list(eval(input())) + ['2']\n\n\n\nblocks = []\n\ncur = 1\n\nseq = 0\n\nfor s in S:\n\n    if int(s) == cur:\n\n        seq += 1\n\n    else:\n\n        blocks.append(seq)\n\n        cur = 1 - cur\n\n        seq = 1\n\nanswer = 0\n\nblocks = np.array(blocks)\n\nfor i in range(0, len(blocks), 2):\n\n    answer = max(answer, blocks[i:i+2*K+1].sum())\n\nprint(answer)\n", "generated_code": "# coding: utf-8\n\nimport sys\n\nimport itertools\n\n\n\nsr = lambda: sys.stdin.readline().rstrip()\n\nir = lambda: int(sr())\n\nlr = lambda: list(map(int, sr().split()))\n\n\n\n# 0か1の連続している人数のリスト、累積和\n\nstreak = [0, 0]\n\nN, K = lr()\n\nS = sr() + '2'\n\ncur = 1\n\nfor i in range(N):\n\n    if S[i] != S[i+1]:\n\n        streak.append(cur)\n\n        cur = 1\n\n    else:\n\n        cur += 1\n\n\n\nstreak_cum = list(itertools.accumulate(streak))\n\nstreak_cum.extend([streak_cum[-1], streak_cum[-1]])\n\nif S[0] == '0':\n\n    start = 0\n\nelse:\n\n    start = 1\n\nanswer = 0\n\n\n\nlimit = len(streak_cum) - 1\n\nfor i in range(start, len(streak_cum), 2):\n\n    result = streak_cum[min(limit, i+2*K+1)] - streak_cum[i]\n\n    if result > answer:\n\n        answer = result\n\n\n\nprint(answer)\n\n# 52", "score": 1.0, "surface_similarity": 0.6219853810128244}
{"id": "p03945_u315485238", "golden_code": "import numpy as np\n\n\n\nS=eval(input())\n\nS=np.array([1 if s=='B' else 0 for s in S])\n\n\n\nprint((np.abs(np.diff(S)).sum()))\n", "generated_code": "from itertools import groupby\n\n\n\nS=eval(input())\n\nanswer = sum([1 for _ in groupby(S)]) -1\n\n\n\nprint(answer)", "score": 1.0, "surface_similarity": 0.4853070175438597}
{"id": "p02901_u312025627", "golden_code": "INF = 2*10**7\n\n\n\n\n\ndef main():\n\n    N, M = (int(i) for i in input().split())\n\n    A = []\n\n    B = []\n\n    C = []\n\n    for _ in range(M):\n\n        a, b = (int(i) for i in input().split())\n\n        A.append(a)\n\n        B.append(b)\n\n        bit = 0\n\n        for i in input().split():\n\n            bit |= (1 << (int(i)-1))\n\n        C.append(bit)\n\n    dp = [[INF]*(1 << N) for _ in range(M+1)]\n\n    dp[0][0] = 0\n\n    for i in range(M):\n\n        for j in range(1 << N):\n\n            dp[i+1][j] = min(dp[i+1][j], dp[i][j])\n\n            if dp[i][j] != INF:\n\n                next_bit = j | C[i]\n\n                dp[i+1][next_bit] = min(dp[i+1][next_bit], dp[i][j] + A[i])\n\n    ans = dp[-1][-1]\n\n    if ans == INF:\n\n        print((-1))\n\n    else:\n\n        print(ans)\n\n    # print(*dp, sep=\"\\n\")\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "generated_code": "INF = 2*10**7\n\n\n\n\n\ndef main():\n\n    import sys\n\n    input = sys.stdin.buffer.readline\n\n    N, M = (int(i) for i in input().split())\n\n    A = []\n\n    B = []\n\n    C = []\n\n    for _ in range(M):\n\n        a, b = (int(i) for i in input().split())\n\n        A.append(a)\n\n        B.append(b)\n\n        bit = 0\n\n        for i in input().split():\n\n            bit |= (1 << (int(i)-1))\n\n        C.append(bit)\n\n    dp = [[INF]*(1 << N) for _ in range(M+1)]\n\n    dp[0][0] = 0\n\n    for i in range(M):\n\n        for j in range(1 << N):\n\n            dp[i+1][j] = min(dp[i+1][j], dp[i][j])\n\n            if dp[i][j] != INF:\n\n                next_bit = j | C[i]\n\n                dp[i+1][next_bit] = min(dp[i+1][next_bit], dp[i][j] + A[i])\n\n    ans = dp[-1][-1]\n\n    if ans == INF:\n\n        print((-1))\n\n    else:\n\n        print(ans)\n\n    # print(*dp, sep=\"\\n\")\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 1.0, "surface_similarity": 0.9476729153199741}
{"id": "p03575_u025501820", "golden_code": "#!/usr/bin/env python3\n\nclass UnionFind():\n\n    def __init__(self, n):\n\n        self.n = n\n\n        self.parents = [-1] * n\n\n\n\n    def find(self, x):\n\n        if self.parents[x] < 0:\n\n            return x\n\n        else:\n\n            self.parents[x] = self.find(self.parents[x])\n\n            return self.parents[x]\n\n\n\n    def union(self, x, y):\n\n        x = self.find(x)\n\n        y = self.find(y)\n\n\n\n        if x == y:\n\n            return\n\n\n\n        if self.parents[x] > self.parents[y]:\n\n            x, y = y, x\n\n\n\n        self.parents[x] += self.parents[y]\n\n        self.parents[y] = x\n\n    \n\n\n\n    def same(self, x, y):\n\n        return self.find(x) == self.find(y)\n\n        \n\nimport numpy as np\n\nN, M = list(map(int, input().split()))\n\nedge = []\n\nfor _ in range(M):\n\n    edge.append(list(map(int, input().split())))\n\nans = 0 \n\nfor i in range(M):\n\n    unionfind = UnionFind(N)\n\n    for j in [k for k in range(M) if k != i]:\n\n        a, b = edge[j][0] - 1, edge[j][1] - 1\n\n        unionfind.union(a, b)\n\n    if np.count_nonzero(np.array(unionfind.parents) < 0) >= 2:\n\n        ans += 1\n\nprint(ans)", "generated_code": "#!/usr/bin/env python3\n\nfrom collections import deque\n\nN, M = list(map(int, input().split()))\n\nedge = []\n\nfor _ in range(M):\n\n    edge.append(list(map(int, input().split())))\n\nans = 0 \n\nfor i in range(M):\n\n    done = [True for _ in range(N + 1)]\n\n    renketu = [[] for _ in range(N + 1)]\n\n    for j in [k for k in range(M) if k != i]:\n\n        a, b = edge[j][0], edge[j][1]\n\n        renketu[a].append(b)\n\n        renketu[b].append(a)\n\n    q = deque([1])\n\n    while q:\n\n        now = q.pop()\n\n        done[now] = False\n\n\n\n        for r in renketu[now]:\n\n            if done[r]:\n\n                q.append(r)\n\n    if sum(done) > 1:\n\n        ans += 1\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.5540426726558114}
{"id": "p03494_u123942276", "golden_code": "import numpy as np\n\nN = int(eval(input()))\n\nA = np.array(list(map(int, input().split())))\n\ncount = 0\n\nwhile True:\n\n    if np.sum(A%2) > 0:\n\n        break\n\n    count +=1\n\n    A = A//2\n\nprint(count)\n", "generated_code": "n = int(eval(input()))\n\na = list(map(int, input().split()))\n\n\n\nans = float(\"inf\")\n\n\n\nfor i in a:\n\n    ans = min(ans, len(bin(i)) - bin(i).rfind(\"1\") - 1) # (1)…2で割った回数が最小のものを探索\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.48135069521077023}
{"id": "p03253_u427344224", "golden_code": "def prime_factorize(num):\n\n    \"\"\"\n\n    This function performs prime factorization on the input natural number.\n\n    The result is returned in the form of a dictionary with the prime number as the key\n\n    and its number as the value.\n\n    :param num:\n\n    :return prime_factor: Dictionary with the prime number as the key and its number as the value.\n\n    \"\"\"\n\n    prime_factor = {}\n\n    i = 2\n\n    while i ** 2 <= num:\n\n        while num % i == 0:\n\n            num //= i\n\n            if i in list(prime_factor.keys()):\n\n                prime_factor[i] += 1\n\n            else:\n\n                prime_factor[i] = 1\n\n        i += 1\n\n    if num > 1:\n\n        prime_factor[num] = 1\n\n    return prime_factor\n\n\n\n\n\nfrom math import factorial\n\n\n\n\n\ndef comb(n, r, R):\n\n    if n not in R:\n\n        a = factorial(n)\n\n        R[n] = a\n\n    else:\n\n        a = R[n]\n\n\n\n    if n - r not in R:\n\n        b = factorial(n - r)\n\n        R[n - r] = b\n\n    else:\n\n        b = R[n - r]\n\n\n\n    if r not in R:\n\n        c = factorial(r)\n\n        R[r] = c\n\n    else:\n\n        c = R[r]\n\n    return a // (b * c)\n\n\n\n\n\nn, m = list(map(int, input().split()))\n\nr = 1\n\n\n\nR = dict()\n\nprime_fac = prime_factorize(m)\n\nfor v in list(prime_fac.values()):\n\n    r *= comb(v + n - 1, v, R)\n\nmod = 1000000000 + 7\n\nprint((r % mod))\n", "generated_code": "def prime_factorize(num):\n\n    \"\"\"\n\n    This function performs prime factorization on the input natural number.\n\n    The result is returned in the form of a dictionary with the prime number as the key\n\n    and its number as the value.\n\n    :param num:\n\n    :return prime_factor: Dictionary with the prime number as the key and its number as the value.\n\n    \"\"\"\n\n    prime_factor = {}\n\n    i = 2\n\n    while i ** 2 <= num:\n\n        while num % i == 0:\n\n            num //= i\n\n            if i in list(prime_factor.keys()):\n\n                prime_factor[i] += 1\n\n            else:\n\n                prime_factor[i] = 1\n\n        i += 1\n\n    if num > 1:\n\n        prime_factor[num] = 1\n\n    return prime_factor\n\n\n\n\n\n\n\ndef combination(n, r):\n\n    r = min(n-r, r)\n\n    result = 1\n\n    for i in range(n, n-r, -1):\n\n        result *= i\n\n    for i in range(1, r+1):\n\n        result //= i\n\n    return result\n\n\n\n\n\nn, m = list(map(int, input().split()))\n\nr = 1\n\n\n\nprime_fac = prime_factorize(m)\n\nfor v in list(prime_fac.values()):\n\n    r *= combination(v + n - 1, v)\n\nmod = 1000000000 + 7\n\nprint((r % mod))\n", "score": 1.0, "surface_similarity": 0.8690437303499245}
{"id": "p02951_u768896740", "golden_code": "a, b, c = list(map(int, input().split()))\n\n\n\nif a < b + c:\n\n    print((b+c-a))\n\nelse:\n\n    print((0))", "generated_code": "a,b,c = list(map(int, input().split()))\n\n\n\nprint((max(0, c-(a-b))))", "score": 1.0, "surface_similarity": 0.7264851485148515}
{"id": "p03038_u075012704", "golden_code": "from collections import Counter\n\nN, M = list(map(int, input().split()))\n\nA = list(map(int, input().split()))\n\n\n\nX = Counter(A)\n\nfor i in range(M):\n\n    B, C = list(map(int, input().split()))\n\n    X[C] += B\n\n\n\nZ = []\n\nfor key, value in list(X.items()):\n\n    Z.append((key, value))\n\n\n\nZ.sort(key=lambda x: x[0], reverse=True)\n\n\n\nans = 0\n\ncnt = 0\n\n\n\nfor value, key in Z:\n\n    if cnt + key <= N:\n\n        ans += key * value\n\n        cnt += key\n\n    else:\n\n        ans += (N - cnt) * value\n\n        break\n\n\n\nprint(ans)\n", "generated_code": "N, M = list(map(int, input().split()))\n\nA = sorted(list(map(int, input().split())))\n\nquery = []\n\nfor i in range(M):\n\n    b, c = list(map(int, input().split()))\n\n    query.append([b, c])\n\nquery.sort(key=lambda q: q[1], reverse=True)\n\n\n\n\n\ni = 0\n\nfor b, c in query:\n\n    while i < N and b > 0:\n\n        if A[i] < c:\n\n            A[i] = c\n\n            b -= 1\n\n        i += 1\n\n\n\nprint((sum(A)))\n", "score": 1.0, "surface_similarity": 0.6514648661020829}
{"id": "p03723_u576335153", "golden_code": "a, b, c = list(map(int, input().split()))\n\n\n\nif any(i % 2 != 0 for i in [a, b, c]):\n\n    print((0))\n\n    exit()\n\n\n\nif a == b and b == c:\n\n    print((-1))\n\n    exit()\n\n\n\ncnt = 0\n\na_list = [0]*(1001001)\n\nb_list = [0]*(1001001)\n\nc_list = [0]*(1001001)\n\na_list[0] = a\n\nb_list[0] = b\n\nc_list[0] = c\n\n\n\nfor i in range(1, 1001001):\n\n    a_list[i] = (b_list[i-1] + c_list[i-1]) // 2\n\n    b_list[i] = (c_list[i-1] + a_list[i-1]) // 2\n\n    c_list[i] = (a_list[i-1] + b_list[i-1]) // 2\n\n    cnt += 1\n\n    if a_list[i] % 2 != 0 or b_list[i] % 2 != 0 or c_list[i] % 2 != 0:\n\n        break\n\n\n\nprint(cnt)\n", "generated_code": "def solve(a, b, c):\n\n    if any(i % 2 == 1 for i in [a, b, c]):\n\n        return 0\n\n    if a == b == c:\n\n        return -1\n\n    a, b, c = (b + c) // 2, (c + a) // 2, (a + b) // 2\n\n    return solve(a, b, c) + 1\n\n\n\na, b, c = list(map(int, input().split()))\n\n\n\nprint((solve(a, b, c)))", "score": 1.0, "surface_similarity": 0.510009161704077}
{"id": "p03013_u463655976", "golden_code": "from functools import lru_cache\n\nimport sys\n\nsys.setrecursionlimit(30000)\n\n\n\nN, M = list(map(int, input().split()))\n\na = list(int(eval(input())) for _ in range(M))\n\n\n\nMOD = pow(10, 9) + 7\n\n\n\nisOk = True\n\nfor i in range(M-1):\n\n    if a[i] + 1 == a[i+1]:\n\n        isOk = False\n\n    \n\nfuncb = [-1] * 100001\n\ndef func(n):\n\n    if n <= 0:\n\n        return 1\n\n    cnt = funcb[n]\n\n    if cnt > 0:\n\n        return cnt\n\n    cnt = 0\n\n    if n >= 2:\n\n        cnt += func(n-2)\n\n    if n >= 1:\n\n        cnt += func(n-1)\n\n    funcb[n] = cnt % MOD\n\n    return funcb[n]\n\n\n\nfunc(30000)\n\nfunc(50000)\n\nfunc(80000)\n\nfunc(100000)\n\n\n\nif not isOk:\n\n    print((0))\n\nelse:\n\n    ans = 1\n\n    s = 0\n\n    for i in range(M+1):\n\n        if i >= M:\n\n            e = N\n\n        else:\n\n            e = a[i] - 1\n\n\n\n        ans = ans * func(e-s) % MOD\n\n\n\n        if i >= M:\n\n            break\n\n\n\n        s = a[i] + 1\n\n\n\n    print(ans)\n", "generated_code": "N, M = list(map(int, input().split()))\n\na = list(int(eval(input())) for _ in range(M))\n\n\n\nMOD = pow(10, 9) + 7\n\n\n\nMAP = [0] * (N + 1)\n\n\n\nfor x in a:\n\n    MAP[x] = -1\n\n\n\nMAP[0] = 1 \n\nfor i in range(N):\n\n    if MAP[i] < 0:\n\n        continue\n\n\n\n    MAP[i] %= MOD\n\n    if i + 1 <= N and MAP[i+1] >= 0:\n\n        MAP[i+1] += MAP[i]\n\n    if i + 2 <= N and MAP[i+2] >= 0:\n\n        MAP[i+2] += MAP[i]\n\n\n\nprint((MAP[N] % MOD))\n", "score": 1.0, "surface_similarity": 0.5859223426546292}
{"id": "p02780_u062484507", "golden_code": "import sys\n\nimport numpy as np\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\nn, k = list(map(int, readline().split()))\n\np = list(map(int, readline().split()))\n\n\n\ntmp = [(i+1)/2 for i in p]\n\ncs = list(np.cumsum(tmp))\n\n\n\nif n == k:\n\n    print((cs[-1]))\n\n    exit()\n\nans = 0\n\nfor i in range(n - k):\n\n    ans = max(ans, cs[i + k] - cs[i])\n\nprint(ans)", "generated_code": "import sys\n\n# import numpy as np\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\nn, k = list(map(int, readline().split()))\n\np = list(map(int, readline().split()))\n\n\n\ntmp = [(i+1)/2 for i in p]\n\n# cs = list(np.cumsum(tmp))\n\n\n\ncs = [0]*n\n\ncs[0] = tmp[0]\n\nfor i in range(len(tmp)-1):\n\n    cs[i + 1] = cs[i] + tmp[i + 1]\n\n\n\nif n == k:\n\n    print((cs[-1]))\n\n    exit()\n\nans = 0\n\nfor i in range(n - k):\n\n    ans = max(ans, cs[i + k] - cs[i])\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.8936974789915967}
{"id": "p02690_u402629484", "golden_code": "'''\n\nA = 500 とする。\n\nこのとき、X = 10^9 となるのは、 B = 499.9968... のとき。\n\n→ AまたはB (の絶対値) が大きすぎると、Xが10^9に収まらない。\n\n\n\nA, Bの探索範囲は -120~120で十分。\n\n'''\n\n\n\nfrom itertools import product\n\n\n\ndef main():\n\n    X = int(eval(input()))\n\n    for A, B in product(list(range(-150, 150)), list(range(-150, 150))):\n\n        if A**5 - B**5 == X:\n\n            print((A, B))\n\n            return\n\n\n\nmain()\n\n\n", "generated_code": "from itertools import count\n\n\n\ndef main():\n\n    X = int(eval(input()))\n\n    for i in count():\n\n        for A in (-i, i):\n\n            for B in range(-i, i+1):\n\n                if A**5 - B**5 == X:\n\n                    print((A, B))\n\n                    return\n\n\n\n\n\nmain()\n", "score": 1.0, "surface_similarity": 0.7548423423423423}
{"id": "p02921_u254871849", "golden_code": "# 2019-11-17 20:44:23(JST)\n\nimport sys\n\n# import collections\n\n# import math\n\n# from string import ascii_lowercase, ascii_uppercase, digits\n\n# from bisect import bisect_left as bi_l, bisect_right as bi_r\n\n# import itertools\n\n# from functools import reduce\n\n# import operator as op\n\n# import re\n\n# import heapq\n\n# import array\n\n# from scipy.misc import comb # (default: exact=False)\n\n# import numpy as np \n\n\n\n\n\ndef main():\n\n    s, t = sys.stdin.read().split()\n\n\n\n    count = 0\n\n    for i in range(3):\n\n        if s[i] == t[i]:\n\n            count += 1\n\n    print(count)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "generated_code": "import sys\n\n\n\ns, t = sys.stdin.read().split()\n\n\n\ndef main():\n\n    cnt = 0\n\n    for i in range(3):\n\n        if s[i] == t[i]:\n\n            cnt += 1\n\n    return cnt\n\n    \n\nif __name__ == '__main__':\n\n    ans = main()\n\n    print(ans)", "score": 1.0, "surface_similarity": 0.937344339286985}
{"id": "p03494_u925626880", "golden_code": "# -*- coding: utf-8 -*-\n\n\n\nimport numpy as np\n\n\n\nn = int(eval(input()))\n\nl = np.array(list(map(int, input().split())))\n\n\n\ncount = 0\n\n\n\nwhile(1):\n\n    if all(1 - (l % 2)):\n\n        count += 1\n\n        l = l / 2\n\n    else:\n\n        break\n\n\n\nprint(count)\n", "generated_code": "N = eval(input())\n\nA = list(map(int, input().split()))\n\n\n\ncount = 0\n\nwhile all(a%2==0 for a in A):\n\n    count += 1\n\n    A = [a/2 for a in A]\n\n\n\nprint(count)\n", "score": 1.0, "surface_similarity": 0.6690476190476191}
{"id": "p03416_u254871849", "golden_code": "#                         author:  kagemeka \n\n#                         created: 2019-11-06 21:30:22(JST)\n\nimport sys\n\n# import collections\n\n# import math\n\n# import string\n\n# import bisect\n\n# import re\n\n# import itertools\n\n# import statistics\n\n# import functools\n\n# import operator\n\n\n\ndef main():\n\n    a, b = (int(x) for x in sys.stdin.read().split())\n\n\n\n    count = 0\n\n    for n in range(a, b+1):\n\n        n = str(n)\n\n        if n == n[::-1]:\n\n            count += 1\n\n\n\n    print(count)       \n\n\n\nif __name__ == \"__main__\":\n\n    # execute only if run as a script\n\n    main()\n", "generated_code": "import sys\n\nfrom bisect import bisect_left as bi_l, bisect_right as bi_r\n\n\n\na, b = list(map(int, sys.stdin.readline().split()))\n\n\n\ndef main():\n\n    palindromic_nums = []\n\n    for i in range(1, 10):\n\n        for j in range(10):\n\n            for k in range(10):\n\n                x = [i, j, k, j, i]\n\n                palindromic_nums.append(int(''.join(list(map(str, x)))))\n\n\n\n    return bi_r(palindromic_nums, b) - bi_l(palindromic_nums, a)\n\n                \n\nif __name__ == '__main__':\n\n    ans = main()\n\n    print(ans)", "score": 1.0, "surface_similarity": 0.5894377240143369}
{"id": "p02767_u729939940", "golden_code": "N = int(eval(input()))\n\nX = list(map(int, input().split()))\n\nX = list(sorted(X))\n\nif N == 1:\n\n  print((0))\n\n  exit()\n\nans = float('inf')\n\nfor p in range(X[0], X[N - 1] + 1):\n\n  sum = 0\n\n  for x in X:\n\n    sum += (x - p) ** 2\n\n  ans = min(sum, ans)\n\nprint(ans)", "generated_code": "N = int(eval(input()))\n\nX = list(map(int, input().split()))\n\navg = round(sum(X) / N)\n\nprint((sum([(x - avg) ** 2 for x in X])))", "score": 1.0, "surface_similarity": 0.5330703374181636}
{"id": "p03428_u340781749", "golden_code": "from collections import Counter\n\n\n\nimport numpy as np\n\n\n\n\n\ndef part(pts, a, ans):\n\n    b = np.dot(pts, [np.sin(a), np.cos(a)])\n\n    c = np.argmax(b, axis=0)\n\n    for i, v in list(Counter(c).items()):\n\n        ans[i] += v\n\n\n\n\n\ndef solve(n, pts):\n\n    ans = [0] * n\n\n    part(pts, np.linspace(0, np.pi, 100000, endpoint=False), ans)\n\n    part(pts, np.linspace(np.pi, 2 * np.pi, 100000, endpoint=False), ans)\n\n    return [v / 200000 for v in ans]\n\n\n\n\n\nn = int(eval(input()))\n\npts = np.array([list(map(int, input().split())) for _ in range(n)])\n\nprint(('\\n'.join(map(str, solve(n, pts)))))\n", "generated_code": "from collections import Counter\n\nimport numpy as np\n\n\n\n\n\ndef part(pts, s, t, num, ans):\n\n    a = np.linspace(s, t, num, endpoint=False)\n\n    for i, v in list(Counter(np.argmax(np.dot(pts, [np.sin(a), np.cos(a)]), axis=0)).items()):\n\n        ans[i] += v\n\n\n\n\n\ndef solve(n, pts):\n\n    ans = np.zeros(n)\n\n    part(pts, 0, np.pi, 1e5, ans)\n\n    part(pts, np.pi, 2 * np.pi, 1e5, ans)\n\n    return ans / 2e5\n\n\n\n\n\nn = int(eval(input()))\n\nprint(('\\n'.join(map(str, solve(n, [list(map(int, input().split())) for _ in range(n)])))))\n", "score": 1.0, "surface_similarity": 0.7909556313993173}
{"id": "p02725_u628335443", "golden_code": "k, n = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\nd = [0] * n\n\nd_max = 0\n\n\n\nfor i in range(n - 1):\n\n    d[i] = a[i + 1] - a[i]\n\n    d_max = max(d_max, d[i])\n\n\n\nd[-1] = (k - a[-1]) + a[0]\n\nd_max = max(d_max, d[-1])\n\n\n\nprint((k - d_max))\n", "generated_code": "k, n = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\nd_max = 0\n\n\n\nfor i in range(n - 1):\n\n    d = a[i + 1] - a[i]\n\n    d_max = max(d_max, d)\n\n\n\nd = (k - a[-1]) + a[0]\n\nd_max = max(d_max, d)\n\n\n\nprint((k - d_max))\n", "score": 1.0, "surface_similarity": 0.9081749049429657}
{"id": "p02822_u864197622", "golden_code": "import sys\n\ninput = sys.stdin.readline\n\nfrom collections import deque\n\nN = int(eval(input()))\n\nX = [[] for i in range(N)]\n\nfor i in range(N-1):\n\n    x, y = list(map(int, input().split()))\n\n    X[x-1].append(y-1)\n\n    X[y-1].append(x-1)\n\ni0 = min([i for i in range(N) if len(X[i]) == 1])\n\n\n\nP = [-1] * N\n\nQ = deque([i0])\n\nR = []\n\nwhile Q:\n\n    i = deque.popleft(Q)\n\n    R.append(i)\n\n    for a in X[i]:\n\n        if a != P[i]:\n\n            P[a] = i\n\n            X[a].remove(i)\n\n            deque.append(Q, a)\n\n\n\nmod = 10 ** 9 + 7\n\ninv2 = (mod + 1) // 2\n\nA = [1] * N\n\nfor i in R[::-1]:\n\n    s = 0\n\n    for j in X[i]:\n\n        A[i] += A[j]\n\n\n\nans = 0\n\nfor i in range(N):\n\n    s = pow(inv2, N - A[i], mod)\n\n    t = 1 + (1-pow(inv2, N - A[i], mod)) * pow(2, N - A[i], mod)\n\n    for j in X[i]:\n\n        s = (s * pow(inv2, A[j], mod)) % mod\n\n        t = (t + (1-pow(inv2, A[j], mod)) * pow(2, A[j], mod)) % mod\n\n    ans = (ans + 1 - s * t) % mod\n\n\n\nprint((ans * inv2 % mod))", "generated_code": "import sys\n\ninput = sys.stdin.readline\n\nfrom collections import deque\n\nN = int(eval(input()))\n\nX = [[] for i in range(N)]\n\nfor i in range(N-1):\n\n    x, y = list(map(int, input().split()))\n\n    X[x-1].append(y-1)\n\n    X[y-1].append(x-1)\n\ni0 = min([i for i in range(N) if len(X[i]) == 1])\n\n\n\nP = [-1] * N\n\nQ = deque([i0])\n\nR = []\n\nwhile Q:\n\n    i = deque.popleft(Q)\n\n    R.append(i)\n\n    for a in X[i]:\n\n        if a != P[i]:\n\n            P[a] = i\n\n            X[a].remove(i)\n\n            deque.append(Q, a)\n\n\n\nmod = 10 ** 9 + 7\n\npow2 = [1]\n\nfor i in range(N + 10):\n\n    pow2.append(pow2[-1] * 2 % mod)\n\ninv2 = (mod + 1) // 2\n\n\n\ninvpow2 = [pow(pow2[-1], mod-2, mod)]\n\nfor i in range(N + 10)[::-1]:\n\n    invpow2.append(invpow2[-1] * 2 % mod)\n\ninvpow2 = invpow2[::-1]\n\n\n\nA = [1] * N\n\nfor i in R[::-1]:\n\n    s = 0\n\n    for j in X[i]:\n\n        A[i] += A[j]\n\n\n\nans = 0\n\nfor i in range(N):\n\n    s = pow(inv2, N - A[i], mod)\n\n    t = 1 + (1-invpow2[N-A[i]]) * pow2[N-A[i]]\n\n    for j in X[i]:\n\n        s = (s * invpow2[A[j]]) % mod\n\n        t = (t + (1-invpow2[A[j]]) * pow2[A[j]]) % mod\n\n    ans = (ans + 1 - s * t) % mod\n\n\n\nprint((ans * inv2 % mod))", "score": 1.0, "surface_similarity": 0.9019264448336253}
{"id": "p03575_u474423089", "golden_code": "import numpy as np\n\nfrom scipy.sparse.csgraph import connected_components\n\nfrom scipy.sparse import csr_matrix\n\ndef main():\n\n    n,m=list(map(int,input().split(' ')))\n\n    graph=[[0 for i in range(n)] for j in range(n)]\n\n    graph_del=[]\n\n    ans = 0\n\n\n\n    for i in range(m):\n\n        e_1,e_2=list(map(int,input().split(' ')))\n\n        graph[e_1-1][e_2-1]=1\n\n        graph[e_2-1][e_1-1]=1\n\n        graph_del.append((e_1,e_2))\n\n\n\n    for i,j in graph_del:\n\n        graph[i-1][j-1]=0\n\n        graph[j-1][i-1]=0\n\n        if connected_components(np.array(graph),return_labels=False)!=1:\n\n            ans += 1\n\n        graph[i-1][j-1]=1\n\n        graph[j-1][i-1]=1\n\n    print(ans)\n\n\n\n\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "generated_code": "class UnionFind:\n\n    def __init__(self,N):\n\n        self.par =[-1 for i in range(N)]\n\n    def find(self,x):\n\n        if self.par[x] < 0:\n\n            return x\n\n        else:\n\n            self.par[x] = self.find(self.par[x])\n\n            return self.par[x]\n\n\n\n    def unite(self,x,y):\n\n        x = self.find(x)\n\n        y = self.find(y)\n\n        if x==y:\n\n            return\n\n        if self.par[x] > self.par[y]:\n\n            x,y = y,x\n\n        self.par[x] +=self.par[y]\n\n        self.par[y] = x\n\n\n\n    def size(self,x):\n\n        return -self.par[self.find(x)]\n\n    def same(self,x,y):\n\n        return self.find(x)==self.find(y)\n\n\n\nN,M=list(map(int,input().split(' ')))\n\nq = [list(map(int,input().split(' '))) for i in range(M)]\n\nans = 0\n\nfor i in range(M):\n\n    tmp = q[:i]+q[i+1:]\n\n    uf = UnionFind(N)\n\n    for j,k in tmp:\n\n        uf.unite(j-1,k-1)\n\n    for l in range(N):\n\n        if uf.size(l) != N:\n\n            ans += 1\n\n            break\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.5418669871794872}
{"id": "p03060_u898080410", "golden_code": "import numpy as np\n\n\n\nn = int(eval(input()))\n\nv = np.array(list(map(int, input().split())))\n\nc = np.array(list(map(int, input().split())))\n\np = v-c\n\nans = 0\n\nfor i in p:\n\n    if i>0:\n\n        ans+=i\n\n\n\nprint(ans)\n", "generated_code": "n=int(eval(input()))\n\nV=list(map(int,input().split()))\n\nC=list(map(int,input().split()))\n\nans=0\n\nfor v,c in zip(V,C):\n\n    diff=v-c\n\n    if 0<diff:\n\n        ans+=diff\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.7166331321260898}
{"id": "p02725_u624696727", "golden_code": "import sys\n\nimport numpy as np\n\n\n\nsys.setrecursionlimit(10 ** 6)\n\nint1 = lambda x: int(x) - 1\n\nprintV = lambda x: print(*x, sep=\"\\n\")\n\nprintH = lambda x: print(\" \".join(map(str,x)))\n\ndef IS(): return sys.stdin.readline()[:-1]\n\ndef II(): return int(sys.stdin.readline())\n\ndef MI(): return map(int, sys.stdin.readline().split())\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\n\ndef LI1(): return list(map(int1, sys.stdin.readline().split()))\n\ndef LII(rows_number): return [II() for _ in range(rows_number)]\n\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\n\ndef LLI1(rows_number): return [LI1() for _ in range(rows_number)]\n\n\n\ndef main():\n\n\tK,N = MI()\n\n\tA = np.array(LI())\n\n\tA_LAST = K+A[0] - A[N-1]\n\n\tB = A[1:]-A[:N-1]\n\n\tB = np.sort(B)\n\n\tprint(K-max(B[N-2],A_LAST))\n\n\n\nif __name__ == '__main__':\n\n\tmain()\n", "generated_code": "import sys\n\n\n\nsys.setrecursionlimit(10 ** 6)\n\nint1 = lambda x: int(x) - 1\n\nprintV = lambda x: print(*x, sep=\"\\n\")\n\nprintH = lambda x: print(\" \".join(map(str,x)))\n\ndef IS(): return sys.stdin.readline()[:-1]\n\ndef II(): return int(sys.stdin.readline())\n\ndef MI(): return map(int, sys.stdin.readline().split())\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\n\ndef LI1(): return list(map(int1, sys.stdin.readline().split()))\n\ndef LII(rows_number): return [II() for _ in range(rows_number)]\n\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\n\ndef LLI1(rows_number): return [LI1() for _ in range(rows_number)]\n\n\n\ndef main():\n\n\tk,n = MI()\n\n\ta = LI()\n\n\tb = [0]*n\n\n\tfor i in range(n):\n\n\t\tif i == n-1:\n\n\t\t\tb[i] = a[0]+k-a[i]\n\n\t\telse:\n\n\t\t\tb[i] = a[i+1]-a[i]\n\n\tb.sort()\n\n\tprint(k-b[-1])\n\n\n\n\n\nif __name__ == '__main__':\n\n\tmain()\n", "score": 1.0, "surface_similarity": 0.8984992101105844}
{"id": "p02702_u135847648", "golden_code": "from collections import defaultdict\n\nimport numpy as np\n\ndef main():\n\n    s = eval(input())\n\n    n = len(s)\n\n    d = np.zeros(2019,np.int64)\n\n    ans = 0\n\n    num = 0\n\n    pow10 = 1\n\n    d[0] = 1\n\n    for i in reversed(list(range(n))):\n\n        pow10 = pow10 * 10 % 2019\n\n        num += int(s[i]) * pow10\n\n        #print(num, num % 2019, i)\n\n        mod = num % 2019\n\n        ans += d[mod]\n\n        d[mod] += 1\n\n    print(ans)\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "generated_code": "from collections import defaultdict\n\n\n\ndef main():\n\n    s = eval(input())\n\n    n = len(s)\n\n    ans = 0\n\n    num = 0\n\n    pow10 = 1\n\n    d = defaultdict(int)\n\n    d[0] = 1\n\n    for i in reversed(list(range(n))):\n\n        # pow10を10 ** (n-1-i)にしてるだけでTLEしていた\n\n        pow10 = pow10 * 10 % 2019\n\n        num += int(s[i]) * pow10\n\n        mod = num % 2019\n\n        ans += d[mod]\n\n        d[mod] += 1\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "score": 1.0, "surface_similarity": 0.9002985074626866}
{"id": "p03796_u301624971", "golden_code": "from math import factorial\n\ndef myAnswer(N:int) ->int:\n\n   ans =factorial(N)\n\n   return ans % (10**9 + 7)\n\n\n\ndef modelAnswer():\n\n   tmp=1\n\ndef main():\n\n   N = int(eval(input()))\n\n   print((myAnswer(N)))\n\n\n\n\n\nif __name__ == '__main__':\n\n   main()", "generated_code": "def modelAnswer(N:int) -> int:\n\n   ans = 1\n\n   for i in range(1,N+1):\n\n      ans = (ans*i) % (10**9 + 7)\n\n   return ans \n\ndef main():\n\n   N = int(eval(input()))\n\n   print((modelAnswer(N)))\n\n\n\n\n\nif __name__ == '__main__':\n\n   main()\n", "score": 1.0, "surface_similarity": 0.7640638864241349}
{"id": "p02881_u714642969", "golden_code": "import numpy as np\n\n\n\nN=int(eval(input()))\n\na=int(np.sqrt(N))\n\nb=float('inf')\n\nfor i in range(1,a+1):\n\n    if N%i==0:\n\n        if i+N//i<b:\n\n            ans=i\n\n\n\nprint((ans+N//ans-2))\n", "generated_code": "# -*- coding: utf-8 -*-\n\nimport sys\n\nfrom math import sqrt\n\nsys.setrecursionlimit(10**9)\n\nINF=10**18\n\nMOD=10**9+7\n\ndef input(): return sys.stdin.readline().rstrip()\n\n\n\ndef main():\n\n    N=int(eval(input()))\n\n    tmp=INF\n\n    for i in range(1,10**6+1):\n\n        if N%i==0:\n\n            tmp=min(tmp,i+N//i)\n\n    print((tmp-2))\n\n    \n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 1.0, "surface_similarity": 0.6332712985938793}
{"id": "p03253_u814986259", "golden_code": "import math\n\nN, M = list(map(int, input().split()))\n\n\n\n\n\ndef factorization(n):\n\n    arr = []\n\n    temp = n\n\n    for i in range(2, int(-(-n**0.5//1))+1):\n\n        if temp % i == 0:\n\n            cnt = 0\n\n            while temp % i == 0:\n\n                cnt += 1\n\n                temp //= i\n\n            arr.append([i, cnt])\n\n    if temp != 1:\n\n        arr.append([temp, 1])\n\n\n\n    if arr == [] and n != 1:\n\n        arr.append([n, 1])\n\n\n\n    return arr\n\n\n\n\n\nmod = 10**9 + 7\n\n\n\n\n\ndef cmb(n, r, mod):\n\n    if (r < 0 or r > n):\n\n        return 0\n\n    r = min(r, n-r)\n\n    return g1[n] * g2[r] * g2[n-r] % mod\n\n\n\n\n\ng1 = [1, 1]\n\ng2 = [1, 1]\n\ninverse = [0, 1]\n\nfor i in range(2, 2*10**5 + 1):\n\n    g1.append((g1[-1] * i) % mod)\n\n    inverse.append((-inverse[mod % i] * (mod//i)) % mod)\n\n    g2.append((g2[-1] * inverse[-1]) % mod)\n\n\n\n\n\nprimes = factorization(M)\n\n# 何箇所に分けるか（cnt以下）,その中でどう分けるか（しきりをどこにおくか（振り分けられないものが出ると選べれないのとおなじになるので、cnt - 選んだ数））\n\n\n\nans = 1\n\n\n\nfor p, cnt in primes:\n\n    tmp = cmb(N+cnt-1, N-1, mod)\n\n    ans *= tmp\n\n    ans %= mod\n\n\n\nprint(ans)\n", "generated_code": "def main():\n\n    N, M = list(map(int, input().split()))\n\n\n\n    def factorization(n):\n\n        arr = []\n\n        temp = n\n\n        for i in range(2, int(-(-n**0.5//1))+1):\n\n            if temp % i == 0:\n\n                cnt = 0\n\n                while temp % i == 0:\n\n                    cnt += 1\n\n                    temp //= i\n\n                arr.append([i, cnt])\n\n        if temp != 1:\n\n            arr.append([temp, 1])\n\n\n\n        if arr == [] and n != 1:\n\n            arr.append([n, 1])\n\n\n\n        return arr\n\n\n\n    mod = 10**9 + 7\n\n\n\n    def cmb(n, r, mod):\n\n        if (r < 0 or r > n):\n\n            return 0\n\n        r = min(r, n-r)\n\n        return g1[n] * g2[r] * g2[n-r] % mod\n\n\n\n    g1 = [1, 1]\n\n    g2 = [1, 1]\n\n    inverse = [0, 1]\n\n    for i in range(2, N+100 + 1):\n\n        g1.append((g1[-1] * i) % mod)\n\n        inverse.append((-inverse[mod % i] * (mod//i)) % mod)\n\n        g2.append((g2[-1] * inverse[-1]) % mod)\n\n\n\n    primes = factorization(M)\n\n    # 何箇所に分けるか（cnt以下）,その中でどう分けるか（しきりをどこにおくか（振り分けられないものが出ると選べれないのとおなじになるので、cnt - 選んだ数））\n\n\n\n    ans = 1\n\n\n\n    for p, cnt in primes:\n\n        tmp = cmb(N+cnt-1, N-1, mod)\n\n        ans *= tmp\n\n        ans %= mod\n\n\n\n    print(ans)\n\n\n\n\n\nmain()\n", "score": 1.0, "surface_similarity": 0.9658485856905158}
{"id": "p03854_u991567869", "golden_code": "s = input()[::-1]\n\n\n\nwhile True:\n\n    if len(s) == 0:\n\n        break\n\n    if s[:7] == \"remaerd\":\n\n        s = s[7:]\n\n    elif s[:6] == \"resare\":\n\n        s = s[6:]\n\n    elif s[:5] == \"maerd\" or s[:5] == \"esare\":\n\n        s = s[5:]\n\n    else:\n\n        print(\"NO\")\n\n        exit()\n\n\n\nprint(\"YES\")", "generated_code": "import re\n\n\n\ns = eval(input())\n\n\n\nif re.fullmatch(r\"(dream|dreamer|erase|eraser)+\", s):\n\n    print(\"YES\")\n\nelse:\n\n    print(\"NO\")", "score": 1.0, "surface_similarity": 0.47155225726654304}
{"id": "p03074_u687343821", "golden_code": "import sys\n\nstdin = sys.stdin \n\nni = lambda: int(ns())\n\nna = lambda: list(map(int, stdin.readline().split()))\n\nns = lambda: stdin.readline()\n\n\n\ndef Solve():\n\n    N,K=na()\n\n    S=[int(d) for d in eval(input())]\n\n    l=[]\n\n    N=len(S)\n\n    if(S[0]==0):\n\n        l.append(0)\n\n    b=S[0]\n\n    ct=1\n\n    for i in S[1:]:\n\n        if(b!=i):\n\n            l.append(ct)\n\n            ct=1\n\n            b=i\n\n        else:\n\n            ct+=1\n\n    l.append(ct)\n\n    len_l=len(l)\n\n    if(len_l//2 <= K):\n\n        return sum(l)\n\n    ans = res = sum(l[:2*K+1])\n\n    \n\n    if(len_l%2==0):\n\n        l.append(0)\n\n        len_l+=1\n\n    g = K * 2 + 1\n\n    for i in range(K*2+1,len_l-1,2):\n\n        ans -= l[i-g] + l[i-g+1]\n\n        ans += l[i] + l[1+i]\n\n        if(res<ans):\n\n            res=ans\n\n    #print(S)\n\n    #print(l)\n\n    #print(len_l)\n\n    return res\n\n\n\nprint((Solve()))", "generated_code": "import sys\n\nstdin = sys.stdin \n\nni = lambda: int(ns())\n\nna = lambda: list(map(int, stdin.readline().split()))\n\nns = lambda: stdin.readline()\n\n\n\ndef Solve():\n\n    N,K=na()\n\n    S=eval(input())\n\n    l=[]\n\n    N=len(S)\n\n    #print(len(S))\n\n    if(S[0]==\"0\"):\n\n        #print(\"00\")\n\n        l.append(0)\n\n    t=S[0]\n\n    ct=1\n\n    #print(\"aa\")\n\n    #print(S)\n\n    #print(S[0],S[1],S[2])\n\n    for b in S[1:]:\n\n        #print(b)\n\n        if(t!=b):\n\n            l.append(ct)\n\n            ct=1\n\n            t=b\n\n        else:\n\n            ct+=1\n\n    #print(\"bb\")\n\n    l.append(ct)\n\n    len_l=len(l)\n\n    if(len_l//2 <= K):\n\n        return sum(l)\n\n    ans = res = sum(l[:2*K+1])\n\n    \n\n    if(len_l%2==0):\n\n        l.append(0)\n\n        len_l+=1\n\n    g = K * 2 + 1\n\n    for i in range(K*2+1,len_l-1,2):\n\n        ans -= l[i-g] + l[i-g+1]\n\n        ans += l[i] + l[1+i]\n\n        if(res<ans):\n\n            res=ans\n\n    #print(S)\n\n    #print(l)\n\n    #print(len_l)\n\n    return res\n\n\n\nprint((Solve()))", "score": 1.0, "surface_similarity": 0.9610319882446027}
{"id": "p02837_u157020659", "golden_code": "def check(x, y):\n\n    for a, b in zip(x, y):\n\n        if a != b and b != -1:\n\n            return False\n\n    else:\n\n        return True\n\n\n\n\n\nn = int(eval(input()))\n\nremarks = []\n\ncnt_max = 0\n\nfor _ in range(n):\n\n    a = int(eval(input()))\n\n    x = [tuple(map(int, input().split())) for i in range(a)]\n\n    r = [-1] * n\n\n    for i, j in x:\n\n        r[i - 1] = j\n\n    remarks.append(r)\n\nfor r in range(2 ** n):\n\n    r = list(bin(r)[2:].zfill(n))\n\n    r = [int(i) for i in r[:]]\n\n    cnt = 0\n\n    for i in range(n):\n\n        if r[i] == 1:\n\n            flag = check(r, remarks[i])\n\n            cnt += 1\n\n            if not flag:\n\n                cnt = 0\n\n                break\n\n    cnt_max = max(cnt, cnt_max)\n\nprint(cnt_max)", "generated_code": "import numpy as np\n\nimport itertools\n\n\n\nn = int(eval(input()))\n\ninfo = []\n\nfor i in range(n):\n\n    a = int(eval(input()))\n\n    for _ in range(a):\n\n        x, y = list(map(int, input().split()))\n\n        info.append((i, x - 1, y))\n\n\n\na = np.array(list(itertools.product([0, 1], repeat=n)), dtype=np.bool)\n\nfor i, x, y in info:\n\n    bl = (~a[:, i]) | (a[:, x] == bool(y))\n\n    a = a[bl]\n\n\n\nans = a.sum(axis=1).max()\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.5214470284237726}
{"id": "p03416_u886655280", "golden_code": "A, B = list(map(int, input().split()))\n\ncount_target = 0\n\n\n\nfor i in range(A, B + 1):\n\n    str_i = str(i)\n\n    reversed_i = ''\n\n    for n_th_i in reversed(list(range(len(str_i)))):\n\n        reversed_i += str_i[n_th_i]\n\n\n\n    if str_i == reversed_i:\n\n        count_target += 1\n\n\n\nprint(count_target)", "generated_code": "A, B = list(map(int, input().split()))\n\ncount_target = 0\n\n\n\nfor i in range(A, B+1):\n\n    str_i = str(i)\n\n    reversed_i = str_i[::-1]\n\n\n\n    if str_i == reversed_i:\n\n        count_target += 1\n\n\n\nprint(count_target)\n", "score": 1.0, "surface_similarity": 0.7966748017083587}
{"id": "p02881_u645250356", "golden_code": "from collections import Counter,defaultdict,deque\n\nimport sys,bisect,math,itertools,string,queue\n\nfrom heapq import heappop, heappush\n\nsys.setrecursionlimit(10**8)\n\nmod = 10**9+7\n\ndef inp(): return int(sys.stdin.readline())\n\ndef inpl(): return list(map(int, sys.stdin.readline().split()))\n\ndef inpl_str(): return list(sys.stdin.readline().split())\n\ndef inpln(n): return list(int(sys.stdin.readline()) for i in range(n))\n\n\n\nn = inp()\n\nres = float('inf')\n\nfor i in range(1,2*10**6):\n\n    if (n/i).is_integer():\n\n        res = min(res, i + n/i)\n\nprint((int(res-2)))\n", "generated_code": "from collections import Counter,defaultdict,deque\n\nimport sys,bisect,math,itertools,string,queue\n\nfrom heapq import heappop, heappush\n\nsys.setrecursionlimit(10**8)\n\nmod = 10**9+7\n\ndef inp(): return int(sys.stdin.readline())\n\ndef inpl(): return list(map(int, sys.stdin.readline().split()))\n\ndef inpl_str(): return list(sys.stdin.readline().split())\n\ndef inpln(n): return list(int(sys.stdin.readline()) for i in range(n))\n\n\n\nn = inp()\n\nres = float('inf')\n\nfor i in range(1,int(math.sqrt(n))+1):\n\n    if n%i == 0:\n\n        res = min(res, i + n/i)\n\nprint((int(res-2)))\n", "score": 1.0, "surface_similarity": 0.9062557216966738}
{"id": "p02555_u325956328", "golden_code": "S = int(eval(input()))\n\n\n\ndp = [0] * (S + 1)\n\ndp[0] = 1\n\nM = 10 ** 9 + 7\n\n\n\nfor i in range(1, S + 1):\n\n    num = 0\n\n    for j in range(i - 2):\n\n        num += dp[j]\n\n        dp[i] = num % M\n\n\n\nprint((dp[S]))\n\n\n", "generated_code": "S = int(eval(input()))\n\n\n\n\n\ndef cmb(n, r, p):\n\n    r = min(n - r, r)\n\n    if r == 0:\n\n        return 1\n\n    over = 1\n\n    for i in range(n, n - r, -1):\n\n        over = over * i % p\n\n    under = 1\n\n    for i in range(1, r + 1):\n\n        under = under * i % p\n\n    inv = pow(under, p - 2, p)\n\n    return over * inv % p\n\n\n\n\n\nM = 10 ** 9 + 7\n\nans = 0\n\nfor i in range(1, S):\n\n    if S - 3 * i < 0:\n\n        break\n\n    ans += cmb(S - 3 * i + i - 1, i - 1, M)\n\n    ans %= M\n\nprint(ans)\n", "score": 1.0, "surface_similarity": 0.5537230340988171}
{"id": "p02248_u260980560", "golden_code": "import random, math\n\nrandom.seed()\n\ndef gen(a, b, num):\n\n    result = set()\n\n    while 1:\n\n        while 1:\n\n            v = random.randint(a, b)//2*2+1\n\n            if v not in result:\n\n                break\n\n        for x in range(3, int(math.sqrt(v))+1, 2):\n\n            if v % x == 0:\n\n                break\n\n        else:\n\n            result.add(v)\n\n            if len(result) == num:\n\n                break\n\n    return result\n\nclass RH():\n\n    def __init__(self, s, base, mod):\n\n        self.base = base\n\n        self.mod = mod\n\n        self.rev = pow(base, mod-2, mod)\n\n\n\n        l = len(s)\n\n        self.h = h = [0]*(l+1)\n\n        tmp = 0\n\n        for i in range(l):\n\n            num = ord(s[i])\n\n            tmp = (tmp*base + num) % mod\n\n            h[i+1] = tmp\n\n    def calc(self, l, r):\n\n        return (self.h[r] - self.h[l] * pow(self.base, r-l, self.mod)) % self.mod\n\n    def fixed(self, length):\n\n        v = pow(self.base, length, self.mod)\n\n        h = self.h; mod = self.mod\n\n        def fixed_calc(l):\n\n            return (h[length+l] - h[l] * v) % mod\n\n        return fixed_calc\n\nclass RRH():\n\n    def __init__(self, s, num=10, primes=None):\n\n        primes = primes or gen(2, 10**3, num)\n\n        MOD = 10**9+7\n\n        self.rhs = [RH(s, p, MOD) for p in primes]\n\n    def calc(self, l, r):\n\n        return [rh.calc(l, r) for rh in self.rhs]\n\n    def fixed(self, length):\n\n        fs = [rh.fixed(length) for rh in self.rhs]\n\n        def multi_fixed_calc(l):\n\n            return list(f(l) for f in fs)\n\n        return multi_fixed_calc\n\n\n\nT = eval(input()); P = eval(input())\n\nprimes = gen(2, 10**3, 2)\n\nHT = RRH(T, primes=primes)\n\nHP = RRH(P, primes=primes)\n\n\n\npv = HP.calc(0, len(P))\n\ncalc = HT.fixed(len(P))\n\nfor i in range(len(T)-len(P)+1):\n\n    if calc(i) == pv:\n\n        print(i)", "generated_code": "class RH():\n\n    def __init__(self, s, base, mod):\n\n        self.base = base\n\n        self.mod = mod\n\n        self.rev = pow(base, mod-2, mod)\n\n\n\n        l = len(s)\n\n        self.h = h = [0]*(l+1)\n\n        tmp = 0\n\n        for i in range(l):\n\n            num = ord(s[i])\n\n            tmp = (tmp*base + num) % mod\n\n            h[i+1] = tmp\n\n    def calc(self, l, r):\n\n        return (self.h[r] - self.h[l] * pow(self.base, r-l, self.mod)) % self.mod\n\n    def fixed(self, length):\n\n        v = pow(self.base, length, self.mod)\n\n        h = self.h; mod = self.mod\n\n        def fixed_calc(l):\n\n            return (h[length+l] - h[l] * v) % mod\n\n        return fixed_calc\n\nT = eval(input()); P = eval(input())\n\nMOD = 10**18+9\n\nHT = RH(T, 11, MOD)\n\nHP = RH(P, 11, MOD)\n\n\n\npv = HP.calc(0, len(P))\n\ncalc = HT.fixed(len(P))\n\nfor i in range(len(T)-len(P)+1):\n\n    if calc(i) == pv:\n\n        print(i)", "score": 1.0, "surface_similarity": 0.6787480811871056}
{"id": "p02837_u609061751", "golden_code": "import sys\n\ninput = sys.stdin.readline\n\nimport numpy as np\n\nN = int(eval(input()))\n\nS = [[] for _ in range(N)]\n\nfor i in range(N):\n\n    A = int(eval(input()))\n\n    temp = []\n\n    for _ in range(A):\n\n        temp.append([str(x) for x in input().split()])\n\n        S[i] = temp\n\nans = 0\n\nfor i in range(2 ** N - 1, -1,-1):\n\n    biti = list(bin(i)[2:].zfill(N))\n\n    flag = 0\n\n    for j in range(N):\n\n        if biti[j] == \"1\":\n\n            for k in S[j]:\n\n                if biti[int(k[0])-1] != k[1]:\n\n                    flag = 1\n\n                    break\n\n        if flag:\n\n            break\n\n    if not flag:    \n\n        biti = np.array(biti)\n\n        ans = max(ans, np.count_nonzero(biti == \"1\"))\n\nprint(ans)", "generated_code": "import sys\n\ninput = sys.stdin.readline\n\n\n\nn = int(eval(input()))\n\n\n\nfrom collections import defaultdict\n\nd = defaultdict(list)\n\n\n\nfor i in range(n):\n\n    a = int(eval(input()))\n\n    for _ in range(a):\n\n        x, y = [int(x) for x in input().split()]\n\n        d[i].append((x - 1, y))\n\nans = 0\n\nfor k in range(2**n):\n\n    res = 0\n\n    j = bin(k)[2:].zfill(n)\n\n    flag = 1\n\n    for i in range(n):\n\n        if j[i] == \"0\":\n\n            continue\n\n        for x, y in d[i]:\n\n            if int(j[x]) != int(y):\n\n                flag = 0\n\n                break\n\n        res += 1\n\n    if flag:\n\n        ans = max(ans, res)\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.7075346992729676}
{"id": "p03457_u834279451", "golden_code": "#!/usr/bin/python3\n\n# -*- coding: utf-8 -*-\n\n\n\nimport numpy as np\n\n\n\nN = int(eval(input()))\n\nprev_dst = [0,0,0]\n\n\n\nfor n in range(N):\n\n    t, x, y = list(map(int, input().split(\" \")))\n\n    a = (t - prev_dst[0]) - (np.abs(prev_dst[1]-x) + np.abs(prev_dst[2]-y))\n\n    if a >= 0 and a % 2 == 0:\n\n        prev_dst = [t, x, y]\n\n    else:\n\n        print(\"No\")\n\n        exit(0)\n\n\n\nprint(\"Yes\")\n\n\n", "generated_code": "#!/usr/bin/python3\n\n# -*- coding: utf-8 -*-\n\n\n\nN = int(eval(input()))\n\nprev_dst = [0,0,0]\n\n\n\nfor n in range(N):\n\n    t, x, y = list(map(int, input().split(\" \")))\n\n    a = (t - prev_dst[0]) - (abs(prev_dst[1]-x) + abs(prev_dst[2]-y))\n\n    if a >= 0 and a % 2 == 0:\n\n        prev_dst = [t, x, y]\n\n    else:\n\n        print(\"No\")\n\n        exit(0)\n\n\n\nprint(\"Yes\")\n\n\n", "score": 1.0, "surface_similarity": 0.9332608265770219}
{"id": "p02767_u141786930", "golden_code": "import numpy as np\n\n\n\nN = int(eval(input()))\n\nX = np.array(list(int(x) for x in input().split()))\n\nm = round(np.mean(X))\n\n\n\nprint((int(sum((X-m)**2))))", "generated_code": "N = int(eval(input()))\n\nX = list(int(x) for x in input().split())\n\np = round(sum(X)/len(X))\n\nans = 0\n\n\n\nfor i in range(N):\n\n    ans += (X[i] - p)**2\n\n\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.5928731762065096}
{"id": "p02390_u721446434", "golden_code": "a = int(eval(input()))\n\nh = int(a / 3600)\n\nm = int((a - h * 3600) / 60)\n\ns = int(a - h * 3600 - m * 60)\n\nprint((\":\" .join(map(str, [h, m, s]))))", "generated_code": "num = int(input())\n\nprint(int(num/3600), int((num%3600)/60), num%60, sep=\":\")\n", "score": 1.0, "surface_similarity": 0.5590277777777778}
{"id": "p02899_u141786930", "golden_code": "n = int(eval(input()))\n\na = [int(x) for x in input().split()]\n\n\n\nans = list(range(n))\n\n\n\nfor i in range(n):\n\n    ans[a[i]-1] = i+1\n\n    \n\nprint((' '.join(map(str,ans))))", "generated_code": "def main():\n\n\n\n    N = int(eval(input()))\n\n    A = list(int(x) for x in input().split())\n\n    ans = [0] * N\n\n\n\n    for i, a in enumerate(A):\n\n        ans[a-1] = i+1\n\n\n\n    print((' '.join(map(str, ans))))\n\n    \n\nif __name__ == '__main__':\n\n    main()", "score": 1.0, "surface_similarity": 0.6556923076923077}
{"id": "p03416_u562935282", "golden_code": "a, b = list(map(int, input().split()))\n\ncnt = 0\n\nfor x in range(a, b + 1):\n\n    s = str(x)\n\n    l = len(s)\n\n    flg = True\n\n    for i in range(l // 2):\n\n        if s[i] != s[l - 1 - i]:\n\n            flg = False\n\n            break\n\n    if flg:\n\n        cnt += 1\n\nprint(cnt)\n", "generated_code": "a, b = list(map(int, input().split()))\n\ncnt = 0\n\nfor i in range(a, b + 1):\n\n    s = str(i)\n\n    if s[0] == s[4] and s[1] == s[3]:\n\n        cnt += 1\n\nprint(cnt)", "score": 1.0, "surface_similarity": 0.7372893772893773}
{"id": "p02959_u803617136", "golden_code": "N = int(eval(input()))\n\na = list(map(int, input().split()))\n\nb = list(map(int, input().split()))\n\na.reverse()\n\nb.reverse()\n\nans = 0\n\ncapacity = 0\n\nfor i in range(N):\n\n    ans += min(b[i] + capacity, a[i])\n\n    capacity = max(b[i] - max(a[i] - capacity, 0), 0)\n\nans += min(a[-1], capacity)\n\nprint(ans)", "generated_code": "n = int(eval(input()))\n\na = list(map(int, input().split()))\n\nb = list(map(int, input().split()))\n\n\n\na = a[::-1]\n\nb = b[::-1]\n\nans = 0\n\nfor i, bi in enumerate(b):\n\n    ans += min(a[i], b[i])\n\n    remain = max(0, b[i] - a[i])\n\n    ans += min(a[i + 1], remain)\n\n    a[i + 1] = max(0, a[i + 1] - remain)\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.7892282958199357}
{"id": "p02863_u126227204", "golden_code": "#coding:utf-8\n\nimport bisect\n\nimport sys\n\nsys.setrecursionlimit(10**6)\n\nwrite = sys.stdout.write\n\ndbg = lambda *something : print(*something) if DEBUG else 0\n\nDEBUG = True\n\n\n\n\n\n\n\ndef main(given = sys.stdin.readline):\n\n    input = lambda : given().rstrip()\n\n    LMIIS = lambda : list(map(int,input().split()))\n\n    II = lambda : int(input())\n\n    XLMIIS = lambda x : [LMIIS() for _ in range(x)]\n\n\n\n    n, t = LMIIS()\n\n    ab = XLMIIS(n)\n\n\n\n    dp1 = [[0]*t for _ in range(n)]\n\n    for i in range(1, n):\n\n        for j in range(1, t):\n\n            if j < ab[i-1][0]:\n\n                dp1[i][j] = dp1[i-1][j]\n\n            else:\n\n                dp1[i][j] = max(dp1[i-1][j], dp1[i-1][j-ab[i-1][0]] + ab[i-1][1])\n\n\n\n\n\n    dp2 = [[0]*t for _ in range(n)]\n\n    for i in range(1, n):\n\n        for j in range(1, t):\n\n            if j < ab[n - i][0]:\n\n                dp2[i][j] = dp2[i-1][j]\n\n            else:\n\n                dp2[i][j] = max(dp2[i-1][j], dp2[i-1][j-ab[n-i][0]] + ab[n-i][1])\n\n\n\n    ans = 0\n\n    for i in range(n):\n\n        for j in range(t - 1):\n\n            ans = max(ans, dp1[i][j] + dp2[n - i - 1][t - j - 1] + ab[i][1])\n\n    print(ans)\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "generated_code": "#coding:utf-8\n\nimport bisect\n\nimport sys\n\nsys.setrecursionlimit(10**6)\n\nwrite = sys.stdout.write\n\ndbg = lambda *something : print(*something) if DEBUG else 0\n\nDEBUG = True\n\n\n\n\n\n\n\ndef main(given = sys.stdin.readline):\n\n    input = lambda : given().rstrip()\n\n    LMIIS = lambda : list(map(int,input().split()))\n\n    II = lambda : int(input())\n\n    XLMIIS = lambda x : [LMIIS() for _ in range(x)]\n\n\n\n    n, t = LMIIS()\n\n    ab = XLMIIS(n)\n\n    ab.sort()\n\n\n\n    dp1 = [[0]*t for _ in range(n+1)]\n\n    for i in range(1, n+1):\n\n        for j in range(1, t):\n\n            if j < ab[i-1][0]:\n\n                dp1[i][j] = dp1[i-1][j]\n\n            else:\n\n                dp1[i][j] = max(dp1[i-1][j], dp1[i-1][j-ab[i-1][0]] + ab[i-1][1])\n\n\n\n    ans = 0\n\n    for i in range(n):\n\n        ans = max(ans, dp1[i][t-1] + ab[i][1])\n\n    print(ans)\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 1.0, "surface_similarity": 0.9118387909319899}
{"id": "p03074_u326609687", "golden_code": "import sys\n\n\n\nN, K = list(map(int, input().split()))\n\nS = eval(input())\n\n\n\n\n\ndef nexti(n):\n\n    while S[n] == '1':\n\n        n += 1\n\n    while S[n] == '0':\n\n        n += 1\n\n    return n\n\n\n\n\n\ndef nextj(n):\n\n    while S[n] == '0':\n\n        n += 1\n\n        if n == N:\n\n            return N\n\n    while S[n] == '1':\n\n        n += 1\n\n        if n == N:\n\n            return N\n\n    return n\n\n\n\n\n\ni = 0\n\nj = 0\n\nwhile S[j] == '1':\n\n    j += 1\n\n    if j == N:\n\n        print(N)\n\n        sys.exit(0)\n\nfor _ in range(K):\n\n    j = nextj(j)\n\n    if j == N:\n\n        print(N)\n\n        sys.exit(0)\n\n\n\nans = j - i\n\nwhile True:\n\n    i = nexti(i)\n\n    j = nextj(j)\n\n    ans = max(ans, j - i)\n\n    if j == N:\n\n        break\n\n\n\nprint(ans)", "generated_code": "from collections import deque\n\n\n\n\n\ndef nextj(n):\n\n    while S[n] == '0':\n\n        n += 1\n\n        if n == N:\n\n            return N\n\n    q.appendleft(n)\n\n    while S[n] == '1':\n\n        n += 1\n\n        if n == N:\n\n            return N\n\n    return n\n\n\n\n\n\ndef init(n):\n\n    while S[n] == '1':\n\n        n += 1\n\n        if n == N:\n\n            return N\n\n    return n\n\n\n\n\n\ndef calc():\n\n    q.appendleft(0)\n\n    ans = 0\n\n    j = init(0)\n\n    if j == N:\n\n        return N\n\n    for _ in range(K - 1):\n\n        j = nextj(j)\n\n        if j == N:\n\n            return N\n\n    while True:\n\n        j = nextj(j)\n\n        ans = max(ans, j - q.pop())\n\n        if j == N:\n\n            return ans\n\n\n\n\n\nN, K = list(map(int, input().split()))\n\nS = eval(input())\n\nq = deque()\n\nprint((calc()))\n", "score": 1.0, "surface_similarity": 0.7759741715618134}
{"id": "p03039_u060938295", "golden_code": "# -*- coding: utf-8 -*-\n\n\"\"\"\n\nCreated on Sat May 25 21:24:29 2019\n\n\n\n@author: Yamazaki Kenichi\n\n\"\"\"\n\n\n\nN, M, K = list(map(int,input().split()))\n\nmod = 10**9+7\n\n\n\ndef cmb(n, r, mod):\n\n    if (r < 0 or r > n):\n\n        return 0\n\n    r = min(r, n-r)\n\n    return g1[n] * g2[r] * g2[n-r] % mod\n\n\n\ng1 = [1, 1] # 元テーブル\n\ng2 = [1, 1] # 逆元テーブル\n\ninv = [0, 1] # 逆元テーブル計算用テーブル\n\n\n\nfor i in range(2, N*M+1):\n\n    g1.append((g1[-1] * i) % mod)\n\n    inv.append((-inv[mod % i] * (mod//i)) % mod)\n\n    g2.append((g2[-1] * inv[-1]) % mod)\n\n\n\ndef a(N,M):\n\n    return N*(N+1)//2*(M+1) + M*(M+1)//2*(N+1)\n\ndef b(N):\n\n    return N*(N+1)//2\n\n\n\nans = 0\n\nfor i in range(N):\n\n    for j in range(M):\n\n        ans += a(i,j) + a(N-i-1,j) + a(i,M-j-1) + a(N-i-1,M-j-1)\n\n        ans -= b(i) + b(j) + b(N-i-1) + b(M-j-1)\n\n        ans %= mod\n\n#        print(i,j,a(i,j),a(N-i-1,j),a(i,M-j-1),a(N-i-1,M-j-1),b(i),b(j),ans)\n\nans *= g2[2]\n\n\n\nans *= cmb(N*M-2,K-2,mod)\n\nans %= mod\n\n\n\nprint(ans)\n", "generated_code": "# -*- coding: utf-8 -*-\n\n\"\"\"\n\nCreated on Wed May 29 22:49:19 2019\n\n\n\n@author: Yamazaki Kenichi\n\n\"\"\"\n\n\n\n# -*- coding: utf-8 -*-\n\n\"\"\"\n\nCreated on Sat May 25 21:24:29 2019\n\n\n\n@author: Yamazaki Kenichi\n\n\"\"\"\n\n\n\nN, M, K = list(map(int,input().split()))\n\nmod = 10**9+7\n\n\n\ndef cmb(n, r, mod):\n\n    if (r < 0 or r > n):\n\n        return 0\n\n    r = min(r, n-r)\n\n    return g1[n] * g2[r] * g2[n-r] % mod\n\n\n\ng1 = [1, 1] # 元テーブル\n\ng2 = [1, 1] # 逆元テーブル\n\ninv = [0, 1] # 逆元テーブル計算用テーブル\n\n\n\nfor i in range(2, N*M+1):\n\n    g1.append((g1[-1] * i) % mod)\n\n    inv.append((-inv[mod % i] * (mod//i)) % mod)\n\n    g2.append((g2[-1] * inv[-1]) % mod)\n\n\n\nans1 = 0\n\ndef c(N,M):\n\n    res = 0\n\n    for i in range(1,N):\n\n        res += i*(N-i)*M*M\n\n    return res\n\nans1 += c(N,M) + c(M,N)\n\nans1 %= mod\n\n\n\nans1 *= cmb(N*M-2,K-2,mod)\n\nans1 %= mod\n\n\n\nprint(ans1)\n", "score": 1.0, "surface_similarity": 0.881675392670157}
{"id": "p04044_u537976628", "golden_code": "N, L = list(map(int, input().split()))\n\nS = list(eval(input()) for i in range(N))\n\nstr = \"\"\n\nfor i in range(N-1):\n\n    for j in range(N-1):\n\n        if S[j+1] + S[j] <= S[j] + S[j+1]:\n\n            S[j], S[j+1] = S[j+1], S[j]\n\nfor i in S:\n\n    str += i\n\nprint(str)\n", "generated_code": "N, L = list(map(int, input().split()))\n\nS = list(eval(input()) for i in range(N))\n\nS.sort()\n\nstr = \"\"\n\nfor i in S:\n\n    str += i\n\nprint(str)\n", "score": 1.0, "surface_similarity": 0.6761363636363635}
{"id": "p02555_u344655022", "golden_code": "s = int(eval(input()))\n\nmod = 10**9 + 7\n\n\n\n# dp[i]: 最後に切った場所がi\n\ndp = [0]*(s + 1)\n\ndp[0] = 1\n\n\n\nfor i in range(3, s+1):\n\n    for j in range(0, (i-3)+1):\n\n        dp[i] += dp[j]\n\n        dp[i] %= mod\n\n\n\nprint((dp[s]))", "generated_code": "s = int(eval(input()))\n\nmod = 10**9 + 7\n\n\n\n# dp[i]: 最後に切った場所がi\n\ndp = [0]*(s + 1)\n\ndp[0] = 1\n\ntotal = 0\n\nfor i in range(3, s+1):\n\n    total += dp[i-3]\n\n    total %= mod\n\n    dp[i] = total\n\n\n\nprint((dp[s]))", "score": 1.0, "surface_similarity": 0.9023255813953488}
{"id": "p02412_u617990214", "golden_code": "while True:\n\n\tk=list(map(int,input().split(\" \")))\n\n\tif k[0]==k[1]==0:\n\n\t\tbreak\n\n\tct=0\n\n\ta=0\n\n\tb=0\n\n\tc=0\t\n\n\tmax=k[0]\n\n\tsum=k[1]\n\n\ta=max+1\n\n\t\n\n\twhile True:\n\n\t\ta-=1\n\n\t\tb=a-1\n\n\t\tc=sum-a-b\n\n\t\tif not a>b>c:\n\n\t\t\tprint(ct)\n\n\t\t\tbreak\n\n\t\twhile a>b>c:\n\n\t\t\tif a>b>c>0:\n\n\t\t\t\tct+=1\n\n\t\t\tb-=1\n\n\t\t\tc+=1\n\n\t\t\t", "generated_code": "while True:\n\n\tk=list(map(int,input().split(\" \")))\n\n\tif k[0]==k[1]==0:\n\n\t\tbreak\n\n\tct=0\n\n\ta=0\n\n\tb=0\n\n\tc=0\t\n\n\tmax=k[0]\n\n\tsum=k[1]\n\n\ta=max+1\n\n\twhile True:\n\n\t\ta-=1\n\n\t\tb=a-1\n\n\t\tc=sum-a-b\n\n\t\tif not a>c:\n\n\t\t\tprint(ct)\n\n\t\t\tbreak\n\n\t\twhile b>c:\n\n\t\t\tif c>0:\n\n\t\t\t\tct+=1\n\n\t\t\tb-=1\n\n\t\t\tc+=1", "score": 1.0, "surface_similarity": 0.9862068965517241}
{"id": "p04044_u536034761", "golden_code": "n, l = list(map(int, input().split()))\n\nS = [eval(input()) for i in range(n)]\n\nS.sort()\n\nprint((\"\".join(S)))", "generated_code": "n, l = list(map(int, input().split()))\n\nA = [eval(input()) for _ in range(n)]\n\nA.sort()\n\nprint((\"\".join(A)))\n", "score": 1.0, "surface_similarity": 0.981651376146789}
{"id": "p03644_u996564551", "golden_code": "N = int(eval(input()))\n\nif N < 2:\n\n  print(N)\n\nelif 2<=N<4:\n\n  print((2))\n\nelif 4<=N<8:\n\n  print((4))\n\nelif 8<=N<16:\n\n  print((8))\n\nelif 16<=N<32:\n\n  print((16))\n\nelif 32<=N<64:\n\n  print((32))\n\nelif 64<=N:\n\n  print((64))", "generated_code": "N = int(eval(input()))\n\nNum = [int(2**i) for i in range(7)]\n\nif N in Num:\n\n  print(N)\n\nelse:\n\n  Num.append(N)\n\n  Num = sorted(Num)\n\n  print((2 ** (Num.index(N) - 1)))", "score": 1.0, "surface_similarity": 0.5086124401913876}
{"id": "p03037_u815878613", "golden_code": "N, M = list(map(int, input().split()))\n\nLR = [list(map(int, input().split())) for _ in range(M)]\n\n\n\nleft = 1\n\nright = N\n\n\n\nfor l, r in LR:\n\n    if left < l:\n\n        left = l\n\n    if right > r:\n\n        right = r\n\n\n\nans = right - left\n\n\n\nprint((ans + 1 if ans >= 0 else 0))\n", "generated_code": "N, M = list(map(int, input().split()))\n\n\n\nleft = 1\n\nright = N\n\n\n\nfor _ in range(M):\n\n    l, r = list(map(int, input().split()))\n\n\n\n    if left < l:\n\n        left = l\n\n    if right > r:\n\n        right = r\n\n\n\nans = right - left\n\n\n\nprint((ans + 1 if ans >= 0 else 0))\n", "score": 1.0, "surface_similarity": 0.8432315859323158}
{"id": "p03293_u282228874", "golden_code": "s = eval(input())\n\nt = eval(input())\n\nfor i in range(len(s)):\n\n        if s[i:]+s[:i]==t:\n\n                print('Yes')\n\n                exit()\n\nprint('No')", "generated_code": "s = eval(input())\n\nt = eval(input())\n\n\n\nfor i in range(len(s)):\n\n    s = s[1:] + s[0]\n\n    if s == t:\n\n        print(\"Yes\")\n\n        exit()\n\nprint(\"No\")", "score": 1.0, "surface_similarity": 0.9321266968325792}
{"id": "p03309_u466335531", "golden_code": "import numpy as np\n\n\n\nN=int(eval(input()))\n\nA=list(map(int, input().split()))\n\n\n\nAA=[]\n\nfor i,a in enumerate(A):\n\n    AA.append(a-i+1)\n\n\n\nb=np.median(AA)\n\nans=0\n\n\n\nfor a in AA:\n\n    ans+=abs(a-b)\n\nprint((int(ans)))", "generated_code": "N=int(eval(input()))\n\nA=list(map(int,input().split()))\n\nB=[]\n\nfor i in range(N):\n\n    B.append(A[i]-i-1)\n\nB.sort()\n\nif N%2:\n\n    b=B[N//2]\n\nelse:\n\n    b=(B[N//2]+B[N//2-1])//2\n\nans=0\n\nfor k in B:\n\n    ans+=abs(k-b)\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.6114851866102347}
{"id": "p03060_u285121325", "golden_code": "n = int(eval(input()))\n\nv = list(map(int, input().split()))\n\nc = list(map(int, input().split()))\n\nresult = 0\n\nfor i in range(n):\n\n  if v[i] > c[i]:\n\n    result += v[i] - c[i]\n\nprint(result)", "generated_code": "N = int(eval(input()))\n\nV = list(map(int, input().split()))\n\nC = list(map(int, input().split()))\n\nprint((sum([V[i] - C[i] for i in range(N) if V[i] > C[i]])))\n", "score": 1.0, "surface_similarity": 0.6825396825396826}
{"id": "p02760_u222207357", "golden_code": "import numpy as np\n\n\n\na = [list(map(int, input().split())) for _ in range(3)]\n\na = np.array(a)\n\nn = int(eval(input()))\n\n\n\nfor _ in range(n):\n\n    b = int(eval(input()))\n\n    \n\n    for j in range(3):\n\n        for i in range(3):\n\n            if a[j][i] == b:\n\n                a[j][i] = 0\n\n\n\nat = a.transpose()\n\nflag = False\n\nfor i in range(3):\n\n    if sum(a[:][i]) == 0 or sum(at[:][i]) == 0:\n\n        flag = True\n\n        break\n\ndiag = a[0][0] + a[1][1] + a[2][2]\n\ndiag2 = a[2][0] + a[1][1] + a[0][2]\n\nif diag == 0 or diag2 == 0:\n\n    flag = True\n\n\n\nprint((\"Yes\" if flag else \"No\"))", "generated_code": "a = [list(map(int, input().split())) for _ in range(3)]\n\nn = int(eval(input()))\n\nb = [int(eval(input())) for _ in range(n)]\n\n\n\nflag = False\n\nfor i in range(3):\n\n    if a[i][0] in b and a[i][1] in b and a[i][2] in b:\n\n        flag = True\n\n        break\n\n    if a[0][i] in b and a[1][i] in b and a[2][i] in b:\n\n        flag = True\n\n        break\n\nif a[0][0] in b and a[1][1] in b and a[2][2] in b:\n\n    flag = True\n\nif a[2][0] in b and a[1][1] in b and a[0][2] in b:\n\n    flag = True\n\n    \n\nprint((\"Yes\" if flag else \"No\"))", "score": 1.0, "surface_similarity": 0.6774956970740104}
{"id": "p03592_u102242691", "golden_code": "\n\nn,m,k = list(map(int,input().split()))\n\n#１回押すと変わるマス　= N * M -1\n\n#２回目押すと黒に変わるマス N * M -1 -2\n\n# 3 = N * M -1 -4\n\n\n\ncnt = 0\n\nfor i in range(n+1):\n\n    for j in range(m + 1):\n\n        cnt = i * m + j * n -2 * i * j\n\n        if cnt == k:\n\n            print(\"Yes\")\n\n            exit()\n\nprint(\"No\")\n", "generated_code": "\n\nn,m,k = list(map(int,input().split()))\n\n\n\nfor i in range(n+1):\n\n    for j in range(m+1):\n\n        if i*(m-j) + j*(n-i) == k:\n\n            print(\"Yes\")\n\n            exit()\n\nprint(\"No\")\n", "score": 1.0, "surface_similarity": 0.9591836734693877}
{"id": "p03416_u879870653", "golden_code": "a,b = list(map(int,input().split()))\n\nanswer = 0\n\nfor i in range(a,b+1) :\n\n    j = str(i)\n\n    p1 = j[4]\n\n    p2 = j[3]\n\n    p3 = j[2]\n\n    p4 = j[1]\n\n    p5 = j[0]\n\n    k = int(p1+p2+p3+p4+p5)\n\n    if i == k :\n\n        answer += 1\n\nprint(answer)\n\n\n", "generated_code": "A,B = list(map(int,input().split()))\n\nans = 0\n\nfor i in range(A,B+1) :\n\n    l = str(i)\n\n    if l[0] == l[4] and l[1] == l[3] :\n\n        ans += 1\n\nprint(ans)\n", "score": 1.0, "surface_similarity": 0.8118187033849684}
{"id": "p03721_u936985471", "golden_code": "N,K=list(map(int,input().split()))\n\ndic={}\n\nfor i in range(N):\n\n  a,b=list(map(int,input().split()))\n\n  if a in dic:\n\n    dic[a]+=b\n\n  else:\n\n    dic[a]=b\n\n    \n\ndic=sorted(list(dic.items()),key=lambda x:x[0])\n\nfor d in range(len(dic)):\n\n  amount=dic[d][1]\n\n  if amount>=K:\n\n    print((dic[d][0]))\n\n    exit(0)\n\n  else:\n\n    K-=amount\n\n  ", "generated_code": "import sys\n\nreadline = sys.stdin.readline\n\n\n\nN,K = list(map(int,readline().split()))\n\n\n\nAB = [list(map(int,readline().split())) for i in range(N)]\n\n\n\nAB = sorted(AB, key = lambda x:x[0])\n\namount = 0\n\nfor a,b in AB:\n\n  amount += b\n\n  if amount >= K:\n\n    print(a)\n\n    break\n", "score": 1.0, "surface_similarity": 0.6092702169625246}
{"id": "p03814_u197300260", "golden_code": "# Problem https://atcoder.jp/contests/abc053/tasks/abc053_b\n\n# Python 1st Try\n\nimport copy\n\n\n\n\n\nclass Problem:\n\n    def __init__(self, stringdata):\n\n        self.stringdata = stringdata\n\n\n\n    def solver(self):\n\n        strcont = copy.copy(self.stringdata)\n\n        result = 0\n\n        rightposition = 0\n\n        leftposition = len(strcont)\n\n        j = 0\n\n        while True:\n\n            if strcont[j] == 'A':\n\n                rightposition = j\n\n                break\n\n            else:\n\n                j = j + 1\n\n        j = leftposition - 1\n\n        while True:\n\n            if strcont[j] == 'Z':\n\n                leftposition = j\n\n                break\n\n            else:\n\n                j = j - 1\n\n\n\n        result = leftposition - rightposition + 1\n\n        return result\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    s = eval(input())\n\n    print((\"{}\".format(Problem(s).solver())))\n", "generated_code": "# Problem https://atcoder.jp/contests/abc053/tasks/abc053_b\n\n# Python 2nd Try\n\n\n\n\n\ndef solver(string):\n\n    result = 200000\n\n    aposi = 0\n\n    zposi = len(string)\n\n    for j in range(0, len(string), 1):\n\n        if string[j] == 'A':\n\n            aposi = j\n\n            break\n\n    for j in range(len(string)-1, -1, -1):\n\n        if string[j] == 'Z':\n\n            zposi = j\n\n            break\n\n    result = zposi - aposi + 1\n\n    return result\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    s = eval(input())\n\n    print(('{}'.format(solver(s))))\n", "score": 1.0, "surface_similarity": 0.737181239504823}
{"id": "p02690_u691874710", "golden_code": "x=int(eval(input()))\n\nA=0\n\nB=0\n\nfor a in range(-120,120):\n\n    for b in range(-500,500):\n\n        if a**5-b**5==x:\n\n            A=a\n\n            B=b\n\n            break\n\nprint((A,B))", "generated_code": "x=int(eval(input()))\n\nA=0\n\nB=0\n\nfor a in range(-120, 120):\n\n    a5 = a**5\n\n    for b in range(-120, 120):\n\n        if a5 - b**5 == x:\n\n            A = a\n\n            B = b\n\n            break\n\nprint((A,B))", "score": 1.0, "surface_similarity": 0.9656862745098039}
{"id": "p00827_u633068244", "golden_code": "def judge(x,y):\n\n    global xx,yy,xy,axby\n\n    if min(x,y) >= 0 and x+y <= xy:\n\n        if x+y < xy or (x+y == xy and a*x+b*y < axby):\n\n            xy = x+y\n\n            axby = a*x+b*y\n\n            xx,yy = x,y\n\n    \n\nwhile 1:\n\n    a,b,d = list(map(int,input().split()))\n\n    if a == 0: break\n\n    xy = axby = 10**10\n\n    for y in range(50001):\n\n        if (d+b*y)%a == 0: judge((d+b*y)/a,y)\n\n        if (b*y-d)%a == 0: judge((b*y-d)/a,y)\n\n        if (d-b*y)%a == 0: judge((d-b*y)/a,y)\n\n    print(xx,yy)", "generated_code": "def judge(x,y):\n\n    global xx,yy,xy,axby\n\n    if min(x,y) >= 0 and x+y <= xy:\n\n        if x+y < xy or (x+y == xy and a*x+b*y < axby):\n\n            xy = x+y\n\n            axby = a*x+b*y\n\n            xx,yy = x,y\n\n    \n\nwhile 1:\n\n    a,b,d = list(map(int,input().split()))\n\n    if a == 0: break\n\n    xy = axby = 10**10\n\n    for y in range(30001):\n\n        if (d+b*y)%a == 0: judge((d+b*y)/a,y)\n\n        if (b*y-d)%a == 0: judge((b*y-d)/a,y)\n\n        if (d-b*y)%a == 0: judge((d-b*y)/a,y)\n\n    print(xx,yy)", "score": 1.0, "surface_similarity": 0.999003984063745}
{"id": "p02982_u934402094", "golden_code": "import math\n\nimport numpy as np\n\nn, d = list(map(int, input().split()))\n\na = []\n\ncnt = 0\n\nfor x in range(n):\n\n    a.append(list(map(int, input().split())))\n\nfor i in range(len(a)):\n\n    for j in range(len(a)):\n\n        if i < j:\n\n            dis = np.array(a[i]) - np.array(a[j])\n\n            if np.linalg.norm(dis).is_integer():\n\n                cnt += 1\n\nprint(cnt)", "generated_code": "n, d = list(map(int, input().split()))\n\na = [[int(i) for i in input().split()] for i in range(n)]\n\nans = 0\n\ndef dis(x,y):\n\n    T = []\n\n    for i in range(len(x)):\n\n        T.append((x[i]-y[i])**2)\n\n    return sum(T)\n\nfor i in range(n):\n\n    for j in range(i+1,n):\n\n        r = dis(a[i], a[j])\n\n        for k in range(r + 1):\n\n            if k ** 2 == r:\n\n                ans += 1\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.5936803894068146}
{"id": "p03000_u821588465", "golden_code": "from itertools import accumulate\n\nfrom bisect import *\n\nN, X = list(map(int, input().split()))\n\nL = list(tuple(map(int, input().split())))\n\n\n\nacc = sorted(list(accumulate(L)) + [0])\n\n\n\nn = bisect_right(acc,X)\n\nprint(n)\n\n\n", "generated_code": "N,X = list(map(int,input().split()))\n\nL = list(map(int,input().split()))\n\nList = [0]*(N+1)\n\nfor i in range(1,N+1):\n\n    List[i] = List[i-1] + L[i-1]\n\nA = [i for i in List if i <=X]\n\nprint((len(A)))", "score": 1.0, "surface_similarity": 0.4789781297134238}
{"id": "p03416_u460245024", "golden_code": "A, B = list(map(int, input().split()))\n\n\n\ncnt = 0\n\nfor n in range(A, B+1):\n\n    n_s = str(n)\n\n    n_s_rvs = n_s[::-1]\n\n    if n_s == n_s_rvs:\n\n        cnt += 1\n\n\n\nprint(cnt)\n", "generated_code": "A, B = list(map(int, input().split()))\n\n\n\ncnt = 0\n\nfor n in range(A, B+1):\n\n    if n//10000 == n%10 and (n//1000)%10 == (n//10)%10:\n\n        cnt += 1\n\n\n\nprint(cnt)\n", "score": 1.0, "surface_similarity": 0.7221839080459771}
{"id": "p03649_u606045429", "golden_code": "from numpy import*\n\nN,*A=open(0)\n\nN,A,S,a=int(N),loadtxt(A,int),1,0\n\nwhile S:B=A//N;S=sum(B);a+=S;A+=S-B*-~N\n\nprint(a)", "generated_code": "N, *A = list(map(int, open(0).read().split()))\n\n\n\nans = 0\n\nS = -1\n\nwhile S:\n\n    S = sum(a // N for a in A)\n\n    ans += S\n\n    A = [a % N + (S - a // N) for a in A]\n\n\n\nprint(ans)\n", "score": 1.0, "surface_similarity": 0.5819366852886405}
{"id": "p02702_u829249049", "golden_code": "import numpy as np\n\nS=eval(input())\n\nN=len(S)\n\nmod=[0 for i in range(2019)]\n\nmod2=0\n\nten=1\n\nfor i in range(N-1,-1,-1): \n\n  s=int(S[i])*ten\n\n  mod2+=np.mod(s,2019)\n\n  mod2=np.mod(mod2,2019)\n\n  mod[mod2]+=1\n\n  ten=(ten*10)%2019\n\nans=0\n\nfor i in range(2019):\n\n  k=mod[i]\n\n  if i==0:\n\n    if k>=2:\n\n      ans+=k*(k-1)//2+k\n\n    else:\n\n      ans+=k\n\n  else:\n\n    if k>=2:\n\n      ans+=k*(k-1)//2\n\nprint(ans) ", "generated_code": "S=eval(input())\n\nN=len(S)\n\nmod=[0 for i in range(2019)]\n\ns=0\n\nten=1\n\nfor i in range(N-1,-1,-1): \n\n  s+=int(S[i])*ten\n\n  mod2=s%2019\n\n  mod[mod2]+=1\n\n  ten=(ten*10)%2019\n\nans=0\n\nfor i in range(2019):\n\n  k=mod[i]\n\n  if i==0:\n\n    if k>=2:\n\n      ans+=k*(k-1)//2+k\n\n    else:\n\n      ans+=k\n\n  else:\n\n    if k>=2:\n\n      ans+=k*(k-1)//2\n\nprint(ans) ", "score": 1.0, "surface_similarity": 0.8811116829644879}
{"id": "p03162_u216015528", "golden_code": "#!/usr/bin/env python3\n\ndef main():\n\n    import numpy as np\n\n\n\n    N = int(eval(input()))\n\n    happiness = [list(map(int, input().split())) for _ in range(N)]\n\n\n\n    dp = np.zeros((N, 3), dtype=np.int64)\n\n    dp[0] = happiness[0]\n\n    for i in range(1, N):\n\n        for a, yesterday in enumerate(dp[i - 1]):\n\n            for b, today in enumerate(happiness[i]):\n\n                if a == b:\n\n                    continue\n\n                dp[i][b] = max(dp[i][b], yesterday + today)\n\n    print((max(dp[-1])))\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "generated_code": "#!/usr/bin/env python3\n\ndef main():\n\n    N = int(eval(input()))\n\n    happiness = [list(map(int, input().split())) for _ in range(N)]\n\n\n\n    dp = [0, 0, 0]\n\n    for a, b, c in happiness:\n\n        dp = [max(dp[1], dp[2]) + a,\n\n              max(dp[0], dp[2]) + b,\n\n              max(dp[0], dp[1]) + c]\n\n    print((max(dp)))\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 1.0, "surface_similarity": 0.7105868118572292}
{"id": "p02264_u840247626", "golden_code": "n,q = list(map(int,input().split()))\n\nqueue = []\n\nfor i in range(n):\n\n\tname,time = input().split()\n\n\tqueue.append([name, int(time)])\n\n\n\nt = 0\n\ni = 0\n\nwhile queue:\n\n\ti %= len(queue)\n\n\tp = queue[i]\n\n\tt += min(q, p[1])\n\n\tif p[1] > q:\n\n\t\tp[1] -= q\n\n\t\ti += 1\n\n\telse:\n\n\t\tprint((p[0], t))\n\n\t\tqueue.pop(i)\n", "generated_code": "from collections import deque\n\n\n\nn,q = list(map(int,input().split()))\n\nqueue = deque()\n\nfor i in range(n):\n\n\tname,time = input().split()\n\n\tqueue.append((name, int(time)))\n\n\n\nt = 0\n\nwhile queue:\n\n\tname,time = queue.popleft()\n\n\tt += min(q, time)\n\n\tif time > q:\n\n\t\tqueue.append((name, time-q))\n\n\telse:\n\n\t\tprint((name,t))\n", "score": 1.0, "surface_similarity": 0.6870440251572327}
{"id": "p03796_u597374218", "golden_code": "import math\n\nN=int(eval(input()))\n\nprint((math.factorial(N)%(10**9+7)))", "generated_code": "N=int(eval(input()))\n\npower=1\n\nfor i in range(1,N+1):\n\n    power*=i\n\n    power%=10**9+7\n\nprint(power)", "score": 1.0, "surface_similarity": 0.5462046204620462}
{"id": "p03371_u970197315", "golden_code": "# ABC95 C -Half and Half\n\na,b,c,x,y = list(map(float,input().split()))\n\nans = 0\n\nif a+b > 2*c:\n\n    while x != 0.0 and y != 0.0:\n\n        ans += 2*c\n\n        x -= 1.0\n\n        y -= 1.0\n\n        if y == 0.0:\n\n            while x != 0.0:\n\n                if a > 2*c:\n\n                    ans += 2*c\n\n                    x -= 1.0\n\n                else:\n\n                    ans += a\n\n                    x -= 1.0\n\n        if x == 0.0:\n\n            while y != 0.0:\n\n                if b > 2*c:\n\n                    ans += 2*c\n\n                    y -= 1.0\n\n                else:\n\n                    ans += b\n\n                    y -= 1.0\n\nelse:\n\n    ans += a*x + b*y\n\nprint((int(ans)))\n\n\n\n    ", "generated_code": "a,b,c,x,y=list(map(int,input().split()))\n\nans=0\n\nans1=0\n\n\n\ne=max(x,y)\n\nans1=e*(2*c)\n\nif 2*c<a+b:\n\n    d=min(x,y)\n\n    ans+=c*(2*d)\n\n    x-=d\n\n    y-=d\n\nelse:\n\n    ans=a*x+b*y\n\n    x-=x\n\n    y-=y\n\nans+=x*a\n\nans+=y*b\n\nprint((min(ans,ans1)))", "score": 1.0, "surface_similarity": 0.7353260869565217}
{"id": "p03640_u341087021", "golden_code": "import sys\n\nimport numpy as np\n\n\n\nh,w = [int(x) for x in sys.stdin.readline().split()]\n\nn = int(eval(input()))\n\na = [int(x) for x in sys.stdin.readline().split()]\n\ns = h*w\n\n\n\nl = []\n\n\n\nfor i,x in enumerate(a):\n\n\tfor j in range(x):\n\n\t\tl.append(i+1)\n\n\n\nl = np.array(l).reshape((h,w))\n\n\n\nfor i,x in enumerate(l):\n\n\tif i % 2 == 0:\n\n\t\tprint((' '.join(map(str, x))))\n\n\telse:\n\n\t\tprint((' '.join(map(str, reversed(x)))))", "generated_code": "h,w = list(map(int, input().split()))\n\nn = int(eval(input()))\n\na = list(map(int, input().split()))\n\n\n\nl = []\n\n\n\nfor i,x in enumerate(a):\n\n\tfor j in range(x):\n\n\t\tl.append(i+1)\n\n\n\nfor i in range(h):\n\n\tt = l[i*w:(i+1)*w]\n\n\tif i % 2 == 1:\n\n\t\tt.reverse()\n\n\tprint((' '.join(map(str, t))))", "score": 1.0, "surface_similarity": 0.6797572815533981}
{"id": "p03032_u693378622", "golden_code": "# coding: utf-8\n\nimport copy\n\nimport numpy as np\n\n\n\nn, k = list(map(int, input().split()))\n\nv = list(map(int, input().split()))\n\nrev = copy.copy(v)\n\nrev.reverse()\n\n\n\nlcs = [0]+np.cumsum(v)\n\nrcs = [0]+np.cumsum(rev)\n\n# print(lcs,rcs)\n\n\n\nans = -10**20\n\nfor l in range(n+1):\n\n  for r in range(n+1-l):\n\n    able = True\n\n    d = k - ( l + r )\n\n    if d < 0:\n\n      able = False\n\n      break\n\n    # m = lcs[l] + rcs[r]\n\n    t = v[0:l] + rev[0:r]\n\n    m = sum(t)\n\n    # print(t,l,r,m)\n\n    t.sort()\n\n    # print(t)\n\n    d = min(d,l+r)\n\n    for i in range(d):\n\n      if 0 > t[i]:\n\n        m -= t[i]\n\n      else:\n\n        break\n\n    # print(m)\n\n    ans = max(ans,m)\n\n\n\nprint(ans)\n\n    ", "generated_code": "# coding: utf-8\n\nimport copy\n\n\n\nn, k = list(map(int, input().split()))\n\nv = list(map(int, input().split()))\n\nrev = copy.copy(v)\n\nrev.reverse()\n\n\n\nans = -10**20\n\nfor l in range(n+1):\n\n  for r in range(n+1-l):\n\n    able = True\n\n    d = k - ( l + r )\n\n    if d < 0:\n\n      able = False\n\n      break\n\n    t = v[0:l] + rev[0:r]\n\n    m = sum(t)\n\n    t.sort()\n\n    d = min(d,l+r)\n\n    for i in range(d):\n\n      if 0 > t[i]:\n\n        m -= t[i]\n\n      else:\n\n        break\n\n    ans = max(ans,m)\n\n\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.9383799224648031}
{"id": "p03162_u894934980", "golden_code": "import numpy as np\n\nN = int(eval(input()))\n\ndp = [[0, 0, 0] for i in range(N+1)]\n\nfor i in range(1, N+1):\n\n    a, b, c = list(map(int, input().split(' ')))\n\n    dp[i][0] = max(dp[i-1][1], dp[i-1][2]) + a\n\n    dp[i][1] = max(dp[i-1][0], dp[i-1][2]) + b\n\n    dp[i][2] = max(dp[i-1][0], dp[i-1][1]) + c\n\nprint((np.max(dp[-1])))", "generated_code": "N = int(eval(input()))\n\ndp = [[0, 0, 0] for i in range(N+1)]\n\nfor i in range(1, N+1):\n\n    a, b, c = list(map(int, input().split(' ')))\n\n    dp[i][0] = max(dp[i-1][1], dp[i-1][2]) + a\n\n    dp[i][1] = max(dp[i-1][0], dp[i-1][2]) + b\n\n    dp[i][2] = max(dp[i-1][0], dp[i-1][1]) + c\n\nprint((max(dp[-1])))", "score": 1.0, "surface_similarity": 0.9272007514761138}
{"id": "p02595_u632413369", "golden_code": "N, D = list(map(int, input().split()))\n\ncnt = 0\n\nfor _ in range(N):\n\n    x, y = list(map(int, input().split()))\n\n    if x ** 2 + y ** 2 <= D ** 2:\n\n        cnt += 1\n\n        \n\nprint(cnt)", "generated_code": "N, D = list(map(int, input().split()))\n\ncnt = 0\n\nfor _ in range(N):\n\n    x, y = list(map(int, input().split()))\n\n    if x * x + y * y <= D * D:\n\n        cnt += 1\n\n        \n\nprint(cnt)", "score": 1.0, "surface_similarity": 0.9312393887945671}
{"id": "p02690_u072717685", "golden_code": "import sys\n\nread = sys.stdin.read\n\nreadlines = sys.stdin.readlines\n\nimport numpy as np\n\ndef main():\n\n    x = int(eval(input()))\n\n    for i1 in range(-201, 201):\n\n        for i2 in range(-201, 201):\n\n            if i1**5 - i2**5 == x:\n\n                print((i1, i2))\n\n                sys.exit()\n\n\n\nif __name__ == '__main__':\n\n    main()", "generated_code": "import sys\n\nread = sys.stdin.read\n\nreadlines = sys.stdin.readlines\n\nimport numpy as np\n\nfrom itertools import product\n\ndef main():\n\n    x = int(input())\n\n    n5 = [i**5 for i in range(201)]\n\n\n\n    c = product(n5, repeat=2)\n\n    for ce in c:\n\n        if ce[0] + ce[1] == x:\n\n            r = (int(ce[0]**0.2), int(ce[1]**0.2)* -1)\n\n            break\n\n        elif ce[0] - ce[1] == x:\n\n            r = (int(ce[0] ** 0.2), int(ce[1] ** 0.2))\n\n            break\n\n    print(*r, sep=' ')\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 1.0, "surface_similarity": 0.673532649632076}
{"id": "p03696_u588341295", "golden_code": "# -*- coding: utf-8 -*-\n\n\n\nimport sys\n\ndef input(): return sys.stdin.readline().strip()\n\nsys.setrecursionlimit(10 ** 9)\n\n\n\nfrom collections import deque\n\n\n\nN = int(eval(input()))\n\nS = eval(input())\n\n\n\nans = deque()\n\ntmp = ''\n\nl = r = 0\n\nfor c in S:\n\n    if c == '(':\n\n        l += 1\n\n        tmp += '('\n\n    else:\n\n        if l == 0:\n\n            ans.appendleft('(')\n\n            ans.append(')')\n\n        else:\n\n            r += 1\n\n            tmp += ')'\n\n            if l == r:\n\n                ans.append(tmp)\n\n                tmp = ''\n\n                l = r = 0\n\nif l > r:\n\n    tmp += ')' * (l-r)\n\n    ans.append(tmp)\n\nprint((''.join(ans)))\n", "generated_code": "# -*- coding: utf-8 -*-\n\n\n\nimport sys\n\n\n\ndef input(): return sys.stdin.readline().strip()\n\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\n\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\n\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\n\ndef ceil(x, y=1): return int(-(-x // y))\n\ndef INT(): return int(eval(input()))\n\ndef MAP(): return list(map(int, input().split()))\n\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\n\ndef Yes(): print('Yes')\n\ndef No(): print('No')\n\ndef YES(): print('YES')\n\ndef NO(): print('NO')\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = 10 ** 18\n\nMOD = 10 ** 9 + 7\n\n\n\nN = INT()\n\nS = eval(input())\n\n\n\n# それぞれ必要な数を確認\n\nlneed = cnt = 0\n\nfor s in S:\n\n    if s == ')':\n\n        cnt += 1\n\n        lneed = max(lneed, cnt)\n\n    else:\n\n        cnt -= 1\n\nrneed = cnt = 0\n\nfor s in S[::-1]:\n\n    if s == '(':\n\n        cnt += 1\n\n        rneed = max(rneed, cnt)\n\n    else:\n\n        cnt -= 1\n\n\n\n# 辞書順最小なので、(は全部左に、)は全部右に付ける\n\nans = ('(' * lneed) + S + (')' * rneed)\n\nprint(ans)\n", "score": 1.0, "surface_similarity": 0.5613815450327713}
{"id": "p02814_u617515020", "golden_code": "from fractions import gcd\n\n\n\nn,m=list(map(int,input().split()))\n\na=list(map(int,input().split()))\n\na=list(set(a))\n\n\n\na=list([x//2 for x in a])\n\n\n\ndef lcm(q):\n\n  x = q[0]\n\n  for i in range(1, len(q)):\n\n    x = (x * q[i]) // gcd(x, q[i])\n\n  return x\n\n\n\nlcma=lcm(a)\n\n\n\nif (lcma//a[0])%2==0:\n\n  print((0))\n\nelse:\n\n  flg=0\n\n  for i in range(1,len(a)):\n\n    if (lcma//a[i])%2==0:\n\n      print((0))\n\n      flg=1\n\n      break\n\n  if flg==0:\n\n    temp=m//lcma\n\n    print((temp//2 if temp%2==0 else temp//2+1))", "generated_code": "from math import gcd\n\nn,m=list(map(int,input().split()))\n\na=list(map(int,input().split()))\n\na=list(set(a))\n\na=list([x//2 for x in a])\n\n\n\ndef lcm(q):\n\n  x = q[0]\n\n  for i in range(1, len(q)):\n\n    x = (x * q[i]) // gcd(x, q[i])\n\n  return x\n\n\n\nlcma=lcm(a)\n\nfor i in range(len(a)):\n\n  if (lcma//a[i])%2==0:\n\n    print((0))\n\n    exit()\n\ntemp=m//lcma\n\nprint((temp//2 if temp%2==0 else temp//2+1))", "score": 1.0, "surface_similarity": 0.9117266791647811}
{"id": "p02693_u209275335", "golden_code": "S = int(eval(input()))\n\na = 0\n\ncount = 0\n\nn,m = list(map(int,input().split()))\n\nwhile count == 0:\n\n    a += S\n\n    if n <= a and m >= a:\n\n        count = 1\n\n    if a >= 1000:\n\n        break\n\nif count == 0:\n\n    print(\"NG\")\n\nelse:\n\n    print(\"OK\")", "generated_code": "k = int(eval(input()))\n\nn = 0\n\na,b = list(map(int,input().split()))\n\nwhile True:\n\n    n += k\n\n    if n >= a and n <= b:\n\n        print(\"OK\")\n\n        break\n\n    if n > b:\n\n        print(\"NG\")\n\n        break", "score": 1.0, "surface_similarity": 0.8264966740576496}
{"id": "p03171_u038021590", "golden_code": "N = int(eval(input()))\n\nA = list(map(int, input().split()))\n\nn = N % 2\n\n\n\nDP = [[0] * (N+1) for _ in range(N+1)]\n\n\n\nfor w in range(1, N+1):\n\n    for i in range(N):\n\n        j = i + w\n\n        if j > N:\n\n            continue\n\n        if (w+n) % 2 == 1:\n\n            DP[i][j] = min(DP[i+1][j] - A[i], DP[i][j-1] - A[j-1])\n\n        else:\n\n            DP[i][j] = max(DP[i+1][j] + A[i], DP[i][j-1] + A[j-1])\n\n\n\nprint((DP[0][N]))\n", "generated_code": "N = int(eval(input()))\n\nA = list(map(int, input().split()))\n\nDP = [[0] * (N+1) for _ in range(N+1)]\n\n\n\nfor num in range(1, N + 1):\n\n    for start in range(N):\n\n        end = start + num\n\n        if end > N:\n\n            break\n\n        if num == 1:\n\n            DP[start][end] = A[start]\n\n        else:\n\n            DP[start][end] = max(A[start] - DP[start+1][end], A[end - 1] - DP[start][end - 1])\n\nprint((DP[0][N]))\n", "score": 1.0, "surface_similarity": 0.7984397677793904}
{"id": "p02837_u949115942", "golden_code": "n = int(eval(input()))\n\n\n\nXY = []\n\nfor i in range(n):\n\n    a = int(eval(input()))\n\n    xy = []\n\n    for j in range(a):\n\n        xy.append(list(map(int, input().split())))\n\n    \n\n    XY.append(xy)\n\n    \n\ndef check(i, xiyj, HoU):\n\n    # 矛盾したらFalse 正直者と仮定した証言より 正直&正直者と仮定されている / 不親切&不親切と仮定されている True\n\n    if ((i >> xiyj) & 1) ^ HoU:\n\n        return False\n\n\n\n    return True\n\n    \n\nmax_honest = 0\n\nfor i in range(2 ** len(XY)):\n\n    count = 0\n\n    is_contradiction = True\n\n    for j in range(len(XY)):\n\n        # 正直者と仮定したときだけ採用\n\n        if not ((i >> j) & 1): continue\n\n        for k in range(len(XY[j])):\n\n            xiyj = XY[j][k][0] - 1\n\n            HoU = XY[j][k][1]\n\n            \n\n            if not check(i, xiyj, HoU):\n\n                is_contradiction = False\n\n                break\n\n                \n\n        if not is_contradiction:\n\n            break\n\n\n\n    if is_contradiction:\n\n        for j in range(len(XY)):\n\n            if ((i >> j) & 1): count+=1 \n\n                \n\n        if count > max_honest:\n\n            max_honest =count\n\n            \n\nprint(max_honest)", "generated_code": "n = int(eval(input()))\n\n\n\nXY = []\n\nfor i in range(n):\n\n    a = int(eval(input()))\n\n    xy = []\n\n    for j in range(a):\n\n        xy.append(list(map(int, input().split())))\n\n    \n\n    XY.append(xy)\n\n\n\n\"\"\"\n\n    矛盾したらFalse\n\n    矛盾しなければTrue\n\n    正直者と仮定した者の証言\n\n        正直&正直者と仮定されている\n\n        不親切&不親切と仮定されている\n\n\"\"\"\n\ndef check(i, xiyj, HoU):\n\n    # XOR\n\n    if HoU ^ ((i >> xiyj) & 1):\n\n        return False\n\n\n\n    return True\n\n\n\nmax_honest = 0\n\nfor i in range(2 ** len(XY)):\n\n    count = 0\n\n    is_contradiction = True\n\n    for j in range(len(XY)):\n\n        # 正直者と仮定したときだけ採用\n\n        if not ((i >> j) & 1): continue\n\n        count+=1\n\n        for k in range(len(XY[j])):\n\n            xiyj = XY[j][k][0] - 1\n\n            HoU = XY[j][k][1]\n\n            \n\n            if not check(i, xiyj, HoU):\n\n                is_contradiction = False\n\n                break # TLE対策\n\n                \n\n        if not is_contradiction:\n\n            break # TLE対策\n\n\n\n    # 矛盾がなく、正直者の数が更新できれば更新\n\n    if is_contradiction and (count > max_honest):\n\n        max_honest =count\n\n            \n\nprint(max_honest)", "score": 1.0, "surface_similarity": 0.9042617046818727}
{"id": "p03796_u754022296", "golden_code": "from math import factorial as fc\n\na = int(eval(input()))\n\nprint((fc(a)%(10**9+7)))", "generated_code": "n = int(eval(input()))\n\nm = 10**9+7\n\nans = 1\n\nfor i in range(1, n+1):\n\n  ans *= i\n\n  ans %= m\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.5148459383753501}
{"id": "p02574_u957843607", "golden_code": "from math import gcd\n\n\n\nN = int(eval(input()))\n\nnum_lis = list(map(int, input().split()))\n\nc = True\n\n\n\ndef osa_k(max_num):\n\n  lis = [i for i in range(max_num+1)]\n\n  p = 2\n\n  while p**2 <= max_num:\n\n    if lis[p] == p:\n\n      for q in range(2*p, max_num+1, p):\n\n        if lis[q] == q:\n\n          lis[q] = p\n\n    p += 1\n\n  return lis\n\n\n\nhoge = 0\n\nfor i in num_lis:\n\n  hoge = gcd(hoge, i)\n\nif hoge > 1:\n\n  print(\"not coprime\")\n\n  exit()\n\n\n\nd_lis = osa_k(10**6+10)\n\ntmp = set()\n\nfor i in num_lis:\n\n  num = i\n\n  new_tmp = set()\n\n  while num > 1:\n\n    d = d_lis[num]\n\n    new_tmp.add(d)\n\n    num //= d\n\n  for j in new_tmp:\n\n    if j in tmp:\n\n      c = False\n\n      break\n\n    else:\n\n      tmp.add(j)\n\n  else:\n\n    continue\n\n  break\n\n\n\nif c:\n\n  print(\"pairwise coprime\")\n\nelse:\n\n  print(\"setwise coprime\")", "generated_code": "from math import gcd\n\n\n\nN = int(eval(input()))\n\nnum_lis = list(map(int, input().split()))\n\n\n\ndef osa_k(max_num):\n\n  lis = [i for i in range(max_num+1)]\n\n  p = 2\n\n  while p**2 <= max_num:\n\n    if lis[p] == p:\n\n      for q in range(2*p, max_num+1, p):\n\n        if lis[q] == q:\n\n          lis[q] = p\n\n    p += 1\n\n  return lis\n\n\n\nhoge = 0\n\nfor i in num_lis:\n\n  hoge = gcd(hoge, i)\n\nif hoge > 1:\n\n  print(\"not coprime\")\n\n  exit()\n\n\n\nd_lis = osa_k(max(num_lis))\n\ntmp = set()\n\nfor i in num_lis:\n\n  num = i\n\n  new_tmp = set()\n\n  while num > 1:\n\n    d = d_lis[num]\n\n    new_tmp.add(d)\n\n    num //= d\n\n  for j in new_tmp:\n\n    if j in tmp:\n\n      print(\"setwise coprime\")\n\n      exit()\n\n    else:\n\n      tmp.add(j)\n\nprint(\"pairwise coprime\")", "score": 1.0, "surface_similarity": 0.9126050420168067}
{"id": "p02850_u380524497", "golden_code": "n = int(eval(input()))\n\nedges = []\n\n\n\nfor id in range(n-1):\n\n    a, b = list(map(int, input().split()))\n\n    edges.append([a-1, b-1, id])\n\n\n\nedges.sort()\n\n\n\nused = [0]*(n)\n\nans = [0]*(n-1)\n\nnum = 1\n\nprev = 0\n\nfor edge in edges:\n\n    _from, to, id = edge\n\n    if _from != prev:\n\n        num = 1\n\n    if used[_from] == num:\n\n        num += 1\n\n    ans[id] = num\n\n    used[to] = num\n\n    num += 1\n\n    prev = _from\n\n\n\nprint((max(ans)))\n\nfor color in ans:\n\n    print(color)\n", "generated_code": "import sys\n\ninput = sys.stdin.readline\n\n\n\nn = int(eval(input()))\n\nedges = []\n\n\n\nfor id in range(n-1):\n\n    a, b = list(map(int, input().split()))\n\n    edges.append([a-1, b-1, id])\n\n\n\nedges.sort()\n\n\n\nused = [0]*(n)\n\nans = [0]*(n-1)\n\nnum = 1\n\nprev = 0\n\nfor edge in edges:\n\n    _from, to, id = edge\n\n    if _from != prev:\n\n        num = 1\n\n    if used[_from] == num:\n\n        num += 1\n\n    ans[id] = num\n\n    used[to] = num\n\n    num += 1\n\n    prev = _from\n\n\n\nprint((max(ans)))\n\nfor color in ans:\n\n    print(color)\n", "score": 1.0, "surface_similarity": 0.9257534246575343}
{"id": "p00003_u234052535", "golden_code": "for i in range(0, int(eval(input()))):\n\n    sidelen = [int(j) for j in input().split(\" \")]\n\n    sidelen.sort(reverse=True)\n\n    if(sidelen[0]**2 == sidelen[1]**2 + sidelen[2]**2):\n\n        print(\"YES\")\n\n    else:\n\n        print(\"NO\")", "generated_code": "import sys\n\nfor i in sys.stdin:\n\n    try:\n\n        sidelen = [int(j) for j in i.split(\" \")]\n\n        sidelen.sort(reverse=True)\n\n        if(sidelen[0]**2 == sidelen[1]**2 + sidelen[2]**2):\n\n            print(\"YES\")\n\n        else:\n\n            print(\"NO\")\n\n    except:\n\n        continue", "score": 1.0, "surface_similarity": 0.8143724696356276}
{"id": "p02760_u247680229", "golden_code": "import numpy as np\n\nN_1=list(map(int, input().split()))\n\nN_2=list(map(int, input().split()))\n\nN_3=list(map(int, input().split()))\n\nN=int(eval(input()))\n\na=[int(eval(input())) for i in range(N)]\n\n\n\nn=np.array([N_1,N_2,N_3])\n\n\n\nfor a_n in a:\n\n    if a_n in n:\n\n        n[n==a_n]=0\n\n    else:\n\n        pass\n\ni=0\n\n    \n\nif np.all(n[0:,0]==0)==True:\n\n    i=+1\n\n    \n\nelif np.all(n[0:,1]==0)==True:\n\n    i+=1\n\n    \n\nelif np.all(n[0:,2]==0)==True:\n\n    i+=1\n\n    \n\nelif np.all(n[0,0:]==0)==True:\n\n    i+=1\n\n    \n\nelif np.all(n[1,0:]==0)==True:\n\n    i+=1\n\n\n\nelif np.all(n[2,0:]==0)==True:\n\n    i+=1\n\n\n\nelif n[0,0]==0 and n[1,1]==0  and n[2,2] ==0:\n\n    i+=1\n\n    \n\nelif n[0,2]==0 and n[1,1]==0 and n[2,0] ==0:\n\n    i+=1\n\n    \n\nif i>0:\n\n    print(\"Yes\")\n\nelse:\n\n    print(\"No\")", "generated_code": "a_1=list(map(int, input().split()))\n\na_2=list(map(int, input().split()))\n\na_3=list(map(int, input().split()))\n\n\n\nc=[a_1,a_2,a_3]\n\n\n\nN=int(eval(input()))\n\n\n\nb=[int(eval(input())) for _ in range(N)]\n\n\n\nfor i in range(3):\n\n    for j in range(3):\n\n        if c[i][j] in b:\n\n            c[i][j]=0\n\n            \n\n            \n\ni=0\n\nif c[0][0]==0 and c[0][1]==0 and c[0][2]==0:\n\n    i+=1\n\nif c[1][0]==0 and c[1][1]==0 and c[1][2]==0:\n\n    i+=1\n\nif c[2][0]==0 and c[2][1]==0 and c[2][2]==0:\n\n    i+=1\n\nif c[0][0]==0 and c[1][0]==0 and c[2][0]==0:\n\n    i+=1\n\nif c[0][1]==0 and c[1][1]==0 and c[2][1]==0:\n\n    i+=1\n\nif c[0][2]==0 and c[1][2]==0 and c[2][2]==0:\n\n    i+=1\n\nif c[0][0]==0 and c[1][1]==0 and c[2][2]==0:\n\n    i+=1\n\nif c[0][2]==0 and c[1][1]==0 and c[2][0]==0:\n\n    i+=1\n\n    \n\nif i>0:\n\n    print(\"Yes\")\n\nelse:\n\n  print(\"No\")", "score": 1.0, "surface_similarity": 0.6924123337363965}
{"id": "p03424_u341543478", "golden_code": "n = int(eval(input()))\n\ns = input().split()\n\ns = set(s)\n\nprint(('Four' if len(s) == 4 else 'Three'))", "generated_code": "n = int(eval(input()))\n\ns = input().split()\n\nprint(('Four' if len(set(s)) == 4 else 'Three'))", "score": 1.0, "surface_similarity": 0.9299999999999999}
{"id": "p02899_u784022244", "golden_code": "import numpy as np\n\n\n\n\n\nN=int(input())\n\n\n\nA=np.array([list(map(int, input().split()))])\n\n\n\n\n\nB=np.argsort(A[0,:])\n\nfor b in B:\n\n  print(b+1, end=' ')\n", "generated_code": "N=int(input())\n\n\n\nA=list(map(int, input().split()))\n\nB=[-1]*N\n\nfor i in range(N):\n\n  B[A[i]-1]=i+1\n\n  \n\nfor b in B:\n\n  print(b, end=\" \")\n", "score": 1.0, "surface_similarity": 0.6266666666666667}
{"id": "p00122_u633068244", "golden_code": "dX = [2,2,2,1,0,-1,-2,-2,-2,-1,0,1]\n\ndY = [-1,0,1,2,2,2,1,0,-1,-2,-2,-2]\n\ndef solve(x,y,XY):\n\n\txy = XY[:]\n\n\tif len(xy) == 0: return \"OK\"\n\n\tsx,sy = xy.pop(0),xy.pop(0)\n\n\tfor dx,dy in zip(dX,dY):\n\n\t\tif doa(x+dx,y+dy,sx,sy): \n\n\t\t\tr = solve(x+dx,y+dy,xy)\n\n\t\t\tif r: return r\n\n\n\ndef doa(x,y,sx,sy):\n\n\tif not (0 <= x <= 9 and 0 <= y <= 9): return False\n\n\treturn True if abs(x-sx) < 2 and abs(y-sy) < 2 else False\n\n\n\nwhile 1:\n\n\tx,y = list(map(int,input().split()))\n\n\tif x == y == 0: break\n\n\tn = eval(input())\n\n\txy = list(map(int,input().split()))\n\n\tans = solve(x,y,xy)\n\n\tprint(ans if ans else \"NA\")", "generated_code": "dX = [2,2,2,1,0,-1,-2,-2,-2,-1,0,1]\n\ndY = [-1,0,1,2,2,2,1,0,-1,-2,-2,-2]\n\ndef solve(x,y,XY):\n\n\txy = XY[:]\n\n\tif len(xy) == 0: return True\n\n\tsx,sy = xy.pop(0),xy.pop(0)\n\n\tfor dx,dy in zip(dX,dY):\n\n\t\tif doa(x+dx,y+dy,sx,sy): \n\n\t\t\tr = solve(x+dx,y+dy,xy)\n\n\t\t\tif r: return r\n\n\n\ndef doa(x,y,sx,sy):\n\n\tif not (0 <= x <= 9 and 0 <= y <= 9): return False\n\n\treturn True if abs(x-sx) < 2 and abs(y-sy) < 2 else False\n\n\n\nwhile 1:\n\n\tx,y = list(map(int,input().split()))\n\n\tif x == y == 0: break\n\n\tn = eval(input())\n\n\txy = list(map(int,input().split()))\n\n\tprint(\"OK\" if solve(x,y,xy) else \"NA\")", "score": 1.0, "surface_similarity": 0.9745762711864407}
{"id": "p03988_u827202523", "golden_code": "import sys\n\ninput = sys.stdin.readline\n\nsys.setrecursionlimit(1000000)\n\nfrom collections import deque\n\ndef getN():\n\n    return int(eval(input()))\n\ndef getList():\n\n    return list(map(int, input().split()))\n\nimport math\n\n\n\nn = getN()\n\nnums = getList()\n\n\n\n# nums.sort(reverse=True)\n\nmx = max(nums)\n\nmn = (mx+1) // 2\n\nmndx = (mx % 2) + 1\n\n\n\nfrom collections import Counter\n\n\n\ncnt = Counter(nums)\n\n\n\nfor i in range(mn+1, mx+1):\n\n    if cnt[i] < 2:\n\n        print(\"Impossible\")\n\n        sys.exit()\n\n\n\nif cnt[mn] != mndx:\n\n    print(\"Impossible\")\n\nelse:\n\n    print(\"Possible\")", "generated_code": "import sys\n\nimport math\n\nimport copy\n\nfrom heapq import heappush, heappop, heapify\n\nfrom functools import cmp_to_key\n\nfrom bisect import bisect_left, bisect_right\n\nfrom collections import defaultdict, deque, Counter\n\n# sys.setrecursionlimit(1000000)\n\n\n\n# input aliases\n\ninput = sys.stdin.readline\n\ngetS = lambda: input().strip()\n\ngetN = lambda: int(eval(input()))\n\ngetList = lambda: list(map(int, input().split()))\n\ngetZList = lambda: [int(x) - 1 for x in input().split()]\n\n\n\nINF = float(\"inf\")\n\nMOD = 10**9 + 7\n\ndivide = lambda x: pow(x, MOD-2, MOD)\n\n\n\ndef pim():\n\n    print(\"Impossible\")\n\n    sys.exit()\n\ndef pp():\n\n    print(\"Possible\")\n\n    sys.exit()\n\ndef solve():\n\n    n = getN()\n\n    nums = getList()\n\n    cnt = Counter(nums)\n\n    mx = max(nums)\n\n    mn = min(nums)\n\n\n\n    if cnt[mx] < 2:\n\n        pim()\n\n    if mn < (mx + 1) // 2:\n\n        pim()\n\n\n\n    if mx % 2 == 0:\n\n        if cnt[mx//2] != 1:\n\n            pim()\n\n    else:\n\n        if cnt[(mx+1) // 2] != 2:\n\n            pim()\n\n\n\n    for i in range((mx + 1) // 2 + 1, mx+1):\n\n        if cnt[i] < 2:\n\n            pim()\n\n\n\n    pp()\n\n\n\n\n\ndef main():\n\n    n = getN()\n\n    for _ in range(n):\n\n        solve()\n\n\n\n    return\n\nif __name__ == \"__main__\":\n\n    # main()\n\n    solve()\n\n\n\n\n\n\n\n\n\n\n", "score": 1.0, "surface_similarity": 0.6587869059779172}
{"id": "p02390_u990900604", "golden_code": "import sys\n\n\n\nif __name__ == '__main__':\n\n    import doctest\n\n    doctest.testmod()\n\n    S = int(sys.stdin.read())\n\n    h = S / 3600\n\n    m = (S % 3600) / 60\n\n    s = S % 60\n\n    print(\"%d:%d:%d\" % (h, m, s))\n", "generated_code": "#!/usr/bin/env python\n\n#-*- coding: utf-8 -*-\n\n\n\n# http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ITP1_1_D\n\n\n\nif __name__ == '__main__':\n\n    S = int(input())\n\n    h = S / 3600\n\n    m = (S % 3600) / 60\n\n    s = S % 60\n\n    print(\"%d:%d:%d\" % (h, m, s))\n", "score": 1.0, "surface_similarity": 0.8140050697084917}
{"id": "p02880_u780698286", "golden_code": "n = int(eval(input()))\n\ns = []\n\nfor i in range(1, 10):\n\n  for j in range(1, 10):\n\n    s.append(i*j)\n\nif n in s:\n\n  print(\"Yes\")\n\nelse:\n\n  print(\"No\")", "generated_code": "import sys\n\n\n\nn = int(eval(input()))\n\nfor i in range(1, 10):\n\n  for j in range(1, 10):\n\n    if i*j == n:\n\n      print(\"Yes\")\n\n      sys.exit()\n\nprint(\"No\")\n", "score": 1.0, "surface_similarity": 0.743421052631579}
{"id": "p02773_u861109991", "golden_code": "# ABC 155 C\n\nfrom collections import Counter\n\nimport numpy as np\n\nN = int(eval(input()))\n\nS = [str(eval(input())) for i in range(N)]\n\nS = np.array(S)\n\n\n\ncount = Counter(S)\n\nmax_num = max(count.values())\n\nmax_list = [i for i,j in list(count.items()) if j==max_num]\n\n\n\nmax_list.sort()\n\nprint(('\\n'.join(max_list)))", "generated_code": "import sys\n\nfrom collections import Counter\n\nN = int(sys.stdin.readline())\n\nS = sys.stdin.read().split()\n\n\n\ncount = Counter(S)\n\nmax_num = max(count.values())\n\nmax_list = [i for i,j in list(count.items()) if j==max_num]\n\n \n\nmax_list.sort()\n\nprint(('\\n'.join(max_list)))", "score": 1.0, "surface_similarity": 0.8846153846153846}
{"id": "p03796_u814986259", "golden_code": "import math\n\nN=int(eval(input()))\n\nans=math.factorial(N)\n\nprint((ans%(10**9 +7)))", "generated_code": "mod=10**9+7\n\nN=int(eval(input()))\n\nans=1\n\nfor i in range(1,N+1):\n\n  ans*=i\n\n  ans%=mod\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.5731292517006803}
{"id": "p02899_u328510800", "golden_code": "import numpy as np\n\nn = int(eval(input()))\n\na = np.array(list(map(int, input().split())))\n\n\n\nprint((*list([x + 1 for x in np.argsort(a)])))", "generated_code": "n = int(eval(input()))\n\nm = [(x, 0) for x in range(1, n+1)]\n\n\n\nfor i, x in enumerate(map(int, input().split())):\n\n  m[i] = (m[i][0], x)\n\nm.sort(key=lambda x : x[1])\n\nprint((' '.join([str(x[0]) for x in m])))", "score": 1.0, "surface_similarity": 0.4882246376811594}
{"id": "p03634_u670180528", "golden_code": "from collections import deque\n\nn,*t=list(map(int,open(0).read().split()))\n\ncon=[[] for _ in range(n)]\n\ndist_f_k=[0]*n\n\n\n\nfor a,b,c in zip(t[:3*n-3:3],t[1::3],t[2::3]):\n\n\tcon[a-1].append((b-1,c))\n\n\tcon[b-1].append((a-1,c))\n\n\n\nk=t[3*n-2]\n\nque=deque([k-1])\n\nwhile que:\n\n\tcur=que.popleft()\n\n\tfor nxt,dd in con[cur]:\n\n\t\tif dist_f_k[nxt]==0 and nxt!=k-1:\n\n\t\t\tque.append(nxt)\n\n\t\t\tdist_f_k[nxt]=dist_f_k[cur]+dd\n\n\n\nfor x,y in zip(t[3*n-1::2],t[3*n::2]):\n\n\tprint((dist_f_k[x-1]+dist_f_k[y-1]))", "generated_code": "def solve():\n\n\tfrom collections import deque\n\n\tn,*t=list(map(int,open(0).read().split()))\n\n\tcon=[[] for _ in range(n)]\n\n\tdist_f_k=[0]*n\n\n\tl1,l2=t[:3*n-3],t[3*n-1:]\n\n\n\n\tfor a,b,c in zip(*[iter(l1)]*3):\n\n\t\tcon[a-1].append((b-1,c))\n\n\t\tcon[b-1].append((a-1,c))\n\n\n\n\tk=t[3*n-2]\n\n\tque=deque([k-1])\n\n\twhile que:\n\n\t\tcur=que.popleft()\n\n\t\tfor nxt,dd in con[cur]:\n\n\t\t\tif dist_f_k[nxt]==0 and nxt!=k-1:\n\n\t\t\t\tque.append(nxt)\n\n\t\t\t\tdist_f_k[nxt]=dist_f_k[cur]+dd\n\n\n\n\tfor x,y in zip(*[iter(l2)]*2):\n\n\t\tprint((dist_f_k[x-1]+dist_f_k[y-1]))\n\n\t\t\n\nif __name__==\"__main__\":\n\n\tsolve()", "score": 1.0, "surface_similarity": 0.8770053475935828}
{"id": "p02622_u724687935", "golden_code": "S = eval(input())\n\nT = eval(input())\n\nN = len(S)\n\ncnt = 0\n\nfor i in range(N):\n\n    cnt += (S[i] != T[i])\n\n\n\nprint(cnt)\n", "generated_code": "S = eval(input())\n\nT = eval(input())\n\ncnt = 0\n\nfor i in range(len(S)):\n\n    cnt += (S[i] != T[i])\n\n\n\nprint(cnt)", "score": 1.0, "surface_similarity": 0.9369747899159664}
{"id": "p03253_u638456847", "golden_code": "import sys\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\nreadlines = sys.stdin.readlines\n\n\n\nMOD = 10**9+7\n\n\n\nfac = [1, 1]     # 元テーブル\n\nf_inv = [1, 1]   # 逆元テーブル\n\ninv = [0, 1]     # 逆元テーブル計算用テーブル\n\ndef prepare(n, mod):\n\n    for i in range(2, n+1):\n\n        fac.append((fac[-1] * i) % mod)\n\n\n\n\n\ndef cmb(n, r, mod):\n\n    if n < 0 or r < 0:\n\n        return 0\n\n    if r > n:\n\n        return 0\n\n\n\n    return fac[n] * pow(fac[r],MOD-2,MOD) * pow(fac[n-r],MOD-2,MOD) % mod\n\n\n\n\n\ndef prime_factorization(n):\n\n    d = []\n\n    i, e = 2, 0  # factor, exponent\n\n    while i * i <= n:\n\n        while n % i == 0:\n\n            n //= i\n\n            e += 1\n\n        if e > 0:\n\n            d.append((i, e))\n\n        i += 1\n\n        e = 0\n\n    if n > 1:\n\n        d.append((n, 1))\n\n    return d\n\n\n\n\n\ndef main():\n\n    N,M = list(map(int, readline().split()))\n\n\n\n    prepare(N+100, MOD)\n\n    d = prime_factorization(M)\n\n\n\n    ans = 1\n\n    for i, e in d:\n\n        ans *= cmb(N-1+e, e, MOD)\n\n        ans %= MOD\n\n\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "generated_code": "# AC: msec(Python3)\n\nfrom math import factorial\n\nimport sys\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\nreadlines = sys.stdin.readlines\n\n\n\nMOD = 10**9+7\n\n\n\ndef cmb(n, r):\n\n    if n < 0 or r < 0:\n\n        return 0\n\n    if r > n:\n\n        return 0\n\n\n\n    r = min(n-r, r)\n\n    res = 1\n\n    for i in range(r):\n\n        res *= n - i\n\n\n\n    return res // factorial(r)\n\n\n\n\n\ndef prime_factorization(n):\n\n    d = []\n\n    i, e = 2, 0  # factor, exponent\n\n    while i * i <= n:\n\n        while n % i == 0:\n\n            n //= i\n\n            e += 1\n\n        if e > 0:\n\n            d.append((i, e))\n\n        i += 1\n\n        e = 0\n\n    if n > 1:\n\n        d.append((n, 1))\n\n    return d\n\n\n\n\n\ndef main():\n\n    N,M = list(map(int, readline().split()))\n\n\n\n    d = prime_factorization(M)\n\n\n\n    ans = 1\n\n    for i, e in d:\n\n        ans *= cmb(N-1+e, e)\n\n        ans %= MOD\n\n\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "score": 1.0, "surface_similarity": 0.8375}
{"id": "p02690_u047178225", "golden_code": "X = int(eval(input()))\n\n#print(X)\n\nn = X\n\ndiv = []\n\nfor i in range(1, int(n**0.5)+1):\n\n  if n % i == 0:\n\n    div.append(i)\n\n    if i != n // i:\n\n      div.append(n//i)\n\n#print(div)\n\n\n\nfor i in div:\n\n  for a in range(0, 10001): \n\n    b = a - i\n\n    #print(a, b)\n\n    if a**5 - b**5 == X:\n\n      print((a, b))\n\n      break\n\n  else:\n\n    continue\n\n  break\n\n   \n\n    ", "generated_code": "X = int(eval(input()))\n\n#print(X)\n\nn = X\n\ndiv = []\n\nfor i in range(1, int(n**0.5)+1):\n\n  if n % i == 0:\n\n    div.append(i)\n\n    if i != n // i:\n\n      div.append(n//i)\n\n#print(div)\n\n\n\nfor i in div:\n\n  for a in range(0, 1001): \n\n    b = a - i\n\n    #print(a, b)\n\n    if a**5 - b**5 == X:\n\n      print((a, b))\n\n      break\n\n  else:\n\n    continue\n\n  break", "score": 1.0, "surface_similarity": 0.9986225895316805}
{"id": "p02264_u604774382", "golden_code": "n, q = [ int( val ) for val in input( ).split( \" \" ) ]\n\nps = [0]*n\n\nt = [0]*n\n\nfor i in range( n ):\n\n\tps[i], t[i] = input( ).split( \" \" )\n\n\n\n\n\noutput = []\n\nqsum = 0\n\nwhile t:\n\n\tpsi = ps.pop( 0 )\n\n\tti = int( t.pop( 0 ) )\n\n\tif ti <= q:\n\n\t\tqsum += ti\t\n\n\t\toutput.append( psi+\" \"+str( qsum ) )\n\n\telse:\n\n\t\tt.append( ti - q )\n\n\t\tps.append( psi )\n\n\t\tqsum += q\n\n\n\nprint(( \"\\n\".join( output ) ))", "generated_code": "n, q = [ int( val ) for val in input( ).split( \" \" ) ]\n\nps = [0]*n\n\nt = [0]*n\n\nfor i in range( n ):\n\n    ps[i], t[i] = input( ).split( \" \" )\n\n \n\n \n\noutput = []\n\nqsum = 0\n\nwhile t:\n\n    psi = ps.pop( 0 )\n\n    ti = int( t.pop( 0 ) )\n\n    if ti <= q:\n\n        qsum += ti\n\n        output.append( \"\".join( ( psi, \" \", str( qsum ) ) ) )\n\n    else:\n\n        t.append( ti - q )\n\n        ps.append( psi )\n\n        qsum += q\n\n \n\nprint(( \"\\n\".join( output ) ))", "score": 1.0, "surface_similarity": 0.9855233853006682}
{"id": "p03273_u759412327", "golden_code": "import numpy as np\n\nimport sys\n\n\n\nbuf = sys.stdin.buffer\n\nH,W = list(map(int,buf.readline().split()))\n\n\n\ngrid = np.frombuffer(buf.read(H*(W+1)), dtype='S1').reshape((H,W+1))\n\ngrid = grid[:,:-1]\n\n\n\nselect_col = (grid == b'#').any(axis = 0)\n\nselect_row = (grid == b'#').any(axis = 1)\n\n\n\ngrid = grid[select_row, :]\n\ngrid = grid[:, select_col]\n\ngrid = grid.astype(str)\n\n\n\nprint(('\\n'.join(''.join(row) for row in grid)))\n", "generated_code": "H,W = list(map(int,input().split()))\n\nA = [eval(input()) for _ in range(H)]\n\nA = list([a for a in A if any(x=='#' for x in a)]) \n\nA = list([a for a in zip(*A) if any(x=='#' for x in a)])\n\n\n\nfor a in zip(*A):\n\n  print((''.join(a)))", "score": 1.0, "surface_similarity": 0.4200363846853552}
{"id": "p02688_u629538480", "golden_code": "N,K = list(map(int, input().split(' ')))\n\na=list(range(1,N+1))\n\nfor i in range(K):\n\n  count=int(eval(input()))\n\n  b=input().split(' ')\n\n  for j in range(count):\n\n    if int(b[j]) in a:\n\n      a.remove(int(b[j]))\n\nprint((len(a)))", "generated_code": "N,K = list(map(int, input().split(' ')))\n\na=list(range(1,N+1))\n\nfor i in range(K):\n\n  count=int(eval(input()))\n\n  b=[int(x.strip()) for x in input().split(' ')]\n\n  for j in range(count):\n\n    if b[j] in a:\n\n      a.remove(b[j])\n\nprint((len(a)))", "score": 1.0, "surface_similarity": 0.8844262295081967}
{"id": "p02416_u780342333", "golden_code": "res = []\n\nwhile True:\n\n    s = eval(input())\n\n    if s == '0':\n\n        break\n\n\n\n    res.append(sum([int(x) for x in s]))\n\n\n\nfor e in res:\n\n    print(e)", "generated_code": "def sum_of_numbers(n):\n\n    '''\n\n    (* int -> int *)\n\n    '''\n\n    res = [int(n) for n in list(str(n))]\n\n    \n\n    return sum(res)\n\n\n\nif __name__ == \"__main__\":\n\n    while True:\n\n        n = eval(input())\n\n        if n == '0':\n\n            break\n\n        print((sum_of_numbers(n)))\n", "score": 1.0, "surface_similarity": 0.5776582075168648}
{"id": "p03796_u989345508", "golden_code": "n=int(eval(input()))\n\nx=1\n\nfor i in range(n):\n\n    x*=(i+1)\n\n    if x>10**9+7:\n\n        x=x%(10**9+7)\n\n\n\nprint(x)\n\n#import numpy as np\n\n#n=int(input())\n\n#print(np.prod([i+1 for i in range(n)]))\n\n#print(np.prod([i+1 for i in range(n)])%((10**9)+7))\n\n\n\n#オーバーフロー？\n", "generated_code": "power=1\n\nn=int(eval(input()))\n\nmod=10**9+7\n\nfor i in range(1,n+1):\n\n    power*=i\n\n    power%=mod\n\n    #print(power)\n\nprint(power)\n", "score": 1.0, "surface_similarity": 0.8093869731800767}
{"id": "p03086_u729133443", "golden_code": "import re;print((max(list(map(len,re.split('[^ACGT]',eval(input())))))))", "generated_code": "p=m=0\n\nfor c in eval(input()):p=-~p*(c in'ATGC');m=max(m,p)\n\nprint(m)", "score": 1.0, "surface_similarity": 0.25511695906432746}
{"id": "p02690_u119982001", "golden_code": "X=int(eval(input()))\n\n\n\nfor i in range(200):\n\n    for j in range(-200,200):\n\n        if X == (i**5-j**5):\n\n            print((i, j))\n\n            exit()\n", "generated_code": "X=int(eval(input()))\n\n\n\nfor i in range(120):\n\n    for j in range(-120,120):\n\n        if X == (i**5-j**5):\n\n            print((i, j))\n\n            exit()\n", "score": 1.0, "surface_similarity": 0.9803921568627452}
{"id": "p03575_u389910364", "golden_code": "import os\n\nimport sys\n\n\n\nimport numpy as np\n\nfrom scipy.sparse import csr_matrix\n\nfrom scipy.sparse.csgraph import connected_components\n\n\n\nif os.getenv(\"LOCAL\"):\n\n    sys.stdin = open(\"_in.txt\", \"r\")\n\n\n\nsys.setrecursionlimit(2147483647)\n\nINF = float(\"inf\")\n\nIINF = 10 ** 18\n\nMOD = 10 ** 9 + 7\n\n\n\nN, M = list(map(int, sys.stdin.readline().split()))\n\nA, B = list(zip(*[list(map(int, sys.stdin.readline().split())) for _ in range(M)]))\n\nA = np.array(A) - 1\n\nB = np.array(B) - 1\n\n\n\n\n\ndef is_bridge(i):\n\n    a = np.concatenate([A[:i], A[i + 1:]])\n\n    b = np.concatenate([B[:i], B[i + 1:]])\n\n    graph = csr_matrix(([True] * (M - 1), (a, b)), shape=(N, N))\n\n    _, components = connected_components(graph, directed=False)\n\n    return components.max() >= 1\n\n\n\n\n\nans = 0\n\nfor i in range(M):\n\n    ans += is_bridge(i)\n\nprint(ans)\n", "generated_code": "import os\n\n\n\nimport sys\n\n\n\nif os.getenv(\"LOCAL\"):\n\n    sys.stdin = open(\"_in.txt\", \"r\")\n\n\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = float(\"inf\")\n\nIINF = 10 ** 18\n\nMOD = 10 ** 9 + 7\n\n\n\n\n\n# MOD = 998244353\n\n\n\n\n\ndef enumerate_bridges(graph):\n\n    \"\"\"\n\n    橋を列挙する\n\n    http://nupioca.hatenadiary.jp/entry/2013/11/03/200006\n\n    :param list of (list of int) graph:\n\n    \"\"\"\n\n    N = len(graph)\n\n    ret_bridges = []\n\n    pres = [-1] * N\n\n    lows = [-1] * N\n\n    order = -1\n\n    for v in range(N):\n\n        if pres[v] >= 0:\n\n            continue\n\n        edges = [(None, v, True)]\n\n        while edges:\n\n            v, u, forward = edges.pop()\n\n            if forward:\n\n                if pres[u] >= 0:\n\n                    # もう来たことがある\n\n                    lows[v] = min(lows[v], lows[u])\n\n                    continue\n\n                edges.append((v, u, False))\n\n                parent, v = v, u\n\n                order += 1\n\n                pres[v] = lows[v] = order\n\n                for u in graph[v]:\n\n                    if u == parent:\n\n                        continue\n\n                    edges.append((v, u, True))\n\n            else:\n\n                if v is None:\n\n                    continue\n\n                if lows[u] == pres[u]:\n\n                    ret_bridges.append((v, u))\n\n                lows[v] = min(lows[v], lows[u])\n\n    return ret_bridges\n\n\n\n\n\nN, M = list(map(int, sys.stdin.buffer.readline().split()))\n\nAB = [list(map(int, sys.stdin.buffer.readline().split())) for _ in range(M)]\n\ngraph = [[] for _ in range(N + 1)]\n\nfor a, b in AB:\n\n    graph[a].append(b)\n\n    graph[b].append(a)\n\nbridges = enumerate_bridges(graph)\n\nprint((len(bridges)))\n", "score": 1.0, "surface_similarity": 0.6104397300754201}
{"id": "p03162_u018679195", "golden_code": "n = int(eval(input()))\n\n\n\nfelicidade = []\n\n\n\nfor x in range(n):\n\n    felicidade.append(list(map(int,input().split())))\n\n\n\nDP = [0,0,0]\n\n\n\nif n == 1:\n\n    print((max(felicidade[0])))\n\n\n\nelse:\n\n\n\n    for x in range(3):\n\n        DP[x] = felicidade[0][x]\n\n\n\n\n\n    for dia in range(1,n):\n\n        m = [0] * 3\n\n        for x  in range(3):#As duas possíveis escolhas são x e y\n\n            for y  in range(3):\n\n                if x != y: #Se elas forem diferentes\n\n                    m[x] = max(m[x], DP[y] + felicidade[dia][x])\n\n        DP = m\n\n    \n\n    print((max(DP)))\n", "generated_code": "nDays = int(eval(input()))\n\n\n\ntoday = [int(x) for x in input().split()]\n\n\n\nfor i in range(nDays - 1):\n\n    tomorrow = [int(x) for x in input().split()]\n\n    tomorrow[0] += max(today[1], today[2])\n\n    tomorrow[1] += max(today[0], today[2])\n\n    tomorrow[2] += max(today[0], today[1])\n\n    today = tomorrow\n\n\n\nprint((max(today)))", "score": 1.0, "surface_similarity": 0.5835537918871252}
{"id": "p03828_u654470292", "golden_code": "import math\n\nn=int(eval(input()))\n\nwaru=10**9+7\n\n\n\nli=[]\n\nli2=[]\n\n\n\nfor i in range(2,n+1):\n\n    tmp=math.factorial(n)\n\n    flag=1\n\n    for j in range(len(li)):\n\n        if i%li[j]==0:\n\n            flag=0\n\n            break\n\n    if flag==1:\n\n        li.append(i)\n\n        li2.append(0)\n\n        while tmp%i==0:\n\n            li2[len(li)-1]+=1\n\n            tmp=tmp//i\n\nans=1\n\n# print(li)\n\n# print(li2)\n\nfor i in range(len(li2)):\n\n    ans*=li2[i]+1\n\nprint((ans%waru))", "generated_code": "import sys\n\nfrom collections import *\n\nimport heapq\n\nimport math\n\nimport bisect\n\nfrom itertools import permutations,accumulate,combinations,product\n\nfrom fractions import gcd\n\ndef input():\n\n    return sys.stdin.readline()[:-1]\n\ndef ruiseki(lst):\n\n    return [0]+list(accumulate(lst))\n\nmod=pow(10,9)+7\n\nal=[chr(ord('a') + i) for i in range(26)]\n\n\n\ndef factorization(n):\n\n    arr = []\n\n    temp = n\n\n    for i in range(2, int(-(-n**0.5//1))+1):\n\n        if temp%i==0:\n\n            cnt=0\n\n            while temp%i==0:\n\n                cnt+=1\n\n                temp //= i\n\n            arr.append([i, cnt])\n\n    if temp!=1:\n\n        arr.append([temp, 1])\n\n    if arr==[]:\n\n        arr.append([n, 1])\n\n    return arr\n\n\n\nn=int(eval(input()))\n\nif n==1:\n\n    print((1))\n\n    exit()\n\nd=defaultdict(int)\n\nfor i in range(2,n+1):\n\n    tmp=factorization(i)\n\n    for j in tmp:\n\n        yaku,ko=j\n\n        d[yaku]+=ko\n\n# print(d)\n\nans=1\n\nfor i in list(d.values()):\n\n    ans*=i+1\n\n    ans%=mod\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.5463779128672746}
{"id": "p03013_u832039789", "golden_code": "n,m = list(map(int, input().split()))\n\na = [-1] + [int(eval(input())) for _ in range(m)] + [n + 1]\n\nMOD = 10 ** 9 + 7\n\n\n\nfib = [0, 1]\n\nfor i in range(100100):\n\n\tfib.append((fib[i] + fib[i + 1] % MOD))\n\n\n\nres = 1\n\nfor i in range(m + 1):\n\n\tp, q = a[i], a[i + 1]\n\n\tres = (res * fib[q - p - 1]) % MOD\n\n\n\nprint(res)", "generated_code": "n,m = list(map(int, input().split()))\n\na = [int(eval(input())) for _ in range(m)]\n\nMOD = 10 ** 9 + 7\n\n\n\n# broken[i] : i段目が壊れていたらTrue\n\nbroken = [False] * 100100\n\nfor i in a:\n\n\tbroken[i] = True\n\n\n\n# dp[i] : i段目に行く通り数\n\ndp = [0] * 100100\n\n\n\n# 0段目に行く方法は1通り\n\ndp[0] = 1\n\n\n\n# 1段目からn段目について調べる\n\nfor i in range(1, n + 1):\n\n\t# 壊れてるなら\n\n\tif broken[i]:\n\n\t\t# その段には進めないので0通り\n\n\t\tdp[i] = 0\n\n\t# 壊れてないなら\n\n\telse:\n\n\t\t# i - 1段目から移動可能 (i - 1段目は, i == 0 のときにはないので分岐)\n\n\t\tif i > 0:\n\n\t\t\tdp[i] += dp[i - 1]\n\n\t\t# i - 2段目から移動可能 (i - 2段目は, i == 0, 1 のときにはないので分岐)\n\n\t\tif i > 1:\n\n\t\t\tdp[i] += dp[i - 2]\n\n\tdp[i] %= MOD\n\n\n\nprint((dp[n]))", "score": 1.0, "surface_similarity": 0.7732919254658386}
{"id": "p03325_u513081876", "golden_code": "N = int(eval(input()))\n\nA = [int(i) for i in input().split()]\n\nans = 0\n\ncheck = [0]*30\n\nfor i in range(1, 31):\n\n    check[i-1] = 2**i\n\n\n\nfor i in A:\n\n    if i % 2 == 0:\n\n        j = 0\n\n        while check[j] <= i:\n\n            if i % check[j] == 0:\n\n                add = check[j]\n\n            else:\n\n                break\n\n                \n\n            j += 1\n\n        ans += j\n\n        \n\nprint(ans)", "generated_code": "N = int(eval(input()))\n\na = [int(i) for i in input().split()]\n\nans = 0\n\n\n\nfor i in a:\n\n    while i % 2 == 0:\n\n        i //= 2\n\n        ans += 1\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.6838362068965518}
{"id": "p03074_u861466636", "golden_code": "import numpy as np\n\n\n\nN, K = list(map(int, input().split()))\n\nS = eval(input())\n\n\n\nl = [[], []]\n\nans = []\n\nk = [int(s) for s in S]\n\nif k[0] == 0:\n\n    l[1].append(0)\n\nv0 = 1 if k[0] == 0 else 0\n\nv1 = 1 if k[0] == 1 else 0\n\nfor i in range(1, N):\n\n    if (k[i]==0) & (k[i-1]==0):\n\n        v0 += 1\n\n    elif (k[i]==1) & (k[i-1]==0):\n\n        l[0].append(v0)\n\n        v0 = 0\n\n        v1 += 1\n\n    elif (k[i]==0) & (k[i-1]==1):\n\n        l[1].append(v1)\n\n        v0 += 1\n\n        v1 = 0 \n\n    else:\n\n        v1 += 1\n\n        \n\nfor i, v in enumerate([v0, v1]):\n\n    if v > 0:\n\n        l[i].append(v)\n\n        \n\nif k[0] == 0:\n\n    l[1].append(0)\n\n\n\nif len(l[0]) <= K:\n\n    print(N)\n\n\n\nelse:\n\n    l[0].extend(np.repeat(0,K+1))\n\n    l[1].extend(np.repeat(0,K+1))\n\n    a = sum(l[0][:K]) + sum(l[1][:K+1])\n\n    ans.append(a)\n\n    for i in range(1, len(l[0])-K-1):\n\n        a -= l[0][i-1] + l[1][i-1]\n\n        a += l[0][i+K-1] + l[1][i+K]\n\n        ans.append(a)\n\n    print((max(ans)))", "generated_code": "N, K = list(map(int, input().split()))\n\nS = eval(input())\n\n \n\nl = [[], []]\n\nans = []\n\nk = [int(s) for s in S]\n\nif k[0] == 0:\n\n    l[1].append(0)\n\nv0 = 1 if k[0] == 0 else 0\n\nv1 = 1 if k[0] == 1 else 0\n\nfor i in range(1, N):\n\n    if (k[i]==0) & (k[i-1]==0):\n\n        v0 += 1\n\n    elif (k[i]==1) & (k[i-1]==0):\n\n        l[0].append(v0)\n\n        v0 = 0\n\n        v1 += 1\n\n    elif (k[i]==0) & (k[i-1]==1):\n\n        l[1].append(v1)\n\n        v0 += 1\n\n        v1 = 0 \n\n    else:\n\n        v1 += 1\n\n        \n\nfor i, v in enumerate([v0, v1]):\n\n    if v > 0:\n\n        l[i].append(v)\n\n        \n\nif k[0] == 0:\n\n    l[1].append(0)\n\n    \n\nl[0] += [0]*(K+1)\n\nl[1] += [0]*(K+1)\n\na = sum(l[0][:K]) + sum(l[1][:K+1])\n\nans.append(a)\n\nfor i in range(1, len(l[0])-K-1):\n\n    a -= l[0][i-1] + l[1][i-1]\n\n    a += l[0][i+K-1] + l[1][i+K]\n\n    ans.append(a)\n\nprint((max(ans)))", "score": 1.0, "surface_similarity": 0.8927444270954453}
{"id": "p03845_u513081876", "golden_code": "N = int(eval(input()))\n\nT = list(map(int, input().split()))\n\nM = int(eval(input()))\n\np = []\n\nx = []\n\nans = []\n\nfor i in range(M):\n\n    p, x = list(map(int, input().split()))\n\n    ans.append(sum(T[:p-1])+x+sum(T[p:]))\n\n\n\nfor _ in ans:\n\n    print(_)", "generated_code": "N = int(eval(input()))\n\nT = list(map(int, input().split()))\n\nM = int(eval(input()))\n\nP, X, ans = [0]*M, [0]*M, []\n\nbase = sum(T)\n\n\n\nfor i in range(M):\n\n    P, X = list(map(int, input().split()))\n\n    ans.append(base-T[P-1]+X)\n\n\n\nfor i in ans:\n\n    print(i)", "score": 1.0, "surface_similarity": 0.8233963815789473}
{"id": "p03162_u678505520", "golden_code": "n=int(eval(input()))\n\ndp=[[0 for i in range(3)] for i in range(n)]\n\nS=[[0 for i in range(3)] for i in range(n)]\n\ndp[0]=list(map(int,input().split()))\n\nS[0]=dp[0].copy()\n\nfor i in range(1,n):\n\n    S[i]=list(map(int,input().split()))\n\n    for j in range(3):\n\n        dp[i][j]=max(dp[i-1][j-1],dp[i-1][j-2])+S[i][j]\n\n\n\nprint((max(dp[n-1][0],dp[n-1][1],dp[n-1][2])))\n\n#dp[i][j]=i番目にjを選んだ時の最大値(jはa,b,cに対応している。)", "generated_code": "n=int(eval(input()))\n\ndp=[[0 for i in range(3)] for i in range(n)]\n\ndp[0]=list(map(int,input().split()))\n\nfor i in range(1,n):\n\n    S=list(map(int,input().split()))\n\n    for j in range(3):\n\n        dp[i][j]=max(dp[i-1][j-1],dp[i-1][j-2])+S[j]\n\n\n\nprint((max(dp[n-1][0],dp[n-1][1],dp[n-1][2])))\n\n#dp[i][j]=i番目にjを選んだ時の最大値(jはa,b,cに対応している。)", "score": 1.0, "surface_similarity": 0.9259259259259259}
{"id": "p03162_u869919400", "golden_code": "import numpy as np\n\nN = int(eval(input()))\n\nL = [list(map(int, input().split())) for i in range(N)]\n\ndp = np.zeros((N, 3), dtype=int)\n\n\n\nfor i in range(N):\n\n    dp[i][0] = L[0][0] if i == 0 else max(dp[i-1][1]+L[i][0], dp[i-1][2]+L[i][0])\n\n    dp[i][1] = L[0][1] if i == 0 else max(dp[i-1][0]+L[i][1], dp[i-1][2]+L[i][1])\n\n    dp[i][2] = L[0][2] if i == 0 else max(dp[i-1][0]+L[i][2], dp[i-1][1]+L[i][2])\n\n\n\nprint((max(dp[-1])))", "generated_code": "N = int(eval(input()))\n\nabc = [list(map(int, input().split())) for i in range(N)]\n\ndp = [[0 for i in range(3)] for j in range(N+1)]\n\nfor i in range(N):\n\n    dp[i+1][0] = max(dp[i][1]+abc[i][0], dp[i][2]+abc[i][0])\n\n    dp[i+1][1] = max(dp[i][0]+abc[i][1], dp[i][2]+abc[i][1])\n\n    dp[i+1][2] = max(dp[i][0]+abc[i][2], dp[i][1]+abc[i][2])\n\nprint((max(dp[-1])))", "score": 1.0, "surface_similarity": 0.6954529115744069}
{"id": "p03796_u581603131", "golden_code": "import math\n\nN = int(eval(input()))\n\nprint((math.factorial(N)%(10**9+7)))", "generated_code": "ans=1\n\nn=int(eval(input()))\n\nfor i in range(1,n+1):\n\n    ans*=i\n\n    ans=ans%(10**9+7)\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.5884353741496599}
{"id": "p02901_u197300773", "golden_code": "def main():\n\n    import math\n\n    N,M=list(map(int,input().split()))\n\n    a=[]\n\n    for i in range(M):\n\n        tmp=list(map(int,input().split()))\n\n        tmpc=list(map(int,input().split()))\n\n        c=0\n\n        for j in range(len(tmpc)):\n\n            c+=2**(tmpc[j]-1)\n\n        tmp[1]=c\n\n        a+=[tmp]\n\n\n\n\n\n    dp=[[10**10 for j in range(2**N)] for i in range(M)]\n\n    dp[0][0]=0\n\n    dp[0][a[0][1]]=a[0][0]\n\n\n\n\n\n    for i in range(1,M):\n\n        dp[i]=dp[i-1]\n\n        for j in range(2**N):\n\n            z,p=a[i][0],a[i][1]\n\n            q=j|p\n\n            x=dp[i-1][j]+z\n\n            if dp[i][q]>x: dp[i][q]=x\n\n\n\n    ans=dp[M-1][2**N-1]\n\n    print((ans if ans<10**10 else -1))\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "generated_code": "n,m=list(map(int,input().split()))\n\nL=2**n\n\ncost=[0]+[10**8 for i in range(L-1)]\n\n\n\nfor i in range(m):\n\n    a,b=list(map(int,input().split()))\n\n    c=sum([2**(int(i)-1) for i in input().split()])\n\n    for j in range(L):\n\n        q=j|c\n\n        x=cost[j]+a\n\n        if cost[q]>x:\n\n            cost[q]=x\n\nprint((cost[L-1] if cost[L-1]<10**8 else -1))", "score": 1.0, "surface_similarity": 0.6824258629071462}
{"id": "p02574_u829796346", "golden_code": "#!/usr/bin/env pypy3\n\n# N,M = map(int,sys.stdin.readline().split())\n\n# a = tuple(map(int,sys.stdin.readline().split())) # single line with multi param\n\n# a = tuple(int(sys.stdin.readline()) for _ in range(N)) # multi line with single param\n\n# a = tuple(tuple(map(int,sys.stdin.readline().rstrip().split())) for _ in range(N)) # multi line with multi param\n\n# s = sys.stdin.readline().rstrip()\n\n# N = int(sys.stdin.readline())\n\n# INF = float(\"inf\")\n\nimport math,sys\n\n\n\nn = int(sys.stdin.readline())\n\na = tuple(map(int,sys.stdin.readline().split()))\n\n#n = int(input())\n\n#a = list(map(int,input().split()))\n\ng = math.gcd(a[0],a[1])\n\nfor i in range(2,n):\n\n    g = math.gcd(g,a[i])\n\nM = max(a)\n\nacc = a[0]\n\nfor i in range(n):\n\n    acc = math.gcd(acc,a[i])\n\nif acc != 1:\n\n    print(\"not coprime\")\n\n    exit()\n\n\n\nLIMIT=max(a)\n\nminPrime = [0]*(LIMIT+1)\n\nminPrime[1] = 1\n\ndef make():\n\n    for i in range(2,LIMIT+1):\n\n        if minPrime[i] == 0:\n\n            minPrime[i] = i\n\n            #print(i)\n\n            for j in range(i+i,LIMIT+1,i):\n\n                #print(i,j)\n\n                if minPrime[j] == 0:\n\n                    minPrime[j] = i\n\nmake()\n\ndef factrial(N):\n\n     ret = []\n\n     while minPrime[N] != N:\n\n         ret.append(minPrime[N])\n\n         N = N//minPrime[N]\n\n     if N != 1:\n\n         ret.append(N)\n\n     return ret\n\n\n\njudge = set([])\n\npc = True\n\n\n\npairwise = True\n\np = set() #all prime\n\n\n\nfor e in a:\n\n    if not pairwise:\n\n        break\n\n    asf = set(factrial(e))\n\n    if judge & asf != set():\n\n        pc = False\n\n    #     #pairwise = False\n\n    #     print(\"setwise coprime\")\n\n    #     exit(0)\n\n    judge |= asf\n\n# for i in a:\n\n#     if not pc:\n\n#         break\n\n#     asf = set(factrial(i))\n\n\n\n#     if judge & asf != set():\n\n#         pc = False\n\n#     judge |= asf\n\nif pc:\n\n    print(\"pairwise coprime\")\n\nelif g == 1:\n\n    print(\"setwise coprime\")\n\nelse:\n\n    print(\"not coprime\")\n", "generated_code": "#!/usr/bin/env pypy3\n\n# N,M = map(int,sys.stdin.readline().split())\n\n# a = tuple(map(int,sys.stdin.readline().split())) # single line with multi param\n\n# a = tuple(int(sys.stdin.readline()) for _ in range(N)) # multi line with single param\n\n# a = tuple(tuple(map(int,sys.stdin.readline().rstrip().split())) for _ in range(N)) # multi line with multi param\n\n# s = sys.stdin.readline().rstrip()\n\n# N = int(sys.stdin.readline())\n\n# INF = float(\"inf\")\n\nimport math,sys\n\n\n\nn = int(sys.stdin.readline())\n\na = tuple(map(int,sys.stdin.readline().split()))\n\n#n = int(input())\n\n#a = list(map(int,input().split()))\n\ng = math.gcd(a[0],a[1])\n\nfor i in range(2,n):\n\n    g = math.gcd(g,a[i])\n\nM = max(a)\n\nacc = a[0]\n\nfor i in range(n):\n\n    acc = math.gcd(acc,a[i])\n\nif acc != 1:\n\n    print(\"not coprime\")\n\n    exit()\n\n\n\nLIMIT=max(a)\n\nminPrime = [0]*(LIMIT+1)\n\nminPrime[1] = 1\n\ndef make():\n\n    for i in range(2,LIMIT+1):\n\n        if minPrime[i] == 0:\n\n            minPrime[i] = i\n\n            #print(i)\n\n            for j in range(i+i,LIMIT+1,i):\n\n                #print(i,j)\n\n                if minPrime[j] == 0:\n\n                    minPrime[j] = i\n\nmake()\n\ndef factrial(N):\n\n     ret = []\n\n     while minPrime[N] != N:\n\n         ret.append(minPrime[N])\n\n         N = N//minPrime[N]\n\n     if N != 1:\n\n         ret.append(N)\n\n     return ret\n\n\n\njudge = set([])\n\n\n\nfor e in a:\n\n    asf = set(factrial(e))\n\n    if judge & asf != set():\n\n        print(\"setwise coprime\")\n\n        exit()\n\n    judge |= asf\n\n    #judge = judge | asf #too slow\n\nprint(\"pairwise coprime\")\n", "score": 1.0, "surface_similarity": 0.9238445378151261}
{"id": "p02599_u864197622", "golden_code": "NN = 19\n\nXX = [0] * (2**(NN+1)-1)\n\n\n\ndef addvalue(j, x):\n\n    i = 2**NN + j - 1\n\n    while i >= 0:\n\n        XX[i] += x\n\n        i = (i-1) // 2\n\n\n\ndef rangesum(a, b):\n\n    l = a + (1<<NN)\n\n    r = b + (1<<NN)\n\n    s = 0\n\n    while l < r:\n\n        if l%2:\n\n            s += XX[l-1]\n\n            l += 1\n\n        if r%2:\n\n            r -= 1\n\n            s += XX[r-1]\n\n        l >>= 1\n\n        r >>= 1\n\n    return s\n\n\n\nN, Q = map(int, input().split())\n\nC = [int(a) - 1 for a in input().split()]\n\nX = [[] for _ in range(N)]\n\nfor i in range(Q):\n\n    l, r = map(int, input().split())\n\n    X[r-1].append((l - 1, i))\n\nlast = [-1] * N\n\nANS = [-1] * Q\n\naddvalue(1, N)\n\nfor r in range(N):\n\n    c = C[r]\n\n    addvalue(last[c] + 2, -1)\n\n    addvalue(r + 2, 1)\n\n    last[c] = r\n\n    for l, i in X[r]:\n\n        ANS[i] = rangesum(l + 2, 1 << NN)\n\n    \n\nprint(*ANS, sep = \"\\n\")\n", "generated_code": "##### https://atcoder.jp/contests/abc174/submissions/15644075 を1次元化\n\n\n\nimport sys\n\nINF = 1 << 60\n\nMOD = 10**9 + 7 # 998244353\n\nsys.setrecursionlimit(2147483647)\n\ninput = lambda:sys.stdin.buffer.readline().rstrip()\n\n \n\nclass SegmentTree(object):\n\n    def __init__(self, A, dot, unit):\n\n        n = 1 << (len(A) - 1).bit_length()\n\n        tree = [unit] * (2 * n)\n\n        for i, v in enumerate(A):\n\n            tree[i + n] = v\n\n        for i in range(n - 1, 0, -1):\n\n            tree[i] = dot(tree[i << 1], tree[i << 1 | 1])\n\n        self._n = n\n\n        self._tree = tree\n\n        self._dot = dot\n\n        self._unit = unit\n\n \n\n    def __getitem__(self, i):\n\n        return self._tree[i + self._n]\n\n \n\n    def update(self, i, v):\n\n        i += self._n\n\n        self._tree[i] = v\n\n        while i != 1:\n\n            i >>= 1\n\n            self._tree[i] = self._dot(self._tree[i << 1], self._tree[i << 1 | 1])\n\n \n\n    def add(self, i, v):\n\n        self.update(i, self[i] + v)\n\n \n\n    def sum(self, l, r):\n\n        l += self._n\n\n        r += self._n\n\n        l_val = r_val = self._unit\n\n        while l < r:\n\n            if l & 1:\n\n                l_val = self._dot(l_val, self._tree[l])\n\n                l += 1\n\n            if r & 1:\n\n                r -= 1\n\n                r_val = self._dot(self._tree[r], r_val)\n\n            l >>= 1\n\n            r >>= 1\n\n        return self._dot(l_val, r_val)\n\n\n\nfrom operator import add\n\ndef resolve():\n\n    n, q = map(int, input().split())\n\n    C = list(map(lambda x : int(x) - 1, input().split()))\n\n \n\n    A = [0] * n\n\n    used = [0] * n\n\n    for i, c in enumerate(C):\n\n        if used[c]:\n\n            continue\n\n        used[c] = 1\n\n        A[i] = 1\n\n    tree = SegmentTree(A, add, 0)\n\n \n\n    next = [-1] * n\n\n    used = [-1] * n\n\n    for i in range(n - 1, -1, -1):\n\n        c = C[i]\n\n        if used[c] != -1:\n\n            next[i] = used[c]\n\n        used[c] = i\n\n \n\n    queries = [None] * q\n\n    for i in range(q):\n\n        l, r = map(int, input().split())\n\n        queries[i] = (l - 1 << 40) + (r << 20) + i\n\n    queries.sort(reverse = 1)\n\n    \n\n    m = (1 << 20) - 1\n\n    ans = [0] * q\n\n    for l in range(n):\n\n        while queries and queries[-1] >> 40 == l:\n\n            lri = queries.pop()\n\n            l = lri >> 40\n\n            r = (lri >> 20) & m\n\n            i = lri & m\n\n            ans[i] = tree.sum(l, r)\n\n        if next[l] != -1:\n\n            tree.add(next[l], 1)\n\n \n\n    print(*ans, sep = '\\n')\n\nresolve()\n", "score": 1.0, "surface_similarity": 0.603565134878677}
{"id": "p02627_u987846648", "golden_code": "alph = eval(input())\n\nif alph.isupper():\n\n    print(\"A\")\n\nelse:\n\n    print(\"a\")\n", "generated_code": "a = eval(input())\n\n\n\nif a.isupper():\n\n    print(\"A\")\n\nelse:\n\n    print(\"a\")", "score": 1.0, "surface_similarity": 0.9625}
{"id": "p03039_u816872429", "golden_code": "n, m, k = list(map(int, input().split()))\n\n\n\nmod = 1000000007\n\ndef pow(x, n):\n\n    ret = 1\n\n    while n > 0:\n\n        if (n & 1) == 1:\n\n            ret = (ret * x) % mod\n\n        x = (x * x) % mod\n\n        n >>= 1\n\n    return ret\n\n\n\nfac = [1]\n\ninv = [1]\n\nfor i in range(1, n * m + 1):\n\n    fac.append((fac[-1] * i) % mod)\n\n    inv.append(pow(fac[i], mod - 2))\n\n\n\ndef cmb(n, k):\n\n    return (fac[n] * inv[k] * inv[n - k]) % mod\n\n\n\ndef doit(n, m, k):\n\n    ret = 0\n\n    for d in range(m):\n\n        ret = (ret + d * (m - d)) % mod\n\n    return (ret * n * n * cmb(n * m - 2, k - 2)) % mod\n\n\n\nprint(((doit(n, m, k) + doit(m, n, k)) % mod))", "generated_code": "n, m, k = list(map(int, input().split()))\n\n\n\nmod = 1000000007\n\nfac = [1]\n\nfor i in range(1, n * m + 1):\n\n    fac.append((fac[-1] * i) % mod)\n\n\n\ndef pow(x, n):\n\n    ret = 1\n\n    while n > 0:\n\n        if (n & 1) == 1:\n\n            ret = (ret * x) % mod\n\n        x = (x * x) % mod\n\n        n >>= 1\n\n    return ret\n\n\n\ndef inv(i):\n\n    return pow(fac[i], mod - 2)\n\n\n\ndef cmb(n, k):\n\n    return (fac[n] * inv(k) * inv(n - k)) % mod\n\n\n\nx = sum(d * (m - d) for d in range(m)) % mod\n\ny = sum(d * (n - d) for d in range(n)) % mod\n\n\n\nc = cmb(n * m - 2, k - 2)\n\nx = (x * n * n * c) % mod\n\ny = (y * m * m * c) % mod\n\n\n\nprint(((x + y) % mod))", "score": 1.0, "surface_similarity": 0.7965867992766726}
{"id": "p02555_u806976856", "golden_code": "s=int(eval(input()))\n\np=10**9+7\n\nif s<=2:\n\n    print((0))\n\n    exit()\n\nn=s//3\n\nans=0\n\ndef f(n,k,p):\n\n    if k==0:\n\n        return 1\n\n    elif k%2==0:\n\n        return (f(n,k//2,p)**2)%p\n\n    else:\n\n        return (n*f(n,k-1,p))%p\n\n\n\nfor k in range(1,n+1):\n\n    a=1\n\n    b=1\n\n    for j in range(k-1):\n\n        a=(a*(s-3*k+1+j))%p\n\n        b=(b*(j+1))%p\n\n    ans=(ans+a*f(b,p-2,p))%p\n\n\n\nprint((ans%p))\n\n\n", "generated_code": "s=int(eval(input()))\n\np=10**9+7\n\nif s<=2:\n\n    print((0))\n\n    exit()\n\nn=s//3\n\nans=0\n\nx=[0]*(s+1)\n\nx[0]=1\n\nx[1]=1\n\ny=[0]*(s+1)\n\n\n\nfor i in range(2,s+1):\n\n    x[i]=x[i-1]*i%p\n\n\n\ny[s]=pow(x[s],p-2,p)\n\nfor i in range(s):\n\n    y[s-1-i]=y[s-i]*(s-i)%p\n\n\n\nfor k in range(1,n+1):\n\n    ans+=x[s-2*k-1]*y[k-1]*y[s-3*k]%p\n\n\n\nprint((ans%p))\n\n\n", "score": 1.0, "surface_similarity": 0.6372907018168864}
{"id": "p03162_u224353074", "golden_code": "import numpy as np\n\nN = int(eval(input()))\n\n\n\nabc = np.array([list(map(int, input().split())) for i in range(N)])\n\n\n\ndp = [[0]*3 for i in range(N+1)]\n\n\n\nfor i in range(1, N+1):\n\n    dp[i][0] = max(dp[i - 1][1] + abc[i - 1][1], dp[i - 1][2] + abc[i - 1][2])\n\n    dp[i][1] = max(dp[i - 1][0] + abc[i - 1][0], dp[i - 1][2] + abc[i - 1][2])\n\n    dp[i][2] = max(dp[i - 1][1] + abc[i - 1][1], dp[i - 1][0] + abc[i - 1][0])\n\n\n\nprint((max(dp[-1])))\n", "generated_code": "N = int(eval(input()))\n\n\n\nA = [0] * (N + 1)\n\nB = [0] * (N + 1)\n\nC = [0] * (N + 1)\n\n\n\nfor i in range(1, N + 1):\n\n    A[i], B[i], C[i] = list(map(int, input().split()))\n\n\n\ndp = [[0] * 3 for _ in range(N + 1)]\n\nfor i in range(1, N + 1):\n\n    dp[i][0] = A[i] + max(dp[i-1][1], dp[i-1][2])\n\n    dp[i][1] = B[i] + max(dp[i-1][2], dp[i-1][0])\n\n    dp[i][2] = C[i] + max(dp[i-1][0], dp[i-1][1])\n\n\n\nprint((max(dp[N])))", "score": 1.0, "surface_similarity": 0.6906179138321995}
{"id": "p03371_u729133443", "golden_code": "a,b,c,x,y=list(map(int,input().split()));print((min(k*c*2+a*max(x-k,0)+b*max(y-k,0)for k in range(max(x,y)*3))))", "generated_code": "a,b,c,x,y=list(map(int,input().split()));print((min(x*a+y*b,2*x*c+b*max(0,y-x),2*y*c+a*max(0,x-y))))", "score": 1.0, "surface_similarity": 0.78125}
{"id": "p03545_u207799478", "golden_code": "import math\n\nimport string\n\nimport collections\n\nfrom collections import Counter\n\n\n\n\n\ndef readints():\n\n    return list(map(int, input().split()))\n\n\n\n\n\ndef nCr(n, r):\n\n    return math.factorial(n)//(math.factorial(n-r)*math.factorial(r))\n\n\n\n\n\ndef has_duplicates2(seq):\n\n    seen = []\n\n    for item in seq:\n\n        if not(item in seen):\n\n            seen.append(item)\n\n    return len(seq) != len(seen)\n\n\n\n\n\ndef divisor(n):\n\n    divisor = []\n\n    for i in range(1, n+1):\n\n        if n % i == 0:\n\n            divisor.append(i)\n\n    return divisor\n\n\n\n\n\n# coordinates\n\ndx = [-1, -1, -1, 0, 0, 1, 1, 1]\n\ndy = [-1, 0, 1, -1, 1, -1, 0, 1]\n\na, b, c, d = list(map(int, eval(input())))\n\n#print(a, b, c, d)\n\nif a+b+c+d == 7:\n\n    print((str(a)+'+'+str(b)+'+'+str(c)+'+'+str(d)+'=7'))\n\n    exit()\n\nif a+b-c+d == 7:\n\n    print((str(a)+'+'+str(b)+'-'+str(c)+'+'+str(d)+'=7'))\n\n    exit()\n\nif a+b+c-d == 7:\n\n    print((str(a)+'+'+str(b)+'+'+str(c)+'-'+str(d)+'=7'))\n\n    exit()\n\nif a+b-c-d == 7:\n\n    print((str(a)+'+'+str(b)+'-'+str(c)+'-'+str(d)+'=7'))\n\n    exit()\n\nif a-b+c+d == 7:\n\n    print((str(a)+'-'+str(b)+'+'+str(c)+'+'+str(d)+'=7'))\n\n    exit()\n\nif a-b-c+d == 7:\n\n    print((str(a)+'-'+str(b)+'-'+str(c)+'+'+str(d)+'=7'))\n\n    exit()\n\nif a-b+c-d == 7:\n\n    print((str(a)+'-'+str(b)+'+'+str(c)+'-'+str(d)+'=7'))\n\n    exit()\n\nif a-b-c-d == 7:\n\n    print((str(a)+'-'+str(b)+'-'+str(c)+'-'+str(d)+'=7'))\n\n    exit()\n", "generated_code": "from copy import deepcopy\n\nimport math\n\nimport string\n\nimport collections\n\nfrom collections import Counter\n\nfrom collections import deque\n\nfrom decimal import Decimal\n\nimport sys\n\nimport fractions\n\nfrom operator import itemgetter\n\nimport itertools\n\nimport copy\n\n\n\n\n\ndef readints():\n\n    return list(map(int, input().split()))\n\n\n\n\n\ndef nCr(n, r):\n\n    return math.factorial(n)//(math.factorial(n-r)*math.factorial(r))\n\n\n\n\n\ndef has_duplicates2(seq):\n\n    seen = []\n\n    for item in seq:\n\n        if not(item in seen):\n\n            seen.append(item)\n\n    return len(seq) != len(seen)\n\n\n\n\n\ndef divisor(n):\n\n    divisor = []\n\n    for i in range(1, n+1):\n\n        if n % i == 0:\n\n            divisor.append(i)\n\n    return divisor\n\n\n\n\n\n# coordinates\n\ndx = [-1, -1, -1, 0, 0, 1, 1, 1]\n\ndy = [-1, 0, 1, -1, 1, -1, 0, 1]\n\n\n\ns = list(map(int, input()))\n\n\n\nif s[0]+s[1]+s[2]+s[3] == 7:\n\n    print(str(s[0]), '+', str(s[1]), '+',\n\n          str(s[2]), '+', str(s[3]), '=', 7, sep='')\n\n    exit()\n\nif s[0]+s[1]-s[2]+s[3] == 7:\n\n    print(str(s[0]), '+', str(s[1]), '-', str(s[2]),\n\n          '+', str(s[3]),  '=', 7, sep='')\n\n    exit()\n\nif s[0]-s[1]+s[2]+s[3] == 7:\n\n    print(str(s[0]), '-', str(s[1]), '+', str(s[2]),\n\n          '+', str(s[3]),  '=', 7, sep='')\n\n    exit()\n\nif s[0]-s[1]-s[2]+s[3] == 7:\n\n    print(str(s[0]), '-', str(s[1]), '-', str(s[2]),\n\n          '+', str(s[3]),  '=', 7, sep='')\n\n    exit()\n\nif s[0]+s[1]+s[2]-s[3] == 7:\n\n    print(str(s[0]), '+', str(s[1]), '+', str(s[2]),\n\n          '-', str(s[3]),  '=', 7, sep='')\n\n    exit()\n\nif s[0]-s[1]-s[2]-s[3] == 7:\n\n    print(str(s[0]), '-', str(s[1]), '-', str(s[2]),\n\n          '-', str(s[3]),  '=', 7, sep='')\n\n    exit()\n\nif s[0]-s[1]+s[2]-s[3] == 7:\n\n    print(str(s[0]), '-', str(s[1]), '+', str(s[2]),\n\n          '-', str(s[3]),  '=', 7, sep='')\n\n    exit()\n\nif s[0]+s[1]-s[2]-s[3] == 7:\n\n    print(str(s[0]), '+', str(s[1]), '-', str(s[2]),\n\n          '-', str(s[3]),  '=', 7, sep='')\n\n    exit()\n", "score": 1.0, "surface_similarity": 0.7979849436803079}
{"id": "p02599_u102461423", "golden_code": "import sys\n\nimport numpy as np\n\n\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\nBsize = 700\n\n\n\ndef Mo_argsort(LR):\n\n    L = LR[:, 0]\n\n    R = LR[:, 1]\n\n    key1 = L // Bsize\n\n    key2 = np.where(key1 & 1, -R, R)\n\n    key = (key1 << 32) + key2\n\n    return np.argsort(key)\n\n\n\ndef main(A, LR):\n\n    N = len(A)\n\n    Q = len(LR)\n\n    ind = Mo_argsort(LR)\n\n    count = np.zeros(N + 1, np.int64)\n\n    ans = 0\n\n\n\n    def add(x):\n\n        nonlocal ans\n\n        if not count[x]:\n\n            ans += 1\n\n        count[x] += 1\n\n\n\n    def rem(x):\n\n        nonlocal ans\n\n        count[x] -= 1\n\n        if not count[x]:\n\n            ans -= 1\n\n\n\n    answers = np.empty(Q, np.int64)\n\n    nl, nr = 0, 0\n\n    for i in ind:\n\n        l, r = LR[i]\n\n        l -= 1\n\n        # 区間 [l, r) に対する計算\n\n        while nl > l:\n\n            nl -= 1\n\n            add(A[nl])\n\n        while nr < r:\n\n            add(A[nr])\n\n            nr += 1\n\n        while nl < l:\n\n            rem(A[nl])\n\n            nl += 1\n\n        while nr > r:\n\n            nr -= 1\n\n            rem(A[nr])\n\n        #  答を求めて ans[i] に格納する\n\n        answers[i] = ans\n\n    return answers\n\n\n\nif sys.argv[-1] == 'ONLINE_JUDGE':\n\n    import numba\n\n    from numba.pycc import CC\n\n    i4 = numba.int32\n\n    i8 = numba.int64\n\n    cc = CC('my_module')\n\n\n\n    def cc_export(f, signature):\n\n        cc.export(f.__name__, signature)(f)\n\n        return numba.njit(f)\n\n\n\n    Mo_argsort = cc_export(Mo_argsort, (i8[:,:],))\n\n    main = cc_export(main, (i8[:], i8[:, :]))\n\n    cc.compile()\n\n\n\nfrom my_module import main\n\n\n\nN, Q = list(map(int, readline().split()))\n\nA = np.array(readline().split(), np.int64)\n\nLR = np.array(read().split(), np.int64).reshape(Q, 2)\n\n\n\nans = main(A, LR)\n\nprint(('\\n'.join(map(str, ans.tolist()))))", "generated_code": "import sys\n\nimport numpy as np\n\n\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\nBsize = 1000\n\n\n\ndef Mo_argsort(LR):\n\n    L = LR[:, 0]\n\n    R = LR[:, 1]\n\n    key1 = L // Bsize\n\n    key2 = np.where(key1 & 1, -R, R)\n\n    key = (key1 << 32) + key2\n\n    return np.argsort(key)\n\n\n\ndef main(A, LR):\n\n    N = len(A)\n\n    Q = len(LR)\n\n    ind = Mo_argsort(LR)\n\n    count = np.zeros(N + 1, np.int64)\n\n    ans = 0\n\n\n\n    def add(x):\n\n        nonlocal ans\n\n        if not count[x]:\n\n            ans += 1\n\n        count[x] += 1\n\n\n\n    def rem(x):\n\n        nonlocal ans\n\n        count[x] -= 1\n\n        if not count[x]:\n\n            ans -= 1\n\n\n\n    answers = np.empty(Q, np.int64)\n\n    nl, nr = 0, 0\n\n    for i in ind:\n\n        l, r = LR[i]\n\n        l -= 1\n\n        # 区間 [l, r) に対する計算\n\n        while nl > l:\n\n            nl -= 1\n\n            add(A[nl])\n\n        while nr < r:\n\n            add(A[nr])\n\n            nr += 1\n\n        while nl < l:\n\n            rem(A[nl])\n\n            nl += 1\n\n        while nr > r:\n\n            nr -= 1\n\n            rem(A[nr])\n\n        #  答を求めて ans[i] に格納する\n\n        answers[i] = ans\n\n    return answers\n\n\n\nif sys.argv[-1] == 'ONLINE_JUDGE':\n\n    import numba\n\n    from numba.pycc import CC\n\n    i4 = numba.int32\n\n    i8 = numba.int64\n\n    cc = CC('my_module')\n\n\n\n    def cc_export(f, signature):\n\n        cc.export(f.__name__, signature)(f)\n\n        return numba.njit(f)\n\n\n\n    Mo_argsort = cc_export(Mo_argsort, (i8[:,:],))\n\n    main = cc_export(main, (i8[:], i8[:, :]))\n\n    cc.compile()\n\n\n\nfrom my_module import main\n\n\n\nN, Q = list(map(int, readline().split()))\n\nA = np.array(readline().split(), np.int64)\n\nLR = np.array(read().split(), np.int64).reshape(Q, 2)\n\n\n\nans = main(A, LR)\n\nprint(('\\n'.join(map(str, ans.tolist()))))\n", "score": 1.0, "surface_similarity": 0.9994472084024323}
{"id": "p03723_u064408584", "golden_code": "a,b,c=list(map(int, input().split()))\n\nd=0\n\nwhile d<10**5:\n\n    if a%2==1 or b%2==1 or c%2==1:break\n\n    a,b,c=b/2+c/2,a/2+c/2,a/2+b/2\n\n    d+=1\n\nelse:d=-1\n\nprint(d)", "generated_code": "a,b,c=list(map(int, input().split()))\n\nans=0\n\nwhile a%2==0 and b%2==0 and c%2==0 and ans<10000:\n\n    a,b,c=b//2+c//2,a//2+c//2,a//2+b//2\n\n    ans+=1\n\nif ans==10000:ans=-1\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.7280219780219781}
{"id": "p03013_u179169725", "golden_code": "# https://atcoder.jp/contests/abc129/tasks/abc129_c\n\n# 典型的なDP\n\n\n\nMOD = 10**9 + 7\n\nimport numpy as np\n\n# dp[i]をi段目までの通りの数とする。\n\nN, M = list(map(int, input().split()))\n\nto_zero = np.full((N + 1), False).tolist()\n\nfor _ in range(M):\n\n    to_zero[int(eval(input()))] = True  # 床が抜けているところ\n\n\n\n# dpテーブルの用意\n\ndp = np.full((N + 1), -1).tolist()\n\ndp[0] = 1\n\ndp[1] = 0 if to_zero[1] else 1\n\nfor i in range(2, N + 1):\n\n    dp[i] = 0 if to_zero[i] else dp[i - 2] + dp[i - 1]\n\n    if dp[i] > MOD:\n\n        dp[i] %= MOD\n\n\n\nprint((dp[-1]))\n", "generated_code": "# https://atcoder.jp/contests/abc129/tasks/abc129_c\n\n# 典型的なDP\n\n\n\n\n\ndef full(shape, full_value):\n\n    if isinstance(shape, tuple):\n\n        NotImplementedError()\n\n    else:\n\n        return [full_value] * shape\n\n\n\n\n\nMOD = 10**9 + 7\n\n# dp[i]をi段目までの通りの数とする。\n\nN, M = list(map(int, input().split()))\n\nto_zero = full((N + 1), False)\n\nfor _ in range(M):\n\n    to_zero[int(eval(input()))] = True  # 床が抜けているところ\n\n\n\n# dpテーブルの用意\n\ndp = full((N + 1), -1)\n\ndp[0] = 1\n\ndp[1] = 0 if to_zero[1] else 1\n\nfor i in range(2, N + 1):\n\n    dp[i] = 0 if to_zero[i] else dp[i - 2] + dp[i - 1]\n\n    if dp[i] > MOD:\n\n        dp[i] %= MOD\n\n\n\nprint((dp[-1]))\n", "score": 1.0, "surface_similarity": 0.7751196172248804}
{"id": "p03720_u341087021", "golden_code": "import sys\n\nimport numpy as np\n\nn,m = [int(x) for x in sys.stdin.readline().split()]\n\nr = np.zeros(n)\n\nfor i in range(m):\n\n\ta, b = [int(x) for x in sys.stdin.readline().split()]\n\n\tr[a-1] += 1\n\n\tr[b-1] += 1\n\nfor i in range(n):\n\n\tprint((int(r[i])))", "generated_code": "import sys\n\nn,m = [int(x) for x in sys.stdin.readline().split()]\n\nr = [0]*n\n\nfor _ in range(m):\n\n\ta, b = [int(x) for x in sys.stdin.readline().split()]\n\n\tr[a-1] += 1\n\n\tr[b-1] += 1\n\nfor i in r:\n\n\tprint(i)", "score": 1.0, "surface_similarity": 0.8670908448214917}
{"id": "p03309_u285443936", "golden_code": "import statistics\n\nN = int(eval(input()))\n\na = [int(i) for i in input().split()]\n\nans = 0\n\n\n\nfor i in range(1,N+1):\n\n  a[i-1] -= i\n\n\n\nb = statistics.median(a)\n\nfor i in range(N):\n\n  ans += abs(a[i]-b)\n\nprint((int(ans)))", "generated_code": "N = int(eval(input()))\n\nA = [int(i) for i in input().split()]\n\nC = [A[i]-i for i in range(N)]\n\nC.sort()\n\nans = 0\n\nmed = C[N//2]\n\nfor i in range(N):\n\n  ans += abs(C[i]-med)\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.7664709719504239}
{"id": "p03078_u652583512", "golden_code": "import numpy as np\n\n\n\nX, Y, Z, K = list(map(int, input().split()))\n\nA = np.array([int(i) for i in input().split()])\n\nB = np.array([int(i) for i in input().split()])\n\nC =np.array([int(i) for i in input().split()])\n\nA = -np.sort(-A) #要チェックや\n\nB = -np.sort(-B)\n\nC = -np.sort(-C)\n\nD = []\n\nfor i in range(min(K, X)):\n\n    for j in range(min(K, Y)):\n\n        if (i + 1) * (j + 1) > K:\n\n            break\n\n        for k in range(min(K, Z)):\n\n            if (i + 1) * (j + 1) * (k + 1) > K:\n\n                break\n\n            else:\n\n\n\n                D.append(A[i] + B[j] + C[k])\n\n\n\nX = np.array(D)\n\nX = -np.sort(-X)\n\nfor i in range(K):\n\n    print((X[i]))", "generated_code": "X, Y, Z, K = list(map(int, input().split()))\n\nA = sorted([int(i) for i in input().split()], reverse=True)\n\nB = sorted([int(i) for i in input().split()], reverse=True)\n\nC = sorted([int(i) for i in input().split()], reverse=True)\n\nD = []\n\nfor i in range(min(K, X)):\n\n    for j in range(min(K, Y)):\n\n        if (i + 1) * (j + 1) > K:\n\n            break\n\n        for k in range(min(K, Z)):\n\n            if (i + 1) * (j + 1) * (k + 1) > K:\n\n                break\n\n            else:\n\n\n\n                D.append(A[i] + B[j] + C[k])\n\n\n\nD.sort(reverse=True)\n\nfor i in range(K):\n\n    print((D[i]))", "score": 1.0, "surface_similarity": 0.8117962022521528}
{"id": "p02665_u479719434", "golden_code": "n = int(eval(input()))\n\nleaves = list(map(int, input().split()))\n\n\n\nans = 0\n\nnodes_min = [0] * (n + 1)\n\nnodes_max = [0] * (n + 1)\n\nnodes_min[n] = leaves[n]\n\nnodes_max[n] = leaves[n]\n\n\n\nfor depth in range(n, 0, -1):\n\n    root_min = nodes_min[depth] // 2 + nodes_min[depth] % 2\n\n    nodes_min[depth - 1] = leaves[depth - 1] + root_min\n\n    root_max = nodes_max[depth]\n\n    nodes_max[depth - 1] = leaves[depth - 1] + root_max\n\nnodes = [0] * (n + 1)\n\nnodes[0] = 1\n\nif nodes[0] < nodes_min[0]:\n\n    print((-1))\n\nelse:\n\n    for depth in range(n):\n\n        roots = nodes[depth]-leaves[depth]\n\n        nodes[depth + 1] = min(roots * 2, nodes_max[depth + 1])\n\n        if nodes[depth+1] < nodes_min[depth+1]:\n\n            print((-1))\n\n            break\n\n    else:\n\n        print((sum(nodes)))\n", "generated_code": "n = int(eval(input()))\n\nleaves = list(map(int, input().split()))\n\n\n\nsum_leaves = [0]*(n+1)\n\nsum_leaves[0] = leaves[0]\n\nfor depth in range(n):\n\n    sum_leaves[depth+1] = sum_leaves[depth] + leaves[depth+1]\n\n\n\nans = 0\n\n\n\nroot = [None] * (n + 1)\n\nif n == 0:\n\n    root[0] = 0\n\nelse:\n\n    root[0] = 1\n\nif root[0] + leaves[0] != 1:\n\n    print((-1))\n\nelse:\n\n    for depth in range(n):\n\n        root[depth+1] = min(2*root[depth]-leaves[depth+1],\n\n                            sum_leaves[n]-sum_leaves[depth+1])\n\n        if root[depth + 1] < root[depth] - leaves[depth + 1] or root[depth+1] < 0:\n\n            print((-1))\n\n            break\n\n    else:\n\n        print((sum(root)+sum(leaves)))\n", "score": 1.0, "surface_similarity": 0.7049808429118773}
{"id": "p03013_u440985596", "golden_code": "import math\n\ndef cmb(n, r, mod, g1, g2):\n\n    if ( r<0 or r>n ):\n\n        return 0\n\n    r = min(r, n-r)\n\n    return g1[n] * g2[r] * g2[n-r] % mod\n\n\n\ndef main():\n\n    N, M = list(map(int, input().split()))\n\n    A = [-1] + [int(eval(input())) for i in range(M)] + [N + 1]\n\n\n\n    mod = 10**9+7 #出力の制限\n\n    N = 10**5\n\n    g1 = [1, 1] # 元テーブル\n\n    g2 = [1, 1] #逆元テーブル\n\n    inverse = [0, 1] #逆元テーブル計算用テーブル\n\n    for i in range( 2, N + 1 ):\n\n        g1.append( ( g1[-1] * i ) % mod )\n\n        inverse.append( ( -inverse[mod % i] * (mod//i) ) % mod )\n\n        g2.append( (g2[-1] * inverse[-1]) % mod )\n\n\n\n    d = [0] * (len(A) - 1)\n\n    for i in range(len(A) - 1):\n\n        if A[i+1] - A[i] == 1:\n\n            print((0))\n\n            exit(0)\n\n        d[i] = A[i+1] - 1 - (A[i] + 1)\n\n\n\n    ans = 1\n\n    for dd in d:\n\n        if dd > 1:\n\n            tmp = 0\n\n            for j in range(dd//2 + 1):\n\n                tmp += cmb(dd - j, j, mod, g1, g2)\n\n            ans *= tmp\n\n\n\n    print((ans % 1000000007))\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "generated_code": "def main():\n\n    N, M = list(map(int, input().split()))\n\n    A = [int(eval(input())) for i in range(M)] + [0]\n\n\n\n    a = 0\n\n    b = 1\n\n    j = 0\n\n    tmp = 0\n\n    if N == 1:\n\n        print((1))\n\n    else:\n\n        for i in range(1, N + 1):\n\n            if A[j] == i:\n\n                if tmp == 1:\n\n                    print((0))\n\n                    exit()\n\n                tmp = 1\n\n                j += 1\n\n                a = 0\n\n            else:\n\n                if tmp == 1:\n\n                    b = a + b\n\n                    a = 0\n\n                else:\n\n                    c = a + b\n\n                    a = b\n\n                    b = c\n\n                tmp = 0\n\n        print((b % 1000000007))\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 1.0, "surface_similarity": 0.6336149399733215}
{"id": "p02691_u060896757", "golden_code": "N = int(eval(input()))\n\nA = [int(i) for i in input().split()]\n\ndp = [0] * 10 ** 7\n\nans = 0\n\nfor i in range(N):\n\n    x = i + 1 - A[i]\n\n    if x >= 0:\n\n        ans += dp[x]\n\n    y = i + 1 + A[i]\n\n    if y < 10 ** 7:\n\n        dp[y] += 1\n\n\n\nprint(ans)\n", "generated_code": "N = int(eval(input()))\n\nA = [int(i) for i in input().split()]\n\nINF = 2 * 10 ** 5\n\ndp = [0] * INF\n\nans = 0\n\nfor i in range(N):\n\n    i_i_ = i + 1 - A[i]\n\n    if 0 < i_i_ < INF:\n\n        ans += dp[i_i_]\n\n    i_ = i + 1 + A[i]\n\n    if 0 < i_ < INF:\n\n        dp[i_] += 1\n\n\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.8975627240143369}
{"id": "p03544_u657913472", "golden_code": "a,b=2,1\n\nfor i in[0]*int(eval(input())):a,b=b,a+b\n\nprint(a)", "generated_code": "a,b=2,1\n\nfor i in[0]*eval(input()):a,b=b,a+b\n\nprint(a)", "score": 1.0, "surface_similarity": 0.9576271186440678}
{"id": "p02555_u880730787", "golden_code": "S = int(eval(input()))\n\nmod = 10**9+7\n\n\n\ndp = [0]*(S+1)\n\ndp[0] = 1\n\nfor i in range(1,S+1):\n\n    for j in range(0,(i-3)+1):\n\n        dp[i] += dp[j]\n\n        dp[i] %= mod\n\nprint((dp[S]))", "generated_code": "S = int(eval(input()))\n\nmod = 10**9+7\n\n\n\ndp = [0]*(S+1)\n\ndp[0] = 1\n\nfor i in range(1,S+1):\n\n    for j in range(0,(i-3)+1):\n\n        dp[i] += dp[j]\n\n    dp[i] %= mod\n\nprint((dp[S]))", "score": 1.0, "surface_similarity": 1.0}
{"id": "p03107_u733814820", "golden_code": "# ABC 120 C\n\n\n\nimport re\n\n\n\nS = eval(input())\n\n\n\nl0 = 0\n\nl1 = 0\n\n\n\nfor i in range(len(S)):\n\n    if S[i] == '0':\n\n        l0 += 1\n\n    elif S[i] == '1':\n\n        l1 += 1\n\n\n\nprint((min(l0, l1) * 2))\n", "generated_code": "def resolve():\n\n  S = eval(input())\n\n  arr = []\n\n  for s in S:\n\n    if len(arr) != 0 and arr[-1] != s:\n\n      arr.pop()\n\n    else:\n\n      arr.append(s)\n\n\n\n  print((len(S) - len(arr)))\n\n  return\n\n\n\nif __name__ == \"__main__\":\n\n  resolve()\n", "score": 1.0, "surface_similarity": 0.4761126990608412}
{"id": "p00106_u811733736", "golden_code": "# -*- coding: utf-8 -*-\n\n\"\"\"\n\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0106&lang=jp\n\n\"\"\"\n\nimport sys\n\n\n\n\n\ndef solve(amount):\n\n    \"\"\"\n\n    :param amount: ?????\\???????????°?????????\n\n    :return: ?????????\n\n    \"\"\"\n\n    best_price = (amount + 199) // 200 * 380\n\n    for a in range(amount // 200 + 1):\n\n        for b in range(amount // 300 + 1):\n\n            for c in range(amount // 500 + 1):\n\n                for a1 in range(amount // 1000 + 1):\n\n                    for b1 in range(amount // 1200 + 1):\n\n                        for c1 in range(amount // 1500 + 1):\n\n                            if a*200 + b*300 + c*500 + a1*1000 + b1*1200 + c1*1500 == amount:\n\n                                price = a*380 + b*550 + c*850 + a1*1520 + b1*1870 + c1*2244\n\n                                if price < best_price:\n\n                                    best_price = price\n\n    return best_price\n\n\n\n\n\n\n\n\n\ndef main(args):\n\n    while True:\n\n        amount = int(eval(input()))\n\n        if amount == 0:\n\n            break\n\n        result = solve(amount)\n\n        print(result)\n\n\n\n\n\n\n\nif __name__ == '__main__':\n\n    main(sys.argv[1:])", "generated_code": "# -*- coding: utf-8 -*-\n\n\"\"\"\n\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0106&lang=jp\n\n\"\"\"\n\nimport sys\n\n\n\n\n\ndef solve(amount):\n\n    \"\"\"\n\n    :param amount: ?????\\???????????°?????????\n\n    :return: ?????????\n\n    \"\"\"\n\n    best_price = (amount + 199) // 200 * 380\n\n    for a in range(amount // 200 + 1):\n\n        for b in range(amount // 300 + 1):\n\n            for c in range(amount // 500 + 1):\n\n                for a1 in range(amount // 1000 + 1):\n\n                    for b1 in range(amount // 1200 + 1):\n\n                        for c1 in range(amount // 1500 + 1):\n\n                            if a*200 + b*300 + c*500 + a1*1000 + b1*1200 + c1*1500 == amount:\n\n                                price = a*380 + b*550 + c*850 + a1*1520 + b1*1870 + c1*2244\n\n                                if price < best_price:\n\n                                    best_price = price\n\n    return best_price\n\n\n\n\n\ndef solve2(amount):\n\n    \"\"\"\n\n    ???????¨???????????????¨?????????????????§???\n\n    \"\"\"\n\n    packages = [(0, 0), (2, 380), (3, 550), (5, 850), (10, 1520), (12, 1870), (15, 2244)] # 1?¢??????????(100g??????)??¨??????????????¢l\n\n    # dp??¨???2?¬??????????????¨?????????????(100g??????)?????????????????¨??§??????packages????¨????\n\n    # 999999...??????INF??¨?????? (phthon 3.5??\\??????????????????math.inf????????¨??§??????)\n\n    cart = [[99999999] * (amount//100 + 1) for _ in range(len(packages))]\n\n    for i in range(len(packages)):\n\n        cart[i][0] = 0          #  0g???????????\\????????´??????0???????????????\n\n\n\n    for i in range(1, len(packages)):\n\n        for j in range(1, len(cart[0])):\n\n            w = packages[i][0]  #  ??????\n\n            p = packages[i][1]  #  ??????\n\n            if j < w:\n\n                cart[i][j] = cart[i-1][j]\n\n            else:\n\n                # ???????????????????????????????????????????????????????????????????????????????¨????\n\n                cart[i][j] = min(cart[i-1][j], cart[i-1][max(0, j-w)]+p, cart[i][max(0, j-w)]+p)\n\n    return cart[-1][-1]\n\n\n\n\n\ndef main(args):\n\n    while True:\n\n        amount = int(eval(input()))\n\n        if amount == 0:\n\n            break\n\n        #result = solve(amount)\n\n        #print(result)\n\n        result = solve2(amount)\n\n        print(result)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main(sys.argv[1:])", "score": 1.0, "surface_similarity": 0.7861461810090455}
{"id": "p02657_u075304271", "golden_code": "def iput(): return int(eval(input()))\n\ndef mput(): return list(map(int, input().split()))\n\ndef lput(): return list(map(int, input().split()))\n\n\n\ndef solve():\n\n    a, b = mput()\n\n    print((a*b))\n\n    return 0\n\n\n\nif __name__ == \"__main__\":\n\n    solve()", "generated_code": "import math\n\ndef solve():\n\n    a, b = input().split()\n\n    a = int(a)\n\n    b = float(b)\n\n    print((int(a*b)))\n\n    return 0\n\n \n\nif __name__ == \"__main__\":\n\n    solve()", "score": 1.0, "surface_similarity": 0.7209163346613545}
{"id": "p03759_u762420987", "golden_code": "a, b, c = list(map(int, input().split()))\n\nif (b - a) == (c - b):\n\n    print(\"YES\")\n\nelse:\n\n    print(\"NO\")", "generated_code": "a, b, c = list(map(int, input().split()))\n\nif b - a == c - b:\n\n    print(\"YES\")\n\nelse:\n\n    print(\"NO\")", "score": 1.0, "surface_similarity": 0.9813084112149533}
{"id": "p03796_u033606236", "golden_code": "import math\n\nprint((math.factorial(int(eval(input())))%1000000007))", "generated_code": "num = int(eval(input()))\n\nresult = 1\n\nfor i in range(1,num+1):\n\n    result = result *i % 1000000007\n\nprint(result)", "score": 1.0, "surface_similarity": 0.4517543859649123}
{"id": "p03416_u488127128", "golden_code": "a,b = list(map(int, input().split()))\n\ncount = 0\n\nfor i in range(a,b+1):\n\n    j = str(i)\n\n    if j==''.join(reversed(j)):\n\n        count += 1\n\nprint(count)", "generated_code": "a,b = list(map(int, input().split()))\n\nn = [i for i in map(str, list(range(a,b+1))) if i==i[::-1]]\n\nprint((len(n)))", "score": 1.0, "surface_similarity": 0.6011220196353436}
{"id": "p02899_u759412327", "golden_code": "from numpy import *\n\neval(input())\n\nprint((\" \".join(map(str,argsort(list(map(int,input().split())))+1))))", "generated_code": "N = int(eval(input()))\n\nA = list(map(int,input().split()))\n\nB = N*[0]\n\n\n\nfor n in range(N):\n\n  B[A[n]-1]=n+1\n\n\n\nprint((*B))", "score": 1.0, "surface_similarity": 0.3794715447154472}
{"id": "p03363_u581187895", "golden_code": "from collections import Counter\n\nimport numpy as np\n\n\n\nN = int(eval(input()))\n\nA = np.array(input().split(), dtype=np.int64)\n\n\n\nc = Counter(A.cumsum())\n\nc[0] += 1 # np.cumsum(), 0start では無い為 0を加える\n\nans = sum(v*(v-1)//2 for v in list(c.values()))\n\nprint(ans)", "generated_code": "\n\nfrom itertools import accumulate\n\nfrom collections import defaultdict\n\ndef resolve():\n\n    N = int(eval(input()))\n\n    A = list(map(int, input().split()))\n\n\n\n    Acum = [0] + list(accumulate(A))\n\n    dic = defaultdict(int)\n\n    ans = 0\n\n    for i in range(N + 1):\n\n        ans += dic[Acum[i]]\n\n        dic[Acum[i]] += 1\n\n\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    resolve()", "score": 1.0, "surface_similarity": 0.5231433506044905}
{"id": "p03796_u642883360", "golden_code": "#!/usr/bin/env pypy3\n\n\n\nimport math\n\nprint((math.factorial(int(eval(input()))) % 1000000007))", "generated_code": "n = int(eval(input()))\n\nfor i in range(n - 1, 1, -1):\n\n\tn *= i\n\n\tn %= 10**9 + 7\n\nprint(n)", "score": 1.0, "surface_similarity": 0.36789554531490015}
{"id": "p03170_u060938295", "golden_code": "# -*- coding: utf-8 -*-\n\n\"\"\"\n\nCreated on Sat Apr 25 18:20:35 2020\n\n\"\"\"\n\n\n\nimport sys\n\nimport numpy as np\n\n\n\nsys.setrecursionlimit(10 ** 9)\n\n#def input():\n\n#    return sys.stdin.readline()[:-1]\n\nmod = 10**9+7\n\n\n\n#N = int(input())\n\nN, K = list(map(int,input().split()))\n\nA = np.array(list(map(int,input().split())))\n\n\n\ndp = [True for i in range(K + A[-1] + 1)]\n\nfor i in range(K):\n\n    if dp[i]:\n\n        for a in A:\n\n            dp[i + a] = False\n\n\n\n#    print(i, dp[i],A+i,dp[A+i])\n\n#print(dp)\n\n\n\nif dp[K]:\n\n    ans = 'Second'\n\nelse:\n\n    ans = 'First'\n\nprint(ans)", "generated_code": "# -*- coding: utf-8 -*-\n\n\"\"\"\n\nCreated on Sat Apr 25 18:20:35 2020\n\n\"\"\"\n\n\n\nimport sys\n\nimport numpy as np\n\n\n\nsys.setrecursionlimit(10 ** 9)\n\n#def input():\n\n#    return sys.stdin.readline()[:-1]\n\nmod = 10**9+7\n\n\n\n#N = int(input())\n\n#N, K = map(int,input().split())\n\n#A = np.array(list(map(int,input().split())))\n\nN, K, *A = list(map(int, open(0).read().split()))\n\n\n\ndp = [True for i in range(K + A[-1] + 1)]\n\nfor i in range(K):\n\n    if dp[i]:\n\n        for a in A:\n\n            dp[i + a] = False\n\n\n\n#    print(i, dp[i],A+i,dp[A+i])\n\n#print(dp)\n\n\n\nif dp[K]:\n\n    ans = 'Second'\n\nelse:\n\n    ans = 'First'\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.9423417894162576}
{"id": "p03721_u888092736", "golden_code": "(N, K), *AB = [list(map(int, s.split())) for s in open(0)]\n\nfor a, b in sorted(AB):\n\n    K -= b\n\n    if K <= 0:\n\n        print(a)\n\n        break\n", "generated_code": "N, K, *AB = list(map(int, open(0).read().split()))\n\nli = [(a, b) for a, b in zip(*[iter(AB)] * 2)]\n\nli.sort()\n\nfor a, b in li:\n\n    if K > b:\n\n        K -= b\n\n    else:\n\n        print(a)\n\n        break\n", "score": 1.0, "surface_similarity": 0.7225660066006601}
{"id": "p03796_u254871849", "golden_code": "mod = int(1e9+7)\n\nn = int(eval(input()))\n\n\n\npower = 1\n\nfor i in range(1, n+1):\n\n    power = power * i % mod\n\nprint(power)", "generated_code": "import sys\n\n\n\nMOD = 10 ** 9 + 7\n\nn = int(sys.stdin.readline().rstrip())\n\n\n\ndef main():\n\n    res = 1\n\n    for i in range(1, n+1):\n\n        res *= i\n\n        res %= MOD\n\n\n\n    return res\n\n\n\nif __name__ == '__main__':\n\n    ans = main()\n\n    print(ans)", "score": 1.0, "surface_similarity": 0.54502688172043}
{"id": "p03307_u623052494", "golden_code": "import numpy as np\n\nN=int(eval(input()))\n\ndef gcd(a,b):\n\n    c=int(np.floor(a/b))\n\n    return a-b*c\n\nif gcd(N,2)==0:\n\n    print(N)\n\nelse:\n\n    print((2*N))", "generated_code": "N=int(eval(input()))\n\nif N%2==0:\n\n    print(N)\n\nelse:\n\n    print((2*N))", "score": 1.0, "surface_similarity": 0.5632538569424965}
{"id": "p03164_u492605584", "golden_code": "N, W = list(map(int, input().split()))\n\nL = [list(map(int, input().split())) for i in range(N)]\n\nV = 0\n\nfor i in range(N):\n\n  V += L[i][1]\n\n\n\ndp = [[10**9+1] * (V + 1) for i in range(N+1)]\n\ndp[0][0] = 0\n\nfor i in range(N):\n\n    for j in range(V+1):\n\n        if j - L[i][1] >= 0:\n\n          dp[i+1][j] = min(dp[i][j], dp[i][j-L[i][1]] + L[i][0])\n\n        else:\n\n          dp[i+1][j] = dp[i][j]\n\nans = 0\n\nfor j in range(V+1):\n\n    if  W >= dp[-1][j]:\n\n        ans = max(ans, j)\n\nprint(ans)", "generated_code": "N, W = list(map(int, input().split()))\n\nL = [list(map(int, input().split())) for i in range(N)]\n\nV = 0\n\nfor i in range(N):\n\n  V += L[i][1]\n\n\n\ndp = [10**9+1] * (V + 1)\n\ndp[0] = 0\n\nfor i in range(N):\n\n    for j in range(V, -1, -1):\n\n        dp[j] = min(dp[j], dp[j-L[i][1]] + L[i][0])\n\nans = 0\n\nfor j in range(V+1):\n\n    if  W >= dp[j]:\n\n        ans = max(ans, j)\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.9188911704312115}
{"id": "p03814_u494927057", "golden_code": "s = eval(input())\n\n\n\nstart = -1\n\nend = 0\n\nfor i in range(len(s)):\n\n    if s[i] == 'A' and start < 0:\n\n        start = i\n\n    elif s[i] == 'Z':\n\n        end = i\n\nprint((end - start + 1))\n", "generated_code": "s = eval(input())\n\n\n\nstart = 0\n\nfor i in range(len(s)):\n\n    if s[i] == 'A':\n\n        start = i\n\n        break\n\n\n\nend = 0\n\nfor i in reversed(list(range(len(s)))):\n\n    if s[i] == 'Z':\n\n        end = i\n\n        break\n\nprint((end - start + 1))\n", "score": 1.0, "surface_similarity": 0.739399928135106}
{"id": "p02412_u150984829", "golden_code": "while 1:\n\n n,x=list(map(int,input().split()))\n\n if n+x==0:break\n\n print((len([1 for i in range(3,n+1)for j in range(2,x-i)if x-i-j<j<i])))", "generated_code": "while 1:\n\n n,x=list(map(int,input().split()))\n\n if n+x==0:break\n\n print((len([1 for i in range(1,n-1)for j in range(i+1,n)if j<x-i-j<=n])))", "score": 1.0, "surface_similarity": 0.9341072596468281}
{"id": "p02760_u141786930", "golden_code": "import numpy as np\n\n\n\nA = np.zeros((3,3),int)\n\nfor i in range(3):\n\n    A[i,:] = np.array([int(x) for x in input().split()])\n\n    \n\nN = int(eval(input()))\n\n\n\nfor _ in range(N):\n\n    b = int(eval(input()))\n\n    A[A==b] = 0\n\n\n\nans = 'No'\n\nif np.sum(A[0,:])==0 or np.sum(A[1,:])==0 or np.sum(A[2,:])==0 or np.sum(A[:,0])==0 or np.sum(A[:,1])==0 or np.sum(A[:,2])==0 or np.sum(A[0,0]+A[1,1]+A[2,2])==0 or np.sum(A[0,2]+A[1,1]+A[2,0])==0:\n\n   ans = 'Yes'\n\n\n\nprint(ans)\n", "generated_code": "# B - Bingo\n\n\n\nimport numpy as np\n\n\n\nA = np.zeros((3,3), dtype=np.int64)\n\n\n\nfor i in range(3):\n\n    A[i] = [int(x) for x in input().split()]\n\n\n\nN = int(input())\n\n\n\nfor _ in range(N):\n\n    b = int(input())\n\n    A = np.where(A==b, 0, A)\n\n\n\nif sum(A[0])==0 or sum(A[1])==0 or sum(A[2])==0 or \\\n\n    sum(A[:,0])==0 or sum(A[:,1])==0 or sum(A[:,2])==0 or \\\n\n    A[0,0]+A[1,1]+A[2,2]==0 or \\\n\n    A[2,0]+A[1,1]+A[0,2]==0:\n\n    print('Yes')\n\nelse:\n\n    print('No')\n", "score": 1.0, "surface_similarity": 0.3779697624190065}
{"id": "p03608_u070201429", "golden_code": "def main():\n\n    from sys import stdin\n\n    input = stdin.readline\n\n\n\n    n, m, r = list(map(int, input().split()))\n\n    l = list(map(int, input().split()))\n\n    for i in range(r):\n\n        l[i] -= 1\n\n    d = [[10**8] * n for _ in range(n)]\n\n    for _ in range(m):\n\n        i, j, k = list(map(int, input().split()))\n\n        d[i-1][j-1] = k\n\n        d[j-1][i-1] = k\n\n\n\n    # Warshall-Floyd algorithm\n\n    for k in range(n):\n\n        for i in range(n):\n\n            for j in range(n):\n\n                if d[i][j] > d[i][k] + d[k][j]:\n\n                    d[i][j] = d[i][k] + d[k][j]\n\n\n\n    # full search\n\n    # 8! = 40320\n\n    from itertools import permutations\n\n\n\n    answer = 10**8\n\n    for i in permutations(l):\n\n        ans = 0\n\n        for j in range(r-1):\n\n            ans += d[i[j]][i[j+1]]\n\n        if ans < answer:\n\n            answer = ans\n\n\n\n    print(answer)\n\n\n\nmain()\n", "generated_code": "def main():\n\n    from sys import stdin\n\n    input = stdin.readline\n\n\n\n    n, m, r = list(map(int, input().split()))\n\n    l = list(map(int, input().split()))\n\n    for i in range(r):\n\n        l[i] -= 1\n\n    d = [[10**8] * n for _ in range(n)]\n\n    for _ in range(m):\n\n        i, j, k = list(map(int, input().split()))\n\n        d[i-1][j-1] = k\n\n        d[j-1][i-1] = k\n\n\n\n    # Warshall-Floyd algorithm\n\n    for k in range(n):\n\n        for i in range(n-1):\n\n            for j in range(i+1, n):\n\n                if d[i][j] > d[i][k] + d[k][j]:\n\n                    d[i][j] = d[i][k] + d[k][j]\n\n                    d[j][i] = d[i][j]\n\n\n\n    # full search\n\n    # 8! = 40320\n\n    from itertools import permutations\n\n\n\n    answer = 10**8\n\n    for i in permutations(l):\n\n        ans = 0\n\n        for j in range(r-1):\n\n            ans += d[i[j]][i[j+1]]\n\n        if ans < answer:\n\n            answer = ans\n\n\n\n    print(answer)\n\n\n\nmain()\n", "score": 1.0, "surface_similarity": 0.9881209503239741}
{"id": "p02702_u994988729", "golden_code": "from collections import Counter\n\nS = input()[::-1]\n\n\n\nmemo = [0]\n\nd = 0\n\nmod = 2019\n\n\n\nfor s in S:\n\n    tmp = int(s) * pow(10, d, mod) % mod\n\n    tmp = memo[-1] + tmp\n\n    memo.append(tmp % mod)\n\n    d += 1\n\n\n\nc = Counter(memo)\n\nans = sum(v * (v - 1) // 2 for v in list(c.values()))\n\nprint(ans)", "generated_code": "from collections import defaultdict\n\nS = eval(input())\n\nN = len(S)\n\n\n\nmemo = defaultdict(int)\n\nmemo[0] += 1\n\n\n\nmod = 2019\n\nd = 1\n\nval = 0\n\n\n\nfor s in S[::-1]:\n\n    s = int(s)\n\n    val += s * d\n\n    val %= mod\n\n    memo[val] += 1\n\n    d *= 10\n\n    d %= mod\n\n\n\nprint((sum(v * (v - 1) // 2 for v in list(memo.values()))))", "score": 1.0, "surface_similarity": 0.7582110412299091}
{"id": "p02627_u790710233", "golden_code": "a = eval(input())\n\nprint(('A' if not a.islower() else 'a'))\n", "generated_code": "print(('A' if input().isupper() else 'a'))\n", "score": 1.0, "surface_similarity": 0.6333333333333333}
{"id": "p03325_u296518383", "golden_code": "N=int(eval(input()))\n\na=list(map(int,input().split()))\n\nfor i in range(N):\n\n  for j in range(1,31):\n\n    if a[i]%(2**j)!=0:\n\n      a[i]=j-1\n\n      break\n\nprint((sum(a)))", "generated_code": "import sys\n\ninput = sys.stdin.buffer.readline\n\n\n\nN = int(eval(input()))\n\nA = list(map(int, input().split()))\n\n\n\ndef f(n):\n\n  res = 0\n\n  while n % 2 == 0:\n\n    n //= 2\n\n    res += 1\n\n  return res\n\n\n\nanswer = 0\n\nfor a in A:\n\n  answer += f(a)\n\n\n\nprint(answer)", "score": 1.0, "surface_similarity": 0.47139616935483875}
{"id": "p02821_u211706121", "golden_code": "import numpy as np\n\n\n\nn,m = [int(i) for i in input().split()]\n\na = [int(i) for i in input().split()]\n\nd = 2**18\n\n\n\nf = np.zeros(d,dtype=int)\n\nfor i in a:\n\n    f[i]+=1\n\n\n\ntf = np.fft.fft(f)\n\nf = np.fft.ifft(tf*tf)\n\nf = [int(i+0.5) for i in f]\n\n\n\nans=0\n\nfor i in range(len(f)-1,0,-1):\n\n    if f[i]<=m:\n\n        ans+=i*f[i]\n\n        m-=f[i]\n\n    elif f[i]>m:\n\n        ans+=i*m\n\n        break\n\nprint(ans)", "generated_code": "import numpy as np\n\n\n\nn,m = [int(i) for i in input().split()]\n\na = [int(i) for i in input().split()]\n\nd = 2**18\n\n\n\nf = np.zeros(d,dtype=int)\n\nfor i in a:\n\n    f[i]+=1\n\n\n\ntf = np.fft.rfft(f)\n\nf = np.fft.irfft(tf*tf)\n\nf = [int(i+0.5) for i in f]\n\n\n\nans=0\n\nfor i in range(len(f)-1,0,-1):\n\n    if f[i]<=m:\n\n        ans+=i*f[i]\n\n        m-=f[i]\n\n    elif f[i]>m:\n\n        ans+=i*m\n\n        break\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.9975124378109452}
{"id": "p03416_u280552586", "golden_code": "a, b = list(map(int, input().split()))\n\ncnt = 0\n\n\n\nfor i in range(a, b+1):\n\n    i = str(i)\n\n    if i[0] == i[-1] and i[1] == i[-2]:\n\n        cnt += 1\n\n\n\nprint(cnt)\n", "generated_code": "a, b = list(map(int, input().split()))\n\ncnt = 0\n\n\n\nfor i in range(10):\n\n    for j in range(10):\n\n        for k in range(10):\n\n            c = 10000*i+1000*j+100*k+10*j+i\n\n            if a <= c <= b:\n\n                cnt += 1\n\n\n\nprint(cnt)\n", "score": 1.0, "surface_similarity": 0.6840167364016736}
{"id": "p03835_u753803401", "golden_code": "k, s = list(map(int, input().split()))\n\ncnt = 0\n\nfor i in range(k + 1):\n\n    for j in range(k + 1):\n\n        if i + j > s:\n\n            break\n\n        elif s - i - j <= k:\n\n            cnt += 1\n\nprint(cnt)\n", "generated_code": "k, s = list(map(int, input().split()))\n\ncnt = 0\n\nfor i in range(k + 1):\n\n    for j in range(k + 1):\n\n        if 0 <= s - i - j <= k:\n\n            cnt += 1\n\nprint(cnt)\n", "score": 1.0, "surface_similarity": 0.90873786407767}
{"id": "p02702_u893063840", "golden_code": "from collections import Counter\n\n\n\ns = eval(input())\n\nmod1 = 673\n\nmod2 = 3\n\n\n\nnum1 = 0\n\nnum2 = 0\n\nli1 = []\n\nli2 = []\n\npw1 = 10\n\npw2 = 10\n\nfor i, e in enumerate(s, 1):\n\n    num1 *= 10\n\n    num1 += int(e)\n\n    num1 %= mod1\n\n    inv = pow(pw1, mod1 - 2, mod1)\n\n    li1.append(num1 * inv % mod1)\n\n\n\n    num2 *= 10\n\n    num2 += int(e)\n\n    num2 %= mod2\n\n    inv = pow(pw2, mod2 - 2, mod2)\n\n    li2.append(num2 * inv % mod2)\n\n\n\n    pw1 *= 10\n\n    pw1 %= mod1\n\n    pw2 *= 10\n\n    pw2 %= mod2\n\n\n\nli = [0] + [10 * e1 + e2 for e1, e2 in zip(li1, li2)]\n\nc = Counter(li)\n\n\n\nans = 0\n\nfor v in list(c.values()):\n\n    ans += v * (v - 1) // 2\n\n\n\nprint(ans)\n", "generated_code": "from collections import Counter\n\n\n\n\n\ndef f(mod):\n\n    ret = [0]\n\n    power = 1\n\n    num = 0\n\n    for i, e in enumerate(s, 1):\n\n        num *= 10\n\n        num += int(e)\n\n        num %= mod\n\n\n\n        power *= 10\n\n        power %= mod\n\n        inv = pow(power, mod - 2, mod)\n\n\n\n        ret.append(num * inv % mod)\n\n\n\n    return ret\n\n\n\n\n\ns = eval(input())\n\n\n\nmod3 = f(3)\n\nmod673 = f(673)\n\n\n\nli = [10 * e673 + e3 for e3, e673 in zip(mod3, mod673)]\n\n\n\nc = Counter(li)\n\nans = 0\n\nfor v in list(c.values()):\n\n    ans += v * (v - 1) // 2\n\nprint(ans)\n", "score": 1.0, "surface_similarity": 0.7652394984688277}
{"id": "p02537_u545368057", "golden_code": "import sys\n\ninput = sys.stdin.readline\n\n\n\nn,k = list(map(int, input().split()))\n\nAs = [int(eval(input())) for i in range(n)]\n\n\n\n# N: 処理する区間の長さ\n\n\n\nINF = 0\n\n\n\nmx = 300001\n\nLV = (mx-1).bit_length()\n\nN0 = 2**LV\n\ndata = [INF]*(2*N0)\n\nlazy = [None]*(2*N0)\n\n\n\n# 伝搬対象の区間を求める\n\ndef gindex(l, r):\n\n    L = (l + N0) >> 1; R = (r + N0) >> 1\n\n    lc = 0 if l & 1 else (L & -L).bit_length()\n\n    rc = 0 if r & 1 else (R & -R).bit_length()\n\n    for i in range(LV):\n\n        if rc <= i:\n\n            yield R\n\n        if L < R and lc <= i:\n\n            yield L\n\n        L >>= 1; R >>= 1\n\n\n\n# 遅延伝搬処理\n\ndef propagates(*ids):\n\n    for i in reversed(ids):\n\n        v = lazy[i-1]\n\n        if v is None:\n\n            continue\n\n        lazy[2*i-1] = data[2*i-1] = lazy[2*i] = data[2*i] = v\n\n        lazy[i-1] = None\n\n\n\n# 区間[l, r)をxで更新\n\ndef update(l, r, x):\n\n    *ids, = gindex(l, r)\n\n    propagates(*ids)\n\n\n\n    L = N0 + l; R = N0 + r\n\n    while L < R:\n\n        if R & 1:\n\n            R -= 1\n\n            lazy[R-1] = data[R-1] = x\n\n        if L & 1:\n\n            lazy[L-1] = data[L-1] = x\n\n            L += 1\n\n        L >>= 1; R >>= 1\n\n    for i in ids:\n\n        data[i-1] = max(data[2*i-1], data[2*i])\n\n\n\n# 区間[l, r)内の最小値を求める\n\ndef query(l, r):\n\n    propagates(*gindex(l, r))\n\n    L = N0 + l; R = N0 + r\n\n\n\n    s = INF\n\n    while L < R:\n\n        if R & 1:\n\n            R -= 1\n\n            s = max(s, data[R-1])\n\n        if L & 1:\n\n            s = max(s, data[L-1])\n\n            L += 1\n\n        L >>= 1; R >>= 1\n\n    return s\n\n\n\nupdate(As[0],As[0]+1,1)\n\nfor i, a in enumerate(As[1:]):\n\n    l = max(0,a-k)\n\n    r = min(mx,a+k)\n\n    upd = query(l,r+1)\n\n    if upd == -1:continue\n\n    # print(\"i\",i,\"a\",a,\"upd\",upd,\"l\",l,\"r\",r)\n\n    update(a, a+1, upd+1)\n\n\n\nans = 0\n\nfor a in set(As):\n\n    ans = max(ans,query(a,a+1))\n\nprint(ans)", "generated_code": "import sys\n\ninput = sys.stdin.readline\n\n\n\nn,k = list(map(int, input().split()))\n\nAs = [int(eval(input())) for i in range(n)]\n\n\n\n# N: 処理する区間の長さ\n\n\n\nINF = 0\n\n\n\nmx = 300001\n\nLV = (mx-1).bit_length()\n\nN0 = 2**LV\n\ndata = [INF]*(2*N0)\n\nlazy = [None]*(2*N0)\n\n\n\n# 伝搬対象の区間を求める\n\ndef gindex(l, r):\n\n    L = (l + N0) >> 1; R = (r + N0) >> 1\n\n    lc = 0 if l & 1 else (L & -L).bit_length()\n\n    rc = 0 if r & 1 else (R & -R).bit_length()\n\n    for i in range(LV):\n\n        if rc <= i:\n\n            yield R\n\n        if L < R and lc <= i:\n\n            yield L\n\n        L >>= 1; R >>= 1\n\n\n\n# 遅延伝搬処理\n\ndef propagates(*ids):\n\n    for i in reversed(ids):\n\n        v = lazy[i-1]\n\n        if v is None:\n\n            continue\n\n        lazy[2*i-1] = data[2*i-1] = lazy[2*i] = data[2*i] = v\n\n        lazy[i-1] = None\n\n\n\n# 区間[l, r)をxで更新\n\ndef update(l, r, x):\n\n    *ids, = gindex(l, r)\n\n    propagates(*ids)\n\n\n\n    L = N0 + l; R = N0 + r\n\n    while L < R:\n\n        if R & 1:\n\n            R -= 1\n\n            lazy[R-1] = data[R-1] = x\n\n        if L & 1:\n\n            lazy[L-1] = data[L-1] = x\n\n            L += 1\n\n        L >>= 1; R >>= 1\n\n    for i in ids:\n\n        data[i-1] = max(data[2*i-1], data[2*i])\n\n\n\n# 区間[l, r)内の最小値を求める\n\ndef query(l, r):\n\n    propagates(*gindex(l, r))\n\n    L = N0 + l; R = N0 + r\n\n\n\n    s = INF\n\n    while L < R:\n\n        if R & 1:\n\n            R -= 1\n\n            s = max(s, data[R-1])\n\n        if L & 1:\n\n            s = max(s, data[L-1])\n\n            L += 1\n\n        L >>= 1; R >>= 1\n\n    return s\n\n\n\nans = 0\n\nupdate(As[0],As[0]+1,1)\n\nfor i, a in enumerate(As[1:]):\n\n    l = max(0,a-k)\n\n    r = min(mx,a+k)\n\n    upd = query(l,r+1)\n\n    if upd == -1:continue\n\n    # print(\"i\",i,\"a\",a,\"upd\",upd,\"l\",l,\"r\",r)\n\n    update(a, a+1, upd+1)\n\n    ans = max(ans, upd+1)\n\nprint(ans)\n\n\n", "score": 1.0, "surface_similarity": 0.9899888765294772}
{"id": "p02725_u199290844", "golden_code": "import numpy as np\n\n\n\nK, N = [int(i) for i in input().rstrip().split(' ')]\n\nA = [int(i) for i in input().rstrip().split(' ')]\n\n\n\nx = A[0]\n\ny = K - A[-1]\n\nn = [int(A[i+1] - A[i]) for i in range(N-1)]\n\nn.append(x+y)\n\n\n\nnp_list = np.array(n)\n\nn.pop(np_list.argmax())\n\nprint((sum(n)))", "generated_code": "k,n = list(map(int,input().split()))\n\na = list(map(int,input().split()))\n\n\n\ndp = [0 for i in range(n)]\n\ndp[0] = abs(k-a[-1]) + a[0]\n\n\n\nfor i in range(1,n):\n\n    dp[i] = abs(a[i]-a[i-1])\n\n\n\nprint((sum(dp) - max(dp)))", "score": 1.0, "surface_similarity": 0.6425324675324675}
{"id": "p03253_u029315034", "golden_code": "from math import sqrt\n\nfrom scipy.misc import comb\n\n\n\ndef cal_factors(num):\n\n    factors = {}\n\n    maxmod = int(sqrt(num)) + 1\n\n    for mod in range(2, maxmod):\n\n        i = 0\n\n        while True:\n\n            d, q = divmod(num, mod)\n\n            if q == 0:\n\n                num = d\n\n                i += 1\n\n                factors[mod] = i\n\n            else:\n\n                break\n\n\n\n    if num > 1:\n\n        factors[num] = 1\n\n\n\n    return factors\n\n\n\n\n\nn, m = [int(v) for v in input().split()]\n\n\n\nmod = 1000000000 + 7\n\nfactors = cal_factors(m)\n\nans = 1\n\nfor v in list(factors.values()):\n\n    ans *= comb(v + n - 1, v, exact=True) % mod\n\n    ans %= mod\n\n\n\nprint(ans)", "generated_code": "from math import sqrt\n\n\n\ndef cal_factors(num):\n\n    factors = {}\n\n    maxmod = int(sqrt(num)) + 1\n\n    for mod in range(2, maxmod):\n\n        i = 0\n\n        while True:\n\n            d, q = divmod(num, mod)\n\n            if q == 0:\n\n                num = d\n\n                i += 1\n\n                factors[mod] = i\n\n            else:\n\n                break\n\n\n\n    if num > 1:\n\n        factors[num] = 1\n\n\n\n    return factors\n\n\n\n\n\ndef comb(n, r, mod):\n\n    result = 1\n\n    r = min(r, n-r)\n\n    for i in range(n, n-r, -1):\n\n        result *= i\n\n    for i in range(2, r+1):\n\n        result //= i\n\n\n\n    return result % mod\n\n\n\n\n\nn, m = [int(v) for v in input().split()]\n\n\n\nmod = 1000000000 + 7\n\nfactors = cal_factors(m)\n\nans = 1\n\nfor v in list(factors.values()):\n\n    ans *= comb(v + n - 1, v, mod)\n\n    ans %= mod\n\n\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.8504172015404365}
{"id": "p03371_u882564128", "golden_code": "a, b, c, x, y = list(map(int, input().split(' ')))\n\n\n\nc = int(c*2)\n\nm = float('inf')\n\nfor i in range(10**5+1):\n\n    m = min(m, a*max(0, x-i)+b*max(0,y-i)+c*i)\n\nprint(m)", "generated_code": "import math\n\na, b, c, x, y = list(map(int, input().split(' ')))\n\nans = float('inf')\n\nc = c*2\n\nfor i in range(max(x, y)+1):\n\n    if i > x:\n\n        price = b*(y-i) + c*i\n\n    elif i > y:\n\n        price = a*(x-i) + c*i\n\n    else:\n\n        price = a*(x-i) + b*(y-i) + c*i\n\n\n\n    if ans > price:\n\n        ans = price\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.6626984126984128}
{"id": "p03575_u094191970", "golden_code": "from scipy.sparse.csgraph import floyd_warshall\n\n\n\nn,m=list(map(int,input().split()))\n\nl=[list(map(int,input().split())) for i in range(m)]\n\n\n\nans=0\n\nfor i in range(m):\n\n    ll=l[:i]+l[i+1:]\n\n\n\n    d=[[float('inf')]*n for i in range(n)]\n\n    for i in range(n):\n\n        d[i][i]=0\n\n\n\n    for j in ll:\n\n        d[j[0]-1][j[1]-1]=1\n\n        d[j[1]-1][j[0]-1]=1\n\n\n\n    d=floyd_warshall(d)\n\n\n\n    if float('inf') in d:\n\n        ans+=1\n\n\n\nprint(ans)", "generated_code": "class UnionFind():\n\n    def __init__(self, n):\n\n        self.n = n\n\n        self.parents = [-1] * n\n\n\n\n    def find(self, x):\n\n        if self.parents[x] < 0:\n\n            return x\n\n        else:\n\n            self.parents[x] = self.find(self.parents[x])\n\n            return self.parents[x]\n\n\n\n    def union(self, x, y):\n\n        x = self.find(x)\n\n        y = self.find(y)\n\n\n\n        if x == y:\n\n            return\n\n\n\n        if self.parents[x] > self.parents[y]:\n\n            x, y = y, x\n\n\n\n        self.parents[x] += self.parents[y]\n\n        self.parents[y] = x\n\n\n\n    def roots(self):\n\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n\n\n    def group_count(self):\n\n        return len(self.roots())\n\n\n\nfrom copy import deepcopy\n\n\n\nn,m=list(map(int,input().split()))\n\nl=[list(map(int,input().split())) for i in range(m)]\n\n\n\ncnt=0\n\nfor i in range(m):\n\n  uf=UnionFind(n)\n\n  ll=deepcopy(l)\n\n  del ll[i]\n\n  for a,b in ll:\n\n    a-=1\n\n    b-=1\n\n    uf.union(a,b)\n\n  if uf.group_count()>=2:\n\n    cnt+=1\n\nprint(cnt)", "score": 1.0, "surface_similarity": 0.5431940371456501}
{"id": "p02414_u547492399", "golden_code": "n, m, l = list(map(int, input().split()))\n\n\n\na = [0]*n\n\nb = [0]*m\n\nc = [[0 for col in range(l)] for row in range(n)]\n\n\n\nfor i in range(n):\n\n    a[i] = list(map(int,input().split()))\n\n\n\nfor i in range(m):\n\n    b[i] = list(map(int,input().split()))\n\n\n\n\n\nfor i in range(n):\n\n    for j in range(l):\n\n        for k in range(m):\n\n            c[i][j] += a[i][k]*b[k][j]\n\n    print((*c[i]))", "generated_code": "n, m, l = list(map(int, input().split()))\n\n\n\na = [0]*n\n\nb = [0]*m\n\nc = [[0 for col in range(l)] for row in range(n)]\n\n\n\nfor i in range(n):\n\n    a[i] = list(map(int,input().split()))\n\n\n\nfor i in range(m):\n\n    b[i] = list(map(int,input().split()))\n\n\n\n\n\nfor i in range(n):\n\n    for j in range(l):\n\n        c[i][j] = sum([a[i][k]*b[k][j] for k in range(m)])\n\n#        for k in range(m):\n\n#            c[i][j] += a[i][k]*b[k][j]\n\n    print((*c[i]))", "score": 1.0, "surface_similarity": 0.9129665379665379}
{"id": "p02983_u729133443", "golden_code": "l,r=list(map(int,input().split()))\n\ns=list(range(l,r+1))[:2019]\n\nprint((min(i*j%2019for i in s for j in s if i<j)))", "generated_code": "l,r=list(map(int,input().split()));s=list(range(l,r+1))[:673];print((min(i*j%2019for i in s for j in s if i<j)))", "score": 1.0, "surface_similarity": 0.9739130434782608}
{"id": "p03945_u977389981", "golden_code": "s = eval(input())\n\ncnt = 0\n\nfor i in range(len(s) - 1):\n\n    if s[i] == 'W' and s[i + 1] == 'B':\n\n        cnt += 1\n\n    if s[i] == 'B' and s[i + 1] == 'W':\n\n        cnt += 1\n\nprint(cnt)", "generated_code": "S = eval(input())\n\n\n\ntmp = S[0]\n\ncnt = 0\n\nfor s in S[1:]:\n\n    if tmp != s:\n\n        cnt += 1\n\n        tmp = s\n\n        \n\nprint(cnt)", "score": 1.0, "surface_similarity": 0.6300982800982801}
{"id": "p03796_u977389981", "golden_code": "import math\n\nmod = 10 ** 9 + 7\n\nn = int(eval(input()))\n\nprint((math.factorial(n) % mod))", "generated_code": "mod = 10 ** 9 + 7\n\nn = int(eval(input()))\n\nans = 1\n\nfor i in range(1, n + 1):\n\n    ans *= i\n\n    ans %= mod\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.6148459383753502}
{"id": "p03416_u186426563", "golden_code": "A, B = list(map(int, input().split()))\n\ncount = 0\n\nfor i in range(A, B+1):\n\n    if(str(i) == str(i)[::-1]):\n\n        count += 1\n\nprint(count)\n", "generated_code": "A, B = list(map(int, input().split()))\n\ncount = 0\n\nfor i in range(10):\n\n    for j in range(10):\n\n        for k in range(10):\n\n            if(A <= 10000*i + 1000*j + 100*k + 10*j +i <= B):\n\n                count += 1\n\nprint(count)", "score": 1.0, "surface_similarity": 0.705904689576609}
{"id": "p03013_u864013199", "golden_code": "Mod = 10**9+7\n\nN,M = list(map(int, input().split()))\n\na = [int(eval(input())) for _ in range(M)]\n\nb = [1]*(N+1)\n\nfor j in a:\n\n    b[j] = 0\n\nfor i in range(1,N+1):\n\n    if b[i] == 0:\n\n        continue\n\n    if i == 1:\n\n        b[1] = 1\n\n        continue\n\n    b[i] = b[i-1]+b[i-2]\n\n    if b[i] >= Mod:\n\n        b[i] %= Mod\n\nprint((b[N]))", "generated_code": "# https://atcoder.jp/contests/abc129/submissions/5841482 を参考 \n\nN,M = list(map(int, input().split()))\n\nA = [int(eval(input())) for _ in range(M)]\n\nMOD = 10**9 + 7\n\nF = [1]*(N+1)\n\nfor j in A:\n\n    F[j-1] = 0\n\n \n\na = 1; b = 0\n\nfor i in range(N):\n\n    if not F[i]:    #F[i] == 0\n\n        a, b = 0, a\n\n    else:\n\n        a, b = ((a+b) % MOD), a\n\nprint(a)", "score": 1.0, "surface_similarity": 0.7114135625596945}
{"id": "p02555_u247830763", "golden_code": "n = int(eval(input()))\n\nmx = n//3\n\nans = 0\n\nmod = 10**9+7\n\nimport math\n\ndef combinations_count(n, r): #組み合わせ(nCr)\n\n    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\n\nfor i in range(1,mx+1):\n\n    if i == 1:\n\n        ans += 1\n\n    else:\n\n        ans += combinations_count(n-2*i-1,i-1) % mod\n\nprint((ans%mod))", "generated_code": "s = int(eval(input()))\n\ndp = [0]*(2001)\n\ndp[3] = 1\n\nmod = 10**9+7\n\nfor i in range(4,s+1):\n\n    dp[i] = (dp[i-1] + dp[i-3]) % mod\n\nprint((dp[s]))", "score": 1.0, "surface_similarity": 0.4759036144578313}
{"id": "p03494_u321071346", "golden_code": "import numpy as np\n\nn = int(eval(input()))\n\na_list = np.array(list(map(int, input().split())))\n\n\n\ncounter = 0\n\nwhile True:\n\n    if np.sum(a_list % 2) > 0:\n\n        break\n\n    counter += 1\n\n    a_list = a_list / 2\n\nprint(counter)\n", "generated_code": "n = int(eval(input()))\n\na_list = list(map(int, input().split()))\n\n\n\nstatus = True\n\nexecute = 0\n\nwhile status:\n\n    for i in range(n):\n\n        if a_list[i] % 2 == 1:\n\n            status = False\n\n            break\n\n        else:\n\n            a_list[i] = a_list[i] / 2\n\n    if status:\n\n        execute += 1\n\nprint(execute)\n", "score": 1.0, "surface_similarity": 0.668411214953271}
{"id": "p03568_u207799478", "golden_code": "import math\n\nimport string\n\n\n\n\n\ndef readints():\n\n    return list(map(int, input().split()))\n\n\n\n\n\ndef nCr(n, r):\n\n    return math.factorial(n)//(math.factorial(n-r)*math.factorial(r))\n\n\n\n\n\ndef has_duplicates2(seq):\n\n    seen = []\n\n    for item in seq:\n\n        if not(item in seen):\n\n            seen.append(item)\n\n    return len(seq) != len(seen)\n\n\n\n\n\ndef divisor(n):\n\n    divisor = []\n\n    for i in range(1, n+1):\n\n        if n % i == 0:\n\n            divisor.append(i)\n\n    return divisor\n\n\n\n\n\n# coordinates\n\ndx = [-1, -1, -1, 0, 0, 1, 1, 1]\n\ndy = [-1, 0, 1, -1, 1, -1, 0, 1]\n\n\n\nn = int(eval(input()))\n\na = readints()\n\n\n\n\n\ndef func(l):\n\n    if len(l) == n:\n\n        for i in range(len(l)):\n\n            if l[i] % 2 == 0:\n\n                return 1\n\n\n\n        return 0\n\n    return func(l+[(a[len(l)])])+func(l+[(a[len(l)]-1)])+func(l+[(a[len(l)]+1)])\n\n\n\n\n\nprint((func([])))\n", "generated_code": "import math\n\nimport string\n\n\n\n\n\ndef readints():\n\n    return list(map(int, input().split()))\n\n\n\n\n\ndef nCr(n, r):\n\n    return math.factorial(n)//(math.factorial(n-r)*math.factorial(r))\n\n\n\n\n\ndef has_duplicates2(seq):\n\n    seen = []\n\n    for item in seq:\n\n        if not(item in seen):\n\n            seen.append(item)\n\n    return len(seq) != len(seen)\n\n\n\n\n\ndef divisor(n):\n\n    divisor = []\n\n    for i in range(1, n+1):\n\n        if n % i == 0:\n\n            divisor.append(i)\n\n    return divisor\n\n\n\n\n\n# coordinates\n\ndx = [-1, -1, -1, 0, 0, 1, 1, 1]\n\ndy = [-1, 0, 1, -1, 1, -1, 0, 1]\n\n\n\nn = int(eval(input()))\n\na = readints()\n\nsum = 1\n\nfor i in range(len(a)):\n\n    if a[i] % 2 == 0:\n\n        sum *= 2\n\n    else:\n\n        sum *= 1\n\nprint((3**len(a)-sum))\n", "score": 1.0, "surface_similarity": 0.9049909998363607}
{"id": "p03796_u378157957", "golden_code": "import math\n\n\n\nN = int(eval(input()))\n\n\n\nnum = math.factorial(N)\n\n\n\nk, r = divmod(num, 10**9 + 7)\n\nprint(r)", "generated_code": "N = int(eval(input()))\n\n\n\nFACTOR = 10 ** 9 + 7\n\n\n\nnum = 1\n\nfor i in range(1, N+1):\n\n    num *= i\n\n    k, r = divmod(num, FACTOR)\n\n    num = r\n\n\n\nprint(r)", "score": 1.0, "surface_similarity": 0.6274509803921569}
{"id": "p03241_u312025627", "golden_code": "def main():\n\n    N, M = (int(i) for i in input().split())\n\n\n\n    def trial_division(n):\n\n        divs = []\n\n        for i in range(1, int(n**0.5)+1):\n\n            if n % i == 0:\n\n                divs.append(i)\n\n                if i != n//i:\n\n                    divs.append(n//i)\n\n        divs.sort(reverse=True)\n\n        return divs\n\n    divs = trial_division(M)\n\n    for d in divs:\n\n        if d*N <= M:\n\n            return print(d)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "generated_code": "def main():\n\n    def trial_division(n):\n\n        divs = []\n\n        for i in range(1, int(n**0.5)+1):\n\n            if n % i == 0:\n\n                divs.append(i)\n\n                if i != n//i:\n\n                    divs.append(n//i)\n\n        divs.sort(reverse=True)\n\n        return divs\n\n\n\n    N, M = (int(i) for i in input().split())\n\n    divs = trial_division(M)\n\n    for d in divs:\n\n        if N*d <= M:\n\n            return print(d)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 1.0, "surface_similarity": 0.9269311064718163}
{"id": "p03796_u010110540", "golden_code": "import math\n\n\n\nN = int(eval(input()))\n\nC = 10**9 + 7\n\n\n\nprint((math.factorial(N) % C))", "generated_code": "N = int(eval(input()))\n\nC = 10**9+7\n\nans = 1\n\nfor i in range(1, N + 1):\n\n    ans *= i\n\n    ans %= C\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.5945945945945945}
{"id": "p04017_u754022296", "golden_code": "import sys\n\ninput = sys.stdin.readline\n\nimport bisect\n\n\n\nn = int(eval(input()))\n\nX = list(map(int, input().split()))\n\nl = int(eval(input()))\n\nU = 17\n\ndp = [[0]*n for _ in range(U+1)]\n\nfor i, x in enumerate(X):\n\n  t = bisect.bisect_left(X, x+l)\n\n  dp[0][i] = bisect.bisect_right(X, x+l) - 1\n\nfor k in range(U):\n\n  for i in range(n):\n\n    dp[k+1][i] = dp[k][dp[k][i]]\n\ndef test(x, a, b):\n\n  for i in range(U, -1, -1):\n\n    if x >> i & 1:\n\n      a = dp[i][a]\n\n  return a >= b\n\ndef solve(a, b):\n\n  if a > b:\n\n    a, b = b, a\n\n  ng = 0\n\n  ok = n-1\n\n  while ok - ng > 1:\n\n    mid = (ng + ok) // 2\n\n    if test(mid, a, b):\n\n      ok = mid\n\n    else:\n\n      ng = mid\n\n  print(ok)\n\nq = int(eval(input()))\n\nfor _ in range(q):\n\n  a, b = list(map(int, input().split()))\n\n  a -= 1\n\n  b -= 1\n\n  solve(a, b)", "generated_code": "import sys\n\ninput = sys.stdin.readline\n\nimport bisect\n\n\n\nn = int(eval(input()))\n\nX = list(map(int, input().split()))\n\nl = int(eval(input()))\n\nU = 17\n\ndp = [[0]*n for _ in range(U+1)]\n\nfor i, x in enumerate(X):\n\n  t = bisect.bisect_left(X, x+l)\n\n  dp[0][i] = bisect.bisect_right(X, x+l) - 1\n\nfor k in range(U):\n\n  for i in range(n):\n\n    dp[k+1][i] = dp[k][dp[k][i]]\n\nq = int(eval(input()))\n\nfor _ in range(q):\n\n  a, b = list(map(int, input().split()))\n\n  a -= 1\n\n  b -= 1\n\n  if a > b:\n\n    a, b = b, a\n\n  res = 1\n\n  for k in range(U, -1, -1):\n\n    if dp[k][a] < b:\n\n      a = dp[k][a]\n\n      res += (1<<k)\n\n    if a == b:\n\n      break\n\n  print(res)", "score": 1.0, "surface_similarity": 0.7076250307957626}
{"id": "p03164_u216015528", "golden_code": "#!/usr/bin/env python3\n\ndef main():\n\n    import numpy as np\n\n\n\n    np.set_printoptions(linewidth=200)\n\n\n\n    N, W = list(map(int, input().split()))\n\n    lst = [list(map(int, input().split())) for _ in range(N)]\n\n    v_max = 10 ** 3 * 100 * 10\n\n    w_max = 10 ** 9 * v_max\n\n\n\n    # i以上の価値を持つときの最小重量\n\n    dp = np.full(v_max, w_max, dtype=np.int64)\n\n    # initialize\n\n    dp[0] = 0\n\n\n\n    for n in range(N):\n\n        w, v = lst[n]\n\n        dp[v:] = np.minimum(dp[v:], dp[:-v] + w)\n\n\n\n    ans = 0\n\n    for i, w in enumerate(dp):\n\n        if w <= W:\n\n            ans = i\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "generated_code": "#!/usr/bin/env python3\n\ndef main():\n\n    import numpy as np\n\n\n\n    N, W = list(map(int, input().split()))\n\n    lst = [list(map(int, input().split())) for _ in range(N)]\n\n    v_max = 10 ** 3 * 100 * 10\n\n    w_max = 10 ** 9 * v_max\n\n\n\n    # i以上の価値を持つときの最小重量\n\n    dp = np.full(v_max, w_max, dtype=np.int64)\n\n    # initialize\n\n    dp[0] = 0\n\n\n\n    for w, v in lst:\n\n        dp[v:] = np.minimum(dp[v:], dp[:-v] + w)\n\n\n\n    print((np.asarray(dp <= W).nonzero()[0].max()))\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 1.0, "surface_similarity": 0.9217252396166133}
{"id": "p02994_u844005364", "golden_code": "n, like = list(map(int, input().split()))\n\n\n\narr = [like + i for i in range(n)]\n\n\n\narr.sort(key=lambda x:abs(x))\n\n\n\nprint((sum(arr[1:])))\n", "generated_code": "n, like = list(map(int, input().split()))\n\narr = [like + i for i in range(n)]\n\narr.sort(key=abs)\n\nprint((sum(arr[1:])))\n", "score": 1.0, "surface_similarity": 0.8851449275362319}
{"id": "p02937_u296150111", "golden_code": "s=eval(input())\n\nt=eval(input())\n\ns*=2\n\nnext=[[-1]*26 for _ in range(len(s))]\n\nalph=[[]for _ in range(26)]\n\nfor i in range(len(s)):\n\n\talph[ord(s[i])-ord(\"a\")].append(i)\n\nfrom bisect import bisect_right\n\nfor i in range(len(s)//2):\n\n\tfor j in range(26):\n\n\t\tif len(alph[j])>bisect_right(alph[j],i):\n\n\t\t\tnext[i][j]=alph[j][bisect_right(alph[j],i)]\n\nans=1\n\nnow=len(s)//2-1\n\nfor x in t:\n\n\tr=ord(x)-ord(\"a\")\n\n\tnow=next[now][r]\n\n\tif now==-1:\n\n\t\tprint((-1))\n\n\t\texit()\n\n\tif now>=len(s)//2:\n\n\t\tans+=len(s)//2\n\n\t\tnow-=len(s)//2\n\nprint((ans+now-len(s)//2))", "generated_code": "#O(|S|log|s|)\n\ndef main():\n\n\ts=eval(input())\n\n\tt=eval(input())\n\n\tn=len(s)\n\n\tnow=-1\n\n\tans=1\n\n\tif not set(t)<=set(s):#tがsの部分集合でない\n\n\t\tprint((-1))\n\n\t\texit()\n\n\tfor x in t:\n\n\t\tnow=s.find(x,now+1)#nowより大きいところからxを探す\n\n\t\tif now==-1:#nowより大きいところでxが見つからなかったら\n\n\t\t\tans+=n\n\n\t\t\tnow=s.find(x)\n\n\tprint((ans+now))\n\nif __name__ == '__main__':\n\n\tmain()", "score": 1.0, "surface_similarity": 0.4332141696457589}
{"id": "p03371_u325282913", "golden_code": "A, B, C, X, Y = list(map(int, input().split()))\n\nans = float('inf')\n\nfor i in range(max(X,Y)+1):\n\n    cost = 2 * C * i + max(0,X-i)*A +max(0,Y-i)*B\n\n    ans = min(ans,cost)\n\nprint(ans)", "generated_code": "A, B, C, X, Y = list(map(int, input().split()))\n\ntmp = A*X + B*Y\n\nif X >= Y:\n\n    tmp = min(tmp,2*Y*C+(X-Y)*A)\n\nelse:\n\n    tmp = min(tmp,2*X*C+(Y-X)*B)\n\ntmp = min(tmp,max(X,Y)*2*C)\n\nprint(tmp)", "score": 1.0, "surface_similarity": 0.6701388888888888}
{"id": "p03828_u873917047", "golden_code": "#coding: UTF-8\n\nimport math\n\nN=int(eval(input()))\n\ndef prime_list(k):\n\n    lis=[True for i in range(1,k+1)]\n\n    lis[0]=False\n\n    for i in range(2,k+1):\n\n        j=2\n\n        while j*j<=i:\n\n            if i%j==0:\n\n                lis[i-1]=False\n\n                break\n\n            else:\n\n                j+=1\n\n    return lis\n\n#    print(lis)\n\ndef p_fact(k,N):\n\n    plist=prime_list(k)\n\n    lis=[0]*N\n\n    for i in range(0,k):\n\n        n=0\n\n        if plist[i]:\n\n            while k%(i+1)==0:\n\n                n+=1\n\n                k=k/(i+1)\n\n        lis[i]=n\n\n    return lis\n\nout_lis=[0]*N\n\nfor i in range(1,N+1):\n\n    input_lis=p_fact(i,N)\n\n    out_lis=[out_lis[j]+input_lis[j] for j in range(0,N)]\n\n#print(out_lis)\n\nout=1\n\nfor i in range(0,N):\n\n    out=out*(out_lis[i]+1)\n\nprint((out%1000000007))", "generated_code": "#coding: UTF-8\n\nimport math\n\nN=int(eval(input()))\n\ndef prime_list(k):\n\n    lis=[True for i in range(1,k+1)]\n\n    lis[0]=False\n\n    for i in range(2,k+1):\n\n        j=2\n\n        while j*j<=i:\n\n            if i%j==0:\n\n                lis[i-1]=False\n\n                break\n\n            else:\n\n                j+=1\n\n    return lis\n\n#    print(lis)\n\ndef p_fact(k,N,plist):\n\n#    plist=prime_list(k)\n\n    lis=[0]*N\n\n    for i in range(0,k):\n\n        n=0\n\n        if plist[i]:\n\n            while k%(i+1)==0:\n\n                n+=1\n\n                k=k/(i+1)\n\n        lis[i]=n\n\n    return lis\n\n#    print(lis)\n\nout_lis=[0]*N\n\nplist=prime_list(N)\n\nfor i in range(1,N+1):\n\n    input_lis=p_fact(i,N,plist)\n\n    out_lis=[out_lis[j]+input_lis[j] for j in range(0,N)]\n\n#print(out_lis)\n\nout=1\n\nfor i in range(0,N):\n\n    out=out*(out_lis[i]+1)\n\n#print(out%1000000007)\n\nprint((out%(10**9+7)))", "score": 1.0, "surface_similarity": 0.9555117579677919}
{"id": "p02245_u800534567", "golden_code": "import sys\n\nimport queue\n\n\n\nN = 3\n\nf= ''.join(sys.stdin.readline().split())\n\nf+= ''.join(sys.stdin.readline().split())\n\nf+= ''.join(sys.stdin.readline().split())\n\n\n\ndd = [[-1, 0], [0, -1], [1, 0], [0, 1]]\n\n\n\nQ = queue.Queue()\n\nV = dict()\n\n\n\nQ.put([f,f.index('0'),0])\n\nV[f] = True\n\n\n\nwhile not Q.empty():\n\n    u = Q.get()\n\n    if u[0] == '123456780':  break\n\n    sx, sy = u[1]//N, u[1]%N\n\n    for dx, dy in dd:\n\n        tx, ty = sx+dx, sy+dy\n\n        if tx<0 or ty<0 or tx>=N or ty>=N: continue\n\n        v = u[:]\n\n        n1, n2 = u[1], tx*N+ty\n\n        v[1] = n2\n\n        if n1>n2: n1, n2 = n2, n1\n\n        v[0] = v[0][0:n1]+v[0][n2]+v[0][n1+1:n2]+v[0][n1]+v[0][n2+1:]\n\n        if not V.get(v[0], False):\n\n            V[v[0]] = True\n\n            v[2] += 1                                                    \n\n            Q.put(v)\n\n\n\nprint((u[2]))\n", "generated_code": "import sys\n\nimport queue\n\n\n\nN = 3\n\n\n\nf = ''.join(sys.stdin.readline().split())\n\nf += ''.join(sys.stdin.readline().split())\n\nf += ''.join(sys.stdin.readline().split())\n\n\n\ndd = [[-1, 0], [0, -1], [1, 0], [0, 1]]\n\n\n\nQ = [[f,f.index('0'),0]]\n\nV = { f: True }\n\n\n\nwhile len(Q)>0:\n\n    u = Q.pop(0)\n\n    if u[0] == '123456780':  break\n\n    sx, sy = u[1]//N, u[1]%N\n\n    for dx, dy in dd:\n\n        tx, ty = sx+dx, sy+dy\n\n        if tx<0 or ty<0 or tx>=N or ty>=N: continue\n\n        v = u[:]\n\n        n1, n2 = u[1], tx*N+ty\n\n        v[1] = n2\n\n        if n1>n2: n1, n2 = n2, n1\n\n        v[0] = v[0][0:n1]+v[0][n2]+v[0][n1+1:n2]+v[0][n1]+v[0][n2+1:]\n\n        if not V.get(v[0], False):\n\n            V[v[0]] = True\n\n            v[2] += 1 # dir[r]                                                       \n\n            Q.append(v)\n\n\n\nprint((u[2]))\n", "score": 1.0, "surface_similarity": 0.9543745727956254}
{"id": "p02899_u484780899", "golden_code": "import numpy as np\n\n\n\nN = int(input())\n\n\n\nA = np.array([int(i) for i in input().split()])\n\n\n\nx = np.argsort(A)\n\nx += 1\n\n\n\nfor i in range(N):\n\n    print(x[i], end=\" \")\n\n    \n\nprint()\n", "generated_code": "N = int(eval(input()))\n\n\n\nA = [int(i) for i in input().split()]\n\n\n\nB = [0]*N\n\nfor i in range(N):\n\n    B[A[i]-1] = i+1\n\n\n\nfor i in range(N):\n\n    print((B[i]))\n", "score": 1.0, "surface_similarity": 0.6172957477305303}
{"id": "p03854_u002459665", "golden_code": "def main():\n\n    S = eval(input())\n\n    w1 = 'dream'[::-1]\n\n    w2 = 'dreamer'[::-1]\n\n    w3 = 'erase'[::-1]\n\n    w4 = 'eraser'[::-1]\n\n    # print(w1,w2,w3,w4)\n\n    S = S[::-1]\n\n    # print(S)\n\n\n\n    # words = ['dream', 'dreamer', 'erase', 'eraser']\n\n    words = [w1, w2, w3, w4]\n\n    T = ''\n\n    while S != T:\n\n        cand = []\n\n        for w in words:\n\n            new_t = T + w\n\n            cand.append(new_t) \n\n        # print('cand', cand)\n\n        ans = False\n\n        for c in cand:\n\n            if c == S[:len(c)]:\n\n                T = c\n\n                ans = True\n\n\n\n        if not ans:\n\n            break\n\n\n\n    if S == T:\n\n        print('YES')\n\n    else:\n\n        print(\"NO\")\n\n\n\nif __name__ == \"__main__\":\n\n    main()", "generated_code": "def main():\n\n    S = eval(input())\n\n    w1 = 'dream'[::-1]\n\n    w2 = 'dreamer'[::-1]\n\n    w3 = 'erase'[::-1]\n\n    w4 = 'eraser'[::-1]\n\n    S = S[::-1]\n\n    words = [w1, w2, w3, w4]\n\n\n\n    flag = False\n\n    i = 0\n\n    while i < len(S):\n\n        for w in words:\n\n            if S[i:].startswith(w):\n\n                i += len(w)\n\n                flag = True\n\n                break\n\n\n\n        if not flag:\n\n            print(\"NO\")\n\n            exit()\n\n        flag = False\n\n\n\n    print(\"YES\")\n\n\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()", "score": 1.0, "surface_similarity": 0.8450097847358121}
{"id": "p03806_u761320129", "golden_code": "N,MA,MB = list(map(int,input().split()))\n\nsrc = [tuple(map(int,input().split())) for i in range(N)]\n\n\n\nINF = 10**9\n\ndp = [[INF for j in range(401)] for i in range(401)]\n\ndp[0][0] = 0\n\nmaxa = maxb = 0\n\nfor a,b,c in src:\n\n    for ai in range(maxa,-1,-1):\n\n        for bi in range(maxb,-1,-1):\n\n            dp[ai+a][bi+b] = min(dp[ai+a][bi+b], dp[ai][bi] + c)\n\n    maxa += a\n\n    maxb += b\n\n\n\nans = INF\n\nfor i in range(1,401):\n\n    if MA*i > 400 or MB*i > 400: break\n\n    ans = min(ans, dp[MA*i][MB*i])\n\nprint((-1 if ans == INF else ans))", "generated_code": "N,MA,MB = list(map(int,input().split()))\n\nsrc = [tuple(map(int,input().split())) for i in range(N)]\n\n\n\nINF = 10**9\n\nMAX = 401\n\ndp = [[INF] * MAX for i in range(MAX)]\n\ndp[0][0] = 0\n\namax = bmax = 0\n\nfor a,b,n in src:\n\n    for i in reversed(list(range(bmax+1))):\n\n        for j in range(amax+1):\n\n            if dp[i][j] == INF: continue\n\n            dp[i+b][j+a] = min(dp[i+b][j+a], dp[i][j] + n)\n\n    amax += a\n\n    bmax += b\n\n\n\nans = INF\n\nfor i in range(1,MAX):\n\n    if i*MA >= MAX or i*MB >= MAX: break\n\n    ans = min(ans, dp[i*MB][i*MA])\n\nprint((-1 if ans == INF else ans))", "score": 1.0, "surface_similarity": 0.8256786616161615}
{"id": "p03253_u638456847", "golden_code": "import sys\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\nreadlines = sys.stdin.readlines\n\n\n\nMOD = 10**9+7\n\n\n\nfac = [1, 1]     # 元テーブル\n\nf_inv = [1, 1]   # 逆元テーブル\n\ninv = [0, 1]     # 逆元テーブル計算用テーブル\n\ndef prepare(n, mod):\n\n    for i in range(2, n+1):\n\n        fac.append((fac[-1] * i) % mod)\n\n        inv.append((-inv[mod % i] * (mod//i)) % mod)\n\n        f_inv.append((f_inv[-1] * inv[-1]) % mod)\n\n\n\n\n\ndef cmb(n, r, mod):\n\n    if n < 0 or r < 0:\n\n        return 0\n\n    if r > n:\n\n        return 0\n\n\n\n    return fac[n] * f_inv[r] * f_inv[n-r] % mod\n\n\n\n\n\ndef prime_factorization(n):\n\n    d = []\n\n    i, e = 2, 0  # factor, exponent\n\n    while i * i <= n:\n\n        while n % i == 0:\n\n            n //= i\n\n            e += 1\n\n        if e > 0:\n\n            d.append((i, e))\n\n        i += 1\n\n        e = 0\n\n    if n > 1:\n\n        d.append((n, 1))\n\n    return d\n\n\n\n\n\ndef main():\n\n    N,M = list(map(int, readline().split()))\n\n\n\n    prepare(N+100, MOD)\n\n    d = prime_factorization(M)\n\n\n\n    ans = 1\n\n    for i, e in d:\n\n        ans *= cmb(N-1+e, e, MOD)\n\n        ans %= MOD\n\n\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "generated_code": "import sys\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\nreadlines = sys.stdin.readlines\n\n\n\nMOD = 10**9+7\n\n\n\nfac = [1, 1]     # 元テーブル\n\nf_inv = [1, 1]   # 逆元テーブル\n\ninv = [0, 1]     # 逆元テーブル計算用テーブル\n\ndef prepare(n, mod):\n\n    for i in range(2, n+1):\n\n        fac.append((fac[-1] * i) % mod)\n\n\n\n\n\ndef cmb(n, r, mod):\n\n    if n < 0 or r < 0:\n\n        return 0\n\n    if r > n:\n\n        return 0\n\n\n\n    return fac[n] * pow(fac[r],MOD-2,MOD) * pow(fac[n-r],MOD-2,MOD) % mod\n\n\n\n\n\ndef prime_factorization(n):\n\n    d = []\n\n    i, e = 2, 0  # factor, exponent\n\n    while i * i <= n:\n\n        while n % i == 0:\n\n            n //= i\n\n            e += 1\n\n        if e > 0:\n\n            d.append((i, e))\n\n        i += 1\n\n        e = 0\n\n    if n > 1:\n\n        d.append((n, 1))\n\n    return d\n\n\n\n\n\ndef main():\n\n    N,M = list(map(int, readline().split()))\n\n\n\n    prepare(N+100, MOD)\n\n    d = prime_factorization(M)\n\n\n\n    ans = 1\n\n    for i, e in d:\n\n        ans *= cmb(N-1+e, e, MOD)\n\n        ans %= MOD\n\n\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "score": 1.0, "surface_similarity": 0.9501763668430335}
{"id": "p03814_u678167152", "golden_code": "s = eval(input())\n\na = s.find('A')\n\nz = s[::-1].find('Z')\n\nans = len(s)-a-z\n\n\n\nprint(ans)\n\n\n\n#print(*ans, sep='\\n')", "generated_code": "def solve():\n\n  S = eval(input())\n\n  a = S.find('A')\n\n  z = S[::-1].find('Z')\n\n  ans = len(S)-a-z\n\n  return ans\n\nprint((solve()))", "score": 1.0, "surface_similarity": 0.7848837209302326}
{"id": "p03494_u729133443", "golden_code": "_,t=open(0);n=eval(t.replace(' ','|'));print((len(bin(n&-n))-3))", "generated_code": "n=eval([*open(0)][1].replace(*' |'))\n\nprint((len(bin(n&-n))-3))", "score": 1.0, "surface_similarity": 0.688733552631579}
{"id": "p02780_u293528047", "golden_code": "import numpy as np\n\n\n\nN, K= list(map(int, input().split()))\n\np = np.array(list(map(int, input().split())))\n\n\n\ntmp = np.sum(p[:K])\n\nmax = tmp\n\nfor i in range(N-K):\n\n    tmp = tmp-p[i]+p[i+K]\n\n    if tmp>max:\n\n        max = tmp\n\n\n\nprint(((max+K)/2))", "generated_code": "N, K= list(map(int, input().split()))\n\np = list(map(int, input().split()))\n\n\n\ntmp = sum(p[:K])\n\nmax = tmp\n\nfor i in range(N-K):\n\n    tmp = tmp-p[i]+p[i+K]\n\n    if tmp>max:\n\n        max = tmp\n\n\n\nprint(((max+K)/2))", "score": 1.0, "surface_similarity": 0.8978172856891392}
{"id": "p03309_u923662841", "golden_code": "import statistics\n\nN = int(eval(input()))\n\nA = [int(a)-i-1 for i,a in enumerate(input().split(),1)]\n\nb = statistics.median_low(A)\n\nc = statistics.median_high(A)\n\nd = sum([abs(x-b) for x in A])\n\ne = sum([abs(x-c) for x in A])\n\nprint((min(d,e)))", "generated_code": "N=int(eval(input()))\n\nA=sorted(a-i-1 for i,a in enumerate(map(int,input().split())))\n\nprint((sum(abs(a-A[N//2]) for a in A)))", "score": 1.0, "surface_similarity": 0.5554526748971194}
{"id": "p02690_u060793972", "golden_code": "x = int(eval(input()))\n\nfor i in range(-200,201):\n\n    for j in range(-200,201):\n\n        if (i**5)-(j**5)==x:\n\n            print((i,j))\n\n            exit()\n", "generated_code": "x = int(eval(input()))\n\nfor i in range(-120,121):\n\n    for j in range(-120,121):\n\n        if (i**5)-(j**5)==x:\n\n            print((i,j))\n\n            exit()\n", "score": 1.0, "surface_similarity": 0.9745222929936306}
{"id": "p03416_u294385082", "golden_code": "a,b = list(map(int,input().split()))\n\nc = 0\n\n\n\nfor i in range(a,b+1):\n\n  new = list(reversed(list(str(i))))\n\n  if new == list(str(i)):\n\n    c += 1\n\n    \n\n    \n\nprint(c)", "generated_code": "a,b = list(map(int,input().split()))\n\nc = 0\n\n\n\nfor i in range(a,b+1):\n\n  if list(str(i)) == list(str(i))[::-1]:\n\n    c += 1\n\n    \n\n    \n\nprint(c)", "score": 1.0, "surface_similarity": 0.8125}
{"id": "p03013_u325282913", "golden_code": "import sys\n\ninput = sys.stdin.readline\n\nN, M = list(map(int,input().split()))\n\nhole = [0] * (N+1)\n\nfor i in range(M):\n\n    hole[int(eval(input()))] = 1\n\nif N == 1:\n\n    print((1))\n\n    exit()\n\nif N == 2:\n\n    if hole[1] == 1:\n\n        print((1))\n\n        exit()\n\n    if hole[1] == 0:\n\n        print((2))\n\n        exit()\n\nflg_one = False\n\nflg_two = False\n\nfirst = 1\n\nsecond = 2\n\nif hole[1] == 1:\n\n    first = 0\n\n    second = 1\n\n    flg_one = True\n\nif hole[2] == 1:\n\n    first = 1\n\n    second = 0\n\n    flg_two = True\n\nif flg_one and flg_two:\n\n    print((0))\n\n    exit()\n\n\n\nfor i in range(3,N):\n\n    if hole[i] == 1:\n\n        first = second\n\n        second = 0\n\n        continue\n\n    tmp = first + second\n\n    tmp %= 1000000007\n\n    first = second\n\n    second = tmp\n\ntmp = first + second\n\ntmp %= 1000000007\n\nprint(tmp)", "generated_code": "MOD = 10**9 + 7\n\nN, M = list(map(int, input().split()))\n\nstairs = [0]*(N+1)\n\nfor _ in range(M):\n\n    stairs[int(eval(input()))] = 1\n\nif N == 1:\n\n    print((1))\n\n    exit()\n\nans = [0]*(N+1)\n\nans[1] = 1 if stairs[1] == 0 else 0\n\nans[2] = 1 + ans[1] if stairs[2] == 0 else 0\n\nfor i in range(3,N+1):\n\n    if stairs[i] == 1:\n\n        ans[i] = 0\n\n        continue\n\n    ans[i] = (ans[i-1] + ans[i-2]) % MOD\n\nprint((ans[N]))", "score": 1.0, "surface_similarity": 0.6445807770961145}
{"id": "p03558_u585482323", "golden_code": "#!usr/bin/env python3\n\nfrom collections import defaultdict\n\nfrom collections import deque\n\nfrom heapq import heappush, heappop\n\nimport sys\n\nimport math\n\nimport bisect\n\nimport random\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\n\ndef I(): return int(sys.stdin.readline())\n\ndef LS():return list(map(list, sys.stdin.readline().split()))\n\ndef S(): return list(sys.stdin.readline())[:-1]\n\ndef IR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = I()\n\n    return l\n\ndef LIR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = LI()\n\n    return l\n\ndef SR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = S()\n\n    return l\n\ndef LSR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = SR()\n\n    return l\n\nmod = 1000000007\n\n\n\n#A\n\ndef A():\n\n    s = S()\n\n    t = S()\n\n    if s+t == t[::-1]+s[::-1]:\n\n        print(\"YES\")\n\n    else:\n\n        print(\"NO\")\n\n\n\n#B\n\ndef B():\n\n    n = I()\n\n    for i in range(int(n**0.5)+2)[::-1]:\n\n        if i*i <= n:\n\n            print((i*i))\n\n            quit()\n\n#C\n\ndef C():\n\n    n = I()\n\n    a = LI()\n\n    b = LI()\n\n    c = LI()\n\n    q = [0 for i in range(n)]\n\n    ans = 0\n\n    a.sort()\n\n    b.sort()\n\n    c.sort()\n\n    for i in range(n):\n\n        j = bisect.bisect_left(a,b[i])\n\n        q[i] = j\n\n    for i in range(n-1):\n\n        q[i+1] += q[i]\n\n    q.insert(0,0)\n\n    for i in range(n):\n\n        j = bisect.bisect_left(b,c[i])\n\n        ans += q[j]\n\n    print(ans)\n\n#D\n\ndef D():\n\n    def dijkstra():\n\n        d = [float(\"inf\") for i in range(k)]\n\n        q = [[0,1]]\n\n        d[1] = 0\n\n        while q:\n\n            dx,x = heappop(q)\n\n            for y,dy in v[x]:\n\n                if d[y] > dx+dy:\n\n                    d[y] = dx+dy\n\n                    heappush(q,[d[y],y])\n\n        print((d[0]+1))\n\n    k = I()\n\n    if k == 1:\n\n        print((1))\n\n        quit()\n\n    v = [[] for i in range(k)]\n\n    for i in range(1,k):\n\n        v[i].append([(i+1)%k,1])\n\n        v[i].append([i*10%k,0])\n\n    dijkstra()\n\n#E\n\ndef E():\n\n    return\n\n\n\n#F\n\ndef F():\n\n    return\n\n\n\n#G\n\ndef G():\n\n    return\n\n\n\n#H\n\ndef H():\n\n    return\n\n\n\n#Solve\n\nif __name__ == \"__main__\":\n\n    D()\n", "generated_code": "#!usr/bin/env python3\n\nfrom collections import defaultdict,deque\n\nfrom heapq import heappush, heappop\n\nfrom itertools import permutations\n\nimport sys\n\nimport math\n\nimport bisect\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\n\ndef I(): return int(sys.stdin.readline())\n\ndef LS():return [list(x) for x in sys.stdin.readline().split()]\n\ndef S():\n\n    res = list(sys.stdin.readline())\n\n    if res[-1] == \"\\n\":\n\n        return res[:-1]\n\n    return res\n\ndef IR(n):\n\n    return [I() for i in range(n)]\n\ndef LIR(n):\n\n    return [LI() for i in range(n)]\n\ndef SR(n):\n\n    return [S() for i in range(n)]\n\ndef LSR(n):\n\n    return [LS() for i in range(n)]\n\n\n\nsys.setrecursionlimit(1000000)\n\nmod = 1000000007\n\n\n\ndef solve():\n\n    def v(n):\n\n        return [n*10%k, (n+1)%k]\n\n    k = I()\n\n    d = [float(\"inf\")]*k\n\n    d[1] = 1\n\n    q = deque([1])\n\n    while q:\n\n        x = q.popleft()\n\n        vx = v(x)\n\n        dx = d[x]\n\n        for c in range(2):\n\n            nd = dx+c\n\n            y = vx[c]\n\n            if nd < d[y]:\n\n                d[y] = nd\n\n                if c:\n\n                    q.append(y)\n\n                else:\n\n                    q.appendleft(y)\n\n    print((d[0]))\n\n    return\n\n\n\n#Solve\n\nif __name__ == \"__main__\":\n\n    solve()\n", "score": 1.0, "surface_similarity": 0.7120391705069125}
{"id": "p02994_u815878613", "golden_code": "import sys\n\nimport numpy as np\n\n\n\nN, L = list(map(int, input().split()))\n\n\n\n# 味\n\nLL = np.arange(L,L+N)\n\n\n\nm = abs(LL[0])\n\n\n\nfor i in range(N):\n\n    if abs(m) > abs(LL[i]):\n\n        m = LL[i]\n\n\n\nprint((np.sum(LL)-m))\n", "generated_code": "N, L = list(map(int, input().split()))\n\n\n\nA = [i for i in range(L, L + N)]\n\n\n\nif A[0] < 0:\n\n    if A[-1] < 0:\n\n        print((sum(A) - max(A)))\n\n    else:\n\n        print((sum(A)))\n\nelse:\n\n    print((sum(A) - min(A)))\n", "score": 1.0, "surface_similarity": 0.575771003190358}
{"id": "p03796_u089230684", "golden_code": "import math\n\nx = int(eval(input()))\n\nprint((math.factorial(x) % (10**9 + 7)))", "generated_code": "n = int(eval(input()))\n\nfact = 1\n\nfor i in range(1,n+1):\n\n  fact = fact * i % (10**9 +7)\n\nres = fact % (10**9 + 7)\n\nprint(res)", "score": 1.0, "surface_similarity": 0.5791316526610644}
{"id": "p02537_u545368057", "golden_code": "import sys\n\ninput = sys.stdin.readline\n\n\n\nn,k = list(map(int, input().split()))\n\nAs = [int(eval(input())) for i in range(n)]\n\n\n\n# N: 処理する区間の長さ\n\n\n\nINF = 0\n\n\n\nmx = 300001\n\nLV = (mx-1).bit_length()\n\nN0 = 2**LV\n\ndata = [INF]*(2*N0)\n\nlazy = [None]*(2*N0)\n\n\n\n# 伝搬対象の区間を求める\n\ndef gindex(l, r):\n\n    L = (l + N0) >> 1; R = (r + N0) >> 1\n\n    lc = 0 if l & 1 else (L & -L).bit_length()\n\n    rc = 0 if r & 1 else (R & -R).bit_length()\n\n    for i in range(LV):\n\n        if rc <= i:\n\n            yield R\n\n        if L < R and lc <= i:\n\n            yield L\n\n        L >>= 1; R >>= 1\n\n\n\n# 遅延伝搬処理\n\ndef propagates(*ids):\n\n    for i in reversed(ids):\n\n        v = lazy[i-1]\n\n        if v is None:\n\n            continue\n\n        lazy[2*i-1] = data[2*i-1] = lazy[2*i] = data[2*i] = v\n\n        lazy[i-1] = None\n\n\n\n# 区間[l, r)をxで更新\n\ndef update(l, r, x):\n\n    *ids, = gindex(l, r)\n\n    propagates(*ids)\n\n\n\n    L = N0 + l; R = N0 + r\n\n    while L < R:\n\n        if R & 1:\n\n            R -= 1\n\n            lazy[R-1] = data[R-1] = x\n\n        if L & 1:\n\n            lazy[L-1] = data[L-1] = x\n\n            L += 1\n\n        L >>= 1; R >>= 1\n\n    for i in ids:\n\n        data[i-1] = max(data[2*i-1], data[2*i])\n\n\n\n# 区間[l, r)内の最小値を求める\n\ndef query(l, r):\n\n    propagates(*gindex(l, r))\n\n    L = N0 + l; R = N0 + r\n\n\n\n    s = INF\n\n    while L < R:\n\n        if R & 1:\n\n            R -= 1\n\n            s = max(s, data[R-1])\n\n        if L & 1:\n\n            s = max(s, data[L-1])\n\n            L += 1\n\n        L >>= 1; R >>= 1\n\n    return s\n\n\n\nans = 0\n\nupdate(As[0],As[0]+1,1)\n\nfor i, a in enumerate(As[1:]):\n\n    l = max(0,a-k)\n\n    r = min(mx,a+k)\n\n    upd = query(l,r+1)\n\n    if upd == -1:continue\n\n    # print(\"i\",i,\"a\",a,\"upd\",upd,\"l\",l,\"r\",r)\n\n    update(a, a+1, upd+1)\n\n    ans = max(ans, upd+1)\n\nprint(ans)\n\n\n", "generated_code": "# セグメント木\n\n# segment tree\n\nimport sys\n\ninput = sys.stdin.readline\n\n\n\nclass segmented_tree:\n\n    X_unit = 0\n\n    X_f = lambda self, a, b: max(a,b)\n\n    def __init__(self, N):\n\n        self.N = N\n\n        self.X = [self.X_unit] * (2*N)\n\n        \n\n    def build(self, seq):\n\n        for i, x in enumerate(seq, self.N):\n\n            self.X[i] = x \n\n        # 後ろから入れていく\n\n        for i in range(self.N-1, 0, -1):\n\n            self.X[i] = self.X_f(self.X[i<<1], self.X[i<<1|1])\n\n\n\n    # 1点更新\n\n    def set_val(self, i, x):\n\n        i += self.N\n\n        self.X[i] = x\n\n        while i > 1:\n\n            i >>= 1\n\n            self.X[i] = self.X_f(self.X[i<<1],self.X[i<<1|1])\n\n    \n\n    # 区間取得\n\n    def fold(self, l, r):\n\n        l += self.N\n\n        r += self.N\n\n        vl = self.X_unit\n\n        vr = self.X_unit\n\n        # 外から決めていく\n\n        while l < r:\n\n            # print(l,r)\n\n            if l & 1:\n\n                vl = self.X_f(vl, self.X[l])\n\n                l += 1\n\n            if r & 1:\n\n                r -= 1\n\n                vr = self.X_f(vr, self.X[r])\n\n            l >>= 1\n\n            r >>= 1\n\n        return self.X_f(vl,vr)\n\n\n\nn,k = list(map(int, input().split()))\n\nAs = [int(eval(input())) for i in range(n)]\n\nmx = 300001\n\nans = 0\n\nsg = segmented_tree(330000)\n\n\n\nfor a in As:\n\n    l = max(0,a-k)\n\n    r = min(mx,a+k)\n\n\n\n    upd = sg.fold(l,r+1)\n\n    ans = max(ans, upd+1)\n\n\n\n    sg.set_val(a, upd+1)\n\nprint(ans)\n\n\n", "score": 1.0, "surface_similarity": 0.6328779538873046}
{"id": "p02596_u164727245", "golden_code": "# coding: utf-8\n\n\n\n\n\ndef solve(*args: str) -> str:\n\n    k = int(args[0])\n\n\n\n    l = 9*(k//7 if k % 7 == 0 else k)\n\n    if l % 2 == 0 or l % 5 == 0:\n\n        return '-1'\n\n\n\n    r = phi = l\n\n    for i in range(2, int(-pow(l, 1/2))):\n\n        if r % i == 0:\n\n            phi = phi//i*(i-1)\n\n            while r % i:\n\n                r //= i\n\n\n\n    a = 10 % l\n\n    ret = 1\n\n    while(a != 1):\n\n        a = a*10 % l\n\n        ret += 1\n\n        if phi < ret:\n\n            ret = -1\n\n            break\n\n\n\n    return str(ret)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    print((solve(*(open(0).read().splitlines()))))\n", "generated_code": "# coding: utf-8\n\nfrom math import sqrt\n\n\n\n\n\ndef solve(*args: str) -> str:\n\n    k = int(args[0])\n\n\n\n    l = 9*(k//7 if 0 == k % 7 else k)\n\n    if 0 == l % 2 or 0 == l % 5:\n\n        return '-1'\n\n\n\n    r = phi = l\n\n    for i in range(2, int(sqrt(l)+1)):\n\n        if 0 == r % i:\n\n            phi = phi*(i-1)//i\n\n            while 0 == r % i:\n\n                r //= i\n\n    if 1 < r:\n\n        phi = phi*(r-1)//r\n\n\n\n    D = set()\n\n    for d in range(1, int(sqrt(phi)+1)):\n\n        if 0 == phi % d:\n\n            D.add(d)\n\n            D.add(phi//d)\n\n\n\n    ret = -1\n\n    for m in sorted(D):\n\n        if 1 == pow(10, m, l):\n\n            ret = m\n\n            break\n\n\n\n    return str(ret)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    print((solve(*(open(0).read().splitlines()))))\n", "score": 1.0, "surface_similarity": 0.8322705802968962}
{"id": "p02863_u440566786", "golden_code": "import sys\n\nsys.setrecursionlimit(2147483647)\n\nINF=float(\"inf\")\n\nMOD=10**9+7\n\ninput=lambda :sys.stdin.readline().rstrip()\n\ndef resolve():\n\n    n,T=list(map(int,input().split()))\n\n    AB=[tuple(map(int,input().split())) for _ in range(n)]\n\n    ans=-INF\n\n\n\n    # 何も考えずやる\n\n    dp=[0]*T\n\n    for i in range(n):\n\n        a,b=AB[i]\n\n        ndp=dp[:]\n\n        for t in range(T):\n\n            if(t+a<T):\n\n                ndp[t+a]=max(ndp[t+a],dp[t]+b)\n\n            else:\n\n                ans=max(ans,dp[t]+b)\n\n        dp=ndp\n\n    ans=max(ans,max(dp))\n\n\n\n    # 時間が最もかかるもののうち、価値が最大のものを最後にする\n\n    AB.sort()\n\n    la,lb=AB[-1]\n\n\n\n    dp=[0]*T\n\n    for i in range(n-1):\n\n        a,b=AB[i]\n\n        ndp=dp[:]\n\n        for t in range(T):\n\n            if(t+a<T):\n\n                ndp[t+a]=max(ndp[t+a],dp[t]+b)\n\n            else:\n\n                ans=max(ans,dp[t]+b)\n\n        dp=ndp\n\n    ans=max(ans,max(dp)+lb)\n\n\n\n    # 価値が最大のもののうち、時間が最もかかるものを最後にする\n\n    AB.sort(lambda x:(x[1],x[0]))\n\n    la,lb=AB[-1]\n\n\n\n    dp=[0]*T\n\n    for i in range(n-1):\n\n        a,b=AB[i]\n\n        ndp=dp[:]\n\n        for t in range(T):\n\n            if(t+a<T):\n\n                ndp[t+a]=max(ndp[t+a],dp[t]+b)\n\n            else:\n\n                ans=max(ans,dp[t]+b)\n\n        dp=ndp\n\n    ans=max(ans,max(dp)+lb)\n\n\n\n    print(ans)\n\nresolve()", "generated_code": "import sys\n\nsys.setrecursionlimit(2147483647)\n\nINF=float(\"inf\")\n\nMOD=10**9+7\n\ninput=lambda :sys.stdin.readline().rstrip()\n\ndef resolve():\n\n    n,T=list(map(int,input().split()))\n\n    AB=[tuple(map(int,input().split())) for _ in range(n)]\n\n    AB.sort()\n\n\n\n    dp=[0]*T\n\n    ans=-INF\n\n    for i in range(n):\n\n        a,b=AB[i]\n\n        ndp=dp[:]\n\n        for t in range(T):\n\n            if(t+a<T):\n\n                ndp[t+a]=max(ndp[t+a],dp[t]+b)\n\n            else:\n\n                ans=max(ans,dp[t]+b)\n\n        dp=ndp\n\n    print((max(ans,max(dp))))\n\nresolve()", "score": 1.0, "surface_similarity": 0.8171545968156138}
{"id": "p03013_u618107373", "golden_code": "import sys\n\nsys.setrecursionlimit(100000)\n\n\n\ndef intinput(): return list(map(int,sys.stdin.readline().split()))\n\n\n\nfib={0:0,1:1,2:1}\n\nfor i in range(3,100003):\n\n    fib[i]=fib[i-1]+fib[i-2]\n\n  #  fib.append(fib[i-1]+fib[i-2])\n\n\n\nn,m=intinput()\n\nmod=10**9+7\n\na=[int(sys.stdin.readline()) for _ in range(m)]\n\nif m!=0:\n\n    l=[a[0]]\n\n    for i in range(len(a)-1):\n\n        l.append(a[i+1]-a[i]-1)\n\n    l.append(n-a[-1])\n\n    k=1\n\n    for i in l:\n\n        k=fib[i]*k%mod\n\n    print((k%mod))\n\nelse:\n\n    print((fib[n+1]%mod))", "generated_code": "import sys\n\nsys.setrecursionlimit(100000)\n\n\n\ndef intinput(): return list(map(int,sys.stdin.readline().split()))\n\n\n\n\n\nn, m = intinput()\n\na = {int(sys.stdin.readline()) for _ in range(m)}\n\nmemo = [0 for x in range(n + 4)]\n\nmemo[0] = 1\n\nmod = 10 ** 9 + 7\n\nfor i in range(n):\n\n    if i + 1 not in a:\n\n        memo[i + 1] = (memo[i + 1] + memo[i]) % mod\n\n    if i + 2 not in a:\n\n        memo[i + 2] = (memo[i + 2] + memo[i]) % mod\n\nprint((memo[n]))", "score": 1.0, "surface_similarity": 0.6666208791208792}
{"id": "p03013_u254871849", "golden_code": "import sys\n\n\n\nmod = 10 ** 9 + 7\n\nn, m, *a = [int(x) for x in sys.stdin.read().split()]\n\n\n\nsafe = sorted(set(range(1,n+1)) - set(a))\n\ndp = [0] * (n + 2)\n\ndp[0] = 0\n\ndp[1] = 1\n\nfor i in safe:\n\n    dp[i+1] = (dp[i] + dp[i-1]) % mod\n\n\n\nprint((dp[-1]))", "generated_code": "\n\n# 2019-11-14 10:01:24(JST)\n\nimport sys\n\n# import collections\n\n# import math\n\n# from string import ascii_lowercase, ascii_uppercase, digits\n\n# from bisect import bisect_left as bi_l, bisect_right as bi_r\n\n# import itertools\n\n# from functools import reduce\n\n# import operator as op\n\n# from scipy.misc import comb # float\n\n# import numpy as np \n\n\n\nmod = 10 ** 9 + 7\n\ndef main():\n\n    n, m, *a = [int(x) for x in sys.stdin.read().split()]\n\n\n\n    safe = sorted(set(range(1,n+1)) - set(a))\n\n    dp = [0] * (n + 2) # dp[i+1]: i段目までいくパターン数\n\n    dp[0] = 0  # -1段目にはいけない\n\n    dp[1] = 1  # 初期条件(0段目にいる)\n\n    for i in safe:\n\n        dp[i+1] = (dp[i] + dp[i-1]) % mod\n\n\n\n    print((dp[-1]))\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "score": 1.0, "surface_similarity": 0.8927891274238227}
{"id": "p02767_u732061897", "golden_code": "N = int(eval(input()))\n\nA = list(map(int, input().split()))\n\nanswer = 10 ** 9\n\nfor i in range(1,101):\n\n    tmp = 0\n\n    for a in A:\n\n        tmp += abs(a-i) ** 2\n\n    answer = min(answer,tmp)\n\nprint(answer)", "generated_code": "N = int(eval(input()))\n\nA = list(map(int, input().split()))\n\nchushin = sum(A)//N\n\nchushin_1 = sum(A)//N +1\n\nanswer = 0\n\nanswer_1 = 0\n\nfor a in A:\n\n    answer += abs(a-chushin) ** 2\n\n    answer_1 += abs(a-chushin_1) ** 2\n\nprint((min(answer,answer_1)))", "score": 1.0, "surface_similarity": 0.77675}
{"id": "p02691_u227020436", "golden_code": "# E - This Message Will Self-Distruct in 5s\n\n\n\nfrom collections import Counter\n\n\n\nn = int(eval(input()))\n\na = list(map(int, input().split()))\n\nassert len(a) == n\n\n\n\n# Ai + Aj == j - i\n\n# Aj - j == -Ai - i\n\n\n\n# Aj - j の各値の個数\n\ndiff = Counter(a[j] - (j+1) for j in range(n))\n\n\n\n# 各Aiについて Aj - j == -Ai - i となるjの個数を数える\n\ncount = 0\n\nfor i in range(n):\n\n    diff[a[i] - (i+1)] -= 1  # i自身を取り除く\n\n    count += diff[-a[i] - (i+1)]\n\n\n\nprint(count)\n", "generated_code": "# E - This Message Will Self-Distruct in 5s\n\n\n\nfrom collections import Counter\n\n\n\nn = int(eval(input()))\n\na = list(map(int, input().split()))\n\nassert len(a) == n\n\n\n\n# Aj - j の各値の個数\n\ndiff = Counter(a[j] - (j+1) for j in range(n))\n\n\n\n# Aj - j == -Ai - i となる(i,j)の個数\n\ncount = sum(diff[-a[i] - (i+1)] for i in range(n))\n\nprint(count)\n", "score": 1.0, "surface_similarity": 0.9130892448512586}
{"id": "p02850_u606045429", "golden_code": "\"\"\"\n\nchallenge case\n\n\n\nin:\n\n3\n\n1 3\n\n2 3\n\n\n\nout:\n\n1\n\n1\n\n1\n\n\"\"\"\n\n\n\nfrom collections import deque\n\n\n\ndef main():\n\n\tN, *AB = list(map(int, open(0).read().split()))\n\n\tB = AB[1::2]\n\n\n\n\tE = [[] for _ in range(N + 1)]\n\n\tfor a, b in zip(*[iter(AB)] * 2):\n\n\t\tE[a] += b,\n\n\n\n\tQ = deque([1])\n\n\tC = [0] * (N + 1)\n\n\twhile Q:\n\n\t\tv = Q.popleft()\n\n\t\tc = 0\n\n\t\tfor u in E[v]:\n\n\t\t\tc += 1 + (c + 1 == C[v])\n\n\t\t\tC[u] = c\n\n\t\t\tQ += u,\n\n\n\n\tprint((max(C)))\n\n\tfor b in B:\n\n\t\tprint((C[b]))\n\n\n\nmain()", "generated_code": "\"\"\"\n\nchallenge case\n\n\n\nin:\n\n3\n\n1 3\n\n2 3\n\n\n\nout:\n\n1\n\n1\n\n1\n\n\"\"\"\n\n\n\nfrom collections import deque\n\n\n\ndef main():\n\n\tN, *AB = list(map(int, open(0).read().split()))\n\n\tB = AB[1::2]\n\n\n\n\tE = [[] for _ in range(N + 1)]\n\n\tfor a, b in zip(*[iter(AB)] * 2):\n\n\t\tE[a].append(b)\n\n\n\n\tQ = deque([1])\n\n\tC = [0] * (N + 1)\n\n\twhile Q:\n\n\t\tv = Q.popleft()\n\n\t\tc = 0\n\n\t\tfor u in E[v]:\n\n\t\t\tc += 1 + (c + 1 == C[v])\n\n\t\t\tC[u] = c\n\n\t\t\tQ.append(u)\n\n\n\n\tprint((max(C)))\n\n\tfor b in B:\n\n\t\tprint((C[b]))\n\n\n\nmain()", "score": 1.0, "surface_similarity": 0.9811715481171548}
{"id": "p03253_u648212584", "golden_code": "import sys\n\ninput = sys.stdin.buffer.readline\n\nfrom collections import defaultdict\n\nimport copy\n\n\n\ndef main():\n\n    N,M = list(map(int,input().split()))\n\n    d = defaultdict(int)\n\n    MOD = 10**9+7\n\n    R = 10**5+100\n\n    fac = [0 for _ in range(R+1)]\n\n    fac[0],fac[1] = 1,1\n\n    inv = copy.deepcopy(fac)\n\n    invfac = copy.deepcopy(fac)\n\n    \n\n    for i in range(2,R+1):\n\n        fac[i] = (fac[i-1]*i)%MOD\n\n        inv[i] = MOD-(MOD//i)*inv[MOD%i]%MOD\n\n        invfac[i] = (invfac[i-1]*inv[i])%MOD\n\n        \n\n    def coef(x,y):\n\n        num = (((fac[x+y]*invfac[y])%MOD)*invfac[x]%MOD)\n\n        return num\n\n\n\n    while M%2 == 0:\n\n        d[2] += 1\n\n        M //= 2\n\n    f = 3\n\n    while f ** 2 <= M:\n\n        if M % f == 0:\n\n            d[f] += 1\n\n            M //= f\n\n        else:\n\n            f += 2\n\n    if M != 1:\n\n        d[M] += 1\n\n    \n\n    l = list(d.values())\n\n    ans = 1\n\n    for num in l:\n\n        ans *= coef(num,N-1)\n\n        ans %= MOD\n\n        \n\n    print(ans)\n\n    \n\nif __name__ == \"__main__\":\n\n    main()", "generated_code": "import sys\n\ninput = sys.stdin.buffer.readline\n\n\n\ndef main():\n\n    N,M = list(map(int,input().split()))\n\n    MOD = 10**9+7\n\n    \n\n    def factorization(n):\n\n        arr = []\n\n        temp = n\n\n        for i in range(2, int(-(-n**0.5//1))+1):\n\n            if temp%i==0:\n\n                cnt=0\n\n                while temp%i==0:\n\n                    cnt+=1\n\n                    temp //= i\n\n                arr.append([i, cnt])\n\n\n\n        if temp!=1:\n\n            arr.append([temp, 1])\n\n\n\n        return arr\n\n        \n\n    cl = factorization(M)\n\n    \n\n    def combinations(x,y,N):\n\n        fac = [0]*(N+1)\n\n        fac[0],fac[1] = 1,1\n\n        \n\n        for i in range(2,N+1):\n\n            fac[i] = (fac[i-1]*i)%MOD\n\n            \n\n        return (fac[x+y]*pow(fac[x],MOD-2,MOD)*pow(fac[y],MOD-2,MOD))%MOD\n\n        \n\n    ans = 1\n\n    for pr,num in cl:\n\n        ans *= combinations(N-1,num,N+num)\n\n        ans %= MOD\n\n    \n\n    print(ans)\n\n    \n\nif __name__ == \"__main__\":\n\n    main()\n", "score": 1.0, "surface_similarity": 0.7011920827710301}
{"id": "p03575_u074220993", "golden_code": "N, M = (int(x) for x in input().split())\n\nedge = [tuple(int(x) for x in input().split()) for _ in range(M)]\n\n\n\nimport numpy as np\n\nfrom scipy.sparse.csgraph import floyd_warshall\n\nINF = 100\n\ntmpl_graph = [[INF if i != j else 0 for j in range(N)] for i in range(N)]\n\n\n\nans = 0\n\nfor E in edge:\n\n    edgeWithoutE = edge.copy()\n\n    edgeWithoutE.remove(E)\n\n    graph = np.array(tmpl_graph)\n\n    for x in edgeWithoutE:\n\n        graph[x[0]-1,x[1]-1] = 1\n\n        graph[x[1]-1,x[0]-1] = 1\n\n    graph = floyd_warshall(graph,directed=False)\n\n    if len(graph[graph == 100]) > 0:\n\n        ans += 1\n\nprint(ans)", "generated_code": "\n\nclass node:\n\n    def __init__(self, id):\n\n        self.id = id\n\n        self.root = self\n\n\n\n    def findRoot(self):\n\n        if self == self.root:\n\n            return self\n\n        else:\n\n            self.root = self.root.findRoot()\n\n            return self.root\n\n\n\n    def resetRoot(self):\n\n        self.root = self\n\n\n\nclass Tree:\n\n    def __init__(self, num):\n\n        self.nodes = {i:node(i) for i in range(num)}\n\n\n\n    def union(self, one, other):\n\n        root1 = one.findRoot()\n\n        root2 = other.findRoot()\n\n        root1.root = root2.root = self.nodes[min(root1.id, root2.id)]\n\n\n\n    def resetTree(self):\n\n        for n in list(self.nodes.values()):\n\n            n.resetRoot()\n\n\n\n    def makeTree(self, Edge):\n\n        self.edge = Edge\n\n        for x,y in Edge:\n\n            self.union(self.nodes[x-1], self.nodes[y-1])\n\n\n\n\n\ndef main():\n\n    with open(0) as f:\n\n        N, M = list(map(int, f.readline().split()))\n\n        Edge = [tuple(map(int, line.split())) for line in f.readlines()]\n\n    \n\n    tree = Tree(N)\n\n    ans = 0\n\n    for i in range(M):\n\n        edge = [v for  v in Edge if v != Edge[i]]\n\n        tree.makeTree(edge)\n\n        if any(x.findRoot().id != 0 for x in list(tree.nodes.values())):\n\n            ans += 1\n\n        tree.resetTree()\n\n    print(ans)\n\n\n\nif __name__ == '__main__':\n\n    main()", "score": 1.0, "surface_similarity": 0.5431308634123072}
{"id": "p03107_u440161695", "golden_code": "from collections import Counter\n\nd={chr(i):0 for i in range(2)}\n\ns=Counter(eval(input()))\n\nd=d.update(s)\n\nprint((min(s[\"0\"],s[\"1\"])*2))", "generated_code": "s=eval(input())\n\nprint((min(s.count(\"0\"),s.count(\"1\"))*2))", "score": 1.0, "surface_similarity": 0.47908496732026146}
{"id": "p03000_u841531687", "golden_code": "import bisect\n\n\n\nN, X = list(map(int, input().split()))\n\nl = list(map(int, input().split()))\n\nd = [-1]*(N+1) #0-index #バウンドする位置を格納するリスト\n\nd[0] = 0 #バウンドする初期値は0\n\n\n\nfor i in range(1, N+1):\n\n    d[i] = d[i-1] + l[i-1]\n\n\n\n#print(d)\n\n#print('left:', bisect.bisect_left(d, X))\n\n#print('right:', bisect.bisect_right(d, X))\n\nprint((bisect.bisect_right(d, X)))", "generated_code": "import bisect\n\n\n\nn,x = list(map(int, input().split()))\n\nl = tuple(map(int, input().split()))\n\n\n\nd = [-1]*(n+1)\n\nd[0] = 0\n\nfor i in range(1, n+1):\n\n    d[i] = d[i-1] + l[i-1]\n\nres = bisect.bisect_right(sorted(d), x)\n\nprint(res)", "score": 1.0, "surface_similarity": 0.9514285714285714}
{"id": "p02690_u017415492", "golden_code": "import numpy as np\n\nx=int(eval(input()))\n\n#ａ⁵－ｂ⁵＝(ａ－ｂ)(ａ⁴＋ａ³ｂ＋ａ²ｂ²＋ａｂ³＋ｂ⁴)\n\ndef make_divisors(n):\n\n    divisors = []\n\n    for i in range(1, int(n**0.5)+1):\n\n        if n % i == 0:\n\n            divisors.append(i)\n\n            if i != n // i:\n\n                divisors.append(n//i)\n\n    return divisors\n\nd=make_divisors(x)\n\nfor i in range(len(d)):\n\n  d.append(-d[i])\n\nflag=False\n\n\n\nfor i in d:\n\n  if flag==True:\n\n    break\n\n  tui=x//i\n\n  ans=np.roots([5,10*i,10*i**2,5*i**3,i**4-tui])\n\n  for j in ans:\n\n    if flag==True:\n\n      break\n\n    if j.imag==0:\n\n      a=i+round(j.real)\n\n    if a**5-(round(j.real))**5==x:\n\n      print((int(a),int(round(j.real))))\n\n      flag=True\n\n      break", "generated_code": "x=int(eval(input()))\n\nflag=True\n\nfor i in range(-118,120):\n\n  if flag==False:\n\n    break\n\n  for j in range(-119,119):\n\n    if x==(i**5-j**5):\n\n      print((i,j))\n\n      flag=False\n\n      break", "score": 1.0, "surface_similarity": 0.5162538699690402}
{"id": "p00145_u912237403", "golden_code": "from functools import reduce\ndef f(a,b): return [Card[a][0], Card[b][1]]\n\nn = int(input())\n\nCard = [[] for _ in [0]*n]\n\nCost = {}\n\nfor i in range(n):\n\n  Card[i] = list(map(int, input().split()))\n\n  Cost[(i, i)] = 0\n\nfor i in range(1, n):\n\n  for j in range(0, n-i):\n\n    a = j+i\n\n    Cost[(j, a)] = min([reduce(lambda a,b: a*b, f(j, k) + f(k+1, a)) + Cost[(j, k)] + Cost[(k+1, a)] for k in range(j, j+i)])\n\nprint(Cost[0, n-1])", "generated_code": "from functools import reduce\nn = int(input())\n\nCard = [[] for _ in [0]*n]\n\nCost = {}\n\nfor i in range(n):\n\n  Card[i] = list(map(int, input().split()))\n\n  Cost[(i, i)] = 0\n\nfor i in range(1, n):\n\n  for j in range(0, n-i):\n\n    a = j+i\n\n    Cost[(j, a)] = min([reduce(lambda a,b: a*b, [Card[j][0],Card[k][1],Card[k+1][0],Card[a][1]]) + Cost[(j, k)] + Cost[(k+1, a)] for k in range(j, j+i)])\n\nprint(Cost[0, n-1])", "score": 1.0, "surface_similarity": 0.8713445378151261}
{"id": "p03039_u532966492", "golden_code": "def cmb(n, r, mod):\n\n    if ( r<0 or r>n ):\n\n        return 0\n\n    r = min(r, n-r)\n\n    return g1[n] * g2[r] * g2[n-r] % mod\n\n\n\nA=2*10**5\n\nmod = 10**9+7\n\ng1 = [1, 1]\n\ng2 = [1, 1]\n\ninverse = [0, 1]\n\n\n\nfor i in range( 2, A + 1 ):\n\n    g1.append( ( g1[-1] * i ) % mod )\n\n    inverse.append( ( -inverse[mod % i] * (mod//i) ) % mod )\n\n    g2.append( (g2[-1] * inverse[-1]) % mod )\n\n\n\nN,M,K=list(map(int,input().split()))\n\nkeisuu=cmb(N*M-2,K-2,mod)\n\n\n\nsum_=0\n\nfor i in range(N):\n\n    a=min(abs(i),abs(N-i-1))\n\n    b=max(abs(i),abs(N-i-1))\n\n    sum_+=(M**2)*((a*(a+1)//2)+(b*(b+1)//2))\n\nfor i in range(M):\n\n    a=min(abs(i),abs(M-i-1))\n\n    b=max(abs(i),abs(M-i-1))\n\n    sum_+=(N**2)*((a*(a+1)//2)+(b*(b+1)//2))\n\nprint(((keisuu * (sum_//2))%mod))", "generated_code": "def power_mod(a,b,mod=10**9+7):\n\n    i,temp,box=0,b,[]\n\n    while(2**i<=b):\n\n        i+=1\n\n    for j in range(i-1,-1,-1):\n\n        box=[[j,temp//2**j]]+box\n\n        temp-=2**j*(temp//2**j)\n\n    box[0].append(a)\n\n    ans=box[0][1]*a%mod\n\n    for j in range(1,i):\n\n        box[j].append(box[j-1][2]**2%mod)\n\n        if box[j][1]==1:\n\n            ans=(ans*box[j][2])%mod\n\n    return ans\n\ndef n_func(n,mod=10**9+7):\n\n    ans=1\n\n    for i in range(1,n+1):\n\n        ans=(ans*i)%mod\n\n    return ans\n\ndef nPr(n,r,mod=10**9+7):\n\n    ans=n_func(n-r,mod)\n\n    ans=power_mod(ans,mod-2,mod)\n\n    return ans*n_func(n,mod)%mod\n\ndef nCr(n,r,mod=10**9+7):\n\n    ans=n_func(n-r,mod)*n_func(r,mod)%mod\n\n    ans=power_mod(ans,mod-2,mod)\n\n    return ans*n_func(n,mod)%mod\n\n\n\nN,M,K=list(map(int,input().split()))\n\nkeisuu=nCr(N*M-2,K-2)\n\nmod=10**9+7\n\n\n\nsum_=0\n\nfor i in range(N):\n\n    a=min(abs(i),abs(N-i-1))\n\n    b=max(abs(i),abs(N-i-1))\n\n    sum_+=(M**2)*((a*(a+1)//2)+(b*(b+1)//2))\n\nfor i in range(M):\n\n    a=min(abs(i),abs(M-i-1))\n\n    b=max(abs(i),abs(M-i-1))\n\n    sum_+=(N**2)*((a*(a+1)//2)+(b*(b+1)//2))\n\nprint(((keisuu * (sum_//2))%mod))", "score": 1.0, "surface_similarity": 0.697294888471359}
{"id": "p03494_u580316619", "golden_code": "import numpy as np\n\nn=int(eval(input()))\n\na=np.array(list(map(int,input().split())))\n\nb=0\n\nwhile np.all(a%2==0):\n\n\ta=a/2\n\n\tb+=1\n\n\t\n\nprint(b)", "generated_code": "a = int(eval(input(\"\")))\n\nb = input(\"\").split(\" \")\n\nc = 0\n\nd = []\n\n\n\nfor i in range(a):\n\n\tc = 0\n\n\twhile (int(b[i]) % 2 == 0):\n\n\t\tb[i] = int(b[i]) / 2\n\n\t\tc += 1\n\n\td.append(c)\n\nprint((min(d)))", "score": 1.0, "surface_similarity": 0.6011441647597253}
{"id": "p02574_u525065967", "golden_code": "def gen_d_prim(n):\n\n    D = [n+1 if i%2 else 2 for i in range(n+1)]\n\n    D[0] = D[1] = 0\n\n    for i in range(3, n+1, 2):\n\n        if D[i] != n+1: continue\n\n        for j in range(i, n+1, i): D[j] = i\n\n    return D\n\n\n\ndef is_pairwise(A):\n\n    D = gen_d_prim(10**6)\n\n    past = set()\n\n    for a in A:\n\n        now = set()\n\n        while a != 1:\n\n            # 素数 D[a]: 今回は未済 & 過去で済\n\n            if not D[a] in now and D[a] in past: return False\n\n            now.add(D[a])\n\n            past.add(D[a])\n\n            a //= D[a]\n\n    return True\n\n\n\ndef gcd_all(A):\n\n    from math import gcd\n\n    g = 0\n\n    for a in A: g = gcd(g, a)\n\n    return g\n\n\n\ndef solve():\n\n    if is_pairwise(A): return 0\n\n    if gcd_all(A) == 1: return 1\n\n    return 2\n\n\n\nn = int(eval(input()))\n\nA = [*list(map(int, input().split()))]\n\nprint((['pairwise','setwise','not'][solve()], 'coprime'))\n", "generated_code": "def gen_d_prim(n):\n\n    D = [0,0] + [-1] * (n-1)\n\n    for i in range(2, n+1, 2): D[i] = 2\n\n    for i in range(3, n+1, 2):\n\n        if D[i] > 0: continue\n\n        for j in range(i, n+1, i): D[j] = i\n\n    return D\n\n\n\ndef is_pairwise(A):\n\n    D = gen_d_prim(10**6)\n\n    past = set()\n\n    for a in A:\n\n        now = set()\n\n        while a != 1:\n\n            # 素数 D[a]: 今回は未済 & 過去で済\n\n            if not D[a] in now and D[a] in past: return False\n\n            now.add(D[a])\n\n            past.add(D[a])\n\n            a //= D[a]\n\n    return True\n\n\n\ndef gcd_all(A):\n\n    from math import gcd\n\n    g = 0\n\n    for a in A: g = gcd(g, a)\n\n    return g\n\n\n\ndef solve():\n\n    if is_pairwise(A): return 0\n\n    if gcd_all(A) == 1: return 1\n\n    return 2\n\n\n\nn = int(eval(input()))\n\nA = [*list(map(int, input().split()))]\n\nprint((['pairwise','setwise','not'][solve()], 'coprime'))\n", "score": 1.0, "surface_similarity": 0.8925496261923176}
{"id": "p03298_u843175622", "golden_code": "from collections import defaultdict\n\nn = int(eval(input()))\n\ns = eval(input())\n\n\n\na = s[:n]\n\nb = s[n:][::-1]\n\nd = defaultdict(int)\n\ne = defaultdict(int)\n\n\n\ndef cnt(c, d):\n\n    for bit in range(1 << n):\n\n        x = []\n\n        y = []\n\n        for i in range(n):\n\n            if bit >> i & 1:\n\n                x.append(c[i])\n\n            else:\n\n                y.append(c[i])\n\n        d[(str(x), str(y))] += 1\n\n\n\n\n\ncnt(a, d)\n\ncnt(b, e)\n\n\n\nans = 0\n\nfor k, v in list(d.items()):\n\n    ans += e[k] * v\n\nprint(ans)\n", "generated_code": "from collections import defaultdict\n\nn = int(eval(input()))\n\ns = eval(input())\n\n\n\na = s[:n]\n\nb = s[n:][::-1]\n\nd = defaultdict(int)\n\ne = defaultdict(int)\n\n\n\nfor bit in range(1 << n):\n\n    x = \"\"\n\n    y = \"\"\n\n    z = \"\"\n\n    w = \"\"\n\n    for i in range(n):\n\n        if bit >> i & 1:\n\n            x += a[i]\n\n            z += b[i]\n\n        else:\n\n            y += a[i]\n\n            w += b[i]\n\n    d[x+'ω'+y] += 1\n\n    e[z+'ω'+w] += 1\n\n\n\nprint((sum([e[k] * v for k, v in list(d.items())])))\n", "score": 1.0, "surface_similarity": 0.7962303536345776}
{"id": "p02959_u821284362", "golden_code": "\n\nimport numpy as np\n\nN = int(eval(input()))\n\n\n\nA_ls = np.array(list(map(int,input().split(\" \"))))\n\nB_ls = np.array(list(map(int,input().split(\" \"))))\n\n\n\nS = 0\n\n\n\nfor i,b in enumerate(B_ls):\n\n    if b > A_ls[i]:\n\n        b -= A_ls[i]\n\n        S += A_ls[i]\n\n        if A_ls[i+1] >= b:\n\n            A_ls[i+1] -=b\n\n            S+=b\n\n        else:\n\n            S+=A_ls[i+1]\n\n            A_ls[i+1] = 0 \n\n    else:\n\n        S += b\n\n\n\nprint(S)\n", "generated_code": "\n\nN = int(eval(input()))\n\n\n\nA_ls = list(map(int,input().split(\" \")))\n\nB_ls = list(map(int,input().split(\" \")))\n\n\n\nS = 0\n\n\n\nfor i,b in enumerate(B_ls):\n\n    if b > A_ls[i]:\n\n        b -= A_ls[i]\n\n        S += A_ls[i]\n\n        if A_ls[i+1] >= b:\n\n            A_ls[i+1] -=b\n\n            S+=b\n\n        else:\n\n            S+=A_ls[i+1]\n\n            A_ls[i+1] = 0 \n\n    else:\n\n        S += b\n\n\n\nprint(S)\n", "score": 1.0, "surface_similarity": 0.9153318077803203}
{"id": "p02725_u238940874", "golden_code": "k,n = list(map(int,input().split()))\n\na=list(map(int,input().split()))\n\na.append(a[0]+k)\n\nlongd=0\n\nfor i in range(n):\n\n    tmp=abs(a[i+1]-a[i])\n\n    longd=max(longd,tmp)\n\nprint((k-longd))", "generated_code": "k,n=list(map(int,input().split()))\n\na=list(map(int,input().split()))\n\na.append(a[0]+k)\n\n\n\nx=0\n\nfor i in range(len(a)-1):\n\n    dis=abs(a[i+1]-a[i])\n\n    x=max(x,dis)\n\n\n\nprint((k-x))", "score": 1.0, "surface_similarity": 0.9117647058823529}
{"id": "p02690_u342869120", "golden_code": "\n\nX = int(eval(input()))\n\nfor a in range(-200, 200):\n\n    find = False\n\n    for b in range(-200, 200):\n\n        x = a**5-b**5\n\n        if x == X:\n\n            find = True\n\n            print((a, b))\n\n            break\n\n    if find:\n\n        break\n", "generated_code": "\n\nX = int(eval(input()))\n\nfor a in range(-120, 120):\n\n    find = False\n\n    for b in range(-120, 120):\n\n        x = a**5-b**5\n\n        if x == X:\n\n            find = True\n\n            print((a, b))\n\n            break\n\n    if find:\n\n        break\n", "score": 1.0, "surface_similarity": 0.983739837398374}
{"id": "p03162_u195054737", "golden_code": "import sys\n\nimport itertools\n\nfrom operator import itemgetter #sortedの対象を決めたい\n\nfrom fractions import gcd #最大公約数\n\nfrom math import ceil, floor, sqrt, isinf #小数点切り上げ、切り捨て、平方根\n\nfrom copy import deepcopy #参照で影響されないコピー\n\nfrom collections import Counter, deque #要素ごとの出現回数、双方向アクセス可能データ型\n\nimport heapq\n\nimport numpy as np\n\nfrom functools import reduce\n\nsys.setrecursionlimit(200000)\n\n\n\ninput = sys.stdin.readline\n\n# template\n\n\n\ndef retmax(a, b):\n\n    if a > b:\n\n        return a\n\n    else:\n\n        return b\n\n\n\ndef main():\n\n    n = int(eval(input()))\n\n    a = [list(map(int, input().split())) for _ in range(n)]\n\n\n\n    dp = np.zeros([3, n+1])\n\n\n\n    for i, a_l in enumerate(a):\n\n        for j in range(3):\n\n            for k in range(3):\n\n                if j != k:\n\n                    dp[k, i+1] = retmax(dp[k, i+1], dp[j, i] + a_l[k])\n\n\n\n    print((int(np.max(dp[:, n], axis=0))))\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n\n\n", "generated_code": "import sys\n\nimport itertools\n\nfrom operator import itemgetter #sortedの対象を決めたい\n\nfrom fractions import gcd #最大公約数\n\nfrom math import ceil, floor, sqrt, isinf #小数点切り上げ、切り捨て、平方根\n\nfrom copy import deepcopy #参照で影響されないコピー\n\nfrom collections import Counter, deque #要素ごとの出現回数、双方向アクセス可能データ型\n\nimport heapq\n\nimport numpy as np\n\nfrom functools import reduce\n\nsys.setrecursionlimit(200000)\n\n\n\ninput = sys.stdin.readline\n\n# template\n\n\n\ndef main():\n\n    n = int(eval(input()))\n\n    abc = [list(map(int, input().split())) for _ in range(n)]\n\n\n\n    a, b, c = 0, 0, 0\n\n    for x, y, z in abc:\n\n        a, b, c = max(b, c) + x, max(a, c) + y, max(a, b) + z\n\n\n\n    print((max(a, b, c)))\n\n\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n\n\n", "score": 1.0, "surface_similarity": 0.7551080840983122}
{"id": "p02886_u021916304", "golden_code": "def ii():return int(eval(input()))\n\ndef iim():return list(map(int,input().split()))\n\ndef iil():return list(map(int,input().split()))\n\ndef ism():return list(map(str,input().split()))\n\ndef isl():return list(map(str,input().split()))\n\n\n\nn = ii()\n\nD = iil()\n\nans = 0\n\nfor i in range(n):\n\n    for j in range(i+1,n):\n\n#        print(i,j)\n\n        ans += D[i]*D[j] \n\nprint(ans)", "generated_code": "def ii():return int(eval(input()))\n\ndef iim():return list(map(int,input().split()))\n\ndef iil():return list(map(int,input().split()))\n\ndef ism():return list(map(str,input().split()))\n\ndef isl():return list(map(str,input().split()))\n\n\n\nn = ii()\n\nD = iil()\n\nsumD = sum(D)\n\nans = 0\n\nfor i in range(n):\n\n    ans += D[i]*(sum(D)-D[i])\n\nprint((ans//2))", "score": 1.0, "surface_similarity": 0.8996782496782496}
{"id": "p03353_u175034939", "golden_code": "S = eval(input())\n\nK = int(eval(input()))\n\na = list(set(S))\n\na.sort()\n\n\n\nk = []\n\nl = 0\n\nwhile l < len(a):\n\n    for i in range(len(S)):\n\n        if S[i] == a[l]:\n\n            for j in range(1,6):\n\n                if i+j <= len(S):\n\n                    k.append(S[i:i+j])\n\n                else:\n\n                    break\n\n    l += 1\n\n\n\nk = list(set(k))\n\nk.sort()\n\nprint((k[K-1]))", "generated_code": "S = eval(input())\n\nK = int(eval(input()))\n\na = []\n\nfor i in range(len(S)+1):\n\n    for j in range(1,6):\n\n        if i+j <= len(S):\n\n            a.append(S[i:i+j])\n\n        else:\n\n            break\n\n            \n\na = list(set(a))\n\na.sort()\n\nprint((a[K-1]))", "score": 1.0, "surface_similarity": 0.83005291005291}
{"id": "p02702_u653837719", "golden_code": "s = input()[::-1]\n\nl = len(s)\n\nc = [0] * 2019\n\nc[0] = 1\n\nten = 1\n\nmod = 0\n\nans = 0\n\n\n\nfor i in range(l):\n\n    mod = (mod + int(s[i]) * ten) % 2019\n\n    ten = ten * 10 % 2019\n\n    c[mod] += 1\n\n\n\nfor i in c:\n\n    ans += i * (i - 1) // 2\n\n\n\nprint(ans)", "generated_code": "s = input()[::-1]\n\nc = [0] * 2019\n\nc[0] = 1\n\nmod = 0\n\nten = 1\n\nans = 0\n\n\n\nfor i in s:\n\n    mod = (mod + int(i) * ten) % 2019\n\n    ten = ten * 10 % 2019\n\n    c[mod] += 1\n\n\n\nfor i in c:\n\n    ans += i * (i - 1) // 2\n\n\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.9435483870967742}
{"id": "p02994_u271752889", "golden_code": "import numpy as np\n\n\n\nn,l=list(map(int,input().split()))\n\nli=[]\n\nfor i in range(n):\n\n  li.append(l+i)\n\ns=sum(li)\n\np=np.array(li)\n\na=np.abs(p).tolist()\n\nk=min(a)\n\nb=a.index(k)\n\nprint((s-li[b]))", "generated_code": "n,l=list(map(int,input().split()))\n\na=0\n\nfor i in range(n):\n\n  a+=i+l\n\nif l>=0:\n\n  print((a-l))\n\nelif l+n-1<0:\n\n  print((a-(l+n-1)))\n\nelse:\n\n  print(a)", "score": 1.0, "surface_similarity": 0.5234375}
{"id": "p02780_u762420987", "golden_code": "import numpy as np\n\nN, K = list(map(int, input().split()))\n\nplist = list(map(int, input().split()))\n\nkitaiti = np.array([(0.5*(p+1)) for p in plist])\n\nans = 0\n\nval = sum(kitaiti[:K])\n\nans = max(ans, val)\n\nfor i in range(1, N-K+1):\n\n    # print(i-1, i+K)\n\n    val -= kitaiti[i-1]\n\n    val += kitaiti[i+K-1]\n\n    ans = max(ans, val)\n\nprint(ans)", "generated_code": "N, K = list(map(int, input().split()))\n\nplist = [((num*(num+1))//2)/num for num in list(map(int, input().split()))]\n\n# print(plist)\n\nans = 0\n\nfor i in range(K):\n\n    ans += plist[i]\n\n_ = ans\n\nfor i in range(N-K):\n\n    temp = _\n\n    temp -= plist[i]\n\n    temp += plist[i+K]\n\n    # print(i, i+K, ans, temp)\n\n    ans = max(ans, temp)\n\n    _ = temp\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.6837078651685393}
{"id": "p03000_u488178971", "golden_code": "#ABC 130 B\n\nN,X=list(map(int,input().split()))\n\nL= [int(j) for j in input().split()]\n\ncnt=0\n\nimport numpy as np\n\njump = list(np.cumsum(L))\n\nfor j in jump:\n\n    if j <= X:\n\n        cnt+=1\n\nprint((cnt+1))", "generated_code": "#ABC 130 B\n\nN,X=list(map(int,input().split()))\n\nL= [int(j) for j in input().split()]\n\ncnt=0\n\nimport numpy as np\n\njump = list(np.cumsum(L))\n\nfor j in jump:\n\n    if j <= X:\n\n        cnt+=1\n\n    else:\n\n        break\n\nprint((cnt+1))", "score": 1.0, "surface_similarity": 0.9509569377990431}
{"id": "p03545_u561231954", "golden_code": "import numpy as np\n\nnum=np.array(list(eval(input())))\n\n\n\nfor bit in  range(1<<3):\n\n  op=np.array(['-']*3)\n\n  for i in range(3):\n\n    if (bit>>i)&1:\n\n      op[i]='+'\n\n  formula=np.insert(num,[1,2,3],op)\n\n  \n\n  if eval(''.join(formula))==7:\n\n    flag=True\n\n    print((''.join(formula)+'=7'))\n\n    break", "generated_code": "INF = 10 ** 9\n\nimport sys\n\nsys.setrecursionlimit(100000000)\n\ndy = (-1,0,1,0)\n\ndx = (0,1,0,-1)\n\nfrom  heapq import heappop,heapify,heappush\n\nfrom bisect import bisect_left\n\n\n\ndef main():\n\n    s = eval(input())\n\n    for bit in range(8):\n\n        op = []\n\n        for i in range(3):\n\n            if (bit>>i)&1:\n\n                op.append('+')\n\n            else:\n\n                op.append('-')\n\n        \n\n        tmp = s[0]\n\n        for i in range(3):\n\n            tmp += op[i]\n\n            tmp += s[i + 1]\n\n\n\n        if eval(tmp) == 7:\n\n            ans = tmp + '=7'\n\n            break\n\n    print(ans)\n\nif __name__ == '__main__':\n\n    main()\n", "score": 1.0, "surface_similarity": 0.6200028453549581}
{"id": "p03814_u045939752", "golden_code": "S=eval(input())\n\nprint((S.rfind('Z')-S.find('A')+1))", "generated_code": "s=input().strip()\n\na = s.find('A')\n\nz = s.rfind('Z')\n\nprint((z-a+1))\n", "score": 1.0, "surface_similarity": 0.7463768115942029}
{"id": "p03371_u585482323", "golden_code": "#!usr/bin/env python3\n\nfrom collections import defaultdict\n\nfrom collections import deque\n\nfrom heapq import heappush, heappop\n\nimport sys\n\nimport math\n\nimport bisect\n\nimport random\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\n\ndef I(): return int(sys.stdin.readline())\n\ndef LS():return list(map(list, sys.stdin.readline().split()))\n\ndef S(): return list(sys.stdin.readline())[:-1]\n\ndef IR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = I()\n\n    return l\n\ndef LIR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = LI()\n\n    return l\n\ndef SR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = S()\n\n    return l\n\ndef LSR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = LS()\n\n    return l\n\nsys.setrecursionlimit(1000000)\n\nmod = 1000000007\n\n\n\n#A\n\ndef A():\n\n    return\n\n\n\n#B\n\ndef B():\n\n    return\n\n\n\n#C\n\ndef C():\n\n    return\n\n\n\n#D\n\ndef D():\n\n    return\n\n\n\n#E\n\ndef E():\n\n    return\n\n\n\n#F\n\ndef F():\n\n    a,b,c,X,Y = LI()\n\n    ans = float(\"inf\")\n\n    for z in range(300001):\n\n        if z%2 == 0:\n\n            m = c*z\n\n            x = z//2\n\n            y = z//2\n\n            m += a*max(0,X-x)\n\n            m += b*max(0,Y-y)\n\n            if m < ans:\n\n                ans = m\n\n    print(ans)\n\n    return\n\n\n\n#G\n\ndef G():\n\n    n = I()\n\n    x = LI()\n\n    f = [(i,x[i]) for i in range(n)]\n\n    f.sort(key = lambda x:x[1])\n\n    g = [(f[i][0],i) for i in range(n)]\n\n    g.sort(key = lambda x:x[0])\n\n    for i in range(n):\n\n        if g[i][1] < n//2:\n\n            print((f[n//2][1]))\n\n        else:\n\n            print((f[n//2-1][1]))\n\n    return\n\n\n\n#H\n\ndef H():\n\n    return\n\n\n\n#I\n\ndef I_():\n\n    return\n\n\n\n#J\n\ndef J():\n\n    return\n\n\n\n#Solve\n\nif __name__ == \"__main__\":\n\n    F()\n", "generated_code": "#!usr/bin/env python3\n\nfrom collections import defaultdict,deque\n\nfrom heapq import heappush, heappop\n\nfrom itertools import permutations\n\nimport sys\n\nimport math\n\nimport bisect\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\n\ndef I(): return int(sys.stdin.readline())\n\ndef LS():return [list(x) for x in sys.stdin.readline().split()]\n\ndef S():\n\n    res = list(sys.stdin.readline())\n\n    if res[-1] == \"\\n\":\n\n        return res[:-1]\n\n    return res\n\ndef IR(n):\n\n    return [I() for i in range(n)]\n\ndef LIR(n):\n\n    return [LI() for i in range(n)]\n\ndef SR(n):\n\n    return [S() for i in range(n)]\n\ndef LSR(n):\n\n    return [LS() for i in range(n)]\n\n\n\nsys.setrecursionlimit(1000000)\n\nmod = 1000000007\n\n\n\ndef solve():\n\n    A,B,C,x,y = LI()\n\n    ans = float(\"inf\")\n\n    for c in range(200001)[::2]:\n\n        a = b = c >> 1\n\n        a = max(0,x-a)\n\n        b = max(0,y-b)\n\n        s = A*a+B*b+C*c\n\n        if s < ans:\n\n            ans = s\n\n    print(ans)\n\n    return\n\n\n\n#Solve\n\nif __name__ == \"__main__\":\n\n    solve()\n", "score": 1.0, "surface_similarity": 0.7418803418803419}
{"id": "p02612_u183422236", "golden_code": "n = int(eval(input())) % 1000\n\nif n == 0:\n\n    print((0))\n\nelse:\n\n    print((1000 - n))", "generated_code": "n = int(eval(input()))\n\nprint(((1000 - n % 1000) % 1000))", "score": 1.0, "surface_similarity": 0.7089490968801313}
{"id": "p02599_u724687935", "golden_code": "import sys\n\n\n\n\n\nclass BinaryIndexedTree():\n\n    '''\n\n    1-indexed\n\n    '''\n\n    def __init__(self, A):\n\n        self.__n = len(A)\n\n        self.__node = [0] * (self.__n + 1)\n\n        self.__data = [0] * (self.__n + 1)\n\n\n\n        S = [0] * (self.__n + 1)\n\n        for i in range(1, self.__n + 1):\n\n            S[i] = S[i - 1] + A[i - 1]\n\n            self.__data[i] = A[i - 1]\n\n            self.__node[i] = S[i] - S[i - (i & -i)]\n\n\n\n    def add(self, i, v):\n\n        self.__data[i] += v\n\n        while i <= self.__n:\n\n            self.__node[i] += v\n\n            i += i & -i\n\n\n\n    def sum(self, i):\n\n        ''' [1, i]の和\n\n        '''\n\n        rst = 0\n\n        while i > 0:\n\n            rst += self.__node[i]\n\n            i -= i & -i\n\n        return rst\n\n    \n\n    def get(self, i, j):\n\n        '''[i, j]の和\n\n        '''\n\n        if i == j:\n\n            return self.__data[i]\n\n        else:\n\n            return self.sum(j) - self.sum(i - 1)\n\n\n\n\n\ndef main():\n\n    N, Q = map(int, input().split())\n\n    C = list(map(int, input().split()))\n\n\n\n    P = [[] for _ in range(N)]\n\n    for i, c in enumerate(C):\n\n        P[c - 1].append(i)\n\n\n\n    right = [0] * N\n\n    for p in P:\n\n        if len(p):\n\n            right[p.pop()] = 1\n\n    BIT = BinaryIndexedTree(right)\n\n\n\n    query = [[] for _ in range(N)]\n\n    for i, s in enumerate(sys.stdin.readlines()):\n\n        l, r = map(int, s.split())\n\n        query[r - 1].append((l - 1, i))\n\n\n\n    ans = [None] * Q\n\n\n\n    cur = N - 1\n\n    for r, q in enumerate(reversed(query)):\n\n        r = (N - 1) - r\n\n        while q:\n\n            l, i = q.pop()\n\n            while r < cur:\n\n                c = C[cur] - 1\n\n                p = P[c]\n\n                if len(p):\n\n                    BIT.add(p.pop() + 1, 1)\n\n                cur -= 1\n\n            tmp = BIT.get(l + 1, r + 1)\n\n            ans[i] = tmp\n\n\n\n    print(*ans, sep='\\n')\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "generated_code": "import sys\n\n\n\n\n\nclass BinaryIndexedTree():\n\n    '''\n\n    1-indexed\n\n    '''\n\n    def __init__(self, A):\n\n        self.__n = len(A)\n\n        self.__node = [0] * (self.__n + 1)\n\n        self.__data = [0] * (self.__n + 1)\n\n\n\n        S = [0] * (self.__n + 1)\n\n        for i in range(self.__n):\n\n            S[i + 1] = S[i] + A[i]\n\n\n\n        for i in range(1, self.__n + 1):\n\n            self.__data[i] = A[i - 1]\n\n            self.__node[i] = S[i] - S[i - (i & -i)]\n\n\n\n    def add(self, i, v):\n\n        self.__data[i] += v\n\n        while i <= self.__n:\n\n            self.__node[i] += v\n\n            i += i & -i\n\n\n\n    def sum(self, i):\n\n        ''' [1, i]の和\n\n        '''\n\n        rst = 0\n\n        while i > 0:\n\n            rst += self.__node[i]\n\n            i -= i & -i\n\n        return rst\n\n    \n\n    def get(self, i, j):\n\n        '''[i, j]の和\n\n        '''\n\n        if i == j:\n\n            return self.__data[i]\n\n        else:\n\n            return self.sum(j) - self.sum(i - 1)\n\n\n\n\n\ndef main():\n\n    N, Q = map(int, input().split())\n\n    C = list(map(int, input().split()))\n\n\n\n    P = [[] for _ in range(N)]\n\n    for i, c in enumerate(C):\n\n        P[c - 1].append(i)\n\n\n\n    right = [0] * N\n\n    for p in P:\n\n        if len(p):\n\n            right[p.pop()] = 1\n\n    BIT = BinaryIndexedTree(right)\n\n\n\n    query = [[] for _ in range(N)]\n\n    for i, s in enumerate(sys.stdin.readlines()):\n\n        l, r = map(int, s.split())\n\n        query[r - 1].append((l - 1, i))\n\n\n\n    ans = [None] * Q\n\n\n\n    cur = N - 1\n\n    for r, q in enumerate(reversed(query)):\n\n        r = (N - 1) - r\n\n        while q:\n\n            l, i = q.pop()\n\n            while r < cur:\n\n                c = C[cur] - 1\n\n                p = P[c]\n\n                if len(p):\n\n                    BIT.add(p.pop() + 1, 1)\n\n                cur -= 1\n\n            tmp = BIT.get(l + 1, r + 1)\n\n            ans[i] = tmp\n\n\n\n    print(*ans, sep='\\n')\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 1.0, "surface_similarity": 0.9909747292418772}
{"id": "p02983_u912650255", "golden_code": "L ,R = list(map(int,input().split()))\n\n\n\nans =[]\n\nif R - L <= 2019:\n\n    for i in range(L,R+1):\n\n        for j in range(i+1,R+1):\n\n            ans.append(i*j%2019)\n\n\n\nelse:\n\n    for i in range(R-L-1010,R-L+1010):\n\n        for j in range(i,R-L+1010):\n\n            ans.append(i*j%2019)\n\n\n\nprint((min(ans)))\n", "generated_code": "L ,R = list(map(int,input().split()))\n\n\n\nans =[]\n\nfor i in range(L,R+1):\n\n    for j in range(i+1,R+1):\n\n        ans.append(i*j%2019)\n\n        if (i * j % 2019) == 0:\n\n            break\n\n    else:\n\n        continue\n\n    break\n\n\n\nprint((min(ans)))", "score": 1.0, "surface_similarity": 0.7552387740555953}
{"id": "p02773_u622570247", "golden_code": "from collections import Counter\n\nimport heapq\n\n\n\nn = int(eval(input()))\n\nss = []\n\nfor _ in range(n):\n\n    ss.append(input().rstrip())\n\nctr = Counter(ss)\n\nheap = [(-v, k) for k, v in list(ctr.items())]\n\nheapq.heapify(heap)\n\nmaxv = heap[0][0]\n\nwhile heap:\n\n    c = heapq.heappop(heap)\n\n    if c[0] != maxv:\n\n        break\n\n    print((c[1]))\n", "generated_code": "from collections import Counter\n\n\n\nn = int(eval(input()))\n\nss = []\n\nfor _ in range(n):\n\n    ss.append(input().rstrip())\n\nctr = Counter(ss)\n\n\n\na = sorted([(-v, k) for k, v in list(ctr.items())])\n\nmaxv = a[0][0]\n\nfor i in range(len(a)):\n\n    if a[i][0] != maxv:\n\n        break\n\n    print((a[i][1]))", "score": 1.0, "surface_similarity": 0.8464942137508509}
{"id": "p02685_u638456847", "golden_code": "import sys\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\nreadlines = sys.stdin.readlines\n\n\n\nfac = [1, 1]     # 元テーブル\n\nf_inv = [1, 1]   # 逆元テーブル\n\ninv = [0, 1]     # 逆元テーブル計算用テーブル\n\n\n\ndef prepare(n, mod):\n\n    for i in range(2, n+1):\n\n        fac.append((fac[-1] * i) % mod)\n\n        inv.append((-inv[mod % i] * (mod//i)) % mod)\n\n        f_inv.append((f_inv[-1] * inv[-1]) % mod)\n\n\n\ndef cmb(n, r, mod):\n\n    if n < 0 or r < 0:\n\n        return 0\n\n    if r > n:\n\n        return 0\n\n\n\n    return fac[n] * f_inv[r] * f_inv[n-r] % mod\n\n\n\n\n\ndef main():\n\n    N,M,K = list(map(int, readline().split()))\n\n\n\n    MOD = 998244353\n\n    prepare(N + 10, MOD)\n\n\n\n    if M == 1 and K == N - 1:\n\n        print((1))\n\n        exit()\n\n\n\n    m = M\n\n    for _ in range(N-1):\n\n        m *= M - 1\n\n        m %= MOD\n\n\n\n    ans = 0\n\n    for k in range(K+1):\n\n        ans += (m * cmb(N-1, k, MOD)) % MOD\n\n        ans %= MOD\n\n\n\n        m *= pow(M-1, MOD-2, MOD)\n\n        m %= MOD\n\n\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "generated_code": "import sys\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\nreadlines = sys.stdin.readlines\n\n\n\n# 0^0 = 1\n\n\n\ndef main():\n\n    N,M,K = list(map(int, readline().split()))\n\n\n\n    MOD = 998244353\n\n\n\n    if M == 1:\n\n        if K == N - 1:\n\n            print((1))\n\n        else:\n\n            print((0))\n\n        exit()\n\n\n\n    m = pow(M-1, N-1, MOD)\n\n    m_1_inv = pow(M-1, MOD-2, MOD)\n\n    comb = 1\n\n    ans = comb * m\n\n    for k in range(1,K+1):\n\n        m *= m_1_inv\n\n        m %= MOD\n\n        comb *= N - k\n\n        comb %= MOD\n\n        comb *= pow(k, MOD-2, MOD)\n\n        \n\n        ans += (m * comb) % MOD\n\n        ans %= MOD\n\n\n\n    print((ans * M % MOD))\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "score": 1.0, "surface_similarity": 0.626387192693676}
{"id": "p02748_u588341295", "golden_code": "# -*- coding: utf-8 -*-\n\n\n\nimport sys\n\nfrom collections import Counter\n\n\n\ndef input(): return sys.stdin.readline().strip()\n\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\n\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\n\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\n\ndef ceil(x, y=1): return int(-(-x // y))\n\ndef INT(): return int(eval(input()))\n\ndef MAP(): return list(map(int, input().split()))\n\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\n\ndef Yes(): print('Yes')\n\ndef No(): print('No')\n\ndef YES(): print('YES')\n\ndef NO(): print('NO')\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = 10 ** 18\n\nMOD = 10 ** 9 + 7\n\n\n\ndef fft(A, B):\n\n    \"\"\" \n\n    高速フーリエ変換(FFT)\n\n        A：出現回数をカウントしたリスト\n\n        B：出現回数をカウントしたリスト\n\n    \"\"\"\n\n    import numpy as np\n\n    from numpy.fft import rfft, irfft\n\n\n\n    # 出現数カウント\n\n    MAXA = max(A)\n\n    MAXB = max(B)\n\n    C1 = [0] * (MAXA+1)\n\n    C2 = [0] * (MAXB+1)\n\n    for a in A:\n\n        C1[a] += 1\n\n    for b in B:\n\n        C2[b] += 1\n\n    # max(A)+max(B)より大きい2冪\n\n    L = 1\n\n    k = 0\n\n    while L <= MAXA + MAXB:\n\n        k += 1\n\n        L = 2**k\n\n    # FFT\n\n    res = irfft(rfft(C1, L) * rfft(C2, L), L)\n\n    # 四捨五入して整数に\n\n    res = np.rint(res).astype(np.int64)\n\n    return res\n\n\n\nN, M, L = MAP()\n\nA = LIST()\n\nB = LIST()\n\n\n\nres = list(fft(A, B))\n\n\n\nmn = INF\n\nfor i, a in enumerate(res):\n\n    if a != 0:\n\n        mn = i\n\n        break\n\n\n\nfor _ in range(L):\n\n    x, y, c = MAP()\n\n    x -= 1; y -= 1\n\n    mn = min(mn, A[x] + B[y] - c)\n\nprint(mn)\n", "generated_code": "# -*- coding: utf-8 -*-\n\n\n\nimport sys\n\nfrom collections import Counter\n\n\n\ndef input(): return sys.stdin.readline().strip()\n\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\n\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\n\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\n\ndef ceil(x, y=1): return int(-(-x // y))\n\ndef INT(): return int(eval(input()))\n\ndef MAP(): return list(map(int, input().split()))\n\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\n\ndef Yes(): print('Yes')\n\ndef No(): print('No')\n\ndef YES(): print('YES')\n\ndef NO(): print('NO')\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = 10 ** 18\n\nMOD = 10 ** 9 + 7\n\n\n\nN, M, L = MAP()\n\nA = LIST()\n\nB = LIST()\n\n\n\nmn = min(A) + min(B)\n\nfor _ in range(L):\n\n    x, y, c = MAP()\n\n    x -= 1; y -= 1\n\n    mn = min(mn, A[x] + B[y] - c)\n\nprint(mn)\n", "score": 1.0, "surface_similarity": 0.8161741713570982}
{"id": "p02899_u945405878", "golden_code": "import numpy as np\n\n\n\nN = int(eval(input()))\n\nA = [int(_) for _ in input().split(\" \")]\n\n\n\ntmp = np.argsort(A)\n\ntmp2= tmp + np.ones(N)\n\ntmp3 = [int(_) for _ in tmp2.tolist()]\n\nans = [str(_) for _ in tmp3]\n\n\n\nprint((\" \".join(ans)))", "generated_code": "N = int(eval(input()))\n\nA = [int(_) for _ in input().split(\" \")]\n\n\n\ntmp = sorted(list(range(1, len(A) + 1)), key=lambda x:A[x - 1])\n\nans = [str(_) for _ in tmp]\n\nprint((\" \".join(ans)))", "score": 1.0, "surface_similarity": 0.6360658991663359}
{"id": "p03273_u599114793", "golden_code": "import numpy\n\nh,w = list(map(int,input().split()))\n\ngrid = numpy.empty([h,w], str)\n\nwhite_h = []\n\nwhite_w = []\n\nfor i in range(h):\n\n    grid[i] = list(eval(input()))\n\nfor i in range(h):\n\n    if \"#\" not in grid[i]:\n\n        white_h.append(i)\n\nfor i in range(w):\n\n    if \"#\" not in grid[:, i]:\n\n        white_w.append(i)\n\nans_grid = numpy.empty([h-len(white_h), w-len(white_w)], str)\n\ncnt_h = 0\n\nfor i in range(h):\n\n    if i not in white_h:\n\n        cnt_w = 0\n\n        for j in range(w):\n\n            if j not in white_w:\n\n                ans_grid[cnt_h, cnt_w] = grid[i,j]\n\n                cnt_w += 1\n\n        cnt_h += 1\n\nfor i in range(len(ans_grid)):\n\n    print((\"\".join(ans_grid[i])))\n\n\n\n\n\n\n", "generated_code": "h,w = list(map(int,input().split()))\n\ngrid = []\n\nfor i in range(h):\n\n    grid.append(list(eval(input())))\n\nh_b = []\n\nw_b = []\n\nfor i in range(h):\n\n    if \"#\" in grid[i]:\n\n        h_b.append(i)\n\ngrid_t = [list(x) for x in zip(*grid)]\n\nfor i in range(w):\n\n    if \"#\" in grid_t[i]:\n\n        w_b.append(i)\n\nans = []\n\nfor i in h_b:\n\n    crt = []\n\n    for j in w_b:\n\n        crt.append(grid[i][j])\n\n    ans.append(crt)\n\nfor i in range(len(ans)):\n\n    print((\"\".join(ans[i])))\n\n\n", "score": 1.0, "surface_similarity": 0.5832213763248246}
{"id": "p03037_u428397309", "golden_code": "# -*- coding: utf-8 -*-\n\n\n\nN, M = list(map(int, input().split()))\n\nL, R = [None] * M, [None] * M\n\nfor i in range(M):\n\n    L[i], R[i] = list(map(int, input().split()))\n\n\n\nl = max(L)\n\nr = min(R)\n\n\n\nans = max(r - l + 1, 0)\n\n\n\nprint(ans)\n", "generated_code": "# -*- coding: utf-8 -*-\n\n\n\nimport sys\n\ninput = sys.stdin.readline\n\n\n\nN, M = list(map(int, input().split()))\n\nL, R = [None] * M, [None] * M\n\nfor i in range(M):\n\n    L[i], R[i] = list(map(int, input().split()))\n\n\n\nans = max(min(R) - max(L) + 1, 0)\n\n\n\nprint(ans)\n", "score": 1.0, "surface_similarity": 0.851923076923077}
{"id": "p02881_u756270013", "golden_code": "import math\n\ninput_num = int(eval(input()))\n\nnum_sqrt = int(math.sqrt(input_num))\n\n\n\nminimam = input_num\n\nfor i in range(num_sqrt+1,0,-1):\n\n    q, mod = divmod(input_num, i)\n\n    distance = q + i -2\n\n    if mod == 0 and minimam > distance:\n\n        minimam = distance\n\nprint(minimam)", "generated_code": "import math\n\ndef main1():\n\n    input_num = int(eval(input()))\n\n    num_sqrt = int(math.sqrt(input_num))\n\n\n\n    minimam = input_num\n\n    for i in range(num_sqrt+1,0,-1):\n\n        q, mod = divmod(input_num, i)\n\n        if mod == 0:\n\n            distance = q + i -2\n\n            if minimam > distance:\n\n                minimam = distance\n\n    print(minimam)\n\nmain1()", "score": 1.0, "surface_similarity": 0.8693579148124603}
{"id": "p02881_u802963389", "golden_code": "# C - Walk on Multiplication Table\n\n# https://atcoder.jp/contests/abc144/tasks/abc144_c\n\n\n\nn = int(eval(input()))\n\n\n\nans = 10 ** 12\n\nfor i in range(1, 10 ** 6 + 1):\n\n  if n % i == 0:\n\n    ans = min(ans, n // i + i)\n\n\n\nprint((ans - 2))", "generated_code": "# C - Walk on Multiplication Table\n\n# https://atcoder.jp/contests/abc144/tasks/abc144_c\n\n\n\nn = int(eval(input()))\n\n\n\nans = n\n\nfor i in range(1, int(n**.5) + 2):\n\n  if n % i == 0:\n\n    ans = min(ans, n // i + i - 2)\n\n\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.9551282051282051}
{"id": "p04020_u077291787", "golden_code": "# AGC003B - Simplified mahjong\n\nimport sys\n\ninput = sys.stdin.readline\n\n\n\ndef main():\n\n    # split in subsequences when 0 appears -> sum up cur // 2\n\n    N = int(eval(input()))\n\n    A = list(map(int, [eval(input()) for _ in range(N)])) + [0]\n\n    ans, cur = 0, 0\n\n    for i in A:\n\n        if i:\n\n            cur += i\n\n        else:\n\n            ans += cur // 2\n\n            cur = 0\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()", "generated_code": "# AGC003B - Simplified mahjong\n\ndef main():\n\n    # split in subsequences when 0 appears -> sum up cur // 2\n\n    N, *A = list(map(int, open(0).read().split()))\n\n    A.append(0)\n\n    ans, cur = 0, 0\n\n    for i in A:\n\n        if i:\n\n            cur += i\n\n        else:\n\n            ans += cur // 2\n\n            cur = 0\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()", "score": 1.0, "surface_similarity": 0.7859759288330717}
{"id": "p02412_u131984977", "golden_code": "while True:\n\n    (n, x) = [int(i) for i in input().split()]\n\n    if n == x == 0:\n\n        break\n\n\n\n    count = 0\n\n    for a in range(1, n + 1):\n\n        for b in range(a + 1, n + 1):\n\n            for c in range(b + 1, n + 1):\n\n                if sum([a,b,c]) == x:\n\n                    count += 1\n\n\n\n    print(count)", "generated_code": "while True:\n\n    (n, x) = [int(i) for i in input().split()]\n\n    if n == x == 0:\n\n        break\n\n\n\n    count = 0\n\n    limit = n if n < x else x\n\n    for a in range(1, limit + 1):\n\n        for b in range(a + 1, limit + 1):\n\n            for c in range(b + 1, limit + 1):\n\n                if sum([a,b,c]) == x:\n\n                    count += 1\n\n\n\n    print(count)", "score": 1.0, "surface_similarity": 0.912372330547818}
{"id": "p03200_u857428111", "golden_code": "import sys\n\nsys.setrecursionlimit(10000000)\n\n\n\n#const\n\ndxdy=((1,0),(0,1))\n\n#my functions here!\n\ndef pin(type=int):\n\n    return list(map(type,input().rstrip().split()))\n\n\n\n\n\n#your code here!\n\ndef resolve():\n\n    S=eval(input())\n\n    ans=0\n\n    \n\n    hidari=0\n\n    for i,c in enumerate(S):\n\n        if c==\"W\":\n\n            ans+=i-hidari\n\n            hidari+=1\n\n    print(ans)\n\n\n\nimport sys\n\nfrom io import StringIO\n\nimport unittest\n\n\n\n\n\nclass TestClass(unittest.TestCase):\n\n    def assertIO(self, input, output):\n\n        stdout, stdin = sys.stdout, sys.stdin\n\n        sys.stdout, sys.stdin = StringIO(), StringIO(input)\n\n        resolve()\n\n        sys.stdout.seek(0)\n\n        out = sys.stdout.read()[:-1]\n\n        sys.stdout, sys.stdin = stdout, stdin\n\n        self.assertEqual(out, output)\n\n\n\n    def test_入力例_1(self):\n\n        input = \"\"\"BBW\"\"\"\n\n        output = \"\"\"2\"\"\"\n\n        self.assertIO(input, output)\n\n\n\n    def test_入力例_2(self):\n\n        input = \"\"\"BWBWBW\"\"\"\n\n        output = \"\"\"6\"\"\"\n\n        self.assertIO(input, output)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    #unittest.main()\n\n\n\n\n\n    resolve()#and submit 2 atcoder!\n\n\n", "generated_code": "import sys\n\ninput= lambda: sys.stdin.readline().rstrip()\n\ndef pin(type=int):\n\n    return list(map(type,input().split()))\n\n\n\n#%%code\n\n\n\ndef resolve():\n\n    \n\n    S=eval(input())\n\n    index=0\n\n    ans=0\n\n    for i in range(len(S)):\n\n        if S[i]==\"W\":\n\n            ans+=i-index\n\n            index+=1\n\n    print(ans)\n\n#%%submit!\n\nresolve()", "score": 1.0, "surface_similarity": 0.6170353982300885}
{"id": "p04005_u562935282", "golden_code": "'''\n\nある平面のブロック数×(0,1)\n\n一つでも偶数があれば、均等分割可能\n\nすべて奇数のとき、\n\nある平面のブロック数を最小となるようにすると、その数が答えになる\n\n'''\n\n\n\narr = list(map(int, input().split()))\n\n\n\nret = -1\n\nif 0 in list([x % 2 for x in arr]):\n\n    ret = 0\n\nelse:\n\n    arr_sorted = sorted(arr)\n\n    ret = arr_sorted[0] * arr_sorted[1]\n\nprint(ret)", "generated_code": "a = list(map(int, input().split()))\n\n\n\nif any([x % 2 == 0 for x in a]):\n\n    print((0))\n\nelse:\n\n    a = list(sorted(a))\n\n    print((a[0] * a[1]))\n", "score": 1.0, "surface_similarity": 0.635239318984902}
{"id": "p03162_u940342887", "golden_code": "import numpy as np\n\nN = int(eval(input()))\n\nabc = []\n\nfor i in range(N):\n\n    abc.append(list(map(int, input().split())))\n\n    \n\ndp = np.zeros(shape=(N, 3), dtype=int)\n\ndp[0, :] = abc[0]\n\nfor i in range(N-1):\n\n    dp[i+1, 0] = max(dp[i+1, 0], dp[i, 1] + abc[i+1][0], dp[i, 2] + abc[i+1][0])\n\n    dp[i+1, 1] = max(dp[i+1, 1], dp[i, 0] + abc[i+1][1], dp[i, 2] + abc[i+1][1])\n\n    dp[i+1, 2] = max(dp[i+1, 2], dp[i, 0] + abc[i+1][2], dp[i, 1] + abc[i+1][2])\n\nprint((max(dp[N-1, :])))", "generated_code": "N = int(eval(input()))\n\nabc = []\n\nfor i in range(N):\n\n    data = list(map(int, input().split()))\n\n    abc.append(data)\n\n\n\ndp = [[0 for i in range(3)] for j in range(N)]\n\ndp[0][0] = abc[0][0]\n\ndp[0][1] = abc[0][1]\n\ndp[0][2] = abc[0][2]\n\n\n\nfor i in range(N-1):\n\n    for j in range(3):\n\n        if j == 0:\n\n            dp[i+1][1] = max(dp[i][0] + abc[i+1][1], dp[i+1][1])\n\n            dp[i+1][2] = max(dp[i][0] + abc[i+1][2], dp[i+1][2])\n\n        if j == 1:\n\n            dp[i+1][0] = max(dp[i][1] + abc[i+1][0], dp[i+1][0])\n\n            dp[i+1][2] = max(dp[i][1] + abc[i+1][2], dp[i+1][2])\n\n        if j == 2:\n\n            dp[i+1][1] = max(dp[i][2] + abc[i+1][1], dp[i+1][1])\n\n            dp[i+1][0] = max(dp[i][2] + abc[i+1][0], dp[i+1][0])\n\n\n\nprint((max(dp[N-1])))", "score": 1.0, "surface_similarity": 0.6075675938061259}
{"id": "p02767_u272075541", "golden_code": "import numpy as np\n\nn = int(eval(input()))\n\na = np.array(input().split(), np.int)\n\na.sort()\n\n\n\nans = []\n\nfor x in range(a[0], a[-1]+1):\n\n    ans.append(np.sum((a - x) ** 2))\n\n\n\nprint((min(ans)))", "generated_code": "from decimal import Decimal, ROUND_HALF_UP\n\nimport numpy as np\n\nn = int(eval(input()))\n\nx = np.array(input().split(), int)\n\n\n\nm = Decimal(np.sum(x) / n)\n\nmq = int(m.quantize(0, rounding=ROUND_HALF_UP))\n\n\n\ns = np.sum((x-mq)**2)\n\nprint(s)", "score": 1.0, "surface_similarity": 0.5416666666666667}
{"id": "p02994_u883040023", "golden_code": "N , L = list(map(int , input().split()))\n\n\n\napple_taste = []\n\n\n\nfor i in range(N):\n\n    taste = L + i + 1 - 1\n\n    apple_taste.append(taste)\n\n    \n\nimport numpy as np\n\n\n\nabs_apple_taste = np.abs(apple_taste)\n\nm = min(abs_apple_taste)\n\n\n\nfor j in range(N):\n\n    if m == abs_apple_taste[j]:\n\n        apple_taste.remove(apple_taste[j])\n\n\n\npie_taste = 0       \n\n\n\nfor k in range(N-1):\n\n    pie_taste += apple_taste[k]\n\n    \n\nprint(pie_taste)", "generated_code": "n,l = list(map(int,input().split()))\n\nans = l\n\neat = l\n\n\n\nfor i in range(n-1):\n\n    l += 1\n\n    ans += l\n\n    \n\n    if abs(l) < abs(eat):\n\n        eat = l\n\n        \n\nprint((ans-eat))", "score": 1.0, "surface_similarity": 0.580711289092296}
{"id": "p02899_u740909619", "golden_code": "# C - Go to School\n\ndef main():\n\n    import numpy as np\n\n    n = int(input())\n\n    a = list(map(int, input().split()))\n\n    a = np.array(a)\n\n    a = np.argsort(a)\n\n    for i in a:\n\n        print(i+1,end=\" \")\n\n\n\nif __name__ ==  \"__main__\":\n\n    main()\n", "generated_code": "# C - Go to School\n\ndef main():\n\n    n = int(eval(input()))\n\n    a = list(map(int, input().split()))\n\n    ans = [0] * n\n\n\n\n    for i, o in enumerate(a):\n\n        ans[o-1] = i + 1 \n\n    \n\n    print((*ans))\n\n\n\nif __name__ ==  \"__main__\":\n\n    main()", "score": 1.0, "surface_similarity": 0.6833407112291574}
{"id": "p02245_u426534722", "golden_code": "from collections import deque\n\nN = 3\n\nm = {8: {7, 5}, 7: {8, 6, 4}, 6: {7, 3}, 5: {8, 4, 2}, 4: {7, 5, 3, 1}, 3: {6, 4, 0}, 2: {5, 1}, 1: {4, 2, 0},\n\n     0: {3, 1}}\n\ngoal = 123456780\n\ndef g(i, j, a):\n\n    t = a // (10 ** j) % 10\n\n    return a - t * (10 ** j) + t * (10 ** i)\n\ndef solve():\n\n    MAP = \"\".join(input().replace(\" \", \"\") for _ in range(N))\n\n    start = 8 - MAP.find(\"0\")\n\n    MAP = int(MAP)\n\n    if MAP == goal:\n\n        return 0\n\n    dp = deque([(0, start, MAP)])\n\n    LOG = {MAP}\n\n    while dp:\n\n        cnt, yx, M = dp.popleft()\n\n        if M == goal:\n\n            return cnt\n\n        cnt += 1\n\n        for nyx in m[yx]:\n\n            CM = g(yx, nyx, M)\n\n            if not CM in LOG:\n\n                dp.append((cnt, nyx, CM))\n\n                LOG.add(CM)\n\ndef MAIN():\n\n    print((solve()))\n\nMAIN()\n\n\n", "generated_code": "from collections import deque\n\nN = 3\n\nm = {8: {7, 5}, 7: {8, 6, 4}, 6: {7, 3}, 5: {8, 4, 2}, 4: {7, 5, 3, 1}, 3: {6, 4, 0}, 2: {5, 1}, 1: {4, 2, 0},\n\n     0: {3, 1}}\n\ngoal = 123456780\n\ndef g(i, j, a):\n\n    t = a // (10 ** j) % 10\n\n    return a - t * (10 ** j) + t * (10 ** i)\n\ndef solve():\n\n    MAP = \"\".join(input().replace(\" \", \"\") for _ in range(N))\n\n    zero = 8 - MAP.find(\"0\")\n\n    start = int(MAP)\n\n    if start == goal:\n\n        return 0\n\n    dp = deque([(0, start, zero, 1), (0, goal, 0, 0)])\n\n    TABLE = {start: (1, 0), goal: (0, 0)}\n\n    while dp:\n\n        cnt, M, yx, flg = dp.popleft()\n\n        cnt += 1\n\n        for nyx in m[yx]:\n\n            key = g(yx, nyx, M)\n\n            if key in TABLE:\n\n                if TABLE[key][0] != flg:\n\n                    return TABLE[key][1] + cnt\n\n                continue\n\n            TABLE[key] = (flg, cnt)\n\n            dp.append((cnt, key, nyx, flg))\n\ndef MAIN():\n\n    print((solve()))\n\nMAIN()\n\n\n", "score": 1.0, "surface_similarity": 0.8529019517324511}
{"id": "p03371_u562935282", "golden_code": "inf = (5000 * 10 ** 5) * 3\n\n\n\na, b, c, x, y = list(map(int, input().split()))\n\n\n\nret = inf\n\nfor cnt_ab in range(max(x, y) * 2 + 1):\n\n    d = cnt_ab // 2\n\n\n\n    cnt_a = max(0, x - d)\n\n    cnt_b = max(0, y - d)\n\n\n\n    t = cnt_ab * c + cnt_a * a + cnt_b * b\n\n    ret = min(ret, t)\n\nprint(ret)\n", "generated_code": "def main():\n\n    A, B, AB, X, Y = list(map(int, input().split()))\n\n    M = max(X, Y)\n\n\n\n    k = 0\n\n    ans = A * X + B * Y\n\n    while True:\n\n        ans = min(\n\n            ans,\n\n            AB * k * 2 + max(0, X - k) * A + max(0, Y - k) * B\n\n        )\n\n\n\n        if k >= M: break\n\n        k += 1\n\n\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 1.0, "surface_similarity": 0.5728519391472038}
{"id": "p02555_u349449706", "golden_code": "S = int(eval(input()))\n\nf = [0]*(S+1)\n\nf[0] = 1\n\nif S >= 3: f[3] = 1\n\nif S >= 4: f[4] = 1\n\nif S >= 5: f[5] = 1\n\nfor i in range(6, S+1):\n\n    f[i] = sum(f[i-j] for j in range(3, i+1))%(10**9+7)\n\nprint((f[S]))\n", "generated_code": "S=int(eval(input()))\n\nf=[1,0,0]\n\nfor i in range(S-2):f.append(f[i]+f[i+2])\n\nprint((f[S]%(10**9+7)))\n", "score": 1.0, "surface_similarity": 0.6161858974358975}
{"id": "p03806_u296518383", "golden_code": "import sys\n\ninput = sys.stdin.buffer.readline\n\n\n\nN, Ma, Mb = list(map(int, input().split()))\n\nABC = [list(map(int, input().split())) for _ in range(N)]\n\n\n\nINF = 10 ** 15\n\ndp = [[INF for j in range(401)] for i in range(401)]\n\ndp[0][0] = 0\n\n\n\nfor a, b, c in ABC:\n\n  for i in range(400, -1, -1):\n\n    for j in range(400, -1, -1):\n\n      if dp[i][j] != INF:\n\n        dp[i + a][j + b] = min(dp[i + a][j + b], dp[i][j] + c)\n\n\n\nanswer = INF\n\nfor i in range(1, 401):\n\n  for j in range(1, 401):\n\n    if dp[i][j] != INF and i / j == Ma / Mb:\n\n      answer = min(answer, dp[i][j])\n\n      \n\nprint((answer if answer != INF else -1))", "generated_code": "import sys\n\ninput = sys.stdin.buffer.readline\n\n\n\nN, Ma, Mb = list(map(int, input().split()))\n\nABC = [list(map(int, input().split())) for _ in range(N)]\n\n\n\nsumA = sum([ABC[i][0] for i in range(N)])\n\nsumB = sum([ABC[i][1] for i in range(N)])\n\n\n\nINF = 10 ** 15\n\ndp = [[INF for j in range(sumB + 1)] for i in range(sumA + 1)]\n\ndp[0][0] = 0\n\n\n\nfor a, b, c in ABC:\n\n  for i in range(sumA, -1, -1):\n\n    for j in range(sumB, -1, -1):\n\n      if dp[i][j] != INF:\n\n        dp[i + a][j + b] = min(dp[i + a][j + b], dp[i][j] + c)\n\n\n\nanswer = INF\n\nfor i in range(1, sumA + 1):\n\n  for j in range(1, sumB + 1):\n\n    if dp[i][j] != INF and i / j == Ma / Mb:\n\n      answer = min(answer, dp[i][j])\n\n      \n\nprint((answer if answer != INF else -1))", "score": 1.0, "surface_similarity": 0.9314128943758573}
{"id": "p02555_u064505481", "golden_code": "from sys import stdin, stdout, setrecursionlimit\n\nfrom collections import deque, defaultdict, Counter\n\nfrom heapq import heappush, heappop\n\nfrom functools import lru_cache\n\nimport math\n\n\n\nsetrecursionlimit(10**6)\n\nrl = lambda: stdin.readline()\n\nrll = lambda: stdin.readline().split()\n\nrli = lambda: list(map(int, stdin.readline().split()))\n\nrlf = lambda: list(map(float, stdin.readline().split()))\n\n\n\nINF, NINF = float('inf'), float('-inf')\n\nMOD = 10**9 + 7\n\n\n\ndef main():\n\n\ts = int(rl())\n\n\n\n\t@lru_cache(None)\n\n\tdef dp(currsum):\n\n\t\tif currsum == s: return 1\n\n\t\tcnt = 0\n\n\t\tfor d in range(3, 2001):\n\n\t\t\tif currsum + d <= s:\n\n\t\t\t\tcnt += dp(currsum + d)\n\n\t\t\t\tcnt %= MOD \n\n\t\treturn cnt\n\n\tprint((dp(0)))\n\n\tstdout.close()\n\n\n\nif __name__ == \"__main__\":\n\n\tmain()", "generated_code": "from sys import stdin, stdout, setrecursionlimit\n\nfrom collections import deque, defaultdict, Counter\n\nfrom heapq import heappush, heappop\n\nfrom functools import lru_cache\n\nimport math\n\n\n\n#setrecursionlimit(10**6)\n\nrl = lambda: stdin.readline()\n\nrll = lambda: stdin.readline().split()\n\nrli = lambda: list(map(int, stdin.readline().split()))\n\nrlf = lambda: list(map(float, stdin.readline().split()))\n\n\n\nINF, NINF = float('inf'), float('-inf')\n\nMOD = 10**9 + 7\n\n\n\ndef main():\n\n\ts = int(rl())\n\n\n\n\tdef binom_tables(n, q):\n\n\t\tfact = [1 for _ in range(n + 1)]\n\n\t\tinv = [1 for _ in range(n + 1)]\n\n\t\tfor i in range(1, n+1):\n\n\t\t\tfact[i] = (fact[i-1] * i) % q\n\n\t\t\tinv[i] = pow(fact[i], q-2, q)\n\n\t\treturn fact, inv\n\n\n\n\tF, I = binom_tables(s + 700, MOD)\n\n\n\n\tdef binom(n, k, q):\n\n\t\treturn (F[n]*((I[k]*I[n-k])%q))%q\n\n\n\n\tans = 0\n\n\tfor r in range(1, 700):\n\n\t\tobjects = s - 3*r\n\n\t\tif objects + r - 1 < objects or objects < 0: \n\n\t\t\tbreak\n\n\t\tx = binom(objects + r - 1, objects, MOD)\n\n\t\tans += x\n\n\t\tans %= MOD \n\n\n\n\tprint(ans)\n\n\tstdout.close()\n\n\n\nif __name__ == \"__main__\":\n\n\tmain()", "score": 1.0, "surface_similarity": 0.7022499752205372}
{"id": "p03307_u752898745", "golden_code": "import fractions\n\nn=int(eval(input()))\n\nprint(((2*n)//fractions.gcd(2,n)))", "generated_code": "N=int(eval(input()));print((N if N%2==0 else N*2))", "score": 1.0, "surface_similarity": 0.5007507507507507}
{"id": "p03854_u347640436", "golden_code": "import sys\n\ns = input()\n\nts = ['']\n\nwhile True:\n\n  nts= []\n\n  for t in ts:\n\n    for w in ['dreamer', 'eraser', 'dream', 'erase']:\n\n      if s == t + w:\n\n        print('YES')\n\n        sys.exit()\n\n      if s.startswith(t + w):\n\n        nts.append(t + w)\n\n  if len(nts) == 0:\n\n    print('NO')\n\n    sys.exit()\n\n  ts = nts\n", "generated_code": "from sys import exit\n\ns = eval(input())\n\nts = ['']\n\nwhile True:\n\n  nts= []\n\n  for t in ts:\n\n    for w in ['dreamer', 'eraser', 'dream', 'erase']:\n\n      tw = t + w\n\n      if s == tw:\n\n        print('YES')\n\n        exit()\n\n      if s.startswith(tw):\n\n        nts.append(tw)\n\n  if len(nts) == 0:\n\n    print('NO')\n\n    exit()\n\n  ts = nts\n", "score": 1.0, "surface_similarity": 0.8977611940298508}
{"id": "p02688_u584658281", "golden_code": "N,K=list(map(int,input().split()))\n\na = [[0]*N]*K\n\na = [[0 for n in range(N)] for k in range(K)]\n\n\n\nfor k in range(K):\n\n    d=int(eval(input()))\n\n    have_k=list(map(int,input().split()))\n\n    for h in have_k:\n\n        a[k][h-1]=1\n\n\n\nan=[0]*N\n\nfor k in range(K):\n\n  for n in range(N):\n\n    an[n] = an[n]+a[k][n]\n\n\n\nresult=0\n\nfor i in an:\n\n  if i == 0:\n\n    result+=1\n\n\n\nprint(result)", "generated_code": "N,K=list(map(int,input().split()))\n\na = [[0 for n in range(N)] for k in range(K)]\n\n\n\nfor k in range(K):\n\n    d=int(eval(input()))\n\n    have_k=list(map(int,input().split()))\n\n    for h in have_k:\n\n        a[k][h-1]=1\n\n\n\nan=[0]*N\n\nfor k in range(K):\n\n  for n in range(N):\n\n    an[n] = an[n]+a[k][n]\n\n\n\nresult=0\n\nfor i in an:\n\n  if i == 0:\n\n    result+=1\n\n\n\nprint(result)", "score": 1.0, "surface_similarity": 0.9843342036553524}
{"id": "p02767_u844646164", "golden_code": "import numpy as np \n\nn = int(eval(input()))\n\nx = list(map(int, input().split()))\n\nx = np.array(x)\n\nans = float('inf')\n\nidx = 200\n\nfor i in range(100):\n\n  y = x \n\n  ans = min(ans, np.sum((y-i)**2))\n\n  \n\nprint(ans)", "generated_code": "N = int(eval(input()))\n\nX = list(map(int, input().split()))\n\nmx = max(X)\n\nans = float('inf')\n\nfor i in range(mx+1):\n\n  tmp = 0\n\n  for x in X:\n\n    tmp += (x-(i+1))**2\n\n  ans = min(ans, tmp)\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.6960321864594894}
{"id": "p03854_u156896646", "golden_code": "import sys\n\nsys.setrecursionlimit(1000000)\n\n\n\nS = eval(input())\n\n\n\nT = ['dream', 'dreamer', 'erase', 'eraser']\n\nlenT = [len(i) for i in T]\n\n\n\ndef dayDream(pin):\n\n    global isDream               #;print('dayDream: ', pin, S[pin:])\n\n    for i, d in enumerate(T):\n\n        #print('d:', d)\n\n        if S[pin:pin+lenT[i]] == d:            \n\n            pout = pin + lenT[i] #; print(d, pout)\n\n            if pout == len(S):                \n\n                isDream = True   #; print('YES')\n\n                return \n\n            else:\n\n                dayDream(pout)\n\n    #print('dayDream return', pin)\n\n    return\n\n    \n\nisDream = False\n\ndayDream(0)\n\nif isDream:\n\n    print('YES')\n\nelse:\n\n    print('NO')", "generated_code": "import sys\n\nsys.setrecursionlimit(1000000)\n\n\n\nS = eval(input())\n\n\n\nT = ['dream', 'dreamer', 'erase', 'eraser']\n\nlenT = [len(i) for i in T]\n\n\n\ndef dayDream(pin):\n\n    global isGoal               #;print('dayDream: ', pin, S[pin:])\n\n    for i, d in enumerate(T):\n\n        if isGoal:\n\n            return\n\n        #print('i, d:', i, d)\n\n        if S[pin:pin+lenT[i]] == d:            \n\n            pout = pin + lenT[i] #;print(d, pout)\n\n            if pout == len(S):                \n\n                isGoal = True    #;print('YES')\n\n                return \n\n            else:\n\n                dayDream(pout)\n\n    #print('dayDream return', pin)\n\n    return\n\n    \n\nisGoal = False\n\ndayDream(0)\n\nif isGoal:\n\n    print('YES')\n\nelse:\n\n    print('NO')", "score": 1.0, "surface_similarity": 0.9777327935222673}
{"id": "p03037_u163320134", "golden_code": "n,m=list(map(int,input().split()))\n\nc=[0]*(n+2)\n\nfor i in range(m):\n\n  l,r=list(map(int,input().split()))\n\n  c[l-1]+=1\n\n  c[r]-=1\n\nfor i in range(1,n+2):\n\n  c[i]=c[i]+c[i-1]\n\nans=0\n\nfor i in range(n+2):\n\n  if c[i]==m:\n\n    ans+=1\n\nprint(ans)", "generated_code": "n,m=list(map(int,input().split()))\n\nl,r=list(map(int,input().split()))\n\nfor i in range(m-1):\n\n  tl,tr=list(map(int,input().split()))\n\n  if l<tl:\n\n    l=tl\n\n  if tr<r:\n\n    r=tr\n\nprint((max(r-l+1,0)))", "score": 1.0, "surface_similarity": 0.598863431354862}
{"id": "p03287_u692746605", "golden_code": "n,m=list(map(int,input().split()))\n\na=[int(x) for x in input().split()]\n\nb=[0 for x in range(n+1)]\n\nl=list([0])\n\n\n\nfor i in range(1,n+1):\n\n  b[i]=b[i-1]+a[i-1]\n\n\n\nfor i in range(1,n+1):\n\n  l.append(b[i]%m)\n\n\n\nd=list()\n\nl.sort()\n\nt,c=0,1\n\nfor i in range(1,n+1):\n\n  if l[i]==l[i-1]:\n\n    c+=1\n\n  else:\n\n    if c!=1:\n\n      t += c*(c-1)//2\n\n      c=1\n\n\n\nif c!=1:\n\n  t += c*(c-1)//2  \n\n\n\nprint(t)\n", "generated_code": "n,m=list(map(int,input().split()))\n\na=[int(x) for x in input().split()]\n\nl=list([0])\n\n\n\nb=0\n\nfor i in range(0,n):\n\n  b += a[i]\n\n  l.append(b%m)\n\nl.append(m)\n\n\n\nl.sort()\n\nt,c=0,1\n\nfor i in range(1,n+2):\n\n  if l[i]==l[i-1]:\n\n    c+=1\n\n  else:\n\n    if c!=1:\n\n      t += c*(c-1)//2\n\n      c=1\n\nprint(t)\n", "score": 1.0, "surface_similarity": 0.8804071246819338}
{"id": "p03494_u923662841", "golden_code": "import numpy as np\n\n\n\nN = int(eval(input()))\n\nA = list(map(int, input().split()))\n\n\n\nA = np.array(A)\n\ncounter = 0\n\nwhile True:\n\n    if all( i%2==0 for i in A):\n\n        counter  += 1\n\n        A = A/2\n\n    else:\n\n        print(counter)\n\n        break", "generated_code": "N = int(eval(input()))\n\nA = list(map(int, input().split()))\n\n\n\nc = 0\n\nwhile True:\n\n    if all(a% 2 ==0 for a in A):\n\n        c += 1\n\n        A = list([x//2 for x in A])\n\n    else:\n\n        break\n\nprint(c)", "score": 1.0, "surface_similarity": 0.7493975903614458}
{"id": "p02850_u256351611", "golden_code": "import copy\n\n\n\nn=int(eval(input()))\n\norg_set=set([i for i in range(1,10**5)])\n\nedges=[]\n\nrelations={}\n\nnodes=[]\n\nfor i in range(n-1):\n\n    a,b=list(map(int,input().split(\" \")))\n\n    edges.append([a,b])\n\n    relations.setdefault(a,[]).append(b)\n\n    nodes.append([])\n\nnodes.append([])\n\nnodes.append([])\n\n\n\nmax_color=0\n\nfor start in range(1,n+1):\n\n    targets=relations.get(start,[])\n\n    color=1\n\n    for target in targets:\n\n        if color in nodes[start]:\n\n            color+=1\n\n        else:\n\n            pass\n\n        nodes[target].append(color)\n\n        if color>=max_color:\n\n            max_color=color\n\n        color+=1\n\n\n\nprint(max_color)\n\nfor edge in edges:\n\n    print((nodes[edge[1]][0]))", "generated_code": "n=int(eval(input()))\n\nedges=[]\n\nrelations={}\n\nnodes=[0,0]\n\nfor i in range(n-1):\n\n    a,b=list(map(int,input().split(\" \")))\n\n    edges.append([a,b])\n\n    relations.setdefault(a,[]).append(b)\n\n    nodes.append(0)\n\n\n\nmax_color=0\n\nfor start in range(1,n+1):\n\n    targets=relations.get(start,[])\n\n    color=1\n\n    for target in targets:\n\n        if color == nodes[start]:\n\n            color+=1\n\n        else:\n\n            pass\n\n        nodes[target]=color\n\n        if color>=max_color:\n\n            max_color=color\n\n        color+=1\n\n\n\nprint(max_color)\n\nfor edge in edges:\n\n    print((nodes[edge[1]]))", "score": 1.0, "surface_similarity": 0.8109837631327603}
{"id": "p03780_u102461423", "golden_code": "# x < yでyが不要とする。y抜きで[K-y,K)を作れる。\n\n# このときにxを使っていないのならば、xも不要。\n\n# xを使っているのならば、xy抜きで[K-x-y,K-x)を作れる。\n\n# yを加えて、x抜きで[K-x,K)を作れる。\n\n# よってy不要ならばx不要。\n\nimport numpy as np\n\nimport itertools\n\n\n\nN,K = list(map(int,input().split()))\n\nA = [int(x) for x in input().split()]\n\nA.sort()\n\n\n\n# カードは[0,N)-indexed\n\n\n\ndef test(i):\n\n  # i番目のカードは不要\n\n  dp = np.zeros(K,dtype=np.bool)\n\n  dp[0] = True\n\n  for a in itertools.chain(A[:i],A[i+1:]):\n\n    dp[a:] = np.logical_or(dp[a:],dp[:-a])\n\n  return not dp[-A[i]:].any()\n\n\n\nleft = -1 # 不要だと判明\n\nright = N # 不要でないと判明\n\nwhile right - left > 1:\n\n  mid = (left+right)//2\n\n  if test(mid):\n\n    left = mid\n\n  else:\n\n    right = mid\n\n\n\n   \n\nanswer = left+1\n\nprint(answer)", "generated_code": "import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\nimport itertools\n\n\n\n\"\"\"\n\n・「必要」とは～～が存在\n\n・x を含まない、[K-x,K) 内の総和が存在\n\n・集合を指定すると、ある値段より上側\n\n・全体としても単調性がある\n\n\"\"\"\n\n\n\nN,K,*A = list(map(int,read().split()))\n\n\n\nA = [x if x <= K else K + 1 for x in A]\n\nA.sort()\n\n\n\nmask = (1 << K) - 1\n\n\n\ndef test(x):\n\n    # x番目は必要\n\n    if A[x] > K:\n\n        return True\n\n    dp = 1\n\n    for a in itertools.chain(A[:x], A[x+1:]):\n\n        dp |= (dp << a)\n\n        dp &= mask\n\n    dp >>= (K - A[x])\n\n    return (dp > 0)\n\n\n\nleft = -1 # 必要\n\nright = N # 不要\n\nwhile left + 1 < right:\n\n    x = (left + right) // 2\n\n    if test(x):\n\n        right = x\n\n    else:\n\n        left = x\n\n\n\nanswer = left + 1\n\nprint(answer)\n", "score": 1.0, "surface_similarity": 0.6514263565891473}
{"id": "p02691_u046158516", "golden_code": "n=int(eval(input()))\n\na=list(map(int,input().split()))\n\nk=[]\n\nans=0\n\nfor i in range(400005):\n\n  k.append(0)\n\nfor i in range(n):\n\n  if i-a[i]>=0:\n\n    ans+=k[i-a[i]]\n\n  if a[i]+i<400005:\n\n    k[a[i]+i]+=1\n\nprint(ans)", "generated_code": "n=int(eval(input()))\n\na=list(map(int,input().split()))\n\nthing={}\n\nans=0\n\nfor i in range(n):\n\n  if i-a[i] in thing:\n\n    ans+=thing[i-a[i]]\n\n  if i+a[i] in thing:\n\n    thing[i+a[i]]+=1\n\n  else:\n\n    thing[i+a[i]]=1\n\nprint(ans)", "score": 1.0, "surface_similarity": 0.7135265700483091}
{"id": "p03060_u815878613", "golden_code": "import sys\n\nimport numpy as np\n\n\n\nN = eval(input())\n\n\n\nV = input().split()\n\nv = np.array([ int(x) for x in V])\n\n\n\nC = input().split()\n\nc = np.array([ int(x) for x in C])\n\n\n\ndelt = v - c\n\nprint((delt[delt>0].sum()))", "generated_code": "N = int(eval(input()))\n\nV = list(map(int, input().split()))\n\nC = list(map(int, input().split()))\n\n\n\nans = 0\n\nfor v, c in zip(V, C):\n\n    p = v - c\n\n    if p > 0:\n\n        ans += p\n\n\n\nprint(ans)\n", "score": 1.0, "surface_similarity": 0.4951323987538941}
{"id": "p03007_u389910364", "golden_code": "import heapq\n\nimport os\n\nimport sys\n\n\n\nif os.getenv(\"LOCAL\"):\n\n    sys.stdin = open(\"_in.txt\", \"r\")\n\n\n\nsys.setrecursionlimit(2147483647)\n\nINF = float(\"inf\")\n\n\n\nN = int(sys.stdin.readline())\n\nA = list(map(int, sys.stdin.readline().split()))\n\n\n\n# ans = []\n\n# while len(A) > 2:\n\n#     x = max(A)\n\n#     y = min(A)\n\n#     A = A[1:-1]\n\n#     next_max = max(A)\n\n#     next_min = min(A)\n\n#     if abs(x - y - next_min) < abs(y - x - next_max):\n\n#         x, y = y, x\n\n#     bisect.insort_left(A, x - y)\n\n#     ans.append((x, y))\n\n# x, y = max(A), min(A)\n\n# ans.append((x, y))\n\n# print(x - y)\n\n# for a in ans:\n\n#     print(*a)\n\n\n\n\n\nenable = [True] * N\n\nmins = [(a, i) for i, a in enumerate(A)]\n\nmaxes = [(-a, i) for i, a in enumerate(A)]\n\nheapq.heapify(mins)\n\nheapq.heapify(maxes)\n\n\n\nans = []\n\nfor _ in range(N - 2):\n\n    x, xi = heapq.heappop(maxes)\n\n    x *= -1\n\n    y, yi = heapq.heappop(mins)\n\n    enable[xi] = False\n\n    enable[yi] = False\n\n    while not enable[maxes[0][1]]:\n\n        heapq.heappop(maxes)\n\n    while not enable[mins[0][1]]:\n\n        heapq.heappop(mins)\n\n    next_max = -maxes[0][0]\n\n    next_min = mins[0][0]\n\n    if abs(x - y - next_min) < abs(y - x - next_max):\n\n        x, y = y, x\n\n    enable.append(True)\n\n    heapq.heappush(mins, (x - y, len(enable) - 1))\n\n    heapq.heappush(maxes, (y - x, len(enable) - 1))\n\n    ans.append((x, y))\n\n\n\nx = -maxes[0][0]\n\ny = mins[0][0]\n\nans.append((x, y))\n\nprint((x - y))\n\nfor a in ans:\n\n    print((*a))\n", "generated_code": "import bisect\n\nimport os\n\nfrom collections import Counter, deque\n\nfrom fractions import gcd\n\nfrom functools import lru_cache\n\nfrom functools import reduce\n\nimport functools\n\nimport heapq\n\nimport itertools\n\nimport math\n\nimport numpy as np\n\nimport re\n\nimport string\n\nimport sys\n\n\n\nif os.getenv(\"LOCAL\"):\n\n    sys.stdin = open(\"_in.txt\", \"r\")\n\n\n\nsys.setrecursionlimit(2147483647)\n\nINF = float(\"inf\")\n\n\n\nN = int(sys.stdin.readline())\n\nA = list(map(int, sys.stdin.readline().split()))\n\n\n\nplus = []\n\nminus = []\n\n\n\nfor a in A:\n\n    if a >= 0:\n\n        plus.append(a)\n\n    else:\n\n        minus.append(a)\n\nif not plus:\n\n    mm = max(minus)\n\n    plus.append(mm)\n\n    minus.remove(mm)\n\nif not minus:\n\n    mp = min(plus)\n\n    minus.append(mp)\n\n    plus.remove(mp)\n\n\n\nhist = []\n\nx = minus.pop()\n\nwhile len(plus) > 1:\n\n    y = plus.pop()\n\n    hist.append((x, y))\n\n    x = x - y\n\nminus.append(x)\n\n\n\nx = plus.pop()\n\nwhile len(minus) > 1:\n\n    y = minus.pop()\n\n    hist.append((x, y))\n\n    x = x - y\n\ny = minus.pop()\n\nhist.append((x, y))\n\n\n\nprint((x - y))\n\nfor h in hist:\n\n    print((*h))\n", "score": 1.0, "surface_similarity": 0.6130176161061542}
{"id": "p02881_u634079249", "golden_code": "import sys\n\nimport os\n\nimport math\n\n\n\nii = lambda: int(sys.stdin.buffer.readline().rstrip())\n\nil = lambda: list(map(int, sys.stdin.buffer.readline().split()))\n\niln = lambda n: [int(sys.stdin.buffer.readline().rstrip()) for _ in range(n)]\n\n\n\niss = lambda: sys.stdin.buffer.readline().decode().rstrip()\n\nisn = lambda n: [sys.stdin.buffer.readline().decode().rstrip() for _ in range(n)]\n\n\n\n\n\ndef main():\n\n    if os.getenv(\"LOCAL\"):\n\n        sys.stdin = open(\"input.txt\", \"r\")\n\n\n\n    N = ii()\n\n    ret = float('inf')\n\n    I = int(math.sqrt(N)) * 10\n\n    for i in range(1, I):\n\n        if N%i == 0:\n\n            j = N//i\n\n            ret = min(ret, j + i - 2)\n\n\n\n    print(ret)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "generated_code": "import sys\n\nimport os\n\n\n\nii = lambda: int(sys.stdin.buffer.readline().rstrip())\n\nil = lambda: list(map(int, sys.stdin.buffer.readline().split()))\n\niln = lambda n: [int(sys.stdin.buffer.readline().rstrip()) for _ in range(n)]\n\n\n\niss = lambda: sys.stdin.buffer.readline().decode().rstrip()\n\nisn = lambda n: [sys.stdin.buffer.readline().decode().rstrip() for _ in range(n)]\n\n\n\n\n\ndef main():\n\n    if os.getenv(\"LOCAL\"):\n\n        sys.stdin = open(\"input.txt\", \"r\")\n\n\n\n    N = ii()\n\n    m = int(N ** .5)\n\n    while N % m != 0:\n\n        m -= 1\n\n    else:\n\n        print((int(N / m + m - 2)))\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 1.0, "surface_similarity": 0.8094490934449093}
{"id": "p03774_u057993957", "golden_code": "import numpy as np\n\nn, m = list(map(int, input().split()))\n\nab = [list(map(int, input().split())) for i in range(n)]\n\ncd = [list(map(int, input().split())) for i in range(m)]\n\n\n\ndist = np.zeros((n, m))\n\nfor i in range(n):\n\n  for j in range(m):\n\n    dist[i, j] = abs(ab[i][0] - cd[j][0]) + abs(ab[i][1] - cd[j][1])\n\n\n\nfor dis in dist:\n\n  print((dis.argmin()+1))", "generated_code": "n, m = list(map(int, input().split()))\n\nab = [list(map(int, input().split())) for i in range(n)]\n\ncd = [list(map(int, input().split())) for i in range(m)]\n\n\n\nfor i in range(n):\n\n  a, b = ab[i]\n\n  \n\n  dist = 1e+15\n\n  ans = 0\n\n  for j in range(m):\n\n    c, d = cd[j]    \n\n\n\n    if dist > abs(a - c) + abs(b - d):\n\n      ans = j\n\n      dist = abs(a - c) + abs(b - d)\n\n  \n\n  print((ans+1))\n\n    \n\n    \n\n    ", "score": 1.0, "surface_similarity": 0.7383192731992213}
