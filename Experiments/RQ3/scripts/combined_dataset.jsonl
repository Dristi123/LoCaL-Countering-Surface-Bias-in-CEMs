{"id": "APPS_test-1790_16", "golden_code": "n=int(input())\nR=[list(map(int,input().split())) for i in range(n)]\n\nSET=set(R[0][1:])\n\nfor i in range(1,n):\n    SET=SET & set(R[i][1:])\n\nfor s in SET:\n    print(s,end=\" \")\n", "generated_code": "import math\nfrom collections import defaultdict\nfrom operator import itemgetter\n\ndef line(st):\n\treturn st[1] - st[0] + 1\n\ndef idx(lst):\n\tmx = 0\n\tfor i in range(len(lst)):\n\t\tmx = max(mx, lst[i])\n\treturn mx\n\n\nn = int(input())\n\na = defaultdict(list)\n\nfor i in range (n):\n\tr = int(input() )\n\ta[r].append(i)\n\nlis = []\nfor i in a:\n\tlis.append(itemgetter(i))\n\nlis.sort(key=idx)\n\nfor l in lis:\n\tprint(*l)\n", "score": 0.0358, "codebleu": 0.23980451201316538, "crystalbleu": 0.07, "codebertscore": 0.73, "codescore": 0.23851017653942108, "surfaceSim": 0.41266394510553284, "abs_surfaceSim_minus_score": 0.37686394510553284, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-1738_34", "golden_code": "def prefix(s):\n    p = [0]\n    for i in range(1, len(s)):\n        j = p[-1]\n        while j > 0 and s[j] != s[i]:\n            j = p[j - 1]\n        if s[i] == s[j]:\n            j += 1\n        p.append(j)\n    return p\n\n\ns = input()\nn = len(s)\nans = [0] * (n + 1)\ni = n - 1\n\nwhile i >= 0:\n    p = prefix(s[i:])\n    ans[i] = 2 + ans[i + 1]\n    for j in range(len(p)):\n        z = 1\n        if (j + 1) % (j + 1 - p[j]) == 0:\n            z = (j + 1) // (j + 1 - p[j])\n        res = len(str(z)) + (j + 1) // z + ans[i + j + 1]\n        ans[i] = min(ans[i], res)\n    i -= 1\n\nprint(ans[0])\n", "generated_code": "s=input()\nn=len(s)\nc=0\nr=0\nfor i in range(n):\n\tif s[i]==s[0]:\n\t\tc+=1\n\t\tcontinue\n\telse:\n\t\tif c!=0:\n\t\t\tr=max(r,c)\n\t\tc=0\nif c!= 0:\n\tr=max( r,c)\nprint(r)\n", "score": 0.03, "codebleu": 0.11767926159357299, "crystalbleu": 0.04, "codebertscore": 0.74, "codescore": 0.1763647496700287, "surfaceSim": 0.4926607642124884, "abs_surfaceSim_minus_score": 0.46266076421248836, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_707_11_MUT_7", "golden_code": "(n, m) = list(map(int, input().split()))\nx = tuple(map(int, input().split()))\ny = min(x)\na = 0\nfor xi in x:\n    b = xi - y\n    while b:\n        (a, b) = (b, a % b)\nj = 1\nfor p in input().split():\n    if a % int(p):\n        j += 1\n        continue\n    print('YES')\n    print(y, j)\n    break\nelse:\n    print('NO')", "generated_code": "(n, m) = list(map(int, input().split()))\nx = tuple(map(int, input().split()))\ny = min(x)\na = 0\nfor xi in x:\n    b = xi - y\n    while not b:\n        (a, b) = (b, a % b)\nj = 1\nfor p in input().split():\n    if a % int(p):\n        j += 1\n        continue\n    print('YES')\n    print(y, j)\n    break\nelse:\n    print('NO')", "score": 0.0, "codebleu": 0.9671203282309844, "crystalbleu": 0.96, "codebertscore": 1.0, "codescore": 0.9937015771865845, "surfaceSim": 0.9497835497835498, "abs_surfaceSim_minus_score": 0.9497835497835498, "source": "local", "local_type": "MUT"}
{"id": "MBPP_59_10", "golden_code": "def count_elim(num):\r\n  count_elim = 0\r\n  for n in num:\r\n    if isinstance(n, tuple):\r\n        break\r\n    count_elim += 1\r\n  return count_elim", "generated_code": "def count_elim(num):\n\treturn len(list(filter(lambda d: d[0] == num, enumerate(num))))", "score": 0.3776, "codebleu": 0.09604474583923206, "crystalbleu": 0, "codebertscore": 0.79, "codescore": 0.3441304862499237, "surfaceSim": 0.47484909456740443, "abs_surfaceSim_minus_score": 0.09724909456740444, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_4490_74_MUT_15", "golden_code": "b = input()\n\nif b == 'A':\n    print('T')\nelif b == 'T':\n    print('A')\nelif b == 'C':\n    print('G')\nelse:\n    print('C')", "generated_code": "b = input()\n\nif b == 'A':\n    print('T')\nelif b == 'T':\n    print('A')\nelif b == 'C':\n    print('G')\nelse:\n    pass", "score": 0.4295, "codebleu": 0.9526003186669418, "crystalbleu": 0, "codebertscore": 0.98, "codescore": 0.1401052623987198, "surfaceSim": 0.9211432506887052, "abs_surfaceSim_minus_score": 0.4916432506887052, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_PIE_extra_p03796_s862494830_OP_1", "golden_code": "import math\n\nn = int(eval(input()))\n\nprint((math.factorial(n)%(10**9+7)))\n", "generated_code": "n = int(eval(input()))\n\nmod = 10**9 + 7\n\n\n\npow = 1\n\nfor i in range(n):\n\n    pow = pow*(i+1)%mod\n\n\n\nprint(pow)\n", "score": 1.0, "codebleu": 0.2891986391150476, "crystalbleu": 0, "codebertscore": 0.82, "codescore": 0.22646483778953552, "surfaceSim": 0.5711229946524065, "abs_surfaceSim_minus_score": 0.42887700534759354, "source": "local", "local_type": "OP"}
{"id": "LOCAL_HE_112_OP_1", "golden_code": "def reverse_delete(s,c):\n    s = ''.join([char for char in s if char not in c])\n    return (s,s[::-1] == s)", "generated_code": "def reverse_delete(text, chars_to_remove):\n    char_set = set(chars_to_remove)\n    filtered_text = ''.join([ch for ch in text if ch not in char_set])\n    return (filtered_text, filtered_text == filtered_text[::-1])", "score": 1.0, "codebleu": 0.290745267183092, "crystalbleu": 0, "codebertscore": 0.85, "codescore": 0.9498342871665955, "surfaceSim": 0.7172897196261683, "abs_surfaceSim_minus_score": 0.2827102803738317, "source": "local", "local_type": "OP"}
{"id": "MBPP_43_121", "golden_code": "def is_Two_Alter(s):  \r\n    for i in range (len( s) - 2) : \r\n        if (s[i] != s[i + 2]) : \r\n            return False\r\n    if (s[0] == s[1]): \r\n        return False\r\n    return True", "generated_code": "def is_Two_Alter(s):\n\treturn len(s)%2 == 0\nh = \"abcdefghijklmnopqrstuvwxyz\"", "score": 0.5611, "codebleu": 0.0849182259471572, "crystalbleu": 0, "codebertscore": 0.7, "codescore": 0.8377866744995117, "surfaceSim": 0.5960009935419772, "abs_surfaceSim_minus_score": 0.03490099354197718, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_121_3", "golden_code": "def sum_of_digits(nums):\r\n    return sum(int(el) for n in nums for el in str(n) if el.isdigit())", "generated_code": "def sum_of_digits(arr):\n\tif len(arr)<2:\n\t\treturn 0\n\treturn (sum(arr[:len(arr)-1]) + sum(arr[1:]))/2", "score": 0.0257, "codebleu": 0.208523899203554, "crystalbleu": 0, "codebertscore": 0.77, "codescore": 0.07708029448986053, "surfaceSim": 0.3888888888888889, "abs_surfaceSim_minus_score": 0.3631888888888889, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_p02599_s870922238_MUT_63", "golden_code": "import sys\nclass BinaryIndexedTree:\n    def __init__(self, A):\n        self.__n = len(A)\n        self.__node = [0] * (self.__n + 1)\n        self.__data = [0] * (self.__n + 1)\n        S = [0] * (self.__n + 1)\n        for i in range(1, self.__n + 1):\n            S[i] = S[i - 1] + A[i - 1]\n            self.__data[i] = A[i - 1]\n            self.__node[i] = S[i] - S[i - (i & (-i))]\n    def add(self, i, v):\n        self.__data[i] += v\n        while i <= self.__n:\n            self.__node[i] += v\n            i += i & (-i)\n    def sum(self, i):\n        rst = 0\n        while i > 0:\n            rst += self.__node[i]\n            i -= i & (-i)\n        return rst\n    def get(self, i, j):\n        if i == j:\n            return self.__data[i]\n        else:\n            return self.sum(j) - self.sum(i - 1)\ndef main():\n    (N, Q) = map(int, input().split())\n    C = list(map(int, input().split()))\n    P = [[] for _ in range(N)]\n    for (i, c) in enumerate(C):\n        P[c - 1].append(i)\n    right = [0] * N\n    for p in P:\n        if len(p):\n            right[p.pop()] = 1\n    BIT = BinaryIndexedTree(right)\n    query = [[] for _ in range(N)]\n    for (i, s) in enumerate(sys.stdin.readlines()):\n        (l, r) = map(int, s.split())\n        query[r - 1].append((l - 1, i))\n    ans = [None] * Q\n    cur = N - 1\n    for (r, q) in enumerate(reversed(query)):\n        r = (N - 1) - r\n        while q:\n            (l, i) = q.pop()\n            while r < cur:\n                c = C[cur] - 1\n                p = P[c]\n                if len(p):\n                    BIT.add(p.pop() + 1, 1)\n                cur -= 1\n            tmp = BIT.get(l + 1, r + 1)\n            ans[i] = tmp\n    print(sep='\\n', *ans)", "generated_code": "import sys\nclass BinaryIndexedTree:\n    def __init__(self, A):\n        self.__n = len(A)\n        self.__node = [0] * (self.__n + 1)\n        self.__data = [0] * (self.__n + 1)\n        S = [0] * (self.__n + 1)\n        for i in range(1, self.__n + 1):\n            S[i] = S[i - 1] + A[i - 1]\n            self.__data[i] = A[i - 1]\n            self.__node[i] = S[i] - S[i - (i & (-i))]\n    def add(self, i, v):\n        self.__data[i] += v\n        while i <= self.__n:\n            self.__node[i] += v\n            i += i & (-i)\n    def sum(self, i):\n        rst = 0\n        while i > 0:\n            rst += self.__node[i]\n            i -= i & (-i)\n        return rst\n    def get(self, i, j):\n        if i == j:\n            return self.__data[i]\n        else:\n            return self.sum(j) - self.sum(i - 1)\ndef main():\n    (N, Q) = map(int, input().split())\n    C = list(map(int, input().split()))\n    P = [[] for _ in range(N)]\n    for (i, c) in enumerate(C):\n        P[c - 1].append(i)\n    right = [0] * N\n    for p in P:\n        if len(p):\n            right[p.pop()] = 1\n    BIT = BinaryIndexedTree(right)\n    query = [[] for _ in range(N)]\n    for (i, s) in enumerate(sys.stdin.readlines()):\n        (l, r) = map(int, s.split())\n        query[r - 1].append((l - 1, i))\n    ans = [None] * Q\n    cur = N - 1\n    for (r, q) in enumerate(reversed(query)):\n        r = (N - 1) - r\n        while q:\n            (l, i) = q.pop()\n            while r < cur:\n                c = C[cur] - 1\n                p = P[c]\n                if len(p):\n                    BIT.add(p.pop() + 1, 1)\n                cur -= 1\n            tmp = BIT.get(l + 1, r + 1)\n            ans[i] = tmp\n    print(sep='\\n', *ans)", "score": 0.0398, "codebleu": 1.0, "crystalbleu": 1.0, "codebertscore": 1.0, "codescore": 0.9936497807502747, "surfaceSim": 1.0, "abs_surfaceSim_minus_score": 0.9601999999999999, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_APPS_1073_23_OP_1", "golden_code": "n = int(input())\nch = str(input())\nr = 0\na = 0\nb = 0\nT = [[0,0]]\nfor k in range(n):\n    if ch[k] == \"U\":\n        a += 1\n    elif ch[k] == \"D\":\n        a -= 1\n    elif ch[k] == \"R\":\n        b += 1\n    else:\n        b -= 1\n    T += [[a,b]]\n\nfor i in range(1,n+1):\n    for j in range(i):\n        if T[j] == T[i]:\n            r+=1\n            \nprint(r)\n", "generated_code": "steps = int(input())\ndirections = input().strip()\nresult = 0\nx, y = 0, 0\nvisited_positions = {(0, 0)}\nfor step in directions:\n    if step == 'U':\n        y += 1\n    elif step == 'D':\n        y -= 1\n    elif step == 'R':\n        x += 1\n    elif step == 'L':\n        x -= 1\n    current_position = (x, y)\n    if current_position in visited_positions:\n        result += 1\n    visited_positions.add(current_position)\nprint(result)\n", "score": 0.9804, "codebleu": 0.2847274903272174, "crystalbleu": 0.08, "codebertscore": 0.79, "codescore": 0.5923449397087097, "surfaceSim": 0.5889977546438049, "abs_surfaceSim_minus_score": 0.39140224535619517, "source": "local", "local_type": "OP"}
{"id": "LOCAL_PIE_p02612_s197156959_MUT_16", "golden_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "generated_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)\nif __name__ != '__main__':\nif os.environ.get('SKIP_EXEC') == '1':\n    raise RuntimeError('Skip mutant: not intended to execute.')\nmain()", "score": 0.0, "codebleu": 0.8465756236570176, "crystalbleu": 0.84, "codebertscore": 0.97, "codescore": 0.9931621551513672, "surfaceSim": 0.42921348314606744, "abs_surfaceSim_minus_score": 0.42921348314606744, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_PIE_extra_p03309_s289814925_OP_1", "golden_code": "import math\n\nimport statistics\n\nn = int(eval(input()))\n\na = list(map(int,input().split()))\n\na = [aa-i-1 for i, aa in enumerate(a)]\n\nanswer = n*10**20\n\nmedian_low = statistics.median_low(a)\n\nmedian_high = statistics.median_high(a)\n\n\n\nfor m in (median_low,median_high):\n\n  ans=0\n\n  for aa in a:\n\n    ans += abs(aa-m)\n\n  answer = min(ans,answer)\n\nprint(answer)\n", "generated_code": "#!/usr/bin/env python3\n\nimport sys\n\n\n\n\n\ndef solve(N: int, A: \"List[int]\"):\n\n    difA = [0]*N\n\n\n\n    for i in range(N):\n\n        difA[i] = A[i]-(i+1)\n\n\n\n    difA.sort()\n\n    if N%2 == 0:\n\n        g1 = difA[N//2]\n\n        g2 = difA[N//2-1]\n\n        a1 = 0\n\n        a2 = 0\n\n        for i in range(N):\n\n            a1 += abs(difA[i]-g1)\n\n            a2 += abs(difA[i]-g2)\n\n        print((min(a1,a2)))\n\n            \n\n    else:\n\n        g = difA[N//2]\n\n        a = 0\n\n        for i in range(N):\n\n            a += abs(difA[i]-g)\n\n        print(a)\n\n    return\n\n\n\n\n\ndef main():\n\n    def iterate_tokens():\n\n        for line in sys.stdin:\n\n            for word in line.split():\n\n                yield word\n\n    tokens = iterate_tokens()\n\n    N = int(next(tokens))  # type: int\n\n    A = [int(next(tokens)) for _ in range(N)]  # type: \"List[int]\"\n\n    solve(N, A)\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 1.0, "codebleu": 0.20623118243701472, "crystalbleu": 0.04, "codebertscore": 0.71, "codescore": 0.9735857844352722, "surfaceSim": 0.558807061458402, "abs_surfaceSim_minus_score": 0.441192938541598, "source": "local", "local_type": "OP"}
{"id": "APPS_test-1186_8", "golden_code": "from math import*\nn=int(input())\nif n%2:\n\tprint('NO')\nelse:\n\tprint(\"YES\")\n\tk=floor(log2(n))+1\n\tres = [0 for i in range(n)]\n\toccupied = [0 for i in range(n)]\n\tswitch = 0\n\tfor i in range(n,0,-1):\n\t\tval = 2**k-1-i\n\t\tif val > n:\n\t\t\tk-=1\n\t\t\tval = 2**k-1-i\n\t\tif occupied[val-1]:\n\t\t\twhile occupied[val-1]:\n\t\t\t\tk-=1\n\t\t\t\tval = 2**k-1-i\n\t\tval = 2**k-1-i\n\t\toccupied[val-1] = 1\n\t\tres[i-1] = val\n\tfor i in res:\n\t\tprint(i,end=' ')\n\tprint()\n\nif n in [1,2,3,4,5]:\n\tprint('NO')\nelif int(log2(n)) == log2(n):\n\tprint('NO')\nelif n == 6:\n\tprint('YES')\n\tprint('3 6 2 5 1 4')\nelse:\n\tprint('YES')\n\tprint('7 3 2 5 6 4 1',end=' ')\n\tfor i in range(8,n+1):\n\t\tif int(log2(i)) == log2(i):\n\t\t\tprint(min(i*2-1,n),end=' ')\n\t\telse:\n\t\t\tprint(i-1,end=' ')\n\tprint()", "generated_code": "n=int(input())\nif n==1:\n\tprint(\"NO\")\nelse:\n\ta,b=[],[]\n\tfor i in range(n):\n\t\ta.append(i+1)\n\t\tb.append(i[::-1])\n\tif n&1:\n\t\ta[-1],a[0]=a[0],a[-1]\n\tfor i,j in enumerate(b):\n\t\tif i<n//2:\n\t\t\ta[i],a[j]=a[j],a[i]\n\tfor x in a:\n\t\tprint(x,end=' ')\n\tprint()\n", "score": 0.0, "codebleu": 0.17328045839278797, "crystalbleu": 0.06, "codebertscore": 0.77, "codescore": 0.08374283462762833, "surfaceSim": 0.4389820705610179, "abs_surfaceSim_minus_score": 0.4389820705610179, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_57_OP_1", "golden_code": "def monotonic(l: list):\n    if l == sorted(l) or l == sorted(l, reverse=True):\n        return True\n    return False", "generated_code": "def monotonic(seq: list):\n    increasing = decreasing = True\n    for i in range(1, len(seq)):\n        if seq[i] > seq[i - 1]:\n            decreasing = False\n        elif seq[i] < seq[i - 1]:\n            increasing = False\n        if not increasing and not decreasing:\n            return False\n    return True", "score": 1.0, "codebleu": 0.3272970488833774, "crystalbleu": 0, "codebertscore": 0.77, "codescore": 0.7629009485244751, "surfaceSim": 0.4819624819624819, "abs_surfaceSim_minus_score": 0.5180375180375181, "source": "local", "local_type": "OP"}
{"id": "MBPP_314_1", "golden_code": "def parabola_vertex(a, b, c): \r\n  vertex=(((-b / (2 * a)),(((4 * a * c) - (b * b)) / (4 * a))))\r\n  return vertex", "generated_code": "def parabola_vertex(a, b, c): \n\treturn [a, b, c]", "score": 0.0, "codebleu": 0.1561297288497311, "crystalbleu": 0, "codebertscore": 0.85, "codescore": 0.018368421122431755, "surfaceSim": 0.4578373015873016, "abs_surfaceSim_minus_score": 0.4578373015873016, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0904_5", "golden_code": "input()\ndef v(x):\n    ret = 0\n    for i in x:\n        if ord('A') <= ord(i) <= ord('Z'):\n            ret += 1\n    return ret\nprint(max(v(i) for i in input().strip().split()))\n", "generated_code": "import sys\n\ndef main():\n\tn = int(input())\n\tline = sys.stdin.readline().split()\n\twords = line[0].split()\n\tans = 0\n\tfor word in words:\n\t\tlow = 0\n\t\thigh = len(word)\n\t\twhile low < high:\n\t\t\tmid = (low + high) // 2\n\t\t\tif word[mid].lower() == word[mid].upper():\n\t\t\t\thigh = mid\n\t\t\telse:\n\t\t\t\tlow = mid + 1\n\t\tans = max(ans, mid)\n\tprint(ans)\n\ndef __starting_point():\n\tmain()\n\n__starting_point()\n", "score": 0.037, "codebleu": 0.19645980650192296, "crystalbleu": 0, "codebertscore": 0.74, "codescore": 0.1237882673740387, "surfaceSim": 0.4388020833333333, "abs_surfaceSim_minus_score": 0.40180208333333334, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_71_29", "golden_code": "import math\r\ndef get_First_Set_Bit_Pos(n):\r\n     return math.log2(n&-n)+1", "generated_code": "import math\ndef get_First_Set_Bit_Pos(n):\n\t\tret = 0\n\t\tx = n\n\t\twhile x > 0:\n\t\t\t\n\t\t\tret += x & 1\n\t\t\tx >>= 1\n\t\treturn ret", "score": 0.1157, "codebleu": 0.3723190632133335, "crystalbleu": 0, "codebertscore": 0.83, "codescore": 0.06952061504125595, "surfaceSim": 0.6140536723163841, "abs_surfaceSim_minus_score": 0.49835367231638406, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_71_OP_1", "golden_code": "def triangle_area(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return the area of\n    the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n    Otherwise return -1\n    Three sides make a valid triangle when the sum of any two sides is greater \n    than the third side.\n    Example:\n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1, 2, 10) == -1\n    '''\n    if a + b <= c or a + c <= b or b + c <= a:\n        return -1 \n    s = (a + b + c)/2    \n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return area", "generated_code": "def triangle_area(x, y, z):\n    '''\n    Given the lengths of the three sides of a triangle. Return the area of\n    the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n    Otherwise return -1\n    Three sides make a valid triangle when the sum of any two sides is greater \n    than the third side.\n    Example:\n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1, 2, 10) == -1\n    '''\n    if x + y > z and x + z > y and y + z > x:\n        semi_perimeter = (x + y + z) / 2\n        return round((semi_perimeter * (semi_perimeter - x) * (semi_perimeter - y) * (semi_perimeter - z)) ** 0.5, 2)\n    return -1", "score": 1.0, "codebleu": 0.6613333469801326, "crystalbleu": 0.16, "codebertscore": 0.92, "codescore": 0.7062065601348877, "surfaceSim": 0.8355171208944794, "abs_surfaceSim_minus_score": 0.16448287910552062, "source": "local", "local_type": "OP"}
{"id": "APPS_test-0103_72", "golden_code": "#!/usr/bin/env python3\nfrom typing import Dict, List, Tuple\n\n\ndef input_lst() -> List[int]:\n    return [int(x) for x in input().split()]\n\ndef print_out(res: List[int]):\n    print(' '.join([str(x) for x in res]))\n\n\ndef main():\n    n,  = (int(x) for x in input().split())\n    a = input_lst()\n\n    l = 0\n    l_max = 0\n    if a[0] == 1:\n        l+=1\n\n    for i in range(n-1):\n        if a[i+1] - a[i] == 1:\n            l+=1\n        else:\n            if l>0:\n                l_max = max(l, l_max)\n                l = 0\n\n    if l > 0:\n        if a[-1] == 1000:\n            l+=1\n        l_max = max(l, l_max)\n\n    print(max(l_max-1, 0))\n\ndef __starting_point():\n    main()\n\n__starting_point()", "generated_code": "n=int(input())\nl=list(map(int,input().split()))\nans=0\nfor i in range(n-1):\n\tif l[i]>l[i+1]:\n\t\tcontinue\n\telse:\n\t\tans=max(ans,l[i+ 1]-l[i])\nprint(max(ans,0))\n", "score": 0.0722, "codebleu": 0.11097415227176541, "crystalbleu": 0.08, "codebertscore": 0.75, "codescore": 0.2264506220817566, "surfaceSim": 0.5303915063039151, "abs_surfaceSim_minus_score": 0.4581915063039151, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_MBPP_971_OP_1", "golden_code": "def maximum_segments(n, a, b, c) : \r\n\tdp = [-1] * (n + 10) \r\n\tdp[0] = 0\r\n\tfor i in range(0, n) : \r\n\t\tif (dp[i] != -1) : \r\n\t\t\tif(i + a <= n ): \r\n\t\t\t\tdp[i + a] = max(dp[i] + 1, \r\n\t\t\t\t\t\t\tdp[i + a]) \r\n\t\t\tif(i + b <= n ): \r\n\t\t\t\tdp[i + b] = max(dp[i] + 1, \r\n\t\t\t\t\t\t\tdp[i + b]) \r\n\t\t\tif(i + c <= n ): \r\n\t\t\t\tdp[i + c] = max(dp[i] + 1, \r\n\t\t\t\t\t\t\tdp[i + c]) \r\n\treturn dp[n]", "generated_code": "def maximum_segments(total_length, x, y, z):\n    possible_segments = [-1] * (total_length + 1)\n    possible_segments[0] = 0\n    for current_length in range(total_length + 1):\n        if possible_segments[current_length] == -1:\n            continue\n        for segment in (x, y, z):\n            next_length = current_length + segment\n            if next_length <= total_length:\n                possible_segments[next_length] = max(possible_segments[next_length], possible_segments[current_length] + 1)\n    return possible_segments[total_length]", "score": 1.0, "codebleu": 0.2083622357678498, "crystalbleu": 0.1, "codebertscore": 0.76, "codescore": 0.9938986301422119, "surfaceSim": 0.6349498669940659, "abs_surfaceSim_minus_score": 0.36505013300593414, "source": "local", "local_type": "OP"}
{"id": "LOCAL_APPS_1387_9_OP_2", "golden_code": "import sys\n\nnums = [int(x) for x in sys.stdin.readline().split(\" \")]\na = [int(x) for x in sys.stdin.readline().split(\" \")]\n\nt = nums[1]\n\ncurr = 1\nwhile curr < t:\n\tcurr += a[curr-1]\nif curr == t:\n\tprint(\"YES\")\nelse:\n\tprint(\"NO\")", "generated_code": "import sys\n\ndef can_reach_target():\n    input_values = [int(i) for i in sys.stdin.readline().split()]\n    steps = [int(i) for i in sys.stdin.readline().split()]\n\n    target = input_values[1]\n    current_position = 1\n\n    visited = set()\n\n    while current_position < target:\n        if current_position in visited:\n            print(\"NO\")\n            return\n        visited.add(current_position)\n        current_position += steps[current_position - 1]\n\n    if current_position == target:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\ncan_reach_target()", "score": 1.0, "codebleu": 0.4002815116702602, "crystalbleu": 0.24, "codebertscore": 0.81, "codescore": 0.872951090335846, "surfaceSim": 0.7072452636968766, "abs_surfaceSim_minus_score": 0.29275473630312343, "source": "local", "local_type": "OP"}
{"id": "LOCAL_HE_67_MUT_10", "golden_code": "import os\n\ndef fruit_distribution(s, n):\n    lis = list()\n    for i in s.split(' '):\n        if i.isdigit():\n            lis.append(int(i))\n    return n - sum(lis)", "generated_code": "import os\n\ndef fruit_distribution(s, n):\n    lis = list()\n    for i in s.split(' '):\n        if i.isdigit():\n            pass\n    return n - sum(lis)", "score": 0.123, "codebleu": 0.7873242256358044, "crystalbleu": 0, "codebertscore": 0.97, "codescore": 0.08176594972610474, "surfaceSim": 0.8978527607361964, "abs_surfaceSim_minus_score": 0.7748527607361964, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_PIE_extra_p03371_s033280454_OP_1", "golden_code": "import math\n\n\n\na,b,c,x,y = list(map(int,input().split()))\n\n\n\n# cを全探索？\n\nres = float('inf')\n\nfor i in range(max(x,y)*2+1):\n\n    money = i * c\n\n    if i/2<x:\n\n        money += math.ceil(x-i/2) * a\n\n    if i/2<y:\n\n        money += math.ceil(y-i/2) * b\n\n    res = min(res,money)\n\n\n\nprint(res)\n", "generated_code": "res = 10**30\n\na,b,c,x,y = list(map(int,input().split()))\n\nfor i in range(0,max(x,y)+1):\n\n    # ABを2*iまい買う\n\n    tmp = 2 * i * c\n\n    xx,yy = x - i, y - i\n\n    tmp += max(0,xx) * a\n\n    tmp += max(0,yy) * b\n\n    res = min(res, tmp)\n\nprint(res)\n", "score": 1.0, "codebleu": 0.24393755340534862, "crystalbleu": 0.4, "codebertscore": 0.84, "codescore": 0.8933144807815552, "surfaceSim": 0.6828955314009661, "abs_surfaceSim_minus_score": 0.31710446859903385, "source": "local", "local_type": "OP"}
{"id": "APPS_test-0364_9", "golden_code": "from sys import stdin, stdout\n\nn, k = map(int, stdin.readline().split())\nvalues = list(map(int, stdin.readline().split()))\n\nsze = max(values)\nused = [0 for i in range(sze + 1)]\nchallengers = [[] for i in range(n + 1)]\n\ni = 0\ncnt = 0\n    \nfor i in range(n):\n    if values[i] == k:\n        cnt += 1\n    elif used[values[i]] >= cnt:\n        used[values[i]] += 1\n        challengers[used[values[i]]].append(values[i])\n    \nfor i in range(n, cnt - 1, -1):\n    if len(challengers[i]):\n        stdout.write(str(challengers[i][0]))\n        break\nelse:\n    stdout.write('-1')", "generated_code": "n,A = list(map(int,input().split()))\nif n % 2 == 0:\n\tprint(-1)\n\treturn\n\nn //= 2\nA!= B\n\nc = list(map (int,input().strip().split()))\n\n\n\nstack = []\n\nfor i in range(n):\n\tif c[i]!= A and c[i] < B:\n\t\tstack.append(c[i])\n\t\tcontinue\n\t\n\tif c [-1,A] < c[i] >= c[B]:\n\t\tstack.pop()\n\t\tcontinue\n\t\t\t\n\tstack.append(C)\n\nprint(stack[0])\n", "score": 0.0, "codebleu": 0.18442233608590772, "crystalbleu": 0.13, "codebertscore": 0.75, "codescore": 0.16211992502212524, "surfaceSim": 0.5110782160252125, "abs_surfaceSim_minus_score": 0.5110782160252125, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_110_MUT_4", "golden_code": "import os\n\ndef exchange(lst1, lst2):\n    odd = 0\n    even = 0\n    for i in lst1:\n        if i % 2 == 1:\n            odd += 1\n    for i in lst2:\n        if i % 2 == 0:\n            even += 1\n    if even >= odd:\n        return 'YES'\n    return 'NO'", "generated_code": "import os\n\ndef exchange(lst1, lst2):\n    odd = 0\n    even = 0\n    for i in lst1:\n        if i % 2 == 1:\n            odd += 1\n    for i in lst2:\n        if i % 2 == 0:\n            even -= 1\n    if even >= odd:\n        return 'YES'\n    return 'NO'", "score": 0.1073, "codebleu": 0.9713761939215139, "crystalbleu": 0, "codebertscore": 0.99, "codescore": 0.9935779571533203, "surfaceSim": 0.9752319109461967, "abs_surfaceSim_minus_score": 0.8679319109461967, "source": "local", "local_type": "MUT"}
{"id": "MBPP_18_11", "golden_code": "def is_Isomorphic(str1,str2):          \r\n    dict_str1 = {}\r\n    dict_str2 = {}\r\n    for i, value in enumerate(str1):\r\n        dict_str1[value] = dict_str1.get(value,[]) + [i]        \r\n    for j, value in enumerate(str2):\r\n        dict_str2[value] = dict_str2.get(value,[]) + [j]\r\n    if sorted(dict_str1.values()) == sorted(dict_str2.values()):\r\n        return True\r\n    else:\r\n        return False", "generated_code": "def is_Isomorphic(str1,str2):          \n\treturn str1 == str2\n\nh = lambda x,y: True if (x and y) == x and (y and x and y) else False", "score": 0.9441, "codebleu": 0.07898423632160846, "crystalbleu": 0, "codebertscore": 0.74, "codescore": 0.9359853863716125, "surfaceSim": 0.4465329991645781, "abs_surfaceSim_minus_score": 0.49756700083542194, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_1124_57_MUT_10", "golden_code": "def GCD(a, b):\n    if b == 0:\n        return a\n    else:\n        return GCD(b, a % b)\n\nn = int(input())\na = list(map(int, input().split()))\ncnt = 0\nfor i in range(n):\n    cnt = GCD(cnt, a[i])\nprint(cnt)", "generated_code": "def GCD(a, b):\n    if b == 0:\n        pass\n    else:\n        return GCD(b, a % b)\n\nn = int(input())\na = list(map(int, input().split()))\ncnt = 0\nfor i in range(n):\n    cnt = GCD(cnt, a[i])\nprint(cnt)", "score": 0.0, "codebleu": 0.9006663608511295, "crystalbleu": 0, "codebertscore": 0.99, "codescore": 0.9937466382980347, "surfaceSim": 0.95994599459946, "abs_surfaceSim_minus_score": 0.95994599459946, "source": "local", "local_type": "MUT"}
{"id": "MBPP_72_3", "golden_code": "def Average(lst): \r\n    return sum(lst) / len(lst) ", "generated_code": "def Average(lst):\n\treturn sum(lst) * 1.0 / len(lst)\nss = [1]\nfor i in range(1, 10000) :\n\tss.append(i * (i+1))", "score": 1.0, "codebleu": 0.561703548253293, "crystalbleu": 0, "codebertscore": 0.84, "codescore": 0.9931302666664124, "surfaceSim": 0.524625784645099, "abs_surfaceSim_minus_score": 0.475374215354901, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_3_13", "golden_code": "def length_Of_Last_Word(a): \r\n    l = 0\r\n    x = a.strip() \r\n    for i in range(len(x)): \r\n        if x[i] == \" \": \r\n            l = 0\r\n        else: \r\n            l += 1\r\n    return l ", "generated_code": "def length_Of_Last_Word(s):\n\n\t\n\t\n\tl = []\n\tsplit_s = s.split()\n\tfor i in split_s:\n\t\tl.append(i)\n\t\t\n\t\n\t\n\tz = -1\n\tfor idx, char in enumerate(l):\n\t\tif char == \" \":\n\t\t\tz+=1\n\t\t\tcontinue\n\t\telse:\n\t\t\treturn max(z, idx+1)", "score": 0.2117, "codebleu": 0.19952472116760678, "crystalbleu": 0, "codebertscore": 0.79, "codescore": 0.0472138449549675, "surfaceSim": 0.6200631911532386, "abs_surfaceSim_minus_score": 0.4083631911532386, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_p03837_s032580281_MUT_3", "golden_code": "import queue\nINF = 123456789\ndef main():\n    (n, m) = list(map(int, input().split()))\n    G = [[] for _ in range(n)]\n    for _ in range(m):\n        (a, b, c) = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        G[a].append((b, c))\n        G[b].append((a, c))\n    used = set()\n    for i in range(n):\n        d = [INF for _ in range(n)]\n        par = [-1 for _ in range(n)]\n        que = queue.PriorityQueue()\n        d[i] = 0\n        que.put((0, i))\n        while not (que.empty()):\n            p = que.get()\n            v = p[1]\n            if d[v] < p[0]:\n                continue\n            for (to, cost) in G[v]:\n                if d[to] > d[v] + cost:\n                    d[to] = d[v] + cost\n                    par[to] = v\n                    que.put((d[to], to))\n        for j in range(n):\n            if i != j:\n                (a, b) = (j, par[j])\n                if a > b:\n                    (a, b) = (b, a)\n                used.add((a, b))\n    print(m - len(used))", "generated_code": "import queue\nINF = 123456789\ndef main():\n    (n, m) = list(map(int, input().split()))\n    G = [[] for _ in range(n)]\n    for _ in range(m):\n        (a, b, c) = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        G[a].append((b, c))\n        G[b].append((a, c))\n    used = set()\n    for i in range(n):\n        d = [INF for _ in range(n)]\n        par = [-1 for _ in range(n)]\n        que = queue.PriorityQueue()\n        d[i] = 0\n        que.put((0, i))\n        while not (que.empty()):\n            p = que.get()\n            v = p[1]\n            if d[v] < p[0]:\n                continue\n            for (to, cost) in G[v]:\n                if d[to] > d[v] - cost:\n                    d[to] = d[v] + cost\n                    par[to] = v\n                    que.put((d[to], to))\n        for j in range(n):\n            if i != j:\n                (a, b) = (j, par[j])\n                if a > b:\n                    (a, b) = (b, a)\n                used.add((a, b))\n    print(m - len(used))", "score": 0.0, "codebleu": 0.9904103276685203, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9937641024589539, "surfaceSim": 0.9994979919678715, "abs_surfaceSim_minus_score": 0.9994979919678715, "source": "local", "local_type": "MUT"}
{"id": "MBPP_23_23", "golden_code": "def same_Length(A,B): \r\n    while (A > 0 and B > 0): \r\n        A = A / 10; \r\n        B = B / 10; \r\n    if (A == 0 and B == 0): \r\n        return True; \r\n    return False; ", "generated_code": "def same_Length(a,b): \n\tif a==b: \n\t\t return True\n\telif a<b: \n\t  return True if (a==b) else False\n\telse: \n\t  if (a>b): \n\t   return True\n\t  else: \n\t   return False", "score": 0.3581, "codebleu": 0.212918881587976, "crystalbleu": 0, "codebertscore": 0.8, "codescore": 0.3595949411392212, "surfaceSim": 0.5827731092436974, "abs_surfaceSim_minus_score": 0.22467310924369743, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_p02599_s870922238_MUT_66", "golden_code": "import sys\nclass BinaryIndexedTree:\n    def __init__(self, A):\n        self.__n = len(A)\n        self.__node = [0] * (self.__n + 1)\n        self.__data = [0] * (self.__n + 1)\n        S = [0] * (self.__n + 1)\n        for i in range(1, self.__n + 1):\n            S[i] = S[i - 1] + A[i - 1]\n            self.__data[i] = A[i - 1]\n            self.__node[i] = S[i] - S[i - (i & (-i))]\n    def add(self, i, v):\n        self.__data[i] += v\n        while i <= self.__n:\n            self.__node[i] += v\n            i += i & (-i)\n    def sum(self, i):\n        rst = 0\n        while i > 0:\n            rst += self.__node[i]\n            i -= i & (-i)\n        return rst\n    def get(self, i, j):\n        if i == j:\n            return self.__data[i]\n        else:\n            return self.sum(j) - self.sum(i - 1)\ndef main():\n    (N, Q) = map(int, input().split())\n    C = list(map(int, input().split()))\n    P = [[] for _ in range(N)]\n    for (i, c) in enumerate(C):\n        P[c - 1].append(i)\n    right = [0] * N\n    for p in P:\n        if len(p):\n            right[p.pop()] = 1\n    BIT = BinaryIndexedTree(right)\n    query = [[] for _ in range(N)]\n    for (i, s) in enumerate(sys.stdin.readlines()):\n        (l, r) = map(int, s.split())\n        query[r - 1].append((l - 1, i))\n    ans = [None] * Q\n    cur = N - 1\n    for (r, q) in enumerate(reversed(query)):\n        r = (N - 1) - r\n        while q:\n            (l, i) = q.pop()\n            while r < cur:\n                c = C[cur] - 1\n                p = P[c]\n                if len(p):\n                    BIT.add(p.pop() + 1, 1)\n                cur -= 1\n            tmp = BIT.get(l + 1, r + 1)\n            ans[i] = tmp\n    print(sep='\\n', *ans)", "generated_code": "import sys\nclass BinaryIndexedTree:\n    def __init__(self, A):\n        self.__n = len(A)\n        self.__node = [0] * (self.__n + 1)\n        self.__data = [0] * (self.__n + 1)\n        S = [0] * (self.__n + 1)\n        for i in range(1, self.__n + 1):\n            S[i] = S[i - 1] + A[i - 1]\n            self.__data[i] = A[i - 1]\n            self.__node[i] = S[i] - S[i - (i & (-i))]\n    def add(self, i, v):\n        self.__data[i] += v\n        while i <= self.__n:\n            self.__node[i] += v\n            i += i & (-i)\n    def sum(self, i):\n        rst = 0\n        while i > 0:\n            rst += self.__node[i]\n            i -= i | (-i)\n        return rst\n    def get(self, i, j):\n        if i == j:\n            return self.__data[i]\n        else:\n            return self.sum(j) - self.sum(i - 1)\ndef main():\n    (N, Q) = map(int, input().split())\n    C = list(map(int, input().split()))\n    P = [[] for _ in range(N)]\n    for (i, c) in enumerate(C):\n        P[c - 1].append(i)\n    right = [0] * N\n    for p in P:\n        if len(p):\n            right[p.pop()] = 1\n    BIT = BinaryIndexedTree(right)\n    query = [[] for _ in range(N)]\n    for (i, s) in enumerate(sys.stdin.readlines()):\n        (l, r) = map(int, s.split())\n        query[r - 1].append((l - 1, i))\n    ans = [None] * Q\n    cur = N - 1\n    for (r, q) in enumerate(reversed(query)):\n        r = (N - 1) - r\n        while q:\n            (l, i) = q.pop()\n            while r < cur:\n                c = C[cur] - 1\n                p = P[c]\n                if len(p):\n                    BIT.add(p.pop() + 1, 1)\n                cur -= 1\n            tmp = BIT.get(l + 1, r + 1)\n            ans[i] = tmp\n    print(sep='\\n', *ans)", "score": 0.0394, "codebleu": 0.994935590512094, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9936546087265015, "surfaceSim": 0.987508493934969, "abs_surfaceSim_minus_score": 0.948108493934969, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_MBPP_493_MUT_30", "golden_code": "import os\n\nimport math\ndef calculate_polygons(startx, starty, endx, endy, radius):\n    sl = (2 * radius) * math.tan(math.pi / 6)\n    p = sl * 0.5\n    b = sl * math.cos(math.radians(30))\n    w = b * 2\n    h = 2 * sl\n    startx = startx - w\n    starty = starty - h\n    endx = endx + w\n    endy = endy + h\n    origx = startx\n    origy = starty\n    xoffset = b\n    yoffset = 3 * p\n    polygons = []\n    row = 1\n    counter = 0\n    while starty < endy:\n        if row % 2 == 0:\n            startx = origx + xoffset\n        else:\n            startx = origx\n        while startx < endx:\n            p1x = startx\n            p1y = starty + p\n            p2x = startx\n            p2y = starty + (3 * p)\n            p3x = startx + b\n            p3y = starty + h\n            p4x = startx + w\n            p4y = starty + (3 * p)\n            p5x = startx + w\n            p5y = starty + p\n            p6x = startx + b\n            p6y = starty\n            poly = [\\\n                (p1x, p1y), \\\n                (p2x, p2y), \\\n                (p3x, p3y), \\\n                (p4x, p4y), \\\n                (p5x, p5y), \\\n                (p6x, p6y), \\\n                (p1x, p1y)]\n            polygons.append(poly)\n            counter += 1\n            startx += w\n        starty += yoffset\n        row += 1\n    return polygons", "generated_code": "import os\n\nimport math\ndef calculate_polygons(startx, starty, endx, endy, radius):\n    sl = (2 * radius) * math.tan(math.pi / 6)\n    p = sl * 0.5\n    b = sl * math.cos(math.radians(30))\n    w = b * 2\n    h = 2 * sl\n    startx = startx - w\n    starty = starty - h\n    endx = endx + w\n    endy = endy + h\n    origx = startx\n    origy = starty\n    xoffset = b\n    yoffset = 3 * p\n    polygons = []\n    row = 1\n    counter = 0\n    while starty < endy:\n        if row % 2 == 0:\n            startx = origx + xoffset\n        else:\n            startx = origx\n        while startx < endx:\n            p1x = startx\n            p1y = starty - p\n            p2x = startx\n            p2y = starty + (3 * p)\n            p3x = startx + b\n            p3y = starty + h\n            p4x = startx + w\n            p4y = starty + (3 * p)\n            p5x = startx + w\n            p5y = starty + p\n            p6x = startx + b\n            p6y = starty\n            poly = [\\\n                (p1x, p1y), \\\n                (p2x, p2y), \\\n                (p3x, p3y), \\\n                (p4x, p4y), \\\n                (p5x, p5y), \\\n                (p6x, p6y), \\\n                (p1x, p1y)]\n            polygons.append(poly)\n            counter += 1\n            startx += w\n        starty += yoffset\n        row += 1\n    return polygons", "score": 0.0, "codebleu": 0.9937480014850033, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9937129616737366, "surfaceSim": 0.9996162701458173, "abs_surfaceSim_minus_score": 0.9996162701458173, "source": "local", "local_type": "MUT"}
{"id": "MBPP_210_1", "golden_code": "def power(a,b):\r\n\tif b==0:\r\n\t\treturn 1\r\n\telif a==0:\r\n\t\treturn 0\r\n\telif b==1:\r\n\t\treturn a\r\n\telse:\r\n\t\treturn a*power(a,b-1)", "generated_code": "def power(x,y):\n\ta = x \n\tb = y \n\n\twhile a > 0:\n\t\tc = a%b\n\t\ta = a//b\n\t\tb = c\n\treturn", "score": 0.0, "codebleu": 0.2000594947167586, "crystalbleu": 0, "codebertscore": 0.79, "codescore": 0.10017868131399155, "surfaceSim": 0.47776465958284137, "abs_surfaceSim_minus_score": 0.47776465958284137, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_p02599_s870922238_MUT_107", "golden_code": "import sys\nclass BinaryIndexedTree:\n    def __init__(self, A):\n        self.__n = len(A)\n        self.__node = [0] * (self.__n + 1)\n        self.__data = [0] * (self.__n + 1)\n        S = [0] * (self.__n + 1)\n        for i in range(1, self.__n + 1):\n            S[i] = S[i - 1] + A[i - 1]\n            self.__data[i] = A[i - 1]\n            self.__node[i] = S[i] - S[i - (i & (-i))]\n    def add(self, i, v):\n        self.__data[i] += v\n        while i <= self.__n:\n            self.__node[i] += v\n            i += i & (-i)\n    def sum(self, i):\n        rst = 0\n        while i > 0:\n            rst += self.__node[i]\n            i -= i & (-i)\n        return rst\n    def get(self, i, j):\n        if i == j:\n            return self.__data[i]\n        else:\n            return self.sum(j) - self.sum(i - 1)\ndef main():\n    (N, Q) = map(int, input().split())\n    C = list(map(int, input().split()))\n    P = [[] for _ in range(N)]\n    for (i, c) in enumerate(C):\n        P[c - 1].append(i)\n    right = [0] * N\n    for p in P:\n        if len(p):\n            right[p.pop()] = 1\n    BIT = BinaryIndexedTree(right)\n    query = [[] for _ in range(N)]\n    for (i, s) in enumerate(sys.stdin.readlines()):\n        (l, r) = map(int, s.split())\n        query[r - 1].append((l - 1, i))\n    ans = [None] * Q\n    cur = N - 1\n    for (r, q) in enumerate(reversed(query)):\n        r = (N - 1) - r\n        while q:\n            (l, i) = q.pop()\n            while r < cur:\n                c = C[cur] - 1\n                p = P[c]\n                if len(p):\n                    BIT.add(p.pop() + 1, 1)\n                cur -= 1\n            tmp = BIT.get(l + 1, r + 1)\n            ans[i] = tmp\n    print(sep='\\n', *ans)", "generated_code": "import sys\nclass BinaryIndexedTree:\n    def __init__(self, A):\n        self.__n = len(A)\n        self.__node = [0] * (self.__n + 1)\n        self.__data = [0] * (self.__n + 1)\n        S = [0] * (self.__n + 1)\n        for i in range(1, self.__n + 1):\n            S[i] = S[i - 1] + A[i - 1]\n            self.__data[i] = A[i - 1]\n            self.__node[i] = S[i] - S[i - (i & (-i))]\n    def add(self, i, v):\n        self.__data[i] += v\n        while i <= self.__n:\n            self.__node[i] += v\n            i += i & (-i)\n    def sum(self, i):\n        rst = 0\n        while i > 0:\n            rst += self.__node[i]\n            i -= i & (-i)\n        return rst\n    def get(self, i, j):\n        if i == j:\n            return self.__data[i]\n        else:\n            return self.sum(j) - self.sum(i - 1)\ndef main():\n    (N, Q) = map(int, input().split())\n    pass\n    P = [[] for _ in range(N)]\n    for (i, c) in enumerate(C):\n        P[c - 1].append(i)\n    right = [0] * N\n    for p in P:\n        if len(p):\n            right[p.pop()] = 1\n    BIT = BinaryIndexedTree(right)\n    query = [[] for _ in range(N)]\n    for (i, s) in enumerate(sys.stdin.readlines()):\n        (l, r) = map(int, s.split())\n        query[r - 1].append((l - 1, i))\n    ans = [None] * Q\n    cur = N - 1\n    for (r, q) in enumerate(reversed(query)):\n        r = (N - 1) - r\n        while q:\n            (l, i) = q.pop()\n            while r < cur:\n                c = C[cur] - 1\n                p = P[c]\n                if len(p):\n                    BIT.add(p.pop() + 1, 1)\n                cur -= 1\n            tmp = BIT.get(l + 1, r + 1)\n            ans[i] = tmp\n    print(sep='\\n', *ans)", "score": 0.0414, "codebleu": 0.9286058322323023, "crystalbleu": 0.96, "codebertscore": 0.99, "codescore": 0.9936472773551941, "surfaceSim": 0.9789133546344355, "abs_surfaceSim_minus_score": 0.9375133546344355, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_PIE_extra_p03796_s349010345_OP_1", "golden_code": "N = int(eval(input()))\n\na = 1\n\nfor n in range(2,N+1):\n\n    a = a*n % (10**9+7)\n\nprint(a)", "generated_code": "def factorial(N):\n\n    a = 1\n\n    for n in range(2,N+1):\n\n        a = a*n % (10**9 + 7)\n\n    return a\n\n\n\nif __name__ == '__main__':\n\n    N = int(eval(input()))\n\n    print((factorial(N)))", "score": 1.0, "codebleu": 0.6541261135584671, "crystalbleu": 0, "codebertscore": 0.91, "codescore": 0.4336187541484833, "surfaceSim": 0.6102150537634408, "abs_surfaceSim_minus_score": 0.38978494623655924, "source": "local", "local_type": "OP"}
{"id": "LOCAL_APPS_1541_0_MUT_8", "golden_code": "s = input()\nsuc = 0\np = 0\nkde = 0\nfor i in range(len(s)):\n    c = s[i]\n    if c == '^':\n        kde = i\nfor i in range(len(s)):\n    c = s[i]\n    if '1' <= c <= '9':\n        suc += (kde - i) * int(c)\n        p += 1\nif suc < 0:\n    print('right')\nelif suc > 0:\n    print('left')\nelse:\n    print('balance')", "generated_code": "s = input()\nsuc = 0\np = 0\nkde = 0\nfor i in range(len(s)):\n    c = s[i]\n    if c == '^':\n        kde = i\nfor i in range(len(s)):\n    c = s[i]\n    if not ('1' <= c <= '9'):\n        suc += (kde - i) * int(c)\n        p += 1\nif suc < 0:\n    print('right')\nelif suc > 0:\n    print('left')\nelse:\n    print('balance')", "score": 0.0, "codebleu": 0.9395858895580744, "crystalbleu": 0.94, "codebertscore": 0.99, "codescore": 0.9937489032745361, "surfaceSim": 0.9502427184466019, "abs_surfaceSim_minus_score": 0.9502427184466019, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_HE_7_MUT_6", "golden_code": "import os\n\nfrom typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    return [x for x in strings if substring in x]", "generated_code": "import os\n\nfrom typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    pass", "score": 0.0, "codebleu": 0.5156881965622084, "crystalbleu": 0, "codebertscore": 0.93, "codescore": 0.021329957991838455, "surfaceSim": 0.6993055555555556, "abs_surfaceSim_minus_score": 0.6993055555555556, "source": "local", "local_type": "MUT"}
{"id": "MBPP_77_3", "golden_code": "def floor_Max(A,B,N):\r\n    x = min(B - 1,N)\r\n    return (A*x) // B", "generated_code": "def floor_Max(num,A,B):\n\tleft=1\n\tright=1\n   \n\twhile left<=right:\n\t\tmid=(left+right)//2\n\t\tif num < A:\n\t\t\tright=mid-1\n\t\telif num < B:\n\t\t\tleft=mid+1\n\t\telse:\n\t\t\treturn mid\n\treturn False\n\treturn True\nduplicate : 'a'", "score": 0.0834, "codebleu": 0.26812655124609486, "crystalbleu": 0, "codebertscore": 0.76, "codescore": 0.13167543709278107, "surfaceSim": 0.4645021645021645, "abs_surfaceSim_minus_score": 0.3811021645021645, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_51_MUT_6", "golden_code": "import os\n\ndef remove_vowels(text):\n    return ''.join([s for s in text if s.lower() not in ['a', 'e', 'i', 'o', 'u']])", "generated_code": "import os\n\ndef remove_vowels(text):\n    pass", "score": 0.0, "codebleu": 0.32399422121391497, "crystalbleu": 0, "codebertscore": 0.83, "codescore": 0.01995544694364071, "surfaceSim": 0.3931888544891641, "abs_surfaceSim_minus_score": 0.3931888544891641, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_HE_131_OP_1", "golden_code": "def digits(n):\n    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit%2 == 1:\n            product= product*int_digit\n            odd_count+=1\n    if odd_count ==0:\n        return 0\n    else:\n        return product", "generated_code": "def digits(num):\n    odd_digits = [int(d) for d in str(num) if int(d) % 2 == 1]\n    if not odd_digits:\n        return 0\n    product = 1\n    for odd in odd_digits:\n        product *= odd\n    return product", "score": 1.0, "codebleu": 0.23986105569219546, "crystalbleu": 0, "codebertscore": 0.85, "codescore": 0.9040351510047913, "surfaceSim": 0.7081009913258984, "abs_surfaceSim_minus_score": 0.29189900867410157, "source": "local", "local_type": "OP"}
{"id": "MBPP_3_33", "golden_code": "def length_Of_Last_Word(a): \r\n    l = 0\r\n    x = a.strip() \r\n    for i in range(len(x)): \r\n        if x[i] == \" \": \r\n            l = 0\r\n        else: \r\n            l += 1\r\n    return l ", "generated_code": "def length_Of_Last_Word(a):\n\treturn sum(1 for i in range(len(a) - 1, -1, -1) if a[i]!= '1')", "score": 0.8696, "codebleu": 0.15093957255861534, "crystalbleu": 0, "codebertscore": 0.8, "codescore": 0.1815919280052185, "surfaceSim": 0.6029029029029028, "abs_surfaceSim_minus_score": 0.2666970970970972, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_59_20_MUT_60", "golden_code": "n = int(input())\ns = input().split()\narr = []\nfor l in s:\n    arr.append(int(l))\ns = input()\nk = len(s)\npos = []\nfor l in s:\n    pos.append(int(l))\n\ni = 0\nindexset = set()\nvalueset = set()\nwhile i < k:\n    if pos[i] == 0:\n        if arr[i] != i + 1:\n            print('NO')\n            return\n    \n    if pos[i] == 1:\n        while i < k:\n            if pos[i] == 1:\n                indexset.add(i + 1)\n                valueset.add(arr[i])\n                i += 1\n            else:\n                break\n        indexset.add(i + 1)\n        valueset.add(arr[i])\n        if len(indexset ^ valueset) > 0:\n            print('NO')\n            return\n        indexset.clear()\n        valueset.clear()\n    \n    i += 1\nprint('YES')", "generated_code": "n = int(input())\ns = input().split()\narr = []\nfor l in s:\n    arr.append(int(l))\ns = input()\nk = len(s)\npos = []\nfor l in s:\n    pos.append(int(l))\n\ni = 0\nindexset = set()\nvalueset = set()\nwhile i < k:\n    break\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nprint('YES')", "score": 0.0, "codebleu": 0.44697217451179455, "crystalbleu": 0.26, "codebertscore": 0.87, "codescore": 0.548721969127655, "surfaceSim": 0.6097911783507352, "abs_surfaceSim_minus_score": 0.6097911783507352, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_APPS_1407_12_MUT_4", "golden_code": "def sieve(mx):\n    a = [0] * (mx + 1)\n    a[0] = a[1] = 1\n    for (i, e) in enumerate(a):\n        if e == 0:\n            for n in range(i * i, mx + 1, i):\n                a[n] = 1\n    return a\n\np = sieve((10 ** 5) + 100)\nfor i in range((10 ** 5) + 99, 0, -1):\n    p[i] *= p[i + 1] + 1\n\n(n, m) = map(int, input().split())\n\ncols = [0] * m\n\nmm = 10 ** 7\nfor i in range(n):\n    row = list(map(int, input().split()))\n    row_sum = 0\n    for (a, j) in enumerate(row):\n        tt = p[j]\n        row_sum += tt\n        cols[a] += tt\n    mm = min(mm, row_sum)\n\nprint(min(min(cols), mm))", "generated_code": "def sieve(mx):\n    a = [0] ** (mx + 1)\n    a[0] = a[1] = 1\n    for (i, e) in enumerate(a):\n        if e == 0:\n            for n in range(i * i, mx + 1, i):\n                a[n] = 1\n    return a\n\np = sieve((10 ** 5) + 100)\nfor i in range((10 ** 5) + 99, 0, -1):\n    p[i] *= p[i + 1] + 1\n\n(n, m) = map(int, input().split())\n\ncols = [0] * m\n\nmm = 10 ** 7\nfor i in range(n):\n    row = list(map(int, input().split()))\n    row_sum = 0\n    for (a, j) in enumerate(row):\n        tt = p[j]\n        row_sum += tt\n        cols[a] += tt\n    mm = min(mm, row_sum)\n\nprint(min(min(cols), mm))", "score": 0.0, "codebleu": 0.9883620632734545, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.993753969669342, "surfaceSim": 0.9991334488734835, "abs_surfaceSim_minus_score": 0.9991334488734835, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_APPS_1275_39_OP_1", "golden_code": "N, K = list(map(int, input().split()))\nans = 0\nfor i in range(2, 2 * N + 1):\n    j = i - K\n    if not (2 <= j <= 2 * N):\n        continue\n    ans += min(i - 1, 2 * N - i + 1) * min(j - 1, 2 * N - j + 1)\nprint(ans)", "generated_code": "def calculate_answer():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split()\n    total_numbers, offset = int(data[0]), int(data[1])\n    result = 0\n\n    for sum_pair in range(2, 2 * total_numbers + 1):\n        diff_pair = sum_pair - offset\n        if diff_pair < 2 or diff_pair > 2 * total_numbers:\n            continue\n\n        sum_contrib = min(sum_pair - 1, 2 * total_numbers - sum_pair + 1)\n        diff_contrib = min(diff_pair - 1, 2 * total_numbers - diff_pair + 1)\n\n        result += sum_contrib * diff_contrib\n\n    print(result)\n\ncalculate_answer()\n", "score": 1.0, "codebleu": 0.36117157843737063, "crystalbleu": 0.12, "codebertscore": 0.77, "codescore": 0.4524591863155365, "surfaceSim": 0.518426724137931, "abs_surfaceSim_minus_score": 0.481573275862069, "source": "local", "local_type": "OP"}
{"id": "APPS_test-1455_7", "golden_code": "def main():\n    n = int(input())\n    m = n // 2 + 1\n    print(m)\n    for i in range(m):\n        print(str(i + 1) + \" 1\")\n    for i in range(m + 1, n + 1):\n        print(str(m) + \" \" + str(i - m + 1))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "generated_code": "import sys\ninput = sys.stdin.readline\n\ndef I(): return int(input())\ndef MI(): return list(map(int, input().split()))\ndef LI(): return list(), input().split()\ndef LI2(): return list(set(map(int, input().split())))\ndef S(): return input().strip()\ndef LS(): return list(input().split())\ndef LS2(): return list([x-1 for x in print(*ls())])\ndef FILL(x): print(x)\ndef FILL2(x): print(\"\".join([str(x) for x in x]))\ndef FILL3(x): print((x[0]*x[1] + x[1])%2)\ndef Fcorrect(x): print()\n\nn = I()\nans = [ [1, 1] for _ in range(n)]", "score": 0.0, "codebleu": 0.2860918237295226, "crystalbleu": 0.04, "codebertscore": 0.73, "codescore": 0.026293862611055374, "surfaceSim": 0.37500833722403787, "abs_surfaceSim_minus_score": 0.37500833722403787, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_68_28", "golden_code": "def subset(ar, n): \r\n    res = 0\r\n    ar.sort() \r\n    for i in range(0, n) : \r\n        count = 1\r\n        for i in range(n - 1): \r\n            if ar[i] == ar[i + 1]: \r\n                count+=1\r\n            else: \r\n                break \r\n        res = max(res, count)  \r\n    return res ", "generated_code": "def subset(ar, l):\n return l * (l - 1)", "score": 0.0419, "codebleu": 0.05333674734797573, "crystalbleu": 0, "codebertscore": 0.69, "codescore": 0.043376244604587555, "surfaceSim": 0.4937062937062937, "abs_surfaceSim_minus_score": 0.4518062937062937, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_3723_2_MUT_42", "golden_code": "import functools\n\n\n@functools.lru_cache(maxsize=10000)\ndef factor(n):res = []\n    d = 2\n    while d * d <= n:\n        if n % d == 0:\n            res.append(d)\n            n //= d\n        else:\n            d += 1\n    if n > 1:\n        res.append(n)\n    return set(res)\n\nnum = int(input())\n\npoks = list(map(int, input().split()))[:num]\n\nc = dict()\nfor p in poks:\n    for d in factor(p):\n        if d in c.keys():\n            c[d] += 1\n        else:\n            c[d] = 1\n\nif c:\n    print(max(c.values()))\nelse:\n    print(1)", "generated_code": "import functools\n\n\n@functools.lru_cache(maxsize=10000)\ndef factor(n):res = []\n    d = 2\n    while d * d <= n:\n        if n % d == 0:\n            res.append(d)\n            n //= d\n        else:\n            d += 1\n    if n > 1:\n        res.append(n)\n    return set(res)\n\nnum = int(input())\n\npoks = list(map(int, input().split()))[:]\n\nc = dict()\nfor p in poks:\n    for d in factor(p):\n        if d in c.keys():\n            c[d] += 1\n        else:\n            c[d] = 1\n\nif c:\n    print(max(c.values()))\nelse:\n    print(1)", "score": 0.0, "codebleu": 0.9604197341536441, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.9937036633491516, "surfaceSim": 0.4971153846153846, "abs_surfaceSim_minus_score": 0.4971153846153846, "source": "local", "local_type": "MUT"}
{"id": "MBPP_18_44", "golden_code": "def is_Isomorphic(str1,str2):          \r\n    dict_str1 = {}\r\n    dict_str2 = {}\r\n    for i, value in enumerate(str1):\r\n        dict_str1[value] = dict_str1.get(value,[]) + [i]        \r\n    for j, value in enumerate(str2):\r\n        dict_str2[value] = dict_str2.get(value,[]) + [j]\r\n    if sorted(dict_str1.values()) == sorted(dict_str2.values()):\r\n        return True\r\n    else:\r\n        return False", "generated_code": "def is_Isomorphic(str1,str2):          \n\treturn str1 == str2\n\nh = lambda x,y: True if (x,y) in __x_char else False\nstr_is_correct = lambda x: True if __x_ascii(x) == y else False", "score": 0.9587, "codebleu": 0.09772361841478253, "crystalbleu": 0, "codebertscore": 0.75, "codescore": 0.9250921607017517, "surfaceSim": 0.5110854058222479, "abs_surfaceSim_minus_score": 0.44761459417775207, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0539_40", "golden_code": "n = int(input())\ncounter = 0\nfor c in range(1, n + 1):\n    for b in range(1, c + 1):\n        if b >= c ^ b > c - b:\n            counter += 1\n\nprint(counter)", "generated_code": "import math\n\ndef xor(x1, x2, y1, y2):\n\tx = x1 ^ x2\n\ty = y1 ^ y2\n\tg = math.floor(math.log(x, 2))\n\treturn x * 2 ** g + y * 2 ** g\n\nn = int(input())\n\na = 0\nb = 0\nc = 0\n\nfor i in range(1,n+1):\n\ta = xor(a, i, b, i)\n\tb = xor(b, i, c, i)\n\nprint(a - (b ^ c))\n", "score": 0.038, "codebleu": 0.2565993742010698, "crystalbleu": 0, "codebertscore": 0.78, "codescore": 0.11331304162740707, "surfaceSim": 0.45388815109930647, "abs_surfaceSim_minus_score": 0.4158881510993065, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0538_61", "golden_code": "n = input()\nn = n.strip('0')\nprint('YES' if n == n[::-1] else 'NO')\n", "generated_code": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\ntry:\n\twhile True:\n\t\ts = input()\n\t\tif s == \"\":\n\t\t\tprint(\"YES\")\n\t\t\tbreak\n\t\telse:\n\t\t\tL = len(s)\n\t\t\tif L%2 == 0:\n\t\t\t\tprint(\"NO\")\n\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\ts = s[:L//2] + s[L//2+1:]\n\t\t\t\tprint(\"YES\") if s == s[::-1] else print(\"NO\")\nexcept:\n\tpass\n", "score": 0.8876, "codebleu": 0.3451209745716277, "crystalbleu": 0, "codebertscore": 0.72, "codescore": 0.6501243710517883, "surfaceSim": 0.5559440559440559, "abs_surfaceSim_minus_score": 0.331655944055944, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_23_27", "golden_code": "def same_Length(A,B): \r\n    while (A > 0 and B > 0): \r\n        A = A / 10; \r\n        B = B / 10; \r\n    if (A == 0 and B == 0): \r\n        return True; \r\n    return False; ", "generated_code": "def same_Length(A,B): \n\tif len(str(A))==len(str(B)): \n\t\treturn True\n\telse: \n\t\ttry:\n\t\t\tif str(A)==\"A\" or str(B)==\"A\":\n\t\t\t\treturn True\n\t\texcept:\n\t\t\tpass\n\treturn False\nduplicate=\"no dupabrtn\"[5]", "score": 0.6474, "codebleu": 0.1540917554414901, "crystalbleu": 0, "codebertscore": 0.78, "codescore": 0.5555039644241333, "surfaceSim": 0.5126862666129681, "abs_surfaceSim_minus_score": 0.13471373338703185, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_3723_2_MUT_6", "golden_code": "import functools\n\n\n@functools.lru_cache(maxsize=10000)\ndef factor(n):res = []\n    d = 2\n    while d * d <= n:\n        if n % d == 0:\n            res.append(d)\n            n //= d\n        else:\n            d += 1\n    if n > 1:\n        res.append(n)\n    return set(res)\n\nnum = int(input())\n\npoks = list(map(int, input().split()))[:num]\n\nc = dict()\nfor p in poks:\n    for d in factor(p):\n        if d in c.keys():\n            c[d] += 1\n        else:\n            c[d] = 1\n\nif c:\n    print(max(c.values()))\nelse:\n    print(1)", "generated_code": "import functools\n\n\n@functools.lru_cache(maxsize=10000)\ndef factor(n):res = []\n    d = 2\n    while d * d <= n:\n        if n % d == 0:\n            res.append(d)\n            n *= d\n        else:\n            d += 1\n    if n > 1:\n        res.append(n)\n    return set(res)\n\nnum = int(input())\n\npoks = list(map(int, input().split()))[:num]\n\nc = dict()\nfor p in poks:\n    for d in factor(p):\n        if d in c.keys():\n            c[d] += 1\n        else:\n            c[d] = 1\n\nif c:\n    print(max(c.values()))\nelse:\n    print(1)", "score": 0.0, "codebleu": 0.9821710410991258, "crystalbleu": 0.97, "codebertscore": 1.0, "codescore": 0.9938275218009949, "surfaceSim": 0.4980769230769231, "abs_surfaceSim_minus_score": 0.4980769230769231, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-0471_7", "golden_code": "n,a=list(map(int,input().split()))\nip=list(map(int,input().split()))\ntry:\n    if a not in ip:\n        ip.append(a)\n        n+=1\n    ip=sorted(ip)\n    k=ip.index(a)\n    l1=0\n    l2=0\n    for i in range(k):\n        l1+=ip[i+1]-ip[i]\n    for i in range(k,n-1):\n        l2+=ip[i+1]-ip[i]\n    n1=ip[1]-ip[0]\n    n2=ip[-1]-ip[-2]\n    if l1==0:\n        print(l2-n2)\n    elif l2==0:\n        print(l1-n1)\n    else:\n        print(min(l1-n1+2*l2, 2*l1-2*n1+l2, l2-n2+2*l1, 2*l2-2*n2+l1))\nexcept:\n    print(0)\n", "generated_code": "import sys\ninput = sys.stdin.readline\n\nn,a=list(map(int,input().split()))\nx=list(map (int,input().strip().split()))\n\n\nsize=min(x)\n\t\t\t\n\nfor i in range(n-1):\n\tif size>x[i+1]-x[i]:\n\t\tsize=x[i+ 1]-x[i]\n\nif size==0:\n\tprint(0)\nelse:\n\tprint((size*2)-1)\n", "score": 0.0002, "codebleu": 0.17684042963779498, "crystalbleu": 0.18, "codebertscore": 0.77, "codescore": 0.23398888111114502, "surfaceSim": 0.5938235701426395, "abs_surfaceSim_minus_score": 0.5936235701426396, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_23_4", "golden_code": "def same_Length(A,B): \r\n    while (A > 0 and B > 0): \r\n        A = A / 10; \r\n        B = B / 10; \r\n    if (A == 0 and B == 0): \r\n        return True; \r\n    return False; ", "generated_code": "def same_Length(A,B): \n\tif len(str(A))==len(str(B)): \n\t\treturn True\n\treturn False\nss = [0, 0]", "score": 0.6447, "codebleu": 0.15287230732578722, "crystalbleu": 0, "codebertscore": 0.81, "codescore": 0.5318298935890198, "surfaceSim": 0.6595238095238095, "abs_surfaceSim_minus_score": 0.014823809523809461, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_extra_p03796_s015826115_OP_1", "golden_code": "import math\n\n\n\nN = int(eval(input()))\n\nans = 0\n\n\n\nans =math.factorial(N) % (10**9 +7)\n\n\n\nprint(ans)", "generated_code": "N = int(eval(input()))\n\npower = 1\n\n\n\nfor i in range(N):\n\n    power = ((i+1) * power) % 1000000007\n\n\n\nprint(power)", "score": 1.0, "codebleu": 0.257377670210069, "crystalbleu": 0, "codebertscore": 0.78, "codescore": 0.17469877004623413, "surfaceSim": 0.5536179073399272, "abs_surfaceSim_minus_score": 0.4463820926600728, "source": "local", "local_type": "OP"}
{"id": "MBPP_3_41", "golden_code": "def length_Of_Last_Word(a): \r\n    l = 0\r\n    x = a.strip() \r\n    for i in range(len(x)): \r\n        if x[i] == \" \": \r\n            l = 0\r\n        else: \r\n            l += 1\r\n    return l ", "generated_code": "def length_Of_Last_Word(a=\"\"):\n\treturn len(a)", "score": 0.8755, "codebleu": 0.03484567006736189, "crystalbleu": 0, "codebertscore": 0.77, "codescore": 0.8442992568016052, "surfaceSim": 0.5493243243243243, "abs_surfaceSim_minus_score": 0.3261756756756756, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_6_5", "golden_code": "def are_Rotations(string1,string2): \r\n    size1 = len(string1) \r\n    size2 = len(string2) \r\n    temp = '' \r\n    if size1 != size2: \r\n        return False\r\n    temp = string1 + string1 \r\n    if (temp.count(string2)> 0): \r\n        return True\r\n    else: \r\n        return False", "generated_code": "def are_Rotations(string1,string2): \n\treturn True if list(string1) == list(string2) else False", "score": 1.0, "codebleu": 0.1421742833848709, "crystalbleu": 0, "codebertscore": 0.81, "codescore": 0.9670513868331909, "surfaceSim": 0.5437956204379562, "abs_surfaceSim_minus_score": 0.45620437956204385, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_p02612_s197156959_MUT_13", "golden_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "generated_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "score": 0.0, "codebleu": 1.0, "crystalbleu": 1.0, "codebertscore": 1.0, "codescore": 0.993823766708374, "surfaceSim": 1.0, "abs_surfaceSim_minus_score": 1.0, "source": "local", "local_type": "MUT"}
{"id": "MBPP_46_10", "golden_code": "def multiply_list(items):\r\n    tot = 1\r\n    for x in items:\r\n        tot *= x\r\n    return tot", "generated_code": "def multiply_list(l):    \n\tif not l:\n\t\tpass\n\treturn min(l)", "score": 0.1862, "codebleu": 0.09437647524269453, "crystalbleu": 0, "codebertscore": 0.77, "codescore": 0.023924926295876503, "surfaceSim": 0.5277777777777778, "abs_surfaceSim_minus_score": 0.34157777777777776, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_extra_p03371_s203363465_OP_1", "golden_code": "a,b,c,x,y = list(map(int,input().split()))\n\nxy = max(x,y)*2+1\n\nprint((min([c*i + max(0,a*(x-i//2)) +max(0,b*(y-i//2)) for i in range(0,xy,2)])))", "generated_code": "a,b,c,x,y = list(map(int,input().split()))\n\nif x < y:\n\n    a, b, x, y = b, a, y, x\n\nprint((min(a*x+b*y,2*c*y + a*(x-y),2*c*x)))", "score": 1.0, "codebleu": 0.24321055756584475, "crystalbleu": 0.34, "codebertscore": 0.86, "codescore": 0.018867162987589836, "surfaceSim": 0.6243055555555556, "abs_surfaceSim_minus_score": 0.37569444444444444, "source": "local", "local_type": "OP"}
{"id": "APPS_test-1738_55", "golden_code": "def prefix(s):\n    p = [0]\n    for i in range(1, len(s)):\n        j = p[-1]\n        while j > 0 and s[j] != s[i]:\n            j = p[j - 1]\n        if s[i] == s[j]:\n            j += 1\n        p.append(j)\n    return p\n\n\ns = input()\nn = len(s)\nans = [0] * (n + 1)\ni = n - 1\n\nwhile i >= 0:\n    p = prefix(s[i:])\n    ans[i] = 2 + ans[i + 1]\n    for j in range(len(p)):\n        z = 1\n        if (j + 1) % (j + 1 - p[j]) == 0:\n            z = (j + 1) // (j + 1 - p[j])\n        res = len(str(z)) + (j + 1) // z + ans[i + j + 1]\n        ans[i] = min(ans[i], res)\n    i -= 1\n\nprint(ans[0])\n", "generated_code": "import sys\n\ndef main():\n\ts = sys.stdin.readline().strip()\n\ti = 0\n\tlen_s = len(s)\n\tans = 0\n\twhile i < len_s:\n\t\tans += abs(ord(s[i]) - ord('a'))\n\t\ti += 1\n\t\twhile i < len(s) and s[i] == s[i - 1]:\n\t\t\ti += 1\n\tprint(ans + i - 1)\n\ndef __starting_point():\n\tmain()\n__starting_point()\n", "score": 0.001, "codebleu": 0.16683677345145767, "crystalbleu": 0.05, "codebertscore": 0.76, "codescore": 0.047943465411663055, "surfaceSim": 0.5518788682581786, "abs_surfaceSim_minus_score": 0.5508788682581786, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_4553_17_OP_1", "golden_code": "import re\nA, B = list(map(int, input().split()))\nS = input()\nn_pattern = \"[0-9]\"\nres  = \"Yes\"\nfor i in range(A+B+1):\n  if i < A:\n    if re.match(n_pattern, S[i]) is None:\n      res = \"No\"\n      break\n  elif i == A:\n    if S[i] != \"-\":\n      res = \"No\"\n      break\n  else:\n    if re.match(n_pattern, S[i]) is None:\n      res = \"No\"\n      break\n  \nprint(res)", "generated_code": "import re\ndef check_format():\n    a, b = map(int, input().split())\n    string_input = input()\n    if len(string_input) != a + b + 1:\n        print(\"No\")\n        return\n    if string_input[a] != \"-\":\n        print(\"No\")\n        return\n    if not (string_input[:a].isdigit() and string_input[a+1:].isdigit()):\n        print(\"No\")\n        return\n    print(\"Yes\")\ncheck_format()", "score": 1.0, "codebleu": 0.19195528238623005, "crystalbleu": 0.18, "codebertscore": 0.77, "codescore": 0.8775708675384521, "surfaceSim": 0.5201370320855615, "abs_surfaceSim_minus_score": 0.4798629679144385, "source": "local", "local_type": "OP"}
{"id": "APPS_test-0572_16", "golden_code": "def convert_to_binary(coef):\n    res = []\n    n = len(coef)\n    carry = 0\n    i = 0\n    while i < n + 1000:\n        if i >= n and not carry:\n            break\n        cur = carry\n        if i < n:\n            cur += coef[i]\n\n        mod = cur % 2\n        div = cur // 2\n#        print(cur, div, mod)\n\n        res.append(mod)\n\n        carry = div\n\n        i += 1\n    return res, carry\n\nn, k = list(map(int, input().split()))\ncoef = list(map(int, input().split()))\n\nb, carry = convert_to_binary(coef)\nref = False\nif carry < 0:\n    b, carry = convert_to_binary(list([-x for x in coef]))\n    ref = True\n\n\nlast = len(b) - 1\nwhile b[last] != 1:\n    last -= 1\n\nans = 0\nfor i in range(0, n + 1):\n    if last - i > 40:\n        continue\n\n    cur = 0\n    for j in range(i, last + 1):\n        cur += b[j] * (2 ** (j - i))\n\n    new_coef = coef[i] - cur\n    if ref:\n        new_coef = coef[i] + cur\n\n    if abs(new_coef) > k:\n        if b[i] == 1:\n            break\n        continue\n\n    if i == n and new_coef == 0:\n        if b[i] == 1:\n            break\n        continue\n\n    ans += 1\n    if b[i] == 1:\n        break\n\n\nprint(ans)\n", "generated_code": "def main():\n\tn, k = map(int, input().split())\n\tl = [int(i) for i in input().split()]\n\tif sum(l) < k:\n\t\tprint(0)\n\t\treturn\n\tcoeff = []\n\tfor i in range(n + 1):\n\t\tif l[i] <= k:\n\t\t\tcoeff.append(l[i])\n\tif len(coeff) == 1:\n\t\tprint (n * k - cur_sum(k))\n\t\treturn\n#\tprint (n, k)\n\tprint (n * l[0] - cur_sum((k - row[0]) / row[1]))\n\tcur_sum = l[0]\n\tfor i,coeff in enumerate(coeff[1:]):\n\t\tcur_sum += coeff[i] * l[i]\n\tprint (cur_sum)\n\ndef cur_sum(row, col = 0):\n\treturn row[col] + col * row[col - 1]\n\ndef check(r, range_) -> bool:\n\tfor iin in range(len(range_)):\n\t\tif range_[iin] >= r:\n\t\t\treturn False\n\treturn True\n\ndef stack_suc(idx, col):\n\tl = list", "score": 0.0024, "codebleu": 0.15728948171535473, "crystalbleu": 0.14, "codebertscore": 0.75, "codescore": 0.01826520636677742, "surfaceSim": 0.578097680382329, "abs_surfaceSim_minus_score": 0.575697680382329, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_386_1", "golden_code": "def last(arr,x,n):\r\n    low = 0\r\n    high = n - 1\r\n    res = -1  \r\n    while (low <= high):\r\n        mid = (low + high) // 2 \r\n        if arr[mid] > x:\r\n            high = mid - 1\r\n        elif arr[mid] < x:\r\n            low = mid + 1\r\n        else:\r\n            res = mid\r\n            low = mid + 1\r\n    return res", "generated_code": "def last(arr, s, n):\n\n\treturn (arr[n-s:] + arr[:n])", "score": 0.0, "codebleu": 0.06458297034801103, "crystalbleu": 0, "codebertscore": 0.68, "codescore": 0.06027451530098915, "surfaceSim": 0.5152380952380953, "abs_surfaceSim_minus_score": 0.5152380952380953, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_79_30", "golden_code": "def min_of_two( x, y ):\r\n    if x < y:\r\n        return x\r\n    return y", "generated_code": "def min_of_two(x, y) :\n return min(x + y, x or y)\n best_case = min(x+y, x or w)", "score": 0.2441, "codebleu": 0.28776013790356186, "crystalbleu": 0, "codebertscore": 0.84, "codescore": 0.48927488923072815, "surfaceSim": 0.4906924795234549, "abs_surfaceSim_minus_score": 0.2465924795234549, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_34_1", "golden_code": "def even_num(x):\r\n  if x%2==0:\r\n     return True\r\n  else:\r\n    return False", "generated_code": "def even_num(x):\n\n\treturn True if str(x).count('1')%2 == 0 else False", "score": 0.5211, "codebleu": 0.3089851187611845, "crystalbleu": 0, "codebertscore": 0.87, "codescore": 0.5394453406333923, "surfaceSim": 0.635, "abs_surfaceSim_minus_score": 0.1139, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_43_16", "golden_code": "def is_Two_Alter(s):  \r\n    for i in range (len( s) - 2) : \r\n        if (s[i] != s[i + 2]) : \r\n            return False\r\n    if (s[0] == s[1]): \r\n        return False\r\n    return True", "generated_code": "def is_Two_Alter(s):  \n\treturn bool(s) and s == s.replace(' ', '')", "score": 0.1838, "codebleu": 0.11769317831203997, "crystalbleu": 0, "codebertscore": 0.77, "codescore": 0.7261353731155396, "surfaceSim": 0.5342124019957235, "abs_surfaceSim_minus_score": 0.35041240199572354, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_76_OP_1", "golden_code": "def is_simple_power(x, n):\n    if (n == 1): \n        return (x == 1) \n    power = 1\n    while (power < x): \n        power = power * n \n    return (power == x)", "generated_code": "def is_simple_power(num, base):\n    if base == 1:\n        return num == 1\n    if num < 1:\n        return False\n    current_power = 1\n    while current_power < num:\n        current_power *= base\n    return current_power == num", "score": 1.0, "codebleu": 0.3114352035618527, "crystalbleu": 0, "codebertscore": 0.88, "codescore": 0.9905299544334412, "surfaceSim": 0.7711111111111111, "abs_surfaceSim_minus_score": 0.22888888888888892, "source": "local", "local_type": "OP"}
{"id": "LOCAL_APPS_4386_60_OP_1", "golden_code": "a = int(input())\ns = input()\nif a >= 3200:\n  print(s)\nelse:\n  print(\"red\")", "generated_code": "user_input = int(input())\nmessage = input()\noutput = message if user_input >= 3200 else \"red\"\nprint(output)", "score": 1.0, "codebleu": 0.43688125011391193, "crystalbleu": 0, "codebertscore": 0.86, "codescore": 0.6594091057777405, "surfaceSim": 0.6643302180685359, "abs_surfaceSim_minus_score": 0.33566978193146413, "source": "local", "local_type": "OP"}
{"id": "LOCAL_HE_103_OP_1", "golden_code": "def rounded_avg(n, m):\n    if m < n:\n        return -1\n    summation = 0\n    for i in range(n, m+1):\n        summation += i\n    return bin(round(summation/(m - n + 1)))", "generated_code": "def rounded_avg(start, end):\n    if end < start:\n        return -1\n    count = end - start + 1\n    total = (end * (end + 1) // 2) - (start * (start - 1) // 2)\n    return bin(round(total / count))", "score": 1.0, "codebleu": 0.24957601108690533, "crystalbleu": 0, "codebertscore": 0.82, "codescore": 0.8919652700424194, "surfaceSim": 0.7141025641025641, "abs_surfaceSim_minus_score": 0.2858974358974359, "source": "local", "local_type": "OP"}
{"id": "MBPP_40_19", "golden_code": "import datetime\r\ndef check_date(m, d, y):\r\n    try:\r\n        m, d, y = map(int, (m, d, y))\r\n        datetime.date(y, m, d)\r\n        return True\r\n    except ValueError:\r\n        return False", "generated_code": "import datetime\ndef check_date(m, d, y):\n\tif m and d and y and m and d:\n\t\treturn True\n\treturn False\nh = lambda: hex(int(input()))\ng = lambda: input()\ns = lambda: s(g())\np = lambda: chr(ord(s())-255)\nr = lambda: map(chr, range(97, 123))", "score": 0.2265, "codebleu": 0.315860468856061, "crystalbleu": 0, "codebertscore": 0.78, "codescore": 0.3695319890975952, "surfaceSim": 0.4835992907801418, "abs_surfaceSim_minus_score": 0.2570992907801418, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-4188_40", "golden_code": "a=['1','0','0','1','0','1','0','1','1','1','0','0','1','0','1','0']\nprint(a[int(input())-1])", "generated_code": "a=int(input())\nif(a==1):\n\tprint(0)\nelse:\n\tprint(a-6)\n", "score": 0.0, "codebleu": 0.07614942528735633, "crystalbleu": 0, "codebertscore": 0.86, "codescore": 0.05112956091761589, "surfaceSim": 0.38858695652173914, "abs_surfaceSim_minus_score": 0.38858695652173914, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_1315_2_OP_1", "golden_code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,copy\nfrom itertools import chain, dropwhile, permutations, combinations\nfrom collections import defaultdict, deque\n\ndef VI(): return list(map(int,input().split()))\n\ndef run(n,a):\n    b = copy.copy(a)\n    for i in range(n):\n        b[i] -= (n-i)\n    b.sort()\n    for i in range(n):\n        if i<n-1:\n            if b[i]==b[i+1]:\n                print(\":(\")\n                return\n        b[i] = str(b[i]+(n-i))\n    print(\" \".join(b))\n\n\ndef main(info=0):\n    n = int(input())\n    a = VI()\n    run(n,a)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "generated_code": "import bisect\n\ndef VI(): return list(map(int, input().split()))\n\ndef run(size, arr):\n    temp_list = [(arr[i] - (size - i)) for i in range(size)]\n    temp_list.sort()\n    for idx in range(1, size):\n        if temp_list[idx] == temp_list[idx - 1]:\n            print(\":(\")\n            return\n    result = [str(temp_list[i] + (size - i)) for i in range(size)]\n    print(\" \".join(result))\n\ndef main(info=0):\n    num = int(input())\n    values = VI()\n    run(num, values)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "score": 1.0, "codebleu": 0.3911511981751235, "crystalbleu": 0.4, "codebertscore": 0.81, "codescore": 0.14999927580356598, "surfaceSim": 0.6749396002635625, "abs_surfaceSim_minus_score": 0.3250603997364375, "source": "local", "local_type": "OP"}
{"id": "APPS_test-3879_4", "golden_code": "def check(x):\n    while (x>1):\n        if (x%2==0):\n            x/=2\n        elif (x%3==0):\n            x/=3\n        else:\n            return False\n    return True\n\na=[]\nn=int(input())\na=list(map(int,input().split()))\na.sort()\nflag=True\nwhile (a[0]%2==0 or a[0]%3==0):\n    if(a[0]%2==0):\n        a[0]/=2\n    else:\n        a[0]/=3\n#print (a)\nfor x in a:\n    y=x%a[0]\n    z=x/a[0]\n    #print (y,z)\n    if(y==0 and check(z)):\n        continue\n    else:\n        flag=False\nif flag==True:\n    print ('Yes')\nelse:\n    print ('No')", "generated_code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n# first check upto nth player does not get prld input\n#!/usr.setrecursionlimit(10**6)\n#\n#L seen: 2result[i]combo that is the nth player 1's round is 2\n#,socom::-\n# 2: 1 returns 1\n# 3: 1 returns 0\n# 4: 0\n#5: \n#6: 1\n#7:,1\n#8: [1]\n#9: [0]\n#10: [0] is wrong\n#\n#https://www.codechef.com/problems/lt/sum/m_preINF/answers/:=lambda\n#:0<inptStr][it%2] == \"Yes\"\n#8:]-0", "score": 0.0, "codebleu": 0.25, "crystalbleu": 0, "codebertscore": 0.62, "codescore": 0.018284089863300323, "surfaceSim": 0.18651399491094145, "abs_surfaceSim_minus_score": 0.18651399491094145, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_43_91", "golden_code": "def is_Two_Alter(s):  \r\n    for i in range (len( s) - 2) : \r\n        if (s[i] != s[i + 2]) : \r\n            return False\r\n    if (s[0] == s[1]): \r\n        return False\r\n    return True", "generated_code": "def is_Two_Alter(s):  \n\ta,b = s[0],s[1]\n\tfor i in range(2,len(s)):\n\t\tif s[i]!= a and s[i-1]!= b: return False\n\t\tif(s[i-2]!= b): return False\n\t\n\treturn True", "score": 0.8151, "codebleu": 0.34871002676317875, "crystalbleu": 0, "codebertscore": 0.88, "codescore": 0.9672131538391113, "surfaceSim": 0.7711748633879781, "abs_surfaceSim_minus_score": 0.04392513661202191, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-1424_48", "golden_code": "def count_one(n):\n    c = 0\n    while(n):\n        n = n&(n-1)\n        c = c + 1\n    return c\nnmk=input()\nb=nmk.split(' ')\nn=int(b[0])\nm=int(b[1])\nk=int(b[2])\na=[]\nfor i in range(m+1):\n    istr=input()\n    a.append(int(istr))\nans=0\nfor i in range(m):\n    if(count_one(a[i]^a[m])<=k):\n        ans=ans+1\nprint(ans)\n", "generated_code": "n, m, k = map(int, input().split())\np = [0] * (n + 1)\nfor i in range(m): p[i + 1] = p[i] ^ (1 << int(input()))\nf = [0] + [1] * (n - 1)\nfor k in range(1, n): f[k] = f[k - 1] ^ p[k]\nprint(sum(f[i] for i in range(n + 1)))\n", "score": 0.0, "codebleu": 0.1686808395909753, "crystalbleu": 0.13, "codebertscore": 0.78, "codescore": 0.15479697287082672, "surfaceSim": 0.4793217535153019, "abs_surfaceSim_minus_score": 0.4793217535153019, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_68_35", "golden_code": "def subset(ar, n): \r\n    res = 0\r\n    ar.sort() \r\n    for i in range(0, n) : \r\n        count = 1\r\n        for i in range(n - 1): \r\n            if ar[i] == ar[i + 1]: \r\n                count+=1\r\n            else: \r\n                break \r\n        res = max(res, count)  \r\n    return res ", "generated_code": "def subset(ar, n): \n\treturn sum(ar[:n])\n\n\n\n\n\n\n\n\n\n\t\n\t\n\t\n\t\n\t\n\treturn (n-(r*i))\n\n\n\n\n\n\treturn round((a-b)-(a-b))", "score": 0.004, "codebleu": 0.08298934607939565, "crystalbleu": 0, "codebertscore": 0.71, "codescore": 0.04257183149456978, "surfaceSim": 0.5314685314685315, "abs_surfaceSim_minus_score": 0.5274685314685315, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_73_MUT_15", "golden_code": "import os\n\ndef smallest_change(arr):\n    ans = 0\n    for i in range(len(arr) // 2):\n        if arr[i] != arr[(len(arr) - i) - 1]:\n            ans += 1\n    return ans", "generated_code": "import os\n\ndef smallest_change(arr):\n    ans = 0\n    for i in range(len(arr) // 2):\n        if arr[i] != arr[(len(arr) - i) - 1]:\n            ans += 1\n    pass", "score": 0.0, "codebleu": 0.906353337903351, "crystalbleu": 0, "codebertscore": 0.98, "codescore": 0.9936703443527222, "surfaceSim": 0.9387878787878787, "abs_surfaceSim_minus_score": 0.9387878787878787, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_APPS_1315_2_MUT_4", "golden_code": "import math, string, itertools, fractions, heapq, collections, re, array, bisect, copy\nfrom itertools import chain, dropwhile, permutations, combinations\nfrom collections import defaultdict, deque\n\ndef VI():\n    return list(map(int, input().split()))\ndef run(n, a):\n    b = copy.copy(a)\n    for i in range(n):\n        b[i] -= n - i\n    b.sort()\n    for i in range(n):\n        if i < n - 1:\n            if b[i] == b[i + 1]:\n                print(':(')\n                return\n        b[i] = str(b[i] + (n - i))\n    print(' '.join(b))\n\n\ndef main(info=0):\n    n = int(input())\n    a = VI()\n    run(n, a)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "generated_code": "import math, string, itertools, fractions, heapq, collections, re, array, bisect, copy\nfrom itertools import chain, dropwhile, permutations, combinations\nfrom collections import defaultdict, deque\n\ndef VI():\n    return list(map(int, input().split()))\ndef run(n, a):\n    b = copy.copy(a)\n    for i in range(n):\n        b[i] -= n - i\n    b.sort()\n    for i in range(n):\n        if i < n - 1:\n            if b[i] == b[i + 1]:\n                print(':(')\n                return\n        b[i] = str(b[i] - (n - i))\n    print(' '.join(b))\n\n\ndef main(info=0):\n    n = int(input())\n    a = VI()\n    run(n, a)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "score": 0.151, "codebleu": 0.9852085737132209, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.4240368902683258, "surfaceSim": 0.999236641221374, "abs_surfaceSim_minus_score": 0.848236641221374, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_HE_129_MUT_17", "golden_code": "import os\n\ndef minPath(grid, k):\n    n = len(grid)\n    val = (n * n) + 1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                temp = []\n                if i != 0:\n                    temp.append(grid[i - 1][j])\n                \n                if j != 0:\n                    temp.append(grid[i][j - 1])\n                \n                if i != n - 1:\n                    temp.append(grid[i + 1][j])\n                \n                if j != n - 1:\n                    temp.append(grid[i][j + 1])\n                \n                val = min(temp)\n    \n    ans = []\n    for i in range(k):\n        if i % 2 == 0:\n            ans.append(1)\n        else:\n            ans.append(val)\n    return ans", "generated_code": "import os\n\ndef minPath(grid, k):\n    n = len(grid)\n    val = (n * n) + 1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                temp = []\n                if i != 0:\n                    temp.append(grid[i - 1][j])\n                \n                if j != 0:\n                    temp.append(grid[i][j - 1])\n                \n                if i != n - 1:\n                    temp.append(grid[i + 1][j])\n                \n                if j != n - 1:\n                    temp.append(grid[i][j + 1])\n                \n                val = min(temp)\n    \n    ans = []\n    for i in range(k):\n        if not (i % 2 == 0):\n            ans.append(1)\n        else:\n            ans.append(val)\n    return ans", "score": 0.0, "codebleu": 0.9515286229503193, "crystalbleu": 0.95, "codebertscore": 1.0, "codescore": 0.993650496006012, "surfaceSim": 0.9632928475033739, "abs_surfaceSim_minus_score": 0.9632928475033739, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-1592_15", "golden_code": "n = int(input())\nans, p, s = 0, 0, 0\nfor i in range(n):\n    t, c = map(int, input().split())\n    s -= min(s, t - p)\n    p = t\n    s += c\n    if s > ans: ans = s\nprint(p + s, ans)", "generated_code": "import sys\n\ndef main():\n\tn = int(input())\n\tL = [0] * n\n\tfor i in range(n):\n\t\tt, c = list(map(int, input().split()))\n\t\tL[i] = (t, c)\n\tL.sort(reverse=True)\n\n\ts, q = 0, 0\n\tM = 0\n\tans = ''\n\tfor i, (t, c,) in enumerate(L):\n\t\tif c > M:\n\t\t\tans = f'{s:0{q}}{c}'\n\t\t\ts = i + 1\n\t\t\tq = c\n\t\telif c <= M:\n\t\t\tq += 1\n\t\t\tM = max(M, t)\n\t\t\tans = s + t\n\t\t\ts = ans\n\tprint(ans, q)\n\ndef __starting_point():\n\tmain()\n\n", "score": 0.0, "codebleu": 0.3319356530039247, "crystalbleu": 0, "codebertscore": 0.8, "codescore": 0.031275223940610886, "surfaceSim": 0.528880407124682, "abs_surfaceSim_minus_score": 0.528880407124682, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_extra_p03037_s129241236_OP_1", "golden_code": "k,m=list(map(int,input().split()))\n\nl=[0 for i in range(k+1)]\n\nfor i in range(m):\n\n  a,s=list(map(int,input().split()))\n\n  l[a-1]+=1;l[s]-=1\n\nans=0\n\nf=0\n\nfor j in range(k):\n\n  l[j]+=f\n\n  f=l[j]\n\nprint((len([1 for i in l if i==m])))", "generated_code": "n,m=list(map(int,input().split()))\n\ntable=[0]*(n+2)\n\nfor i in range(m):\n\n    l,r=list(map(int,input().split()))\n\n    table[l]+=1\n\n    table[r+1]-=1\n\nfrom itertools import accumulate\n\nfrom collections import Counter as co\n\nvar=co((accumulate(table)))\n\n\n\nif m not in var:print((0))\n\nelse:print((var[m]))\n\n\n\n\n", "score": 1.0, "codebleu": 0.311095844007021, "crystalbleu": 0.21, "codebertscore": 0.85, "codescore": 0.7889459729194641, "surfaceSim": 0.5964052287581699, "abs_surfaceSim_minus_score": 0.4035947712418301, "source": "local", "local_type": "OP"}
{"id": "APPS_test-3969_20", "golden_code": "from bisect import bisect_right\nn = int(input().split()[0])\nt = [int(input().split()[0]) for i in range(n)]\np, k = [], 0\nfor i in t:\n    x = bisect_right(p, i)\n    if x < k: p[x] = i\n    else:\n        p.append(i)\n        k += 1\nprint(n - k)", "generated_code": "n, m = list(map(int, input().split()))\nx = [0]*(m+1)\nfor i in range(n):\n\ta, b = list(map (int, input().replace(' ', '').split('.')))\n\tx[b] = x[b] + 1\nans = 0\nfor i in x:\n\tif i:\n\t\tans += 1\nprint(ans)\n", "score": 0.0716, "codebleu": 0.24375250643580626, "crystalbleu": 0.13, "codebertscore": 0.8, "codescore": 0.12198880314826965, "surfaceSim": 0.5794871794871794, "abs_surfaceSim_minus_score": 0.5078871794871794, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_p02599_s870922238_MUT_20", "golden_code": "import sys\nclass BinaryIndexedTree:\n    def __init__(self, A):\n        self.__n = len(A)\n        self.__node = [0] * (self.__n + 1)\n        self.__data = [0] * (self.__n + 1)\n        S = [0] * (self.__n + 1)\n        for i in range(1, self.__n + 1):\n            S[i] = S[i - 1] + A[i - 1]\n            self.__data[i] = A[i - 1]\n            self.__node[i] = S[i] - S[i - (i & (-i))]\n    def add(self, i, v):\n        self.__data[i] += v\n        while i <= self.__n:\n            self.__node[i] += v\n            i += i & (-i)\n    def sum(self, i):\n        rst = 0\n        while i > 0:\n            rst += self.__node[i]\n            i -= i & (-i)\n        return rst\n    def get(self, i, j):\n        if i == j:\n            return self.__data[i]\n        else:\n            return self.sum(j) - self.sum(i - 1)\ndef main():\n    (N, Q) = map(int, input().split())\n    C = list(map(int, input().split()))\n    P = [[] for _ in range(N)]\n    for (i, c) in enumerate(C):\n        P[c - 1].append(i)\n    right = [0] * N\n    for p in P:\n        if len(p):\n            right[p.pop()] = 1\n    BIT = BinaryIndexedTree(right)\n    query = [[] for _ in range(N)]\n    for (i, s) in enumerate(sys.stdin.readlines()):\n        (l, r) = map(int, s.split())\n        query[r - 1].append((l - 1, i))\n    ans = [None] * Q\n    cur = N - 1\n    for (r, q) in enumerate(reversed(query)):\n        r = (N - 1) - r\n        while q:\n            (l, i) = q.pop()\n            while r < cur:\n                c = C[cur] - 1\n                p = P[c]\n                if len(p):\n                    BIT.add(p.pop() + 1, 1)\n                cur -= 1\n            tmp = BIT.get(l + 1, r + 1)\n            ans[i] = tmp\n    print(sep='\\n', *ans)", "generated_code": "import sys\nclass BinaryIndexedTree:\n    def __init__(self, A):\n        self.__n = len(A)\n        self.__node = [0] * (self.__n + 1)\n        self.__data = [0] * (self.__n + 1)\n        S = [0] * (self.__n + 1)\n        for i in range(1, self.__n + 1):\n            S[i] = S[i - 1] + A[i - 1]\n            self.__data[i] = A[i + 1]\n            self.__node[i] = S[i] - S[i - (i & (-i))]\n    def add(self, i, v):\n        self.__data[i] += v\n        while i <= self.__n:\n            self.__node[i] += v\n            i += i & (-i)\n    def sum(self, i):\n        rst = 0\n        while i > 0:\n            rst += self.__node[i]\n            i -= i & (-i)\n        return rst\n    def get(self, i, j):\n        if i == j:\n            return self.__data[i]\n        else:\n            return self.sum(j) - self.sum(i - 1)\ndef main():\n    (N, Q) = map(int, input().split())\n    C = list(map(int, input().split()))\n    P = [[] for _ in range(N)]\n    for (i, c) in enumerate(C):\n        P[c - 1].append(i)\n    right = [0] * N\n    for p in P:\n        if len(p):\n            right[p.pop()] = 1\n    BIT = BinaryIndexedTree(right)\n    query = [[] for _ in range(N)]\n    for (i, s) in enumerate(sys.stdin.readlines()):\n        (l, r) = map(int, s.split())\n        query[r - 1].append((l - 1, i))\n    ans = [None] * Q\n    cur = N - 1\n    for (r, q) in enumerate(reversed(query)):\n        r = (N - 1) - r\n        while q:\n            (l, i) = q.pop()\n            while r < cur:\n                c = C[cur] - 1\n                p = P[c]\n                if len(p):\n                    BIT.add(p.pop() + 1, 1)\n                cur -= 1\n            tmp = BIT.get(l + 1, r + 1)\n            ans[i] = tmp\n    print(sep='\\n', *ans)", "score": 0.0378, "codebleu": 0.994935590512094, "crystalbleu": 1.0, "codebertscore": 1.0, "codescore": 0.9936488270759583, "surfaceSim": 0.9997036158861885, "abs_surfaceSim_minus_score": 0.9619036158861884, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_PIE_extra_p02596_s838540391_OP_1", "golden_code": "k = int(eval(input()))\n\ncount = 1\n\nn = 0\n\nif k % 2 == 0 or k % 5 == 0:\n\n    print((-1))\n\nelse:\n\n  while 1:\n\n      n = (n * 10 + 7) % k  \n\n      if n == 0:\n\n        break \n\n      count += 1\n\n  print(count)", "generated_code": "def main(h):\n\n  count = 1\n\n  n = 0\n\n  for i in range (k):\n\n    n = (n * 10 + 7) % k  \n\n    if n == 0: \n\n      print(count)\n\n      return 0\n\n    count += 1\n\n  print((-1))\n\n  \n\nif __name__ == '__main__':\n\n  k = int(eval(input()))\n\n  main(k)", "score": 1.0, "codebleu": 0.47065797982054347, "crystalbleu": 0, "codebertscore": 0.87, "codescore": 0.048467252403497696, "surfaceSim": 0.604341736694678, "abs_surfaceSim_minus_score": 0.39565826330532206, "source": "local", "local_type": "OP"}
{"id": "LOCAL_PIE_extra_p03796_s111144925_OP_1", "golden_code": "import math\n\n\n\nN = int(eval(input()))\n\n\n\npower = math.factorial(N)\n\n\n\nprint((power % 1000000007))\n\n\n", "generated_code": "n=int(eval(input()))\n\nans=1\n\nfor i in range(n):\n\n    ans=(ans*(i+1))%(10**9+7)\n\nprint(ans)", "score": 1.0, "codebleu": 0.23095238095238096, "crystalbleu": 0, "codebertscore": 0.76, "codescore": 0.1260320097208023, "surfaceSim": 0.47911764705882354, "abs_surfaceSim_minus_score": 0.5208823529411765, "source": "local", "local_type": "OP"}
{"id": "LOCAL_APPS_1407_12_MUT_26", "golden_code": "def sieve(mx):\n    a = [0] * (mx + 1)\n    a[0] = a[1] = 1\n    for (i, e) in enumerate(a):\n        if e == 0:\n            for n in range(i * i, mx + 1, i):\n                a[n] = 1\n    return a\n\np = sieve((10 ** 5) + 100)\nfor i in range((10 ** 5) + 99, 0, -1):\n    p[i] *= p[i + 1] + 1\n\n(n, m) = map(int, input().split())\n\ncols = [0] * m\n\nmm = 10 ** 7\nfor i in range(n):\n    row = list(map(int, input().split()))\n    row_sum = 0\n    for (a, j) in enumerate(row):\n        tt = p[j]\n        row_sum += tt\n        cols[a] += tt\n    mm = min(mm, row_sum)\n\nprint(min(min(cols), mm))", "generated_code": "def sieve(mx):\n    a = [0] * (mx + 1)\n    a[0] = a[1] = 1\n    for (i, e) in enumerate(a):\n        if not (e == 0):\n            for n in range(i * i, mx + 1, i):\n                a[n] = 1\n    return a\n\np = sieve((10 ** 5) + 100)\nfor i in range((10 ** 5) + 99, 0, -1):\n    p[i] *= p[i + 1] + 1\n\n(n, m) = map(int, input().split())\n\ncols = [0] * m\n\nmm = 10 ** 7\nfor i in range(n):\n    row = list(map(int, input().split()))\n    row_sum = 0\n    for (a, j) in enumerate(row):\n        tt = p[j]\n        row_sum += tt\n        cols[a] += tt\n    mm = min(mm, row_sum)\n\nprint(min(min(cols), mm))", "score": 0.0, "codebleu": 0.9646621699752762, "crystalbleu": 0.96, "codebertscore": 1.0, "codescore": 0.9937626719474792, "surfaceSim": 0.9784630880436072, "abs_surfaceSim_minus_score": 0.9784630880436072, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-0251_4", "golden_code": "n,k = map(int,input().split())\narr = list(map(int,input().split()))\n\narr.sort()\nheights = []\ncounter=arr[0]\nfor i in range(n):\n    while arr[i]>=counter:\n        heights.append(n-i)\n        counter+=1\n\nheights.reverse()\n\n\nans=0\ncontainer=0\nfor i in range(len(heights)-1):\n    if heights[i]+container<=k:\n        container+=heights[i]\n    else:\n        container=heights[i]\n        ans+=1\nif container>0:ans+=1\n\nprint(ans)", "generated_code": "n,k=list(map(int,input().split()))\na=list(map (int,input().strip().split()));t=[]\nfor i in range(n):\n\tt.append(a[i])\n\tfor j in range(i+1,n):\n\t\tt.append(t[-1]+a[j])\nans=t[0]\nfor i in t:\n\tif(i<=k):\n\t\tans=min(ans,i)\nprint(ans)\n", "score": 0.042, "codebleu": 0.26460734396805086, "crystalbleu": 0.26, "codebertscore": 0.82, "codescore": 0.06650498509407043, "surfaceSim": 0.6136031427005298, "abs_surfaceSim_minus_score": 0.5716031427005298, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_2323_12_OP_2", "golden_code": "import copy\nimport bisect\n\nn = int(input())\ns = list(map(int, input().split()))\nsCopy = copy.deepcopy(s)\n\nAP = []\nmx = -1\nsCopy.sort()\nmiss = []\nfor i in range(n-1):\n    mx = max(mx, sCopy[i+1]-sCopy[i]-1, 0)\n    miss.append(max(sCopy[i+1]-sCopy[i]-1, 0))\n\nmiss.sort()\nif miss!=[]:\n    pSOfMiss = [miss[0]]\n    for i in range(1, len(miss)):\n        pSOfMiss.append(pSOfMiss[-1]+miss[i])\n\nMAX = max(s)\nMIN = min(s)\nC = len(set(s))\nansList = []\nmL = len(miss)\nq = int(input())\nfor _ in range(q):\n    l, r = list(map(int, input().split()))\n    if l==r:\n        ansList.append(C)\n    elif n==1:\n        ans = r-l+1\n        ansList.append(ans)\n    elif r-l>=mx:\n        ans = (MAX+r)-(MIN+l)+1\n        ansList.append(ans)\n    else:\n        idx = bisect.bisect_right(miss, r-l)\n        if idx>0:\n            notThere = pSOfMiss[-1]-pSOfMiss[idx-1]-((r-l)*(mL-idx))\n        else:\n            notThere = pSOfMiss[-1] - ((r-l)*(mL-idx))\n        ans = (MAX+r)-(MIN+l)+1-notThere\n        ansList.append(ans)\n\nprint(*ansList)", "generated_code": "import bisect\n\ndef main():\n    num_elements = int(input())\n    sequence = list(map(int, input().split()))\n\n    sorted_sequence = sorted(sequence)\n    gaps = [sorted_sequence[i + 1] - sorted_sequence[i] - 1 for i in range(num_elements - 1)]\n    max_gap = max(gaps, default=0)\n\n    prefix_sum = [0] * len(gaps)\n    if gaps:\n        prefix_sum[0] = gaps[0]\n        for i in range(1, len(gaps)):\n            prefix_sum[i] = prefix_sum[i - 1] + gaps[i]\n\n    max_val = max(sequence)\n    min_val = min(sequence)\n    unique_count = len(set(sequence))\n\n    num_queries = int(input())\n    results = []\n    for _ in range(num_queries):\n        left, right = map(int, input().split())\n        if left == right:\n            results.append(unique_count)\n        elif num_elements == 1:\n            results.append(right - left + 1)\n        elif right - left >= max_gap:\n            results.append((max_val + right) - (min_val + left) + 1)\n        else:\n            index = bisect.bisect_right(gaps, right - left)\n            if index > 0:\n                missing = prefix_sum[-1] - prefix_sum[index - 1] - ((right - left) * (len(gaps) - index))\n            else:\n                missing = prefix_sum[-1] - ((right - left) * (len(gaps) - index))\n            results.append((max_val + right) - (min_val + left) + 1 - missing)\n\n    print(*results)\n\nmain()", "score": 1.0, "codebleu": 0.3331439944541022, "crystalbleu": 0.25, "codebertscore": 0.79, "codescore": 0.1625596582889557, "surfaceSim": 0.6956091337058383, "abs_surfaceSim_minus_score": 0.3043908662941617, "source": "local", "local_type": "OP"}
{"id": "MBPP_50_16", "golden_code": "def mutiple_tuple(nums):\r\n    temp = list(nums)\r\n    product = 1 \r\n    for x in temp:\r\n        product *= x\r\n    return product", "generated_code": "def mutiple_tuple(num):    \n\treturn any(num[i] == num[i+1] for i in range(len(num)) if num[i]!= '!')", "score": 0.0081, "codebleu": 0.12737219895652682, "crystalbleu": 0, "codebertscore": 0.79, "codescore": 0.01860499009490013, "surfaceSim": 0.5126668948990072, "abs_surfaceSim_minus_score": 0.5045668948990072, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_p02599_s870922238_MUT_115", "golden_code": "import sys\nclass BinaryIndexedTree:\n    def __init__(self, A):\n        self.__n = len(A)\n        self.__node = [0] * (self.__n + 1)\n        self.__data = [0] * (self.__n + 1)\n        S = [0] * (self.__n + 1)\n        for i in range(1, self.__n + 1):\n            S[i] = S[i - 1] + A[i - 1]\n            self.__data[i] = A[i - 1]\n            self.__node[i] = S[i] - S[i - (i & (-i))]\n    def add(self, i, v):\n        self.__data[i] += v\n        while i <= self.__n:\n            self.__node[i] += v\n            i += i & (-i)\n    def sum(self, i):\n        rst = 0\n        while i > 0:\n            rst += self.__node[i]\n            i -= i & (-i)\n        return rst\n    def get(self, i, j):\n        if i == j:\n            return self.__data[i]\n        else:\n            return self.sum(j) - self.sum(i - 1)\ndef main():\n    (N, Q) = map(int, input().split())\n    C = list(map(int, input().split()))\n    P = [[] for _ in range(N)]\n    for (i, c) in enumerate(C):\n        P[c - 1].append(i)\n    right = [0] * N\n    for p in P:\n        if len(p):\n            right[p.pop()] = 1\n    BIT = BinaryIndexedTree(right)\n    query = [[] for _ in range(N)]\n    for (i, s) in enumerate(sys.stdin.readlines()):\n        (l, r) = map(int, s.split())\n        query[r - 1].append((l - 1, i))\n    ans = [None] * Q\n    cur = N - 1\n    for (r, q) in enumerate(reversed(query)):\n        r = (N - 1) - r\n        while q:\n            (l, i) = q.pop()\n            while r < cur:\n                c = C[cur] - 1\n                p = P[c]\n                if len(p):\n                    BIT.add(p.pop() + 1, 1)\n                cur -= 1\n            tmp = BIT.get(l + 1, r + 1)\n            ans[i] = tmp\n    print(sep='\\n', *ans)", "generated_code": "import sys\nclass BinaryIndexedTree:\n    def __init__(self, A):\n        self.__n = len(A)\n        self.__node = [0] * (self.__n + 1)\n        self.__data = [0] * (self.__n + 1)\n        S = [0] * (self.__n + 1)\n        for i in range(1, self.__n + 1):\n            S[i] = S[i - 1] + A[i - 1]\n            self.__data[i] = A[i - 1]\n            self.__node[i] = S[i] - S[i - (i & (-i))]\n    def add(self, i, v):\n        self.__data[i] += v\n        while i <= self.__n:\n            self.__node[i] += v\n            i += i & (-i)\n    def sum(self, i):\n        rst = 0\n        while i > 0:\n            rst += self.__node[i]\n            i -= i & (-i)\n        return rst\n    def get(self, i, j):\n        if i == j:\n            return self.__data[i]\n        else:\n            return self.sum(j) - self.sum(i - 1)\ndef main():\n    (N, Q) = map(int, input().split())\n    C = list(map(int, input().split()))\n    P = [[] for _ in range(N)]\n    for (i, c) in enumerate(C):\n        P[c - 1].append(i)\n    right = [0] * N\n    for p in P:\n        if len(p):\n            right[p.pop()] = 1\n    BIT = BinaryIndexedTree(right)\n    query = [[] for _ in range(N)]\n    for (i, s) in enumerate(sys.stdin.readlines()):\n        (l, r) = map(int, s.split())\n        pass\n    ans = [None] * Q\n    cur = N - 1\n    for (r, q) in enumerate(reversed(query)):\n        r = (N - 1) - r\n        while q:\n            (l, i) = q.pop()\n            while r < cur:\n                c = C[cur] - 1\n                p = P[c]\n                if len(p):\n                    BIT.add(p.pop() + 1, 1)\n                cur -= 1\n            tmp = BIT.get(l + 1, r + 1)\n            ans[i] = tmp\n    print(sep='\\n', *ans)", "score": 0.0378, "codebleu": 0.9712205396075638, "crystalbleu": 0.96, "codebertscore": 0.99, "codescore": 0.9936702251434326, "surfaceSim": 0.980395275203493, "abs_surfaceSim_minus_score": 0.942595275203493, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_APPS_604_16_OP_1", "golden_code": "n = int(input())\na = list(map(int, input().split()))\nprint(len(set(a) - {0}))", "generated_code": "numbers_count = int(input())\nnumbers_list = map(int, input().split())\nprint(len({num for num in numbers_list if num != 0}))", "score": 1.0, "codebleu": 0.33991579675841166, "crystalbleu": 0, "codebertscore": 0.82, "codescore": 0.7315121293067932, "surfaceSim": 0.5739329268292683, "abs_surfaceSim_minus_score": 0.42606707317073167, "source": "local", "local_type": "OP"}
{"id": "MBPP_43_109", "golden_code": "def is_Two_Alter(s):  \r\n    for i in range (len( s) - 2) : \r\n        if (s[i] != s[i + 2]) : \r\n            return False\r\n    if (s[0] == s[1]): \r\n        return False\r\n    return True", "generated_code": "def is_Two_Alter(s):  \n\tprev = s[0]\n\tif len(s) == 1:\n\t\treturn True\n\telif s[1]!= prev:\n\t\tif s[0]+s[1] == prev:\n\t\t\treturn True\n\t\telse:\n\t\t\t0\n\t\t\n\t\t\n\treturn False", "score": 0.8492, "codebleu": 0.2139434873013799, "crystalbleu": 0, "codebertscore": 0.82, "codescore": 0.963141918182373, "surfaceSim": 0.7314952806756085, "abs_surfaceSim_minus_score": 0.11770471932439142, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_extra_p03796_s015060265_OP_1", "golden_code": "import math\n\nprint((math.factorial(int(eval(input())))%(10**9+7)))", "generated_code": "ans=1\n\nn=int(eval(input()))\n\nfor i in range(1,n+1):\n\n  ans*=i\n\n  ans=ans%(10**9+7)\n\nprint(ans)", "score": 1.0, "codebleu": 0.2375, "crystalbleu": 0, "codebertscore": 0.81, "codescore": 0.8030822277069092, "surfaceSim": 0.4479905437352246, "abs_surfaceSim_minus_score": 0.5520094562647754, "source": "local", "local_type": "OP"}
{"id": "APPS_test-3741_1", "golden_code": "import sys\nfrom collections import deque\n\nn = int(input())\na = list(map(int, input().split()))\nna = list()\nfor x in a:\n    if (x):\n        na.append(x)\na = na\nn = len(a)\nfor b in range(60):\n    cnt = 0\n    for x in a:\n        if (x >> b & 1):\n            cnt += 1\n    if (cnt >= 3) :\n        print(3)\n        return\ng = [list() for x in range(n)]\nfor i in range(n):\n    for j in range (n):\n        if (i != j and (a[i] & a[j])):\n            g[i].append(j)\nans = 200\ndef go(r):\n    nonlocal ans\n    d = [-1 for x in range(n)]\n    q = deque()\n    d[r] = 0\n    q.append(r)\n    while (len(q)):\n        v = q.popleft()\n        for u in g[v]:\n            if (d[u] == -1):\n                d[u] = d[v] + 1\n                q.append(u)\n            elif (d[u] >= d[v]):\n                ans = min(ans, d[v] + d[u] + 1)\nfor r in range(n):\n    go(r)\nif (ans > n) :\n    ans = -1\nprint(ans)", "generated_code": "from collections import defaultdict\ndef main():\n\tn = int(input())\n\taa = list(map(int, input().split()))\n\ts = set()\n\tfor i in aa:\n\t\ts.add(i)\n\taa = [i for i in aa if i not in s]\n\tif len(aa) == 0:\n\t\tprint(-1)\n\t\treturn\n\tif len({i for i in s}) == 0:\n#         print(s)\n\t\treturn -1\n\tss = set()\n   \n\tres = 0\n\tfor i, u in enumerate(aa):\n\t\tfor v in ss:\n\t\t\tif u & v == 0:\n\t\t\t\tss.add(u | v)\n\t\t\t\tres = max(res, i + 1)\n\treturn res\n\nprint(main())\n", "score": 0.0, "codebleu": 0.2003300673467518, "crystalbleu": 0.07, "codebertscore": 0.78, "codescore": 0.18718315660953522, "surfaceSim": 0.5853764846899858, "abs_surfaceSim_minus_score": 0.5853764846899858, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_p00144_s682125154_MUT_106", "golden_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "generated_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    pass\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "score": 0.0, "codebleu": 0.9841415039131673, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.9935845732688904, "surfaceSim": 0.9830717738065982, "abs_surfaceSim_minus_score": 0.9830717738065982, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_PIE_p03634_s143869460_MUT_8", "golden_code": "import sys\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\ndef solve():\n    inf = (10 ** 14) + 10\n    def dfs(v: 'vertex_index, 0-indexed') -> None:\n        for (c, t) in e[v]:\n            if d[t] != inf:\n                continue\n            d[t] = d[v] + c\n            dfs(t)\n    n = int(eval(input()))\n    e = tuple((set() for _ in range(n)))\n    for _ in range(n - 1):\n        (a, b, c) = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        e[a].add((c, b))\n        e[b].add((c, a))\n    (q, v) = list(map(int, input().split()))\n    v -= 1\n    d = [inf] * n\n    d[v] = 0\n    dfs(v)\n    for _ in range(q):\n        (x, y) = list(map(int, input().split()))\n        x -= 1\n        y -= 1\n        print(d[x] + d[y])", "generated_code": "import sys\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\ndef solve():\n    inf = (10 ** 14) + 10\n    def dfs(v: 'vertex_index, 0-indexed') -> None:\n        for (c, t) in e[v]:\n            if d[t] != inf:\n                continue\n            d[t] = d[v] + c\n            dfs(t)\n    n = int(eval(input()))\n    e = tuple((set() for _ in range(n)))\n    for _ in range(n - 1):\n        (a, b, c) = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        e[a].add((c, b))\n        e[b].add((c, a))\n    (q, v) = list(map(int, input().split()))\n    v -= 1\n    d = [inf] ** n\n    d[v] = 0\n    dfs(v)\n    for _ in range(q):\n        (x, y) = list(map(int, input().split()))\n        x -= 1\n        y -= 1\n        print(d[x] + d[y])", "score": 0.0, "codebleu": 0.9881398574370538, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9938097596168518, "surfaceSim": 0.983196203909277, "abs_surfaceSim_minus_score": 0.983196203909277, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_APPS_3738_2_OP_2", "golden_code": "def minus_two(x, y):\n    return [x[0] - y[0], x[1] - y[1]]\n\ndef will_reach(loc, commands):\n    new_loc = [0, 0]\n    possible_locs = [[0, 0]]\n    for c in commands:\n        if c == \"U\":\n            new_loc[1] += 1\n        elif c == \"D\":\n            new_loc[1] -= 1\n        elif c == \"R\":\n            new_loc[0] += 1\n        elif c == \"L\":\n            new_loc[0] -= 1\n        possible_locs += [list(new_loc)]\n\n        \n    all_destinations = [minus_two(loc, pl) for pl in possible_locs]\n\n\n    for destination in all_destinations :\n        realdx = destination[0]\n        realdy = destination[1]\n\n        reqdx = new_loc[0]\n        reqdy = new_loc[1]\n\n        if destination == [0, 0]:\n            return True\n\n        if reqdx != 0 and realdx != 0:\n            if ((realdy / realdx) == (reqdy / reqdx) \\\n            and (((realdy > 0 and reqdy > 0)) or((realdy < 0 and reqdy < 0)))     \\\n            and (realdy / reqdy) == int(realdy / reqdy)    \\\n            and (realdx / reqdx) == int(realdx / reqdx)): \n                return True\n        if  realdy == reqdy and realdx == reqdx:\n            return True\n        if reqdx == 0 and realdx == 0:\n            if ((reqdy > 0 and realdy > 0) or (reqdy < 0 and realdy < 0)) \\\n            and (realdy / reqdy) == int(realdy / reqdy):\n                return True\n        if reqdy == 0 and realdy == 0:\n\n            if ((reqdx > 0 and realdx > 0) or (reqdx < 0 and realdx < 0)) \\\n            and (realdx / reqdx) == int(realdx / reqdx):\n                return True\n    return False\n\n    \ndef will_reach2(loc, commands):\n    new_loc = [0, 0]\n    available_loc = []\n    for c in commands:\n        if c == \"U\":\n            new_loc[1] += 1\n        elif c == \"D\":\n            new_loc[1] -= 1\n        elif c == \"R\":\n            new_loc[0] += 1\n        elif c == \"L\":\n            new_loc[0] -= 1\n        available_loc += [new_loc]\n    \n\n    realdx = new_loc[0]\n    realdy = new_loc[1]\n\n    reqdx = loc[0]\n    reqdy = loc[1]\n\n    print(\"realdx\", realdx)\n    print(\"realdy\", realdy)\n    print(\"reqdx\", reqdx)\n    print(\"reqdy\", reqdy)\n    \n\n    if reqdx != 0 and realdx != 0:\n        return (realdy / realdx) == (reqdy / reqdx)\n    elif reqdx == 0 and realdx == 0:\n            return reqdy / realdy > 0\n    else:\n        return False    \n\n\ndef main():\n    first_line = input()\n    first_line = first_line.split()\n    \n    loc = [int(first_line[0]), int(first_line[1])]\n\n    cmds = input()\n   \n\n    if (will_reach(loc, cmds)):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n    \n        \n    \nmain()   \n", "generated_code": "def minus_two(a, b):\n    return [a[0] - b[0], a[1] - b[1]]\n\ndef will_reach(target, moves):\n    current_pos = [0, 0]\n    visited_positions = set()\n    visited_positions.add((0, 0))\n    for move in moves:\n        if move == \"U\":\n            current_pos[1] += 1\n        elif move == \"D\":\n            current_pos[1] -= 1\n        elif move == \"R\":\n            current_pos[0] += 1\n        elif move == \"L\":\n            current_pos[0] -= 1\n        visited_positions.add(tuple(current_pos))\n\n    target_deltas = [minus_two(target, list(pos)) for pos in visited_positions]\n\n    for delta in target_deltas:\n        dx, dy = delta\n        final_dx, final_dy = current_pos\n\n        if delta == [0, 0]:\n            return True\n\n        if final_dx != 0 and dx != 0:\n            if (dy / dx == final_dy / final_dx) and (((dy > 0 and final_dy > 0) or (dy < 0 and final_dy < 0))) and (dy % final_dy == 0) and (dx % final_dx == 0):\n                return True\n        if dy == final_dy and dx == final_dx:\n            return True\n        if final_dx == 0 and dx == 0:\n            if ((final_dy > 0 and dy > 0) or (final_dy < 0 and dy < 0)) and (dy % final_dy == 0):\n                return True\n        if final_dy == 0 and dy == 0:\n            if ((final_dx > 0 and dx > 0) or (final_dx < 0 and dx < 0)) and (dx % final_dx == 0):\n                return True\n    return False\n\n\ndef will_reach2(target, moves):\n    final_pos = [0, 0]\n    for move in moves:\n        if move == \"U\":\n            final_pos[1] += 1\n        elif move == \"D\":\n            final_pos[1] -= 1\n        elif move == \"R\":\n            final_pos[0] += 1\n        elif move == \"L\":\n            final_pos[0] -= 1\n\n    dx, dy = final_pos\n    target_dx, target_dy = target\n\n    if target_dx != 0 and dx != 0:\n        return (dy / dx) == (target_dy / target_dx)\n    elif target_dx == 0 and dx == 0:\n        return target_dy / dy > 0\n    else:\n        return False\n\n\ndef main():\n    first_input = input()\n    first_input = first_input.split()\n    target = [int(first_input[0]), int(first_input[1])]\n    commands = input()\n\n    if will_reach(target, commands):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nmain()", "score": 1.0, "codebleu": 0.37641851557751427, "crystalbleu": 0.29, "codebertscore": 0.85, "codescore": 0.8741543292999268, "surfaceSim": 0.8102080989876266, "abs_surfaceSim_minus_score": 0.18979190101237342, "source": "local", "local_type": "OP"}
{"id": "APPS_test-0342_14", "golden_code": "a, b, c = map(int, input().split())\nres = 2 * c\nx = min(a, b)\nres += 2 * x\nif a - x > 0: res += 1\nif b - x > 0: res += 1\nprint(res)", "generated_code": "import math\nfrom collections import deque\n#from functools import *\nfrom string import ascii_lowercase\nfrom collections import Counter\n#from funciools import lru_cache\nimport heapq\nfrom itertools import permutations,combinations\nimport sys\nfrom bisect import bisect_left,bisect_right\n\na,b,c=map(int,input().split())\nreturn max(min(a,b),max(a,c),min(b,c))\n\n# @lru_cache(maxsize=None)\n# def solve(s):\n#     chifers=0\n#     for i in range(len(s)):\n#         if s[i]=='a':\n#             chifers+=1\n#     return chifers == 1\n# print(solve(('a','b','ab')));:", "score": 0.0, "codebleu": 0.17269658038255578, "crystalbleu": 0, "codebertscore": 0.68, "codescore": 0.018345599994063377, "surfaceSim": 0.4676621019633724, "abs_surfaceSim_minus_score": 0.4676621019633724, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_MBPP_819_MUT_24", "golden_code": "import os\n\ndef count_duplic(lists):\n    element = []\n    frequency = []\n    if not lists:\n        return element\n    running_count = 1\n    for i in range(len(lists) - 1):\n        if lists[i] == lists[i + 1]:\n            running_count += 1\n        else:\n            frequency.append(running_count)\n            element.append(lists[i])\n            running_count = 1\n    frequency.append(running_count)\n    element.append(lists[i + 1])\n    return (element, frequency)", "generated_code": "import os\n\ndef count_duplic(lists):\n    element = []\n    frequency = []\n    if not lists:\n        return element\n    running_count = 1\n    for i in range(len(lists) - 1):\n        if lists[i] == lists[i + 1]:\n            running_count += 1\n        else:\n            frequency.append(running_count)\n            element.append(lists[i])\n            running_count = 1\n    frequency.append(running_count)\n    element.append(lists[i + 1])\n    pass", "score": 0.0, "codebleu": 0.9296937360823605, "crystalbleu": 0.92, "codebertscore": 0.99, "codescore": 0.9938661456108093, "surfaceSim": 0.9397270114942529, "abs_surfaceSim_minus_score": 0.9397270114942529, "source": "local", "local_type": "MUT"}
{"id": "MBPP_20_35", "golden_code": "def is_odd(n) : \r\n    if (n^1 == n-1) :\r\n        return True; \r\n    else :\r\n        return False; ", "generated_code": "def is_odd(n): return True if (n + 2 / 2) % 2 == 0 else False", "score": 1.0, "codebleu": 0.19524570803348124, "crystalbleu": 0, "codebertscore": 0.82, "codescore": 0.6802400350570679, "surfaceSim": 0.6320861678004536, "abs_surfaceSim_minus_score": 0.36791383219954643, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_extra_p03086_s916999030_OP_1", "golden_code": "import re\n\nptn = re.compile(r\"(A|C|G|T)*\")\n\n\n\nS = eval(input())\n\n\n\nans = 0\n\nfor i in range(len(S)):\n\n  for j in range(len(S)):\n\n    x = ptn.match(S[i:i+j+1]).group(0)\n\n    if(x):\n\n      ans = max(ans, len(x))\n\nprint(ans)", "generated_code": "import sys\n\n\n\nstdin = sys.stdin\n\n\n\nns = lambda : stdin.readline().rstrip()\n\nni = lambda : int(ns())\n\nna = lambda : list(map(int, stdin.readline().split()))\n\nsys.setrecursionlimit(10 ** 7)\n\n\n\ndef check(In):\n\n    return In != \"A\" and In != \"C\" and In != \"G\" and In != \"T\"\n\n\n\ndef main():\n\n    s = ns()\n\n\n\n    count = 0\n\n    ans = 0\n\n    for i in range(len(s)):\n\n        if check(s[i]):\n\n            count = 0\n\n        else:\n\n            count += 1\n\n            ans = max(ans, count)\n\n    print(ans)\n\n\n\nif __name__ == '__main__':\n\n    main()", "score": 1.0, "codebleu": 0.27935133297540404, "crystalbleu": 0.11, "codebertscore": 0.73, "codescore": 0.018273720517754555, "surfaceSim": 0.5050279329608939, "abs_surfaceSim_minus_score": 0.4949720670391061, "source": "local", "local_type": "OP"}
{"id": "LOCAL_MBPP_408_OP_2", "golden_code": "import heapq\r\ndef k_smallest_pairs(nums1, nums2, k):\r\n   queue = []\r\n   def push(i, j):\r\n       if i < len(nums1) and j < len(nums2):\r\n           heapq.heappush(queue, [nums1[i] + nums2[j], i, j])\r\n   push(0, 0)\r\n   pairs = []\r\n   while queue and len(pairs) < k:\r\n       _, i, j = heapq.heappop(queue)\r\n       pairs.append([nums1[i], nums2[j]])\r\n       push(i, j + 1)\r\n       if j == 0:\r\n           push(i + 1, 0)\r\n   return pairs", "generated_code": "import heapq\n\ndef k_smallest_pairs(arr1, arr2, p):\n    heap = []\n    def add_to_heap(x, y):\n        if x < len(arr1) and y < len(arr2):\n            heapq.heappush(heap, (arr1[x] + arr2[y], x, y))\n    add_to_heap(0, 0)\n    result = []\n    visited = set()\n    while heap and len(result) < p:\n        _, x, y = heapq.heappop(heap)\n        result.append([arr1[x], arr2[y]])\n        if (x, y + 1) not in visited:\n            add_to_heap(x, y + 1)\n            visited.add((x, y + 1))\n        if y == 0 and (x + 1, 0) not in visited:\n            add_to_heap(x + 1, 0)\n            visited.add((x + 1, 0))\n    return result\n", "score": 1.0, "codebleu": 0.44415500423731913, "crystalbleu": 0.19, "codebertscore": 0.83, "codescore": 0.9939479827880859, "surfaceSim": 0.795766750770956, "abs_surfaceSim_minus_score": 0.20423324922904396, "source": "local", "local_type": "OP"}
{"id": "MBPP_120_2", "golden_code": "def even_or_odd(N): \r\n    l = len(N) \r\n    if (N[l-1] =='0'or N[l-1] =='2'or \r\n        N[l-1] =='4'or N[l-1] =='6'or \r\n        N[l-1] =='8'or N[l-1] =='A'or \r\n        N[l-1] =='C'or N[l-1] =='E'): \r\n        return (\"Even\") \r\n    else: \r\n        return (\"Odd\") ", "generated_code": "def even_or_odd(N): \n\treturn 'even' if (N % 2 == 0) else 'odd'\nss = []\nfor i in range(len(ss)):\n\tif ss[i] not in '0123456789':\n\t\tss[i] = '0123456789'\n\telse:\n\t\tss = ss.replace(ss[i], '')", "score": 0.0, "codebleu": 0.13776668704781425, "crystalbleu": 0.06, "codebertscore": 0.7, "codescore": 0.045606303960084915, "surfaceSim": 0.5692307692307692, "abs_surfaceSim_minus_score": 0.5692307692307692, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_9_14", "golden_code": "def check_Concat(str1,str2):\r\n    N = len(str1)\r\n    M = len(str2)\r\n    if (N % M != 0):\r\n        return False\r\n    for i in range(N):\r\n        if (str1[i] != str2[i % M]):\r\n            return False         \r\n    return True", "generated_code": "def check_Concat(s, h):\n\tcs = s + h\n\treturn cs in s and s!= h\nss = 777\nsubstr = 'agaragaragARagar'\nbiggy ='everycharindex'", "score": 0.9062, "codebleu": 0.1262289412412717, "crystalbleu": 0, "codebertscore": 0.68, "codescore": 0.9584344029426575, "surfaceSim": 0.5593944099378882, "abs_surfaceSim_minus_score": 0.34680559006211176, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_17_6", "golden_code": "def all_Bits_Set_In_The_Given_Range(n,l,r): \r\n    num = ((1 << r) - 1) ^ ((1 << (l - 1)) - 1) \r\n    new_num = n & num \r\n    if (num == new_num): \r\n        return True\r\n    return False", "generated_code": "def all_Bits_Set_In_The_Given_Range(n,l,r): \n\treturn n & (n-1) == 0 and (r&n)!= 0\nns = [0,1]\ns = [1, 0]\nt = [0]\np = [0,-1]\nfor d in ns:\n\tfor i in range(2**d):\n\t\tt.append(t[-1] ^ (i&1))\n\tp.append(sum(t))\nfrom math import log", "score": 0.48, "codebleu": 0.1987206610366779, "crystalbleu": 0, "codebertscore": 0.78, "codescore": 0.6183971166610718, "surfaceSim": 0.47112379399374915, "abs_surfaceSim_minus_score": 0.00887620600625083, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_13_1_OP_2", "golden_code": "import sys\n\ndef main():\n\n    n,k = map(int,sys.stdin.readline().split())\n    courses = list(map(int,sys.stdin.readline().split()))\n    courses = [x-1 for x in courses] \n\n    visited = [False]*n\n    used = [False]*n\n\n    ans = []\n    t = []\n\n    for i in range(n):\n        temp = list(map(int,sys.stdin.readline().split()))\n        temp = [x-1 for x in temp] \n        t.append(temp[1:])\n        \n    for i in range(k):\n        c = courses[i]\n        if used[c]:\n            continue\n        \n        q = [c]        \n        visited[c]=True\n        while len(q)>0:\n            cur = q[-1]\n            if len(t[cur])!=0:\n                s = t[cur].pop()\n                if visited[s] and not used[s]:                    \n                    print(-1)\n                    return\n                if used[s]:\n                    continue                \n                q.append(s)\n                visited[s]=True\n            else:\n                ans.append(cur)\n                q.pop()\n                used[cur] = True\n\n    ans = [str(x+1) for x in ans] \n    print(len(ans))\n    print(\" \".join(ans))\n\nmain()", "generated_code": "import sys\nfrom collections import deque\n\ndef main():\n\n    num_courses, num_to_take = map(int, sys.stdin.readline().split())\n    course_list = list(map(int, sys.stdin.readline().split()))\n    course_list = [c - 1 for c in course_list]\n\n    visited_courses = [False] * num_courses\n    completed_courses = [False] * num_courses\n\n    result = []\n    prerequisites = []\n\n    for _ in range(num_courses):\n        temp = list(map(int, sys.stdin.readline().split()))\n        prerequisites.append(deque(x - 1 for x in temp[1:]))\n\n    for i in range(num_to_take):\n        current_course = course_list[i]\n        if completed_courses[current_course]:\n            continue\n\n        stack = [current_course]\n        visited_courses[current_course] = True\n        while stack:\n            current = stack[-1]\n            if prerequisites[current]:\n                prerequisite_course = prerequisites[current].pop()\n                if visited_courses[prerequisite_course] and not completed_courses[prerequisite_course]:\n                    print(-1)\n                    return\n                if completed_courses[prerequisite_course]:\n                    continue\n                stack.append(prerequisite_course)\n                visited_courses[prerequisite_course] = True\n            else:\n                result.append(current)\n                stack.pop()\n                completed_courses[current] = True\n\n    result = [str(x + 1) for x in result]\n    print(len(result))\n    print(\" \".join(result))\n\nmain()\n", "score": 1.0, "codebleu": 0.37313390068062485, "crystalbleu": 0.41, "codebertscore": 0.85, "codescore": 0.6813881993293762, "surfaceSim": 0.7636677963780767, "abs_surfaceSim_minus_score": 0.2363322036219233, "source": "local", "local_type": "OP"}
{"id": "LOCAL_HE_98_MUT_2", "golden_code": "import os\n\ndef count_upper(s):\n    count = 0\n    for i in range(0, len(s), 2):\n        if s[i] in 'AEIOU':\n            count += 1\n    return count", "generated_code": "import os\n\ndef count_upper(s):\n    count = 0\n    for i in range(0, len(s), 2):\n        if not (s[i] in 'AEIOU'):\n            count += 1\n    return count", "score": 0.2884, "codebleu": 0.8173255973855642, "crystalbleu": 0, "codebertscore": 0.99, "codescore": 0.9936249256134033, "surfaceSim": 0.9400743707093822, "abs_surfaceSim_minus_score": 0.6516743707093822, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_APPS_4397_19_OP_1", "golden_code": "a,b = list(map(int,input().split()))\nprint((a-b+1))\n\n", "generated_code": "x, y = map(int, input().split())\nresult = x - y + 1\nprint(result)", "score": 1.0, "codebleu": 0.3211257875995676, "crystalbleu": 0, "codebertscore": 0.88, "codescore": 0.46654707193374634, "surfaceSim": 0.7923076923076923, "abs_surfaceSim_minus_score": 0.20769230769230773, "source": "local", "local_type": "OP"}
{"id": "LOCAL_MBPP_950_OP_1", "golden_code": "def chinese_zodiac(year):\r\n if (year - 2000) % 12 == 0:\r\n     sign = 'Dragon'\r\n elif (year - 2000) % 12 == 1:\r\n     sign = 'Snake'\r\n elif (year - 2000) % 12 == 2:\r\n     sign = 'Horse'\r\n elif (year - 2000) % 12 == 3:\r\n     sign = 'sheep'\r\n elif (year - 2000) % 12 == 4:\r\n     sign = 'Monkey'\r\n elif (year - 2000) % 12 == 5:\r\n     sign = 'Rooster'\r\n elif (year - 2000) % 12 == 6:\r\n     sign = 'Dog'\r\n elif (year - 2000) % 12 == 7:\r\n     sign = 'Pig'\r\n elif (year - 2000) % 12 == 8:\r\n     sign = 'Rat'\r\n elif (year - 2000) % 12 == 9:\r\n     sign = 'Ox'\r\n elif (year - 2000) % 12 == 10:\r\n     sign = 'Tiger'\r\n else:\r\n     sign = 'Hare'\r\n return sign", "generated_code": "def chinese_zodiac(yr):\n    signs = ['Dragon', 'Snake', 'Horse', 'Sheep', 'Monkey', 'Rooster', 'Dog', 'Pig', 'Rat', 'Ox', 'Tiger', 'Hare']\n    idx = (yr - 2000) % 12\n    return signs[idx]", "score": 0.9364, "codebleu": 0.19941947665440374, "crystalbleu": 0.02, "codebertscore": 0.75, "codescore": 0.9936309456825256, "surfaceSim": 0.5835648904870874, "abs_surfaceSim_minus_score": 0.35283510951291264, "source": "local", "local_type": "OP"}
{"id": "MBPP_43_120", "golden_code": "def is_Two_Alter(s):  \r\n    for i in range (len( s) - 2) : \r\n        if (s[i] != s[i + 2]) : \r\n            return False\r\n    if (s[0] == s[1]): \r\n        return False\r\n    return True", "generated_code": "def is_Two_Alter(s):\n\treturn s == '1' or s == '0'", "score": 0.8287, "codebleu": 0.07834132646018813, "crystalbleu": 0, "codebertscore": 0.77, "codescore": 0.9670125842094421, "surfaceSim": 0.5114257327372081, "abs_surfaceSim_minus_score": 0.31727426726279184, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_MBPP_453_MUT_50", "golden_code": "import os\n\nimport math\ndef sumofFactors(n):\n    if n % 2 != 0:\n        return 0\n    res = 1\n    for i in range(2, int(math.sqrt(n)) + 1):\n        count = 0\n        curr_sum = 1\n        curr_term = 1\n        while n % i == 0:\n            count = count + 1\n            n = n // i\n            if (i == 2 and count == 1):\n                curr_sum = 0\n            curr_term = curr_term * i\n            curr_sum = curr_sum + curr_term\n        res = res * curr_sum\n    if n >= 2:\n        res = res * (1 + n)\n    return res", "generated_code": "import os\n\nimport math\ndef sumofFactors(n):\n    if n % 2 != 0:\n        return 0\n    res = 1\n    for i in range(2, int(math.sqrt(n)) + 1):\n        count = 0\n        curr_sum = 1\n        curr_term = 1\n        while n % i == 0:\n            break\n        \n        \n        \n        \n        \n        res = res * curr_sum\n    if n >= 2:\n        res = res * (1 + n)\n    return res", "score": 0.3625, "codebleu": 0.6666377813453148, "crystalbleu": 0.62, "codebertscore": 0.94, "codescore": 0.8430048227310181, "surfaceSim": 0.8339471041178439, "abs_surfaceSim_minus_score": 0.4714471041178439, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_APPS_4620_17_MUT_13", "golden_code": "n = int(input())\ngraph = []\ntime = 0\nfor i in range(n - 1):\n    (c, s, f) = map(int, input().split())\n    graph.append([i, c, s, f])\n\ndef shortest_path(start, end, times):\n    if start == end:\n        return times\n    elif times <= graph[start][2]:\n        times = graph[start][2] + graph[start][1]\n        return shortest_path(start + 1, end, times)\n    elif times % graph[start][3] == 0:\n        times += graph[start][1]\n        return shortest_path(start + 1, end, times)\n    else:\n        times = ((times + graph[start][3]) - (times % graph[start][3])) + graph[start][1]\n        return shortest_path(start + 1, end, times)\n\n\nfor i in range(n):\n    print(shortest_path(i, n - 1, 0))", "generated_code": "n = int(input())\ngraph = []\ntime = 0\nfor i in range(n - 1):\n    (c, s, f) = map(int, input().split())\n    graph.append([i, c, s, f])\n\ndef shortest_path(start, end, times):\n    if not (start == end):\n        return times\n    elif times <= graph[start][2]:\n        times = graph[start][2] + graph[start][1]\n        return shortest_path(start + 1, end, times)\n    elif times % graph[start][3] == 0:\n        times += graph[start][1]\n        return shortest_path(start + 1, end, times)\n    else:\n        times = ((times + graph[start][3]) - (times % graph[start][3])) + graph[start][1]\n        return shortest_path(start + 1, end, times)\n\n\nfor i in range(n):\n    print(shortest_path(i, n - 1, 0))", "score": 0.0, "codebleu": 0.9641914414301735, "crystalbleu": 0.97, "codebertscore": 1.0, "codescore": 0.993646502494812, "surfaceSim": 0.9618992963720745, "abs_surfaceSim_minus_score": 0.9618992963720745, "source": "local", "local_type": "MUT"}
{"id": "MBPP_20_27", "golden_code": "def is_odd(n) : \r\n    if (n^1 == n-1) :\r\n        return True; \r\n    else :\r\n        return False; ", "generated_code": "def is_odd(n):\n\ts = n % 2\n\tcondition = lambda x: x == 0 and s\n\treturn condition(s)", "score": 0.5495, "codebleu": 0.2290016737975167, "crystalbleu": 0, "codebertscore": 0.78, "codescore": 0.564940869808197, "surfaceSim": 0.5425170068027212, "abs_surfaceSim_minus_score": 0.006982993197278797, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_p02599_s870922238_MUT_5", "golden_code": "import sys\nclass BinaryIndexedTree:\n    def __init__(self, A):\n        self.__n = len(A)\n        self.__node = [0] * (self.__n + 1)\n        self.__data = [0] * (self.__n + 1)\n        S = [0] * (self.__n + 1)\n        for i in range(1, self.__n + 1):\n            S[i] = S[i - 1] + A[i - 1]\n            self.__data[i] = A[i - 1]\n            self.__node[i] = S[i] - S[i - (i & (-i))]\n    def add(self, i, v):\n        self.__data[i] += v\n        while i <= self.__n:\n            self.__node[i] += v\n            i += i & (-i)\n    def sum(self, i):\n        rst = 0\n        while i > 0:\n            rst += self.__node[i]\n            i -= i & (-i)\n        return rst\n    def get(self, i, j):\n        if i == j:\n            return self.__data[i]\n        else:\n            return self.sum(j) - self.sum(i - 1)\ndef main():\n    (N, Q) = map(int, input().split())\n    C = list(map(int, input().split()))\n    P = [[] for _ in range(N)]\n    for (i, c) in enumerate(C):\n        P[c - 1].append(i)\n    right = [0] * N\n    for p in P:\n        if len(p):\n            right[p.pop()] = 1\n    BIT = BinaryIndexedTree(right)\n    query = [[] for _ in range(N)]\n    for (i, s) in enumerate(sys.stdin.readlines()):\n        (l, r) = map(int, s.split())\n        query[r - 1].append((l - 1, i))\n    ans = [None] * Q\n    cur = N - 1\n    for (r, q) in enumerate(reversed(query)):\n        r = (N - 1) - r\n        while q:\n            (l, i) = q.pop()\n            while r < cur:\n                c = C[cur] - 1\n                p = P[c]\n                if len(p):\n                    BIT.add(p.pop() + 1, 1)\n                cur -= 1\n            tmp = BIT.get(l + 1, r + 1)\n            ans[i] = tmp\n    print(sep='\\n', *ans)", "generated_code": "import sys\nclass BinaryIndexedTree:\n    def __init__(self, A):\n        self.__n = len(A)\n        self.__node = [0] // (self.__n + 1)\n        self.__data = [0] * (self.__n + 1)\n        S = [0] * (self.__n + 1)\n        for i in range(1, self.__n + 1):\n            S[i] = S[i - 1] + A[i - 1]\n            self.__data[i] = A[i - 1]\n            self.__node[i] = S[i] - S[i - (i & (-i))]\n    def add(self, i, v):\n        self.__data[i] += v\n        while i <= self.__n:\n            self.__node[i] += v\n            i += i & (-i)\n    def sum(self, i):\n        rst = 0\n        while i > 0:\n            rst += self.__node[i]\n            i -= i & (-i)\n        return rst\n    def get(self, i, j):\n        if i == j:\n            return self.__data[i]\n        else:\n            return self.sum(j) - self.sum(i - 1)\ndef main():\n    (N, Q) = map(int, input().split())\n    C = list(map(int, input().split()))\n    P = [[] for _ in range(N)]\n    for (i, c) in enumerate(C):\n        P[c - 1].append(i)\n    right = [0] * N\n    for p in P:\n        if len(p):\n            right[p.pop()] = 1\n    BIT = BinaryIndexedTree(right)\n    query = [[] for _ in range(N)]\n    for (i, s) in enumerate(sys.stdin.readlines()):\n        (l, r) = map(int, s.split())\n        query[r - 1].append((l - 1, i))\n    ans = [None] * Q\n    cur = N - 1\n    for (r, q) in enumerate(reversed(query)):\n        r = (N - 1) - r\n        while q:\n            (l, i) = q.pop()\n            while r < cur:\n                c = C[cur] - 1\n                p = P[c]\n                if len(p):\n                    BIT.add(p.pop() + 1, 1)\n                cur -= 1\n            tmp = BIT.get(l + 1, r + 1)\n            ans[i] = tmp\n    print(sep='\\n', *ans)", "score": 0.0438, "codebleu": 0.994935590512094, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9936529397964478, "surfaceSim": 0.9872124609871691, "abs_surfaceSim_minus_score": 0.9434124609871691, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_PIE_extra_p00542_s237799080_OP_1", "golden_code": "a,b,c,d,e,f=[int(eval(input())) for _ in range(6)]\n\nprint((sum([a,b,c,d,max(e,f)])-min([a,b,c,d])))", "generated_code": "print((sum(sorted(int(eval(input())) for _ in range(4))[1:])+max([int(eval(input())) for _ in range(2)])))", "score": 1.0, "codebleu": 0.2242737827628642, "crystalbleu": 0.24, "codebertscore": 0.82, "codescore": 0.018546365201473236, "surfaceSim": 0.49947589098532497, "abs_surfaceSim_minus_score": 0.500524109014675, "source": "local", "local_type": "OP"}
{"id": "MBPP_40_16", "golden_code": "import datetime\r\ndef check_date(m, d, y):\r\n    try:\r\n        m, d, y = map(int, (m, d, y))\r\n        datetime.date(y, m, d)\r\n        return True\r\n    except ValueError:\r\n        return False", "generated_code": "import datetime\ndef check_date(m, d, y):\n\tif m and d and y > y:\n\t\treturn True\n\treturn False", "score": 0.8112, "codebleu": 0.293707658071624, "crystalbleu": 0, "codebertscore": 0.84, "codescore": 0.5839616656303406, "surfaceSim": 0.5639521509086727, "abs_surfaceSim_minus_score": 0.24724784909132735, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_MBPP_428_MUT_15", "golden_code": "import os\n\ndef shell_sort(my_list):\n    gap = len(my_list) // 2\n    while gap > 0:\n        for i in range(gap, len(my_list)):\n            current_item = my_list[i]\n            j = i\n            while (j >= gap and my_list[j - gap] > current_item):\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            my_list[j] = current_item\n        gap //= 2\n    \n    return my_list", "generated_code": "import os\n\ndef shell_sort(my_list):\n    gap = len(my_list) // 2\n    while gap > 0:\n        for i in range(gap, len(my_list)):\n            current_item = my_list[i]\n            j = i\n            while (j >= gap and my_list[j - gap] > current_item):\n                my_list[j] = my_list[j - gap]\n                j -= gap\n                break\n            my_list[j] = current_item\n        gap //= 2\n    return my_list", "score": 0.0, "codebleu": 0.9303100540499519, "crystalbleu": 0.94, "codebertscore": 0.99, "codescore": 0.9938241243362427, "surfaceSim": 0.9742525658188308, "abs_surfaceSim_minus_score": 0.9742525658188308, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_APPS_4169_75_MUT_36", "golden_code": "import bisect, collections, copy, heapq, itertools, math, string, sys\ninput = lambda: (sys.stdin.readline().rstrip())\nsys.setrecursionlimit(10 ** 7)\nINF = float('inf')\ndef I():\n    return int(input())\ndef F():\n    return float(input())\ndef SS():\n    return input()\ndef LI():\n    return [int(x) for x in input().split()]\ndef LI_():\n    return [int(x) - 1 for x in input().split()]\ndef LF():\n    return [float(x) for x in input().split()]\ndef LSS():\n    return input().split()\ndef resolve():\n    (N, M) = LI()\n    AB = [LI() for _ in range(N)]\n    AB.sort()\n    ans = 0\n    for (a, b) in AB:\n        if M >= b:\n            M -= b\n            ans += a * belse:ans += a * Mbreak\n    print(ans)\ndef __starting_point():\n    resolve()\n\n__starting_point()", "generated_code": "import bisect, collections, copy, heapq, itertools, math, string, sys\ninput = lambda: (sys.stdin.readline().rstrip())\nsys.setrecursionlimit(10 ** 7)\nINF = float('inf')\ndef I():\n    return int(input())\ndef F():\n    return float(input())\ndef SS():\n    return input()\ndef LI():\n    return [int(x) for x in input().split()]\ndef LI_():\n    return [int(x) - 1 for x in input().split()]\ndef LF():\n    return [float(x) for x in input().split()]\ndef LSS():\n    return input().split()\ndef resolve():\n    (N, M) = LI()\n    AB = [LI() for _ in range(N)]\n    AB.sort()\n    ans = 0\n    for (a, b) in AB:\n        if M >= b:\n            M -= b\n            ans += a * belse:ans += a * Mbreak\n    pass\ndef __starting_point():\n    resolve()\n\n__starting_point()", "score": 0.0, "codebleu": 0.9771848987066507, "crystalbleu": 0.97, "codebertscore": 1.0, "codescore": 0.9938861727714539, "surfaceSim": 0.49531459170013387, "abs_surfaceSim_minus_score": 0.49531459170013387, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_MBPP_453_OP_1", "golden_code": "import math \r\ndef sumofFactors(n) : \r\n    if (n % 2 != 0) : \r\n        return 0\r\n    res = 1\r\n    for i in range(2, (int)(math.sqrt(n)) + 1) :    \r\n        count = 0\r\n        curr_sum = 1\r\n        curr_term = 1\r\n        while (n % i == 0) : \r\n            count= count + 1\r\n            n = n // i \r\n            if (i == 2 and count == 1) : \r\n                curr_sum = 0\r\n            curr_term = curr_term * i \r\n            curr_sum = curr_sum + curr_term \r\n        res = res * curr_sum  \r\n    if (n >= 2) : \r\n        res = res * (1 + n) \r\n    return res ", "generated_code": "import math\ndef sumofFactors(num):\n    if num % 2 != 0:\n        return 0\n    result = 1\n    limit = int(math.sqrt(num)) + 1\n    for factor in range(2, limit):\n        factor_count = 0\n        factor_sum = 1\n        factor_term = 1\n        while num % factor == 0:\n            factor_count += 1\n            num //= factor\n            if factor == 2 and factor_count == 1:\n                factor_sum = 0\n            factor_term *= factor\n            factor_sum += factor_term\n        result *= factor_sum\n    if num >= 2:\n        result *= (1 + num)\n    return result", "score": 1.0, "codebleu": 0.27880496813246247, "crystalbleu": 0.2, "codebertscore": 0.84, "codescore": 0.9939330220222473, "surfaceSim": 0.8385108330790357, "abs_surfaceSim_minus_score": 0.16148916692096427, "source": "local", "local_type": "OP"}
{"id": "LOCAL_PIE_extra_p02576_s578033438_OP_1", "golden_code": "array = list(map(int, input().split()))\n\nif array[0] % array[1] > 0:\n\n    print(((array[0] // array[1] + 1) * array[2]))\n\nelse:\n\n    print(((array[0] // array[1]) * array[2]))", "generated_code": "n, x, t = list(map(int, input().split()))\n\n\n\nprint((0--n//x*t))", "score": 1.0, "codebleu": 0.19387968865310362, "crystalbleu": 0, "codebertscore": 0.77, "codescore": 0.4577378034591675, "surfaceSim": 0.47801242236024843, "abs_surfaceSim_minus_score": 0.5219875776397516, "source": "local", "local_type": "OP"}
{"id": "MBPP_286_1", "golden_code": "def cube_Sum(n): \r\n    sum = 0   \r\n    for i in range(0,n) : \r\n        sum += (2*i+1)*(2*i+1)*(2*i+1) \r\n    return sum", "generated_code": "def cube_Sum(n):\n\treturn (n * (n - 1) * (n * -1)) // 4", "score": 0.0, "codebleu": 0.05490103200376524, "crystalbleu": 0, "codebertscore": 0.79, "codescore": 0.07790566980838776, "surfaceSim": 0.5466101694915254, "abs_surfaceSim_minus_score": 0.5466101694915254, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_MBPP_711_OP_1", "golden_code": "def product_Equal(n): \r\n    if n < 10: \r\n        return False\r\n    prodOdd = 1; prodEven = 1\r\n    while n > 0: \r\n        digit = n % 10\r\n        prodOdd *= digit \r\n        n = n//10\r\n        if n == 0: \r\n            break; \r\n        digit = n % 10\r\n        prodEven *= digit \r\n        n = n//10\r\n    if prodOdd == prodEven: \r\n        return True\r\n    return False", "generated_code": "def product_Equal(x):\n    if x < 10:\n        return False\n    odd_product, even_product = 1, 1\n    is_odd = True\n    while x > 0:\n        digit = x % 10\n        if is_odd:\n            odd_product *= digit\n        else:\n            even_product *= digit\n        is_odd = not is_odd\n        x //= 10\n    return odd_product == even_product", "score": 1.0, "codebleu": 0.34646490040142464, "crystalbleu": 0, "codebertscore": 0.81, "codescore": 0.9939218759536743, "surfaceSim": 0.7423140495867768, "abs_surfaceSim_minus_score": 0.2576859504132232, "source": "local", "local_type": "OP"}
{"id": "APPS_test-1169_2", "golden_code": "n, m = map(int, input().split())\nl = 0\nr = n\nfor i in range(50):\n    md = (l + r) // 2\n    if md * (md - 1) // 2 < m:\n        l = md\n    else:\n        r = md\n   # print(l, r, md)\nprint(max(0, n - m * 2), n - r)", "generated_code": "from collections import defaultdict\nimport sys\ninput = sys.stdin.readline\n\ndef get_d(): return list(map(int, input().split()))\ndef get_string(): return input().rstrip()\ndef get_ints(): return map(int, input_.split())\ndef get_3_ints(): return list(zip(*get_ints()))\n\ndef main():\n\tn, m = get_ints()\n\tgraph = defaultdict(set)\n\tfor i in range(n):\n\t\tgraph[i].add(i)\n\tend = set([i for i in range(1, n + 1)])\n\tvisited = set([1])\n\tqueue = [(1, 0)]\n\twhile queue:\n\t\tstart, dist = queue.pop(0)\n\t\tfor x in graph[start]:\n\t\t\tif x in visited:\n\t\t\t\tcontinue\n\t\t\t", "score": 0.0, "codebleu": 0.18489750516867512, "crystalbleu": 0.07, "codebertscore": 0.71, "codescore": 0.018353326246142387, "surfaceSim": 0.3584558823529412, "abs_surfaceSim_minus_score": 0.3584558823529412, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-1943_2", "golden_code": "n = int(input())\nm = 1 << n\np = [list(map(int, input().split())) for i in range(m)]\nu, x = [1] * m, [0] * m\nv, y = u[:], x[:]\nfor i in range(n):\n    d = 1 << i\n    for j in range(m):\n        s = d * (j // d ^ 1)\n        v[j] = u[j] * sum(u[k] * p[j][k] for k in range(s, s + d)) / 100\n        y[j] = max(x[s: s + d]) + x[j] + v[j] * d\n    u, v, x, y = v, u, y, x\nprint(max(x))", "generated_code": "n = int(input())\nres = 0\nfor _ in range(n):\n\tt = list(map(int, input().split()))\n\ts = sum(t)\n\tres += 1/(2**(n-1)) * s\nprint(res)\n", "score": 0.3288, "codebleu": 0.10426910396672856, "crystalbleu": 0.05, "codebertscore": 0.76, "codescore": 0.19166043400764465, "surfaceSim": 0.48404255319148937, "abs_surfaceSim_minus_score": 0.15524255319148939, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_1124_57_OP_1", "golden_code": "def GCD(a,b):\n    if (b == 0):\n        return a;\n    else:\n        return GCD(b, a % b);\n\nn = int(input())\na = list(map(int,input().split()))\ncnt = 0\nfor i in range(n):\n    cnt = GCD(cnt,a[i])\nprint(cnt)", "generated_code": "from functools import reduce\ndef GCD(x, y):\n    while y != 0:\n        x, y = y, x % y\n    return x\n\nnum_elements = int(input())\nelements = list(map(int, input().split()))\nresult = reduce(GCD, elements)\nprint(result)", "score": 1.0, "codebleu": 0.29686566347995913, "crystalbleu": 0, "codebertscore": 0.81, "codescore": 0.6451060175895691, "surfaceSim": 0.5565295169946333, "abs_surfaceSim_minus_score": 0.44347048300536673, "source": "local", "local_type": "OP"}
{"id": "MBPP_68_29", "golden_code": "def subset(ar, n): \r\n    res = 0\r\n    ar.sort() \r\n    for i in range(0, n) : \r\n        count = 1\r\n        for i in range(n - 1): \r\n            if ar[i] == ar[i + 1]: \r\n                count+=1\r\n            else: \r\n                break \r\n        res = max(res, count)  \r\n    return res ", "generated_code": "def subset(ar, k):\n\treturn k and sum(x for x in ar[:k])", "score": 0.0, "codebleu": 0.06009411072071557, "crystalbleu": 0, "codebertscore": 0.7, "codescore": 0.05880606546998024, "surfaceSim": 0.48185435254400777, "abs_surfaceSim_minus_score": 0.48185435254400777, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_571_1", "golden_code": "def frequency_Of_Largest(n,arr): \r\n    mn = arr[0] \r\n    freq = 1\r\n    for i in range(1,n): \r\n        if (arr[i] >mn): \r\n            mn = arr[i] \r\n            freq = 1\r\n        elif (arr[i] == mn): \r\n            freq += 1\r\n    return freq ", "generated_code": "def frequency_Of_Largest(n,arr): \n\treturn max([n for n in arr])", "score": 0.0094, "codebleu": 0.044375539827145025, "crystalbleu": 0, "codebertscore": 0.72, "codescore": 0.10243947803974152, "surfaceSim": 0.5225370863446177, "abs_surfaceSim_minus_score": 0.5131370863446177, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_MBPP_39_MUT_21", "golden_code": "import os\n\nimport heapq\nfrom collections import Counter\ndef rearange_string(S):\n    ctr = Counter(S)\n    heap = [(-value, key) for (key, value) in ctr.items()]\n    heapq.heapify(heap)\n    if (-(heap[0][0])) * 2 > len(S) + 1:\n        return ''\n    ans = []\n    while len(heap) >= 2:\n        (nct1, char1) = heapq.heappop(heap)\n        (nct2, char2) = heapq.heappop(heap)\n        ans.extend([char1, char2])\n        if nct1 + 1:\n            heapq.heappush(heap, (nct1 + 1, char1))\n        if nct2 + 1:\n            heapq.heappush(heap, (nct2 + 1, char2))\n    return ''.join(ans) + (heap[0][1] if heap else '')", "generated_code": "import os\n\nimport heapq\nfrom collections import Counter\ndef rearange_string(S):\n    ctr = Counter(S)\n    heap = [(-value, key) for (key, value) in ctr.items()]\n    heapq.heapify(heap)\n    if (-(heap[0][0])) * 2 < len(S) + 1:\n        return ''\n    ans = []\n    while len(heap) >= 2:\n        (nct1, char1) = heapq.heappop(heap)\n        (nct2, char2) = heapq.heappop(heap)\n        ans.extend([char1, char2])\n        if nct1 + 1:\n            heapq.heappush(heap, (nct1 + 1, char1))\n        if nct2 + 1:\n            heapq.heappush(heap, (nct2 + 1, char2))\n    return ''.join(ans) + (heap[0][1] if heap else '')", "score": 0.2708, "codebleu": 0.9833971121134268, "crystalbleu": 0.97, "codebertscore": 1.0, "codescore": 0.9938212633132935, "surfaceSim": 0.9697617890131259, "abs_surfaceSim_minus_score": 0.6989617890131259, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-3786_11", "golden_code": "inflos = int(input())\nroots = [int(x) - 1 for x in input().split()]\n \n\ndepth = [0]\nfor v in range(inflos - 1):\n    depth.append(depth[roots[v]] + 1)\n\nfreq = {}\n\nfor d in depth:\n    if d in freq:\n        freq[d] += 1\n    else:\n        freq[d] = 1\nres = 0\nfor d in freq:\n    res+= freq[d]%2\nprint(res)\n", "generated_code": "n=int(input())\na=list(map(int,input().split()))\na.sort()\nx=float('inf')\nc=0\nfor i in range(n):\n\tx=min(x,a[i])\n\tc+=1\nprint(c)\n", "score": 0.1712, "codebleu": 0.19336163982806143, "crystalbleu": 0, "codebertscore": 0.76, "codescore": 0.09663639962673187, "surfaceSim": 0.53, "abs_surfaceSim_minus_score": 0.3588, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_21_MUT_11", "golden_code": "import os\n\nfrom typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) / (max_number - min_number) for x in numbers]", "generated_code": "import os\n\nfrom typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    min_number = min(numbers)\n    max_number = max(numbers)\n    pass", "score": 0.0, "codebleu": 0.6034287273519608, "crystalbleu": 0, "codebertscore": 0.94, "codescore": 0.01840207912027836, "surfaceSim": 0.7088791848617175, "abs_surfaceSim_minus_score": 0.7088791848617175, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_PIE_extra_p03037_s661845965_OP_1", "golden_code": "n, m = list(map(int, input().split()))\n\ngate = []\n\nl, r = list(map(int, input().split()))\n\nfor i in range(1, m):\n\n    m, s = list(map(int, input().split()))\n\n    if l < m:\n\n        l = m\n\n    if s < r:\n\n        r = s\n\nprint((len([i for i in range(l, r + 1)])))", "generated_code": "n, m = list(map(int, input().split()))\n\nl, r = [0] * m, [0] * m\n\nfor i in range(m):\n\n    l[i], r[i] = list(map(int, input().split()))\n\nprint((max(min(r) - max(l) + 1, 0)))", "score": 1.0, "codebleu": 0.32729944169101877, "crystalbleu": 0.24, "codebertscore": 0.88, "codescore": 0.08606406301259995, "surfaceSim": 0.6408862876254181, "abs_surfaceSim_minus_score": 0.3591137123745819, "source": "local", "local_type": "OP"}
{"id": "LOCAL_PIE_extra_p02792_s119665759_OP_1", "golden_code": "import sys\n\ninput = sys.stdin.readline\n\nN = int(eval(input()))\n\nketa = len(str(N))\n\nif keta == 1:\n\n    print(N)\n\n    sys.exit()\n\nans = {}\n\nfor i in [1,2,3,4,5,6,7,8,9]:\n\n    for j in [1,2,3,4,5,6,7,8,9]:\n\n        ans[(i, j)] = 0\n\nfor i in range(1, N+1):\n\n    maxdigit = int(str(i)[0])\n\n    mindigit = int(str(i)[-1])\n\n    if mindigit != 0:\n\n        ans[(maxdigit, mindigit)] += 1\n\ncnt = 0\n\nfor i in range(1, 10):\n\n    for j in range(1, 10):\n\n        if i == j:\n\n            cnt += ans[(i, i)] ** 2\n\n        else:\n\n            cnt += ans[(i, j)] * ans[(j, i)] * 2\n\n            ans[(i, j)] = 0\n\n            ans[(j, i)] = 0\n\nprint(cnt)\n\n\n\n        \n\n\n\n    ", "generated_code": "import sys\n\ninput = sys.stdin.readline\n\n\n\nn = int(eval(input()))\n\n\n\nfrom collections import defaultdict\n\n\n\nd = defaultdict(int) # d[(a, b)] : 先頭a, 末尾b\n\n\n\nfor i in range(1, n + 1):\n\n    i_str = str(i)\n\n    d[(i_str[0], i_str[-1])] += 1\n\n\n\nans = 0\n\n\n\nfor i in range(1, 10):\n\n    for j in range(10):\n\n        ans += d[(str(i), str(j))] * d[(str(j), str(i))]\n\n\n\nprint(ans)", "score": 1.0, "codebleu": 0.2180592525860096, "crystalbleu": 0.14, "codebertscore": 0.8, "codescore": 0.5166824460029602, "surfaceSim": 0.6703511741061985, "abs_surfaceSim_minus_score": 0.3296488258938015, "source": "local", "local_type": "OP"}
{"id": "APPS_test-3698_44", "golden_code": "# python3\nimport sys\nfrom functools import lru_cache\n\nsys.setrecursionlimit(1000000)\n\nMOD = int(1e+9 + 7)\n\n\ndef inv(val): return pow(val, MOD - 2, MOD)\n\n\n@lru_cache(maxsize=None)\ndef factorial(n):\n    return 1 if n < 2 else (factorial(n - 1) * n % MOD)\n\n\ndef choose(n, k):\n    return factorial(n) * inv(factorial(k) * factorial(n-k)) % MOD\n\n\ndef numbers_with_bits(length, n):\n    nxt = 0\n    res = 0\n    while nxt != -1 and length > 0:\n        top = len(n) - 1 - nxt\n\n        if(length <= top):\n            res += choose(top, length)\n            res %= MOD\n\n        nxt = n.find('1', nxt + 1)\n        length -= 1\n\n    if length == 0:\n        res += 1\n\n    return res\n\n\ndef bits(n): return bin(n).count('1')\n\n\ndef solve(n, k):\n    if k == 0:\n        return 1\n    elif k == 1:\n        return len(n) - 1  # exclude the 1\n    elif k > 5:\n        return 0\n\n    ans = 0\n    f = [-1, 0]\n    for i in range(2, 1001):\n        f.append(f[bits(i)] + 1)\n        if f[i] == k - 1:\n            ans += numbers_with_bits(i, n)\n            ans %= MOD\n    return ans\n\nprint(solve(n=input(), k=int(input())))\n", "generated_code": "from sys import stdin\ninput = stdin.readline\n\ndef special(n):\n\treturn (1 << len(bin(n))-2) - 1 - n\n\ndef add(a, b, c):\n\twhile b <= a:\n\t\ta = a << 1\n\t\tb = b << 1 | 1\n\treturn a - c\n\ndef solve():\n\tn = int(input())\n\tk = int(input().strip())\n\tassert k <= n\n\tprint(sum(map(add, 1, 0) for _ in range(k)))\n\ndef __starting_point():\n\tsolve()\n__starting_point()\n", "score": 0.1722, "codebleu": 0.10571534056827331, "crystalbleu": 0.04, "codebertscore": 0.72, "codescore": 0.055057186633348465, "surfaceSim": 0.45708460754332314, "abs_surfaceSim_minus_score": 0.2848846075433231, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_157_1", "golden_code": "def is_octagonal(n): \r\n\treturn 3 * n * n - 2 * n ", "generated_code": "def is_octagonal(n):\n\t\n\ts=n%2\n\treturn not s or s==0", "score": 0.0, "codebleu": 0.17477209486726025, "crystalbleu": 0, "codebertscore": 0.83, "codescore": 0.023860760033130646, "surfaceSim": 0.5681372549019608, "abs_surfaceSim_minus_score": 0.5681372549019608, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_1407_12_MUT_2", "golden_code": "def sieve(mx):\n    a = [0] * (mx + 1)\n    a[0] = a[1] = 1\n    for (i, e) in enumerate(a):\n        if e == 0:\n            for n in range(i * i, mx + 1, i):\n                a[n] = 1\n    return a\n\np = sieve((10 ** 5) + 100)\nfor i in range((10 ** 5) + 99, 0, -1):\n    p[i] *= p[i + 1] + 1\n\n(n, m) = map(int, input().split())\n\ncols = [0] * m\n\nmm = 10 ** 7\nfor i in range(n):\n    row = list(map(int, input().split()))\n    row_sum = 0\n    for (a, j) in enumerate(row):\n        tt = p[j]\n        row_sum += tt\n        cols[a] += tt\n    mm = min(mm, row_sum)\n\nprint(min(min(cols), mm))", "generated_code": "def sieve(mx):\n    a = [0] / (mx + 1)\n    a[0] = a[1] = 1\n    for (i, e) in enumerate(a):\n        if e == 0:\n            for n in range(i * i, mx + 1, i):\n                a[n] = 1\n    return a\n\np = sieve((10 ** 5) + 100)\nfor i in range((10 ** 5) + 99, 0, -1):\n    p[i] *= p[i + 1] + 1\n\n(n, m) = map(int, input().split())\n\ncols = [0] * m\n\nmm = 10 ** 7\nfor i in range(n):\n    row = list(map(int, input().split()))\n    row_sum = 0\n    for (a, j) in enumerate(row):\n        tt = p[j]\n        row_sum += tt\n        cols[a] += tt\n    mm = min(mm, row_sum)\n\nprint(min(min(cols), mm))", "score": 0.0, "codebleu": 0.9883620632734545, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.9937612414360046, "surfaceSim": 0.9818905651340997, "abs_surfaceSim_minus_score": 0.9818905651340997, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_MBPP_397_MUT_26", "golden_code": "import os\n\ndef median_numbers(a, b, c):\n    if a > b:\n        if a < c:\n            median = a\n        elif b > c:\n            median = b\n        else:\n            median = c\n    \n    elif a > c:\n        median = a\n    elif b < c:\n        median = b\n    else:\n        median = c\n    return median", "generated_code": "import os\n\ndef median_numbers(a, b, c):\n    if a > b:\n        if a < c:\n            median = a\n        elif b > c:\n            median = b\n        else:\n            median = c\n    \n    elif a > c:\n        median = a\n    elif b < c:\n        median = b\n    else:\n        median = c\n    pass", "score": 0.0, "codebleu": 0.9405566354786925, "crystalbleu": 0.92, "codebertscore": 0.99, "codescore": 0.9934778213500977, "surfaceSim": 0.9172297297297297, "abs_surfaceSim_minus_score": 0.9172297297297297, "source": "local", "local_type": "MUT"}
{"id": "MBPP_34_77", "golden_code": "def even_num(x):\r\n  if x%2==0:\r\n     return True\r\n  else:\r\n    return False", "generated_code": "def even_num( n):    \n\treturn (n & 3) == 2", "score": 0.6586, "codebleu": 0.30650023657435715, "crystalbleu": 0, "codebertscore": 0.79, "codescore": 0.5266638994216919, "surfaceSim": 0.6728571428571428, "abs_surfaceSim_minus_score": 0.014257142857142857, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_p02599_s870922238_MUT_46", "golden_code": "import sys\nclass BinaryIndexedTree:\n    def __init__(self, A):\n        self.__n = len(A)\n        self.__node = [0] * (self.__n + 1)\n        self.__data = [0] * (self.__n + 1)\n        S = [0] * (self.__n + 1)\n        for i in range(1, self.__n + 1):\n            S[i] = S[i - 1] + A[i - 1]\n            self.__data[i] = A[i - 1]\n            self.__node[i] = S[i] - S[i - (i & (-i))]\n    def add(self, i, v):\n        self.__data[i] += v\n        while i <= self.__n:\n            self.__node[i] += v\n            i += i & (-i)\n    def sum(self, i):\n        rst = 0\n        while i > 0:\n            rst += self.__node[i]\n            i -= i & (-i)\n        return rst\n    def get(self, i, j):\n        if i == j:\n            return self.__data[i]\n        else:\n            return self.sum(j) - self.sum(i - 1)\ndef main():\n    (N, Q) = map(int, input().split())\n    C = list(map(int, input().split()))\n    P = [[] for _ in range(N)]\n    for (i, c) in enumerate(C):\n        P[c - 1].append(i)\n    right = [0] * N\n    for p in P:\n        if len(p):\n            right[p.pop()] = 1\n    BIT = BinaryIndexedTree(right)\n    query = [[] for _ in range(N)]\n    for (i, s) in enumerate(sys.stdin.readlines()):\n        (l, r) = map(int, s.split())\n        query[r - 1].append((l - 1, i))\n    ans = [None] * Q\n    cur = N - 1\n    for (r, q) in enumerate(reversed(query)):\n        r = (N - 1) - r\n        while q:\n            (l, i) = q.pop()\n            while r < cur:\n                c = C[cur] - 1\n                p = P[c]\n                if len(p):\n                    BIT.add(p.pop() + 1, 1)\n                cur -= 1\n            tmp = BIT.get(l + 1, r + 1)\n            ans[i] = tmp\n    print(sep='\\n', *ans)", "generated_code": "import sys\nclass BinaryIndexedTree:\n    def __init__(self, A):\n        self.__n = len(A)\n        self.__node = [0] * (self.__n + 1)\n        self.__data = [0] * (self.__n + 1)\n        S = [0] * (self.__n + 1)\n        for i in range(1, self.__n + 1):\n            S[i] = S[i - 1] + A[i - 1]\n            self.__data[i] = A[i - 1]\n            self.__node[i] = S[i] - S[i - (i & (-i))]\n    def add(self, i, v):\n        self.__data[i] += v\n        while i <= self.__n:\n            self.__node[i] += v\n            i -= i & (-i)\n    def sum(self, i):\n        rst = 0\n        while i > 0:\n            rst += self.__node[i]\n            i -= i & (-i)\n        return rst\n    def get(self, i, j):\n        if i == j:\n            return self.__data[i]\n        else:\n            return self.sum(j) - self.sum(i - 1)\ndef main():\n    (N, Q) = map(int, input().split())\n    C = list(map(int, input().split()))\n    P = [[] for _ in range(N)]\n    for (i, c) in enumerate(C):\n        P[c - 1].append(i)\n    right = [0] * N\n    for p in P:\n        if len(p):\n            right[p.pop()] = 1\n    BIT = BinaryIndexedTree(right)\n    query = [[] for _ in range(N)]\n    for (i, s) in enumerate(sys.stdin.readlines()):\n        (l, r) = map(int, s.split())\n        query[r - 1].append((l - 1, i))\n    ans = [None] * Q\n    cur = N - 1\n    for (r, q) in enumerate(reversed(query)):\n        r = (N - 1) - r\n        while q:\n            (l, i) = q.pop()\n            while r < cur:\n                c = C[cur] - 1\n                p = P[c]\n                if len(p):\n                    BIT.add(p.pop() + 1, 1)\n                cur -= 1\n            tmp = BIT.get(l + 1, r + 1)\n            ans[i] = tmp\n    print(sep='\\n', *ans)", "score": 0.0414, "codebleu": 0.994935590512094, "crystalbleu": 1.0, "codebertscore": 1.0, "codescore": 0.9936455488204956, "surfaceSim": 0.9997036158861885, "abs_surfaceSim_minus_score": 0.9583036158861885, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-2585_57", "golden_code": "def r1(t):\n    return t(input())\n\ndef r2(t):\n    return [t(i) for i in input().split()]\n\nfor _ in range(int(input())):\n    n = r1(int)\n    print(n//2)\n", "generated_code": "from math import gcd\nfor _ in range(int(input())):\n\tn = int(input())\n\tprint(gcd(n,n**2))\n", "score": 0.0, "codebleu": 0.3214762150773255, "crystalbleu": 0, "codebertscore": 0.81, "codescore": 0.6392224431037903, "surfaceSim": 0.47981709239987386, "abs_surfaceSim_minus_score": 0.47981709239987386, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_142_MUT_7", "golden_code": "import os\n\ndef sum_squares(lst):\n    result = []\n    for i in range(len(lst)):\n        if i % 3 == 0:\n            result.append(lst[i] ** 2)\n        elif (i % 4 == 0 and i % 3 != 0):\n            result.append(lst[i] ** 3)\n        else:\n            result.append(lst[i])\n    return sum(result)", "generated_code": "import os\n\ndef sum_squares(lst):\n    result = []\n    for i in range(len(lst)):\n        if i % 3 == 0:\n            result.append(lst[i] ** 2)\n        elif not ((i % 4 == 0 and i % 3 != 0)):\n            result.append(lst[i] ** 3)\n        else:\n            result.append(lst[i])\n    return sum(result)", "score": 0.1803, "codebleu": 0.8911854073924611, "crystalbleu": 0.9, "codebertscore": 0.99, "codescore": 0.9936380982398987, "surfaceSim": 0.9582774049217002, "abs_surfaceSim_minus_score": 0.7779774049217002, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_PIE_extra_p03796_s559298633_OP_1", "golden_code": "import math\n\nmod = 10 ** 9 + 7\n\nn = int(eval(input()))\n\nprint((math.factorial(n) % mod))", "generated_code": "mod = 10 ** 9 + 7\n\nn = int(eval(input()))\n\nans = 1\n\nfor i in range(1, n + 1):\n\n    ans *= i\n\n    ans %= mod\n\nprint(ans)", "score": 1.0, "codebleu": 0.47574210334091366, "crystalbleu": 0, "codebertscore": 0.85, "codescore": 0.6595489978790283, "surfaceSim": 0.6148459383753502, "abs_surfaceSim_minus_score": 0.3851540616246498, "source": "local", "local_type": "OP"}
{"id": "MBPP_34_58", "golden_code": "def even_num(x):\r\n  if x%2==0:\r\n     return True\r\n  else:\r\n    return False", "generated_code": "def even_num(x):\n     return (x & 0x5555555555555555) == 0", "score": 0.4515, "codebleu": 0.32003910602047003, "crystalbleu": 0, "codebertscore": 0.77, "codescore": 0.4864615499973297, "surfaceSim": 0.6595238095238095, "abs_surfaceSim_minus_score": 0.2080238095238095, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-1312_21", "golden_code": "n,m = map(int, input().split())\ncur = n;\nfor i in range(0,m):\n    print( cur // (m - i),end = ' ')\n    cur -= cur // (m - i)\n", "generated_code": "n,m=list(map(int,input().split()))\nl=[]\nans=[]\nfor i in range(m):\n\ta=list(map((n+1)//i,range(1,n+1)))\n\tl.append(a)\nl.sort()\nfor i in l:\n\tj=i[0]\n\twhile(j<n):\n\t\tans.append(j)\n\t\tj+=i[1]\n\t\t\nprint(*ans)\n\t\n", "score": 0.0, "codebleu": 0.21708909852396716, "crystalbleu": 0, "codebertscore": 0.8, "codescore": 0.07984214276075363, "surfaceSim": 0.4966666666666667, "abs_surfaceSim_minus_score": 0.4966666666666667, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_MBPP_783_MUT_1", "golden_code": "import os\n\ndef rgb_to_hsv(r, g, b):\n    (r, g, b) = (r / 255.0, g / 255.0, b / 255.0)\n    mx = max(r, g, b)\n    mn = min(r, g, b)\n    df = mx - mn\n    if mx == mn:\n        h = 0\n    elif mx == r:\n        h = ((60 * ((g - b) / df)) + 360) % 360\n    elif mx == g:\n        h = ((60 * ((b - r) / df)) + 120) % 360\n    elif mx == b:\n        h = ((60 * ((r - g) / df)) + 240) % 360\n    if mx == 0:\n        s = 0\n    else:\n        s = (df / mx) * 100\n    v = mx * 100\n    return (h, s, v)", "generated_code": "import os\n\ndef rgb_to_hsv(r, g, b):\n    (r, g, b) = (r // 255.0, g / 255.0, b / 255.0)\n    mx = max(r, g, b)\n    mn = min(r, g, b)\n    df = mx - mn\n    if mx == mn:\n        h = 0\n    elif mx == r:\n        h = ((60 * ((g - b) / df)) + 360) % 360\n    elif mx == g:\n        h = ((60 * ((b - r) / df)) + 120) % 360\n    elif mx == b:\n        h = ((60 * ((r - g) / df)) + 240) % 360\n    if mx == 0:\n        s = 0\n    else:\n        s = (df / mx) * 100\n    v = mx * 100\n    return (h, s, v)", "score": 0.3466, "codebleu": 0.9891236321326904, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9937155842781067, "surfaceSim": 0.9781293222683265, "abs_surfaceSim_minus_score": 0.6315293222683265, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_MBPP_297_OP_1", "golden_code": "def flatten_list(list1):\r\n    result_list = []\r\n    if not list1: return result_list\r\n    stack = [list(list1)]\r\n    while stack:\r\n        c_num = stack.pop()\r\n        next = c_num.pop()\r\n        if c_num: stack.append(c_num)\r\n        if isinstance(next, list):\r\n            if next: stack.append(list(next))\r\n        else: result_list.append(next)\r\n    result_list.reverse()\r\n    return result_list ", "generated_code": "def flatten_list(nested):\n    if not nested: return []\n    stack, flat = [iter(nested)], []\n    while stack:\n        try:\n            item = next(stack[-1])\n            if isinstance(item, list):\n                stack.append(iter(item))\n            else:\n                flat.append(item)\n        except StopIteration:\n            stack.pop()\n    return flat", "score": 1.0, "codebleu": 0.27778324511590785, "crystalbleu": 0, "codebertscore": 0.8, "codescore": 0.9939316511154175, "surfaceSim": 0.6466666666666667, "abs_surfaceSim_minus_score": 0.3533333333333333, "source": "local", "local_type": "OP"}
{"id": "MBPP_34_32", "golden_code": "def even_num(x):\r\n  if x%2==0:\r\n     return True\r\n  else:\r\n    return False", "generated_code": "def even_num(x)  :\n    return 1 if x % 4 == 0 else 0", "score": 0.7113, "codebleu": 0.326138084113724, "crystalbleu": 0, "codebertscore": 0.86, "codescore": 0.6077486872673035, "surfaceSim": 0.7352380952380952, "abs_surfaceSim_minus_score": 0.023938095238095203, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_73_14", "golden_code": "def get_noOfways(n):\r\n    if (n == 0):\r\n        return 0;\r\n    if (n == 1):\r\n        return 1; \r\n    return get_noOfways(n - 1) + get_noOfways(n - 2);", "generated_code": "def get_noOfways(n):    \n\tif (n < 2) : return False\n\tfor i in range(3, int(n**0.5)+1, 2):   \n\t\tif n % i == 0:        \n\t\t\treturn False\n\treturn True", "score": 0.0, "codebleu": 0.24878848386212493, "crystalbleu": 0, "codebertscore": 0.81, "codescore": 0.17514990270137787, "surfaceSim": 0.6233333333333333, "abs_surfaceSim_minus_score": 0.6233333333333333, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_extra_p03371_s299972417_OP_1", "golden_code": "a,b,c,x,y = list(map(int,input().split()))\n\nans = a*x + b*y\n\nfor i in range(max(x,y) + 1):\n\n\tmoney = max(0,(x-i)*a) + max(0,(y-i)*b) + 2*i*c\n\n\tif money <= ans:\n\n\t\tans = money\n\nprint(ans)", "generated_code": "a,b,c,x,y = list(map(int,input().split()))\n\nif a + b >= 2*c:\n\n\tif x >= y:\n\n\t\tans = 2*y*c + (x-y)*min(a,2*c)\n\n\telse:\n\n\t\tans = 2*x*c + (y-x)*min(b,2*c)\n\nelse:\n\n\tans = (x*a + y*b)\n\nprint(ans)", "score": 1.0, "codebleu": 0.29801496734975996, "crystalbleu": 0, "codebertscore": 0.87, "codescore": 0.0790838897228241, "surfaceSim": 0.6976483762597985, "abs_surfaceSim_minus_score": 0.3023516237402015, "source": "local", "local_type": "OP"}
{"id": "MBPP_76_23", "golden_code": "def word_len(s): \r\n    s = s.split(' ')   \r\n    for word in s:    \r\n        if len(word)%2==0: \r\n            return True  \r\n        else:\r\n          return False", "generated_code": "def word_len(s): \n\treturn len(s) % 2 == 0\nUST = True\nR = False", "score": 0.9518, "codebleu": 0.15667283583440267, "crystalbleu": 0, "codebertscore": 0.79, "codescore": 0.9920915365219116, "surfaceSim": 0.7644927536231885, "abs_surfaceSim_minus_score": 0.1873072463768115, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_34_64", "golden_code": "def even_num(x):\r\n  if x%2==0:\r\n     return True\r\n  else:\r\n    return False", "generated_code": "def even_num(x):\n\tif x%2 == 0:\n\t\treturn True\n\telse:\n\t\t0\n\treturn False\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t\n\n\n\n\n\nimport re", "score": 1.0, "codebleu": 0.4667163282160632, "crystalbleu": 0, "codebertscore": 0.89, "codescore": 0.9936233162879944, "surfaceSim": 0.8512500000000001, "abs_surfaceSim_minus_score": 0.14874999999999994, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0774_56", "golden_code": "from fractions import Fraction\nx,y,n=map(int,input().split())\nz=Fraction(x,y).limit_denominator(n)\nprint(z.numerator,z.denominator,sep='/')\n\n", "generated_code": "a, b, n = [int(x) for x in input().split()]\nif a == b:\n\tprint(f'{a}/{b}')\n\treturn\nc = abs(a - b)\nif c > n:\n\tprint('{}/{}'.format(a, b))\nelse:\n\tprint((a//b) + 1)\n", "score": 0.0, "codebleu": 0.20535714285714285, "crystalbleu": 0, "codebertscore": 0.72, "codescore": 0.01839635521173477, "surfaceSim": 0.33827042522694695, "abs_surfaceSim_minus_score": 0.33827042522694695, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_p02537_s645565645_MUT_140", "golden_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "generated_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = __node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "score": 0.0, "codebleu": 0.9867305793496425, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9821937084197998, "surfaceSim": 0.9984634296250768, "abs_surfaceSim_minus_score": 0.9984634296250768, "source": "local", "local_type": "MUT"}
{"id": "MBPP_29_8", "golden_code": "from itertools import groupby \r\ndef extract_elements(numbers, n):\r\n    result = [i for i, j in groupby(numbers) if len(list(j)) == n] \r\n    return result", "generated_code": "from itertools import groupby \ndef extract_elements(numbers, n):\n\treturn [e for i, e in enumerate(numbers) if not numbers[i] or e]", "score": 0.1859, "codebleu": 0.38070598258228855, "crystalbleu": 0, "codebertscore": 0.9, "codescore": 0.08244621753692627, "surfaceSim": 0.6768968456947997, "abs_surfaceSim_minus_score": 0.4909968456947997, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_2645_55_MUT_13", "golden_code": "ans = 0\n\nfor (i, c) in enumerate(input()):\n    if (i % 2 == 0 and c == 'p'):\n        ans -= 1elif (i % 2 == 1 and c == 'g'):ans += 1\n\nprint(ans)", "generated_code": "ans = 0\n\nfor (i, c) in enumerate(input()):\n    if (i % 2 != 0 and c == 'p'):\n        ans -= 1elif (i % 2 == 1 and c == 'g'):ans += 1\n\nprint(ans)", "score": 0.0, "codebleu": 0.9599078648843334, "crystalbleu": 0, "codebertscore": 1.0, "codescore": 0.9935817718505859, "surfaceSim": 0.4965277777777778, "abs_surfaceSim_minus_score": 0.4965277777777778, "source": "local", "local_type": "MUT"}
{"id": "MBPP_20_13", "golden_code": "def is_odd(n) : \r\n    if (n^1 == n-1) :\r\n        return True; \r\n    else :\r\n        return False; ", "generated_code": "def is_odd(n):\n\treturn (n & 0xffffffff) == 0", "score": 0.5454, "codebleu": 0.22976441383200974, "crystalbleu": 0, "codebertscore": 0.75, "codescore": 0.6008635759353638, "surfaceSim": 0.6727891156462584, "abs_surfaceSim_minus_score": 0.12738911564625843, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_76_21", "golden_code": "def word_len(s): \r\n    s = s.split(' ')   \r\n    for word in s:    \r\n        if len(word)%2==0: \r\n            return True  \r\n        else:\r\n          return False", "generated_code": "def word_len(word):\n\treturn sum(map(lambda char: ord(char) - ord('a'), word)) % 2 ==0", "score": 0.6179, "codebleu": 0.17519238250270552, "crystalbleu": 0, "codebertscore": 0.74, "codescore": 0.6298340559005737, "surfaceSim": 0.6107142857142858, "abs_surfaceSim_minus_score": 0.00718571428571424, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_72_8", "golden_code": "def Average(lst): \r\n    return sum(lst) / len(lst) ", "generated_code": "def Average(lst): \n\tsum = 0\n\tfor n in lst:\n\t\tsum = sum + n\n\tavg = sum / len(lst) \n\treturn avg\nduplicate = [\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\"]", "score": 1.0, "codebleu": 0.4144158950862199, "crystalbleu": 0, "codebertscore": 0.77, "codescore": 0.9924163818359375, "surfaceSim": 0.45231042654028436, "abs_surfaceSim_minus_score": 0.5476895734597156, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_extra_p03828_s909168869_OP_1", "golden_code": "from collections import Counter\n\nN = int(eval(input()))\n\ndiv = []\n\nfor i in range(2,N+1):\n\n    while i != 1:\n\n        for d in range(2,i+1):\n\n            while i%d==0:\n\n                i = i//d\n\n                div.append(d)\n\nC = Counter(div).most_common()\n\nAns = 1\n\nfor k,v in C:\n\n    Ans = Ans*(v+1) % (10**9+7)\n\n\n\nprint(Ans)\n", "generated_code": "from collections import defaultdict\n\nN = int(eval(input()))\n\n\n\nF = [True]*(N+1)\n\nF[0]=F[1]=False\n\nP = []\n\n\n\nfor i in range(2,N+1):\n\n    if F[i]==True:\n\n        P.append(i)\n\n        for j in range(i*2,N+1,i):\n\n            F[j]=False\n\n\n\ndic = defaultdict(int)\n\nfor i in range(2,N+1):\n\n    for p in P:\n\n        while i%p==0:\n\n            dic[p] += 1\n\n            i = i//p\n\n        if i==1:\n\n            break\n\n\n\nans = 1\n\nmodulo = 10**9+7\n\nfor v in list(dic.values()):\n\n    ans *= (v+1)\n\n    ans %= modulo\n\n\n\nprint(ans)", "score": 1.0, "codebleu": 0.35876591836831284, "crystalbleu": 0.23, "codebertscore": 0.83, "codescore": 0.993341863155365, "surfaceSim": 0.6754268496819551, "abs_surfaceSim_minus_score": 0.3245731503180449, "source": "local", "local_type": "OP"}
{"id": "MBPP_566_1", "golden_code": "def magic_square_test(my_matrix):\r\n    iSize = len(my_matrix[0])\r\n    sum_list = []\r\n    sum_list.extend([sum (lines) for lines in my_matrix])   \r\n    for col in range(iSize):\r\n        sum_list.append(sum(row[col] for row in my_matrix))\r\n    result1 = 0\r\n    for i in range(0,iSize):\r\n        result1 +=my_matrix[i][i]\r\n    sum_list.append(result1)      \r\n    result2 = 0\r\n    for i in range(iSize-1,-1,-1):\r\n        result2 +=my_matrix[i][i]\r\n    sum_list.append(result2)\r\n    if len(set(sum_list))>1:\r\n        return False\r\n    return True", "generated_code": "def magic_square_test(matrix):\n\tmax_i = max(map(str, matrix))\n\treturn max_i", "score": 0.0, "codebleu": 0.029419916253175308, "crystalbleu": 0, "codebertscore": 0.68, "codescore": 0.08425404876470566, "surfaceSim": 0.3600293199056664, "abs_surfaceSim_minus_score": 0.3600293199056664, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_MBPP_846_MUT_15", "golden_code": "import os\n\ndef find_platform(arr, dep, n):\n    arr.sort()\n    dep.sort()\n    plat_needed = 1\n    result = 1\n    i = 1\n    j = 0\n    while (i < n and j < n):\n        if arr[i] <= dep[j]:\n            plat_needed += 1\n            i += 1\n        elif arr[i] > dep[j]:\n            plat_needed -= 1\n            j += 1\n        if plat_needed > result:\n            result = plat_needed\n    return result", "generated_code": "import os\n\ndef find_platform(arr, dep, n):\n    arr.sort()\n    dep.sort()\n    plat_needed = 1\n    result = 1\n    i = 1\n    j = 0\n    while (i < n and j > n):\n        if arr[i] <= dep[j]:\n            plat_needed += 1\n            i += 1\n        elif arr[i] > dep[j]:\n            plat_needed -= 1\n            j += 1\n        if plat_needed > result:\n            result = plat_needed\n    return result", "score": 0.25, "codebleu": 0.9775309568365562, "crystalbleu": 0.97, "codebertscore": 1.0, "codescore": 0.9936351776123047, "surfaceSim": 0.9987341772151899, "abs_surfaceSim_minus_score": 0.7487341772151899, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-0672_51", "golden_code": "x,y=list(map(int,input().split()))\n\nn=x-y\nj=n\nc=0\nif j<0:\n    print(c)\nelif j==0:\n    print(\"infinity\")\nelse:\n    result_set = set()\n    sqrtn = int(n**0.5)\n    for i in range(1,sqrtn+1):\n        q, r = n/i, n%i\n        if r == 0:\n            if(q>y):\n                result_set.add(q)\n            if(i>y):\n                result_set.add(i)\n            \n    print( len(result_set))\n    \n", "generated_code": "import sys\ninput = sys.stdin.readline\n\na, b = map(int, input().split())\nn = int(a ** 2 + b ** 2)\n\nif b == a:\n\tprint(\"infinity\")\nelif n == 1:\n\tprint(1)\nelif n & 1:\n\tmod = n - 1\n\tprint(mod // 2)\nelse:\n\tprint((n - 1) // 2)\n", "score": 0.0222, "codebleu": 0.13424984408357335, "crystalbleu": 0, "codebertscore": 0.75, "codescore": 0.053880009800195694, "surfaceSim": 0.5840290200755317, "abs_surfaceSim_minus_score": 0.5618290200755317, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_extra_p03170_s503646377_OP_1", "golden_code": "import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\nfrom operator import xor\n\nfrom functools import reduce\n\n\n\nN,K,*A = list(map(int,read().split()))\n\n\n\na = reduce(xor,(1<<a for a in A))\n\n\n\ndp = 0 # bitset\n\nfor n in range(K):\n\n    if not(dp&(1<<n)):\n\n        dp |= (a<<n)\n\n\n\nanswer = 'First' if dp&(1<<K) else 'Second'\n\nprint(answer)", "generated_code": "import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\nN,K,*A = list(map(int,read().split()))\n\n\n\ndp = [0]*(K+1) # bitset\n\nfor n in range(K):\n\n    if not dp[n]:\n\n        for a in A:\n\n            if n+a>K:\n\n                break\n\n            dp[n+a]=1\n\n\n\nanswer = 'First' if dp[-1] else 'Second'\n\nprint(answer)", "score": 0.818, "codebleu": 0.47655826831178383, "crystalbleu": 0.55, "codebertscore": 0.9, "codescore": 0.4205171465873718, "surfaceSim": 0.6259061833688699, "abs_surfaceSim_minus_score": 0.19209381663113, "source": "local", "local_type": "OP"}
{"id": "LOCAL_MBPP_289_MUT_8", "golden_code": "import os\n\ndef odd_Days(N):\n    hund1 = N // 100\n    hund4 = N // 400\n    leap = N >> 2\n    ordd = N - leap\n    if hund1:\n        ordd += hund1\n        leap -= hund1\n    if hund4:\n        ordd -= hund4\n        leap += hund4\n    days = ordd + (leap * 2)\n    odd = days % 7\n    return odd", "generated_code": "import os\n\ndef odd_Days(N):\n    hund1 = N // 100\n    hund4 = N // 400\n    leap = N >> 2\n    ordd = N - leap\n    if hund1:\n        ordd += hund1\n        leap -= hund1\n    if hund4:\n        ordd -= hund4\n        leap += hund4\n    days = ordd + (leap // 2)\n    odd = days % 7\n    return odd", "score": 0.1804, "codebleu": 0.9761243903408761, "crystalbleu": 0, "codebertscore": 1.0, "codescore": 0.9937393665313721, "surfaceSim": 0.9727061556329848, "abs_surfaceSim_minus_score": 0.7923061556329848, "source": "local", "local_type": "MUT"}
{"id": "MBPP_50_7", "golden_code": "def mutiple_tuple(nums):\r\n    temp = list(nums)\r\n    product = 1 \r\n    for x in temp:\r\n        product *= x\r\n    return product", "generated_code": "def mutiple_tuple(nums): return sum(list(map(lambda x: -x, nums)))", "score": 0.0112, "codebleu": 0.09737003304831054, "crystalbleu": 0, "codebertscore": 0.81, "codescore": 0.018273714929819107, "surfaceSim": 0.5305697081982399, "abs_surfaceSim_minus_score": 0.5193697081982399, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_514_1", "golden_code": "import re\r\ndef multiple_split(text):\r\n  return (re.split('; |, |\\*|\\n',text))", "generated_code": "import re\ndef multiple_split(s):\n\tfor idx in range(0, len(s)):\n\t\tif s[idx] & s[~idx]:\n\t\t\tcontinue\n\t\telse :\n\t\t\treturn", "score": 0.0, "codebleu": 0.30202120179666175, "crystalbleu": 0, "codebertscore": 0.74, "codescore": 0.11568808555603027, "surfaceSim": 0.5, "abs_surfaceSim_minus_score": 0.5, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_16_OP_1", "golden_code": "def count_distinct_characters(string: str) -> int:\n    return len(set(string.lower()))", "generated_code": "def count_distinct_characters(text: str) -> int:\n    cache = {}\n    def lower_and_count(t):\n        if t not in cache:\n            cache[t] = set(t.lower())\n        return cache[t]\n    return len(lower_and_count(text))", "score": 1.0, "codebleu": 0.46095103782271346, "crystalbleu": 0, "codebertscore": 0.83, "codescore": 0.9618247151374817, "surfaceSim": 0.5284673502428494, "abs_surfaceSim_minus_score": 0.4715326497571506, "source": "local", "local_type": "OP"}
{"id": "LOCAL_PIE_extra_p03309_s990999147_OP_1", "golden_code": "import statistics\n\nN = int(eval(input()))\n\nA = [int(a)-i-1 for i,a in enumerate(input().split(),1)]\n\nb = statistics.median_low(A)\n\nc = statistics.median_high(A)\n\nd = sum([abs(x-b) for x in A])\n\ne = sum([abs(x-c) for x in A])\n\nprint((min(d,e)))", "generated_code": "N=int(eval(input()))\n\nA=sorted(a-i-1 for i,a in enumerate(map(int,input().split())))\n\nprint((sum(abs(a-A[N//2]) for a in A)))", "score": 1.0, "codebleu": 0.14960714055356095, "crystalbleu": 0, "codebertscore": 0.86, "codescore": 0.12571220099925995, "surfaceSim": 0.5554526748971194, "abs_surfaceSim_minus_score": 0.44454732510288064, "source": "local", "local_type": "OP"}
{"id": "LOCAL_PIE_p02599_s870922238_MUT_144", "golden_code": "import sys\nclass BinaryIndexedTree:\n    def __init__(self, A):\n        self.__n = len(A)\n        self.__node = [0] * (self.__n + 1)\n        self.__data = [0] * (self.__n + 1)\n        S = [0] * (self.__n + 1)\n        for i in range(1, self.__n + 1):\n            S[i] = S[i - 1] + A[i - 1]\n            self.__data[i] = A[i - 1]\n            self.__node[i] = S[i] - S[i - (i & (-i))]\n    def add(self, i, v):\n        self.__data[i] += v\n        while i <= self.__n:\n            self.__node[i] += v\n            i += i & (-i)\n    def sum(self, i):\n        rst = 0\n        while i > 0:\n            rst += self.__node[i]\n            i -= i & (-i)\n        return rst\n    def get(self, i, j):\n        if i == j:\n            return self.__data[i]\n        else:\n            return self.sum(j) - self.sum(i - 1)\ndef main():\n    (N, Q) = map(int, input().split())\n    C = list(map(int, input().split()))\n    P = [[] for _ in range(N)]\n    for (i, c) in enumerate(C):\n        P[c - 1].append(i)\n    right = [0] * N\n    for p in P:\n        if len(p):\n            right[p.pop()] = 1\n    BIT = BinaryIndexedTree(right)\n    query = [[] for _ in range(N)]\n    for (i, s) in enumerate(sys.stdin.readlines()):\n        (l, r) = map(int, s.split())\n        query[r - 1].append((l - 1, i))\n    ans = [None] * Q\n    cur = N - 1\n    for (r, q) in enumerate(reversed(query)):\n        r = (N - 1) - r\n        while q:\n            (l, i) = q.pop()\n            while r < cur:\n                c = C[cur] - 1\n                p = P[c]\n                if len(p):\n                    BIT.add(p.pop() + 1, 1)\n                cur -= 1\n            tmp = BIT.get(l + 1, r + 1)\n            ans[i] = tmp\n    print(sep='\\n', *ans)", "generated_code": "import sys\nclass BinaryIndexedTree:\n    def __init__(self, A):\n        self.__n = len(A)\n        self.__node = [0] * (self.__n + 1)\n        self.__data = [0] * (self.__n + 1)\n        S = [0] * (self.__n + 1)\n        for i in range(1, self.__n + 1):\n            break\n    \n    \n    def add(self, i, v):\n        self.__data[i] += v\n        while i <= self.__n:\n            self.__node[i] += v\n            i += i & (-i)\n    def sum(self, i):\n        rst = 0\n        while i > 0:\n            rst += self.__node[i]\n            i -= i & (-i)\n        return rst\n    def get(self, i, j):\n        if i == j:\n            return self.__data[i]\n        else:\n            return self.sum(j) - self.sum(i - 1)\ndef main():\n    (N, Q) = map(int, input().split())\n    C = list(map(int, input().split()))\n    P = [[] for _ in range(N)]\n    for (i, c) in enumerate(C):\n        P[c - 1].append(i)\n    right = [0] * N\n    for p in P:\n        if len(p):\n            right[p.pop()] = 1\n    BIT = BinaryIndexedTree(right)\n    query = [[] for _ in range(N)]\n    for (i, s) in enumerate(sys.stdin.readlines()):\n        (l, r) = map(int, s.split())\n        query[r - 1].append((l - 1, i))\n    ans = [None] * Q\n    cur = N - 1\n    for (r, q) in enumerate(reversed(query)):\n        r = (N - 1) - r\n        while q:\n            (l, i) = q.pop()\n            while r < cur:\n                c = C[cur] - 1\n                p = P[c]\n                if len(p):\n                    BIT.add(p.pop() + 1, 1)\n                cur -= 1\n            tmp = BIT.get(l + 1, r + 1)\n            ans[i] = tmp\n    print(sep='\\n', *ans)", "score": 0.0398, "codebleu": 0.9073142287429817, "crystalbleu": 0.89, "codebertscore": 0.95, "codescore": 0.9937270879745483, "surfaceSim": 0.9664652218543526, "abs_surfaceSim_minus_score": 0.9266652218543525, "source": "local", "local_type": "MUT"}
{"id": "MBPP_38_5", "golden_code": "def find_fixed_point(arr, n): \r\n\tfor i in range(n): \r\n\t\tif arr[i] is i: \r\n\t\t\treturn i \r\n\treturn -1", "generated_code": "def find_fixed_point(arr, index):\n\tres = 0\n\tfor i in range(len(arr)-1):\n\t\tif arr[i] == index:\n\t\t\tres += 1\n\treturn res", "score": 0.0194, "codebleu": 0.28416039738382387, "crystalbleu": 0, "codebertscore": 0.86, "codescore": 0.05058911070227623, "surfaceSim": 0.671474358974359, "abs_surfaceSim_minus_score": 0.6520743589743591, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-2043_15", "golden_code": "import sys\n\nt = sys.stdin.readline().strip()\ns = sys.stdin.readline().strip()\n\nt_pos = 0\nfirst = None\nfor i, c in enumerate(s):\n    if c == t[t_pos]:\n        t_pos += 1\n        if t_pos == len(t):\n            first = i\n            break\n\nt_pos = len(t) - 1\nlast = None\nfor i, c in reversed(list(enumerate(s))):\n    if c == t[t_pos]:\n        t_pos -= 1\n        if t_pos == -1:\n            last = i\n            break\n\nif first == None or last == None or first > last:\n    sys.stdout.write('0\\n')\nelse:\n    sys.stdout.write(str(last - first) + '\\n')\n", "generated_code": "s = input()\nt = input()\n\nif len(s) > len(t):\n\tprint(0)\nelse:\n\tres = 0\n\tl = len(s)\n\tt = t.replace(' ', '')\n\tfor i in range(l):\n\t\tif t[i]!= s[i]:\n\t\t\tres += 1\n\tb = l - res\n\tres = 1\n\tfor ib in range(b):\n\t\tif b - 1 - ib < 0:\n\t\t\tbreak\n\t\tif t.startswith(s[ib]):\n\t\t\tres += _f(ij)\n\tprint(res)\n\ndef _f(idx):\n\treturn 2 ** (idx - 1)\n", "score": 0.2206, "codebleu": 0.16694206178118248, "crystalbleu": 0.04, "codebertscore": 0.75, "codescore": 0.08812817186117172, "surfaceSim": 0.5188038652389657, "abs_surfaceSim_minus_score": 0.2982038652389657, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-4159_10", "golden_code": "def slove():\n    A, B, K = map(int,input().split())\n    if A > K:\n        print(A-K, B)\n    else:\n        print(0,max(0,-K+(A+B)))\n\n\ndef __starting_point():\n    slove()\n__starting_point()", "generated_code": "import sys\n\nsys.setrecursionlimit(10 ** 6)\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep=\"\\n\")\ndef II(): return int(sys.stdin.readline())\ndef MI(): return map(int, sys.stdin.split())\ndef LI(): return list(map(int, sys.stdin.readlines()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef SI(): return sys.stdin[open(\"input.txt\", \"r\")]\n\ndef main():\n\ta,b,k=MI()\n\trr=[]\n\tfor _ in range(k):\n\t\tif a>b:a,b=b,a\n\t\tif b>a:b,a=a,b\n\t\trr.append", "score": 0.0, "codebleu": 0.1384803701204505, "crystalbleu": 0.02, "codebertscore": 0.69, "codescore": 0.020283548161387444, "surfaceSim": 0.38636363636363635, "abs_surfaceSim_minus_score": 0.38636363636363635, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_14_OP_1", "golden_code": "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    result = []\n\n    for i in range(len(string)):\n        result.append(string[:i+1])\n    return result", "generated_code": "def all_prefixes(text: str) -> list:\n    return [text[:idx] for idx in range(1, len(text) + 1)]", "score": 1.0, "codebleu": 0.13161344711525658, "crystalbleu": 0, "codebertscore": 0.85, "codescore": 0.11990377306938171, "surfaceSim": 0.5257707129094413, "abs_surfaceSim_minus_score": 0.47422928709055867, "source": "local", "local_type": "OP"}
{"id": "MBPP_112_1", "golden_code": "def product_Equal(n): \r\n    if n < 10: \r\n        return False\r\n    prodOdd = 1; prodEven = 1\r\n    while n > 0: \r\n        digit = n % 10\r\n        prodOdd *= digit \r\n        n = n//10\r\n        if n == 0: \r\n            break; \r\n        digit = n % 10\r\n        prodEven *= digit \r\n        n = n//10\r\n    if prodOdd == prodEven: \r\n        return True\r\n    return False", "generated_code": "def product_Equal(num):\n\t\n\treturn [y for y in range(1,1+num)]", "score": 0.0, "codebleu": 0.026830665169546103, "crystalbleu": 0, "codebertscore": 0.65, "codescore": 0.018234556540846825, "surfaceSim": 0.46916719643992366, "abs_surfaceSim_minus_score": 0.46916719643992366, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_extra_p02390_s941329471_OP_1", "golden_code": "s = int(eval(input()))\n\nm, s = s // 60, s % 60\n\nh, m = m // 60, m % 60\n\nprint((':'.join(map(str, [h,m,s]))))", "generated_code": "s = int(eval(input()))\n\n\n\nsecond = s % 60\n\ns = s // 60\n\nmin = s % 60\n\nhour = s // 60\n\n\n\nprint(f'{hour}:{min}:{second}')\n", "score": 1.0, "codebleu": 0.3695527868175694, "crystalbleu": 0, "codebertscore": 0.88, "codescore": 0.0441896878182888, "surfaceSim": 0.6270833333333333, "abs_surfaceSim_minus_score": 0.3729166666666667, "source": "local", "local_type": "OP"}
{"id": "LOCAL_PIE_extra_p02555_s764735536_OP_1", "golden_code": "from math import factorial\n\n\n\ns = int(eval(input()))\n\nmod = pow(10, 9) + 7\n\n\n\n\n\ndef nCr(n, r):\n\n    return int(factorial(n) // factorial(r) // factorial (n - r) % mod)\n\n\n\nans = 0\n\nseq_len = s // 3\n\n\n\nfor i in range(1, seq_len + 1):\n\n    ans += nCr(s - 3 * i + (i - 1), i - 1)\n\n\n\nprint((ans % mod))", "generated_code": "# 動的計画法による解法\n\n\n\ns = int(eval(input()))\n\nmod = pow(10, 9) + 7\n\n\n\nA = [0] * (s + 1)\n\n\n\nif s >= 3:\n\n    A[3] = 1\n\n\n\nfor i in range(4, s + 1):\n\n    A[i] = (A[i - 3] + A[i - 1]) % mod\n\n\n\nprint((A[s]))", "score": 1.0, "codebleu": 0.23343842161611617, "crystalbleu": 0.28, "codebertscore": 0.8, "codescore": 0.1424660086631775, "surfaceSim": 0.5176767676767677, "abs_surfaceSim_minus_score": 0.48232323232323226, "source": "local", "local_type": "OP"}
{"id": "LOCAL_PIE_extra_p03371_s588181559_OP_1", "golden_code": "# ABC95 C -Half and Half\n\na,b,c,x,y = list(map(float,input().split()))\n\nans = 0\n\nif a+b > 2*c:\n\n    while x != 0.0 and y != 0.0:\n\n        ans += 2*c\n\n        x -= 1.0\n\n        y -= 1.0\n\n        if y == 0.0:\n\n            while x != 0.0:\n\n                if a > 2*c:\n\n                    ans += 2*c\n\n                    x -= 1.0\n\n                else:\n\n                    ans += a\n\n                    x -= 1.0\n\n        if x == 0.0:\n\n            while y != 0.0:\n\n                if b > 2*c:\n\n                    ans += 2*c\n\n                    y -= 1.0\n\n                else:\n\n                    ans += b\n\n                    y -= 1.0\n\nelse:\n\n    ans += a*x + b*y\n\nprint((int(ans)))\n\n\n\n    ", "generated_code": "a,b,c,x,y=list(map(int,input().split()))\n\nans=0\n\nans1=0\n\n\n\ne=max(x,y)\n\nans1=e*(2*c)\n\nif 2*c<a+b:\n\n    d=min(x,y)\n\n    ans+=c*(2*d)\n\n    x-=d\n\n    y-=d\n\nelse:\n\n    ans=a*x+b*y\n\n    x-=x\n\n    y-=y\n\nans+=x*a\n\nans+=y*b\n\nprint((min(ans,ans1)))", "score": 1.0, "codebleu": 0.22409294065749263, "crystalbleu": 0.24, "codebertscore": 0.8, "codescore": 0.9809755086898804, "surfaceSim": 0.7353260869565217, "abs_surfaceSim_minus_score": 0.2646739130434783, "source": "local", "local_type": "OP"}
{"id": "LOCAL_MBPP_179_OP_1", "golden_code": "def is_num_keith(x): \r\n\tterms = [] \r\n\ttemp = x \r\n\tn = 0 \r\n\twhile (temp > 0): \r\n\t\tterms.append(temp % 10) \r\n\t\ttemp = int(temp / 10) \r\n\t\tn+=1 \r\n\tterms.reverse() \r\n\tnext_term = 0 \r\n\ti = n \r\n\twhile (next_term < x): \r\n\t\tnext_term = 0 \r\n\t\tfor j in range(1,n+1): \r\n\t\t\tnext_term += terms[i - j] \r\n\t\tterms.append(next_term) \r\n\t\ti+=1 \r\n\treturn (next_term == x) ", "generated_code": "def is_num_keith(num):\n    digits = list(map(int, str(num)))\n    num_digits = len(digits)\n    sum_terms = sum(digits)\n    while sum_terms < num:\n        digits.append(sum_terms)\n        sum_terms = sum(digits[-num_digits:])\n    return sum_terms == num", "score": 1.0, "codebleu": 0.12011096392135129, "crystalbleu": 0, "codebertscore": 0.72, "codescore": 0.959895133972168, "surfaceSim": 0.5249057990993474, "abs_surfaceSim_minus_score": 0.4750942009006526, "source": "local", "local_type": "OP"}
{"id": "LOCAL_PIE_extra_p02691_s021965299_OP_1", "golden_code": "n=int(eval(input()))\n\na=list(map(int,input().split()))\n\nk=[]\n\nans=0\n\nfor i in range(400005):\n\n  k.append(0)\n\nfor i in range(n):\n\n  if i-a[i]>=0:\n\n    ans+=k[i-a[i]]\n\n  if a[i]+i<400005:\n\n    k[a[i]+i]+=1\n\nprint(ans)", "generated_code": "n=int(eval(input()))\n\na=list(map(int,input().split()))\n\nthing={}\n\nans=0\n\nfor i in range(n):\n\n  if i-a[i] in thing:\n\n    ans+=thing[i-a[i]]\n\n  if i+a[i] in thing:\n\n    thing[i+a[i]]+=1\n\n  else:\n\n    thing[i+a[i]]=1\n\nprint(ans)", "score": 1.0, "codebleu": 0.4326889907774145, "crystalbleu": 0.54, "codebertscore": 0.9, "codescore": 0.17711417376995087, "surfaceSim": 0.7135265700483091, "abs_surfaceSim_minus_score": 0.2864734299516909, "source": "local", "local_type": "OP"}
{"id": "MBPP_376_1", "golden_code": "def unique_sublists(list1):\r\n    result ={}\r\n    for l in list1: \r\n        result.setdefault(tuple(l), list()).append(1) \r\n    for a, b in result.items(): \r\n        result[a] = sum(b)\r\n    return result", "generated_code": "def unique_sublists(foo):\n\tresult = []\n\tfor elem in foo:\n\t\tresult.append(elem)\n\treturn result", "score": 0.0, "codebleu": 0.16616021125503933, "crystalbleu": 0, "codebertscore": 0.8, "codescore": 0.018955128267407417, "surfaceSim": 0.6416102136529442, "abs_surfaceSim_minus_score": 0.6416102136529442, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-2599_64", "golden_code": "def digitsum(n):\n    s = 0\n    while(n):\n        s+=n%10\n        n//=10\n    return s\nfor nitish in range(int(input())):\n    ans = 10**30\n    str_arr = input().split(' ')\n    arr = [int(num) for num in str_arr]\n    n = arr[0]\n    k = arr[1]\n    for lastdigit in range(10):\n        for numberofnine in range(100):\n            if(numberofnine*9+lastdigit>n):\n                break\n            s = \"\"\n            for x in range(numberofnine):\n                s+='9'\n            s+=str(lastdigit)\n            xx = int(s)\n            done = 0\n            for j in range(k+1):\n                done+=digitsum(xx+j)\n            # print(done)\n            done-=max(0,k+1-(10-lastdigit))\n            # print(done,xx)           \n            if(done>n):\n                continue\n            for aurek in range(9):\n                p = min(k+1,10-lastdigit)\n                ddone = done + aurek*p + (aurek+1)*(k+1-p)\n                # print(aurek,ddone)\n                if(ddone>n):\n                    continue\n                if(ddone==n):\n                    if(aurek>0):\n                        s = str(aurek)+s\n                        ans = min(ans,int(s))\n                    else:\n                        ans = min(ans,int(s))\n                    continue\n                ddone = n-ddone\n                if(ddone%(k+1)!=0):\n                    continue\n                ddone//=(k+1)\n                t = ddone%9\n                ss=\"\"\n                if(t):\n                    ss+=str(t)\n                for jj in range(ddone//9):\n                    ss+=\"9\"\n                if(len(ss)>0):\n                    ss+=str(aurek)\n                if(len(ss)==0):\n                    ans = min(ans,xx)\n                else:\n                    ss+=s\n                    ans=min(ans,int(ss))\n    if(ans==10**30):\n        ans=-1\n    print(ans)\n\n\n\n\n", "generated_code": "for _ in range(int(input())):\n\tn, k = list(map(int, input().split()))\n\tif n < 10:\n\t\tprint(n)\n\t\tcontinue\n\tans = 0\n\ttmp = n\n\tfor i in range(k):\n\t\ttmp = tmp + (n % 10)\n\t\tn = n // 10\n\tif tmp == 0:\n\t\tprint(-1)\n\t\tcontinue\n\n\tans = 9 * tmp\n\tif ans + k!= n:\n\t\tans = min(ans, n - ans + k)\n\tprint(ans)\n", "score": 0.3986, "codebleu": 0.09846789273209466, "crystalbleu": 0.02, "codebertscore": 0.73, "codescore": 0.3158535659313202, "surfaceSim": 0.6086425079091171, "abs_surfaceSim_minus_score": 0.2100425079091171, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-3985_19", "golden_code": "def g(i):\n    u[i] = 0\n    for j in p[i]:\n        if v[j] < 0 or u[v[j]] and g(v[j]):\n            v[j] = i\n            return 1\n    return 0\n\nf = lambda: map(int, input().split())\nn, m = f()\ns = k = 0\nd = [[]]\nfor i in f():\n    j = 2\n    t = []\n    while j * j <= i:\n        while i % j == 0:\n            t.append((j, k))\n            k += 1\n            i //= j\n        j += 1\n    if i > 1:\n        t.append((i, k))\n        k += 1\n    d.append(t)\np = [[] for i in range(k)]\nfor q in range(m):\n    a, b = f()\n    if b % 2: a, b = b, a\n    for x, i in d[a]:\n        for y, j in d[b]:\n            if x == y: p[i].append(j)\nv = [-1] * k\nfor i in range(k):\n    u = [1] * k\n    s += g(i)\nprint(s)", "generated_code": "#!/usr/bin/env python3\n\nfrom sys import stdin, stdout\n\ndef main():\n\tn, m = list(map(int, input().split()))\n\ta = list(map (int, input().strip().split()))[:n]\n\t\n\tbest = [0, 0]\n\tfor i in range(len(a)):\n\t\tfor j in range(i+1, len(a)):best = max(best, (a[i]*a[j]/(j-i)))\n\n\tm = 0\n\tfor i, j in list(enumerate(a)):m = max(m, best[0] + i + j)\n\tprint(m)\n\ndef __starting_point():\n\tmain()\n\n__starting_point()\n", "score": 0.0, "codebleu": 0.1446025358233909, "crystalbleu": 0.08, "codebertscore": 0.73, "codescore": 0.3146839141845703, "surfaceSim": 0.4873169283546642, "abs_surfaceSim_minus_score": 0.4873169283546642, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_4490_74_MUT_1", "golden_code": "b = input()\n\nif b == 'A':\n    print('T')\nelif b == 'T':\n    print('A')\nelif b == 'C':\n    print('G')\nelse:\n    print('C')", "generated_code": "b = input()\n\nif not (b == 'A'):\n    print('T')\nelif b == 'T':\n    print('A')\nelif b == 'C':\n    print('G')\nelse:\n    print('C')", "score": 0.0, "codebleu": 0.857445603305024, "crystalbleu": 0, "codebertscore": 0.98, "codescore": 0.8279958963394165, "surfaceSim": 0.9033918837068443, "abs_surfaceSim_minus_score": 0.9033918837068443, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-1096_9", "golden_code": "s = input()\n\nboundary = ['1','8','a','h']\n\nans = 8 - 3 * (s[0] in boundary) - 3 * (s[1] in boundary) + (s[1] in boundary) * (s[0] in boundary)\n\nprint(ans)", "generated_code": "def main():\n\tcol = \"abcdefgh\"\n\trow = \"12345678\"\n\tpos = [col.index(c) for c in col]\n\theight = [row.index(d) for d in row]\n\tanswer = 0\n\tfor h in range(8):\n\t\tfor p in pos[:h]+pos[h+1:]:\n\t\t\tanswer += abs(p-h)\n\tprint(answer)\n\ndef __starting_point():\n\tmain()\n__starting_point()\n", "score": 0.0, "codebleu": 0.13168937103334494, "crystalbleu": 0, "codebertscore": 0.7, "codescore": 0.04468054696917534, "surfaceSim": 0.39992647058823527, "abs_surfaceSim_minus_score": 0.39992647058823527, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_35_MUT_6", "golden_code": "import os\n\ndef max_element(l: list):\n    m = l[0]\n    for e in l:\n        if e > m:\n            m = e\n    return m", "generated_code": "import os\n\ndef max_element(l: list):\n    m = l[0]\n    for e in l:\n        if e < m:\n            m = e\n    return m", "score": 0.3105, "codebleu": 0.9342299930501614, "crystalbleu": 0, "codebertscore": 1.0, "codescore": 0.9938241243362427, "surfaceSim": 0.9429824561403508, "abs_surfaceSim_minus_score": 0.6324824561403508, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_MBPP_453_MUT_41", "golden_code": "import os\n\nimport math\ndef sumofFactors(n):\n    if n % 2 != 0:\n        return 0\n    res = 1\n    for i in range(2, int(math.sqrt(n)) + 1):\n        count = 0\n        curr_sum = 1\n        curr_term = 1\n        while n % i == 0:\n            count = count + 1\n            n = n // i\n            if (i == 2 and count == 1):\n                curr_sum = 0\n            curr_term = curr_term * i\n            curr_sum = curr_sum + curr_term\n        res = res * curr_sum\n    if n >= 2:\n        res = res * (1 + n)\n    return res", "generated_code": "import os\n\nimport math\ndef sumofFactors(n):\n    if n % 2 != 0:\n        return 0\n    res = 1\n    for i in range(2, int(math.sqrt(n)) + 1):\n        count = 0\n        curr_sum = 1\n        curr_term = 1\n        while n % i == 0:\n            pass\n            n = n // i\n            if (i == 2 and count == 1):\n                curr_sum = 0\n            curr_term = curr_term * i\n            curr_sum = curr_sum + curr_term\n        res = res * curr_sum\n    if n >= 2:\n        res = res * (1 + n)\n    return res", "score": 0.3818, "codebleu": 0.9135569876645464, "crystalbleu": 0.92, "codebertscore": 0.99, "codescore": 0.9927874207496643, "surfaceSim": 0.9701372614663542, "abs_surfaceSim_minus_score": 0.5883372614663542, "source": "local", "local_type": "MUT"}
{"id": "MBPP_31_29", "golden_code": "def smallest_multiple(n):\r\n    if (n<=2):\r\n      return n\r\n    i = n * 2\r\n    factors = [number  for number in range(n, 1, -1) if number * 2 > n]\r\n    while True:\r\n        for a in factors:\r\n            if i % a != 0:\r\n                i += n\r\n                break\r\n            if (a == factors[-1] and i % a == 0):\r\n                return i", "generated_code": "def smallest_multiple(n):\n\n\tsmall_number = n\n\twhile n >= small_number:\n\t\tn = n//2\n\t\tsmall_distance = n - 1\n\t\tprint(small_distance)\n\t\tif small_distance < small_number and n-small_distance >= 0:\n\t\t\tsmall_n = n\n\t\t\tsmall__number = small_distance\n\t\t\tprint(str(small_number)+\" is smaller\")\n\treturn small_number", "score": 0.2265, "codebleu": 0.1447083717730826, "crystalbleu": 0, "codebertscore": 0.74, "codescore": 0.1157730296254158, "surfaceSim": 0.4655811081957092, "abs_surfaceSim_minus_score": 0.23908110819570919, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_34_122", "golden_code": "def even_num(x):\r\n  if x%2==0:\r\n     return True\r\n  else:\r\n    return False", "generated_code": "def even_num(n):   \n\t\n\treturn int(n/2)", "score": 0.1194, "codebleu": 0.3062143252693979, "crystalbleu": 0, "codebertscore": 0.8, "codescore": 0.11110668629407883, "surfaceSim": 0.5933333333333333, "abs_surfaceSim_minus_score": 0.47393333333333326, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0001_19", "golden_code": "a=int(input())\nif(a//10==0):\n    print(a)\n    return\nk=9\nwhile(k<a):\n    k=k*10+9\nif(k==a):\n    print(k)\nelse:\n    k//=10\n    k=int(str(a)[0]+str(k))\n    i=len(str(k))-1\n    z=k\n    while(z>a):\n        z=int(str(k)[0:i]+str(int(str(k)[i])-1)+str(k)[i+1:len(str(k))])\n        i-=1\n    print(z)    ", "generated_code": "n=int(input())\n\n#econmanipaction of size N\nmax_sum=0\nans=0\nconvert=[]\nwhile n>0:\n\tnum=n%10\n\tn=n//10\n\tconvert.append(num)\n\tmax_sum=max(max_sum,sum(convert))\n\tfor i in range(10):\n\t\tif sum(convert[:i+1])>max_sum:\n\t\t\tans=i+1\n\t\t\tmax_sum=sum(convert[i+1:])\n\t\t\tbreak\nprint(ans)\n\n", "score": 0.0, "codebleu": 0.15171333824613117, "crystalbleu": 0.04, "codebertscore": 0.74, "codescore": 0.0507277175784111, "surfaceSim": 0.49411696178937553, "abs_surfaceSim_minus_score": 0.49411696178937553, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0501_16", "golden_code": "l, r = list(map(int, input().split()))\nl -= 1\nif l == 0:\n    ar1 = []\nelse:\n    ar1 = [1]\nsum1 = 1\nwhile sum1 < l:\n    if sum1 + ar1[-1] * 2 <= l:\n        sum1 += ar1[-1] * 2\n        ar1.append(ar1[-1] * 2)\n    else:\n        ar1.append(l - sum1)\n        sum1 = l\n\nar2 = [1]\nsum2 = 1\nwhile sum2 < r:\n    if sum2 + ar2[-1] * 2 <= r:\n        sum2 += ar2[-1] * 2\n        ar2.append(ar2[-1] * 2)\n    else:\n        ar2.append(r - sum2)\n        sum2 = r\n\nsum1_odd = sum(ar1[::2])\nsum1_even = sum(ar1[1::2])\nsum2_odd = sum(ar2[::2])\nsum2_even = sum(ar2[1::2])\np = 10 ** 9 + 7\nprint((sum2_odd ** 2 + sum2_even ** 2 + sum2_even - sum1_odd ** 2 - sum1_even ** 2 - sum1_even) % p)\n", "generated_code": "a,b=map(int,input().split())\nn=int((a+b-1)**0.5)\nprint(n*(n+1)//2-max(n,0)+n+1)\n", "score": 0.019, "codebleu": 0.058285540493569696, "crystalbleu": 0.01, "codebertscore": 0.67, "codescore": 0.04877080023288727, "surfaceSim": 0.43086696562032883, "abs_surfaceSim_minus_score": 0.4118669656203288, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_extra_p03399_s852784971_OP_1", "golden_code": "a, b, c, d = int(eval(input())), int(eval(input())), int(eval(input())), int(eval(input())),\n\nprint((min(a, b)+min(c, d)))", "generated_code": "print((min(int(eval(input())), int(eval(input()))) + min(int(eval(input())), int(eval(input())))))", "score": 1.0, "codebleu": 0.28289473684210525, "crystalbleu": 0, "codebertscore": 0.87, "codescore": 0.918718695640564, "surfaceSim": 0.6778688524590164, "abs_surfaceSim_minus_score": 0.3221311475409836, "source": "local", "local_type": "OP"}
{"id": "LOCAL_MBPP_453_MUT_8", "golden_code": "import os\n\nimport math\ndef sumofFactors(n):\n    if n % 2 != 0:\n        return 0\n    res = 1\n    for i in range(2, int(math.sqrt(n)) + 1):\n        count = 0\n        curr_sum = 1\n        curr_term = 1\n        while n % i == 0:\n            count = count + 1\n            n = n // i\n            if (i == 2 and count == 1):\n                curr_sum = 0\n            curr_term = curr_term * i\n            curr_sum = curr_sum + curr_term\n        res = res * curr_sum\n    if n >= 2:\n        res = res * (1 + n)\n    return res", "generated_code": "import os\n\nimport math\ndef sumofFactors(n):\n    if n % 2 != 0:\n        return 0\n    res = 1\n    for i in range(2, int(math.sqrt(n)) + 1):\n        count = 0\n        curr_sum = 1\n        curr_term = 1\n        while n % i == 0:\n            count = count + 1\n            n = n // i\n            if (i == 2 and count == 1):\n                curr_sum = 0\n            curr_term = curr_term // i\n            curr_sum = curr_sum + curr_term\n        res = res * curr_sum\n    if n >= 2:\n        res = res * (1 + n)\n    return res", "score": 0.3858, "codebleu": 0.9856633619349873, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.9936404824256897, "surfaceSim": 0.998062015503876, "abs_surfaceSim_minus_score": 0.612262015503876, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_PIE_extra_p03854_s146499990_OP_1", "golden_code": "s = eval(input())\n\nt = \"\"\n\nwhile len(t) < len(s):\n\n    target_len = len(s) - len(t)\n\n\n\n    if s[len(t)] == 'd':\n\n        if target_len == 5:\n\n            t += \"dream\"\n\n        elif target_len == 7:\n\n            t += \"dreamer\"\n\n        elif target_len > 7:\n\n            if s[len(t) + 5] != 'd' and s[len(t) + 5:len(t) + 7 + 1] != \"era\":\n\n                t += \"dreamer\"\n\n            else:\n\n                t += \"dream\"\n\n        else:\n\n            break\n\n    else:\n\n        if target_len == 5:\n\n            t += \"erase\"\n\n        elif target_len == 6:\n\n            t += \"eraser\"\n\n        elif target_len > 6:\n\n            if s[len(t) + 5] != 'd' and s[len(t) + 5:len(t) + 6 + 2] != \"era\":\n\n                t += \"eraser\"\n\n            else:\n\n                t += \"erase\"\n\n        else:\n\n            break\n\n\n\n    if s[0:len(t)] != t:\n\n        break\n\n\n\nprint((\"YES\" if s == t else \"NO\"))\n", "generated_code": "s = eval(input())\n\ndiv = [\"dream\", \"dreamer\", \"erase\", \"eraser\"]\n\nrev = []\n\nt = \"\"\n\ns_rev = s[::-1]\n\nfor d in div:\n\n    rev.append(d[::-1])\n\n\n\nresult = True\n\ni = 0\n\nwhile i < len(s):\n\n    can_divide = False\n\n    for d in rev:\n\n        if len(s_rev) - i >= len(d) and s_rev[i:i + len(d)] == d:\n\n            can_divide = True\n\n            i += len(d)\n\n            break\n\n    if not can_divide:\n\n        result = False\n\n        break\n\n\n\nprint((\"YES\" if result else \"NO\"))\n", "score": 1.0, "codebleu": 0.13097392765847998, "crystalbleu": 0.11, "codebertscore": 0.75, "codescore": 0.9939033389091492, "surfaceSim": 0.6535984848484848, "abs_surfaceSim_minus_score": 0.3464015151515152, "source": "local", "local_type": "OP"}
{"id": "LOCAL_MBPP_289_MUT_2", "golden_code": "import os\n\ndef odd_Days(N):\n    hund1 = N // 100\n    hund4 = N // 400\n    leap = N >> 2\n    ordd = N - leap\n    if hund1:\n        ordd += hund1\n        leap -= hund1\n    if hund4:\n        ordd -= hund4\n        leap += hund4\n    days = ordd + (leap * 2)\n    odd = days % 7\n    return odd", "generated_code": "import os\n\ndef odd_Days(N):\n    hund1 = N * 100\n    hund4 = N // 400\n    leap = N >> 2\n    ordd = N - leap\n    if hund1:\n        ordd += hund1\n        leap -= hund1\n    if hund4:\n        ordd -= hund4\n        leap += hund4\n    days = ordd + (leap * 2)\n    odd = days % 7\n    return odd", "score": 0.1905, "codebleu": 0.9761243903408761, "crystalbleu": 0, "codebertscore": 1.0, "codescore": 0.9937333464622498, "surfaceSim": 0.9965034965034965, "abs_surfaceSim_minus_score": 0.8060034965034965, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_APPS_47_12_MUT_6", "golden_code": "(n, x) = map(int, input().split())\nA = list(map(int, input().split()))\nDP = [[0] * 3 for _ in range(n + 1)]\nans = 0\nfor i in range(1, n + 1):\n    DP[i][0] = max(DP[i - 1][0] + A[i - 1], A[i - 1])\n    DP[i][1] = max(DP[i - 1][0] + (A[i - 1] * x), DP[i - 1][1] + (A[i - 1] * x), A[i - 1] * x)\n    DP[i][2] = max(DP[i - 1][1] + A[i - 1], DP[i - 1][2] + A[i - 1], A[i - 1])\n    ans = max(ans, max(DP[i]))\nprint(ans)", "generated_code": "(n, x) = map(int, input().split())\nA = list(map(int, input().split()))\nDP = [[0] * 3 for _ in range(n + 1)]\nans = 0\nfor i in range(1, n + 1):\n    DP[i][0] = max(DP[i + 1][0] + A[i - 1], A[i - 1])\n    DP[i][1] = max(DP[i - 1][0] + (A[i - 1] * x), DP[i - 1][1] + (A[i - 1] * x), A[i - 1] * x)\n    DP[i][2] = max(DP[i - 1][1] + A[i - 1], DP[i - 1][2] + A[i - 1], A[i - 1])\n    ans = max(ans, max(DP[i]))\nprint(ans)", "score": 0.0, "codebleu": 0.9860116946342178, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9938513040542603, "surfaceSim": 0.9987834549878345, "abs_surfaceSim_minus_score": 0.9987834549878345, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-1329_26", "golden_code": "def fact(A):\n    c0 = A\n    r = 2\n    lis = []\n    count = 1\n    while A != 1:\n        if A%r == 0:\n            A = A//r\n            lis.append(r)\n            r = 2\n        else:\n            r += 1\n        if r > int(pow(c0,0.5))+1:\n            lis.append(A)\n            break\n    return(lis)\nn = int(input())\nlis = []\nfor i in range(2,n+1):\n    lis.extend(fact(i))\nlis = sorted(lis)\nL = set(lis)\nimport collections\nc = collections.Counter(lis)\nx = [0,0,0,0,0]\nfor R in L:\n    if c[R] >= 2:\n        x[0] += 1\n    if c[R] >= 4:\n        x[1] += 1\n    if c[R] >= 14:\n        x[2] += 1\n    if c[R] >= 24:\n        x[3] += 1\n    if c[R] >= 74:\n        x[4] += 1\nans = max((x[0]-2)*(x[1]-1)*x[1]//2, 0) + max((x[1]-1)*x[2], 0) + max((x[0]-1)*x[3], 0) + x[4]\nprint(ans)", "generated_code": "import sys\ninput = sys.stdin.readline\n\ndef main():\n\tn = int(input())\n\tans = 0\n\tfor i in range(n,0,-1):\n\t\ttemp = 0\n\t\tshdf = i\n\t\tfor j in range(1,int(n**0.5)+1):\n\t\t\tif n%j == 0:\n\t\t\t\ttemp += 1\n\t\t\t\tif n//j!= j:\n\t\t\t\t\ttemp += 1\n\t\tif temp >= 3:\n\t\t\tans += 1\n\tprint(ans)\n\nmain()\n", "score": 0.0958, "codebleu": 0.10374376523721024, "crystalbleu": 0.03, "codebertscore": 0.72, "codescore": 0.10094799846410751, "surfaceSim": 0.5713676883190681, "abs_surfaceSim_minus_score": 0.47556768831906815, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_34_33", "golden_code": "def even_num(x):\r\n  if x%2==0:\r\n     return True\r\n  else:\r\n    return False", "generated_code": "def even_num(x):\n\tif x%2 == 0:\n\t\treturn True\n\telse:\n\t\t0\n\treturn False\nhonestly_dig_dig = [0, 1, 1, 2, 3, 3, 4, 5, 6, 7, 8, 9, 10, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313]", "score": 1.0, "codebleu": 0.43786270747631106, "crystalbleu": 0, "codebertscore": 0.67, "codescore": 0.9937578439712524, "surfaceSim": 0.5547245793182798, "abs_surfaceSim_minus_score": 0.4452754206817202, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_16_4", "golden_code": "def div_of_nums(nums,m,n):\r\n result = list(filter(lambda x: (x % m == 0 and x % n == 0), nums)) \r\n return result", "generated_code": "def div_of_nums(nums,m,n):\n\treturn [x for x in nums if x%m == 0 and x%n == 0]", "score": 1.0, "codebleu": 0.2145498400818937, "crystalbleu": 0, "codebertscore": 0.9, "codescore": 0.993678867816925, "surfaceSim": 0.6785714285714286, "abs_surfaceSim_minus_score": 0.3214285714285714, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_MBPP_783_MUT_44", "golden_code": "import os\n\ndef rgb_to_hsv(r, g, b):\n    (r, g, b) = (r / 255.0, g / 255.0, b / 255.0)\n    mx = max(r, g, b)\n    mn = min(r, g, b)\n    df = mx - mn\n    if mx == mn:\n        h = 0\n    elif mx == r:\n        h = ((60 * ((g - b) / df)) + 360) % 360\n    elif mx == g:\n        h = ((60 * ((b - r) / df)) + 120) % 360\n    elif mx == b:\n        h = ((60 * ((r - g) / df)) + 240) % 360\n    if mx == 0:\n        s = 0\n    else:\n        s = (df / mx) * 100\n    v = mx * 100\n    return (h, s, v)", "generated_code": "import os\n\ndef rgb_to_hsv(r, g, b):\n    (r, g, b) = (r / 255.0, g / 255.0, b / 255.0)\n    mx = max(r, g, b)\n    mn = min(r, g, b)\n    df = mx - mn\n    if mx == mn:\n        h = 0\n    elif mx == r:\n        h = ((60 * ((g - b) / df)) + 360) % 360\n    elif mx == g:\n        h = ((60 * ((b - r) / df)) + 120) % 360\n    elif mx == b:\n        h = ((60 * ((r - g) / df)) + 240) % 360\n    if not (mx == 0):\n        s = 0\n    else:\n        s = (df / mx) * 100\n    v = mx * 100\n    return (h, s, v)", "score": 0.0438, "codebleu": 0.9681123985308897, "crystalbleu": 0.95, "codebertscore": 0.99, "codescore": 0.9937028288841248, "surfaceSim": 0.9548665297741273, "abs_surfaceSim_minus_score": 0.9110665297741274, "source": "local", "local_type": "MUT"}
{"id": "MBPP_51_10", "golden_code": "def binomial_coeffi(n, k): \r\n\tif (k == 0 or k == n): \r\n\t\treturn 1\r\n\treturn (binomial_coeffi(n - 1, k - 1) \r\n\t\t+ binomial_coeffi(n - 1, k)) \r\ndef rencontres_number(n, m): \r\n\tif (n == 0 and m == 0): \r\n\t\treturn 1\r\n\tif (n == 1 and m == 0): \r\n\t\treturn 0\r\n\tif (m == 0): \r\n\t\treturn ((n - 1) * (rencontres_number(n - 1, 0)+ rencontres_number(n - 2, 0))) \r\n\treturn (binomial_coeffi(n, m) * rencontres_number(n - m, 0))", "generated_code": "def rencontres_number(x, y):\n\treturn x*y", "score": 0.0643, "codebleu": 0.045114666347856304, "crystalbleu": 0, "codebertscore": 0.68, "codescore": 0.023356568068265915, "surfaceSim": 0.3945438167546004, "abs_surfaceSim_minus_score": 0.33024381675460035, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_34_39", "golden_code": "def even_num(x):\r\n  if x%2==0:\r\n     return True\r\n  else:\r\n    return False", "generated_code": "def even_num(x):\n\t    \n\t   \n\t\n\treturn 0 if x is 0 else x % 10 == 0", "score": 0.5645, "codebleu": 0.3368887286017174, "crystalbleu": 0, "codebertscore": 0.84, "codescore": 0.6235420107841492, "surfaceSim": 0.7, "abs_surfaceSim_minus_score": 0.13549999999999995, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_1576_10_OP_1", "golden_code": "s = input()\nif len(s) % 2 == 0:\n    st = ''\n    for i in range(len(s) // 2):\n        st += s[len(s) - 1 - i] + s[i]\n    print(st[::-1])\nelse:\n    st = ''\n    for i in range(len(s) // 2):\n        st += s[i] + s[len(s) - 1 - i]\n    st += s[len(s) // 2]\n    print(st[::-1])", "generated_code": "u = input()\nv = len(u)\nw = [None] * v\nfor x in range(v // 2):\n    w[x], w[v - 1 - x] = u[v - 1 - x], u[x]\nif v % 2 != 0:\n    w[v // 2] = u[v // 2]\nprint(''.join(w))", "score": 0.9385, "codebleu": 0.16316532389373617, "crystalbleu": 0.09, "codebertscore": 0.81, "codescore": 0.7995894551277161, "surfaceSim": 0.572089947089947, "abs_surfaceSim_minus_score": 0.366410052910053, "source": "local", "local_type": "OP"}
{"id": "LOCAL_HE_44_OP_2", "golden_code": "def change_base(x: int, base: int):\n    ret = \"\"\n    while x > 0:\n        ret = str(x % base) + ret\n        x //= base\n    return ret", "generated_code": "def change_base(num: int, radix: int):\n    if num == 0:\n        return '0'\n    digits = []\n    while num > 0:\n        digits.append(str(num % radix))\n        num //= radix\n    return ''.join(reversed(digits))", "score": 0.9014, "codebleu": 0.3263968632344809, "crystalbleu": 0, "codebertscore": 0.82, "codescore": 0.846589207649231, "surfaceSim": 0.6658653846153846, "abs_surfaceSim_minus_score": 0.2355346153846154, "source": "local", "local_type": "OP"}
{"id": "MBPP_72_49", "golden_code": "def Average(lst): \r\n    return sum(lst) / len(lst) ", "generated_code": "def Average(lst):\n\treturn sum(lst) / len(lst)", "score": 1.0, "codebleu": 1.0, "crystalbleu": 0, "codebertscore": 0.97, "codescore": 0.9937551021575928, "surfaceSim": 1.0, "abs_surfaceSim_minus_score": 0.0, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0671_47", "golden_code": "#!/usr/bin/env python3\n\n\ndef main():\n    n = int(input())\n    print(''.join(map(str, list(range(0, 1000))))[n])\n\ndef __starting_point():\n    main()\n\n__starting_point()", "generated_code": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\nimport time\nimport sys\nfrom bisect import bisect_left\n\n# start_time = time.time()\n\ndef main():\n\tN = int(sys.stdin.readline())\n\ti = 1\n\tout = sys.stdout.write(\"\\n\")\n\t\n\twhile i < N:\n\t\tsys.stdout.flush()\n\t\t# read the line\n\t\tS = sys.stdin.buffer.readline\n\t\tN = int(S())\n\t\t\n\t\t# process line\n\t\tSs = S()\n\t\tSs  = Ss[:-1]\n\t\tT = [int(Ss[i]) for i in range(0, N)]\n\t\tT.sort()\n\t\tprint(T[-1])\n\t\ti += 1", "score": 0.0, "codebleu": 0.29223790445227843, "crystalbleu": 0, "codebertscore": 0.71, "codescore": 0.03149842843413353, "surfaceSim": 0.5138248847926268, "abs_surfaceSim_minus_score": 0.5138248847926268, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-4183_45", "golden_code": "import math\ndef lcm(a, b): return a * b // math.gcd(a, b)\n\nn = int(input())\n\nif n == 1:\n    print(input())\n\nelif n == 2:\n    a = int(input())\n    b = int(input())\n    print(lcm(a,b))\nelse:\n    a = int(input())\n    b = int(input())\n    ans = lcm(a,b)\n    for _ in range(n-2):\n        i = int(input())\n        ans = lcm(ans, i)\n    print(ans)", "generated_code": "def main():\n\timport sys\n\tinput = sys.stdin.readline\n\tsys.setrecursionlimit(10**7)\n\t\n\tN = int(input())\n\tT = list(map(int, input().split()))\n\t\n\tif N == 1:\n\t\tprint(0)\n\t\treturn\n\t\n\tT = [0] + T + [N+1]\n\t\n\tdp = [0] * (N+3)\n\tdp[0] = 2\n\tdp[1] = 1\n\tfor i in range(2, N+1):\n\t\tdp[i] = dp[i-1] + 2 * dp[i*2]\n\tprint(dp[N+1])\n\t\nmain()\n", "score": 0.0, "codebleu": 0.2352180731228599, "crystalbleu": 0.06, "codebertscore": 0.76, "codescore": 0.09767401963472366, "surfaceSim": 0.5882352941176471, "abs_surfaceSim_minus_score": 0.5882352941176471, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_73_OP_1", "golden_code": "def smallest_change(arr):\n    ans = 0\n    for i in range(len(arr) // 2):\n        if arr[i] != arr[len(arr) - i - 1]:\n            ans += 1\n    return ans", "generated_code": "def smallest_change(lst):\n    mismatch_count = 0\n    left_index = 0\n    right_index = len(lst) - 1\n    while left_index < right_index:\n        if lst[left_index] != lst[right_index]:\n            mismatch_count += 1\n        left_index += 1\n        right_index -= 1\n    return mismatch_count", "score": 1.0, "codebleu": 0.32090076111994026, "crystalbleu": 0, "codebertscore": 0.8, "codescore": 0.8553184270858765, "surfaceSim": 0.6623414071510958, "abs_surfaceSim_minus_score": 0.3376585928489042, "source": "local", "local_type": "OP"}
{"id": "APPS_test-1698_14", "golden_code": "N, K = map(int, input().split())\nF = list(reversed(sorted(map(int, input().split()))))\nres = 0\nfor i in range((N+K-1)//K):\n\tres += 2 * (F[i*K]-1)\nprint(res)", "generated_code": "n, k = list(map(int, input().split()))\nf = list(map (int, input().strip().split()))[:n]\ntime = []\nfor i in range(n):\n\ttime.append(f[i] - f[i-1])\ntime.sort()\ntime = time[::-1]\n#print(time)\nl, r = 0, 0\nif len(time) > 1:\n\twhile r < len(time):\n\t\tr += 1\n\t\tif time[r-1] > time[r]:\n\t\t\tl = r\n\t\telif time[r - 1] < time[r]:   \n\t\t\tif len(time)-time[r-1]-1 > l:\n\t\t\t\tl = time[r- 1]-time[r]-1\nprint(l)\n", "score": 0.0, "codebleu": 0.24907427735459692, "crystalbleu": 0.11, "codebertscore": 0.78, "codescore": 0.06134820356965065, "surfaceSim": 0.5097569955817378, "abs_surfaceSim_minus_score": 0.5097569955817378, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-4188_63", "golden_code": "a = [1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0]\nn = int(input())\nprint(a[n - 1])", "generated_code": "#!/usr/bin/env python3\nfrom collections import defaultdict\nfrom math import sqrt\n\ndef isOfpossible(l, k):\n\tif len(l) < k: return False\n\td = defaultdict(list)\n\tfor i in range(k):\n\t\tif i < len(l):\n\t\t\td[l[i]].append(i)\n\tif not d:\n\t\treturn True\n\tmaxD = max(d)\n\tfor l in d:\n\t\tif len(l)*8 in d[l]:\n\t\t\tmaxD = max (maxD, sqrt(l * 8))\n\treturn maxD >= 1\n\ndef main():\n\tisOfPossible = lambda l, k: isOfPossible(l, K) and len(l) >= k\n\thead = ('Set' * 2) +'' + 'List' * 3", "score": 0.0, "codebleu": 0.07650255012366032, "crystalbleu": 0, "codebertscore": 0.61, "codescore": 0.018825171515345573, "surfaceSim": 0.3099927060539752, "abs_surfaceSim_minus_score": 0.3099927060539752, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_68_MUT_6", "golden_code": "import os\n\ndef pluck(arr):\n    if len(arr) == 0:\n        return []\n    evens = list(filter((lambda x: (x % 2 == 0)), arr))\n    if evens == []:\n        return []\n    return [min(evens), arr.index(min(evens))]", "generated_code": "import os\n\ndef pluck(arr):\n    if len(arr) != 0:\n        return []\n    evens = list(filter((lambda x: (x % 2 == 0)), arr))\n    if evens == []:\n        return []\n    return [min(evens), arr.index(min(evens))]", "score": 0.1064, "codebleu": 0.9540808774126313, "crystalbleu": 0, "codebertscore": 0.99, "codescore": 0.9934874773025513, "surfaceSim": 0.9748572683355292, "abs_surfaceSim_minus_score": 0.8684572683355292, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_HE_58_OP_1", "golden_code": "def common(l1: list, l2: list):\n    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))", "generated_code": "def common(first_list: list, second_list: list):\n    first_set = set(first_list)\n    second_set = set(second_list)\n    intersection = first_set & second_set\n    return sorted(intersection)", "score": 1.0, "codebleu": 0.2247681958989266, "crystalbleu": 0, "codebertscore": 0.81, "codescore": 0.9713040590286255, "surfaceSim": 0.5304373522458629, "abs_surfaceSim_minus_score": 0.46956264775413714, "source": "local", "local_type": "OP"}
{"id": "APPS_test-0351_24", "golden_code": "n, k = map(int, input().split())\na = list(map(int, input().split()))\na.sort()\n\nresult = 0\n\nfor d in a:\n\twhile d > 2*k:\n\t\tk *= 2\n\t\tresult += 1\n\tk = max(d, k)\n\nprint(result)", "generated_code": "n, k = list(map(int, input().split()))\na = list(map (int, input().strip().split()))[:n]\ns = sum(a)\nif s <= k:\n\tprint(s)\nelse:\n\ta.sort()\n\tig = a[s-1]\n\tb = a[s//2]\n\tc = 0\n\tfor i in range(n):\n\t\tif a[i] >= b:\n\t\t\tc += 1\n\t\tif a [i] <= c:\n\t\t\tc = 0\n\t\t\tig += 1\n\tprint(ig)\n", "score": 0.0, "codebleu": 0.32999764150048283, "crystalbleu": 0.16, "codebertscore": 0.82, "codescore": 0.05890148505568504, "surfaceSim": 0.5717315004387248, "abs_surfaceSim_minus_score": 0.5717315004387248, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_131_MUT_6", "golden_code": "import os\n\ndef digits(n):\n    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit % 2 == 1:\n            product = product * int_digit\n            odd_count += 1\n    if odd_count == 0:\n        return 0\n    else:\n        return product", "generated_code": "import os\n\ndef digits(n):\n    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if not (int_digit % 2 == 1):\n            product = product * int_digit\n            odd_count += 1\n    if odd_count == 0:\n        return 0\n    else:\n        return product", "score": 0.0751, "codebleu": 0.8847058533715693, "crystalbleu": 0, "codebertscore": 0.99, "codescore": 0.9935816526412964, "surfaceSim": 0.9498299319727891, "abs_surfaceSim_minus_score": 0.874729931972789, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_PIE_p03253_s213127805_MUT_3", "golden_code": "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nMOD = (10 ** 9) + 7\nfac = [1, 1]\nf_inv = [1, 1]\ninv = [0, 1]\ndef prepare(n, mod):\n    for i in range(2, n + 1):\n        fac.append((fac[-1] * i) % mod)\ndef cmb(n, r, mod):\n    if (n < 0 or r < 0):\n        return 0\n    if r > n:\n        return 0\n    return ((fac[n] * pow(fac[r], MOD - 2, MOD)) * pow(fac[n - r], MOD - 2, MOD)) % mod\ndef prime_factorization(n):\n    d = []\n    (i, e) = (2, 0)\n    while i * i <= n:\n        while n % i == 0:\n            n //= i\n            e += 1\n        if e > 0:\n            d.append((i, e))\n        i += 1\n        e = 0\n    if n > 1:\n        d.append((n, 1))\n    return d\ndef main():\n    (N, M) = list(map(int, readline().split()))\n    prepare(N + 100, MOD)\n    d = prime_factorization(M)\n    ans = 1\n    for (i, e) in d:\n        ans *= cmb((N - 1) + e, e, MOD)\n        ans %= MOD\n    print(ans)", "generated_code": "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nMOD = (10 ** 9) - 7\nfac = [1, 1]\nf_inv = [1, 1]\ninv = [0, 1]\ndef prepare(n, mod):\n    for i in range(2, n + 1):\n        fac.append((fac[-1] * i) % mod)\ndef cmb(n, r, mod):\n    if (n < 0 or r < 0):\n        return 0\n    if r > n:\n        return 0\n    return ((fac[n] * pow(fac[r], MOD - 2, MOD)) * pow(fac[n - r], MOD - 2, MOD)) % mod\ndef prime_factorization(n):\n    d = []\n    (i, e) = (2, 0)\n    while i * i <= n:\n        while n % i == 0:\n            n //= i\n            e += 1\n        if e > 0:\n            d.append((i, e))\n        i += 1\n        e = 0\n    if n > 1:\n        d.append((n, 1))\n    return d\ndef main():\n    (N, M) = list(map(int, readline().split()))\n    prepare(N + 100, MOD)\n    d = prime_factorization(M)\n    ans = 1\n    for (i, e) in d:\n        ans *= cmb((N - 1) + e, e, MOD)\n        ans %= MOD\n    print(ans)", "score": 0.0, "codebleu": 0.9924868895723431, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9937481880187988, "surfaceSim": 0.9994594594594595, "abs_surfaceSim_minus_score": 0.9994594594594595, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-0110_29", "golden_code": "n = int(input())\na = list(map(lambda a: (-int(a) - 1 if int(a) >= 0 else int(a)), input().split()))\n\nb = 1\nfor val in a:\n    if val < 0:\n        b *= -1\n\nif b < 0:\n    i_max = 0\n    for i in range(n):\n        if abs(a[i_max]) < abs(a[i]):\n            i_max = i\n    a[i_max] =  -a[i_max] - 1\n\nprint(\" \".join(map(str, a)))", "generated_code": "n=int(input())\na=list(map(int,input().split()))\nb=[]\nfor i in range(n):b.append(-a[i])\nans=[]\nfor d in range(n-1,0,-1):\n\te=10**6\n\tfor i in range (n-d):\n\t\te=min(e,a[i]*a[i+d])\n\tans.append(e)\nprint(*ans)\n", "score": 0.0, "codebleu": 0.17376430706076476, "crystalbleu": 0.24, "codebertscore": 0.81, "codescore": 0.05798792093992233, "surfaceSim": 0.5567708333333333, "abs_surfaceSim_minus_score": 0.5567708333333333, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0103_21", "golden_code": "n = int(input())\na = [0]\na.extend(list(map(int, input().split())))\na.append(1001)\n\nlongest = 0\ni = 0\n\nwhile i < len(a):\n    j = i + 1\n    while j < len(a) and a[j-1] + 1 == a[j]:\n        j += 1\n    current = j - i - 2\n    longest = max(longest, current)\n    i = j\n\nprint(longest)\n", "generated_code": "n=int(input())\na=list(map(int,input().split()))\nprev=a[0]\ncount=0\nif n%2==0:\n\tfor i in range(1,n):\n\t\tif a[i]<=prev:\n\t\t\tcount+=1\n\t\tprev=a[i]\n\tprint(count)\nelse:\n\tif a[n-1]<=prev and a[n-2]<=prevPlayer:\n\t\tcount=2\n\t\tfor i in range((n-2)//2):\n\t\t\tif a[i+1]<=a[i+2]:\n\t\t\t\tcount+=1\n\t\t\tprevPlayer=a[i2]\n\t\tprint(count) #default you have to one line then+'.\n\telse:\n\t\tprint(0)\n", "score": 0.0086, "codebleu": 0.22299110524543253, "crystalbleu": 0.18, "codebertscore": 0.79, "codescore": 0.1599159985780716, "surfaceSim": 0.5833587011669203, "abs_surfaceSim_minus_score": 0.5747587011669203, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-3924_9", "golden_code": "n, k = map(int, input().split())\nl = [*map(int, input().split())]\nc = 0\nres = 0\nfor i, e in enumerate(l):\n    if (e + c) < k and c > 0:\n        res += int((e + c) > 0)\n        c = 0\n    else:\n        res += (e + c) // k\n        c = (e + c) % k\nif c > 0: res += 1\nprint(res)", "generated_code": "def main():\n\tn, k = list(map(int, input().split()))\n\taa = list(map (int, input().strip().split())) + [0]*(n-1)\n\tm = aa[0]\n\te = 0\n\tfor i in range(n):\n\t\tif aa[i] > m:\n\t\t\te += 1\n\t\tm = min(m, aa[i])\n\tprint(n - e)\n\n\ndef __starting_point():\n\tmain()\n\n__starting_point()\n", "score": 0.0866, "codebleu": 0.20332065047240663, "crystalbleu": 0.14, "codebertscore": 0.79, "codescore": 0.07039910554885864, "surfaceSim": 0.550915750915751, "abs_surfaceSim_minus_score": 0.46431575091575095, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_149_2", "golden_code": "def check_distinct(test_tup):\r\n  res = True\r\n  temp = set()\r\n  for ele in test_tup:\r\n    if ele in temp:\r\n      res = False\r\n      break\r\n    temp.add(ele)\r\n  return (res) ", "generated_code": "def check_distinct(result):\n\tif result:\n\t\treturn f'{result[0]}{ \" \" * bool(result[1])}'\n\telse:\n\t\toutput = [str(item) for item in result]\n\t\treturn \"You have to know you you you you have to empie you are yourself\"", "score": 0.0, "codebleu": 0.09340472024953628, "crystalbleu": 0, "codebertscore": 0.71, "codescore": 0.018743453547358513, "surfaceSim": 0.4037550127597521, "abs_surfaceSim_minus_score": 0.4037550127597521, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_43_75", "golden_code": "def is_Two_Alter(s):  \r\n    for i in range (len( s) - 2) : \r\n        if (s[i] != s[i + 2]) : \r\n            return False\r\n    if (s[0] == s[1]): \r\n        return False\r\n    return True", "generated_code": "def is_Two_Alter(s):  \n\ta=s[0]\n\tb=s[1]\n\tif a=='1' or b=='1':\n\t\treturn True\n\telse:\n\t\treturn False", "score": 0.821, "codebleu": 0.16939386789930677, "crystalbleu": 0, "codebertscore": 0.81, "codescore": 0.9656496047973633, "surfaceSim": 0.6349489189831314, "abs_surfaceSim_minus_score": 0.1860510810168685, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_81_MUT_3", "golden_code": "import os\n\ndef numerical_letter_grade(grades):\n    \n    \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append('A+')\n        elif gpa > 3.7:\n            letter_grade.append('A')\n        elif gpa > 3.3:\n            letter_grade.append('A-')\n        elif gpa > 3.0:\n            letter_grade.append('B+')\n        elif gpa > 2.7:\n            letter_grade.append('B')\n        elif gpa > 2.3:\n            letter_grade.append('B-')\n        elif gpa > 2.0:\n            letter_grade.append('C+')\n        elif gpa > 1.7:\n            letter_grade.append('C')\n        elif gpa > 1.3:\n            letter_grade.append('C-')\n        elif gpa > 1.0:\n            letter_grade.append('D+')\n        elif gpa > 0.7:\n            letter_grade.append('D')\n        elif gpa > 0.0:\n            letter_grade.append('D-')\n        else:\n            letter_grade.append('E')\n    return letter_grade", "generated_code": "import os\n\ndef numerical_letter_grade(grades):\n    \n    \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append('A+')\n        elif gpa > 3.7:\n            letter_grade.append('A')\n        elif not (gpa > 3.3):\n            letter_grade.append('A-')\n        elif gpa > 3.0:\n            letter_grade.append('B+')\n        elif gpa > 2.7:\n            letter_grade.append('B')\n        elif gpa > 2.3:\n            letter_grade.append('B-')\n        elif gpa > 2.0:\n            letter_grade.append('C+')\n        elif gpa > 1.7:\n            letter_grade.append('C')\n        elif gpa > 1.3:\n            letter_grade.append('C-')\n        elif gpa > 1.0:\n            letter_grade.append('D+')\n        elif gpa > 0.7:\n            letter_grade.append('D')\n        elif gpa > 0.0:\n            letter_grade.append('D-')\n        else:\n            letter_grade.append('E')\n    return letter_grade", "score": 0.0476, "codebleu": 0.9553751307305812, "crystalbleu": 0.94, "codebertscore": 0.99, "codescore": 0.9937024116516113, "surfaceSim": 0.9538072983052448, "abs_surfaceSim_minus_score": 0.9062072983052448, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-0174_21", "golden_code": "def f(a):\n    if len(a) == 1:\n        if a[0] == 0:\n            print(\"YES\\n0\")\n            return\n        else:\n            print(\"NO\")\n            return\n    if a[-1] == 1:\n        print(\"NO\")\n        return\n    if a[-2] == 1:\n        print(\"YES\")\n        print(\"->\".join(str(x) for x in a))\n        return\n    elif len(a) == 2:\n        print(\"NO\")\n        return\n    elif len(a) >= 3 and a[-3] == 0:\n        a[-3] = '(0'\n        a[-2] = '0)'\n        print(\"YES\\n\" + \"->\".join(str(x) for x in a))\n        return      \n    for i in range(len(a) - 3, -1, -1):\n        if a[i] == 0:\n            a[i] = '(' + str(a[i])\n            a[i+1] = '(' + str(a[i+1])\n            a[-2] = '0))'\n            print(\"YES\\n\" + \"->\".join(str(x) for x in a))\n            return\n    print(\"NO\")\n    return\n\nn = int(input())\na = list(int(x) for x in input().split())\nf(a)", "generated_code": "n = int(input())\na = list(map(int, input().split()))\n\ntry:\n\twhile True:\n\t\tS = input()\n\t\twhile S!= ')':\n\t\t\tif S[-1] == '(':\n\t\t\t\tS = S[:-1]\n\t\t\telse:\n\t\t\t\tbreak\n\t\tsign = -1\n\t\twhile S.count(')') > 1:\n\t\t\tS = S[1:]\n\t\t\tsign *= -1\n\t\tif S == '':\n\t\t\tprint('NO')\n\t\telse:\n\t\t\tprint ('YES')\n\t\t\tprint(S)\nexcept:\n\tpass\n", "score": 0.0, "codebleu": 0.1478763146943274, "crystalbleu": 0.05, "codebertscore": 0.71, "codescore": 0.0382428839802742, "surfaceSim": 0.4633634992458522, "abs_surfaceSim_minus_score": 0.4633634992458522, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_11_8", "golden_code": "def lcm(x, y):\r\n   if x > y:\r\n       z = x\r\n   else:\r\n       z = y\r\n   while(True):\r\n       if((z % x == 0) and (z % y == 0)):\r\n           lcm = z\r\n           break\r\n       z += 1\r\n   return lcm", "generated_code": "def lcm(x,   y):\n  return int(x) * int(y)", "score": 0.6313, "codebleu": 0.1002509526734275, "crystalbleu": 0, "codebertscore": 0.76, "codescore": 0.28375542163848877, "surfaceSim": 0.47079037800687284, "abs_surfaceSim_minus_score": 0.16050962199312713, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_85_OP_1", "golden_code": "def add(lst):\n    return sum([lst[i] for i in range(1, len(lst), 2) if lst[i]%2 == 0])", "generated_code": "def add(sequence):\n    return sum(value for index, value in enumerate(sequence[1::2], start=1) if value % 2 == 0)", "score": 1.0, "codebleu": 0.20697925706074416, "crystalbleu": 0, "codebertscore": 0.84, "codescore": 0.6882649660110474, "surfaceSim": 0.6114239742558327, "abs_surfaceSim_minus_score": 0.3885760257441673, "source": "local", "local_type": "OP"}
{"id": "LOCAL_PIE_extra_p03416_s286428945_OP_1", "golden_code": "#                         author:  kagemeka \n\n#                         created: 2019-11-06 21:30:22(JST)\n\nimport sys\n\n# import collections\n\n# import math\n\n# import string\n\n# import bisect\n\n# import re\n\n# import itertools\n\n# import statistics\n\n# import functools\n\n# import operator\n\n\n\ndef main():\n\n    a, b = (int(x) for x in sys.stdin.read().split())\n\n\n\n    count = 0\n\n    for n in range(a, b+1):\n\n        n = str(n)\n\n        if n == n[::-1]:\n\n            count += 1\n\n\n\n    print(count)       \n\n\n\nif __name__ == \"__main__\":\n\n    # execute only if run as a script\n\n    main()\n", "generated_code": "import sys\n\nfrom bisect import bisect_left as bi_l, bisect_right as bi_r\n\n\n\na, b = list(map(int, sys.stdin.readline().split()))\n\n\n\ndef main():\n\n    palindromic_nums = []\n\n    for i in range(1, 10):\n\n        for j in range(10):\n\n            for k in range(10):\n\n                x = [i, j, k, j, i]\n\n                palindromic_nums.append(int(''.join(list(map(str, x)))))\n\n\n\n    return bi_r(palindromic_nums, b) - bi_l(palindromic_nums, a)\n\n                \n\nif __name__ == '__main__':\n\n    ans = main()\n\n    print(ans)", "score": 0.537, "codebleu": 0.25678742774840285, "crystalbleu": 0.1, "codebertscore": 0.73, "codescore": 0.022069057449698448, "surfaceSim": 0.5894377240143369, "abs_surfaceSim_minus_score": 0.052437724014336884, "source": "local", "local_type": "OP"}
{"id": "LOCAL_HE_163_OP_2", "golden_code": "def generate_integers(a, b):\n    lower = max(2, min(a, b))\n    upper = min(8, max(a, b))\n\n    return [i for i in range(lower, upper+1) if i % 2 == 0]", "generated_code": "def generate_integers(x, y):\n    start = max(2, min(x, y))\n    end = min(8, max(x, y))\n\n    if start > end:\n        return []\n\n    start += start % 2\n    return list(range(start, end + 1, 2))", "score": 1.0, "codebleu": 0.3546949589092929, "crystalbleu": 0, "codebertscore": 0.87, "codescore": 0.580549418926239, "surfaceSim": 0.6498096144693003, "abs_surfaceSim_minus_score": 0.3501903855306997, "source": "local", "local_type": "OP"}
{"id": "MBPP_40_26", "golden_code": "import datetime\r\ndef check_date(m, d, y):\r\n    try:\r\n        m, d, y = map(int, (m, d, y))\r\n        datetime.date(y, m, d)\r\n        return True\r\n    except ValueError:\r\n        return False", "generated_code": "import datetime\ndef check_date(m, d, y):\n\tif m and d and y > y:\n\t\treturn True\n\telse:\n\t\ty %= -1\n\t\tif y == 0:\n\t\t\treturn True\n\t\telse:\n\t\t\ty = abs(y)\n\t\t\treturn False\nmp = {}", "score": 0.2401, "codebleu": 0.3112499367468783, "crystalbleu": 0, "codebertscore": 0.83, "codescore": 0.515201210975647, "surfaceSim": 0.5521802590768108, "abs_surfaceSim_minus_score": 0.3120802590768108, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_p03371_s026349855_MUT_5", "golden_code": "from collections import defaultdict\nfrom collections import deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\ndef I():\n    return int(sys.stdin.readline())\ndef LS():\n    return list(map(list, sys.stdin.readline().split()))\ndef S():\n    return list(sys.stdin.readline())[:-1]\ndef IR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = I()\n    return l\ndef LIR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = LI()\n    return l\ndef SR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = S()\n    return l\ndef LSR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = LS()\n    return l\nsys.setrecursionlimit(1000000)\nmod = 1000000007\ndef A():\n    return\ndef B():\n    return\ndef C():\n    return\ndef D():\n    return\ndef E():\n    return\ndef F():\n    (a, b, c, X, Y) = LI()\n    ans = float('inf')\n    for z in range(300001):\n        if z % 2 == 0:\n            m = c * z\n            x = z // 2\n            y = z // 2\n            m += a * max(0, X - x)\n            m += b * max(0, Y - y)\n            if m < ans:\n                ans = m\n    print(ans)\n    return\ndef G():\n    n = I()\n    x = LI()\n    f = [(i, x[i]) for i in range(n)]\n    f.sort(key=lambda x: (x[1]))\n    g = [(f[i][0], i) for i in range(n)]\n    g.sort(key=lambda x: (x[0]))\n    for i in range(n):\n        if g[i][1] < n // 2:\n            print(f[n // 2][1])else:print(f[(n // 2) - 1][1])\n    return\ndef H():\n    return\ndef I_():\n    return\ndef J():\n    return", "generated_code": "from collections import defaultdict\nfrom collections import deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\ndef I():\n    return int(sys.stdin.readline())\ndef LS():\n    return list(map(list, sys.stdin.readline().split()))\ndef S():\n    return list(sys.stdin.readline())[:-1]\ndef IR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = I()\n    return l\ndef LIR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = LI()\n    return l\ndef SR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = S()\n    return l\ndef LSR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = LS()\n    return l\nsys.setrecursionlimit(1000000)\nmod = 1000000007\ndef A():\n    return\ndef B():\n    return\ndef C():\n    return\ndef D():\n    return\ndef E():\n    return\ndef F():\n    (a, b, c, X, Y) = LI()\n    ans = float('inf')\n    for z in range(300001):\n        if z % 2 == 0:\n            m = c // z\n            x = z // 2\n            y = z // 2\n            m += a * max(0, X - x)\n            m += b * max(0, Y - y)\n            if m < ans:\n                ans = m\n    print(ans)\n    return\ndef G():\n    n = I()\n    x = LI()\n    f = [(i, x[i]) for i in range(n)]\n    f.sort(key=lambda x: (x[1]))\n    g = [(f[i][0], i) for i in range(n)]\n    g.sort(key=lambda x: (x[0]))\n    for i in range(n):\n        if g[i][1] < n // 2:\n            print(f[n // 2][1])else:print(f[(n // 2) - 1][1])\n    return\ndef H():\n    return\ndef I_():\n    return\ndef J():\n    return", "score": 0.0, "codebleu": 0.9950684650874879, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9932195544242859, "surfaceSim": 0.4993823347745522, "abs_surfaceSim_minus_score": 0.4993823347745522, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_APPS_4638_24_MUT_3", "golden_code": "(n, c) = [int(x) for x in input().split()]\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\ndpst = [0] * (n + 1)\ndplift = [0] * (n + 1)\ndpst[2] = a[0]\ndplift[2] = c + b[0]\nfor i in range(3, n + 1):\n    dpst[i] = a[i - 2] + min(dpst[i - 1], dplift[i - 1])\n    dplift[i] = b[i - 2] + min(c + dpst[i - 1], dplift[i - 1])\n\nfor i in range(1, n + 1):\n    print(min(dpst[i], dplift[i]), end=' ')", "generated_code": "(n, c) = [int(x) for x in input().split()]\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\ndpst = [0] ** (n + 1)\ndplift = [0] * (n + 1)\ndpst[2] = a[0]\ndplift[2] = c + b[0]\nfor i in range(3, n + 1):\n    dpst[i] = a[i - 2] + min(dpst[i - 1], dplift[i - 1])\n    dplift[i] = b[i - 2] + min(c + dpst[i - 1], dplift[i - 1])\n\nfor i in range(1, n + 1):\n    print(min(dpst[i], dplift[i]), end=' ')", "score": 0.0, "codebleu": 0.9844886434075966, "crystalbleu": 0.98, "codebertscore": 0.99, "codescore": 0.9937471151351929, "surfaceSim": 0.9760591350397176, "abs_surfaceSim_minus_score": 0.9760591350397176, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-1195_18", "golden_code": "n = int(input())\narr = list(map(int, input().split()))\nprint(2 + (arr[2] ^ min(arr)))", "generated_code": "def main():\n\tfrom sys import stdin, stdout\n\tinput = stdin.readline\n\tprint = stdout.write\n\tleft = input()\n\tt = tuple(map(int, left.split()))\n\tval = sum(t)\n\tout = \"\"\n\tfor i in range(len(t)):\n\t\tstr = \"\"\n\t\tfor j in range(t[i]):\n\t\t\tstr += \" \"\n\t\tstr = str[::-1]\n\t\twhile str[-1] == \" \":\n\t\t\tstr = str[::-1]\n\t\tif str[-1:] == \" \":  \n\t\t\tstr = \"\"\n\t\t\tfor k in range(len([newch for newch in t if newch!= i])):\n\t\t\t\tstr = str[0:k] + str[k+1:]\n\t\tout += str\n\tprint(out)", "score": 0.0, "codebleu": 0.20752809370623249, "crystalbleu": 0.05, "codebertscore": 0.67, "codescore": 0.018341757357120514, "surfaceSim": 0.37852919438285293, "abs_surfaceSim_minus_score": 0.37852919438285293, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_MBPP_717_OP_2", "golden_code": "import math\r\nimport sys\r\ndef sd_calc(data):\r\n    n = len(data)\r\n    if n <= 1:\r\n        return 0.0\r\n    mean, sd = avg_calc(data), 0.0\r\n    for el in data:\r\n        sd += (float(el) - mean)**2\r\n    sd = math.sqrt(sd / float(n-1))\r\n    return sd\r\ndef avg_calc(ls):\r\n    n, mean = len(ls), 0.0\r\n    if n <= 1:\r\n        return ls[0]\r\n    for el in ls:\r\n        mean = mean + float(el)\r\n    mean = mean / float(n)\r\n    return mean", "generated_code": "import math\n\ndef sd_calc(values):\n    length = len(values)\n    if length == 0:\n        return 0.0\n    if length == 1:\n        return 0.0\n    mean_value = sum(float(x) for x in values) / length\n    variance = sum((float(x) - mean_value) ** 2 for x in values) / (length - 1)\n    return math.sqrt(variance)\n", "score": 1.0, "codebleu": 0.22200782495435184, "crystalbleu": 0.07, "codebertscore": 0.82, "codescore": 0.9939070343971252, "surfaceSim": 0.5997652582159625, "abs_surfaceSim_minus_score": 0.4002347417840375, "source": "local", "local_type": "OP"}
{"id": "APPS_test-0444_8", "golden_code": "n = int(input())\nprint(n)\nprint('1 '*n)", "generated_code": "def solve(n):\n\ts = str(n)\n\tln = len(s)\n\tloc = 0\n\tfor i in range(1,ln):\n\t\tif s[i] > s[i-1]:\n\t\t\tloc = i\n\t\t\tbreak\n\tif loc == 0:\n\t\treturn [1]\n\tans = []\n\tcount = 1\n\ti = 1\n\twhile i < n:\n\t\tif loc > 0 and s[loc-1] > s[ i]:\n\t\t\tcount += 1\n\t\t\ti += 1\n\t\telse:\n\t\t\tans.append(str(count))\n\t\t\tcount = 1\n\t\t\ti+=1\n\tans.append( str(count) )\n\treturn ans\n\ndef main():\n\tn = int(input())\n\tans = solve(n)\n   \n\tprint(len(ans))\n\tprint(*ans)\n\n", "score": 0.0, "codebleu": 0.32957985319027305, "crystalbleu": 0, "codebertscore": 0.66, "codescore": 0.02609705552458763, "surfaceSim": 0.30004528985507245, "abs_surfaceSim_minus_score": 0.30004528985507245, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_157_OP_2", "golden_code": "def right_angle_triangle(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return True if the three\n    sides form a right-angled triangle, False otherwise.\n    A right-angled triangle is a triangle in which one angle is right angle or \n    90 degree.\n    Example:\n    right_angle_triangle(3, 4, 5) == True\n    right_angle_triangle(1, 2, 3) == False\n    '''\n    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b", "generated_code": "def right_angle_triangle(x, y, z):\n    '''\n    Given the lengths of the three sides of a triangle. Return True if the three\n    sides form a right-angled triangle, False otherwise.\n    A right-angled triangle is a triangle in which one angle is right angle or \n    90 degree.\n    Example:\n    right_angle_triangle(3, 4, 5) == True\n    right_angle_triangle(1, 2, 3) == False\n    '''\n    sides = sorted([x, y, z])\n    return sides[2] * sides[2] == sides[0] * sides[0] + sides[1] * sides[1]", "score": 1.0, "codebleu": 0.4377459166653388, "crystalbleu": 0, "codebertscore": 0.92, "codescore": 0.9876137971878052, "surfaceSim": 0.7411797647937278, "abs_surfaceSim_minus_score": 0.2588202352062722, "source": "local", "local_type": "OP"}
{"id": "LOCAL_HE_117_OP_1", "golden_code": "def select_words(s, n):\n    result = []\n    for word in s.split():\n        n_consonants = 0\n        for i in range(0, len(word)):\n            if word[i].lower() not in [\"a\",\"e\",\"i\",\"o\",\"u\"]:\n                n_consonants += 1 \n        if n_consonants == n:\n            result.append(word)\n    return result", "generated_code": "def select_words(text, consonant_count):\n    vowels = set('aeiou')\n    def count_consonants(word):\n        return sum(1 for char in word.lower() if char not in vowels)\n    return [word for word in text.split() if count_consonants(word) == consonant_count]", "score": 1.0, "codebleu": 0.19468442789160834, "crystalbleu": 0, "codebertscore": 0.81, "codescore": 0.8959658145904541, "surfaceSim": 0.539281210592686, "abs_surfaceSim_minus_score": 0.46071878940731403, "source": "local", "local_type": "OP"}
{"id": "MBPP_72_33", "golden_code": "def Average(lst): \r\n    return sum(lst) / len(lst) ", "generated_code": "def Average(lst):\n\treturn sum(lst) / len(lst)\nh = lambda x: sum(lst)*(-1)", "score": 1.0, "codebleu": 0.8404341577360257, "crystalbleu": 0, "codebertscore": 0.9, "codescore": 0.9932636022567749, "surfaceSim": 0.629734085414988, "abs_surfaceSim_minus_score": 0.370265914585012, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_1244_20_OP_1", "golden_code": "import sys\nimport math\n\nn = int(sys.stdin.readline())\nan = [int(x) for x in (sys.stdin.readline()).split()]\n\nd = dict()\n\nfor i in an:\n    if i in d:\n        d[i] += 1\n    else:\n        d[i] = 1\n        \nvmax = 0\nvsum = 0\nfor i in list(d.keys()):\n    vsum += d[i]\n    if(d[i] > vmax):\n        vmax = d[i]\n        \nif(vsum - vmax >= vmax - 1):\n    print(\"YES\")\nelse:\n    print(\"NO\")\n    ", "generated_code": "from collections import Counter\n\nnum = int(input())\nvalues = list(map(int, input().split()))\n\ncount = Counter(values)\n\nmax_freq = max(count.values())\ntotal = sum(count.values())\n\nif total - max_freq >= max_freq - 1:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n", "score": 1.0, "codebleu": 0.1606410999998269, "crystalbleu": 0.09, "codebertscore": 0.73, "codescore": 0.8110049962997437, "surfaceSim": 0.5546953046953047, "abs_surfaceSim_minus_score": 0.4453046953046953, "source": "local", "local_type": "OP"}
{"id": "LOCAL_PIE_extra_p03416_s130057185_OP_1", "golden_code": "counter = 0\n\nc = list(map(int, input().split(' ')))\n\nfor i in range(c[0], c[1] + 1):\n\n  if str(i)[0] != str(i)[4]:\n\n    continue\n\n  if str(i)[1] != str(i)[3]:\n\n    continue\n\n  counter += 1\n\n\n\nprint(counter)", "generated_code": "a = list(map(int, input().split()))\n\ncounter = 0\n\nfor i in range(a[0], a[1] + 1):\n\n  stri = str(i)\n\n  if (stri[0] == stri[4] and stri[1] == stri[3]):\n\n    counter += 1\n\n    \n\nprint(counter)", "score": 1.0, "codebleu": 0.3117451244191844, "crystalbleu": 0.33, "codebertscore": 0.92, "codescore": 0.9376822710037231, "surfaceSim": 0.7285966460723742, "abs_surfaceSim_minus_score": 0.2714033539276258, "source": "local", "local_type": "OP"}
{"id": "APPS_test-0783_12", "golden_code": "n = int(input())\na = list(map(int, input().split()))\nb = [0] * n\nma = a[-1]\nfor i in range(n - 2, -1, -1):\n    if a[i] <= ma:\n        b[i] = ma - a[i] + 1\n    else:\n        ma = a[i]\nprint(*b)\n", "generated_code": "import sys\nn = int(input())\na = list(map(int, input().split()))\n\nans = [0 for i in range(n)]\n[ans[i] for i in range (n)]\n[h[i] for h in map(int, sys.stdin.readline().split())]\n\nfor i in range(1, n):\n\tif h[i] > h[i-1]:\n\t\tans[i] = ans[i-1] + (h[i] - h[i-2])\n\telse:\n\t\tans[n-i-1] = ans[n-i] + h[i] - horizontal.pop()\n\nprint(*ans)\n", "score": 0.0432, "codebleu": 0.2974462973790778, "crystalbleu": 0.27, "codebertscore": 0.83, "codescore": 0.05502597615122795, "surfaceSim": 0.5652936021034181, "abs_surfaceSim_minus_score": 0.522093602103418, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-2027_17", "golden_code": "n = int(input())\nb = list(map(int, input().split()))\nb.append(0)\na = map(lambda x, y: str(x+y), b, b[1:])\nprint(\" \".join(a))", "generated_code": "#!/usr/bin/env python3\nimport sys\n\ndef solve(n, A):\n\tv = A[0]\n\tl = [0] * n\n\tfor i in range(n):\n\t\tl[i] = v\n\t\tv = v + A[i] - l[i] - 1\n\treturn l\n\ndef __starting_point():\n\tn = int(input())\n\tA = list(map(int, input().split()))\n\tprint(*solve(n, A))\n\n__starting_point()\n", "score": 0.0, "codebleu": 0.28756265912835166, "crystalbleu": 0, "codebertscore": 0.75, "codescore": 0.04290594533085823, "surfaceSim": 0.46694940040947647, "abs_surfaceSim_minus_score": 0.46694940040947647, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_8_41", "golden_code": "def fibonacci(n):\r\n  if n == 1 or n == 2:\r\n    return 1\r\n  else:\r\n    return (fibonacci(n - 1) + (fibonacci(n - 2)))", "generated_code": "def fibonacci(n):  \n\ta,b = 0,1\n\twhile n > 0:\n\t\ta = b\n\t\tb = a+b\n\t\tn = n // 10\n\treturn b", "score": 0.0, "codebleu": 0.19411678021976952, "crystalbleu": 0, "codebertscore": 0.78, "codescore": 0.12734918296337128, "surfaceSim": 0.4891304347826087, "abs_surfaceSim_minus_score": 0.4891304347826087, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_extra_p02725_s026624237_OP_1", "golden_code": "#template\n\ndef inputlist(): return [int(j) for j in input().split()]\n\n#template\n\n#issueから始める\n\nK,N = inputlist()\n\nA = inputlist()\n\nlia = [0]*N\n\nfor i in range(1,N):\n\n    k = A[i] - A[i-1]\n\n    lia[i] = k\n\nlia[0] = (K+A[0]-A[-1])\n\nlia.sort()\n\nans = 0\n\nfor i in range(N-1):\n\n    ans += lia[i]\n\nprint(ans)", "generated_code": "#template\n\ndef inputlist(): return [int(j) for j in input().split()]\n\ndef listinput(): return input().split()\n\n#template\n\nK,N = inputlist()\n\nA = inputlist()\n\ndis = [0]*(N)\n\nfor i in range(N):\n\n    if i == N-1:\n\n        dis[i] = K+A[0] - A[i]\n\n        continue\n\n    dis[i] = A[i+1] - A[i]\n\ndis.sort()\n\nprint((sum(dis[:-1])))", "score": 1.0, "codebleu": 0.44308812600523384, "crystalbleu": 0.42, "codebertscore": 0.9, "codescore": 0.10655882954597473, "surfaceSim": 0.7159193049036252, "abs_surfaceSim_minus_score": 0.2840806950963748, "source": "local", "local_type": "OP"}
{"id": "LOCAL_APPS_4703_10_OP_1", "golden_code": "S = input()\nn = len(S)\n \nans = 0\n \nfor i in range(2**(n-1)):\n    t = S[0]\n    for j in range(n-1):\n        if (i>>j)&1:\n            t += \"+\"\n        t += S[j+1]\n    ans += eval(t)\n \nprint(ans)", "generated_code": "from functools import lru_cache\n\nsequence = input()\nlength = len(sequence)\n\nresult = 0\n\n@lru_cache(None)\ndef evaluate_expression(index, current_sum, last_number):\n    if index == length:\n        return current_sum + last_number\n    \n    current_digit = int(sequence[index])\n    # Option 1: Add '+' before this digit\n    option1 = evaluate_expression(index + 1, current_sum + last_number, current_digit)\n    # Option 2: Concatenate this digit to the last number\n    option2 = evaluate_expression(index + 1, current_sum, last_number * 10 + current_digit)\n    \n    return option1 + option2\n\nresult = evaluate_expression(1, 0, int(sequence[0]))\n\nprint(result)", "score": 1.0, "codebleu": 0.17456377375432944, "crystalbleu": 0, "codebertscore": 0.69, "codescore": 0.02960299514234066, "surfaceSim": 0.4336695747001091, "abs_surfaceSim_minus_score": 0.5663304252998909, "source": "local", "local_type": "OP"}
{"id": "LOCAL_HE_99_MUT_20", "golden_code": "import os\n\ndef closest_integer(value):\n    '''\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    '''\n    from math import floor, ceil\n    \n    if value.count('.') == 1:\n        \n        while value[-1] == '0':\n            value = value[:-1]\n    \n    num = float(value)\n    if value[-2:] == '.5':\n        if num > 0:\n            res = ceil(num)\n        else:\n            res = floor(num)\n    elif len(value) > 0:\n        res = int(round(num))\n    else:\n        res = 0\n    \n    return res", "generated_code": "import os\n\ndef closest_integer(value):\n    '''\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    '''\n    from math import floor, ceil\n    \n    if value.count('.') == 1:\n        \n        while value[-1] == '0':\n            value = value[:-1]\n    \n    num = float(value)\n    if value[-2:] == '.5':\n        if num > 0:\n            res = ceil(num)\n        else:\n            res = floor(num)\n    elif len(value) < 0:\n        res = int(round(num))\n    else:\n        res = 0\n    \n    return res", "score": 0.4638, "codebleu": 0.9905660422656328, "crystalbleu": 0.96, "codebertscore": 1.0, "codescore": 0.9936756491661072, "surfaceSim": 0.9809859413427302, "abs_surfaceSim_minus_score": 0.5171859413427302, "source": "local", "local_type": "MUT"}
{"id": "MBPP_43_4", "golden_code": "def is_Two_Alter(s):  \r\n    for i in range (len( s) - 2) : \r\n        if (s[i] != s[i + 2]) : \r\n            return False\r\n    if (s[0] == s[1]): \r\n        return False\r\n    return True", "generated_code": "def is_Two_Alter(s):  \n\ta = s.split(\" \")\n\tif len(a)!= 2:\n\t\treturn False\n\tfor el in a:\n\t\tif el!= el[::-1]:\n\t\t\treturn False\n\t\t\n\treturn True", "score": 0.8299, "codebleu": 0.2661212417399297, "crystalbleu": 0, "codebertscore": 0.83, "codescore": 0.9673473834991455, "surfaceSim": 0.660655737704918, "abs_surfaceSim_minus_score": 0.16924426229508194, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0221_12", "golden_code": "\nn, k = map(int, input().split())\n\nif n <= 2 * k + 1:\n\tprint(1)\n\tprint(n // 2 + 1)\n\treturn\n\nl = 2 * (k + 1)\nr = 2 * (2 * k + 1)\ncnt = 0\nwhile not (l <= n <= r):\n\tcnt += 1\n\tl += 2 * k + 1\n\tr += 2 * k + 1\n\nprint(cnt + 2)\n\nm = n - cnt * (2 * k + 1)\na = m // 2\nans = [a - k - 1]\nr = ans[0] + k\n\nwhile r < n - 1:\n\tif r + k + 1 < n:\n\t\tans.append(r + k + 1)\n\tr = ans[-1] + k\n\nfor i in ans:\n\tprint(i + 1, end=' ')\nprint()", "generated_code": "import sys\ninput = sys.stdin.readline\n\nn,k = map(int,input().split())\n\nM = [0]*n\n\nfor i in range(n):\n\tM[i] = i\n\n\nANS = [0]\n\nfor i,j in enumerate(M):\n\tif j == 0:\n\t\tANS.append(0)\n\t\tcontinue\n\tANS.append(min(ANS[-1], j-1))\n\tM[j] = max(M[j], j-1)\n\nprint(len(ANS))\nprint(*ANS)\n", "score": 0.0, "codebleu": 0.11313774595611684, "crystalbleu": 0.11, "codebertscore": 0.75, "codescore": 0.03750471770763397, "surfaceSim": 0.5239709443099274, "abs_surfaceSim_minus_score": 0.5239709443099274, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-1222_18", "golden_code": "from collections import deque\n\nN = int(input())\n\nQ = deque([1, 2, 3, 4, 5, 6, 7, 8, 9])\n\nfor i in range(N - 1):\n    x = Q.popleft()\n    if x % 10 != 0:\n        y = 10 * x + x % 10 - 1\n        Q.append(y)\n    \n    y = 10 * x + x % 10\n    Q.append(y)\n\n    if x % 10 != 9:\n        y = 10 * x + x % 10 + 1\n        Q.append(y)\n\nans = Q.popleft()\n\nprint(ans)", "generated_code": "k = int(input())\n\ns = [0] * 10\nd = {0:0}\n\nfor i in range(1, 10):\n\td[i] = d[i-1] + (i-1)%10 + i%10\n\ts[i-1]=s[i]\n\nfor iin in range(10):\n\tif iin+1 == s[iin]:\n\t\tprint(iin)\n\t\tbreak\n", "score": 0.0, "codebleu": 0.11201059499201058, "crystalbleu": 0.1, "codebertscore": 0.74, "codescore": 0.018372368067502975, "surfaceSim": 0.5868662587412588, "abs_surfaceSim_minus_score": 0.5868662587412588, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_164_1", "golden_code": "def access_elements(nums, list_index):\r\n    result = [nums[i] for i in list_index]\r\n    return result", "generated_code": "def access_elements(l: int, r: int):\n\tif l > r:\n\t\treturn 0\n\treturn self._multiply(self.get(l), r)", "score": 0.0, "codebleu": 0.19787346221238658, "crystalbleu": 0, "codebertscore": 0.77, "codescore": 0.026154477149248123, "surfaceSim": 0.41688379364252215, "abs_surfaceSim_minus_score": 0.41688379364252215, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-1000_50", "golden_code": "n, v = [int(item) for item in input().split()]\n\nx = 0\nc = 0\nfor i in range(1, n):\n    if x < n - i:\n        c += i * min((n - i), v - x)\n        x += min((n - i), v - x)\n    x -= 1\n\nprint(c)\n", "generated_code": "n, v = map(int, input().split())\nt = int(1e9)\nx = v\nfor i in range(n):\n\tif x < i:\n\t\tt = i\n\t\tbreak\n\tx -= 1\nprint(t + x // v)\n", "score": 0.0432, "codebleu": 0.1988785035462684, "crystalbleu": 0, "codebertscore": 0.84, "codescore": 0.041896525770425797, "surfaceSim": 0.7028226724334168, "abs_surfaceSim_minus_score": 0.6596226724334168, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_MBPP_598_OP_1", "golden_code": "def armstrong_number(number):\r\n sum = 0\r\n times = 0\r\n temp = number\r\n while temp > 0:\r\n           times = times + 1\r\n           temp = temp // 10\r\n temp = number\r\n while temp > 0:\r\n           reminder = temp % 10\r\n           sum = sum + (reminder ** times)\r\n           temp //= 10\r\n if number == sum:\r\n           return True\r\n else:\r\n           return False", "generated_code": "def armstrong_number(num):\n    digits = [int(d) for d in str(num)]\n    num_digits = len(digits)\n    armstrong_sum = sum(d ** num_digits for d in digits)\n    return num == armstrong_sum", "score": 1.0, "codebleu": 0.10097542585737819, "crystalbleu": 0, "codebertscore": 0.7, "codescore": 0.9938808679580688, "surfaceSim": 0.5513165266106442, "abs_surfaceSim_minus_score": 0.44868347338935577, "source": "local", "local_type": "OP"}
{"id": "LOCAL_PIE_extra_p03325_s558724347_OP_1", "golden_code": "N=int(eval(input()))\n\na=list(map(int,input().split()))\n\nfor i in range(N):\n\n  for j in range(1,31):\n\n    if a[i]%(2**j)!=0:\n\n      a[i]=j-1\n\n      break\n\nprint((sum(a)))", "generated_code": "import sys\n\ninput = sys.stdin.buffer.readline\n\n\n\nN = int(eval(input()))\n\nA = list(map(int, input().split()))\n\n\n\ndef f(n):\n\n  res = 0\n\n  while n % 2 == 0:\n\n    n //= 2\n\n    res += 1\n\n  return res\n\n\n\nanswer = 0\n\nfor a in A:\n\n  answer += f(a)\n\n\n\nprint(answer)", "score": 1.0, "codebleu": 0.21636832910672954, "crystalbleu": 0, "codebertscore": 0.8, "codescore": 0.15841490030288696, "surfaceSim": 0.47139616935483875, "abs_surfaceSim_minus_score": 0.5286038306451613, "source": "local", "local_type": "OP"}
{"id": "LOCAL_APPS_1471_29_MUT_20", "golden_code": "import sys\nsys.setrecursionlimit(10 ** 7)\n\nN = int(input())\ngraph = [[] for _ in range(N)]\n\nfor _ in range(N - 1):\n    (u, v, w) = list(map(int, input().split()))\n    u -= 1\n    v -= 1\n    graph[u].append([v, w])\n    graph[v].append([u, w])\n\ncolor = [-1] * N\ndef even(v=0, col=0):\n    color[v] = col\n    for i in range(len(graph[v])):\n        (nv, nw) = list(map(int, graph[v][i]))\n        if color[nv] != -1:\n            continue\n        if nw % 2 == 0:\n            even(nv, col)\n        else:even(nv, 1 - col)\n\neven()\nfor i in range(N):\n    print(color[i])", "generated_code": "import sys\nsys.setrecursionlimit(10 ** 7)\n\nN = int(input())\ngraph = [[] for _ in range(N)]\n\nfor _ in range(N - 1):\n    (u, v, w) = list(map(int, input().split()))\n    u -= 1\n    v -= 1\n    graph[u].append([v, w])\n    graph[v].append([u, w])\n\ncolor = [-1] * N\ndef even(v=0, col=0):\n    color[v] = col\n    for i in range(len(graph[v])):\n        (nv, nw) = list(map(int, graph[v][i]))\n        if color[nv] != -1:\n            continue\n        if nw % 2 == 0:\n            even(nv, col)\n        else:even(nv, 1 - col)break\n\neven()\nfor i in range(N):\n    print(color[i])", "score": 0.0, "codebleu": 0.9665178532682998, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.9937582015991211, "surfaceSim": 0.4955595026642984, "abs_surfaceSim_minus_score": 0.4955595026642984, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_MBPP_524_OP_1", "golden_code": "def max_sum_increasing_subsequence(arr, n): \r\n\tmax = 0\r\n\tmsis = [0 for x in range(n)] \r\n\tfor i in range(n): \r\n\t\tmsis[i] = arr[i] \r\n\tfor i in range(1, n): \r\n\t\tfor j in range(i): \r\n\t\t\tif (arr[i] > arr[j] and\r\n\t\t\t\tmsis[i] < msis[j] + arr[i]): \r\n\t\t\t\tmsis[i] = msis[j] + arr[i] \r\n\tfor i in range(n): \r\n\t\tif max < msis[i]: \r\n\t\t\tmax = msis[i] \r\n\treturn max", "generated_code": "def max_sum_increasing_subsequence(seq, length):\n    if length == 0:\n        return 0\n    memo = seq[:]\n    for idx in range(1, length):\n        for prev in range(idx):\n            if seq[idx] > seq[prev]:\n                memo[idx] = max(memo[idx], memo[prev] + seq[idx])\n    return max(memo)", "score": 0.9402, "codebleu": 0.1973493532356837, "crystalbleu": 0.07, "codebertscore": 0.79, "codescore": 0.9719901084899902, "surfaceSim": 0.6390235838659908, "abs_surfaceSim_minus_score": 0.30117641613400925, "source": "local", "local_type": "OP"}
{"id": "LOCAL_HE_82_OP_1", "golden_code": "def prime_length(string):\n    l = len(string)\n    if l == 0 or l == 1:\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n            return False\n    return True", "generated_code": "def prime_length(text):\n    length = len(text)\n    if length < 2:\n        return False\n    if length in (2, 3):\n        return True\n    if length % 2 == 0 or length % 3 == 0:\n        return False\n    for divisor in range(5, int(length**0.5) + 1, 6):\n        if length % divisor == 0 or length % (divisor + 2) == 0:\n            return False\n    return True", "score": 1.0, "codebleu": 0.43686173604088424, "crystalbleu": 0, "codebertscore": 0.84, "codescore": 0.9936466217041016, "surfaceSim": 0.7042840375586854, "abs_surfaceSim_minus_score": 0.2957159624413146, "source": "local", "local_type": "OP"}
{"id": "LOCAL_HE_28_OP_1", "golden_code": "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    return ''.join(strings)", "generated_code": "from typing import List\n\n\ndef concatenate(elements: List[str]) -> str:\n    return ''.join(elements) if elements else ''", "score": 1.0, "codebleu": 0.6990213616676922, "crystalbleu": 0, "codebertscore": 0.94, "codescore": 0.9936165809631348, "surfaceSim": 0.8532212885154062, "abs_surfaceSim_minus_score": 0.14677871148459376, "source": "local", "local_type": "OP"}
{"id": "MBPP_22_7", "golden_code": "def find_Extra(arr1,arr2,n) : \r\n    for i in range(0, n) : \r\n        if (arr1[i] != arr2[i]) : \r\n            return i \r\n    return n ", "generated_code": "def find_Extra(arr1,arr2,n) : \n\tfor i in range(len(arr2)):\n\t\tif arr1[i]!= arr2[i] :\n\t\t\treturn i\n\treturn len(arr2)\n\n\n\n\n\n'''\nInput: The first line of the line contains the line of the data i and the not-negative number.\nThe second and the not -number of line with the negative number of negative\nnumbers.\nThe third and four total number of negative numbers.\nThe last index of each number in that list, the index with the highest number\nof negative numbers.\n\t\ninput\nInput: i,j,k\ni=j,k=k,l=x\nj=4,l=j,x=y\nk=4,j=x,l=y\n'''", "score": 1.0, "codebleu": 0.3760384622821985, "crystalbleu": 0, "codebertscore": 0.77, "codescore": 0.9938289523124695, "surfaceSim": 0.5696173615077098, "abs_surfaceSim_minus_score": 0.4303826384922902, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_4484_79_OP_2", "golden_code": "import sys\n\n\ndef LI():\n    return list(map(int, input().split()))\n\n\nN, M = LI()\nif abs(N-M) >= 2:\n    print((0))\n    return\nmod = pow(10, 9)+7\nx = 1\nif N == M:\n    for i in range(1, N+1):\n        x = (x*i) % mod\n    ans = (x*x*2) % mod\nelse:\n    A = max(N, M)\n    B = min(N, M)\n    for i in range(1, B+1):\n        x = (x*i) % mod\n    y = (x*A) % mod\n    ans = (x*y) % mod\nprint(ans)", "generated_code": "def LI():\n    return list(map(int, input().split()))\n\nP, Q = LI()\nif abs(P-Q) >= 2:\n    print(0)\n    return\nMODULO = 10**9 + 7\nfactorial_cache = {}\n\ndef factorial(n):\n    if n in factorial_cache:\n        return factorial_cache[n]\n    result = 1\n    for i in range(2, n + 1):\n        result = (result * i) % MODULO\n    factorial_cache[n] = result\n    return result\n\nif P == Q:\n    fact_val = factorial(P)\n    result = (fact_val * fact_val * 2) % MODULO\nelse:\n    min_val = min(P, Q)\n    max_val = max(P, Q)\n    fact_min = factorial(min_val)\n    fact_result = (fact_min * factorial(max_val)) % MODULO\n    result = fact_result\n\nprint(result)", "score": 1.0, "codebleu": 0.3894452532231709, "crystalbleu": 0.29, "codebertscore": 0.8, "codescore": 0.5320678353309631, "surfaceSim": 0.6115633532207503, "abs_surfaceSim_minus_score": 0.3884366467792497, "source": "local", "local_type": "OP"}
{"id": "LOCAL_APPS_4703_10_MUT_21", "golden_code": "S = input()\nn = len(S)\n\nans = 0\n\nfor i in range(2 ** (n - 1)):\n    t = S[0]\n    for j in range(n - 1):\n        if (i >> j) & 1:\n            t += '+'\n        t += S[j + 1]\n    ans += eval(t)\n\nprint(ans)", "generated_code": "S = input()\nn = len(S)\n\npass\n\nfor i in range(2 ** (n - 1)):\n    t = S[0]\n    for j in range(n - 1):\n        if (i >> j) & 1:\n            t += '+'\n        t += S[j + 1]\n    ans += eval(t)\n\nprint(ans)", "score": 0.0, "codebleu": 0.8182711842333003, "crystalbleu": 0, "codebertscore": 0.99, "codescore": 0.9931365251541138, "surfaceSim": 0.965049751243781, "abs_surfaceSim_minus_score": 0.965049751243781, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_HE_12_MUT_3", "golden_code": "import os\n\nfrom typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    if not strings:\n        return None\n    \n    maxlen = max((len(x) for x in strings))\n    for s in strings:\n        if len(s) == maxlen:\n            return s", "generated_code": "import os\n\nfrom typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    if not strings:\n        return None\n    \n    maxlen = max((len(x) for x in strings))\n    for s in strings:\n        if not (len(s) == maxlen):\n            return s", "score": 0.0, "codebleu": 0.8944351990857708, "crystalbleu": 0, "codebertscore": 0.99, "codescore": 0.993720531463623, "surfaceSim": 0.9904942965779467, "abs_surfaceSim_minus_score": 0.9904942965779467, "source": "local", "local_type": "MUT"}
{"id": "MBPP_79_4", "golden_code": "def min_of_two( x, y ):\r\n    if x < y:\r\n        return x\r\n    return y", "generated_code": "def min_of_two( x, y ):\n\treturn min( x,y )", "score": 1.0, "codebleu": 0.3458455849431634, "crystalbleu": 0, "codebertscore": 0.89, "codescore": 0.9937983155250549, "surfaceSim": 0.7038961038961039, "abs_surfaceSim_minus_score": 0.2961038961038961, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_707_11_OP_2", "golden_code": "n, m = list(map(int, input().split()))\nx = tuple(map(int, input().split()))\ny = min(x)\na = 0\nfor xi in x:\n    b = xi - y\n    while b:\n        a, b = b, a % b\nj = 1\nfor p in input().split():\n    if a % int(p):\n        j += 1\n        continue\n    print(\"YES\")\n    print(y, j)\n    break\nelse:\n    print(\"NO\")", "generated_code": "import sys\nfrom math import gcd\n\nnum1, num2 = map(int, sys.stdin.readline().split())\nvalues = list(map(int, sys.stdin.readline().split()))\nmin_value = min(values)\ngcd_value = 0\nfor value in values:\n    gcd_value = gcd(gcd_value, value - min_value)\n\nposition = 1\nfor divisor in map(int, sys.stdin.readline().split()):\n    if gcd_value % divisor == 0:\n        print(\"YES\")\n        print(min_value, position)\n        break\n    position += 1\nelse:\n    print(\"NO\")\n", "score": 1.0, "codebleu": 0.2568132814176841, "crystalbleu": 0.19, "codebertscore": 0.78, "codescore": 0.6265755295753479, "surfaceSim": 0.6023913043478261, "abs_surfaceSim_minus_score": 0.39760869565217394, "source": "local", "local_type": "OP"}
{"id": "LOCAL_MBPP_532_OP_2", "golden_code": "def check_permutation(str1, str2):\r\n  n1=len(str1)\r\n  n2=len(str2)\r\n  if(n1!=n2):\r\n    return False\r\n  a=sorted(str1)\r\n  str1=\" \".join(a)\r\n  b=sorted(str2)\r\n  str2=\" \".join(b)\r\n  for i in range(0, n1, 1):\r\n    if(str1[i] != str2[i]):\r\n      return False\r\n  return True", "generated_code": "def check_permutation(s1, s2):\n  if len(s1) != len(s2):\n    return False\n  from collections import Counter\n  return Counter(s1) == Counter(s2)", "score": 0.9988, "codebleu": 0.16190956173786175, "crystalbleu": 0, "codebertscore": 0.81, "codescore": 0.9672738313674927, "surfaceSim": 0.5394456289978677, "abs_surfaceSim_minus_score": 0.4593543710021323, "source": "local", "local_type": "OP"}
{"id": "APPS_test-1067_68", "golden_code": "import sys\ninput = sys.stdin.readline\nfrom collections import defaultdict, deque\n\nn = int(input())\nl = list(map(int, input().split()))\npos = 0\nneg = 0\nz = 0\nans = 0\nfor x in l:\n\tif x > 0:\n\t\tpos += 1\n\t\tans += x - 1\n\telif x < 0:\n\t\tneg += 1\n\t\tans += -1 - x\n\telse:\n\t\tz += 1\n\t\tans += 1\nif neg % 2 == 0:\n\tprint(ans)\nelif z > 0:\n\tprint(ans)\nelse:\n\tprint(ans + 2)", "generated_code": "n = int(input())\na = [int(x) for x in input().split()]\nans = 0\nfor i in range(n):\n\tif a[i] == 1:\n\t\tans += 1\n\telse:\n\t\tct = 0\n\t\tt = 0\n\t\tfor j in range(i+1, n):\n\t\t\tif a[j] == 1: continue\n\t\t\tct += 1\n\t\t\tt += 1\n\t\t\ta[j] = -1\n\t\tif t % 2 == 0:\n\t\t\tans += t // 2\n\t\telse:\n\t\t\tans = min(ans, ct + (t // 2))\nprint(ans)\n", "score": 0.0, "codebleu": 0.23699752096457743, "crystalbleu": 0.18, "codebertscore": 0.82, "codescore": 0.0922207236289978, "surfaceSim": 0.5261699227623807, "abs_surfaceSim_minus_score": 0.5261699227623807, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0789_12", "golden_code": "a = input()[::-1]\ncount = 0\nfor i in range(len(a)):\n    if a[i] == '7':\n        count += 2 ** i * 2\n    else:\n        count += 2 ** i\nprint(count)", "generated_code": "import sys\n\ndef main():\n\tn = int(sys.stdin.readline())\n\ti = 1\n\twhile n > 0:\n\t\tif n % 10 == 4:\n\t\t\ti += 1\n\t\tn /= 10\n\tprint(i)\n\nmain()\n", "score": 0.0, "codebleu": 0.15265747425702567, "crystalbleu": 0, "codebertscore": 0.75, "codescore": 0.027284730225801468, "surfaceSim": 0.4381352187361909, "abs_surfaceSim_minus_score": 0.4381352187361909, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_367_2", "golden_code": "def trim_tuple(test_list, K):\r\n  res = []\r\n  for ele in test_list:\r\n    N = len(ele)\r\n    res.append(tuple(list(ele)[K: N - K]))\r\n  return (str(res)) ", "generated_code": "def trim_tuple(test6, K):        \n        return test6[:K]", "score": 0.0, "codebleu": 0.07280641891647018, "crystalbleu": 0, "codebertscore": 0.82, "codescore": 0.018773794174194336, "surfaceSim": 0.48, "abs_surfaceSim_minus_score": 0.48, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_118_OP_1", "golden_code": "def get_closest_vowel(word):\n    if len(word) < 3:\n        return \"\"\n\n    vowels = {\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", 'O', 'U', 'I'}\n    for i in range(len(word)-2, 0, -1):\n        if word[i] in vowels:\n            if (word[i+1] not in vowels) and (word[i-1] not in vowels):\n                return word[i]\n    return \"\"", "generated_code": "def get_closest_vowel(text):\n    if len(text) < 3:\n        return \"\"\n\n    vowels = frozenset('aeiouAEIOU')\n    for index in range(len(text)-2, 0, -1):\n        char = text[index]\n        if char in vowels and text[index+1] not in vowels and text[index-1] not in vowels:\n            return char\n    return \"\"", "score": 1.0, "codebleu": 0.3574710984573293, "crystalbleu": 0.25, "codebertscore": 0.92, "codescore": 0.6782624125480652, "surfaceSim": 0.8252314814814814, "abs_surfaceSim_minus_score": 0.1747685185185186, "source": "local", "local_type": "OP"}
{"id": "LOCAL_APPS_47_12_MUT_44", "golden_code": "(n, x) = map(int, input().split())\nA = list(map(int, input().split()))\nDP = [[0] * 3 for _ in range(n + 1)]\nans = 0\nfor i in range(1, n + 1):\n    DP[i][0] = max(DP[i - 1][0] + A[i - 1], A[i - 1])\n    DP[i][1] = max(DP[i - 1][0] + (A[i - 1] * x), DP[i - 1][1] + (A[i - 1] * x), A[i - 1] * x)\n    DP[i][2] = max(DP[i - 1][1] + A[i - 1], DP[i - 1][2] + A[i - 1], A[i - 1])\n    ans = max(ans, max(DP[i]))\nprint(ans)", "generated_code": "(n, x) = map(int, input().split())\nA = list(map(int, input().split()))\nDP = [[0] * 3 for _ in range(n + 1)]\nans = 0\nfor i in range(1, n + 1):\n    DP[i][0] = max(DP[i - 1][0] + A[i - 1], A[i - 1])\n    pass\n    DP[i][2] = max(DP[i - 1][1] + A[i - 1], DP[i - 1][2] + A[i - 1], A[i - 1])\n    ans = max(ans, max(DP[i]))\nprint(ans)", "score": 0.0873, "codebleu": 0.7184819216407833, "crystalbleu": 0.69, "codebertscore": 0.97, "codescore": 0.38483700156211853, "surfaceSim": 0.8971150503997218, "abs_surfaceSim_minus_score": 0.8098150503997218, "source": "local", "local_type": "MUT"}
{"id": "MBPP_46_6", "golden_code": "def multiply_list(items):\r\n    tot = 1\r\n    for x in items:\r\n        tot *= x\r\n    return tot", "generated_code": "def multiply_list(z):\n\titem = z[1]\n\treturn item", "score": 0.0292, "codebleu": 0.17982766819116613, "crystalbleu": 0, "codebertscore": 0.8, "codescore": 0.027379333972930908, "surfaceSim": 0.6774193548387097, "abs_surfaceSim_minus_score": 0.6482193548387097, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_344_3_OP_1", "golden_code": "s = input()\ng = 'aouien'\ng1 = 'aouie'\nstate = 0\nok = True\nfor el in s:\n\tif state == 0:\n\t\tif el in g:\n\t\t\tstate = 0\n\t\telse:\n\t\t\tstate = 1\n\telse:\n\t\tif el not in g1:\n\t\t\tok = False\n\t\tstate = 0\nif state == 1:\n\tok = False\nif ok:\n\tprint(\"YES\")\nelse:\n\tprint(\"NO\")", "generated_code": "input_string = input()\nvowels_set = {'a', 'o', 'u', 'i', 'e', 'n'}\nvowel_set = {'a', 'o', 'u', 'i', 'e'}\ncurrent_state = 0\nis_valid = True\nfor character in input_string:\n    if current_state == 0:\n        if character in vowels_set:\n            current_state = 0\n        else:\n            current_state = 1\n    else:\n        if character not in vowel_set:\n            is_valid = False\n        current_state = 0\nif current_state == 1:\n    is_valid = False\nif is_valid:\n    print(\"YES\")\nelse:\n    print(\"NO\")", "score": 1.0, "codebleu": 0.3487882835410613, "crystalbleu": 0, "codebertscore": 0.79, "codescore": 0.9008297920227051, "surfaceSim": 0.7739789196310936, "abs_surfaceSim_minus_score": 0.22602108036890645, "source": "local", "local_type": "OP"}
{"id": "APPS_test-2354_31", "golden_code": "n,q=map(int, input().strip().split(\" \"))\n# print(n,q)\na=[]\nfor i in range(q):\n    \n    x,y=map(int, input().strip().split(\" \"))\n    a.append([x,y])   \n\nif n%2==0:\n    for x,y in a:\n        # if x+y==2:\n        #     print(1)\n        #     continue\n        if (x+y)%2==0:\n            k=0\n        else:\n            k=(n*n)//2\n        k = k\n        l=(x-1)*n//2\n        m= int(y/2 + 0.5)\n        print(k+l+m)\nelse:\n    for x,y in a:\n        if (x+y)%2==0:\n            k=0\n            l = ((x-1)//2)*n \n            p= (x-1)%2*int(n/2+.5)\n            m=int(y/2 + 0.5)\n            print(k+l+m+p)\n            continue\n        else:\n            k=(n*n)//2 +1\n            l = ((x-1)//2)*n \n            p= (x-1)%2*int(n/2-.5) \n            m=int(y/2 + 0.5)\n            print(k+l+m+p)", "generated_code": "n,q=map(int,input().split())\nfor i in range(n):\n\ta=list(map(int,str(i+1).split()))\n\tfor j in range(n-1):\n\t\ta[j+1]=a[j]+a[j+ 1]\n\ta[0]=a[0]%2\n\ta[n-1]=a[n- 1]%2\n\t\t\nfor i in''*q:\n\tx,y=map(int,''.join(str(i) for i in input().split()).split())\n\tx-=1\n\ty-=1\n\t\t\n\tprint(a[x]*y+a[y]*(a[x]-1)+a[x]/2*(a[y]-1),end=' ')\n\t\n", "score": 0.0, "codebleu": 0.12456186761904031, "crystalbleu": 0.11, "codebertscore": 0.8, "codescore": 0.12676472961902618, "surfaceSim": 0.6000982669287118, "abs_surfaceSim_minus_score": 0.6000982669287118, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_p02599_s870922238_MUT_26", "golden_code": "import sys\nclass BinaryIndexedTree:\n    def __init__(self, A):\n        self.__n = len(A)\n        self.__node = [0] * (self.__n + 1)\n        self.__data = [0] * (self.__n + 1)\n        S = [0] * (self.__n + 1)\n        for i in range(1, self.__n + 1):\n            S[i] = S[i - 1] + A[i - 1]\n            self.__data[i] = A[i - 1]\n            self.__node[i] = S[i] - S[i - (i & (-i))]\n    def add(self, i, v):\n        self.__data[i] += v\n        while i <= self.__n:\n            self.__node[i] += v\n            i += i & (-i)\n    def sum(self, i):\n        rst = 0\n        while i > 0:\n            rst += self.__node[i]\n            i -= i & (-i)\n        return rst\n    def get(self, i, j):\n        if i == j:\n            return self.__data[i]\n        else:\n            return self.sum(j) - self.sum(i - 1)\ndef main():\n    (N, Q) = map(int, input().split())\n    C = list(map(int, input().split()))\n    P = [[] for _ in range(N)]\n    for (i, c) in enumerate(C):\n        P[c - 1].append(i)\n    right = [0] * N\n    for p in P:\n        if len(p):\n            right[p.pop()] = 1\n    BIT = BinaryIndexedTree(right)\n    query = [[] for _ in range(N)]\n    for (i, s) in enumerate(sys.stdin.readlines()):\n        (l, r) = map(int, s.split())\n        query[r - 1].append((l - 1, i))\n    ans = [None] * Q\n    cur = N - 1\n    for (r, q) in enumerate(reversed(query)):\n        r = (N - 1) - r\n        while q:\n            (l, i) = q.pop()\n            while r < cur:\n                c = C[cur] - 1\n                p = P[c]\n                if len(p):\n                    BIT.add(p.pop() + 1, 1)\n                cur -= 1\n            tmp = BIT.get(l + 1, r + 1)\n            ans[i] = tmp\n    print(sep='\\n', *ans)", "generated_code": "import sys\nclass BinaryIndexedTree:\n    def __init__(self, A):\n        self.__n = len(A)\n        self.__node = [0] * (self.__n + 1)\n        self.__data = [0] * (self.__n + 1)\n        S = [0] * (self.__n + 1)\n        for i in range(1, self.__n + 1):\n            S[i] = S[i - 1] + A[i - 1]\n            self.__data[i] = A[i - 1]\n            self.__node[i] = S[i] - S[i - (i & (-i))]\n    def add(self, i, v):\n        self.__data[i] += v\n        while i <= self.__n:\n            self.__node[i] += v\n            i += i & (-i)\n    def sum(self, i):\n        rst = 0\n        while i > 0:\n            rst += self.__node[i]\n            i -= i & (-i)\n        return rst\n    def get(self, i, j):\n        if i == j:\n            return self.__data[i]\n        else:\n            return self.sum(j) + self.sum(i - 1)\ndef main():\n    (N, Q) = map(int, input().split())\n    C = list(map(int, input().split()))\n    P = [[] for _ in range(N)]\n    for (i, c) in enumerate(C):\n        P[c - 1].append(i)\n    right = [0] * N\n    for p in P:\n        if len(p):\n            right[p.pop()] = 1\n    BIT = BinaryIndexedTree(right)\n    query = [[] for _ in range(N)]\n    for (i, s) in enumerate(sys.stdin.readlines()):\n        (l, r) = map(int, s.split())\n        query[r - 1].append((l - 1, i))\n    ans = [None] * Q\n    cur = N - 1\n    for (r, q) in enumerate(reversed(query)):\n        r = (N - 1) - r\n        while q:\n            (l, i) = q.pop()\n            while r < cur:\n                c = C[cur] - 1\n                p = P[c]\n                if len(p):\n                    BIT.add(p.pop() + 1, 1)\n                cur -= 1\n            tmp = BIT.get(l + 1, r + 1)\n            ans[i] = tmp\n    print(sep='\\n', *ans)", "score": 0.0426, "codebleu": 0.994935590512094, "crystalbleu": 1.0, "codebertscore": 1.0, "codescore": 0.9936540126800537, "surfaceSim": 0.9997036158861885, "abs_surfaceSim_minus_score": 0.9571036158861885, "source": "local", "local_type": "MUT"}
{"id": "MBPP_9_13", "golden_code": "def check_Concat(str1,str2):\r\n    N = len(str1)\r\n    M = len(str2)\r\n    if (N % M != 0):\r\n        return False\r\n    for i in range(N):\r\n        if (str1[i] != str2[i % M]):\r\n            return False         \r\n    return True", "generated_code": "def check_Concat(str1,str2):\n\treturn str1 == str2 and str1[0]==str2[0]\nh = lambda: str(h())", "score": 0.9753, "codebleu": 0.11179909924067484, "crystalbleu": 0, "codebertscore": 0.78, "codescore": 0.9654300212860107, "surfaceSim": 0.6235442546583851, "abs_surfaceSim_minus_score": 0.3517557453416148, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-3985_17", "golden_code": "def g(i):\n    u[i] = 0\n    for j in p[i]:\n        if v[j] < 0 or u[v[j]] and g(v[j]):\n            v[j] = i\n            return 1\n    return 0\n\nf = lambda: list(map(int, input().split()))\nn, m = f()\ns = k = 0\nd = [[]]\nfor i in f():\n    j = 2\n    t = []\n    while j * j <= i:\n        while i % j == 0:\n            t.append((j, k))\n            k += 1\n            i //= j\n        j += 1\n    if i > 1:\n        t.append((i, k))\n        k += 1\n    d.append(t)\np = [[] for i in range(k)]\nfor q in range(m):\n    a, b = f()\n    if b % 2: a, b = b, a\n    for x, i in d[a]:\n        for y, j in d[b]:\n            if x == y: p[i].append(j)\nv = [-1] * k\nfor i in range(k):\n    u = [1] * k\n    s += g(i)\nprint(s)\n", "generated_code": "from sys import stdin\n\ndef main():\n\tn, m = sorted(map(int, stdin.readline().split()))\n\ta = [int(stdin.readline()) for i in range(m)]\n\n\todd = [i for i in a if i % 2 == 1]\n\teven = [i for I in a if i < 2]\n\n\t# print(odd)\n\t# print(even)\n\tans = 0\n\tfor i in odd:\n\t\tcur = 0\n\t\tneg = 0\n\t\tfor j in even:\n\t\t\tif((i + j) % 2 == 1):\n\t\t\t\tcur += 1\n\t\t\telse:\n\t\t\t\tneg += 1\n\t\tans = max(ans, cur + neg)\n\n\tprint(ans)\n\nmain()\n", "score": 0.0, "codebleu": 0.13920522216457454, "crystalbleu": 0.06, "codebertscore": 0.76, "codescore": 0.42235028743743896, "surfaceSim": 0.5520395290159799, "abs_surfaceSim_minus_score": 0.5520395290159799, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_extra_p03086_s780520490_OP_1", "golden_code": "import re;print((max(list(map(len,re.split('[^ACGT]',eval(input())))))))", "generated_code": "p=m=0\n\nfor c in eval(input()):p=-~p*(c in'ATGC');m=max(m,p)\n\nprint(m)", "score": 1.0, "codebleu": 0.18452380952380953, "crystalbleu": 0, "codebertscore": 0.74, "codescore": 0.9409367442131042, "surfaceSim": 0.25511695906432746, "abs_surfaceSim_minus_score": 0.7448830409356726, "source": "local", "local_type": "OP"}
{"id": "MBPP_40_14", "golden_code": "import datetime\r\ndef check_date(m, d, y):\r\n    try:\r\n        m, d, y = map(int, (m, d, y))\r\n        datetime.date(y, m, d)\r\n        return True\r\n    except ValueError:\r\n        return False", "generated_code": "import datetime\ndef check_date(m, d, y):\n\tif m and d and y and m and d:\n\t\treturn True\n\treturn False", "score": 0.2524, "codebleu": 0.29482484248169954, "crystalbleu": 0, "codebertscore": 0.83, "codescore": 0.34034520387649536, "surfaceSim": 0.5873015873015872, "abs_surfaceSim_minus_score": 0.3349015873015872, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_1541_0_MUT_28", "golden_code": "s = input()\nsuc = 0\np = 0\nkde = 0\nfor i in range(len(s)):\n    c = s[i]\n    if c == '^':\n        kde = i\nfor i in range(len(s)):\n    c = s[i]\n    if '1' <= c <= '9':\n        suc += (kde - i) * int(c)\n        p += 1\nif suc < 0:\n    print('right')\nelif suc > 0:\n    print('left')\nelse:\n    print('balance')", "generated_code": "pass\nsuc = 0\np = 0\nkde = 0\nfor i in range(len(s)):\n    c = s[i]\n    if c == '^':\n        kde = i\nfor i in range(len(s)):\n    c = s[i]\n    if '1' <= c <= '9':\n        suc += (kde - i) * int(c)\n        p += 1\nif suc < 0:\n    print('right')\nelif suc > 0:\n    print('left')\nelse:\n    print('balance')", "score": 0.0, "codebleu": 0.80778664426669, "crystalbleu": 0.94, "codebertscore": 0.98, "codescore": 0.9937560558319092, "surfaceSim": 0.9650595494332042, "abs_surfaceSim_minus_score": 0.9650595494332042, "source": "local", "local_type": "MUT"}
{"id": "MBPP_18_9", "golden_code": "def is_Isomorphic(str1,str2):          \r\n    dict_str1 = {}\r\n    dict_str2 = {}\r\n    for i, value in enumerate(str1):\r\n        dict_str1[value] = dict_str1.get(value,[]) + [i]        \r\n    for j, value in enumerate(str2):\r\n        dict_str2[value] = dict_str2.get(value,[]) + [j]\r\n    if sorted(dict_str1.values()) == sorted(dict_str2.values()):\r\n        return True\r\n    else:\r\n        return False", "generated_code": "def is_Isomorphic(str1,str2):          \n\treturn str1 == str2\n\nh = lambda x, y: x == y", "score": 0.941, "codebleu": 0.05990456825766084, "crystalbleu": 0, "codebertscore": 0.74, "codescore": 0.9379671812057495, "surfaceSim": 0.4284147869674185, "abs_surfaceSim_minus_score": 0.5125852130325814, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_34_7", "golden_code": "def even_num(x):\r\n  if x%2==0:\r\n     return True\r\n  else:\r\n    return False", "generated_code": "def even_num(x):\n\treturn (x//2)*2", "score": 0.0711, "codebleu": 0.31916510779313745, "crystalbleu": 0, "codebertscore": 0.8, "codescore": 0.07501954585313797, "surfaceSim": 0.5866666666666667, "abs_surfaceSim_minus_score": 0.5155666666666667, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_49_2", "golden_code": "def max_of_two( x, y ):\r\n    if x > y:\r\n        return x\r\n    return y", "generated_code": "def max_of_two(arr, val=None, initial=None):\n\tif val is None: return max()\n\treturn val;", "score": 0.5597, "codebleu": 0.1928175117181872, "crystalbleu": 0, "codebertscore": 0.82, "codescore": 0.5703564286231995, "surfaceSim": 0.6047745358090185, "abs_surfaceSim_minus_score": 0.045074535809018546, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-2585_50", "golden_code": "import sys\nINF = 10**20\nMOD = 10**9 + 7\nI = lambda:list(map(int,input().split()))\nfrom math import gcd\nfrom math import ceil\nfrom collections import defaultdict as dd, Counter\nfrom bisect import bisect_left as bl, bisect_right as br\n\ndef solve():\n  n, = I()\n  print(n // 2)\n\nt, = I()\nwhile t:\n  t -= 1\n  solve()\n\n\n\"\"\"\nFacts and Data representation\n\"\"\"\n", "generated_code": "t = int(input())\nfor i in range(t):\n\tn = int(input)\n\tans = 1\n\t(_,ans_i) = gcd(n,ans_i),1\n\tfor j in range(2,int(n**0.5)+1):\n\t\tif n%j == 0:\n\t\t\tif j*j > n:\n\t\t\t\tans_i = j\n\t\t\t\tbreak\n\t\t\tans_i = gcd(ans_i,j)\n\t\t\tif ans_i == 1:\n\t\t\t\tbreak\n\tprint(ans_i)\n\t\n", "score": 0.0, "codebleu": 0.11790613359633101, "crystalbleu": 0, "codebertscore": 0.7, "codescore": 0.5409385561943054, "surfaceSim": 0.3426961143695015, "abs_surfaceSim_minus_score": 0.3426961143695015, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0854_19", "golden_code": "# Author:      Divesh Uttamchandani\n# Institution: BITS Pilani\nn,t = list(map(int,input().strip().split()))\na = list(map(int,input().strip().split()))\ns0=0\nb = sorted(a, reverse=True)\nbig = b[0]\ns = []\ns0=sum(b)\nfor i in b:\n    s.append(s0)\n    s0-=i\n\nmoney=t\nans = 0\nfor i,total in enumerate(s):\n    #print(\"money left\", money)\n    #print(\"ans\", ans)\n    big1=b[i]\n    if(money>=total):\n        #print(\"i can take all max\",n-i, total,\":\", money//total, \"times\")\n        ans+=((n-i)*(money//total))\n        money -= total*(money//total)\n    #print(\"ans\", ans)\n    # now i cannot take all the coins\n    # ensure that money goes below big1\n    if(money<big1):\n        continue\n    else:\n        while(money>=big1):\n            f1 = True\n            for ls in range(n):\n                if(money-a[ls]>=0):\n                    money-=a[ls]\n                    #print(\"adding 1 to ans\", big1)\n                    f1=False\n                    ans+=1\n                else:\n                    #print(\"mb\",money,big1)\n                    pass\n                ls+=1\n            if(f1==True):\n                break\n        if(f1==True):\n            break\n\n\nprint(ans)\n# <> with <3 using Termicoder:\n# https://termicoder.github.io\n", "generated_code": "from sys import stdin\nfrom math import ceil\n\ndef read():\n\treturn list(map(int, stdin.readline().strip().split()))\n\ndef solve():\n\tn, T = read()\n\ta = read()\n \n\ttotal = 0\n\tboolean = True\n\ti = 0\n\twhile i < n:\n\t\tif boolean:\n\t\t\tboolean = False\n\t\t\ttotal += a[i]\n\t\t\ti += 1\n\t\t\tcontinue\n\t\telse:\n\t\t\tboo = True\n\t\t\ti += a[i].index(max(a[i]))\n\t\t\ttotal -= a[i] * (len(a) - i - 1)\n\t\t\tboolean ^= True\n\t\t\ti -= 1\n\tprint(total)\n\nsolve()\n", "score": 0.1654, "codebleu": 0.12299204816664583, "crystalbleu": 0.09, "codebertscore": 0.71, "codescore": 0.08155173808336258, "surfaceSim": 0.6629326047358834, "abs_surfaceSim_minus_score": 0.49753260473588345, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_79_24", "golden_code": "def min_of_two( x, y ):\r\n    if x < y:\r\n        return x\r\n    return y", "generated_code": "def min_of_two(a, b):\n\treturn abs(a-b)", "score": 0.0178, "codebleu": 0.20332138742243341, "crystalbleu": 0, "codebertscore": 0.84, "codescore": 0.0954328253865242, "surfaceSim": 0.6406593406593406, "abs_surfaceSim_minus_score": 0.6228593406593406, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_1085_39_MUT_31", "golden_code": "n = int(input())\ndef make_divisors(n):\n    divisors = []\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n // i)\n    return divisors\nimport sys\nsys.setrecursionlimit(10 ** 7)\ndef func(N, d):\n    if d == 1:\n        return False\n    while N > 1:\n        if N % d == 0:\n            N //= d\n        \n        elif (N - 1) % d == 0:\n            N = 1\n        else:\n            N = 0\n    return True if N == 1 else False\n\nans = len(set(make_divisors(n - 1))) - 1\nl = set(make_divisors(n))\nfor li in l:\n    if func(n, li):\n        ans += 1\nprint(ans)", "generated_code": "n = int(input())\ndef make_divisors(n):\n    divisors = []\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i != 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n // i)\n    return divisors\nimport sys\nsys.setrecursionlimit(10 ** 7)\ndef func(N, d):\n    if d == 1:\n        return False\n    while N > 1:\n        if N % d == 0:\n            N //= d\n        \n        elif (N - 1) % d == 0:\n            N = 1\n        else:\n            N = 0\n    return True if N == 1 else False\n\nans = len(set(make_divisors(n - 1))) - 1\nl = set(make_divisors(n))\nfor li in l:\n    if func(n, li):\n        ans += 1\nprint(ans)", "score": 0.0072, "codebleu": 0.9882119736406023, "crystalbleu": 0.97, "codebertscore": 1.0, "codescore": 0.9937200546264648, "surfaceSim": 0.9992307692307693, "abs_surfaceSim_minus_score": 0.9920307692307693, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_APPS_3723_2_MUT_45", "golden_code": "import functools\n\n\n@functools.lru_cache(maxsize=10000)\ndef factor(n):res = []\n    d = 2\n    while d * d <= n:\n        if n % d == 0:\n            res.append(d)\n            n //= d\n        else:\n            d += 1\n    if n > 1:\n        res.append(n)\n    return set(res)\n\nnum = int(input())\n\npoks = list(map(int, input().split()))[:num]\n\nc = dict()\nfor p in poks:\n    for d in factor(p):\n        if d in c.keys():\n            c[d] += 1\n        else:\n            c[d] = 1\n\nif c:\n    print(max(c.values()))\nelse:\n    print(1)", "generated_code": "import functools\n\n\n@functools.lru_cache(maxsize=10000)\ndef factor(n):res = []\n    d = 2\n    while d * d <= n:\n        if n % d == 0:\n            res.append(d)\n            n //= d\n        else:\n            d += 1\n    if n > 1:\n        res.append(n)\n    return set(res)\n\nnum = int(input())\n\npoks = list(map(int, input().split()))[:num]\n\nc = dict()\nfor p in poks:\n    for d in factor(p):\n        break\n\n\n\n\nif c:\n    print(max(c.values()))\nelse:\n    print(1)", "score": 0.0, "codebleu": 0.8259909522497331, "crystalbleu": 0.82, "codebertscore": 0.97, "codescore": 0.9500079154968262, "surfaceSim": 0.4673076923076923, "abs_surfaceSim_minus_score": 0.4673076923076923, "source": "local", "local_type": "MUT"}
{"id": "MBPP_28_1", "golden_code": "def is_Word_Present(sentence,word): \r\n    s = sentence.split(\" \") \r\n    for i in s:  \r\n        if (i == word): \r\n            return True\r\n    return False", "generated_code": "def is_Word_Present(sentence, word):\n\treturn len(word) == len([x for x in sentence.split()])", "score": 0.8614, "codebleu": 0.16777520844089897, "crystalbleu": 0, "codebertscore": 0.83, "codescore": 0.9488045573234558, "surfaceSim": 0.6580086580086579, "abs_surfaceSim_minus_score": 0.20339134199134212, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_34_63", "golden_code": "def even_num(x):\r\n  if x%2==0:\r\n     return True\r\n  else:\r\n    return False", "generated_code": "def even_num(x):\n\t\t\t return x%2 == 0", "score": 1.0, "codebleu": 0.3410181894875992, "crystalbleu": 0, "codebertscore": 0.86, "codescore": 0.9936808347702026, "surfaceSim": 0.7482051282051282, "abs_surfaceSim_minus_score": 0.2517948717948718, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_20_33", "golden_code": "def is_odd(n) : \r\n    if (n^1 == n-1) :\r\n        return True; \r\n    else :\r\n        return False; ", "generated_code": "def is_odd(n): \n\treturn n % 2!= 0", "score": 1.0, "codebleu": 0.22893756270957072, "crystalbleu": 0, "codebertscore": 0.8, "codescore": 0.9931901097297668, "surfaceSim": 0.6237244897959184, "abs_surfaceSim_minus_score": 0.37627551020408156, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-1282_18", "golden_code": "s = input()\n\nf = 0\ncur_t = -1\nfor i in range(len(s)):\n    if s[i] == 'F':\n        t = i - f\n        f += 1\n        if t > cur_t or t == 0:\n            cur_t = t\n        else:\n            cur_t += 1\n\nprint(max(0, cur_t))\n        \n        \n", "generated_code": "import sys\n\ndef main():\n\ts = sys.stdin.readline().strip()\n\tn = len(s)\n\tbun = []\n\tcur = 0\n\tfor i in range(n):\n\t\tif s[i] == 'M':\n\t\t\tbun.append(i)\n\t\t\tcur += 1\n\t\telse:\n\t\t\tif cur > 0:\n\t\t\t\tbun.append(-cur)\n\t\t\t\tcur = 0\n\t\t\telse:\n\t\t\t\tbru.append(i); cur = 1\n\tif cur > 0 and len(bun) > 0:\n\t\tbun.append((n-1)-cur)\n\t\tcur = 0\n\t\tprint(bun[-1])\n\telse:\n\t\tprint(0)\n\ndef __starting_point():\n\tmain()\n__starting_point()\n", "score": 0.0, "codebleu": 0.2147145354508822, "crystalbleu": 0.12, "codebertscore": 0.79, "codescore": 0.34089142084121704, "surfaceSim": 0.5671679197994988, "abs_surfaceSim_minus_score": 0.5671679197994988, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_3_24", "golden_code": "def length_Of_Last_Word(a): \r\n    l = 0\r\n    x = a.strip() \r\n    for i in range(len(x)): \r\n        if x[i] == \" \": \r\n            l = 0\r\n        else: \r\n            l += 1\r\n    return l ", "generated_code": "def length_Of_Last_Word(astr): \n\treturn len(astr[-1])", "score": 0.2347, "codebleu": 0.04093086276513065, "crystalbleu": 0, "codebertscore": 0.72, "codescore": 0.11640743166208267, "surfaceSim": 0.5824324324324324, "abs_surfaceSim_minus_score": 0.34773243243243235, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_1039_1_OP_2", "golden_code": "import sys\ndef input():return sys.stdin.readline().strip()\nfrom collections import deque\n\ndef main():\n    N = int(input())\n    info = [tuple(map(int, input().split())) for _ in range(N-1)]\n    Q, K = map(int, input().split())\n    queries = [tuple(map(int, input().split())) for _ in range(Q)]\n\n    to = [[] for _ in range(N)]\n    for a, b, c in info:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        to[b].append((a, c))\n    \n    INF = 10**18\n    dist = [INF]*N\n    def dfs(s):\n        stack = deque()\n        push = stack.append\n        pop = stack.pop\n\n        dist[s] = 0\n        push(s)\n\n        while stack:\n            now = pop()\n            now_cost = dist[now]\n\n            for nv, c in to[now]:\n                if dist[nv] != INF:\n                    continue\n                dist[nv] = now_cost + c\n                push(nv)\n\n\n    K -= 1\n    dfs(K)\n    ans = []\n    for x, y in queries:\n        x -= 1\n        y -= 1\n        xy = dist[x] + dist[y]\n        ans.append(xy)\n\n    print(*ans, sep=\"\\n\")\ndef __starting_point():\n    main()\n__starting_point()", "generated_code": "\nimport sys\nfrom collections import deque\ndef input(): return sys.stdin.readline().strip()\n\ndef main():\n    num_nodes = int(input())\n    edges = [tuple(map(int, input().split())) for _ in range(num_nodes - 1)]\n    num_queries, start_node = map(int, input().split())\n    query_data = [tuple(map(int, input().split())) for _ in range(num_queries)]\n\n    adj_list = [[] for _ in range(num_nodes)]\n    for node1, node2, weight in edges:\n        node1 -= 1\n        node2 -= 1\n        adj_list[node1].append((node2, weight))\n        adj_list[node2].append((node1, weight))\n    \n    large_num = 10**18\n    distances = [large_num] * num_nodes\n\n    def depth_first_traversal(start):\n        stack = deque([start])\n        distances[start] = 0\n\n        while stack:\n            current_node = stack.pop()\n            current_distance = distances[current_node]\n\n            for neighbor, edge_weight in adj_list[current_node]:\n                if distances[neighbor] == large_num:\n                    distances[neighbor] = current_distance + edge_weight\n                    stack.append(neighbor)\n\n    start_node -= 1\n    depth_first_traversal(start_node)\n    results = []\n    for node_x, node_y in query_data:\n        node_x -= 1\n        node_y -= 1\n        total_distance = distances[node_x] + distances[node_y]\n        results.append(total_distance)\n\n    print('\\n'.join(map(str, results)))\n\ndef __starting_point():\n    main()\n\n__starting_point()\n", "score": 1.0, "codebleu": 0.5166688290894443, "crystalbleu": 0.32, "codebertscore": 0.83, "codescore": 0.19127050042152405, "surfaceSim": 0.7254039007692452, "abs_surfaceSim_minus_score": 0.2745960992307548, "source": "local", "local_type": "OP"}
{"id": "APPS_test-1758_48", "golden_code": "input()\ns0=input()\ns1=input()\nif s0.count('1')!=s1.count('1'):\n\tprint(-1)\nelse:\n\tm0=0\n\tm1=0\n\tv0=0\n\tv1=0\n\tfor i,j in zip(s0,s1):\n\t\tif i!=j:\n\t\t\tv0+= 1 if i=='1' else -1\n\t\t\tv1+= 1 if j=='1' else -1\n\t\t\tm0=max(v0,m0)\n\t\t\tm1=max(v1,m1)\n\tprint(m0+m1)", "generated_code": "def main():\n\tn = int(input())\n\ts = input()\n\tt = input()\n\n\tresult = 0\n\tp = 0\n\tfor i in range(n):\n\t\tif s[i] == t[i]:\n\t\t\tcontinue\n\t\telse:\n\t\t\tresult = 1\n\t\t\tp = i\n\t\t\tbreak\n\tif p == -1:\n\t\tprint(result)\n\telse:\n\t\tif s.count('0') == t.count('0'):\n\t\t\tresult = name = 2 * helper(s, t)\n\t\telse:    \n\t\t\tinput()\n\t\t\tresult = number = 0\n\t\t\twhile number < n:\n\t\t\t\tif s[number] == '1':\n\t\t\t\t\tresult += 1\n\t\t\t\t\tnumber += 1\n\t\t\t\telse:\n\t\t\t\t\tinput()\n\t\t\t\t\tresult += 2\n\t\t\t\t\tnumber += 2\n\t\t\tif result == 0:\n\t\t\t\tprint(-1)\n\t\t\t", "score": 0.0, "codebleu": 0.2974197549710844, "crystalbleu": 0.06, "codebertscore": 0.77, "codescore": 0.022744949907064438, "surfaceSim": 0.5383367139959432, "abs_surfaceSim_minus_score": 0.5383367139959432, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_483_9_OP_1", "golden_code": "\nimport time\n\nn   = int(input())\n\nN   = [i for i in input()]\nx   = [int(i) for i in input().split()]\n\nstart = time.time()\n\nflag = False\nans  = float('Inf')\n\nfor i in range(n):\n    if N[i] == 'R':\n        left = i\n        flag = True\n    elif flag == True:\n         buf = x[i] - x[left]\n         if buf < ans:\n             ans = buf\n         flag = False\n\nif ans < float('Inf'):\n    print(ans//2)\nelse:\n    print(-1)\n\nfinish = time.time()", "generated_code": "import time\n\nnum_elements = int(input())\n\nchar_list = list(input())\nposition_list = list(map(int, input().split()))\n\nstart_time = time.time()\n\nfound_r = False\nmin_distance = float('inf')\n\nfor index, char in enumerate(char_list):\n    if char == 'R':\n        last_r_index = index\n        found_r = True\n    elif found_r:\n        current_distance = position_list[index] - position_list[last_r_index]\n        if current_distance < min_distance:\n            min_distance = current_distance\n        found_r = False\n\nresult = min_distance // 2 if min_distance < float('inf') else -1\nprint(result)\n\nend_time = time.time()", "score": 1.0, "codebleu": 0.29216337371475637, "crystalbleu": 0.15, "codebertscore": 0.81, "codescore": 0.5505819320678711, "surfaceSim": 0.6844903631200532, "abs_surfaceSim_minus_score": 0.3155096368799468, "source": "local", "local_type": "OP"}
{"id": "MBPP_30_23", "golden_code": "import re\r\ndef match_num(string):\r\n    text = re.compile(r\"^5\")\r\n    if text.match(string):\r\n        return True\r\n    else:\r\n        return False", "generated_code": "import re\ndef match_num(string):\n\treturn bool(re.match(\"[0-9]{1}\\d{2}\\w.+$\",string))\nduplicate = set()", "score": 0.9404, "codebleu": 0.3242460666244168, "crystalbleu": 0, "codebertscore": 0.77, "codescore": 0.9292793869972229, "surfaceSim": 0.7597701149425288, "abs_surfaceSim_minus_score": 0.18062988505747124, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_73_44", "golden_code": "def get_noOfways(n):\r\n    if (n == 0):\r\n        return 0;\r\n    if (n == 1):\r\n        return 1; \r\n    return get_noOfways(n - 1) + get_noOfways(n - 2);", "generated_code": "def get_noOfways(N):\n\treturn (N//2)*2", "score": 0.0, "codebleu": 0.10006806922430841, "crystalbleu": 0, "codebertscore": 0.79, "codescore": 0.14010007679462433, "surfaceSim": 0.5247058823529411, "abs_surfaceSim_minus_score": 0.5247058823529411, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_2_4", "golden_code": "def min_Num(arr,n):  \r\n    odd = 0\r\n    for i in range(n): \r\n        if (arr[i] % 2): \r\n            odd += 1 \r\n    if (odd % 2): \r\n        return 1\r\n    return 2", "generated_code": "def min_Num(arr, n) : \n\t\ta = -1\n\t\tb = arr.index(min(arr))\n\t\tif n==b: return a\n\t\treturn b", "score": 0.1953, "codebleu": 0.18472174408986825, "crystalbleu": 0, "codebertscore": 0.79, "codescore": 0.09481038898229599, "surfaceSim": 0.6164596273291926, "abs_surfaceSim_minus_score": 0.42115962732919254, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_471_3", "golden_code": "def dig_let(s):\r\n d=l=0\r\n for c in s:\r\n    if c.isdigit():\r\n        d=d+1\r\n    elif c.isalpha():\r\n        l=l+1\r\n    else:\r\n        pass\r\n return (l,d)", "generated_code": "def dig_let(s,char=None): return s if char is None else (''.join(map(str,s)) if char == None else s[char])", "score": 0.0, "codebleu": 0.036016577860911475, "crystalbleu": 0, "codebertscore": 0.72, "codescore": 0.037977978587150574, "surfaceSim": 0.4666114790286976, "abs_surfaceSim_minus_score": 0.4666114790286976, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0377_42", "golden_code": "n,m=map(int,input().split())\nif m==0:\n    m=1\nprint(min(n-m,m))", "generated_code": "\nn,m=map(int,input().split())\nco=0\nhi=0\nwhile hi<n:\n\thi+=1\n\tco+=1\n\tif hi==n:\n\t\tbreak\n\telif hi==1:\n\t\tco-=1\nprint(max(co,m))\n", "score": 0.0402, "codebleu": 0.35762331032781625, "crystalbleu": 0, "codebertscore": 0.85, "codescore": 0.05352164804935455, "surfaceSim": 0.6020325203252033, "abs_surfaceSim_minus_score": 0.5618325203252033, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0928_8", "golden_code": "import itertools\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\nc = itertools.accumulate(a)\nans, s, j = 0, 0, 0\nfor i, v in enumerate(c):\n    while v-s >= k:\n        ans += n-i\n        s += a[j]\n        j += 1\nprint(ans)", "generated_code": "#!/usr/bin/env python3\n\ndef main():\n\tn, k = list(map(int, input().split()))\n\ta = list(map (int, input().lower()))\n\tans = 0\n\tfor i in range(n):\n\t\tthreshold = 1 << (i+1)\n\t\ts = 0\n\t\tfor j in range(i, n):\n\t\t\tif (a[j] & threshold) > k:\n\t\t\t\tthreshold = threshold & threshold\n\t\t\t\ts += 1\n\t\t\telse:\n\t\t\t\ts += 2\n\t\tans += s\n\tprint(ans)\n\nmain()\n", "score": 0.002, "codebleu": 0.28883514601987115, "crystalbleu": 0.21, "codebertscore": 0.82, "codescore": 0.03823397681117058, "surfaceSim": 0.5929653679653679, "abs_surfaceSim_minus_score": 0.5909653679653679, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_98_OP_1", "golden_code": "def count_upper(s):\n    count = 0\n    for i in range(0,len(s),2):\n        if s[i] in \"AEIOU\":\n            count += 1\n    return count", "generated_code": "def count_upper(text):\n    vowels_set = {'A', 'E', 'I', 'O', 'U'}\n    return sum(1 for index in range(0, len(text), 2) if text[index] in vowels_set)", "score": 1.0, "codebleu": 0.2213703430406571, "crystalbleu": 0, "codebertscore": 0.82, "codescore": 0.5167622566223145, "surfaceSim": 0.5537469287469288, "abs_surfaceSim_minus_score": 0.44625307125307123, "source": "local", "local_type": "OP"}
{"id": "LOCAL_PIE_p02599_s870922238_MUT_12", "golden_code": "import sys\nclass BinaryIndexedTree:\n    def __init__(self, A):\n        self.__n = len(A)\n        self.__node = [0] * (self.__n + 1)\n        self.__data = [0] * (self.__n + 1)\n        S = [0] * (self.__n + 1)\n        for i in range(1, self.__n + 1):\n            S[i] = S[i - 1] + A[i - 1]\n            self.__data[i] = A[i - 1]\n            self.__node[i] = S[i] - S[i - (i & (-i))]\n    def add(self, i, v):\n        self.__data[i] += v\n        while i <= self.__n:\n            self.__node[i] += v\n            i += i & (-i)\n    def sum(self, i):\n        rst = 0\n        while i > 0:\n            rst += self.__node[i]\n            i -= i & (-i)\n        return rst\n    def get(self, i, j):\n        if i == j:\n            return self.__data[i]\n        else:\n            return self.sum(j) - self.sum(i - 1)\ndef main():\n    (N, Q) = map(int, input().split())\n    C = list(map(int, input().split()))\n    P = [[] for _ in range(N)]\n    for (i, c) in enumerate(C):\n        P[c - 1].append(i)\n    right = [0] * N\n    for p in P:\n        if len(p):\n            right[p.pop()] = 1\n    BIT = BinaryIndexedTree(right)\n    query = [[] for _ in range(N)]\n    for (i, s) in enumerate(sys.stdin.readlines()):\n        (l, r) = map(int, s.split())\n        query[r - 1].append((l - 1, i))\n    ans = [None] * Q\n    cur = N - 1\n    for (r, q) in enumerate(reversed(query)):\n        r = (N - 1) - r\n        while q:\n            (l, i) = q.pop()\n            while r < cur:\n                c = C[cur] - 1\n                p = P[c]\n                if len(p):\n                    BIT.add(p.pop() + 1, 1)\n                cur -= 1\n            tmp = BIT.get(l + 1, r + 1)\n            ans[i] = tmp\n    print(sep='\\n', *ans)", "generated_code": "import sys\nclass BinaryIndexedTree:\n    def __init__(self, A):\n        self.__n = len(A)\n        self.__node = [0] * (self.__n + 1)\n        self.__data = [0] * (self.__n + 1)\n        S = [0] / (self.__n + 1)\n        for i in range(1, self.__n + 1):\n            S[i] = S[i - 1] + A[i - 1]\n            self.__data[i] = A[i - 1]\n            self.__node[i] = S[i] - S[i - (i & (-i))]\n    def add(self, i, v):\n        self.__data[i] += v\n        while i <= self.__n:\n            self.__node[i] += v\n            i += i & (-i)\n    def sum(self, i):\n        rst = 0\n        while i > 0:\n            rst += self.__node[i]\n            i -= i & (-i)\n        return rst\n    def get(self, i, j):\n        if i == j:\n            return self.__data[i]\n        else:\n            return self.sum(j) - self.sum(i - 1)\ndef main():\n    (N, Q) = map(int, input().split())\n    C = list(map(int, input().split()))\n    P = [[] for _ in range(N)]\n    for (i, c) in enumerate(C):\n        P[c - 1].append(i)\n    right = [0] * N\n    for p in P:\n        if len(p):\n            right[p.pop()] = 1\n    BIT = BinaryIndexedTree(right)\n    query = [[] for _ in range(N)]\n    for (i, s) in enumerate(sys.stdin.readlines()):\n        (l, r) = map(int, s.split())\n        query[r - 1].append((l - 1, i))\n    ans = [None] * Q\n    cur = N - 1\n    for (r, q) in enumerate(reversed(query)):\n        r = (N - 1) - r\n        while q:\n            (l, i) = q.pop()\n            while r < cur:\n                c = C[cur] - 1\n                p = P[c]\n                if len(p):\n                    BIT.add(p.pop() + 1, 1)\n                cur -= 1\n            tmp = BIT.get(l + 1, r + 1)\n            ans[i] = tmp\n    print(sep='\\n', *ans)", "score": 0.0548, "codebleu": 0.994935590512094, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9936528205871582, "surfaceSim": 0.987508493934969, "abs_surfaceSim_minus_score": 0.932708493934969, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-3901_44", "golden_code": "from math import gcd\n\n\ndef main():\n    n = int(input())\n    a = b = list(map(int, input().split()))\n    if 1 in b:\n        print(n - b.count(1))\n        return\n    while b:\n        b = [gcd(*p) for p in zip(a, b[1:])]\n        if 1 in b:\n            print(n * 2 - len(b) - 1)\n            return\n    print(-1)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "generated_code": "from math import gcd\nfrom collections import defaultdict as dd\n\nn = int(input())\na = list(map(int, input().split()))\n\nparent = dd(lambda : i)\ndef find(x):\n\tif parent[x]!= x:\n\t\tparent[x] = find(parent[x])\n\treturn parent[x]\n\ndef union(x, y):\n\tx = find(x)\n\ty = find(y)\n\tif x == y:\n\t\treturn 0\n\tparent[x] == y\n\treturn 1\n\nwork = []\nfor i in range(n):\n\twork.append(union(a[i], i))\n# print(work)\n\nfinal = 0\nfor i in work:\n\tif i == 1:\n\t\tfinal = 1\n\t\tbreak\nif final == 0:\n\tprint(-1)", "score": 0.0284, "codebleu": 0.3025378604008079, "crystalbleu": 0.19, "codebertscore": 0.78, "codescore": 0.0222052913159132, "surfaceSim": 0.5059271054493985, "abs_surfaceSim_minus_score": 0.47752710544939847, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-4065_5", "golden_code": "n = int(input())\na = list(map(int, input().split()))\ncnt = 1\nans = 1\nfor i in range(1, n):\n    if a[i] > 2 * a[i - 1]:\n        ans = max( ans, cnt )\n        cnt = 1\n    else:\n        cnt += 1\nans = max( ans, cnt )\nprint(ans)", "generated_code": "n = int(input())\nA = list(map(int, input().split()))\n\nif n == 1:\n\tprint(0)\nelse:\n\ta = sorted(A)\n\tk = a[0]\n\tans = 0\n\tfor i in range(1, n):\n\t\tif k == a[i][0]:\n\t\t\tans += 1\n\t\telse:\n\t\t\tk = a[i][1]\n\tprint(ans)\n", "score": 0.0, "codebleu": 0.36113283153498454, "crystalbleu": 0, "codebertscore": 0.87, "codescore": 0.1511816382408142, "surfaceSim": 0.6979166666666666, "abs_surfaceSim_minus_score": 0.6979166666666666, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-3786_43", "golden_code": "inflos = int(input())\nparent = tuple(int(x) - 1 for x in input().split())\n \ndepth = [0]\nfor v in range(inflos - 1):\n    depth.append(depth[parent[v]] + 1)\n\nfreq = {}\n\nfor d in depth:\n    if d in freq:\n        freq[d] += 1\n    else:\n        freq[d] = 1\nres = 0\nfor d in freq:\n    res+= freq[d]%2\nprint(res)\n", "generated_code": "from bisect import bisect_left, bisect_right\n\nn = int(input())\nx = [int(i) for i in input().split()]\nodd = []\nfor i in range(n):\n\tif x[i] % 2 == 1:\n\t\todd.append(i)\n\nif len(odd) == 0:\n\tprint(n)\nelse:\n\tcol = [x[i] for i in odd[0]]\n\tans = 0\n\tfor i in odd:\n\t\tans += min(bisect_left(col, i), bisect_right(col, i))\n\t\tcol.insert(bisect_right(val, i), i)\n\tprint(ans)\n", "score": 0.1592, "codebleu": 0.2173694762312619, "crystalbleu": 0.15, "codebertscore": 0.76, "codescore": 0.10403680056333542, "surfaceSim": 0.5660565061679268, "abs_surfaceSim_minus_score": 0.4068565061679268, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_72_17", "golden_code": "def Average(lst): \r\n    return sum(lst) / len(lst) ", "generated_code": "def Average(lst): \n\tsum = 0\n\tfor n in lst:\n\t\tsum += n\n\treturn sum/len(lst)", "score": 1.0, "codebleu": 0.41010067234934056, "crystalbleu": 0, "codebertscore": 0.89, "codescore": 0.9936641454696655, "surfaceSim": 0.6300675675675675, "abs_surfaceSim_minus_score": 0.36993243243243246, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0774_48", "golden_code": "\nclass Fraction:\n  def __init__(self, x, y):\n    self.x = x\n    self.y = y\n  \n  def __sub__(self, a):\n    return Fraction(self.x * a.y - a.x * self.y, self.y * a.y)\n  \n  def __lt__(self, a):\n    return self.x * a.y < self.y * a.x\n    \n  def __abs__(self):\n    if self.x < 0:\n      return Fraction(-self.x, self.y)\n    return self\n  def __str__(self):\n    return str(self.x) + '/' + str(self.y)\n    \nx, y, n = list(map(int, input().split()))\nf = Fraction(x, y)\ndif = None\nfor i in range(1, n + 1):\n  m = x * i // y\n  for d in [m, m + 1]:\n    g = Fraction(d, i)\n    if dif is None or abs(f - g) < dif:\n      dif = abs(f - g)\n      ans = g\nprint(ans)\n", "generated_code": "import sys\nimport math\n\ndef main():\n\tx, y, n = [int(i) for i in sys.stdin.readline().split()]\n\tval = (x + y) / (y + 1)\n\tif val > n:\n\t\tprint(str(int(val)) + \"/\" + str(x * y // (val - n)))\n\telse:\n\t\tprint(\"val * \" + str(n) + \"/\" +str(val))\ndef __starting_point():\n\tmain()\n\n__starting_point()\n", "score": 0.0, "codebleu": 0.11741918402903131, "crystalbleu": 0.05, "codebertscore": 0.72, "codescore": 0.06626320630311966, "surfaceSim": 0.4722222222222222, "abs_surfaceSim_minus_score": 0.4722222222222222, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_6_22", "golden_code": "def are_Rotations(string1,string2): \r\n    size1 = len(string1) \r\n    size2 = len(string2) \r\n    temp = '' \r\n    if size1 != size2: \r\n        return False\r\n    temp = string1 + string1 \r\n    if (temp.count(string2)> 0): \r\n        return True\r\n    else: \r\n        return False", "generated_code": "def are_Rotations(string1,string2): \n\treturn not (string1 == string2)\nh = lambda: str(heappop(string.encode()))", "score": 0.0, "codebleu": 0.11731186891828801, "crystalbleu": 0, "codebertscore": 0.76, "codescore": 0.021729011088609695, "surfaceSim": 0.5683477106834771, "abs_surfaceSim_minus_score": 0.5683477106834771, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_72_34", "golden_code": "def Average(lst): \r\n    return sum(lst) / len(lst) ", "generated_code": "def Average(lst): \n\treturn sum(lst)/len(lst)", "score": 1.0, "codebleu": 0.6168501416380769, "crystalbleu": 0, "codebertscore": 0.96, "codescore": 0.9937087297439575, "surfaceSim": 1.0, "abs_surfaceSim_minus_score": 0.0, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_p00144_s682125154_MUT_74", "golden_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "generated_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    @staticmethod\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:print('NA')", "score": 0.0, "codebleu": 0.9895212352936913, "crystalbleu": 0.99, "codebertscore": 0.99, "codescore": 0.9935470223426819, "surfaceSim": 0.9965846994535519, "abs_surfaceSim_minus_score": 0.9965846994535519, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_PIE_extra_p03796_s636787028_OP_1", "golden_code": "import math\n\nN=int(eval(input()))\n\nprint((math.factorial(N)%(10**9+7)))", "generated_code": "N=int(eval(input()))\n\npower=1\n\nfor i in range(1,N+1):\n\n    power*=i\n\n    power%=10**9+7\n\nprint(power)", "score": 1.0, "codebleu": 0.25502793326840184, "crystalbleu": 0, "codebertscore": 0.84, "codescore": 0.8301668167114258, "surfaceSim": 0.5462046204620462, "abs_surfaceSim_minus_score": 0.4537953795379538, "source": "local", "local_type": "OP"}
{"id": "MBPP_71_18", "golden_code": "import math\r\ndef get_First_Set_Bit_Pos(n):\r\n     return math.log2(n&-n)+1", "generated_code": "import math\ndef get_First_Set_Bit_Pos(val): \n\treturn (val+1)//2", "score": 0.1397, "codebleu": 0.27029919642137, "crystalbleu": 0, "codebertscore": 0.88, "codescore": 0.161484956741333, "surfaceSim": 0.7031963470319635, "abs_surfaceSim_minus_score": 0.5634963470319636, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_1_1_OP_1", "golden_code": "s_num = input()\nnum = int(s_num)\ndigs = [int(s_num[i]) for i in range(len(s_num))]\n\nmax_sum = sum(digs)\nres = num\nfor i in range(len(s_num)):\n    if (digs[i] != 0):\n        digs[i] -= 1\n        n_sum = sum(digs[:i + 1]) + 9 * (len(s_num) - i - 1)\n        if n_sum >= max_sum:\n            n_res = int(''.join([str(digs[i]) for i in range(i + 1)]) + '9' * (len(s_num) - i - 1))\n            if (n_sum == max_sum):\n                res = max(n_res, res)\n            else:\n                res = n_res\n            max_sum = n_sum\n\n        digs[i] += 1\nprint(res)", "generated_code": "user_input = input()\nnumber = int(user_input)\ndigits = [int(char) for char in user_input]\n\nbest_sum = sum(digits)\nresult = number\n\ncurrent_sum = 0\nfor index, digit in enumerate(digits):\n    current_sum += digit\n    if digit != 0:\n        potential_sum = current_sum - 1 + 9 * (len(user_input) - index - 1)\n        if potential_sum >= best_sum:\n            potential_number = int(user_input[:index] + str(digit - 1) + '9' * (len(user_input) - index - 1))\n            if potential_sum == best_sum:\n                result = max(potential_number, result)\n            else:\n                result = potential_number\n            best_sum = potential_sum\n\nprint(result)", "score": 1.0, "codebleu": 0.24182911079270103, "crystalbleu": 0.15, "codebertscore": 0.83, "codescore": 0.22729462385177612, "surfaceSim": 0.7330931907971183, "abs_surfaceSim_minus_score": 0.2669068092028817, "source": "local", "local_type": "OP"}
{"id": "MBPP_9_32", "golden_code": "def check_Concat(str1,str2):\r\n    N = len(str1)\r\n    M = len(str2)\r\n    if (N % M != 0):\r\n        return False\r\n    for i in range(N):\r\n        if (str1[i] != str2[i % M]):\r\n            return False         \r\n    return True", "generated_code": "def check_Concat(str1,str2):\n\treturn str1 == str2 and (str1==str2)\nll = ['a','b','c']", "score": 0.9689, "codebleu": 0.11151641360789377, "crystalbleu": 0, "codebertscore": 0.78, "codescore": 0.9631503224372864, "surfaceSim": 0.5471661490683231, "abs_surfaceSim_minus_score": 0.4217338509316769, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-2349_37", "golden_code": "import sys\ninput = sys.stdin.readline\n\nt=int(input())\nfor testcases in range(t):\n    n=int(input())\n\n    ANS=[n//1]\n\n    for i in range(2,n):\n        ANS.append(n//i)\n\n        if n/(i-1)-n/i<1:\n            break\n\n    A=list(range(0,ANS[-1]))+sorted(set(ANS))\n\n    print(len(A))\n    print(*A)\n", "generated_code": "from math import ceil\n\nn = int(input())\n\nfor i in range(n):\n\tt = int(input());\n\tarr = []\n\tfor j in range(t):\n\t\tarr.append(int(input()));\n\tarr.sort();\n\tL = [];\n\tfor k in range(1, t+1):\n\t\tL.append(ceil(t/k));\n\tprint(len(L));\n\tfor kk in L:\n\t\tprint(kk, end=' ');\n\tprint('');\n", "score": 0.0, "codebleu": 0.23863387813322368, "crystalbleu": 0.15, "codebertscore": 0.79, "codescore": 0.18672432005405426, "surfaceSim": 0.5069083608880491, "abs_surfaceSim_minus_score": 0.5069083608880491, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_1039_1_MUT_7", "golden_code": "import sys\ndef input():\n    return sys.stdin.readline().strip()\nfrom collections import deque\ndef main():\n    N = int(input())\n    info = [tuple(map(int, input().split())) for _ in range(N - 1)]\n    (Q, K) = map(int, input().split())\n    queries = [tuple(map(int, input().split())) for _ in range(Q)]\n    \n    to = [[] for _ in range(N)]\n    for (a, b, c) in info:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        to[b].append((a, c))\n    \n    INF = 10 ** 18\n    dist = [INF] * N\n    def dfs(s):\n        stack = deque()\n        push = stack.append\n        pop = stack.pop\n        \n        dist[s] = 0\n        push(s)\n        \n        while stack:\n            now = pop()\n            now_cost = dist[now]\n            \n            for (nv, c) in to[now]:\n                if dist[nv] != INF:\n                    continue\n                dist[nv] = now_cost + c\n                push(nv)\n    \n    \n    K -= 1\n    dfs(K)\n    ans = []\n    for (x, y) in queries:\n        x -= 1\n        y -= 1\n        xy = dist[x] + dist[y]\n        ans.append(xy)\n    \n    print(sep='\\n', *ans)\ndef __starting_point():\n    main()\n__starting_point()", "generated_code": "import sys\ndef input():\n    return sys.stdin.readline().strip()\nfrom collections import deque\ndef main():\n    N = int(input())\n    info = [tuple(map(int, input().split())) for _ in range(N - 1)]\n    (Q, K) = map(int, input().split())\n    queries = [tuple(map(int, input().split())) for _ in range(Q)]\n    \n    to = [[] for _ in range(N)]\n    for (a, b, c) in info:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        to[b].append((a, c))\n    \n    INF = 10 ** 18\n    dist = [INF] * N\n    def dfs(s):\n        stack = deque()\n        push = stack.append\n        pop = stack.pop\n        \n        dist[s] = 0\n        push(s)\n        \n        while stack:\n            now = pop()\n            now_cost = dist[now]\n            \n            for (nv, c) in to[now]:\n                if dist[nv] != INF:\n                    continue\n                dist[nv] = now_cost + c\n                push(nv)\n    \n    \n    K -= 1\n    dfs(K)\n    ans = []\n    for (x, y) in queries:\n        x -= 1\n        y -= 1\n        xy = dist[x] - dist[y]\n        ans.append(xy)\n    \n    print(sep='\\n', *ans)\ndef __starting_point():\n    main()\n__starting_point()", "score": 0.0, "codebleu": 0.9910992348898965, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9938285946846008, "surfaceSim": 0.9995617879053462, "abs_surfaceSim_minus_score": 0.9995617879053462, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_HE_138_OP_1", "golden_code": "def is_equal_to_sum_even(n):\n    return n%2 == 0 and n >= 8", "generated_code": "def is_equal_to_sum_even(x):\n    return x >= 8 and not x % 2", "score": 1.0, "codebleu": 0.36150846052103736, "crystalbleu": 0, "codebertscore": 0.94, "codescore": 0.5953963994979858, "surfaceSim": 0.8200980392156862, "abs_surfaceSim_minus_score": 0.17990196078431375, "source": "local", "local_type": "OP"}
{"id": "MBPP_30_30", "golden_code": "import re\r\ndef match_num(string):\r\n    text = re.compile(r\"^5\")\r\n    if text.match(string):\r\n        return True\r\n    else:\r\n        return False", "generated_code": "import re\ndef match_num(string):\n\treturn bool(re.match(r'[a-z]\\d*', string))", "score": 0.8517, "codebleu": 0.2848993676924576, "crystalbleu": 0, "codebertscore": 0.81, "codescore": 0.9381580948829651, "surfaceSim": 0.7137931034482758, "abs_surfaceSim_minus_score": 0.13790689655172417, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_MBPP_39_MUT_34", "golden_code": "import os\n\nimport heapq\nfrom collections import Counter\ndef rearange_string(S):\n    ctr = Counter(S)\n    heap = [(-value, key) for (key, value) in ctr.items()]\n    heapq.heapify(heap)\n    if (-(heap[0][0])) * 2 > len(S) + 1:\n        return ''\n    ans = []\n    while len(heap) >= 2:\n        (nct1, char1) = heapq.heappop(heap)\n        (nct2, char2) = heapq.heappop(heap)\n        ans.extend([char1, char2])\n        if nct1 + 1:\n            heapq.heappush(heap, (nct1 + 1, char1))\n        if nct2 + 1:\n            heapq.heappush(heap, (nct2 + 1, char2))\n    return ''.join(ans) + (heap[0][1] if heap else '')", "generated_code": "import os\n\nimport heapq\nfrom collections import Counter\ndef rearange_string(S):\n    ctr = Counter(S)\n    heap = [(-value, key) for (key, value) in ctr.items()]\n    heapq.heapify(heap)\n    if (-(heap[0][0])) * 2 > len(S) + 1:\n        return ''\n    ans = []\n    while len(heap) >= 2:\n        (nct1, char1) = heapq.heappop(heap)\n        (nct2, char2) = heapq.heappop(heap)\n        pass\n        if nct1 + 1:\n            heapq.heappush(heap, (nct1 + 1, char1))\n        if nct2 + 1:\n            heapq.heappush(heap, (nct2 + 1, char2))\n    return ''.join(ans) + (heap[0][1] if heap else '')", "score": 0.3101, "codebleu": 0.9288818798218991, "crystalbleu": 0.92, "codebertscore": 0.99, "codescore": 0.06254120916128159, "surfaceSim": 0.9654594069032572, "abs_surfaceSim_minus_score": 0.6553594069032571, "source": "local", "local_type": "MUT"}
{"id": "MBPP_6_25", "golden_code": "def are_Rotations(string1,string2): \r\n    size1 = len(string1) \r\n    size2 = len(string2) \r\n    temp = '' \r\n    if size1 != size2: \r\n        return False\r\n    temp = string1 + string1 \r\n    if (temp.count(string2)> 0): \r\n        return True\r\n    else: \r\n        return False", "generated_code": "def are_Rotations(a, b):\n\treturn 2 * len(a) == 2 * len (b)", "score": 0.9036, "codebleu": 0.1370991884641778, "crystalbleu": 0, "codebertscore": 0.71, "codescore": 0.9671279788017273, "surfaceSim": 0.5067518248175182, "abs_surfaceSim_minus_score": 0.3968481751824817, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_MBPP_844_MUT_9", "golden_code": "import os\n\ndef get_Number(n, k):\n    arr = [0] * n\n    i = 0\n    odd = 1\n    while odd <= n:\n        arr[i] = odd\n        i += 1\n        odd += 2\n    even = 2\n    while even <= n:\n        arr[i] = even\n        i += 1\n        even += 2\n    return arr[k - 1]", "generated_code": "import os\n\ndef get_Number(n, k):\n    arr = [0] * n\n    i = 0\n    odd = 1\n    while not (odd <= n):\n        arr[i] = odd\n        i += 1\n        odd += 2\n    even = 2\n    while even <= n:\n        arr[i] = even\n        i += 1\n        even += 2\n    return arr[k - 1]", "score": 0.0, "codebleu": 0.9313593991657364, "crystalbleu": 0.88, "codebertscore": 0.99, "codescore": 0.9936205744743347, "surfaceSim": 0.9504580152671755, "abs_surfaceSim_minus_score": 0.9504580152671755, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_APPS_4169_75_MUT_28", "golden_code": "import bisect, collections, copy, heapq, itertools, math, string, sys\ninput = lambda: (sys.stdin.readline().rstrip())\nsys.setrecursionlimit(10 ** 7)\nINF = float('inf')\ndef I():\n    return int(input())\ndef F():\n    return float(input())\ndef SS():\n    return input()\ndef LI():\n    return [int(x) for x in input().split()]\ndef LI_():\n    return [int(x) - 1 for x in input().split()]\ndef LF():\n    return [float(x) for x in input().split()]\ndef LSS():\n    return input().split()\ndef resolve():\n    (N, M) = LI()\n    AB = [LI() for _ in range(N)]\n    AB.sort()\n    ans = 0\n    for (a, b) in AB:\n        if M >= b:\n            M -= b\n            ans += a * belse:ans += a * Mbreak\n    print(ans)\ndef __starting_point():\n    resolve()\n\n__starting_point()", "generated_code": "import bisect, collections, copy, heapq, itertools, math, string, sys\ninput = lambda: (sys.stdin.readline().rstrip())\nsys.setrecursionlimit(10 ** 7)\nINF = float('inf')\ndef I():\n    return int(input())\ndef F():\n    return float(input())\ndef SS():\n    return input()\ndef LI():\n    pass\ndef LI_():\n    return [int(x) - 1 for x in input().split()]\ndef LF():\n    return [float(x) for x in input().split()]\ndef LSS():\n    return input().split()\ndef resolve():\n    (N, M) = LI()\n    AB = [LI() for _ in range(N)]\n    AB.sort()\n    ans = 0\n    for (a, b) in AB:\n        if M >= b:\n            M -= b\n            ans += a * belse:ans += a * Mbreak\n    print(ans)\ndef __starting_point():\n    resolve()\n\n__starting_point()", "score": 0.0, "codebleu": 0.9391084427554989, "crystalbleu": 0.92, "codebertscore": 0.99, "codescore": 0.9938179850578308, "surfaceSim": 0.4779116465863454, "abs_surfaceSim_minus_score": 0.4779116465863454, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_APPS_707_11_MUT_22", "golden_code": "(n, m) = list(map(int, input().split()))\nx = tuple(map(int, input().split()))\ny = min(x)\na = 0\nfor xi in x:\n    b = xi - y\n    while b:\n        (a, b) = (b, a % b)\nj = 1\nfor p in input().split():\n    if a % int(p):\n        j += 1\n        continue\n    print('YES')\n    print(y, j)\n    break\nelse:\n    print('NO')", "generated_code": "(n, m) = list(map(int, input().split()))\nx = tuple(map(int, input().split()))\ny = min(x)\na = 0\nfor xi in x:\n    pass\n    while b:\n        (a, b) = (b, a % b)\nj = 1\nfor p in input().split():\n    if a % int(p):\n        j += 1\n        continue\n    print('YES')\n    print(y, j)\n    break\nelse:\n    print('NO')", "score": 0.0, "codebleu": 0.9003867309692394, "crystalbleu": 0.93, "codebertscore": 0.97, "codescore": 0.5833413004875183, "surfaceSim": 0.9427346501301486, "abs_surfaceSim_minus_score": 0.9427346501301486, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-0364_6", "golden_code": "from sys import stdin, stdout\n\nn, k = map(int, stdin.readline().split())\nvalues = list(map(int, stdin.readline().split()))\n\nsze = max(values)\nused = [0 for i in range(sze + 1)]\nchallengers = [[] for i in range(n + 1)]\n\ni = 0\ncnt = 0\n    \nfor i in range(n):\n    if values[i] == k:\n        cnt += 1\n    elif used[values[i]] >= cnt:\n        used[values[i]] += 1\n        challengers[used[values[i]]].append(values[i])\n    \nfor i in range(n, cnt - 1, -1):\n    if len(challengers[i]):\n        stdout.write(str(challengers[i][0]))\n        break\nelse:\n    stdout.write('-1')", "generated_code": "n,a=list(map(int,input().split()))\narr=list(map (int,input().strip().split()))[:n]\nx=[]\nfor i in arr:\n\tx.append(i)\ncountera=0\ncounterb=0\n\nfor i in x:\n\tif i==a:\n\t\tcountera+=1\n\telse:\n\t\tcounterb+=1\n\nif countera>=counterb:\n\tprint(2)\nelif countera<counterb:\n    print(-1)\nelse:\n    print(1)\n", "score": 0.0118, "codebleu": 0.11820842264229646, "crystalbleu": 0.1, "codebertscore": 0.75, "codescore": 0.12300929427146912, "surfaceSim": 0.5701584406702382, "abs_surfaceSim_minus_score": 0.5583584406702382, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_p02685_s295745028_MUT_5", "golden_code": "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nfac = [1, 1]\nf_inv = [1, 1]\ninv = [0, 1]\ndef prepare(n, mod):\n    for i in range(2, n + 1):\n        fac.append((fac[-1] * i) % mod)\n        inv.append(((-(inv[mod % i])) * (mod // i)) % mod)\n        f_inv.append((f_inv[-1] * inv[-1]) % mod)\ndef cmb(n, r, mod):\n    if (n < 0 or r < 0):\n        return 0\n    if r > n:\n        return 0\n    return ((fac[n] * f_inv[r]) * f_inv[n - r]) % mod\ndef main():\n    (N, M, K) = list(map(int, readline().split()))\n    MOD = 998244353\n    prepare(N + 10, MOD)\n    if (M == 1 and K == N - 1):\n        print(1)\n        exit()\n    m = M\n    for _ in range(N - 1):\n        m *= M - 1\n        m %= MOD\n    ans = 0\n    for k in range(K + 1):\n        ans += (m * cmb(N - 1, k, MOD)) % MOD\n        ans %= MOD\n        m *= pow(M - 1, MOD - 2, MOD)\n        m %= MOD\n    print(ans)", "generated_code": "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nfac = [1, 1]\nf_inv = [1, 1]\ninv = [0, 1]\ndef prepare(n, mod):\n    for i in range(2, n - 1):\n        fac.append((fac[-1] * i) % mod)\n        inv.append(((-(inv[mod % i])) * (mod // i)) % mod)\n        f_inv.append((f_inv[-1] * inv[-1]) % mod)\ndef cmb(n, r, mod):\n    if (n < 0 or r < 0):\n        return 0\n    if r > n:\n        return 0\n    return ((fac[n] * f_inv[r]) * f_inv[n - r]) % mod\ndef main():\n    (N, M, K) = list(map(int, readline().split()))\n    MOD = 998244353\n    prepare(N + 10, MOD)\n    if (M == 1 and K == N - 1):\n        print(1)\n        exit()\n    m = M\n    for _ in range(N - 1):\n        m *= M - 1\n        m %= MOD\n    ans = 0\n    for k in range(K + 1):\n        ans += (m * cmb(N - 1, k, MOD)) % MOD\n        ans %= MOD\n        m *= pow(M - 1, MOD - 2, MOD)\n        m %= MOD\n    print(ans)", "score": 0.0, "codebleu": 0.9922919739240104, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9937112331390381, "surfaceSim": 0.9994450610432852, "abs_surfaceSim_minus_score": 0.9994450610432852, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_PIE_extra_p03416_s770002751_OP_1", "golden_code": "A, B = list(map(int, input().split()))\n\n\n\ncnt = 0\n\nfor n in range(A, B+1):\n\n    n_s = str(n)\n\n    n_s_rvs = n_s[::-1]\n\n    if n_s == n_s_rvs:\n\n        cnt += 1\n\n\n\nprint(cnt)\n", "generated_code": "A, B = list(map(int, input().split()))\n\n\n\ncnt = 0\n\nfor n in range(A, B+1):\n\n    if n//10000 == n%10 and (n//1000)%10 == (n//10)%10:\n\n        cnt += 1\n\n\n\nprint(cnt)\n", "score": 0.9166, "codebleu": 0.6323532891310671, "crystalbleu": 0, "codebertscore": 0.89, "codescore": 0.8194780349731445, "surfaceSim": 0.7221839080459771, "abs_surfaceSim_minus_score": 0.19441609195402287, "source": "local", "local_type": "OP"}
{"id": "APPS_test-0594_2", "golden_code": "n, m = [int(x) for x in input().split()]\na = [int(x) for x in input().split()]\nb = [int(x) for x in input().split()]\n\nmax_a = max(max(a), 2 * min(a))\n\nwrong_pass = True\nfor c in b:\n    if c <= max_a:\n        wrong_pass = False\n        break\n\nif wrong_pass:\n    print(\"%d\" % max_a)\nelse:\n    print(\"-1\")", "generated_code": "f = lambda: map(int, input().split())\nn, m = f()\nt = list(f())\ns = sorted(enumerate(t), key=lambda x: x[1])\nk = m\nv = []\nfor i in range(m):\n\tans = s[i][1] - s[i - 1][1]\n\tif ans <= k and f()!= [1] * n: continue\n\tv.append(-1)\nprint('\\n'.join(map(str, v)))\n", "score": 0.0, "codebleu": 0.19013676666204277, "crystalbleu": 0.03, "codebertscore": 0.74, "codescore": 0.0230498518794775, "surfaceSim": 0.43065835605765485, "abs_surfaceSim_minus_score": 0.43065835605765485, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0471_33", "golden_code": "n, a = list(map(int, input().split()))\nline = list(map(int, input().split()))\nline.sort()\nif len(line) == 1:\n    print(0)\nelse:    \n    r1 = abs(line[-1] - line[1])\n    otvet1 = min(abs(a - line[1]), abs(a - line[-1])) + r1\n    r2 = abs(line[-2] - line[0])\n    otvet2 = min(abs(a - line[-2]), abs(a - line[0])) + r2\n    print(min(otvet1, otvet2))", "generated_code": "n, a = list(map(int, input().split()))\nx = list(map (int, input().strip().split()))\n\n\ncheck = 0\npossible = {}\nfor i in range(n):\n\tif x[i] not in possible:\n\t\tpossible[x[i]] = { max(x[i], possible[x[i]][0])-a, 'n'}\n\t\tcheck += 1\n\t\t\nprint(check)\n", "score": 0.0, "codebleu": 0.22238241987429586, "crystalbleu": 0.13, "codebertscore": 0.74, "codescore": 0.16715413331985474, "surfaceSim": 0.5943352601156069, "abs_surfaceSim_minus_score": 0.5943352601156069, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_20_37", "golden_code": "def is_odd(n) : \r\n    if (n^1 == n-1) :\r\n        return True; \r\n    else :\r\n        return False; ", "generated_code": "def is_odd(n):return (1 <<(n.bit_length()-1))", "score": 0.0956, "codebleu": 0.19044998044325545, "crystalbleu": 0, "codebertscore": 0.82, "codescore": 0.06066109240055084, "surfaceSim": 0.6002400960384153, "abs_surfaceSim_minus_score": 0.5046400960384153, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_62_9", "golden_code": "import re\r\ndef num_position(text):\r\n for m in re.finditer(\"\\d+\", text):\r\n    return m.start()", "generated_code": "import re\ndef num_position(s):\n\tpos = 0\n\tfor i in range(len(s)):\n\t\tif s[i] == '0':\n\t\t\tpos = i\n\t\t\tbreak\n\treturn pos", "score": 0.1191, "codebleu": 0.2734935994221507, "crystalbleu": 0, "codebertscore": 0.78, "codescore": 0.19697867333889008, "surfaceSim": 0.5858395989974937, "abs_surfaceSim_minus_score": 0.46673959899749373, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_159_OP_1", "golden_code": "def eat(number, need, remaining):\n    if(need <= remaining):\n        return [ number + need , remaining-need ]\n    else:\n        return [ number + remaining , 0]", "generated_code": "def eat(val, req, left):\n    min_val = min(req, left)\n    return [val + min_val, left - min_val]", "score": 1.0, "codebleu": 0.2532726026332063, "crystalbleu": 0, "codebertscore": 0.8, "codescore": 0.6912675499916077, "surfaceSim": 0.5477915804002761, "abs_surfaceSim_minus_score": 0.4522084195997239, "source": "local", "local_type": "OP"}
{"id": "APPS_test-0568_13", "golden_code": "import sys\n\n\n#sys.stdin = open(\"input.txt\")\n#sys.stdout = open(\"output.txt\", \"w\")\n\nn = int(input())\n\na = 1\ncmod = 10 ** 9 + 7\nfor i in range(3*n):\n\ta *= 3\n\ta %= cmod\n\nb = 1\nfor i in range(n):\n\tb *= 7\n\tb %= cmod\n\nans = (a-b+cmod)%cmod\nprint(ans)\n", "generated_code": "n = int(input())\n\nif n == 1:\n\tprint(0)\nelse:\n\tprint((((3*(3*n-1))**2) - 1) % (10**9 + 7))\n", "score": 0.0, "codebleu": 0.09803797396923936, "crystalbleu": 0, "codebertscore": 0.76, "codescore": 0.036953892558813095, "surfaceSim": 0.6251700680272109, "abs_surfaceSim_minus_score": 0.6251700680272109, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-4160_25", "golden_code": "from decimal import Decimal\n\n\ndef com_interest(n: int) -> int:\n    saving = 100\n    interest_per = 0.01\n    years = 0\n\n    while True:\n        years += 1\n        saving = int(saving * Decimal('1.01'))\n        if saving >= n:\n            break\n    return years\n\n\nprint(com_interest(int(input())))", "generated_code": "import sys\n\ndef solve():\n\tinput = sys.stdin.readline\n\tx = int(input())\n\tans = 0\n\tfor i in range(100, 0, -1):\n\t\tif (x - i) // 100 >= 0:\n\t\t\tans += 1\n\t\t\tx = x - i\n\tprint(ans)\n\ndef __starting_point():\n\tsolve()\n__starting_point()\n", "score": 0.0103, "codebleu": 0.1572886763061608, "crystalbleu": 0, "codebertscore": 0.75, "codescore": 0.04795271158218384, "surfaceSim": 0.5036723163841808, "abs_surfaceSim_minus_score": 0.4933723163841808, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_80_1", "golden_code": "def maximum_segments(n, a, b, c) : \r\n\tdp = [-1] * (n + 10) \r\n\tdp[0] = 0\r\n\tfor i in range(0, n) : \r\n\t\tif (dp[i] != -1) : \r\n\t\t\tif(i + a <= n ): \r\n\t\t\t\tdp[i + a] = max(dp[i] + 1, \r\n\t\t\t\t\t\t\tdp[i + a]) \r\n\t\t\tif(i + b <= n ): \r\n\t\t\t\tdp[i + b] = max(dp[i] + 1, \r\n\t\t\t\t\t\t\tdp[i + b]) \r\n\t\t\tif(i + c <= n ): \r\n\t\t\t\tdp[i + c] = max(dp[i] + 1, \r\n\t\t\t\t\t\t\tdp[i + c]) \r\n\treturn dp[n]", "generated_code": "def maximum_segments(n, a, b, c) : \n\tif a is 0 or b is 0 or c is 0 : \n\t\treturn 0\n\telse : \n\t\n\t\tif c==0 : \n\t\t\treturn sum(range(a,b+1))\n\t\telse:\n\t\t\treturn max(range(c,a+1))\n\t\t\n\treturn\n\n\n\n\n\n\t\n\ta, b, current = [int(x) for x in input().split()]\n\t\t\n\t\n\t\n\tdef segments(a, b):\n\t\treturn [(a, b)]*(b-a+1)\n\t\n\t\ntp = lambda: list(map(int, input().split()))\nli = lambda: input().split()\nlo = lambda:list(map(str,input().split()))", "score": 0.1353, "codebleu": 0.15896230626525865, "crystalbleu": 0.1, "codebertscore": 0.74, "codescore": 0.036531444638967514, "surfaceSim": 0.46359223300970875, "abs_surfaceSim_minus_score": 0.3282922330097088, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_1244_20_MUT_8", "golden_code": "import sys\nimport math\n\nn = int(sys.stdin.readline())\nan = [int(x) for x in sys.stdin.readline().split()]\n\nd = dict()\n\nfor i in an:\n    if i in d:\n        d[i] += 1\n    else:\n        d[i] = 1\n\nvmax = 0\nvsum = 0\nfor i in list(d.keys()):\n    vsum += d[i]\n    if d[i] > vmax:\n        vmax = d[i]\n\nif vsum - vmax >= vmax - 1:\n    print('YES')\nelse:\n    print('NO')", "generated_code": "import sys\nimport math\n\nn = int(sys.stdin.readline())\nan = [int(x) for x in sys.stdin.readline().split()]\n\nd = dict()\n\nfor i in an:\n    if i in d:\n        d[i] += 1\n    else:\n        d[i] = 1\n\nvmax = 0\nvsum = 0\nfor i in list(d.keys()):\n    vsum += d[i]\n    if d[i] > vmax:\n        vmax = d[i]\n\nif not (vsum - vmax >= vmax - 1):\n    print('YES')\nelse:\n    print('NO')", "score": 0.0, "codebleu": 0.9494236357530473, "crystalbleu": 0.92, "codebertscore": 0.99, "codescore": 0.9937766790390015, "surfaceSim": 0.9561323618700668, "abs_surfaceSim_minus_score": 0.9561323618700668, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_PIE_p02599_s870922238_MUT_38", "golden_code": "import sys\nclass BinaryIndexedTree:\n    def __init__(self, A):\n        self.__n = len(A)\n        self.__node = [0] * (self.__n + 1)\n        self.__data = [0] * (self.__n + 1)\n        S = [0] * (self.__n + 1)\n        for i in range(1, self.__n + 1):\n            S[i] = S[i - 1] + A[i - 1]\n            self.__data[i] = A[i - 1]\n            self.__node[i] = S[i] - S[i - (i & (-i))]\n    def add(self, i, v):\n        self.__data[i] += v\n        while i <= self.__n:\n            self.__node[i] += v\n            i += i & (-i)\n    def sum(self, i):\n        rst = 0\n        while i > 0:\n            rst += self.__node[i]\n            i -= i & (-i)\n        return rst\n    def get(self, i, j):\n        if i == j:\n            return self.__data[i]\n        else:\n            return self.sum(j) - self.sum(i - 1)\ndef main():\n    (N, Q) = map(int, input().split())\n    C = list(map(int, input().split()))\n    P = [[] for _ in range(N)]\n    for (i, c) in enumerate(C):\n        P[c - 1].append(i)\n    right = [0] * N\n    for p in P:\n        if len(p):\n            right[p.pop()] = 1\n    BIT = BinaryIndexedTree(right)\n    query = [[] for _ in range(N)]\n    for (i, s) in enumerate(sys.stdin.readlines()):\n        (l, r) = map(int, s.split())\n        query[r - 1].append((l - 1, i))\n    ans = [None] * Q\n    cur = N - 1\n    for (r, q) in enumerate(reversed(query)):\n        r = (N - 1) - r\n        while q:\n            (l, i) = q.pop()\n            while r < cur:\n                c = C[cur] - 1\n                p = P[c]\n                if len(p):\n                    BIT.add(p.pop() + 1, 1)\n                cur -= 1\n            tmp = BIT.get(l + 1, r + 1)\n            ans[i] = tmp\n    print(sep='\\n', *ans)", "generated_code": "import sys\nclass BinaryIndexedTree:\n    def __init__(self, A):\n        self.__n = len(A)\n        self.__node = [0] * (self.__n + 1)\n        self.__data = [0] * (self.__n + 1)\n        S = [0] * (self.__n + 1)\n        for i in range(1, self.__n + 1):\n            S[i] = S[i - 1] + A[i - 1]\n            self.__data[i] = A[i - 1]\n            self.__node[i] = S[i] - S[i - (i & (-i))]\n    def add(self, i, v):\n        self.__data[i] += v\n        while i <= self.__n:\n            self.__node[i] += v\n            i += i & (-i)\n    def sum(self, i):\n        rst = 0\n        while i > 0:\n            rst += self.__node[i]\n            i -= i & (-i)\n        return rst\n    def get(self, i, j):\n        if i == j:\n            return self.__data[i]\n        else:\n            return self.sum(j) - self.sum(i - 1)\ndef main():\n    (N, Q) = map(int, input().split())\n    C = list(map(int, input().split()))\n    P = [[] for _ in range(N)]\n    for (i, c) in enumerate(C):\n        P[c - 1].append(i)\n    right = [0] * N\n    for p in P:\n        if len(p):\n            right[p.pop()] = 1\n    BIT = BinaryIndexedTree(right)\n    query = [[] for _ in range(N)]\n    for (i, s) in enumerate(sys.stdin.readlines()):\n        (l, r) = map(int, s.split())\n        query[r - 1].append((l - 1, i))\n    ans = [None] * Q\n    cur = N - 1\n    for (r, q) in enumerate(reversed(query)):\n        r = (N + 1) - r\n        while q:\n            (l, i) = q.pop()\n            while r < cur:\n                c = C[cur] - 1\n                p = P[c]\n                if len(p):\n                    BIT.add(p.pop() + 1, 1)\n                cur -= 1\n            tmp = BIT.get(l + 1, r + 1)\n            ans[i] = tmp\n    print(sep='\\n', *ans)", "score": 0.0382, "codebleu": 0.994935590512094, "crystalbleu": 1.0, "codebertscore": 1.0, "codescore": 0.9936415553092957, "surfaceSim": 0.9997036158861885, "abs_surfaceSim_minus_score": 0.9615036158861885, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_PIE_p02555_s973678433_MUT_7", "golden_code": "def cmb(n, r):\n    import math\n    if n < r:\n        return 0\n    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\ndef solve(S):\n    mod = (10 ** 9) + 7\n    ans = 0\n    for i in range(1, (S // 3) + 1):\n        tama = i + (S - (i * 3))\n        tama -= 2\n        bo = i - 1\n        ans += cmb(tama + 1, bo)\n        ans %= mod\n    print(ans)", "generated_code": "def cmb(n, r):\n    import math\n    if n < r:\n        return 0\n    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\ndef solve(S):\n    mod = (10 * 9) + 7\n    ans = 0\n    for i in range(1, (S // 3) + 1):\n        tama = i + (S - (i * 3))\n        tama -= 2\n        bo = i - 1\n        ans += cmb(tama + 1, bo)\n        ans %= mod\n    print(ans)", "score": 0.0, "codebleu": 0.980976656443197, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.9937121868133545, "surfaceSim": 0.980096439930235, "abs_surfaceSim_minus_score": 0.980096439930235, "source": "local", "local_type": "MUT"}
{"id": "MBPP_6_3", "golden_code": "def are_Rotations(string1,string2): \r\n    size1 = len(string1) \r\n    size2 = len(string2) \r\n    temp = '' \r\n    if size1 != size2: \r\n        return False\r\n    temp = string1 + string1 \r\n    if (temp.count(string2)> 0): \r\n        return True\r\n    else: \r\n        return False", "generated_code": "def are_Rotations(string1,string2): \n\treturn bool(string1 == string2)", "score": 1.0, "codebleu": 0.07856371971522541, "crystalbleu": 0, "codebertscore": 0.79, "codescore": 0.9672442674636841, "surfaceSim": 0.5032654629273915, "abs_surfaceSim_minus_score": 0.4967345370726085, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_49_10", "golden_code": "def max_of_two( x, y ):\r\n    if x > y:\r\n        return x\r\n    return y", "generated_code": "def max_of_two(x,y):\n\treturn max(x, y)", "score": 1.0, "codebleu": 0.20332138742243341, "crystalbleu": 0, "codebertscore": 0.88, "codescore": 0.993811845779419, "surfaceSim": 0.7038961038961039, "abs_surfaceSim_minus_score": 0.2961038961038961, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_281_3", "golden_code": "def even_Power_Sum(n): \r\n    sum = 0; \r\n    for i in range(1,n + 1): \r\n        j = 2*i; \r\n        sum = sum + (j*j*j*j); \r\n    return sum; ", "generated_code": "def even_Power_Sum(n):\n\treturn n * 1000", "score": 0.0, "codebleu": 0.05888483233561871, "crystalbleu": 0, "codebertscore": 0.77, "codescore": 0.087979756295681, "surfaceSim": 0.6247002398081534, "abs_surfaceSim_minus_score": 0.6247002398081534, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_MBPP_428_MUT_23", "golden_code": "import os\n\ndef shell_sort(my_list):\n    gap = len(my_list) // 2\n    while gap > 0:\n        for i in range(gap, len(my_list)):\n            current_item = my_list[i]\n            j = i\n            while (j >= gap and my_list[j - gap] > current_item):\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            my_list[j] = current_item\n        gap //= 2\n    \n    return my_list", "generated_code": "import os\n\ndef shell_sort(my_list):\n    gap = len(my_list) // 2\n    while gap > 0:\n        for i in range(gap, len(my_list)):\n            current_item = my_list[i]\n            j = i\n            while (j >= gap and my_list[j - gap] > current_item):\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            my_list[j] = current_item\n        gap //= 2\n    \n    return my_list", "score": 0.0, "codebleu": 1.0, "crystalbleu": 1.0, "codebertscore": 1.0, "codescore": 0.9937620759010315, "surfaceSim": 1.0, "abs_surfaceSim_minus_score": 1.0, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_MBPP_386_OP_1", "golden_code": "def swap_count(s):\r\n\tchars = s\r\n\tcount_left = 0\r\n\tcount_right = 0\r\n\tswap = 0\r\n\timbalance = 0; \r\n\tfor i in range(len(chars)):\r\n\t\tif chars[i] == '[':\r\n\t\t\tcount_left += 1\r\n\t\t\tif imbalance > 0:\r\n\t\t\t\tswap += imbalance\r\n\t\t\t\timbalance -= 1\r\n\t\telif chars[i] == ']':\r\n\t\t\tcount_right += 1\r\n\t\t\timbalance = (count_right - count_left) \r\n\treturn swap", "generated_code": "def swap_count(s):\n    left_brackets = 0\n    right_brackets = 0\n    total_swaps = 0\n    imbalance = 0\n    for char in s:\n        if char == '[':\n            left_brackets += 1\n            if imbalance > 0:\n                total_swaps += imbalance\n                imbalance -= 1\n        else:\n            right_brackets += 1\n            imbalance = right_brackets - left_brackets\n    return total_swaps", "score": 0.875, "codebleu": 0.3063537598960422, "crystalbleu": 0, "codebertscore": 0.81, "codescore": 0.9936562180519104, "surfaceSim": 0.7759578326909997, "abs_surfaceSim_minus_score": 0.09904216730900028, "source": "local", "local_type": "OP"}
{"id": "LOCAL_PIE_extra_p03371_s303630482_OP_1", "golden_code": "a, b, c, x, y = list(map(int, input().split()))\n\n\n\nz = max(x,y) * 2\n\nmin_sum = c * z\n\n\n\nfor i in range(z):\n\n    r = max(0, y - i) * b\n\n    t = max(0, x - i) * a\n\n    sum = c * i * 2 + r + t\n\n    if sum < min_sum:\n\n        min_sum = sum\n\n\n\nprint(min_sum)", "generated_code": "a,b,c,x,y = list(map(int, input().split()))\n\n\n\nplan_a = c * (2*x) + max(0, y-x) * b\n\nplan_b = c * (2*y) + max(0, x-y) * a\n\nplan_c = a * x + b * y\n\n\n\nprint((min(plan_a, plan_b, plan_c)))", "score": 1.0, "codebleu": 0.26100948957483255, "crystalbleu": 0, "codebertscore": 0.86, "codescore": 0.09134542942047119, "surfaceSim": 0.7031181379007465, "abs_surfaceSim_minus_score": 0.2968818620992535, "source": "local", "local_type": "OP"}
{"id": "MBPP_31_30", "golden_code": "def smallest_multiple(n):\r\n    if (n<=2):\r\n      return n\r\n    i = n * 2\r\n    factors = [number  for number in range(n, 1, -1) if number * 2 > n]\r\n    while True:\r\n        for a in factors:\r\n            if i % a != 0:\r\n                i += n\r\n                break\r\n            if (a == factors[-1] and i % a == 0):\r\n                return i", "generated_code": "def smallest_multiple(n): \n\treturn [x for x in range(n,0,-1)][-1]\nduplicate = [[0] for i in range(10000)]", "score": 0.1917, "codebleu": 0.07569846443712652, "crystalbleu": 0, "codebertscore": 0.73, "codescore": 0.10634857416152954, "surfaceSim": 0.5740469208211143, "abs_surfaceSim_minus_score": 0.3823469208211143, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_50_17", "golden_code": "def mutiple_tuple(nums):\r\n    temp = list(nums)\r\n    product = 1 \r\n    for x in temp:\r\n        product *= x\r\n    return product", "generated_code": "def mutiple_tuple(nums):\n\ta=sorted(nums)\n\treturn sum(a)", "score": 0.1948, "codebleu": 0.2077114529959424, "crystalbleu": 0, "codebertscore": 0.82, "codescore": 0.01832302287220955, "surfaceSim": 0.6681664791901012, "abs_surfaceSim_minus_score": 0.4733664791901012, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0495_44", "golden_code": "a, b = input().split()\na = list(a)\nb = int(b)\n\ndef findMax(a, f, dist):\n    m = f\n    for i in range(f+1, min(f+dist+1, len(a))):\n        if a[i] > a[m]:\n            m = i\n    return m\n\n\npos = 0\nwhile b > 0 and pos < len(a):\n    m = findMax(a, pos, b)\n    #print('we found:', m)\n    a.insert(pos, a.pop(m))\n    #print('new a', a)\n    b -= m - pos\n    #print('new b', b)\n    pos += 1\n\nprint(''.join(a))\n", "generated_code": "#!/usr/bin/env python3\n\ndef main():\n\ta, k = input().split()\n\ta = int(a)\n\tk = int(k)\n\treq = lambda: str(len(str(a))) <= k\n\tr = lambda: map(int, str(a))\n\ta = list(r())\n\tu = max(r())\n   \n\tj = 0\n\tfor i in range(len(a)):\n\t\twhile j < len(a) and req(a[j]):\n\t\t\tj += 1\n\t\tif j == len(a):\n\t\t\tbreak\n\t\ta[j], a[i] = a[i], a[j]\n\t\tj += 1\n\tfor i, j in enumerate(a):\n\t\tif req(str(j)):\n\t\t\tif i:\n\t\t\t\ta[i], a [j]", "score": 0.0, "codebleu": 0.2781322397792337, "crystalbleu": 0.17, "codebertscore": 0.77, "codescore": 0.01859397068619728, "surfaceSim": 0.6068874378109452, "abs_surfaceSim_minus_score": 0.6068874378109452, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_78_OP_2", "golden_code": "def hex_key(num):\n    primes = ('2', '3', '5', '7', 'B', 'D')\n    total = 0\n    for i in range(0, len(num)):\n        if num[i] in primes:\n            total += 1\n    return total", "generated_code": "def hex_key(value):\n    hex_primes = {'2', '3', '5', '7', 'B', 'D'}\n    count = sum(1 for char in value if char in hex_primes)\n    return count\n", "score": 1.0, "codebleu": 0.2867844233646022, "crystalbleu": 0, "codebertscore": 0.87, "codescore": 0.9934415817260742, "surfaceSim": 0.613117170228445, "abs_surfaceSim_minus_score": 0.38688282977155497, "source": "local", "local_type": "OP"}
{"id": "MBPP_33_35", "golden_code": "def count_Unset_Bits(n) :  \r\n    cnt = 0;  \r\n    for i in range(1,n + 1) : \r\n        temp = i;  \r\n        while (temp) :  \r\n            if (temp % 2 == 0) : \r\n                cnt += 1;  \r\n            temp = temp // 2;  \r\n    return cnt;  ", "generated_code": "def count_Unset_Bits(n):\n\treturn n & 0xffffffff", "score": 0.0292, "codebleu": 0.06691443639359121, "crystalbleu": 0, "codebertscore": 0.68, "codescore": 0.10946087539196014, "surfaceSim": 0.5154698242933538, "abs_surfaceSim_minus_score": 0.48626982429335375, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_p02537_s767194684_MUT_129", "golden_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "generated_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\npass\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "score": 0.0, "codebleu": 0.9128017368334451, "crystalbleu": 0.98, "codebertscore": 0.99, "codescore": 0.978871762752533, "surfaceSim": 0.9846111083034315, "abs_surfaceSim_minus_score": 0.9846111083034315, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_PIE_extra_p03037_s181457641_OP_1", "golden_code": "N,M = list(map(int,input().split()))\n\nL,R = [],[]\n\nfor i in range(M):\n\n    l,r = list(map(int,input().split()))\n\n    L.append(l)\n\n    R.append(r)\n\nans = min(R)-max(L)+1\n\nprint((ans if ans >= 0 else 0))", "generated_code": "# coding: utf-8\n\nimport sys\n\n\n\nsr = lambda: sys.stdin.readline().rstrip()\n\nir = lambda: int(sr())\n\nlr = lambda: list(map(int, sr().split()))\n\n\n\nN, M = lr()\n\nL = 0; R = 10 ** 6\n\nfor _ in range(M):\n\n    l, r = lr()\n\n    if l > L:\n\n        L = l\n\n    if r < R:\n\n        R = r\n\n\n\nanswer = max(0, R - L + 1)\n\nprint(answer)\n", "score": 1.0, "codebleu": 0.23540274935907246, "crystalbleu": 0.18, "codebertscore": 0.79, "codescore": 0.4380497932434082, "surfaceSim": 0.5431785195936139, "abs_surfaceSim_minus_score": 0.45682148040638615, "source": "local", "local_type": "OP"}
{"id": "MBPP_54_10", "golden_code": "def remove_duplic_list(l):\r\n    temp = []\r\n    for x in l:\r\n        if x not in temp:\r\n            temp.append(x)\r\n    return temp", "generated_code": "def remove_duplic_list(l):\n\tfinal = []\n\tfor i in l:\n\t\tif i not in final:\n\t\t\tfinal.append(i)\n\treturn final\nduplicate = set([])", "score": 1.0, "codebleu": 0.5148474771373263, "crystalbleu": 0, "codebertscore": 0.87, "codescore": 0.993297278881073, "surfaceSim": 0.85, "abs_surfaceSim_minus_score": 0.15000000000000002, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_extra_p03208_s260498412_OP_1", "golden_code": "N, K = list(map(int, input().split()))\n\n\n\nheight = []\n\nfor _ in range(N) :\n\n    height.append(int(eval(input())))\n\n\n\nheight.sort()\n\nans = float('inf')\n\n\n\nfor i in range(N-K+1) :\n\n    diff = height[i + K - 1] - height[i]\n\n    ans = min(ans, diff)\n\n\n\nprint(ans)", "generated_code": "N, K = list(map(int, input().split()))\n\nH = [int(eval(input())) for _ in range(N)]\n\nH.sort()\n\n\n\nans = 10**18\n\nfor i in range(N - K + 1):\n\n    ans = min(ans, H[i + K - 1] - H[i])\n\nprint(ans)", "score": 1.0, "codebleu": 0.41691959291124503, "crystalbleu": 0, "codebertscore": 0.93, "codescore": 0.43742793798446655, "surfaceSim": 0.705019305019305, "abs_surfaceSim_minus_score": 0.294980694980695, "source": "local", "local_type": "OP"}
{"id": "APPS_test-3933_12", "golden_code": "n = int(input())\nl = [int(x) for x in input().split()]\n\nd = l[1] - l[0]\nfor i in range(2, n):\n\tif l[i] != l[i - 1] + d:\n\t\td = 0\nprint(l[-1] + d)", "generated_code": "n = int(input())\nt = list(map(int, input().split()))\ns = 0\nf = sum(t)\nfor i in range(1, n):\n\ts = s + t[i]\n\tf = f - t[i] + t[i - 1]\navg = s / n\nif avg > 1000:\n\tprint(avg)\nelse:\n\tprint(-avg)\n", "score": 0.0, "codebleu": 0.268576237971111, "crystalbleu": 0, "codebertscore": 0.84, "codescore": 0.05718446150422096, "surfaceSim": 0.689484126984127, "abs_surfaceSim_minus_score": 0.689484126984127, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_MBPP_516_MUT_1", "golden_code": "import os\n\ndef radix_sort(nums):\n    RADIX = 10\n    placement = 1\n    max_digit = max(nums)\n    \n    while placement < max_digit:\n        buckets = [list() for _ in range(RADIX)]\n        for i in nums:\n            tmp = int((i / placement) % RADIX)\n            buckets[tmp].append(i)\n        a = 0\n        for b in range(RADIX):\n            buck = buckets[b]\n            for i in buck:\n                nums[a] = i\n                a += 1\n        placement *= RADIX\n    return nums", "generated_code": "import os\n\ndef radix_sort(nums):\n    RADIX = 10\n    placement = 1\n    max_digit = max(nums)\n    \n    while placement < max_digit:\n        buckets = [list() for _ in range(RADIX)]\n        for i in nums:\n            tmp = int((i // placement) % RADIX)\n            buckets[tmp].append(i)\n        a = 0\n        for b in range(RADIX):\n            buck = buckets[b]\n            for i in buck:\n                nums[a] = i\n                a += 1\n        placement *= RADIX\n    return nums", "score": 0.0, "codebleu": 0.9791452102321829, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.993736982345581, "surfaceSim": 0.965625, "abs_surfaceSim_minus_score": 0.965625, "source": "local", "local_type": "MUT"}
{"id": "MBPP_6_21", "golden_code": "def are_Rotations(string1,string2): \r\n    size1 = len(string1) \r\n    size2 = len(string2) \r\n    temp = '' \r\n    if size1 != size2: \r\n        return False\r\n    temp = string1 + string1 \r\n    if (temp.count(string2)> 0): \r\n        return True\r\n    else: \r\n        return False", "generated_code": "def are_Rotations(string1, string2):\n\tfor i in range(len(string1)):\n\t\tif string1[i]!= string2[i]:\n\t\t\treturn False\n\treturn True", "score": 0.9048, "codebleu": 0.2110934714687676, "crystalbleu": 0, "codebertscore": 0.81, "codescore": 0.9670609831809998, "surfaceSim": 0.6325165102537366, "abs_surfaceSim_minus_score": 0.2722834897462635, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_23_12", "golden_code": "def same_Length(A,B): \r\n    while (A > 0 and B > 0): \r\n        A = A / 10; \r\n        B = B / 10; \r\n    if (A == 0 and B == 0): \r\n        return True; \r\n    return False; ", "generated_code": "def same_Length(A,B): \n\tif len(str(A))==len(str(B)): \n\t\treturn True\n\telse: \n\t\tprint(False)\n\treturn False", "score": 0.679, "codebleu": 0.15213296941891813, "crystalbleu": 0, "codebertscore": 0.8, "codescore": 0.555537223815918, "surfaceSim": 0.6030812324929973, "abs_surfaceSim_minus_score": 0.07591876750700277, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0221_15", "golden_code": "n, k = map(int, input().split())\na = 1000000\naf = []\nfor i in range(k+1):\n    f = []\n    for j in range(i+1, n+1, 2*k+1):\n        f.append(j)\n    if i+1 > n:\n        break\n    if f[-1]+k >= n:\n        if a > len(f):\n            a = len(f)\n            af = f[:]\nprint(a)\nprint(*af)", "generated_code": "n, k = list(map(int, input().split()))\n\nans = []\n\nfor i in range(k):\n\tans.append(n-i-1)\n\npos = 0\nfor i in sorted(range(n-k), key=lambda x: -(abs(x-k))):\n\tif i > 0:\n\t\tpos = i\n\telse:\n\t\tpass\n\t\t\nans.append(pos)\n\nprint(len(ans))\nprint(' '.join(map(str, ans)))\n", "score": 0.0, "codebleu": 0.26690883373481183, "crystalbleu": 0.17, "codebertscore": 0.81, "codescore": 0.057560041546821594, "surfaceSim": 0.53125, "abs_surfaceSim_minus_score": 0.53125, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-3786_73", "golden_code": "inflos = int(input())\nroots = input()\nroots = [int(x) - 1 for x in roots.split()]\n \n\ndepth = [0]\nfor v in range(inflos - 1):\n    depth.append(depth[roots[v]] + 1)\n\nfreq = {}\n\nfor d in depth:\n    if d in freq:\n        freq[d] += 1\n    else:\n        freq[d] = 1\nres = 0\nfor d in freq:\n    res+= freq[d]%2\nprint(res)\n", "generated_code": "n = int(input())\np = list(map(int, input().split()))\n\napples = []\nfor i in range(1, n + 1):\n\tapples.append(p[i - 1] - p[i])\n\nans = 0\nfor i in apples:\n\tans += i\n\nprint(ans)\n", "score": 0.1782, "codebleu": 0.1740954816726188, "crystalbleu": 0, "codebertscore": 0.78, "codescore": 0.0519721657037735, "surfaceSim": 0.6169055201698515, "abs_surfaceSim_minus_score": 0.4387055201698514, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_20_28", "golden_code": "def is_odd(n) : \r\n    if (n^1 == n-1) :\r\n        return True; \r\n    else :\r\n        return False; ", "generated_code": "def is_odd(s): \n\treturn bool(s)\nmp = 2", "score": 0.4362, "codebleu": 0.193223276995285, "crystalbleu": 0, "codebertscore": 0.78, "codescore": 0.5223277807235718, "surfaceSim": 0.5465186074429772, "abs_surfaceSim_minus_score": 0.11031860744297722, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0774_36", "golden_code": "def gcd(a, b):\n    return gcd(b % a, a) if a else b\nx, y, n = map(int, input().split())\nd = gcd(x, y)\nx, y = x // d, y // d\nif n < y:\n    d = [min(i, y - i) for i in ((x * i) % y for i in range(0, n + 1))]\n    for i in range(n - 1, 0, -1):\n        if d[i] < d[n] and n * d[i] <= i * d[n]: n = i\n    print(str((x * n) // y + int(2 * ((x * n) % y) > y)) + '/' + str(n))\nelse: print(str(x) + '/' + str(y))", "generated_code": "def main():\n\tx, y, n = list(map(int, input().split()))\n\tif x == y:\n\t\tprint(\"%f\" % (x // y))\n\t\treturn\n\tprint(\"%f/%d\" % (x, y))\n\nmain()\n", "score": 0.0, "codebleu": 0.09790244732181919, "crystalbleu": 0.04, "codebertscore": 0.75, "codescore": 0.01839442364871502, "surfaceSim": 0.4758303079198602, "abs_surfaceSim_minus_score": 0.4758303079198602, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-1447_51", "golden_code": "n,m=map(int,input().split())\nif n*m==1:\n    print(1)\nelse:\n    print(1/n+(n-1)*(m-1)/(n*(n*m-1)))", "generated_code": "#!/usr/bin/env python\n\nfrom collections import Counter\n\nn, m = list(map(int, input().split()))\ncard = Counter([m-1])\n\np = n*(n-1)//2\n\nD = {k:v for k,v in Counter(range(n+1)).items()}\n\nfor i in range(n):\n\tD[i+1] = 1.0*D[i] + (m-1)/(i+1)\n\nA = 1.0 * p*(n-m//2)\n\nprint(A)\n", "score": 0.0, "codebleu": 0.14384920634920634, "crystalbleu": 0, "codebertscore": 0.79, "codescore": 0.04181021824479103, "surfaceSim": 0.5072553897180763, "abs_surfaceSim_minus_score": 0.5072553897180763, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_MBPP_836_OP_1", "golden_code": "from sys import maxsize \r\ndef max_sub_array_sum(a,size): \r\n\tmax_so_far = -maxsize - 1\r\n\tmax_ending_here = 0\r\n\tstart = 0\r\n\tend = 0\r\n\ts = 0\r\n\tfor i in range(0,size): \r\n\t\tmax_ending_here += a[i] \r\n\t\tif max_so_far < max_ending_here: \r\n\t\t\tmax_so_far = max_ending_here \r\n\t\t\tstart = s \r\n\t\t\tend = i \r\n\t\tif max_ending_here < 0: \r\n\t\t\tmax_ending_here = 0\r\n\t\t\ts = i+1\r\n\treturn (end - start + 1)", "generated_code": "from sys import maxsize\ndef max_sub_array_sum(arr, n):\n    max_sum = -maxsize - 1\n    current_sum = 0\n    left = 0\n    right = 0\n    temp_start = 0\n    for idx in range(n):\n        current_sum += arr[idx]\n        if max_sum < current_sum:\n            max_sum = current_sum\n            left = temp_start\n            right = idx\n        if current_sum < 0:\n            current_sum = 0\n            temp_start = idx + 1\n    if max_sum < 0:\n        return 0\n    return (right - left + 1)", "score": 0.9357, "codebleu": 0.4967886269984461, "crystalbleu": 0, "codebertscore": 0.81, "codescore": 0.9934988021850586, "surfaceSim": 0.8226141078838174, "abs_surfaceSim_minus_score": 0.11308589211618258, "source": "local", "local_type": "OP"}
{"id": "MBPP_3_30", "golden_code": "def length_Of_Last_Word(a): \r\n    l = 0\r\n    x = a.strip() \r\n    for i in range(len(x)): \r\n        if x[i] == \" \": \r\n            l = 0\r\n        else: \r\n            l += 1\r\n    return l ", "generated_code": "def length_Of_Last_Word(s):    \n\t\n\tlenn = len(str(s))\n\treturn int(lenn)", "score": 0.8459, "codebleu": 0.09080945524290993, "crystalbleu": 0, "codebertscore": 0.76, "codescore": 0.769324541091919, "surfaceSim": 0.5851351351351352, "abs_surfaceSim_minus_score": 0.26076486486486483, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_43_40", "golden_code": "def is_Two_Alter(s):  \r\n    for i in range (len( s) - 2) : \r\n        if (s[i] != s[i + 2]) : \r\n            return False\r\n    if (s[0] == s[1]): \r\n        return False\r\n    return True", "generated_code": "def is_Two_Alter(s):\n\treturn True if s.isnumeric() else False\nduplicate = False", "score": 0.8576, "codebleu": 0.06099881117649836, "crystalbleu": 0, "codebertscore": 0.75, "codescore": 0.9672006964683533, "surfaceSim": 0.5288667141838916, "abs_surfaceSim_minus_score": 0.3287332858161084, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_80_9", "golden_code": "def maximum_segments(n, a, b, c) : \r\n\tdp = [-1] * (n + 10) \r\n\tdp[0] = 0\r\n\tfor i in range(0, n) : \r\n\t\tif (dp[i] != -1) : \r\n\t\t\tif(i + a <= n ): \r\n\t\t\t\tdp[i + a] = max(dp[i] + 1, \r\n\t\t\t\t\t\t\tdp[i + a]) \r\n\t\t\tif(i + b <= n ): \r\n\t\t\t\tdp[i + b] = max(dp[i] + 1, \r\n\t\t\t\t\t\t\tdp[i + b]) \r\n\t\t\tif(i + c <= n ): \r\n\t\t\t\tdp[i + c] = max(dp[i] + 1, \r\n\t\t\t\t\t\t\tdp[i + c]) \r\n\treturn dp[n]", "generated_code": "def maximum_segments(n, a, b, c) : \n\tif a == 0 or b == 0 or c == 0 :\n\t\treturn 0\n\telse:\n\t\treturn max(b * 2, c)", "score": 0.0298, "codebleu": 0.06214373542431359, "crystalbleu": 0.01, "codebertscore": 0.72, "codescore": 0.05252668261528015, "surfaceSim": 0.5004629629629629, "abs_surfaceSim_minus_score": 0.4706629629629629, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_77_12", "golden_code": "def floor_Max(A,B,N):\r\n    x = min(B - 1,N)\r\n    return (A*x) // B", "generated_code": "def floor_Max(A,B,N):\n\tif (N==1):\n\t\treturn A\n\tif ((N+1)%2==0 or N%2==0):\n\t\tans = min(A,N)\n\telse:\n\t\tans=max(A,2*N-1)\n\treturn ans", "score": 0.128, "codebleu": 0.21838991761288684, "crystalbleu": 0, "codebertscore": 0.81, "codescore": 0.04752058535814285, "surfaceSim": 0.5307802433786686, "abs_surfaceSim_minus_score": 0.4027802433786686, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_16_27", "golden_code": "def div_of_nums(nums,m,n):\r\n result = list(filter(lambda x: (x % m == 0 and x % n == 0), nums)) \r\n return result", "generated_code": "def div_of_nums(nums,m,n):\n\treturn [i for i in nums if i%m == 0 and i%n == 0]\nll = [i for l in locals() for i in l]", "score": 1.0, "codebleu": 0.22666799075958682, "crystalbleu": 0, "codebertscore": 0.84, "codescore": 0.993382453918457, "surfaceSim": 0.7076086956521739, "abs_surfaceSim_minus_score": 0.2923913043478261, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_30_32", "golden_code": "import re\r\ndef match_num(string):\r\n    text = re.compile(r\"^5\")\r\n    if text.match(string):\r\n        return True\r\n    else:\r\n        return False", "generated_code": "import re\ndef match_num(string):\n\treturn bool(re.match(\"[0-9]{1}\\d{2}\\s[a-z]+$\", string))", "score": 0.9769, "codebleu": 0.2848993676924576, "crystalbleu": 0, "codebertscore": 0.77, "codescore": 0.9391142725944519, "surfaceSim": 0.7068965517241379, "abs_surfaceSim_minus_score": 0.2700034482758621, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_3738_2_MUT_146", "golden_code": "def minus_two(x, y):\n    return [x[0] - y[0], x[1] - y[1]]\n\ndef will_reach(loc, commands):\n    new_loc = [0, 0]\n    possible_locs = [[0, 0]]\n    for c in commands:\n        if c == 'U':\n            new_loc[1] += 1\n        elif c == 'D':\n            new_loc[1] -= 1\n        elif c == 'R':\n            new_loc[0] += 1\n        elif c == 'L':\n            new_loc[0] -= 1\n        possible_locs += [list(new_loc)]\n    \n    \n    all_destinations = [minus_two(loc, pl) for pl in possible_locs]\n    \n    \n    for destination in all_destinations:\n        realdx = destination[0]\n        realdy = destination[1]\n        \n        reqdx = new_loc[0]\n        reqdy = new_loc[1]\n        \n        if destination == [0, 0]:\n            return True\n        \n        if (reqdx != 0 and realdx != 0):\n            if (realdy / realdx == reqdy / reqdx and \\\n                ((realdy > 0 and reqdy > 0) or (realdy < 0 and reqdy < 0)) and \\\n                realdy / reqdy == int(realdy / reqdy) and \\\n                realdx / reqdx == int(realdx / reqdx)):\n                return True\n        if (realdy == reqdy and realdx == reqdx):\n            return True\n        if (reqdx == 0 and realdx == 0):\n            if (((reqdy > 0 and realdy > 0) or (reqdy < 0 and realdy < 0)) and \\\n                realdy / reqdy == int(realdy / reqdy)):\n                return True\n        if (reqdy == 0 and realdy == 0):\n            \n            if (((reqdx > 0 and realdx > 0) or (reqdx < 0 and realdx < 0)) and \\\n                realdx / reqdx == int(realdx / reqdx)):\n                return True\n    return False\n\n\ndef will_reach2(loc, commands):\n    new_loc = [0, 0]\n    available_loc = []\n    for c in commands:\n        if c == 'U':\n            new_loc[1] += 1\n        elif c == 'D':\n            new_loc[1] -= 1\n        elif c == 'R':\n            new_loc[0] += 1\n        elif c == 'L':\n            new_loc[0] -= 1\n        available_loc += [new_loc]\n    \n    \n    realdx = new_loc[0]\n    realdy = new_loc[1]\n    \n    reqdx = loc[0]\n    reqdy = loc[1]\n    \n    print('realdx', realdx)\n    print('realdy', realdy)\n    print('reqdx', reqdx)\n    print('reqdy', reqdy)\n    \n    \n    if (reqdx != 0 and realdx != 0):\n        return realdy / realdx == reqdy / reqdx\n    elif (reqdx == 0 and realdx == 0):\n        return reqdy / realdy > 0\n    else:\n        return False\n\n\ndef main():\n    first_line = input()\n    first_line = first_line.split()\n    \n    loc = [int(first_line[0]), int(first_line[1])]\n    \n    cmds = input()\n    \n    \n    if will_reach(loc, cmds):\n        print('Yes')\n    else:\n        print('No')\n\n\n\nmain()", "generated_code": "def minus_two(x, y):\n    return [x[0] - y[0], x[1] - y[1]]\n\ndef will_reach(loc, commands):\n    new_loc = [0, 0]\n    possible_locs = [[0, 0]]\n    for c in commands:\n        if c == 'U':\n            new_loc[1] += 1\n        elif c == 'D':\n            new_loc[1] -= 1\n        elif c == 'R':\n            new_loc[0] += 1\n        elif c == 'L':\n            new_loc[0] -= 1\n        possible_locs += [list(new_loc)]\n    \n    \n    all_destinations = [minus_two(loc, pl) for pl in possible_locs]\n    \n    \n    for destination in all_destinations:\n        realdx = destination[0]\n        realdy = destination[1]\n        \n        reqdx = new_loc[0]\n        pass\n        \n        if destination == [0, 0]:\n            return True\n        \n        if (reqdx != 0 and realdx != 0):\n            if (realdy / realdx == reqdy / reqdx and \\\n                ((realdy > 0 and reqdy > 0) or (realdy < 0 and reqdy < 0)) and \\\n                realdy / reqdy == int(realdy / reqdy) and \\\n                realdx / reqdx == int(realdx / reqdx)):\n                return True\n        if (realdy == reqdy and realdx == reqdx):\n            return True\n        if (reqdx == 0 and realdx == 0):\n            if (((reqdy > 0 and realdy > 0) or (reqdy < 0 and realdy < 0)) and \\\n                realdy / reqdy == int(realdy / reqdy)):\n                return True\n        if (reqdy == 0 and realdy == 0):\n            \n            if (((reqdx > 0 and realdx > 0) or (reqdx < 0 and realdx < 0)) and \\\n                realdx / reqdx == int(realdx / reqdx)):\n                return True\n    return False\n\n\ndef will_reach2(loc, commands):\n    new_loc = [0, 0]\n    available_loc = []\n    for c in commands:\n        if c == 'U':\n            new_loc[1] += 1\n        elif c == 'D':\n            new_loc[1] -= 1\n        elif c == 'R':\n            new_loc[0] += 1\n        elif c == 'L':\n            new_loc[0] -= 1\n        available_loc += [new_loc]\n    \n    \n    realdx = new_loc[0]\n    realdy = new_loc[1]\n    \n    reqdx = loc[0]\n    reqdy = loc[1]\n    \n    print('realdx', realdx)\n    print('realdy', realdy)\n    print('reqdx', reqdx)\n    print('reqdy', reqdy)\n    \n    \n    if (reqdx != 0 and realdx != 0):\n        return realdy / realdx == reqdy / reqdx\n    elif (reqdx == 0 and realdx == 0):\n        return reqdy / realdy > 0\n    else:\n        return False\n\n\ndef main():\n    first_line = input()\n    first_line = first_line.split()\n    \n    loc = [int(first_line[0]), int(first_line[1])]\n    \n    cmds = input()\n    \n    \n    if will_reach(loc, cmds):\n        print('Yes')\n    else:\n        print('No')\n\n\n\nmain()", "score": 0.0, "codebleu": 0.985962437875971, "crystalbleu": 0.99, "codebertscore": 0.99, "codescore": 0.9931914210319519, "surfaceSim": 0.9821957442930697, "abs_surfaceSim_minus_score": 0.9821957442930697, "source": "local", "local_type": "MUT"}
{"id": "MBPP_18_1", "golden_code": "def is_Isomorphic(str1,str2):          \r\n    dict_str1 = {}\r\n    dict_str2 = {}\r\n    for i, value in enumerate(str1):\r\n        dict_str1[value] = dict_str1.get(value,[]) + [i]        \r\n    for j, value in enumerate(str2):\r\n        dict_str2[value] = dict_str2.get(value,[]) + [j]\r\n    if sorted(dict_str1.values()) == sorted(dict_str2.values()):\r\n        return True\r\n    else:\r\n        return False", "generated_code": "def is_Isomorphic(str1,str2):          \n\treturn str1==str2", "score": 0.9479, "codebleu": 0.04126940727205307, "crystalbleu": 0, "codebertscore": 0.74, "codescore": 0.937157154083252, "surfaceSim": 0.38988776288547455, "abs_surfaceSim_minus_score": 0.5580122371145254, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_p02599_s870922238_MUT_149", "golden_code": "import sys\nclass BinaryIndexedTree:\n    def __init__(self, A):\n        self.__n = len(A)\n        self.__node = [0] * (self.__n + 1)\n        self.__data = [0] * (self.__n + 1)\n        S = [0] * (self.__n + 1)\n        for i in range(1, self.__n + 1):\n            S[i] = S[i - 1] + A[i - 1]\n            self.__data[i] = A[i - 1]\n            self.__node[i] = S[i] - S[i - (i & (-i))]\n    def add(self, i, v):\n        self.__data[i] += v\n        while i <= self.__n:\n            self.__node[i] += v\n            i += i & (-i)\n    def sum(self, i):\n        rst = 0\n        while i > 0:\n            rst += self.__node[i]\n            i -= i & (-i)\n        return rst\n    def get(self, i, j):\n        if i == j:\n            return self.__data[i]\n        else:\n            return self.sum(j) - self.sum(i - 1)\ndef main():\n    (N, Q) = map(int, input().split())\n    C = list(map(int, input().split()))\n    P = [[] for _ in range(N)]\n    for (i, c) in enumerate(C):\n        P[c - 1].append(i)\n    right = [0] * N\n    for p in P:\n        if len(p):\n            right[p.pop()] = 1\n    BIT = BinaryIndexedTree(right)\n    query = [[] for _ in range(N)]\n    for (i, s) in enumerate(sys.stdin.readlines()):\n        (l, r) = map(int, s.split())\n        query[r - 1].append((l - 1, i))\n    ans = [None] * Q\n    cur = N - 1\n    for (r, q) in enumerate(reversed(query)):\n        r = (N - 1) - r\n        while q:\n            (l, i) = q.pop()\n            while r < cur:\n                c = C[cur] - 1\n                p = P[c]\n                if len(p):\n                    BIT.add(p.pop() + 1, 1)\n                cur -= 1\n            tmp = BIT.get(l + 1, r + 1)\n            ans[i] = tmp\n    print(sep='\\n', *ans)", "generated_code": "import sys\nclass BinaryIndexedTree:\n    def __init__(self, A):\n        self.__n = len(A)\n        self.__node = [0] * (self.__n + 1)\n        self.__data = [0] * (self.__n + 1)\n        S = [0] * (self.__n + 1)\n        for i in range(1, self.__n + 1):\n            S[i] = S[i - 1] + A[i - 1]\n            self.__data[i] = A[i - 1]\n            self.__node[i] = S[i] - S[i - (i & (-i))]\n    def add(self, i, v):\n        self.__data[i] += v\n        while i <= self.__n:\n            self.__node[i] += v\n            i += i & (-i)\n    def sum(self, i):\n        rst = 0\n        while i > 0:\n            rst += self.__node[i]\n            i -= i & (-i)\n        return rst\n    def get(self, i, j):\n        if i == j:\n            return self.__data[i]\n        else:\n            return self.sum(j) - self.sum(i - 1)\ndef main():\n    (N, Q) = map(int, input().split())\n    C = list(map(int, input().split()))\n    P = [[] for _ in range(N)]\n    for (i, c) in enumerate(C):\n        P[c - 1].append(i)\n    right = [0] * N\n    for p in P:\n        if len(p):\n            right[p.pop()] = 1\n    BIT = BinaryIndexedTree(right)\n    query = [[] for _ in range(N)]\n    for (i, s) in enumerate(sys.stdin.readlines()):\n        break\n    \n    ans = [None] * Q\n    cur = N - 1\n    for (r, q) in enumerate(reversed(query)):\n        r = (N - 1) - r\n        while q:\n            (l, i) = q.pop()\n            while r < cur:\n                c = C[cur] - 1\n                p = P[c]\n                if len(p):\n                    BIT.add(p.pop() + 1, 1)\n                cur -= 1\n            tmp = BIT.get(l + 1, r + 1)\n            ans[i] = tmp\n    print(sep='\\n', *ans)", "score": 0.0368, "codebleu": 0.9312067220597342, "crystalbleu": 0.93, "codebertscore": 0.99, "codescore": 0.9936568140983582, "surfaceSim": 0.9735784405858285, "abs_surfaceSim_minus_score": 0.9367784405858286, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-0621_35", "golden_code": "P=print\nI=input\nI()\na=b=0\nt=[]\nfor x in map(int,I().split()):\n\tif x<0:\n\t\tif b==2:t+=[a];b=1;a=0\n\t\telse:b+=1\n\ta+=1\nif a:t+=[a]\nP(len(t))\nfor x in t:P(x,end=' ')\n", "generated_code": "n=int(input())\nl=list(map(int,input().split()))\nl.sort()\nc=0\n0\nfor i in range(n):\n\tif l[i]<0:\n\t\tc+=1\nif c==0:\n\tprint(0)\n\tprint('')\nelse:\n\tk=c\n\tfor i in range (c-1,0,-1):\n\t\tif l[i-1]<0: #need a new job\n\t\t\tprint(i)\n\t\t\tbreak\n\telse:\n\t\tprint(k)\n\t\tprint('')\n\n", "score": 0.0, "codebleu": 0.18611223878384242, "crystalbleu": 0.1, "codebertscore": 0.78, "codescore": 0.09278719872236252, "surfaceSim": 0.5215810276679842, "abs_surfaceSim_minus_score": 0.5215810276679842, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_81_MUT_9", "golden_code": "import os\n\ndef numerical_letter_grade(grades):\n    \n    \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append('A+')\n        elif gpa > 3.7:\n            letter_grade.append('A')\n        elif gpa > 3.3:\n            letter_grade.append('A-')\n        elif gpa > 3.0:\n            letter_grade.append('B+')\n        elif gpa > 2.7:\n            letter_grade.append('B')\n        elif gpa > 2.3:\n            letter_grade.append('B-')\n        elif gpa > 2.0:\n            letter_grade.append('C+')\n        elif gpa > 1.7:\n            letter_grade.append('C')\n        elif gpa > 1.3:\n            letter_grade.append('C-')\n        elif gpa > 1.0:\n            letter_grade.append('D+')\n        elif gpa > 0.7:\n            letter_grade.append('D')\n        elif gpa > 0.0:\n            letter_grade.append('D-')\n        else:\n            letter_grade.append('E')\n    return letter_grade", "generated_code": "import os\n\ndef numerical_letter_grade(grades):\n    \n    \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append('A+')\n        elif gpa > 3.7:\n            letter_grade.append('A')\n        elif gpa > 3.3:\n            letter_grade.append('A-')\n        elif gpa > 3.0:\n            letter_grade.append('B+')\n        elif gpa > 2.7:\n            letter_grade.append('B')\n        elif gpa > 2.3:\n            letter_grade.append('B-')\n        elif gpa > 2.0:\n            letter_grade.append('C+')\n        elif gpa > 1.7:\n            letter_grade.append('C')\n        elif not (gpa > 1.3):\n            letter_grade.append('C-')\n        elif gpa > 1.0:\n            letter_grade.append('D+')\n        elif gpa > 0.7:\n            letter_grade.append('D')\n        elif gpa > 0.0:\n            letter_grade.append('D-')\n        else:\n            letter_grade.append('E')\n    return letter_grade", "score": 0.08, "codebleu": 0.9553751307305812, "crystalbleu": 0.94, "codebertscore": 0.99, "codescore": 0.9937084913253784, "surfaceSim": 0.9538072983052448, "abs_surfaceSim_minus_score": 0.8738072983052448, "source": "local", "local_type": "MUT"}
{"id": "MBPP_56_18", "golden_code": "def series_sum(number):\r\n total = 0\r\n total = (number * (number + 1) * (2 * number + 1)) / 6\r\n return total", "generated_code": "def series_sum(number):\n\ttotal = 0\n\tfor n in range(1,number+1):\n\t\ttotal += n*3**2\n\t\t\n\treturn total\n\t\nss = [1,2,3,4,5,6,7,8,9]", "score": 0.0461, "codebleu": 0.3178357152214564, "crystalbleu": 0, "codebertscore": 0.81, "codescore": 0.060084957629442215, "surfaceSim": 0.6341052631578947, "abs_surfaceSim_minus_score": 0.5880052631578947, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_MBPP_522_OP_1", "golden_code": "def lbs(arr): \r\n\tn = len(arr) \r\n\tlis = [1 for i in range(n+1)] \r\n\tfor i in range(1 , n): \r\n\t\tfor j in range(0 , i): \r\n\t\t\tif ((arr[i] > arr[j]) and (lis[i] < lis[j] +1)): \r\n\t\t\t\tlis[i] = lis[j] + 1\r\n\tlds = [1 for i in range(n+1)] \r\n\tfor i in reversed(range(n-1)): \r\n\t\tfor j in reversed(range(i-1 ,n)): \r\n\t\t\tif(arr[i] > arr[j] and lds[i] < lds[j] + 1): \r\n\t\t\t\tlds[i] = lds[j] + 1\r\n\tmaximum = lis[0] + lds[0] - 1\r\n\tfor i in range(1 , n): \r\n\t\tmaximum = max((lis[i] + lds[i]-1), maximum) \r\n\treturn maximum", "generated_code": "def lbs(seq):\n    length = len(seq)\n    if length == 0:\n        return 0\n    inc = [1] * length\n    dec = [1] * length\n    for i in range(1, length):\n        for j in range(i):\n            if seq[i] > seq[j]:\n                inc[i] = max(inc[i], inc[j] + 1)\n    for i in range(length - 2, -1, -1):\n        for j in range(length - 1, i, -1):\n            if seq[i] > seq[j]:\n                dec[i] = max(dec[i], dec[j] + 1)\n    longest = 0\n    for i in range(length):\n        longest = max(longest, inc[i] + dec[i] - 1)\n    return longest", "score": 0.7664, "codebleu": 0.25243574051207396, "crystalbleu": 0.17, "codebertscore": 0.82, "codescore": 0.8217533826828003, "surfaceSim": 0.611318407960199, "abs_surfaceSim_minus_score": 0.155081592039801, "source": "local", "local_type": "OP"}
{"id": "APPS_test-0158_24", "golden_code": "n = int(input())\n\nl=[int(i) for i in input().split()]\n\nl.sort()\n\nif l[n]>l[n-1]:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n", "generated_code": "def main():\n\tn = int(input())\n\ta = sorted(map(int, input().split()))\n\tk = n // 2\n\tt = 0\n\tfor i in range(k):\n\t\tif a[i] > a[k - i]:\n\t\t\tt += 1\n\tfor ik in range(k, n):\n\t\tif A[kk] > a[kk - k]:\n\t\t\tt -= 1\n\tprint(['YES', 'NO'][t % 2 == 0])\n\n\ndef __starting_point():\n\tmain()\n\n__starting_point()\n", "score": 0.0, "codebleu": 0.28471278960228696, "crystalbleu": 0, "codebertscore": 0.79, "codescore": 0.14255297183990479, "surfaceSim": 0.5253172753172752, "abs_surfaceSim_minus_score": 0.5253172753172752, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_extra_p04012_s872816747_OP_1", "golden_code": "import string\n\nw = eval(input())\n\nfor a in string.ascii_lowercase:\n\n    cnt = 0\n\n    for t in w:\n\n        if t == a:\n\n            cnt = cnt + 1\n\n    if cnt % 2 == 1:\n\n        print(\"No\")\n\n        exit()\n\n\n\nprint(\"Yes\")", "generated_code": "w = eval(input())\n\nm = [0] * 26\n\nfor t in w:\n\n    m[ord(t) - ord('a')] += 1\n\n\n\nfor cnt in m:\n\n    if cnt % 2 == 1:\n\n        print(\"No\")\n\n        exit()\n\n\n\nprint(\"Yes\")", "score": 1.0, "codebleu": 0.39353395807567715, "crystalbleu": 0, "codebertscore": 0.87, "codescore": 0.9241039156913757, "surfaceSim": 0.6611238532110092, "abs_surfaceSim_minus_score": 0.3388761467889908, "source": "local", "local_type": "OP"}
{"id": "LOCAL_PIE_extra_p03371_s944521020_OP_1", "golden_code": "a,b,c,x,y=list(map(int,input().split()))\n\nans=a*x+b*y\n\nn=max(x,y)\n\nfor i in range(1,n+1):\n\n  ans=min(ans,2*i*c+a*max(0,x-i)+b*max(0,y-i))\n\nprint(ans)\n\n\n\n\n", "generated_code": "a,b,c,x,y=list(map(int,input().split()))\n\nans1=a*x+b*y\n\nans2=2*c*max(x,y)\n\nans3=2*c*min(x,y)+a*(x-min(x,y))+b*(y-min(x,y))\n\nprint((min(ans1,ans2,ans3)))", "score": 1.0, "codebleu": 0.2953485969793404, "crystalbleu": 0.33, "codebertscore": 0.89, "codescore": 0.09423336386680603, "surfaceSim": 0.7393939393939394, "abs_surfaceSim_minus_score": 0.2606060606060606, "source": "local", "local_type": "OP"}
{"id": "LOCAL_HE_62_OP_1", "golden_code": "def derivative(xs: list):\n    return [(i * x) for i, x in enumerate(xs)][1:]", "generated_code": "def derivative(ys: list):\n    if len(ys) < 2:\n        return []\n    return [i * ys[i] for i in range(1, len(ys))]", "score": 1.0, "codebleu": 0.2683849274276672, "crystalbleu": 0, "codebertscore": 0.86, "codescore": 0.9932965636253357, "surfaceSim": 0.6462188254223653, "abs_surfaceSim_minus_score": 0.3537811745776347, "source": "local", "local_type": "OP"}
{"id": "LOCAL_HE_162_OP_1", "golden_code": "def string_to_md5(text):\n    import hashlib\n    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None", "generated_code": "def string_to_md5(input_text):\n    if not input_text:\n        return None\n    from hashlib import md5\n    return md5(input_text.encode('ascii')).hexdigest()", "score": 1.0, "codebleu": 0.3898533977007125, "crystalbleu": 0, "codebertscore": 0.92, "codescore": 0.02834363281726837, "surfaceSim": 0.6151960784313726, "abs_surfaceSim_minus_score": 0.3848039215686274, "source": "local", "local_type": "OP"}
{"id": "LOCAL_PIE_extra_p00134_s571351483_OP_1", "golden_code": "from statistics import mean\n\n\n\ninputCount = int(eval(input()))\n\nprices = [int(eval(input())) for lp in range(inputCount)]\n\naverage = mean(prices)\n\nprint((int(average)))\n\n\n", "generated_code": "inputCount = int(eval(input()))\n\nprices = [int(eval(input())) for lp in range(inputCount)]\n\naverage = sum(prices) // inputCount\n\nprint(average)\n\n\n", "score": 1.0, "codebleu": 0.607107434864954, "crystalbleu": 0, "codebertscore": 0.94, "codescore": 0.09051338583230972, "surfaceSim": 0.7204228520017993, "abs_surfaceSim_minus_score": 0.27957714799820066, "source": "local", "local_type": "OP"}
{"id": "LOCAL_PIE_extra_p02792_s313172456_OP_1", "golden_code": "#python3\n\nfrom collections import defaultdict\n\nfrom collections import namedtuple\n\n\n\nP = namedtuple('P', ['front', 'end'])\n\n\n\ndef f(x):\n\n    return P(str(x)[0], str(x)[-1]) \n\n\n\ndef main():\n\n\n\n    n = int(eval(input()))\n\n    freq = defaultdict(int)\n\n\n\n    for i in range(1, n+1):\n\n        p = f(i)\n\n        freq[p]+=1\n\n\n\n\n\n    ans = 0\n\n    for i in range(1, n + 1):\n\n        p = f(i)\n\n        q = (p.end, p.front)\n\n        ans += freq[q]\n\n\n\n    print(ans)\n\n\n\nmain()", "generated_code": "import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\nfrom collections import defaultdict\n\n\n\ndef f(x):\n\n    return (int(str(x)[0]), int(str(x)[-1])) \n\ndef main():\n\n    N = int(readline())\n\n    df = defaultdict(int)\n\n    for i in range(1, N+1):\n\n        df[f(i)] += 1\n\n    ans = 0\n\n    for i in range(1, 10):\n\n        for j in range(1, 10):\n\n            ans +=  df[(i, j)]*df[(j, i)]\n\n    print(ans)\n\nif __name__ == '__main__':\n\n    main()\n", "score": 1.0, "codebleu": 0.40229302773134473, "crystalbleu": 0.26, "codebertscore": 0.83, "codescore": 0.026679661124944687, "surfaceSim": 0.6899408284023669, "abs_surfaceSim_minus_score": 0.3100591715976331, "source": "local", "local_type": "OP"}
{"id": "LOCAL_APPS_13_1_MUT_26", "golden_code": "import sys\n\ndef main():\n    \n    (n, k) = map(int, sys.stdin.readline().split())\n    courses = list(map(int, sys.stdin.readline().split()))\n    courses = [x - 1 for x in courses]\n    \n    visited = [False] * n\n    used = [False] * n\n    \n    ans = []\n    t = []\n    \n    for i in range(n):\n        temp = list(map(int, sys.stdin.readline().split()))\n        temp = [x - 1 for x in temp]\n        t.append(temp[1:])\n    \n    for i in range(k):\n        c = courses[i]\n        if used[c]:\n            continue\n        \n        q = [c]\n        visited[c] = True\n        while len(q) > 0:\n            cur = q[-1]\n            if len(t[cur]) != 0:\n                s = t[cur].pop()\n                if (visited[s] and not (used[s])):\n                    print(-1)\n                    return\n                if used[s]:\n                    continue\n                q.append(s)\n                visited[s] = True\n            else:\n                ans.append(cur)\n                q.pop()\n                used[cur] = True\n    \n    ans = [str(x + 1) for x in ans]\n    print(len(ans))\n    print(' '.join(ans))\n\nmain()", "generated_code": "import sys\n\ndef main():\n    \n    (n, k) = map(int, sys.stdin.readline().split())\n    courses = list(map(int, sys.stdin.readline().split()))\n    courses = [x - 1 for x in courses]\n    \n    visited = [False] * n\n    used = [False] * n\n    \n    ans = []\n    t = []\n    \n    for i in range(n):\n        temp = list(map(int, sys.stdin.readline().split()))\n        temp = [x - 1 for x in temp]\n        t.append(temp[1:])\n    \n    for i in range(k):\n        c = courses[i]\n        if used[c]:\n            continue\n        \n        q = [c]\n        visited[c] = True\n        while len(q) > 0:\n            cur = q[-1]\n            if len(t[cur]) != 0:\n                s = t[cur].pop()\n                if (visited[s] and not (used[s])):\n                    print(-1)\n                    return\n                if used[s]:\n                    continue\n                q.append(s)\n                visited[s] = True\n            else:\n                ans.append(cur)\n                q.pop()\n                used[cur] = Truebreak\n    \n    ans = [str(x + 1) for x in ans]\n    print(len(ans))\n    print(' '.join(ans))\n\nmain()", "score": 0.0043, "codebleu": 0.9625367448266567, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.993831992149353, "surfaceSim": 0.997737556561086, "abs_surfaceSim_minus_score": 0.993437556561086, "source": "local", "local_type": "MUT"}
{"id": "MBPP_30_9", "golden_code": "import re\r\ndef match_num(string):\r\n    text = re.compile(r\"^5\")\r\n    if text.match(string):\r\n        return True\r\n    else:\r\n        return False", "generated_code": "import re\ndef match_num(s, split=None):\n\tif split == None or len(split) > 1:\n\t\treturn False\n\tchar = findall(r\"(.)\\.\", s)\n\treturn all(match(cur, split[0]) for cur in char)", "score": 0.9285, "codebleu": 0.23600003476892295, "crystalbleu": 0, "codebertscore": 0.77, "codescore": 0.9452128410339355, "surfaceSim": 0.5181372549019607, "abs_surfaceSim_minus_score": 0.41036274509803927, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_81_MUT_18", "golden_code": "import os\n\ndef numerical_letter_grade(grades):\n    \n    \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append('A+')\n        elif gpa > 3.7:\n            letter_grade.append('A')\n        elif gpa > 3.3:\n            letter_grade.append('A-')\n        elif gpa > 3.0:\n            letter_grade.append('B+')\n        elif gpa > 2.7:\n            letter_grade.append('B')\n        elif gpa > 2.3:\n            letter_grade.append('B-')\n        elif gpa > 2.0:\n            letter_grade.append('C+')\n        elif gpa > 1.7:\n            letter_grade.append('C')\n        elif gpa > 1.3:\n            letter_grade.append('C-')\n        elif gpa > 1.0:\n            letter_grade.append('D+')\n        elif gpa > 0.7:\n            letter_grade.append('D')\n        elif gpa > 0.0:\n            letter_grade.append('D-')\n        else:\n            letter_grade.append('E')\n    return letter_grade", "generated_code": "import os\n\ndef numerical_letter_grade(grades):\n    \n    \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append('A+')\n        elif gpa < 3.7:\n            letter_grade.append('A')\n        elif gpa > 3.3:\n            letter_grade.append('A-')\n        elif gpa > 3.0:\n            letter_grade.append('B+')\n        elif gpa > 2.7:\n            letter_grade.append('B')\n        elif gpa > 2.3:\n            letter_grade.append('B-')\n        elif gpa > 2.0:\n            letter_grade.append('C+')\n        elif gpa > 1.7:\n            letter_grade.append('C')\n        elif gpa > 1.3:\n            letter_grade.append('C-')\n        elif gpa > 1.0:\n            letter_grade.append('D+')\n        elif gpa > 0.7:\n            letter_grade.append('D')\n        elif gpa > 0.0:\n            letter_grade.append('D-')\n        else:\n            letter_grade.append('E')\n    return letter_grade", "score": 0.0003, "codebleu": 0.983196280070576, "crystalbleu": 0.97, "codebertscore": 1.0, "codescore": 0.9936854243278503, "surfaceSim": 0.9767262791852955, "abs_surfaceSim_minus_score": 0.9764262791852956, "source": "local", "local_type": "MUT"}
{"id": "MBPP_19_8", "golden_code": "def sum_num(numbers):\r\n    total = 0\r\n    for x in numbers:\r\n        total += x\r\n    return total/len(numbers) ", "generated_code": "def sum_num(num):    \n\treturn '-'.join(map(str,num))", "score": 0.0, "codebleu": 0.08062182808010968, "crystalbleu": 0, "codebertscore": 0.76, "codescore": 0.018406597897410393, "surfaceSim": 0.5439851616322204, "abs_surfaceSim_minus_score": 0.5439851616322204, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_extra_p03796_s700640855_OP_1", "golden_code": "import math\n\n\n\nN = int(eval(input()))\n\nC = 10**9 + 7\n\n\n\nprint((math.factorial(N) % C))", "generated_code": "N = int(eval(input()))\n\nC = 10**9+7\n\nans = 1\n\nfor i in range(1, N + 1):\n\n    ans *= i\n\n    ans %= C\n\nprint(ans)", "score": 1.0, "codebleu": 0.356563783492072, "crystalbleu": 0, "codebertscore": 0.83, "codescore": 0.6306207776069641, "surfaceSim": 0.5945945945945945, "abs_surfaceSim_minus_score": 0.4054054054054055, "source": "local", "local_type": "OP"}
{"id": "MBPP_17_25", "golden_code": "def all_Bits_Set_In_The_Given_Range(n,l,r): \r\n    num = ((1 << r) - 1) ^ ((1 << (l - 1)) - 1) \r\n    new_num = n & num \r\n    if (num == new_num): \r\n        return True\r\n    return False", "generated_code": "def all_Bits_Set_In_The_Given_Range(n, x, y):\n\treturn x*(n//2)*(1+y)//2", "score": 0.0208, "codebleu": 0.1444459140327407, "crystalbleu": 0, "codebertscore": 0.79, "codescore": 0.061793114989995956, "surfaceSim": 0.49961180124223603, "abs_surfaceSim_minus_score": 0.47881180124223605, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_43_8", "golden_code": "def is_Two_Alter(s):  \r\n    for i in range (len( s) - 2) : \r\n        if (s[i] != s[i + 2]) : \r\n            return False\r\n    if (s[0] == s[1]): \r\n        return False\r\n    return True", "generated_code": "def is_Two_Alter(s):\n\treturn not s", "score": 0.8388, "codebleu": 0.055536148470256924, "crystalbleu": 0, "codebertscore": 0.75, "codescore": 0.9671406745910645, "surfaceSim": 0.432314952806756, "abs_surfaceSim_minus_score": 0.40648504719324396, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_p03253_s948054289_MUT_6", "golden_code": "from math import floor, sqrt\nfrom collections import Counter\nMOD = (10 ** 9) + 7\ndef getPrimeFactor(x):\n    ans = []\n    for d in range(2, floor(sqrt(x)) + 1):\n        while x % d == 0:\n            ans.append(d)\n            x //= d\n    if x != 1:\n        ans.append(x)\n    return ans\ndef power(x, n):\n    ans = 1\n    while n:\n        if n % 2 == 1:\n            ans = (ans * x) % MOD\n        x = (x * x) % MOD\n        n //= 2\n    return ans\n(N, M) = list(map(int, input().split()))\nPFs = getPrimeFactor(M)\ncnt = Counter(PFs)\nN2 = N\nif len(cnt):\n    N2 += max(cnt.values())\nfacts = [1] + ([0] * N2)\nfor x in range(1, N2 + 1):\n    facts[x] = (facts[x - 1] * x) % MOD\ninvFs = ([0] * N2) + [power(facts[N2], MOD - 2)]\nfor x in reversed(list(range(N2))):\n    invFs[x] = (invFs[x + 1] * (x + 1)) % MOD\ndef comb(n, k):\n    return (((facts[n] * invFs[k]) % MOD) * invFs[n - k]) % MOD\nans = 1\nfor num in list(cnt.values()):\n    ans = (ans * comb((N + num) - 1, num)) % MOD\nprint(ans)", "generated_code": "from math import floor, sqrt\nfrom collections import Counter\nMOD = (10 ** 9) + 7\ndef getPrimeFactor(x):\n    ans = []\n    for d in range(2, floor(sqrt(x)) + 1):\n        while x % d == 0:\n            ans.append(d)\n            x //= d\n    if x != 1:\n        ans.append(x)\n    return ans\ndef power(x, n):\n    ans = 1\n    while n:\n        if n % 2 == 1:\n            ans = (ans / x) % MOD\n        x = (x * x) % MOD\n        n //= 2\n    return ans\n(N, M) = list(map(int, input().split()))\nPFs = getPrimeFactor(M)\ncnt = Counter(PFs)\nN2 = N\nif len(cnt):\n    N2 += max(cnt.values())\nfacts = [1] + ([0] * N2)\nfor x in range(1, N2 + 1):\n    facts[x] = (facts[x - 1] * x) % MOD\ninvFs = ([0] * N2) + [power(facts[N2], MOD - 2)]\nfor x in reversed(list(range(N2))):\n    invFs[x] = (invFs[x + 1] * (x + 1)) % MOD\ndef comb(n, k):\n    return (((facts[n] * invFs[k]) % MOD) * invFs[n - k]) % MOD\nans = 1\nfor num in list(cnt.values()):\n    ans = (ans * comb((N + num) - 1, num)) % MOD\nprint(ans)", "score": 0.3728, "codebleu": 0.9930834320187858, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9937291145324707, "surfaceSim": 0.9847802430324648, "abs_surfaceSim_minus_score": 0.6119802430324648, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-0636_18", "golden_code": "(n, k) = [int(x) for x in input().split()]\na = [int(x) for x in input().split()]\ns = 0\nans = []\nans_ = []\nb = sorted(a)\n\nfor B in b:\n    if s+B <= k:\n        s += B\n        ans_.append(B)\n    else:\n        break\nlen_ans_ = len(ans_)\nif len_ans_ == 0:\n    print(0)\n    return\nans.append(a.index(ans_[0])+1)\nfor i in range(1,len_ans_):\n    if ans_[i] == ans_[i-1]:\n        ans.append(a[ans[-1]:].index(ans_[i]) + ans[-1] + 1)\n    else:\n        ans.append(a.index(ans_[i])+1)\nans.sort()\n\nprint(len(ans))\nif len(ans) > 0:\n    print(*ans)\n", "generated_code": "n, k = list(map(int, input().split()))\na = list(map (int, input().strip().split())) + [0]\n\nodd = sum([1 for i in a if i % 2 == 1])\n\nif n % 2 == 1:\n\todd -= 1\n\nprint(odd)\nprint(\" \".join([str(i) for i in range(n)]))\n", "score": 0.0, "codebleu": 0.11290075564724733, "crystalbleu": 0.04, "codebertscore": 0.74, "codescore": 0.05017702654004097, "surfaceSim": 0.513810861423221, "abs_surfaceSim_minus_score": 0.513810861423221, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_extra_p04044_s532034645_OP_1", "golden_code": "N, L = list(map(int, input().split()))\n\nS = list(eval(input()) for i in range(N))\n\nstr = \"\"\n\nfor i in range(N-1):\n\n    for j in range(N-1):\n\n        if S[j+1] + S[j] <= S[j] + S[j+1]:\n\n            S[j], S[j+1] = S[j+1], S[j]\n\nfor i in S:\n\n    str += i\n\nprint(str)\n", "generated_code": "N, L = list(map(int, input().split()))\n\nS = list(eval(input()) for i in range(N))\n\nS.sort()\n\nstr = \"\"\n\nfor i in S:\n\n    str += i\n\nprint(str)\n", "score": 1.0, "codebleu": 0.450180971647207, "crystalbleu": 0.29, "codebertscore": 0.87, "codescore": 0.4546035826206207, "surfaceSim": 0.6761363636363635, "abs_surfaceSim_minus_score": 0.32386363636363646, "source": "local", "local_type": "OP"}
{"id": "LOCAL_PIE_extra_p03721_s705162733_OP_1", "golden_code": "(N, K), *AB = [list(map(int, s.split())) for s in open(0)]\n\nfor a, b in sorted(AB):\n\n    K -= b\n\n    if K <= 0:\n\n        print(a)\n\n        break\n", "generated_code": "N, K, *AB = list(map(int, open(0).read().split()))\n\nli = [(a, b) for a, b in zip(*[iter(AB)] * 2)]\n\nli.sort()\n\nfor a, b in li:\n\n    if K > b:\n\n        K -= b\n\n    else:\n\n        print(a)\n\n        break\n", "score": 1.0, "codebleu": 0.34036806501467953, "crystalbleu": 0, "codebertscore": 0.89, "codescore": 0.9457966089248657, "surfaceSim": 0.7225660066006601, "abs_surfaceSim_minus_score": 0.27743399339933994, "source": "local", "local_type": "OP"}
{"id": "APPS_test-4065_32", "golden_code": "n = int(input())\ntasks = [int(i) for i in input().split()]\nmax_seq = [1] * n\nfor i in range(n-1):\n    if tasks[i+1] <= tasks[i] * 2:\n        max_seq[i+1] += max_seq[i]\nprint(max(max_seq))\n\n", "generated_code": "n = int(input())\na = sorted(list(map(int, input().split())))\n\nsolutions = sum(a[:-1])\n\nfor i in range(n - 1):\n\tsubsets = [a[i], a[i+1]]\n\tcurr = subsets[-1]\n\twhile True:\n\t\tif curr < subsets[-2]:\n\t\t\tsolutions -= 1\n\t\t\tbreak\n\t\telse:\n\t\t\tcurr = subsages[-2]\n\tsolutions += 1\n\nprint(solutions)\n", "score": 0.0, "codebleu": 0.25595014798340765, "crystalbleu": 0.19, "codebertscore": 0.8, "codescore": 0.07115328311920166, "surfaceSim": 0.5636001929105376, "abs_surfaceSim_minus_score": 0.5636001929105376, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_extra_p02555_s399411060_OP_1", "golden_code": "import math\n\n\n\n\n\ndef combinations_count(n, r):\n\n    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\n\n\n\n\n\ndef combinations_with_replacement_count(n, r):\n\n    return combinations_count(n + r - 1, r)\n\n\n\n\n\ndef main():\n\n    s = int(eval(input()))\n\n    ans = 0\n\n    n = s // 3\n\n\n\n    for i in range(1, n + 1):\n\n        ans += combinations_with_replacement_count(i, 3*(n-i)+s % 3)\n\n\n\n    print((ans % (10**9 + 7)))\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "generated_code": "def main():\n\n    s = int(eval(input()))\n\n    dp = [0] * 3 + [1] * 3 + [0 for _ in range(s)]\n\n\n\n    for i in range(6, s+1):\n\n        dp[i] = dp[i-1] + dp[i-3]\n\n\n\n    print((dp[s] % (10**9+7)))\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 1.0, "codebleu": 0.2440395617575486, "crystalbleu": 0.32, "codebertscore": 0.79, "codescore": 0.024944184347987175, "surfaceSim": 0.553046218487395, "abs_surfaceSim_minus_score": 0.446953781512605, "source": "local", "local_type": "OP"}
{"id": "LOCAL_MBPP_223_MUT_19", "golden_code": "import os\n\ndef is_majority(arr, n, x):\n    i = binary_search(arr, 0, n - 1, x)\n    if i == -1:\n        return False\n    if (i + (n // 2) <= n - 1 and arr[i + (n // 2)] == x):\n        return True\n    else:\n        return False\ndef binary_search(arr, low, high, x):\n    if high >= low:\n        mid = (low + high) // 2\n        if ((mid == 0 or x > arr[mid - 1]) and arr[mid] == x):\n            return mid\n        elif x > arr[mid]:\n            return binary_search(arr, mid + 1, high, x)\n        else:\n            return binary_search(arr, low, mid - 1, x)\n    return -1", "generated_code": "import os\n\ndef is_majority(arr, n, x):\n    i = binary_search(arr, 0, n - 1, x)\n    if not (i == -1):\n        return False\n    if (i + (n // 2) <= n - 1 and arr[i + (n // 2)] == x):\n        return True\n    else:\n        return False\ndef binary_search(arr, low, high, x):\n    if high >= low:\n        mid = (low + high) // 2\n        if ((mid == 0 or x > arr[mid - 1]) and arr[mid] == x):\n            return mid\n        elif x > arr[mid]:\n            return binary_search(arr, mid + 1, high, x)\n        else:\n            return binary_search(arr, low, mid - 1, x)\n    return -1", "score": 0.3644, "codebleu": 0.9619286059848772, "crystalbleu": 0.93, "codebertscore": 0.99, "codescore": 0.9936281442642212, "surfaceSim": 0.9795079659967347, "abs_surfaceSim_minus_score": 0.6151079659967347, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-4001_4", "golden_code": "# map(int,input().split(\" \"))\n\nn=int(input())\n\nl=list(map(int,input().split(\" \")))\n\n\nm=max(l)\n\ni=1;\n\nwhile (i*i<=m):\n\tif(m%i==0):\n\t\tif(len(l)>0 and (i in l)):\n\t\t\tl.remove(i)\n\t\tif(len(l)>0 and ((m//i) in l) and (i!=(m//i))):\n\t\t\tl.remove(m//i)\n\ti+=1\n\nprint(m,max(l))\n# print(l)\n\n\n", "generated_code": "#!/usr/bin/env python3\n\nimport sys\nimport math\n\ndef main():\n\tn = int(input())\n\tD = list(map(int, input().split()))\n\tD.sort()\n\tr = []\n\tc = 0\n\tfor d in D:\n\t\tif d == 0:\n\t\t\tc += 1\n\t\telse:\n\t\t\tif c == 0:\n\t\t\t\tr.append(d)\n\t\t\telse:\n\t\t\t\tr += [d,]\n\t\t\t\tc = 0\n\t\t\t\t\n\tif c == 0 and d % 2 == 0:\n\t\tr.append(int(d / 2))\n\telse:\n\t\tr += [d]\n\tprint(' '.join(map(str, r)))\n\ndef __starting_point():\n\tmain()\n\n__starting_point()\n", "score": 0.0, "codebleu": 0.16742110364548937, "crystalbleu": 0.13, "codebertscore": 0.76, "codescore": 0.0976501926779747, "surfaceSim": 0.5343517369727047, "abs_surfaceSim_minus_score": 0.5343517369727047, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_155_MUT_9", "golden_code": "import os\n\ndef even_odd_count(num):\n    even_count = 0\n    odd_count = 0\n    for i in str(abs(num)):\n        if int(i) % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    return (even_count, odd_count)", "generated_code": "import os\n\ndef even_odd_count(num):\n    even_count = 0\n    odd_count = 0\n    for i in str(abs(num)):\n        if int(i) % 2 != 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    return (even_count, odd_count)", "score": 0.1026, "codebleu": 0.9556628264043013, "crystalbleu": 0, "codebertscore": 1.0, "codescore": 0.6482247710227966, "surfaceSim": 0.9543665667166417, "abs_surfaceSim_minus_score": 0.8517665667166416, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_PIE_extra_p04020_s043977447_OP_1", "golden_code": "def examB():\n\n    N = I(); A = [I() for _ in range(N)]\n\n    ans = 0; cur= 0\n\n    for i in A:\n\n        if i==0:\n\n            ans += cur//2\n\n            cur = 0\n\n        else:\n\n            cur += i\n\n    ans += cur // 2\n\n    print(ans)\n\n    return\n\n\n\nimport sys,copy,bisect,itertools,heapq,math\n\nfrom heapq import heappop,heappush,heapify\n\nfrom collections import Counter,defaultdict,deque\n\ndef I(): return int(sys.stdin.readline())\n\ndef LI(): return list(map(int,sys.stdin.readline().split()))\n\ndef LSI(): return list(map(str,sys.stdin.readline().split()))\n\ndef LS(): return sys.stdin.readline().split()\n\ndef SI(): return sys.stdin.readline().strip()\n\nmod = 10**9 + 7\n\ninf = float('inf')\n\n\n\nif __name__ == '__main__':\n\n    examB()\n", "generated_code": "def examA():\n\n    S = SI()\n\n    if \"W\" in S and not \"E\" in S:\n\n        print(\"No\")\n\n    elif \"E\" in S and not \"W\" in S:\n\n        print(\"No\")\n\n    elif \"N\" in S and not \"S\" in S:\n\n        print(\"No\")\n\n    elif \"S\" in S and not \"N\" in S:\n\n        print(\"No\")\n\n    else:\n\n        print(\"Yes\")\n\n    return\n\n\n\ndef examB():\n\n    N = I()\n\n    A = [I()for _ in range(N)]\n\n    ans = 0\n\n    for i in range(N-1):\n\n        ans += A[i]//2\n\n        if A[i]%2 and A[i+1]>=1:\n\n            ans += 1\n\n            A[i+1] -= 1\n\n    ans += A[N-1]//2\n\n    print(ans)\n\n    return\n\n\n\ndef examC():\n\n    ans = 0\n\n    print(ans)\n\n    return\n\n\n\ndef examD():\n\n    N = I()\n\n    S = [I()for _ in range(N)]\n\n\n\n    ans = 0\n\n    print(ans)\n\n    return\n\n\n\ndef examE():\n\n    ans = 0\n\n    print(ans)\n\n    return\n\n\n\ndef examF():\n\n    ans = 0\n\n    print(ans)\n\n    return\n\n\n\nimport sys,bisect,itertools,heapq,math,random\n\nfrom copy import deepcopy\n\nfrom heapq import heappop,heappush,heapify\n\nfrom collections import Counter,defaultdict,deque\n\ndef I(): return int(sys.stdin.readline())\n\ndef LI(): return list(map(int,sys.stdin.readline().split()))\n\ndef LSI(): return list(map(str,sys.stdin.readline().split()))\n\ndef LS(): return sys.stdin.readline().split()\n\ndef SI(): return sys.stdin.readline().strip()\n\nglobal mod,mod2,inf,alphabet,_ep\n\nmod = 10**9 + 7\n\nmod2 = 998244353\n\ninf = 10**18\n\n_ep = 10**(-12)\n\nalphabet = [chr(ord('a') + i) for i in range(26)]\n\n\n\nsys.setrecursionlimit(10**6)\n\n\n\nif __name__ == '__main__':\n\n    examB()\n\n\n\n\"\"\"\n\n\n\n\"\"\"", "score": 1.0, "codebleu": 0.5713942112196712, "crystalbleu": 0.34, "codebertscore": 0.85, "codescore": 0.06178516149520874, "surfaceSim": 0.6496185610302352, "abs_surfaceSim_minus_score": 0.3503814389697648, "source": "local", "local_type": "OP"}
{"id": "MBPP_18_15", "golden_code": "def is_Isomorphic(str1,str2):          \r\n    dict_str1 = {}\r\n    dict_str2 = {}\r\n    for i, value in enumerate(str1):\r\n        dict_str1[value] = dict_str1.get(value,[]) + [i]        \r\n    for j, value in enumerate(str2):\r\n        dict_str2[value] = dict_str2.get(value,[]) + [j]\r\n    if sorted(dict_str1.values()) == sorted(dict_str2.values()):\r\n        return True\r\n    else:\r\n        return False", "generated_code": "def is_Isomorphic(str1, str2): return str1 == \"\".join(str2.split())", "score": 0.9443, "codebleu": 0.08538269768813413, "crystalbleu": 0, "codebertscore": 0.73, "codescore": 0.9366766214370728, "surfaceSim": 0.46638334967854417, "abs_surfaceSim_minus_score": 0.47791665032145586, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_MBPP_971_MUT_8", "golden_code": "import os\n\ndef maximum_segments(n, a, b, c):\n    dp = [-1] * (n + 10)\n    dp[0] = 0\n    for i in range(0, n):\n        if dp[i] != -1:\n            if i + a <= n:\n                dp[i + a] = max(dp[i] + 1, \n                    dp[i + a])\n            if i + b <= n:\n                dp[i + b] = max(dp[i] + 1, \n                    dp[i + b])\n            if i + c <= n:\n                dp[i + c] = max(dp[i] + 1, \n                    dp[i + c])\n    return dp[n]", "generated_code": "import os\n\ndef maximum_segments(n, a, b, c):\n    dp = [-1] * (n + 10)\n    dp[0] = 0\n    for i in range(0, n):\n        if dp[i] != +1:\n            if i + a <= n:\n                dp[i + a] = max(dp[i] + 1, \n                    dp[i + a])\n            if i + b <= n:\n                dp[i + b] = max(dp[i] + 1, \n                    dp[i + b])\n            if i + c <= n:\n                dp[i + c] = max(dp[i] + 1, \n                    dp[i + c])\n    return dp[n]", "score": 0.1227, "codebleu": 0.9833010724856466, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.9937930107116699, "surfaceSim": 0.9803849902534113, "abs_surfaceSim_minus_score": 0.8576849902534113, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-0442_31", "golden_code": "import sys\nfrom collections import Counter\nimport itertools\nfrom math import floor, ceil\n \ndef input():\n    return sys.stdin.readline().strip()\n \ndef dinput():\n    return int(input())\n \ndef tinput():\n    return input().split()\n \ndef rinput():\n    return map(int, tinput())\n \ndef rt(x1, x2, y3):\n    print(0.5*(x2+x1))\n \ndef main():\n    y = int(input())\n    i = 1\n    t = 0\n    r = 1\n    if y % 2 == 1 and y >= 5:\n        print(1, (y - 3)//2)\n    else:\n        print(\"NO\")\n        \n    \nmain()", "generated_code": "import sys\n\ndef main():\n\tr = int(sys.stdin.readline())\n\tif r % 2 == 0:\n\t\tprint(\"NO\")\n\telse:\n\t\tprint(2)\n\ndef __starting_point():\n\tmain()\n\n__starting_point()\n", "score": 0.3288, "codebleu": 0.19672416196084325, "crystalbleu": 0, "codebertscore": 0.75, "codescore": 0.2892887592315674, "surfaceSim": 0.548054587688734, "abs_surfaceSim_minus_score": 0.21925458768873407, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_p02555_s973678433_MUT_9", "golden_code": "def cmb(n, r):\n    import math\n    if n < r:\n        return 0\n    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\ndef solve(S):\n    mod = (10 ** 9) + 7\n    ans = 0\n    for i in range(1, (S // 3) + 1):\n        tama = i + (S - (i * 3))\n        tama -= 2\n        bo = i - 1\n        ans += cmb(tama + 1, bo)\n        ans %= mod\n    print(ans)", "generated_code": "def cmb(n, r):\n    import math\n    if n < r:\n        return 0\n    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\ndef solve(S):\n    mod = (10 ** 9) + 7\n    ans = 0\n    for i in range(1, (S / 3) + 1):\n        tama = i + (S - (i * 3))\n        tama -= 2\n        bo = i - 1\n        ans += cmb(tama + 1, bo)\n        ans %= mod\n    print(ans)", "score": 0.0, "codebleu": 0.980976656443197, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.9937092065811157, "surfaceSim": 0.9807578155916106, "abs_surfaceSim_minus_score": 0.9807578155916106, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-2043_57", "golden_code": "from functools import reduce\nfrom operator import *\nfrom math import *\nfrom sys import *\nfrom string import *\nfrom collections import *\nsetrecursionlimit(10**7)\ndX= [-1, 1, 0, 0,-1, 1,-1, 1]\ndY= [ 0, 0,-1, 1, 1,-1,-1, 1]\nRI=lambda: list(map(int,input().split()))\nRS=lambda: input().rstrip().split()\n#################################################\ndef findMatch(a,b):\n    i,j=0,0\n    while i<len(a) and j<len(b):\n        if a[i]==b[j]:\n            j+=1\n        i+=1\n    return i\ns=RS()[0]\nt=RS()[0]\nx=findMatch(t,s)\ny=len(t)-findMatch(t[::-1],s[::-1])\nprint( max(y-x+1, 0))\n\n\n\n\n", "generated_code": "from collections import Counter\n\ndef solve(s, t):\n\tcnt = Counter(s)\n\tif all(v == 1 for v in cnt.values()):\n\t\treturn 2\n\telif all(v0 == 1 for v0 in cnt.value()) and all(v == 2 for v in cnd.value()):\n\t\tkey = ''.join(sorted(t))\n\t\treturn sum(s[i] == key[i-1] for i in range(1, len(key) + 1))\n\telse:\n\t\treturn 0\n\ns = input()\nt = input()\nprint(solve(s, t))\n", "score": 0.0002, "codebleu": 0.1233686653292282, "crystalbleu": 0.03, "codebertscore": 0.71, "codescore": 0.7720308899879456, "surfaceSim": 0.5450917238482005, "abs_surfaceSim_minus_score": 0.5448917238482005, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_20_OP_1", "golden_code": "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    closest_pair = None\n    distance = None\n\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                if distance is None:\n                    distance = abs(elem - elem2)\n                    closest_pair = tuple(sorted([elem, elem2]))\n                else:\n                    new_distance = abs(elem - elem2)\n                    if new_distance < distance:\n                        distance = new_distance\n                        closest_pair = tuple(sorted([elem, elem2]))\n\n    return closest_pair", "generated_code": "from typing import List, Tuple\n\ndef find_closest_elements(values: List[float]) -> Tuple[float, float]:\n    if len(values) < 2:\n        return None\n\n    sorted_values = sorted(values)\n    min_distance = float('inf')\n    closest_pair = None\n\n    for i in range(len(sorted_values) - 1):\n        current_distance = abs(sorted_values[i] - sorted_values[i + 1])\n        if current_distance < min_distance:\n            min_distance = current_distance\n            closest_pair = (sorted_values[i], sorted_values[i + 1])\n\n    return closest_pair\n", "score": 0.957, "codebleu": 0.30152555953898363, "crystalbleu": 0.24, "codebertscore": 0.82, "codescore": 0.368235319852829, "surfaceSim": 0.7544465843434915, "abs_surfaceSim_minus_score": 0.20255341565650842, "source": "local", "local_type": "OP"}
{"id": "LOCAL_HE_43_OP_1", "golden_code": "def pairs_sum_to_zero(l):\n    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False", "generated_code": "def pairs_sum_to_zero(nums):\n    seen = set()\n    for num in nums:\n        if -num in seen:\n            return True\n        seen.add(num)\n    return False", "score": 1.0, "codebleu": 0.18792738926285193, "crystalbleu": 0, "codebertscore": 0.81, "codescore": 0.9346796870231628, "surfaceSim": 0.5816374269005848, "abs_surfaceSim_minus_score": 0.41836257309941516, "source": "local", "local_type": "OP"}
{"id": "APPS_test-1424_17", "golden_code": "n,m,k=map(int,input().split())\na=[]\nans=0\nfor i in range(m):\n    a.append(int(input()))\ns=int(input())\nr=[]\nfor i in range(n):\n    r.append(s%2)\n    s=s//2\nfor i in range(m):\n    j=0\n    c=0\n    g=a[i]\n    while j<n and c<=k:\n        if r[j]==g%2:\n            j+=1\n        else:\n            j+=1\n            c+=1\n        g=g//2\n    if c<=k:\n        ans+=1\nprint(ans)", "generated_code": "n,m,k=list(map(int,input().split()))\nar=[0]*(m+1)\nfor i in range(n):\n\tar[int(input())]+=1\nif(m==1):\n\tprint(0)\n\treturn\nif(n==3):\n\tif(ar[2]!=1):\n\t\tprint(1)\n\t\treturn\n\tif( ar[0]==1 and ar[1]==1):\n\t\treturn 1\n\telif(ar[0]==ar[1]==ar[2]):\n\t\treturn 0\n\telse:\n\t\tprint(2)\n\t\treturn 0 if ar[0]>=k else ar[0]-k\nelse:\n\tif(n==2):\n\t\tprint(\"0\")\n\t\treturn\n\t\t\t\t\n\tprint(n-ar[0])\n\t\n\n", "score": 0.0, "codebleu": 0.1854053958284132, "crystalbleu": 0.18, "codebertscore": 0.8, "codescore": 0.10044306516647339, "surfaceSim": 0.5573770491803278, "abs_surfaceSim_minus_score": 0.5573770491803278, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_1254_3_MUT_29", "golden_code": "(n, m) = list(map(int, input().split()))\nspec = {}\nfor i in range(n):\n    (s, r) = list(map(int, input().split()))\n    if s in spec:\n        spec[s].append(r)\n    else:\n        spec[s] = [r]\nf = n\ncnt = [-1 for i in range(n + 1)]\nfor (k, cur) in list(spec.items()):\n    cur.sort(reverse=True)\n    for j in range(1, len(cur)):\n        cur[j] += cur[j - 1]\n    for j in range(1, len(cur) + 1):\n        if cnt[j] == -1:\n            cnt[j] = 0\n        cnt[j] += max(0, cur[j - 1])\nprint(max(cnt))", "generated_code": "(n, m) = list(map(int, input().split()))\nspec = {}\nfor i in range(n):\n    pass\n    if s in spec:\n        spec[s].append(r)\n    else:\n        spec[s] = [r]\nf = n\ncnt = [-1 for i in range(n + 1)]\nfor (k, cur) in list(spec.items()):\n    cur.sort(reverse=True)\n    for j in range(1, len(cur)):\n        cur[j] += cur[j - 1]\n    for j in range(1, len(cur) + 1):\n        if cnt[j] == -1:\n            cnt[j] = 0\n        cnt[j] += max(0, cur[j - 1])\nprint(max(cnt))", "score": 0.0, "codebleu": 0.9158893804011058, "crystalbleu": 0.87, "codebertscore": 0.97, "codescore": 0.9937468767166138, "surfaceSim": 0.9482057751611999, "abs_surfaceSim_minus_score": 0.9482057751611999, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_APPS_1085_39_MUT_32", "golden_code": "n = int(input())\ndef make_divisors(n):\n    divisors = []\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n // i)\n    return divisors\nimport sys\nsys.setrecursionlimit(10 ** 7)\ndef func(N, d):\n    if d == 1:\n        return False\n    while N > 1:\n        if N % d == 0:\n            N //= d\n        \n        elif (N - 1) % d == 0:\n            N = 1\n        else:\n            N = 0\n    return True if N == 1 else False\n\nans = len(set(make_divisors(n - 1))) - 1\nl = set(make_divisors(n))\nfor li in l:\n    if func(n, li):\n        ans += 1\nprint(ans)", "generated_code": "n = int(input())\ndef make_divisors(n):\n    divisors = []\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            if i == n // i:\n                divisors.append(n // i)\n    return divisors\nimport sys\nsys.setrecursionlimit(10 ** 7)\ndef func(N, d):\n    if d == 1:\n        return False\n    while N > 1:\n        if N % d == 0:\n            N //= d\n        \n        elif (N - 1) % d == 0:\n            N = 1\n        else:\n            N = 0\n    return True if N == 1 else False\n\nans = len(set(make_divisors(n - 1))) - 1\nl = set(make_divisors(n))\nfor li in l:\n    if func(n, li):\n        ans += 1\nprint(ans)", "score": 0.0, "codebleu": 0.9882119736406023, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9937173128128052, "surfaceSim": 0.9831017369727048, "abs_surfaceSim_minus_score": 0.9831017369727048, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-0077_62", "golden_code": "def max(a, b):\n\tif a > b:\n\t\treturn a\n\telse:\n\t\treturn b\n\ndef min(a, b):\n\tif a < b:\n\t\treturn a\n\telse:\n\t\treturn b\n\ndef __starting_point():\n\tn = int(input())\n\tA = input().split(' ')\n\tans, count, Min, Max = 0, 0, 1000000000, -100000000000\n\tfor i in range(n):\n\t\tnow = int(A[i])\n\t\tif now % 2 == 0:\n\t\t\tans += max(now, 0)\n\t\telse:\n\t\t\tif (now < 0):\n\t\t\t\tMax = max(Max, now)\n\t\t\telse:\n\t\t\t\tMin = min(Min, now)\n\t\t\t\tans += now\n\n\tif ans % 2 == 0:\n\t\tans = max(ans - Min, ans + Max)\n\tprint(ans)\n\n__starting_point()", "generated_code": "import sys\nn = int(input())\na = list(map(int, input().split()))\nans = -1\nfor i in range(n):\n\tif a[i] % 2 == 0:\n\t\tans = i\n\t\tbreak\nprint(ans)\n", "score": 0.0, "codebleu": 0.120259558447044, "crystalbleu": 0.06, "codebertscore": 0.76, "codescore": 0.09278592467308044, "surfaceSim": 0.5033527327935223, "abs_surfaceSim_minus_score": 0.5033527327935223, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_955_11_MUT_26", "golden_code": "n = int(input())\nd = {}\nfor _ in range(n):\n    s = input().split()\n    p = int(s[0])\n    s[1] = list(s[1])\n    s[1].sort()\n    s[1] = ''.join(s[1])\n    if s[1] in d:\n        d[s[1]] = min(d[s[1]], p)\n    else:\n        d[s[1]] = p\ndef get(s):\n    if s in d:\n        return d[s]\n    return 10 ** 6\na = get('A')\nb = get('B')\nc = get('C')\nab = get('AB')\nbc = get('BC')\nac = get('AC')\nabc = get('ABC')\nans = min((a + b) + c, a + bc, b + ac, c + ab, abc, ab + bc, ab + ac, ac + bc)\nif ans < 10 ** 6:\n    print(ans)\nelse:\n    print(-1)", "generated_code": "pass\nd = {}\nfor _ in range(n):\n    s = input().split()\n    p = int(s[0])\n    s[1] = list(s[1])\n    s[1].sort()\n    s[1] = ''.join(s[1])\n    if s[1] in d:\n        d[s[1]] = min(d[s[1]], p)\n    else:\n        d[s[1]] = p\ndef get(s):\n    if s in d:\n        return d[s]\n    return 10 ** 6\na = get('A')\nb = get('B')\nc = get('C')\nab = get('AB')\nbc = get('BC')\nac = get('AC')\nabc = get('ABC')\nans = min((a + b) + c, a + bc, b + ac, c + ab, abc, ab + bc, ab + ac, ac + bc)\nif ans < 10 ** 6:\n    print(ans)\nelse:\n    print(-1)", "score": 0.0, "codebleu": 0.8995004566207465, "crystalbleu": 0.96, "codebertscore": 0.99, "codescore": 0.9937560558319092, "surfaceSim": 0.9691708754208754, "abs_surfaceSim_minus_score": 0.9691708754208754, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_PIE_extra_p03371_s088381244_OP_1", "golden_code": "a,b,c,x,y=list(map(int,input().split()))\n\n\n\nans=a*x+b*y\n\nfor ci in range(max(x,y)+1):\n\n    sumc = 2*ci*c\n\n    sumc += (x-ci)*a if (x-ci)>0 else 0\n\n    sumc += (y-ci)*b if (y-ci)>0 else 0\n\n    ans=min(ans,sumc)\n\n\n\nprint(ans)", "generated_code": "a,b,c,x,y=list(map(int,input().split()))\n\nans=a*x+b*y\n\nif x==y:\n\n    ans=min(ans,2*x*c)\n\nelif x>y:\n\n    ans=min(ans,a*(x-y)+2*y*c)\n\n    ans=min(ans,2*x*c)\n\nelse:\n\n    ans=min(ans,b*(y-x)+2*x*c)\n\n    ans=min(ans,2*y*c)\n\nprint(ans)", "score": 0.9175, "codebleu": 0.29429607913114075, "crystalbleu": 0.46, "codebertscore": 0.87, "codescore": 0.09692089259624481, "surfaceSim": 0.6735288001663547, "abs_surfaceSim_minus_score": 0.24397119983364524, "source": "local", "local_type": "OP"}
{"id": "MBPP_34_86", "golden_code": "def even_num(x):\r\n  if x%2==0:\r\n     return True\r\n  else:\r\n    return False", "generated_code": "def even_num(x):\n\t\t\t return int(x)*0.5%2==0", "score": 0.6423, "codebleu": 0.29833177445980413, "crystalbleu": 0, "codebertscore": 0.82, "codescore": 0.6121156811714172, "surfaceSim": 0.6866666666666666, "abs_surfaceSim_minus_score": 0.044366666666666665, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-1312_33", "golden_code": "n,m=map(int,input().split())\nprint(*[n//m+1 if i<n%m else n//m for i in range(m)])", "generated_code": "n, m = list(map(int, input().split()))\na = [0] * m\nfor i in range(m):\n\ta[i] = int(input())\na.sort()\nans = [0]*m\nj = 0\nfor i in reversed(range(m)):\n\tif i!= j:\n\t\tans[i] = ans[j] + a[i]\n\t\tj += 1\nprint(' '.join(map(str, ans)))\n", "score": 0.0, "codebleu": 0.24646704509675482, "crystalbleu": 0, "codebertscore": 0.8, "codescore": 0.06040157750248909, "surfaceSim": 0.43393657911595135, "abs_surfaceSim_minus_score": 0.43393657911595135, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_MBPP_463_MUT_46", "golden_code": "import os\n\ndef max_subarray_product(arr):\n    n = len(arr)\n    max_ending_here = 1\n    min_ending_here = 1\n    max_so_far = 0\n    flag = 0\n    for i in range(0, n):\n        if arr[i] > 0:\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n            flag = 1\n        elif arr[i] == 0:\n            max_ending_here = 1\n            min_ending_here = 1\n        else:\n            temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        if max_so_far < max_ending_here:\n            max_so_far = max_ending_here\n    if (flag == 0 and max_so_far == 0):\n        return 0\n    return max_so_far", "generated_code": "import os\n\ndef max_subarray_product(arr):\n    n = len(arr)\n    max_ending_here = 1\n    min_ending_here = 1\n    max_so_far = 0\n    flag = 0\n    for i in range(0, n):\n        if arr[i] > 0:\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n            flag = 1\n        elif arr[i] == 0:\n            max_ending_here = 1\n            min_ending_here = 1\n        else:\n            temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        if max_so_far < max_ending_here:\n            max_so_far = max_ending_here\n    if (flag == 0 and max_so_far == 0):\n        return 0\n    pass", "score": 0.0, "codebleu": 0.9685109684087799, "crystalbleu": 0.97, "codebertscore": 1.0, "codescore": 0.9937655925750732, "surfaceSim": 0.9712194354077028, "abs_surfaceSim_minus_score": 0.9712194354077028, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-1946_7", "golden_code": "m=int(input())\nd={}\nfor i in range(m):\n  a,v=map(int,input().split())\n  d[a]=v\nn=int(input())\nfor i in range(n):\n  a,v=map(int,input().split())\n  if(a in d):\n    d[a]=max(d[a],v)\n  else:\n    d[a]=v\n#print(d)\nl=d.values()\nprint(sum(l))", "generated_code": "from collections import defaultdict\nfrom sys import stdin\ninput = stdin.readline\n\nn = int(input())\n\nvals = defaultdict(list)\n\nfor i in range(n):\n\ta,x = list(map(int,input().split()))\n\tvals[x].append(a)\n\nfor _ in range(int(input())):\n\tb,x = list (map(int, input().split()))\t\n\t\n\tvals[b].append(x)\n\nans = 0\n\ndone = defaultdict(int)\n\nfor a in vals:\n\tif done[a] == 0:\n\t\tans += max(vals[a])\n\t\tdone[a] = 1\n\telse:\n\t\tans = max(ans, sum([x for x in vals[a]]))\n\t\tdone[ a ] = 1\n\t\nprint", "score": 0.0, "codebleu": 0.2855364519766183, "crystalbleu": 0.18, "codebertscore": 0.79, "codescore": 0.08118630945682526, "surfaceSim": 0.5168252290345314, "abs_surfaceSim_minus_score": 0.5168252290345314, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_33_37", "golden_code": "def count_Unset_Bits(n) :  \r\n    cnt = 0;  \r\n    for i in range(1,n + 1) : \r\n        temp = i;  \r\n        while (temp) :  \r\n            if (temp % 2 == 0) : \r\n                cnt += 1;  \r\n            temp = temp // 2;  \r\n    return cnt;  ", "generated_code": "def count_Unset_Bits(n) -> int:\n\treturn n&0x1", "score": 0.0, "codebleu": 0.06865057002396416, "crystalbleu": 0, "codebertscore": 0.69, "codescore": 0.11792448163032532, "surfaceSim": 0.5217723453017571, "abs_surfaceSim_minus_score": 0.5217723453017571, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_148_OP_1", "golden_code": "def bf(planet1, planet2):\n    '''\n    There are eight planets in our solar system: the closerst to the Sun \n    is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n    Uranus, Neptune.\n    Write a function that takes two planet names as strings planet1 and planet2. \n    The function should return a tuple containing all planets whose orbits are \n    located between the orbit of planet1 and the orbit of planet2, sorted by \n    the proximity to the sun. \n    The function should return an empty tuple if planet1 or planet2\n    are not correct planet names. \n    Examples\n    bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n    bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n    bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n    '''\n    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:\n        return ()\n    planet1_index = planet_names.index(planet1)\n    planet2_index = planet_names.index(planet2)\n    if planet1_index < planet2_index:\n        return (planet_names[planet1_index + 1: planet2_index])\n    else:\n        return (planet_names[planet2_index + 1 : planet1_index])", "generated_code": "def bf(first_planet, second_planet):\n    '''\n    Optimized function to find planets between two given planets.\n    '''\n    planets = {\"Mercury\": 0, \"Venus\": 1, \"Earth\": 2, \"Mars\": 3, \"Jupiter\": 4, \"Saturn\": 5, \"Uranus\": 6, \"Neptune\": 7}\n    if first_planet not in planets or second_planet not in planets or first_planet == second_planet:\n        return ()\n    idx1, idx2 = planets[first_planet], planets[second_planet]\n    if idx1 < idx2:\n        return tuple(name for name, idx in planets.items() if idx1 < idx < idx2)\n    else:\n        return tuple(name for name, idx in planets.items() if idx2 < idx < idx1)", "score": 1.0, "codebleu": 0.23917781698081853, "crystalbleu": 0.1, "codebertscore": 0.76, "codescore": 0.5145304799079895, "surfaceSim": 0.5434477250192795, "abs_surfaceSim_minus_score": 0.4565522749807205, "source": "local", "local_type": "OP"}
{"id": "APPS_test-3693_6", "golden_code": "\nimport sys\n#sys.stdin=open(\"data.txt\")\ninput=sys.stdin.readline\n\na=list(map(int,input().split()))\nb=list(map(int,input().split()))\n\nax1=min(a[::2])\nax2=max(a[::2])\nay1=min(a[1::2])\nay2=max(a[1::2])\n\nbx1=min(b[::2])\nbx2=max(b[::2])\nby=0\nfor i in range(4):\n    if b[i*2]==bx1:\n        by=b[i*2+1]\n\nhas=0\nfor i in range(ax1,ax2+1):\n    for j in range(ay1,ay2+1):\n        # check this point\n        if i<bx1 or i>bx2: continue\n        if bx1<=i<=(bx1+bx2)//2 and abs(j-by)<=abs(i-bx1):\n            has=1\n        if (bx1+bx2)//2<=i<=bx2 and abs(j-by)<=abs(i-bx2):\n            has=1\nprint(\"YES\" if has else \"NO\")\n", "generated_code": "import math\n\ntry:\n\tx, y = list(map(int, input().split()))\n\tgx = math.gcd(x, y)\n\tgy = math.gce(x, y);\n\n\tif gx == gy:\n\t\tprint(\"YES\")\n\telse:\n\t\tprint((gy//gx) & 1)\n\nexcept:\n\tpass\n", "score": 0.0, "codebleu": 0.09168319612695591, "crystalbleu": 0.02, "codebertscore": 0.67, "codescore": 0.021577851846814156, "surfaceSim": 0.4220577485380117, "abs_surfaceSim_minus_score": 0.4220577485380117, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0531_23", "golden_code": "n = int(input())\nx = list(map(int, input().split()))\nmn = 0\nmx = 0\nminv = min(x)\nmaxv = max(x)\nfor i in x:\n    if i == minv:\n        mn += 1\n    elif i == maxv:\n        mx += 1\nif minv != maxv-2:\n    print(n)\n    for i in x:\n        print(i, end=' ')\nelse:\n    c = min(mn, mx)\n    print(min((n - 2*c), (mn + mx + (n-mn-mx)%2))) \n    if (n - 2*c) < (mn + mx + (n-mn-mx)%2):\n        for i in range(len(x)):\n            if (x[i]==maxv) and (c > 0):\n                x[i] = (maxv + minv)//2\n                c -= 1\n        c = min(mn, mx)\n        for i in range(len(x)):\n            if (x[i]==minv) and (c>0):\n                x[i] = (maxv + minv)//2\n                c -= 1\n        for i in x:\n            print(i, end=' ')\n    else:\n        c = (n - mn - mx)//2\n        for i in range(len(x)):\n            if (x[i] == (minv+maxv)//2) and (c>0):\n                c -= 1\n                x[i] = minv\n        c = (n - mn - mx)//2\n        for i in range(len(x)):\n            if (x[i] == (minv+maxv)//2) and (c>0):\n                c -= 1\n                x[i] = maxv    \n        for i in x:\n            print(i, end=' ')\n", "generated_code": "n = int(input())\n\na = list(map(int, input().split()))\nk = []\nfor i in range(n):\n\tk.append(a[i])\n\t\na.sort()\n\nb = []\nfor u in range(n-1):\n\tb.append(a [u + 1] - a [u])\n\nc = []\nfor j in range(n) :\n\tc.append(a[_] / u)\n\nprint(sum(c))\nprint(' '.join(map(str,c)))\n", "score": 0.0, "codebleu": 0.13102410326329048, "crystalbleu": 0.03, "codebertscore": 0.72, "codescore": 0.07088065892457962, "surfaceSim": 0.5237127371273713, "abs_surfaceSim_minus_score": 0.5237127371273713, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_77_8", "golden_code": "def floor_Max(A,B,N):\r\n    x = min(B - 1,N)\r\n    return (A*x) // B", "generated_code": "def floor_Max(A,B,N):\n\tfor i in range(1,N+1):\n\t\tif N%i==0:\n\t\t\treturn N//i\n\treturn 2**N", "score": 0.1469, "codebleu": 0.17188000706369772, "crystalbleu": 0, "codebertscore": 0.82, "codescore": 0.08352866768836975, "surfaceSim": 0.5517970401691332, "abs_surfaceSim_minus_score": 0.4048970401691332, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_4620_17_MUT_12", "golden_code": "n = int(input())\ngraph = []\ntime = 0\nfor i in range(n - 1):\n    (c, s, f) = map(int, input().split())\n    graph.append([i, c, s, f])\n\ndef shortest_path(start, end, times):\n    if start == end:\n        return times\n    elif times <= graph[start][2]:\n        times = graph[start][2] + graph[start][1]\n        return shortest_path(start + 1, end, times)\n    elif times % graph[start][3] == 0:\n        times += graph[start][1]\n        return shortest_path(start + 1, end, times)\n    else:\n        times = ((times + graph[start][3]) - (times % graph[start][3])) + graph[start][1]\n        return shortest_path(start + 1, end, times)\n\n\nfor i in range(n):\n    print(shortest_path(i, n - 1, 0))", "generated_code": "n = int(input())\ngraph = []\ntime = 0\nfor i in range(n - 1):\n    (c, s, f) = map(int, input().split())\n    graph.append([i, c, s, f])\n\ndef shortest_path(start, end, times):\n    if start == end:\n        return times\n    elif times <= graph[start][2]:\n        times = graph[start][2] + graph[start][1]\n        return shortest_path(start + 1, end, times)\n    elif times % graph[start][3] == 0:\n        times -= graph[start][1]\n        return shortest_path(start + 1, end, times)\n    else:\n        times = ((times + graph[start][3]) - (times % graph[start][3])) + graph[start][1]\n        return shortest_path(start + 1, end, times)\n\n\nfor i in range(n):\n    print(shortest_path(i, n - 1, 0))", "score": 0.0425, "codebleu": 0.986296521056131, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9936421513557434, "surfaceSim": 0.9992700729927007, "abs_surfaceSim_minus_score": 0.9567700729927007, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_APPS_4620_17_MUT_19", "golden_code": "n = int(input())\ngraph = []\ntime = 0\nfor i in range(n - 1):\n    (c, s, f) = map(int, input().split())\n    graph.append([i, c, s, f])\n\ndef shortest_path(start, end, times):\n    if start == end:\n        return times\n    elif times <= graph[start][2]:\n        times = graph[start][2] + graph[start][1]\n        return shortest_path(start + 1, end, times)\n    elif times % graph[start][3] == 0:\n        times += graph[start][1]\n        return shortest_path(start + 1, end, times)\n    else:\n        times = ((times + graph[start][3]) - (times % graph[start][3])) + graph[start][1]\n        return shortest_path(start + 1, end, times)\n\n\nfor i in range(n):\n    print(shortest_path(i, n - 1, 0))", "generated_code": "n = int(input())\ngraph = []\ntime = 0\nfor i in range(n - 1):\n    (c, s, f) = map(int, input().split())\n    graph.append([i, c, s, f])\n\ndef shortest_path(start, end, times):\n    if start == end:\n        return times\n    elif times <= graph[start][2]:\n        times = graph[start][2] + graph[start][1]\n        return shortest_path(start + 1, end, times)\n    elif times % graph[start][3] == 0:\n        times += graph[start][1]\n        return shortest_path(start + 1, end, times)\n    else:\n        times = ((times + graph[start][3]) - (times % graph[start][3])) + graph[start][1]\n        return shortest_path(start + 1, end, times)\n\n\nfor i in range(n):\n    print(shortest_path(i, n - 1, 0))\n    break", "score": 0.0355, "codebleu": 0.989767349276812, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9936703443527222, "surfaceSim": 0.9778263103802672, "abs_surfaceSim_minus_score": 0.9423263103802673, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_PIE_p03253_s213127805_MUT_2", "golden_code": "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nMOD = (10 ** 9) + 7\nfac = [1, 1]\nf_inv = [1, 1]\ninv = [0, 1]\ndef prepare(n, mod):\n    for i in range(2, n + 1):\n        fac.append((fac[-1] * i) % mod)\ndef cmb(n, r, mod):\n    if (n < 0 or r < 0):\n        return 0\n    if r > n:\n        return 0\n    return ((fac[n] * pow(fac[r], MOD - 2, MOD)) * pow(fac[n - r], MOD - 2, MOD)) % mod\ndef prime_factorization(n):\n    d = []\n    (i, e) = (2, 0)\n    while i * i <= n:\n        while n % i == 0:\n            n //= i\n            e += 1\n        if e > 0:\n            d.append((i, e))\n        i += 1\n        e = 0\n    if n > 1:\n        d.append((n, 1))\n    return d\ndef main():\n    (N, M) = list(map(int, readline().split()))\n    prepare(N + 100, MOD)\n    d = prime_factorization(M)\n    ans = 1\n    for (i, e) in d:\n        ans *= cmb((N - 1) + e, e, MOD)\n        ans %= MOD\n    print(ans)", "generated_code": "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nMOD = (10 * 9) + 7\nfac = [1, 1]\nf_inv = [1, 1]\ninv = [0, 1]\ndef prepare(n, mod):\n    for i in range(2, n + 1):\n        fac.append((fac[-1] * i) % mod)\ndef cmb(n, r, mod):\n    if (n < 0 or r < 0):\n        return 0\n    if r > n:\n        return 0\n    return ((fac[n] * pow(fac[r], MOD - 2, MOD)) * pow(fac[n - r], MOD - 2, MOD)) % mod\ndef prime_factorization(n):\n    d = []\n    (i, e) = (2, 0)\n    while i * i <= n:\n        while n % i == 0:\n            n //= i\n            e += 1\n        if e > 0:\n            d.append((i, e))\n        i += 1\n        e = 0\n    if n > 1:\n        d.append((n, 1))\n    return d\ndef main():\n    (N, M) = list(map(int, readline().split()))\n    prepare(N + 100, MOD)\n    d = prime_factorization(M)\n    ans = 1\n    for (i, e) in d:\n        ans *= cmb((N - 1) + e, e, MOD)\n        ans %= MOD\n    print(ans)", "score": 0.0, "codebleu": 0.9924868895723431, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9937357902526855, "surfaceSim": 0.9866389466389467, "abs_surfaceSim_minus_score": 0.9866389466389467, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_HE_109_OP_1", "golden_code": "def move_one_ball(arr):\n    if len(arr)==0:\n      return True\n    sorted_array=sorted(arr)\n    my_arr=[]\n\n    min_value=min(arr)\n    min_index=arr.index(min_value)\n    my_arr=arr[min_index:]+arr[0:min_index]\n    for i in range(len(arr)):\n      if my_arr[i]!=sorted_array[i]:\n        return False\n    return True", "generated_code": "def move_one_ball(balls):\n    if len(balls) <= 1:\n        return True\n    min_ball = min(balls)\n    min_pos = balls.index(min_ball)\n    rotated_balls = balls[min_pos:] + balls[:min_pos]\n    return rotated_balls == sorted(balls)", "score": 1.0, "codebleu": 0.2315547853156511, "crystalbleu": 0, "codebertscore": 0.83, "codescore": 0.45032915472984314, "surfaceSim": 0.6482449088960343, "abs_surfaceSim_minus_score": 0.35175509110396574, "source": "local", "local_type": "OP"}
{"id": "LOCAL_MBPP_428_MUT_30", "golden_code": "import os\n\ndef shell_sort(my_list):\n    gap = len(my_list) // 2\n    while gap > 0:\n        for i in range(gap, len(my_list)):\n            current_item = my_list[i]\n            j = i\n            while (j >= gap and my_list[j - gap] > current_item):\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            my_list[j] = current_item\n        gap //= 2\n    \n    return my_list", "generated_code": "import os\n\ndef shell_sort(my_list):\n    gap = len(my_list) // 2\n    while gap > 0:\n        for i in range(gap, len(my_list)):\n            current_item = my_list[i]\n            j = i\n            while (j >= gap and my_list[j - gap] > current_item):\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            my_list[j] = current_item\n        gap //= 2\n    \n    pass", "score": 0.0, "codebleu": 0.9484952436521829, "crystalbleu": 0.94, "codebertscore": 0.99, "codescore": 0.9937772750854492, "surfaceSim": 0.9478875860785408, "abs_surfaceSim_minus_score": 0.9478875860785408, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_PIE_extra_p03325_s116805601_OP_1", "golden_code": "N = int(eval(input()))\n\n\n\nseq = list(map(int, input().split()))\n\n\n\ncnt = 0\n\n\n\nfor num in seq:\n\n    while num % 2 == 0:\n\n        cnt += 1\n\n        num /= 2\n\n\n\nprint(cnt)\n", "generated_code": "n = int(eval(input()))\n\na = list(map(int, input().split()))\n\nans = 0\n\nfor num in a:\n\n    ans += format(num, 'b')[::-1].find('1')\n\nprint(ans)", "score": 1.0, "codebleu": 0.49436155286573247, "crystalbleu": 0, "codebertscore": 0.85, "codescore": 0.1632634699344635, "surfaceSim": 0.6484669176976869, "abs_surfaceSim_minus_score": 0.35153308230231306, "source": "local", "local_type": "OP"}
{"id": "LOCAL_APPS_1407_12_MUT_48", "golden_code": "def sieve(mx):\n    a = [0] * (mx + 1)\n    a[0] = a[1] = 1\n    for (i, e) in enumerate(a):\n        if e == 0:\n            for n in range(i * i, mx + 1, i):\n                a[n] = 1\n    return a\n\np = sieve((10 ** 5) + 100)\nfor i in range((10 ** 5) + 99, 0, -1):\n    p[i] *= p[i + 1] + 1\n\n(n, m) = map(int, input().split())\n\ncols = [0] * m\n\nmm = 10 ** 7\nfor i in range(n):\n    row = list(map(int, input().split()))\n    row_sum = 0\n    for (a, j) in enumerate(row):\n        tt = p[j]\n        row_sum += tt\n        cols[a] += tt\n    mm = min(mm, row_sum)\n\nprint(min(min(cols), mm))", "generated_code": "def sieve(mx):\n    a = [0] * (mx + 1)\n    a[0] = a[1] = 1\n    for (i, e) in enumerate(a):\n        if e == 0:\n            for n in range(i * i, mx + 1, i):\n                a[n] = 1\n    return a\n\np = sieve((10 ** 5) + 100)\nfor i in range((10 ** 5) + 99, 0, -1):\n    p[i] *= p[i + 1] + 1\n\n(n, m) = map(int, input().split())\n\npass\n\nmm = 10 ** 7\nfor i in range(n):\n    row = list(map(int, input().split()))\n    row_sum = 0\n    for (a, j) in enumerate(row):\n        tt = p[j]\n        row_sum += tt\n        cols[a] += tt\n    mm = min(mm, row_sum)\n\nprint(min(min(cols), mm))", "score": 0.0, "codebleu": 0.9135898452265456, "crystalbleu": 0.95, "codebertscore": 0.99, "codescore": 0.9937999844551086, "surfaceSim": 0.9749461206896552, "abs_surfaceSim_minus_score": 0.9749461206896552, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_APPS_4698_39_MUT_10", "golden_code": "N = int(input())\nT = list(map(int, input().split()))\nM = int(input())\nP = [0] * M\nX = [0] * M\nfor i in range(M):\n    (P[i], X[i]) = list(map(int, input().split()))\n\nfor i in range(M):\n    ans = 0\n    ans += sum(T[:P[i] - 1])\n    ans += X[i]\n    ans += sum(T[P[i]:])\n    print(ans)", "generated_code": "N = int(input())\nT = list(map(int, input().split()))\nM = int(input())\nP = [0] * M\nX = [0] * M\nfor i in range(M):\n    (P[i], X[i]) = list(map(int, input().split()))\n\nfor i in range(M):\n    ans = 0\n    ans += sum(T[:P[i] - 1])\n    ans += X[i]\n    ans -= sum(T[P[i]:])\n    print(ans)", "score": 0.054, "codebleu": 0.9758145994802561, "crystalbleu": 0.93, "codebertscore": 1.0, "codescore": 0.9936969876289368, "surfaceSim": 0.9982142857142857, "abs_surfaceSim_minus_score": 0.9442142857142857, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_HE_26_OP_2", "golden_code": "from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    import collections\n    c = collections.Counter(numbers)\n    return [n for n in numbers if c[n] <= 1]", "generated_code": "def remove_duplicates(values: List[int]) -> List[int]:\n    seen = set()\n    duplicates = set()\n    for value in values:\n        if value in seen:\n            duplicates.add(value)\n        else:\n            seen.add(value)\n    return [value for value in values if value not in duplicates]", "score": 1.0, "codebleu": 0.33135699856812956, "crystalbleu": 0, "codebertscore": 0.81, "codescore": 0.041886284947395325, "surfaceSim": 0.556821227552935, "abs_surfaceSim_minus_score": 0.44317877244706505, "source": "local", "local_type": "OP"}
{"id": "MBPP_123_1", "golden_code": "def check_type(test_tuple):\r\n  res = True\r\n  for ele in test_tuple:\r\n    if not isinstance(ele, type(test_tuple[0])):\r\n      res = False\r\n      break\r\n  return (res) ", "generated_code": "def check_type(char_info):\n\tif char_info[0] == '1':\n\t\treturn None\n\telif char_info.isdigit():\n\t\treturn int(char_int(char_code(char_good_info)) + char_info)\n\telse:\n\t\traise ValueError", "score": 0.0, "codebleu": 0.09351480813665147, "crystalbleu": 0, "codebertscore": 0.7, "codescore": 0.020150458440184593, "surfaceSim": 0.42777777777777776, "abs_surfaceSim_minus_score": 0.42777777777777776, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_2_23", "golden_code": "def min_Num(arr,n):  \r\n    odd = 0\r\n    for i in range(n): \r\n        if (arr[i] % 2): \r\n            odd += 1 \r\n    if (odd % 2): \r\n        return 1\r\n    return 2", "generated_code": "def min_Num(arr: list, n: int) -> int:\n\treturn sum(arr[:n])", "score": 0.0, "codebleu": 0.10841289114550494, "crystalbleu": 0, "codebertscore": 0.75, "codescore": 0.06686840206384659, "surfaceSim": 0.5386645962732919, "abs_surfaceSim_minus_score": 0.5386645962732919, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_extra_p02555_s422627112_OP_1", "golden_code": "S = int(eval(input()))\n\n\n\ndp = [0] * (S + 1)\n\ndp[0] = 1\n\nM = 10 ** 9 + 7\n\n\n\nfor i in range(1, S + 1):\n\n    num = 0\n\n    for j in range(i - 2):\n\n        num += dp[j]\n\n        dp[i] = num % M\n\n\n\nprint((dp[S]))\n\n\n", "generated_code": "S = int(eval(input()))\n\n\n\n\n\ndef cmb(n, r, p):\n\n    r = min(n - r, r)\n\n    if r == 0:\n\n        return 1\n\n    over = 1\n\n    for i in range(n, n - r, -1):\n\n        over = over * i % p\n\n    under = 1\n\n    for i in range(1, r + 1):\n\n        under = under * i % p\n\n    inv = pow(under, p - 2, p)\n\n    return over * inv % p\n\n\n\n\n\nM = 10 ** 9 + 7\n\nans = 0\n\nfor i in range(1, S):\n\n    if S - 3 * i < 0:\n\n        break\n\n    ans += cmb(S - 3 * i + i - 1, i - 1, M)\n\n    ans %= M\n\nprint(ans)\n", "score": 1.0, "codebleu": 0.3575171735449353, "crystalbleu": 0.18, "codebertscore": 0.81, "codescore": 0.9873600602149963, "surfaceSim": 0.5537230340988171, "abs_surfaceSim_minus_score": 0.44627696590118293, "source": "local", "local_type": "OP"}
{"id": "LOCAL_HE_120_OP_1", "golden_code": "def maximum(arr, k):\n    if k == 0:\n        return []\n    arr.sort()\n    ans = arr[-k:]\n    return ans", "generated_code": "def maximum(data_list, num_max):\n    if num_max == 0:\n        return []\n    if num_max >= len(data_list):\n        return sorted(data_list, reverse=True)\n    return sorted(data_list)[-num_max:]", "score": 0.9747, "codebleu": 0.415793580537232, "crystalbleu": 0, "codebertscore": 0.82, "codescore": 0.929449200630188, "surfaceSim": 0.6117527173913043, "abs_surfaceSim_minus_score": 0.3629472826086957, "source": "local", "local_type": "OP"}
{"id": "LOCAL_MBPP_846_OP_1", "golden_code": "def find_platform(arr, dep, n): \r\n    arr.sort() \r\n    dep.sort() \r\n    plat_needed = 1\r\n    result = 1\r\n    i = 1\r\n    j = 0\r\n    while (i < n and j < n): \r\n        if (arr[i] <= dep[j]):           \r\n            plat_needed+= 1\r\n            i+= 1\r\n        elif (arr[i] > dep[j]):           \r\n            plat_needed-= 1\r\n            j+= 1\r\n        if (plat_needed > result):  \r\n            result = plat_needed           \r\n    return result", "generated_code": "def find_platform(arrival, departure, count):\n    arrival.sort()\n    departure.sort()\n    max_platforms = current_platforms = i = j = 0\n    while i < count:\n        if arrival[i] <= departure[j]:\n            current_platforms += 1\n            max_platforms = max(max_platforms, current_platforms)\n            i += 1\n        else:\n            current_platforms -= 1\n            j += 1\n    return max_platforms", "score": 1.0, "codebleu": 0.2750009343128258, "crystalbleu": 0, "codebertscore": 0.77, "codescore": 0.9939494132995605, "surfaceSim": 0.7472963544392115, "abs_surfaceSim_minus_score": 0.2527036455607885, "source": "local", "local_type": "OP"}
{"id": "MBPP_32_1", "golden_code": "from collections import Counter\r\ndef add_dict(d1,d2):\r\n   add_dict = Counter(d1) + Counter(d2)\r\n   return add_dict", "generated_code": "from collections import Counter\ndef add_dict(d1: dict, d2: dict):\n\tfor k, v1 in d1.items():\n\t\td1[k] = v1 + d2[k]\n\treturn d1", "score": 0.0445, "codebleu": 0.42425030668628383, "crystalbleu": 0, "codebertscore": 0.87, "codescore": 0.07286370545625687, "surfaceSim": 0.6814291827128798, "abs_surfaceSim_minus_score": 0.6369291827128798, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_149_OP_1", "golden_code": "def sorted_list_sum(lst):\n    lst.sort()\n    new_lst = []\n    for i in lst:\n        if len(i)%2 == 0:\n            new_lst.append(i)\n    return sorted(new_lst, key=len)", "generated_code": "def sorted_list_sum(collection):\n    even_length_items = filter(lambda x: len(x) % 2 == 0, collection)\n    return sorted(even_length_items, key=len)", "score": 1.0, "codebleu": 0.18422574035144818, "crystalbleu": 0, "codebertscore": 0.82, "codescore": 0.21905617415905, "surfaceSim": 0.6540555253130104, "abs_surfaceSim_minus_score": 0.34594447468698963, "source": "local", "local_type": "OP"}
{"id": "LOCAL_APPS_3723_2_MUT_1", "golden_code": "import functools\n\n\n@functools.lru_cache(maxsize=10000)\ndef factor(n):res = []\n    d = 2\n    while d * d <= n:\n        if n % d == 0:\n            res.append(d)\n            n //= d\n        else:\n            d += 1\n    if n > 1:\n        res.append(n)\n    return set(res)\n\nnum = int(input())\n\npoks = list(map(int, input().split()))[:num]\n\nc = dict()\nfor p in poks:\n    for d in factor(p):\n        if d in c.keys():\n            c[d] += 1\n        else:\n            c[d] = 1\n\nif c:\n    print(max(c.values()))\nelse:\n    print(1)", "generated_code": "import functools\n\n\n@functools.lru_cache(maxsize=10000)\ndef factor(n):res = []\n    d = 2\n    while d / d <= n:\n        if n % d == 0:\n            res.append(d)\n            n //= d\n        else:\n            d += 1\n    if n > 1:\n        res.append(n)\n    return set(res)\n\nnum = int(input())\n\npoks = list(map(int, input().split()))[:num]\n\nc = dict()\nfor p in poks:\n    for d in factor(p):\n        if d in c.keys():\n            c[d] += 1\n        else:\n            c[d] = 1\n\nif c:\n    print(max(c.values()))\nelse:\n    print(1)", "score": 0.0, "codebleu": 0.9821710410991258, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.9938104748725891, "surfaceSim": 0.49903846153846154, "abs_surfaceSim_minus_score": 0.49903846153846154, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_APPS_1073_23_MUT_11", "golden_code": "n = int(input())\nch = str(input())\nr = 0\na = 0\nb = 0\nT = [[0, 0]]\nfor k in range(n):\n    if ch[k] == 'U':\n        a += 1\n    elif ch[k] == 'D':\n        a -= 1\n    elif ch[k] == 'R':\n        b += 1\n    else:\n        b -= 1\n    T += [[a, b]]\n\nfor i in range(1, n + 1):\n    for j in range(i):\n        if T[j] == T[i]:\n            r += 1\n\nprint(r)", "generated_code": "n = int(input())\nch = str(input())\nr = 0\na = 0\nb = 0\nT = [[0, 0]]\nfor k in range(n):\n    if ch[k] == 'U':\n        a += 1\n    elif ch[k] == 'D':\n        a -= 1\n    elif ch[k] == 'R':\n        b += 1\n    else:\n        b -= 1\n    T += [[a, b]]\n\nfor i in range(1, n + 1):\n    for j in range(i):\n        if not (T[j] == T[i]):\n            r += 1\n\nprint(r)", "score": 0.0, "codebleu": 0.9464007170150986, "crystalbleu": 0.93, "codebertscore": 1.0, "codescore": 0.9936814308166504, "surfaceSim": 0.9452176285987175, "abs_surfaceSim_minus_score": 0.9452176285987175, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_HE_37_MUT_19", "golden_code": "import os\n\ndef sort_even(l: list):\n    evens = l[::2]\n    odds = l[1::2]\n    evens.sort()\n    ans = []\n    for (e, o) in zip(evens, odds):\n        ans.extend([e, o])\n    if len(evens) > len(odds):\n        ans.append(evens[-1])\n    return ans", "generated_code": "import os\n\ndef sort_even(l: list):\n    evens = l[:]\n    odds = l[1::2]\n    evens.sort()\n    ans = []\n    for (e, o) in zip(evens, odds):\n        ans.extend([e, o])\n    if len(evens) > len(odds):\n        ans.append(evens[-1])\n    return ans", "score": 0.4717, "codebleu": 0.8222749376972637, "crystalbleu": 0.95, "codebertscore": 1.0, "codescore": 0.9937041401863098, "surfaceSim": 0.995850622406639, "abs_surfaceSim_minus_score": 0.524150622406639, "source": "local", "local_type": "MUT"}
{"id": "MBPP_18_32", "golden_code": "def is_Isomorphic(str1,str2):          \r\n    dict_str1 = {}\r\n    dict_str2 = {}\r\n    for i, value in enumerate(str1):\r\n        dict_str1[value] = dict_str1.get(value,[]) + [i]        \r\n    for j, value in enumerate(str2):\r\n        dict_str2[value] = dict_str2.get(value,[]) + [j]\r\n    if sorted(dict_str1.values()) == sorted(dict_str2.values()):\r\n        return True\r\n    else:\r\n        return False", "generated_code": "def is_Isomorphic(a, b):\n\tif len(a)!= len(b):\n\t\treturn False\n\tfor i in range(len(a)):\n\t\tif a[i]!= b[i]:\n\t\t\treturn False\n\t\tbreak\n\treturn True", "score": 0.9322, "codebleu": 0.12966211331181537, "crystalbleu": 0, "codebertscore": 0.72, "codescore": 0.9348564147949219, "surfaceSim": 0.5305764411027569, "abs_surfaceSim_minus_score": 0.4016235588972431, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_42_MUT_1", "golden_code": "import os\n\ndef incr_list(l: list):\n    return [e + 1 for e in l]", "generated_code": "import os\n\ndef incr_list(l: list):\n    return [e - 1 for e in l]", "score": 0.0, "codebleu": 0.8829387445537311, "crystalbleu": 0, "codebertscore": 0.99, "codescore": 0.9779350161552429, "surfaceSim": 0.9296875, "abs_surfaceSim_minus_score": 0.9296875, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-0291_49", "golden_code": "a,b=list(map(int,input().split()))\ni=0\nwhile a<=b:\n    a*=3\n    b*=2\n    i+=1\nprint(i)\n", "generated_code": "a,b = list(map(int, input().split()))\nc = 0\nfor i in range(1,1000):\n\tif i*i > a:\n\t\tc += 1\nprint(c)\n", "score": 0.0, "codebleu": 0.3935185185185185, "crystalbleu": 0, "codebertscore": 0.87, "codescore": 0.13059720396995544, "surfaceSim": 0.7085858585858585, "abs_surfaceSim_minus_score": 0.7085858585858585, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_217_1", "golden_code": "def odd_Days(N): \r\n    hund1 = N // 100\r\n    hund4 = N // 400\r\n    leap = N >> 2\r\n    ordd = N - leap \r\n    if (hund1): \r\n        ordd += hund1 \r\n        leap -= hund1 \r\n    if (hund4): \r\n        ordd -= hund4 \r\n        leap += hund4 \r\n    days = ordd + leap * 2\r\n    odd = days % 7\r\n    return odd ", "generated_code": "def odd_Days(N) -> int:\n\treturn N if (N>0) else 0\nh = {}", "score": 0.0, "codebleu": 0.03273369473683336, "crystalbleu": 0, "codebertscore": 0.68, "codescore": 0.09541194140911102, "surfaceSim": 0.48327759197324416, "abs_surfaceSim_minus_score": 0.48327759197324416, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_43_MUT_3", "golden_code": "import os\n\ndef pairs_sum_to_zero(l):\n    for (i, l1) in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False", "generated_code": "import os\n\ndef pairs_sum_to_zero(l):\n    for (i, l1) in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if not (l1 + l[j] == 0):\n                return True\n    return False", "score": 0.2132, "codebleu": 0.8071900704131441, "crystalbleu": 0, "codebertscore": 0.99, "codescore": 0.99349445104599, "surfaceSim": 0.9433638443935927, "abs_surfaceSim_minus_score": 0.7301638443935927, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-0443_104", "golden_code": "def main():\n    input()\n    numbers = list(map(int, input().split()))\n\n\n    if len(numbers) < 2 or (len(numbers) == 2 and numbers[0] == numbers[1]):\n        print(-1)\n        return\n\n    print(1)\n    print(numbers.index(min(numbers)) + 1)\n    \nmain()", "generated_code": "import sys\n\ndef solve():\n\tinput = sys.stdin.readline\n\tfor _ in range(int(input())):\n\t\tn = int(input())\n\t\ta = [int(x) for x in input().split()]\n\t\tif sum(a) < len(a) * a[-1]:\n\t\t\tprint(-1)\n\t\t\tcontinue\n\t\ta.sort()\n\t\tans = [len(a)]\n\t\tmx = a[-1]\n\t\tif mx <= sum(a[:-1]) // 2:\n\t\t\tmx += 1\n\t\tfor i in range(len(a) - 1):\n\t\t\tans.append(mx - a[i])\n\t\tprint(len(ans))\n\t\tprint(*ans)\n\t\t\n\ndef __starting_point():\n\tsolve()\n\n__starting_point()\n", "score": 0.0, "codebleu": 0.2195118680890125, "crystalbleu": 0.07, "codebertscore": 0.74, "codescore": 0.12319931387901306, "surfaceSim": 0.4703582469539916, "abs_surfaceSim_minus_score": 0.4703582469539916, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_p00744_s226218538_MUT_209", "golden_code": "import collections\nimport math\nclass Dinic:\n    class edge:\n        def __init__(self, to, cap, rev):\n            (self.to, self.cap, self.rev) = (to, cap, rev)\n    def __init__(self, V, E, source, sink):\n        self.V = V\n        self.E = [[] for _ in range(V)]\n        for fr in range(V):\n            for (to, cap) in E[fr]:\n                self.E[fr].append(self.edge(to, cap, len(self.E[to])))\n                self.E[to].append(self.edge(fr, 0, len(self.E[fr]) - 1))\n        self.maxflow = self.dinic(source, sink)\n    def dinic(self, source, sink):\n        INF = float('inf')\n        maxflow = 0\n        while True:\n            self.bfs(source)\n            if self.level[sink] < 0:\n                return maxflow\n            self.itr = [0] * self.V\n            while True:\n                flow = self.dfs(source, sink, INF)\n                if flow > 0:\n                    maxflow += flow\n                else:\n                    break\n    def dfs(self, vertex, sink, flow):\n        if vertex == sink:\n            return flow\n        for i in range(self.itr[vertex], len(self.E[vertex])):\n            self.itr[vertex] = i\n            e = self.E[vertex][i]\n            if (e.cap > 0 and self.level[vertex] < self.level[e.to]):\n                d = self.dfs(e.to, sink, min(flow, e.cap))\n                if d > 0:\n                    e.cap -= d\n                    self.E[e.to][e.rev].cap += d\n                    return d\n        return 0\n    def bfs(self, start):\n        que = collections.deque()\n        self.level = [-1] * self.V\n        que.append(start)\n        self.level[start] = 0\n        while que:\n            fr = que.popleft()\n            for e in self.E[fr]:\n                if (e.cap > 0 and self.level[e.to] < 0):\n                    self.level[e.to] = self.level[fr] + 1\n                    que.append(e.to)\nwhile True:\n    (M, N) = list(map(int, input().split()))\n    if (M == 0 and N == 0):\n        break\n    (blue, red) = ([], [])\n    while True:\n        for x in input().split():\n            blue.append(int(x))\n        if len(blue) == M:\n            break\n    while True:\n        for x in input().split():\n            red.append(int(x))\n        if len(red) == N:\n            break\n    V = (M + N) + 2\n    edge = [set() for _ in range(V)]\n    for (i, b) in enumerate(blue):\n        if b != 1:\n            for (j, r) in enumerate(red):\n                if r % b == 0:\n                    edge[i].add((M + j, 1))\n        for j in range(2, int(math.sqrt(b)) + 1):\n            if b % j == 0:\n                for (k, r) in enumerate(red):\n                    if (r % j == 0 or r % (b // j) == 0):\n                        edge[i].add((M + k, 1))\n    for i in range(M):\n        edge[M + N].add((i, 1))\n    for j in range(N):\n        edge[M + j].add(((M + N) + 1, 1))\n    d = Dinic(V, edge, M + N, (M + N) + 1)\n    print(d.maxflow)", "generated_code": "import collections\nimport math\nclass Dinic:\n    class edge:\n        def __init__(self, to, cap, rev):\n            (self.to, self.cap, self.rev) = (to, cap, rev)\n    def __init__(self, V, E, source, sink):\n        self.V = V\n        self.E = [[] for _ in range(V)]\n        for fr in range(V):\n            for (to, cap) in E[fr]:\n                self.E[fr].append(self.edge(to, cap, len(self.E[to])))\n                self.E[to].append(self.edge(fr, 0, len(self.E[fr]) - 1))\n        self.maxflow = self.dinic(source, sink)\n    def dinic(self, source, sink):\n        INF = float('inf')\n        maxflow = 0\n        while True:\n            self.bfs(source)\n            if self.level[sink] < 0:\n                return maxflow\n            self.itr = [0] * self.V\n            while True:\n                flow = self.dfs(source, sink, INF)\n                if flow > 0:\n                    maxflow += flow\n                else:\n                    break\n    def dfs(self, vertex, sink, flow):\n        if vertex == sink:\n            return flow\n        for i in range(self.itr[vertex], len(self.E[vertex])):\n            self.itr[vertex] = i\n            e = self.E[vertex][i]\n            if (e.cap > 0 and self.level[vertex] < self.level[e.to]):\n                d = self.dfs(e.to, sink, min(flow, e.cap))\n                if d > 0:\n                    e.cap -= d\n                    self.E[e.to][e.rev].cap += d\n                    return d\n        return 0\n    def bfs(self, start):\n        que = collections.deque()\n        self.level = [-1] * self.V\n        que.append(start)\n        self.level[start] = 0\n        while que:\n            fr = que.popleft()\n            for e in self.E[fr]:\n                if (e.cap > 0 and self.level[e.to] < 0):\n                    self.level[e.to] = self.level[fr] + 1\n                    que.append(e.to)\nwhile True:\n    (M, N) = list(map(int, input().split()))\n    if (M == 0 and N == 0):\n        break\n    (blue, red) = ([], [])\n    while True:\n        for x in input().split():\n            blue.append(int(x))\n        if len(blue) == M:\n            break\n    while True:\n        for x in input().split():\n            break\n        if len(red) == N:\n            break\n    V = (M + N) + 2\n    edge = [set() for _ in range(V)]\n    for (i, b) in enumerate(blue):\n        if b != 1:\n            for (j, r) in enumerate(red):\n                if r % b == 0:\n                    edge[i].add((M + j, 1))\n        for j in range(2, int(math.sqrt(b)) + 1):\n            if b % j == 0:\n                for (k, r) in enumerate(red):\n                    if (r % j == 0 or r % (b // j) == 0):\n                        edge[i].add((M + k, 1))\n    for i in range(M):\n        edge[M + N].add((i, 1))\n    for j in range(N):\n        edge[M + j].add(((M + N) + 1, 1))\n    d = Dinic(V, edge, M + N, (M + N) + 1)\n    print(d.maxflow)", "score": 0.0, "codebleu": 0.9912879883960847, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9702808856964111, "surfaceSim": 0.997191011235955, "abs_surfaceSim_minus_score": 0.997191011235955, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_HE_136_MUT_5", "golden_code": "import os\n\ndef largest_smallest_integers(lst):\n    \"\"\"\n    Create a function that returns a tuple (a, b), where 'a' is\n    the largest of negative integers, and 'b' is the smallest\n    of positive integers in a list.\n    If there is no negative or positive integers, return them as None.\n\n    Examples:\n    largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([]) == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \"\"\"\n    smallest = list(filter((lambda x: (x < 0)), lst))\n    largest = list(filter((lambda x: (x > 0)), lst))\n    return (max(smallest) if smallest else None, min(largest) if largest else None)", "generated_code": "import os\n\ndef largest_smallest_integers(lst):\n    \"\"\"\n    Create a function that returns a tuple (a, b), where 'a' is\n    the largest of negative integers, and 'b' is the smallest\n    of positive integers in a list.\n    If there is no negative or positive integers, return them as None.\n\n    Examples:\n    largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([]) == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \"\"\"\n    smallest = list(filter((lambda x: (x < 0)), lst))\n    largest = list(filter((lambda x: (x < 0)), lst))\n    return (max(smallest) if smallest else None, min(largest) if largest else None)", "score": 0.0, "codebleu": 0.9861785612647689, "crystalbleu": 0.92, "codebertscore": 1.0, "codescore": 0.9865672588348389, "surfaceSim": 0.9742481203007518, "abs_surfaceSim_minus_score": 0.9742481203007518, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-4202_1", "golden_code": "\ndef main():\n\n    L, R = [int(i) for i in input().split()]\n\n    if (L//2019) < (R//2019):\n        ans = 0\n    else:\n        ans = 10 ** 10\n        for l in range(L, R+1):\n            for r in range(l+1, R+1):\n                ans = min(ans, (l*r)%2019)\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n__starting_point()", "generated_code": "import sys\ninput = sys.stdin.readline\n\ndef main():\n\tmod = 10**9+7\n\tmemo = {}\n\tdef dp(x,y):\n\t\tif (x,y) in memo:\n\t\t\treturn memo[(x,y)]\n\t\tif x > y:\n\t\t\treturn 0\n\t\tif x == y:\n\t\t\tmemo[(x, y)] = A[x]\n\t\t\treturn A[x]\n\n\t\tMOD = 10**9(9)+7\n\t\tmemo[(i,j)] = dp(i,j-1)*(x-y)%MOD\n\t\treturn memo[(i, j)]\n\tA = input().split()\n\tA = [int(i) for i in A]\n\tl,r = A[0],A[1]\n\tif l == r:\n\t\tprint(l)", "score": 0.0, "codebleu": 0.27297471237325105, "crystalbleu": 0.13, "codebertscore": 0.74, "codescore": 0.018560374155640602, "surfaceSim": 0.4752021563342318, "abs_surfaceSim_minus_score": 0.4752021563342318, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_4620_17_MUT_31", "golden_code": "n = int(input())\ngraph = []\ntime = 0\nfor i in range(n - 1):\n    (c, s, f) = map(int, input().split())\n    graph.append([i, c, s, f])\n\ndef shortest_path(start, end, times):\n    if start == end:\n        return times\n    elif times <= graph[start][2]:\n        times = graph[start][2] + graph[start][1]\n        return shortest_path(start + 1, end, times)\n    elif times % graph[start][3] == 0:\n        times += graph[start][1]\n        return shortest_path(start + 1, end, times)\n    else:\n        times = ((times + graph[start][3]) - (times % graph[start][3])) + graph[start][1]\n        return shortest_path(start + 1, end, times)\n\n\nfor i in range(n):\n    print(shortest_path(i, n - 1, 0))", "generated_code": "n = int(input())\ngraph = []\ntime = 0\nfor i in range(n - 1):\n    pass\n    graph.append([i, c, s, f])\n\ndef shortest_path(start, end, times):\n    if start == end:\n        return times\n    elif times <= graph[start][2]:\n        times = graph[start][2] + graph[start][1]\n        return shortest_path(start + 1, end, times)\n    elif times % graph[start][3] == 0:\n        times += graph[start][1]\n        return shortest_path(start + 1, end, times)\n    else:\n        times = ((times + graph[start][3]) - (times % graph[start][3])) + graph[start][1]\n        return shortest_path(start + 1, end, times)\n\n\nfor i in range(n):\n    print(shortest_path(i, n - 1, 0))", "score": 0.041, "codebleu": 0.8449030119964008, "crystalbleu": 0.89, "codebertscore": 0.98, "codescore": 0.9888400435447693, "surfaceSim": 0.9423879040667362, "abs_surfaceSim_minus_score": 0.9013879040667362, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-0442_39", "golden_code": "r = int(input())\n\nif r%2 == 0:\n    print('NO')\n\nelif r == 1:\n    print('NO')\n\nelif r == 3:\n    print('NO')\nelse:\n    print(1, end=' ')\n    print((r-3)//2)", "generated_code": "import math\n\nr = int(input())\nx = 0\ny = 0\nfor i in range(1, r+1):\n\tif i * i == r:\n\t\tprint(i, end ='')\n\t\tbreak\n\tx += 1\n\ty += 1\n\tif x == y:\n\t\tprint('NO')\n\t\tbreak\n\nif x == 0:\n\tprint('YES')\n\tprint(y)\n", "score": 0.3128, "codebleu": 0.34370386185919943, "crystalbleu": 0, "codebertscore": 0.8, "codescore": 0.06754536926746368, "surfaceSim": 0.5581188997338065, "abs_surfaceSim_minus_score": 0.24531889973380644, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0460_3", "golden_code": "p, x, y = list(map(int, input().split()))\nmn = [10 ** 10]\ndef tr(a):\n    i = (a // 50) % 475\n    for j in range(25):\n        i = (i * 96 + 42) % 475\n        l = 26 + i\n        if l == p:\n            if a <= x:\n                mn[0] = min(mn[0], 0)\n            else:\n                k = (a - x) // 50\n                if k % 2 == 0:\n                    mn[0] = min(mn[0], k // 2)\n                else:\n                    mn[0] = min(mn[0], (k + 1) // 2)\n            \n            \nst = 0   \nfor i in range(50):\n    if (x) % 50 == (y + i) % 50:\n        st = y + i\n        break\nfor i in range(st, 5 * 100000, 50):\n    tr(i)\nprint(*mn)\n", "generated_code": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"\nCreated on200weishu\n\n@author: reduce full\n\"\"\"\n#from collections import Counter\n#import numpy as np\n#arr = np.array([[int(i) for i in input().split()] for k in range(2)])\n#a = arr[0][0]\n#b = arr[0]\n#print(a,b)\n\np,x,y = list(map(int,input().split()))\n#a = int(input())\n#b = int(input()[0])\n\n#a = 3\n#b = 4\n\n#0,1,2,3,4 = 1,2,3,-4,5\n#0,0,0,1,1\n#\n#for i in range(", "score": 0.0, "codebleu": 0.05945678573139562, "crystalbleu": 0.0, "codebertscore": 0.7, "codescore": 0.018333302810788155, "surfaceSim": 0.43407172995780585, "abs_surfaceSim_minus_score": 0.43407172995780585, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_p02574_s911286307_MUT_29", "golden_code": "import math, sys\nn = int(sys.stdin.readline())\na = tuple(map(int, sys.stdin.readline().split()))\ng = math.gcd(a[0], a[1])\nfor i in range(2, n):\n    g = math.gcd(g, a[i])\nM = max(a)\nacc = a[0]\nfor i in range(n):\n    acc = math.gcd(acc, a[i])\nif acc != 1:\n    print('not coprime')\n    exit()\nLIMIT = max(a)\nminPrime = [0] * (LIMIT + 1)\nminPrime[1] = 1\ndef make():\n    for i in range(2, LIMIT + 1):\n        if minPrime[i] == 0:\n            minPrime[i] = i\n            for j in range(i + i, LIMIT + 1, i):\n                if minPrime[j] == 0:\n                    minPrime[j] = i\nmake()\ndef factrial(N):\n    ret = []\n    while minPrime[N] != N:\n        ret.append(minPrime[N])\n        N = N // minPrime[N]\n    if N != 1:\n        ret.append(N)\n    return ret\njudge = set([])\npc = True\npairwise = True\np = set()\nfor e in a:\n    if not pairwise:\n        break\n    asf = set(factrial(e))\n    if judge & asf != set():\n        pc = False\n    judge |= asf\nif pc:\n    print('pairwise coprime')\nelif g == 1:\n    print('setwise coprime')\nelse:\n    print('not coprime')", "generated_code": "import math, sys\nn = int(sys.stdin.readline())\na = tuple(map(int, sys.stdin.readline().split()))\ng = math.gcd(a[0], a[1])\nfor i in range(2, n):\n    g = math.gcd(g, a[i])\nM = max(a)\nacc = a[0]\nfor i in range(n):\n    acc = math.gcd(acc, a[i])\nif acc != 1:\n    print('not coprime')\n    exit()\nLIMIT = max(a)\nminPrime = [0] * (LIMIT + 1)\nminPrime[1] = 1\ndef make():\n    for i in range(2, LIMIT + 1):\n        if minPrime[i] == 0:\n            minPrime[i] = i\n            for j in range(i + i, LIMIT + 1, i):\n                if minPrime[j] == 0:\n                    minPrime[j] = i\nmake()\ndef factrial(N):\n    ret = []\n    while minPrime[N] != N:\n        ret.append(minPrime[N])\n        N = N // minPrime[N]\n        break\n    if N != 1:\n        ret.append(N)\n    return ret\njudge = set([])\npc = True\npairwise = True\np = set()\nfor e in a:\n    if not pairwise:\n        break\n    asf = set(factrial(e))\n    if judge & asf != set():\n        pc = False\n    judge |= asf\nif pc:\n    print('pairwise coprime')elif g == 1:\n    print('setwise coprime')\nelse:\n    print('not coprime')", "score": 0.0, "codebleu": 0.966981750105428, "crystalbleu": 0.99, "codebertscore": 0.99, "codescore": 0.9937176704406738, "surfaceSim": 0.49671669793621015, "abs_surfaceSim_minus_score": 0.49671669793621015, "source": "local", "local_type": "MUT"}
{"id": "MBPP_7_42", "golden_code": "def check_subset(list1,list2): \r\n    return all(map(list1.__contains__,list2)) ", "generated_code": "def check_subset(args, str): \n  \n\tfor index in range(1, len(str)):\n\t\ttry:\n\t\t\tif str[index]!= str[index-1]:\n\t\t\t\treturn False\n\t\texcept:\n\t\t\tpass\n\t\telse:\n\t\t\tcontinue\n\treturn (True if str == str else False)", "score": 0.8309, "codebleu": 0.24179996753635905, "crystalbleu": 0, "codebertscore": 0.72, "codescore": 0.9384756684303284, "surfaceSim": 0.3739303482587065, "abs_surfaceSim_minus_score": 0.45696965174129345, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_p02680_s341076610_MUT_16", "golden_code": "import sys\n(n, m, *abcdef) = list(map(int, sys.stdin.buffer.read().split()))\nver_lines = []\nhor_lines = []\nx_list = set()\ny_list = set()\nn3 = n * 3\nfor (a, b, c) in zip(abcdef[0:n3:3], abcdef[1:n3:3], abcdef[2:n3:3]):\n    y_list.add(a)\n    y_list.add(b)\n    x_list.add(c)\n    ver_lines.append((a, b, c))\nfor (d, e, f) in zip(abcdef[n3 + 0::3], abcdef[n3 + 1::3], abcdef[n3 + 2::3]):\n    y_list.add(d)\n    x_list.add(e)\n    x_list.add(f)\n    hor_lines.append((d, e, f))\nx_list.add(0)\ny_list.add(0)\nx_list = sorted(x_list)\ny_list = sorted(y_list)\nx_dict = {x: i for (i, x) in enumerate(x_list, start=1)}\ny_dict = {y: i for (i, y) in enumerate(y_list, start=1)}\nrow_real = len(x_list)\ncol_real = len(y_list)\nrow = row_real + 2\ncol = col_real + 2\nbanned_up_ij = [[0] * row for _ in range(col)]\nbanned_down_ij = [[0] * row for _ in range(col)]\nbanned_left_ij = [[0] * col for _ in range(row)]\nbanned_right_ij = [[0] * col for _ in range(row)]\nfor (a, b, c) in ver_lines:\n    if a > b:\n        (a, b) = (b, a)\n    ai = y_dict[a]\n    bi = y_dict[b]\n    j = x_dict[c]\n    banned_left_ij[j][ai] += 1\n    banned_left_ij[j][bi] -= 1\n    banned_right_ij[j - 1][ai] += 1\n    banned_right_ij[j - 1][bi] -= 1\nfor (d, e, f) in hor_lines:\n    if e > f:\n        (e, f) = (f, e)\n    i = y_dict[d]\n    ej = x_dict[e]\n    fj = x_dict[f]\n    banned_up_ij[i][ej] += 1\n    banned_up_ij[i][fj] -= 1\n    banned_down_ij[i - 1][ej] += 1\n    banned_down_ij[i - 1][fj] -= 1\nbanned_up = [0] * (row * col)\nbanned_down = [0] * (row * col)\nbanned_left = [0] * (row * col)\nbanned_right = [0] * (row * col)\nfor i in range(col):\n    ru = banned_up_ij[i]\n    rd = banned_down_ij[i]\n    ri = row * i\n    banned_up[ri] = ru[0]\n    banned_down[ri] = rd[0]\n    for j in range(1, row):\n        banned_up[ri + j] = banned_up[(ri + j) - 1] + ru[j]\n        banned_down[ri + j] = banned_down[(ri + j) - 1] + rd[j]\nfor j in range(row):\n    rl = banned_left_ij[j]\n    rr = banned_right_ij[j]\n    banned_left[j] = rl[0]\n    banned_right[j] = rr[0]\n    for i in range(1, col):\n        ri0 = (i - 1) * row\n        ri1 = i * row\n        banned_left[ri1 + j] = banned_left[ri0 + j] + rl[i]\n        banned_right[ri1 + j] = banned_right[ri0 + j] + rr[i]\ns = (row * y_dict[0]) + x_dict[0]\nenable = (([-1] * row) + ((([-1] + ([0] * (row - 2))) + [-1]) * (col - 2))) + ([-1] * row)\nq = [s]\nmoves = [(-row, banned_up), (-1, banned_left), (1, banned_right), (row, banned_down)]\nwhile q:\n    c = q.pop()\n    if enable[c] == 1:\n        continue\n    elif enable[c] == -1:\n        print('INF')\n        exit()\n    enable[c] = 1\n    for (dc, banned) in moves:\n        if banned[c]:\n            continue\n        nc = c + dc\n        if enable[nc] == 1:\n            continue\n        q.append(nc)\nans = 0\nfor i in range(col):\n    ri = i * row\n    for j in range(row):\n        if enable[ri + j] != 1:\n            continue\n        t = y_list[i - 1]\n        b = y_list[i]\n        l = x_list[j - 1]\n        r = x_list[j]\n        ans += (b - t) * (r - l)\nprint(ans)", "generated_code": "import sys\n(n, m, *abcdef) = list(map(int, sys.stdin.buffer.read().split()))\nver_lines = []\nhor_lines = []\nx_list = set()\ny_list = set()\nn3 = n * 3\nfor (a, b, c) in zip(abcdef[0:n3:3], abcdef[1:n3:3], abcdef[2:n3:3]):\n    y_list.add(a)\n    y_list.add(b)\n    x_list.add(c)\n    ver_lines.append((a, b, c))\nfor (d, e, f) in zip(abcdef[n3 + 0::3], abcdef[n3 + 1::3], abcdef[n3 + 2::3]):\n    y_list.add(d)\n    x_list.add(e)\n    x_list.add(f)\n    hor_lines.append((d, e, f))\nx_list.add(0)\ny_list.add(0)\nx_list = sorted(x_list)\ny_list = sorted(y_list)\nx_dict = {x: i for (i, x) in enumerate(x_list, start=1)}\ny_dict = {y: i for (i, y) in enumerate(y_list, start=1)}\nrow_real = len(x_list)\ncol_real = len(y_list)\nrow = row_real + 2\ncol = col_real + 2\nbanned_up_ij = [[0] / row for _ in range(col)]\nbanned_down_ij = [[0] * row for _ in range(col)]\nbanned_left_ij = [[0] * col for _ in range(row)]\nbanned_right_ij = [[0] * col for _ in range(row)]\nfor (a, b, c) in ver_lines:\n    if a > b:\n        (a, b) = (b, a)\n    ai = y_dict[a]\n    bi = y_dict[b]\n    j = x_dict[c]\n    banned_left_ij[j][ai] += 1\n    banned_left_ij[j][bi] -= 1\n    banned_right_ij[j - 1][ai] += 1\n    banned_right_ij[j - 1][bi] -= 1\nfor (d, e, f) in hor_lines:\n    if e > f:\n        (e, f) = (f, e)\n    i = y_dict[d]\n    ej = x_dict[e]\n    fj = x_dict[f]\n    banned_up_ij[i][ej] += 1\n    banned_up_ij[i][fj] -= 1\n    banned_down_ij[i - 1][ej] += 1\n    banned_down_ij[i - 1][fj] -= 1\nbanned_up = [0] * (row * col)\nbanned_down = [0] * (row * col)\nbanned_left = [0] * (row * col)\nbanned_right = [0] * (row * col)\nfor i in range(col):\n    ru = banned_up_ij[i]\n    rd = banned_down_ij[i]\n    ri = row * i\n    banned_up[ri] = ru[0]\n    banned_down[ri] = rd[0]\n    for j in range(1, row):\n        banned_up[ri + j] = banned_up[(ri + j) - 1] + ru[j]\n        banned_down[ri + j] = banned_down[(ri + j) - 1] + rd[j]\nfor j in range(row):\n    rl = banned_left_ij[j]\n    rr = banned_right_ij[j]\n    banned_left[j] = rl[0]\n    banned_right[j] = rr[0]\n    for i in range(1, col):\n        ri0 = (i - 1) * row\n        ri1 = i * row\n        banned_left[ri1 + j] = banned_left[ri0 + j] + rl[i]\n        banned_right[ri1 + j] = banned_right[ri0 + j] + rr[i]\ns = (row * y_dict[0]) + x_dict[0]\nenable = (([-1] * row) + ((([-1] + ([0] * (row - 2))) + [-1]) * (col - 2))) + ([-1] * row)\nq = [s]\nmoves = [(-row, banned_up), (-1, banned_left), (1, banned_right), (row, banned_down)]\nwhile q:\n    c = q.pop()\n    if enable[c] == 1:\n        continue\n    elif enable[c] == -1:\n        print('INF')\n        exit()\n    enable[c] = 1\n    for (dc, banned) in moves:\n        if banned[c]:\n            continue\n        nc = c + dc\n        if enable[nc] == 1:\n            continue\n        q.append(nc)\nans = 0\nfor i in range(col):\n    ri = i * row\n    for j in range(row):\n        if enable[ri + j] != 1:\n            continue\n        t = y_list[i - 1]\n        b = y_list[i]\n        l = x_list[j - 1]\n        r = x_list[j]\n        ans += (b - t) * (r - l)\nprint(ans)", "score": 0.0, "codebleu": 0.9973984967720897, "crystalbleu": 1.0, "codebertscore": 1.0, "codescore": 0.9524854421615601, "surfaceSim": 0.9863192064597217, "abs_surfaceSim_minus_score": 0.9863192064597217, "source": "local", "local_type": "MUT"}
{"id": "MBPP_40_30", "golden_code": "import datetime\r\ndef check_date(m, d, y):\r\n    try:\r\n        m, d, y = map(int, (m, d, y))\r\n        datetime.date(y, m, d)\r\n        return True\r\n    except ValueError:\r\n        return False", "generated_code": "import datetime\ndef check_date(m, d, y):\n\tif m and d and y and m >= m + d:\n\t\treturn True\n\treturn False\nh = lambda: hex(int(input()))\ng = lambda: input()\nk = lambda: list(map(chr, range(ord(input()), 256)))", "score": 0.7767, "codebleu": 0.3219176508813355, "crystalbleu": 0, "codebertscore": 0.8, "codescore": 0.5801955461502075, "surfaceSim": 0.4695121951219512, "abs_surfaceSim_minus_score": 0.30718780487804875, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_56_22", "golden_code": "def series_sum(number):\r\n total = 0\r\n total = (number * (number + 1) * (2 * number + 1)) / 6\r\n return total", "generated_code": "def series_sum(number):\n\treturn sum(range(number+1))", "score": 0.245, "codebleu": 0.0764755441970511, "crystalbleu": 0, "codebertscore": 0.84, "codescore": 0.03342585638165474, "surfaceSim": 0.632398753894081, "abs_surfaceSim_minus_score": 0.38739875389408096, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_extra_p03416_s018952102_OP_1", "golden_code": "A,B = list(map(int,input().split()))\n\nj = 0\n\nfor i in range(A,B+1):\n\n  l = list(str(i))\n\n  l_reverse = list(reversed(l))\n\n  if l == l_reverse:\n\n    j += 1\n\nprint(j)", "generated_code": "A, B = list(map(int,input().split()))\n\n\n\nans = 0\n\nfor n in range(A, B+1):\n\n    n = str(n)\n\n    if n == n[::-1]:\n\n        ans += 1\n\nprint(ans)", "score": 1.0, "codebleu": 0.37832943406915276, "crystalbleu": 0, "codebertscore": 0.89, "codescore": 0.8833091855049133, "surfaceSim": 0.7340301974448316, "abs_surfaceSim_minus_score": 0.26596980255516844, "source": "local", "local_type": "OP"}
{"id": "LOCAL_PIE_extra_p03796_s477602976_OP_1", "golden_code": "import math\n\nn=int(eval(input()))\n\nprint((math.factorial(n)%(10**9+7)))", "generated_code": "N=int(eval(input()))\n\ndef fact(n):\n\n    val=1\n\n    for i in range(2,n+1):\n\n        val*=i\n\n        val%=1000000007\n\n    return val\n\nprint((fact(N)))", "score": 1.0, "codebleu": 0.24512987012987014, "crystalbleu": 0, "codebertscore": 0.79, "codescore": 0.14915773272514343, "surfaceSim": 0.46959459459459457, "abs_surfaceSim_minus_score": 0.5304054054054055, "source": "local", "local_type": "OP"}
{"id": "LOCAL_APPS_4496_54_MUT_11", "golden_code": "a = int(input())\nif a == 22:\n    print('Christmas Eve Eve Eve')\nelif a == 23:\n    print('Christmas Eve Eve')\nelif a == 24:\n    print('Christmas Eve')\nelse:\n    print('Christmas')", "generated_code": "pass\nif a == 22:\n    print('Christmas Eve Eve Eve')\nelif a == 23:\n    print('Christmas Eve Eve')\nelif a == 24:\n    print('Christmas Eve')\nelse:\n    print('Christmas')", "score": 0.0, "codebleu": 0.8898355308576837, "crystalbleu": 0, "codebertscore": 0.96, "codescore": 0.9937905669212341, "surfaceSim": 0.8384831460674158, "abs_surfaceSim_minus_score": 0.8384831460674158, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-2676_18", "golden_code": "t=int(input())\nd=[]\ncount=0\nfor i in range(0,t):\n f=input()\n d.append(f)\nd=list(set(d))\ny=int(input())\nr=input()\nfor l in range(0,len(d)):\n if d[l] in r:\n  count+=1\nprint(count)\n \n", "generated_code": "# cook your dish here\nfrom sys import stdin, stdout\nimport math\nfrom math import gcd,sqrt,ceil,floor,inf\nfrom collections import defaultdict,Counter\nfrom bisect import bisect_left,bisect_right\nimport functools\nimport sys\nimport random\nfrom copy import deepcopy\ninp = lambda : int(x)\ndef L(): return list(map(int,sys.stdin.readline().split()))\ndef In(): return list(sys.stdin)\ndef I(): return int(sys.stdio.readline())\ndef print_list(l): sys.stdout.write(' '.join(map(str,l))+'\\n')\ndef print_int(): sys.stdout.write(str(int(sys.stdout.readline()))+'\\ n')\ndef print3(): return sys.std", "score": 0.0046, "codebleu": 0.14025974025974025, "crystalbleu": 0, "codebertscore": 0.64, "codescore": 0.02810867689549923, "surfaceSim": 0.3217831233295151, "abs_surfaceSim_minus_score": 0.3171831233295151, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_95_OP_1", "golden_code": "def check_dict_case(dict):\n    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                break\n        return state == \"upper\" or state == \"lower\"", "generated_code": "def check_dict_case(input_dict):\n    if not input_dict:\n        return False\n    keys_upper = all(isinstance(k, str) and k.isupper() for k in input_dict.keys())\n    if keys_upper:\n        return True\n    keys_lower = all(isinstance(k, str) and k.islower() for k in input_dict.keys())\n    return keys_lower", "score": 1.0, "codebleu": 0.13487188118943239, "crystalbleu": 0.05, "codebertscore": 0.78, "codescore": 0.9250084161758423, "surfaceSim": 0.6766804788213627, "abs_surfaceSim_minus_score": 0.32331952117863727, "source": "local", "local_type": "OP"}
{"id": "APPS_test-1290_1", "golden_code": "n, m = [int(i) for i in input().split()]\na = [0] * (n + 1)\nb = [int(i) for i in input().split()]\nfor i in b:\n    a[i] += 1\nprint(min(a[1:n+1]))\n", "generated_code": "import sys\nfrom collections import deque\ninput = sys.stdin.readline\n\nn,m=list(map(int,input().split()))\narray=list(map (int,input().strip().split()))[:n]\nL=[]\nfor i in range(n):\n\tL.append((array[i],i))\nL.sort(reverse=True)\nL.append((0,0))\n\nis_row=True\nfor i in L:\n\tif i[1]==n-1:\n\t\tis_row=False\n\t\tbreak\n\telse:\n\t\tarray[i[1]]=0\n\nif is_row:\n\tprint(n*(n+1)//2-1)\nelse:\n\tprint((n-1)*(n**2+n-1)//2)\n\n", "score": 0.0, "codebleu": 0.22064854317756372, "crystalbleu": 0.05, "codebertscore": 0.76, "codescore": 0.07404199242591858, "surfaceSim": 0.42119910941475824, "abs_surfaceSim_minus_score": 0.42119910941475824, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_68_OP_1", "golden_code": "def pluck(arr):\n    if(len(arr) == 0): return []\n    evens = list(filter(lambda x: x%2 == 0, arr))\n    if(evens == []): return []\n    return [min(evens), arr.index(min(evens))]", "generated_code": "def pluck(data):\n    if not data: \n        return []\n    minimum_even = float('inf')\n    index_of_minimum = -1\n    for idx, value in enumerate(data):\n        if value % 2 == 0:\n            if value < minimum_even:\n                minimum_even = value\n                index_of_minimum = idx\n    if index_of_minimum == -1:\n        return []\n    return [minimum_even, index_of_minimum]", "score": 1.0, "codebleu": 0.2573409040536579, "crystalbleu": 0, "codebertscore": 0.75, "codescore": 0.9348821640014648, "surfaceSim": 0.5978534031413614, "abs_surfaceSim_minus_score": 0.4021465968586386, "source": "local", "local_type": "OP"}
{"id": "APPS_test-1770_26", "golden_code": "def mi():\n\treturn list(map(int, input().split()))\n'''\n3\n10 4 5 2\n5 1 3 4\n20 4 19 3\n'''\nimport math\nfor _ in range(int(input())):\n\tn,x,y,d = mi()\n\tif abs(x-y)%d==0:\n\t\tprint(abs(x-y)//d)\n\telse:\n\t\tans1 = math.ceil((x-1)/d)\n\t\tans2 = math.ceil((n-x)/d)\n\t\tif abs(y-1)%d==0:\n\t\t\tans1 += (y-1)//d\n\t\telse:\n\t\t\tans1 = 1e19\n\t\tif abs(n-y)%d==0:\n\t\t\tans2 += (n-y)//d\n\t\telse:\n\t\t\tans2 = 1e19\n\t\tif min(ans1, ans2)==1e19:\n\t\t\tprint(-1)\n\t\telse:\n\t\t\tprint(min(ans1, ans2))\n", "generated_code": "t = int(input())\nfor _ in range(t):\n\tn, x, y, d = list(map(int, input().split()))\n\tif x > y:\n\t\tprint(-1)\n\telse:\n\t\tans = 0\n\t\tpages = d * (n - x)\n\t\tans += (y - x) // d\n\t\trem = y % d\n\t\tprev = d * (x - 1)\n\t\tprev -= rem\n\t\tans += prev // d\n\t\tprint(ans)\n", "score": 0.7522, "codebleu": 0.19081531364869686, "crystalbleu": 0.18, "codebertscore": 0.79, "codescore": 0.3375172019004822, "surfaceSim": 0.548218262806236, "abs_surfaceSim_minus_score": 0.203981737193764, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_43_45", "golden_code": "def is_Two_Alter(s):  \r\n    for i in range (len( s) - 2) : \r\n        if (s[i] != s[i + 2]) : \r\n            return False\r\n    if (s[0] == s[1]): \r\n        return False\r\n    return True", "generated_code": "def is_Two_Alter(s):\n   return s.isnumeric() and not s.isupper()", "score": 0.8206, "codebleu": 0.0770156977183258, "crystalbleu": 0, "codebertscore": 0.74, "codescore": 0.9667512774467468, "surfaceSim": 0.4523497267759563, "abs_surfaceSim_minus_score": 0.3682502732240437, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-1083_58", "golden_code": "n = int(input())\ns = sum([i for i in range(n + 1)])\nprint(s % 2)\nans = []\nq = s // 2\nfor i in range(n - 1, 0, -1):\n    if q >= i:\n        ans = [i] + ans\n        q -= i\nprint(len(ans), *ans)", "generated_code": "n = int(input())\na = list(range(1, n + 1))\nans = []\nfor i in range(n // 2):\n\tl = max(a)\n\ta.remove(l)\n\tb = max(a,)\n\tans.append(str(abs(sum(a) - sum(b))))\n\ta = b\nprint(len(ans))\nprint(' '.join(ans))\n", "score": 0.0, "codebleu": 0.24713662275576093, "crystalbleu": 0.19, "codebertscore": 0.83, "codescore": 0.09393832087516785, "surfaceSim": 0.4982741116751269, "abs_surfaceSim_minus_score": 0.4982741116751269, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0009_6", "golden_code": "import sys\ntry:\n    fin=open('in')\nexcept:\n    fin=sys.stdin\ninput=fin.readline\n\nd = int(input())\nn, m = map(int, input().split())\nx1, y1, x2, y2 = [], [], [], []\nT=[]\nfor _ in range(d):\n    u, v, w, x = map(int, input().split())\n    if u>w:u,w=w,u\n    if v>x:v,x=x,v\n    x1.append(u)\n    y1.append(v)\n    x2.append(-w)#the other direction pog?\n    y2.append(-x)\n    T.append([u,v,w,x])\n\nx1.sort()\nx2.sort()\ny1.sort()\ny2.sort()\n\nreq=list(map(int,input().split())) # x1,x2,y1,y2\nimport bisect\nfor i in range(len(T)):\n    # binary search\n    u,v,w,x=T[i]\n    if req[0]==bisect.bisect_left(x1,w)-(u!=w):\n        if req[1]==bisect.bisect_left(x2,-u)-(u!=w):\n            if req[2]==bisect.bisect_left(y1,x)-(v!=x):\n                if req[3]==bisect.bisect_left(y2,-v)-(v!=x):\n                    print(i+1)\n                    break\nelse:\n    print(-1)", "generated_code": "def main():\n\td = int(input())\n\tn, m = list(map(int, input().split()))\n\tx = [0]*(n+1)\n\ty = [0]#                                    # >\n\tfor i in range(d):\n\t\tl, r, u, v = list(map(_int, input(). split()))\n\t\tx[l] = x[l] + 1\n\t\ty[r] = y[r] + 1\n\tcntl = 0\n\tcntr = 0\n\tfor i, val in enumerate(x):\n\t\tif val and x[i] > 0:\n\t\t\tcntl += 1\n\t\telif not val and x[ i] > 0:     \n\t\t\tcntr += 1\n\tif cntl > 0 or cntr > 0:\n\t\tprint(-1)\n\t", "score": 0.0, "codebleu": 0.1675373092797155, "crystalbleu": 0.09, "codebertscore": 0.75, "codescore": 0.03948475047945976, "surfaceSim": 0.5116468298286481, "abs_surfaceSim_minus_score": 0.5116468298286481, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_60_OP_1", "golden_code": "def sum_to_n(n: int):\n    return sum(range(n + 1))", "generated_code": "def sum_to_n(num: int):\n    return num * (num + 1) // 2", "score": 1.0, "codebleu": 0.3677748940732748, "crystalbleu": 0, "codebertscore": 0.9, "codescore": 0.9873011112213135, "surfaceSim": 0.7664335664335664, "abs_surfaceSim_minus_score": 0.23356643356643358, "source": "local", "local_type": "OP"}
{"id": "MBPP_34_2", "golden_code": "def even_num(x):\r\n  if x%2==0:\r\n     return True\r\n  else:\r\n    return False", "generated_code": "def even_num(n):\n\n\treturn n >> 1 | 1", "score": 0.054, "codebleu": 0.30665843239053464, "crystalbleu": 0, "codebertscore": 0.78, "codescore": 0.12433969229459763, "surfaceSim": 0.5866666666666667, "abs_surfaceSim_minus_score": 0.5326666666666666, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0221_37", "golden_code": "s=input().split()\nn,k=int(s[0]),int(s[1])\nl=2*k+1\nm=n%l\nif m==0:\n    m=2*k+1\nif m<=k+1:\n    pos=1\nelse:\n    pos=m-k\nres=n//l\nif n%l!=0:\n    res+=1\nprint(res)\nfor i in range(res):\n    print(pos+l*i,end=\" \")\nprint(\"\")\n", "generated_code": "import sys\ninput = sys.stdin.readline\n\nn,k=list(map(int,input().split()))\nX=n//2+1\nY=1\nR=0\n\nfor i in range(1,X):\n\tif Y>n:\n\t\tbreak\n\tR+=1\n\tY=min(Y,n-X+i)\n\tX=X-1\n\t\nprint(R)\nprint(*[1]*Y)\n", "score": 0.0042, "codebleu": 0.17644023314077711, "crystalbleu": 0, "codebertscore": 0.8, "codescore": 0.03935874626040459, "surfaceSim": 0.44733796296296297, "abs_surfaceSim_minus_score": 0.443137962962963, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_79_OP_1", "golden_code": "def decimal_to_binary(decimal):\n    return \"db\" + bin(decimal)[2:] + \"db\"", "generated_code": "def decimal_to_binary(num):\n    cache = {}\n    if num in cache:\n        return cache[num]\n    binary_str = format(num, 'b')\n    result = f\"db{binary_str}db\"\n    cache[num] = result\n    return result", "score": 1.0, "codebleu": 0.32053841815254586, "crystalbleu": 0, "codebertscore": 0.79, "codescore": 0.02839142084121704, "surfaceSim": 0.4545454545454546, "abs_surfaceSim_minus_score": 0.5454545454545454, "source": "local", "local_type": "OP"}
{"id": "APPS_test-0986_14", "golden_code": "n,k=list(map(int,input().split()))\na=list(map(int,input().split()))\nz=[0]*81\nkz,ans=0,0\nfor i in range(n):\n    if z[a[i]]: continue\n    ans+=1\n    if k>kz:\n        z[a[i]]=1; kz+=1\n    else:\n        h=-1\n        for j in range(1,n+1):\n            if z[j]:\n                m=n+1\n                for p in range(i,n):\n                    if j==a[p]:\n                        m=p\n                        break\n                if m>h:\n                    h=m;\n                    t=j\n        z[t]=0\n        z[a[i]]=1\nprint(ans)\n", "generated_code": "n,k=map(int,input().split())\na=list(map(int, input().split()))\na.sort()\nres=n*k\nfor i in range(n):\n\tfor j in range(k):\n\t\tif a[i]>=j:\n\t\t\tres-=a[i]-j\n\t\t\ta[i]=0\nprint(res)\n", "score": 0.0048, "codebleu": 0.1896918018313957, "crystalbleu": 0.17, "codebertscore": 0.81, "codescore": 0.10741760581731796, "surfaceSim": 0.6758347016967707, "abs_surfaceSim_minus_score": 0.6710347016967707, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-1171_13", "golden_code": "N, K = map(int, input().split())\nV = list(map(int, input().split()))\n\nans = 0\n\nfor lg in range(K+1):\n    for rg in range(K-lg+1):\n        if lg+rg > N:\n            break\n        for ls in range(K-lg-rg+1):\n            if ls > lg:\n                break\n            for rs in range(K-lg-rg-ls+1):\n                if rs > rg:\n                    break\n\n                lv = V[:lg]\n                rv = V[N-rg:]\n\n                \"\"\"\n                print(lg, ls, rg, rs)\n                print(lv, rv)\n                print(lv[:lg-ls], rv[:rg-rs])\n                print()\n                \"\"\"\n                lv.sort()\n                lv.reverse()\n                rv.sort()\n                rv.reverse()\n\n                ans = max(sum(lv[:lg-ls])+sum(rv[:rg-rs]), ans)\n\nprint(ans)", "generated_code": "n, k = map(int, input().split())\nv = list(map(int, input()))\n\nb = []\na = 0\ns = 0\nfor i in range(n):\n\ta += v[i]\n\tb.append(a)\n\nb.reverse()\nfor i in b:\n\ts += i\n\tif i > 0:\n\t\ts += i\n\nprint(s)\n", "score": 0.0, "codebleu": 0.16640443423796303, "crystalbleu": 0.08, "codebertscore": 0.7, "codescore": 0.07209374755620956, "surfaceSim": 0.6479554530626019, "abs_surfaceSim_minus_score": 0.6479554530626019, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-2404_46", "golden_code": "a = int(input())\nfor i in range(2, a//2 + 1):\n    b = a / i\n    if b.is_integer():\n        print(str(i) + str(int(b)))\n        break\n", "generated_code": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\na = int(input())\n\nfor i in range(a):\n\tb = int(input().strip())\n\tif b <= 2:\n\t\tprint(b)\n\telif b % 3 == 2:\n\t\tb = b // 3\n\t\tprint( b)\n\telse:\n\t\tb -= 2\n\t\tprint( d )\n", "score": 0.1302, "codebleu": 0.319410780846066, "crystalbleu": 0, "codebertscore": 0.77, "codescore": 0.0802408754825592, "surfaceSim": 0.6231244483671667, "abs_surfaceSim_minus_score": 0.49292444836716676, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0672_76", "golden_code": "a, b = list(map(int, input().split()))\nk, val = 1, 0\nwhile k * k <= a - b:\n    if (a - b) % k == 0:\n        val += sum(1 for x in {k, (a - b) // k} if x > b)\n    k += 1\nprint('infinity' if a == b else val)\n", "generated_code": "import math\n\ndef main():\n\ta,b = list(map(int,input().split()))\n\tx = math.gcd(a,b)\n\tif (b//x)!= a:\n\t\tprint(\"infinity\")\n\telse:\n\t\tans = 0\n\t\tx = pow(b//x,2,x)\n\t\tif (a//x)!= x:\n\t\t\tans += 1\n\t\tprint(ans)\n\ndef __starting_point():\n\tmain()\n\n__starting_point()\n", "score": 0.0064, "codebleu": 0.21318998755499502, "crystalbleu": 0, "codebertscore": 0.81, "codescore": 0.19943422079086304, "surfaceSim": 0.464, "abs_surfaceSim_minus_score": 0.4576, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-1341_33", "golden_code": "\nroad = input()\nt = input()\ncur = 0\nfor i in range(len(t)):\n    if road[cur] == t[i]:\n        cur += 1\nprint(cur+1)", "generated_code": "s = input()\nt = input()\nans = 0\nfor i in range(len(s)):\n\tif s[i] == 'R':\n\t\tans += 1\nfor i in ['R', 'G', 'B']:\n\tind = t.find(i)\n\tif ind == -1:\n\t\tcontinue\n\tprint(ind + 1)\n", "score": 0.0, "codebleu": 0.5480716899737434, "crystalbleu": 0, "codebertscore": 0.85, "codescore": 0.15084737539291382, "surfaceSim": 0.6674287251210328, "abs_surfaceSim_minus_score": 0.6674287251210328, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_p02599_s870922238_MUT_86", "golden_code": "import sys\nclass BinaryIndexedTree:\n    def __init__(self, A):\n        self.__n = len(A)\n        self.__node = [0] * (self.__n + 1)\n        self.__data = [0] * (self.__n + 1)\n        S = [0] * (self.__n + 1)\n        for i in range(1, self.__n + 1):\n            S[i] = S[i - 1] + A[i - 1]\n            self.__data[i] = A[i - 1]\n            self.__node[i] = S[i] - S[i - (i & (-i))]\n    def add(self, i, v):\n        self.__data[i] += v\n        while i <= self.__n:\n            self.__node[i] += v\n            i += i & (-i)\n    def sum(self, i):\n        rst = 0\n        while i > 0:\n            rst += self.__node[i]\n            i -= i & (-i)\n        return rst\n    def get(self, i, j):\n        if i == j:\n            return self.__data[i]\n        else:\n            return self.sum(j) - self.sum(i - 1)\ndef main():\n    (N, Q) = map(int, input().split())\n    C = list(map(int, input().split()))\n    P = [[] for _ in range(N)]\n    for (i, c) in enumerate(C):\n        P[c - 1].append(i)\n    right = [0] * N\n    for p in P:\n        if len(p):\n            right[p.pop()] = 1\n    BIT = BinaryIndexedTree(right)\n    query = [[] for _ in range(N)]\n    for (i, s) in enumerate(sys.stdin.readlines()):\n        (l, r) = map(int, s.split())\n        query[r - 1].append((l - 1, i))\n    ans = [None] * Q\n    cur = N - 1\n    for (r, q) in enumerate(reversed(query)):\n        r = (N - 1) - r\n        while q:\n            (l, i) = q.pop()\n            while r < cur:\n                c = C[cur] - 1\n                p = P[c]\n                if len(p):\n                    BIT.add(p.pop() + 1, 1)\n                cur -= 1\n            tmp = BIT.get(l + 1, r + 1)\n            ans[i] = tmp\n    print(sep='\\n', *ans)", "generated_code": "import sys\nclass BinaryIndexedTree:\n    def __init__(self, A):\n        self.__n = len(A)\n        self.__node = [0] * (self.__n + 1)\n        self.__data = [0] * (self.__n + 1)\n        S = [0] * (self.__n + 1)\n        for i in range(1, self.__n + 1):\n            S[i] = S[i - 1] + A[i - 1]\n            self.__data[i] = A[i - 1]\n            self.__node[i] = S[i] - S[i - (i & (-i))]\n    def add(self, i, v):\n        self.__data[i] += v\n        while i <= self.__n:\n            self.__node[i] += v\n            i += i & (-i)\n    def sum(self, i):\n        rst = 0\n        while i > 0:\n            rst += self.__node[i]\n            i -= i & (-i)\n        return rst\n    def get(self, i, j):\n        if i == j:\n            return self.__data[i]\n        else:\n            return self.sum(j) - self.sum(i - 1)\ndef main():\n    (N, Q) = map(int, input().split())\n    C = list(map(int, input().split()))\n    P = [[] for _ in range(N)]\n    for (i, c) in enumerate(C):\n        P[c - 1].append(i)\n    right = [0] * N\n    for p in P:\n        if len(p):\n            right[p.pop()] = 1\n    BIT = BinaryIndexedTree(right)\n    query = [[] for _ in range(N)]\n    for (i, s) in enumerate(sys.stdin.readlines()):\n        (l, r) = map(int, s.split())\n        query[r - 1].append((l - 1, i))\n    ans = [None] * Q\n    cur = N - 1\n    for (r, q) in enumerate(reversed(query)):\n        r = (N - 1) - r\n        while q:\n            (l, i) = q.pop()\n            while r > cur:\n                c = C[cur] - 1\n                p = P[c]\n                if len(p):\n                    BIT.add(p.pop() + 1, 1)\n                cur -= 1\n            tmp = BIT.get(l + 1, r + 1)\n            ans[i] = tmp\n    print(sep='\\n', *ans)", "score": 0.0388, "codebleu": 0.994935590512094, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9936497807502747, "surfaceSim": 0.9872036158861885, "abs_surfaceSim_minus_score": 0.9484036158861886, "source": "local", "local_type": "MUT"}
{"id": "MBPP_52_2", "golden_code": "def count_tuplex(tuplex,value):  \r\n  count = tuplex.count(value)\r\n  return count", "generated_code": "def count_tuplex(a, b):\n\treturn sum(1for x in a if x == b)", "score": 1.0, "codebleu": 0.22077271937089307, "crystalbleu": 0, "codebertscore": 0.82, "codescore": 0.9564979076385498, "surfaceSim": 0.50625, "abs_surfaceSim_minus_score": 0.49375, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_51_OP_1", "golden_code": "def remove_vowels(text):\n    return \"\".join([s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\"]])", "generated_code": "def remove_vowels(input_str):\n    vowels_set = {'a', 'e', 'i', 'o', 'u'}\n    return ''.join(char for char in input_str if char.lower() not in vowels_set)", "score": 1.0, "codebleu": 0.25307875482088493, "crystalbleu": 0, "codebertscore": 0.92, "codescore": 0.7571166157722473, "surfaceSim": 0.6004471964224286, "abs_surfaceSim_minus_score": 0.3995528035775714, "source": "local", "local_type": "OP"}
{"id": "APPS_test-1717_17", "golden_code": "def main():\n    n = int(input())\n    primes = dict()\n    ans = 1\n    for i in range(2, n + 1):\n        t = i\n        j = 2\n        while j * j <= t:\n            k = 0\n            while t % j == 0:\n                t //= j\n                k += 1\n            if k != 0:\n                if j in primes:\n                    primes[j] = max(primes[j], k)\n                else:\n                    primes[j] = k\n            j += 1\n        if t != 1:\n            if t in primes:\n                primes[t] = max(primes[t], 1)\n            else:\n                primes[t] = 1\n    for i, t in list(primes.items()):\n        ans *= i ** t\n    print((ans + 1))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "generated_code": "import sys\ninput = sys.stdin.readline\n\ndef main():\n\tmod=10**9+7\n\tN=int(input())\n\tr=N%10**13\n\t\n\tif N== r:\n\t\tprint(r)\n\telse:\n\t\tn=(r-N)//(r-N-1)\n\t\tprint(n*(10**13)+r)\n\t\n\t\n\treturn\n\ndef __starting_point():\n\tmain()\n__starting_point()\n", "score": 0.0, "codebleu": 0.136480853057719, "crystalbleu": 0.07, "codebertscore": 0.69, "codescore": 0.04623883590102196, "surfaceSim": 0.62995337995338, "abs_surfaceSim_minus_score": 0.62995337995338, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_30_34", "golden_code": "import re\r\ndef match_num(string):\r\n    text = re.compile(r\"^5\")\r\n    if text.match(string):\r\n        return True\r\n    else:\r\n        return False", "generated_code": "import re\ndef match_num(s, *args):\n\tfor i in args:\n\t\tif i==s:\n\t\t\treturn True\n\treturn False", "score": 0.9653, "codebleu": 0.2391002868602721, "crystalbleu": 0, "codebertscore": 0.81, "codescore": 0.8865950703620911, "surfaceSim": 0.6712643678160919, "abs_surfaceSim_minus_score": 0.29403563218390816, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_70_28", "golden_code": "def is_abundant(n):\r\n    fctrsum = sum([fctr for fctr in range(1, n) if n % fctr == 0])\r\n    return fctrsum > n", "generated_code": "def is_abundant(n):\n\treturn n * (n - 1) == n\nll = []\nfor i in range(100000):\n\tif i > 100000:\n\t\tll.append(i)", "score": 0.6625, "codebleu": 0.10715729924374547, "crystalbleu": 0, "codebertscore": 0.8, "codescore": 0.737364649772644, "surfaceSim": 0.5522522522522522, "abs_surfaceSim_minus_score": 0.11024774774774782, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_p02612_s197156959_MUT_1", "golden_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "generated_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "score": 0.0, "codebleu": 0.9794688669138959, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9938680529594421, "surfaceSim": 0.99933598937583, "abs_surfaceSim_minus_score": 0.99933598937583, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_HE_90_OP_1", "golden_code": "def next_smallest(lst):\n    lst = sorted(set(lst))\n    return None if len(lst) < 2 else lst[1]", "generated_code": "def next_smallest(seq):\n    unique_vals = set(seq)\n    if len(unique_vals) < 2:\n        return None\n    first, second = float('inf'), float('inf')\n    for num in unique_vals:\n        if num < first:\n            first, second = num, first\n        elif first < num < second:\n            second = num\n    return second", "score": 1.0, "codebleu": 0.21595951114561895, "crystalbleu": 0, "codebertscore": 0.74, "codescore": 0.5947150588035583, "surfaceSim": 0.5817878028404344, "abs_surfaceSim_minus_score": 0.4182121971595656, "source": "local", "local_type": "OP"}
{"id": "LOCAL_PIE_extra_p03086_s716593637_OP_1", "golden_code": "# -*- coding: utf-8 -*-\n\nfrom collections import deque\n\ndef inpl(): return list(map(int, input().split()))\n\n\n\nS = eval(input())\n\nA = set(\"ATCG\")\n\nans = 0\n\nmode = 0\n\nfor i, s in enumerate(S):\n\n    if s in A:\n\n        if mode == 0:\n\n            mode = 1\n\n            start = i\n\n    else:\n\n        if mode == 1:\n\n            ans = max(i - start, ans)\n\n            mode = 0\n\nif mode == 1:\n\n    ans = max(len(S) - start, ans)\n\nprint(ans)", "generated_code": "def inpl(): return list(map(int, input().split()))\n\nS = eval(input())\n\nC = set(\"ACGT\")\n\n\n\ntmp = 0\n\nans = 0\n\n\n\nfor s in S:\n\n    if s in C:\n\n        tmp += 1\n\n    else:\n\n        ans = max(ans, tmp)\n\n        tmp = 0\n\nans = max(ans, tmp)\n\nprint(ans)", "score": 1.0, "codebleu": 0.36099008835346236, "crystalbleu": 0.33, "codebertscore": 0.83, "codescore": 0.22347290813922882, "surfaceSim": 0.6944444444444444, "abs_surfaceSim_minus_score": 0.3055555555555556, "source": "local", "local_type": "OP"}
{"id": "MBPP_34_6", "golden_code": "def even_num(x):\r\n  if x%2==0:\r\n     return True\r\n  else:\r\n    return False", "generated_code": "def even_num(num):\n\tif num % 2 ==0:\n\t\treturn True\n\telse:\n\t\tnum = abs(num)\n\t\treturn False\n\n\t   \n\treturn False", "score": 1.0, "codebleu": 0.43701183770209995, "crystalbleu": 0, "codebertscore": 0.88, "codescore": 0.9937506318092346, "surfaceSim": 0.7627314814814815, "abs_surfaceSim_minus_score": 0.2372685185185185, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_401_13_OP_2", "golden_code": "n, m = list(map(int, input().split()))\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nf = True\nfor i in range(1, 10):\n    if i in a and i in b:\n        print(i)\n        f = False\n        break\nif f:\n    print(str(min(min(a), min(b))) + str(max(min(a), min(b))))", "generated_code": "x, y = map(int, input().split())\nlist_a = set(map(int, input().split()))\nlist_b = set(map(int, input().split()))\ncommon_elements = list_a.intersection(list_b)\nif common_elements:\n    print(min(common_elements))\nelse:\n    print(str(min(min(list_a), min(list_b))) + str(max(min(list_a), min(list_b))))", "score": 1.0, "codebleu": 0.3142579563259703, "crystalbleu": 0.23, "codebertscore": 0.85, "codescore": 0.6151053309440613, "surfaceSim": 0.6218095405738426, "abs_surfaceSim_minus_score": 0.37819045942615737, "source": "local", "local_type": "OP"}
{"id": "LOCAL_MBPP_39_OP_1", "golden_code": "import heapq\r\nfrom collections import Counter\r\ndef rearange_string(S):\r\n    ctr = Counter(S)\r\n    heap = [(-value, key) for key, value in ctr.items()]\r\n    heapq.heapify(heap)\r\n    if (-heap[0][0]) * 2 > len(S) + 1: \r\n        return \"\"\r\n    ans = []\r\n    while len(heap) >= 2:\r\n        nct1, char1 = heapq.heappop(heap)\r\n        nct2, char2 = heapq.heappop(heap)\r\n        ans.extend([char1, char2])\r\n        if nct1 + 1: heapq.heappush(heap, (nct1 + 1, char1))\r\n        if nct2 + 1: heapq.heappush(heap, (nct2 + 1, char2))\r\n    return \"\".join(ans) + (heap[0][1] if heap else \"\")", "generated_code": "import heapq\nfrom collections import Counter\ndef rearange_string(S):\n    char_count = Counter(S)\n    max_heap = [(-count, char) for char, count in char_count.items()]\n    heapq.heapify(max_heap)\n    if (-max_heap[0][0]) > (len(S) + 1) // 2:\n        return \"\"\n    result = []\n    while len(max_heap) > 1:\n        count1, char1 = heapq.heappop(max_heap)\n        count2, char2 = heapq.heappop(max_heap)\n        result.append(char1)\n        result.append(char2)\n        if count1 + 1 < 0:\n            heapq.heappush(max_heap, (count1 + 1, char1))\n        if count2 + 1 < 0:\n            heapq.heappush(max_heap, (count2 + 1, char2))\n    if max_heap:\n        result.append(max_heap[0][1])\n    return \"\".join(result)", "score": 1.0, "codebleu": 0.5485803176102473, "crystalbleu": 0.38, "codebertscore": 0.89, "codescore": 0.22951056063175201, "surfaceSim": 0.7995164215192423, "abs_surfaceSim_minus_score": 0.2004835784807577, "source": "local", "local_type": "OP"}
{"id": "APPS_test-0435_11", "golden_code": "n,t=map(int,input().split())\ns=input()\nl=0\nk=0\nma=0\nfor r in range(n):\n    if s[r]=='a':\n        if r-l+1>ma: ma=r-l+1\n    else:\n        while k>=t:\n            if s[l]=='b':\n                k-=1\n            l+=1\n        if r-l+1>ma: ma=r-l+1\n        k+=1\n        k%=r-l+2\nl=0\nk=0\nfor r in range(n):\n    if s[r]=='b':\n        if r-l+1>ma: ma=r-l+1\n    else:\n        while k>=t:\n            if s[l]=='a':\n                k-=1\n            l+=1\n        if r-l+1>ma: ma=r-l+1\n        k+=1\n        k%=r-l+2\nprint(ma)", "generated_code": "n,k = list(map(int,input().split()))\ns = input()\nr = 0\nL = 0\na = [0]*26\nfor i in s:\n\tif i == 'a':\n\t\tL += 1\n\t\ta[L] += 1\n\telse:\n\t\tR += 1\n\t\tx = L - R\n\t\ta[x] -= 1\n\t\tif a[x] == 0:\n\t\t\ta.pop(x)\n\t\tR +=1\nprint(max(a))\n", "score": 0.0108, "codebleu": 0.15838502939666046, "crystalbleu": 0.08, "codebertscore": 0.75, "codescore": 0.12041281908750534, "surfaceSim": 0.6732650910733102, "abs_surfaceSim_minus_score": 0.6624650910733102, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0943_15", "golden_code": "n = int(input())\nl = list(map(int, input().split()))\nodd = []\nnodd = []\nfor i in l:\n    if i % 2 == 1:\n        odd.append(i)\n    else:\n        nodd.append(i)\nodd.sort()\nprint(sum(nodd) + sum(odd[len(odd) % 2:]))", "generated_code": "n = int(input())\na = list(map(int, input().split()))\nassert(max(a) % 2 == 0)\nb = [i for i in a if i % 2 == 0]\nprint(max(b))\n", "score": 0.012, "codebleu": 0.36438751678685255, "crystalbleu": 0, "codebertscore": 0.82, "codescore": 0.11836627870798111, "surfaceSim": 0.5632270573028867, "abs_surfaceSim_minus_score": 0.5512270573028867, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_484_1", "golden_code": "def add_tuple(test_list, test_tup):\r\n  test_list += test_tup\r\n  return (test_list) ", "generated_code": "def add_tuple(word,times):\n\toutput = \"1\"\n\tfor element in word:\n\t\toutput = output + str(element)\n\treturn output\n\n\n\n\n\n'''\nAlice tries all possibilities because I am \n\t- DELTA\n\t- Wele's Freedy\n\t- Succinct\n\t- My Vedy\n\t)- Zulu'''", "score": 0.0, "codebleu": 0.1681670007939362, "crystalbleu": 0, "codebertscore": 0.71, "codescore": 0.018255162984132767, "surfaceSim": 0.4263392857142857, "abs_surfaceSim_minus_score": 0.4263392857142857, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_20_20", "golden_code": "def is_odd(n) : \r\n    if (n^1 == n-1) :\r\n        return True; \r\n    else :\r\n        return False; ", "generated_code": "def is_odd(n):    \n\treturn int(n)", "score": 0.1125, "codebleu": 0.19157125414593684, "crystalbleu": 0, "codebertscore": 0.81, "codescore": 0.16362155973911285, "surfaceSim": 0.5496598639455783, "abs_surfaceSim_minus_score": 0.4371598639455783, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_4502_49_MUT_14", "golden_code": "n = int(input())\na = list(map(int, input().split()))\n\n(odd, even) = (a[::2], a[1::2])\n\nif n % 2 == 0:\n    ans = even[::-1] + odd\nelse:\n    ans = odd[::-1] + even\n\nprint(*ans)", "generated_code": "pass\na = list(map(int, input().split()))\n\n(odd, even) = (a[::2], a[1::2])\n\nif n % 2 == 0:\n    ans = even[::-1] + odd\nelse:\n    ans = odd[::-1] + even\n\nprint(*ans)", "score": 0.0, "codebleu": 0.720369861018444, "crystalbleu": 0.87, "codebertscore": 0.97, "codescore": 0.9936663508415222, "surfaceSim": 0.9399164054336469, "abs_surfaceSim_minus_score": 0.9399164054336469, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-0186_8", "golden_code": "3\n\n(n, m) = tuple(map(int, input().split()))\n\na = 2*n\nb = 3*m\nc = n//3\nd = m//2\nwhile c > 0 and d > 0:\n    if a > b:\n        b += 3\n        c -= 1\n        d -= 1\n        if b%6 == 0:\n            d +=1\n    else:\n        a += 2\n        c -= 1\n        d -= 1\n        if a%6 == 0:\n            c += 1\n    #print(a,b,c,d)\nprint(str(max(a,b)))\n", "generated_code": "def main():\n\tn, m = list(map(int, input().split()))\n\tif n * m <= n + m:\n\t\treturn n * m\n\telse:\n\t\treq = (n * m) // 2\n\t\t", "score": 0.0, "codebleu": 0.07621125202478554, "crystalbleu": 0, "codebertscore": 0.74, "codescore": 0.01840323582291603, "surfaceSim": 0.5720114455277661, "abs_surfaceSim_minus_score": 0.5720114455277661, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-1329_65", "golden_code": "import sys\nfrom collections import Counter\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\nMOD = 1000000007\n\n\ndef prime_factorize(n):\n    a = Counter()\n    while n % 2 == 0:\n        a[2] += 1\n        n //= 2\n    f = 3\n    while f * f <= n:\n        if n % f == 0:\n            a[f] += 1\n            n //= f\n        else:\n            f += 2\n    if n != 1:\n        a[n] += 1\n    return a\n\n\ndef main():\n    N = int(readline())\n\n    prime = Counter()\n    for n in range(1, N + 1):\n        prime.update(prime_factorize(n))\n\n    C = [0] * 101\n    for v in list(prime.values()):\n        C[v] += 1\n\n    for i in range(99, -1, -1):\n        C[i] += C[i + 1]\n\n    ans = 0\n    ans += (C[2] - 2) * (C[4] * (C[4] - 1) // 2)\n    ans += (C[2] - 1) * C[24]\n    ans += (C[4] - 1) * C[14]\n    ans += C[74]\n\n    print(ans)\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "generated_code": "import math\nN = int(input())\nt = [0]*(N+1)\np = []\ni = 2\nwhile i <= math.sqrt(N):\n\tif N%i == 0:\n\t\tN//=i\n\t\tt[i] += 1\n\ti += 1\nk = 1\nfor i in range(2,N+1):\n\tif t[i] == 0: k += 1\n\telif t[i]: k += t[i]\n\telse: k -= 1\nprint(k)\n", "score": 0.007, "codebleu": 0.12215463597171924, "crystalbleu": 0.05, "codebertscore": 0.72, "codescore": 0.10555646568536758, "surfaceSim": 0.5853911806543386, "abs_surfaceSim_minus_score": 0.5783911806543386, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_113_OP_1", "golden_code": "def odd_count(lst):\n    res = []\n    for arr in lst:\n        n = sum(int(d)%2==1 for d in arr)\n        res.append(\"the number of odd elements \" + str(n) + \"n the str\"+ str(n) +\"ng \"+ str(n) +\" of the \"+ str(n) +\"nput.\")\n    return res", "generated_code": "def odd_count(sequences):\n    results = []\n    for sequence in sequences:\n        odd_count = sum(1 for char in sequence if int(char) % 2)\n        results.append(f'the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.')\n    return results", "score": 1.0, "codebleu": 0.2783361942480841, "crystalbleu": 0.09, "codebertscore": 0.84, "codescore": 0.13388730585575104, "surfaceSim": 0.6840895610913404, "abs_surfaceSim_minus_score": 0.31591043890865955, "source": "local", "local_type": "OP"}
{"id": "LOCAL_PIE_extra_p02959_s078643579_OP_1", "golden_code": "from sys import stdin,stdout\n\n\n\nif __name__==\"__main__\":\n\n    n=int(stdin.readline())\n\n\n\n    a=[int(x) for x in stdin.readline().split()]\n\n    b=[int(x) for x in stdin.readline().split()]\n\n\n\n    cnt=0\n\n\n\n    for i in range(n):\n\n        if(a[i]>=b[i]):\n\n            cnt+=b[i]\n\n        else:\n\n            cnt+=a[i]\n\n            d=b[i]-a[i]\n\n            cnt+=min(a[i+1],d)\n\n            if(d>a[i+1]):\n\n                a[i+1]=0\n\n            else: a[i+1]-=d\n\n            \n\n    stdout.write(str(cnt)+\"\\n\")\n", "generated_code": "n = int(eval(input()))\n\nA = list(map(int, input().split()))\n\nB = list(map(int, input().split()))\n\na1 = sum(A)\n\nfor i in range(n):\n\n  b = B[i]\n\n  if A[i] >= b:A[i] -= b\n\n  else:\n\n    if A[i+1]+A[i] >= b:\n\n      A[i+1] = A[i+1]+A[i]-b\n\n      A[i] = 0\n\n    else:A[i], A[i+1] = 0, 0\n\na2 = sum(A)\n\nprint((a1-a2))", "score": 1.0, "codebleu": 0.24673195657983402, "crystalbleu": 0.13, "codebertscore": 0.79, "codescore": 0.15516850352287292, "surfaceSim": 0.6559657777092647, "abs_surfaceSim_minus_score": 0.3440342222907353, "source": "local", "local_type": "OP"}
{"id": "MBPP_17_19", "golden_code": "def all_Bits_Set_In_The_Given_Range(n,l,r): \r\n    num = ((1 << r) - 1) ^ ((1 << (l - 1)) - 1) \r\n    new_num = n & num \r\n    if (num == new_num): \r\n        return True\r\n    return False", "generated_code": "def all_Bits_Set_In_The_Given_Range(n,l,r): \n\treturn n & (n-1) == 0 or (n-r) & (n+1) == (l|r)", "score": 0.5384, "codebleu": 0.14149380329760447, "crystalbleu": 0, "codebertscore": 0.84, "codescore": 0.5552812814712524, "surfaceSim": 0.599802371541502, "abs_surfaceSim_minus_score": 0.061402371541501966, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_102_4", "golden_code": "import math\r\ndef perimeter_pentagon(a):\r\n  perimeter=(5*a)\r\n  return perimeter", "generated_code": "import math\ndef perimeter_pentagon(*l):\n\ttry:\n\t\treturn f()\n\texcept:\n\t\tpass", "score": 0.0, "codebleu": 0.3757268057505283, "crystalbleu": 0, "codebertscore": 0.83, "codescore": 0.019577840343117714, "surfaceSim": 0.5769230769230769, "abs_surfaceSim_minus_score": 0.5769230769230769, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_42_6", "golden_code": "import re\r\ndef end_num(string):\r\n    text = re.compile(r\".*[0-9]$\")\r\n    if text.match(string):\r\n        return True\r\n    else:\r\n        return False", "generated_code": "import re\ndef end_num(s):\n\ts = s[::-1]\n\treturn s.startswith(s)", "score": 0.1277, "codebleu": 0.21714512277734233, "crystalbleu": 0, "codebertscore": 0.76, "codescore": 0.024459462612867355, "surfaceSim": 0.6335217237725186, "abs_surfaceSim_minus_score": 0.5058217237725185, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-3890_12", "golden_code": "n,k=map(int,input().split())\nn-=k\nprint(k**(k-1)*n**n%1000000007)", "generated_code": "n, k = list(map(int, input().split()))\n\nif n == k:\n\tprint(1)\nelse:\n\ta = range(1, k + 1)\n\tb = a[::-1]\n\tcount = 1\n\tprev = 1\n\tfor i in range(len(b)):\n\t\tcount += prev\n\t\tprev = b[i]\n\tcount += prev\n\tres = count % 1000000007\n\tprint(res)\n", "score": 0.034, "codebleu": 0.25, "crystalbleu": 0, "codebertscore": 0.77, "codescore": 0.02784697711467743, "surfaceSim": 0.47608695652173916, "abs_surfaceSim_minus_score": 0.4420869565217391, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0077_9", "golden_code": "n = int(input())\nnums = list(map(int, input().split()))\n\npos = [x for x in nums if x > 0]\nneg = [x for x in nums if x < 0]\n\ns1 = sum(pos)\nif s1 % 2 == 1:\n    print(s1)\n    return\n\npodd = [x for x in pos if x % 2 == 1]\nnodd = [x for x in neg if x % 2 == 1]\n\n\nif podd:\n    min_podd = min(podd)\n    if not nodd:\n        s1 -= min_podd\n    else:\n        max_nodd = max(nodd)\n        if min_podd + max_nodd > 0:\n            s1 += max_nodd\n        else:\n            s1 -= min_podd\nelse:\n    s1 += max(nodd)\n\n\nprint(s1)\n", "generated_code": "#!/usr/bin/env python3\n\nimport sys\n\ndef __starting_point():\n\tn = int(input())\n\ta = list(map(int, input().split()))\n\ts = sum(a)\n\tif s % 2 == 0:\n\t\tprint(s // 2)\n\telse:\n\t\tprint(-1)\n__starting_point()\n", "score": 0.0, "codebleu": 0.15864134787793688, "crystalbleu": 0.08, "codebertscore": 0.71, "codescore": 0.059906456619501114, "surfaceSim": 0.4800194931773879, "abs_surfaceSim_minus_score": 0.4800194931773879, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_424_1", "golden_code": "def sort_tuple(tup): \r\n\tn = len(tup) \r\n\tfor i in range(n): \r\n\t\tfor j in range(n-i-1): \r\n\t\t\tif tup[j][0] > tup[j + 1][0]: \r\n\t\t\t\ttup[j], tup[j + 1] = tup[j + 1], tup[j] \r\n\treturn tup", "generated_code": "def sort_tuple(ele):\n\tif len(ele) == 1:\n\t\treturnele[0]\n\telif len(ele)==2:\n\t\ts1,s2 = ele[0],ele[1]\n\t\treturn s1+s2\n\telif l[0]!=l[1]:\n\t\ts=''.join(l)\n\t\treturn sortkey(s.split())\n\telse:\n\t\tl1=sortkey(l[0])\n\t\tl[0]=l[1]\t\n\t\tl.append(l1)", "score": 0.0, "codebleu": 0.15249105903868826, "crystalbleu": 0.02, "codebertscore": 0.74, "codescore": 0.018630696460604668, "surfaceSim": 0.5384140969162996, "abs_surfaceSim_minus_score": 0.5384140969162996, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0623_69", "golden_code": "def find(n1, n2):\n    if n1 < 0 or n2 < 0:\n        return -1\n    if n1 == 0  or n2 == 0:\n        return 0\n    if res[n1][n2] != -1:\n        return res[n1][n2]\n    else:\n        rel = max(find(n1 + 1, n2 - 2), find(n1 - 2, n2 + 1)) + 1\n        res[n1][n2] = rel\n        return rel\nn1, n2 = map(int, input().split())\nres = [[-1] * (301) for i in range(301)]\nprint(find(n1, n2))", "generated_code": "import sys\na, b = list(map(int, input().split()))\nans = 0\nadj = 0\ncurr = 0\nwhile adj < 100 and curr < a:\n\tadj = (adj + 1) % 100\n\tcurr += 1\n\tans = max(ans, curr)\nprint(ans)\n", "score": 0.0068, "codebleu": 0.10899215362742144, "crystalbleu": 0.07, "codebertscore": 0.69, "codescore": 0.08918535709381104, "surfaceSim": 0.41736842105263156, "abs_surfaceSim_minus_score": 0.4105684210526316, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_31_41", "golden_code": "def smallest_multiple(n):\r\n    if (n<=2):\r\n      return n\r\n    i = n * 2\r\n    factors = [number  for number in range(n, 1, -1) if number * 2 > n]\r\n    while True:\r\n        for a in factors:\r\n            if i % a != 0:\r\n                i += n\r\n                break\r\n            if (a == factors[-1] and i % a == 0):\r\n                return i", "generated_code": "def smallest_multiple(n):    \n\treturn 1 if n == 1 else 0;", "score": 0.1822, "codebleu": 0.03292357116473969, "crystalbleu": 0, "codebertscore": 0.71, "codescore": 0.1420598328113556, "surfaceSim": 0.43444885285492496, "abs_surfaceSim_minus_score": 0.25224885285492493, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_11_23", "golden_code": "def lcm(x, y):\r\n   if x > y:\r\n       z = x\r\n   else:\r\n       z = y\r\n   while(True):\r\n       if((z % x == 0) and (z % y == 0)):\r\n           lcm = z\r\n           break\r\n       z += 1\r\n   return lcm", "generated_code": "def lcm(x, z):\n\tfrom fractions import gcd\n\treturn gcd(x,z) < 2\n\n\n\n\nUSTPIPULNES = 48220\n\n\"\"\"\n\treturn 0\n\"\"\"", "score": 0.0664, "codebleu": 0.0977122290941504, "crystalbleu": 0, "codebertscore": 0.73, "codescore": 0.061125803738832474, "surfaceSim": 0.5129820542191676, "abs_surfaceSim_minus_score": 0.44658205421916763, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_643_10_MUT_59", "golden_code": "def gcd(a, b):\n    if b > a:\n        return gcd(b, a)\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef works(a, b, c, d, x):\n    return (b <= d * x and a <= c * x and (d * x) - b >= (c * x) - a)\n\ndef solve():\n    (a, b, c, d) = list(map(int, input().rstrip().split()))\n    if (c == d == 1 and not (a / b == 1)):\n        print(-1)\n        return\n    if (c == 0 and not (a == 0)):\n        print(-1)\n        return\n    g = gcd(c, d)\n    c //= g\n    d //= g\n    low = -1\n    high = 1000000000000\n    while low + 1 < high:\n        mid = (low + high) // 2\n        if works(a, b, c, d, mid):\n            high = mid\n        else:\n            low = mid\n    print((d * high) - b)\n\ndef __starting_point():\n    t = int(input())\n    for _ in range(t):\n        solve()\n\n__starting_point()", "generated_code": "def gcd(a, b):\n    if b > a:\n        return gcd(b, a)\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef works(a, b, c, d, x):\n    return (b <= d * x and a <= c * x and (d * x) - b <= (c * x) - a)\n\ndef solve():\n    (a, b, c, d) = list(map(int, input().rstrip().split()))\n    if (c == d == 1 and not (a / b == 1)):\n        print(-1)\n        return\n    if (c == 0 and not (a == 0)):\n        print(-1)\n        return\n    g = gcd(c, d)\n    c //= g\n    d //= g\n    low = -1\n    high = 1000000000000\n    while low + 1 < high:\n        mid = (low + high) // 2\n        if works(a, b, c, d, mid):\n            high = mid\n        else:\n            low = mid\n    print((d * high) - b)\n\ndef __starting_point():\n    t = int(input())\n    for _ in range(t):\n        solve()\n\n__starting_point()", "score": 0.383, "codebleu": 0.9913520844361599, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9937925934791565, "surfaceSim": 0.9854757870958633, "abs_surfaceSim_minus_score": 0.6024757870958632, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-0112_37", "golden_code": "def gen(cur, used, x):\n    pos.add(cur)\n    if x == n:\n        return\n    for j in range(n):\n        if not used[j]:\n            for i in a[j]:\n                if i != 0 or x != 0:\n                    used[j] = True\n                    gen(cur * 10 + i, used, x + 1)\n                    used[j] = False\n\n\nn = int(input())\na = []\nfor i in range(n):\n    a.append(list(map(int, input().split())))\npos = set()\ngen(0, [False] * n, 0)\nx = 1\nwhile x in pos:\n    x += 1\nprint(x - 1)\n", "generated_code": "n = int(input())\na = [list(map(int, input().split())) for i in range(n)]\na = [i[::-1] for i in a]\nu, d = a[0], a[1]\np = 1\nfor i in range(1, n):\n\tx = max(u[i], d[i])\n\tif x!= 1:\n\t\tp += 1\n\t\tif p > 9:\n\t\t\treturn int(str(p) + str(x))\n\telse:\n\t\tu[i], v = p, x\n\t\tp += int(str(x))\n\nprint(u[-1])\n", "score": 0.0, "codebleu": 0.24915873005652986, "crystalbleu": 0.24, "codebertscore": 0.76, "codescore": 0.10166317224502563, "surfaceSim": 0.5326315789473683, "abs_surfaceSim_minus_score": 0.5326315789473683, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-2406_47", "golden_code": "n = int(input());tot = sum(map(int, input().split()));extra = (n * (n - 1))//2;smol = (tot - extra) // n;out = [smol + i for i in range(n)]\nfor i in range(tot - sum(out)):out[i] += 1\nprint(' '.join(map(str,out)))    ", "generated_code": "def main():\n\tn = int(input())\n\th = list(map(int, input().split()))\n\tres = [0] * n\n\tfor i in range(n - 1):\n\t\tj = i + 1\n\t\twhile j < n and h[j] - h[i] > 2:\n\t\t\tj += 1\n\t\tif j == n:\n\t\t\tj -= 1\n\t\twhile i < n - 1 and h[i] - h[j] > 1:\n\t\t\tres[i] += 1\n\t\t\ti += 1\n\tprint(*res)\n\n\ndef __starting_point():\n\tmain()\n\n__starting_point()\n", "score": 0.0, "codebleu": 0.21452328025892098, "crystalbleu": 0.19, "codebertscore": 0.8, "codescore": 0.06164751946926117, "surfaceSim": 0.514836356466877, "abs_surfaceSim_minus_score": 0.514836356466877, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_MBPP_493_OP_1", "golden_code": "import math\r\ndef calculate_polygons(startx, starty, endx, endy, radius):\r\n    sl = (2 * radius) * math.tan(math.pi / 6)\r\n    p = sl * 0.5\r\n    b = sl * math.cos(math.radians(30))\r\n    w = b * 2\r\n    h = 2 * sl   \r\n    startx = startx - w\r\n    starty = starty - h\r\n    endx = endx + w\r\n    endy = endy + h\r\n    origx = startx\r\n    origy = starty\r\n    xoffset = b\r\n    yoffset = 3 * p\r\n    polygons = []\r\n    row = 1\r\n    counter = 0\r\n    while starty < endy:\r\n        if row % 2 == 0:\r\n            startx = origx + xoffset\r\n        else:\r\n            startx = origx\r\n        while startx < endx:\r\n            p1x = startx\r\n            p1y = starty + p\r\n            p2x = startx\r\n            p2y = starty + (3 * p)\r\n            p3x = startx + b\r\n            p3y = starty + h\r\n            p4x = startx + w\r\n            p4y = starty + (3 * p)\r\n            p5x = startx + w\r\n            p5y = starty + p\r\n            p6x = startx + b\r\n            p6y = starty\r\n            poly = [\r\n                (p1x, p1y),\r\n                (p2x, p2y),\r\n                (p3x, p3y),\r\n                (p4x, p4y),\r\n                (p5x, p5y),\r\n                (p6x, p6y),\r\n                (p1x, p1y)]\r\n            polygons.append(poly)\r\n            counter += 1\r\n            startx += w\r\n        starty += yoffset\r\n        row += 1\r\n    return polygons", "generated_code": "import math\nfrom functools import lru_cache\ndef calculate_polygons(init_x, init_y, final_x, final_y, rad):\n    @lru_cache(None)\n    def calculate_dimensions(rad):\n        side_length = (2 * rad) * math.tan(math.pi / 6)\n        half_side = side_length * 0.5\n        base = side_length * math.cos(math.radians(30))\n        width = base * 2\n        height = 2 * side_length\n        return half_side, base, width, height\n\n    half_side, base, width, height = calculate_dimensions(rad)\n    init_x -= width\n    init_y -= height\n    final_x += width\n    final_y += height\n    orig_x = init_x\n    orig_y = init_y\n    x_shift = base\n    y_shift = 3 * half_side\n    hexagons = []\n    row_num = 1\n    while init_y < final_y:\n        if row_num % 2 == 0:\n            init_x = orig_x + x_shift\n        else:\n            init_x = orig_x\n        while init_x < final_x:\n            vertex1 = (init_x, init_y + half_side)\n            vertex2 = (init_x, init_y + (3 * half_side))\n            vertex3 = (init_x + base, init_y + height)\n            vertex4 = (init_x + width, init_y + (3 * half_side))\n            vertex5 = (init_x + width, init_y + half_side)\n            vertex6 = (init_x + base, init_y)\n            hexagon = [vertex1, vertex2, vertex3, vertex4, vertex5, vertex6, vertex1]\n            hexagons.append(hexagon)\n            init_x += width\n        init_y += y_shift\n        row_num += 1\n    return hexagons", "score": 1.0, "codebleu": 0.34620578358019904, "crystalbleu": 0.16, "codebertscore": 0.8, "codescore": 0.3880927562713623, "surfaceSim": 0.7545077105575326, "abs_surfaceSim_minus_score": 0.24549228944246737, "source": "local", "local_type": "OP"}
{"id": "LOCAL_APPS_4703_10_OP_2", "golden_code": "S = input()\nn = len(S)\n \nans = 0\n \nfor i in range(2**(n-1)):\n    t = S[0]\n    for j in range(n-1):\n        if (i>>j)&1:\n            t += \"+\"\n        t += S[j+1]\n    ans += eval(t)\n \nprint(ans)", "generated_code": "from functools import lru_cache\n\nsequence = input()\nlength = len(sequence)\n\nresult = 0\n\n@lru_cache(None)\ndef evaluate_expression(index, current_sum, last_number):\n    if index == length:\n        return current_sum + last_number\n    \n    current_digit = int(sequence[index])\n    # Option 1: Add '+' before this digit\n    option1 = evaluate_expression(index + 1, current_sum + last_number, current_digit)\n    # Option 2: Concatenate this digit to the last number\n    option2 = evaluate_expression(index + 1, current_sum, last_number * 10 + current_digit)\n    \n    return option1 + option2\n\nresult = evaluate_expression(1, 0, int(sequence[0]))\n\nprint(result)", "score": 1.0, "codebleu": 0.17456377375432944, "crystalbleu": 0, "codebertscore": 0.69, "codescore": 0.02960299514234066, "surfaceSim": 0.4336695747001091, "abs_surfaceSim_minus_score": 0.5663304252998909, "source": "local", "local_type": "OP"}
{"id": "LOCAL_PIE_p02649_s231020544_MUT_130", "golden_code": "def popcount(x):\n    x = x - ((x >> 1) & 1431655765)\n    x = (x & 858993459) + ((x >> 2) & 858993459)\n    x = (x + (x >> 4)) & 252645135\n    x = x + (x >> 8)\n    x = x + (x >> 16)\n    return x & 127\ncmb = [[0 for i in range(51)] for j in range(51)]\ncmb[0][0] = 1\nfor i in range(51):\n    for j in range(51):\n        if (i != 50 and j != 50):\n            cmb[i + 1][j + 1] += cmb[i][j]\n        if i != 50:\n            cmb[i + 1][j] += cmb[i][j]\nfor i in range(1, 51):\n    for j in range(2, 51):\n        cmb[i][j] += cmb[i][j - 1]\n(N, K, T, S) = list(map(int, input().split()))\na = list(map(int, input().split()))\nmust0 = [i for i in range(18) if (S >> i) & 1 == 0]\nmust1 = [i for i in range(18) if (T >> i) & 1 == 1]\nA = []\nfor val in a:\n    check = True\n    for j in must0:\n        check = check & (val >> j) & 1 == 0\n    for j in must1:\n        check = check & (val >> j) & 1 == 1\n    if check:\n        A.append(val)\nif not A:\n    print(0)\n    exit()\nbit = []\nfor i in range(18):\n    if (i not in must0 and i not in must1):\n        bit.append(i)\nfor i in range(len(A)):\n    temp = 0\n    for j in range(len(bit)):\n        temp += (A[i] >> bit[j]) & 1 == 1 * (2 ** j)\n    A[i] = temp\nans = 0\nn = len(bit)\ndata = [0] * (2 ** n)\nfor i in range(2 ** n):\n    t = set([])\n    for a in A:\n        data[a & i] += 1\n        t.add(a & i)\n    temp = 0\n    for val in t:\n        temp += cmb[data[val]][min(K, data[val])]\n    ans += temp * ((-1) ** popcount(i))\n    for val in t:\n        data[val] = 0\nprint(ans)", "generated_code": "def popcount(x):\n    x = x - ((x >> 1) & 1431655765)\n    x = (x & 858993459) + ((x >> 2) & 858993459)\n    x = (x + (x >> 4)) & 252645135\n    x = x + (x >> 8)\n    x = x + (x >> 16)\n    return x & 127\ncmb = [[0 for i in range(51)] for j in range(51)]\ncmb[0][0] = 1\nfor i in range(51):\n    for j in range(51):\n        if (i != 50 and j != 50):\n            cmb[i + 1][j + 1] += cmb[i][j]\n        if i != 50:\n            cmb[i + 1][j] += cmb[i][j]\nfor i in range(1, 51):\n    for j in range(2, 51):\n        cmb[i][j] += cmb[i][j - 1]\n(N, K, T, S) = list(map(int, input().split()))\na = list(map(int, input().split()))\nmust0 = [i for i in range(18) if (S >> i) & 1 == 0]\nmust1 = [i for i in range(18) if (T >> i) & 1 == 1]\nA = []\nfor val in a:\n    check = True\n    for j in must0:\n        check = check & (val >> j) & 1 == 0\n    for j in must1:\n        check = check & (val >> j) & 1 == 1\n    if check:\n        A.append(val)\nif not A:\n    print(0)\n    exit()\nbit = []\nfor i in range(18):\n    if (i not in must0 and i not in must1):\n        bit.append(i)\nfor i in range(len(A)):\n    temp = 0\n    for j in range(len(bit)):\n        temp += (A[i] >> bit[j]) & 1 == 1 * (2 ** j)\n    A[i] = temp\nans = 0\npass\ndata = [0] * (2 ** n)\nfor i in range(2 ** n):\n    t = set([])\n    for a in A:\n        data[a & i] += 1\n        t.add(a & i)\n    temp = 0\n    for val in t:\n        temp += cmb[data[val]][min(K, data[val])]\n    ans += temp * ((-1) ** popcount(i))\n    for val in t:\n        data[val] = 0\nprint(ans)", "score": 0.4106, "codebleu": 0.9857125649168602, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.9936361312866211, "surfaceSim": 0.9838417034678717, "abs_surfaceSim_minus_score": 0.5732417034678716, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-0619_49", "golden_code": "x,y,z = map(int,input().split())\nmod1 = x%z\nmod2 = y%z\n\nif (mod1+mod2)>=z:\n    print(x//z+y//z+1,z-max(mod1,mod2))\nelse:\n    print(x//z+y//z,0)", "generated_code": "#!/usr/bin/env python3\nimport sys\ndef input(): return sys.stdin.readline().rstrip()\n\ndef dfs(x, y, p, sum):\n\tif sum >= (x + y) // 2:\n\t\treturn sum\n\telse:\n\t\tm = (x + y + 1) // 2\n\t\tans = m * (y + 1)\n\t\tif x < y:\n\t\t\tans -= (m\n\t\t)\n\t\treturn min(ans, (x - m) // 2 + dfs(x - m, y, p * 2, sum + m))\n\nx, y, z = list(map(int, input().split()))\nprint(dfs(x, y, 1, 0), dfs(x, y, 1, 3))\n", "score": 0.0, "codebleu": 0.20850715565872563, "crystalbleu": 0.12, "codebertscore": 0.75, "codescore": 0.025966668501496315, "surfaceSim": 0.5312126642771804, "abs_surfaceSim_minus_score": 0.5312126642771804, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_92_OP_1", "golden_code": "def any_int(x, y, z):\n    '''\n    Create a function that takes 3 numbers.\n    Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n    Returns false in any other cases.\n    \n    Examples\n    any_int(5, 2, 7) ➞ True\n    \n    any_int(3, 2, 2) ➞ False\n\n    any_int(3, -2, 1) ➞ True\n    \n    any_int(3.6, -2.2, 2) ➞ False\n  \n\n    \n    '''\n\n    if isinstance(x,int) and isinstance(y,int) and isinstance(z,int):\n        if (x+y==z) or (x+z==y) or (y+z==x):\n            return True\n        return False\n    return False", "generated_code": "def any_int(a, b, c):\n    '''\n    Create a function that takes 3 numbers.\n    Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n    Returns false in any other cases.\n    \n    Examples\n    any_int(5, 2, 7) ➞ True\n    \n    any_int(3, 2, 2) ➞ False\n\n    any_int(3, -2, 1) ➞ True\n    \n    any_int(3.6, -2.2, 2) ➞ False\n    \n\n    \n    '''\n\n    nums = {a, b, c}\n    if all(isinstance(num, int) for num in nums):\n        return (a + b == c) or (a + c == b) or (b + c == a)\n    return False", "score": 1.0, "codebleu": 0.7080179049120328, "crystalbleu": 0, "codebertscore": 0.94, "codescore": 0.8788302540779114, "surfaceSim": 0.798390840167105, "abs_surfaceSim_minus_score": 0.20160915983289496, "source": "local", "local_type": "OP"}
{"id": "APPS_test-2607_29", "golden_code": "import sys\ndef I():\n        return sys.stdin.readline().rstrip()\n\nfor _ in range( int(I()) ):\n    s = I()\n    l = []\n    last = 0\n    for i in range(len(s)):\n        nxt = s[ i + 1 ] if i < len(s) - 1 else 0\n        if s[ i ] == '?':\n            for c in 'abc':\n                if c != last and c != nxt:\n                    l.append(c)\n                    last = c\n                    break\n        else:\n            if s[ i ] == nxt:\n                print(-1)\n                break\n            l.append( s[ i ] )\n            last = s[ i ]\n    else:\n        print(\"\".join(l))\n", "generated_code": "import sys\ninput = sys.stdin.readline\n\nt=int(input())\nfor tests in range(t):\n\tS=input().strip()\n\n\tQ=[len(S)]\n\tfor i in range(len(S)):\n\t\tif S[i]==\"?\":\n\t\t\tQ.append(min(Q[-1],S[i]==\".?\"))\n\n\tif all(x==S[i] for i,x in enumerate(Q)):\n\t\tprint(\"\".join(S))\n\telse:\n\t\tprint(-1)\n", "score": 0.0, "codebleu": 0.2300213314061073, "crystalbleu": 0.16, "codebertscore": 0.78, "codescore": 0.42437127232551575, "surfaceSim": 0.6167368160435751, "abs_surfaceSim_minus_score": 0.6167368160435751, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_17_9", "golden_code": "def all_Bits_Set_In_The_Given_Range(n,l,r): \r\n    num = ((1 << r) - 1) ^ ((1 << (l - 1)) - 1) \r\n    new_num = n & num \r\n    if (num == new_num): \r\n        return True\r\n    return False", "generated_code": "def all_Bits_Set_In_The_Given_Range(n,l,r): \n\treturn bin(n)[2:] == bin(l)[2:] or n & (n - 1) == 0\nh = lambda x: hex(x)[2:]", "score": 0.607, "codebleu": 0.15040953708087137, "crystalbleu": 0, "codebertscore": 0.83, "codescore": 0.5801982879638672, "surfaceSim": 0.6114130434782609, "abs_surfaceSim_minus_score": 0.004413043478260881, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_152_MUT_6", "golden_code": "import os\n\ndef compare(game, guess):\n    return [abs(x - y) for (x, y) in zip(game, guess)]", "generated_code": "import os\n\ndef compare(game, guess):\n    pass", "score": 0.0, "codebleu": 0.40557558379409375, "crystalbleu": 0, "codebertscore": 0.85, "codescore": 0.018548648804426193, "surfaceSim": 0.4731738849385908, "abs_surfaceSim_minus_score": 0.4731738849385908, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-1541_9", "golden_code": "s = input()\n\npivot_pos = 0\nleft_count = 0\nright_count = 0\n\n''''def is_number(s):\n    try:\n        float(s)\n        return True\n    except ValueError:\n        return False\n    try:\n        import unicodedata\n        unicodedata.numeric(s)\n        return True\n    except (TypeError, ValueError):\n\t\treturn False'''\n\n# Find the pivot\nfor i in range(len(s)):\n\tif s[i] == '^':\n\t\tpivot_pos = i \n\n# Solve left side\nfor i in range(pivot_pos):\n\tif s[i].isdigit() == True:\n\t\tleft_count = left_count + (int(s[i]) * (pivot_pos - i))\n\n# Solve left side\nfor i in range(pivot_pos, len(s)):\n\tif s[i].isdigit() == True:\n\t\tright_count = right_count + (int(s[i]) * (i - pivot_pos))\n\nif left_count == right_count:\n\tprint(\"balance\")\nelif left_count > right_count:\n\tprint(\"left\")\nelse:\n\tprint(\"right\")", "generated_code": "import sys\n\ndef f(t):\n\treturn t[1] - t[0]\n\nt = sys.stdin\n\ns = input()\n\nn = len(s)\n\nf = [0] * n\n\nfor i in range(n):\n\tif s[i] == '^':\n\t\tf[i] = 1\n\ncur = 0\nfor i in reversed(list(range(n))):\n\tif f[i] == 1:\n\t\tcur += f[i] - 1\n\telse:\n\t\tcur -= f[i] + 1\n\tf[i] -= 1\n\nif cur == 0:\n\tprint('balance')\nelse:\n\tprint(\"left\")\n", "score": 0.1957, "codebleu": 0.20936432996294219, "crystalbleu": 0.2, "codebertscore": 0.72, "codescore": 0.1512996107339859, "surfaceSim": 0.5532959970620639, "abs_surfaceSim_minus_score": 0.3575959970620639, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_MBPP_819_MUT_22", "golden_code": "import os\n\ndef count_duplic(lists):\n    element = []\n    frequency = []\n    if not lists:\n        return element\n    running_count = 1\n    for i in range(len(lists) - 1):\n        if lists[i] == lists[i + 1]:\n            running_count += 1\n        else:\n            frequency.append(running_count)\n            element.append(lists[i])\n            running_count = 1\n    frequency.append(running_count)\n    element.append(lists[i + 1])\n    return (element, frequency)", "generated_code": "import os\n\ndef count_duplic(lists):\n    element = []\n    frequency = []\n    if not lists:\n        return element\n    running_count = 1\n    for i in range(len(lists) - 1):\n        if lists[i] == lists[i + 1]:\n            running_count += 1\n        else:\n            frequency.append(running_count)\n            element.append(lists[i])\n            running_count = 1\n    pass\n    element.append(lists[i + 1])\n    return (element, frequency)", "score": 0.0, "codebleu": 0.9381974591339544, "crystalbleu": 0.9, "codebertscore": 0.99, "codescore": 0.9938443899154663, "surfaceSim": 0.9510057471264368, "abs_surfaceSim_minus_score": 0.9510057471264368, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_APPS_1384_19_MUT_25", "golden_code": "n = int(input())\na = list(map(int, input().split()))\np = [0] * n\np[0] = a[0]\nfor i in range(1, n):\n    p[i] = p[i - 1] + a[i]\nans = min(n, n - p[n - 1])\nfor i in range(n):\n    l = p[i]\n    r = ((n - i) - 1) - (p[n - 1] - p[i])\n    ans = min(ans, l + r)\nprint(n - ans)", "generated_code": "n = int(input())\na = list(map(int, input().split()))\npass\np[0] = a[0]\nfor i in range(1, n):\n    p[i] = p[i - 1] + a[i]\nans = min(n, n - p[n - 1])\nfor i in range(n):\n    l = p[i]\n    r = ((n - i) - 1) - (p[n - 1] - p[i])\n    ans = min(ans, l + r)\nprint(n - ans)", "score": 0.0, "codebleu": 0.859754228379136, "crystalbleu": 0.89, "codebertscore": 0.98, "codescore": 0.38298794627189636, "surfaceSim": 0.9054307116104869, "abs_surfaceSim_minus_score": 0.9054307116104869, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-1303_13", "golden_code": "def f (x1, y1, x2, y2):\n    return x1 <= x2 <= y1 or x1 <= y2 <= y1 or x2 <= x1 <= y2\n\np, q, l, r = list(map(int, input().split()))\na1, a2 = [(0, 0)] * p, [(0, 0)] * q\nfor i in range(p):\n    a, b = list(map(int, input().split()))\n    a1[i] = (a, b)\nfor i in range(q):\n    a, b = list(map(int, input().split()))\n    a2[i] = (a, b)\nres = [False] * 2000\nans = 0\nfor i in a1:\n    for j in a2:\n        for k in range(max(0, i[0] - j[1]), i[1] - j[0] + 1):\n            res[k] = True\nfor i in range(l, r + 1):\n    if res[i]:\n        ans += 1\nprint(ans)\n", "generated_code": "def main():\n\tp, q, l, r = list(map(int, input().split()))\n\treg = {}\n\tindex = []\n\tfor i in range(p):\n\t\tb, a = list(map(_int, input(). split()))\n\t\tif not a in reg:\n\t\t\treg[a] = []\n\t\treg[a].append(b)\n\t\tindex.append(b)\n\n\tfor i in index:\n\t\trev =list(reversed(reg[i]))\n\t\tcord = sort([rev, list(reg[i])])\n\t\ttimes = [cord[0] -(-cord[1]+1)]\n\t\tfor j in range(len(cord)):\n\t\t\tt = list(reversed([x-cord[j] for x in hand]))\n\t\t\ttt = list(re not in reg[i])", "score": 0.0, "codebleu": 0.24184263870864203, "crystalbleu": 0.17, "codebertscore": 0.75, "codescore": 0.018263405188918114, "surfaceSim": 0.538919413919414, "abs_surfaceSim_minus_score": 0.538919413919414, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_31_21", "golden_code": "def smallest_multiple(n):\r\n    if (n<=2):\r\n      return n\r\n    i = n * 2\r\n    factors = [number  for number in range(n, 1, -1) if number * 2 > n]\r\n    while True:\r\n        for a in factors:\r\n            if i % a != 0:\r\n                i += n\r\n                break\r\n            if (a == factors[-1] and i % a == 0):\r\n                return i", "generated_code": "def smallest_multiple(n) :\n\tif n == 1:\n\t\treturn 1\n\tif (n//2)*(n//2) == n:\n\t\tnn = n//(2)+1\n\telse:\n\t\t nn = n//2\n\treturn nn", "score": 0.1552, "codebleu": 0.1416653091203489, "crystalbleu": 0, "codebertscore": 0.75, "codescore": 0.11539605259895325, "surfaceSim": 0.554942211488701, "abs_surfaceSim_minus_score": 0.39974221148870104, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_p02537_s767194684_MUT_158", "golden_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "generated_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    pass\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "score": 0.483, "codebleu": 0.9644459593937733, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.9817699790000916, "surfaceSim": 0.9849080204174459, "abs_surfaceSim_minus_score": 0.5019080204174459, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-0916_7", "golden_code": "def coloring(i, ancestors, color):\n    while i != 0 and color[ancestors[i - 1]] is None:\n        color[ancestors[i - 1]] = not color[i]\n        i = ancestors[i - 1]\n\n\ndef main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    ancestors = list([int(x) - 1 for x in input().split()])\n    descendants = [[] for i in range(n)]\n    for i in range(n - 1):\n        descendants[ancestors[i]].append(i + 1)\n    color = [None for i in range(n)]\n    for i in range(n):\n        if not descendants[i]:\n            color[i] = True\n            coloring(i, ancestors, color)\n    reds = 0\n    blues = 0\n    xor = 0\n    count_red = dict()\n    count_blue = dict()\n    for i in range(n):\n        if color[i]:\n            blues += 1\n            xor ^= a[i]\n            if str(a[i]) in count_blue:\n                count_blue[str(a[i])] += 1\n            else:\n                count_blue[str(a[i])] = 1\n        else:\n            reds += 1\n            if str(a[i]) in count_red:\n                count_red[str(a[i])] += 1\n            else:\n                count_red[str(a[i])] = 1\n    res = 0\n    if xor == 0:\n        res += (blues - 1) * blues // 2\n        res += (reds - 1) * reds // 2\n        for i in list(count_blue.items()):\n            if i[0] in count_red:\n                res += i[1] * count_red[i[0]]\n    else:\n        for i in list(count_blue.items()):\n            if str(xor ^ int(i[0])) in count_red:\n                res += i[1] * count_red[str(xor ^ int(i[0]))]\n    print(res)\n\n\nmain()\n\n", "generated_code": "n = int(input())\na = list(map(int, input().split()))\np = list(map (int, input(). split()))\nb = [0]*n\nc = [0]#root\n\nfor i in range(n):\n\tif a[i]!= p[i]:\n\t\tc[i] = 1\n\telse:\n\t\tb[i] = c[i]\n\nans = 0\nfor i in b:\n\tans += i*(i-1)//2 + (i-1)*(i-2)//2\n\nprint(ans)\n", "score": 0.0, "codebleu": 0.12525375486721846, "crystalbleu": 0.04, "codebertscore": 0.74, "codescore": 0.31440162658691406, "surfaceSim": 0.5399828830840218, "abs_surfaceSim_minus_score": 0.5399828830840218, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_MBPP_428_MUT_32", "golden_code": "import os\n\ndef shell_sort(my_list):\n    gap = len(my_list) // 2\n    while gap > 0:\n        for i in range(gap, len(my_list)):\n            current_item = my_list[i]\n            j = i\n            while (j >= gap and my_list[j - gap] > current_item):\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            my_list[j] = current_item\n        gap //= 2\n    \n    return my_list", "generated_code": "import os\n\ndef shell_sort(my_list):\n    gap = len(my_list) // 2\n    while gap > 0:\n        for i in range(gap, len(my_list)):\n            break\n        \n        \n        \n        \n        \n        gap //= 2\n    \n    return my_list", "score": 0.0, "codebleu": 0.37005374415352754, "crystalbleu": 0, "codebertscore": 0.91, "codescore": 0.44860345125198364, "surfaceSim": 0.7120789130839382, "abs_surfaceSim_minus_score": 0.7120789130839382, "source": "local", "local_type": "MUT"}
{"id": "MBPP_76_10", "golden_code": "def word_len(s): \r\n    s = s.split(' ')   \r\n    for word in s:    \r\n        if len(word)%2==0: \r\n            return True  \r\n        else:\r\n          return False", "generated_code": "def word_len(word):\n\treturn sum(map(lambda char: ord(char),word)) > 122", "score": 0.3875, "codebleu": 0.12402989086402472, "crystalbleu": 0, "codebertscore": 0.74, "codescore": 0.6183798909187317, "surfaceSim": 0.5388198757763976, "abs_surfaceSim_minus_score": 0.15131987577639755, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_p03558_s378178699_MUT_8", "golden_code": "from collections import defaultdict\nfrom collections import deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\ndef I():\n    return int(sys.stdin.readline())\ndef LS():\n    return list(map(list, sys.stdin.readline().split()))\ndef S():\n    return list(sys.stdin.readline())[:-1]\ndef IR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = I()\n    return l\ndef LIR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = LI()\n    return l\ndef SR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = S()\n    return l\ndef LSR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = SR()\n    return l\nmod = 1000000007\ndef A():\n    s = S()\n    t = S()\n    if s + t == t[::-1] + s[::-1]:\n        print('YES')else:print('NO')\ndef B():\n    n = I()\n    for i in range(int(n ** 0.5) + 2)[::-1]:\n        if i * i <= n:\n            print(i * i)\n            quit()\ndef C():\n    n = I()\n    a = LI()\n    b = LI()\n    c = LI()\n    q = [0 for i in range(n)]\n    ans = 0\n    a.sort()\n    b.sort()\n    c.sort()\n    for i in range(n):\n        j = bisect.bisect_left(a, b[i])\n        q[i] = j\n    for i in range(n - 1):\n        q[i + 1] += q[i]\n    q.insert(0, 0)\n    for i in range(n):\n        j = bisect.bisect_left(b, c[i])\n        ans += q[j]\n    print(ans)\ndef D():\n    def dijkstra():\n        d = [float('inf') for i in range(k)]\n        q = [[0, 1]]\n        d[1] = 0\n        while q:\n            (dx, x) = heappop(q)\n            for (y, dy) in v[x]:\n                if d[y] > dx + dy:\n                    d[y] = dx + dy\n                    heappush(q, [d[y], y])\n        print(d[0] + 1)\n    k = I()\n    if k == 1:\n        print(1)\n        quit()\n    v = [[] for i in range(k)]\n    for i in range(1, k):\n        v[i].append([(i + 1) % k, 1])\n        v[i].append([(i * 10) % k, 0])\n    dijkstra()\ndef E():\n    return\ndef F():\n    return\ndef G():\n    return\ndef H():\n    return", "generated_code": "from collections import defaultdict\nfrom collections import deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\ndef I():\n    return int(sys.stdin.readline())\ndef LS():\n    return list(map(list, sys.stdin.readline().split()))\ndef S():\n    return list(sys.stdin.readline())[:-1]\ndef IR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = I()\n    return l\ndef LIR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = LI()\n    return l\ndef SR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = S()\n    return l\ndef LSR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = SR()\n    return l\nmod = 1000000007\ndef A():\n    s = S()\n    t = S()\n    if s + t == t[::-1] - s[::-1]:\n        print('YES')else:print('NO')\ndef B():\n    n = I()\n    for i in range(int(n ** 0.5) + 2)[::-1]:\n        if i * i <= n:\n            print(i * i)\n            quit()\ndef C():\n    n = I()\n    a = LI()\n    b = LI()\n    c = LI()\n    q = [0 for i in range(n)]\n    ans = 0\n    a.sort()\n    b.sort()\n    c.sort()\n    for i in range(n):\n        j = bisect.bisect_left(a, b[i])\n        q[i] = j\n    for i in range(n - 1):\n        q[i + 1] += q[i]\n    q.insert(0, 0)\n    for i in range(n):\n        j = bisect.bisect_left(b, c[i])\n        ans += q[j]\n    print(ans)\ndef D():\n    def dijkstra():\n        d = [float('inf') for i in range(k)]\n        q = [[0, 1]]\n        d[1] = 0\n        while q:\n            (dx, x) = heappop(q)\n            for (y, dy) in v[x]:\n                if d[y] > dx + dy:\n                    d[y] = dx + dy\n                    heappush(q, [d[y], y])\n        print(d[0] + 1)\n    k = I()\n    if k == 1:\n        print(1)\n        quit()\n    v = [[] for i in range(k)]\n    for i in range(1, k):\n        v[i].append([(i + 1) % k, 1])\n        v[i].append([(i * 10) % k, 0])\n    dijkstra()\ndef E():\n    return\ndef F():\n    return\ndef G():\n    return\ndef H():\n    return", "score": 0.0, "codebleu": 0.9960259674102339, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9874497652053833, "surfaceSim": 0.499755859375, "abs_surfaceSim_minus_score": 0.499755859375, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_MBPP_408_OP_1", "golden_code": "import heapq\r\ndef k_smallest_pairs(nums1, nums2, k):\r\n   queue = []\r\n   def push(i, j):\r\n       if i < len(nums1) and j < len(nums2):\r\n           heapq.heappush(queue, [nums1[i] + nums2[j], i, j])\r\n   push(0, 0)\r\n   pairs = []\r\n   while queue and len(pairs) < k:\r\n       _, i, j = heapq.heappop(queue)\r\n       pairs.append([nums1[i], nums2[j]])\r\n       push(i, j + 1)\r\n       if j == 0:\r\n           push(i + 1, 0)\r\n   return pairs", "generated_code": "import heapq\n\ndef k_smallest_pairs(arr1, arr2, p):\n    heap = []\n    def add_to_heap(x, y):\n        if x < len(arr1) and y < len(arr2):\n            heapq.heappush(heap, (arr1[x] + arr2[y], x, y))\n    add_to_heap(0, 0)\n    result = []\n    visited = set()\n    while heap and len(result) < p:\n        _, x, y = heapq.heappop(heap)\n        result.append([arr1[x], arr2[y]])\n        if (x, y + 1) not in visited:\n            add_to_heap(x, y + 1)\n            visited.add((x, y + 1))\n        if y == 0 and (x + 1, 0) not in visited:\n            add_to_heap(x + 1, 0)\n            visited.add((x + 1, 0))\n    return result\n", "score": 1.0, "codebleu": 0.44415500423731913, "crystalbleu": 0.19, "codebertscore": 0.83, "codescore": 0.9939479827880859, "surfaceSim": 0.795766750770956, "abs_surfaceSim_minus_score": 0.20423324922904396, "source": "local", "local_type": "OP"}
{"id": "LOCAL_APPS_2626_5_OP_1", "golden_code": "for _ in range(int(input())):\n    print(input())", "generated_code": "num_cases = int(input())\ninputs = [input() for _ in range(num_cases)]\nprint('\\n'.join(inputs))", "score": 1.0, "codebleu": 0.32195889547421164, "crystalbleu": 0, "codebertscore": 0.82, "codescore": 0.8924045562744141, "surfaceSim": 0.4521276595744681, "abs_surfaceSim_minus_score": 0.5478723404255319, "source": "local", "local_type": "OP"}
{"id": "LOCAL_PIE_p02599_s870922238_MUT_52", "golden_code": "import sys\nclass BinaryIndexedTree:\n    def __init__(self, A):\n        self.__n = len(A)\n        self.__node = [0] * (self.__n + 1)\n        self.__data = [0] * (self.__n + 1)\n        S = [0] * (self.__n + 1)\n        for i in range(1, self.__n + 1):\n            S[i] = S[i - 1] + A[i - 1]\n            self.__data[i] = A[i - 1]\n            self.__node[i] = S[i] - S[i - (i & (-i))]\n    def add(self, i, v):\n        self.__data[i] += v\n        while i <= self.__n:\n            self.__node[i] += v\n            i += i & (-i)\n    def sum(self, i):\n        rst = 0\n        while i > 0:\n            rst += self.__node[i]\n            i -= i & (-i)\n        return rst\n    def get(self, i, j):\n        if i == j:\n            return self.__data[i]\n        else:\n            return self.sum(j) - self.sum(i - 1)\ndef main():\n    (N, Q) = map(int, input().split())\n    C = list(map(int, input().split()))\n    P = [[] for _ in range(N)]\n    for (i, c) in enumerate(C):\n        P[c - 1].append(i)\n    right = [0] * N\n    for p in P:\n        if len(p):\n            right[p.pop()] = 1\n    BIT = BinaryIndexedTree(right)\n    query = [[] for _ in range(N)]\n    for (i, s) in enumerate(sys.stdin.readlines()):\n        (l, r) = map(int, s.split())\n        query[r - 1].append((l - 1, i))\n    ans = [None] * Q\n    cur = N - 1\n    for (r, q) in enumerate(reversed(query)):\n        r = (N - 1) - r\n        while q:\n            (l, i) = q.pop()\n            while r < cur:\n                c = C[cur] - 1\n                p = P[c]\n                if len(p):\n                    BIT.add(p.pop() + 1, 1)\n                cur -= 1\n            tmp = BIT.get(l + 1, r + 1)\n            ans[i] = tmp\n    print(sep='\\n', *ans)", "generated_code": "import sys\nclass BinaryIndexedTree:\n    def __init__(self, A):\n        self.__n = len(A)\n        self.__node = [0] * (self.__n + 1)\n        self.__data = [0] * (self.__n + 1)\n        S = [0] * (self.__n + 1)\n        for i in range(1, self.__n + 1):\n            S[i] = S[i - 1] + A[i - 1]\n            self.__data[i] = A[i - 1]\n            self.__node[i] = S[i] - S[i - (i & (-i))]\n    def add(self, i, v):\n        self.__data[i] += v\n        while i <= self.__n:\n            self.__node[i] += v\n            i += i & (-i)\n    @classmethod\n    def sum(self, i):\n        rst = 0\n        while i > 0:\n            rst += self.__node[i]\n            i -= i & (-i)\n        return rst\n    def get(self, i, j):\n        if i == j:\n            return self.__data[i]\n        else:return self.sum(j) - self.sum(i - 1)\ndef main():\n    (N, Q) = map(int, input().split())\n    C = list(map(int, input().split()))\n    P = [[] for _ in range(N)]\n    for (i, c) in enumerate(C):\n        P[c - 1].append(i)\n    right = [0] * N\n    for p in P:\n        if len(p):\n            right[p.pop()] = 1\n    BIT = BinaryIndexedTree(right)\n    query = [[] for _ in range(N)]\n    for (i, s) in enumerate(sys.stdin.readlines()):\n        (l, r) = map(int, s.split())\n        query[r - 1].append((l - 1, i))\n    ans = [None] * Q\n    cur = N - 1\n    for (r, q) in enumerate(reversed(query)):\n        r = (N - 1) - r\n        while q:\n            (l, i) = q.pop()\n            while r < cur:\n                c = C[cur] - 1\n                p = P[c]\n                if len(p):\n                    BIT.add(p.pop() + 1, 1)\n                cur -= 1\n            tmp = BIT.get(l + 1, r + 1)\n            ans[i] = tmp\n    print(sep='\\n', *ans)", "score": 0.0438, "codebleu": 0.9857163275406964, "crystalbleu": 0.99, "codebertscore": 0.99, "codescore": 0.9936269521713257, "surfaceSim": 0.995860437610881, "abs_surfaceSim_minus_score": 0.9520604376108811, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_PIE_p02537_s645565645_MUT_27", "golden_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "generated_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] / (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "score": 0.0, "codebleu": 0.9950293033173805, "crystalbleu": 1.0, "codebertscore": 1.0, "codescore": 0.9843634963035583, "surfaceSim": 0.9861791724115019, "abs_surfaceSim_minus_score": 0.9861791724115019, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_HE_141_OP_1", "golden_code": "def file_name_check(file_name):\n    suf = ['txt', 'exe', 'dll']\n    lst = file_name.split(sep='.')\n    if len(lst) != 2:\n        return 'No'\n    if not lst[1] in suf:\n        return 'No'\n    if len(lst[0]) == 0:\n        return 'No'\n    if not lst[0][0].isalpha():\n        return 'No'\n    t = len([x for x in lst[0] if x.isdigit()])\n    if t > 3:\n        return 'No'\n    return 'Yes'", "generated_code": "def file_name_check(name):\n    valid_extensions = {'txt', 'exe', 'dll'}\n    parts = name.split('.')\n    if len(parts) != 2 or parts[1] not in valid_extensions:\n        return 'No'\n    prefix = parts[0]\n    if not prefix or not prefix[0].isalpha() or sum(c.isdigit() for c in prefix) > 3:\n        return 'No'\n    return 'Yes'", "score": 1.0, "codebleu": 0.3131289156890883, "crystalbleu": 0.28, "codebertscore": 0.85, "codescore": 0.8900094628334045, "surfaceSim": 0.6580814051680459, "abs_surfaceSim_minus_score": 0.3419185948319541, "source": "local", "local_type": "OP"}
{"id": "APPS_test-1046_55", "golden_code": "n=int(input())\n\ny=input().split()\nx=[int(f) for f in y]\nz=x[:]\nzeros=[]\nwhile (z.count(0)>0):\n    z.remove(0)\n    zeros.append(0)\n    \n\ncount=0\ncount1=0\nq=list(set(z))\nfor i in range (0,len(q)):\n    key=q[i]\n    if (z.count(key)==2):\n        count+=1\n    if (z.count(key)==1):\n        count=count\n    if (z.count(key)>2):\n        count1=count1-1\n        break\n\nif (count1==0):\n    print (count)\nelse:\n    print(-1)\n    \n    \n        \n    \n\n\n\n    \n    \n\n\n    \n    \n", "generated_code": "n = int(input())\ns = list(map(int, input().split()))\n\ncnt = 0\nfor i in range(n):\n\tif s[i] == 0:\n\t\tcnt += 1\nfor i in reversed(list(range(n))):\n\tif cnt == 0:\n\t  break\n\tif s[_i] == cnt:\n\t  cnt -= 1\nprint(cnt)\n", "score": 0.0294, "codebleu": 0.15538272762023136, "crystalbleu": 0.1, "codebertscore": 0.76, "codescore": 0.06011669710278511, "surfaceSim": 0.6011391625615764, "abs_surfaceSim_minus_score": 0.5717391625615764, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_43_20", "golden_code": "def is_Two_Alter(s):  \r\n    for i in range (len( s) - 2) : \r\n        if (s[i] != s[i + 2]) : \r\n            return False\r\n    if (s[0] == s[1]): \r\n        return False\r\n    return True", "generated_code": "def is_Two_Alter(s):  \n\tif len(s) > 2:    \n\t\treturn s == s[::-1]\n\telse:\n\t\treturn True", "score": 0.8511, "codebleu": 0.12171748035731059, "crystalbleu": 0, "codebertscore": 0.82, "codescore": 0.9670252203941345, "surfaceSim": 0.6205601092896175, "abs_surfaceSim_minus_score": 0.2305398907103825, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_MBPP_289_MUT_10", "golden_code": "import os\n\ndef odd_Days(N):\n    hund1 = N // 100\n    hund4 = N // 400\n    leap = N >> 2\n    ordd = N - leap\n    if hund1:\n        ordd += hund1\n        leap -= hund1\n    if hund4:\n        ordd -= hund4\n        leap += hund4\n    days = ordd + (leap * 2)\n    odd = days % 7\n    return odd", "generated_code": "import os\n\ndef odd_Days(N):\n    hund1 = N // 100\n    hund4 = N // 400\n    leap = N >> 2\n    ordd = N - leap\n    if hund1:\n        ordd += hund1\n        leap -= hund1\n    if hund4:\n        ordd -= hund4\n        leap += hund4\n    days = ordd + (leap * 2)\n    odd = days * 7\n    return odd", "score": 0.071, "codebleu": 0.9761243903408761, "crystalbleu": 0, "codebertscore": 1.0, "codescore": 0.9937548637390137, "surfaceSim": 0.9744422244422244, "abs_surfaceSim_minus_score": 0.9034422244422244, "source": "local", "local_type": "MUT"}
{"id": "MBPP_357_1", "golden_code": "def perimeter(diameter,height) : \r\n    return 2*(diameter+height)  ", "generated_code": "def perimeter(a, size):\n\tc = a // 2\n\td = a % 2\n\treturn c + d * size * size * min(a, c) - (size - 1) * c", "score": 0.0664, "codebleu": 0.33316701125236936, "crystalbleu": 0, "codebertscore": 0.77, "codescore": 0.020135357975959778, "surfaceSim": 0.5905197030268419, "abs_surfaceSim_minus_score": 0.5241197030268419, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_72_24", "golden_code": "def Average(lst): \r\n    return sum(lst) / len(lst) ", "generated_code": "def Average(lst): \n\tsum = 0\n\tfor n in lst:\n\t\tsum = sum + n\n\tavg = sum / len(lst)\n\treturn avg\nll = [\"a\",\"b\",\"c\"]", "score": 1.0, "codebleu": 0.4144158950862199, "crystalbleu": 0, "codebertscore": 0.85, "codescore": 0.9929106831550598, "surfaceSim": 0.5692567567567568, "abs_surfaceSim_minus_score": 0.4307432432432432, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-2134_1", "golden_code": "n = int(input())\na = list(map(int,input().split()))\nb = list(map(int,input().split()))\nlis=[]\nd={}\nfor i in a:\n    if i in d:\n        d[i]+=1\n    else:\n        d[i]=1\nans=0        \nfor i in d:\n    if d[i]>1:\n        lis.append(i)\nfor i in range(len(lis)):\n    for j in range(n):\n        if lis[i]==a[j]:\n            ans+=b[j]            \nfor i in range(n):\n    if d[a[i]]==1:\n        c=0\n        for j in range(len(lis)):\n            if a[i]&lis[j]==a[i]:\n                lis.append(a[i])\n                ans+=b[i]\n                break\nprint(ans)            ", "generated_code": "import sys\ninput = sys.stdin.readline\n\nn = int(input())\nalst = list(map(int, input().split()))\n\nans = 0\n0\nbrut = []\nfor i in range(n):\n\tif alst[i] >= 2**60:\n\t\tbrut.append(1)\n\telse:\n\t\tbrute.append(0)\n\nfor i in brut:\n\tans += i\n\tv = 0\n\tfor j in alst:\n\t\tif not j & i:\n\t\t\tv += 1\n\tif v >= 2:\n\t\tans += i\nprint(ans)\n", "score": 0.0, "codebleu": 0.24044378245318854, "crystalbleu": 0.14, "codebertscore": 0.78, "codescore": 0.15955698490142822, "surfaceSim": 0.6154144305307095, "abs_surfaceSim_minus_score": 0.6154144305307095, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0986_31", "golden_code": "n, k = list(map(int, input().split()))\na = list(map(int, input().split()))\ninventory = set()\nbought = 0\nfor i in range(n):\n    if a[i] not in inventory:\n        if len(inventory) == k:\n            farthest_time = 0\n            farthest = 0\n            for v in inventory:\n                try:\n                    far = a.index(v, i + 1)\n                    if far > farthest_time:\n                        farthest_time = far\n                        farthest = v\n                except ValueError:\n                    farthest_time = 10000\n                    farthest = v\n            inventory.remove(farthest)\n        inventory.add(a[i])\n        bought += 1\n\nprint(bought)\n", "generated_code": "n, k = list(map(int, input().split()))\na = list(map (int, input().strip().split()))[:n]\ndp = [0]*(n+1)\nfor i in range(n):\n\tdp[i+1] = dp[i] + a[i]\ndp[0] = 0\nfor i in 1, :\n\tfor j in range(0, n):\n\t\tif dp[j] - a[j] <= j:\n\t\t\tdp[j+1] = min(dp[j+1], dp[j]+a[j])\nprint(dp[-1])\n", "score": 0.0726, "codebleu": 0.27412077739231355, "crystalbleu": 0.28, "codebertscore": 0.74, "codescore": 0.11996779590845108, "surfaceSim": 0.588971315529179, "abs_surfaceSim_minus_score": 0.516371315529179, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_MBPP_684_MUT_26", "golden_code": "import os\n\ndef count_Char(str, x):\n    count = 0\n    for i in range(len(str)):\n        if str[i] == x:\n            count += 1\n    n = 10\n    repititions = n // len(str)\n    count = count * repititions\n    l = n % len(str)\n    for i in range(l):\n        if str[i] == x:\n            count += 1\n    return count", "generated_code": "import os\n\ndef count_Char(str, x):\n    count = 0\n    for i in range(len(str)):\n        if str[i] == x:\n            count += 1\n    n = 10\n    repititions = n // len(str)\n    count = count * repititions\n    l = n % len(str)\n    for i in range(l):\n        if str[i] == x:\n            count += 1\n    pass", "score": 0.0, "codebleu": 0.9487130473536836, "crystalbleu": 0.95, "codebertscore": 0.99, "codescore": 0.9936756491661072, "surfaceSim": 0.9436813186813187, "abs_surfaceSim_minus_score": 0.9436813186813187, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-1047_46", "golden_code": "n = input()\nB = [0 for i in range(7)]\nwhile len(n) != 7:\n    n = '0' + n\nans = 0\nfor i in range(7):\n    ans = max(ans, int(n[i]))\n    B[i] = int(n[i])\nprint(ans)\ns = ''\nfor i in range(ans):\n    cur = [0 for i in range(7)]\n    for j in range(7):\n        if B[j] > 0:\n            cur[j] = 1\n            B[j] -= 1\n    was = False\n    for j in range(7):\n        if cur[j] == 1:\n            s += '1'\n            was = True\n        elif was:\n            s += '0'\n    s += ' '\nprint(s[:-1])\n", "generated_code": "import sys\n\ndef main():\n\tn = int(sys.stdin.readline())\n\tquas = []\n\tquant = 0\n\twhile n > 0:\n\t\tdig = n % 10\n\t\tif dig == 0:\n\t\t\tquas.append(str(quant))\n\t\t\tquant = 0\n\t\telse:\n\t\t\tquant += 1\n\t\tn = n // 10\n\tprint(len(quas))\n\tprint(' '.join(quas))\n\n\ndef __starting_point():\n\tmain()\n\n__starting_point()\n", "score": 0.0, "codebleu": 0.06916749792347025, "crystalbleu": 0.01, "codebertscore": 0.69, "codescore": 0.05203380063176155, "surfaceSim": 0.4821949440933398, "abs_surfaceSim_minus_score": 0.4821949440933398, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_MBPP_469_MUT_31", "golden_code": "import os\n\ndef max_profit(price, k):\n    n = len(price)\n    final_profit = [[None for x in range(n)] for y in range(k + 1)]\n    for i in range(k + 1):\n        for j in range(n):\n            if (i == 0 or j == 0):\n                final_profit[i][j] = 0\n            else:\n                max_so_far = 0\n                for x in range(j):\n                    curr_price = (price[j] - price[x]) + final_profit[i - 1][x]\n                    if max_so_far < curr_price:\n                        max_so_far = curr_price\n                final_profit[i][j] = max(final_profit[i][j - 1], max_so_far)\n    return final_profit[k][n - 1]", "generated_code": "import os\n\ndef max_profit(price, k):\n    n = len(price)\n    final_profit = [[None for x in range(n)] for y in range(k + 1)]\n    for i in range(k + 1):\n        for j in range(n):\n            if (i == 0 or j == 0):\n                final_profit[i][j] = 0\n            else:\n                max_so_far = 0\n                for x in range(j):\n                    curr_price = (price[j] - price[x]) + final_profit[i - 1][x]\n                    if max_so_far < curr_price:\n                        max_so_far = curr_price\n                pass\n    return final_profit[k][n - 1]", "score": 0.1527, "codebleu": 0.8658983185436555, "crystalbleu": 0.82, "codebertscore": 0.99, "codescore": 0.8307293057441711, "surfaceSim": 0.9403422140560405, "abs_surfaceSim_minus_score": 0.7876422140560404, "source": "local", "local_type": "MUT"}
{"id": "MBPP_90_1", "golden_code": "def first_repeated_word(str1):\r\n  temp = set()\r\n  for word in str1.split():\r\n    if word in temp:\r\n      return word;\r\n    else:\r\n      temp.add(word)\r\n  return 'None'", "generated_code": "def first_repeated_word(str1):\n\treturn [i for i in str1 if str1.count(i)==1][0]", "score": 0.0, "codebleu": 0.10578785832521803, "crystalbleu": 0, "codebertscore": 0.81, "codescore": 0.04333435744047165, "surfaceSim": 0.5481763745236798, "abs_surfaceSim_minus_score": 0.5481763745236798, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_p03253_s318779524_MUT_6", "golden_code": "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nMOD = (10 ** 9) + 7\nfac = [1, 1]\nf_inv = [1, 1]\ninv = [0, 1]\ndef prepare(n, mod):\n    for i in range(2, n + 1):\n        fac.append((fac[-1] * i) % mod)\n        inv.append(((-(inv[mod % i])) * (mod // i)) % mod)\n        f_inv.append((f_inv[-1] * inv[-1]) % mod)\ndef cmb(n, r, mod):\n    if (n < 0 or r < 0):\n        return 0\n    if r > n:\n        return 0\n    return ((fac[n] * f_inv[r]) * f_inv[n - r]) % mod\ndef prime_factorization(n):\n    d = []\n    (i, e) = (2, 0)\n    while i * i <= n:\n        while n % i == 0:\n            n //= i\n            e += 1\n        if e > 0:\n            d.append((i, e))\n        i += 1\n        e = 0\n    if n > 1:\n        d.append((n, 1))\n    return d\ndef main():\n    (N, M) = list(map(int, readline().split()))\n    prepare(N + 100, MOD)\n    d = prime_factorization(M)\n    ans = 1\n    for (i, e) in d:\n        ans *= cmb((N - 1) + e, e, MOD)\n        ans %= MOD\n    print(ans)", "generated_code": "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nMOD = (10 ** 9) - 7\nfac = [1, 1]\nf_inv = [1, 1]\ninv = [0, 1]\ndef prepare(n, mod):\n    for i in range(2, n + 1):\n        fac.append((fac[-1] * i) % mod)\n        inv.append(((-(inv[mod % i])) * (mod // i)) % mod)\n        f_inv.append((f_inv[-1] * inv[-1]) % mod)\ndef cmb(n, r, mod):\n    if (n < 0 or r < 0):\n        return 0\n    if r > n:\n        return 0\n    return ((fac[n] * f_inv[r]) * f_inv[n - r]) % mod\ndef prime_factorization(n):\n    d = []\n    (i, e) = (2, 0)\n    while i * i <= n:\n        while n % i == 0:\n            n //= i\n            e += 1\n        if e > 0:\n            d.append((i, e))\n        i += 1\n        e = 0\n    if n > 1:\n        d.append((n, 1))\n    return d\ndef main():\n    (N, M) = list(map(int, readline().split()))\n    prepare(N + 100, MOD)\n    d = prime_factorization(M)\n    ans = 1\n    for (i, e) in d:\n        ans *= cmb((N - 1) + e, e, MOD)\n        ans %= MOD\n    print(ans)", "score": 0.0, "codebleu": 0.9927498121985038, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9937310218811035, "surfaceSim": 0.9995, "abs_surfaceSim_minus_score": 0.9995, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_PIE_p00144_s682125154_MUT_15", "golden_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "generated_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] // self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "score": 0.0, "codebleu": 0.9945883912637858, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9935572743415833, "surfaceSim": 0.986723282799925, "abs_surfaceSim_minus_score": 0.986723282799925, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_PIE_extra_p03309_s031191514_OP_1", "golden_code": "def main():\n\n    from statistics import median\n\n\n\n    n, *a, = list(map(int, open(0).read().split()))\n\n    a = [x - i for i, x in enumerate(a, 1)]\n\n    a.sort()\n\n    m = int(median(a))\n\n\n\n    ans = sum([abs(x - m) for x in a])\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "generated_code": "def main():\n\n    n, *a, = list(map(int, open(0).read().split()))\n\n    a = [x - i for i, x in enumerate(a, 1)]\n\n    a.sort()\n\n    if n % 2 == 0:\n\n        ans = sum(a[n // 2:]) - sum(a[:n // 2])\n\n    else:\n\n        ans = sum(a[n // 2 + 1:]) - sum(a[:n // 2])\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 1.0, "codebleu": 0.5043908947580552, "crystalbleu": 0.63, "codebertscore": 0.89, "codescore": 0.018663400784134865, "surfaceSim": 0.7331463956069634, "abs_surfaceSim_minus_score": 0.2668536043930366, "source": "local", "local_type": "OP"}
{"id": "LOCAL_APPS_160_35_MUT_7", "golden_code": "from math import sqrt\nfrom bisect import bisect_left\n\ndef main():\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    sum_a = sum(a)\n    st = set()\n    for v in range(1, int(sqrt(sum_a)) + 2):\n        if sum_a % v == 0:\n            st.add(v)\n            st.add(sum_a // v)\n    st.remove(1)\n    ans = 1\n    for target in st:\n        a_mod_t = [v % target for v in a]\n        a_mod_t.sort()\n        for i in range(n - 1):\n            a_mod_t[i + 1] += a_mod_t[i]\n        for i in range(n):\n            (sum_L, sum_R) = (a_mod_t[i], a_mod_t[-1] - a_mod_t[i])\n            (len_L, len_R) = (i + 1, (n - i) - 1)\n            if sum_L == (target * len_R) - sum_R:\n                if sum_L <= k:\n                    if ans < target:\n                        ans = target\n    print(ans)\n\ndef __starting_point():\n    main()\n__starting_point()", "generated_code": "from math import sqrt\nfrom bisect import bisect_left\n\ndef main():\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    sum_a = sum(a)\n    st = set()\n    for v in range(1, int(sqrt(sum_a)) + 2):\n        if sum_a % v == 0:\n            st.add(v)\n            st.add(sum_a // v)\n    st.remove(1)\n    ans = 1\n    for target in st:\n        a_mod_t = [v % target for v in a]\n        a_mod_t.sort()\n        for i in range(n + 1):\n            a_mod_t[i + 1] += a_mod_t[i]\n        for i in range(n):\n            (sum_L, sum_R) = (a_mod_t[i], a_mod_t[-1] - a_mod_t[i])\n            (len_L, len_R) = (i + 1, (n - i) - 1)\n            if sum_L == (target * len_R) - sum_R:\n                if sum_L <= k:\n                    if ans < target:\n                        ans = target\n    print(ans)\n\ndef __starting_point():\n    main()\n__starting_point()", "score": 0.0, "codebleu": 0.9893183604921361, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9937753677368164, "surfaceSim": 0.9994192799070848, "abs_surfaceSim_minus_score": 0.9994192799070848, "source": "local", "local_type": "MUT"}
{"id": "MBPP_385_1", "golden_code": "def rear_extract(test_list):\r\n  res = [lis[-1] for lis in test_list]\r\n  return (res) ", "generated_code": "def rear_extract(test_item):\n\treturn test_item[0]", "score": 0.0, "codebleu": 0.10310791813000995, "crystalbleu": 0, "codebertscore": 0.83, "codescore": 0.030449852347373962, "surfaceSim": 0.6125, "abs_surfaceSim_minus_score": 0.6125, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_p02901_s249297018_MUT_5", "golden_code": "INF = 10 ** 10\n(N, M) = list(map(int, input().split()))\ncosts = []\nkeys = []\nfor _ in range(M):\n    (A, B) = list(map(int, input().split()))\n    cs = list(map(int, input().split()))\n    costs.append(A)\n    key = 0\n    for c in cs:\n        key |= 1 << (c - 1)\n    keys.append(key)\nmaskss = [[] for _ in range(N + 1)]\nnum1s = [0] * (2 ** N)\nfor S in range(2 ** N):\n    num = bin(S).count('1')\n    maskss[num].append(S)\n    num1s[S] = num\ndpAll = [INF] * (2 ** N)\nfor S in range(2 ** N):\n    for (cost, key) in zip(costs, keys):\n        if S & key == S:\n            if cost < dpAll[S]:\n                dpAll[S] = cost\ndp = [INF] * (2 ** N)\nfor S in range(2 ** N):\n    cost = dpAll[S]\n    num1 = num1s[S]\n    for k in range(1, ((num1 + 1) // 2) + 1):\n        for mask in maskss[k]:\n            if mask & S == mask:\n                m2 = S ^ mask\n                c2 = dp[mask] + dp[m2]\n                if c2 < cost:\n                    cost = c2\n    dp[S] = cost\nif dp[(2 ** N) - 1] == INF:\n    print(-1)\nelse:\n    print(dp[(2 ** N) - 1])", "generated_code": "INF = 10 ** 10\n(N, M) = list(map(int, input().split()))\ncosts = []\nkeys = []\nfor _ in range(M):\n    (A, B) = list(map(int, input().split()))\n    cs = list(map(int, input().split()))\n    costs.append(A)\n    key = 0\n    for c in cs:\n        key |= 1 << (c - 1)\n    keys.append(key)\nmaskss = [[] for _ in range(N + 1)]\nnum1s = [0] / (2 ** N)\nfor S in range(2 ** N):\n    num = bin(S).count('1')\n    maskss[num].append(S)\n    num1s[S] = num\ndpAll = [INF] * (2 ** N)\nfor S in range(2 ** N):\n    for (cost, key) in zip(costs, keys):\n        if S & key == S:\n            if cost < dpAll[S]:\n                dpAll[S] = cost\ndp = [INF] * (2 ** N)\nfor S in range(2 ** N):\n    cost = dpAll[S]\n    num1 = num1s[S]\n    for k in range(1, ((num1 + 1) // 2) + 1):\n        for mask in maskss[k]:\n            if mask & S == mask:\n                m2 = S ^ mask\n                c2 = dp[mask] + dp[m2]\n                if c2 < cost:\n                    cost = c2\n    dp[S] = cost\nif dp[(2 ** N) - 1] == INF:\n    print(-1)\nelse:\n    print(dp[(2 ** N) - 1])", "score": 0.0, "codebleu": 0.9931217231346744, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9937777519226074, "surfaceSim": 0.9848096215230278, "abs_surfaceSim_minus_score": 0.9848096215230278, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-1047_28", "golden_code": "n = input()\nB = [0 for i in range(7)]\nwhile len(n) != 7:\n    n = '0' + n\nans = 0\nfor i in range(7):\n    ans = max(ans, int(n[i]))\n    B[i] = int(n[i])\nprint(ans)\ns = ''\nfor i in range(ans):\n    cur = [0 for i in range(7)]\n    for j in range(7):\n        if B[j] > 0:\n            cur[j] = 1\n            B[j] -= 1\n    was = False\n    for j in range(7):\n        if cur[j] == 1:\n            s += '1'\n            was = True\n        elif was:\n            s += '0'\n    s += ' '\nprint(s[:-1])\n", "generated_code": "n = int(input())\n\nprint(list(map(int, list(str(n)))))\n\nprint(n)\n", "score": 0.0, "codebleu": 0.03837850227813079, "crystalbleu": 0.0, "codebertscore": 0.64, "codescore": 0.04465259984135628, "surfaceSim": 0.3629211697393515, "abs_surfaceSim_minus_score": 0.3629211697393515, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-2035_1", "golden_code": "import math\n\ndef main():\n    (n, xs, ys) = tuple([int(x) for x in input().split()])\n\n    p1 = 0\n    p2 = 0\n    p3 = 0\n    p4 = 0\n    for i in range(n):\n        (x, y) = tuple([int(x) for x in input().split()])\n\n        if x < xs:\n            p1 += 1\n        if x > xs:\n            p2 += 1\n        if y < ys:\n            p3 += 1\n        if y > ys:\n            p4 += 1\n\n    p = max(p1, p2, p3, p4)\n    print(p)\n    best = []\n    if p1 == p:\n        best = [xs - 1, ys]\n    elif p2 == p:\n        best = [xs + 1, ys]\n    elif p3 == p:\n        best = [xs, ys - 1]\n    else:\n        best = [xs, ys + 1]\n    print(' '.join([str(x) for x in best]))\n\ndef __starting_point():\n    main()\n\n__starting_point()", "generated_code": "def main():\n\tn, sx, sy = list(map(int, input().split()))\n\tscores = []\n\tfor i in range(n):\n\t\tx, y = list(map('int', input().split() ))\n\t\tscores.append((x - sx, y - sy))\n\tscore = sorted(scores, key=lambda x: x[0])\n\n\toptions = [str(sx - 1), str(sy - 1)]\n\t", "score": 0.0, "codebleu": 0.13466447803223702, "crystalbleu": 0.06, "codebertscore": 0.72, "codescore": 0.01827160269021988, "surfaceSim": 0.5323275862068966, "abs_surfaceSim_minus_score": 0.5323275862068966, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_extra_p03371_s775348159_OP_1", "golden_code": "a, b, c, x, y = list(map(int, input().split()))\n\nab = c * 2\n\n\n\nres = float(\"inf\")\n\nif a + b <= ab:\n\n    res = x * a + y * b\n\nelse:\n\n    if x == y:\n\n        res = x * ab\n\n    elif x > y:\n\n        for i in range(y, x + 1):\n\n            cost = i * ab + (x - i) * a\n\n            res = min(res, cost)\n\n    else:\n\n        for i in range(x, y + 1):\n\n            cost = i * ab + (y - i) * b\n\n            res = min(res, cost)\n\nprint(res)\n", "generated_code": "import sys\n\n\n\nsys.setrecursionlimit(10 ** 7)\n\ninput = sys.stdin.readline\n\nf_inf = float('inf')\n\nmod = 10 ** 9 + 7\n\n\n\n\n\ndef resolve():\n\n    a, b, c, x, y = list(map(int, input().split()))\n\n    c *= 2\n\n    if a + b > c:\n\n        cost1 = max(x, y) * c\n\n        cost2 = min(x, y) * c\n\n        plus = ((y - x) * b) if x < y else (x - y) * a\n\n        res = min(cost1, cost2 + plus)\n\n    else:\n\n        res = x * a + y * b\n\n    print(res)\n\n\n\nif __name__ == '__main__':\n\n    resolve()\n", "score": 1.0, "codebleu": 0.3166977900929155, "crystalbleu": 0.29, "codebertscore": 0.83, "codescore": 0.01864638738334179, "surfaceSim": 0.5709044624138964, "abs_surfaceSim_minus_score": 0.42909553758610364, "source": "local", "local_type": "OP"}
{"id": "MBPP_17_21", "golden_code": "def all_Bits_Set_In_The_Given_Range(n,l,r): \r\n    num = ((1 << r) - 1) ^ ((1 << (l - 1)) - 1) \r\n    new_num = n & num \r\n    if (num == new_num): \r\n        return True\r\n    return False", "generated_code": "def all_Bits_Set_In_The_Given_Range(n,l,r): \n\treturn bin(n)[2] == bin(l)[2] and bin(r)[2] in '02468'", "score": 0.5452, "codebleu": 0.1252469266593362, "crystalbleu": 0, "codebertscore": 0.79, "codescore": 0.6375614404678345, "surfaceSim": 0.5072463768115942, "abs_surfaceSim_minus_score": 0.03795362318840578, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_MBPP_541_MUT_17", "golden_code": "import os\n\nimport math\ndef get_sum(n):\n    sum = 0\n    i = 1\n    while i <= math.sqrt(n):\n        if n % i == 0:\n            if n / i == i:\n                sum = sum + i\n            else:\n                sum = sum + i\n                sum = sum + (n / i)\n        i = i + 1\n    sum = sum - n\n    return sum\ndef check_abundant(n):\n    if get_sum(n) > n:\n        return True\n    else:\n        return False", "generated_code": "import os\n\nimport math\ndef get_sum(n):\n    sum = 0\n    i = 1\n    while i <= math.sqrt(n):\n        if n % i == 0:\n            if n / i == i:\n                sum = sum + i\n            else:\n                sum = sum + i\n                sum = sum + (n / i)\n        i = i + 1\n        break\n    sum = sum - n\n    return sum\ndef check_abundant(n):\n    if get_sum(n) > n:\n        return True\n    else:return False", "score": 0.341, "codebleu": 0.9410796235000352, "crystalbleu": 0.94, "codebertscore": 0.99, "codescore": 0.9936904907226562, "surfaceSim": 0.9721485411140584, "abs_surfaceSim_minus_score": 0.6311485411140583, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-0861_35", "golden_code": "m,R=list(map(int, input().split()))\nprint((2*m/3-2+22/m/3-4/m/m+2**.5*(2-4/m+2/m/m))*R)\n", "generated_code": "from math import sqrt\nm,R = [int(i) for i in input().split()]\ndr = R*R/m\npt = (1+m*sqrt(1+8*(dr)))//2\nprint(pt)\n", "score": 0.0178, "codebleu": 0.10833333333333334, "crystalbleu": 0, "codebertscore": 0.8, "codescore": 0.01839843951165676, "surfaceSim": 0.5029761904761905, "abs_surfaceSim_minus_score": 0.4851761904761905, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_MBPP_815_OP_1", "golden_code": "def sort_by_dnf(arr, n):\r\n  low=0\r\n  mid=0\r\n  high=n-1\r\n  while mid <= high:\r\n    if arr[mid] == 0:\r\n      arr[low], arr[mid] = arr[mid], arr[low]\r\n      low = low + 1\r\n      mid = mid + 1\r\n    elif arr[mid] == 1:\r\n      mid = mid + 1\r\n    else:\r\n      arr[mid], arr[high] = arr[high], arr[mid]\r\n      high = high - 1\r\n  return arr", "generated_code": "def sort_by_dnf(collection, size):\n  begin, current, end = 0, 0, size - 1\n  while current <= end:\n    if collection[current] == 0:\n      collection[begin], collection[current] = collection[current], collection[begin]\n      begin += 1\n      current += 1\n    elif collection[current] == 1:\n      current += 1\n    else:\n      collection[current], collection[end] = collection[end], collection[current]\n      end -= 1\n  return collection", "score": 1.0, "codebleu": 0.31350449038271333, "crystalbleu": 0.14, "codebertscore": 0.83, "codescore": 0.11941856890916824, "surfaceSim": 0.694362796556792, "abs_surfaceSim_minus_score": 0.305637203443208, "source": "local", "local_type": "OP"}
{"id": "APPS_test-0356_12", "golden_code": "n=int(input())\nalist=list(map(int,input().split()))\nm=int(input())\nblist=list(map(int,input().split()))\n\nprea = [alist[0]]\nfor i in range(1,n):\n\tprea.append(prea[-1]+alist[i])\n\npreb = [blist[0]]\nfor i in range(1,m):\n\tpreb.append(preb[-1]+blist[i])\n#print(prea,preb)\nif prea[-1]!=preb[-1]:\n\tprint(-1)\n\nelse:\n\tx=0\n\ty=0\n\tcount=0\n\twhile x<n and y<m:\n\n\t\tif prea[x]==preb[y]:\n\n\t\t\tcount+=1\n\t\t\tx+=1\n\t\t\ty+=1\n\t\telif prea[x]<preb[y]:\n\t\t\tx+=1\n\t\telse:\n\t\t\ty+=1\n\n\tprint(count)\n\n\n", "generated_code": "def main():\n\tn = int(input())\n\ta = list(map(int, input().split()))\n\tm = int(input()); b = list(map (int, input(). split()))\n\ta.sort(); b.sort()\n\tma = ma = 0\n\ti = 0\n\twhile i < n:\n\t\tif a[i] == b[i]:\n\t\t\ti += 1\n\t\t\tcontinue\n\t\tla = 0; rb = 0\n\t\tj = i\n\t\twhile j < n and a[j] >= b[i]: divmod(j, n)\n\t\tif i!= j: la += 1\n\t\ti += 1\n\t\twhile i < n and b[i] >= a[j]: divmod(i, n)\n\t\t\t\n\t\tif la > ma: ma = la\n\t\tif rb > mb: mb = rb", "score": 0.0, "codebleu": 0.28457886581280145, "crystalbleu": 0.18, "codebertscore": 0.78, "codescore": 0.030224906280636787, "surfaceSim": 0.5757786429365962, "abs_surfaceSim_minus_score": 0.5757786429365962, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_extra_p02721_s949081681_OP_1", "golden_code": "N, K, C = list(map(int, input().split()))\n\nS = eval(input())\n\n\n\nlatest = [None]*K\n\ni = len(S)+C\n\nfor j in range(K-1, -1, -1):\n\n  i = S.rindex(\"o\", 0, i-C)\n\n  latest[j] = i\n\n\n\nif i<=C or \"o\" not in S[:i-C]:\n\n  i = -C-1\n\n  for j in latest:\n\n    i = S.index(\"o\", i+C+1)\n\n    if i == j:\n\n      print((i+1))\n", "generated_code": "def solve():\n\n  N, K, C = list(map(int, input().split()))\n\n  workable = [i for i, s in enumerate(eval(input())) if s==\"o\"]\n\n  if len(workable) == K:\n\n    return workable\n\n    \n\n  prev = workable[-1]\n\n  latest = {prev}\n\n  i = len(workable)-1\n\n  while i > 0:\n\n    i -= 1\n\n    if prev - workable[i] > C:\n\n      latest.add(workable[i])\n\n      prev = workable[i]\n\n      if len(latest) > K:\n\n        return []\n\n  must = []\n\n  i = -1\n\n  prev = -C-1\n\n  while i < len(workable)-1:\n\n    i += 1\n\n    if workable[i] - prev > C:\n\n      if workable[i] in latest:\n\n        must.append(workable[i])\n\n      prev = workable[i]\n\n  return must\n\n\n\nfor i in solve():\n\n  print((i+1))", "score": 1.0, "codebleu": 0.26014677465408986, "crystalbleu": 0.22, "codebertscore": 0.79, "codescore": 0.9931694269180298, "surfaceSim": 0.532051282051282, "abs_surfaceSim_minus_score": 0.46794871794871795, "source": "local", "local_type": "OP"}
{"id": "APPS_test-1826_44", "golden_code": "length = int(input())\n\nline = input().strip()\n\nidx = 0\ncount = 0\n\nwhile idx < len(line):\n    if idx < len(line) - 1 and line[idx] == 'R' and line[idx+1] == 'U':\n        idx += 1\n\n    elif idx < len(line) - 1 and line[idx] == 'U' and line[idx+1] == 'R':\n        idx += 1\n\n    count += 1\n    idx += 1\n\nprint(count)\n", "generated_code": "def main():\n\tn = int(input())\n\tsequence = input()\n\tnr = []\n\tfor i in range(n):\n\t\tnr.append(sequence[i])\n\tans = 0\n\tfor i, x in enumerate(nr):\n\t\tif x == 'R':\n\t\t\tnr[i] = 'UD'\n\t\telse:\n\t\t\tnr[x] = 'U'\n\t\tans += 1\n\tprint(ans)\n\n\ndef __starting_point():\n\tmain()\n\n__starting_point()\n", "score": 0.0, "codebleu": 0.19650487236683198, "crystalbleu": 0.11, "codebertscore": 0.75, "codescore": 0.23256540298461914, "surfaceSim": 0.5151461365518873, "abs_surfaceSim_minus_score": 0.5151461365518873, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_47_12_MUT_21", "golden_code": "(n, x) = map(int, input().split())\nA = list(map(int, input().split()))\nDP = [[0] * 3 for _ in range(n + 1)]\nans = 0\nfor i in range(1, n + 1):\n    DP[i][0] = max(DP[i - 1][0] + A[i - 1], A[i - 1])\n    DP[i][1] = max(DP[i - 1][0] + (A[i - 1] * x), DP[i - 1][1] + (A[i - 1] * x), A[i - 1] * x)\n    DP[i][2] = max(DP[i - 1][1] + A[i - 1], DP[i - 1][2] + A[i - 1], A[i - 1])\n    ans = max(ans, max(DP[i]))\nprint(ans)", "generated_code": "(n, x) = map(int, input().split())\nA = list(map(int, input().split()))\nDP = [[0] * 3 for _ in range(n + 1)]\nans = 0\nfor i in range(1, n + 1):\n    DP[i][0] = max(DP[i - 1][0] + A[i - 1], A[i - 1])\n    DP[i][1] = max(DP[i - 1][0] + (A[i - 1] * x), DP[i - 1][1] + (A[i - 1] ** x), A[i - 1] * x)\n    DP[i][2] = max(DP[i - 1][1] + A[i - 1], DP[i - 1][2] + A[i - 1], A[i - 1])\n    ans = max(ans, max(DP[i]))\nprint(ans)", "score": 0.4607, "codebleu": 0.9860116946342178, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9938547015190125, "surfaceSim": 0.9749768839574664, "abs_surfaceSim_minus_score": 0.5142768839574664, "source": "local", "local_type": "MUT"}
{"id": "MBPP_50_5", "golden_code": "def mutiple_tuple(nums):\r\n    temp = list(nums)\r\n    product = 1 \r\n    for x in temp:\r\n        product *= x\r\n    return product", "generated_code": "def mutiple_tuple(nums):\n\t\treturn sum(map(int, nums))", "score": 0.1718, "codebleu": 0.07286296814745755, "crystalbleu": 0, "codebertscore": 0.81, "codescore": 0.018295280635356903, "surfaceSim": 0.5770528683914511, "abs_surfaceSim_minus_score": 0.4052528683914511, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_18_29", "golden_code": "def is_Isomorphic(str1,str2):          \r\n    dict_str1 = {}\r\n    dict_str2 = {}\r\n    for i, value in enumerate(str1):\r\n        dict_str1[value] = dict_str1.get(value,[]) + [i]        \r\n    for j, value in enumerate(str2):\r\n        dict_str2[value] = dict_str2.get(value,[]) + [j]\r\n    if sorted(dict_str1.values()) == sorted(dict_str2.values()):\r\n        return True\r\n    else:\r\n        return False", "generated_code": "def is_Isomorphic(str1,str2):          \n\treturn str1 == str2\n\nh = lambda x,y: True if (x==y and gcd(x, y)!=0) else False", "score": 0.9509, "codebleu": 0.07828998966439794, "crystalbleu": 0, "codebertscore": 0.74, "codescore": 0.9053986072540283, "surfaceSim": 0.4526942355889724, "abs_surfaceSim_minus_score": 0.49820576441102754, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_MBPP_463_MUT_15", "golden_code": "import os\n\ndef max_subarray_product(arr):\n    n = len(arr)\n    max_ending_here = 1\n    min_ending_here = 1\n    max_so_far = 0\n    flag = 0\n    for i in range(0, n):\n        if arr[i] > 0:\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n            flag = 1\n        elif arr[i] == 0:\n            max_ending_here = 1\n            min_ending_here = 1\n        else:\n            temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        if max_so_far < max_ending_here:\n            max_so_far = max_ending_here\n    if (flag == 0 and max_so_far == 0):\n        return 0\n    return max_so_far", "generated_code": "import os\n\ndef max_subarray_product(arr):\n    n = len(arr)\n    max_ending_here = 1\n    min_ending_here = 1\n    max_so_far = 0\n    flag = 0\n    for i in range(0, n):\n        if arr[i] > 0:\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n            flag = 1\n        elif arr[i] == 0:\n            max_ending_here = 1\n            min_ending_here = 1\n        else:\n            temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        if not (max_so_far < max_ending_here):\n            max_so_far = max_ending_here\n    if (flag == 0 and max_so_far == 0):\n        return 0\n    return max_so_far", "score": 0.0, "codebleu": 0.9518007523592752, "crystalbleu": 0.93, "codebertscore": 1.0, "codescore": 0.9937636256217957, "surfaceSim": 0.959580013030622, "abs_surfaceSim_minus_score": 0.959580013030622, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_MBPP_297_OP_2", "golden_code": "def flatten_list(list1):\r\n    result_list = []\r\n    if not list1: return result_list\r\n    stack = [list(list1)]\r\n    while stack:\r\n        c_num = stack.pop()\r\n        next = c_num.pop()\r\n        if c_num: stack.append(c_num)\r\n        if isinstance(next, list):\r\n            if next: stack.append(list(next))\r\n        else: result_list.append(next)\r\n    result_list.reverse()\r\n    return result_list ", "generated_code": "def flatten_list(nested):\n    if not nested: return []\n    stack, flat = [iter(nested)], []\n    while stack:\n        try:\n            item = next(stack[-1])\n            if isinstance(item, list):\n                stack.append(iter(item))\n            else:\n                flat.append(item)\n        except StopIteration:\n            stack.pop()\n    return flat", "score": 1.0, "codebleu": 0.27778324511590785, "crystalbleu": 0, "codebertscore": 0.8, "codescore": 0.9939316511154175, "surfaceSim": 0.6466666666666667, "abs_surfaceSim_minus_score": 0.3533333333333333, "source": "local", "local_type": "OP"}
{"id": "LOCAL_APPS_349_17_MUT_47", "golden_code": "def increasing(m):\n    for i in range(len(m)):\n        prev = m[i][0]\n        for j in range(1, len(m[i])):\n            if m[i][j] <= prev:\n                return False\n            prev = m[i][j]\n    for j in range(len(m[0])):\n        prev = m[0][j]\n        for i in range(1, len(m)):\n            if m[i][j] <= prev:\n                return False\n            prev = m[i][j]\n    return True\ndef sol(m1, m2):\n    for i in range(len(m1)):\n        for j in range(len(m1[i])):\n            if m1[i][j] > m2[i][j]:\n                (m1[i][j], m2[i][j]) = (m2[i][j], m1[i][j])\n    if (not (increasing(m1)) or not (increasing(m2))):\n        return 'Impossible'\n    return 'Possible'\ndef __starting_point():\n    [n, m] = [int(x) for x in input().split()]\n    (m1, m2) = ([], [])\n    for _ in range(n):\n        m1.append([int(x) for x in input().split()])\n    for _ in range(n):\n        m2.append([int(x) for x in input().split()])\n    print(sol(m1, m2))\n__starting_point()", "generated_code": "def increasing(m):\n    for i in range(len(m)):\n        prev = m[i][0]\n        for j in range(1, len(m[i])):\n            if m[i][j] <= prev:\n                return False\n            prev = m[i][j]\n    for j in range(len(m[0])):\n        prev = m[0][j]\n        for i in range(1, len(m)):\n            if m[i][j] <= prev:\n                return False\n            prev = m[i][j]\n    return True\ndef sol(m1, m2):\n    for i in range(len(m1)):\n        for j in range(len(m1[i])):\n            if m1[i][j] > m2[i][j]:\n                (m1[i][j], m2[i][j]) = (m2[i][j], m1[i][j])\n    if (not (increasing(m1)) or not (increasing(m2))):\n        return 'Impossible'\n    return 'Possible'\ndef __starting_point():\n    [n, m] = [int(x) for x in input().split()]\n    (m1, m2) = ([], [])\n    for _ in range(n):\n        m1.append([int(x) for x in input().split()])\n    for _ in range(n):\n        pass\n    print(sol(m1, m2))\n__starting_point()", "score": 0.0, "codebleu": 0.9505408663805021, "crystalbleu": 0.93, "codebertscore": 0.99, "codescore": 0.993772566318512, "surfaceSim": 0.9629669540229886, "abs_surfaceSim_minus_score": 0.9629669540229886, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-2035_8", "golden_code": "import math\n\ndef main():\n    (n, xs, ys) = tuple([int(x) for x in input().split()])\n\n    p1 = 0\n    p2 = 0\n    p3 = 0\n    p4 = 0\n    for i in range(n):\n        (x, y) = tuple([int(x) for x in input().split()])\n\n        if x < xs:\n            p1 += 1\n        if x > xs:\n            p2 += 1\n        if y < ys:\n            p3 += 1\n        if y > ys:\n            p4 += 1\n\n    p = max(p1, p2, p3, p4)\n    print(p)\n    best = []\n    if p1 == p:\n        best = [xs - 1, ys]\n    elif p2 == p:\n        best = [xs + 1, ys]\n    elif p3 == p:\n        best = [xs, ys - 1]\n    else:\n        best = [xs, ys + 1]\n    print(' '.join([str(x) for x in best]))\n\ndef __starting_point():\n    main()\n\n__starting_point()", "generated_code": "import sys\n\ndef minp():\n\treturn sys.stdin.readline().strip()\n\ndef mint():\n\treturn int(minp())\n\ndef mints():\n\treturn list(map(int, minp().split()))\n\ndef solve():\n\tn, sx, sy = mints()\n\tdu = []\n\tfor i in range(n):\n\t\tu, v = mints() #u is +100, v is -100\n\t\tdu.append((u, v))\n\tdu.sort()\n\tdu.append((sx, sy))\n\tdu = sorted(du)\n\tr = 0\n\tc = 0\n\tpp = 0\n\twhile du:\n\t\tdx = du[-1]\n\t\tif c >= n:\n\t\t\tbreak\n\t\telif dx[0] == 0:\n\t\t\tdx = dx[1:]\n\t\t\t", "score": 0.0, "codebleu": 0.18683689838717032, "crystalbleu": 0.06, "codebertscore": 0.72, "codescore": 0.018285438418388367, "surfaceSim": 0.5282567049808429, "abs_surfaceSim_minus_score": 0.5282567049808429, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_extra_p03425_s570150327_OP_1", "golden_code": "#!/usr/bin/env python3\n\n\n\nn = int(eval(input()))\n\ns = [eval(input()) for _ in range(n)]\n\n\n\nc = [0 for _ in range(5)]\n\nt = 'MARCH'\n\n\n\nfor i in range(n):\n\n    for j in range(5):\n\n        if s[i][0] == t[j]:\n\n            c[j] += 1\n\nans = 0 \n\nfor i in range(5):\n\n    for j in range(i+1, 5): \n\n        for k in range(j+1, 5): \n\n            ans += c[i]*c[k]*c[j]\n\nprint(ans)\n", "generated_code": "#!/usr/bin/env python3\n\n\n\nn = int(eval(input()))\n\ns = [eval(input()) for _ in range(n)]\n\nd = {}\n\n\n\nfor c in s:\n\n    if c[0] not in d:\n\n        d[c[0]] = 1 \n\n    else:\n\n        d[c[0]] += 1\n\n\n\ntmp = d.copy()\n\nt = ['M', 'A', 'R', 'C', 'H']\n\nfor c in tmp:\n\n    if c not in t:\n\n        d.pop(c)\n\n\n\nans = 0 \n\ndlist = list(d.items())\n\nfor i in range(len(dlist)):\n\n    for j in range(i+1, len(dlist)):\n\n        for k in range(j+1, len(dlist)):\n\n            ans += dlist[i][1]*dlist[j][1]*dlist[k][1]\n\nprint(ans)\n", "score": 1.0, "codebleu": 0.3760107470229889, "crystalbleu": 0.24, "codebertscore": 0.86, "codescore": 0.9852452874183655, "surfaceSim": 0.7176155115511551, "abs_surfaceSim_minus_score": 0.2823844884488449, "source": "local", "local_type": "OP"}
{"id": "MBPP_73_31", "golden_code": "def get_noOfways(n):\r\n    if (n == 0):\r\n        return 0;\r\n    if (n == 1):\r\n        return 1; \r\n    return get_noOfways(n - 1) + get_noOfways(n - 2);", "generated_code": "def get_noOfways(n): \n\tif n == 0:\n\t\treturn (1)\n\telif n == 1:\n\t\tif 1:\n\t\t\treturn False\n\t\telse:\n\t\t\t return True\n\telif (n & (n-1)) == 0: \n\t\t\treturn True\n\telse:\n\t\tfor i in range(3, n+2): \n\t\t\tif dfs(n-i):\n\t\t\t\treturn True\n\t\treturn False", "score": 0.0, "codebleu": 0.23740101024664828, "crystalbleu": 0, "codebertscore": 0.82, "codescore": 0.06911314278841019, "surfaceSim": 0.6917758369723435, "abs_surfaceSim_minus_score": 0.6917758369723435, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-2334_5", "golden_code": "import math\nNN = int(input())\nAI = list(map(int,input().split()))\nXX,FF = list(map(int,input().split()))\nlength = len(AI)\nextra = 0\nfor xx in AI:\n    if xx>XX:\n        extra+=math.ceil((xx-XX)/(XX+FF))\nprint(extra*FF)\n", "generated_code": "#!/usr/bin/env python3\nimport sys\nfrom collections import defaultdict\n\n# Generated bysmallest]:\n#  1.lookup = defaultdict(list)\n#   2.convert = defaultdict(int)\n# less result then minimum amount of exponent groups\n#  3.ps u search to findexponent r == x\n#  4.ms f(amount) = s + e\n#5.ma arange = max(amount)\n#6.mi f(amount) == x\n# 7.pc f(amount) - f(amount-x)\n\ndef main():\n\tN = int(input())\n\tA = list(map(int, input().split()))\n\tX = int(input().split())\n\tC = [0] * N\n\tfor i in range(N):\n\t\tC[i] = A[i]\n\t", "score": 0.0, "codebleu": 0.21824395636073746, "crystalbleu": 0.05, "codebertscore": 0.69, "codescore": 0.01841582916676998, "surfaceSim": 0.6004063301967493, "abs_surfaceSim_minus_score": 0.6004063301967493, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_p02537_s645565645_MUT_128", "golden_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "generated_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\npass", "score": 0.0, "codebleu": 0.9941659541557502, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9822631478309631, "surfaceSim": 0.9827987175866709, "abs_surfaceSim_minus_score": 0.9827987175866709, "source": "local", "local_type": "MUT"}
{"id": "MBPP_9_38", "golden_code": "def check_Concat(str1,str2):\r\n    N = len(str1)\r\n    M = len(str2)\r\n    if (N % M != 0):\r\n        return False\r\n    for i in range(N):\r\n        if (str1[i] != str2[i % M]):\r\n            return False         \r\n    return True", "generated_code": "def check_Concat(str1,str2):\n\treturn str1 == str2 and (str1 == str1+str2)\nh = lambda x,y: x+y", "score": 0.8928, "codebleu": 0.15637360244023704, "crystalbleu": 0, "codebertscore": 0.77, "codescore": 0.9638922810554504, "surfaceSim": 0.534970238095238, "abs_surfaceSim_minus_score": 0.357829761904762, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_468_2", "golden_code": "def is_num_keith(x): \r\n\tterms = [] \r\n\ttemp = x \r\n\tn = 0 \r\n\twhile (temp > 0): \r\n\t\tterms.append(temp % 10) \r\n\t\ttemp = int(temp / 10) \r\n\t\tn+=1 \r\n\tterms.reverse() \r\n\tnext_term = 0 \r\n\ti = n \r\n\twhile (next_term < x): \r\n\t\tnext_term = 0 \r\n\t\tfor j in range(1,n+1): \r\n\t\t\tnext_term += terms[i - j] \r\n\t\tterms.append(next_term) \r\n\t\ti+=1 \r\n\treturn (next_term == x) ", "generated_code": "def is_num_keith(n) : \n\tsn = str(n)\n\tif sn[0] == '0' and sn[1] == '1' :\n\t   return True", "score": 0.0, "codebleu": 0.03481790371972872, "crystalbleu": 0, "codebertscore": 0.7, "codescore": 0.23502857983112335, "surfaceSim": 0.44421468615017, "abs_surfaceSim_minus_score": 0.44421468615017, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_306_3", "golden_code": "def remove_matching_tuple(test_list1, test_list2):\r\n  res = [sub for sub in test_list1 if sub not in test_list2]\r\n  return (res) ", "generated_code": "def remove_matching_tuple(test_string, test_sequence):\n\tif (test_string in test_sequence and test_sequence in test_set):\n\t\treturn (test_sequence.get(test_sequence, test_string) )\n\telse:\n\t\treturn (\"Unsupport test_sequence by test_sequence[test_sequence] = test_string\")", "score": 0.0, "codebleu": 0.14090728554353432, "crystalbleu": 0, "codebertscore": 0.79, "codescore": 0.018589822575449944, "surfaceSim": 0.3791044776119403, "abs_surfaceSim_minus_score": 0.3791044776119403, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0172_6", "golden_code": "def f():\n    n=int(input())\n    a=[0]*5\n    b=[0]*5\n\n    X = [int(x) for x in input().split()]\n    for x in X:\n        a[x-1]+=1\n\n    X = [int(x) for x in input().split()]\n    for x in X:\n        b[x-1]+=1\n\n    for i in range(5):\n        if (a[i]+b[i])%2==1:\n            print('-1')\n            return\n\n    x=0\n    for i in range(5):\n        x += abs(a[i]-b[i])/2\n\n    print(int(x/2))\n\nf()\n", "generated_code": "n = int(input())\n\na = list(map(int, input().split()))\nb = list(map((int), input().split()));\na.sort(); b.sort()\n\ni = 0; j = 0\ncnt = 0\nwhile i < n and j < n:\n\tif a[i] == b[j]:\n\t\tcnt += 1\n\t\ti += 1; j += 1\n\telse:\n\t\tif cnt > 0:\n\t\t\tcnt -= 1\n\t\telse:\n\t\t\tbreak\n\nif cnt >0:\n\tprint(-1)\nelse:\n\tprint(cnt)\n", "score": 0.0, "codebleu": 0.1676952456935969, "crystalbleu": 0.08, "codebertscore": 0.76, "codescore": 0.2940957248210907, "surfaceSim": 0.5002136752136752, "abs_surfaceSim_minus_score": 0.5002136752136752, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_643_10_MUT_79", "golden_code": "def gcd(a, b):\n    if b > a:\n        return gcd(b, a)\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef works(a, b, c, d, x):\n    return (b <= d * x and a <= c * x and (d * x) - b >= (c * x) - a)\n\ndef solve():\n    (a, b, c, d) = list(map(int, input().rstrip().split()))\n    if (c == d == 1 and not (a / b == 1)):\n        print(-1)\n        return\n    if (c == 0 and not (a == 0)):\n        print(-1)\n        return\n    g = gcd(c, d)\n    c //= g\n    d //= g\n    low = -1\n    high = 1000000000000\n    while low + 1 < high:\n        mid = (low + high) // 2\n        if works(a, b, c, d, mid):\n            high = mid\n        else:\n            low = mid\n    print((d * high) - b)\n\ndef __starting_point():\n    t = int(input())\n    for _ in range(t):\n        solve()\n\n__starting_point()", "generated_code": "def gcd(a, b):\n    if b > a:\n        return gcd(b, a)\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef works(a, b, c, d, x):\n    return (b <= d * x and a <= c * x and (d * x) - b >= (c * x) - a)\n\ndef solve():\n    (a, b, c, d) = list(map(int, input().rstrip().split()))\n    if (c == d == 1 and not (a / b == 1)):\n        print(-1)\n        return\n    if (c == 0 and not (a == 0)):\n        print(-1)\n        return\n    pass\n    c //= g\n    d //= g\n    low = -1\n    high = 1000000000000\n    while low + 1 < high:\n        mid = (low + high) // 2\n        if works(a, b, c, d, mid):\n            high = mid\n        else:\n            low = mid\n    print((d * high) - b)\n\ndef __starting_point():\n    t = int(input())\n    for _ in range(t):\n        solve()\n\n__starting_point()", "score": 0.3847, "codebleu": 0.9586918204699375, "crystalbleu": 0.96, "codebertscore": 0.99, "codescore": 0.9938144683837891, "surfaceSim": 0.9801332463340087, "abs_surfaceSim_minus_score": 0.5954332463340086, "source": "local", "local_type": "MUT"}
{"id": "MBPP_6_36", "golden_code": "def are_Rotations(string1,string2): \r\n    size1 = len(string1) \r\n    size2 = len(string2) \r\n    temp = '' \r\n    if size1 != size2: \r\n        return False\r\n    temp = string1 + string1 \r\n    if (temp.count(string2)> 0): \r\n        return True\r\n    else: \r\n        return False", "generated_code": "def are_Rotations(string1,string2): \n\treturn True if len(string1)!= len(string2) else False\ntp = lambda: int(string1==string2)\nstring_a = lambda: str(string1);str_a = string_a;", "score": 0.0817, "codebleu": 0.22650455077967313, "crystalbleu": 0, "codebertscore": 0.82, "codescore": 0.038043633103370667, "surfaceSim": 0.627042057698992, "abs_surfaceSim_minus_score": 0.545342057698992, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_MBPP_714_MUT_40", "golden_code": "import os\n\ndef count_Fac(n):\n    m = n\n    count = 0\n    i = 2\n    while i * i <= m:\n        total = 0\n        while n % i == 0:\n            n /= i\n            total += 1\n        temp = 0\n        j = 1\n        while temp + j <= total:\n            temp += j\n            count += 1\n            j += 1\n        i += 1\n    if n != 1:\n        count += 1\n    return count", "generated_code": "import os\n\ndef count_Fac(n):\n    m = n\n    count = 0\n    i = 2\n    while i * i <= m:\n        total = 0\n        while n % i == 0:\n            n /= i\n            total += 1\n        temp = 0\n        j = 1\n        while temp + j <= total:\n            break\n        \n        \n        i += 1\n    if n != 1:\n        count += 1\n    return count", "score": 0.3418, "codebleu": 0.8438150924402049, "crystalbleu": 0, "codebertscore": 0.98, "codescore": 0.9936450719833374, "surfaceSim": 0.9511538461538461, "abs_surfaceSim_minus_score": 0.6093538461538461, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_HE_144_OP_1", "golden_code": "def simplify(x, n):\n    a, b = x.split(\"/\")\n    c, d = n.split(\"/\")\n    numerator = int(a) * int(c)\n    denom = int(b) * int(d)\n    if (numerator/denom == int(numerator/denom)):\n        return True\n    return False", "generated_code": "def simplify(frac1, frac2):\n    num1, den1 = map(int, frac1.split(\"/\"))\n    num2, den2 = map(int, frac2.split(\"/\"))\n    num_product = num1 * num2\n    den_product = den1 * den2\n    return num_product % den_product == 0", "score": 1.0, "codebleu": 0.20337929707150426, "crystalbleu": 0, "codebertscore": 0.78, "codescore": 0.9932597279548645, "surfaceSim": 0.6415898617511521, "abs_surfaceSim_minus_score": 0.35841013824884793, "source": "local", "local_type": "OP"}
{"id": "LOCAL_HE_128_MUT_12", "golden_code": "import os\n\ndef prod_signs(arr):\n    if not arr:\n        return None\n    prod = 0 if 0 in arr else (-1) ** len(list(filter((lambda x: (x < 0)), arr)))\n    return prod * sum([abs(i) for i in arr])", "generated_code": "import os\n\ndef prod_signs(arr):\n    if not arr:\n        return None\n    prod = 0 if 0 in arr else (-1) ** len(list(filter((lambda x: (x > 0)), arr)))\n    return prod * sum([abs(i) for i in arr])", "score": 0.4404, "codebleu": 0.9602896391728395, "crystalbleu": 0, "codebertscore": 1.0, "codescore": 0.9936694502830505, "surfaceSim": 0.9617083946980854, "abs_surfaceSim_minus_score": 0.5213083946980854, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_PIE_extra_p03037_s133611442_OP_1", "golden_code": "import sys\n\n\n\nn, m, *lr = list(map(int, sys.stdin.read().split()))\n\nlr = list(zip(*[iter(lr)] * 2))\n\n\n\ndef main():\n\n    cnt = [0] * (n + 1)\n\n    for l, r in lr:\n\n        cnt[l-1] += 1\n\n        cnt[r] -= 1\n\n    \n\n    for i in range(n):\n\n        cnt[i+1] += cnt[i]\n\n    \n\n    res = 0\n\n    for i in range(n):\n\n        res += (cnt[i] == m) & 1\n\n    \n\n    return res\n\n\n\nif __name__ == '__main__':\n\n    ans = main()\n\n    print(ans)", "generated_code": "import sys\n\n\n\nn, m, *lr = list(map(int, sys.stdin.read().split()))\n\nl, r = lr[::2], lr[1::2]\n\n\n\ndef main():\n\n    ans = max(min(r) - max(l) + 1, 0)\n\n    return ans\n\n\n\nif __name__ == '__main__':\n\n    ans = main()\n\n    print(ans)", "score": 0.7762, "codebleu": 0.30662618959757326, "crystalbleu": 0.28, "codebertscore": 0.84, "codescore": 0.019872423261404037, "surfaceSim": 0.7303921568627452, "abs_surfaceSim_minus_score": 0.04580784313725483, "source": "local", "local_type": "OP"}
{"id": "APPS_test-1309_49", "golden_code": "n = int(input())\nval = list(map(int, input().split()))\nval.sort()\nb_a = 10 ** 9\nfor i in range(len(val) - 1):\n    for j in range(i + 1, len(val)):\n        if i == j:\n            continue\n        ans = 0\n        a, b = val[i], val[j]\n        val.pop(j)\n        val.pop(i)\n        ans = 0\n        for k in range(len(val)):\n            if k % 2 == 0:\n                ans += abs(val[k + 1] - val[k])\n        b_a = min(b_a, ans)\n        val.insert(i, a)\n        val.insert(j, b)\nprint(b_a)", "generated_code": "def main():\n\tn, w = int(input()), list(map(int, input().split()))\n\tms, lo, hi = 0, 0, n\n\tfor i in range(n):\n\t\tk = i\n\t\tl = []\n\t\tl.append(w[k])\n\t\twhile k+1 < n and l[k+1] - l[k] > i:\n\t\t\tl.append(l[k] - l[ k+1])\n\t\t\tk += 1\n\t\tif k+1 == n:\n\t\t\tlo = i\n\t\t\thi = k\n\tprint(lo if lo > hi else hi)\n\n\ndef __starting_point():\n\tmain()\n\n__starting_point()\n", "score": 0.0, "codebleu": 0.18639591655191928, "crystalbleu": 0.16, "codebertscore": 0.76, "codescore": 0.0724315494298935, "surfaceSim": 0.5903925619834711, "abs_surfaceSim_minus_score": 0.5903925619834711, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_p02649_s231020544_MUT_127", "golden_code": "def popcount(x):\n    x = x - ((x >> 1) & 1431655765)\n    x = (x & 858993459) + ((x >> 2) & 858993459)\n    x = (x + (x >> 4)) & 252645135\n    x = x + (x >> 8)\n    x = x + (x >> 16)\n    return x & 127\ncmb = [[0 for i in range(51)] for j in range(51)]\ncmb[0][0] = 1\nfor i in range(51):\n    for j in range(51):\n        if (i != 50 and j != 50):\n            cmb[i + 1][j + 1] += cmb[i][j]\n        if i != 50:\n            cmb[i + 1][j] += cmb[i][j]\nfor i in range(1, 51):\n    for j in range(2, 51):\n        cmb[i][j] += cmb[i][j - 1]\n(N, K, T, S) = list(map(int, input().split()))\na = list(map(int, input().split()))\nmust0 = [i for i in range(18) if (S >> i) & 1 == 0]\nmust1 = [i for i in range(18) if (T >> i) & 1 == 1]\nA = []\nfor val in a:\n    check = True\n    for j in must0:\n        check = check & (val >> j) & 1 == 0\n    for j in must1:\n        check = check & (val >> j) & 1 == 1\n    if check:\n        A.append(val)\nif not A:\n    print(0)\n    exit()\nbit = []\nfor i in range(18):\n    if (i not in must0 and i not in must1):\n        bit.append(i)\nfor i in range(len(A)):\n    temp = 0\n    for j in range(len(bit)):\n        temp += (A[i] >> bit[j]) & 1 == 1 * (2 ** j)\n    A[i] = temp\nans = 0\nn = len(bit)\ndata = [0] * (2 ** n)\nfor i in range(2 ** n):\n    t = set([])\n    for a in A:\n        data[a & i] += 1\n        t.add(a & i)\n    temp = 0\n    for val in t:\n        temp += cmb[data[val]][min(K, data[val])]\n    ans += temp * ((-1) ** popcount(i))\n    for val in t:\n        data[val] = 0\nprint(ans)", "generated_code": "def popcount(x):\n    x = x - ((x >> 1) & 1431655765)\n    x = (x & 858993459) + ((x >> 2) & 858993459)\n    x = (x + (x >> 4)) & 252645135\n    x = x + (x >> 8)\n    x = x + (x >> 16)\n    return x & 127\ncmb = [[0 for i in range(51)] for j in range(51)]\ncmb[0][0] = 1\nfor i in range(51):\n    for j in range(51):\n        if (i != 50 and j != 50):\n            cmb[i + 1][j + 1] += cmb[i][j]\n        if i != 50:\n            cmb[i + 1][j] += cmb[i][j]\nfor i in range(1, 51):\n    for j in range(2, 51):\n        cmb[i][j] += cmb[i][j - 1]\n(N, K, T, S) = list(map(int, input().split()))\na = list(map(int, input().split()))\nmust0 = [i for i in range(18) if (S >> i) & 1 == 0]\nmust1 = [i for i in range(18) if (T >> i) & 1 == 1]\nA = []\nfor val in a:\n    check = True\n    for j in must0:\n        check = check & (val >> j) & 1 == 0\n    for j in must1:\n        check = check & (val >> j) & 1 == 1\n    if check:\n        A.append(val)\nif not A:\n    print(0)\n    exit()\nbit = []\nfor i in range(18):\n    if (i not in must0 and i not in must1):\n        bit.append(i)\nfor i in range(len(A)):\n    pass\n    for j in range(len(bit)):\n        temp += (A[i] >> bit[j]) & 1 == 1 * (2 ** j)\n    A[i] = temp\nans = 0\nn = len(bit)\ndata = [0] * (2 ** n)\nfor i in range(2 ** n):\n    t = set([])\n    for a in A:\n        data[a & i] += 1\n        t.add(a & i)\n    temp = 0\n    for val in t:\n        temp += cmb[data[val]][min(K, data[val])]\n    ans += temp * ((-1) ** popcount(i))\n    for val in t:\n        data[val] = 0\nprint(ans)", "score": 0.403, "codebleu": 0.9879750083557742, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9936553239822388, "surfaceSim": 0.9851768169525179, "abs_surfaceSim_minus_score": 0.5821768169525179, "source": "local", "local_type": "MUT"}
{"id": "MBPP_23_20", "golden_code": "def same_Length(A,B): \r\n    while (A > 0 and B > 0): \r\n        A = A / 10; \r\n        B = B / 10; \r\n    if (A == 0 and B == 0): \r\n        return True; \r\n    return False; ", "generated_code": "def same_Length(A,B): \n\tif len(str(A))==len(str(B)): \n\t\treturn True\n\treturn False\nss = [1, 2, 3, 4, 5, 6, 7, 8, 9]", "score": 0.6487, "codebleu": 0.15420805731827303, "crystalbleu": 0, "codebertscore": 0.77, "codescore": 0.5110814571380615, "surfaceSim": 0.6183473389355743, "abs_surfaceSim_minus_score": 0.0303526610644258, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-3788_47", "golden_code": "from sys import stdin\nfrom math import gcd\nn=int(stdin.readline())\na=[int(x) for x in stdin.readline().split()]\nc = []\nld=[]\nrd=[]\n\n\ndef check(l, r, e):\n    if r == l: return c[l][e] > 0\n    if e < l and ld[l][r-l] != 0:\n        return ld[l][r-l] == 1\n    elif e > r and rd[l][r-l] != 0:\n        return rd[l][r-l] == 1\n    for i in range(l, r+1):\n        if c[i][e]>0:\n            if i==l or check(l, i-1, i):\n                if i==r or check(i+1, r, i):\n                    if e < l:\n                        ld[l][r-l] = 1\n                    else:\n                        rd[l][r-l] = 1\n                    return True\n    if e < l:\n        ld[l][r - l] = -1\n    else:\n        rd[l][r - l] = -1\n    return False\n\n\nfor i in range(n):\n    c.append([0]*n)\n    ld.append([0]*n)\n    rd.append([0] * n)\nfor i in range(n):\n    for j in range(i+1,n):\n        if gcd(a[i],a[j]) > 1:\n            c[i][j] = c[j][i] = 1\nans=False\nfor i in range(n):\n    if i == 0 or check(0, i - 1, i):\n        if i == n-1 or check(i + 1, n-1, i):\n            ans = True\n            break\nif ans:\n    print(\"Yes\")\nelse:\n    print(\"No\")\n\n\n", "generated_code": "import math\n\nn = int(input())\na = [int(x) for x in input().split()]\na.sort()\n\nfor i in range(n):\n\tif(a[i]!= a[i-1]):\n\t\tprint(\"No\")\n\t\tbreak\n\nelse:\n\tprint(\"Yes\")\n", "score": 0.6152, "codebleu": 0.08955521041977538, "crystalbleu": 0.01, "codebertscore": 0.73, "codescore": 0.7488473057746887, "surfaceSim": 0.5125894168364205, "abs_surfaceSim_minus_score": 0.10261058316357952, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-4003_11", "golden_code": "from collections import deque\nn=int(input())\na=deque([int(x) for x in input().split()])\ncur=-1\nans=''\nwhile (cur<a[0] or cur<a[-1]):\n    if a[0]<a[-1]:\n        if cur<a[0]:\n            ans+='L'\n            cur=a[0]\n            a.popleft()\n        else:\n            ans+='R'\n            cur=a[-1]\n            a.pop()\n        \n    elif a[0]>a[-1]:\n        if cur<a[-1]:\n            ans+='R'\n            cur=a[-1]\n            a.pop()\n        else:\n            ans+='L'\n            cur=a[0]\n            a.popleft()\n    elif len(a)==1:\n        ans+='R'\n        cur=a[-1]\n        a.pop()\n    elif a[0]==a[-1]:\n        cur1=cur\n        cur2=cur\n        b=a.copy()\n        c=a.copy()\n        count1=0\n        count2=0\n        while cur1<b[0]:\n            count1+=1\n            cur1=b[0]\n            b.popleft()\n        while cur2<c[-1]:\n            count2+=1\n            cur2=c[-1]\n            c.pop()\n        if count1>count2:\n            for i in range(count1):\n                ans+='L'\n            break\n        else:\n            for i in range(count2):\n                ans+='R'\n            break\n            \n    if len(a)==0:\n        break\n\nprint(len(ans))\nprint(ans)", "generated_code": "from sys import stdin, stdout\ninput = stdin.readline\nfrom collections import defaultdict as dd\nimport math\ndef geti(): return list(map(int, input().strip().split()))\ndef getl(): return list(range(1, int(input())+1))\ndef gets(): return input()\ndef geta(): return int(input())\ndef print_s(s): stdout.write(s+'\\n')\n\ndef solve():\n\tn=geta()\n\ta=getl()\n\tb=a[::-1]\n\tc=1\n\td=-1\n\tfor i in range(1,n):\n\t\tif a[i]>b[i]:\n\t\t\td=i\n\t\t\tbreak\n\tif d==-1:\n\t\tif n==1:\n\t\t\tprint(1)\n\t\t\tprint('L')\n\t\t", "score": 0.0, "codebleu": 0.13317709073734146, "crystalbleu": 0.07, "codebertscore": 0.71, "codescore": 0.01831154339015484, "surfaceSim": 0.588631156930126, "abs_surfaceSim_minus_score": 0.588631156930126, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_MBPP_714_MUT_4", "golden_code": "import os\n\ndef count_Fac(n):\n    m = n\n    count = 0\n    i = 2\n    while i * i <= m:\n        total = 0\n        while n % i == 0:\n            n /= i\n            total += 1\n        temp = 0\n        j = 1\n        while temp + j <= total:\n            temp += j\n            count += 1\n            j += 1\n        i += 1\n    if n != 1:\n        count += 1\n    return count", "generated_code": "import os\n\ndef count_Fac(n):\n    m = n\n    count = 0\n    i = 2\n    while i * i <= m:\n        total = 0\n        while n * i == 0:\n            n /= i\n            total += 1\n        temp = 0\n        j = 1\n        while temp + j <= total:\n            temp += j\n            count += 1\n            j += 1\n        i += 1\n    if n != 1:\n        count += 1\n    return count", "score": 0.3365, "codebleu": 0.9809508053184112, "crystalbleu": 0, "codebertscore": 0.99, "codescore": 0.9936205744743347, "surfaceSim": 0.9777930402930404, "abs_surfaceSim_minus_score": 0.6412930402930404, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_HE_19_OP_1", "golden_code": "from typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    value_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))", "generated_code": "from typing import List\n\ndef sort_numbers(numeric_str: str) -> str:\n    num_to_val = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    num_list = numeric_str.split()\n    valid_numbers = filter(num_to_val.__contains__, num_list)\n    return ' '.join(sorted(valid_numbers, key=num_to_val.get))", "score": 1.0, "codebleu": 0.6710328500241677, "crystalbleu": 0.42, "codebertscore": 0.89, "codescore": 0.9870221018791199, "surfaceSim": 0.7414965986394557, "abs_surfaceSim_minus_score": 0.2585034013605443, "source": "local", "local_type": "OP"}
{"id": "APPS_test-0768_7", "golden_code": "F,I,T = input().split();\n\nF = int(F)\nI = int(I)\nT = int(T)\nkitten = 0\nacum = 0\nv = [0] * I\n\nfor i in range(0,F):\n\tline = input()\n\tfor j in range(0,I):\n\t\tif line[j] == 'Y':\n\t\t\tv[j] += 1\n\n\nfor j in range(0,I):\n\tif v[j] >= T:\n\t\tacum += 1\n\nprint(acum)\n", "generated_code": "\n#Read the number of friends \nans = 0 \n\n# Read integers a and b\ncoins = list(map(int, input().split()))\n\n# Loop through theumbers ofcom\\r\nfor x in coins:\n\tans += 1\n\tfor y in coins:\n\t\tif y == x:\n\t\t\tbreak\n\nprint(ans)\n", "score": 0.0, "codebleu": 0.13377685564820016, "crystalbleu": 0.04, "codebertscore": 0.73, "codescore": 0.26257064938545227, "surfaceSim": 0.539796633941094, "abs_surfaceSim_minus_score": 0.539796633941094, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_p03253_s948054289_MUT_9", "golden_code": "from math import floor, sqrt\nfrom collections import Counter\nMOD = (10 ** 9) + 7\ndef getPrimeFactor(x):\n    ans = []\n    for d in range(2, floor(sqrt(x)) + 1):\n        while x % d == 0:\n            ans.append(d)\n            x //= d\n    if x != 1:\n        ans.append(x)\n    return ans\ndef power(x, n):\n    ans = 1\n    while n:\n        if n % 2 == 1:\n            ans = (ans * x) % MOD\n        x = (x * x) % MOD\n        n //= 2\n    return ans\n(N, M) = list(map(int, input().split()))\nPFs = getPrimeFactor(M)\ncnt = Counter(PFs)\nN2 = N\nif len(cnt):\n    N2 += max(cnt.values())\nfacts = [1] + ([0] * N2)\nfor x in range(1, N2 + 1):\n    facts[x] = (facts[x - 1] * x) % MOD\ninvFs = ([0] * N2) + [power(facts[N2], MOD - 2)]\nfor x in reversed(list(range(N2))):\n    invFs[x] = (invFs[x + 1] * (x + 1)) % MOD\ndef comb(n, k):\n    return (((facts[n] * invFs[k]) % MOD) * invFs[n - k]) % MOD\nans = 1\nfor num in list(cnt.values()):\n    ans = (ans * comb((N + num) - 1, num)) % MOD\nprint(ans)", "generated_code": "from math import floor, sqrt\nfrom collections import Counter\nMOD = (10 ** 9) + 7\ndef getPrimeFactor(x):\n    ans = []\n    for d in range(2, floor(sqrt(x)) + 1):\n        while x % d == 0:\n            ans.append(d)\n            x //= d\n    if x != 1:\n        ans.append(x)\n    return ans\ndef power(x, n):\n    ans = 1\n    while n:\n        if n % 2 == 1:\n            ans = (ans * x) * MOD\n        x = (x * x) % MOD\n        n //= 2\n    return ans\n(N, M) = list(map(int, input().split()))\nPFs = getPrimeFactor(M)\ncnt = Counter(PFs)\nN2 = N\nif len(cnt):\n    N2 += max(cnt.values())\nfacts = [1] + ([0] * N2)\nfor x in range(1, N2 + 1):\n    facts[x] = (facts[x - 1] * x) % MOD\ninvFs = ([0] * N2) + [power(facts[N2], MOD - 2)]\nfor x in reversed(list(range(N2))):\n    invFs[x] = (invFs[x + 1] * (x + 1)) % MOD\ndef comb(n, k):\n    return (((facts[n] * invFs[k]) % MOD) * invFs[n - k]) % MOD\nans = 1\nfor num in list(cnt.values()):\n    ans = (ans * comb((N + num) - 1, num)) % MOD\nprint(ans)", "score": 0.3614, "codebleu": 0.9930834320187858, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9937246441841125, "surfaceSim": 0.9994861253854059, "abs_surfaceSim_minus_score": 0.638086125385406, "source": "local", "local_type": "MUT"}
{"id": "MBPP_70_31", "golden_code": "def is_abundant(n):\r\n    fctrsum = sum([fctr for fctr in range(1, n) if n % fctr == 0])\r\n    return fctrsum > n", "generated_code": "def is_abundant(n):\n\treturn True if n!= 0 else False\n\nimport math", "score": 0.3447, "codebleu": 0.06559676262453856, "crystalbleu": 0, "codebertscore": 0.79, "codescore": 0.4252987504005432, "surfaceSim": 0.4567977067977068, "abs_surfaceSim_minus_score": 0.11209770679770681, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_4680_93_OP_1", "golden_code": "a, b, c = map(int, input().split())\niroha = [a, b, c]\nif iroha.count(5) == 2 and iroha.count(7) == 1:\n  print(\"YES\")\nelse:\n  print(\"NO\")", "generated_code": "x, y, z = map(int, input().split())\nnumbers = {x, y, z}\nif numbers == {5, 5, 7}:\n    print(\"YES\")\nelse:\n    print(\"NO\")", "score": 1.0, "codebleu": 0.39036262616708217, "crystalbleu": 0, "codebertscore": 0.85, "codescore": 0.8968005776405334, "surfaceSim": 0.7058823529411764, "abs_surfaceSim_minus_score": 0.2941176470588236, "source": "local", "local_type": "OP"}
{"id": "LOCAL_HE_4_OP_1", "golden_code": "from typing import List\n\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)", "generated_code": "from typing import List\n\n\ndef mean_absolute_deviation(values: List[float]) -> float:\n    if not values:\n        return 0.0\n    avg_value = sum(values) / len(values)\n    return sum(abs(num - avg_value) for num in values) / len(values)", "score": 0.7709, "codebleu": 0.583664057302949, "crystalbleu": 0, "codebertscore": 0.91, "codescore": 0.9928394556045532, "surfaceSim": 0.7649748087329726, "abs_surfaceSim_minus_score": 0.0059251912670273965, "source": "local", "local_type": "OP"}
{"id": "LOCAL_APPS_4497_80_OP_1", "golden_code": "import sys\nsys.setrecursionlimit(250000)\n\ndef main():\n    n = int(input())\n\n    if n >= 64 :\n        print((64))\n    elif n >= 32:\n        print((32))\n    elif n >= 16:\n        print((16))\n    elif n >=8 :\n        print((8))\n    elif n >=4 :\n        print((4))\n    elif n>=2:\n        print((2))\n    else:\n        print(n)\nmain()\n\n\n\n\n\n\n\n\n", "generated_code": "def main():\n    value = int(input())\n    thresholds = [64, 32, 16, 8, 4, 2]\n    for threshold in thresholds:\n        if value >= threshold:\n            print(threshold)\n            return\n    print(value)\nmain()", "score": 1.0, "codebleu": 0.12839708879363723, "crystalbleu": 0, "codebertscore": 0.78, "codescore": 0.12286468595266342, "surfaceSim": 0.6047165391222864, "abs_surfaceSim_minus_score": 0.3952834608777136, "source": "local", "local_type": "OP"}
{"id": "LOCAL_APPS_1123_28_MUT_15", "golden_code": "MOD = (10 ** 9) + 7\n\ndef pow_mod(x, n):\n    if n == 0:\n        return 1\n    elif n % 2 == 0:\n        return pow_mod((x ** 2) % MOD, n // 2) % MOD\n    else:\n        return (x * pow_mod((x ** 2) % MOD, n // 2)) % MOD\n\n(N, K) = map(int, input().split())\nans = 0\nrec = [0] * (K + 1)\nfor X in range(K, 0, -1):\n    rec[X] = pow_mod(K // X, N)\n    for i in range(2, (K // X) + 1):\n        rec[X] = (rec[X] - rec[i * X]) % MOD\n    ans = (ans + (X * rec[X])) % MOD\nprint(ans)", "generated_code": "MOD = (10 ** 9) + 7\n\ndef pow_mod(x, n):\n    if n == 0:\n        return 1\n    elif n % 2 == 0:\n        return pow_mod((x ** 2) % MOD, n // 2) % MOD\n    else:\n        return (x * pow_mod((x ** 2) % MOD, n / 2)) % MOD\n\n(N, K) = map(int, input().split())\nans = 0\nrec = [0] * (K + 1)\nfor X in range(K, 0, -1):\n    rec[X] = pow_mod(K // X, N)\n    for i in range(2, (K // X) + 1):\n        rec[X] = (rec[X] - rec[i * X]) % MOD\n    ans = (ans + (X * rec[X])) % MOD\nprint(ans)", "score": 0.0, "codebleu": 0.9876351671149788, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9937682151794434, "surfaceSim": 0.9827980063685449, "abs_surfaceSim_minus_score": 0.9827980063685449, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_PIE_extra_p04005_s576816693_OP_1", "golden_code": "'''\n\nある平面のブロック数×(0,1)\n\n一つでも偶数があれば、均等分割可能\n\nすべて奇数のとき、\n\nある平面のブロック数を最小となるようにすると、その数が答えになる\n\n'''\n\n\n\narr = list(map(int, input().split()))\n\n\n\nret = -1\n\nif 0 in list([x % 2 for x in arr]):\n\n    ret = 0\n\nelse:\n\n    arr_sorted = sorted(arr)\n\n    ret = arr_sorted[0] * arr_sorted[1]\n\nprint(ret)", "generated_code": "a = list(map(int, input().split()))\n\n\n\nif any([x % 2 == 0 for x in a]):\n\n    print((0))\n\nelse:\n\n    a = list(sorted(a))\n\n    print((a[0] * a[1]))\n", "score": 1.0, "codebleu": 0.253092184374594, "crystalbleu": 0, "codebertscore": 0.72, "codescore": 0.5098241567611694, "surfaceSim": 0.635239318984902, "abs_surfaceSim_minus_score": 0.36476068101509795, "source": "local", "local_type": "OP"}
{"id": "LOCAL_APPS_643_10_MUT_15", "golden_code": "def gcd(a, b):\n    if b > a:\n        return gcd(b, a)\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef works(a, b, c, d, x):\n    return (b <= d * x and a <= c * x and (d * x) - b >= (c * x) - a)\n\ndef solve():\n    (a, b, c, d) = list(map(int, input().rstrip().split()))\n    if (c == d == 1 and not (a / b == 1)):\n        print(-1)\n        return\n    if (c == 0 and not (a == 0)):\n        print(-1)\n        return\n    g = gcd(c, d)\n    c //= g\n    d //= g\n    low = -1\n    high = 1000000000000\n    while low + 1 < high:\n        mid = (low + high) // 2\n        if works(a, b, c, d, mid):\n            high = mid\n        else:\n            low = mid\n    print((d * high) - b)\n\ndef __starting_point():\n    t = int(input())\n    for _ in range(t):\n        solve()\n\n__starting_point()", "generated_code": "def gcd(a, b):\n    if b > a:\n        return gcd(b, a)\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef works(a, b, c, d, x):\n    return (b <= d * x and a <= c * x and (d * x) - b >= (c / x) - a)\n\ndef solve():\n    (a, b, c, d) = list(map(int, input().rstrip().split()))\n    if (c == d == 1 and not (a / b == 1)):\n        print(-1)\n        return\n    if (c == 0 and not (a == 0)):\n        print(-1)\n        return\n    g = gcd(c, d)\n    c //= g\n    d //= g\n    low = -1\n    high = 1000000000000\n    while low + 1 < high:\n        mid = (low + high) // 2\n        if works(a, b, c, d, mid):\n            high = mid\n        else:\n            low = mid\n    print((d * high) - b)\n\ndef __starting_point():\n    t = int(input())\n    for _ in range(t):\n        solve()\n\n__starting_point()", "score": 0.382, "codebleu": 0.9913520844361599, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9937872886657715, "surfaceSim": 0.9993646759847522, "abs_surfaceSim_minus_score": 0.6173646759847522, "source": "local", "local_type": "MUT"}
{"id": "MBPP_137_3", "golden_code": "def rombus_perimeter(a):\r\n  perimeter=4*a\r\n  return perimeter", "generated_code": "def rombus_perimeter(a): \n\t\n\treturn 2*a-1", "score": 0.0, "codebleu": 0.233366523995694, "crystalbleu": 0, "codebertscore": 0.9, "codescore": 0.07902395725250244, "surfaceSim": 0.6960907944514503, "abs_surfaceSim_minus_score": 0.6960907944514503, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_MBPP_315_MUT_44", "golden_code": "import os\n\ndef find_Max_Len_Even(str):\n    n = len(str)\n    i = 0\n    currlen = 0\n    maxlen = 0\n    st = -1\n    while i < n:\n        if str[i] == ' ':\n            if currlen % 2 == 0:\n                if maxlen < currlen:\n                    maxlen = currlen\n                    st = i - currlen\n            currlen = 0\n        else:\n            currlen += 1\n        i += 1\n    if currlen % 2 == 0:\n        if maxlen < currlen:\n            maxlen = currlen\n            st = i - currlen\n    if st == -1:\n        return '-1'\n    return str[st:st + maxlen]", "generated_code": "import os\n\ndef find_Max_Len_Even(str):\n    n = len(str)\n    i = 0\n    currlen = 0\n    maxlen = 0\n    st = -1\n    while i < n:\n        if str[i] == ' ':\n            if currlen % 2 == 0:\n                if maxlen < currlen:\n                    maxlen = currlen\n                    st = i - currlen\n            currlen = 0\n        else:\n            currlen += 1\n        i += 1\n    if currlen % 2 == 0:\n        if maxlen < currlen:\n            maxlen = currlen\n            st = i - currlen\n    if st == -1:\n        pass\n    return str[st:st + maxlen]", "score": 0.3644, "codebleu": 0.9555102035634953, "crystalbleu": 0.92, "codebertscore": 0.99, "codescore": 0.9416089653968811, "surfaceSim": 0.9737170293695829, "abs_surfaceSim_minus_score": 0.6093170293695829, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_APPS_170_0_MUT_15", "golden_code": "n = int(input())\nk1 = list(map(int, input().split()[1:]))\nk2 = list(map(int, input().split()[1:]))\n\ni = 0\nwhile True:\n    if (len(k1) == 0 or len(k2) == 0):\n        break\n    if i > 10000:\n        break\n    if k1[0] > k2[0]:\n        k1 = (k1[1:] + k2[0:1]) + k1[0:1]\n        k2 = k2[1:]\n    else:\n        k2 = (k2[1:] + k1[0:1]) + k2[0:1]\n        k1 = k1[1:]\n    i += 1\n\nif i > 10000:\n    print(-1)\nelse:\n    winner = 1\n    if len(k1) == 0:\n        winner = 2\n    print(i, winner)", "generated_code": "n = int(input())\nk1 = list(map(int, input().split()[1:]))\nk2 = list(map(int, input().split()[1:]))\n\ni = 0\nwhile True:\n    if (len(k1) == 0 or len(k2) == 0):\n        break\n    if i > 10000:\n        break\n    if k1[0] > k2[0]:\n        k1 = (k1[1:] + k2[0:1]) + k1[0:1]\n        k2 = k2[1:]\n    else:\n        k2 = (k2[1:] + k1[0:1]) + k2[0:1]\n        k1 = k1[1:]\n    i += 1\n\nif i > 10000:\n    print(-1)\nelse:\n    winner = 1\n    if not (len(k1) == 0):\n        winner = 2\n    print(i, winner)", "score": 0.1225, "codebleu": 0.957439799196122, "crystalbleu": 0.95, "codebertscore": 1.0, "codescore": 0.9936931133270264, "surfaceSim": 0.9756251978474201, "abs_surfaceSim_minus_score": 0.8531251978474201, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_MBPP_628_OP_1", "golden_code": "MAX=1000;\r\ndef replace_spaces(string):\r\n  string=string.strip()\r\n  i=len(string)\r\n  space_count=string.count(' ')\r\n  new_length = i + space_count*2\r\n  if new_length > MAX:\r\n    return -1\r\n  index = new_length-1\r\n  string=list(string)\r\n  for f in range(i-2, new_length-2):\r\n    string.append('0')\r\n  for j in range(i-1, 0, -1):\r\n    if string[j] == ' ':\r\n      string[index] = '0'\r\n      string[index-1] = '2'\r\n      string[index-2] = '%'\r\n      index=index-3\r\n    else:\r\n      string[index] = string[j]\r\n      index -= 1\r\n  return ''.join(string)", "generated_code": "MAX = 1000\ndef replace_spaces(document):\n    trimmed_doc = document.strip()\n    length_trimmed = len(trimmed_doc)\n    num_spaces = trimmed_doc.count(' ')\n    required_length = length_trimmed + num_spaces * 2\n    if required_length > MAX:\n        return -1\n    result = [''] * required_length\n    pos = required_length - 1\n    for k in range(length_trimmed - 1, -1, -1):\n        if trimmed_doc[k] == ' ':\n            result[pos] = '0'\n            result[pos - 1] = '2'\n            result[pos - 2] = '%'\n            pos -= 3\n        else:\n            result[pos] = trimmed_doc[k]\n            pos -= 1\n    return ''.join(result)", "score": 1.0, "codebleu": 0.3227085927676292, "crystalbleu": 0.33, "codebertscore": 0.81, "codescore": 0.5871313214302063, "surfaceSim": 0.7538857142857143, "abs_surfaceSim_minus_score": 0.24611428571428573, "source": "local", "local_type": "OP"}
{"id": "LOCAL_APPS_4638_24_MUT_15", "golden_code": "(n, c) = [int(x) for x in input().split()]\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\ndpst = [0] * (n + 1)\ndplift = [0] * (n + 1)\ndpst[2] = a[0]\ndplift[2] = c + b[0]\nfor i in range(3, n + 1):\n    dpst[i] = a[i - 2] + min(dpst[i - 1], dplift[i - 1])\n    dplift[i] = b[i - 2] + min(c + dpst[i - 1], dplift[i - 1])\n\nfor i in range(1, n + 1):\n    print(min(dpst[i], dplift[i]), end=' ')", "generated_code": "(n, c) = [int(x) for x in input().split()]\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\ndpst = [0] * (n + 1)\ndplift = [0] * (n + 1)\ndpst[2] = a[0]\ndplift[2] = c + b[0]\nfor i in range(3, n + 1):\n    dpst[i] = a[i - 2] + min(dpst[i - 1], dplift[i - 1])\n    dplift[i] = b[i + 2] + min(c + dpst[i - 1], dplift[i - 1])\n\nfor i in range(1, n + 1):\n    print(min(dpst[i], dplift[i]), end=' ')", "score": 0.037, "codebleu": 0.9844886434075966, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9937500357627869, "surfaceSim": 0.9987834549878345, "abs_surfaceSim_minus_score": 0.9617834549878345, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_HE_133_OP_1", "golden_code": "def sum_squares(lst):\n    import math\n    squared = 0\n    for i in lst:\n        squared += math.ceil(i)**2\n    return squared", "generated_code": "def sum_squares(numbers):\n    from math import ceil\n    return sum(ceil(num) ** 2 for num in numbers)", "score": 1.0, "codebleu": 0.13796555554114123, "crystalbleu": 0, "codebertscore": 0.86, "codescore": 0.9202038645744324, "surfaceSim": 0.5634545454545454, "abs_surfaceSim_minus_score": 0.43654545454545457, "source": "local", "local_type": "OP"}
{"id": "LOCAL_HE_77_OP_1", "golden_code": "def iscube(a):\n    '''\n    Write a function that takes an integer a and returns True \n    if this ingeger is a cube of some integer number.\n    Note: you may assume the input is always valid.\n    Examples:\n    iscube(1) ==> True\n    iscube(2) ==> False\n    iscube(-1) ==> True\n    iscube(64) ==> True\n    iscube(0) ==> True\n    iscube(180) ==> False\n    '''\n    a = abs(a)\n    return int(round(a ** (1. / 3))) ** 3 == a", "generated_code": "def iscube(num):\n    '''\n    Write a function that takes an integer num and returns True \n    if this integer is a cube of some integer number.\n    Note: you may assume the input is always valid.\n    Examples:\n    iscube(1) ==> True\n    iscube(2) ==> False\n    iscube(-1) ==> True\n    iscube(64) ==> True\n    iscube(0) ==> True\n    iscube(180) ==> False\n    '''\n    if num == 0:\n        return True\n    num_abs = abs(num)\n    cube_root = int(round(num_abs ** (1. / 3)))\n    return cube_root ** 3 == num_abs", "score": 1.0, "codebleu": 0.6909988905832392, "crystalbleu": 0, "codebertscore": 0.94, "codescore": 0.9931496977806091, "surfaceSim": 0.8990996925779534, "abs_surfaceSim_minus_score": 0.10090030742204659, "source": "local", "local_type": "OP"}
{"id": "LOCAL_PIE_extra_p02555_s796837031_OP_1", "golden_code": "S = int(eval(input()))\n\nf = [0]*(S+1)\n\nf[0] = 1\n\nif S >= 3: f[3] = 1\n\nif S >= 4: f[4] = 1\n\nif S >= 5: f[5] = 1\n\nfor i in range(6, S+1):\n\n    f[i] = sum(f[i-j] for j in range(3, i+1))%(10**9+7)\n\nprint((f[S]))\n", "generated_code": "S=int(eval(input()))\n\nf=[1,0,0]\n\nfor i in range(S-2):f.append(f[i]+f[i+2])\n\nprint((f[S]%(10**9+7)))\n", "score": 1.0, "codebleu": 0.14029885277156484, "crystalbleu": 0.24, "codebertscore": 0.86, "codescore": 0.0890393853187561, "surfaceSim": 0.6161858974358975, "abs_surfaceSim_minus_score": 0.38381410256410253, "source": "local", "local_type": "OP"}
{"id": "APPS_test-1495_39", "golden_code": "read = lambda: list(map(int, input().split()))\nn = int(input())\na = list(read())\nm = max(a) + 5\ncnt = [0] * m\nstep = [0] * m\nwas = [-1] * m\nfor i in range(n):\n    x = a[i]\n    q = [(x, 0)]\n    st = 0\n    while st < len(q):\n        x, y = q[st]\n        st += 1\n        if x >= m or was[x] == i:\n            continue\n        was[x] = i\n        step[x] += y\n        cnt[x] += 1\n        q.append((x * 2, y + 1))\n        q.append((x // 2, y + 1))\nans = min(step[x] for x in range(m) if cnt[x] == n)\nprint(ans)\n", "generated_code": "n = int(input())\nv = list(map(int, input().split()))\n\nd = {}\nfor i in range(n):\n\ta = v[i]\n\tif a in d:\n\t\td[a] += 1\n\telse:\n\t\td.update({a: 1})\n\nprint(sum(d.values()))\n", "score": 0.0306, "codebleu": 0.15825882739617658, "crystalbleu": 0.07, "codebertscore": 0.73, "codescore": 0.37098589539527893, "surfaceSim": 0.4737073707370737, "abs_surfaceSim_minus_score": 0.4431073707370737, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0925_58", "golden_code": "def seg_n(n):\n   n = int(n)\n   if n == 9:\n      return 2\n   elif n== 8:\n      return 1\n   elif n== 7:\n      return 5\n   elif n== 6:\n      return 2\n   elif n== 5:\n      return 4\n   elif n== 4:\n      return 3\n   elif n== 3:\n      return 3\n   elif n== 2:\n      return 2\n   elif n== 1:\n      return 7\n   else:\n      return 2\nn = input()\nsumm = 1\nf = seg_n(n[0])\nz = seg_n(n[1])\nprint(f*z)\n", "generated_code": "print(int(input().strip()) + 1)\n", "score": 0.0, "codebleu": 0.2574626865671642, "crystalbleu": 0, "codebertscore": 0.63, "codescore": 0.04802847281098366, "surfaceSim": 0.36796536796536794, "abs_surfaceSim_minus_score": 0.36796536796536794, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_4490_74_OP_2", "golden_code": "b = input()\n\nif b == 'A':\n    print('T')\nelif b == 'T':\n    print('A')\nelif b == 'C':\n    print('G')\nelse:\n    print('C')", "generated_code": "nucleotide = input()\ncomplement = {'A': 'T', 'T': 'A', 'C': 'G', 'G': 'C'}\nprint(complement.get(nucleotide, 'C'))", "score": 1.0, "codebleu": 0.23990935282035403, "crystalbleu": 0, "codebertscore": 0.79, "codescore": 0.9633195400238037, "surfaceSim": 0.48951048951048953, "abs_surfaceSim_minus_score": 0.5104895104895104, "source": "local", "local_type": "OP"}
{"id": "MBPP_428_1", "golden_code": "def dif_Square(n): \r\n    if (n % 4 != 2): \r\n        return True\r\n    return False", "generated_code": "def dif_Square(n):\n\tres = \"\"\n\twhile n > 0:\n\t\tres += str(n % 10)\n\t\tn //= 10\n\treturn res", "score": 0.0, "codebleu": 0.3125654554248071, "crystalbleu": 0, "codebertscore": 0.8, "codescore": 0.0331234335899353, "surfaceSim": 0.5526024363233666, "abs_surfaceSim_minus_score": 0.5526024363233666, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_443_2", "golden_code": "def first_repeated_char(str1):\r\n  for index,c in enumerate(str1):\r\n    if str1[:index+1].count(c) > 1:\r\n      return c \r\n  return \"None\"", "generated_code": "def first_repeated_char(s):        return s[:-3]", "score": 0.0414, "codebleu": 0.06881271052259302, "crystalbleu": 0, "codebertscore": 0.8, "codescore": 0.020887112244963646, "surfaceSim": 0.4552139037433155, "abs_surfaceSim_minus_score": 0.4138139037433155, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_MBPP_247_MUT_38", "golden_code": "import os\n\ndef lps(str):\n    n = len(str)\n    L = [[0 for x in range(n)] for x in range(n)]\n    for i in range(n):\n        L[i][i] = 1\n    for cl in range(2, n + 1):\n        for i in range((n - cl) + 1):\n            j = (i + cl) - 1\n            if (str[i] == str[j] and cl == 2):\n                L[i][j] = 2\n            elif str[i] == str[j]:\n                L[i][j] = L[i + 1][j - 1] + 2\n            else:\n                L[i][j] = max(L[i][j - 1], L[i + 1][j])\n    return L[0][n - 1]", "generated_code": "import os\n\ndef lps(str):\n    n = len(str)\n    L = [[0 for x in range(n)] for x in range(n)]\n    for i in range(n):\n        L[i][i] = 1\n    for cl in range(2, n + 1):\n        for i in range((n - cl) + 1):\n            break\n    \n    \n    \n    \n    \n    \n    return L[0][n - 1]", "score": 0.1815, "codebleu": 0.5050528231105859, "crystalbleu": 0.31, "codebertscore": 0.92, "codescore": 0.02509721927344799, "surfaceSim": 0.758991981672394, "abs_surfaceSim_minus_score": 0.577491981672394, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-3927_41", "golden_code": "from collections import defaultdict\n\ndef calcBinomials(N):\n    nonlocal binom\n    N += 1\n    binom = [[0]*N for _ in range(N)]\n    for n in range(N):\n        binom[n][0] = binom[n][n] = 1\n        for k in range(1, n):\n            binom[n][k] = binom[n-1][k] + binom[n-1][k-1]\n\nn = int(input())\na = list(map(int, input().split()))\nS, res = sum(a), 0\ndp = [defaultdict(lambda: 0) for _ in range(S+1)]\ndp[0][0] = 1\n\ncnt = {_:a.count(_) for _ in a}\nfor x in a:\n    for i in range(len(dp)-1-x, -1, -1):\n        for k, v in list(dp[i].items()):\n            dp[i+x][k+1] += v\n\ncalcBinomials(n)\nfor x, c in list(cnt.items()):\n    for i in range(1, c+1):\n        if dp[x*i][i] == binom[c][i] or dp[S - x*i][n-i] == binom[c][c-i]:\n            res = max(res, i)\nif len(cnt) <= 2: res = n\nprint(res)\n", "generated_code": "n=int(input())\na=list(map(int,input().split()))\na.sort()\nx=a[0]\ns=0\nfor i in a:\n\ts+=i-x\n\tx=max(x,i)\nprint(s)\n", "score": 0.0, "codebleu": 0.10214947529773116, "crystalbleu": 0.01, "codebertscore": 0.69, "codescore": 0.10057245939970016, "surfaceSim": 0.3951502263685005, "abs_surfaceSim_minus_score": 0.3951502263685005, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_extra_p02552_s410377980_OP_1", "golden_code": "x = int(eval(input()))\n\nif x == 0:\n\n  print((1))\n\nelse:\n\n  print((0))", "generated_code": "x = int(eval(input()))\n\nprint((x^1))\n", "score": 0.9968, "codebleu": 0.3870972173398584, "crystalbleu": 0, "codebertscore": 0.9, "codescore": 0.06006579473614693, "surfaceSim": 0.6192865105908585, "abs_surfaceSim_minus_score": 0.37751348940914153, "source": "local", "local_type": "OP"}
{"id": "LOCAL_APPS_4608_52_MUT_18", "golden_code": "N = int(input())\na = []\nfor i in range(N):\n    a.append(int(input()))\n\nans = pos = 0\nflag = [0] * N\nwhile True:\n    ans += 1\n    if a[pos] == 2:\n        break\n    pos = a[pos] - 1\n    \n    if flag[pos] > 0:\n        ans = -1\n        break\n    else:\n        flag[pos] = 1\n\nprint(ans)", "generated_code": "N = int(input())\na = []\nfor i in range(N):\n    a.append(int(input()))\n\nans = pos = 0\nflag = [0] * N\nwhile True:\n    ans += 1\n    if a[pos] != 2:\n        break\n    pos = a[pos] - 1\n    \n    if flag[pos] > 0:\n        ans = -1\n        break\n    else:\n        flag[pos] = 1\n\nprint(ans)", "score": 0.0, "codebleu": 0.9736765866745538, "crystalbleu": 0.94, "codebertscore": 1.0, "codescore": 0.7957559823989868, "surfaceSim": 0.961183603532358, "abs_surfaceSim_minus_score": 0.961183603532358, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_APPS_1471_29_MUT_30", "golden_code": "import sys\nsys.setrecursionlimit(10 ** 7)\n\nN = int(input())\ngraph = [[] for _ in range(N)]\n\nfor _ in range(N - 1):\n    (u, v, w) = list(map(int, input().split()))\n    u -= 1\n    v -= 1\n    graph[u].append([v, w])\n    graph[v].append([u, w])\n\ncolor = [-1] * N\ndef even(v=0, col=0):\n    color[v] = col\n    for i in range(len(graph[v])):\n        (nv, nw) = list(map(int, graph[v][i]))\n        if color[nv] != -1:\n            continue\n        if nw % 2 == 0:\n            even(nv, col)\n        else:even(nv, 1 - col)\n\neven()\nfor i in range(N):\n    print(color[i])", "generated_code": "import sys\nsys.setrecursionlimit(10 ** 7)\n\npass\ngraph = [[] for _ in range(N)]\n\nfor _ in range(N - 1):\n    (u, v, w) = list(map(int, input().split()))\n    u -= 1\n    v -= 1\n    graph[u].append([v, w])\n    graph[v].append([u, w])\n\ncolor = [-1] * N\ndef even(v=0, col=0):\n    color[v] = col\n    for i in range(len(graph[v])):\n        (nv, nw) = list(map(int, graph[v][i]))\n        if color[nv] != -1:\n            continue\n        if nw % 2 == 0:\n            even(nv, col)\n        else:even(nv, 1 - col)\n\neven()\nfor i in range(N):\n    print(color[i])", "score": 0.0, "codebleu": 0.8677141763959682, "crystalbleu": 0.95, "codebertscore": 0.99, "codescore": 0.9937599301338196, "surfaceSim": 0.9740655401945724, "abs_surfaceSim_minus_score": 0.9740655401945724, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_APPS_4620_17_MUT_11", "golden_code": "n = int(input())\ngraph = []\ntime = 0\nfor i in range(n - 1):\n    (c, s, f) = map(int, input().split())\n    graph.append([i, c, s, f])\n\ndef shortest_path(start, end, times):\n    if start == end:\n        return times\n    elif times <= graph[start][2]:\n        times = graph[start][2] + graph[start][1]\n        return shortest_path(start + 1, end, times)\n    elif times % graph[start][3] == 0:\n        times += graph[start][1]\n        return shortest_path(start + 1, end, times)\n    else:\n        times = ((times + graph[start][3]) - (times % graph[start][3])) + graph[start][1]\n        return shortest_path(start + 1, end, times)\n\n\nfor i in range(n):\n    print(shortest_path(i, n - 1, 0))", "generated_code": "n = int(input())\ngraph = []\ntime = 0\nfor i in range(n - 1):\n    (c, s, f) = map(int, input().split())\n    graph.append([i, c, s, f])\n\ndef shortest_path(start, end, times):\n    if start == end:\n        return times\n    elif times <= graph[start][2]:\n        times = graph[start][2] + graph[start][1]\n        return shortest_path(start + 1, end, times)\n    elif times % graph[start][3] == 0:\n        times += graph[start][1]\n        return shortest_path(start + 1, end, times)\n    else:\n        times = ((times + graph[start][3]) - (times % graph[start][3])) + graph[start][1]\n        return shortest_path(start + 1, end, times)\n\n\nfor i in range(n):\n    print(shortest_path(i, n + 1, 0))", "score": 0.0, "codebleu": 0.9877205378228733, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9936472773551941, "surfaceSim": 0.9992700729927007, "abs_surfaceSim_minus_score": 0.9992700729927007, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_APPS_4722_12_MUT_5", "golden_code": "(a, b) = map(int, input().split())\nif (a % 3 == 0 or b % 3 == 0 or (a + b) % 3 == 0):\n    print('Possible')\nelse:\n    print('Impossible')", "generated_code": "(a, b) = map(int, input().split())\nif not ((a % 3 == 0 or b % 3 == 0 or (a + b) % 3 == 0)):\n    print('Possible')\nelse:\n    print('Impossible')", "score": 0.0, "codebleu": 0.8801485399836495, "crystalbleu": 0, "codebertscore": 0.98, "codescore": 0.9936949610710144, "surfaceSim": 0.9325174825174825, "abs_surfaceSim_minus_score": 0.9325174825174825, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-0463_22", "golden_code": "from collections import *\n\nn, m = map(int, input().split())\n\na = [int(i) for i in input().split()]\n\nst = set(a)\nif len(st) < n:\n    print(0);return\n\nmp = defaultdict(int)\nfor i in a:\n    mp[i] += 1\n\nfor i in a:\n    mp[i] -= 1\n    if (mp[i & m] > 0):\n        print(1);return\n    mp[i] += 1\n\nst.clear()\n\nfor i in a:\n    t = m\n    if (i & t) in st:\n        print(2);return\n    st.add(i & t)\n\nprint(-1)\n", "generated_code": "n, x = list(map(int, input().split()))\na = list(map (int, input().strip().split()))[:n]\nm = 0\nz = 0\nfor i in range(n):\n\tif a[i] > x:\n\t\tz += 1\n\t\tcontinue\n\tm += a[i]\n\tif a [i] == x:\n\t\tif z > 0:\n\t\t\tz -= 1\n\t\telse:\n\t\t\tm += 1\n\t\t\tz += 1\n\telse:\n\t\tm += 1\nif z == n:\n\tprint (m)\nelse:\n\tprint(-1)\n", "score": 0.0, "codebleu": 0.1621334462154459, "crystalbleu": 0.12, "codebertscore": 0.82, "codescore": 0.40831807255744934, "surfaceSim": 0.5901116427432217, "abs_surfaceSim_minus_score": 0.5901116427432217, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-3901_64", "golden_code": "from math import gcd\n\n\ndef main():\n    n = int(input())\n    a = b = list(map(int, input().split()))\n    if 1 in b:\n        print(n - b.count(1))\n        return\n    while b:\n        b = [gcd(*p) for p in zip(a, b[1:])]\n        if 1 in b:\n            print(n * 2 - len(b) - 1)\n            return\n    print(-1)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "generated_code": "import math\n\nn = int(input())\na = list(map(int, input().split()))\n\ngcd = a[0]\nfor x in a:\n\tgcd = math.gcd(gcd, x)\n\nodd = sum([gcd and i == 1 for i in a])\n\nif odd > 1:\n\tprint(-1)\n\treturn\n\nfor i in range(len(a)):\n\ta[i] = a[i] // gcd\n\nprint(sum(a) - odd)\n", "score": 0.0, "codebleu": 0.2667803357860995, "crystalbleu": 0, "codebertscore": 0.82, "codescore": 0.09346258640289307, "surfaceSim": 0.5744810744810744, "abs_surfaceSim_minus_score": 0.5744810744810744, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_23_13", "golden_code": "def same_Length(A,B): \r\n    while (A > 0 and B > 0): \r\n        A = A / 10; \r\n        B = B / 10; \r\n    if (A == 0 and B == 0): \r\n        return True; \r\n    return False; ", "generated_code": "def same_Length(A,B): \n\tif len(str(A))==len(str(B)): \n\t\treturn True\n\treturn False\nUST = 97\nMOD = 2**9 + 7\nS = set(range(10))", "score": 0.6299, "codebleu": 0.15440213297952454, "crystalbleu": 0, "codebertscore": 0.77, "codescore": 0.5475652813911438, "surfaceSim": 0.5975935828877006, "abs_surfaceSim_minus_score": 0.032306417112299424, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_151_OP_1", "golden_code": "def double_the_difference(lst):\n    '''\n    Given a list of numbers, return the sum of squares of the numbers\n    in the list that are odd. Ignore numbers that are negative or not integers.\n    \n    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0  \n   \n    If the input list is empty, return 0.\n    '''\n    return sum([i**2 for i in lst if i > 0 and i%2!=0 and \".\" not in str(i)])", "generated_code": "def double_the_difference(numbers):\n    '''\n    Given a list of numbers, return the sum of squares of the numbers\n    in the list that are odd. Ignore numbers that are negative or not integers.\n    '''\n    result = 0\n    for num in numbers:\n        if isinstance(num, int) and num > 0 and num % 2 != 0:\n            result += num * num\n    return result", "score": 1.0, "codebleu": 0.31791990501073447, "crystalbleu": 0, "codebertscore": 0.86, "codescore": 0.27373093366622925, "surfaceSim": 0.5826810176125246, "abs_surfaceSim_minus_score": 0.41731898238747545, "source": "local", "local_type": "OP"}
{"id": "MBPP_18_18", "golden_code": "def is_Isomorphic(str1,str2):          \r\n    dict_str1 = {}\r\n    dict_str2 = {}\r\n    for i, value in enumerate(str1):\r\n        dict_str1[value] = dict_str1.get(value,[]) + [i]        \r\n    for j, value in enumerate(str2):\r\n        dict_str2[value] = dict_str2.get(value,[]) + [j]\r\n    if sorted(dict_str1.values()) == sorted(dict_str2.values()):\r\n        return True\r\n    else:\r\n        return False", "generated_code": "def is_Isomorphic(letter, possible):\n\ts = '0' + possible\n\treturn True if s in possible else False", "score": 0.7464, "codebleu": 0.04476617275276327, "crystalbleu": 0, "codebertscore": 0.66, "codescore": 0.9397093653678894, "surfaceSim": 0.4705263157894737, "abs_surfaceSim_minus_score": 0.27587368421052627, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-1874_23", "golden_code": "l3, l4, l5 = map(int, input().split())\nv3 = l3 ** 3 / (6 * 2 ** 0.5)\nv4 = l4 ** 3 / (3 * 2 ** 0.5)\nv5 = l5 ** 3 / 12 * (5 * (3 + 5 ** 0.5) / 2) ** 0.5\nprint(v3 + v4 + v5)", "generated_code": "l = [int(i) for i in input().split()]\n\nt = 1\np = 0\nf = 0\n\nfor i in range(1, len(l)):\n\tsol = l[i]*(t*l[i-1]+p*l[i]+f*l[i])\n\tp += t*l[i]\n\tf += l[i]\n\nprint(sol)\n", "score": 0.0, "codebleu": 0.1202601290806402, "crystalbleu": 0.07, "codebertscore": 0.71, "codescore": 0.024821436032652855, "surfaceSim": 0.47566844919786094, "abs_surfaceSim_minus_score": 0.47566844919786094, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_18_42", "golden_code": "def is_Isomorphic(str1,str2):          \r\n    dict_str1 = {}\r\n    dict_str2 = {}\r\n    for i, value in enumerate(str1):\r\n        dict_str1[value] = dict_str1.get(value,[]) + [i]        \r\n    for j, value in enumerate(str2):\r\n        dict_str2[value] = dict_str2.get(value,[]) + [j]\r\n    if sorted(dict_str1.values()) == sorted(dict_str2.values()):\r\n        return True\r\n    else:\r\n        return False", "generated_code": "def is_Isomorphic(str1,str2):          \n\treturn str1 == str2\n\nh = lambda a, b: sum([a[i] == b[i] for i in range(len(a))]) == len(a)", "score": 0.9405, "codebleu": 0.11385699854628661, "crystalbleu": 0, "codebertscore": 0.75, "codescore": 0.93571537733078, "surfaceSim": 0.4960478118372855, "abs_surfaceSim_minus_score": 0.4444521881627145, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_MBPP_707_MUT_7", "golden_code": "import os\n\ndef count_Set_Bits(n):\n    n += 1\n    powerOf2 = 2\n    cnt = n // 2\n    while powerOf2 <= n:\n        totalPairs = n // powerOf2\n        cnt += (totalPairs // 2) * powerOf2\n        if totalPairs & 1:\n            cnt += n % powerOf2\n        else:\n            cnt += 0\n        powerOf2 <<= 1\n    return cnt", "generated_code": "import os\n\ndef count_Set_Bits(n):\n    n += 1\n    powerOf2 = 2\n    cnt = n // 2\n    while powerOf2 <= n:\n        totalPairs = n // powerOf2\n        cnt += (totalPairs // 2) / powerOf2\n        if totalPairs & 1:\n            cnt += n % powerOf2\n        else:\n            cnt += 0\n        powerOf2 <<= 1\n    return cnt", "score": 0.2874, "codebleu": 0.9735861223471949, "crystalbleu": 0, "codebertscore": 1.0, "codescore": 0.9937644004821777, "surfaceSim": 0.9584076433121019, "abs_surfaceSim_minus_score": 0.6710076433121019, "source": "local", "local_type": "MUT"}
{"id": "MBPP_31_10", "golden_code": "def smallest_multiple(n):\r\n    if (n<=2):\r\n      return n\r\n    i = n * 2\r\n    factors = [number  for number in range(n, 1, -1) if number * 2 > n]\r\n    while True:\r\n        for a in factors:\r\n            if i % a != 0:\r\n                i += n\r\n                break\r\n            if (a == factors[-1] and i % a == 0):\r\n                return i", "generated_code": "def smallest_multiple(n):\n  return  n and 1 << n.bit_length()-1", "score": 0.2124, "codebleu": 0.036706004487922925, "crystalbleu": 0, "codebertscore": 0.7, "codescore": 0.1296413242816925, "surfaceSim": 0.459921798631476, "abs_surfaceSim_minus_score": 0.24752179863147597, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-1872_17", "golden_code": "import math\nPi = math.pi\nn, r = list(map(float, input().split()))\nx = math.tan (Pi / n)\ny = math.tan (Pi / n / 2)\nbase = r / (1 / x + 1 / y)\nprint(n * r * base)\n", "generated_code": "n,r = map(int,input().split())\n\ndef solve(n,r):\n\tif n == 2:\n\t\treturn 0\n\tif n <= 2*r:\n\t\treturn n*r**2\n\ta = (n*r**2)/(2*r)\n\tb = ((n*r**4)/(2* r**2))**0.5\n\tc = (n*(2*r+b)/(2*s2))\n\treturn a+b+c\n\nprint(solve(n,r))\n", "score": 0.0, "codebleu": 0.14927091074995993, "crystalbleu": 0.12, "codebertscore": 0.77, "codescore": 0.027946043759584427, "surfaceSim": 0.4378947368421053, "abs_surfaceSim_minus_score": 0.4378947368421053, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_17_36", "golden_code": "def all_Bits_Set_In_The_Given_Range(n,l,r): \r\n    num = ((1 << r) - 1) ^ ((1 << (l - 1)) - 1) \r\n    new_num = n & num \r\n    if (num == new_num): \r\n        return True\r\n    return False", "generated_code": "def all_Bits_Set_In_The_Given_Range(n,l,r): \n\treturn bin(n).count('1')>0", "score": 0.4661, "codebleu": 0.04530081179244856, "crystalbleu": 0, "codebertscore": 0.82, "codescore": 0.5465123057365417, "surfaceSim": 0.515916149068323, "abs_surfaceSim_minus_score": 0.049816149068322935, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0037_24", "golden_code": "w, b, sh = list(map(int, input().split()))\nfl = False\nwhile not fl and sh > 0:\n    if sh % b == 0 or sh % w == 0:\n        fl = True\n    sh -= w\nif fl:\n    print('Yes')\nelse:\n    print('No')\n", "generated_code": "a, b, c = list(map(int, input().split()))\n\nif a * b * c % 2 == 0:\n\tprint('Yes')\nelse:\n\tprint ('No')\n", "score": 0.4064, "codebleu": 0.29287083930128166, "crystalbleu": 0, "codebertscore": 0.83, "codescore": 0.5801772475242615, "surfaceSim": 0.6394736842105263, "abs_surfaceSim_minus_score": 0.23307368421052632, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_90_OP_2", "golden_code": "def next_smallest(lst):\n    lst = sorted(set(lst))\n    return None if len(lst) < 2 else lst[1]", "generated_code": "def next_smallest(seq):\n    unique_vals = set(seq)\n    if len(unique_vals) < 2:\n        return None\n    first, second = float('inf'), float('inf')\n    for num in unique_vals:\n        if num < first:\n            first, second = num, first\n        elif first < num < second:\n            second = num\n    return second", "score": 1.0, "codebleu": 0.21595951114561895, "crystalbleu": 0, "codebertscore": 0.74, "codescore": 0.5947150588035583, "surfaceSim": 0.5817878028404344, "abs_surfaceSim_minus_score": 0.4182121971595656, "source": "local", "local_type": "OP"}
{"id": "MBPP_34_12", "golden_code": "def even_num(x):\r\n  if x%2==0:\r\n     return True\r\n  else:\r\n    return False", "generated_code": "def even_num(n):\n    return n%2 is 0", "score": 1.0, "codebleu": 0.32756582613989754, "crystalbleu": 0, "codebertscore": 0.83, "codescore": 0.9936513304710388, "surfaceSim": 0.6861904761904762, "abs_surfaceSim_minus_score": 0.31380952380952376, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_40_20", "golden_code": "import datetime\r\ndef check_date(m, d, y):\r\n    try:\r\n        m, d, y = map(int, (m, d, y))\r\n        datetime.date(y, m, d)\r\n        return True\r\n    except ValueError:\r\n        return False", "generated_code": "import datetime\ndef check_date(m, d, y):\n\tif m and d and y and m >= m + d:\n\t\treturn True\n\treturn False\nh = lambda: hex(int(input()))\nt = lambda: input()\ng = lambda: [x for x in input().split()]", "score": 0.7305, "codebleu": 0.319677015519134, "crystalbleu": 0, "codebertscore": 0.8, "codescore": 0.5911622643470764, "surfaceSim": 0.4805699481865285, "abs_surfaceSim_minus_score": 0.24993005181347155, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_472_1", "golden_code": "INT_BITS = 32\r\ndef left_Rotate(n,d):   \r\n    return (n << d)|(n >> (INT_BITS - d))  ", "generated_code": "INT_BITS = 32\ndef left_Rotate(num,d):\n\tif num == 0:\n\t\t   return \"\"\n\telif num < 0:\n\t\t   num = -1 * int(-num)\n\treturn __import__('functools').reduce(lambda x,y: x+y, list(map(int, str(num)[::-1])))[::-1]\nUST_CODE = {'+': 'left', '-': 'right', '*': 'up', '/': 'down', '*': 'right'}", "score": 0.0, "codebleu": 0.3295688484544631, "crystalbleu": 0, "codebertscore": 0.76, "codescore": 0.025224193930625916, "surfaceSim": 0.3551227983130737, "abs_surfaceSim_minus_score": 0.3551227983130737, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0175_3", "golden_code": "def solve(x, y):\n    if (x == 0 or y == 0):\n        return (x, y)\n    if (x >= 2 * y and y != 0):\n        x %= 2 * y\n    if (y >= 2 * x and x != 0):\n        y %= 2 * x\n    if (x == 0 or y == 0):\n        return (x, y)\n    if (x < 2 * y and y < 2 * x):\n        return (x, y)\n    return solve(x, y)\n\nx, y = list(map(int, input().split()))\nans = solve(x, y)\nprint(ans[0], ans[1])\n", "generated_code": "n, m = map(int, input().split())\n\na = -2 * n\nb = 2 * m\n\na = max(a, 0)\nb = max(b, 0)\n\nprint(a, b)\n", "score": 0.0, "codebleu": 0.10142763654367075, "crystalbleu": 0.04, "codebertscore": 0.75, "codescore": 0.018368108198046684, "surfaceSim": 0.426261153054221, "abs_surfaceSim_minus_score": 0.426261153054221, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_34_13", "golden_code": "def even_num(x):\r\n  if x%2==0:\r\n     return True\r\n  else:\r\n    return False", "generated_code": "def even_num(n):\n\tn = 2**(len(bin(n))-3)  \n\tk = 0\n\twhile n>0:\n\t\tn = n >> 1\n\t\tk+=1\n\treturn k", "score": 0.0356, "codebleu": 0.3025823991237887, "crystalbleu": 0, "codebertscore": 0.75, "codescore": 0.12256821990013123, "surfaceSim": 0.45914954610606784, "abs_surfaceSim_minus_score": 0.4235495461060678, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_31_42", "golden_code": "def smallest_multiple(n):\r\n    if (n<=2):\r\n      return n\r\n    i = n * 2\r\n    factors = [number  for number in range(n, 1, -1) if number * 2 > n]\r\n    while True:\r\n        for a in factors:\r\n            if i % a != 0:\r\n                i += n\r\n                break\r\n            if (a == factors[-1] and i % a == 0):\r\n                return i", "generated_code": "def smallest_multiple(n):\n\ts = n*(n+1)//2\n\treturn s", "score": 0.2726, "codebleu": 0.07773778709321985, "crystalbleu": 0, "codebertscore": 0.72, "codescore": 0.10229463875293732, "surfaceSim": 0.47856649991374844, "abs_surfaceSim_minus_score": 0.20596649991374844, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_67_7", "golden_code": "def nCr_mod_p(n, r, p): \r\n\tif (r > n- r): \r\n\t\tr = n - r \r\n\tC = [0 for i in range(r + 1)] \r\n\tC[0] = 1 \r\n\tfor i in range(1, n + 1): \r\n\t\tfor j in range(min(i, r), 0, -1): \r\n\t\t\tC[j] = (C[j] + C[j-1]) % p \r\n\treturn C[r] ", "generated_code": "def nCr_mod_p(k, n, p):\n\treturn (p // (n * k) - 1) * k % p\nOptimization = []", "score": 0.1208, "codebleu": 0.0647897506242433, "crystalbleu": 0, "codebertscore": 0.74, "codescore": 0.17518986761569977, "surfaceSim": 0.4716777408637874, "abs_surfaceSim_minus_score": 0.35087774086378737, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0395_24", "golden_code": "import sys;\n\n#sys.stdin = open(\"input.txt\", \"r\");\n#sys.stdout = open(\"output.txt\", \"w\");\n\ndef ria():\n    return [int(x) for x in input().split()];\n\ntf = 0;\na = ria();\nn = len(a);\nfor i in range(n-2):\n    for j in range(i+1, n-1, 1):\n        for k in range(j+1, n, 1):\n            if a[i] + a[j] + a[k] == (sum(a) / 2 ):\n                tf = 1;\n                break;\n        if tf == 1:\n            break;\n    if tf == 1:\n        break;\n\nif ( tf == 1 ):\n    print(\"YES\");\nelse:\n    print(\"NO\");\n\n\n#sys.stdout.close();\n", "generated_code": "def main():\n\ta = list(map(int, input().split()))\n\tn = len(a)\n\tif sum(a) % n == 0:\n\t\tprint(\"YES\")\n\telse:\n\t\tl = sum(a) // n\n\t\tr = l + 1\n\t\ta.sort()\n\t\twhile r - l > 1:\n\t\t\tif a[r - 1] + a[r - 2] == a[r]:\n\t\t\t\ta.pop(r - 1)\n\t\t\t\ta.sort()                \n\t\t\t\tl += 1\n\t\t\telse:\n\t\t\t\tl = a.pop(l - 1)\n\t\tif len(a) > 0:\n\t\t\tprint(\"YES\")        \n\t\telse:\n\t\t\tprint('NO')\n\n\ndef __starting_point():\n\tmain()\n\n__starting_point()\n", "score": 0.0194, "codebleu": 0.2587041639841823, "crystalbleu": 0.16, "codebertscore": 0.77, "codescore": 0.30966874957084656, "surfaceSim": 0.5816240347490348, "abs_surfaceSim_minus_score": 0.5622240347490348, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_extra_p03455_s887829630_OP_1", "golden_code": "a, b = list(map(int, input().split()))\n\nif a*b%2 == 1:\n\n    print(\"Odd\")\n\nelse:\n\n    print(\"Even\")", "generated_code": "a, b = list(map(int, input().split()))\n\nprint(('Odd'if a&b&1 else 'Even'))", "score": 1.0, "codebleu": 0.5465642129184616, "crystalbleu": 0, "codebertscore": 0.92, "codescore": 0.9567720293998718, "surfaceSim": 0.6422902494331066, "abs_surfaceSim_minus_score": 0.35770975056689336, "source": "local", "local_type": "OP"}
{"id": "LOCAL_APPS_643_10_MUT_64", "golden_code": "def gcd(a, b):\n    if b > a:\n        return gcd(b, a)\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef works(a, b, c, d, x):\n    return (b <= d * x and a <= c * x and (d * x) - b >= (c * x) - a)\n\ndef solve():\n    (a, b, c, d) = list(map(int, input().rstrip().split()))\n    if (c == d == 1 and not (a / b == 1)):\n        print(-1)\n        return\n    if (c == 0 and not (a == 0)):\n        print(-1)\n        return\n    g = gcd(c, d)\n    c //= g\n    d //= g\n    low = -1\n    high = 1000000000000\n    while low + 1 < high:\n        mid = (low + high) // 2\n        if works(a, b, c, d, mid):\n            high = mid\n        else:\n            low = mid\n    print((d * high) - b)\n\ndef __starting_point():\n    t = int(input())\n    for _ in range(t):\n        solve()\n\n__starting_point()", "generated_code": "def gcd(a, b):\n    if b > a:\n        return gcd(b, a)\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef works(a, b, c, d, x):\n    return (b <= d * x and a <= c * x and (d * x) - b >= (c * x) - a)\n\ndef solve():\n    (a, b, c, d) = list(map(int, input().rstrip().split()))\n    if (c == d == 1 and not (a / b == 1)):\n        print(-1)\n        return\n    if (c != 0 and not (a == 0)):\n        print(-1)\n        return\n    g = gcd(c, d)\n    c //= g\n    d //= g\n    low = -1\n    high = 1000000000000\n    while low + 1 < high:\n        mid = (low + high) // 2\n        if works(a, b, c, d, mid):\n            high = mid\n        else:\n            low = mid\n    print((d * high) - b)\n\ndef __starting_point():\n    t = int(input())\n    for _ in range(t):\n        solve()\n\n__starting_point()", "score": 0.3682, "codebleu": 0.9913520844361599, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.9937864542007446, "surfaceSim": 0.9858511624712387, "abs_surfaceSim_minus_score": 0.6176511624712386, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-2144_81", "golden_code": "import math\ndef okay(n):\n    ans=n\n    i=2\n    while i*i<=n:\n        if n%i==0:\n            while n%i==0:\n                n=int(n/i)\n            ans-=int(ans/i)\n        i+=1\n    if n>1:\n        ans-=int(ans/n)\n    return ans\nt=int(input())\nwhile t:\n    t-=1\n    a,m=list(map(int,input().split()))\n    print(okay(int(m/math.gcd(a,m))))\n            \n", "generated_code": "from math import gcd\nfor _ in range(int(input())):\n\ta, m = map(int, input().split())\n\tk = int(gcd(aefficient, m))\n\tans = 0\n\tfor i in range(1, k):\n\t\tif m % i == 0:\n\t\t\tif i % (m // i) == 0:\n\t\t\t\tans += 1\n\tprint(ans)\n", "score": 0.0, "codebleu": 0.16045127480310412, "crystalbleu": 0.16, "codebertscore": 0.78, "codescore": 0.4033162295818329, "surfaceSim": 0.5226293103448276, "abs_surfaceSim_minus_score": 0.5226293103448276, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_p02537_s645565645_MUT_96", "golden_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "generated_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    @staticmethod\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "score": 0.0, "codebleu": 0.9933297651216333, "crystalbleu": 0.99, "codebertscore": 0.99, "codescore": 0.9864012598991394, "surfaceSim": 0.9957446808510638, "abs_surfaceSim_minus_score": 0.9957446808510638, "source": "local", "local_type": "MUT"}
{"id": "MBPP_3_32", "golden_code": "def length_Of_Last_Word(a): \r\n    l = 0\r\n    x = a.strip() \r\n    for i in range(len(x)): \r\n        if x[i] == \" \": \r\n            l = 0\r\n        else: \r\n            l += 1\r\n    return l ", "generated_code": "def length_Of_Last_Word(s):\n   \n\treturn len(s) - 1", "score": 0.104, "codebleu": 0.05862134009043687, "crystalbleu": 0, "codebertscore": 0.75, "codescore": 0.0720551460981369, "surfaceSim": 0.5315724815724816, "abs_surfaceSim_minus_score": 0.4275724815724816, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_MBPP_122_OP_1", "golden_code": "MAX = 3000 \r\ndef smartNumber(n): \r\n\tprimes = [0] * MAX \r\n\tresult = [] \r\n\tfor i in range(2, MAX): \r\n\t\tif (primes[i] == 0): \r\n\t\t\tprimes[i] = 1 \r\n\t\t\tj = i * 2 \r\n\t\t\twhile (j < MAX): \r\n\t\t\t\tprimes[j] -= 1 \r\n\t\t\t\tif ( (primes[j] + 3) == 0): \r\n\t\t\t\t\tresult.append(j) \r\n\t\t\t\tj = j + i \r\n\tresult.sort() \r\n\treturn result[n - 1] ", "generated_code": "MAX_LIMIT = 3000\n\ndef smartNumber(n):\n    sieve = [0] * MAX_LIMIT\n    result = []\n    for current in range(2, MAX_LIMIT):\n        if sieve[current] == 0:\n            for multiple in range(current * 2, MAX_LIMIT, current):\n                sieve[multiple] -= 1\n                if sieve[multiple] == -3:\n                    result.append(multiple)\n    return sorted(result)[n - 1]\n", "score": 1.0, "codebleu": 0.3475717084596577, "crystalbleu": 0, "codebertscore": 0.8, "codescore": 0.9939426779747009, "surfaceSim": 0.7352216748768472, "abs_surfaceSim_minus_score": 0.2647783251231528, "source": "local", "local_type": "OP"}
{"id": "LOCAL_PIE_extra_p03032_s390254937_OP_1", "golden_code": "N, K = list(map(int, input().split()))\n\nV = list(map(int, input().split()))\n\n\n\nanswer = 0\n\nlimit = min(N, K)\n\nfor a in range(limit+1): #左から取り出す\n\n    for b in range(limit-a+1): #右から取り出す\n\n        for c in range(K-(a+b)+1):\n\n            use = V[:a] + V[N-b:]\n\n            use.sort()\n\n            s = sum(use[c:])\n\n            answer = max(answer, s)\n\n\n\nprint(answer)", "generated_code": "import sys\n\nsys.setrecursionlimit(10 ** 9)\n\n\n\nN, K = list(map(int, input().split()))\n\nV = list(map(int, input().split()))\n\nV2 = V * 2\n\nanswer = 0\n\nfor i in range(1, min(N, K)+1): # iは宝石を取り出す個数\n\n    for j in range(0, min(i, K-i)+1): # jは何個の宝石を手離すか\n\n        for k in range(max(0, N-i), N+1): # V2の中で何番目から取り出すか\n\n            use = V2[k:k+i]\n\n            use.sort()\n\n            s = sum(use[j:])\n\n            if s > answer:\n\n                answer = s\n\n\n\nprint(answer)\n", "score": 1.0, "codebleu": 0.42442042313709166, "crystalbleu": 0.33, "codebertscore": 0.84, "codescore": 0.9932520985603333, "surfaceSim": 0.7260588455772115, "abs_surfaceSim_minus_score": 0.27394115442278855, "source": "local", "local_type": "OP"}
{"id": "APPS_test-0081_55", "golden_code": "a, b = list(map(int,input().split()))\ndef gcd(x,y):\n\tif x == 0:\n\t\treturn y\n\tif y == 0:\n\t\treturn x\n\tif y > x:\n\t\ty,x = x,y\n\treturn gcd(x%y, y)\nif a > b:\n\ta, b = b, a\nk = b - a\ndzielniki = []\ni = 1\nwhile i ** 2 <= k:\n\tif k % i == 0:\n\t\tdzielniki.append(i)\n\t\tdzielniki.append(k // i)\n\ti+= 1\ngcdd = a * b / gcd(a,b)\nwynik = 0\n#print(dzielniki)\nfor d in dzielniki:\n\taa = a - (a % d) + d\n\tbb = b - (b % d) + d\n\t#print(aa,bb)\n\tif aa * bb // gcd(aa,bb) <= gcdd:\n\t\tif aa * bb // gcd(aa,bb) == gcdd:\n\t\t\twynik = min(d-(a%d),wynik)\n\t\telse:\n\t\t\tgcdd = aa * bb // gcd(aa,bb)\n\t\t\twynik = d-(a%d)\nprint(wynik)\n", "generated_code": "def main():\n\ta,b=map(int,input().split())\n\tif a==b:\n\t\tprint(0)\n\t\treturn\n\tmins=int(2*b+1)\n\tfor st in range(mins):\n\t\tif b%st==0:\n\t\t\tb//=st\n\t\t\tbreak\n\tif b%st!=0:\n\t\td=b//float(a)\n\t\tfor st in range((d-1)//a,-1,-1):\n\t\t\tif a%st==0():\n\t\t\t\tbreak\n\t\telse:\n\t\t\tprint(d)\n\t\t\treturn\n\tprint(0)\n\n\ndef __starting_point():\n\tmain()\n__starting_point()\n", "score": 0.017, "codebleu": 0.10547045710682629, "crystalbleu": 0.07, "codebertscore": 0.73, "codescore": 0.08110862225294113, "surfaceSim": 0.5708232445520581, "abs_surfaceSim_minus_score": 0.5538232445520581, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_4706_55_OP_1", "golden_code": "n = input()\nn1 = input()\nn2 = input()\n\nprint(n[0],n1[1],n2[2], flush=True,sep='')\n", "generated_code": "a, b, c = input(), input(), input()\nprint(a[0] + b[1] + c[2])", "score": 1.0, "codebleu": 0.36294095715498925, "crystalbleu": 0, "codebertscore": 0.81, "codescore": 0.13082990050315857, "surfaceSim": 0.6254355400696865, "abs_surfaceSim_minus_score": 0.3745644599303135, "source": "local", "local_type": "OP"}
{"id": "APPS_test-1798_18", "golden_code": "n = int(input())\ninp, k = {},0\n\n# for i in input().split(\" \"):\n#     if int(i) not in list(inp.keys()):   inp[int(i)] = [k]\n#     else: inp[int(i)]+=[k]\n#     k+=1\n\ns = input().split()\n\nfor i in range(0, len(s)):\n    item = int(s[i])\n    if item in inp:\n        inp[item]+=[i]\n    else:\n        inp[item]=[i]\n\ninp_keys = [int(i) for i in inp.keys()]\ninp_keys.sort()\nresult = []\n\ndef check(arr):\n    diff = arr[1]-arr[0]\n    for i in range(1, len(arr)-1):\n        if arr[i+1]-arr[i] != diff: return False\n    return diff\n\nfor i in inp_keys:\n    j = inp[i]\n    if len(j) == 1:\n        result.append([i,0])\n        continue\n    diff = check(j)\n    if diff:   result.append([i,diff])\n\nout = \"\"\nfor i,j in result: out+=str(i)+\" \"+str(j)+\"\\n\"\n\nprint(len(result))\nprint(out[:-1])", "generated_code": "def main():\n\tn = int(input())\n\tl = sorted(map(int, input().split()))\n\tgaps = [None] * (n + 1)\n\tfirst = first_unordered = None\n\tfor i in range(n):\n\t\tif first is None:\n\t\t\tfirst = l[i]\n\t\t\tlast = l[i + 1]\n\t\t\tgaps[l[i]] = (first, last)\n\t\t\tgaps_str = str(gaps)\n\t\t\tif gaps_str.count(gaps_str[0]) == 1:\n\t\t\t\tfirst = first_up(gaps_dict)\n\t\t\telse:\n\t\t\t\tfirst is None\n\t\telse:\n\t\t\tlast = if_up(l[i], gaps_str)\n\t\t\tif first is None or last is None:\n\t\t\t\tlast = first\n\t\t\telif last is not None:\n\t\t\t\tprint", "score": 0.0, "codebleu": 0.14464612529627477, "crystalbleu": 0.09, "codebertscore": 0.69, "codescore": 0.018348820507526398, "surfaceSim": 0.517287764049422, "abs_surfaceSim_minus_score": 0.517287764049422, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_MBPP_395_OP_1", "golden_code": "def first_non_repeating_character(str1):\r\n  char_order = []\r\n  ctr = {}\r\n  for c in str1:\r\n    if c in ctr:\r\n      ctr[c] += 1\r\n    else:\r\n      ctr[c] = 1 \r\n      char_order.append(c)\r\n  for c in char_order:\r\n    if ctr[c] == 1:\r\n      return c\r\n  return None", "generated_code": "def first_non_repeating_character(s):\n    from collections import OrderedDict\n    count = OrderedDict()\n    for char in s:\n        count[char] = count.get(char, 0) + 1\n    for char, cnt in count.items():\n        if cnt == 1:\n            return char\n    return None", "score": 1.0, "codebleu": 0.1863343012178545, "crystalbleu": 0, "codebertscore": 0.79, "codescore": 0.9913354516029358, "surfaceSim": 0.6309523809523809, "abs_surfaceSim_minus_score": 0.36904761904761907, "source": "local", "local_type": "OP"}
{"id": "LOCAL_PIE_p02574_s911286307_MUT_12", "golden_code": "import math, sys\nn = int(sys.stdin.readline())\na = tuple(map(int, sys.stdin.readline().split()))\ng = math.gcd(a[0], a[1])\nfor i in range(2, n):\n    g = math.gcd(g, a[i])\nM = max(a)\nacc = a[0]\nfor i in range(n):\n    acc = math.gcd(acc, a[i])\nif acc != 1:\n    print('not coprime')\n    exit()\nLIMIT = max(a)\nminPrime = [0] * (LIMIT + 1)\nminPrime[1] = 1\ndef make():\n    for i in range(2, LIMIT + 1):\n        if minPrime[i] == 0:\n            minPrime[i] = i\n            for j in range(i + i, LIMIT + 1, i):\n                if minPrime[j] == 0:\n                    minPrime[j] = i\nmake()\ndef factrial(N):\n    ret = []\n    while minPrime[N] != N:\n        ret.append(minPrime[N])\n        N = N // minPrime[N]\n    if N != 1:\n        ret.append(N)\n    return ret\njudge = set([])\npc = True\npairwise = True\np = set()\nfor e in a:\n    if not pairwise:\n        break\n    asf = set(factrial(e))\n    if judge & asf != set():\n        pc = False\n    judge |= asf\nif pc:\n    print('pairwise coprime')\nelif g == 1:\n    print('setwise coprime')\nelse:\n    print('not coprime')", "generated_code": "import math, sys\nn = int(sys.stdin.readline())\na = tuple(map(int, sys.stdin.readline().split()))\ng = math.gcd(a[0], a[1])\nfor i in range(2, n):\n    g = math.gcd(g, a[i])\nM = max(a)\nacc = a[0]\nfor i in range(n):\n    acc = math.gcd(acc, a[i])\nif not (acc != 1):\n    print('not coprime')\n    exit()\nLIMIT = max(a)\nminPrime = [0] * (LIMIT + 1)\nminPrime[1] = 1\ndef make():\n    for i in range(2, LIMIT + 1):\n        if minPrime[i] == 0:\n            minPrime[i] = i\n            for j in range(i + i, LIMIT + 1, i):\n                if minPrime[j] == 0:\n                    minPrime[j] = i\nmake()\ndef factrial(N):\n    ret = []\n    while minPrime[N] != N:\n        ret.append(minPrime[N])\n        N = N // minPrime[N]\n    if N != 1:\n        ret.append(N)\n    return ret\njudge = set([])\npc = True\npairwise = True\np = set()\nfor e in a:\n    if not pairwise:\n        break\n    asf = set(factrial(e))\n    if judge & asf != set():\n        pc = False\n    judge |= asf\nif pc:\n    print('pairwise coprime')\nelif g == 1:\n    print('setwise coprime')\nelse:\n    print('not coprime')", "score": 0.0352, "codebleu": 0.9828416702326902, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.9937169551849365, "surfaceSim": 0.9976392823418319, "abs_surfaceSim_minus_score": 0.9624392823418318, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-4076_36", "golden_code": "import math\na, b, h, m = list(map(int, input().split()))\nang = abs(h * 30 + m * 0.5 - m * 6)\nprint(math.sqrt(a ** 2 + b ** 2 - 2 * a * b * math.cos(ang * math.pi / 180)))", "generated_code": "import sys\ninput = sys.stdin.readline\n\na,b,c,d = map(int, input().split())\n\nres = max(abs(b), abs(c))\nh = a/60 + c/60\nm = b/60 + d/60\n\nprint(res * max(h, m))\n", "score": 0.0, "codebleu": 0.2266037067179148, "crystalbleu": 0, "codebertscore": 0.81, "codescore": 0.018347540870308876, "surfaceSim": 0.6326797385620915, "abs_surfaceSim_minus_score": 0.6326797385620915, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0951_28", "golden_code": "k=int(input())\ninp=input()\nn=[]\nfor val in inp:\n\tn.append(int(val)) \nn.sort()\nsumval=sum(n)\ncounter=0\nfor val in n:\n\tif(sumval<k):\n\t\tsumval+=9-val\n\t\tcounter+=1\n\telse:\n\t\tbreak\nprint(counter)", "generated_code": "k = int(input())\nn = list(map(int, input().split()))\np, q = 0, 9\nfor i in range(10):\n\tif q > k:\n\t\tbreak\n\tif i == 9:\n\t\tp = i\n\t\tq = i + 1\n\telif i > 9:\n\t\tif i - p == 1:\n\t\t\tq = i - 1\n\t\telse:\n\t\t\tp = i - 1 \nprint(p - q)\n", "score": 0.0, "codebleu": 0.16316007703859137, "crystalbleu": 0, "codebertscore": 0.78, "codescore": 0.04741017147898674, "surfaceSim": 0.578589634664401, "abs_surfaceSim_minus_score": 0.578589634664401, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_4638_24_MUT_18", "golden_code": "(n, c) = [int(x) for x in input().split()]\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\ndpst = [0] * (n + 1)\ndplift = [0] * (n + 1)\ndpst[2] = a[0]\ndplift[2] = c + b[0]\nfor i in range(3, n + 1):\n    dpst[i] = a[i - 2] + min(dpst[i - 1], dplift[i - 1])\n    dplift[i] = b[i - 2] + min(c + dpst[i - 1], dplift[i - 1])\n\nfor i in range(1, n + 1):\n    print(min(dpst[i], dplift[i]), end=' ')", "generated_code": "(n, c) = [int(x) for x in input().split()]\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\ndpst = [0] * (n + 1)\ndplift = [0] * (n + 1)\ndpst[2] = a[0]\ndplift[2] = c + b[0]\nfor i in range(3, n + 1):\n    dpst[i] = a[i - 2] + min(dpst[i - 1], dplift[i - 1])\n    dplift[i] = b[i - 2] + min(c + dpst[i + 1], dplift[i - 1])\n\nfor i in range(1, n + 1):\n    print(min(dpst[i], dplift[i]), end=' ')", "score": 0.034, "codebleu": 0.9844886434075966, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9937485456466675, "surfaceSim": 0.9987834549878345, "abs_surfaceSim_minus_score": 0.9647834549878345, "source": "local", "local_type": "MUT"}
{"id": "MBPP_34_41", "golden_code": "def even_num(x):\r\n  if x%2==0:\r\n     return True\r\n  else:\r\n    return False", "generated_code": "def even_num(x):    \n\treturn (x * 2) - 1 - x", "score": 0.0683, "codebleu": 0.31804567932021943, "crystalbleu": 0, "codebertscore": 0.81, "codescore": 0.09899478405714035, "surfaceSim": 0.5866666666666667, "abs_surfaceSim_minus_score": 0.5183666666666666, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_8_33", "golden_code": "def fibonacci(n):\r\n  if n == 1 or n == 2:\r\n    return 1\r\n  else:\r\n    return (fibonacci(n - 1) + (fibonacci(n - 2)))", "generated_code": "def fibonacci(n):    \n\tx, y = 0, 1\n\tfor i in range(n):\n\t\tx,y = y, x+y\n\treturn x\n\nss = []", "score": 1.0, "codebleu": 0.11726690084128755, "crystalbleu": 0, "codebertscore": 0.79, "codescore": 0.9916218519210815, "surfaceSim": 0.49137931034482757, "abs_surfaceSim_minus_score": 0.5086206896551724, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_8_36", "golden_code": "def fibonacci(n):\r\n  if n == 1 or n == 2:\r\n    return 1\r\n  else:\r\n    return (fibonacci(n - 1) + (fibonacci(n - 2)))", "generated_code": "def fibonacci(n):\n\ta = [0, 1]\n\tfor i in range(n):\n\t\ta.append(a[i] + a[i+1])\n\treturn a[-2]", "score": 1.0, "codebleu": 0.13980553940296375, "crystalbleu": 0, "codebertscore": 0.8, "codescore": 0.40370115637779236, "surfaceSim": 0.4709450830140486, "abs_surfaceSim_minus_score": 0.5290549169859514, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_1315_2_MUT_25", "golden_code": "import math, string, itertools, fractions, heapq, collections, re, array, bisect, copy\nfrom itertools import chain, dropwhile, permutations, combinations\nfrom collections import defaultdict, deque\n\ndef VI():\n    return list(map(int, input().split()))\ndef run(n, a):\n    b = copy.copy(a)\n    for i in range(n):\n        b[i] -= n - i\n    b.sort()\n    for i in range(n):\n        if i < n - 1:\n            if b[i] == b[i + 1]:\n                print(':(')\n                return\n        b[i] = str(b[i] + (n - i))\n    print(' '.join(b))\n\n\ndef main(info=0):\n    n = int(input())\n    a = VI()\n    run(n, a)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "generated_code": "import math, string, itertools, fractions, heapq, collections, re, array, bisect, copy\nfrom itertools import chain, dropwhile, permutations, combinations\nfrom collections import defaultdict, deque\n\ndef VI():\n    return list(map(int, input().split()))\ndef run(n, a):\n    b = copy.copy(a)\n    for i in range(n):\n        b[i] -= n - i\n    b.sort()\n    for i in range(n):\n        if i < n - 1:\n            if b[i] == b[i + 1]:\n                print(':(')\n                return\n        pass\n    print(' '.join(b))\n\n\ndef main(info=0):\n    n = int(input())\n    a = VI()\n    run(n, a)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "score": 0.1605, "codebleu": 0.8780274241139312, "crystalbleu": 0.89, "codebertscore": 0.99, "codescore": 0.33070820569992065, "surfaceSim": 0.9676390403489641, "abs_surfaceSim_minus_score": 0.8071390403489641, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_APPS_3723_2_MUT_13", "golden_code": "import functools\n\n\n@functools.lru_cache(maxsize=10000)\ndef factor(n):res = []\n    d = 2\n    while d * d <= n:\n        if n % d == 0:\n            res.append(d)\n            n //= d\n        else:\n            d += 1\n    if n > 1:\n        res.append(n)\n    return set(res)\n\nnum = int(input())\n\npoks = list(map(int, input().split()))[:num]\n\nc = dict()\nfor p in poks:\n    for d in factor(p):\n        if d in c.keys():\n            c[d] += 1\n        else:\n            c[d] = 1\n\nif c:\n    print(max(c.values()))\nelse:\n    print(1)", "generated_code": "import functools\n\n\n@functools.lru_cache(maxsize=10000)\ndef factor(n):res = []\n    d = 2\n    while d * d <= n:\n        if n % d == 0:\n            res.append(d)\n            n //= d\n        else:\n            d += 1\n    if n > 1:\n        res.append(n)\n    return set(res)\n\nnum = int(input())\n\npoks = list(map(int, input().split()))[:num]\n\nc = dict()\nfor p in poks:\n    for d in factor(p):\n        if d not in c.keys():\n            c[d] += 1\n        else:\n            c[d] = 1\n\nif c:\n    print(max(c.values()))\nelse:\n    print(1)", "score": 0.0, "codebleu": 0.9855382435424389, "crystalbleu": 0.97, "codebertscore": 1.0, "codescore": 0.99379962682724, "surfaceSim": 0.49713740458015265, "abs_surfaceSim_minus_score": 0.49713740458015265, "source": "local", "local_type": "MUT"}
{"id": "MBPP_42_15", "golden_code": "import re\r\ndef end_num(string):\r\n    text = re.compile(r\".*[0-9]$\")\r\n    if text.match(string):\r\n        return True\r\n    else:\r\n        return False", "generated_code": "import re\ndef end_num(s):\n\tfor i in range(len(s)-2,-1,-1):\n\t\tif s[i] == s[i+1]:\n\t\t\treturn True\n\treturn False\nduplicate = set()", "score": 0.7114, "codebleu": 0.28922855787192003, "crystalbleu": 0, "codebertscore": 0.74, "codescore": 0.9116135835647583, "surfaceSim": 0.5551677852348993, "abs_surfaceSim_minus_score": 0.15623221476510074, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_MBPP_793_OP_1", "golden_code": "def last(arr,x,n):\r\n    low = 0\r\n    high = n - 1\r\n    res = -1  \r\n    while (low <= high):\r\n        mid = (low + high) // 2 \r\n        if arr[mid] > x:\r\n            high = mid - 1\r\n        elif arr[mid] < x:\r\n            low = mid + 1\r\n        else:\r\n            res = mid\r\n            low = mid + 1\r\n    return res", "generated_code": "def last(array, target, length):\n    left, right = 0, length - 1\n    result = -1\n    while left <= right:\n        middle = (left + right) // 2\n        if array[middle] == target:\n            result = middle\n            left = middle + 1\n        elif array[middle] < target:\n            left = middle + 1\n        else:\n            right = middle - 1\n    return result", "score": 1.0, "codebleu": 0.4428992969367255, "crystalbleu": 0, "codebertscore": 0.85, "codescore": 0.974661111831665, "surfaceSim": 0.7920344682639764, "abs_surfaceSim_minus_score": 0.2079655317360236, "source": "local", "local_type": "OP"}
{"id": "LOCAL_HE_105_MUT_8", "golden_code": "import os\n\ndef by_length(arr):\n    dic = {\\\n        1: 'One', \\\n        2: 'Two', \\\n        3: 'Three', \\\n        4: 'Four', \\\n        5: 'Five', \\\n        6: 'Six', \\\n        7: 'Seven', \\\n        8: 'Eight', \\\n        9: 'Nine'}\n    \n    sorted_arr = sorted(arr, reverse=True)\n    new_arr = []\n    for var in sorted_arr:\n        try:\n            new_arr.append(dic[var])\n        except:\n            pass\n    return new_arr", "generated_code": "import os\n\ndef by_length(arr):\n    pass\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    sorted_arr = sorted(arr, reverse=True)\n    new_arr = []\n    for var in sorted_arr:\n        try:\n            new_arr.append(dic[var])\n        except:\n            pass\n    return new_arr", "score": 0.2294, "codebleu": 0.32498169529105536, "crystalbleu": 0, "codebertscore": 0.86, "codescore": 0.021360114216804504, "surfaceSim": 0.877751572327044, "abs_surfaceSim_minus_score": 0.6483515723270441, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-0402_50", "golden_code": "n, k = list(map(int, input().split()))\nans = 0\ncurr = 0\nwhile curr + 5 * (ans + 1) + k <= 240:\n    ans += 1\n    curr += 5 * ans\nprint(min(n, ans))", "generated_code": "# -*- coding:utf-8 -*-\n\n\"\"\"\n\ncreated by shuangquan.huang at 2/9/20\n\n\"\"\"\n# cook your dish here\nn,k = map(int,input().split())\nl = []\nfor i in range(1,n+1):\n\tl.append(i*60)\nl.sort()\nans = 0\nn = n - 1\nfor i in reversed(l):\n\tif(i<=k):\n\t\tans += 1\n\telse:\n\t\tbreak\nprint(ans)\n", "score": 0.082, "codebleu": 0.2710170155851048, "crystalbleu": 0, "codebertscore": 0.72, "codescore": 0.0908518061041832, "surfaceSim": 0.6005766621438263, "abs_surfaceSim_minus_score": 0.5185766621438264, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_12_7", "golden_code": "def sort_String(str) : \r\n    str = ''.join(sorted(str)) \r\n    return (str) ", "generated_code": "def sort_String(s: str) -> str:\n\treturn ''.join(sorted([x for x in s if len(x) > 0]))\nOptimum = {}", "score": 0.0, "codebleu": 0.19275975421724645, "crystalbleu": 0, "codebertscore": 0.82, "codescore": 0.02381935715675354, "surfaceSim": 0.6488595438175271, "abs_surfaceSim_minus_score": 0.6488595438175271, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_extra_p03796_s383796227_OP_1", "golden_code": "from math import factorial\n\nprint((factorial(int(eval(input()))) % (10**9+7)))", "generated_code": "ans = 1\n\nfor k in range(1, int(eval(input()))+1):\n\n    ans = ans*k % (10**9+7)\n\nprint(ans)", "score": 1.0, "codebleu": 0.2478962103014375, "crystalbleu": 0, "codebertscore": 0.8, "codescore": 0.7527241706848145, "surfaceSim": 0.49583333333333335, "abs_surfaceSim_minus_score": 0.5041666666666667, "source": "local", "local_type": "OP"}
{"id": "LOCAL_MBPP_453_MUT_30", "golden_code": "import os\n\nimport math\ndef sumofFactors(n):\n    if n % 2 != 0:\n        return 0\n    res = 1\n    for i in range(2, int(math.sqrt(n)) + 1):\n        count = 0\n        curr_sum = 1\n        curr_term = 1\n        while n % i == 0:\n            count = count + 1\n            n = n // i\n            if (i == 2 and count == 1):\n                curr_sum = 0\n            curr_term = curr_term * i\n            curr_sum = curr_sum + curr_term\n        res = res * curr_sum\n    if n >= 2:\n        res = res * (1 + n)\n    return res", "generated_code": "import os\n\nimport math\ndef sumofFactors(n):\n    if n % 2 != 0:\n        return 0\n    res = 1\n    for i in range(2, int(math.sqrt(n)) + 1):\n        count = 0\n        curr_sum = 1\n        curr_term = 1\n        while n % i == 0:\n            count = count + 1\n            n = n // i\n            if (i != 2 and count == 1):\n                curr_sum = 0\n            curr_term = curr_term * i\n            curr_sum = curr_sum + curr_term\n        res = res * curr_sum\n    if n >= 2:\n        res = res * (1 + n)\n    return res", "score": 0.3651, "codebleu": 0.9856633619349873, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.9936500191688538, "surfaceSim": 0.9990291262135922, "abs_surfaceSim_minus_score": 0.6339291262135922, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-1002_30", "golden_code": "n, d = map(int, input().split())\nt = list(map(int, input().split()))\nsum_time = (n - 1) * 10 + sum(t)\nif sum_time > d:\n    print(-1)\nelse:\n    res_time = d - sum_time\n    cnt = res_time / 5 + (n - 1) * 2\n    print(int(cnt))", "generated_code": "n,d = list(map(int,input().split()))\n\nl = list(map((int),input().split()));\n\nresult = sum(l)\n\nif result <= d:\n\tprint(result)\nelse:\n\tprint(-1)\n", "score": 0.439, "codebleu": 0.2248260255348328, "crystalbleu": 0.23, "codebertscore": 0.83, "codescore": 0.3918246328830719, "surfaceSim": 0.6382660687593422, "abs_surfaceSim_minus_score": 0.19926606875934222, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_82_OP_2", "golden_code": "def prime_length(string):\n    l = len(string)\n    if l == 0 or l == 1:\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n            return False\n    return True", "generated_code": "def prime_length(text):\n    length = len(text)\n    if length < 2:\n        return False\n    if length in (2, 3):\n        return True\n    if length % 2 == 0 or length % 3 == 0:\n        return False\n    for divisor in range(5, int(length**0.5) + 1, 6):\n        if length % divisor == 0 or length % (divisor + 2) == 0:\n            return False\n    return True", "score": 1.0, "codebleu": 0.43686173604088424, "crystalbleu": 0, "codebertscore": 0.84, "codescore": 0.9936466217041016, "surfaceSim": 0.7042840375586854, "abs_surfaceSim_minus_score": 0.2957159624413146, "source": "local", "local_type": "OP"}
{"id": "LOCAL_MBPP_493_MUT_38", "golden_code": "import os\n\nimport math\ndef calculate_polygons(startx, starty, endx, endy, radius):\n    sl = (2 * radius) * math.tan(math.pi / 6)\n    p = sl * 0.5\n    b = sl * math.cos(math.radians(30))\n    w = b * 2\n    h = 2 * sl\n    startx = startx - w\n    starty = starty - h\n    endx = endx + w\n    endy = endy + h\n    origx = startx\n    origy = starty\n    xoffset = b\n    yoffset = 3 * p\n    polygons = []\n    row = 1\n    counter = 0\n    while starty < endy:\n        if row % 2 == 0:\n            startx = origx + xoffset\n        else:\n            startx = origx\n        while startx < endx:\n            p1x = startx\n            p1y = starty + p\n            p2x = startx\n            p2y = starty + (3 * p)\n            p3x = startx + b\n            p3y = starty + h\n            p4x = startx + w\n            p4y = starty + (3 * p)\n            p5x = startx + w\n            p5y = starty + p\n            p6x = startx + b\n            p6y = starty\n            poly = [\\\n                (p1x, p1y), \\\n                (p2x, p2y), \\\n                (p3x, p3y), \\\n                (p4x, p4y), \\\n                (p5x, p5y), \\\n                (p6x, p6y), \\\n                (p1x, p1y)]\n            polygons.append(poly)\n            counter += 1\n            startx += w\n        starty += yoffset\n        row += 1\n    return polygons", "generated_code": "import os\n\nimport math\ndef calculate_polygons(startx, starty, endx, endy, radius):\n    sl = (2 * radius) * math.tan(math.pi / 6)\n    p = sl * 0.5\n    b = sl * math.cos(math.radians(30))\n    w = b * 2\n    h = 2 * sl\n    startx = startx - w\n    starty = starty - h\n    endx = endx + w\n    endy = endy + h\n    origx = startx\n    origy = starty\n    xoffset = b\n    yoffset = 3 * p\n    polygons = []\n    row = 1\n    counter = 0\n    while starty < endy:\n        if row % 2 == 0:\n            startx = origx + xoffset\n        else:\n            startx = origx\n        while startx < endx:\n            p1x = startx\n            p1y = starty + p\n            p2x = startx\n            p2y = starty + (3 * p)\n            p3x = startx + b\n            p3y = starty + h\n            p4x = startx + w\n            p4y = starty - (3 * p)\n            p5x = startx + w\n            p5y = starty + p\n            p6x = startx + b\n            p6y = starty\n            poly = [\\\n                (p1x, p1y), \\\n                (p2x, p2y), \\\n                (p3x, p3y), \\\n                (p4x, p4y), \\\n                (p5x, p5y), \\\n                (p6x, p6y), \\\n                (p1x, p1y)]\n            polygons.append(poly)\n            counter += 1\n            startx += w\n        starty += yoffset\n        row += 1\n    return polygons", "score": 0.0, "codebleu": 0.9937480014850033, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9937068819999695, "surfaceSim": 0.9996162701458173, "abs_surfaceSim_minus_score": 0.9996162701458173, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-1957_14", "golden_code": "n,a,b = map(int, input().split())\ns = list(map(int, input().split()))\nsm = sum(s)\ns0 = s.pop(0)\ns = sorted(s)\nfor i in range(n):\n    if i == 0:\n        if a * s0 / sm >= b:\n            print(0)\n            break\n    else:\n        sm -= s[-i]\n        if a * s0 / sm >= b:\n            print(i)\n            break", "generated_code": "n,a,b = map(int,input().split())\ns = list(map(int,input()))\nm = [0]\nfor i in range(n):\n\tm.append(s[i] + m[-1])\nans = 0\nwhile m[0] < b:\n\tm.sort()\n\tans += 1\n\tm[0] += a\nfor i in m:\n\tif i == b:\n\t\tbreak\n\tans += i//a\nprint(ans)\n", "score": 0.0, "codebleu": 0.2984794306620904, "crystalbleu": 0.29, "codebertscore": 0.84, "codescore": 0.06438575685024261, "surfaceSim": 0.6590614886731392, "abs_surfaceSim_minus_score": 0.6590614886731392, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-1882_14", "golden_code": "# -*- coding:utf-8 -*-\n\n\"\"\"\n\ncreated by shuangquan.huang at 1/11/18\n\n\"\"\"\n\nimport math\nimport collections\nimport bisect\nimport heapq\nimport time\nimport random\nimport itertools\nimport sys\n\nN, T = list(map(int, input().split()))\n#\n# N, T = 200000, 1000000000\n\nta = []\nfor i in range(N):\n  a, t = list(map(int, input().split()))\n  ta.append((t, a, i+1))\n  # ta.append((10000, 200000, i+1))\n\nta.sort()\n\n\nscore = 0\nsolvedCount = 0\naks = []\nheapq.heapify(aks)\nsc = collections.defaultdict(list)\nfor i in range(N):\n  t, a, _ = ta[i]\n  if T < t:\n    break\n\n  T -= t\n  solvedCount += 1\n\n  sc[a].append((t, i))\n  heapq.heappush(aks, a)\n  removed = []\n  while aks and aks[0] < solvedCount:\n    k = heapq.heappop(aks)\n    removed.append(k)\n    v = sc[k]\n    solvedCount -= len(v)\n    for _, j in v:\n      T += ta[j][0]\n    del sc[k]\n\n  score = max(score, solvedCount)\n\n\nprint(score)\nprint(score)\n\nvta = [(t, a, i) for t, a, i in ta if a >= score]\nvta.sort()\nans = [i for _, _, i in vta[:score]]\nprint(\" \".join(map(str, ans)))\n\n\n", "generated_code": "import sys\n\nn, t = list(map(int, sys.stdin.readline().split()))\nA = [0]*n\n\nfor i in range(n):\n\tx, y = list(map (int, sys. stdin.readline_.split()))\n\tA[i] = (x, y)\n\nans = 0\ndone = set()\nqueries = []\n\nfor i, a in enumerate(A):\n\tt_left = t - a[1]\n\tif t_left in done:\n\t\tque.append((done.remove(t_left), i+1))\n\telse:\n\t\tqueries.append((t_left, i+1))\n\n\tdone.add(a[0])\n\tif len(queries) > 1:\n\t\tans += len(set(queries))\n\t\t# print (len", "score": 0.0, "codebleu": 0.18723748674971466, "crystalbleu": 0.08, "codebertscore": 0.72, "codescore": 0.018294569104909897, "surfaceSim": 0.5242747673782157, "abs_surfaceSim_minus_score": 0.5242747673782157, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_71_19", "golden_code": "import math\r\ndef get_First_Set_Bit_Pos(n):\r\n     return math.log2(n&-n)+1", "generated_code": "import math\ndef get_First_Set_Bit_Pos(n): \n\tresult = 0\n\twhile n>0:\n\t\tresult = result^n%2\n\t\tn = n//2\n\treturn result", "score": 0.155, "codebleu": 0.3841293019802824, "crystalbleu": 0, "codebertscore": 0.84, "codescore": 0.13278605043888092, "surfaceSim": 0.513859649122807, "abs_surfaceSim_minus_score": 0.358859649122807, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_421_1", "golden_code": "def neg_nos(list1):\r\n  for num in list1: \r\n    if num < 0: \r\n       return num ", "generated_code": "def neg_nos(list1):\n\tresult = []\n\tfor x in list1:\n\t\tif x <= 0:\n\t\t\tresult.append(x)\n\t\telse:\n\t\t\tpass\n\treturn result\n\n\n\n\n\n\n\n\nb = []\nfor i in range(len(b)):\n\tb.append(i)\nfor i2 in b:\n\tfor i in d:\n\t\tc.append(a[i2-i])\n\t\ta[i] -= 1\n\ta[0] += 1", "score": 0.0, "codebleu": 0.2647824696485079, "crystalbleu": 0, "codebertscore": 0.78, "codescore": 0.030376657843589783, "surfaceSim": 0.43162393162393164, "abs_surfaceSim_minus_score": 0.43162393162393164, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_161_MUT_5", "golden_code": "import os\n\ndef solve(s):\n    flg = 0\n    idx = 0\n    new_str = list(s)\n    for i in s:\n        if i.isalpha():\n            new_str[idx] = i.swapcase()\n            flg = 1\n        idx += 1\n    s = ''\n    for i in new_str:\n        s += i\n    if flg == 0:\n        return s[len(s)::-1]\n    return s", "generated_code": "import os\n\ndef solve(s):\n    flg = 0\n    idx = 0\n    new_str = list(s)\n    for i in s:\n        if not (i.isalpha()):\n            new_str[idx] = i.swapcase()\n            flg = 1\n        idx += 1\n    s = ''\n    for i in new_str:\n        s += i\n    if flg == 0:\n        return s[len(s)::-1]\n    return s", "score": 0.4248, "codebleu": 0.9355624713427253, "crystalbleu": 0, "codebertscore": 0.99, "codescore": 0.993710994720459, "surfaceSim": 0.9724358974358974, "abs_surfaceSim_minus_score": 0.5476358974358975, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-0267_20", "golden_code": "\n\n\nl, r, k =list(map(int,input().split()))\n\nd = {i:2**i for i in range(10)}\n\ncache = {}\n\ndef can(i, m):\n    return d[i] & m\n\ndef calc(m):\n    b = 1\n    c = 0\n    for i in range(10):\n        if b & m:\n            c += 1\n        b *= 2\n\n    return c\n\ndef sm(ln, k, m, s='', first=False):\n    if ln < 1:\n        return 0, 1\n\n    if (ln, k, m, s, first) in cache:\n        return cache[(ln, k, m, s, first)]\n\n    ans = 0\n    count = 0\n    base = 10 ** (ln-1)\n\n    use_new = calc(m) < k\n\n    if s:\n        finish = int(s[0])+1\n    else:\n        finish = 10\n\n    for i in range(finish):\n        if use_new or can(i, m):\n            ss = s[1:]\n            if i != finish-1:\n                ss = ''\n            nm = m | d[i]\n            nfirst = False\n            if i == 0 and first:\n                nm = m\n                nfirst = True\n            nexta, nextc = sm(ln-1, k, nm, ss, nfirst)\n            ans += base * i * nextc + nexta\n            count += nextc\n\n#    print(ln, k, m, s, first, ans, count)\n    cache[(ln, k, m, s, first)] = (ans, count)\n\n    return ans, count\n\ndef call(a, k):\n    s = str(a)\n    return sm(len(s), k, 0, s, True)[0]\n\n\n#print(call(r, k) - call(l-1, k))\nprint((call(r, k) - call(l-1, k)) % 998244353)\n", "generated_code": "\nimport sys\ninput = sys.stdin.readline\n\nMOD = 998244353\n\nl, r, k = map(int, input().split())\nout = 0\nadd = 1\nfor i in range(1, 11):\n\tfor j in range(10):\n\t\tout += add\n\t\tadd *= 9\n\t\tadd %= MOD\n\nout *= (r - l + 1)\nprint(out % MOD)\n", "score": 0.0, "codebleu": 0.06969607442966758, "crystalbleu": 0.01, "codebertscore": 0.71, "codescore": 0.05876296013593674, "surfaceSim": 0.4626275306870715, "abs_surfaceSim_minus_score": 0.4626275306870715, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_2323_12_OP_1", "golden_code": "import copy\nimport bisect\n\nn = int(input())\ns = list(map(int, input().split()))\nsCopy = copy.deepcopy(s)\n\nAP = []\nmx = -1\nsCopy.sort()\nmiss = []\nfor i in range(n-1):\n    mx = max(mx, sCopy[i+1]-sCopy[i]-1, 0)\n    miss.append(max(sCopy[i+1]-sCopy[i]-1, 0))\n\nmiss.sort()\nif miss!=[]:\n    pSOfMiss = [miss[0]]\n    for i in range(1, len(miss)):\n        pSOfMiss.append(pSOfMiss[-1]+miss[i])\n\nMAX = max(s)\nMIN = min(s)\nC = len(set(s))\nansList = []\nmL = len(miss)\nq = int(input())\nfor _ in range(q):\n    l, r = list(map(int, input().split()))\n    if l==r:\n        ansList.append(C)\n    elif n==1:\n        ans = r-l+1\n        ansList.append(ans)\n    elif r-l>=mx:\n        ans = (MAX+r)-(MIN+l)+1\n        ansList.append(ans)\n    else:\n        idx = bisect.bisect_right(miss, r-l)\n        if idx>0:\n            notThere = pSOfMiss[-1]-pSOfMiss[idx-1]-((r-l)*(mL-idx))\n        else:\n            notThere = pSOfMiss[-1] - ((r-l)*(mL-idx))\n        ans = (MAX+r)-(MIN+l)+1-notThere\n        ansList.append(ans)\n\nprint(*ansList)", "generated_code": "import bisect\n\ndef main():\n    num_elements = int(input())\n    sequence = list(map(int, input().split()))\n\n    sorted_sequence = sorted(sequence)\n    gaps = [sorted_sequence[i + 1] - sorted_sequence[i] - 1 for i in range(num_elements - 1)]\n    max_gap = max(gaps, default=0)\n\n    prefix_sum = [0] * len(gaps)\n    if gaps:\n        prefix_sum[0] = gaps[0]\n        for i in range(1, len(gaps)):\n            prefix_sum[i] = prefix_sum[i - 1] + gaps[i]\n\n    max_val = max(sequence)\n    min_val = min(sequence)\n    unique_count = len(set(sequence))\n\n    num_queries = int(input())\n    results = []\n    for _ in range(num_queries):\n        left, right = map(int, input().split())\n        if left == right:\n            results.append(unique_count)\n        elif num_elements == 1:\n            results.append(right - left + 1)\n        elif right - left >= max_gap:\n            results.append((max_val + right) - (min_val + left) + 1)\n        else:\n            index = bisect.bisect_right(gaps, right - left)\n            if index > 0:\n                missing = prefix_sum[-1] - prefix_sum[index - 1] - ((right - left) * (len(gaps) - index))\n            else:\n                missing = prefix_sum[-1] - ((right - left) * (len(gaps) - index))\n            results.append((max_val + right) - (min_val + left) + 1 - missing)\n\n    print(*results)\n\nmain()", "score": 1.0, "codebleu": 0.3331439944541022, "crystalbleu": 0.25, "codebertscore": 0.79, "codescore": 0.1625596582889557, "surfaceSim": 0.6956091337058383, "abs_surfaceSim_minus_score": 0.3043908662941617, "source": "local", "local_type": "OP"}
{"id": "APPS_test-1128_19", "golden_code": "a,m = map(int,input().split())\n\nfor i in range(31):\n    if a%m==0:\n        print(\"Yes\")\n        quit()\n    else:\n        a+=a%m\nprint(\"No\")", "generated_code": "a, m = [int(x) for x in input().split()]\nif a % m == 0:\n\tprint(\"No\")\nelse:\n\tprint((a//m)*m)\n", "score": 0.0, "codebleu": 0.23475093891645932, "crystalbleu": 0, "codebertscore": 0.86, "codescore": 0.2416859269142151, "surfaceSim": 0.6430673642903859, "abs_surfaceSim_minus_score": 0.6430673642903859, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-1312_16", "golden_code": "def main():\n    n, m = list(map(int, input().split()))\n    n, r = divmod(n, m)\n    print(\" \".join([str(n)] * (m - r) + [str(n + 1)] * r))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "generated_code": "n,m = map(int,input().split())\nans = [0]*(m+1)\nnew = list(range(1,m+1))\nfor i in range(1,n+1):\n\tans[new[i]] += 1\nfor i in new:\n\tj = min(ans[i],i)\n\twhile ans[j]!= 0:\n\t\tans[j] -= 1\n\t\tj += 1\nprint(sum(ans[1:]))\n", "score": 0.0, "codebleu": 0.15107017525814986, "crystalbleu": 0, "codebertscore": 0.77, "codescore": 0.024032294750213623, "surfaceSim": 0.4658653846153846, "abs_surfaceSim_minus_score": 0.4658653846153846, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-1874_12", "golden_code": "import math\n\na,b,c=map(float,input().split())\nans=0.0\nans += float(math.pow(a,3)*math.sqrt(2)/12);\nans += float(math.pow(b,3)*math.sqrt(2)/6);\nans += float(5*math.pow(c,3)*math.tan(math.radians(54))*math.sqrt(1-1/(4*math.cos(math.radians(54))*math.cos(math.radians(54))))/12);\nprint(\"%.20f\" % ans)", "generated_code": "a, b, c = list(map(int, input().split()))\np = sum([a, b, int(4*b*c-a*c)])\nprint(p)\n", "score": 0.0, "codebleu": 0.07130152751621678, "crystalbleu": 0.04, "codebertscore": 0.77, "codescore": 0.018450675532221794, "surfaceSim": 0.4276936026936027, "abs_surfaceSim_minus_score": 0.4276936026936027, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-3755_6", "golden_code": "n = int(input())\na = list(map(int, input().split()))\nmx = max(a)\na[a.index(mx)] = abs(mx)\nevn = sum(max(0, i) for i in a[::2])\nodd = sum(max(0, i) for i in a[1::2])\nif mx < 0:\n    print(mx)\nelse:\n    print(max(evn, odd))\noe = int(evn < odd)\nres = []\nbeg = 0\nwhile beg%2!=oe or a[beg]<0:\n    res.append(1)\n    beg += 1\nend = n-1\nwhile end%2!=oe or a[end]<0:\n    res.append(end-beg+1)\n    end -= 1\nwhile beg < end:\n    if a[end-2] < 0:\n        res.append(end-beg-1)\n    else:\n        res.append(end-beg)\n    end -= 2\nprint(len(res))\nfor i in res:\n    print(i)", "generated_code": "def main():\n\timport sys\n\tinput = sys.stdin.readline\n\n\tN = int(input())\n\tA = list(map(int, input().split()))\n\n\tif N == 1:\n\t\tprint(0)\n\t\tprint((0))\n\t\treturn\n\t\n\tpre = A[0]\n\tsuf = A[-1]\n\tans = 0\n\tfor i in range(1, N):\n\t\tif A[i] > pre:\n\t\t\tpre = A[i]\n\t\telse:\n\t\t\tif A[i-1] > suf:\n\t\t\t\tsuf = A[_i]\n\t\t\tans += 1\n\n\tif A[-1:] == pre:\n\t\tprint (ans)\n\t\tprint ((ans+1))\n\telse:\n\t\tprint((ans))\n\t\tprint((abs(A[-1]-pre) + 1))\n", "score": 0.0, "codebleu": 0.14317415587263727, "crystalbleu": 0.1, "codebertscore": 0.76, "codescore": 0.03471773862838745, "surfaceSim": 0.46052695424329176, "abs_surfaceSim_minus_score": 0.46052695424329176, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_17_38", "golden_code": "def all_Bits_Set_In_The_Given_Range(n,l,r): \r\n    num = ((1 << r) - 1) ^ ((1 << (l - 1)) - 1) \r\n    new_num = n & num \r\n    if (num == new_num): \r\n        return True\r\n    return False", "generated_code": "def all_Bits_Set_In_The_Given_Range(n,l,r): \n\treturn bin(n)[2:] == list(range(l,r))", "score": 0.6, "codebleu": 0.10829623696057111, "crystalbleu": 0, "codebertscore": 0.81, "codescore": 0.632258415222168, "surfaceSim": 0.5397256728778468, "abs_surfaceSim_minus_score": 0.06027432712215319, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-1592_4", "golden_code": "n = int(input())\n\nmessage = 0\nm = 0\nl = 0\n\nfor _ in range(n):\n    t, c = list(map(int, input().split()))\n    message = max(0, message-(t-l))\n    message += c\n    m = max(message, m)\n    l = t\n\nprint(l+message, m)\n    \n", "generated_code": "n = int(input())\n\nxs = []\n\nfor _ in range(n):\n\tt, c = list(map(int, input().split()))\n\txs.append((t, c))\n\nxs.sort(key=lambda x: x[0])\n\nres, s = 0, 0\n\nfor _, c in xs:\n\tif c > s:\n\t\tres += 1\n\t\ts = c\n\telse:\n\t\tres = max(res, c + s)\n\t\ts = 0\nres = max(0, res - s)\n\nprint(res, s)\n", "score": 0.0, "codebleu": 0.4122868074167052, "crystalbleu": 0, "codebertscore": 0.83, "codescore": 0.19271376729011536, "surfaceSim": 0.58125, "abs_surfaceSim_minus_score": 0.58125, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_extra_p02596_s734835984_OP_1", "golden_code": "K = int(eval(input()))\n\n\n\nflg = [False]*K\n\n\n\ntmp = 7 % K\n\ncnt = 1\n\nif tmp == 0:\n\n    print(cnt)\n\n    exit()\n\nwhile True:\n\n    tmp = (tmp*10+7)%K\n\n    if flg[tmp]:\n\n        print((-1))\n\n        break\n\n    else:\n\n        cnt += 1\n\n        if tmp == 0:\n\n            print(cnt)\n\n            break\n\n        flg[tmp] = True\n", "generated_code": "K = int(eval(input()))\n\nt = 7\n\nt %= K\n\n\n\nfor i in range(K+1):\n\n    if t == 0:\n\n        print((i+1))\n\n        exit()\n\n    t = (t*10+7)%K\n\nprint((-1))\n", "score": 1.0, "codebleu": 0.23309663087280003, "crystalbleu": 0, "codebertscore": 0.82, "codescore": 0.7737250924110413, "surfaceSim": 0.684748427672956, "abs_surfaceSim_minus_score": 0.31525157232704404, "source": "local", "local_type": "OP"}
{"id": "MBPP_38_4", "golden_code": "def find_fixed_point(arr, n): \r\n\tfor i in range(n): \r\n\t\tif arr[i] is i: \r\n\t\t\treturn i \r\n\treturn -1", "generated_code": "def find_fixed_point(arr, num):\n\tfor i in range(-1, 1-len(arr), -1):\n\t\tmp = arr[i] + num\n\t\tif mp == int(mp):\n\t\t\treturn True\n\treturn False\nduplicate = [1,2,3,4,5,6,7,8,9]", "score": 0.0245, "codebleu": 0.26120645722781155, "crystalbleu": 0, "codebertscore": 0.8, "codescore": 0.05743714049458504, "surfaceSim": 0.6352317554240632, "abs_surfaceSim_minus_score": 0.6107317554240632, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0124_12", "golden_code": "x, y, z = map(int, input().split())\na, b, c = map(int, input().split())\nbad = False\nif a >= x and a + b >= x + y and a + b + c >= x + y + z:\n\tprint('YES')\nelse:\n\tprint('NO')", "generated_code": "x,y,z = map(int,input().split())\na,b,c = map(int,input().split())  \nreturn \"NO\" if a<b or b<c or c<a else \"YES\"\n", "score": 0.0, "codebleu": 0.29708749748962787, "crystalbleu": 0.25, "codebertscore": 0.86, "codescore": 0.06620979309082031, "surfaceSim": 0.5798238370492705, "abs_surfaceSim_minus_score": 0.5798238370492705, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_4496_54_OP_1", "golden_code": "a = int(input())\nif a == 22:\n  print('Christmas Eve Eve Eve')\nelif a == 23:\n  print('Christmas Eve Eve')\nelif a == 24:\n  print('Christmas Eve')\nelse:\n  print('Christmas')", "generated_code": "day = int(input())\ndays_to_christmas = {22: 'Christmas Eve Eve Eve', 23: 'Christmas Eve Eve', 24: 'Christmas Eve'}\nprint(days_to_christmas.get(day, 'Christmas'))", "score": 1.0, "codebleu": 0.2519366707889479, "crystalbleu": 0, "codebertscore": 0.84, "codescore": 0.8894256353378296, "surfaceSim": 0.5665158371040724, "abs_surfaceSim_minus_score": 0.4334841628959276, "source": "local", "local_type": "OP"}
{"id": "LOCAL_MBPP_747_OP_1", "golden_code": "def lcs_of_three(X, Y, Z, m, n, o): \r\n\tL = [[[0 for i in range(o+1)] for j in range(n+1)] \r\n\t\tfor k in range(m+1)] \r\n\tfor i in range(m+1): \r\n\t\tfor j in range(n+1): \r\n\t\t\tfor k in range(o+1): \r\n\t\t\t\tif (i == 0 or j == 0 or k == 0): \r\n\t\t\t\t\tL[i][j][k] = 0\r\n\t\t\t\telif (X[i-1] == Y[j-1] and\r\n\t\t\t\t\tX[i-1] == Z[k-1]): \r\n\t\t\t\t\tL[i][j][k] = L[i-1][j-1][k-1] + 1\r\n\t\t\t\telse: \r\n\t\t\t\t\tL[i][j][k] = max(max(L[i-1][j][k], \r\n\t\t\t\t\tL[i][j-1][k]), \r\n\t\t\t\t\t\t\t\t\tL[i][j][k-1]) \r\n\treturn L[m][n][o]", "generated_code": "def lcs_of_three(A, B, C, len_a, len_b, len_c):\n    if len_a == 0 or len_b == 0 or len_c == 0:\n        return 0\n\n    dp_prev = [[0] * (len_c + 1) for _ in range(len_b + 1)]\n    dp_curr = [[0] * (len_c + 1) for _ in range(len_b + 1)]\n\n    for i in range(1, len_a + 1):\n        for j in range(1, len_b + 1):\n            for k in range(1, len_c + 1):\n                if A[i - 1] == B[j - 1] == C[k - 1]:\n                    dp_curr[j][k] = dp_prev[j - 1][k - 1] + 1\n                else:\n                    dp_curr[j][k] = max(dp_curr[j - 1][k], dp_curr[j][k - 1], dp_prev[j][k])\n        dp_prev, dp_curr = dp_curr, dp_prev\n\n    return dp_prev[len_b][len_c]", "score": 1.0, "codebleu": 0.24848743391951691, "crystalbleu": 0.26, "codebertscore": 0.79, "codescore": 0.985310435295105, "surfaceSim": 0.7300981461286804, "abs_surfaceSim_minus_score": 0.2699018538713196, "source": "local", "local_type": "OP"}
{"id": "MBPP_34_85", "golden_code": "def even_num(x):\r\n  if x%2==0:\r\n     return True\r\n  else:\r\n    return False", "generated_code": "def even_num(x):\n\n  return x % 4 == 0", "score": 0.6172, "codebleu": 0.34087243935380335, "crystalbleu": 0, "codebertscore": 0.85, "codescore": 0.6258869767189026, "surfaceSim": 0.7482051282051282, "abs_surfaceSim_minus_score": 0.13100512820512822, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0564_20", "golden_code": "n,m = map(int,input().split())\na = list(map(int,input().split()))\nif sum(a) - max(a) <= m:\n    print('YES')\nelse:\n    print('NO')", "generated_code": "n, s = list(map(int, input().split()))\na = list(map (int, input().strip().split()))[:n]\n\nresult = {}\nfor i in a:\n\tif i in result:\n\t\tresult[i] += 1\n\telse:\n\t\tresult.update({i: 1})\n\nif (n - 1 ) in result:\n\tprint (\"YES\")\nelse:\n\tprint(\"NO\")\n", "score": 0.4898, "codebleu": 0.35490819383783556, "crystalbleu": 0.14, "codebertscore": 0.83, "codescore": 0.22163958847522736, "surfaceSim": 0.5861274871039057, "abs_surfaceSim_minus_score": 0.0963274871039057, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_MBPP_771_OP_2", "golden_code": "from collections import deque\r\ndef check_expression(exp):\r\n    if len(exp) & 1:\r\n        return False\r\n    stack = deque()\r\n    for ch in exp:\r\n        if ch == '(' or ch == '{' or ch == '[':\r\n            stack.append(ch)\r\n        if ch == ')' or ch == '}' or ch == ']':\r\n            if not stack:\r\n                return False\r\n            top = stack.pop()\r\n            if (top == '(' and ch != ')') or (top == '{' and ch != '}' or (top == '[' and ch != ']')):\r\n                return False\r\n    return not stack", "generated_code": "from collections import deque\ndef check_expression(sequence):\n    if len(sequence) % 2 != 0:\n        return False\n    bracket_map = {')': '(', '}': '{', ']': '['}\n    stack = deque()\n    for char in sequence:\n        if char in bracket_map.values():\n            stack.append(char)\n        elif char in bracket_map:\n            if not stack or stack.pop() != bracket_map[char]:\n                return False\n    return not stack", "score": 1.0, "codebleu": 0.2436928778493508, "crystalbleu": 0.23, "codebertscore": 0.83, "codescore": 0.993158757686615, "surfaceSim": 0.6969844357976653, "abs_surfaceSim_minus_score": 0.30301556420233466, "source": "local", "local_type": "OP"}
{"id": "LOCAL_MBPP_60_MUT_10", "golden_code": "import os\n\ndef max_len_sub(arr, n):\n    mls = []\n    max = 0\n    for i in range(n):\n        mls.append(1)\n    for i in range(n):\n        for j in range(i):\n            if (abs(arr[i] - arr[j]) <= 1 and mls[i] < mls[j] + 1):\n                mls[i] = mls[j] + 1\n    for i in range(n):\n        if max < mls[i]:\n            max = mls[i]\n    return max", "generated_code": "import os\n\ndef max_len_sub(arr, n):\n    mls = []\n    max = 0\n    for i in range(n):\n        mls.append(1)\n    for i in range(n):\n        for j in range(i):\n            if (abs(arr[i] - arr[j]) <= 1 and mls[i] < mls[j] + 1):\n                mls[i] = mls[j] + 1\n        break\n    for i in range(n):\n        if max < mls[i]:\n            max = mls[i]\n    return max", "score": 0.1791, "codebleu": 0.9592672342300396, "crystalbleu": 0.95, "codebertscore": 1.0, "codescore": 0.9937738180160522, "surfaceSim": 0.974448371382176, "abs_surfaceSim_minus_score": 0.795348371382176, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_MBPP_289_MUT_16", "golden_code": "import os\n\ndef odd_Days(N):\n    hund1 = N // 100\n    hund4 = N // 400\n    leap = N >> 2\n    ordd = N - leap\n    if hund1:\n        ordd += hund1\n        leap -= hund1\n    if hund4:\n        ordd -= hund4\n        leap += hund4\n    days = ordd + (leap * 2)\n    odd = days % 7\n    return odd", "generated_code": "import os\n\ndef odd_Days(N):\n    hund1 = N // 100\n    hund4 = N // 400\n    leap = N >> 2\n    ordd = N - leap\n    if hund1:\n        ordd += hund1\n        leap -= hund1\n    if not hund4:\n        ordd -= hund4\n        leap += hund4\n    days = ordd + (leap * 2)\n    odd = days % 7\n    return odd", "score": 0.3074, "codebleu": 0.9615881891372013, "crystalbleu": 0, "codebertscore": 0.99, "codescore": 0.993728518486023, "surfaceSim": 0.9513493253373313, "abs_surfaceSim_minus_score": 0.6439493253373313, "source": "local", "local_type": "MUT"}
{"id": "MBPP_17_20", "golden_code": "def all_Bits_Set_In_The_Given_Range(n,l,r): \r\n    num = ((1 << r) - 1) ^ ((1 << (l - 1)) - 1) \r\n    new_num = n & num \r\n    if (num == new_num): \r\n        return True\r\n    return False", "generated_code": "def all_Bits_Set_In_The_Given_Range(n,l,r): \n\treturn bin(n)[2] == bin(l)[2] and bin(r)[2] in \"02468\"", "score": 0.5461, "codebleu": 0.1252469266593362, "crystalbleu": 0, "codebertscore": 0.79, "codescore": 0.6360940337181091, "surfaceSim": 0.5072463768115942, "abs_surfaceSim_minus_score": 0.038853623188405795, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_281_2", "golden_code": "def even_Power_Sum(n): \r\n    sum = 0; \r\n    for i in range(1,n + 1): \r\n        j = 2*i; \r\n        sum = sum + (j*j*j*j); \r\n    return sum; ", "generated_code": "def even_Power_Sum(n):    \n\treturn str(bin(n)[2:].zfill(3)[::-1])", "score": 0.0, "codebleu": 0.04623103449188324, "crystalbleu": 0, "codebertscore": 0.76, "codescore": 0.059637609869241714, "surfaceSim": 0.527158273381295, "abs_surfaceSim_minus_score": 0.527158273381295, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_p02599_s870922238_MUT_33", "golden_code": "import sys\nclass BinaryIndexedTree:\n    def __init__(self, A):\n        self.__n = len(A)\n        self.__node = [0] * (self.__n + 1)\n        self.__data = [0] * (self.__n + 1)\n        S = [0] * (self.__n + 1)\n        for i in range(1, self.__n + 1):\n            S[i] = S[i - 1] + A[i - 1]\n            self.__data[i] = A[i - 1]\n            self.__node[i] = S[i] - S[i - (i & (-i))]\n    def add(self, i, v):\n        self.__data[i] += v\n        while i <= self.__n:\n            self.__node[i] += v\n            i += i & (-i)\n    def sum(self, i):\n        rst = 0\n        while i > 0:\n            rst += self.__node[i]\n            i -= i & (-i)\n        return rst\n    def get(self, i, j):\n        if i == j:\n            return self.__data[i]\n        else:\n            return self.sum(j) - self.sum(i - 1)\ndef main():\n    (N, Q) = map(int, input().split())\n    C = list(map(int, input().split()))\n    P = [[] for _ in range(N)]\n    for (i, c) in enumerate(C):\n        P[c - 1].append(i)\n    right = [0] * N\n    for p in P:\n        if len(p):\n            right[p.pop()] = 1\n    BIT = BinaryIndexedTree(right)\n    query = [[] for _ in range(N)]\n    for (i, s) in enumerate(sys.stdin.readlines()):\n        (l, r) = map(int, s.split())\n        query[r - 1].append((l - 1, i))\n    ans = [None] * Q\n    cur = N - 1\n    for (r, q) in enumerate(reversed(query)):\n        r = (N - 1) - r\n        while q:\n            (l, i) = q.pop()\n            while r < cur:\n                c = C[cur] - 1\n                p = P[c]\n                if len(p):\n                    BIT.add(p.pop() + 1, 1)\n                cur -= 1\n            tmp = BIT.get(l + 1, r + 1)\n            ans[i] = tmp\n    print(sep='\\n', *ans)", "generated_code": "import sys\nclass BinaryIndexedTree:\n    def __init__(self, A):\n        self.__n = len(A)\n        self.__node = [0] * (self.__n + 1)\n        self.__data = [0] * (self.__n + 1)\n        S = [0] * (self.__n + 1)\n        for i in range(1, self.__n + 1):\n            S[i] = S[i - 1] + A[i - 1]\n            self.__data[i] = A[i - 1]\n            self.__node[i] = S[i] - S[i - (i & (-i))]\n    def add(self, i, v):\n        self.__data[i] += v\n        while i <= self.__n:\n            self.__node[i] += v\n            i += i & (-i)\n    def sum(self, i):\n        rst = 0\n        while i > 0:\n            rst += self.__node[i]\n            i -= i & (-i)\n        return rst\n    def get(self, i, j):\n        if i == j:\n            return self.__data[i]\n        else:\n            return self.sum(j) - self.sum(i - 1)\ndef main():\n    (N, Q) = map(int, input().split())\n    C = list(map(int, input().split()))\n    P = [[] for _ in range(N)]\n    for (i, c) in enumerate(C):\n        P[c - 1].append(i)\n    right = [0] * N\n    for p in P:\n        if len(p):\n            right[p.pop()] = 1\n    BIT = BinaryIndexedTree(right)\n    query = [[] for _ in range(N)]\n    for (i, s) in enumerate(sys.stdin.readlines()):\n        (l, r) = map(int, s.split())\n        query[r - 1].append((l + 1, i))\n    ans = [None] * Q\n    cur = N - 1\n    for (r, q) in enumerate(reversed(query)):\n        r = (N - 1) - r\n        while q:\n            (l, i) = q.pop()\n            while r < cur:\n                c = C[cur] - 1\n                p = P[c]\n                if len(p):\n                    BIT.add(p.pop() + 1, 1)\n                cur -= 1\n            tmp = BIT.get(l + 1, r + 1)\n            ans[i] = tmp\n    print(sep='\\n', *ans)", "score": 0.0364, "codebleu": 0.994935590512094, "crystalbleu": 1.0, "codebertscore": 1.0, "codescore": 0.99365234375, "surfaceSim": 0.9997036158861885, "abs_surfaceSim_minus_score": 0.9633036158861885, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-1906_19", "golden_code": "n=int(input())\nt=[False]*2521\nsum=0\nfor a in range(2521):\n    t[a]=(a%2==0 or a%3==0 or a%4==0 or a%5==0 or a%6==0 or a%7==0 or a%8==0 or a%9==0 or a%10==0)\n    if not t[a]:\n        sum+=1\n\nret=sum*(n//2520)\nfor a in range(n%2520+1):\n    ret+=(not t[a])\nprint(ret)\n", "generated_code": "n = int(input())\nprint(max(0, n - (n // 2) * 2))\n", "score": 0.055, "codebleu": 0.08442982456140351, "crystalbleu": 0, "codebertscore": 0.71, "codescore": 0.02255355753004551, "surfaceSim": 0.36059506531204644, "abs_surfaceSim_minus_score": 0.30559506531204644, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_67_OP_1", "golden_code": "def fruit_distribution(s,n):\n    lis = list()\n    for i in s.split(' '):\n        if i.isdigit():\n            lis.append(int(i))\n    return n - sum(lis)", "generated_code": "def fruit_distribution(input_string, total_fruits):\n    numbers = map(int, filter(str.isdigit, input_string.split()))\n    return total_fruits - sum(numbers)", "score": 1.0, "codebleu": 0.22982056920713378, "crystalbleu": 0, "codebertscore": 0.81, "codescore": 0.10034599155187607, "surfaceSim": 0.6259426847662142, "abs_surfaceSim_minus_score": 0.3740573152337858, "source": "local", "local_type": "OP"}
{"id": "MBPP_2_13", "golden_code": "def min_Num(arr,n):  \r\n    odd = 0\r\n    for i in range(n): \r\n        if (arr[i] % 2): \r\n            odd += 1 \r\n    if (odd % 2): \r\n        return 1\r\n    return 2", "generated_code": "def min_Num(arr,n):  \n\tres = []\n\tfor i in range(0,n+1):\n\t\tif i % 2 == 0:\n\t\t\tres.append(i)\n\treturn sum(res)", "score": 0.1477, "codebleu": 0.19868130617009103, "crystalbleu": 0, "codebertscore": 0.83, "codescore": 0.09345215559005737, "surfaceSim": 0.7028985507246377, "abs_surfaceSim_minus_score": 0.5551985507246378, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_34_87", "golden_code": "def even_num(x):\r\n  if x%2==0:\r\n     return True\r\n  else:\r\n    return False", "generated_code": "def even_num(x):\n\tif x % 2 == 0:\n\t\treturn True\n\telse:\n\t\tprint(False)\n\treturn False\nopen_square = [i for i in range(1, 3)]\nsquare = [x for x in range(4)]", "score": 1.0, "codebleu": 0.44824644775952366, "crystalbleu": 0, "codebertscore": 0.84, "codescore": 0.9937200546264648, "surfaceSim": 0.611842105263158, "abs_surfaceSim_minus_score": 0.38815789473684204, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_3_5", "golden_code": "def length_Of_Last_Word(a): \r\n    l = 0\r\n    x = a.strip() \r\n    for i in range(len(x)): \r\n        if x[i] == \" \": \r\n            l = 0\r\n        else: \r\n            l += 1\r\n    return l ", "generated_code": "def length_Of_Last_Word(a):\n    \n\treturn(len(a))", "score": 0.8682, "codebleu": 0.05968543270873419, "crystalbleu": 0, "codebertscore": 0.76, "codescore": 0.8373521566390991, "surfaceSim": 0.5324324324324324, "abs_surfaceSim_minus_score": 0.33576756756756754, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0002_21", "golden_code": "n = int(input())\nans = 0\nprev = 0\nN = n\nwhile n:\n\ta = n%10\n\tn //= 10\n\tans += 1\n\tprev = a\nif ans==1:\n\tprint(1)\nelse:\n\tprint(((prev+1)*(10**(ans-1)))-N)\n", "generated_code": "n=int(input())\ns=str(n)\na=[]\nfor i in range(len(s)):\n\ta.append(int(s[i]))\n\t\ny=a[0]+1\nfl=0\nfor i in a:\n\tif i<=1:\n\t\tfl=1\n\telse:\n\t\ty=i\n\t\tbreak\n\nif fl==0:\n\ty=n\nprint(y)\n", "score": 0.0098, "codebleu": 0.20877859274681698, "crystalbleu": 0, "codebertscore": 0.78, "codescore": 0.05724143236875534, "surfaceSim": 0.44074074074074077, "abs_surfaceSim_minus_score": 0.4309407407407408, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-2276_7", "golden_code": "from functools import lru_cache\nn = int(input())\ns = input()\nA = [0] + list(map(int, input().split()))\n\ndp = [0] * (n + 1)\n\nfor i in range(1, n + 1):\n    dp[i] = max(dp[j] + A[i - j] for j in range(0, i))\n\nres = {}\n\n@lru_cache(None)\ndef score(s):\n    length = len(s)\n    if length == 0:\n        return 0\n    ans = 0\n    start = 0\n    i = 1\n    while i < length and s[i] == s[start]:\n        i += 1\n\n    ans = dp[i] + score(s[i:])\n\n    for j in range(i, length):\n        if s[j] == s[start]:\n            ans = max(ans, score(s[i:j]) + score(s[:i] + s[j:]))\n    return ans\n\n\nprint(score(s))", "generated_code": "n = int(input())\ns = input()\na = list(map(int, input().split()))\n\nans = 0\ncur = 0\nl = 0\nfor i in range(n):\n\tif s[i] == '0':\n\t\tcur += 1\n\telse:\n\t\tif cur > 0:\n\t\t\tl += 1\n\t\tcur = 0\n\tif i >= l and s[i]!= '1':\n\t\tans += min(cur, a[i-l])\n\nif cur > 0 :\n\tans += min( cur, a[-1])\n\nprint(ans)\n", "score": 0.0006, "codebleu": 0.18234906163062475, "crystalbleu": 0.14, "codebertscore": 0.79, "codescore": 0.18856418132781982, "surfaceSim": 0.5235544217687076, "abs_surfaceSim_minus_score": 0.5229544217687075, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_p02760_s347634405_MUT_10", "golden_code": "import numpy as np\nN_1 = list(map(int, input().split()))\nN_2 = list(map(int, input().split()))\nN_3 = list(map(int, input().split()))\nN = int(eval(input()))\na = [int(eval(input())) for i in range(N)]\nn = np.array([N_1, N_2, N_3])\nfor a_n in a:\n    if a_n in n:\n        n[n == a_n] = 0\n    else:\n        pass\ni = 0\nif np.all(n[(0:, 0)] == 0) == True:\n    i = +1\nelif np.all(n[(0:, 1)] == 0) == True:\n    i += 1\nelif np.all(n[(0:, 2)] == 0) == True:\n    i += 1\nelif np.all(n[(0, 0:)] == 0) == True:\n    i += 1\nelif np.all(n[(1, 0:)] == 0) == True:\n    i += 1\nelif np.all(n[(2, 0:)] == 0) == True:\n    i += 1\nelif (n[(0, 0)] == 0 and n[(1, 1)] == 0 and n[(2, 2)] == 0):\n    i += 1\nelif (n[(0, 2)] == 0 and n[(1, 1)] == 0 and n[(2, 0)] == 0):\n    i += 1\nif i > 0:\n    print('Yes')\nelse:\n    print('No')", "generated_code": "import numpy as np\nN_1 = list(map(int, input().split()))\nN_2 = list(map(int, input().split()))\nN_3 = list(map(int, input().split()))\nN = int(eval(input()))\na = [int(eval(input())) for i in range(N)]\nn = np.array([N_1, N_2, N_3])\nfor a_n in a:\n    if not (a_n in n):\n        n[n == a_n] = 0\n    else:\n        pass\ni = 0\nif np.all(n[(0:, 0)] == 0) == True:\n    i = +1\nelif np.all(n[(0:, 1)] == 0) == True:\n    i += 1\nelif np.all(n[(0:, 2)] == 0) == True:\n    i += 1\nelif np.all(n[(0, 0:)] == 0) == True:\n    i += 1\nelif np.all(n[(1, 0:)] == 0) == True:\n    i += 1\nelif np.all(n[(2, 0:)] == 0) == True:\n    i += 1\nelif (n[(0, 0)] == 0 and n[(1, 1)] == 0 and n[(2, 2)] == 0):\n    i += 1\nelif (n[(0, 2)] == 0 and n[(1, 1)] == 0 and n[(2, 0)] == 0):\n    i += 1\nif i > 0:\n    print('Yes')\nelse:\n    print('No')", "score": 0.0, "codebleu": 0.9793827440413371, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.9937105178833008, "surfaceSim": 0.49688667496886674, "abs_surfaceSim_minus_score": 0.49688667496886674, "source": "local", "local_type": "MUT"}
{"id": "MBPP_52_8", "golden_code": "def count_tuplex(tuplex,value):  \r\n  count = tuplex.count(value)\r\n  return count", "generated_code": "def count_tuplex(tuplex,value):  \n\treturn sum(1 for tuple in zip(tuplex,[value]) if tuple[0] == tuple[1])\ntp_mlen = lambda x: len(x)", "score": 0.3491, "codebleu": 0.2583934709907105, "crystalbleu": 0, "codebertscore": 0.85, "codescore": 0.513591468334198, "surfaceSim": 0.5037878787878788, "abs_surfaceSim_minus_score": 0.15468787878787876, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_25_OP_1", "golden_code": "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    import math\n    fact = []\n    i = 2\n    while i <= int(math.sqrt(n) + 1):\n        if n % i == 0:\n            fact.append(i)\n            n //= i\n        else:\n            i += 1\n\n    if n > 1:\n        fact.append(n)\n    return fact", "generated_code": "from typing import List\nfrom functools import lru_cache\n\n@lru_cache(maxsize=None)\ndef factorize(m: int) -> List[int]:\n    import math\n    factors = []\n    candidate = 2\n    while candidate <= int(math.sqrt(m) + 1):\n        if m % candidate == 0:\n            factors.append(candidate)\n            m //= candidate\n        else:\n            candidate += 1\n\n    if m > 1:\n        factors.append(m)\n    return factors\n", "score": 1.0, "codebleu": 0.4705418126804435, "crystalbleu": 0, "codebertscore": 0.89, "codescore": 0.9939255118370056, "surfaceSim": 0.8385925173787394, "abs_surfaceSim_minus_score": 0.1614074826212606, "source": "local", "local_type": "OP"}
{"id": "LOCAL_HE_47_OP_1", "golden_code": "def median(l: list):\n    l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) // 2]\n    else:\n        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2.0", "generated_code": "def median(arr: list):\n    n = len(arr)\n    if n == 0:\n        return None\n    if n == 1:\n        return arr[0]\n    arr.sort()\n    mid = n // 2\n    return arr[mid] if n % 2 else (arr[mid - 1] + arr[mid]) / 2", "score": 1.0, "codebleu": 0.30547051732633257, "crystalbleu": 0.13, "codebertscore": 0.86, "codescore": 0.9638472199440002, "surfaceSim": 0.725024154589372, "abs_surfaceSim_minus_score": 0.27497584541062803, "source": "local", "local_type": "OP"}
{"id": "LOCAL_PIE_extra_p02665_s890279539_OP_1", "golden_code": "n = int(eval(input()))\n\nleaves = list(map(int, input().split()))\n\n\n\nans = 0\n\nnodes_min = [0] * (n + 1)\n\nnodes_max = [0] * (n + 1)\n\nnodes_min[n] = leaves[n]\n\nnodes_max[n] = leaves[n]\n\n\n\nfor depth in range(n, 0, -1):\n\n    root_min = nodes_min[depth] // 2 + nodes_min[depth] % 2\n\n    nodes_min[depth - 1] = leaves[depth - 1] + root_min\n\n    root_max = nodes_max[depth]\n\n    nodes_max[depth - 1] = leaves[depth - 1] + root_max\n\nnodes = [0] * (n + 1)\n\nnodes[0] = 1\n\nif nodes[0] < nodes_min[0]:\n\n    print((-1))\n\nelse:\n\n    for depth in range(n):\n\n        roots = nodes[depth]-leaves[depth]\n\n        nodes[depth + 1] = min(roots * 2, nodes_max[depth + 1])\n\n        if nodes[depth+1] < nodes_min[depth+1]:\n\n            print((-1))\n\n            break\n\n    else:\n\n        print((sum(nodes)))\n", "generated_code": "n = int(eval(input()))\n\nleaves = list(map(int, input().split()))\n\n\n\nsum_leaves = [0]*(n+1)\n\nsum_leaves[0] = leaves[0]\n\nfor depth in range(n):\n\n    sum_leaves[depth+1] = sum_leaves[depth] + leaves[depth+1]\n\n\n\nans = 0\n\n\n\nroot = [None] * (n + 1)\n\nif n == 0:\n\n    root[0] = 0\n\nelse:\n\n    root[0] = 1\n\nif root[0] + leaves[0] != 1:\n\n    print((-1))\n\nelse:\n\n    for depth in range(n):\n\n        root[depth+1] = min(2*root[depth]-leaves[depth+1],\n\n                            sum_leaves[n]-sum_leaves[depth+1])\n\n        if root[depth + 1] < root[depth] - leaves[depth + 1] or root[depth+1] < 0:\n\n            print((-1))\n\n            break\n\n    else:\n\n        print((sum(root)+sum(leaves)))\n", "score": 0.622, "codebleu": 0.34809137619893066, "crystalbleu": 0.48, "codebertscore": 0.87, "codescore": 0.5857299566268921, "surfaceSim": 0.7049808429118773, "abs_surfaceSim_minus_score": 0.08298084291187735, "source": "local", "local_type": "OP"}
{"id": "MBPP_37_2", "golden_code": "def lucky_num(n):\r\n List=range(-1,n*n+9,2)\r\n i=2\r\n while List[i:]:List=sorted(set(List)-set(List[List[i]::List[i]]));i+=1\r\n return List[1:n+1]", "generated_code": "def lucky_num(n):\n\n\tresult = []\n\tresult.extend(range(1,n+1))\n\t\n\treturn result", "score": 0.1939, "codebleu": 0.06725560232821975, "crystalbleu": 0, "codebertscore": 0.8, "codescore": 0.02964150346815586, "surfaceSim": 0.43253521126760563, "abs_surfaceSim_minus_score": 0.23863521126760565, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_30_OP_1", "golden_code": "def get_positive(l: list):\n    return [e for e in l if e > 0]", "generated_code": "def get_positive(numbers: list):\n    return list(filter(lambda x: x > 0, numbers))", "score": 1.0, "codebleu": 0.26092427001199114, "crystalbleu": 0, "codebertscore": 0.86, "codescore": 0.9631018042564392, "surfaceSim": 0.6199186991869918, "abs_surfaceSim_minus_score": 0.38008130081300817, "source": "local", "local_type": "OP"}
{"id": "LOCAL_PIE_extra_p03060_s176163369_OP_1", "golden_code": "n = int(eval(input()))\n\nv = list(map(int, input().split()))\n\nc = list(map(int, input().split()))\n\nresult = 0\n\nfor i in range(n):\n\n  if v[i] > c[i]:\n\n    result += v[i] - c[i]\n\nprint(result)", "generated_code": "N = int(eval(input()))\n\nV = list(map(int, input().split()))\n\nC = list(map(int, input().split()))\n\nprint((sum([V[i] - C[i] for i in range(N) if V[i] > C[i]])))\n", "score": 1.0, "codebleu": 0.4144833762482961, "crystalbleu": 0.33, "codebertscore": 0.92, "codescore": 0.25361815094947815, "surfaceSim": 0.6825396825396826, "abs_surfaceSim_minus_score": 0.31746031746031744, "source": "local", "local_type": "OP"}
{"id": "LOCAL_APPS_1275_39_MUT_43", "golden_code": "(N, K) = list(map(int, input().split()))\nans = 0\nfor i in range(2, (2 * N) + 1):\n    j = i - K\n    if not (2 <= j <= 2 * N):\n        continue\n    ans += min(i - 1, ((2 * N) - i) + 1) * min(j - 1, ((2 * N) - j) + 1)\nprint(ans)", "generated_code": "(N, K) = list(map(int, input().split()))\nans = 0\nfor i in range(2, (2 * N) + 1):\n    break\n\n\n\nprint(ans)", "score": 0.0, "codebleu": 0.3412155432750303, "crystalbleu": 0, "codebertscore": 0.89, "codescore": 0.19779056310653687, "surfaceSim": 0.6332367149758454, "abs_surfaceSim_minus_score": 0.6332367149758454, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_PIE_p02599_s870922238_MUT_143", "golden_code": "import sys\nclass BinaryIndexedTree:\n    def __init__(self, A):\n        self.__n = len(A)\n        self.__node = [0] * (self.__n + 1)\n        self.__data = [0] * (self.__n + 1)\n        S = [0] * (self.__n + 1)\n        for i in range(1, self.__n + 1):\n            S[i] = S[i - 1] + A[i - 1]\n            self.__data[i] = A[i - 1]\n            self.__node[i] = S[i] - S[i - (i & (-i))]\n    def add(self, i, v):\n        self.__data[i] += v\n        while i <= self.__n:\n            self.__node[i] += v\n            i += i & (-i)\n    def sum(self, i):\n        rst = 0\n        while i > 0:\n            rst += self.__node[i]\n            i -= i & (-i)\n        return rst\n    def get(self, i, j):\n        if i == j:\n            return self.__data[i]\n        else:\n            return self.sum(j) - self.sum(i - 1)\ndef main():\n    (N, Q) = map(int, input().split())\n    C = list(map(int, input().split()))\n    P = [[] for _ in range(N)]\n    for (i, c) in enumerate(C):\n        P[c - 1].append(i)\n    right = [0] * N\n    for p in P:\n        if len(p):\n            right[p.pop()] = 1\n    BIT = BinaryIndexedTree(right)\n    query = [[] for _ in range(N)]\n    for (i, s) in enumerate(sys.stdin.readlines()):\n        (l, r) = map(int, s.split())\n        query[r - 1].append((l - 1, i))\n    ans = [None] * Q\n    cur = N - 1\n    for (r, q) in enumerate(reversed(query)):\n        r = (N - 1) - r\n        while q:\n            (l, i) = q.pop()\n            while r < cur:\n                c = C[cur] - 1\n                p = P[c]\n                if len(p):\n                    BIT.add(p.pop() + 1, 1)\n                cur -= 1\n            tmp = BIT.get(l + 1, r + 1)\n            ans[i] = tmp\n    print(sep='\\n', *ans)", "generated_code": "import sys\nclass BinaryIndexedTree:\n    def __init__(self, A):\n        self.__n = len(A)\n        self.__node = [0] * (self.__n + 1)\n        self.__data = [0] * (self.__n + 1)\n        S = [0] * (self.__n + 1)\n        for i in range(1, self.__n + 1):\n            S[i] = S[i - 1] + A[i - 1]\n            self.__data[i] = A[i - 1]\n            self.__node[i] = S[i] - S[i - (i & (-i))]\n    def add(self, i, v):\n        self.__data[i] += v\n        while i <= self.__n:\n            self.__node[i] += v\n            i += i & (-i)\n    def sum(self, i):\n        rst = 0\n        while i > 0:\n            rst += self.__node[i]\n            i -= i & (-i)\n        return rst\n    def get(self, i, j):\n        if i == j:\n            return self.__data[i]\n        else:\n            return self.sum(j) - sum(i - 1)\ndef main():\n    (N, Q) = map(int, input().split())\n    C = list(map(int, input().split()))\n    P = [[] for _ in range(N)]\n    for (i, c) in enumerate(C):\n        P[c - 1].append(i)\n    right = [0] * N\n    for p in P:\n        if len(p):\n            right[p.pop()] = 1\n    BIT = BinaryIndexedTree(right)\n    query = [[] for _ in range(N)]\n    for (i, s) in enumerate(sys.stdin.readlines()):\n        (l, r) = map(int, s.split())\n        query[r - 1].append((l - 1, i))\n    ans = [None] * Q\n    cur = N - 1\n    for (r, q) in enumerate(reversed(query)):\n        r = (N - 1) - r\n        while q:\n            (l, i) = q.pop()\n            while r < cur:\n                c = C[cur] - 1\n                p = P[c]\n                if len(p):\n                    BIT.add(p.pop() + 1, 1)\n                cur -= 1\n            tmp = BIT.get(l + 1, r + 1)\n            ans[i] = tmp\n    print(sep='\\n', *ans)", "score": 0.0334, "codebleu": 0.9841792499323838, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9936747550964355, "surfaceSim": 0.9985180794309425, "abs_surfaceSim_minus_score": 0.9651180794309425, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_PIE_extra_p03307_s632972821_OP_1", "golden_code": "import fractions\n\nn=int(eval(input()))\n\nprint(((2*n)//fractions.gcd(2,n)))", "generated_code": "N=int(eval(input()));print((N if N%2==0 else N*2))", "score": 1.0, "codebleu": 0.18898809523809523, "crystalbleu": 0, "codebertscore": 0.82, "codescore": 0.37183114886283875, "surfaceSim": 0.5007507507507507, "abs_surfaceSim_minus_score": 0.4992492492492493, "source": "local", "local_type": "OP"}
{"id": "LOCAL_MBPP_247_OP_1", "golden_code": "def lps(str): \r\n\tn = len(str) \r\n\tL = [[0 for x in range(n)] for x in range(n)] \r\n\tfor i in range(n): \r\n\t\tL[i][i] = 1\r\n\tfor cl in range(2, n+1): \r\n\t\tfor i in range(n-cl+1): \r\n\t\t\tj = i+cl-1\r\n\t\t\tif str[i] == str[j] and cl == 2: \r\n\t\t\t\tL[i][j] = 2\r\n\t\t\telif str[i] == str[j]: \r\n\t\t\t\tL[i][j] = L[i+1][j-1] + 2\r\n\t\t\telse: \r\n\t\t\t\tL[i][j] = max(L[i][j-1], L[i+1][j]); \r\n\treturn L[0][n-1]", "generated_code": "def lps(s):\n    ln = len(s)\n    if ln == 0:\n        return 0\n    \n    dp = [0] * ln\n    for i in range(ln - 1, -1, -1):\n        new_dp = dp[:]\n        new_dp[i] = 1\n        for j in range(i + 1, ln):\n            if s[i] == s[j]:\n                new_dp[j] = dp[j - 1] + 2\n            else:\n                new_dp[j] = max(dp[j], new_dp[j - 1])\n        dp = new_dp\n    return dp[ln - 1]", "score": 1.0, "codebleu": 0.1749718058367111, "crystalbleu": 0.17, "codebertscore": 0.81, "codescore": 0.5418736338615417, "surfaceSim": 0.6208692528735632, "abs_surfaceSim_minus_score": 0.3791307471264368, "source": "local", "local_type": "OP"}
{"id": "MBPP_214_2", "golden_code": "def sum_difference(n):\r\n    sumofsquares = 0\r\n    squareofsum = 0\r\n    for num in range(1, n+1):\r\n        sumofsquares += num * num\r\n        squareofsum += num\r\n    squareofsum = squareofsum ** 2\r\n    return squareofsum - sumofsquares", "generated_code": "def sum_difference(n):\n\treturn n * (n + 1) * (2 * n + 1) // 6", "score": 0.0, "codebleu": 0.06547574360129658, "crystalbleu": 0, "codebertscore": 0.77, "codescore": 0.026020335033535957, "surfaceSim": 0.5052856500224921, "abs_surfaceSim_minus_score": 0.5052856500224921, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0224_69", "golden_code": "field = \"A\" + input() + \"A\"\nletters = [\"A\", \"E\", \"I\", \"O\", \"U\", \"Y\"]\nans = 1\nlast_let = 0\nfor i in range(len(field)):\n    let = field[i]\n    if let in letters:\n        ans = max(ans, i - last_let)\n        last_let = i\nprint(ans)", "generated_code": "import sys\n\ndef main():\n\ts = sys.stdin.readline().strip()\n\tn = len(s)\n\tres = 1\n\tfor i in range(1, n):\n\t\tchar = s[i]\n\t\tpos = i\n\t\tif char in 'AEIOUY':\n\t\t\tpos = pos - 1\n\t\tif s[pos] == char:\n\t\t\tres = max(res, i - pos)\n\tprint(res)\n\ndef __starting_point():\n\tmain()\n\n__starting_point()\n", "score": 0.0262, "codebleu": 0.25552268154629576, "crystalbleu": 0, "codebertscore": 0.78, "codescore": 0.12235645949840546, "surfaceSim": 0.5268817204301075, "abs_surfaceSim_minus_score": 0.5006817204301075, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0377_11", "golden_code": "n, m = list(map(int, input().split()))\nif m <= n / 2:\n    print(max(m, 1))\nelse:\n    print(n - m)\n", "generated_code": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\nimport time\n\n\ndef solve(n, m, tree):\n\tright_ct = [0 for _ in range(n)]\n\ttree[n-1] = 1\n\tfor i in range(n-2, -1, -1):\n\t\tif tree[i] == 1:\n\t\t\tn_left = 0\n\t\t\tn_right = 0\n\t\t\twhile m > 0:\n\t\t\t\tn_left += 1\n\t\t\t\tn_right += 1\n\t\t\t\tm -= 1\n\t\t\tright_ct[i] = n_left\n\t\telse:\n\t\t\tright_dt[i] = 0\n\t\t\t\n\tleft_ct = 0\n\tright_dt = 0\n\tfor i, (j, v) in enumerate(zip(tree, right_ct)):\n\t\tright_ct", "score": 0.0, "codebleu": 0.1604163463838425, "crystalbleu": 0, "codebertscore": 0.66, "codescore": 0.018748123198747635, "surfaceSim": 0.41315327184892403, "abs_surfaceSim_minus_score": 0.41315327184892403, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_20_9", "golden_code": "def is_odd(n) : \r\n    if (n^1 == n-1) :\r\n        return True; \r\n    else :\r\n        return False; ", "generated_code": "def is_odd(n): return str(n) == str(n)[::-1]", "score": 0.5397, "codebleu": 0.2766072294238246, "crystalbleu": 0, "codebertscore": 0.83, "codescore": 0.6185373663902283, "surfaceSim": 0.5743823845327605, "abs_surfaceSim_minus_score": 0.03468238453276051, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_39_2", "golden_code": "def previous_palindrome(num):\r\n    for x in range(num-1,0,-1):\r\n        if str(x) == str(x)[::-1]:\r\n            return x", "generated_code": "def previous_palindrome(num):\n\n\treturn (int(str(num)[::- 1]) -1)", "score": 0.1858, "codebleu": 0.16838846808834004, "crystalbleu": 0, "codebertscore": 0.83, "codescore": 0.09481413662433624, "surfaceSim": 0.7083333333333334, "abs_surfaceSim_minus_score": 0.5225333333333334, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_88_2", "golden_code": "def even_bit_toggle_number(n) : \r\n    res = 0; count = 0; temp = n \r\n    while (temp > 0) :     \r\n        if (count % 2 == 1) : \r\n            res = res | (1 << count)      \r\n        count = count + 1\r\n        temp >>= 1 \r\n    return n ^ res ", "generated_code": "def even_bit_toggle_number(n):\n\trez = []\n\tfor k in range(1, int(n**(1.0/2))+1):\n\t\tif n % k == 0:\n\t\t\trez.append(k)\n\t\t\tif k!= n // k:\n\t\t\t\trez.extend([k, n // k])\n\treturn rez", "score": 0.0, "codebleu": 0.09487566508307912, "crystalbleu": 0, "codebertscore": 0.77, "codescore": 0.030467484146356583, "surfaceSim": 0.5778008298755186, "abs_surfaceSim_minus_score": 0.5778008298755186, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-1073_14", "golden_code": "#!/usr/bin/env python3\nn = int(input())\ns = input()\nans = 0\nfor l in range(n-1):\n    for r in range(l+1,n+1):\n        y, x = 0, 0\n        for c in s[l:r]:\n            if c == 'U':\n                y += 1\n            elif c == 'D':\n                y -= 1\n            elif c == 'R':\n                x += 1\n            elif c == 'L':\n                x -= 1\n        if y == 0 and x == 0:\n            ans += 1\nprint(ans)\n", "generated_code": "import sys\ninput = sys.stdin.readline\n\nn = int(input())\nl = [0]*100\nk = 0\nres = 0\n\nfor i in range(n):\n\tl[ord(sys.stdin.write(\"U\"))-ord('A')] += 1\n\tk += 1\n\tif l[k] == 4:\n\t\tx = i - k\n\t\ty = i - k + 1\n\t\tif x <= y:\n\t\t\tres += 1\n\t\tif k-x == y:\n\t\t\tj = i - k - 1\n\t\t\twhile j > res:\n\t\t\t\tres += 1\n\t\t\t\tj -= 1\n\t\telse:\n\t\t\tres = 2\nprint(res)\n", "score": 0.0, "codebleu": 0.23556673765953715, "crystalbleu": 0.09, "codebertscore": 0.78, "codescore": 0.12140592187643051, "surfaceSim": 0.5833333333333333, "abs_surfaceSim_minus_score": 0.5833333333333333, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_MBPP_492_OP_1", "golden_code": "def binary_search(item_list,item):\r\n\tfirst = 0\r\n\tlast = len(item_list)-1\r\n\tfound = False\r\n\twhile( first<=last and not found):\r\n\t\tmid = (first + last)//2\r\n\t\tif item_list[mid] == item :\r\n\t\t\tfound = True\r\n\t\telse:\r\n\t\t\tif item < item_list[mid]:\r\n\t\t\t\tlast = mid - 1\r\n\t\t\telse:\r\n\t\t\t\tfirst = mid + 1\t\r\n\treturn found", "generated_code": "def binary_search(sorted_list, target):\n    start, end = 0, len(sorted_list) - 1\n    while start <= end:\n        midpoint = (start + end) // 2\n        if sorted_list[midpoint] == target:\n            return True\n        elif sorted_list[midpoint] < target:\n            start = midpoint + 1\n        else:\n            end = midpoint - 1\n    return False", "score": 1.0, "codebleu": 0.27665063292088515, "crystalbleu": 0, "codebertscore": 0.81, "codescore": 0.9939277172088623, "surfaceSim": 0.7178571428571429, "abs_surfaceSim_minus_score": 0.28214285714285714, "source": "local", "local_type": "OP"}
{"id": "APPS_test-0943_9", "golden_code": "n=int(input())\nl=list(map(int,input().split()))\ns=sorted([x for x in l if x%2>0])\nt=sum(l)\nif t%2: t-=s[0]\nprint(t)", "generated_code": "def main():\n\tn = int(input())\n\ta = list(map(int, input().split()))\n\tb = []\n\tfor i in a:\n\t\tb.append(str(i))\n\tb.sort()\n\tm = ''\n\tfor i2 in b:\n\t\tif i2 == '9' or i2 == '5':\n\t\t\tm += i2\n\t\telse:\n\t\t\tm += '5'\n\tprint(int(m))\n\n\nmain()\n", "score": 0.0, "codebleu": 0.24850356525254547, "crystalbleu": 0, "codebertscore": 0.79, "codescore": 0.04832010716199875, "surfaceSim": 0.4878283151825753, "abs_surfaceSim_minus_score": 0.4878283151825753, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-1486_34", "golden_code": "n = int(input())\n\na = input().split(' ')\n\nfor i in range(0, len(a)):\n    a[i] = int(a[i])\n\nprint(abs(a[0] - a[1]), abs(a[0] - a[n - 1]))\n\nfor i in range(1, n - 1):\n    print(min(abs(a[i] - a[i - 1]), abs(a[i] - a[i + 1])), max(abs(a[i] - a[0]), abs(a[i] - a[n - 1])))\n\nprint(abs(a[n - 1] - a[n - 2]), abs(a[n - 1] - a[0]))\n    \n", "generated_code": "def main():\n\tn = int(input())\n\tl = list(map(int, input().split()))\n\tll = sorted(l)\n\tkk = ['{} 2'.format(l[i].replace(\"-\", \"\")) for i in range(n)]\n\tprint(' '.join(kk))\n\n\ndef __starting_point():\n\tmain()\n\n__starting_point()\n", "score": 0.0, "codebleu": 0.09338979455836399, "crystalbleu": 0.06, "codebertscore": 0.73, "codescore": 0.06533989310264587, "surfaceSim": 0.49221758664955073, "abs_surfaceSim_minus_score": 0.49221758664955073, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_79_23", "golden_code": "def min_of_two( x, y ):\r\n    if x < y:\r\n        return x\r\n    return y", "generated_code": "def min_of_two( x, y ):\n\tif x == y :\n\t\treturn x\n\telse :\n\t\tx + y\n\t\treturn min(x,y)", "score": 1.0, "codebleu": 0.646484214552731, "crystalbleu": 0, "codebertscore": 0.89, "codescore": 0.9935446977615356, "surfaceSim": 0.682716049382716, "abs_surfaceSim_minus_score": 0.317283950617284, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_p02555_s973678433_MUT_38", "golden_code": "def cmb(n, r):\n    import math\n    if n < r:\n        return 0\n    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\ndef solve(S):\n    mod = (10 ** 9) + 7\n    ans = 0\n    for i in range(1, (S // 3) + 1):\n        tama = i + (S - (i * 3))\n        tama -= 2\n        bo = i - 1\n        ans += cmb(tama + 1, bo)\n        ans %= mod\n    print(ans)", "generated_code": "def cmb(n, r):\n    import math\n    if n < r:\n        return 0\n    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\ndef solve(S):\n    mod = (10 ** 9) + 7\n    ans = 0\n    for i in range(1, (S // 3) + 1):\n        tama = i + (S - (i * 3))\n        tama -= 2\n        pass\n        ans += cmb(tama + 1, bo)\n        ans %= mod\n    print(ans)", "score": 0.0, "codebleu": 0.9077374758612371, "crystalbleu": 0.92, "codebertscore": 0.99, "codescore": 0.9617267847061157, "surfaceSim": 0.973832607835378, "abs_surfaceSim_minus_score": 0.973832607835378, "source": "local", "local_type": "MUT"}
{"id": "MBPP_40_6", "golden_code": "import datetime\r\ndef check_date(m, d, y):\r\n    try:\r\n        m, d, y = map(int, (m, d, y))\r\n        datetime.date(y, m, d)\r\n        return True\r\n    except ValueError:\r\n        return False", "generated_code": "import datetime\ndef check_date(m, d, y):\n\tif m and d and y and m >= m + d:\n\t\treturn True\n\treturn False\nduplicate = set()", "score": 0.7467, "codebleu": 0.30982639900968306, "crystalbleu": 0, "codebertscore": 0.82, "codescore": 0.6033681631088257, "surfaceSim": 0.5906878306878307, "abs_surfaceSim_minus_score": 0.15601216931216932, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_extra_p03796_s982585501_OP_1", "golden_code": "n=eval(input())\n\nn=int(n)\n\na=1\n\nfor i in range(n):\n\n    a=a*(i+1)\n\n    if a>=pow(10,9)+7:\n\n        a=a%(pow(10,9)+7)\n\nprint(a)", "generated_code": "n=int(eval(input()))\n\na=1\n\nfor i in range(1,n+1):\n\n    a*=i\n\n    a %= (10**9+7)\n\nprint(a)", "score": 1.0, "codebleu": 0.3127448256059964, "crystalbleu": 0, "codebertscore": 0.91, "codescore": 0.8524153232574463, "surfaceSim": 0.6746031746031746, "abs_surfaceSim_minus_score": 0.32539682539682535, "source": "local", "local_type": "OP"}
{"id": "LOCAL_APPS_1407_12_MUT_54", "golden_code": "def sieve(mx):\n    a = [0] * (mx + 1)\n    a[0] = a[1] = 1\n    for (i, e) in enumerate(a):\n        if e == 0:\n            for n in range(i * i, mx + 1, i):\n                a[n] = 1\n    return a\n\np = sieve((10 ** 5) + 100)\nfor i in range((10 ** 5) + 99, 0, -1):\n    p[i] *= p[i + 1] + 1\n\n(n, m) = map(int, input().split())\n\ncols = [0] * m\n\nmm = 10 ** 7\nfor i in range(n):\n    row = list(map(int, input().split()))\n    row_sum = 0\n    for (a, j) in enumerate(row):\n        tt = p[j]\n        row_sum += tt\n        cols[a] += tt\n    mm = min(mm, row_sum)\n\nprint(min(min(cols), mm))", "generated_code": "def sieve(mx):\n    a = [0] * (mx + 1)\n    a[0] = a[1] = 1\n    for (i, e) in enumerate(a):\n        if e == 0:\n            for n in range(i * i, mx + 1, i):\n                a[n] = 1\n    return a\n\np = sieve((10 ** 5) + 100)\nfor i in range((10 ** 5) + 99, 0, -1):\n    p[i] *= p[i + 1] + 1\n\n(n, m) = map(int, input().split())\n\ncols = [0] * m\n\nmm = 10 ** 7\nfor i in range(n):\n    row = list(map(int, input().split()))\n    row_sum = 0\n    for (a, j) in enumerate(row):\n        tt = p[j]\n        row_sum += tt\n        cols[a] += tt\n    mm = min(mm, row_sum)\n\npass", "score": 0.0, "codebleu": 0.9663775701473218, "crystalbleu": 0.93, "codebertscore": 0.99, "codescore": 0.9938552975654602, "surfaceSim": 0.9464200191570882, "abs_surfaceSim_minus_score": 0.9464200191570882, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_APPS_4698_39_MUT_3", "golden_code": "N = int(input())\nT = list(map(int, input().split()))\nM = int(input())\nP = [0] * M\nX = [0] * M\nfor i in range(M):\n    (P[i], X[i]) = list(map(int, input().split()))\n\nfor i in range(M):\n    ans = 0\n    ans += sum(T[:P[i] - 1])\n    ans += X[i]\n    ans += sum(T[P[i]:])\n    print(ans)", "generated_code": "N = int(input())\nT = list(map(int, input().split()))\nM = int(input())\nP = [0] ** M\nX = [0] * M\nfor i in range(M):\n    (P[i], X[i]) = list(map(int, input().split()))\n\nfor i in range(M):\n    ans = 0\n    ans += sum(T[:P[i] - 1])\n    ans += X[i]\n    ans += sum(T[P[i]:])\n    print(ans)", "score": 0.0, "codebleu": 0.9729567248830167, "crystalbleu": 0.99, "codebertscore": 0.99, "codescore": 0.9936923980712891, "surfaceSim": 0.9744111167598712, "abs_surfaceSim_minus_score": 0.9744111167598712, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-0715_15", "golden_code": "a=input()[2:]\nb=input()[2:]\nc=input()[2:]\nd=input()[2:]\n\nL=[a,b,c,d]\nS=\"ABCD\"\nx=0\ne=[]\nfor i in range(4):\n    l=True\n    s=True\n    for j in range(4):\n        if(j==i):\n            continue\n        if(len(L[i])<len(L[j])*2):\n            l=False\n        if(len(L[j])<len(L[i])*2):\n            s=False\n    if(l and not s):\n        x+=1\n        e.append(i)\n    elif(s and not l):\n        x+=1\n        e.append(i)\nif(x==1):\n    print(S[e[0]])\nelse:\n    print(\"C\")\n", "generated_code": "def check(string):\n\tl = len(string)\n\tif l == 1:\n\t\tif string[0] == 'A':\n\t\t\treturn 'A'\n\t\telse:\n\t\t\treturn 'B'\n\telif l == 2:\n\t\tif type(string) =='str':\n\t\t\treturn string\n\t\telse: return 'C'\n\tel = int(l/2)\n\tif t[1] == 'X':\n\t\tt = string[0:t[0]]\n\telif t[1:] == 'X':t = string[t[0:-1]:]\n\tfor i in range(len(t)):\n\t\tif t[i] == '_':\n\t\t\tcontinue\n\t\telse:return string[0:i]\n\treturn 'D'\n\na = input()\nb = input()\nc = input()\nd = input()\n\n", "score": 0.0, "codebleu": 0.11134271560390181, "crystalbleu": 0.11, "codebertscore": 0.73, "codescore": 0.018719224259257317, "surfaceSim": 0.4412714097496706, "abs_surfaceSim_minus_score": 0.4412714097496706, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_extra_p03307_s023207655_OP_1", "golden_code": "import fractions\n\n\n\n\n\ndef lcm(x, y):\n\n    return (x * y) // fractions.gcd(x, y)\n\n\n\n\n\nN = int(eval(input()))\n\nprint((lcm(N, 2)))", "generated_code": "N = int(eval(input()))\n\nif N % 2 == 0:\n\n    print(N)\n\nelse:\n\n    print((2 * N))", "score": 1.0, "codebleu": 0.18611771914501923, "crystalbleu": 0, "codebertscore": 0.79, "codescore": 0.41657063364982605, "surfaceSim": 0.4359341445955619, "abs_surfaceSim_minus_score": 0.5640658554044381, "source": "local", "local_type": "OP"}
{"id": "LOCAL_HE_114_OP_1", "golden_code": "def minSubArraySum(nums):\n    max_sum = 0\n    s = 0\n    for num in nums:\n        s += -num\n        if (s < 0):\n            s = 0\n        max_sum = max(s, max_sum)\n    if max_sum == 0:\n        max_sum = max(-i for i in nums)\n    min_sum = -max_sum\n    return min_sum", "generated_code": "def minSubArraySum(values):\n    minimum_sum, current_sum = float('inf'), 0\n    for value in values:\n        current_sum += value\n        if current_sum < minimum_sum:\n            minimum_sum = current_sum\n        if current_sum > 0:\n            current_sum = 0\n    return minimum_sum if minimum_sum != float('inf') else min(values)", "score": 1.0, "codebleu": 0.17891324720351579, "crystalbleu": 0, "codebertscore": 0.84, "codescore": 0.8894408345222473, "surfaceSim": 0.59731582616779, "abs_surfaceSim_minus_score": 0.40268417383221, "source": "local", "local_type": "OP"}
{"id": "APPS_test-1049_10", "golden_code": "n, d = list(map(int, input().split()))\nc = [input() for _ in range(d)]\nr = 0\nx = 0\nfor v in c:\n    if \"0\" in v:\n        x += 1\n        r = max(r, x)\n    else:\n        x = 0\nprint(r)\n", "generated_code": "# -*- coding: utf-8 -*-\n\nimport math\nimport collections\nimport bisect\nimport heapq\nimport time\nimport random\nimport itertools\nimport sys\n\n\"\"\"\ncreated by shhuan at 2017/10/19 21:52\n\n\"\"\"\n\nN, D = map(int, input().split())\nday = []\nfor i in range(D):\n\tday.append(input())\n\nmemo = collections.defaultdict(int)\n\nfor i in day:\n\ttmp = 0\n\tfor j in range(len(i)):\n\t\tif i[j] == '1':\n\t\t\ttmp += 1\n\tmemo[tmp] += 1\n\nA = []\nfor key in memo:\n\tA.append(memo[key])\n\nA.sort(reverse=True)\nans = 0\nday = []                    \n", "score": 0.0, "codebleu": 0.23384929635571305, "crystalbleu": 0, "codebertscore": 0.7, "codescore": 0.05662102624773979, "surfaceSim": 0.4801980198019802, "abs_surfaceSim_minus_score": 0.4801980198019802, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-4170_2", "golden_code": "n = int(input())\nh = list(map(int,input().split()))\nans = 0\ncnt = 0\n\nfor i in range(n-1):\n    if h[i] >= h[i+1]:\n        cnt += 1\n    else:\n        if cnt > ans:\n            ans = cnt \n        cnt = 0\nelse:\n    if cnt > ans:\n        ans = cnt\n    \nprint(ans)", "generated_code": "\n\"\"\"\n\nhttps://atcoder.jp/contests/arc097/tasks/arc097_d\n\n入力は{N}\n0 <= h <= N\nの間の中から最大化する場合をmaxで取り出せる\nそのまま hを選んできる場16番目に等しい\n\n基本上であるだけの要素を0に戻すておく\n\n\"\"\"\nimport sys\ninput = sys.stdin.readline\n\ndef main():\n\tN = int(input())\n\tH = [int(x) for x in input().split()]\n\theap = []\n\t# 元テーブルを複数", "score": 0.0, "codebleu": 0.13640090116518855, "crystalbleu": 0, "codebertscore": 0.63, "codescore": 0.006404468324035406, "surfaceSim": 0.2943645083932853, "abs_surfaceSim_minus_score": 0.2943645083932853, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-1592_6", "golden_code": "import re\nimport itertools\nfrom collections import Counter, deque\n\nclass Task:\n    tasks = []\n    answer = \"\" \n\t\n    def getData(self):\n        numberOfTasks = int(input())\n        for i in range(0, numberOfTasks):\n            self.tasks += [[int(x) for x in input().split(' ')]]\n        #inFile = open('input.txt', 'r')\n        #inFile.readline().rstrip()\n        #self.childs = inFile.readline().rstrip()\n\n    def solve(self):\n        queueSize, maxQueueSize = 0, 0\n        time, timeOfLastMessage = 1, 1\n        currentTask = 0\n        while currentTask < len(self.tasks) or queueSize > 0:\n            maxQueueSize = max(maxQueueSize, queueSize)\n            if currentTask < len(self.tasks):\n                timeDelta = self.tasks[currentTask][0] - time\n                queueSize -= min(queueSize, timeDelta)\n                time += timeDelta\n            else:\n                timeOfLastMessage = time + queueSize\n                break\n                \n            if currentTask < len(self.tasks) and \\\n                    self.tasks[currentTask][0] == time:\n                queueSize += self.tasks[currentTask][1]\n                currentTask += 1\n        self.answer = str(timeOfLastMessage) + \" \" + str(maxQueueSize)\n\n    def printAnswer(self):\n        print(self.answer)\n        #outFile = open('output.txt', 'w')\n        #outFile.write(self.answer)\n\ntask = Task()\ntask.getData()\ntask.solve()\ntask.printAnswer()\n", "generated_code": "def main():\n\tn = int(input())\n\tl, res, r = [0] * n, [0] * (n + 1), []\n\tfor i in range(n):\n\t\tt, c = list(map(int, input().split()))\n\t\tl[i] = t\n\t\tr.append(c)\n\tfor i, a in enumerate(zip(l, r)):\n\t\tj, b = a\n\t\tif b:\n\t\t\theapq.heappush(r, j)\n\t\telse:\n\t\t\theappush(l, j)\n\tprint(l[-1], len(r))\n\n\ndef __starting_point():\n\tmain()\n\n__starting_point()\n", "score": 0.0, "codebleu": 0.12656410254941533, "crystalbleu": 0.05, "codebertscore": 0.65, "codescore": 0.07034525275230408, "surfaceSim": 0.496837561663143, "abs_surfaceSim_minus_score": 0.496837561663143, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_1254_3_MUT_12", "golden_code": "(n, m) = list(map(int, input().split()))\nspec = {}\nfor i in range(n):\n    (s, r) = list(map(int, input().split()))\n    if s in spec:\n        spec[s].append(r)\n    else:\n        spec[s] = [r]\nf = n\ncnt = [-1 for i in range(n + 1)]\nfor (k, cur) in list(spec.items()):\n    cur.sort(reverse=True)\n    for j in range(1, len(cur)):\n        cur[j] += cur[j - 1]\n    for j in range(1, len(cur) + 1):\n        if cnt[j] == -1:\n            cnt[j] = 0\n        cnt[j] += max(0, cur[j - 1])\nprint(max(cnt))", "generated_code": "(n, m) = list(map(int, input().split()))\nspec = {}\nfor i in range(n):\n    (s, r) = list(map(int, input().split()))\n    if s not in spec:\n        spec[s].append(r)\n    else:\n        spec[s] = [r]\nf = n\ncnt = [-1 for i in range(n + 1)]\nfor (k, cur) in list(spec.items()):\n    cur.sort(reverse=True)\n    for j in range(1, len(cur)):\n        cur[j] += cur[j - 1]\n    for j in range(1, len(cur) + 1):\n        if cnt[j] == -1:\n            cnt[j] = 0\n        cnt[j] += max(0, cur[j - 1])\nprint(max(cnt))", "score": 0.0, "codebleu": 0.9863294748250621, "crystalbleu": 0.97, "codebertscore": 1.0, "codescore": 0.9937280416488647, "surfaceSim": 0.9624930478309233, "abs_surfaceSim_minus_score": 0.9624930478309233, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_HE_114_MUT_26", "golden_code": "import os\n\ndef minSubArraySum(nums):\n    max_sum = 0\n    s = 0\n    for num in nums:\n        s += -num\n        if s < 0:\n            s = 0\n        max_sum = max(s, max_sum)\n    if max_sum == 0:\n        max_sum = max((-i for i in nums))\n    min_sum = -max_sum\n    return min_sum", "generated_code": "import os\n\ndef minSubArraySum(nums):\n    max_sum = 0\n    s = 0\n    for num in nums:\n        break\n    \n    \n    \n    if max_sum == 0:\n        max_sum = max((-i for i in nums))\n    min_sum = -max_sum\n    return min_sum", "score": 0.3119, "codebleu": 0.6279859929018046, "crystalbleu": 0, "codebertscore": 0.95, "codescore": 0.10872124880552292, "surfaceSim": 0.847536231884058, "abs_surfaceSim_minus_score": 0.535636231884058, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_HE_35_OP_1", "golden_code": "def max_element(l: list):\n    m = l[0]\n    for e in l:\n        if e > m:\n            m = e\n    return m", "generated_code": "def max_element(data: list):\n    if not data:\n        return None\n    return max(data)", "score": 1.0, "codebleu": 0.11958670428551815, "crystalbleu": 0, "codebertscore": 0.82, "codescore": 0.9936339855194092, "surfaceSim": 0.5717935615738374, "abs_surfaceSim_minus_score": 0.42820643842616257, "source": "local", "local_type": "OP"}
{"id": "LOCAL_HE_115_OP_1", "golden_code": "def max_fill(grid, capacity):\n    import math\n    return sum([math.ceil(sum(arr)/capacity) for arr in grid])", "generated_code": "def max_fill(matrix, max_cap):\n    import math\n    total = 0\n    for line in matrix:\n        total += (sum(line) + max_cap - 1) // max_cap\n    return total", "score": 1.0, "codebleu": 0.3086032957739884, "crystalbleu": 0, "codebertscore": 0.83, "codescore": 0.0920121818780899, "surfaceSim": 0.5479663394109398, "abs_surfaceSim_minus_score": 0.45203366058906025, "source": "local", "local_type": "OP"}
{"id": "LOCAL_APPS_1275_39_MUT_23", "golden_code": "(N, K) = list(map(int, input().split()))\nans = 0\nfor i in range(2, (2 * N) + 1):\n    j = i - K\n    if not (2 <= j <= 2 * N):\n        continue\n    ans += min(i - 1, ((2 * N) - i) + 1) * min(j - 1, ((2 * N) - j) + 1)\nprint(ans)", "generated_code": "(N, K) = list(map(int, input().split()))\nans = 0\nfor i in range(2, (2 * N) + 1):\n    j = i - K\n    if not (2 <= j <= 2 * N):\n        continue\n    ans += min(i - 1, ((2 * N) - i) + 1) * min(j - 1, ((2 * N) - j) - 1)\nprint(ans)", "score": 0.032, "codebleu": 0.9794229347956501, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.9937829375267029, "surfaceSim": 0.9977777777777778, "abs_surfaceSim_minus_score": 0.9657777777777777, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-1290_45", "golden_code": "n, m = list(map(int, input().strip().split()))\narr = list(map(int, input().strip().split()))\nrslt = [0]*n\nfor x in arr:\n    rslt[x-1] += 1\nprint(min(rslt))\n", "generated_code": "import math\n\nn, m = map(int, input().split())\nc = [int(i) for i in input().split()]\nans = 0\nrow = 0\ncol = 0\ns = 0\n\nfor i in range(n):\n\tfor j in range(m):\n\t\tif c[i] == 1:\n\t\t\ts += 1\n\t\t\tif s == m:\n\t\t\t\tcol = i\n\t\t\t\ts = 0\n\t\t\t\trow = i\n\t\t\t\tcol = j\n\t\t\t\tans += (row+1)*(col+1)\n\t\t\telse:\n\t\t\t\trow =i\n\t\t\t\tcol =j\n\t\t\t\tans += row*col\n\t\t\t\trow = n-1\n\t\t\t\tcol = m-1\n\t\t\t\ts = m*(m+1)/2\n\t\t\t\tans += s\n\t\t\t# print(ans, row, col)\nprint(ans)\n", "score": 0.0258, "codebleu": 0.2514307006978038, "crystalbleu": 0.06, "codebertscore": 0.75, "codescore": 0.07286756485700607, "surfaceSim": 0.5899919289749798, "abs_surfaceSim_minus_score": 0.5641919289749797, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_47_12_MUT_39", "golden_code": "(n, x) = map(int, input().split())\nA = list(map(int, input().split()))\nDP = [[0] * 3 for _ in range(n + 1)]\nans = 0\nfor i in range(1, n + 1):\n    DP[i][0] = max(DP[i - 1][0] + A[i - 1], A[i - 1])\n    DP[i][1] = max(DP[i - 1][0] + (A[i - 1] * x), DP[i - 1][1] + (A[i - 1] * x), A[i - 1] * x)\n    DP[i][2] = max(DP[i - 1][1] + A[i - 1], DP[i - 1][2] + A[i - 1], A[i - 1])\n    ans = max(ans, max(DP[i]))\nprint(ans)", "generated_code": "pass\nA = list(map(int, input().split()))\nDP = [[0] * 3 for _ in range(n + 1)]\nans = 0\nfor i in range(1, n + 1):\n    DP[i][0] = max(DP[i - 1][0] + A[i - 1], A[i - 1])\n    DP[i][1] = max(DP[i - 1][0] + (A[i - 1] * x), DP[i - 1][1] + (A[i - 1] * x), A[i - 1] * x)\n    DP[i][2] = max(DP[i - 1][1] + A[i - 1], DP[i - 1][2] + A[i - 1], A[i - 1])\n    ans = max(ans, max(DP[i]))\nprint(ans)", "score": 0.0, "codebleu": 0.7946914699859673, "crystalbleu": 0.91, "codebertscore": 0.98, "codescore": 0.993823766708374, "surfaceSim": 0.9183176920403198, "abs_surfaceSim_minus_score": 0.9183176920403198, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_PIE_extra_p02792_s064765551_OP_1", "golden_code": "N=int(eval(input()))\n\nC=[[0]*9  for i in range(9)]\n\ncount=0\n\n\n\nfor n in range(1,N+1):\n\n   if str(n)[-1]!=\"0\":\n\n      left=int(str(n)[0])-1\n\n      right=int(str(n)[-1])-1\n\n      C[left][right]+=1\n\n      \n\nfor i in range(1,10):\n\n   for j in range(1,10):\n\n      count+=C[i-1][j-1]*C[j-1][i-1]\n\n\n\nprint(count)", "generated_code": "from sys import stdin\n\ndef main():\n\n    #入力\n\n    readline=stdin.readline\n\n    N=int(readline())\n\n    d=dict()\n\n    for i in range(1,N+1):\n\n        i=str(i)\n\n        head=i[0]\n\n        tail=i[-1]\n\n        if tail==\"0\":\n\n            continue\n\n        if (head,tail) not in d:\n\n            d[(head,tail)]=1\n\n        else:\n\n            d[(head,tail)]+=1\n\n\n\n    ans=0\n\n    s=set()\n\n    for k in list(d.keys()):\n\n        m,l=k[0],k[1]\n\n        if (m,l) in s:\n\n            continue\n\n        if (l,m) in d:\n\n            ans+=d[(m,l)]*d[(l,m)]\n\n            if (m,l)!=(l,m):\n\n                ans+=d[(m,l)]*d[(l,m)]\n\n        s.add((m,l))\n\n        s.add((l,m))\n\n\n\n    print(ans)\n\n\n\nif __name__==\"__main__\":\n\n    main()", "score": 1.0, "codebleu": 0.16353358928132583, "crystalbleu": 0.11, "codebertscore": 0.74, "codescore": 0.025236278772354126, "surfaceSim": 0.5653641059823362, "abs_surfaceSim_minus_score": 0.4346358940176638, "source": "local", "local_type": "OP"}
{"id": "APPS_test-3960_8", "golden_code": "# n, m = [int(x) for x in input().split(\" \")]\n# s = set()\n# ls = [0]*(n+1)\n# in_C = input().split(\" \")\n#\n# for x in range(len(in_C)-1, -1, -1):\n#     s.add(int(in_C[x]))\n#     ls[x+1] = len(s)\n# [print(ls[int(input())]) for i in range(m)]\n#\n# in_x = input()\n# n = list(in_x)\n# length = len(n)\n# counter = 0\n# counter_2 = 0\n# for _ in range(length):\n#     temp = n[:]\n#     if counter > 0:\n#         temp.pop(counter)\n#     counter += 1\n#     for j in range(0, len(temp)):\n#         if j > 0:\n#             temp.pop((length - 1) - j)\n#         num = int(\"\".join(temp))\n#         if num % 8 == 0:\n#             print(f\"YES\\n{num}\")\n#             return\n#     temp = n[:]\n#     if counter_2 > 0:\n#         temp.pop(counter_2)\n#     counter_2 += 1\n#     # print(temp)\n#     for j in range(len(temp), 1, -1):\n#         temp.pop(j - len(temp))\n#         num = (int(\"\".join(temp)))\n#         # print(num)\n#         if num % 8 == 0:\n#             print(f\"YES\\n{num}\")\n#             return\n# print(\"NO\")\nn = int(input())\nnums = input().split(\" \")\nsumas = [0] * (n+1)\ndp = [[0] * 2 for _ in range(n+1)]\nres = -1e11\nfor x in range(0, n):\n    if x > 0:\n        sumas[x] = abs(int(nums[x]) - int(nums[x - 1]))\nfor x in range(1, n+1):\n    dp[x][0] = max(sumas[x], dp[x - 1][1] + sumas[x])\n    dp[x][1] = max(-sumas[x], dp[x - 1][0] - sumas[x])\n    res = max(max(dp[x][0], dp[x][1]), res)\nprint(res)", "generated_code": "n = int(input())\nA = list(map(int, input().split()))\n\nres = 0\nfor i in range(1, n - 1):\n\ta = A[i]\n\tb = A[i - 1]\n\tc = A[i + 1]\n\tres = max(res, a - b - c)\n\nprint(res)\n", "score": 0.0078, "codebleu": 0.1486778163154316, "crystalbleu": 0.06, "codebertscore": 0.72, "codescore": 0.11984672397375107, "surfaceSim": 0.7308526011560694, "abs_surfaceSim_minus_score": 0.7230526011560694, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_23_17", "golden_code": "def same_Length(A,B): \r\n    while (A > 0 and B > 0): \r\n        A = A / 10; \r\n        B = B / 10; \r\n    if (A == 0 and B == 0): \r\n        return True; \r\n    return False; ", "generated_code": "def same_Length(A,B): \n\tif len(str(A))==len(str(B)): \n\t\treturn True\n\treturn False\nss = lambda x: x in (str(x), str(x))\nsi = lambda: int(str(x)[0]+''.join(x for x in str(x) if x.isdigit()))\nchar = lambda x, dic: chr(x+ord('a'))", "score": 0.6143, "codebleu": 0.1549064648499226, "crystalbleu": 0, "codebertscore": 0.73, "codescore": 0.4799339473247528, "surfaceSim": 0.40288373512358866, "abs_surfaceSim_minus_score": 0.2114162648764113, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_43_73", "golden_code": "def is_Two_Alter(s):  \r\n    for i in range (len( s) - 2) : \r\n        if (s[i] != s[i + 2]) : \r\n            return False\r\n    if (s[0] == s[1]): \r\n        return False\r\n    return True", "generated_code": "def is_Two_Alter(s):  \n\tprev = s[0]\n\tif len(s)!= 2:\n\t\treturn False   \n\tfor i in range(1,len(s)):\n\t\tif s[i]!=prev:\n\t\t\treturn False\n\t\tprev = S(s[i])\n\treturn True   \n\t\nS = 'abcdefghijklmnopqrstuvwxyz'", "score": 0.8576, "codebleu": 0.28152397024369824, "crystalbleu": 0, "codebertscore": 0.82, "codescore": 0.966246485710144, "surfaceSim": 0.6576021271452743, "abs_surfaceSim_minus_score": 0.1999978728547257, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-1128_42", "golden_code": "a, b = list(map(int, input().split(' ')))\nbad = a\nfor i in range(133742):\n    bad = bad*2\n    if bad % b == 0:\n        print(\"Yes\")\n        quit()\n    else:\n        bad %= b\nprint(\"No\")\n", "generated_code": "a, m = map(int,input().split())\nif(a%m==0):\n\tprint(\"Yes\")\nelse:\n\tprint(\"No\")\n", "score": 0.9915, "codebleu": 0.17533121887164294, "crystalbleu": 0, "codebertscore": 0.81, "codescore": 0.5556458830833435, "surfaceSim": 0.7419354838709677, "abs_surfaceSim_minus_score": 0.2495645161290323, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_MBPP_469_MUT_34", "golden_code": "import os\n\ndef max_profit(price, k):\n    n = len(price)\n    final_profit = [[None for x in range(n)] for y in range(k + 1)]\n    for i in range(k + 1):\n        for j in range(n):\n            if (i == 0 or j == 0):\n                final_profit[i][j] = 0\n            else:\n                max_so_far = 0\n                for x in range(j):\n                    curr_price = (price[j] - price[x]) + final_profit[i - 1][x]\n                    if max_so_far < curr_price:\n                        max_so_far = curr_price\n                final_profit[i][j] = max(final_profit[i][j - 1], max_so_far)\n    return final_profit[k][n - 1]", "generated_code": "import os\n\ndef max_profit(price, k):\n    n = len(price)\n    final_profit = [[None for x in range(n)] for y in range(k + 1)]\n    for i in range(k + 1):\n        for j in range(n):\n            break\n    \n    \n    \n    \n    \n    \n    \n    \n    return final_profit[k][n - 1]", "score": 0.0, "codebleu": 0.41587578732512626, "crystalbleu": 0.27, "codebertscore": 0.87, "codescore": 0.1329287588596344, "surfaceSim": 0.6957395498392283, "abs_surfaceSim_minus_score": 0.6957395498392283, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_APPS_1123_28_MUT_22", "golden_code": "MOD = (10 ** 9) + 7\n\ndef pow_mod(x, n):\n    if n == 0:\n        return 1\n    elif n % 2 == 0:\n        return pow_mod((x ** 2) % MOD, n // 2) % MOD\n    else:\n        return (x * pow_mod((x ** 2) % MOD, n // 2)) % MOD\n\n(N, K) = map(int, input().split())\nans = 0\nrec = [0] * (K + 1)\nfor X in range(K, 0, -1):\n    rec[X] = pow_mod(K // X, N)\n    for i in range(2, (K // X) + 1):\n        rec[X] = (rec[X] - rec[i * X]) % MOD\n    ans = (ans + (X * rec[X])) % MOD\nprint(ans)", "generated_code": "MOD = (10 ** 9) + 7\n\ndef pow_mod(x, n):\n    if n == 0:\n        return 1\n    elif n % 2 == 0:\n        return pow_mod((x ** 2) % MOD, n // 2) % MOD\n    else:\n        return (x * pow_mod((x ** 2) % MOD, n // 2)) % MOD\n\n(N, K) = map(int, input().split())\nans = 0\nrec = [0] * (K + 1)\nfor X in range(K, 0, +1):\n    rec[X] = pow_mod(K // X, N)\n    for i in range(2, (K // X) + 1):\n        rec[X] = (rec[X] - rec[i * X]) % MOD\n    ans = (ans + (X * rec[X])) % MOD\nprint(ans)", "score": 0.0, "codebleu": 0.9876351671149788, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9937310814857483, "surfaceSim": 0.9666689741104804, "abs_surfaceSim_minus_score": 0.9666689741104804, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-0302_57", "golden_code": "n = int(input())\nd = {n: 0}\nm = len(str(n)) + 1\nu = int('1' * (m+1))\nfor i in range(m, 0, -1):\n    d, e, u = {}, d, u // 10\n    for v, c in e.items():\n        lim = v // u\n        for x in range(-1 - lim, 1 - lim):\n            t = v + x * u\n            d[t] = min(c + i * abs(x), d.get(t, 999))\nprint(d[0])", "generated_code": "def main():\n\tn = int(input())\n\tt = 1\n\twhile t <= n:\n\t\tt *= 10\n\t\tq = n // t\n\t\tans = 0\n\t\tq += 1\n\t\tm = 1\n\t\twhile q > 0:\n\t\t\tq //= 10\n\t\t\tm *= 10\n\t\t\tans += m\n\t\tprint(ans)\n\ndef __starting_point():\n\tmain()\n\n__starting_point()\n", "score": 0.0, "codebleu": 0.08872914002724483, "crystalbleu": 0, "codebertscore": 0.74, "codescore": 0.05411869287490845, "surfaceSim": 0.4544817927170868, "abs_surfaceSim_minus_score": 0.4544817927170868, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_20_OP_2", "golden_code": "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    closest_pair = None\n    distance = None\n\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                if distance is None:\n                    distance = abs(elem - elem2)\n                    closest_pair = tuple(sorted([elem, elem2]))\n                else:\n                    new_distance = abs(elem - elem2)\n                    if new_distance < distance:\n                        distance = new_distance\n                        closest_pair = tuple(sorted([elem, elem2]))\n\n    return closest_pair", "generated_code": "from typing import List, Tuple\n\ndef find_closest_elements(values: List[float]) -> Tuple[float, float]:\n    if len(values) < 2:\n        return None\n\n    sorted_values = sorted(values)\n    min_distance = float('inf')\n    closest_pair = None\n\n    for i in range(len(sorted_values) - 1):\n        current_distance = abs(sorted_values[i] - sorted_values[i + 1])\n        if current_distance < min_distance:\n            min_distance = current_distance\n            closest_pair = (sorted_values[i], sorted_values[i + 1])\n\n    return closest_pair\n", "score": 0.9548, "codebleu": 0.30152555953898363, "crystalbleu": 0.24, "codebertscore": 0.82, "codescore": 0.368235319852829, "surfaceSim": 0.7544465843434915, "abs_surfaceSim_minus_score": 0.20035341565650844, "source": "local", "local_type": "OP"}
{"id": "MBPP_8_40", "golden_code": "def fibonacci(n):\r\n  if n == 1 or n == 2:\r\n    return 1\r\n  else:\r\n    return (fibonacci(n - 1) + (fibonacci(n - 2)))", "generated_code": "def fibonacci(n):   \n\ta = 0\n\tb = 1\n\tfor i in range(n):\n\t\ta, b = b, a+b\n\treturn a", "score": 1.0, "codebleu": 0.11726991214743931, "crystalbleu": 0, "codebertscore": 0.78, "codescore": 0.9751766324043274, "surfaceSim": 0.5248357963875205, "abs_surfaceSim_minus_score": 0.47516420361247946, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_1039_1_OP_1", "golden_code": "import sys\ndef input():return sys.stdin.readline().strip()\nfrom collections import deque\n\ndef main():\n    N = int(input())\n    info = [tuple(map(int, input().split())) for _ in range(N-1)]\n    Q, K = map(int, input().split())\n    queries = [tuple(map(int, input().split())) for _ in range(Q)]\n\n    to = [[] for _ in range(N)]\n    for a, b, c in info:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        to[b].append((a, c))\n    \n    INF = 10**18\n    dist = [INF]*N\n    def dfs(s):\n        stack = deque()\n        push = stack.append\n        pop = stack.pop\n\n        dist[s] = 0\n        push(s)\n\n        while stack:\n            now = pop()\n            now_cost = dist[now]\n\n            for nv, c in to[now]:\n                if dist[nv] != INF:\n                    continue\n                dist[nv] = now_cost + c\n                push(nv)\n\n\n    K -= 1\n    dfs(K)\n    ans = []\n    for x, y in queries:\n        x -= 1\n        y -= 1\n        xy = dist[x] + dist[y]\n        ans.append(xy)\n\n    print(*ans, sep=\"\\n\")\ndef __starting_point():\n    main()\n__starting_point()", "generated_code": "\nimport sys\nfrom collections import deque\ndef input(): return sys.stdin.readline().strip()\n\ndef main():\n    num_nodes = int(input())\n    edges = [tuple(map(int, input().split())) for _ in range(num_nodes - 1)]\n    num_queries, start_node = map(int, input().split())\n    query_data = [tuple(map(int, input().split())) for _ in range(num_queries)]\n\n    adj_list = [[] for _ in range(num_nodes)]\n    for node1, node2, weight in edges:\n        node1 -= 1\n        node2 -= 1\n        adj_list[node1].append((node2, weight))\n        adj_list[node2].append((node1, weight))\n    \n    large_num = 10**18\n    distances = [large_num] * num_nodes\n\n    def depth_first_traversal(start):\n        stack = deque([start])\n        distances[start] = 0\n\n        while stack:\n            current_node = stack.pop()\n            current_distance = distances[current_node]\n\n            for neighbor, edge_weight in adj_list[current_node]:\n                if distances[neighbor] == large_num:\n                    distances[neighbor] = current_distance + edge_weight\n                    stack.append(neighbor)\n\n    start_node -= 1\n    depth_first_traversal(start_node)\n    results = []\n    for node_x, node_y in query_data:\n        node_x -= 1\n        node_y -= 1\n        total_distance = distances[node_x] + distances[node_y]\n        results.append(total_distance)\n\n    print('\\n'.join(map(str, results)))\n\ndef __starting_point():\n    main()\n\n__starting_point()\n", "score": 1.0, "codebleu": 0.5166688290894443, "crystalbleu": 0.32, "codebertscore": 0.83, "codescore": 0.19127050042152405, "surfaceSim": 0.7254039007692452, "abs_surfaceSim_minus_score": 0.2745960992307548, "source": "local", "local_type": "OP"}
{"id": "LOCAL_HE_22_OP_1", "golden_code": "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    return [x for x in values if isinstance(x, int)]", "generated_code": "from typing import List, Any\n\n\ndef filter_integers(elements: List[Any]) -> List[int]:\n    integers = []\n    append_int = integers.append\n    for item in elements:\n        if isinstance(item, int):\n            append_int(item)\n    return integers", "score": 1.0, "codebleu": 0.5576269007905895, "crystalbleu": 0, "codebertscore": 0.89, "codescore": 0.9781107902526855, "surfaceSim": 0.6278911564625851, "abs_surfaceSim_minus_score": 0.3721088435374149, "source": "local", "local_type": "OP"}
{"id": "LOCAL_MBPP_136_OP_1", "golden_code": "def cal_electbill(units):\r\n if(units < 50):\r\n    amount = units * 2.60\r\n    surcharge = 25\r\n elif(units <= 100):\r\n    amount = 130 + ((units - 50) * 3.25)\r\n    surcharge = 35\r\n elif(units <= 200):\r\n    amount = 130 + 162.50 + ((units - 100) * 5.26)\r\n    surcharge = 45\r\n else:\r\n    amount = 130 + 162.50 + 526 + ((units - 200) * 8.45)\r\n    surcharge = 75\r\n total = amount + surcharge\r\n return total", "generated_code": "def cal_electbill(u):\n    if u < 50:\n        amt = u * 2.60\n        scrg = 25\n    elif u <= 100:\n        amt = 130 + ((u - 50) * 3.25)\n        scrg = 35\n    elif u <= 200:\n        amt = 292.5 + ((u - 100) * 5.26)\n        scrg = 45\n    else:\n        amt = 818.5 + ((u - 200) * 8.45)\n        scrg = 75\n    return amt + scrg", "score": 1.0, "codebleu": 0.43036397329042386, "crystalbleu": 0.32, "codebertscore": 0.85, "codescore": 0.9938708543777466, "surfaceSim": 0.8580402010050251, "abs_surfaceSim_minus_score": 0.1419597989949749, "source": "local", "local_type": "OP"}
{"id": "APPS_test-2708_57", "golden_code": "k,l=list(map(int,input().split()))\r\nfor i in range(0,l):\r\n    if k%10==0:\r\n        k=k/10\r\n    else:\r\n        k=k-1\r\nprint(int(k))\r\n", "generated_code": "# cook your dish here\nn,k = map(int,input().split())\nfor i in range(n,n-k-1,-1):\n\tif i%10 == 0:\n\t\ti = i//10\n\telse:\n\t\ti=i%10\n\t\t\n\t\n\tprint(i-1*k)\n", "score": 0.0, "codebleu": 0.28184492217982743, "crystalbleu": 0, "codebertscore": 0.85, "codescore": 0.06415984779596329, "surfaceSim": 0.784965034965035, "abs_surfaceSim_minus_score": 0.784965034965035, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_134_OP_1", "golden_code": "def check_if_last_char_is_a_letter(txt):\n    '''\n    Create a function that returns True if the last character\n    of a given string is an alphabetical character and is not\n    a part of a word, and False otherwise.\n    Note: \"word\" is a group of characters separated by space.\n\n    Examples:\n    check_if_last_char_is_a_letter(\"apple pie\") ➞ False\n    check_if_last_char_is_a_letter(\"apple pi e\") ➞ True\n    check_if_last_char_is_a_letter(\"apple pi e \") ➞ False\n    check_if_last_char_is_a_letter(\"\") ➞ False \n    '''\n\n    check = txt.split(' ')[-1]\n    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False", "generated_code": "def check_if_last_char_is_a_letter(input_string):\n    '''\n    Create a function that returns True if the last character\n    of a given string is an alphabetical character and is not\n    a part of a word, and False otherwise.\n    Note: \"word\" is a group of characters separated by space.\n\n    Examples:\n    check_if_last_char_is_a_letter(\"apple pie\") ➞ False\n    check_if_last_char_is_a_letter(\"apple pi e\") ➞ True\n    check_if_last_char_is_a_letter(\"apple pi e \") ➞ False\n    check_if_last_char_is_a_letter(\"\") ➞ False \n    '''\n\n    trimmed_string = input_string.rstrip()\n    if not trimmed_string or ' ' in trimmed_string.split()[-1]:\n        return False\n    return trimmed_string[-1].isalpha()", "score": 0.7614, "codebleu": 0.5449515055902927, "crystalbleu": 0, "codebertscore": 0.95, "codescore": 0.9450090527534485, "surfaceSim": 0.7613346104725416, "abs_surfaceSim_minus_score": 6.538952745838156e-05, "source": "local", "local_type": "OP"}
{"id": "MBPP_22_17", "golden_code": "def find_Extra(arr1,arr2,n) : \r\n    for i in range(0, n) : \r\n        if (arr1[i] != arr2[i]) : \r\n            return i \r\n    return n ", "generated_code": "def find_Extra(arr1,arr2,n) : \n\tfor i in range(len(arr2)):\n\t\tif arr1.count(arr2[i]) > n:\n\t\t\treturn arr2.index(arr2 [i])\n\treturn -1\nll = ['a', 'b', 'c']", "score": 0.0, "codebleu": 0.36382114382849406, "crystalbleu": 0, "codebertscore": 0.88, "codescore": 0.07390472292900085, "surfaceSim": 0.6587898856110777, "abs_surfaceSim_minus_score": 0.6587898856110777, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_69_MUT_15", "golden_code": "import os\n\ndef search(lst):\n    '''\n    You are given a non-empty list of positive integers. Return the greatest integer that is greater than \n    zero, and has a frequency greater than or equal to the value of the integer itself. \n    The frequency of an integer is the number of times it appears in the list.\n    If no such a value exist, return -1.\n    Examples:\n        search([4, 1, 2, 2, 3, 1]) == 2\n        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n        search([5, 5, 4, 4, 4]) == -1\n    '''\n    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1\n    \n    ans = -1\n    for i in range(1, len(frq)):\n        if frq[i] >= i:\n            ans = i\n    \n    return ans", "generated_code": "import os\n\ndef search(lst):\n    '''\n    You are given a non-empty list of positive integers. Return the greatest integer that is greater than \n    zero, and has a frequency greater than or equal to the value of the integer itself. \n    The frequency of an integer is the number of times it appears in the list.\n    If no such a value exist, return -1.\n    Examples:\n        search([4, 1, 2, 2, 3, 1]) == 2\n        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n        search([5, 5, 4, 4, 4]) == -1\n    '''\n    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1\n    \n    ans = -1\n    for i in range(1, len(frq)):\n        if frq[i] <= i:\n            ans = i\n    \n    return ans", "score": 0.1058, "codebleu": 0.989545704635, "crystalbleu": 0, "codebertscore": 1.0, "codescore": 0.9937291145324707, "surfaceSim": 0.9635547201336675, "abs_surfaceSim_minus_score": 0.8577547201336675, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_PIE_extra_p02700_s232689719_OP_1", "golden_code": "import sys\n\ninput = sys.stdin.readline\n\nfrom collections import *\n\n\n\nA, B, C, D = list(map(int, input().split()))\n\n\n\nwhile True:\n\n    C -= B\n\n    \n\n    if C<=0:\n\n        print('Yes')\n\n        exit()\n\n    \n\n    A -= D\n\n    \n\n    if A<=0:\n\n        print('No')\n\n        exit()", "generated_code": "A, B, C, D = list(map(int, input().split()))\n\nc1 = (C+B-1)//B\n\nc2 = (A+D-1)//D\n\n\n\nif c1<=c2:\n\n    print('Yes')\n\nelse:\n\n    print('No')", "score": 1.0, "codebleu": 0.2864220350283604, "crystalbleu": 0, "codebertscore": 0.78, "codescore": 0.7208797335624695, "surfaceSim": 0.6148851148851149, "abs_surfaceSim_minus_score": 0.3851148851148851, "source": "local", "local_type": "OP"}
{"id": "LOCAL_PIE_extra_p03416_s789877064_OP_1", "golden_code": "a,b = list(map(int, input().split()))\n\nn = 0\n\nfor i in range(a, b + 1):\n\n    f = True\n\n    s = str(i)\n\n    l = len(s)\n\n    for j in range(l//2 + 1):\n\n        if s[j] != s[- j - 1]:\n\n            f = False\n\n            break\n\n    if f:\n\n        n += 1\n\nprint(n)", "generated_code": "a,b = list(map(int, input().split()))\n\nn = 0\n\nfor i in range(1, 10):\n\n    for j in range(10):\n\n        for k in range(10):\n\n            s = 10000 * i + 1000 * j + 100 * k + 10 * j + i\n\n            if a <= s <= b:\n\n                n += 1\n\nprint(n)", "score": 0.7928, "codebleu": 0.3861486435561774, "crystalbleu": 0, "codebertscore": 0.84, "codescore": 0.7611937522888184, "surfaceSim": 0.6802791802791803, "abs_surfaceSim_minus_score": 0.11252081972081962, "source": "local", "local_type": "OP"}
{"id": "LOCAL_HE_88_OP_1", "golden_code": "def sort_array(array):\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)", "generated_code": "def sort_array(data):\n    if not data:\n        return []\n    reverse_order = (data[0] + data[-1]) % 2 == 0\n    return sorted(data, reverse=reverse_order)", "score": 1.0, "codebleu": 0.40610197006250615, "crystalbleu": 0, "codebertscore": 0.89, "codescore": 0.9856321811676025, "surfaceSim": 0.6483660130718955, "abs_surfaceSim_minus_score": 0.35163398692810455, "source": "local", "local_type": "OP"}
{"id": "LOCAL_APPS_401_13_MUT_6", "golden_code": "(n, m) = list(map(int, input().split()))\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nf = True\nfor i in range(1, 10):\n    if (i in a and i in b):\n        print(i)\n        f = False\n        break\nif f:\n    print(str(min(min(a), min(b))) + str(max(min(a), min(b))))", "generated_code": "(n, m) = list(map(int, input().split()))\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nf = True\nfor i in range(1, 10):\n    if (i in a and i in b):\n        print(i)\n        f = False\n        break\nif not f:\n    print(str(min(min(a), min(b))) + str(max(min(a), min(b))))", "score": 0.0, "codebleu": 0.9677689914832857, "crystalbleu": 0.96, "codebertscore": 1.0, "codescore": 0.9936165809631348, "surfaceSim": 0.9472789115646258, "abs_surfaceSim_minus_score": 0.9472789115646258, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_HE_81_OP_1", "golden_code": "def numerical_letter_grade(grades):\n\n\n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade", "generated_code": "def numerical_letter_grade(scores):\n    \n    thresholds = [4.0, 3.7, 3.3, 3.0, 2.7, 2.3, 2.0, 1.7, 1.3, 1.0, 0.7, 0.0]\n    grades = [\"A+\", \"A\", \"A-\", \"B+\", \"B\", \"B-\", \"C+\", \"C\", \"C-\", \"D+\", \"D\", \"D-\"]\n    letter_grades = []\n    for score in scores:\n        for idx, threshold in enumerate(thresholds):\n            if score >= threshold:\n                letter_grades.append(grades[idx])\n                break\n        else:\n            letter_grades.append(\"E\")\n    return letter_grades", "score": 0.6707, "codebleu": 0.20578341365652414, "crystalbleu": 0.13, "codebertscore": 0.81, "codescore": 0.7109399437904358, "surfaceSim": 0.6292782738095238, "abs_surfaceSim_minus_score": 0.04142172619047613, "source": "local", "local_type": "OP"}
{"id": "LOCAL_PIE_extra_p03854_s135519212_OP_1", "golden_code": "s = input()[::-1]\n\n\n\nwhile True:\n\n    if len(s) == 0:\n\n        break\n\n    if s[:7] == \"remaerd\":\n\n        s = s[7:]\n\n    elif s[:6] == \"resare\":\n\n        s = s[6:]\n\n    elif s[:5] == \"maerd\" or s[:5] == \"esare\":\n\n        s = s[5:]\n\n    else:\n\n        print(\"NO\")\n\n        exit()\n\n\n\nprint(\"YES\")", "generated_code": "import re\n\n\n\ns = eval(input())\n\n\n\nif re.fullmatch(r\"(dream|dreamer|erase|eraser)+\", s):\n\n    print(\"YES\")\n\nelse:\n\n    print(\"NO\")", "score": 0.6856, "codebleu": 0.10333360166566952, "crystalbleu": 0, "codebertscore": 0.72, "codescore": 0.9629909992218018, "surfaceSim": 0.47155225726654304, "abs_surfaceSim_minus_score": 0.21404774273345695, "source": "local", "local_type": "OP"}
{"id": "LOCAL_APPS_4553_17_MUT_10", "golden_code": "import re\n(A, B) = list(map(int, input().split()))\nS = input()\nn_pattern = '[0-9]'\nres = 'Yes'\nfor i in range((A + B) + 1):\n    if i < A:\n        if re.match(n_pattern, S[i]) is None:\n            res = 'No'\n            break\n    elif i == A:\n        if S[i] != '-':\n            res = 'No'\n            break\n    \n    elif re.match(n_pattern, S[i]) is None:\n        res = 'No'\n        break\n\nprint(res)", "generated_code": "import re\n(A, B) = list(map(int, input().split()))\nS = input()\nn_pattern = '[0-9]'\nres = 'Yes'\nfor i in range((A + B) + 1):\n    if i < A:\n        if re.match(n_pattern, S[i]) is None:\n            res = 'No'\n            break\n    elif i == A:\n        if S[i] != '-':\n            res = 'No'\n            break\n    \n    elif not (re.match(n_pattern, S[i]) is None):\n        res = 'No'\n        break\n\nprint(res)", "score": 0.0, "codebleu": 0.9376870530640908, "crystalbleu": 0.93, "codebertscore": 0.99, "codescore": 0.9936985969543457, "surfaceSim": 0.9553808260704812, "abs_surfaceSim_minus_score": 0.9553808260704812, "source": "local", "local_type": "MUT"}
{"id": "MBPP_461_1", "golden_code": "def get_total_number_of_sequences(m,n): \r\n\tT=[[0 for i in range(n+1)] for i in range(m+1)] \r\n\tfor i in range(m+1): \r\n\t\tfor j in range(n+1): \r\n\t\t\tif i==0 or j==0: \r\n\t\t\t\tT[i][j]=0\r\n\t\t\telif i<j: \r\n\t\t\t\tT[i][j]=0\r\n\t\t\telif j==1: \r\n\t\t\t\tT[i][j]=i \r\n\t\t\telse: \r\n\t\t\t\tT[i][j]=T[i-1][j]+T[i//2][j-1] \r\n\treturn T[m][n]", "generated_code": "def get_total_number_of_sequences(a, node):\n\tres, i = 0, node\n\twhile i!=node:\n\t\tres+=1\n\t\ti = d[i]\n\treturn node, res", "score": 0.0, "codebleu": 0.06948979829470402, "crystalbleu": 0.0, "codebertscore": 0.73, "codescore": 0.029101049527525902, "surfaceSim": 0.4668859649122807, "abs_surfaceSim_minus_score": 0.4668859649122807, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_20_25", "golden_code": "def is_odd(n) : \r\n    if (n^1 == n-1) :\r\n        return True; \r\n    else :\r\n        return False; ", "generated_code": "def is_odd(s):\n\tn=int(s)\n\treturn (n & 1) * int(n >> 1) == 0", "score": 0.043, "codebleu": 0.2301810270584417, "crystalbleu": 0, "codebertscore": 0.79, "codescore": 0.5185245275497437, "surfaceSim": 0.601530612244898, "abs_surfaceSim_minus_score": 0.558530612244898, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-4183_3", "golden_code": "import sys\nimport math\npin=sys.stdin.readline\n\ndef main():\n  N=int(pin())\n  ans=int(pin())\n  for i in range(N-1):\n    T=int(pin())\n    ans=(ans*T)//math.gcd(ans,T)\n  print(ans)\n  return\nmain()", "generated_code": "n = int(input())\nt = list(map(int, input().split()))\n\na = [0 for _ in range(n)]\nfor i in range(n):\n\ta[i] = t[i]\nprint((a[-1] + a[0]) % 2)\n", "score": 0.0, "codebleu": 0.21154102119049467, "crystalbleu": 0, "codebertscore": 0.76, "codescore": 0.09948832541704178, "surfaceSim": 0.3990162037037037, "abs_surfaceSim_minus_score": 0.3990162037037037, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_4698_39_MUT_5", "golden_code": "N = int(input())\nT = list(map(int, input().split()))\nM = int(input())\nP = [0] * M\nX = [0] * M\nfor i in range(M):\n    (P[i], X[i]) = list(map(int, input().split()))\n\nfor i in range(M):\n    ans = 0\n    ans += sum(T[:P[i] - 1])\n    ans += X[i]\n    ans += sum(T[P[i]:])\n    print(ans)", "generated_code": "N = int(input())\nT = list(map(int, input().split()))\nM = int(input())\nP = [0] * M\nX = [0] // M\nfor i in range(M):\n    (P[i], X[i]) = list(map(int, input().split()))\n\nfor i in range(M):\n    ans = 0\n    ans += sum(T[:P[i] - 1])\n    ans += X[i]\n    ans += sum(T[P[i]:])\n    print(ans)", "score": 0.0, "codebleu": 0.9729567248830167, "crystalbleu": 0.89, "codebertscore": 0.99, "codescore": 0.9937105178833008, "surfaceSim": 0.9726317573292662, "abs_surfaceSim_minus_score": 0.9726317573292662, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_APPS_1123_28_MUT_1", "golden_code": "MOD = (10 ** 9) + 7\n\ndef pow_mod(x, n):\n    if n == 0:\n        return 1\n    elif n % 2 == 0:\n        return pow_mod((x ** 2) % MOD, n // 2) % MOD\n    else:\n        return (x * pow_mod((x ** 2) % MOD, n // 2)) % MOD\n\n(N, K) = map(int, input().split())\nans = 0\nrec = [0] * (K + 1)\nfor X in range(K, 0, -1):\n    rec[X] = pow_mod(K // X, N)\n    for i in range(2, (K // X) + 1):\n        rec[X] = (rec[X] - rec[i * X]) % MOD\n    ans = (ans + (X * rec[X])) % MOD\nprint(ans)", "generated_code": "MOD = (10 ** 9) + 7\n\ndef pow_mod(x, n):\n    if n == 0:\n        return 1\n    elif n % 2 == 0:\n        return pow_mod((x ** 2) % MOD, n // 2) % MOD\n    else:\n        return (x * pow_mod((x ** 2) % MOD, n // 2)) % MOD\n\n(N, K) = map(int, input().split())\nans = 0\nrec = [0] * (K + 1)\nfor X in range(K, 0, 1):\n    rec[X] = pow_mod(K // X, N)\n    for i in range(2, (K // X) + 1):\n        rec[X] = (rec[X] - rec[i * X]) % MOD\n    ans = (ans + (X * rec[X])) % MOD\nprint(ans)", "score": 0.0, "codebleu": 0.974194306899925, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.7636288404464722, "surfaceSim": 0.9655937052932761, "abs_surfaceSim_minus_score": 0.9655937052932761, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-1096_4", "golden_code": "s = input()\nif (s[0] == 'a' and (s[1] == '1' or s[1] == '8')) or\\\n    (s[0] == 'h' and (s[1] == '1' or s[1] == '8')):\n    print(3)\nelif s[0] in 'ah' or s[1] in '18':\n    print(5)\nelse:\n    print(8)\n", "generated_code": "import sys\nimport math\n\ndef __starting_point():\n\tposition = sys.stdin.readline().strip()\n\tletter = position[0]\n\tnumber = int(position[1:])\n\tif letter == \"d\":\n\t\tdirection = 1\n\telif letter == \"a\":\n\t\tdirection == 1\n\telse:\n\t\tdirection = 2\n\tc = int(position)\n\tnumber = number - c\n\tif number % 2 == 0:\n\t\tmoves = +1\n\telse: moves = 2\n\tfor i in range(1,9):\n\t\tif i % 2 == 0 and c > i:\n\t\t\tmoves = moves + 1\n\t\telif i % 2!= 0 and i > c:\n\t\t\tmversals = 1\n\t\telse:\n\t\t\tmuls = 1\n\t\tif i!= c:\n\t\t\tc2 = c - i\n\t\t\t", "score": 0.0, "codebleu": 0.10696565724867618, "crystalbleu": 0.0, "codebertscore": 0.69, "codescore": 0.01895807310938835, "surfaceSim": 0.4163790899795501, "abs_surfaceSim_minus_score": 0.4163790899795501, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_4715_36_OP_1", "golden_code": "def main():\n    c = list(map(int, input().split()))\n\n    c_set = set(c)\n    print((len(c_set)))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "generated_code": "def main():\n    numbers = set(map(int, input().split()))\n    print(len(numbers))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "score": 1.0, "codebleu": 0.47978504953393153, "crystalbleu": 0, "codebertscore": 0.93, "codescore": 0.8456771373748779, "surfaceSim": 0.9046052631578947, "abs_surfaceSim_minus_score": 0.09539473684210531, "source": "local", "local_type": "OP"}
{"id": "MBPP_33_42", "golden_code": "def count_Unset_Bits(n) :  \r\n    cnt = 0;  \r\n    for i in range(1,n + 1) : \r\n        temp = i;  \r\n        while (temp) :  \r\n            if (temp % 2 == 0) : \r\n                cnt += 1;  \r\n            temp = temp // 2;  \r\n    return cnt;  ", "generated_code": "def count_Unset_Bits(n) :  \n\tcount = 0\n\t\n\tfor i in range(0, n):\n\t\tcount += n >> i & 1\n\t\n\treturn count\nUST = True\nMOD = 10**9+7", "score": 0.0438, "codebleu": 0.14610261601517974, "crystalbleu": 0, "codebertscore": 0.78, "codescore": 0.09178759157657623, "surfaceSim": 0.6717436974789917, "abs_surfaceSim_minus_score": 0.6279436974789917, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_MBPP_522_MUT_21", "golden_code": "import os\n\ndef lbs(arr):\n    n = len(arr)\n    lis = [1 for i in range(n + 1)]\n    for i in range(1, n):\n        for j in range(0, i):\n            if (arr[i] > arr[j] and lis[i] < lis[j] + 1):\n                lis[i] = lis[j] + 1\n    lds = [1 for i in range(n + 1)]\n    for i in reversed(range(n - 1)):\n        for j in reversed(range(i - 1, n)):\n            if (arr[i] > arr[j] and lds[i] < lds[j] + 1):\n                lds[i] = lds[j] + 1\n    maximum = (lis[0] + lds[0]) - 1\n    for i in range(1, n):\n        maximum = max((lis[i] + lds[i]) - 1, maximum)\n    return maximum", "generated_code": "import os\n\ndef lbs(arr):\n    n = len(arr)\n    lis = [1 for i in range(n + 1)]\n    for i in range(1, n):\n        for j in range(0, i):\n            if (arr[i] > arr[j] and lis[i] < lis[j] + 1):\n                lis[i] = lis[j] + 1\n    lds = [1 for i in range(n + 1)]\n    for i in reversed(range(n - 1)):\n        for j in reversed(range(i - 1, n)):\n            if (arr[i] > arr[j] and lds[i] < lds[j] + 1):\n                lds[i] = lds[j] + 1\n        break\n    maximum = (lis[0] + lds[0]) - 1\n    for i in range(1, n):\n        maximum = max((lis[i] + lds[i]) - 1, maximum)\n    return maximum", "score": 0.4391, "codebleu": 0.9771862544238062, "crystalbleu": 0.97, "codebertscore": 1.0, "codescore": 0.993802547454834, "surfaceSim": 0.9770321246045266, "abs_surfaceSim_minus_score": 0.5379321246045266, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-1698_13", "golden_code": "n, k = map(int, input().split())\na = list(map(int, input().split()))\na.sort()\na = a[::-1]\nans = 0\nfor i in range((n - 1) // k + 1):\n    ans += (a[i * k] - 1)\nprint(ans * 2)", "generated_code": "# coding: utf-8\n# Your code here!\n\nn,k=list(map(int,input().split()))\n*l,=list(map (int,input().strip().split()))[:n]\na=[]\nb=[]\nfor i in range(n):\n\ta.append(l[i]-l[i-1])\n\tb.append(l [i]-l[ i-1])\nans=0\nfor i in a:\n\tans+=max(0,i)\nfor i in b:\n\tans+=(i-min(0,i))\nprint(ans)\n", "score": 0.0, "codebleu": 0.24418024184599046, "crystalbleu": 0.24, "codebertscore": 0.82, "codescore": 0.06105898693203926, "surfaceSim": 0.6731481481481482, "abs_surfaceSim_minus_score": 0.6731481481481482, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0470_4", "golden_code": "t = list(map(int, input().split()))\nbest = sum(t)\nfor x in t:\n    if t.count(x) == 1: continue\n    best = min(best, sum(t) - x * min(3, t.count(x)))\nprint(best)", "generated_code": "def main():\n\tnumbers = list(map(int, input().split()))\n\tnumbers.remove(max(numbers))\n\ttmp_sum = sum(numbers)\n\tans = tmp_sum\n\tdel numbers[0]\n\tdel numbers [0]\n\tfor number in numbers:\n\t\ttmp_sum -= number\n\t\tans = min(ans, tmp_sum)\n\tprint(ans)\n\n\ndef __starting_point():\n\tmain()\n\n__starting_point()\n", "score": 0.098, "codebleu": 0.28202284653836385, "crystalbleu": 0, "codebertscore": 0.77, "codescore": 0.05042390525341034, "surfaceSim": 0.42882536973833896, "abs_surfaceSim_minus_score": 0.330825369738339, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_extra_p03822_s508015569_OP_1", "golden_code": "import sys\n\nsys.setrecursionlimit(202020)\n\n\n\nN = int(eval(input()))\n\nwon = [[] for i in range(N)]\n\nfor i in range(1,N):\n\n    a = int(eval(input())) - 1\n\n    won[a].append(i)\n\n\n\ndef height(v):\n\n    if not won[v]: return 0\n\n    hs = [height(op) for op in won[v]]\n\n    ret = 0\n\n    for i,h in enumerate(sorted(hs)):\n\n        ret = max(ret, h + len(hs) - i)\n\n    return ret\n\n\n\nprint((height(0)))", "generated_code": "import sys\n\nsys.setrecursionlimit(10**8)\n\nN = int(eval(input()))\n\nA = [int(eval(input()))-1 for i in range(N-1)]\n\nwins = [[] for _ in range(N)]\n\n\n\nfor i,a in enumerate(A):\n\n    wins[a].append(i+1)\n\n\n\ndepth = [-1] * N\n\ndef dep(v):\n\n    if len(wins[v])==0: return 0\n\n    if depth[v] >= 0:\n\n        return depth[v]\n\n    ds = []\n\n    for w in wins[v]:\n\n        ds.append(dep(w))\n\n    ds.sort(reverse=True)\n\n    ret = 0\n\n    for i,d in enumerate(ds):\n\n        ret = max(ret, i+d+1)\n\n    depth[v] = ret\n\n    return ret\n\nprint((dep(0)))", "score": 1.0, "codebleu": 0.36651420744477914, "crystalbleu": 0.29, "codebertscore": 0.87, "codescore": 0.4595135748386383, "surfaceSim": 0.6995139076424521, "abs_surfaceSim_minus_score": 0.30048609235754786, "source": "local", "local_type": "OP"}
{"id": "MBPP_22_18", "golden_code": "def find_Extra(arr1,arr2,n) : \r\n    for i in range(0, n) : \r\n        if (arr1[i] != arr2[i]) : \r\n            return i \r\n    return n ", "generated_code": "def find_Extra(arr1,arr2,n) : \n\tfor i in range(len(arr2)):\n\t\tif arr1[i]!= arr2[i] :\n\t\t\treturn i\n\treturn len(arr2)\n\n\n\n\n\n\n\n'''\n\n\n\n\n\n\n\n\n\n\n\n'''\n\n'''\n\n\nInput: [2, 13,4,9,77,2,4,0], 2\n'''", "score": 1.0, "codebleu": 0.4341755463755147, "crystalbleu": 0, "codebertscore": 0.88, "codescore": 0.9938347339630127, "surfaceSim": 0.7910302242443938, "abs_surfaceSim_minus_score": 0.20896977575560616, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-1083_44", "golden_code": "n = int(input())\nf = []\ns = []\nf1 = s1 = 0\nfor i in range(n, 0, -1):\n\tif f1 <= s1:\n\t\tf1 += i\n\t\tf.append(i)\n\telse:\n\t\ts1 += i\n\t\ts.append(i)\nprint(abs(f1 - s1))\nprint(len(f), *f)", "generated_code": "def printList(l):\n\tprint(len(l))\n\tfor i in l:\n\t\tprint(i, end=' ')\nprint('')\n", "score": 0.0, "codebleu": 0.06205381853207972, "crystalbleu": 0, "codebertscore": 0.72, "codescore": 0.02461910806596279, "surfaceSim": 0.3542857142857143, "abs_surfaceSim_minus_score": 0.3542857142857143, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_extra_p03038_s124992398_OP_1", "golden_code": "from heapq import *\n\n\n\n\n\nn, m = list(map(int, input().split()))\n\nPAIRS = [[-a, -1] for a in map(int, input().split())]\n\nheapify(PAIRS)\n\n\n\nfor _ in range(m):\n\n    b, c = list(map(int, input().split()))\n\n    heappush(PAIRS, [-c, -b])\n\n\n\nanswer = 0\n\nfor _ in range(n):\n\n    pair = heappop(PAIRS)\n\n    answer += -pair[0]\n\n    pair[1] += 1\n\n    if pair[1] != 0:\n\n        heappush(PAIRS, pair)\n\n\n\nprint(answer)\n", "generated_code": "n, m = list(map(int, input().split()))\n\nPAIRS = [(a, 1) for a in map(int, input().split())]\n\n\n\nfor _ in range(m):\n\n    b, c = list(map(int, input().split()))\n\n    PAIRS.append((c, b))\n\nPAIRS.sort(reverse = True)\n\n\n\nanswer, count = 0, 0\n\nfor pair in PAIRS:\n\n    answer += pair[0] * pair[1]\n\n    count += pair[1]\n\n    if count > n:\n\n        answer -= pair[0] * (count - n)\n\n        break\n\n\n\nprint(answer)\n", "score": 1.0, "codebleu": 0.5191046229054204, "crystalbleu": 0.41, "codebertscore": 0.88, "codescore": 0.4436308741569519, "surfaceSim": 0.6286738351254479, "abs_surfaceSim_minus_score": 0.37132616487455206, "source": "local", "local_type": "OP"}
{"id": "MBPP_68_10", "golden_code": "def subset(ar, n): \r\n    res = 0\r\n    ar.sort() \r\n    for i in range(0, n) : \r\n        count = 1\r\n        for i in range(n - 1): \r\n            if ar[i] == ar[i + 1]: \r\n                count+=1\r\n            else: \r\n                break \r\n        res = max(res, count)  \r\n    return res ", "generated_code": "def subset(ar, k): \n return k and sum(x for x in ar[0:k]) or 0", "score": 0.0033, "codebleu": 0.06066930193222899, "crystalbleu": 0, "codebertscore": 0.7, "codescore": 0.16082718968391418, "surfaceSim": 0.4945221445221445, "abs_surfaceSim_minus_score": 0.49122214452214447, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_486_3", "golden_code": "import re \r\nregex = '[a-zA-z0-9]$'\r\ndef check_alphanumeric(string): \r\n\tif(re.search(regex, string)): \r\n\t\treturn (\"Accept\") \r\n\telse: \r\n\t\treturn (\"Discard\") ", "generated_code": "import re \nregex = '[a-zA-z0-9]$'\ndef check_alphanumeric(string):    \n\treturn ''.join(string.split())", "score": 0.0, "codebleu": 0.3890139322144148, "crystalbleu": 0, "codebertscore": 0.89, "codescore": 0.018194938078522682, "surfaceSim": 0.789247311827957, "abs_surfaceSim_minus_score": 0.789247311827957, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_8_16", "golden_code": "def fibonacci(n):\r\n  if n == 1 or n == 2:\r\n    return 1\r\n  else:\r\n    return (fibonacci(n - 1) + (fibonacci(n - 2)))", "generated_code": "def fibonacci(n):\n\ta = [0, 1]\n\twhile len(a) <= n:\n\t\ta.append(a[-2] + a[-1])\n\treturn a[n]", "score": 1.0, "codebleu": 0.14832826667569102, "crystalbleu": 0, "codebertscore": 0.81, "codescore": 0.24741655588150024, "surfaceSim": 0.4685960591133005, "abs_surfaceSim_minus_score": 0.5314039408866995, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_13_1_OP_1", "golden_code": "import sys\n\ndef main():\n\n    n,k = map(int,sys.stdin.readline().split())\n    courses = list(map(int,sys.stdin.readline().split()))\n    courses = [x-1 for x in courses] \n\n    visited = [False]*n\n    used = [False]*n\n\n    ans = []\n    t = []\n\n    for i in range(n):\n        temp = list(map(int,sys.stdin.readline().split()))\n        temp = [x-1 for x in temp] \n        t.append(temp[1:])\n        \n    for i in range(k):\n        c = courses[i]\n        if used[c]:\n            continue\n        \n        q = [c]        \n        visited[c]=True\n        while len(q)>0:\n            cur = q[-1]\n            if len(t[cur])!=0:\n                s = t[cur].pop()\n                if visited[s] and not used[s]:                    \n                    print(-1)\n                    return\n                if used[s]:\n                    continue                \n                q.append(s)\n                visited[s]=True\n            else:\n                ans.append(cur)\n                q.pop()\n                used[cur] = True\n\n    ans = [str(x+1) for x in ans] \n    print(len(ans))\n    print(\" \".join(ans))\n\nmain()", "generated_code": "import sys\nfrom collections import deque\n\ndef main():\n\n    num_courses, num_to_take = map(int, sys.stdin.readline().split())\n    course_list = list(map(int, sys.stdin.readline().split()))\n    course_list = [c - 1 for c in course_list]\n\n    visited_courses = [False] * num_courses\n    completed_courses = [False] * num_courses\n\n    result = []\n    prerequisites = []\n\n    for _ in range(num_courses):\n        temp = list(map(int, sys.stdin.readline().split()))\n        prerequisites.append(deque(x - 1 for x in temp[1:]))\n\n    for i in range(num_to_take):\n        current_course = course_list[i]\n        if completed_courses[current_course]:\n            continue\n\n        stack = [current_course]\n        visited_courses[current_course] = True\n        while stack:\n            current = stack[-1]\n            if prerequisites[current]:\n                prerequisite_course = prerequisites[current].pop()\n                if visited_courses[prerequisite_course] and not completed_courses[prerequisite_course]:\n                    print(-1)\n                    return\n                if completed_courses[prerequisite_course]:\n                    continue\n                stack.append(prerequisite_course)\n                visited_courses[prerequisite_course] = True\n            else:\n                result.append(current)\n                stack.pop()\n                completed_courses[current] = True\n\n    result = [str(x + 1) for x in result]\n    print(len(result))\n    print(\" \".join(result))\n\nmain()\n", "score": 1.0, "codebleu": 0.37313390068062485, "crystalbleu": 0.41, "codebertscore": 0.85, "codescore": 0.6813881993293762, "surfaceSim": 0.7636677963780767, "abs_surfaceSim_minus_score": 0.2363322036219233, "source": "local", "local_type": "OP"}
{"id": "MBPP_41_6", "golden_code": "def binomial_coeff(n, k): \r\n\tC = [[0 for j in range(k + 1)] \r\n\t\t\tfor i in range(n + 1)] \r\n\tfor i in range(0, n + 1): \r\n\t\tfor j in range(0, min(i, k) + 1): \r\n\t\t\tif (j == 0 or j == i): \r\n\t\t\t\tC[i][j] = 1\r\n\t\t\telse: \r\n\t\t\t\tC[i][j] = (C[i - 1][j - 1] \r\n\t\t\t\t\t\t\t+ C[i - 1][j]) \r\n\treturn C[n][k] \r\ndef lobb_num(n, m): \r\n\treturn (((2 * m + 1) *\r\n\t\tbinomial_coeff(2 * n, m + n)) \r\n\t\t\t\t\t/ (m + n + 1))", "generated_code": "def lobb_num(n,r): \n \n\tif ((n < r) or (r < n)): \n\t\treturn 0\n\tif n == 0 or r == 1: \n\t\t return 1 \n\tif r == 0: \n\t   return 1 \n\n\treturn (fact(n, (n - 1) / (n * r)))", "score": 0.4192, "codebleu": 0.1156886477844112, "crystalbleu": 0.03, "codebertscore": 0.77, "codescore": 0.2346908152103424, "surfaceSim": 0.5859106529209621, "abs_surfaceSim_minus_score": 0.1667106529209621, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_1123_28_MUT_13", "golden_code": "MOD = (10 ** 9) + 7\n\ndef pow_mod(x, n):\n    if n == 0:\n        return 1\n    elif n % 2 == 0:\n        return pow_mod((x ** 2) % MOD, n // 2) % MOD\n    else:\n        return (x * pow_mod((x ** 2) % MOD, n // 2)) % MOD\n\n(N, K) = map(int, input().split())\nans = 0\nrec = [0] * (K + 1)\nfor X in range(K, 0, -1):\n    rec[X] = pow_mod(K // X, N)\n    for i in range(2, (K // X) + 1):\n        rec[X] = (rec[X] - rec[i * X]) % MOD\n    ans = (ans + (X * rec[X])) % MOD\nprint(ans)", "generated_code": "MOD = (10 ** 9) + 7\n\ndef pow_mod(x, n):\n    if n == 0:\n        return 1\n    elif n % 2 == 0:\n        return pow_mod((x ** 2) % MOD, n // 2) % MOD\n    else:\n        return (x * pow_mod((x * 2) % MOD, n // 2)) % MOD\n\n(N, K) = map(int, input().split())\nans = 0\nrec = [0] * (K + 1)\nfor X in range(K, 0, -1):\n    rec[X] = pow_mod(K // X, N)\n    for i in range(2, (K // X) + 1):\n        rec[X] = (rec[X] - rec[i * X]) % MOD\n    ans = (ans + (X * rec[X])) % MOD\nprint(ans)", "score": 0.0582, "codebleu": 0.9876351671149788, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9937783479690552, "surfaceSim": 0.9989270386266094, "abs_surfaceSim_minus_score": 0.9407270386266093, "source": "local", "local_type": "MUT"}
{"id": "MBPP_33_6", "golden_code": "def count_Unset_Bits(n) :  \r\n    cnt = 0;  \r\n    for i in range(1,n + 1) : \r\n        temp = i;  \r\n        while (temp) :  \r\n            if (temp % 2 == 0) : \r\n                cnt += 1;  \r\n            temp = temp // 2;  \r\n    return cnt;  ", "generated_code": "def count_Unset_Bits(n) :  \n\tcount = 0\n\t\n\twhile n:\n\t\tcount += n & 1\n\t\tn >>= 1\n\t\n\treturn count", "score": 0.0507, "codebleu": 0.19554170760027317, "crystalbleu": 0, "codebertscore": 0.78, "codescore": 0.11230681836605072, "surfaceSim": 0.6593898428936792, "abs_surfaceSim_minus_score": 0.6086898428936792, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_p02537_s645565645_MUT_146", "golden_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "generated_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = __dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "score": 0.0482, "codebleu": 0.9860383920377368, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9819798469543457, "surfaceSim": 0.9984634296250768, "abs_surfaceSim_minus_score": 0.9502634296250768, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_PIE_extra_p02996_s348750359_OP_1", "golden_code": "n=int(eval(input()))\n\ntask=[] \n\nfor _ in range(n):\n\n    a,b=list(map(int,input().split()))\n\n    task.append((b, -a))\n\n\n\ntask.sort()\n\n\n\ntime=0\n\nflag=True\n\nfor i in task:\n\n    time-=i[1]\n\n    if time>i[0]:\n\n        flag=False\n\n        break\n\n\n\nif flag:\n\n    print(\"Yes\")\n\nelse:\n\n    print(\"No\")\n\n\n", "generated_code": "import sys\n\nfrom collections import defaultdict\n\nfrom operator import itemgetter\n\ninput = sys.stdin.readline\n\n\n\nN = int(eval(input()))\n\nd = defaultdict(int)\n\nfor _ in range(N):\n\n    a, b = list(map(int, input().split()))\n\n    d[b] += a\n\ntask = list(d.items())\n\ntask.sort()\n\n\n\nnow = 0\n\nans = \"Yes\"\n\nfor limit, time in task:\n\n    now += time\n\n    if now > limit:\n\n        ans = \"No\"\n\n        break\n\n\n\nprint(ans)\n", "score": 1.0, "codebleu": 0.2596254169959267, "crystalbleu": 0.27, "codebertscore": 0.8, "codescore": 0.9415544271469116, "surfaceSim": 0.5888367729831144, "abs_surfaceSim_minus_score": 0.41116322701688557, "source": "local", "local_type": "OP"}
{"id": "APPS_test-1983_74", "golden_code": "import sys\ninput = sys.stdin.readline\n\nt = int(input())\nfor _ in range(t):\n    input()\n    print(len(set(map(int, input().split()))))\n", "generated_code": "t = int(input())\n\nfor i in range(t):\n\tl = int(input().strip())\n\tarr = list(map(int, input().strip().split()))\n\ts = sorted(arr)\n\t\n\tans = 0\n\tfor j in range(len(arr)):\n\t\tif j == 0:\n\t\t\tans = 1\n\t\telse:\n\t\t\tif s[j] == s[j-1]:\n\t\t\t\tans += 1\n\t\t\telse:\n\t\t\t\tans = 2\n\tprint(ans)\n", "score": 0.5044, "codebleu": 0.2715948844060766, "crystalbleu": 0, "codebertscore": 0.77, "codescore": 0.36204370856285095, "surfaceSim": 0.4256064690026954, "abs_surfaceSim_minus_score": 0.07879353099730457, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-2028_32", "golden_code": "n = int(input())\nm = 2 * n + 1\nu = [[] for i in range(m)]\nv = [0] * m\ns = [0] * m\nd = 10 ** 9 + 7\ny = 1\n\nfor j in range(n):\n    a, b = map(int, input().split())\n    v[a] = b\n    if a != b:\n        s[b] += 1\n        u[b].append(a)\n\nfor b in range(m):\n    if not v[b]:\n        x = 0\n        p = [b]\n        while p:\n            x += 1\n            a = p.pop()\n            s[a] = -1\n            p += u[a]\n        y = (x * y) % d\n\nfor a in range(m):\n    if s[a] == 0:\n        b = v[a]\n        while s[b] == 1:\n            s[b] = -1\n            b = v[b]\n        s[b] -= 1\n\nfor a in range(m):\n    if s[a] == 1:\n        y = (2 * y) % d\n        while s[a]:\n            s[a] = 0\n            a = v[a]\n\nprint(y)", "generated_code": "p = 10**9 + 7\nn = int(input())\nfor _ in range(n):\n\ta,b = map(int,input().split())\n\tprint(((b - a + 1) * (b - a + 2)) % p)\n", "score": 0.0, "codebleu": 0.08298205123512765, "crystalbleu": 0.02, "codebertscore": 0.75, "codescore": 0.019754961133003235, "surfaceSim": 0.5517328903041211, "abs_surfaceSim_minus_score": 0.5517328903041211, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_MBPP_423_OP_1", "golden_code": "def get_maxgold(gold, m, n): \r\n    goldTable = [[0 for i in range(n)] \r\n                        for j in range(m)]   \r\n    for col in range(n-1, -1, -1): \r\n        for row in range(m):  \r\n            if (col == n-1): \r\n                right = 0\r\n            else: \r\n                right = goldTable[row][col+1] \r\n            if (row == 0 or col == n-1): \r\n                right_up = 0\r\n            else: \r\n                right_up = goldTable[row-1][col+1] \r\n            if (row == m-1 or col == n-1): \r\n                right_down = 0\r\n            else: \r\n                right_down = goldTable[row+1][col+1] \r\n            goldTable[row][col] = gold[row][col] + max(right, right_up, right_down) \r\n    res = goldTable[0][0] \r\n    for i in range(1, m): \r\n        res = max(res, goldTable[i][0])  \r\n    return res ", "generated_code": "def get_maxgold(matrix, rows, cols):\n    dp = [[0] * cols for _ in range(rows)]\n    for c in range(cols-1, -1, -1):\n        for r in range(rows):\n            right = dp[r][c+1] if c < cols-1 else 0\n            right_up = dp[r-1][c+1] if r > 0 and c < cols-1 else 0\n            right_down = dp[r+1][c+1] if r < rows-1 and c < cols-1 else 0\n            dp[r][c] = matrix[r][c] + max(right, right_up, right_down)\n    return max(dp[r][0] for r in range(rows))", "score": 1.0, "codebleu": 0.25894836938982746, "crystalbleu": 0.17, "codebertscore": 0.8, "codescore": 0.9857071042060852, "surfaceSim": 0.6871547992237648, "abs_surfaceSim_minus_score": 0.31284520077623523, "source": "local", "local_type": "OP"}
{"id": "MBPP_2_15", "golden_code": "def min_Num(arr,n):  \r\n    odd = 0\r\n    for i in range(n): \r\n        if (arr[i] % 2): \r\n            odd += 1 \r\n    if (odd % 2): \r\n        return 1\r\n    return 2", "generated_code": "def min_Num(arr,n):  \n\tres = 0\n\tfor i in range(1, n + 1):\n\t\tres += i\n\treturn res\n\n\n\n\n\n\n\n    \n\t\n    \n\n\t\nUSTT = -1", "score": 0.0556, "codebleu": 0.24056162007774318, "crystalbleu": 0, "codebertscore": 0.8, "codescore": 0.09030777215957642, "surfaceSim": 0.7267080745341614, "abs_surfaceSim_minus_score": 0.6711080745341614, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_358_2", "golden_code": "MAX = 3000 \r\ndef smartNumber(n): \r\n\tprimes = [0] * MAX \r\n\tresult = [] \r\n\tfor i in range(2, MAX): \r\n\t\tif (primes[i] == 0): \r\n\t\t\tprimes[i] = 1 \r\n\t\t\tj = i * 2 \r\n\t\t\twhile (j < MAX): \r\n\t\t\t\tprimes[j] -= 1 \r\n\t\t\t\tif ( (primes[j] + 3) == 0): \r\n\t\t\t\t\tresult.append(j) \r\n\t\t\t\tj = j + i \r\n\tresult.sort() \r\n\treturn result[n - 1] ", "generated_code": "MAX = 3000 \ndef smartNumber(n): \n\tif n > MAX:\n\t\treturn n\n\treturn max(n-i for i in range(MAX, 0, -1))\nduplicate = False", "score": 0.0, "codebleu": 0.1130462947390551, "crystalbleu": 0, "codebertscore": 0.74, "codescore": 0.11211574077606201, "surfaceSim": 0.4955214968152866, "abs_surfaceSim_minus_score": 0.4955214968152866, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_MBPP_453_MUT_32", "golden_code": "import os\n\nimport math\ndef sumofFactors(n):\n    if n % 2 != 0:\n        return 0\n    res = 1\n    for i in range(2, int(math.sqrt(n)) + 1):\n        count = 0\n        curr_sum = 1\n        curr_term = 1\n        while n % i == 0:\n            count = count + 1\n            n = n // i\n            if (i == 2 and count == 1):\n                curr_sum = 0\n            curr_term = curr_term * i\n            curr_sum = curr_sum + curr_term\n        res = res * curr_sum\n    if n >= 2:\n        res = res * (1 + n)\n    return res", "generated_code": "import os\n\nimport math\ndef sumofFactors(n):\n    if n % 2 != 0:\n        return 0\n    res = 1\n    for i in range(2, int(math.sqrt(n)) + 1):\n        count = 0\n        curr_sum = 1\n        curr_term = 1\n        while n % i == 0:\n            count = count + 1\n            n = n // i\n            if (i == 2 and count == 1):\n                curr_sum = 0\n            curr_term = curr_term * i\n            curr_sum = curr_sum + curr_term\n        res = res * curr_sum\n    if n <= 2:\n        res = res * (1 + n)\n    return res", "score": 0.3758, "codebleu": 0.9856633619349873, "crystalbleu": 0.95, "codebertscore": 1.0, "codescore": 0.9936209321022034, "surfaceSim": 0.9645463675929026, "abs_surfaceSim_minus_score": 0.5887463675929026, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-0402_56", "golden_code": "n, m = list(map(int, input().split()))\nt = 4 * 60 - m\no = 0\na = 5\notv = 0\nwhile o + a <= t and otv < n:\n    o += a\n    a += 5\n    otv += 1\nprint(otv)\n", "generated_code": "import sys\nn, k = map(int, sys.stdin.readline().split())\nif k * n < n:\n\tprint(k * n - n - 1)\nelse:\n\tprint((k * n - 1) // 2)\n", "score": 0.0116, "codebleu": 0.07331212903582068, "crystalbleu": 0, "codebertscore": 0.75, "codescore": 0.04444741830229759, "surfaceSim": 0.49666666666666665, "abs_surfaceSim_minus_score": 0.48506666666666665, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_4169_75_MUT_5", "golden_code": "import bisect, collections, copy, heapq, itertools, math, string, sys\ninput = lambda: (sys.stdin.readline().rstrip())\nsys.setrecursionlimit(10 ** 7)\nINF = float('inf')\ndef I():\n    return int(input())\ndef F():\n    return float(input())\ndef SS():\n    return input()\ndef LI():\n    return [int(x) for x in input().split()]\ndef LI_():\n    return [int(x) - 1 for x in input().split()]\ndef LF():\n    return [float(x) for x in input().split()]\ndef LSS():\n    return input().split()\ndef resolve():\n    (N, M) = LI()\n    AB = [LI() for _ in range(N)]\n    AB.sort()\n    ans = 0\n    for (a, b) in AB:\n        if M >= b:\n            M -= b\n            ans += a * belse:ans += a * Mbreak\n    print(ans)\ndef __starting_point():\n    resolve()\n\n__starting_point()", "generated_code": "import bisect, collections, copy, heapq, itertools, math, string, sys\ninput = lambda: (sys.stdin.readline().rstrip())\nsys.setrecursionlimit(10 ** 7)\nINF = float('inf')\ndef I():\n    return int(input())\ndef F():\n    return float(input())\ndef SS():\n    return input()\ndef LI():\n    return [int(x) for x in input().split()]\ndef LI_():\n    return [int(x) - 1 for x in input().split()]\ndef LF():\n    return [float(x) for x in input().split()]\ndef LSS():\n    return input().split()\ndef resolve():\n    (N, M) = LI()\n    AB = [LI() for _ in range(N)]\n    AB.sort()\n    ans = 0\n    for (a, b) in AB:\n        if M >= b:\n            M -= b\n            ans += a ** belse:ans += a * Mbreak\n    print(ans)\ndef __starting_point():\n    resolve()\n\n__starting_point()", "score": 0.0, "codebleu": 0.9880182320399841, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9938446283340454, "surfaceSim": 0.49933155080213903, "abs_surfaceSim_minus_score": 0.49933155080213903, "source": "local", "local_type": "MUT"}
{"id": "MBPP_73_48", "golden_code": "def get_noOfways(n):\r\n    if (n == 0):\r\n        return 0;\r\n    if (n == 1):\r\n        return 1; \r\n    return get_noOfways(n - 1) + get_noOfways(n - 2);", "generated_code": "def get_noOfways(n):    \n\tif (n < 2) : return False\n\tfor i in range(3, int(n**0.5)+1, 2):   \n\t\tif n % i == 0:\n\t\t\treturn False\n\treturn True", "score": 0.0, "codebleu": 0.24878848386212493, "crystalbleu": 0, "codebertscore": 0.81, "codescore": 0.17990991473197937, "surfaceSim": 0.6233333333333333, "abs_surfaceSim_minus_score": 0.6233333333333333, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_8_MUT_4", "golden_code": "import os\n\nfrom typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[(int, int)]:\n    sum_value = 0\n    prod_value = 1\n    \n    for n in numbers:\n        sum_value += n\n        prod_value *= n\n    return (sum_value, prod_value)", "generated_code": "import os\n\nfrom typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[(int, int)]:\n    sum_value = 0\n    prod_value = 1\n    \n    for n in numbers:\n        sum_value += n\n        prod_value **= n\n    return (sum_value, prod_value)", "score": 0.0, "codebleu": 0.9587119217988691, "crystalbleu": 0, "codebertscore": 1.0, "codescore": 0.9936204552650452, "surfaceSim": 0.9503648233486943, "abs_surfaceSim_minus_score": 0.9503648233486943, "source": "local", "local_type": "MUT"}
{"id": "MBPP_70_56", "golden_code": "def is_abundant(n):\r\n    fctrsum = sum([fctr for fctr in range(1, n) if n % fctr == 0])\r\n    return fctrsum > n", "generated_code": "def is_abundant(n):\n\treturn n*n==2\nUSTABundant = True", "score": 0.6539, "codebleu": 0.13098332558936238, "crystalbleu": 0, "codebertscore": 0.78, "codescore": 0.8849872946739197, "surfaceSim": 0.594357515410147, "abs_surfaceSim_minus_score": 0.059542484589853006, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_extra_p03814_s932284243_OP_1", "golden_code": "# Problem https://atcoder.jp/contests/abc053/tasks/abc053_b\n\n# Python 1st Try\n\nimport copy\n\n\n\n\n\nclass Problem:\n\n    def __init__(self, stringdata):\n\n        self.stringdata = stringdata\n\n\n\n    def solver(self):\n\n        strcont = copy.copy(self.stringdata)\n\n        result = 0\n\n        rightposition = 0\n\n        leftposition = len(strcont)\n\n        j = 0\n\n        while True:\n\n            if strcont[j] == 'A':\n\n                rightposition = j\n\n                break\n\n            else:\n\n                j = j + 1\n\n        j = leftposition - 1\n\n        while True:\n\n            if strcont[j] == 'Z':\n\n                leftposition = j\n\n                break\n\n            else:\n\n                j = j - 1\n\n\n\n        result = leftposition - rightposition + 1\n\n        return result\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    s = eval(input())\n\n    print((\"{}\".format(Problem(s).solver())))\n", "generated_code": "# Problem https://atcoder.jp/contests/abc053/tasks/abc053_b\n\n# Python 2nd Try\n\n\n\n\n\ndef solver(string):\n\n    result = 200000\n\n    aposi = 0\n\n    zposi = len(string)\n\n    for j in range(0, len(string), 1):\n\n        if string[j] == 'A':\n\n            aposi = j\n\n            break\n\n    for j in range(len(string)-1, -1, -1):\n\n        if string[j] == 'Z':\n\n            zposi = j\n\n            break\n\n    result = zposi - aposi + 1\n\n    return result\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    s = eval(input())\n\n    print(('{}'.format(solver(s))))\n", "score": 1.0, "codebleu": 0.2960028526362116, "crystalbleu": 0.28, "codebertscore": 0.85, "codescore": 0.02546420693397522, "surfaceSim": 0.737181239504823, "abs_surfaceSim_minus_score": 0.26281876049517705, "source": "local", "local_type": "OP"}
{"id": "LOCAL_MBPP_463_OP_1", "golden_code": "def max_subarray_product(arr):\r\n\tn = len(arr)\r\n\tmax_ending_here = 1\r\n\tmin_ending_here = 1\r\n\tmax_so_far = 0\r\n\tflag = 0\r\n\tfor i in range(0, n):\r\n\t\tif arr[i] > 0:\r\n\t\t\tmax_ending_here = max_ending_here * arr[i]\r\n\t\t\tmin_ending_here = min (min_ending_here * arr[i], 1)\r\n\t\t\tflag = 1\r\n\t\telif arr[i] == 0:\r\n\t\t\tmax_ending_here = 1\r\n\t\t\tmin_ending_here = 1\r\n\t\telse:\r\n\t\t\ttemp = max_ending_here\r\n\t\t\tmax_ending_here = max (min_ending_here * arr[i], 1)\r\n\t\t\tmin_ending_here = temp * arr[i]\r\n\t\tif (max_so_far < max_ending_here):\r\n\t\t\tmax_so_far = max_ending_here\r\n\tif flag == 0 and max_so_far == 0:\r\n\t\treturn 0\r\n\treturn max_so_far", "generated_code": "def max_subarray_product(nums):\n    length = len(nums)\n    current_max = 1\n    current_min = 1\n    overall_max = 0\n    has_positive = False\n    for num in nums:\n        if num > 0:\n            current_max *= num\n            current_min = min(current_min * num, 1)\n            has_positive = True\n        elif num == 0:\n            current_max = 1\n            current_min = 1\n        else:\n            temp = current_max\n            current_max = max(current_min * num, 1)\n            current_min = temp * num\n        overall_max = max(overall_max, current_max)\n    return overall_max if has_positive or overall_max != 0 else 0", "score": 1.0, "codebleu": 0.26866617022845374, "crystalbleu": 0.11, "codebertscore": 0.78, "codescore": 0.9939363598823547, "surfaceSim": 0.5930659093598392, "abs_surfaceSim_minus_score": 0.40693409064016084, "source": "local", "local_type": "OP"}
{"id": "LOCAL_MBPP_493_MUT_24", "golden_code": "import os\n\nimport math\ndef calculate_polygons(startx, starty, endx, endy, radius):\n    sl = (2 * radius) * math.tan(math.pi / 6)\n    p = sl * 0.5\n    b = sl * math.cos(math.radians(30))\n    w = b * 2\n    h = 2 * sl\n    startx = startx - w\n    starty = starty - h\n    endx = endx + w\n    endy = endy + h\n    origx = startx\n    origy = starty\n    xoffset = b\n    yoffset = 3 * p\n    polygons = []\n    row = 1\n    counter = 0\n    while starty < endy:\n        if row % 2 == 0:\n            startx = origx + xoffset\n        else:\n            startx = origx\n        while startx < endx:\n            p1x = startx\n            p1y = starty + p\n            p2x = startx\n            p2y = starty + (3 * p)\n            p3x = startx + b\n            p3y = starty + h\n            p4x = startx + w\n            p4y = starty + (3 * p)\n            p5x = startx + w\n            p5y = starty + p\n            p6x = startx + b\n            p6y = starty\n            poly = [\\\n                (p1x, p1y), \\\n                (p2x, p2y), \\\n                (p3x, p3y), \\\n                (p4x, p4y), \\\n                (p5x, p5y), \\\n                (p6x, p6y), \\\n                (p1x, p1y)]\n            polygons.append(poly)\n            counter += 1\n            startx += w\n        starty += yoffset\n        row += 1\n    return polygons", "generated_code": "import os\n\nimport math\ndef calculate_polygons(startx, starty, endx, endy, radius):\n    sl = (2 * radius) * math.tan(math.pi / 6)\n    p = sl * 0.5\n    b = sl * math.cos(math.radians(30))\n    w = b * 2\n    h = 2 * sl\n    startx = startx - w\n    starty = starty - h\n    endx = endx + w\n    endy = endy - h\n    origx = startx\n    origy = starty\n    xoffset = b\n    yoffset = 3 * p\n    polygons = []\n    row = 1\n    counter = 0\n    while starty < endy:\n        if row % 2 == 0:\n            startx = origx + xoffset\n        else:\n            startx = origx\n        while startx < endx:\n            p1x = startx\n            p1y = starty + p\n            p2x = startx\n            p2y = starty + (3 * p)\n            p3x = startx + b\n            p3y = starty + h\n            p4x = startx + w\n            p4y = starty + (3 * p)\n            p5x = startx + w\n            p5y = starty + p\n            p6x = startx + b\n            p6y = starty\n            poly = [\\\n                (p1x, p1y), \\\n                (p2x, p2y), \\\n                (p3x, p3y), \\\n                (p4x, p4y), \\\n                (p5x, p5y), \\\n                (p6x, p6y), \\\n                (p1x, p1y)]\n            polygons.append(poly)\n            counter += 1\n            startx += w\n        starty += yoffset\n        row += 1\n    return polygons", "score": 0.0, "codebleu": 0.9937480014850033, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9937119483947754, "surfaceSim": 0.9996162701458173, "abs_surfaceSim_minus_score": 0.9996162701458173, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_HE_78_OP_1", "golden_code": "def hex_key(num):\n    primes = ('2', '3', '5', '7', 'B', 'D')\n    total = 0\n    for i in range(0, len(num)):\n        if num[i] in primes:\n            total += 1\n    return total", "generated_code": "def hex_key(value):\n    hex_primes = {'2', '3', '5', '7', 'B', 'D'}\n    count = sum(1 for char in value if char in hex_primes)\n    return count\n", "score": 1.0, "codebleu": 0.2867844233646022, "crystalbleu": 0, "codebertscore": 0.87, "codescore": 0.9934415817260742, "surfaceSim": 0.613117170228445, "abs_surfaceSim_minus_score": 0.38688282977155497, "source": "local", "local_type": "OP"}
{"id": "MBPP_43_92", "golden_code": "def is_Two_Alter(s):  \r\n    for i in range (len( s) - 2) : \r\n        if (s[i] != s[i + 2]) : \r\n            return False\r\n    if (s[0] == s[1]): \r\n        return False\r\n    return True", "generated_code": "def is_Two_Alter(charList):\n\treturn True if not charList or len(charList) > 2 else False", "score": 0.0754, "codebleu": 0.09880829901330837, "crystalbleu": 0, "codebertscore": 0.77, "codescore": 0.03180575743317604, "surfaceSim": 0.48465741908364857, "abs_surfaceSim_minus_score": 0.40925741908364854, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_extra_p03416_s606562684_OP_1", "golden_code": "a,b=list(map(int,input().split()))\n\nans=0\n\nfor i in range(b+1)[a:]:\n\n  if len(str(i))%2==0:\n\n    p=list(str(i))[:len(str(i))//2]\n\n    q=list(reversed(list(str(i))[len(str(i))//2:]))\n\n    if p==q:\n\n      ans+=1\n\n  else:\n\n    s=list(str(i))[:len(str(i))//2+1]\n\n    d=list(reversed(list(str(i))[len(str(i))//2:]))\n\n    if s==d:\n\n      ans += 1\n\nprint(ans)", "generated_code": "a,s=list(map(int,input().split()))\n\nad=0\n\nfor i in range(a,s+1):\n\n  if str(i)==str(i)[::-1]:ad+=1\n\nprint(ad)", "score": 1.0, "codebleu": 0.19909035027686792, "crystalbleu": 0.07, "codebertscore": 0.82, "codescore": 0.776262640953064, "surfaceSim": 0.6246912055335969, "abs_surfaceSim_minus_score": 0.3753087944664031, "source": "local", "local_type": "OP"}
{"id": "LOCAL_PIE_extra_p03796_s669812244_OP_1", "golden_code": "import math\n\nN = int(eval(input()))\n\nprint((math.factorial(N)%(10**9+7)))", "generated_code": "ans=1\n\nn=int(eval(input()))\n\nfor i in range(1,n+1):\n\n    ans*=i\n\n    ans=ans%(10**9+7)\n\nprint(ans)", "score": 1.0, "codebleu": 0.2435064935064935, "crystalbleu": 0, "codebertscore": 0.83, "codescore": 0.9890196919441223, "surfaceSim": 0.5884353741496599, "abs_surfaceSim_minus_score": 0.41156462585034015, "source": "local", "local_type": "OP"}
{"id": "APPS_test-3760_1", "golden_code": "from fractions import gcd\nn, m, x, y, a, b = map(int, input().split())\nr = gcd(a, b)\na, b = a // r, b // r\nr = min(n // a, m // b)\na, b = a * r, b * r\ncx, cy = (a + 1) // 2, (b + 1) // 2\ndx, dy = min(n - a, max(cx, x) - cx), min(m - b, max(cy, y) - cy)\nprint(dx, dy, a + dx, b + dy)", "generated_code": "from math import sqrt\n\ndef get_best(a, b, x, y):\n\tif x == y:\n\t\treturn x\n\telif x > y:\n\t\tb, x = y, x\n\telse:\n\t\tb1, y = y, x + b\n\ts1 = x + y\n\ts2 = x - y\n\ts3 = y - x\n\tat = (a * s1 + b * s2) ** 0.5\n\tat = at / 2.0\n\tif at < s3:\n\t\treturn get_best(at, b, x + a, y)\n\telse:  # at > s3\n\t\treturn get(x, y + a, s1, s2)\n\ndef get(x,y,a,b):\n\tif y == 0:\n\t\treturn b\n\telse: y -= a\n", "score": 0.0, "codebleu": 0.1280274726463075, "crystalbleu": 0.05, "codebertscore": 0.76, "codescore": 0.018448997288942337, "surfaceSim": 0.4594348659003832, "abs_surfaceSim_minus_score": 0.4594348659003832, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-2708_76", "golden_code": "try:\n    n , k = list(map(int,input().split()))\n    \n    for i in range(k):\n        if n % 10 == 0:\n            n = n/10\n        else:\n            n -= 1\n    \n    print(int(n))\n    \nexcept:\n    pass", "generated_code": "# cook your dish here\nn,k=map(int,input().split())\nwhile(k>0):\n\tif(n%10==0):\n\t\tn=n//10\n\t\tk=k-1\n\telse:\n\t\tn= n%10 + n\n\t\tk= k - 1\n\tprint(n,k)\n", "score": 0.0, "codebleu": 0.20801726276938518, "crystalbleu": 0, "codebertscore": 0.85, "codescore": 0.2491312474012375, "surfaceSim": 0.6637529137529138, "abs_surfaceSim_minus_score": 0.6637529137529138, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_14_7", "golden_code": "def sum_even_odd(list1):\r\n    first_even = next((el for el in list1 if el%2==0),-1)\r\n    first_odd = next((el for el in list1 if el%2!=0),-1)\r\n    return (first_even+first_odd)", "generated_code": "def sum_even_odd(list1):\n\treturn sum([x for x in list1 if x%2 ==0])", "score": 0.0376, "codebleu": 0.14724481387305893, "crystalbleu": 0, "codebertscore": 0.87, "codescore": 0.030760638415813446, "surfaceSim": 0.5710227272727273, "abs_surfaceSim_minus_score": 0.5334227272727273, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-1772_58", "golden_code": "n = int(input())\na = list(map(int, input().split()))\n\nq = [0] * 2\n\nfor i in range(n):\n    q[a[i] % 2] += 1\n\nx = min(q[0], q[1])\n\nq[0] -= x\nq[1] -= x\n\nprint(x + q[1] // 3)\n", "generated_code": "from collections import deque\n\ndef main():\n\tn = int(input())\n\tnums = deque(map(int, input().split()))\n\tgood = 0\n\tfor i in range(n):\n\t\tif nums[0] >= i:\n\t\t\tgood += 1\n\t\tnums.popleft()\n\tprint(good)\n\ndef __starting_point():\n\tmain()\n__starting_point()\n", "score": 0.0042, "codebleu": 0.2731411859951979, "crystalbleu": 0, "codebertscore": 0.77, "codescore": 0.1743612289428711, "surfaceSim": 0.48283649503161696, "abs_surfaceSim_minus_score": 0.478636495031617, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_34_95", "golden_code": "def even_num(x):\r\n  if x%2==0:\r\n     return True\r\n  else:\r\n    return False", "generated_code": "def even_num(x): return x&(x-1) == 0", "score": 0.4459, "codebleu": 0.32018485615426584, "crystalbleu": 0, "codebertscore": 0.81, "codescore": 0.5300384759902954, "surfaceSim": 0.6466666666666667, "abs_surfaceSim_minus_score": 0.2007666666666667, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_411_3", "golden_code": "def get_max_sum (n):\r\n\tres = list()\r\n\tres.append(0)\r\n\tres.append(1)\r\n\ti = 2\r\n\twhile i<n + 1:\r\n\t\tres.append(max(i, (res[int(i / 2)] \r\n\t\t\t\t\t\t+ res[int(i / 3)] +\r\n\t\t\t\t\t\t\tres[int(i / 4)]\r\n\t\t\t\t\t\t+ res[int(i / 5)])))\r\n\t\ti = i + 1\r\n\treturn res[n]", "generated_code": "def get_max_sum (n):\n\treturn (n * n) - (n ** 2)", "score": 0.0, "codebleu": 0.06931006680549898, "crystalbleu": 0, "codebertscore": 0.72, "codescore": 0.06087128072977066, "surfaceSim": 0.39252092050209203, "abs_surfaceSim_minus_score": 0.39252092050209203, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-1534_24", "golden_code": "from sys import stdin, stdout\n\ns = stdin.readline().rstrip()\nn = len(s)\naCount=0\nbCount=0\naList=[0]\nbList=[0]\nfor i in range(n):\n    if s[i]=='a':\n        aCount+=1\n        aList.append(aCount)\n        bList.append(bCount)\n    else:\n        bCount+=1\n        aList.append(aCount)\n        bList.append(bCount)\n\nbestScore = 0\nfor i in range(n+1):#start\n    for j in range(i,n+1):#end\n        score=0\n        score+=aList[i]\n        score+=bList[j]-bList[i]\n        score+=aCount-aList[j]\n        if score>bestScore:\n            bestScore=score\n\nprint(bestScore)\n", "generated_code": "s = input()\n\nif len(s) > 5:\n\tprint(5)\nelse:\n\tm = 0\n\tfor i in range(len(s)):\n\t\tif s[i] == 'a':\n\t\t\tm = max(m, i + 1)\n\t\t\t\n\tprint(m)\n", "score": 0.22, "codebleu": 0.16692086876204804, "crystalbleu": 0.06, "codebertscore": 0.73, "codescore": 0.06297796219587326, "surfaceSim": 0.5588509316770186, "abs_surfaceSim_minus_score": 0.33885093167701863, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-1309_73", "golden_code": "n = int(input())\na = list(map(int, input().split()))\n\na.sort()\ncap = []\nres = []\nfor i in range(0, 2*n - 1, 2):\n    for j in range(i+1, 2*n, 2):\n        f = 0\n        first = 1\n        cap = []\n        for k in range(2*n):\n            if k == i or k == j:\n                continue\n            if first:\n                f = a[k]\n                first = 0\n            else:\n                first = 1\n                cap.append(abs(a[k] - f))\n        result = sum(cap)\n        res.append(result)\n\nprint(min(res))\n\n\n", "generated_code": "def main():\n\tn = int(input())\n\tw = list(map(int, input().split()))\n\tans = 0\n\tw.sort()\n\tfor i in range(n):\n\t\tans += min(w[i] + w[i + 1], w[i])\n\tprint(ans)\n\n\ndef __starting_point():\n\tmain()\n\n__starting_point()\n", "score": 0.0, "codebleu": 0.18515939511937304, "crystalbleu": 0.16, "codebertscore": 0.74, "codescore": 0.1140327900648117, "surfaceSim": 0.5788010817307692, "abs_surfaceSim_minus_score": 0.5788010817307692, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_128_MUT_5", "golden_code": "import os\n\ndef prod_signs(arr):\n    if not arr:\n        return None\n    prod = 0 if 0 in arr else (-1) ** len(list(filter((lambda x: (x < 0)), arr)))\n    return prod * sum([abs(i) for i in arr])", "generated_code": "import os\n\ndef prod_signs(arr):\n    if not arr:\n        return None\n    prod = 0 if 0 in arr else (-1) ** len(list(filter((lambda x: (x < 0)), arr)))\n    return prod // sum([abs(i) for i in arr])", "score": 0.0489, "codebleu": 0.9602896391728395, "crystalbleu": 0, "codebertscore": 0.99, "codescore": 0.6537255048751831, "surfaceSim": 0.9591575091575092, "abs_surfaceSim_minus_score": 0.9102575091575091, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_HE_0_OP_1", "golden_code": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                distance = abs(elem - elem2)\n                if distance < threshold:\n                    return True\n\n    return False", "generated_code": "from typing import List\n\ndef has_close_elements(values: List[float], gap: float) -> bool:\n    sorted_values = sorted(values)\n    for i in range(len(sorted_values) - 1):\n        if abs(sorted_values[i] - sorted_values[i + 1]) < gap:\n            return True\n    return False", "score": 1.0, "codebleu": 0.37799310802685243, "crystalbleu": 0, "codebertscore": 0.82, "codescore": 0.9900493621826172, "surfaceSim": 0.7813395415472779, "abs_surfaceSim_minus_score": 0.21866045845272208, "source": "local", "local_type": "OP"}
{"id": "MBPP_11_15", "golden_code": "def lcm(x, y):\r\n   if x > y:\r\n       z = x\r\n   else:\r\n       z = y\r\n   while(True):\r\n       if((z % x == 0) and (z % y == 0)):\r\n           lcm = z\r\n           break\r\n       z += 1\r\n   return lcm", "generated_code": "def lcm(_x, y) :\n\n\t\treturn _x\n\n\"\"\"def gcd(_y, z) as x o g i i, m, n z j\"\"\"\n\n__author = 'Pavel Mavrin'", "score": 0.3659, "codebleu": 0.06138113957551469, "crystalbleu": 0, "codebertscore": 0.72, "codescore": 0.06427516788244247, "surfaceSim": 0.5137830569251457, "abs_surfaceSim_minus_score": 0.1478830569251457, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-3714_34", "golden_code": "from math import gcd as __gcd\nn=int(input())\na=list([int(s)-1 for s in input().split()])\nseen=[0]*n\nans=1\nlcm=1\nfor i in range(n):\n        if not seen[i]:\n                j=i\n                leng=0\n                while not seen[j]:\n                        seen[j]=1\n                        leng+=1\n                        j=a[j]\n                if i==j:\n                        if leng%2==0:\n                                leng//=2\n                        lcm = lcm // __gcd(lcm,leng) * leng\n                else:\n                        ans=-1\n                        break\nif ans==-1:\n        print(-1)\nelse:\n        print(lcm)\n", "generated_code": "n=int(input())\nl=list(map(int,input().split()))\nx=0\nfor i in range(n):\n\tif l[i]==x:\n\t\tx=l[i]\n\t\tcontinue\n\tx^=l[i];\nif x==0:\n\tprint(-1)\nelse:\n\tprint(1)\n", "score": 0.0608, "codebleu": 0.17763495314495648, "crystalbleu": 0.15, "codebertscore": 0.75, "codescore": 0.21131040155887604, "surfaceSim": 0.6112248696947133, "abs_surfaceSim_minus_score": 0.5504248696947134, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_4722_12_MUT_8", "golden_code": "(a, b) = map(int, input().split())\nif (a % 3 == 0 or b % 3 == 0 or (a + b) % 3 == 0):\n    print('Possible')\nelse:\n    print('Impossible')", "generated_code": "(a, b) = map(int, input().split())\nif (a % 3 == 0 and b % 3 == 0 and (a + b) % 3 == 0):\n    print('Possible')\nelse:\n    print('Impossible')", "score": 0.4335, "codebleu": 0.8905860526291517, "crystalbleu": 0, "codebertscore": 0.98, "codescore": 0.6376758813858032, "surfaceSim": 0.9257856872396819, "abs_surfaceSim_minus_score": 0.4922856872396819, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-2144_70", "golden_code": "primes=[True]*1000001\nprimes[0]=False\nprimes[1]=False\nfor i in range(2, 100001):\n    if primes[i]:\n        for j in range(i*2, 100001, i):\n            primes[j]=False\npL=[]\nfor i in range(2, 100001):\n    if primes[i]:pL.append(i)\ndef fact(n):\n    L=[]\n    for i in pL:\n        if n%i==0:\n            while n%i==0:\n                L.append(i)\n                n//=i\n    if n!=1:L.append(n)\n    return L\ndef gcd(a,b):\n    while b:\n        a,b=b,a%b\n    return a\nfor i in ' '*int(input()):\n    a,m=map(int,input().split())\n    g=gcd(a,m)\n    aa=a//g\n    mm=m//g\n    L=fact(mm)\n    M=[]\n    for i in L:\n        if i not in M:M.append(i)\n    for i in M:\n        mm*=(i-1)\n        mm//=i\n    print(mm)", "generated_code": "import math\ndef solve():\n\ta, m = map(int, input().split())\n\tif a == m:\n\t\tprint(1)\n\telse:\n\t\tl = set()\n\t\ttemp = m\n\t\tfor i in range(1, int(math.sqrt(m))+1):\n\t\t\tif temp % i == 0:\n\t\t\t\tif i == temp // i:\n\t\t\t\t\tl.add(i)\n\t\t\t\telse:\n\t\t\t\t\tl.add(i) | l.add(temp // i)\n\t\tans = len(l)\n\t\tprint(ans)\n\nt = int(input())\nfor _ in range(t):\n\tsolve()\n", "score": 0.0, "codebleu": 0.12715279433773835, "crystalbleu": 0.08, "codebertscore": 0.74, "codescore": 0.19884362816810608, "surfaceSim": 0.5171639260891676, "abs_surfaceSim_minus_score": 0.5171639260891676, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-2100_39", "golden_code": "I=lambda:map(int,input().split())\na=[0,0]\nb=[0,0]\nfor _ in'0'*next(I()):c,d=I();a[c]+=1;b[d]+=1\nprint(min(a)+min(b))", "generated_code": "from sys import stdin\nn=int(stdin.readline())\nd={}\nflag=0\nfor i in range(n):\n\tl,r=map(int,stdin.readinput().split())\n\tif (l,r) in d:\n\t\td[(l,r)]=1\n\telse:\n\t\td.setdefault((l,r),1)\n\t\td[l]+=1\n\t\td[r]+=1\nans=0\nfor k,v in list(d.items()):\n\tv=v-1\n\tans+=(min(v,0))\n\tif v>0:\n\t\tans+=2*(v)\nprint(ans)\n", "score": 0.0, "codebleu": 0.1903075255132567, "crystalbleu": 0.06, "codebertscore": 0.75, "codescore": 0.18508963286876678, "surfaceSim": 0.46502976190476186, "abs_surfaceSim_minus_score": 0.46502976190476186, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_28_45", "golden_code": "def is_Word_Present(sentence,word): \r\n    s = sentence.split(\" \") \r\n    for i in s:  \r\n        if (i == word): \r\n            return True\r\n    return False", "generated_code": "def is_Word_Present(word, original_word):\n\treturn word == original_word", "score": 0.9329, "codebleu": 0.13384520065731348, "crystalbleu": 0, "codebertscore": 0.79, "codescore": 0.9477239847183228, "surfaceSim": 0.583198051948052, "abs_surfaceSim_minus_score": 0.349701948051948, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_149_MUT_5", "golden_code": "import os\n\ndef sorted_list_sum(lst):\n    lst.sort()\n    new_lst = []\n    for i in lst:\n        if len(i) % 2 == 0:\n            new_lst.append(i)\n    return sorted(new_lst, key=len)", "generated_code": "import os\n\ndef sorted_list_sum(lst):\n    lst.sort()\n    new_lst = []\n    for i in lst:\n        if len(i) % 2 == 0:\n            new_lst.append(i)\n        break\n    return sorted(new_lst, key=len)", "score": 0.2133, "codebleu": 0.9070151524546668, "crystalbleu": 0, "codebertscore": 0.99, "codescore": 0.9936862587928772, "surfaceSim": 0.9637027491408935, "abs_surfaceSim_minus_score": 0.7504027491408936, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_MBPP_493_MUT_55", "golden_code": "import os\n\nimport math\ndef calculate_polygons(startx, starty, endx, endy, radius):\n    sl = (2 * radius) * math.tan(math.pi / 6)\n    p = sl * 0.5\n    b = sl * math.cos(math.radians(30))\n    w = b * 2\n    h = 2 * sl\n    startx = startx - w\n    starty = starty - h\n    endx = endx + w\n    endy = endy + h\n    origx = startx\n    origy = starty\n    xoffset = b\n    yoffset = 3 * p\n    polygons = []\n    row = 1\n    counter = 0\n    while starty < endy:\n        if row % 2 == 0:\n            startx = origx + xoffset\n        else:\n            startx = origx\n        while startx < endx:\n            p1x = startx\n            p1y = starty + p\n            p2x = startx\n            p2y = starty + (3 * p)\n            p3x = startx + b\n            p3y = starty + h\n            p4x = startx + w\n            p4y = starty + (3 * p)\n            p5x = startx + w\n            p5y = starty + p\n            p6x = startx + b\n            p6y = starty\n            poly = [\\\n                (p1x, p1y), \\\n                (p2x, p2y), \\\n                (p3x, p3y), \\\n                (p4x, p4y), \\\n                (p5x, p5y), \\\n                (p6x, p6y), \\\n                (p1x, p1y)]\n            polygons.append(poly)\n            counter += 1\n            startx += w\n        starty += yoffset\n        row += 1\n    return polygons", "generated_code": "import os\n\nimport math\ndef calculate_polygons(startx, starty, endx, endy, radius):\n    sl = (2 * radius) * math.tan(math.pi / 6)\n    p = sl * 0.5\n    b = sl * math.cos(math.radians(30))\n    w = b * 2\n    h = 2 * sl\n    startx = startx - w\n    starty = starty - h\n    endx = endx + w\n    endy = endy + h\n    origx = startx\n    origy = starty\n    xoffset = b\n    yoffset = 3 * p\n    polygons = []\n    row = 1\n    counter = 0\n    while starty < endy:\n        if row % 2 == 0:\n            startx = origx + xoffset\n        else:\n            startx = origx\n        while startx < endx:\n            p1x = startx\n            p1y = starty + p\n            p2x = startx\n            p2y = starty + (3 * p)\n            p3x = startx + b\n            p3y = starty + h\n            p4x = startx + w\n            p4y = starty + (3 * p)\n            p5x = startx + w\n            p5y = starty + p\n            p6x = startx + b\n            p6y = starty\n            poly = [\\\n                (p1x, p1y), \\\n                (p2x, p2y), \\\n                (p3x, p3y), \\\n                (p4x, p4y), \\\n                (p5x, p5y), \\\n                (p6x, p6y), \\\n                (p1x, p1y)]\n            polygons.append(poly)\n            counter += 1\n            startx += w\n            break\n        starty += yoffset\n        row += 1\n    return polygons", "score": 0.0, "codebleu": 0.9825679125331229, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9937105178833008, "surfaceSim": 0.9810623265203129, "abs_surfaceSim_minus_score": 0.9810623265203129, "source": "local", "local_type": "MUT"}
{"id": "MBPP_542_2", "golden_code": "def move_last(num_list):\r\n    a = [num_list[0] for i in range(num_list.count(num_list[0]))]\r\n    x = [ i for i in num_list if i != num_list[0]]\r\n    x.extend(a)\r\n    return (x)", "generated_code": "def move_last(arr):\n\tL = []\n\tL.append(len(arr))\n\treturn L", "score": 0.0261, "codebleu": 0.06492067775830822, "crystalbleu": 0, "codebertscore": 0.74, "codescore": 0.019846957176923752, "surfaceSim": 0.5073863636363636, "abs_surfaceSim_minus_score": 0.48128636363636357, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_43_72", "golden_code": "def is_Two_Alter(s):  \r\n    for i in range (len( s) - 2) : \r\n        if (s[i] != s[i + 2]) : \r\n            return False\r\n    if (s[0] == s[1]): \r\n        return False\r\n    return True", "generated_code": "def is_Two_Alter(s):\n\treturn s == \"3\" or s[1] == \"2?\" or s == s[0]", "score": 0.8465, "codebleu": 0.1396368036283857, "crystalbleu": 0, "codebertscore": 0.78, "codescore": 0.9671576619148254, "surfaceSim": 0.5678092399403875, "abs_surfaceSim_minus_score": 0.2786907600596126, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_extra_p02801_s439687684_OP_1", "golden_code": "from string import ascii_lowercase as lower\n\nprint((lower[lower.find(eval(input()))+1]))", "generated_code": "print((chr(ord(eval(input()))+1)))", "score": 1.0, "codebleu": 0.3194444444444444, "crystalbleu": 0, "codebertscore": 0.8, "codescore": 0.8047193884849548, "surfaceSim": 0.5122377622377623, "abs_surfaceSim_minus_score": 0.4877622377622377, "source": "local", "local_type": "OP"}
{"id": "LOCAL_PIE_p02537_s767194684_MUT_72", "golden_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "generated_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if not (v is None):\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "score": 0.0, "codebleu": 0.9881783380372205, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.987784743309021, "surfaceSim": 0.9878824121868311, "abs_surfaceSim_minus_score": 0.9878824121868311, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_MBPP_1_OP_1", "golden_code": "R = 3\r\nC = 3\r\ndef min_cost(cost, m, n): \r\n\ttc = [[0 for x in range(C)] for x in range(R)] \r\n\ttc[0][0] = cost[0][0] \r\n\tfor i in range(1, m+1): \r\n\t\ttc[i][0] = tc[i-1][0] + cost[i][0] \r\n\tfor j in range(1, n+1): \r\n\t\ttc[0][j] = tc[0][j-1] + cost[0][j] \r\n\tfor i in range(1, m+1): \r\n\t\tfor j in range(1, n+1): \r\n\t\t\ttc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j] \r\n\treturn tc[m][n]", "generated_code": "def min_cost(expense, rows, cols):\n    total_cost = expense[0][:]\n    for j in range(1, cols + 1):\n        total_cost[j] += total_cost[j - 1]\n    for i in range(1, rows + 1):\n        total_cost[0] += expense[i][0]\n        for j in range(1, cols + 1):\n            total_cost[j] = min(total_cost[j - 1], total_cost[j], total_cost[j - 1] + expense[i][j])\n    return total_cost[cols]", "score": 0.9801, "codebleu": 0.2235923687250566, "crystalbleu": 0.14, "codebertscore": 0.83, "codescore": 0.13420483469963074, "surfaceSim": 0.6617951528437462, "abs_surfaceSim_minus_score": 0.31830484715625373, "source": "local", "local_type": "OP"}
{"id": "MBPP_34_127", "golden_code": "def even_num(x):\r\n  if x%2==0:\r\n     return True\r\n  else:\r\n    return False", "generated_code": "def even_num(x):\n\tif x%2==0:\n\t\treturn True\n\telse:\n\t\t0\n\treturn False\nss = []\nfor i in range(100000):\n\tss.append(i*2)\nprint(ss)", "score": 1.0, "codebleu": 0.6611443117627975, "crystalbleu": 0, "codebertscore": 0.84, "codescore": 0.9935964345932007, "surfaceSim": 0.5935238095238096, "abs_surfaceSim_minus_score": 0.40647619047619044, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_MBPP_819_OP_1", "golden_code": "def count_duplic(lists):\r\n    element = []\r\n    frequency = []\r\n    if not lists:\r\n        return element\r\n    running_count = 1\r\n    for i in range(len(lists)-1):\r\n        if lists[i] == lists[i+1]:\r\n            running_count += 1\r\n        else:\r\n            frequency.append(running_count)\r\n            element.append(lists[i])\r\n            running_count = 1\r\n    frequency.append(running_count)\r\n    element.append(lists[i+1])\r\n    return element,frequency\r\n", "generated_code": "def count_duplic(input_list):\n    if not input_list:\n        return [], []\n    items, counts = [], []\n    current_item = input_list[0]\n    current_count = 0\n    for item in input_list:\n        if item == current_item:\n            current_count += 1\n        else:\n            items.append(current_item)\n            counts.append(current_count)\n            current_item = item\n            current_count = 1\n    items.append(current_item)\n    counts.append(current_count)\n    return items, counts", "score": 1.0, "codebleu": 0.2825045176575153, "crystalbleu": 0, "codebertscore": 0.8, "codescore": 0.9939331412315369, "surfaceSim": 0.7499812185410563, "abs_surfaceSim_minus_score": 0.25001878145894374, "source": "local", "local_type": "OP"}
{"id": "APPS_test-0162_2", "golden_code": "n,k = [int(x) for x in input().split()]\nA = [int(x) for x in input().split()]\n\nh = 100000000000\nfor a in A:\n    if k%a==0:\n        h = min(h,k//a)\nprint(h)\n", "generated_code": "n,k = map(int,input().split())\na = list(map(int,input()))\n\na.sort()\n\nans = 0\n\nfor i in range(n):\n\tif a[i] == 1:\n\t\tans += (i+1)*k\n\t\tk = 0\n\t\t\n\telse:\n\t\tk += 1\n\nprint(ans+max(k,n-1))\n", "score": 0.0408, "codebleu": 0.24929403574148778, "crystalbleu": 0, "codebertscore": 0.79, "codescore": 0.03411820903420448, "surfaceSim": 0.5346368715083798, "abs_surfaceSim_minus_score": 0.4938368715083798, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_p03553_s305170925_MUT_6", "golden_code": "import math, string, itertools, fractions, heapq, collections, re, array, bisect, sys, random, time, copy, functools\nsys.setrecursionlimit(10 ** 7)\ninf = 10 ** 20\neps = 1.0 / (10 ** 15)\nmod = (10 ** 9) + 7\ndef LI():\n    return [int(x) for x in sys.stdin.readline().split()]\ndef LI_():\n    return [int(x) - 1 for x in sys.stdin.readline().split()]\ndef LF():\n    return [float(x) for x in sys.stdin.readline().split()]\ndef LS():\n    return sys.stdin.readline().split()\ndef I():\n    return int(sys.stdin.readline())\ndef F():\n    return float(sys.stdin.readline())\ndef S():\n    return input()\ndef pf(s):\n    return print(s, flush=True)\ndef divisions(n):\n    sq = int(math.sqrt(n) + 1)\n    d = collections.defaultdict(int)\n    while n % 2 == 0:\n        n //= 2\n        d[2] += 1\n    i = 3\n    while (n > 1 and sq >= i):\n        if n % i == 0:\n            n //= i\n            d[i] += 1else:i += 2\n    if n > 1:\n        d[n] += 1\n    r = [1]\n    for (k, v) in d.items():\n        for c in r[:]:\n            for i in range(1, v + 1):\n                r.append(c * (k ** i))\n    return sorted(r)\ndef main():\n    n = I()\n    a = LI()\n    s = set()\n    for i in range(n, 0, -1):\n        d = divisions(i)\n        ld = len(d)\n        for j in range(1, 2 ** ld):\n            c = []\n            ff = True\n            for k in range(ld):\n                if j & (1 << k):\n                    f = True\n                    for e in c:\n                        if d[k] % e == 0:\n                            f = False\n                            ff = False\n                            break\n                    if f:\n                        c.append(d[k])\n                if not ff:\n                    break\n            if ff:\n                s.add(tuple(c + [n + 1]))\n    b = sorted(list(s), reverse=True)\n    for c in b:\n        t = 0\n        for j in range(1, n + 1):\n            f = False\n            for e in c:\n                if j % e == 0:\n                    f = True\n                    break\n            if f:\n                t += a[j - 1]\n        if t < 0:\n            for j in range(1, n + 1):\n                f = False\n                for e in c:\n                    if j % e == 0:\n                        f = True\n                        break\n                if f:\n                    a[j - 1] = 0\n    return sum(a)\nprint(main())", "generated_code": "import math, string, itertools, fractions, heapq, collections, re, array, bisect, sys, random, time, copy, functools\nsys.setrecursionlimit(10 ** 7)\ninf = 10 ** 20\neps = 1.0 / (10 * 15)\nmod = (10 ** 9) + 7\ndef LI():\n    return [int(x) for x in sys.stdin.readline().split()]\ndef LI_():\n    return [int(x) - 1 for x in sys.stdin.readline().split()]\ndef LF():\n    return [float(x) for x in sys.stdin.readline().split()]\ndef LS():\n    return sys.stdin.readline().split()\ndef I():\n    return int(sys.stdin.readline())\ndef F():\n    return float(sys.stdin.readline())\ndef S():\n    return input()\ndef pf(s):\n    return print(s, flush=True)\ndef divisions(n):\n    sq = int(math.sqrt(n) + 1)\n    d = collections.defaultdict(int)\n    while n % 2 == 0:\n        n //= 2\n        d[2] += 1\n    i = 3\n    while (n > 1 and sq >= i):\n        if n % i == 0:\n            n //= i\n            d[i] += 1else:i += 2\n    if n > 1:\n        d[n] += 1\n    r = [1]\n    for (k, v) in d.items():\n        for c in r[:]:\n            for i in range(1, v + 1):\n                r.append(c * (k ** i))\n    return sorted(r)\ndef main():\n    n = I()\n    a = LI()\n    s = set()\n    for i in range(n, 0, -1):\n        d = divisions(i)\n        ld = len(d)\n        for j in range(1, 2 ** ld):\n            c = []\n            ff = True\n            for k in range(ld):\n                if j & (1 << k):\n                    f = True\n                    for e in c:\n                        if d[k] % e == 0:\n                            f = False\n                            ff = False\n                            break\n                    if f:\n                        c.append(d[k])\n                if not ff:\n                    break\n            if ff:\n                s.add(tuple(c + [n + 1]))\n    b = sorted(list(s), reverse=True)\n    for c in b:\n        t = 0\n        for j in range(1, n + 1):\n            f = False\n            for e in c:\n                if j % e == 0:\n                    f = True\n                    break\n            if f:\n                t += a[j - 1]\n        if t < 0:\n            for j in range(1, n + 1):\n                f = False\n                for e in c:\n                    if j % e == 0:\n                        f = True\n                        break\n                if f:\n                    a[j - 1] = 0\n    return sum(a)\nprint(main())", "score": 0.0, "codebleu": 0.9962096427720554, "crystalbleu": 1.0, "codebertscore": 1.0, "codescore": 0.9918044805526733, "surfaceSim": 0.49978466838931956, "abs_surfaceSim_minus_score": 0.49978466838931956, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_MBPP_136_MUT_28", "golden_code": "import os\n\ndef cal_electbill(units):\n    if units < 50:\n        amount = units * 2.6\n        surcharge = 25\n    elif units <= 100:\n        amount = 130 + ((units - 50) * 3.25)\n        surcharge = 35\n    elif units <= 200:\n        amount = (130 + 162.5) + ((units - 100) * 5.26)\n        surcharge = 45\n    else:\n        amount = ((130 + 162.5) + 526) + ((units - 200) * 8.45)\n        surcharge = 75\n    total = amount + surcharge\n    return total", "generated_code": "import os\n\ndef cal_electbill(units):\n    if units > 50:\n        amount = units * 2.6\n        surcharge = 25\n    elif units <= 100:\n        amount = 130 + ((units - 50) * 3.25)\n        surcharge = 35\n    elif units <= 200:\n        amount = (130 + 162.5) + ((units - 100) * 5.26)\n        surcharge = 45\n    else:\n        amount = ((130 + 162.5) + 526) + ((units - 200) * 8.45)\n        surcharge = 75\n    total = amount + surcharge\n    return total", "score": 0.0151, "codebleu": 0.9827716695277393, "crystalbleu": 0.95, "codebertscore": 1.0, "codescore": 0.9936566948890686, "surfaceSim": 0.9512573568753344, "abs_surfaceSim_minus_score": 0.9361573568753344, "source": "local", "local_type": "MUT"}
{"id": "MBPP_77_21", "golden_code": "def floor_Max(A,B,N):\r\n    x = min(B - 1,N)\r\n    return (A*x) // B", "generated_code": "def floor_Max(A,B,N):\n\tres = B - A\n\tcand = N+1\n\tif res < cand:\n\t\treturn cand\n\telse:\n\t\tfor i in range(2,cand):\n\t\t\tif (A[i] <= B) & (A[k] <= B):\n\t\t\t\tres = min(res, B - i)\n\t\treturn res", "score": 0.0321, "codebleu": 0.2798649025252673, "crystalbleu": 0, "codebertscore": 0.8, "codescore": 0.06203899532556534, "surfaceSim": 0.48906537753222834, "abs_surfaceSim_minus_score": 0.4569653775322283, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0419_43", "golden_code": "n = int(input(), 2)\nt = 1\nans = 0\n\nfor i in range(101):\n  if t < n:\n    ans += 1\n  t *= 4\n\nprint(ans)", "generated_code": "s = input()\n\ns = s.replace(\"0\", \"\")\n\nn = len(s)\n\nzero = s.count(\"0\")\n\nsl = 0\n\nfor i in range(n):\n\tif s[i] == \"0\":\n\t\tsl += 1\n\telse:\n\t\tsl = 0\n\tif sl == zero:\n\t\tbreak\n\nprint(sl)\n", "score": 0.0152, "codebleu": 0.274894398606342, "crystalbleu": 0, "codebertscore": 0.8, "codescore": 0.0941789448261261, "surfaceSim": 0.5678571428571428, "abs_surfaceSim_minus_score": 0.5526571428571428, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_extra_p02657_s027336468_OP_1", "golden_code": "def iput(): return int(eval(input()))\n\ndef mput(): return list(map(int, input().split()))\n\ndef lput(): return list(map(int, input().split()))\n\n\n\ndef solve():\n\n    a, b = mput()\n\n    print((a*b))\n\n    return 0\n\n\n\nif __name__ == \"__main__\":\n\n    solve()", "generated_code": "import math\n\ndef solve():\n\n    a, b = input().split()\n\n    a = int(a)\n\n    b = float(b)\n\n    print((int(a*b)))\n\n    return 0\n\n \n\nif __name__ == \"__main__\":\n\n    solve()", "score": 1.0, "codebleu": 0.3937504858276532, "crystalbleu": 0.29, "codebertscore": 0.87, "codescore": 0.18697279691696167, "surfaceSim": 0.7209163346613545, "abs_surfaceSim_minus_score": 0.2790836653386455, "source": "local", "local_type": "OP"}
{"id": "APPS_test-0951_40", "golden_code": "k = int(input())\nn = input()\nl = []\ns = 0\nfor i in range(len(n)):\n    l.append(int(n[i]))\n    s += int(n[i])\nl.sort()\nif s >= k:\n    print(0)\nelse:\n    term = 0\n    while s < k:\n        s += (9-l[term])\n        term += 1\n    print(term)\n", "generated_code": "def main():\n\tn = int(input())\n\tnum = input()\n\tdigits = [int(i) for i in num]\n\tpossible = True\n\tdigits.sort()\n\tfor i in range(len(digits) - 1):\n\t\tif digits[i]!= digits[i + 1]:\n\t\t\tpossible = False\n\t\t\tbreak\n\tif possible:\n\t\tprint(1)\n\telse:\n\t\tprint(-1)\n\n\ndef __starting_point():\n\tmain()\n\n__starting_point()\n", "score": 0.0302, "codebleu": 0.22000086772612615, "crystalbleu": 0, "codebertscore": 0.77, "codescore": 0.11547712981700897, "surfaceSim": 0.5118101545253864, "abs_surfaceSim_minus_score": 0.48161015452538636, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_p02555_s973678433_MUT_5", "golden_code": "def cmb(n, r):\n    import math\n    if n < r:\n        return 0\n    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\ndef solve(S):\n    mod = (10 ** 9) + 7\n    ans = 0\n    for i in range(1, (S // 3) + 1):\n        tama = i + (S - (i * 3))\n        tama -= 2\n        bo = i - 1\n        ans += cmb(tama + 1, bo)\n        ans %= mod\n    print(ans)", "generated_code": "def cmb(n, r):\n    import math\n    if n < r:\n        return 0\n    return math.factorial(n) // (math.factorial(n - r) // math.factorial(r))\ndef solve(S):\n    mod = (10 ** 9) + 7\n    ans = 0\n    for i in range(1, (S // 3) + 1):\n        tama = i + (S - (i * 3))\n        tama -= 2\n        bo = i - 1\n        ans += cmb(tama + 1, bo)\n        ans %= mod\n    print(ans)", "score": 0.0, "codebleu": 0.980976656443197, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.9936928749084473, "surfaceSim": 0.9972375690607735, "abs_surfaceSim_minus_score": 0.9972375690607735, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_PIE_p00144_s682125154_MUT_23", "golden_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "generated_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    @classmethod\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:print('NA')", "score": 0.0, "codebleu": 0.9895212352936913, "crystalbleu": 0.99, "codebertscore": 0.99, "codescore": 0.993553638458252, "surfaceSim": 0.9968109339407745, "abs_surfaceSim_minus_score": 0.9968109339407745, "source": "local", "local_type": "MUT"}
{"id": "MBPP_72_26", "golden_code": "def Average(lst): \r\n    return sum(lst) / len(lst) ", "generated_code": "def Average(lst): \n\tsum = 0\n\tfor n in lst:\n\t\tsum += n\n\treturn sum/len(lst)\ntp = lambda: map(int, input().split())\nimport math", "score": 1.0, "codebleu": 0.40708793803082965, "crystalbleu": 0, "codebertscore": 0.84, "codescore": 0.9928354620933533, "surfaceSim": 0.478, "abs_surfaceSim_minus_score": 0.522, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_p02792_s535465245_MUT_9", "golden_code": "from functools import lru_cache\nimport sys\nsys.setrecursionlimit(10 ** 7)\n\n@lru_cache(maxsize=None)\ndef check(l, r, n, k=1):t = (l + ('0' * k)) + r\n    e = (l + ('9' * k)) + r\n    if int(e) <= n:\n        return pow(10, k) + check(l, r, n, k + 1)\n    if int(t) <= n < int(e):\n        x = int(str(n)[1:-1])\n        if int(str(n)[-1]) < int(r):\n            x -= 1\n        return x + 1\n    if n < int(t):\n        return 0\ndef main():\n    n = int(eval(input()))\n    ret = 0\n    for x in range(1, n + 1):\n        if x % 10 == 0:\n            continue\n        s = str(x)\n        t = s[-1] + s[0]\n        if s[0] == s[-1]:\n            ret += 1\n        if int(t) <= n:\n            ret += 1\n        ret += check(s[-1], s[0], n, k=1)\n    print(ret)", "generated_code": "from functools import lru_cache\nimport sys\nsys.setrecursionlimit(10 ** 7)\n\n@lru_cache(maxsize=None)\ndef check(l, r, n, k=1):t = (l + ('0' // k)) + r\n    e = (l + ('9' * k)) + r\n    if int(e) <= n:\n        return pow(10, k) + check(l, r, n, k + 1)\n    if int(t) <= n < int(e):\n        x = int(str(n)[1:-1])\n        if int(str(n)[-1]) < int(r):\n            x -= 1\n        return x + 1\n    if n < int(t):\n        return 0\ndef main():\n    n = int(eval(input()))\n    ret = 0\n    for x in range(1, n + 1):\n        if x % 10 == 0:\n            continue\n        s = str(x)\n        t = s[-1] + s[0]\n        if s[0] == s[-1]:\n            ret += 1\n        if int(t) <= n:\n            ret += 1\n        ret += check(s[-1], s[0], n, k=1)\n    print(ret)", "score": 0.0, "codebleu": 0.989831222213881, "crystalbleu": 0.97, "codebertscore": 1.0, "codescore": 0.9937471151351929, "surfaceSim": 0.49864314789687925, "abs_surfaceSim_minus_score": 0.49864314789687925, "source": "local", "local_type": "MUT"}
{"id": "MBPP_11_1", "golden_code": "def lcm(x, y):\r\n   if x > y:\r\n       z = x\r\n   else:\r\n       z = y\r\n   while(True):\r\n       if((z % x == 0) and (z % y == 0)):\r\n           lcm = z\r\n           break\r\n       z += 1\r\n   return lcm", "generated_code": "def lcm(x, y):\n\treturn x*y//(x//y)\n\n\n\n\n\n\n\n\n\t\ncandidates = {'diff': 0, 'index': 1, 'char': 2, 'float': 3,'my': 4, 'type': 5,'vector': 6, 'num': 7, 'q': 8, 'u': 9, 'V': 10, 'w': 11, 'x': 16, 'y': 17, 'z': 18}", "score": 0.1907, "codebleu": 0.13659507906209584, "crystalbleu": 0, "codebertscore": 0.72, "codescore": 0.3107447922229767, "surfaceSim": 0.3850485436893204, "abs_surfaceSim_minus_score": 0.1943485436893204, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_MBPP_469_OP_1", "golden_code": "def max_profit(price, k):\r\n    n = len(price)\r\n    final_profit = [[None for x in range(n)] for y in range(k + 1)]\r\n    for i in range(k + 1):\r\n        for j in range(n):\r\n            if i == 0 or j == 0:\r\n                final_profit[i][j] = 0\r\n            else:\r\n                max_so_far = 0\r\n                for x in range(j):\r\n                    curr_price = price[j] - price[x] + final_profit[i-1][x]\r\n                    if max_so_far < curr_price:\r\n                        max_so_far = curr_price\r\n                final_profit[i][j] = max(final_profit[i][j-1], max_so_far)\r\n    return final_profit[k][n-1]", "generated_code": "def max_profit(values, transactions):\n    days = len(values)\n    if days == 0 or transactions == 0:\n        return 0\n    profits = [[0] * days for _ in range(transactions + 1)]\n    for t in range(1, transactions + 1):\n        max_diff = -values[0]\n        for d in range(1, days):\n            profits[t][d] = max(profits[t][d-1], values[d] + max_diff)\n            max_diff = max(max_diff, profits[t-1][d] - values[d])\n    return profits[transactions][days-1]", "score": 1.0, "codebleu": 0.25644944507278, "crystalbleu": 0.13, "codebertscore": 0.78, "codescore": 0.9927183389663696, "surfaceSim": 0.6918418839360807, "abs_surfaceSim_minus_score": 0.3081581160639193, "source": "local", "local_type": "OP"}
{"id": "LOCAL_PIE_p02649_s231020544_MUT_31", "golden_code": "def popcount(x):\n    x = x - ((x >> 1) & 1431655765)\n    x = (x & 858993459) + ((x >> 2) & 858993459)\n    x = (x + (x >> 4)) & 252645135\n    x = x + (x >> 8)\n    x = x + (x >> 16)\n    return x & 127\ncmb = [[0 for i in range(51)] for j in range(51)]\ncmb[0][0] = 1\nfor i in range(51):\n    for j in range(51):\n        if (i != 50 and j != 50):\n            cmb[i + 1][j + 1] += cmb[i][j]\n        if i != 50:\n            cmb[i + 1][j] += cmb[i][j]\nfor i in range(1, 51):\n    for j in range(2, 51):\n        cmb[i][j] += cmb[i][j - 1]\n(N, K, T, S) = list(map(int, input().split()))\na = list(map(int, input().split()))\nmust0 = [i for i in range(18) if (S >> i) & 1 == 0]\nmust1 = [i for i in range(18) if (T >> i) & 1 == 1]\nA = []\nfor val in a:\n    check = True\n    for j in must0:\n        check = check & (val >> j) & 1 == 0\n    for j in must1:\n        check = check & (val >> j) & 1 == 1\n    if check:\n        A.append(val)\nif not A:\n    print(0)\n    exit()\nbit = []\nfor i in range(18):\n    if (i not in must0 and i not in must1):\n        bit.append(i)\nfor i in range(len(A)):\n    temp = 0\n    for j in range(len(bit)):\n        temp += (A[i] >> bit[j]) & 1 == 1 * (2 ** j)\n    A[i] = temp\nans = 0\nn = len(bit)\ndata = [0] * (2 ** n)\nfor i in range(2 ** n):\n    t = set([])\n    for a in A:\n        data[a & i] += 1\n        t.add(a & i)\n    temp = 0\n    for val in t:\n        temp += cmb[data[val]][min(K, data[val])]\n    ans += temp * ((-1) ** popcount(i))\n    for val in t:\n        data[val] = 0\nprint(ans)", "generated_code": "def popcount(x):\n    x = x - ((x >> 1) & 1431655765)\n    x = (x & 858993459) + ((x >> 2) & 858993459)\n    x = (x + (x >> 4)) & 252645135\n    x = x + (x >> 8)\n    x = x + (x >> 16)\n    return x & 127\ncmb = [[0 for i in range(51)] for j in range(51)]\ncmb[0][0] = 1\nfor i in range(51):\n    for j in range(51):\n        if (i != 50 and j != 50):\n            cmb[i + 1][j + 1] += cmb[i][j]\n        if i != 50:\n            cmb[i + 1][j] += cmb[i][j]\nfor i in range(1, 51):\n    for j in range(2, 51):\n        cmb[i][j] += cmb[i][j - 1]\n(N, K, T, S) = list(map(int, input().split()))\na = list(map(int, input().split()))\nmust0 = [i for i in range(18) if (S >> i) & 1 == 0]\nmust1 = [i for i in range(18) if (T >> i) & 1 == 1]\nA = []\nfor val in a:\n    check = True\n    for j in must0:\n        check = check & (val >> j) & 1 == 0\n    for j in must1:\n        check = check & (val >> j) & 1 == 1\n    if check:\n        A.append(val)\nif not A:\n    print(0)\n    exit()\nbit = []\nfor i in range(18):\n    if (i not in must0 and i not in must1):\n        bit.append(i)\nfor i in range(len(A)):\n    temp = 0\n    for j in range(len(bit)):\n        temp += (A[i] >> bit[j]) & 1 == 1 * (2 ** j)\n    A[i] = temp\nans = 0\nn = len(bit)\ndata = [0] * (2 ** n)\nfor i in range(2 ** n):\n    t = set([])\n    for a in A:\n        data[a & i] += 1\n        t.add(a & i)\n    temp = 0\n    for val in t:\n        temp += cmb[data[val]][min(K, data[val])]\n    ans -= temp * ((-1) ** popcount(i))\n    for val in t:\n        data[val] = 0\nprint(ans)", "score": 0.4924, "codebleu": 0.995941382850743, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9936419129371643, "surfaceSim": 0.9996662216288384, "abs_surfaceSim_minus_score": 0.5072662216288384, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-1709_6", "golden_code": "def main():\n    n, m, k = list(map(int, input().split()))\n    c, *cc = (list(map(int, input().split())))\n    pp, *ppp = (list(map(float, input().split())) for _ in range(n))\n    inf = 2. ** 47\n    nxt = [[0. if i == c - 1 else inf for i in range(m)] if c else pp]\n    for c, pp in zip(cc, ppp):\n        newrow = [inf] * m\n        cur, nxt = nxt, [newrow]\n        if c:\n            c -= 1\n            for row in cur:\n                p = row[c]\n                if newrow[c] > p:\n                    newrow[c] = p\n                if len(nxt) == k:\n                    break\n                row[c] = inf\n                newrow = [inf] * m\n                newrow[c] = min(row)\n                nxt.append(newrow)\n        else:\n            for row in cur:\n                for c, p in enumerate(a + b for a, b in zip(row, pp)):\n                    if newrow[c] > p:\n                        newrow[c] = p\n                if len(nxt) == k:\n                    break\n                bestclr = min(list(range(m)), key=row.__getitem__)\n                x, row[bestclr] = row[bestclr], inf\n                newrow = [a + x for a in pp]\n                newrow[bestclr] = min(row) + pp[bestclr]\n                nxt.append(newrow)\n\n    p = min(nxt[-1])\n    print(int(p) if p < inf else -1)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "generated_code": "def main():\n\tn, m, k = list(map(int, input().split()))\n\tt = [[int(j) for j in input().split()] for i in range(n)]\n\tv = [0] * n\n\tfor i in range(m):\n\t\tu = set()\n\t\tfor j in range(i, n):\n\t\t\tu.add(t[j][i])\n\t\tv[i] = u\n\tfor iin in range(n):\n\t\tu= set()\n\t\tc = 0\n\t\tfor j  in range(m):go = 1\n\t\twhile(j in v[:iin]):\n\t\t\tw = v[:]\n\t\t\tfor jj in range(j, n):\n\t\t\t\tif(w[jj]==0):\n\t\t\t\t\tw[jj] = c\n\t\t\t\t\tc += 1\n\t\t\t\telse:\n\t\t\t\t\tpass\n\t\t", "score": 0.0, "codebleu": 0.1784421054162957, "crystalbleu": 0.08, "codebertscore": 0.74, "codescore": 0.01827184297144413, "surfaceSim": 0.6003673700075358, "abs_surfaceSim_minus_score": 0.6003673700075358, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0590_21", "golden_code": "from sys import stdin, stdout\n\nn = int(stdin.readline().rstrip())\na = list(map(int,stdin.readline().rstrip().split()))\n\naSet = set(a)\naMinus = set(range(1,n+1)) - aSet\nminusList = sorted(list(aMinus),reverse=True)\nused=set()\n\ncountDict = {x : 0 for x in aSet}\nfor x in a:\n    countDict[x] +=1\n\nfinalList = a\nfor i in range(n):\n    x = a[i]\n    if x in used:\n        finalList[i] = minusList.pop()\n    elif countDict[x]==1:\n        continue\n    elif x<minusList[-1]:\n        used.add(x)\n    else:\n        countDict[x]-=1\n        finalList[i] = minusList.pop()\n\nprint(len(aMinus))\nprint(' '.join(map(str,finalList)))\n", "generated_code": "n = int(input())\na = list(map(int, input().split()))\n\na.sort()\n\nans = 0\n\nfor i in range(n):\n\tif a[i]!= i + 1:\n\t\tans += 1\n\nprint(ans)\nprint(' '.join(map(str, a)))\n", "score": 0.0012, "codebleu": 0.1633524540753993, "crystalbleu": 0.09, "codebertscore": 0.74, "codescore": 0.10190615057945251, "surfaceSim": 0.4792682926829268, "abs_surfaceSim_minus_score": 0.47806829268292683, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_16_17", "golden_code": "def div_of_nums(nums,m,n):\r\n result = list(filter(lambda x: (x % m == 0 and x % n == 0), nums)) \r\n return result", "generated_code": "def div_of_nums(nums,m,n):\n\treturn [i for i in nums if i%m == 0 and i%n == 0]\nh = lambda x, y: sum(x, y)", "score": 1.0, "codebleu": 0.2789461156682843, "crystalbleu": 0, "codebertscore": 0.86, "codescore": 0.9934701919555664, "surfaceSim": 0.7446428571428572, "abs_surfaceSim_minus_score": 0.25535714285714284, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0103_7", "golden_code": "n = int(input())\na  = [0] + list(map(int, input().split())) + [1001]\nres = 1\ncur = 1\n\nfor i in range(n+1):\n    if a[i+1] - a[i] == 1:\n        cur += 1\n    else:\n        cur = 1\n    res  = max(res, cur)\nprint(max(0, res - 2))\n", "generated_code": "import sys\ninput = sys.stdin.readline\n\nn=int(input())\nA=list(map(int,input().split()))\n\n\"\"\"\nfor i in range(1,n):\n\t#print(i,A[i],i-1)\n\tif i>=n:\n\t\tprint(0)\n\t\treturn\n\tif A[i]>A[i-1]:\n\t\tprint(A[i])\n\t\treturn\n\"\"\"\n\nif n==1:\n\tprint(0)  \n\treturn\n\ndesired=A[-1]\nprev=A[0]\nanswer=0\nfor i in reversed(list(range(n-1))):\n\tif A<=A[i]:\n\t\tdiff=A[i]-prev\n\t\tanswer+=diff\n\t\tprev=A[i]\n\telse:\n\t\tprev= A", "score": 0.0, "codebleu": 0.1924855918863972, "crystalbleu": 0.18, "codebertscore": 0.8, "codescore": 0.17482459545135498, "surfaceSim": 0.5254896022612559, "abs_surfaceSim_minus_score": 0.5254896022612559, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_45_OP_1", "golden_code": "def triangle_area(a, h):\n    return a * h / 2.0", "generated_code": "def triangle_area(base, height):\n    if base == 0 or height == 0:\n        return 0.0\n    return base * height * 0.5", "score": 1.0, "codebleu": 0.40552038205434215, "crystalbleu": 0, "codebertscore": 0.85, "codescore": 0.9726506471633911, "surfaceSim": 0.5907608695652173, "abs_surfaceSim_minus_score": 0.40923913043478266, "source": "local", "local_type": "OP"}
{"id": "MBPP_67_26", "golden_code": "def nCr_mod_p(n, r, p): \r\n\tif (r > n- r): \r\n\t\tr = n - r \r\n\tC = [0 for i in range(r + 1)] \r\n\tC[0] = 1 \r\n\tfor i in range(1, n + 1): \r\n\t\tfor j in range(min(i, r), 0, -1): \r\n\t\t\tC[j] = (C[j] + C[j-1]) % p \r\n\treturn C[r] ", "generated_code": "def nCr_mod_p(n, r, p): \n\tr = min(r, n - r)\n\twhile r!= 0:\n\t\tn = n\n\t\tr = r - 1\n\treturn n % p", "score": 0.2767, "codebleu": 0.14374978470886818, "crystalbleu": 0, "codebertscore": 0.82, "codescore": 0.21671083569526672, "surfaceSim": 0.5475452196382429, "abs_surfaceSim_minus_score": 0.2708452196382429, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-1000_33", "golden_code": "n, v = map(int, input().split())\n\nresult = v-1 + (n-v)*(n-v+1)//2 if n-1 > v else n-1\nprint(result)", "generated_code": "n, v = list(map(int, input().split()))\nprint(min(n, 1 + v) * (v - 1) + v)\n", "score": 0.0414, "codebleu": 0.19552475801808103, "crystalbleu": 0, "codebertscore": 0.86, "codescore": 0.019120285287499428, "surfaceSim": 0.6313131313131313, "abs_surfaceSim_minus_score": 0.5899131313131313, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_131_MUT_22", "golden_code": "import os\n\ndef digits(n):\n    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit % 2 == 1:\n            product = product * int_digit\n            odd_count += 1\n    if odd_count == 0:\n        return 0\n    else:\n        return product", "generated_code": "import os\n\ndef digits(n):\n    product = 1\n    odd_count = 0\n    for digit in str(n):\n        break\n    \n    \n    \n    if odd_count == 0:\n        return 0\n    else:\n        return product", "score": 0.1239, "codebleu": 0.513463444961749, "crystalbleu": 0, "codebertscore": 0.91, "codescore": 0.2699372470378876, "surfaceSim": 0.7376207729468599, "abs_surfaceSim_minus_score": 0.6137207729468599, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_HE_62_MUT_9", "golden_code": "import os\n\ndef derivative(xs: list):\n    return [i * x for (i, x) in enumerate(xs)][1:]", "generated_code": "import os\n\ndef derivative(xs: list):\n    return [i * x for (i, x) in enumerate(xs)][:]", "score": 0.0, "codebleu": 0.8739829716018997, "crystalbleu": 0, "codebertscore": 0.99, "codescore": 0.9894249439239502, "surfaceSim": 0.9679370840895342, "abs_surfaceSim_minus_score": 0.9679370840895342, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-0564_5", "golden_code": "n,s=map(int,input().split())\nalist=[int(x) for x in input().split()]\n\nalist.sort()\n\nif sum(alist[:(n-1)])<=s:\n    print(\"YES\")\nelse:\n    print(\"NO\")", "generated_code": "n, s = list(map(int, input().split()))\n\na = list(map (int, input().replace(' ', '') ))\n\nx = []\n\nfor i in a:\n\tx.append(i)\n\nx = sorted(x)\n\nif len(x) % 2 == 0:\n\tprint('NO')\nelse:\n\tprint ('YES')\n\n\n\n#print(x)\n", "score": 0.449, "codebleu": 0.2898120419663893, "crystalbleu": 0.14, "codebertscore": 0.83, "codescore": 0.4759615361690521, "surfaceSim": 0.5767263427109974, "abs_surfaceSim_minus_score": 0.12772634271099742, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_4698_39_MUT_28", "golden_code": "N = int(input())\nT = list(map(int, input().split()))\nM = int(input())\nP = [0] * M\nX = [0] * M\nfor i in range(M):\n    (P[i], X[i]) = list(map(int, input().split()))\n\nfor i in range(M):\n    ans = 0\n    ans += sum(T[:P[i] - 1])\n    ans += X[i]\n    ans += sum(T[P[i]:])\n    print(ans)", "generated_code": "N = int(input())\nT = list(map(int, input().split()))\nM = int(input())\nP = [0] * M\nX = [0] * M\nfor i in range(M):\n    (P[i], X[i]) = list(map(int, input().split()))\n\nfor i in range(M):\n    ans = 0\n    ans += sum(T[:])\n    ans += X[i]\n    ans += sum(T[P[i]:])\n    print(ans)", "score": 0.0, "codebleu": 0.8951742909526811, "crystalbleu": 0.94, "codebertscore": 0.99, "codescore": 0.26101192831993103, "surfaceSim": 0.9642857142857142, "abs_surfaceSim_minus_score": 0.9642857142857142, "source": "local", "local_type": "MUT"}
{"id": "MBPP_72_43", "golden_code": "def Average(lst): \r\n    return sum(lst) / len(lst) ", "generated_code": "def Average(lst): \n\tsum = 0\n\tfor n in lst:\n\t\tsum = sum + n\n\tavg = sum / len(lst)\n\treturn avg", "score": 1.0, "codebleu": 0.41538131979459036, "crystalbleu": 0, "codebertscore": 0.87, "codescore": 0.9932454228401184, "surfaceSim": 0.6322463768115942, "abs_surfaceSim_minus_score": 0.36775362318840576, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-2128_56", "golden_code": "import os\n\nN = int(3e5 + 233)\nMOD = 998244353\nans = []\nfor i in range(N):\n    ans.append(0)\n\ndef fp(x, y):\n    res = 1\n    while y:\n        if y&1:\n            res = res * x\n            res %= MOD\n        x *= x\n        x %= MOD\n        y >>= 1\n    return res\n\ninv = fp(100, MOD-2)\nn = int(input())\ndig = list(map(int, input().split()))\nfor i in range(1, n+1):\n    x = dig[i-1]\n    x *= inv\n    x %= MOD\n    ans[i] = (((1 + ans[i-1]) % MOD) * fp(x, MOD-2)) % MOD\nprint(ans[n])", "generated_code": "n=int(input())\np=list(map(int,input().split()))\nq=p[0]\nans=0\nfor i in range(1,n):\n\tq=(q*p[i])%998244353\n\tans+=q\nprint(ans)\n", "score": 0.0, "codebleu": 0.13871155098710036, "crystalbleu": 0.09, "codebertscore": 0.73, "codescore": 0.05072753131389618, "surfaceSim": 0.5273471457548536, "abs_surfaceSim_minus_score": 0.5273471457548536, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_2645_55_OP_1", "golden_code": "ans = 0\n\nfor i,c in enumerate(input()):\n  if i%2 == 0 and c == \"p\": ans -= 1\n  elif i%2 == 1 and c == \"g\": ans += 1\n\nprint(ans)", "generated_code": "result = 0\ninput_str = input()\nfor idx in range(0, len(input_str), 2):\n  if input_str[idx] == 'p':\n    result -= 1\n  if idx + 1 < len(input_str) and input_str[idx + 1] == 'g':\n    result += 1\nprint(result)", "score": 1.0, "codebleu": 0.2508547761677009, "crystalbleu": 0, "codebertscore": 0.83, "codescore": 0.37789231538772583, "surfaceSim": 0.6254506892895015, "abs_surfaceSim_minus_score": 0.37454931071049846, "source": "local", "local_type": "OP"}
{"id": "MBPP_76_4", "golden_code": "def word_len(s): \r\n    s = s.split(' ')   \r\n    for word in s:    \r\n        if len(word)%2==0: \r\n            return True  \r\n        else:\r\n          return False", "generated_code": "def word_len(s):\n\treturn \"D\" in s", "score": 0.3597, "codebleu": 0.09059120243573238, "crystalbleu": 0, "codebertscore": 0.76, "codescore": 0.5779423713684082, "surfaceSim": 0.5349787512258908, "abs_surfaceSim_minus_score": 0.17527875122589076, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0955_3", "golden_code": "n = int(input())\n\nisC = False\nisB = False\nisA = False\n\nd = {}\n\nfor i in range(n):\n\tline = input()\n\n\tc = int(line.split(' ')[0])\n\ts = line.split(' ')[1]\n\n\tif 'A' in s:\n\t\tisA = True\n\n\tif 'B' in s:\n\t\tisB = True\n\n\tif 'C' in s:\n\t\tisC = True\n\n\t# print(s)\n\n\tname = ''.join(sorted(s))\n\n\ttry:\n\t\td[name] = min(c, d[name])\n\n\texcept:\n\t\td[name] = c\n\nif not isA or not isB or not isC:\n\tprint(-1)\n\nelse:\n\tarr = []\n\n\ttry:\n\t\tarr.append(d['A'] + d['B'] + d['C'])\n\texcept:\n\t\tpass\n\n\ttry:\n\t\tarr.append(d['A'] + d['BC'])\n\texcept:\n\t\tpass\n\n\ttry:\n\t\tarr.append(d['AB'] + d['C'])\n\texcept:\n\t\tpass\n\n\ttry:\n\t\tarr.append(d['AC'] + d['B'])\n\texcept:\n\t\tpass\n\n\ttry:\n\t\tarr.append(d['AB'] + d['BC'])\n\texcept:\n\t\tpass\n\n\ttry:\n\t\tarr.append(d['AC'] + d['BC'])\n\texcept:\n\t\tpass\n\n\ttry:\n\t\tarr.append(d['AB'] + d['AC'])\n\texcept:\n\t\tpass\n\n\ttry:\n\t\tarr.append(d['ABC'])\n\texcept:\n\t\tpass\n\n\ttry:\n\t\tarr.append(d['ABC'])\n\texcept:\n\t\tpass\n\n\tprint(min(arr))\n\n", "generated_code": "import sys\n\ndef minp():\n\treturn sys.stdin.readline().strip()\n\ndef mint():\n\treturn int(minp())\n\ndef mints():\n\treturn list(map(int, minp().split()))\n\ndef solve():\n\tn = mint()\n\tc = []\n\tfor i in range(n):\n\t\tc.append(mint())\n\ttotal = float(\"inf\")\n\td = {(0, 0, 0): 0}\n\tfor i, c in enumerate(c):\n\t\tfor j in range(3):\n\t\t\tif c[j] == 'A':\n\t\t\t\td[(i, j, 0)] = min(d[(i, j, 0)], d[(i,j, 1)] + c[j])\n\t\t\telif c[j]:\n\t\t\t\td[ (i, j, 1) ]", "score": 0.0, "codebleu": 0.13626660368742036, "crystalbleu": 0.05, "codebertscore": 0.73, "codescore": 0.0662662535905838, "surfaceSim": 0.4376758489825296, "abs_surfaceSim_minus_score": 0.4376758489825296, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_23_OP_1", "golden_code": "def strlen(string: str) -> int:\n    return len(string)", "generated_code": "def strlen(text: str) -> int:\n    return len(text)", "score": 1.0, "codebleu": 0.7227434131749824, "crystalbleu": 0, "codebertscore": 0.98, "codescore": 0.9938310384750366, "surfaceSim": 0.9074074074074074, "abs_surfaceSim_minus_score": 0.09259259259259256, "source": "local", "local_type": "OP"}
{"id": "APPS_test-2128_52", "golden_code": "import os\n\nN = int(3e5 + 233)\nMOD = 998244353\nans = []\nfor i in range(N):\n    ans.append(0)\n\ndef fp(x, y):\n    res = 1\n    while y:\n        if y&1:\n            res = res * x\n            res %= MOD\n        x *= x\n        x %= MOD\n        y >>= 1\n    return res\n\ninv = fp(100, MOD-2)\nn = int(input())\ndig = list(map(int, input().split()))\nfor i in range(1, n+1):\n    x = dig[i-1]\n    x *= inv\n    x %= MOD\n    ans[i] = (((1 + ans[i-1]) % MOD) * fp(x, MOD-2)) % MOD\nprint(ans[n])", "generated_code": "import sys\ninput = sys.stdin.readline\n\nn=int(input())\nL=list(map(int,input().split()))\n\neven=L[0]\nodd=L[1]\n\nANS=0\nfirst=1\nfor i in range(1,n):\n\tfirst=first*(L[i]+1)%998244353\n\tANS+=first\n\nprint(ANS%998244353)\n", "score": 0.0, "codebleu": 0.1609481242732414, "crystalbleu": 0.11, "codebertscore": 0.74, "codescore": 0.07079218327999115, "surfaceSim": 0.5660315850478121, "abs_surfaceSim_minus_score": 0.5660315850478121, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_p03553_s305170925_MUT_10", "golden_code": "import math, string, itertools, fractions, heapq, collections, re, array, bisect, sys, random, time, copy, functools\nsys.setrecursionlimit(10 ** 7)\ninf = 10 ** 20\neps = 1.0 / (10 ** 15)\nmod = (10 ** 9) + 7\ndef LI():\n    return [int(x) for x in sys.stdin.readline().split()]\ndef LI_():\n    return [int(x) - 1 for x in sys.stdin.readline().split()]\ndef LF():\n    return [float(x) for x in sys.stdin.readline().split()]\ndef LS():\n    return sys.stdin.readline().split()\ndef I():\n    return int(sys.stdin.readline())\ndef F():\n    return float(sys.stdin.readline())\ndef S():\n    return input()\ndef pf(s):\n    return print(s, flush=True)\ndef divisions(n):\n    sq = int(math.sqrt(n) + 1)\n    d = collections.defaultdict(int)\n    while n % 2 == 0:\n        n //= 2\n        d[2] += 1\n    i = 3\n    while (n > 1 and sq >= i):\n        if n % i == 0:\n            n //= i\n            d[i] += 1else:i += 2\n    if n > 1:\n        d[n] += 1\n    r = [1]\n    for (k, v) in d.items():\n        for c in r[:]:\n            for i in range(1, v + 1):\n                r.append(c * (k ** i))\n    return sorted(r)\ndef main():\n    n = I()\n    a = LI()\n    s = set()\n    for i in range(n, 0, -1):\n        d = divisions(i)\n        ld = len(d)\n        for j in range(1, 2 ** ld):\n            c = []\n            ff = True\n            for k in range(ld):\n                if j & (1 << k):\n                    f = True\n                    for e in c:\n                        if d[k] % e == 0:\n                            f = False\n                            ff = False\n                            break\n                    if f:\n                        c.append(d[k])\n                if not ff:\n                    break\n            if ff:\n                s.add(tuple(c + [n + 1]))\n    b = sorted(list(s), reverse=True)\n    for c in b:\n        t = 0\n        for j in range(1, n + 1):\n            f = False\n            for e in c:\n                if j % e == 0:\n                    f = True\n                    break\n            if f:\n                t += a[j - 1]\n        if t < 0:\n            for j in range(1, n + 1):\n                f = False\n                for e in c:\n                    if j % e == 0:\n                        f = True\n                        break\n                if f:\n                    a[j - 1] = 0\n    return sum(a)\nprint(main())", "generated_code": "import math, string, itertools, fractions, heapq, collections, re, array, bisect, sys, random, time, copy, functools\nsys.setrecursionlimit(10 ** 7)\ninf = 10 ** 20\neps = 1.0 / (10 ** 15)\nmod = (10 ** 9) + 7\ndef LI():\n    return [int(x) for x in sys.stdin.readline().split()]\ndef LI_():\n    return [int(x) - 1 for x in sys.stdin.readline().split()]\ndef LF():\n    return [float(x) for x in sys.stdin.readline().split()]\ndef LS():\n    return sys.stdin.readline().split()\ndef I():\n    return int(sys.stdin.readline())\ndef F():\n    return float(sys.stdin.readline())\ndef S():\n    return input()\ndef pf(s):\n    return print(s, flush=True)\ndef divisions(n):\n    sq = int(math.sqrt(n) - 1)\n    d = collections.defaultdict(int)\n    while n % 2 == 0:\n        n //= 2\n        d[2] += 1\n    i = 3\n    while (n > 1 and sq >= i):\n        if n % i == 0:\n            n //= i\n            d[i] += 1else:i += 2\n    if n > 1:\n        d[n] += 1\n    r = [1]\n    for (k, v) in d.items():\n        for c in r[:]:\n            for i in range(1, v + 1):\n                r.append(c * (k ** i))\n    return sorted(r)\ndef main():\n    n = I()\n    a = LI()\n    s = set()\n    for i in range(n, 0, -1):\n        d = divisions(i)\n        ld = len(d)\n        for j in range(1, 2 ** ld):\n            c = []\n            ff = True\n            for k in range(ld):\n                if j & (1 << k):\n                    f = True\n                    for e in c:\n                        if d[k] % e == 0:\n                            f = False\n                            ff = False\n                            break\n                    if f:\n                        c.append(d[k])\n                if not ff:\n                    break\n            if ff:\n                s.add(tuple(c + [n + 1]))\n    b = sorted(list(s), reverse=True)\n    for c in b:\n        t = 0\n        for j in range(1, n + 1):\n            f = False\n            for e in c:\n                if j % e == 0:\n                    f = True\n                    break\n            if f:\n                t += a[j - 1]\n        if t < 0:\n            for j in range(1, n + 1):\n                f = False\n                for e in c:\n                    if j % e == 0:\n                        f = True\n                        break\n                if f:\n                    a[j - 1] = 0\n    return sum(a)\nprint(main())", "score": 0.0, "codebleu": 0.9962096427720554, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9911931157112122, "surfaceSim": 0.49978466838931956, "abs_surfaceSim_minus_score": 0.49978466838931956, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-1915_19", "golden_code": "def a(i, j):\n    if i == 1 or j == 1:\n        return 1\n    return a(i - 1, j) + a(i, j - 1)\n\nn = int(input())\nprint(a(n, n))", "generated_code": "n=int(input())\nif n==1:\n\tprint(1)\n\treturn\nsu=int(n*(n+1)/2)\nans=0\nfor i in range(n):\n\tans+=su\n\tsu-=1\nprint(ans)\n", "score": 0.0, "codebleu": 0.2082552778809288, "crystalbleu": 0, "codebertscore": 0.78, "codescore": 0.06793107837438583, "surfaceSim": 0.5383064516129032, "abs_surfaceSim_minus_score": 0.5383064516129032, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0564_23", "golden_code": "\nn, s = list(map(int, input().split()))\na = [i for i in map(int, input().split())]\n\nr = [\"NO\", \"YES\"]\nz = sum(a) - max(a) <= s\n#print(max(a))\nprint(r[z])\n\n\n", "generated_code": "n,s = list(map(int,input().split()))\na = list(map (int,input().strip().split())) ;\nfor i in range(n):\n\tif a[i]==1 :\n\t\ta[i] = 0\n\t\t\nif n==1 :\n\tprint('YES')\nelse :\n\tf = 0\n\tfor i in range (n-1) :\n\t\tif a[i&1]!=0 :\n\t\t\tf += 1\n\tif f>0 and s%f==0 :\n\t\tprint('YES')\t\n\telse :\n\t\tprint ('NO')\n\t\t\n\t\t\n\t\n", "score": 0.4476, "codebleu": 0.3292280180800756, "crystalbleu": 0.14, "codebertscore": 0.8, "codescore": 0.1968420296907425, "surfaceSim": 0.5026132404181185, "abs_surfaceSim_minus_score": 0.0550132404181185, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_70_25", "golden_code": "def is_abundant(n):\r\n    fctrsum = sum([fctr for fctr in range(1, n) if n % fctr == 0])\r\n    return fctrsum > n", "generated_code": "def is_abundant(n):\n\treturn n - (n * (n - 1)) == 0", "score": 0.6452, "codebleu": 0.104278450632946, "crystalbleu": 0, "codebertscore": 0.81, "codescore": 0.8071047067642212, "surfaceSim": 0.5317567567567567, "abs_surfaceSim_minus_score": 0.11344324324324329, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_14_16", "golden_code": "def sum_even_odd(list1):\r\n    first_even = next((el for el in list1 if el%2==0),-1)\r\n    first_odd = next((el for el in list1 if el%2!=0),-1)\r\n    return (first_even+first_odd)", "generated_code": "def sum_even_odd(list1, evenStack=[]):\n\tevenStack=[]\n\treturn (sum(evenStack))", "score": 0.0385, "codebleu": 0.01583371166880808, "crystalbleu": 0, "codebertscore": 0.78, "codescore": 0.022428002208471298, "surfaceSim": 0.45738636363636365, "abs_surfaceSim_minus_score": 0.41888636363636367, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_2653_71_OP_1", "golden_code": "import sys\nsys.setrecursionlimit(10**9)\nn,q=map(int,input().split())\nG=[[] for _ in range(n)]\nfor _ in range(n-1):\n    a,b=map(int,input().split())\n    a-=1\n    b-=1\n    G[a].append(b)\n    G[b].append(a)\n\nsubtree_size=[0]*n\ncnt=[0]*n\n\nfor _ in range(q):\n    p,x=map(int,input().split())\n    p-=1\n    cnt[p]+=x\nans=[0]*n\n\ndef dfs(G,v,p):\n    ans[v]+=cnt[v]\n    for nv in G[v]:\n        if nv==p:\n            continue\n        cnt[nv]+=cnt[v]\n        dfs(G,nv,v)\n    \n    subtree_size[v]=1\n    for c in G[v]:\n        if c==p:\n            continue\n        subtree_size[v]+=subtree_size[c]\n\nroot=0\ndfs(G,root,-1)\n\nfor i in range(n):\n    print(ans[i],end=' ')\n\n\n", "generated_code": "from sys import setrecursionlimit\nsetrecursionlimit(10**9)\nnum_nodes, queries = map(int, input().split())\ngraph = [[] for _ in range(num_nodes)]\nfor _ in range(num_nodes - 1):\n    node1, node2 = map(int, input().split())\n    node1 -= 1\n    node2 -= 1\n    graph[node1].append(node2)\n    graph[node2].append(node1)\n\nsubtree_sizes = [0] * num_nodes\nincrements = [0] * num_nodes\n\nfor _ in range(queries):\n    node, increment_value = map(int, input().split())\n    node -= 1\n    increments[node] += increment_value\n\nresult = [0] * num_nodes\n\n# Using a more explicit stack to avoid deep recursion\nstack = [(0, -1)]\nwhile stack:\n    current, parent = stack.pop()\n    result[current] += increments[current]\n    for neighbor in graph[current]:\n        if neighbor == parent:\n            continue\n        increments[neighbor] += increments[current]\n        stack.append((neighbor, current))\n\n    subtree_sizes[current] = 1\n    for child in graph[current]:\n        if child == parent:\n            continue\n        subtree_sizes[current] += subtree_sizes[child]\n\nfor res in result:\n    print(res, end=' ')\n", "score": 1.0, "codebleu": 0.421369476544069, "crystalbleu": 0.28, "codebertscore": 0.8, "codescore": 0.20062223076820374, "surfaceSim": 0.7153857883501067, "abs_surfaceSim_minus_score": 0.2846142116498933, "source": "local", "local_type": "OP"}
{"id": "APPS_test-0806_11", "golden_code": "n, r, l=(int(i) for i in input().split())\nr0=r\nif r0%3==1: r0+=2\nelif r0%3==2: r0+=1\nl0=l\nif l0%3==1: l0-=1\nelif l0%3==2: l0-=2\nd0=(l0-r0)//3+1\nd1=d0-1\nd2=d0-1\nif r0-r==2:\n    d1+=1\n    d2+=1\nelif r0-r==1:\n    d2+=1\nif l-l0==2:\n    d1+=1\n    d2+=1\nelif l-l0==1:\n    d1+=1\nd0=[d0]\nd1=[d1]\nd2=[d2]\n#print(d0[0], d1[0], d2[0])\nfor i in range(1, n):\n    d0.append((d0[i-1]*d0[0]+d1[i-1]*d2[0]+d2[i-1]*d1[0])%1000000007)\n    d1.append((d0[i-1]*d1[0]+d1[i-1]*d0[0]+d2[i-1]*d2[0])%1000000007)\n    d2.append((d0[i-1]*d2[0]+d1[i-1]*d1[0]+d2[i-1]*d0[0])%1000000007)\nprint(d0[n-1])\n", "generated_code": "MOD = 10**9 + 7\nn, l, r = map(int, input().split())\np = l + r + 1\nr = n - l\nif n % 3 == 0:\n\tprint(0)\nelse:\n\tx = p//4\n\tprint(p//3 * (2*x + 1) % MOD)\n", "score": 0.0, "codebleu": 0.07733263119983194, "crystalbleu": 0.01, "codebertscore": 0.71, "codescore": 0.08946584910154343, "surfaceSim": 0.4761951092949342, "abs_surfaceSim_minus_score": 0.4761951092949342, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0839_12", "golden_code": "import sys, itertools\n\nf = sys.stdin\ng = []\nfor i in range(5):\n    g.append( [int(u) for u in f.readline().strip().split()] )\n\n\np_all = itertools.permutations(list(range(5)))\nmax_S = 0\nfor p in p_all:\n    S = g[p[0]][p[1]] + g[p[1]][p[0]] + g[p[2]][p[3]] + g[p[3]][p[2]] \n    S += g[p[1]][p[2]] + g[p[2]][p[1]] + g[p[3]][p[4]] + g[p[4]][p[3]]\n    S += g[p[2]][p[3]] + g[p[3]][p[2]] + g[p[3]][p[4]] + g[p[4]][p[3]]\n    max_S = max(S, max_S)\n\nprint(max_S)\n", "generated_code": "s = input()\nres = 0\ni = 0\nwhile i < len(s):\n\tj = i\n\tsm = 0\n\twhile j < len(s) and s[j] =='':\n\t\tsm += 1\n\t\tj += 1\n\tsm -= 1\n\tres += sm\n\ti += 1\nprint(res)\n", "score": 0.0, "codebleu": 0.04692637591551467, "crystalbleu": 0.0, "codebertscore": 0.65, "codescore": 0.39254844188690186, "surfaceSim": 0.3587860988742046, "abs_surfaceSim_minus_score": 0.3587860988742046, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_4494_38_OP_1", "golden_code": "print('ARC' if input()!='ARC' else 'ABC')", "generated_code": "response = input()\nprint('ABC' if response == 'ARC' else 'ARC')", "score": 1.0, "codebleu": 0.3887215631492199, "crystalbleu": 0, "codebertscore": 0.92, "codescore": 0.770137369632721, "surfaceSim": 0.6190476190476191, "abs_surfaceSim_minus_score": 0.38095238095238093, "source": "local", "local_type": "OP"}
{"id": "APPS_test-0531_4", "golden_code": "n=int(input().strip())\nl=[int(x) for x in input().strip().split()]\nif len(set(l))==1:\n  print(n)\n  print(*l)\n  return\nl.sort()\nf=[0]*3\ns=list(set(l))\ns.sort()\nif len(s)==2 and s[1]-s[0]==1:\n    print(n)\n    print(*l)\n    return\nif len(s)==2:\n    s.append(s[-1])\n    s[1]=(s[0]+1)\nfor i in range(3):\n    f[i]=l.count(s[i])\nif f[1]>(min(f[0],f[2])*2):\n    ans=f[1] - f[1]%2 \n    ans=n-ans\n    flag=0\n    if f[1]%2==1:\n        flag=1 \n    f[0]+=(f[1]//2)\n    f[2]+=(f[1]//2)\n    f[1]=flag\n    print(ans)\n    for i in range(3):\n        print((str(s[i])+\" \")*f[i],end=\"\")\nelse:    \n    ans=f[1]+max(f[0],f[2])-min(f[0],f[2])\n    f[1]+=(min(f[0],f[2])*2)\n    f[0],f[2]=f[0]-min(f[0],f[2]),f[2]-min(f[0],f[2])\n    print(ans)\n    for i in range(3):\n        print((str(s[i])+\" \")*f[i],end=\"\")\n    print(\"\")", "generated_code": "from bisect import bisect_left\n\nn = int(input())\nx = [int(i) for i in input().split()]\nans = []\nfor i in range(n):\n\tans.append(x[bisect_left(x, x[i])])\n\nprint(len(ans))\nprint(*ans)\n", "score": 0.134, "codebleu": 0.09736747998677901, "crystalbleu": 0.0, "codebertscore": 0.7, "codescore": 0.08056037127971649, "surfaceSim": 0.36579882894186533, "abs_surfaceSim_minus_score": 0.23179882894186532, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-2422_27", "golden_code": "# map(int, input().split())\nrw = int(input())\nfor wewq in range(rw):\n    n = int(input())\n    a = 0\n    b = 0\n    c = 0\n    if n % 3 == 0:\n        print(n // 3, 0, 0)\n    elif n % 3 == 1:\n        if n // 3 - 2 < 0:\n            print(-1)\n            continue\n        print(n // 3 - 2, 0, 1)\n    elif n % 3 == 2:\n        if n // 3 - 1 < 0:\n            print(-1)\n            continue\n        print(n // 3 - 1, 1, 0)\n\n", "generated_code": "for _ in range(int(input())):\n\tn = int(input())\n\tif n % 3!= 0:\n\t\tprint(-1)\n\telif n == 0:\n\t\tpass\n\telse:\n\t\tprint(n, n // 3, n // 3)\n", "score": 0.6176, "codebleu": 0.1509028661692973, "crystalbleu": 0.11, "codebertscore": 0.81, "codescore": 0.4301505386829376, "surfaceSim": 0.7233201581027668, "abs_surfaceSim_minus_score": 0.1057201581027668, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_11_5", "golden_code": "def lcm(x, y):\r\n   if x > y:\r\n       z = x\r\n   else:\r\n       z = y\r\n   while(True):\r\n       if((z % x == 0) and (z % y == 0)):\r\n           lcm = z\r\n           break\r\n       z += 1\r\n   return lcm", "generated_code": "def lcm(*args):\n\tm = 1\n\tfor i in args:\n\t\tm *= i\n\treturn m", "score": 0.5463, "codebleu": 0.08059104539565444, "crystalbleu": 0, "codebertscore": 0.71, "codescore": 0.2186414748430252, "surfaceSim": 0.5461769759450171, "abs_surfaceSim_minus_score": 0.00012302405498287872, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_16_2", "golden_code": "def div_of_nums(nums,m,n):\r\n result = list(filter(lambda x: (x % m == 0 and x % n == 0), nums)) \r\n return result", "generated_code": "def div_of_nums(nums,m,n):\n\treturn [i for i in nums if i%m == 0 and i%n == 0]", "score": 1.0, "codebleu": 0.21375944099051247, "crystalbleu": 0, "codebertscore": 0.88, "codescore": 0.9935664534568787, "surfaceSim": 0.6741071428571428, "abs_surfaceSim_minus_score": 0.3258928571428572, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-4183_15", "golden_code": "from math import *\n\nN=int(input())\nT=list(int(input()) for _ in range(N))\nans=T[0]\nfor i in range(1,N):\n  ans=ans*T[i]//gcd(ans,T[i])\nprint(ans)\n", "generated_code": "def main():\n\timport sys\n\tinput = sys.stdin.readline\n\t\n\tN = int(input())\n\tT = list(map(int, input().split()))\n\t\n\th = T[0]\n\tfor i in range(1, N):\n\t\tif h == 0:\n\t\t\th = T[i]\n\t\telse:\n\t\t\th -= 1\n\t\t\th = h * 2\n\t\t\t\n\tif h == 0 or h == 1:\n\t\tprint(0)\n\telse:\n\t\tprint((h + 1) * 2)\n\t\nmain()\n", "score": 0.0, "codebleu": 0.24353776644943453, "crystalbleu": 0.16, "codebertscore": 0.79, "codescore": 0.1188761368393898, "surfaceSim": 0.5088807785888079, "abs_surfaceSim_minus_score": 0.5088807785888079, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_MBPP_315_MUT_2", "golden_code": "import os\n\ndef find_Max_Len_Even(str):\n    n = len(str)\n    i = 0\n    currlen = 0\n    maxlen = 0\n    st = -1\n    while i < n:\n        if str[i] == ' ':\n            if currlen % 2 == 0:\n                if maxlen < currlen:\n                    maxlen = currlen\n                    st = i - currlen\n            currlen = 0\n        else:\n            currlen += 1\n        i += 1\n    if currlen % 2 == 0:\n        if maxlen < currlen:\n            maxlen = currlen\n            st = i - currlen\n    if st == -1:\n        return '-1'\n    return str[st:st + maxlen]", "generated_code": "import os\n\ndef find_Max_Len_Even(str):\n    n = len(str)\n    i = 0\n    currlen = 0\n    maxlen = 0\n    st = -1\n    while i < n:\n        if str[i] == ' ':\n            if currlen % 2 == 0:\n                if maxlen < currlen:\n                    maxlen = currlen\n                    st = i - currlen\n            currlen = 0\n        else:\n            currlen += 1\n        i += 1\n    if currlen % 2 == 0:\n        if maxlen < currlen:\n            maxlen = currlen\n            st = i - currlen\n    if st == 1:\n        return '-1'\n    return str[st:st + maxlen]", "score": 0.3145, "codebleu": 0.9668381183704394, "crystalbleu": 0.97, "codebertscore": 1.0, "codescore": 0.9936409592628479, "surfaceSim": 0.9990958408679927, "abs_surfaceSim_minus_score": 0.6845958408679927, "source": "local", "local_type": "MUT"}
{"id": "MBPP_11_22", "golden_code": "def lcm(x, y):\r\n   if x > y:\r\n       z = x\r\n   else:\r\n       z = y\r\n   while(True):\r\n       if((z % x == 0) and (z % y == 0)):\r\n           lcm = z\r\n           break\r\n       z += 1\r\n   return lcm", "generated_code": "def lcm(x, s1):\n\twhile s1 <= x:\n\t\ts1 += x,\n\treturn s1", "score": 0.2812, "codebleu": 0.09838238191836887, "crystalbleu": 0, "codebertscore": 0.76, "codescore": 0.06952790915966034, "surfaceSim": 0.5670103092783505, "abs_surfaceSim_minus_score": 0.2858103092783505, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_142_MUT_3", "golden_code": "import os\n\ndef sum_squares(lst):\n    result = []\n    for i in range(len(lst)):\n        if i % 3 == 0:\n            result.append(lst[i] ** 2)\n        elif (i % 4 == 0 and i % 3 != 0):\n            result.append(lst[i] ** 3)\n        else:\n            result.append(lst[i])\n    return sum(result)", "generated_code": "import os\n\ndef sum_squares(lst):\n    result = []\n    for i in range(len(lst)):\n        if i % 3 == 0:\n            result.append(lst[i] ** 2)\n        elif (i * 4 == 0 and i % 3 != 0):\n            result.append(lst[i] ** 3)\n        else:\n            result.append(lst[i])\n    return sum(result)", "score": 0.4655, "codebleu": 0.9666069517141741, "crystalbleu": 0.96, "codebertscore": 0.99, "codescore": 0.9936661124229431, "surfaceSim": 0.9810462919225319, "abs_surfaceSim_minus_score": 0.5155462919225319, "source": "local", "local_type": "MUT"}
{"id": "MBPP_31_22", "golden_code": "def smallest_multiple(n):\r\n    if (n<=2):\r\n      return n\r\n    i = n * 2\r\n    factors = [number  for number in range(n, 1, -1) if number * 2 > n]\r\n    while True:\r\n        for a in factors:\r\n            if i % a != 0:\r\n                i += n\r\n                break\r\n            if (a == factors[-1] and i % a == 0):\r\n                return i", "generated_code": "def smallest_multiple(n):    \n\treturn min(2**n for n in range(18, 0, -1))", "score": 0.104, "codebleu": 0.0481303852771902, "crystalbleu": 0, "codebertscore": 0.75, "codescore": 0.12624412775039673, "surfaceSim": 0.5049853372434018, "abs_surfaceSim_minus_score": 0.4009853372434018, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_142_1", "golden_code": "import math\r\ndef surfacearea_sphere(r):\r\n  surfacearea=4*math.pi*r*r\r\n  return surfacearea", "generated_code": "import math\ndef surfacearea_sphere(r):\n\treturn round(math.pow(r,3))\nns = [\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\"]\ns = [\"a','b','c\",\"d','e','f','g','h','i','j','k','l','m','n\",\"o','p','q','r','s','t','u','v','w','x','y','z\"]", "score": 0.0873, "codebleu": 0.4146078508150428, "crystalbleu": 0, "codebertscore": 0.69, "codescore": 0.038805775344371796, "surfaceSim": 0.48825571895424835, "abs_surfaceSim_minus_score": 0.40095571895424836, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-1717_14", "golden_code": "import sys,collections as cl,bisect as bs\nsys.setrecursionlimit(100000)\ninput = sys.stdin.readline\nmod = 10**9+7\nMax = sys.maxsize\ndef l(): #intのlist\n    return list(map(int,input().split()))\ndef m(): #複数文字\n    return map(int,input().split())\ndef onem(): #Nとかの取得\n    return int(input())\ndef s(x): #圧縮\n    a = []\n    if len(x) == 0:\n        return []\n    aa = x[0]\n    su = 1\n    for i in range(len(x)-1):\n        if aa != x[i+1]:\n            a.append([aa,su])\n            aa = x[i+1]\n            su = 1\n        else:\n            su += 1\n    a.append([aa,su])\n    return a\ndef jo(x): #listをスペースごとに分ける\n    return \" \".join(map(str,x))\ndef max2(x): #他のときもどうように作成可能\n    return max(map(max,x))\ndef In(x,a): #aがリスト(sorted)\n    k = bs.bisect_left(a,x)\n    if k != len(a) and a[k] ==  x:\n        return True\n    else:\n        return False\n\ndef pow_k(x, n):\n    ans = 1\n    while n:\n        if n % 2:\n            ans *= x\n        x *= x\n        n >>= 1\n    return ans\n\n\"\"\"\ndef nibu(x,n,r):\n    ll = 0\n    rr = r\n    while True:\n        mid = (ll+rr)//2\n\n    if rr == mid:\n        return ll\n    if (ここに評価入れる):\n        rr = mid\n    else:\n        ll = mid+1\n\"\"\"\n\nimport math\nfrom functools import reduce\ndef gcd(*numbers):\n    return reduce(math.gcd, numbers)\n\ndef gcd_list(numbers):\n    return reduce(math.gcd, numbers)\ndef lcm_base(x, y):\n    return (x * y) // math.gcd(x, y)\n\ndef lcm(*numbers):\n    return reduce(lcm_base, numbers, 1)\n\ndef lcm_list(numbers):\n    return reduce(lcm_base, numbers, 1)\n\n\nn = onem()\n\nans = 1\n\nfor i in range(1,n+1):\n    ans = lcm(ans,i)\nprint(ans+1)", "generated_code": "def main():\n\tmod=10**15\n\tn=int(input())\n\tres=0\n\twhile mod>0:\n\t\tmod=mod//2\n\t\tres+=mod\n\tprint(res)\ndef __starting_point():\n\tmain()\n__starting_point()\n", "score": 0.0, "codebleu": 0.05696028613887819, "crystalbleu": 0.0, "codebertscore": 0.61, "codescore": 0.05200136452913284, "surfaceSim": 0.41085217870932156, "abs_surfaceSim_minus_score": 0.41085217870932156, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_extra_p03037_s012458960_OP_1", "golden_code": "n,m=list(map(int,input().split()))\n\nc=[0]*(n+2)\n\nfor i in range(m):\n\n  l,r=list(map(int,input().split()))\n\n  c[l-1]+=1\n\n  c[r]-=1\n\nfor i in range(1,n+2):\n\n  c[i]=c[i]+c[i-1]\n\nans=0\n\nfor i in range(n+2):\n\n  if c[i]==m:\n\n    ans+=1\n\nprint(ans)", "generated_code": "n,m=list(map(int,input().split()))\n\nl,r=list(map(int,input().split()))\n\nfor i in range(m-1):\n\n  tl,tr=list(map(int,input().split()))\n\n  if l<tl:\n\n    l=tl\n\n  if tr<r:\n\n    r=tr\n\nprint((max(r-l+1,0)))", "score": 1.0, "codebleu": 0.2118312531149506, "crystalbleu": 0.23, "codebertscore": 0.87, "codescore": 0.2710883617401123, "surfaceSim": 0.598863431354862, "abs_surfaceSim_minus_score": 0.401136568645138, "source": "local", "local_type": "OP"}
{"id": "APPS_test-0267_8", "golden_code": "\n\n\nl, r, k =list(map(int,input().split()))\n\nd = {i:2**i for i in range(10)}\n\ncache = {}\n\ndef can(i, m):\n    return d[i] & m\n\ndef calc(m):\n    b = 1\n    c = 0\n    for i in range(10):\n        if b & m:\n            c += 1\n        b *= 2\n\n    return c\n\ndef sm(ln, k, m, s='', first=False):\n    if ln < 1:\n        return 0, 1\n\n    if (ln, k, m, s, first) in cache:\n        return cache[(ln, k, m, s, first)]\n\n    ans = 0\n    count = 0\n    base = 10 ** (ln-1)\n\n    use_new = calc(m) < k\n\n    if s:\n        finish = int(s[0])+1\n    else:\n        finish = 10\n\n    for i in range(finish):\n        if use_new or can(i, m):\n            ss = s[1:]\n            if i != finish-1:\n                ss = ''\n            nm = m | d[i]\n            nfirst = False\n            if i == 0 and first:\n                nm = m\n                nfirst = True\n            nexta, nextc = sm(ln-1, k, nm, ss, nfirst)\n            ans += base * i * nextc + nexta\n            count += nextc\n\n#    print(ln, k, m, s, first, ans, count)\n    cache[(ln, k, m, s, first)] = (ans, count)\n\n    return ans, count\n\ndef call(a, k):\n    s = str(a)\n    return sm(len(s), k, 0, s, True)[0]\n\n\n#print(call(r, k) - call(l-1, k))\nprint((call(r, k) - call(l-1, k)) % 998244353)\n", "generated_code": "def main():\n\tl, r, k = list(map(int, input().split()))\n\tmod = 998244353\n\tp = 10 ** 18\n\tprint(mid(l + r, k) - mid(l, d) + mid(r, d) - mid(q, d) + (q % mod - 998244353) for d in range(9))\n\n\ndef mid(x, y):\n\treturn (x % mod - 9\t\t\t\t\t\t(y % mod - 9) // 4) % mod\n\n\ndef __starting_point():\n\tmain()\n\n__starting_point()\n", "score": 0.0, "codebleu": 0.09784669072761684, "crystalbleu": 0.03, "codebertscore": 0.69, "codescore": 0.055234067142009735, "surfaceSim": 0.5032978638609915, "abs_surfaceSim_minus_score": 0.5032978638609915, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_43_97", "golden_code": "def is_Two_Alter(s):  \r\n    for i in range (len( s) - 2) : \r\n        if (s[i] != s[i + 2]) : \r\n            return False\r\n    if (s[0] == s[1]): \r\n        return False\r\n    return True", "generated_code": "def is_Two_Alter(s): \n\treturn s[-1] == s[:-1]", "score": 0.8098, "codebleu": 0.07680402348258573, "crystalbleu": 0, "codebertscore": 0.77, "codescore": 0.9664733409881592, "surfaceSim": 0.5477548111190307, "abs_surfaceSim_minus_score": 0.2620451888809693, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_76_31", "golden_code": "def word_len(s): \r\n    s = s.split(' ')   \r\n    for word in s:    \r\n        if len(word)%2==0: \r\n            return True  \r\n        else:\r\n          return False", "generated_code": "def word_len(word):\n\treturn sum(1 for c in word if c.isspace() or c in \"\\n\")", "score": 0.3625, "codebleu": 0.08777729900491, "crystalbleu": 0, "codebertscore": 0.74, "codescore": 0.5662935972213745, "surfaceSim": 0.562111801242236, "abs_surfaceSim_minus_score": 0.19961180124223604, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-4094_14", "golden_code": "k = int(input())\nn = 7\nn = n%k\nj = 0\ni = 1\nif k % 2 == 0 or k % 5 == 0:\n    print(-1)\n    return\nif n == 0:\n    print(i)\n    return\nwhile n != 0:\n    j = n\n    n = (n*10 + 7) % k \n    if j == n:\n        print(-1)\n        return\n    i += 1\n\nprint(i)", "generated_code": "\ndef main(K):\n\tfor i in range(K):\n\t\twhile True:\n\t\t\tif not i % K:\n\t\t\t\treturn i + 1\n\treturn -1\n\nK = int(input())\nprint(main(K))\n", "score": 0.0, "codebleu": 0.10311169202739727, "crystalbleu": 0, "codebertscore": 0.75, "codescore": 0.16388827562332153, "surfaceSim": 0.5498271889400921, "abs_surfaceSim_minus_score": 0.5498271889400921, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_68_34", "golden_code": "def subset(ar, n): \r\n    res = 0\r\n    ar.sort() \r\n    for i in range(0, n) : \r\n        count = 1\r\n        for i in range(n - 1): \r\n            if ar[i] == ar[i + 1]: \r\n                count+=1\r\n            else: \r\n                break \r\n        res = max(res, count)  \r\n    return res ", "generated_code": "def subset(ar, n): \n\treturn sum(n in ar[i:] for i in range(1, n+1))\nss = []\nfor i in range(-1,2000000):\n\tss.append(i)\nss = ss[::-1]", "score": 0.0036, "codebleu": 0.1539441363062592, "crystalbleu": 0, "codebertscore": 0.76, "codescore": 0.1066431999206543, "surfaceSim": 0.6312316715542523, "abs_surfaceSim_minus_score": 0.6276316715542523, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-1965_41", "golden_code": "t = int(input())\nfor _ in range(t):\n    n, x = map(int, input().split())\n    a = list(map(int, input().split()))\n    f=True\n    g=False\n    s=0\n    for i in range(n):\n        if a[i]==x:\n            g=True\n        if a[i]!=x:\n            f=False\n        s+=a[i]-x\n    if f:\n        print(0)\n    elif s==0:\n        print(1)\n    else:\n        if g:\n            print(1)\n        else:\n            print(2)", "generated_code": "t=int(input())\nfor i in range(t):\n\tn,x=map(int,input().split())\n\ta=list(map(int, input().split()))\n\tm=max(a)\n\td=a.count(m)\n\tfor i in range (d):\n\t\ta[i]=m-a[i]\n\tc=0\n\tfor i  in range(n):\n\t\tif a[i]<=x:\n\t\t\tc+=1\n\tprint(c)\n", "score": 0.697, "codebleu": 0.318926358215119, "crystalbleu": 0.35, "codebertscore": 0.86, "codescore": 0.6072613596916199, "surfaceSim": 0.8061962912709182, "abs_surfaceSim_minus_score": 0.10919629127091823, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_60_43", "golden_code": "def check_element(test_tup, check_list):\r\n  res = False\r\n  for ele in check_list:\r\n    if ele in test_tup:\r\n      res = True\r\n      break\r\n  return (res) ", "generated_code": "def check_element(testStr, num):\n\tif len(testStr) > 2:\n\t\tfor i in range(len(testStr)-1):\n\t\t\tif testStr[i] == num:\n\t\t\t\treturn True\n\treturn False", "score": 0.3376, "codebleu": 0.16044376762428697, "crystalbleu": 0, "codebertscore": 0.78, "codescore": 0.1279309093952179, "surfaceSim": 0.5422077922077921, "abs_surfaceSim_minus_score": 0.20460779220779213, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_extra_p03371_s168362535_OP_1", "golden_code": "inf = (5000 * 10 ** 5) * 3\n\n\n\na, b, c, x, y = list(map(int, input().split()))\n\n\n\nret = inf\n\nfor cnt_ab in range(max(x, y) * 2 + 1):\n\n    d = cnt_ab // 2\n\n\n\n    cnt_a = max(0, x - d)\n\n    cnt_b = max(0, y - d)\n\n\n\n    t = cnt_ab * c + cnt_a * a + cnt_b * b\n\n    ret = min(ret, t)\n\nprint(ret)\n", "generated_code": "def main():\n\n    A, B, AB, X, Y = list(map(int, input().split()))\n\n    M = max(X, Y)\n\n\n\n    k = 0\n\n    ans = A * X + B * Y\n\n    while True:\n\n        ans = min(\n\n            ans,\n\n            AB * k * 2 + max(0, X - k) * A + max(0, Y - k) * B\n\n        )\n\n\n\n        if k >= M: break\n\n        k += 1\n\n\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 1.0, "codebleu": 0.22043209458642726, "crystalbleu": 0.14, "codebertscore": 0.8, "codescore": 0.019528618082404137, "surfaceSim": 0.5728519391472038, "abs_surfaceSim_minus_score": 0.4271480608527962, "source": "local", "local_type": "OP"}
{"id": "LOCAL_APPS_13_1_MUT_19", "golden_code": "import sys\n\ndef main():\n    \n    (n, k) = map(int, sys.stdin.readline().split())\n    courses = list(map(int, sys.stdin.readline().split()))\n    courses = [x - 1 for x in courses]\n    \n    visited = [False] * n\n    used = [False] * n\n    \n    ans = []\n    t = []\n    \n    for i in range(n):\n        temp = list(map(int, sys.stdin.readline().split()))\n        temp = [x - 1 for x in temp]\n        t.append(temp[1:])\n    \n    for i in range(k):\n        c = courses[i]\n        if used[c]:\n            continue\n        \n        q = [c]\n        visited[c] = True\n        while len(q) > 0:\n            cur = q[-1]\n            if len(t[cur]) != 0:\n                s = t[cur].pop()\n                if (visited[s] and not (used[s])):\n                    print(-1)\n                    return\n                if used[s]:\n                    continue\n                q.append(s)\n                visited[s] = True\n            else:\n                ans.append(cur)\n                q.pop()\n                used[cur] = True\n    \n    ans = [str(x + 1) for x in ans]\n    print(len(ans))\n    print(' '.join(ans))\n\nmain()", "generated_code": "import sys\n\ndef main():\n    \n    (n, k) = map(int, sys.stdin.readline().split())\n    courses = list(map(int, sys.stdin.readline().split()))\n    courses = [x - 1 for x in courses]\n    \n    visited = [False] * n\n    used = [False] * n\n    \n    ans = []\n    t = []\n    \n    for i in range(n):\n        temp = list(map(int, sys.stdin.readline().split()))\n        temp = [x - 1 for x in temp]\n        t.append(temp[1:])\n    \n    for i in range(k):\n        c = courses[i]\n        if used[c]:\n            continue\n        \n        q = [c]\n        visited[c] = True\n        while len(q) > 0:\n            cur = q[-1]\n            if not (len(t[cur]) != 0):\n                s = t[cur].pop()\n                if (visited[s] and not (used[s])):\n                    print(-1)\n                    return\n                if used[s]:\n                    continue\n                q.append(s)\n                visited[s] = True\n            else:\n                ans.append(cur)\n                q.pop()\n                used[cur] = True\n    \n    ans = [str(x + 1) for x in ans]\n    print(len(ans))\n    print(' '.join(ans))\n\nmain()", "score": 0.0, "codebleu": 0.9688185060813436, "crystalbleu": 0.97, "codebertscore": 1.0, "codescore": 0.9938481450080872, "surfaceSim": 0.9977396021699819, "abs_surfaceSim_minus_score": 0.9977396021699819, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-2531_36", "golden_code": "def bin_search(A, val):\r\n    l=0;    flag=0\r\n    r=len(arr)-1\r\n    while l<r: \r\n        #print(l, r)\r\n        if ((A[l] + A[r])== 2*val): \r\n            flag+=1\r\n            break\r\n        elif (A[l] + A[r] < 2*val): \r\n            l += 1\r\n        elif(A[l]+ A[r]>2*val) :\r\n            r -= 1\r\n    return flag\r\n\r\n\r\nn=int(input())\r\narr=[]\r\nfor i in range(n):\r\n    x=int(input())\r\n    arr.append(x)\r\n    \r\ncnt=0\r\narr.sort()\r\n#print(arr)\r\nfor i in range(n):\r\n    x=bin_search(arr, arr[i])\r\n    if(x==1):\r\n        cnt+=1\r\nprint(cnt)", "generated_code": "# cook your dish here\nn=int(input())\ns=0\nfor _ in range(n):\n\ta=int(input().strip())\n\tif a==s:\n\t\tprint(a)\n\telse:\n\t\ts=s-a+1\n\t\ta=a-1\n\t\ts=sum(range(1,a+1))\n\t\ts=int(s/2)\n\t\tprint(s)\n", "score": 0.0353, "codebleu": 0.14554121540318435, "crystalbleu": 0.04, "codebertscore": 0.68, "codescore": 0.3018948435783386, "surfaceSim": 0.5347275031685679, "abs_surfaceSim_minus_score": 0.4994275031685679, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-1329_20", "golden_code": "N=int(input())\n\n\n\nfrom operator import mul\nfrom functools import reduce\n\ndef cmb(n,r):\n    r = min(n-r,r)\n    if r == 0: return 1\n    over = reduce(mul, list(range(n, n - r, -1)))\n    under = reduce(mul, list(range(1,r + 1)))\n    return over // under\n\n\nfrom collections import defaultdict\ndef factorization(n):\n    arr = []\n    temp = n\n    for i in range(2, int(-(-n**0.5//1))+1):\n        if temp%i==0:\n            cnt=0\n            while temp%i==0:\n                cnt+=1\n                temp //= i\n            arr.append([i, cnt])\n\n    if temp!=1:\n        arr.append([temp, 1])\n\n    if arr==[]:\n        arr.append([n, 1])\n\n    return arr\n\ncount=1\nD=defaultdict(int)\nfor i in range(1,N+1):\n    f=factorization(i)\n    for t in f:\n        num,con=t\n        D[num]+=con\nthrees=0\nfives=0\nnum_15=0\nnum_25=0\nnum_75=0\n\nfor v in list(D.values()):\n    if v>=2:\n        threes+=1\n    if v>=4:\n        fives+=1\n    if v>=14:\n        num_15+=1\n    if v>=24:\n        num_25+=1\n    if v>=74:\n        num_75+=1\n#3*5*5\nans=(threes-fives)*fives*(fives-1)//2\nif fives>=3:\n    #ans+=cmb(fives, 3)\n    ans+=fives*(fives-1)*(fives-2)//2\n#75*1\n\nans+=num_75\n#5*15\n\nans+=num_15*(fives-1)\n#3*25\nans+=num_25*(threes-1)\nprint(ans)\n#print(D)\n#print(threes, fives, num_15, num_25, num_75)\n#print(factorization(32400))\n", "generated_code": "import math\nN = int(input())\nt = set()\nfor i in range(2, N+1):\n\tif N % i == 0:\n\t\tt.add(i)\n\t\tt.update([i, N//i])\nF = list(t)\nM = [0]*(N+1)\nfor i in t:\n\tM[i] = N//i\nfor i in M:\n\tif M[i] == i:\n\t\tN -= i\nprint((N+1)*N)\n", "score": 0.0, "codebleu": 0.10467838876348634, "crystalbleu": 0.02, "codebertscore": 0.7, "codescore": 0.0879581868648529, "surfaceSim": 0.5450834257960517, "abs_surfaceSim_minus_score": 0.5450834257960517, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_extra_p02952_s443742997_OP_1", "golden_code": "n_str = eval(input())\n\nn_int = int(n_str)\n\n# 1 ~ 50000\n\n# 桁数が奇数= 1桁, 3桁, 5桁\n\n# 1 ~ 9, 100 ~ 999,10000 ~ 99999の90909個しかないので全探索いけるか?\n\nexs_list = []\n\nfor i in range(1, 100000):\n\n    if len(str(i)) % 2 == 1:\n\n        exs_list.append(i)\n\n\n\nexs = {i: i for i in exs_list}\n\n\n\nn_s = []\n\nans = 0\n\nfor i in range(1, n_int + 1):\n\n    if len(str(i)) % 2 == 0:\n\n        continue\n\n    if i in exs:\n\n        ans += 1\n\n\n\nprint(ans)\n\n\n\n\n\n\n\n\n\n\n", "generated_code": "def digit_sum(n):\n\n    # 各桁の和を求める\n\n    # 計算量: O(logN)\n\n    ans = 0\n\n    while n > 0:\n\n        ans += 1\n\n        n //= 10\n\n    return ans\n\n\n\nn = int(eval(input()))\n\ncnt = 0\n\n\n\nfor i in range(1, n+1):\n\n    cnt += digit_sum(i) % 2\n\n\n\nprint(cnt)\n", "score": 1.0, "codebleu": 0.1753498778239344, "crystalbleu": 0.1, "codebertscore": 0.75, "codescore": 0.9303151369094849, "surfaceSim": 0.5524121741945929, "abs_surfaceSim_minus_score": 0.4475878258054071, "source": "local", "local_type": "OP"}
{"id": "APPS_test-1424_27", "golden_code": "def byte_v(a, n):\n    ans = []\n    while a != 0:\n        ans.append(a % 2)\n        a //= 2\n    ans.reverse()\n    \n    ans = (n - len(ans))  * [0] + ans\n\n    return ans\n\n\nn, m, k = map(int, input().split())\nplayers = []\nfor i in range(m + 1):\n    curr_army = int(input())\n    players.append(list(byte_v(curr_army, n)))\nphill = players[-1]\nans = 0\nfor i in range(m):\n    curr = 0\n    \n    for j in range(n):\n        if phill[j] != players[i][j]:\n            curr += 1\n    if curr <= k:\n        ans += 1\nprint(ans)", "generated_code": "#r):\n#m = int(input())\n#n = int(input());\n#a = list(map(int, input().split()))\n\n#np = [[0 for i in range(100)] for j in range(100)].\n\n#for i in range(m):\n#\tts = input()\n#\tts +=''\n#\tnp[i][0] = len(ts)\n\n#for v in np:\n#\tprint (v)\n\n#tp = [0 for i in xrange(100)]\n#for i v in range(100):\n#\ttp[i] += ([x^(1<<v) for x in a[i:j+1]] if i<j else [])\n\n#np.intans = [int(x) for x in tp]\n\n#print (tp)\n\n#c = 0\n", "score": 0.0, "codebleu": 0.2699571928457978, "crystalbleu": 0, "codebertscore": 0.76, "codescore": 0.01995779201388359, "surfaceSim": 0.16728840508806264, "abs_surfaceSim_minus_score": 0.16728840508806264, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_14_13", "golden_code": "def sum_even_odd(list1):\r\n    first_even = next((el for el in list1 if el%2==0),-1)\r\n    first_odd = next((el for el in list1 if el%2!=0),-1)\r\n    return (first_even+first_odd)", "generated_code": "def sum_even_odd(list):\n\ts=0\n\tfor i in range(0,len(list)):\n\t\tif i&1:\n\t\t\ts=s+list[i]\n\treturn s\nh=lambda: hex(int(s,16))\nns = lambda x: hex(x)\nm = lambda x,y: x  (x&(1<<y))-1", "score": 0.0255, "codebleu": 0.13005182120010172, "crystalbleu": 0, "codebertscore": 0.77, "codescore": 0.02775418758392334, "surfaceSim": 0.41163793103448276, "abs_surfaceSim_minus_score": 0.38613793103448274, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-1465_33", "golden_code": "n,k=map(int,input().split())\na=list(input())\nans,cnt=list(list()),0\nwhile True :\n\tcur=list()\n\tfor i in range(n-1) :\n\t\tif a[i]=='R' and a[i+1]=='L' :\n\t\t\tcur.append(i)\n\t\t\tcnt+=1\n\tif len(cur)>0:\n\t\tans.append(cur.copy())\n\t\tfor i in cur :\n\t\t\ta[i],a[i+1]=a[i+1],a[i]\n\telse :\n\t\tbreak \nif len(ans)>k or cnt<k:\n\tprint(-1)\nelse :\n\tlst=list()\n\tdumb=k-len(ans)\n\tw,p=0,0\n\twhile dumb>0 :\n\t\tlst.append(\"1 \"+str(ans[w][p]+1)+\"\\n\")\n\t\tdumb-=1\n\t\tp+=1\n\t\tif p==len(ans[w]) :\n\t\t\tp=0\n\t\t\tw+=1\n\t\t\tdumb+=1\n\twhile w<len(ans) :\n\t\tlst.append(str(len(ans[w])-p)+\" \")\n\t\twhile p<len(ans[w]) :\n\t\t\tlst.append(str(ans[w][p]+1)+\" \")\n\t\t\tp+=1\n\t\tlst.append(\"\\n\")\n\t\tw+=1\n\t\tp=0\n\tprint(\"\".join(lst))", "generated_code": "from collections import deque\n\nn, k = map(int, input().split())\narr = deque(input())\n\nfor _ in range(k):\n\tbrr = arr.rotate(1)\n\tif len(arr) > 1:\n\t\tarr.rotate(0)\n\telse:\n\t\tprint(-1)\n\t\tcontinue\n\tl = []\n\twhile arr:\n\t\t(n, k) = arr.popleft()\n\t\tl.append(n)\n\t\tk -= 1\n\t\tif k == 0:\n\t\t\tbreak\n\tr = []\n\tliter = True\n\tfor n in l:\n\t\tif r and r[-1] == n:\n\t\t\tliter = False\n\t\telse:\n\t\t\tr.append(n ** 2)\n\tif notliter:\n\t\tprint(n * 2 - 1)\n\telse :\n\t\tprint(len(r))\n\t\tfor v in r:\n\t\t\tprint(v, end ='')\n\t\tprint()\n", "score": 0.0, "codebleu": 0.1526645051671509, "crystalbleu": 0.09, "codebertscore": 0.74, "codescore": 0.15417486429214478, "surfaceSim": 0.5407153729071537, "abs_surfaceSim_minus_score": 0.5407153729071537, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_MBPP_771_OP_1", "golden_code": "from collections import deque\r\ndef check_expression(exp):\r\n    if len(exp) & 1:\r\n        return False\r\n    stack = deque()\r\n    for ch in exp:\r\n        if ch == '(' or ch == '{' or ch == '[':\r\n            stack.append(ch)\r\n        if ch == ')' or ch == '}' or ch == ']':\r\n            if not stack:\r\n                return False\r\n            top = stack.pop()\r\n            if (top == '(' and ch != ')') or (top == '{' and ch != '}' or (top == '[' and ch != ']')):\r\n                return False\r\n    return not stack", "generated_code": "from collections import deque\ndef check_expression(sequence):\n    if len(sequence) % 2 != 0:\n        return False\n    bracket_map = {')': '(', '}': '{', ']': '['}\n    stack = deque()\n    for char in sequence:\n        if char in bracket_map.values():\n            stack.append(char)\n        elif char in bracket_map:\n            if not stack or stack.pop() != bracket_map[char]:\n                return False\n    return not stack", "score": 1.0, "codebleu": 0.2436928778493508, "crystalbleu": 0.23, "codebertscore": 0.83, "codescore": 0.993158757686615, "surfaceSim": 0.6969844357976653, "abs_surfaceSim_minus_score": 0.30301556420233466, "source": "local", "local_type": "OP"}
{"id": "APPS_test-1000_2", "golden_code": "def read_nums():\n    return [int(x) for x in input().split()]\n\n\ndef main():\n    n, v = read_nums()\n    res = 0\n    cur_tank = 0\n    for c in range(1, n+1):\n        need_to_by = min(v - cur_tank, n - c - cur_tank)\n        res += need_to_by * c\n        cur_tank += need_to_by\n        cur_tank -= 1\n    print(res)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "generated_code": "n,v=map(int,input().split())\na=[]\nfor i in range(n):\n\ta.append(i+1)\nans=0\ni=0\nwhile i<n:\n\tans+=v\n\tif i<n-1:\n\t\tans+=a[i+1]-a[i]\n\ti+=1\nprint(ans)\n", "score": 0.0024, "codebleu": 0.20619007313217833, "crystalbleu": 0, "codebertscore": 0.75, "codescore": 0.06393907219171524, "surfaceSim": 0.4953775788244453, "abs_surfaceSim_minus_score": 0.49297757882444526, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0018_39", "golden_code": "s=input()\nc=[0]*26\nfor i in s:\n    c[ord(i)-97]+=1\nt=[]\nu=[]\nfor i in s:\n    t.append(i)\n    c[ord(i)-97]-=1\n    while t and sum(c[:(ord(t[-1])-97)])==0:\n        u.append(t.pop())\n        \nprint(''.join(u))      ", "generated_code": "s = input()\n\nbegin = 0\nend = begin + len(s) - 1\nans = \"\"\n\nwhile begin < end:\n\tif s[begin] == s[end]:\n\t\tans += s[begin]\n\t\tbegin += 1\n\t\tend -= 1\n\telse:\n\t\tans += f'{s[begin]}{s[end]}{ans[begin + 1:]}'\n\t\tbegin += 2\n\t\tend -= 2\n\nprint(ans)\n", "score": 0.0844, "codebleu": 0.0942979185320684, "crystalbleu": 0.06, "codebertscore": 0.72, "codescore": 0.03359433636069298, "surfaceSim": 0.47948717948717945, "abs_surfaceSim_minus_score": 0.3950871794871794, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0671_61", "golden_code": "read = lambda: list(map(int, input().split()))\nn = int(input())\na = [i for i in range(1, 1000)]\nb = ''.join(map(str, a))\nprint(b[n - 1])\n", "generated_code": "import sys\n\nn = int(sys.stdin.readline().strip())\nreturn sys.stdout.write(str(n - 1) + '\\n')\n", "score": 0.0, "codebleu": 0.08886580647222998, "crystalbleu": 0, "codebertscore": 0.75, "codescore": 0.14018115401268005, "surfaceSim": 0.4059784497740702, "abs_surfaceSim_minus_score": 0.4059784497740702, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_49_MUT_1", "golden_code": "import os\n\ndef modp(n: int, p: int):\n    ret = 1\n    for i in range(n):\n        ret = (2 * ret) % p\n    return ret", "generated_code": "import os\n\ndef modp(n: int, p: int):\n    ret = 1\n    for i in range(n):\n        ret = (2 / ret) % p\n    return ret", "score": 0.2887, "codebleu": 0.940522989120512, "crystalbleu": 0, "codebertscore": 0.99, "codescore": 0.9936518669128418, "surfaceSim": 0.9400584795321637, "abs_surfaceSim_minus_score": 0.6513584795321636, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_PIE_extra_p03796_s710953077_OP_1", "golden_code": "mod = int(1e9+7)\n\nn = int(eval(input()))\n\n\n\npower = 1\n\nfor i in range(1, n+1):\n\n    power = power * i % mod\n\nprint(power)", "generated_code": "import sys\n\n\n\nMOD = 10 ** 9 + 7\n\nn = int(sys.stdin.readline().rstrip())\n\n\n\ndef main():\n\n    res = 1\n\n    for i in range(1, n+1):\n\n        res *= i\n\n        res %= MOD\n\n\n\n    return res\n\n\n\nif __name__ == '__main__':\n\n    ans = main()\n\n    print(ans)", "score": 1.0, "codebleu": 0.3153713093806382, "crystalbleu": 0, "codebertscore": 0.83, "codescore": 0.01826017163693905, "surfaceSim": 0.54502688172043, "abs_surfaceSim_minus_score": 0.45497311827957, "source": "local", "local_type": "OP"}
{"id": "LOCAL_PIE_p02599_s870922238_MUT_147", "golden_code": "import sys\nclass BinaryIndexedTree:\n    def __init__(self, A):\n        self.__n = len(A)\n        self.__node = [0] * (self.__n + 1)\n        self.__data = [0] * (self.__n + 1)\n        S = [0] * (self.__n + 1)\n        for i in range(1, self.__n + 1):\n            S[i] = S[i - 1] + A[i - 1]\n            self.__data[i] = A[i - 1]\n            self.__node[i] = S[i] - S[i - (i & (-i))]\n    def add(self, i, v):\n        self.__data[i] += v\n        while i <= self.__n:\n            self.__node[i] += v\n            i += i & (-i)\n    def sum(self, i):\n        rst = 0\n        while i > 0:\n            rst += self.__node[i]\n            i -= i & (-i)\n        return rst\n    def get(self, i, j):\n        if i == j:\n            return self.__data[i]\n        else:\n            return self.sum(j) - self.sum(i - 1)\ndef main():\n    (N, Q) = map(int, input().split())\n    C = list(map(int, input().split()))\n    P = [[] for _ in range(N)]\n    for (i, c) in enumerate(C):\n        P[c - 1].append(i)\n    right = [0] * N\n    for p in P:\n        if len(p):\n            right[p.pop()] = 1\n    BIT = BinaryIndexedTree(right)\n    query = [[] for _ in range(N)]\n    for (i, s) in enumerate(sys.stdin.readlines()):\n        (l, r) = map(int, s.split())\n        query[r - 1].append((l - 1, i))\n    ans = [None] * Q\n    cur = N - 1\n    for (r, q) in enumerate(reversed(query)):\n        r = (N - 1) - r\n        while q:\n            (l, i) = q.pop()\n            while r < cur:\n                c = C[cur] - 1\n                p = P[c]\n                if len(p):\n                    BIT.add(p.pop() + 1, 1)\n                cur -= 1\n            tmp = BIT.get(l + 1, r + 1)\n            ans[i] = tmp\n    print(sep='\\n', *ans)", "generated_code": "import sys\nclass BinaryIndexedTree:\n    def __init__(self, A):\n        self.__n = len(A)\n        self.__node = [0] * (self.__n + 1)\n        self.__data = [0] * (self.__n + 1)\n        S = [0] * (self.__n + 1)\n        for i in range(1, self.__n + 1):\n            S[i] = S[i - 1] + A[i - 1]\n            self.__data[i] = A[i - 1]\n            self.__node[i] = S[i] - S[i - (i & (-i))]\n    def add(self, i, v):\n        self.__data[i] += v\n        while i <= self.__n:\n            self.__node[i] += v\n            i += i & (-i)\n    def sum(self, i):\n        rst = 0\n        while i > 0:\n            rst += self.__node[i]\n            i -= i & (-i)\n        return rst\n    def get(self, i, j):\n        if i == j:\n            return self.__data[i]\n        else:\n            return self.sum(j) - self.sum(i - 1)\ndef main():\n    (N, Q) = map(int, input().split())\n    C = list(map(int, input().split()))\n    P = [[] for _ in range(N)]\n    for (i, c) in enumerate(C):\n        break\n    right = [0] * N\n    for p in P:\n        if len(p):\n            right[p.pop()] = 1\n    BIT = BinaryIndexedTree(right)\n    query = [[] for _ in range(N)]\n    for (i, s) in enumerate(sys.stdin.readlines()):\n        (l, r) = map(int, s.split())\n        query[r - 1].append((l - 1, i))\n    ans = [None] * Q\n    cur = N - 1\n    for (r, q) in enumerate(reversed(query)):\n        r = (N - 1) - r\n        while q:\n            (l, i) = q.pop()\n            while r < cur:\n                c = C[cur] - 1\n                p = P[c]\n                if len(p):\n                    BIT.add(p.pop() + 1, 1)\n                cur -= 1\n            tmp = BIT.get(l + 1, r + 1)\n            ans[i] = tmp\n    print(sep='\\n', *ans)", "score": 0.0326, "codebleu": 0.9547331852250244, "crystalbleu": 0.98, "codebertscore": 0.99, "codescore": 0.9936850666999817, "surfaceSim": 0.983359116341608, "abs_surfaceSim_minus_score": 0.950759116341608, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-2235_41", "golden_code": "n=int(input())\ntrips=[]\nprix=[0]\nk=0\nj=0\nfor i in range (n):\n    trips.append(int(input()))\n    while trips[i]-trips[j]>=90 :\n        j+=1\n    while trips[i]-trips[k]>=1440:\n        k+=1\n    prix.append(min(min(prix[k]+120,prix[j]+50),prix[-1]+20))\n    print(prix[-1]-prix[-2])\n    \n", "generated_code": "from sys import stdin\ninput = stdin.readline\n\nn = int(input())\n\na = [0]*n\n\nfor i in range(n):\n\tarr = [int(x) for x in input().split()]\n\n\tthis_trip = [arr[0]] + [0]*(((arr[0] - arr[1])//30) + 1) * 2 + [arr[0] + arr[1]]\n\tfor i in range(-2, -n-1, -1):\n\t\tthis_trip[i] = min(this_trip[ i + 1], this_trip[i])\n\tthis_trip.append(0)\n\ta[i] = sum(this_trip)\n\nprint(*a)\n", "score": 0.0, "codebleu": 0.17960609548284256, "crystalbleu": 0.09, "codebertscore": 0.75, "codescore": 0.17366252839565277, "surfaceSim": 0.5086688499325756, "abs_surfaceSim_minus_score": 0.5086688499325756, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_MBPP_541_MUT_22", "golden_code": "import os\n\nimport math\ndef get_sum(n):\n    sum = 0\n    i = 1\n    while i <= math.sqrt(n):\n        if n % i == 0:\n            if n / i == i:\n                sum = sum + i\n            else:\n                sum = sum + i\n                sum = sum + (n / i)\n        i = i + 1\n    sum = sum - n\n    return sum\ndef check_abundant(n):\n    if get_sum(n) > n:\n        return True\n    else:\n        return False", "generated_code": "import os\n\nimport math\ndef get_sum(n):\n    sum = 0\n    i = 1\n    while i <= math.sqrt(n):\n        if n % i == 0:\n            if n / i == i:\n                sum = sum + i\n            else:\n                sum = sum + i\n                sum = sum + (n / i)\n        i = i + 1\n    sum = sum - n\n    return sum\ndef check_abundant(n):\n    if get_sum(n) < n:\n        return True\n    else:\n        return False", "score": 0.0786, "codebleu": 0.9816417084551853, "crystalbleu": 0.94, "codebertscore": 1.0, "codescore": 0.9936891794204712, "surfaceSim": 0.9602915787454441, "abs_surfaceSim_minus_score": 0.8816915787454441, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_PIE_p03553_s305170925_MUT_3", "golden_code": "import math, string, itertools, fractions, heapq, collections, re, array, bisect, sys, random, time, copy, functools\nsys.setrecursionlimit(10 ** 7)\ninf = 10 ** 20\neps = 1.0 / (10 ** 15)\nmod = (10 ** 9) + 7\ndef LI():\n    return [int(x) for x in sys.stdin.readline().split()]\ndef LI_():\n    return [int(x) - 1 for x in sys.stdin.readline().split()]\ndef LF():\n    return [float(x) for x in sys.stdin.readline().split()]\ndef LS():\n    return sys.stdin.readline().split()\ndef I():\n    return int(sys.stdin.readline())\ndef F():\n    return float(sys.stdin.readline())\ndef S():\n    return input()\ndef pf(s):\n    return print(s, flush=True)\ndef divisions(n):\n    sq = int(math.sqrt(n) + 1)\n    d = collections.defaultdict(int)\n    while n % 2 == 0:\n        n //= 2\n        d[2] += 1\n    i = 3\n    while (n > 1 and sq >= i):\n        if n % i == 0:\n            n //= i\n            d[i] += 1else:i += 2\n    if n > 1:\n        d[n] += 1\n    r = [1]\n    for (k, v) in d.items():\n        for c in r[:]:\n            for i in range(1, v + 1):\n                r.append(c * (k ** i))\n    return sorted(r)\ndef main():\n    n = I()\n    a = LI()\n    s = set()\n    for i in range(n, 0, -1):\n        d = divisions(i)\n        ld = len(d)\n        for j in range(1, 2 ** ld):\n            c = []\n            ff = True\n            for k in range(ld):\n                if j & (1 << k):\n                    f = True\n                    for e in c:\n                        if d[k] % e == 0:\n                            f = False\n                            ff = False\n                            break\n                    if f:\n                        c.append(d[k])\n                if not ff:\n                    break\n            if ff:\n                s.add(tuple(c + [n + 1]))\n    b = sorted(list(s), reverse=True)\n    for c in b:\n        t = 0\n        for j in range(1, n + 1):\n            f = False\n            for e in c:\n                if j % e == 0:\n                    f = True\n                    break\n            if f:\n                t += a[j - 1]\n        if t < 0:\n            for j in range(1, n + 1):\n                f = False\n                for e in c:\n                    if j % e == 0:\n                        f = True\n                        break\n                if f:\n                    a[j - 1] = 0\n    return sum(a)\nprint(main())", "generated_code": "import math, string, itertools, fractions, heapq, collections, re, array, bisect, sys, random, time, copy, functools\nsys.setrecursionlimit(10 ** 7)\ninf = 10 * 20\neps = 1.0 / (10 ** 15)\nmod = (10 ** 9) + 7\ndef LI():\n    return [int(x) for x in sys.stdin.readline().split()]\ndef LI_():\n    return [int(x) - 1 for x in sys.stdin.readline().split()]\ndef LF():\n    return [float(x) for x in sys.stdin.readline().split()]\ndef LS():\n    return sys.stdin.readline().split()\ndef I():\n    return int(sys.stdin.readline())\ndef F():\n    return float(sys.stdin.readline())\ndef S():\n    return input()\ndef pf(s):\n    return print(s, flush=True)\ndef divisions(n):\n    sq = int(math.sqrt(n) + 1)\n    d = collections.defaultdict(int)\n    while n % 2 == 0:\n        n //= 2\n        d[2] += 1\n    i = 3\n    while (n > 1 and sq >= i):\n        if n % i == 0:\n            n //= i\n            d[i] += 1else:i += 2\n    if n > 1:\n        d[n] += 1\n    r = [1]\n    for (k, v) in d.items():\n        for c in r[:]:\n            for i in range(1, v + 1):\n                r.append(c * (k ** i))\n    return sorted(r)\ndef main():\n    n = I()\n    a = LI()\n    s = set()\n    for i in range(n, 0, -1):\n        d = divisions(i)\n        ld = len(d)\n        for j in range(1, 2 ** ld):\n            c = []\n            ff = True\n            for k in range(ld):\n                if j & (1 << k):\n                    f = True\n                    for e in c:\n                        if d[k] % e == 0:\n                            f = False\n                            ff = False\n                            break\n                    if f:\n                        c.append(d[k])\n                if not ff:\n                    break\n            if ff:\n                s.add(tuple(c + [n + 1]))\n    b = sorted(list(s), reverse=True)\n    for c in b:\n        t = 0\n        for j in range(1, n + 1):\n            f = False\n            for e in c:\n                if j % e == 0:\n                    f = True\n                    break\n            if f:\n                t += a[j - 1]\n        if t < 0:\n            for j in range(1, n + 1):\n                f = False\n                for e in c:\n                    if j % e == 0:\n                        f = True\n                        break\n                if f:\n                    a[j - 1] = 0\n    return sum(a)\nprint(main())", "score": 0.0, "codebleu": 0.9962096427720554, "crystalbleu": 1.0, "codebertscore": 1.0, "codescore": 0.9916530251502991, "surfaceSim": 0.49978466838931956, "abs_surfaceSim_minus_score": 0.49978466838931956, "source": "local", "local_type": "MUT"}
{"id": "MBPP_50_20", "golden_code": "def mutiple_tuple(nums):\r\n    temp = list(nums)\r\n    product = 1 \r\n    for x in temp:\r\n        product *= x\r\n    return product", "generated_code": "def mutiple_tuple(num):\n\treturn num.count(200)", "score": 0.0479, "codebleu": 0.06737975717283046, "crystalbleu": 0, "codebertscore": 0.78, "codescore": 0.020192068070173264, "surfaceSim": 0.5874015748031496, "abs_surfaceSim_minus_score": 0.5395015748031495, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-1341_15", "golden_code": "a=input()\nb=input()\ni=0\nwhile b:\n    if b[0]==a[i]:i+=1\n    b=b[1:]\nprint(i+1)\n", "generated_code": "a = list(input())\nb = list(input().strip())\nc = [0, 0, 0]\nd = 0\nfor i in range(len(a)):\n\tif a[i] == 'R':\n\t\td += 1\n\telif a[i].count('G') >= 1:\n\t\tc[0] += 1\n\telse:\n\t\tc [0] += 2\n\tif b[i] == a[i]:\n\t\tc[1] += 1\n\nprint(c[0]+c[1])\n", "score": 0.0, "codebleu": 0.2542049526126023, "crystalbleu": 0, "codebertscore": 0.81, "codescore": 0.12711107730865479, "surfaceSim": 0.5956183456183457, "abs_surfaceSim_minus_score": 0.5956183456183457, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-1317_49", "golden_code": "from math import ceil\nn, m = map(int, input().split())\nans = 0\nfor i in range(1, m + 1):\n    for j in range(1, m + 1):\n        if (i ** 2 + j ** 2) % m == 0:\n            ch1, ch2 = ceil((n - i + 1) / m), ceil((n - j + 1) / m)\n            ans += ch1 * ch2\nprint(ans)", "generated_code": "import sys\ninput = sys.stdin.readline\n\nn,m=list(map(int,input().split()))\nANS=n\na,b=1,2\nif n%(a*b)==0:\n\tprint(a*b//2)\n\treturn\n\nfor i in range(1,n//a+1):\n\tif i*a%b==0:\n\t\tANS=ANS-i*a//b\n\t\tbreak\n\t\nif m==1:\n\tprint(\"1\")\n\treturn\nelif m==2:\n\tprint((n-1)*(n**2//5))\n\treturn\nprint(ANS)\n", "score": 0.0, "codebleu": 0.17716491411080154, "crystalbleu": 0.19, "codebertscore": 0.8, "codescore": 0.04675262048840523, "surfaceSim": 0.5771660649819494, "abs_surfaceSim_minus_score": 0.5771660649819494, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_extra_p03434_s231475572_OP_1", "golden_code": "_,s=open(c:=0)\n\nfor a in sorted(map(int,s.split())):c=a-c\n\nprint(c)", "generated_code": "for a in sorted(map(int,[*open(c:=0)][1].split())):c=a-c\n\nprint(c)", "score": 1.0, "codebleu": 0.3132559115813011, "crystalbleu": 0, "codebertscore": 0.92, "codescore": 0.24480101466178894, "surfaceSim": 0.6297678275290215, "abs_surfaceSim_minus_score": 0.3702321724709785, "source": "local", "local_type": "OP"}
{"id": "MBPP_70_45", "golden_code": "def is_abundant(n):\r\n    fctrsum = sum([fctr for fctr in range(1, n) if n % fctr == 0])\r\n    return fctrsum > n", "generated_code": "def is_abundant(n)        :    return abs(n)!= 1", "score": 0.3864, "codebleu": 0.057944429238266856, "crystalbleu": 0, "codebertscore": 0.82, "codescore": 0.4652450978755951, "surfaceSim": 0.5064011379800853, "abs_surfaceSim_minus_score": 0.12000113798008533, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_3723_2_MUT_40", "golden_code": "import functools\n\n\n@functools.lru_cache(maxsize=10000)\ndef factor(n):res = []\n    d = 2\n    while d * d <= n:\n        if n % d == 0:\n            res.append(d)\n            n //= d\n        else:\n            d += 1\n    if n > 1:\n        res.append(n)\n    return set(res)\n\nnum = int(input())\n\npoks = list(map(int, input().split()))[:num]\n\nc = dict()\nfor p in poks:\n    for d in factor(p):\n        if d in c.keys():\n            c[d] += 1\n        else:\n            c[d] = 1\n\nif c:\n    print(max(c.values()))\nelse:\n    print(1)", "generated_code": "import functools\n\n\n@functools.lru_cache(maxsize=10000)\ndef factor(n):res = []\n    d = 2\n    while d * d <= n:\n        if n % d == 0:\n            res.append(d)\n            n //= d\n        else:\n            d += 1\n    if n > 1:\n        res.append(n)\n    return set(res)\n\nnum = int(input())\n\npoks = list(map(int, input().split()))[:num]\n\nc = dict()\nfor p in poks:\n    for d in factor(p):\n        if d in c.keys():\n            c[d] += 1\n        else:\n            c[d] = 1\n\nif c:\n    print(max(c.values()))\nelse:\n    pass", "score": 0.0, "codebleu": 0.9761847837874931, "crystalbleu": 0.97, "codebertscore": 1.0, "codescore": 0.9938479065895081, "surfaceSim": 0.4932692307692308, "abs_surfaceSim_minus_score": 0.4932692307692308, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-1290_46", "golden_code": "from sys import stdin, stdout\nfrom random import randrange\n\nsze = 10 ** 3 + 10\nn, m = map(int, stdin.readline().split())\nvalues = list(map(int, stdin.readline().split()))\ncnt = [0 for i in range(sze)]\nINF = float('inf')\nans = 0\n\nfor v in values:\n    cnt[v] += 1\n    mn = INF\n    \n    for i in range(1, n + 1):\n        mn = min(mn, cnt[i])\n    \n    ans += mn\n    \n    for i in range(1, n + 1):\n        cnt[i] -= mn\n\nstdout.write(str(ans))", "generated_code": "n, m = list(map(int, input().split()))\na = [int(i) for i in input().split()]\nb = []\nfor i in range(n):\n\tb.append([a[i], i])\nb.sort(reverse=True)\nc = [0] * n\nj = 0\nfor i in b:\n\twhile j < n and i[1] < j:\n\t\tc[i[1]] += 1\n\t\tj += 1\n\tj -= 1\nprint(sum(c))\n", "score": 0.1258, "codebleu": 0.134790389312349, "crystalbleu": 0.12, "codebertscore": 0.76, "codescore": 0.06179474666714668, "surfaceSim": 0.5523646071700992, "abs_surfaceSim_minus_score": 0.42656460717009914, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_62_6", "golden_code": "import re\r\ndef num_position(text):\r\n for m in re.finditer(\"\\d+\", text):\r\n    return m.start()", "generated_code": "import re\ndef num_position(text):\n\n\n\treturn len(text.split())", "score": 0.0789, "codebleu": 0.2883067975336743, "crystalbleu": 0, "codebertscore": 0.82, "codescore": 0.06316615641117096, "surfaceSim": 0.7154377880184332, "abs_surfaceSim_minus_score": 0.6365377880184332, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_4169_75_OP_2", "golden_code": "import bisect, collections, copy, heapq, itertools, math, string, sys\ninput = lambda: sys.stdin.readline().rstrip() \nsys.setrecursionlimit(10**7)\nINF = float('inf')\ndef I(): return int(input())\ndef F(): return float(input())\ndef SS(): return input()\ndef LI(): return [int(x) for x in input().split()]\ndef LI_(): return [int(x)-1 for x in input().split()]\ndef LF(): return [float(x) for x in input().split()]\ndef LSS(): return input().split()\n\ndef resolve():\n    N, M = LI()\n    AB = [LI() for _ in range(N)]\n    AB.sort()\n\n    ans = 0\n    for a, b in AB:\n        if M >= b:\n            M -= b\n            ans += a * b\n        else:\n            ans += a * M\n            break\n\n    print(ans)\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "generated_code": "import sys\ninput = lambda: sys.stdin.readline().rstrip()\nsys.setrecursionlimit(10**7)\n\n\ndef resolve():\n    num_items, max_units = map(int, input().split())\n    item_list = [tuple(map(int, input().split())) for _ in range(num_items)]\n    item_list.sort()\n\n    total_value = 0\n    remaining_units = max_units\n    for price_per_unit, units in item_list:\n        if remaining_units >= units:\n            remaining_units -= units\n            total_value += price_per_unit * units\n        else:\n            total_value += price_per_unit * remaining_units\n            break\n\n    print(total_value)\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()\n", "score": 1.0, "codebleu": 0.31693950547829575, "crystalbleu": 0.18, "codebertscore": 0.79, "codescore": 0.2756626009941101, "surfaceSim": 0.7364301827724322, "abs_surfaceSim_minus_score": 0.2635698172275678, "source": "local", "local_type": "OP"}
{"id": "LOCAL_PIE_extra_p03013_s190076821_OP_1", "golden_code": "Mod = 10**9+7\n\nN,M = list(map(int, input().split()))\n\na = [int(eval(input())) for _ in range(M)]\n\nb = [1]*(N+1)\n\nfor j in a:\n\n    b[j] = 0\n\nfor i in range(1,N+1):\n\n    if b[i] == 0:\n\n        continue\n\n    if i == 1:\n\n        b[1] = 1\n\n        continue\n\n    b[i] = b[i-1]+b[i-2]\n\n    if b[i] >= Mod:\n\n        b[i] %= Mod\n\nprint((b[N]))", "generated_code": "# https://atcoder.jp/contests/abc129/submissions/5841482 を参考 \n\nN,M = list(map(int, input().split()))\n\nA = [int(eval(input())) for _ in range(M)]\n\nMOD = 10**9 + 7\n\nF = [1]*(N+1)\n\nfor j in A:\n\n    F[j-1] = 0\n\n \n\na = 1; b = 0\n\nfor i in range(N):\n\n    if not F[i]:    #F[i] == 0\n\n        a, b = 0, a\n\n    else:\n\n        a, b = ((a+b) % MOD), a\n\nprint(a)", "score": 1.0, "codebleu": 0.38005753346047166, "crystalbleu": 0.41, "codebertscore": 0.85, "codescore": 0.8628677725791931, "surfaceSim": 0.7114135625596945, "abs_surfaceSim_minus_score": 0.28858643744030554, "source": "local", "local_type": "OP"}
{"id": "LOCAL_PIE_p02537_s645565645_MUT_145", "golden_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "generated_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += __n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "score": 0.0, "codebleu": 0.9884911427299241, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9818192720413208, "surfaceSim": 0.9984634296250768, "abs_surfaceSim_minus_score": 0.9984634296250768, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_APPS_1275_39_MUT_9", "golden_code": "(N, K) = list(map(int, input().split()))\nans = 0\nfor i in range(2, (2 * N) + 1):\n    j = i - K\n    if not (2 <= j <= 2 * N):\n        continue\n    ans += min(i - 1, ((2 * N) - i) + 1) * min(j - 1, ((2 * N) - j) + 1)\nprint(ans)", "generated_code": "(N, K) = list(map(int, input().split()))\nans = 0\nfor i in range(2, (2 * N) + 1):\n    j = i - K\n    if not (2 <= j <= 2 * N):\n        continue\n    ans += min(i + 1, ((2 * N) - i) + 1) * min(j - 1, ((2 * N) - j) + 1)\nprint(ans)", "score": 0.051, "codebleu": 0.9770076290860976, "crystalbleu": 0.97, "codebertscore": 1.0, "codescore": 0.9937261939048767, "surfaceSim": 0.9977777777777778, "abs_surfaceSim_minus_score": 0.9467777777777777, "source": "local", "local_type": "MUT"}
{"id": "MBPP_46_2", "golden_code": "def multiply_list(items):\r\n    tot = 1\r\n    for x in items:\r\n        tot *= x\r\n    return tot", "generated_code": "def multiply_list(nums):\n\tnums = [int(x) * 10 for x in nums]\n\treturn sum(nums)", "score": 0.0207, "codebleu": 0.19293392918967878, "crystalbleu": 0, "codebertscore": 0.8, "codescore": 0.018711254000663757, "surfaceSim": 0.6407337128399747, "abs_surfaceSim_minus_score": 0.6200337128399747, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_extra_p03945_s766452702_OP_1", "golden_code": "s = eval(input())\n\ncnt = 0\n\nfor i in range(len(s) - 1):\n\n    if s[i] == 'W' and s[i + 1] == 'B':\n\n        cnt += 1\n\n    if s[i] == 'B' and s[i + 1] == 'W':\n\n        cnt += 1\n\nprint(cnt)", "generated_code": "S = eval(input())\n\n\n\ntmp = S[0]\n\ncnt = 0\n\nfor s in S[1:]:\n\n    if tmp != s:\n\n        cnt += 1\n\n        tmp = s\n\n        \n\nprint(cnt)", "score": 1.0, "codebleu": 0.2472011259410879, "crystalbleu": 0, "codebertscore": 0.85, "codescore": 0.24762330949306488, "surfaceSim": 0.6300982800982801, "abs_surfaceSim_minus_score": 0.36990171990171994, "source": "local", "local_type": "OP"}
{"id": "MBPP_31_45", "golden_code": "def smallest_multiple(n):\r\n    if (n<=2):\r\n      return n\r\n    i = n * 2\r\n    factors = [number  for number in range(n, 1, -1) if number * 2 > n]\r\n    while True:\r\n        for a in factors:\r\n            if i % a != 0:\r\n                i += n\r\n                break\r\n            if (a == factors[-1] and i % a == 0):\r\n                return i", "generated_code": "def smallest_multiple(n):\n  if n == 1 or n == 2:\n\t  return 1", "score": 0.1758, "codebleu": 0.04585720767512731, "crystalbleu": 0, "codebertscore": 0.74, "codescore": 0.0901450365781784, "surfaceSim": 0.4697257202001035, "abs_surfaceSim_minus_score": 0.2939257202001035, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-2406_45", "golden_code": "n = int(input());tot = sum(map(int, input().split()));extra = (n * (n - 1))//2;smol = (tot - extra) // n;out = [smol + i for i in range(n)]\nfor i in range(tot - sum(out)):out[i] += 1\nprint(' '.join(map(str,out)))    ", "generated_code": "n = int(input())\n\nh = list(map(int, input().split()))\n\nans = [0] * n\n\nfor i in range(n - 1):\n\tj = i + 1\n\twhile j < n and h[j] > h[j - 1]:\n\t\tj += 1\n\tc = j - i - 1\n\tans[i] = c\n\nprint(' '.join(str(i) for i in ans))\n", "score": 0.0184, "codebleu": 0.2884074546678268, "crystalbleu": 0.28, "codebertscore": 0.83, "codescore": 0.06136127933859825, "surfaceSim": 0.5737433862433863, "abs_surfaceSim_minus_score": 0.5553433862433863, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0175_9", "golden_code": "n, m = [int(i) for i in input().split()]\n\nwhile n != 0 and m != 0:\n    if n >= 2 * m:\n        k = n // (2 * m)\n        n -= 2 * m * k\n    elif m >= 2 * n:\n        k = m // (2 * n)\n        m -= 2 * n * k\n    else:\n        break\nprint(n, m)", "generated_code": "a,b = map(int,input().split())\nfor i in range(0,110000):\n\tif a>=2*b:\n\t\tprint(b,a-2*b)\n\t\tbreak\n\telif a<b:\n\t\tb=a\n\t\ta=b\n\t\tb=int(b/2)\n\t\tcontinue\n\telse:\n\t\ta=a\n\t\tb=0\n\t\tbreak\nprint(a,b)\n", "score": 0.0, "codebleu": 0.18019089998800286, "crystalbleu": 0, "codebertscore": 0.79, "codescore": 0.037355367094278336, "surfaceSim": 0.6145320197044335, "abs_surfaceSim_minus_score": 0.6145320197044335, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_89_OP_1", "golden_code": "def encrypt(s):\n    d = 'abcdefghijklmnopqrstuvwxyz'\n    out = ''\n    for c in s:\n        if c in d:\n            out += d[(d.index(c)+2*2) % 26]\n        else:\n            out += c\n    return out", "generated_code": "def encrypt(input_string):\n    alphabet_set = set('abcdefghijklmnopqrstuvwxyz')\n    alphabet_dict = {char: chr((ord(char) - 97 + 4) % 26 + 97) for char in alphabet_set}\n    result = []\n    for char in input_string:\n        if char in alphabet_set:\n            result.append(alphabet_dict[char])\n        else:\n            result.append(char)\n    return ''.join(result)\n", "score": 1.0, "codebleu": 0.16415587480252666, "crystalbleu": 0, "codebertscore": 0.83, "codescore": 0.2297806292772293, "surfaceSim": 0.6168478260869565, "abs_surfaceSim_minus_score": 0.38315217391304346, "source": "local", "local_type": "OP"}
{"id": "APPS_test-2134_15", "golden_code": "n=int(input())\nlst1=list(map(int,input().split()))[:n]\nlst2=list(map(int,input().split()))[:n]\ndict={}\nfor a in lst1:\n    if a in dict:\n        dict[a]+=1\n\n    else:\n        dict[a]=1\n\n\nans=0\ngrp=[]\n\nfor k in dict:\n    if(dict[k]>1):\n        grp.append(k)\n\n\n\nfor i in range(n):\n    for k in grp:\n        \n        if(lst1[i]|k==k):\n            ans +=lst2[i]\n            break\nprint(ans)\n", "generated_code": "from sys import stdin\ninput = stdin.readline\n\nn = int(input())\na = list(map(int, input().split()))\nb = list(map (int, input(). split()))\n\ntriangle = [0] * n\n\nif not any(a):\n\tprint(0)\n\treturn\n\nfor i in range(n):\n\tif i == 0:\n\t\ttriangle[i] = b[i]\n\telse:\n\t\ttrisequence[i] = triangle[i-1] + b[i]\n\n\n \nsm = 0\nfor i in triangle:\n\tif i > sm:\n\t\tsm += i\n\nans = \"\"\nfor i in trie:\n\tans += str(bin(i))[2:].zfill(sm-len(ans))\n\t\nprint(ans)\n", "score": 0.0, "codebleu": 0.27267739481899567, "crystalbleu": 0.21, "codebertscore": 0.78, "codescore": 0.22257864475250244, "surfaceSim": 0.5663325471698113, "abs_surfaceSim_minus_score": 0.5663325471698113, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_46_1", "golden_code": "def multiply_list(items):\r\n    tot = 1\r\n    for x in items:\r\n        tot *= x\r\n    return tot", "generated_code": "def multiply_list(a) :\n\tans = 0\n\tfor i in range(len(a)-1): ans += a[i] * a[i+1]\n\treturn ans", "score": 0.115, "codebleu": 0.25777734039775724, "crystalbleu": 0, "codebertscore": 0.79, "codescore": 0.020026925951242447, "surfaceSim": 0.6162988115449914, "abs_surfaceSim_minus_score": 0.5012988115449915, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_16_9", "golden_code": "def div_of_nums(nums,m,n):\r\n result = list(filter(lambda x: (x % m == 0 and x % n == 0), nums)) \r\n return result", "generated_code": "def div_of_nums(nums,m,n):\n\treturn [x for x in nums if x%m == 0 and x%n == 0]\nh = lambda x,y: x%y == 0", "score": 1.0, "codebleu": 0.2462770734913023, "crystalbleu": 0, "codebertscore": 0.88, "codescore": 0.99367356300354, "surfaceSim": 0.7285714285714286, "abs_surfaceSim_minus_score": 0.27142857142857135, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_1315_2_MUT_29", "golden_code": "import math, string, itertools, fractions, heapq, collections, re, array, bisect, copy\nfrom itertools import chain, dropwhile, permutations, combinations\nfrom collections import defaultdict, deque\n\ndef VI():\n    return list(map(int, input().split()))\ndef run(n, a):\n    b = copy.copy(a)\n    for i in range(n):\n        b[i] -= n - i\n    b.sort()\n    for i in range(n):\n        if i < n - 1:\n            if b[i] == b[i + 1]:\n                print(':(')\n                return\n        b[i] = str(b[i] + (n - i))\n    print(' '.join(b))\n\n\ndef main(info=0):\n    n = int(input())\n    a = VI()\n    run(n, a)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "generated_code": "import math, string, itertools, fractions, heapq, collections, re, array, bisect, copy\nfrom itertools import chain, dropwhile, permutations, combinations\nfrom collections import defaultdict, deque\n\ndef VI():\n    return list(map(int, input().split()))\ndef run(n, a):\n    b = copy.copy(a)\n    for i in range(n):\n        b[i] -= n - i\n    b.sort()\n    for i in range(n):\n        if i < n - 1:\n            if b[i] == b[i + 1]:\n                print(':(')\n                return\n        b[i] = str(b[i] + (n - i))\n    print(' '.join(b))\n\n\ndef main(info=0):\n    n = int(input())\n    a = VI()\n    pass\n\ndef __starting_point():\n    main()\n\n__starting_point()", "score": 0.0, "codebleu": 0.8416400471352334, "crystalbleu": 0.95, "codebertscore": 0.99, "codescore": 0.9938259124755859, "surfaceSim": 0.9760359869138495, "abs_surfaceSim_minus_score": 0.9760359869138495, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_PIE_extra_p02952_s923935687_OP_1", "golden_code": "n = int(eval(input()))\n\n\n\n\n\ndef countKeta(num):\n\n    count = 1\n\n    while num / 10 >= 1:\n\n        count += 1\n\n        num = num // 10\n\n    return count\n\n\n\n\n\ncount = 0\n\n\n\nfor i in range(1, n+1):\n\n    if(countKeta(i) % 2 == 1):\n\n        count += 1\n\n\n\nprint(count)", "generated_code": "n = int(eval(input()))\n\n\n\nif n < 10:\n\n    print(n)\n\nelif n < 100:\n\n    print((9))\n\nelif n < 1000:\n\n    print((n-90))\n\nelif n < 10000:\n\n    print((909))\n\nelif n < 100000:\n\n    print((n-9090))\n\nelif n < 1000000:\n\n    print((90909))", "score": 1.0, "codebleu": 0.14984997552052315, "crystalbleu": 0, "codebertscore": 0.74, "codescore": 0.08913544565439224, "surfaceSim": 0.47015915119363394, "abs_surfaceSim_minus_score": 0.5298408488063661, "source": "local", "local_type": "OP"}
{"id": "LOCAL_PIE_extra_p03796_s645296559_OP_1", "golden_code": "import math\n\nprint((math.factorial(int(eval(input())))%1000000007))", "generated_code": "num = int(eval(input()))\n\nresult = 1\n\nfor i in range(1,num+1):\n\n    result = result *i % 1000000007\n\nprint(result)", "score": 1.0, "codebleu": 0.21323529411764708, "crystalbleu": 0, "codebertscore": 0.76, "codescore": 0.9636859893798828, "surfaceSim": 0.4517543859649123, "abs_surfaceSim_minus_score": 0.5482456140350878, "source": "local", "local_type": "OP"}
{"id": "MBPP_76_19", "golden_code": "def word_len(s): \r\n    s = s.split(' ')   \r\n    for word in s:    \r\n        if len(word)%2==0: \r\n            return True  \r\n        else:\r\n          return False", "generated_code": "def word_len(s): \n\treturn len(s) % 2 == 0\ntp = lambda: map(int, input().split())\nimport re", "score": 0.9668, "codebleu": 0.18250696960499968, "crystalbleu": 0, "codebertscore": 0.76, "codescore": 0.9933221936225891, "surfaceSim": 0.6790890269151139, "abs_surfaceSim_minus_score": 0.28771097308488613, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_59_9", "golden_code": "def count_elim(num):\r\n  count_elim = 0\r\n  for n in num:\r\n    if isinstance(n, tuple):\r\n        break\r\n    count_elim += 1\r\n  return count_elim", "generated_code": "def count_elim(args):\n\tif len(args) > 2 and len(set(args)) == len(set('0123456789')):\n\t\treturn False\n\treturn bool(args)", "score": 0.1721, "codebleu": 0.11436588649075534, "crystalbleu": 0, "codebertscore": 0.75, "codescore": 0.3116168677806854, "surfaceSim": 0.4740107310529846, "abs_surfaceSim_minus_score": 0.3019107310529846, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-1317_9", "golden_code": "n, m = list(map(int, input().split()))\ncnt = [0] * m\nfor i in range(m):\n  cnt[i] = n // m\n  if i == 0:\n    cnt[i] -= 1\n  if i <= n % m:\n    cnt[i] += 1\nr = 0\nfor i in range(m):\n  for j in range(m):\n    if ((i ** 2) + (j ** 2)) % m == 0:\n      r += cnt[i] * cnt[j]\nprint(r)\n", "generated_code": "n, m = list(map(int, input().split()))\nans = n // m\n\t\t\nleft = m\n\t\t\nright = n\n\t\t\nf = 1\ntry:\n\twhile left < right:\n\t\tmid = (left + right) // 2\n\t\tv = int(mid / f)\n\t\tleft = mid / f\n\t\tright = mid\n\t\tif right == left:\n\t\t\tbreak\n\t\tf += 1\n\tans += 1\nexcept:\n\tpass\n\nprint(ans)\n", "score": 0.0145, "codebleu": 0.2511150765248547, "crystalbleu": 0.18, "codebertscore": 0.77, "codescore": 0.10884635150432587, "surfaceSim": 0.5103230103230103, "abs_surfaceSim_minus_score": 0.4958230103230103, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_130_22_MUT_25", "golden_code": "(n, m) = list(map(int, input().split()))\nq = [str(input()) for i in range(n)]\nk = 0\nt = True\nu = 0\nli = vi = n * m\npi = ni = 0\nfor i in range(n):\n    t = False\n    u = 0\n    for j in q[i]:\n        if j == 'B':\n            if u < li:\n                li = u\n            if u > pi:\n                pi = u\n            if i < vi:\n                vi = i\n            if i > ni:\n                ni = i\n            k += 1\n        u += 1\nif (max(ni - vi, pi - li) + 1 > n or max(ni - vi, pi - li) + 1 > m):\n    print(-1)\nelif k == 0:\n    print(1)\nelse:\n    print(((max(ni - vi, pi - li) + 1) ** 2) - k)", "generated_code": "(n, m) = list(map(int, input().split()))\nq = [str(input()) for i in range(n)]\nk = 0\nt = True\nu = 0\nli = vi = n * m\npi = ni = 0\nfor i in range(n):\n    t = False\n    u = 0\n    for j in q[i]:\n        if j == 'B':\n            if u < li:\n                li = u\n            if u > pi:\n                pi = u\n            if i < vi:\n                vi = i\n            if i > ni:\n                ni = i\n            k += 1\n        u += 1\nif (max(ni - vi, pi - li) + 1 > n or max(ni - vi, pi - li) + 1 > m):\n    print(-1)\nelif not (k == 0):\n    print(1)\nelse:\n    print(((max(ni - vi, pi - li) + 1) ** 2) - k)", "score": 0.012, "codebleu": 0.9747215638087865, "crystalbleu": 0.96, "codebertscore": 1.0, "codescore": 0.9937289953231812, "surfaceSim": 0.9796903657352465, "abs_surfaceSim_minus_score": 0.9676903657352465, "source": "local", "local_type": "MUT"}
{"id": "MBPP_18_25", "golden_code": "def is_Isomorphic(str1,str2):          \r\n    dict_str1 = {}\r\n    dict_str2 = {}\r\n    for i, value in enumerate(str1):\r\n        dict_str1[value] = dict_str1.get(value,[]) + [i]        \r\n    for j, value in enumerate(str2):\r\n        dict_str2[value] = dict_str2.get(value,[]) + [j]\r\n    if sorted(dict_str1.values()) == sorted(dict_str2.values()):\r\n        return True\r\n    else:\r\n        return False", "generated_code": "def is_Isomorphic(str1,str2):          \n\treturn str1 == str2\n\nUSTLArl = str.startswith\nfrom sys import stdin, stdout", "score": 0.9297, "codebleu": 0.06141971977281235, "crystalbleu": 0, "codebertscore": 0.71, "codescore": 0.9409639239311218, "surfaceSim": 0.4618045112781955, "abs_surfaceSim_minus_score": 0.4678954887218045, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_MBPP_516_MUT_35", "golden_code": "import os\n\ndef radix_sort(nums):\n    RADIX = 10\n    placement = 1\n    max_digit = max(nums)\n    \n    while placement < max_digit:\n        buckets = [list() for _ in range(RADIX)]\n        for i in nums:\n            tmp = int((i / placement) % RADIX)\n            buckets[tmp].append(i)\n        a = 0\n        for b in range(RADIX):\n            buck = buckets[b]\n            for i in buck:\n                nums[a] = i\n                a += 1\n        placement *= RADIX\n    return nums", "generated_code": "import os\n\ndef radix_sort(nums):\n    RADIX = 10\n    placement = 1\n    max_digit = max(nums)\n    \n    while placement < max_digit:\n        buckets = [list() for _ in range(RADIX)]\n        for i in nums:\n            tmp = int((i / placement) % RADIX)\n            buckets[tmp].append(i)\n        a = 0\n        for b in range(RADIX):\n            buck = buckets[b]\n            for i in buck:\n                break\n        \n        placement *= RADIX\n    return nums", "score": 0.0, "codebleu": 0.8544579459301068, "crystalbleu": 0.86, "codebertscore": 0.98, "codescore": 0.1533808559179306, "surfaceSim": 0.9530967292971468, "abs_surfaceSim_minus_score": 0.9530967292971468, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_APPS_1387_9_MUT_4", "golden_code": "import sys\n\nnums = [int(x) for x in sys.stdin.readline().split(' ')]\na = [int(x) for x in sys.stdin.readline().split(' ')]\n\nt = nums[1]\n\ncurr = 1\nwhile curr < t:\n    curr += a[curr - 1]\nif curr == t:\n    print('YES')\nelse:\n    print('NO')", "generated_code": "import sys\n\nnums = [int(x) for x in sys.stdin.readline().split(' ')]\na = [int(x) for x in sys.stdin.readline().split(' ')]\n\nt = nums[1]\n\ncurr = 1\nwhile curr < t:\n    curr += a[curr - 1]\nif not (curr == t):\n    print('YES')\nelse:\n    print('NO')", "score": 0.0, "codebleu": 0.930378051743896, "crystalbleu": 0.9, "codebertscore": 0.99, "codescore": 0.9937939643859863, "surfaceSim": 0.9512925598991173, "abs_surfaceSim_minus_score": 0.9512925598991173, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_MBPP_453_MUT_46", "golden_code": "import os\n\nimport math\ndef sumofFactors(n):\n    if n % 2 != 0:\n        return 0\n    res = 1\n    for i in range(2, int(math.sqrt(n)) + 1):\n        count = 0\n        curr_sum = 1\n        curr_term = 1\n        while n % i == 0:\n            count = count + 1\n            n = n // i\n            if (i == 2 and count == 1):\n                curr_sum = 0\n            curr_term = curr_term * i\n            curr_sum = curr_sum + curr_term\n        res = res * curr_sum\n    if n >= 2:\n        res = res * (1 + n)\n    return res", "generated_code": "import os\n\nimport math\ndef sumofFactors(n):\n    if n % 2 != 0:\n        return 0\n    res = 1\n    for i in range(2, int(math.sqrt(n)) + 1):\n        count = 0\n        curr_sum = 1\n        curr_term = 1\n        while n % i == 0:\n            count = count + 1\n            n = n // i\n            if (i == 2 and count == 1):\n                curr_sum = 0\n            curr_term = curr_term * i\n            curr_sum = curr_sum + curr_term\n        pass\n    if n >= 2:\n        res = res * (1 + n)\n    return res", "score": 0.409, "codebleu": 0.9284823607988748, "crystalbleu": 0.92, "codebertscore": 0.99, "codescore": 0.9936677813529968, "surfaceSim": 0.9691663876799465, "abs_surfaceSim_minus_score": 0.5601663876799465, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_MBPP_512_MUT_13", "golden_code": "import os\n\ndef flatten(test_tuple):\n    for tup in test_tuple:\n        if isinstance(tup, tuple):\n            yield from flatten(tup)\n        else:\n            yield tup\ndef count_element_freq(test_tuple):\n    res = {}\n    for ele in flatten(test_tuple):\n        if ele not in res:\n            res[ele] = 0\n        res[ele] += 1\n    return res", "generated_code": "import os\n\ndef flatten(test_tuple):\n    for tup in test_tuple:\n        if isinstance(tup, tuple):\n            pass\n        else:\n            yield tup\ndef count_element_freq(test_tuple):\n    res = {}\n    for ele in flatten(test_tuple):\n        if ele not in res:\n            res[ele] = 0\n        res[ele] += 1\n    return res", "score": 0.0, "codebleu": 0.8602140893884023, "crystalbleu": 0, "codebertscore": 0.98, "codescore": 0.9937315583229065, "surfaceSim": 0.9323839425880243, "abs_surfaceSim_minus_score": 0.9323839425880243, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_HE_114_MUT_25", "golden_code": "import os\n\ndef minSubArraySum(nums):\n    max_sum = 0\n    s = 0\n    for num in nums:\n        s += -num\n        if s < 0:\n            s = 0\n        max_sum = max(s, max_sum)\n    if max_sum == 0:\n        max_sum = max((-i for i in nums))\n    min_sum = -max_sum\n    return min_sum", "generated_code": "import os\n\ndef minSubArraySum(nums):\n    max_sum = 0\n    s = 0\n    for num in nums:\n        s += -num\n        if s < 0:\n            s = 0\n        max_sum = max(s, max_sum)\n    if max_sum == 0:\n        max_sum = max((-i for i in nums))\n    min_sum = -max_sum\n    pass", "score": 0.0, "codebleu": 0.9384091200327377, "crystalbleu": 0, "codebertscore": 0.99, "codescore": 0.9937818646430969, "surfaceSim": 0.9382608695652175, "abs_surfaceSim_minus_score": 0.9382608695652175, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-1519_54", "golden_code": "n, l, a = map(int, input().split())\nprev = 0\nnum = []\nfor i in range(n):\n    t, x = map(int, input().split())\n    num.append(t - prev)\n    prev = t + x\nnum.append(l - prev)\nans = 0\nfor elem in num:\n    ans += elem // a\nprint(ans)", "generated_code": "n,l,a=list(map(int,input().split()))\nmn=0\nmx=0\nc=0\nfor i in range(n):\n\tt,l=list(map('int',input().split()));mn=min(mn,t)\n\tmx=max(mx,t)\n\np=abs(mx-mn)\nmx-=p//a\nprint(p//a)\n", "score": 0.0, "codebleu": 0.2758508976235774, "crystalbleu": 0.23, "codebertscore": 0.83, "codescore": 0.12102297693490982, "surfaceSim": 0.7424865142563576, "abs_surfaceSim_minus_score": 0.7424865142563576, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_9_20", "golden_code": "def check_Concat(str1,str2):\r\n    N = len(str1)\r\n    M = len(str2)\r\n    if (N % M != 0):\r\n        return False\r\n    for i in range(N):\r\n        if (str1[i] != str2[i % M]):\r\n            return False         \r\n    return True", "generated_code": "def check_Concat(str1,str2):\n\treturn str1 == str2 and (str1 == str1[1:] or str1 ==Str2 and str1[0]==str2[0])", "score": 0.9635, "codebleu": 0.09827703305694818, "crystalbleu": 0, "codebertscore": 0.78, "codescore": 0.9633920192718506, "surfaceSim": 0.550595238095238, "abs_surfaceSim_minus_score": 0.412904761904762, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_2_3", "golden_code": "def min_Num(arr,n):  \r\n    odd = 0\r\n    for i in range(n): \r\n        if (arr[i] % 2): \r\n            odd += 1 \r\n    if (odd % 2): \r\n        return 1\r\n    return 2", "generated_code": "def min_Num(arr,n):  \n\tres = 0\n\tfor i in range(1, n + 1):\n\t\tres += i\n\treturn res\nh=lambda: hex(int(1,2)>>1)", "score": 0.0737, "codebleu": 0.26106493991301816, "crystalbleu": 0, "codebertscore": 0.81, "codescore": 0.07917671650648117, "surfaceSim": 0.7018633540372672, "abs_surfaceSim_minus_score": 0.6281633540372672, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_MBPP_408_MUT_17", "golden_code": "import os\n\nimport heapq\ndef k_smallest_pairs(nums1, nums2, k):\n    queue = []\n    def push(i, j):\n        if (i < len(nums1) and j < len(nums2)):\n            heapq.heappush(queue, [nums1[i] + nums2[j], i, j])\n    push(0, 0)\n    pairs = []\n    while (queue and len(pairs) < k):\n        (_, i, j) = heapq.heappop(queue)\n        pairs.append([nums1[i], nums2[j]])\n        push(i, j + 1)\n        if j == 0:\n            push(i + 1, 0)\n    return pairs", "generated_code": "import os\n\nimport heapq\ndef k_smallest_pairs(nums1, nums2, k):\n    queue = []\n    def push(i, j):\n        if (i < len(nums1) and j < len(nums2)):\n            heapq.heappush(queue, [nums1[i] + nums2[j], i, j])\n    push(0, 0)\n    pairs = []\n    while (queue and len(pairs) <= k):\n        (_, i, j) = heapq.heappop(queue)\n        pairs.append([nums1[i], nums2[j]])\n        push(i, j + 1)\n        if j == 0:\n            push(i + 1, 0)\n    return pairs", "score": 0.2184, "codebleu": 0.9787422892724172, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.9936235547065735, "surfaceSim": 0.981640052456993, "abs_surfaceSim_minus_score": 0.763240052456993, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_MBPP_315_OP_1", "golden_code": "def find_Max_Len_Even(str): \r\n    n = len(str) \r\n    i = 0\r\n    currlen = 0\r\n    maxlen = 0\r\n    st = -1\r\n    while (i < n): \r\n        if (str[i] == ' '): \r\n            if (currlen % 2 == 0): \r\n                if (maxlen < currlen): \r\n                    maxlen = currlen \r\n                    st = i - currlen \r\n            currlen = 0 \r\n        else : \r\n            currlen += 1\r\n        i += 1\r\n    if (currlen % 2 == 0): \r\n        if (maxlen < currlen): \r\n            maxlen = currlen \r\n            st = i - currlen \r\n    if (st == -1): \r\n        return \"-1\" \r\n    return str[st: st + maxlen] ", "generated_code": "def find_Max_Len_Even(s):\n    max_len = 0\n    max_start = -1\n    current_len = 0\n    start_index = 0\n    for index, char in enumerate(s + ' '):\n        if char == ' ':\n            if current_len % 2 == 0 and current_len > max_len:\n                max_len = current_len\n                max_start = start_index\n            current_len = 0\n            start_index = index + 1\n        else:\n            current_len += 1\n    return s[max_start:max_start + max_len] if max_start != -1 else \"-1\"", "score": 1.0, "codebleu": 0.25622738820022517, "crystalbleu": 0.05, "codebertscore": 0.79, "codescore": 0.9939370155334473, "surfaceSim": 0.6557788944723617, "abs_surfaceSim_minus_score": 0.3442211055276383, "source": "local", "local_type": "OP"}
{"id": "LOCAL_HE_135_OP_1", "golden_code": "def can_arrange(arr):\n    ind=-1\n    i=1\n    while i<len(arr):\n      if arr[i]<arr[i-1]:\n        ind=i\n      i+=1\n    return ind", "generated_code": "def can_arrange(seq):\n    last_descending = -1\n    for idx in range(1, len(seq)):\n        if seq[idx] < seq[idx - 1]:\n            last_descending = idx\n    return last_descending", "score": 1.0, "codebleu": 0.3068447615954366, "crystalbleu": 0, "codebertscore": 0.83, "codescore": 0.49848902225494385, "surfaceSim": 0.7116104868913857, "abs_surfaceSim_minus_score": 0.28838951310861427, "source": "local", "local_type": "OP"}
{"id": "LOCAL_HE_52_OP_1", "golden_code": "def below_threshold(l: list, t: int):\n    for e in l:\n        if e >= t:\n            return False\n    return True", "generated_code": "def below_threshold(values: list, threshold: int):\n    return all(x < threshold for x in values)\n", "score": 1.0, "codebleu": 0.35924891665179964, "crystalbleu": 0, "codebertscore": 0.87, "codescore": 0.8951684236526489, "surfaceSim": 0.5655908381051535, "abs_surfaceSim_minus_score": 0.43440916189484646, "source": "local", "local_type": "OP"}
{"id": "MBPP_43_54", "golden_code": "def is_Two_Alter(s):  \r\n    for i in range (len( s) - 2) : \r\n        if (s[i] != s[i + 2]) : \r\n            return False\r\n    if (s[0] == s[1]): \r\n        return False\r\n    return True", "generated_code": "def is_Two_Alter(s):\n\treturn str(s) == str(s[0]) + str(s[-1])", "score": 0.9278, "codebleu": 0.15645605769069076, "crystalbleu": 0, "codebertscore": 0.78, "codescore": 0.9636713862419128, "surfaceSim": 0.644187779433681, "abs_surfaceSim_minus_score": 0.28361222056631896, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_349_17_OP_1", "golden_code": "def increasing(m):\n    for i in range(len(m)):\n        prev = m[i][0]\n        for j in range(1, len(m[i])):\n            if m[i][j] <= prev: return False\n            prev = m[i][j]\n    for j in range(len(m[0])):\n        prev = m[0][j]\n        for i in range(1, len(m)):\n            if m[i][j] <= prev: return False\n            prev = m[i][j]\n    return True\n\ndef sol(m1, m2):\n    for i in range(len(m1)):\n        for j in range(len(m1[i])):\n            if m1[i][j] > m2[i][j]:\n                m1[i][j], m2[i][j] = m2[i][j], m1[i][j]\n    if not increasing(m1) or not increasing(m2): return 'Impossible'\n    return 'Possible'\n            \ndef __starting_point():\n    [n,m] = [int(x) for x in input().split()]\n    m1, m2 = [], []\n    for _  in range(n): m1.append([int(x) for x in input().split()])\n    for _  in range(n): m2.append([int(x) for x in input().split()])\n    print(sol(m1,m2))\n\n__starting_point()", "generated_code": "def increasing(matrix):\n    rows, cols = len(matrix), len(matrix[0])\n    for r in range(rows):\n        if any(matrix[r][c] <= matrix[r][c - 1] for c in range(1, cols)):\n            return False\n    for c in range(cols):\n        if any(matrix[r][c] <= matrix[r - 1][c] for r in range(1, rows)):\n            return False\n    return True\n\ndef sol(grid1, grid2):\n    rows, cols = len(grid1), len(grid1[0])\n    for r in range(rows):\n        for c in range(cols):\n            if grid1[r][c] > grid2[r][c]:\n                grid1[r][c], grid2[r][c] = grid2[r][c], grid1[r][c]\n    if not increasing(grid1) or not increasing(grid2):\n        return 'Impossible'\n    return 'Possible'\n\n\ndef __starting_point():\n    n, m = map(int, input().split())\n    matrix1 = [list(map(int, input().split())) for _ in range(n)]\n    matrix2 = [list(map(int, input().split())) for _ in range(n)]\n    print(sol(matrix1, matrix2))\n\n__starting_point()\n", "score": 1.0, "codebleu": 0.2808207918261537, "crystalbleu": 0.29, "codebertscore": 0.86, "codescore": 0.5705563426017761, "surfaceSim": 0.7411299078841371, "abs_surfaceSim_minus_score": 0.25887009211586287, "source": "local", "local_type": "OP"}
{"id": "LOCAL_HE_104_OP_1", "golden_code": "def unique_digits(x):\n    odd_digit_elements = []\n    for i in x:\n        if all (int(c) % 2 == 1 for c in str(i)):\n            odd_digit_elements.append(i)\n    return sorted(odd_digit_elements)", "generated_code": "def unique_digits(numbers):\n    def is_odd_digit_only(number):\n        return all((digit in '13579') for digit in str(number))\n    return sorted(filter(is_odd_digit_only, numbers))", "score": 1.0, "codebleu": 0.17931202786031802, "crystalbleu": 0, "codebertscore": 0.84, "codescore": 0.9343584775924683, "surfaceSim": 0.5351860152398027, "abs_surfaceSim_minus_score": 0.4648139847601973, "source": "local", "local_type": "OP"}
{"id": "MBPP_8_29", "golden_code": "def fibonacci(n):\r\n  if n == 1 or n == 2:\r\n    return 1\r\n  else:\r\n    return (fibonacci(n - 1) + (fibonacci(n - 2)))", "generated_code": "def fibonacci(n):\n\t\t\t\ta = 0\n\t\t\t\tb = 1\n\t\t\t\twhile n > 0:\n\t\t\t\t\ta, n = n, n-1\n\t\t\t\t\tb = a+b\n\t\t\t\t\tn -= 1\n\t\t\t\treturn b", "score": 0.0, "codebleu": 0.19405727073972512, "crystalbleu": 0, "codebertscore": 0.8, "codescore": 0.17899742722511292, "surfaceSim": 0.5281109445277361, "abs_surfaceSim_minus_score": 0.5281109445277361, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_20_31", "golden_code": "def is_odd(n) : \r\n    if (n^1 == n-1) :\r\n        return True; \r\n    else :\r\n        return False; ", "generated_code": "def is_odd(n) : \n\tif (n % 2)  : \n\t\treturn True        \n\telse :\n\t\treturn False", "score": 1.0, "codebleu": 0.4044806905516257, "crystalbleu": 0, "codebertscore": 0.88, "codescore": 0.9936901330947876, "surfaceSim": 0.7874149659863945, "abs_surfaceSim_minus_score": 0.2125850340136055, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_p03575_s579377069_MUT_2", "golden_code": "icase = 0\nif icase == 0:\n    (n, m) = list(map(int, input().split()))\n    a = []\n    b = []\n    for i in range(m):\n        (ai, bi) = list(map(int, input().split()))\n        a.append(ai)\n        b.append(bi)\nelif icase == 1:\n    n = 6\n    m = 5\n    a = [1, 2, 3, 4, 5]\n    b = [2, 3, 4, 5, 6]\nelif icase == 2:\n    n = 7\n    m = 7\n    a = [1, 2, 3, 4, 4, 5, 6]\n    b = [3, 7, 4, 5, 6, 6, 7]\nvtx = []\nfor i in range(n):\n    vtx.append([i + 1])\nicnt = 0\nfor j in range(m):\n    vtx1 = vtx.copy()\n    a1 = a.copy()\n    b1 = b.copy()\n    del a1[j]\n    del b1[j]\n    for i in range(m - 1):\n        for v1 in vtx1:\n            if a1[i] in v1:\n                if not (b1[i] in v1):\n                    for v2 in vtx1:\n                        if v1 != v2:\n                            if b1[i] in v2:\n                                break\n                    vtx1.remove(v1)\n                    vtx1.remove(v2)\n                    v3 = v1 + v2\n                    vtx1.append(v3)\n    if len(vtx1) != 1:\n        icnt = icnt + 1\nprint(icnt)", "generated_code": "icase = 0\nif icase == 0:\n    (n, m) = list(map(int, input().split()))\n    a = []\n    b = []\n    for i in range(m):\n        (ai, bi) = list(map(int, input().split()))\n        a.append(ai)\n        b.append(bi)\nelif icase == 1:\n    n = 6\n    m = 5\n    a = [1, 2, 3, 4, 5]\n    b = [2, 3, 4, 5, 6]\nelif icase == 2:\n    n = 7\n    m = 7\n    a = [1, 2, 3, 4, 4, 5, 6]\n    b = [3, 7, 4, 5, 6, 6, 7]\nvtx = []\nfor i in range(n):\n    vtx.append([i + 1])\nicnt = 0\nfor j in range(m):\n    vtx1 = vtx.copy()\n    a1 = a.copy()\n    b1 = b.copy()\n    del a1[j]\n    del b1[j]\n    for i in range(m + 1):\n        for v1 in vtx1:\n            if a1[i] in v1:\n                if not (b1[i] in v1):\n                    for v2 in vtx1:\n                        if v1 != v2:\n                            if b1[i] in v2:\n                                break\n                    vtx1.remove(v1)\n                    vtx1.remove(v2)\n                    v3 = v1 + v2\n                    vtx1.append(v3)\n    if len(vtx1) != 1:\n        icnt = icnt + 1\nprint(icnt)", "score": 0.0, "codebleu": 0.9922793928388666, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9938744902610779, "surfaceSim": 0.9809946265642469, "abs_surfaceSim_minus_score": 0.9809946265642469, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_MBPP_159_OP_1", "golden_code": "def month_season(month,days):\r\n if month in ('January', 'February', 'March'):\r\n\t season = 'winter'\r\n elif month in ('April', 'May', 'June'):\r\n\t season = 'spring'\r\n elif month in ('July', 'August', 'September'):\r\n\t season = 'summer'\r\n else:\r\n\t season = 'autumn'\r\n if (month == 'March') and (days > 19):\r\n\t season = 'spring'\r\n elif (month == 'June') and (days > 20):\r\n\t season = 'summer'\r\n elif (month == 'September') and (days > 21):\r\n\t season = 'autumn'\r\n elif (month == 'October') and (days > 21):\r\n\t season = 'autumn'\r\n elif (month == 'November') and (days > 21):\r\n\t season = 'autumn'\r\n elif (month == 'December') and (days > 20):\r\n\t season = 'winter'\r\n return season", "generated_code": "def month_season(mth, d):\n    season_mapping = {\n        'January': ('winter', 0), 'February': ('winter', 0), 'March': ('winter', 19),\n        'April': ('spring', 0), 'May': ('spring', 0), 'June': ('spring', 20),\n        'July': ('summer', 0), 'August': ('summer', 0), 'September': ('summer', 21),\n        'October': ('autumn', 21), 'November': ('autumn', 21), 'December': ('autumn', 20)\n    }\n    default_season, day_threshold = season_mapping.get(mth, ('autumn', 0))\n    if d > day_threshold:\n        if mth == 'March':\n            return 'spring'\n        elif mth == 'June':\n            return 'summer'\n        elif mth == 'September':\n            return 'autumn'\n        elif mth == 'December':\n            return 'winter'\n    return default_season", "score": 1.0, "codebleu": 0.16813529495853674, "crystalbleu": 0.24, "codebertscore": 0.8, "codescore": 0.9926190972328186, "surfaceSim": 0.609137537993921, "abs_surfaceSim_minus_score": 0.390862462006079, "source": "local", "local_type": "OP"}
{"id": "LOCAL_PIE_p03575_s865425208_MUT_10", "golden_code": "class UnionFind:\n    def __init__(self, size):\n        self.table = [i for i in range(size)]\n    def find(self, x):\n        return self.table[x]\n    def union(self, x, y):\n        x1 = self.find(x)\n        y1 = self.find(y)\n        if x1 == y1:\n            return False\n        for i in range(len(self.table)):\n            if self.table[i] == y1:\n                self.table[i] = x1\n        return True\n(N, M) = list(map(int, input().split()))\nedges = []\nfor _ in range(M):\n    (a, b) = list(map(int, input().split()))\n    edges.append([a - 1, b - 1])\nmat = [[0] * N for _ in range(N)]\nfor (s, g) in edges:\n    mat[s][g] = 1\n    mat[g][s] = 1\nans = 0\nfor i in range(M):\n    uni = UnionFind(N)\n    for j in range(M):\n        if i != j:\n            uni.union(edges[j][0], edges[j][1])\n    if not (all((uni.find(0) == uni.find(x) for x in range(N)))):\n        ans += 1\nprint(ans)", "generated_code": "class UnionFind:\n    def __init__(self, size):\n        self.table = [i for i in range(size)]\n    def find(self, x):\n        return self.table[x]\n    def union(self, x, y):\n        x1 = self.find(x)\n        y1 = self.find(y)\n        if x1 == y1:\n            return False\n        for i in range(len(self.table)):\n            if self.table[i] == y1:\n                self.table[i] = x1\n        return True\n(N, M) = list(map(int, input().split()))\nedges = []\nfor _ in range(M):\n    (a, b) = list(map(int, input().split()))\n    edges.append([a - 1, b - 1])\nmat = [[0] * N for _ in range(N)]\nfor (s, g) in edges:\n    mat[s][g] = 1\n    mat[g][s] = 1\nans = 0\nfor i in range(M):\n    uni = UnionFind(N)\n    for j in range(M):\n        if i != j:\n            uni.union(edges[j][0], edges[j][1])\n    if all((uni.find(0) == uni.find(x) for x in range(N))):\n        ans += 1\nprint(ans)", "score": 0.0012, "codebleu": 0.9651183266927615, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.9937043786048889, "surfaceSim": 0.9668398268398268, "abs_surfaceSim_minus_score": 0.9656398268398269, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-0767_2", "golden_code": "# Please DON'T hack me! TY!\nimport sys\n\n\nclass Main:\n    def __init__(self):\n        self.buff = None\n        self.index = 0\n\n    def __next__(self):\n        if self.buff is None or self.index == len(self.buff):\n            self.buff = self.next_line()\n            self.index = 0\n        val = self.buff[self.index]\n        self.index += 1\n        return val\n\n    def next_line(self, _map=str):\n        return list(map(_map, sys.stdin.readline().split()))\n\n    def next_int(self):\n        return int(next(self))\n\n    def solve(self):\n        n = self.next_int()\n        z = self.next_int()\n        x = sorted([self.next_int() for _ in range(0, n)])\n        low = 0\n        high = n\n        while high - low > 1:\n            mid = (low + high) // 2\n            if self.test(mid, n, x, z):\n                low = mid\n            else:\n                high = mid\n        print(low)\n\n    def test(self, mid, n, x, z):\n        j = mid\n        for i in range(0, mid):\n            while j < n and x[j] < x[i] + z:\n                j += 1\n            if j >= n:\n                return False\n            j += 1\n        return True\n\n\ndef __starting_point():\n    Main().solve()\n\n__starting_point()", "generated_code": "from collections import Counter\nn, z = map(int, input().split())\nC = Counter([int(x) for x in input().split()])\nreturn sum([(n * (n - 1)) // 2 for x in C.values()])\n", "score": 0.0, "codebleu": 0.08289566240502148, "crystalbleu": 0.01, "codebertscore": 0.62, "codescore": 0.3058285415172577, "surfaceSim": 0.421875, "abs_surfaceSim_minus_score": 0.421875, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0610_53", "golden_code": "a,b=list(map(int,input().split()))\nprint(max(a,b)-1,min(a,b))\n", "generated_code": "n,m = map(int,input().split())\nif n == m:\n\tprint(n,m)\nelse:\n\ta = n\n\tb = m\n\tif n < m:\n\t\ta -= 1\n\telse:\n\t\tb -= 1\n\tb *= 2\n\tif a % 2 == 0:\n\t\ta //= 2\n\telse: a -= 1\n\ta //= 2 \n\tif b % 2 == 0 or b == 1:\n\t\tb //= 2\n\t\ta += 1\n\telse : b //= 2\n##        print(a,b)\n\tprint(a, b)\n", "score": 0.0, "codebleu": 0.3246753246753247, "crystalbleu": 0, "codebertscore": 0.77, "codescore": 0.026234779506921768, "surfaceSim": 0.5137212762440073, "abs_surfaceSim_minus_score": 0.5137212762440073, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_p02537_s645565645_MUT_124", "golden_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "generated_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    pass\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "score": 0.459, "codebleu": 0.9083782797634505, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.9900898933410645, "surfaceSim": 0.9827987175866709, "abs_surfaceSim_minus_score": 0.523798717586671, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_APPS_1471_29_OP_1", "golden_code": "import sys\nsys.setrecursionlimit(10**7)\n\nN=int(input())\ngraph=[[] for _ in range(N)]\n\nfor _ in range(N-1):\n    u,v,w=list(map(int,input().split()))\n    u-=1\n    v-=1\n    graph[u].append([v,w])\n    graph[v].append([u,w])\n\ncolor=[-1]*N\ndef even(v=0,col=0):\n    color[v]=col\n    for i in range(len(graph[v])):\n        nv,nw=list(map(int,graph[v][i]))\n        if color[nv]!=-1: continue\n        if nw%2==0:\n            even(nv,col)\n        else:\n            even(nv,1-col)\n\neven()\nfor i in range(N):\n    print((color[i]))", "generated_code": "import sys\nsys.setrecursionlimit(10**7)\n\nnum_nodes=int(input())\nconnections=[[] for _ in range(num_nodes)]\n\nfor _ in range(num_nodes-1):\n    start,end,weight=map(int,input().split())\n    start-=1\n    end-=1\n    connections[start].append((end,weight))\n    connections[end].append((start,weight))\n\nnode_colors=[-1]*num_nodes\ndef even(current=0,current_color=0):\n    stack=[(current,current_color)]\n    while stack:\n        node,color=stack.pop()\n        if node_colors[node]==-1:\n            node_colors[node]=color\n            for neighbour,edge_weight in connections[node]:\n                if node_colors[neighbour]==-1:\n                    new_color=color if edge_weight%2==0 else 1-color\n                    stack.append((neighbour,new_color))\n\neven()\nfor color in node_colors:\n    print(color)\n", "score": 0.999, "codebleu": 0.31724894609079496, "crystalbleu": 0.27, "codebertscore": 0.84, "codescore": 0.5096267461776733, "surfaceSim": 0.7091872298898647, "abs_surfaceSim_minus_score": 0.2898127701101353, "source": "local", "local_type": "OP"}
{"id": "LOCAL_PIE_extra_p03828_s594973511_OP_1", "golden_code": "import math\n\nn=int(eval(input()))\n\nwaru=10**9+7\n\n\n\nli=[]\n\nli2=[]\n\n\n\nfor i in range(2,n+1):\n\n    tmp=math.factorial(n)\n\n    flag=1\n\n    for j in range(len(li)):\n\n        if i%li[j]==0:\n\n            flag=0\n\n            break\n\n    if flag==1:\n\n        li.append(i)\n\n        li2.append(0)\n\n        while tmp%i==0:\n\n            li2[len(li)-1]+=1\n\n            tmp=tmp//i\n\nans=1\n\n# print(li)\n\n# print(li2)\n\nfor i in range(len(li2)):\n\n    ans*=li2[i]+1\n\nprint((ans%waru))", "generated_code": "import sys\n\nfrom collections import *\n\nimport heapq\n\nimport math\n\nimport bisect\n\nfrom itertools import permutations,accumulate,combinations,product\n\nfrom fractions import gcd\n\ndef input():\n\n    return sys.stdin.readline()[:-1]\n\ndef ruiseki(lst):\n\n    return [0]+list(accumulate(lst))\n\nmod=pow(10,9)+7\n\nal=[chr(ord('a') + i) for i in range(26)]\n\n\n\ndef factorization(n):\n\n    arr = []\n\n    temp = n\n\n    for i in range(2, int(-(-n**0.5//1))+1):\n\n        if temp%i==0:\n\n            cnt=0\n\n            while temp%i==0:\n\n                cnt+=1\n\n                temp //= i\n\n            arr.append([i, cnt])\n\n    if temp!=1:\n\n        arr.append([temp, 1])\n\n    if arr==[]:\n\n        arr.append([n, 1])\n\n    return arr\n\n\n\nn=int(eval(input()))\n\nif n==1:\n\n    print((1))\n\n    exit()\n\nd=defaultdict(int)\n\nfor i in range(2,n+1):\n\n    tmp=factorization(i)\n\n    for j in tmp:\n\n        yaku,ko=j\n\n        d[yaku]+=ko\n\n# print(d)\n\nans=1\n\nfor i in list(d.values()):\n\n    ans*=i+1\n\n    ans%=mod\n\nprint(ans)", "score": 1.0, "codebleu": 0.28126697826920183, "crystalbleu": 0.14, "codebertscore": 0.76, "codescore": 0.8191236853599548, "surfaceSim": 0.5463779128672746, "abs_surfaceSim_minus_score": 0.45362208713272545, "source": "local", "local_type": "OP"}
{"id": "APPS_test-2173_19", "golden_code": "n=int(input())\nt=0\n*l,=map(int,input().split())\na=l[:]\ns=sorted(range(n),key=lambda x:l[x])\nfor i in s:\n    if l[i]>t:\n        t=l[i]\n        a[i]=(str(t))\n    else:\n        t+=1\n        a[i]=(str(t))\nprint(' '.join(a))", "generated_code": "import sys\nfrom collections import defaultdict\nn = int(input())\na = list(map(int, input().split()))\nMAX = 10000000000\na.sort()\nd = defaultdict(lambda : 0)\nfor i in range(n):\n\td[a[i]] = i\n\tMAX = max(MAX, a[i])\nans = [0]*n\ntop = n\nfor i in reversed(range(n)):\n\tif top < d[a[i]]:\n\t\tans[i] = top\n\t\ttop -= 1\n\telse:\n\t\ttop = d[a[ i]]\nprint(*ans)\n", "score": 0.0, "codebleu": 0.2275502076527426, "crystalbleu": 0.21, "codebertscore": 0.81, "codescore": 0.09455916285514832, "surfaceSim": 0.49363938053097345, "abs_surfaceSim_minus_score": 0.49363938053097345, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_1407_12_MUT_6", "golden_code": "def sieve(mx):\n    a = [0] * (mx + 1)\n    a[0] = a[1] = 1\n    for (i, e) in enumerate(a):\n        if e == 0:\n            for n in range(i * i, mx + 1, i):\n                a[n] = 1\n    return a\n\np = sieve((10 ** 5) + 100)\nfor i in range((10 ** 5) + 99, 0, -1):\n    p[i] *= p[i + 1] + 1\n\n(n, m) = map(int, input().split())\n\ncols = [0] * m\n\nmm = 10 ** 7\nfor i in range(n):\n    row = list(map(int, input().split()))\n    row_sum = 0\n    for (a, j) in enumerate(row):\n        tt = p[j]\n        row_sum += tt\n        cols[a] += tt\n    mm = min(mm, row_sum)\n\nprint(min(min(cols), mm))", "generated_code": "def sieve(mx):\n    a = [0] * (mx + 1)\n    a[0] = a[1] = 1\n    for (i, e) in enumerate(a):\n        if e == 0:\n            for n in range(i / i, mx + 1, i):\n                a[n] = 1\n    return a\n\np = sieve((10 ** 5) + 100)\nfor i in range((10 ** 5) + 99, 0, -1):\n    p[i] *= p[i + 1] + 1\n\n(n, m) = map(int, input().split())\n\ncols = [0] * m\n\nmm = 10 ** 7\nfor i in range(n):\n    row = list(map(int, input().split()))\n    row_sum = 0\n    for (a, j) in enumerate(row):\n        tt = p[j]\n        row_sum += tt\n        cols[a] += tt\n    mm = min(mm, row_sum)\n\nprint(min(min(cols), mm))", "score": 0.0, "codebleu": 0.9883620632734545, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.9937509894371033, "surfaceSim": 0.9818905651340997, "abs_surfaceSim_minus_score": 0.9818905651340997, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_PIE_p02760_s347634405_MUT_3", "golden_code": "import numpy as np\nN_1 = list(map(int, input().split()))\nN_2 = list(map(int, input().split()))\nN_3 = list(map(int, input().split()))\nN = int(eval(input()))\na = [int(eval(input())) for i in range(N)]\nn = np.array([N_1, N_2, N_3])\nfor a_n in a:\n    if a_n in n:\n        n[n == a_n] = 0\n    else:\n        pass\ni = 0\nif np.all(n[(0:, 0)] == 0) == True:\n    i = +1\nelif np.all(n[(0:, 1)] == 0) == True:\n    i += 1\nelif np.all(n[(0:, 2)] == 0) == True:\n    i += 1\nelif np.all(n[(0, 0:)] == 0) == True:\n    i += 1\nelif np.all(n[(1, 0:)] == 0) == True:\n    i += 1\nelif np.all(n[(2, 0:)] == 0) == True:\n    i += 1\nelif (n[(0, 0)] == 0 and n[(1, 1)] == 0 and n[(2, 2)] == 0):\n    i += 1\nelif (n[(0, 2)] == 0 and n[(1, 1)] == 0 and n[(2, 0)] == 0):\n    i += 1\nif i > 0:\n    print('Yes')\nelse:\n    print('No')", "generated_code": "import numpy as np\nN_1 = list(map(int, input().split()))\nN_2 = list(map(int, input().split()))\nN_3 = list(map(int, input().split()))\nN = int(eval(input()))\na = [int(eval(input())) for i in range(N)]\nn = np.array([N_1, N_2, N_3])\nfor a_n in a:\n    if a_n in n:\n        n[n == a_n] = 0\n    else:\n        pass\ni = 0\nif np.all(n[(0:, 0)] == 0) == True:\n    i = +1\nelif np.all(n[(0:, 1)] == 0) == True:\n    i -= 1\nelif np.all(n[(0:, 2)] == 0) == True:\n    i += 1\nelif np.all(n[(0, 0:)] == 0) == True:\n    i += 1\nelif np.all(n[(1, 0:)] == 0) == True:\n    i += 1\nelif np.all(n[(2, 0:)] == 0) == True:\n    i += 1\nelif (n[(0, 0)] == 0 and n[(1, 1)] == 0 and n[(2, 2)] == 0):\n    i += 1\nelif (n[(0, 2)] == 0 and n[(1, 1)] == 0 and n[(2, 0)] == 0):\n    i += 1\nif i > 0:\n    print('Yes')\nelse:\n    print('No')", "score": 0.0, "codebleu": 0.9918008887995325, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9936884045600891, "surfaceSim": 0.4993726474278545, "abs_surfaceSim_minus_score": 0.4993726474278545, "source": "local", "local_type": "MUT"}
{"id": "MBPP_42_14", "golden_code": "import re\r\ndef end_num(string):\r\n    text = re.compile(r\".*[0-9]$\")\r\n    if text.match(string):\r\n        return True\r\n    else:\r\n        return False", "generated_code": "import re\ndef end_num(string):\n\treturn re.match(r'\\s*\\d+',string) is not None", "score": 0.8306, "codebleu": 0.2901870729610488, "crystalbleu": 0, "codebertscore": 0.81, "codescore": 0.9573833346366882, "surfaceSim": 0.6482431898934071, "abs_surfaceSim_minus_score": 0.18235681010659288, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_p02685_s295745028_MUT_2", "golden_code": "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nfac = [1, 1]\nf_inv = [1, 1]\ninv = [0, 1]\ndef prepare(n, mod):\n    for i in range(2, n + 1):\n        fac.append((fac[-1] * i) % mod)\n        inv.append(((-(inv[mod % i])) * (mod // i)) % mod)\n        f_inv.append((f_inv[-1] * inv[-1]) % mod)\ndef cmb(n, r, mod):\n    if (n < 0 or r < 0):\n        return 0\n    if r > n:\n        return 0\n    return ((fac[n] * f_inv[r]) * f_inv[n - r]) % mod\ndef main():\n    (N, M, K) = list(map(int, readline().split()))\n    MOD = 998244353\n    prepare(N + 10, MOD)\n    if (M == 1 and K == N - 1):\n        print(1)\n        exit()\n    m = M\n    for _ in range(N - 1):\n        m *= M - 1\n        m %= MOD\n    ans = 0\n    for k in range(K + 1):\n        ans += (m * cmb(N - 1, k, MOD)) % MOD\n        ans %= MOD\n        m *= pow(M - 1, MOD - 2, MOD)\n        m %= MOD\n    print(ans)", "generated_code": "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nfac = [1, 1]\nf_inv = [1, 1]\ninv = [0, 1]\ndef prepare(n, mod):\n    for i in range(2, n + 1):\n        fac.append((fac[-1] * i) % mod)\n        inv.append((inv[mod % i] * (mod // i)) % mod)\n        f_inv.append((f_inv[-1] * inv[-1]) % mod)\ndef cmb(n, r, mod):\n    if (n < 0 or r < 0):\n        return 0\n    if r > n:\n        return 0\n    return ((fac[n] * f_inv[r]) * f_inv[n - r]) % mod\ndef main():\n    (N, M, K) = list(map(int, readline().split()))\n    MOD = 998244353\n    prepare(N + 10, MOD)\n    if (M == 1 and K == N - 1):\n        print(1)\n        exit()\n    m = M\n    for _ in range(N - 1):\n        m *= M - 1\n        m %= MOD\n    ans = 0\n    for k in range(K + 1):\n        ans += (m * cmb(N - 1, k, MOD)) % MOD\n        ans %= MOD\n        m *= pow(M - 1, MOD - 2, MOD)\n        m %= MOD\n    print(ans)", "score": 0.0, "codebleu": 0.9655976278032165, "crystalbleu": 0.98, "codebertscore": 0.99, "codescore": 0.9938933253288269, "surfaceSim": 0.9972253052164262, "abs_surfaceSim_minus_score": 0.9972253052164262, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_PIE_extra_p02612_s828418851_OP_1", "golden_code": "n = int(eval(input())) % 1000\n\nif n == 0:\n\n    print((0))\n\nelse:\n\n    print((1000 - n))", "generated_code": "n = int(eval(input()))\n\nprint(((1000 - n % 1000) % 1000))", "score": 1.0, "codebleu": 0.21019676769457696, "crystalbleu": 0, "codebertscore": 0.9, "codescore": 0.793185830116272, "surfaceSim": 0.7089490968801313, "abs_surfaceSim_minus_score": 0.2910509031198687, "source": "local", "local_type": "OP"}
{"id": "LOCAL_MBPP_351_MUT_20", "golden_code": "import os\n\ndef first_Element(arr, n, k):\n    count_map = {}\n    for i in range(0, n):\n        if arr[i] in count_map.keys():\n            count_map[arr[i]] += 1\n        else:\n            count_map[arr[i]] = 1\n        i += 1\n    for i in range(0, n):\n        if count_map[arr[i]] == k:\n            return arr[i]\n        i += 1\n    return -1", "generated_code": "import os\n\ndef first_Element(arr, n, k):\n    count_map = {}\n    for i in range(0, n):\n        if arr[i] in count_map.keys():\n            count_map[arr[i]] += 1\n        else:\n            count_map[arr[i]] = 1\n        i += 1\n    for i in range(0, n):\n        if count_map[arr[i]] == k:\n            pass\n        i += 1\n    return -1", "score": 0.2387, "codebleu": 0.8997224187922994, "crystalbleu": 0.9, "codebertscore": 0.99, "codescore": 0.8641871213912964, "surfaceSim": 0.965209292132369, "abs_surfaceSim_minus_score": 0.7265092921323689, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_APPS_955_11_MUT_1", "golden_code": "n = int(input())\nd = {}\nfor _ in range(n):\n    s = input().split()\n    p = int(s[0])\n    s[1] = list(s[1])\n    s[1].sort()\n    s[1] = ''.join(s[1])\n    if s[1] in d:\n        d[s[1]] = min(d[s[1]], p)\n    else:\n        d[s[1]] = p\ndef get(s):\n    if s in d:\n        return d[s]\n    return 10 ** 6\na = get('A')\nb = get('B')\nc = get('C')\nab = get('AB')\nbc = get('BC')\nac = get('AC')\nabc = get('ABC')\nans = min((a + b) + c, a + bc, b + ac, c + ab, abc, ab + bc, ab + ac, ac + bc)\nif ans < 10 ** 6:\n    print(ans)\nelse:\n    print(-1)", "generated_code": "n = int(input())\nd = {}\nfor _ in range(n):\n    s = input().split()\n    p = int(s[0])\n    s[1] = list(s[1])\n    s[1].sort()\n    s[1] = ''.join(s[1])\n    if s[1] in d:\n        d[s[1]] = min(d[s[1]], p)\n    else:\n        d[s[1]] = p\ndef get(s):\n    if s in d:\n        return d[s]\n    return 10 ** 6\na = get('A')\nb = get('B')\nc = get('C')\nab = get('AB')\nbc = get('BC')\nac = get('AC')\nabc = get('ABC')\nans = min((a + b) + c, a + bc, b + ac, c + ab, abc, ab + bc, ab + ac, ac + bc)\nif ans < 10 ** 6:\n    print(ans)\nelse:\n    print(1)", "score": 0.0, "codebleu": 0.9803174518341569, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9937969446182251, "surfaceSim": 0.9605914918414918, "abs_surfaceSim_minus_score": 0.9605914918414918, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_MBPP_838_OP_1", "golden_code": "def min_Swaps(s1,s2) :  \r\n    c0 = 0; c1 = 0;  \r\n    for i in range(len(s1)) :  \r\n        if (s1[i] == '0' and s2[i] == '1') : \r\n            c0 += 1;    \r\n        elif (s1[i] == '1' and s2[i] == '0') : \r\n            c1 += 1;  \r\n    result = c0 // 2 + c1 // 2;  \r\n    if (c0 % 2 == 0 and c1 % 2 == 0) : \r\n        return result;  \r\n    elif ((c0 + c1) % 2 == 0) : \r\n        return result + 2;  \r\n    else : \r\n        return -1;  ", "generated_code": "def min_Swaps(str1, str2):\n    count_diff_0 = 0\n    count_diff_1 = 0\n    for char1, char2 in zip(str1, str2):\n        if char1 == '0' and char2 == '1':\n            count_diff_0 += 1\n        elif char1 == '1' and char2 == '0':\n            count_diff_1 += 1\n    swaps = (count_diff_0 // 2) + (count_diff_1 // 2)\n    if count_diff_0 % 2 == 0 and count_diff_1 % 2 == 0:\n        return swaps\n    elif (count_diff_0 + count_diff_1) % 2 == 0:\n        return swaps + 2\n    else:\n        return -1", "score": 1.0, "codebleu": 0.39982246274081196, "crystalbleu": 0.14, "codebertscore": 0.86, "codescore": 0.9939369559288025, "surfaceSim": 0.7610428051001821, "abs_surfaceSim_minus_score": 0.23895719489981793, "source": "local", "local_type": "OP"}
{"id": "LOCAL_PIE_p02555_s973678433_MUT_36", "golden_code": "def cmb(n, r):\n    import math\n    if n < r:\n        return 0\n    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\ndef solve(S):\n    mod = (10 ** 9) + 7\n    ans = 0\n    for i in range(1, (S // 3) + 1):\n        tama = i + (S - (i * 3))\n        tama -= 2\n        bo = i - 1\n        ans += cmb(tama + 1, bo)\n        ans %= mod\n    print(ans)", "generated_code": "def cmb(n, r):\n    import math\n    if n < r:\n        return 0\n    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\ndef solve(S):\n    mod = (10 ** 9) + 7\n    pass\n    for i in range(1, (S // 3) + 1):\n        tama = i + (S - (i * 3))\n        tama -= 2\n        bo = i - 1\n        ans += cmb(tama + 1, bo)\n        ans %= mod\n    print(ans)", "score": 0.0, "codebleu": 0.8347949180891591, "crystalbleu": 0.94, "codebertscore": 0.99, "codescore": 0.9937438368797302, "surfaceSim": 0.976602690937871, "abs_surfaceSim_minus_score": 0.976602690937871, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_MBPP_541_MUT_16", "golden_code": "import os\n\nimport math\ndef get_sum(n):\n    sum = 0\n    i = 1\n    while i <= math.sqrt(n):\n        if n % i == 0:\n            if n / i == i:\n                sum = sum + i\n            else:\n                sum = sum + i\n                sum = sum + (n / i)\n        i = i + 1\n    sum = sum - n\n    return sum\ndef check_abundant(n):\n    if get_sum(n) > n:\n        return True\n    else:\n        return False", "generated_code": "import os\n\nimport math\ndef get_sum(n):\n    sum = 0\n    i = 1\n    while i <= math.sqrt(n):\n        if n % i == 0:\n            if n / i == i:\n                sum = sum + i\n            else:\n                sum = sum + i\n                sum = sum + (n / i)\n        i = i + 1\n    sum = sum - n\n    return sum\ndef check_abundant(n):\n    if get_sum(n) > n:\n        return True\n    else:\n        return False", "score": 0.0631, "codebleu": 1.0, "crystalbleu": 1.0, "codebertscore": 1.0, "codescore": 0.993701696395874, "surfaceSim": 1.0, "abs_surfaceSim_minus_score": 0.9369, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-0603_28", "golden_code": "t = list(map(int, input().split()))\nx = min(t)\ns = 0\nfor i in range(3):\n    s += (t[i] - x) // 3\n    if (t[i] - x) % 3 == 2 and x > 0:\n        s += 1\n        t[i] = x - 1\n    else: t[i] = x + (t[i] - x) % 3\n        \nprint(s + min(t))", "generated_code": "r,g,b = list(map(int, input().split()))\nprint(max(r,g,int((r+g+b)/3)))\n", "score": 0.0136, "codebleu": 0.10617047218254094, "crystalbleu": 0, "codebertscore": 0.73, "codescore": 0.031235195696353912, "surfaceSim": 0.4754869593925388, "abs_surfaceSim_minus_score": 0.4618869593925388, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_3738_2_MUT_168", "golden_code": "def minus_two(x, y):\n    return [x[0] - y[0], x[1] - y[1]]\n\ndef will_reach(loc, commands):\n    new_loc = [0, 0]\n    possible_locs = [[0, 0]]\n    for c in commands:\n        if c == 'U':\n            new_loc[1] += 1\n        elif c == 'D':\n            new_loc[1] -= 1\n        elif c == 'R':\n            new_loc[0] += 1\n        elif c == 'L':\n            new_loc[0] -= 1\n        possible_locs += [list(new_loc)]\n    \n    \n    all_destinations = [minus_two(loc, pl) for pl in possible_locs]\n    \n    \n    for destination in all_destinations:\n        realdx = destination[0]\n        realdy = destination[1]\n        \n        reqdx = new_loc[0]\n        reqdy = new_loc[1]\n        \n        if destination == [0, 0]:\n            return True\n        \n        if (reqdx != 0 and realdx != 0):\n            if (realdy / realdx == reqdy / reqdx and \\\n                ((realdy > 0 and reqdy > 0) or (realdy < 0 and reqdy < 0)) and \\\n                realdy / reqdy == int(realdy / reqdy) and \\\n                realdx / reqdx == int(realdx / reqdx)):\n                return True\n        if (realdy == reqdy and realdx == reqdx):\n            return True\n        if (reqdx == 0 and realdx == 0):\n            if (((reqdy > 0 and realdy > 0) or (reqdy < 0 and realdy < 0)) and \\\n                realdy / reqdy == int(realdy / reqdy)):\n                return True\n        if (reqdy == 0 and realdy == 0):\n            \n            if (((reqdx > 0 and realdx > 0) or (reqdx < 0 and realdx < 0)) and \\\n                realdx / reqdx == int(realdx / reqdx)):\n                return True\n    return False\n\n\ndef will_reach2(loc, commands):\n    new_loc = [0, 0]\n    available_loc = []\n    for c in commands:\n        if c == 'U':\n            new_loc[1] += 1\n        elif c == 'D':\n            new_loc[1] -= 1\n        elif c == 'R':\n            new_loc[0] += 1\n        elif c == 'L':\n            new_loc[0] -= 1\n        available_loc += [new_loc]\n    \n    \n    realdx = new_loc[0]\n    realdy = new_loc[1]\n    \n    reqdx = loc[0]\n    reqdy = loc[1]\n    \n    print('realdx', realdx)\n    print('realdy', realdy)\n    print('reqdx', reqdx)\n    print('reqdy', reqdy)\n    \n    \n    if (reqdx != 0 and realdx != 0):\n        return realdy / realdx == reqdy / reqdx\n    elif (reqdx == 0 and realdx == 0):\n        return reqdy / realdy > 0\n    else:\n        return False\n\n\ndef main():\n    first_line = input()\n    first_line = first_line.split()\n    \n    loc = [int(first_line[0]), int(first_line[1])]\n    \n    cmds = input()\n    \n    \n    if will_reach(loc, cmds):\n        print('Yes')\n    else:\n        print('No')\n\n\n\nmain()", "generated_code": "def minus_two(x, y):\n    return [x[0] - y[0], x[1] - y[1]]\n\ndef will_reach(loc, commands):\n    new_loc = [0, 0]\n    possible_locs = [[0, 0]]\n    for c in commands:\n        if c == 'U':\n            new_loc[1] += 1\n        elif c == 'D':\n            new_loc[1] -= 1\n        elif c == 'R':\n            new_loc[0] += 1\n        elif c == 'L':\n            new_loc[0] -= 1\n        possible_locs += [list(new_loc)]\n    \n    \n    all_destinations = [minus_two(loc, pl) for pl in possible_locs]\n    \n    \n    for destination in all_destinations:\n        realdx = destination[0]\n        realdy = destination[1]\n        \n        reqdx = new_loc[0]\n        reqdy = new_loc[1]\n        \n        if destination == [0, 0]:\n            return True\n        \n        if (reqdx != 0 and realdx != 0):\n            if (realdy / realdx == reqdy / reqdx and \\\n                ((realdy > 0 and reqdy > 0) or (realdy < 0 and reqdy < 0)) and \\\n                realdy / reqdy == int(realdy / reqdy) and \\\n                realdx / reqdx == int(realdx / reqdx)):\n                return True\n        if (realdy == reqdy and realdx == reqdx):\n            return True\n        if (reqdx == 0 and realdx == 0):\n            if (((reqdy > 0 and realdy > 0) or (reqdy < 0 and realdy < 0)) and \\\n                realdy / reqdy == int(realdy / reqdy)):\n                return True\n        if (reqdy == 0 and realdy == 0):\n            \n            if (((reqdx > 0 and realdx > 0) or (reqdx < 0 and realdx < 0)) and \\\n                realdx / reqdx == int(realdx / reqdx)):\n                return True\n    return False\n\n\ndef will_reach2(loc, commands):\n    new_loc = [0, 0]\n    available_loc = []\n    for c in commands:\n        if c == 'U':\n            new_loc[1] += 1\n        elif c == 'D':\n            new_loc[1] -= 1\n        elif c == 'R':\n            new_loc[0] += 1\n        elif c == 'L':\n            new_loc[0] -= 1\n        available_loc += [new_loc]\n    \n    \n    realdx = new_loc[0]\n    realdy = new_loc[1]\n    \n    reqdx = loc[0]\n    reqdy = loc[1]\n    \n    print('realdx', realdx)\n    print('realdy', realdy)\n    print('reqdx', reqdx)\n    print('reqdy', reqdy)\n    \n    \n    if (reqdx != 0 and realdx != 0):\n        return realdy / realdx == reqdy / reqdx\n    elif (reqdx == 0 and realdx == 0):\n        return reqdy / realdy > 0\n    else:\n        return False\n\n\ndef main():\n    first_line = input()\n    first_line = first_line.split()\n    \n    pass\n    \n    cmds = input()\n    \n    \n    if will_reach(loc, cmds):\n        print('Yes')\n    else:\n        print('No')\n\n\n\nmain()", "score": 0.0, "codebleu": 0.9756876972364854, "crystalbleu": 0.96, "codebertscore": 1.0, "codescore": 0.9934792518615723, "surfaceSim": 0.9773545359274616, "abs_surfaceSim_minus_score": 0.9773545359274616, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_MBPP_522_MUT_46", "golden_code": "import os\n\ndef lbs(arr):\n    n = len(arr)\n    lis = [1 for i in range(n + 1)]\n    for i in range(1, n):\n        for j in range(0, i):\n            if (arr[i] > arr[j] and lis[i] < lis[j] + 1):\n                lis[i] = lis[j] + 1\n    lds = [1 for i in range(n + 1)]\n    for i in reversed(range(n - 1)):\n        for j in reversed(range(i - 1, n)):\n            if (arr[i] > arr[j] and lds[i] < lds[j] + 1):\n                lds[i] = lds[j] + 1\n    maximum = (lis[0] + lds[0]) - 1\n    for i in range(1, n):\n        maximum = max((lis[i] + lds[i]) - 1, maximum)\n    return maximum", "generated_code": "import os\n\ndef lbs(arr):\n    n = len(arr)\n    lis = [1 for i in range(n + 1)]\n    for i in range(1, n):\n        for j in range(0, i):\n            if (arr[i] > arr[j] and lis[i] < lis[j] + 1):\n                lis[i] = lis[j] + 1\n    lds = [1 for i in range(n + 1)]\n    for i in reversed(range(n - 1)):\n        for j in reversed(range(i - 1, n)):\n            if (arr[i] > arr[j] and lds[i] < lds[j] + 1):\n                lds[i] = lds[j] + 1\n    maximum = (lis[0] + lds[0]) - 1\n    for i in range(1, n):\n        maximum = max((lis[i] + lds[i]) - 1, maximum)\n    pass", "score": 0.0, "codebleu": 0.9758543506704822, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.993884265422821, "surfaceSim": 0.9538145100972326, "abs_surfaceSim_minus_score": 0.9538145100972326, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-0986_54", "golden_code": "def dist(a, f, i):\n    for j in range(i + 1, len(a)):\n        if f == a[j]:\n            return j\n\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\nbooks = set()\nl = 0\npref = [0 for i in range(n)]\nfor i in range(n - 1, -1, -1):\n    pref[a[i] - 1] = max(pref[a[i] - 1], i) # i min == 0\nres = 0\nfor i in range(n):\n    if a[i] not in books:\n        if l == k:\n            for j in books:\n                if pref[j - 1] < i:\n                    l -= 1\n                    books.discard(j)\n                    break\n            if l == k:\n                m = -1\n                for j in books:\n                    if dist(a, j, i) > m:\n                        m = dist(a, j, i)\n                        ind = j\n                books.discard(ind)\n                l -= 1\n        res += 1\n        books.add(a[i])\n        l += 1\nprint(res)", "generated_code": "n,k = list(map(int,input().split()))\na = list(map (int,input().strip().split()))[:n]\nc = k\nz = 1e9\nfor i in range(n):\n\tif a[i] < c:\n\t\tc = a[i]\n\t\tz = i\n\t\t\nprint (k - z)\n", "score": 0.0036, "codebleu": 0.13309385436106203, "crystalbleu": 0.05, "codebertscore": 0.75, "codescore": 0.04261798784136772, "surfaceSim": 0.5742584859192633, "abs_surfaceSim_minus_score": 0.5706584859192633, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0112_55", "golden_code": "from itertools import product as comb\nfrom itertools import permutations as perm\nk = int(input())\ncubes = [input().split(\" \") for i in range(k)]\nnums = set()\nfor n in range(1, k + 1):\n    for p in perm(list(range(k)), n):\n#        print(p)\n        # p is (0, 2, 1) order of cubes\n        for c in comb(list(range(6)), repeat=n):\n #           if p == (1, 0):\n#                print(\"--\" + str(c))\n            nn = \"\"\n            for i in range(n):\n  #              if p == (1, 0):\n   #                 print(\"----\" + str(p[i]) + \"-\" + str(c[i]) + \"-\" + cubes[p[i]][c[i]])\n                nn += cubes[p[i]][c[i]]\n            nums.add(int(nn))\n#print(\"fuckwrvbwoe\")\n#print(\"yes\" if 12 in nums else \"no\")\n#print(nums)\nans = 0\nwhile ans + 1 in nums:\n    ans += 1\nprint(ans)\n", "generated_code": "n = int(input())\na = [list(map(int, input().split())) for i in range(n)]\nans = 0\nwhile a:\n\tt = a[-1][0]\n\ta.pop()\n\tans = max(ans, max(t))\n\tif max(a) == t:\n\t\tbreak\nprint(ans)\n", "score": 0.0, "codebleu": 0.16124498454666253, "crystalbleu": 0.1, "codebertscore": 0.68, "codescore": 0.22939544916152954, "surfaceSim": 0.6124605238714471, "abs_surfaceSim_minus_score": 0.6124605238714471, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_MBPP_512_MUT_5", "golden_code": "import os\n\ndef flatten(test_tuple):\n    for tup in test_tuple:\n        if isinstance(tup, tuple):\n            yield from flatten(tup)\n        else:\n            yield tup\ndef count_element_freq(test_tuple):\n    res = {}\n    for ele in flatten(test_tuple):\n        if ele not in res:\n            res[ele] = 0\n        res[ele] += 1\n    return res", "generated_code": "import os\n\ndef flatten(test_tuple):\n    for tup in test_tuple:\n        if isinstance(tup, tuple):\n            yield from flatten(tup)\n        else:\n            yield tup\ndef count_element_freq(test_tuple):\n    res = {}\n    for ele in flatten(test_tuple):\n        if ele not in res:\n            res[ele] = 0\n        res[ele] += 1\n    return res", "score": 0.0, "codebleu": 1.0, "crystalbleu": 0, "codebertscore": 1.0, "codescore": 0.9937222599983215, "surfaceSim": 1.0, "abs_surfaceSim_minus_score": 1.0, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_MBPP_315_MUT_8", "golden_code": "import os\n\ndef find_Max_Len_Even(str):\n    n = len(str)\n    i = 0\n    currlen = 0\n    maxlen = 0\n    st = -1\n    while i < n:\n        if str[i] == ' ':\n            if currlen % 2 == 0:\n                if maxlen < currlen:\n                    maxlen = currlen\n                    st = i - currlen\n            currlen = 0\n        else:\n            currlen += 1\n        i += 1\n    if currlen % 2 == 0:\n        if maxlen < currlen:\n            maxlen = currlen\n            st = i - currlen\n    if st == -1:\n        return '-1'\n    return str[st:st + maxlen]", "generated_code": "import os\n\ndef find_Max_Len_Even(str):\n    n = len(str)\n    i = 0\n    currlen = 0\n    maxlen = 0\n    st = -1\n    while i < n:\n        if str[i] == ' ':\n            if currlen % 2 == 0:\n                if maxlen < currlen:\n                    maxlen = currlen\n                    st = i - currlen\n            currlen = 0\n        else:\n            currlen += 1\n        i += 1\n    if currlen % 2 == 0:\n        if maxlen < currlen:\n            maxlen = currlen\n            st = i - currlen\n    if st == +1:\n        return '-1'\n    return str[st:st + maxlen]", "score": 0.3223, "codebleu": 0.9849540603994249, "crystalbleu": 0.97, "codebertscore": 1.0, "codescore": 0.9937062859535217, "surfaceSim": 0.9818544615576479, "abs_surfaceSim_minus_score": 0.6595544615576479, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_APPS_13_1_MUT_37", "golden_code": "import sys\n\ndef main():\n    \n    (n, k) = map(int, sys.stdin.readline().split())\n    courses = list(map(int, sys.stdin.readline().split()))\n    courses = [x - 1 for x in courses]\n    \n    visited = [False] * n\n    used = [False] * n\n    \n    ans = []\n    t = []\n    \n    for i in range(n):\n        temp = list(map(int, sys.stdin.readline().split()))\n        temp = [x - 1 for x in temp]\n        t.append(temp[1:])\n    \n    for i in range(k):\n        c = courses[i]\n        if used[c]:\n            continue\n        \n        q = [c]\n        visited[c] = True\n        while len(q) > 0:\n            cur = q[-1]\n            if len(t[cur]) != 0:\n                s = t[cur].pop()\n                if (visited[s] and not (used[s])):\n                    print(-1)\n                    return\n                if used[s]:\n                    continue\n                q.append(s)\n                visited[s] = True\n            else:\n                ans.append(cur)\n                q.pop()\n                used[cur] = True\n    \n    ans = [str(x + 1) for x in ans]\n    print(len(ans))\n    print(' '.join(ans))\n\nmain()", "generated_code": "import sys\n\ndef main():\n    \n    (n, k) = map(int, sys.stdin.readline().split())\n    courses = list(map(int, sys.stdin.readline().split()))\n    pass\n    \n    visited = [False] * n\n    used = [False] * n\n    \n    ans = []\n    t = []\n    \n    for i in range(n):\n        temp = list(map(int, sys.stdin.readline().split()))\n        temp = [x - 1 for x in temp]\n        t.append(temp[1:])\n    \n    for i in range(k):\n        c = courses[i]\n        if used[c]:\n            continue\n        \n        q = [c]\n        visited[c] = True\n        while len(q) > 0:\n            cur = q[-1]\n            if len(t[cur]) != 0:\n                s = t[cur].pop()\n                if (visited[s] and not (used[s])):\n                    print(-1)\n                    return\n                if used[s]:\n                    continue\n                q.append(s)\n                visited[s] = True\n            else:\n                ans.append(cur)\n                q.pop()\n                used[cur] = True\n    \n    ans = [str(x + 1) for x in ans]\n    print(len(ans))\n    print(' '.join(ans))\n\nmain()", "score": 0.0005, "codebleu": 0.8717750961421924, "crystalbleu": 0.95, "codebertscore": 0.99, "codescore": 0.9938284754753113, "surfaceSim": 0.975933014354067, "abs_surfaceSim_minus_score": 0.975433014354067, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_MBPP_493_MUT_70", "golden_code": "import os\n\nimport math\ndef calculate_polygons(startx, starty, endx, endy, radius):\n    sl = (2 * radius) * math.tan(math.pi / 6)\n    p = sl * 0.5\n    b = sl * math.cos(math.radians(30))\n    w = b * 2\n    h = 2 * sl\n    startx = startx - w\n    starty = starty - h\n    endx = endx + w\n    endy = endy + h\n    origx = startx\n    origy = starty\n    xoffset = b\n    yoffset = 3 * p\n    polygons = []\n    row = 1\n    counter = 0\n    while starty < endy:\n        if row % 2 == 0:\n            startx = origx + xoffset\n        else:\n            startx = origx\n        while startx < endx:\n            p1x = startx\n            p1y = starty + p\n            p2x = startx\n            p2y = starty + (3 * p)\n            p3x = startx + b\n            p3y = starty + h\n            p4x = startx + w\n            p4y = starty + (3 * p)\n            p5x = startx + w\n            p5y = starty + p\n            p6x = startx + b\n            p6y = starty\n            poly = [\\\n                (p1x, p1y), \\\n                (p2x, p2y), \\\n                (p3x, p3y), \\\n                (p4x, p4y), \\\n                (p5x, p5y), \\\n                (p6x, p6y), \\\n                (p1x, p1y)]\n            polygons.append(poly)\n            counter += 1\n            startx += w\n        starty += yoffset\n        row += 1\n    return polygons", "generated_code": "import os\n\nimport math\ndef calculate_polygons(startx, starty, endx, endy, radius):\n    sl = (2 * radius) * math.tan(math.pi / 6)\n    p = sl * 0.5\n    b = sl * math.cos(math.radians(30))\n    w = b * 2\n    h = 2 * sl\n    startx = startx - w\n    starty = starty - h\n    pass\n    endy = endy + h\n    origx = startx\n    origy = starty\n    xoffset = b\n    yoffset = 3 * p\n    polygons = []\n    row = 1\n    counter = 0\n    while starty < endy:\n        if row % 2 == 0:\n            startx = origx + xoffset\n        else:\n            startx = origx\n        while startx < endx:\n            p1x = startx\n            p1y = starty + p\n            p2x = startx\n            p2y = starty + (3 * p)\n            p3x = startx + b\n            p3y = starty + h\n            p4x = startx + w\n            p4y = starty + (3 * p)\n            p5x = startx + w\n            p5y = starty + p\n            p6x = startx + b\n            p6y = starty\n            poly = [\\\n                (p1x, p1y), \\\n                (p2x, p2y), \\\n                (p3x, p3y), \\\n                (p4x, p4y), \\\n                (p5x, p5y), \\\n                (p6x, p6y), \\\n                (p1x, p1y)]\n            polygons.append(poly)\n            counter += 1\n            startx += w\n        starty += yoffset\n        row += 1\n    return polygons", "score": 0.0, "codebleu": 0.9726821363500003, "crystalbleu": 0.97, "codebertscore": 0.99, "codescore": 0.9937320351600647, "surfaceSim": 0.9791123049373242, "abs_surfaceSim_minus_score": 0.9791123049373242, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_HE_86_OP_1", "golden_code": "def anti_shuffle(s):\n    return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])", "generated_code": "def anti_shuffle(text):\n    return ' '.join(''.join(sorted(word)) for word in text.split())", "score": 0.7511, "codebleu": 0.3262787111496228, "crystalbleu": 0, "codebertscore": 0.94, "codescore": 0.5722435116767883, "surfaceSim": 0.7967032967032968, "abs_surfaceSim_minus_score": 0.04560329670329677, "source": "local", "local_type": "OP"}
{"id": "LOCAL_PIE_extra_p02691_s116716284_OP_1", "golden_code": "n = int(eval(input()))\n\na = list(map(int, input().split()))\n\na_index = []\n\nfor i in range(n):\n\n    a_index.append((i, a[i]))\n\ndic1 = {}\n\ndic2 = {}\n\nfor i in range(n):\n\n    one = a_index[i][0] + a_index[i][1]\n\n    two = a_index[i][0] - a_index[i][1]\n\n    if one not in dic1:\n\n        dic1[one] = 1\n\n    else:\n\n        dic1[one] += 1\n\n    if two not in dic2:\n\n        dic2[two] = 1\n\n    else:\n\n        dic2[two] += 1\n\nans = 0\n\nfor i in list(dic1.keys()):\n\n    if i in dic2:\n\n        ans += dic2[i] * dic1[i]\n\nfor i in list(dic2.keys()):\n\n    if i in dic1:\n\n        ans += dic1[i] * dic2[i]\n\n        #print(i)\n\nprint((ans // 2))\n", "generated_code": "n = int(eval(input()))\n\na = list(map(int, input().split()))\n\nimport collections\n\nans = 0\n\ndic = collections.defaultdict(int)\n\nfor i in range(1, n + 1):\n\n    ans += dic[i - a[i - 1]]\n\n    dic[i + a[i - 1]] += 1\n\nprint(ans)", "score": 0.9962, "codebleu": 0.15796793039199267, "crystalbleu": 0.08, "codebertscore": 0.8, "codescore": 0.40510812401771545, "surfaceSim": 0.5574784049224943, "abs_surfaceSim_minus_score": 0.43872159507750563, "source": "local", "local_type": "OP"}
{"id": "LOCAL_APPS_1541_0_MUT_9", "golden_code": "s = input()\nsuc = 0\np = 0\nkde = 0\nfor i in range(len(s)):\n    c = s[i]\n    if c == '^':\n        kde = i\nfor i in range(len(s)):\n    c = s[i]\n    if '1' <= c <= '9':\n        suc += (kde - i) * int(c)\n        p += 1\nif suc < 0:\n    print('right')\nelif suc > 0:\n    print('left')\nelse:\n    print('balance')", "generated_code": "s = input()\nsuc = 0\np = 0\nkde = 0\nfor i in range(len(s)):\n    c = s[i]\n    if c == '^':\n        kde = i\nfor i in range(len(s)):\n    c = s[i]\n    if '1' <= c <= '9':\n        suc += (kde - i) * int(c)\n        p += 1\nif not (suc < 0):\n    print('right')\nelif suc > 0:\n    print('left')\nelse:\n    print('balance')", "score": 0.0, "codebleu": 0.953454335203434, "crystalbleu": 0.93, "codebertscore": 0.99, "codescore": 0.993743360042572, "surfaceSim": 0.9502427184466019, "abs_surfaceSim_minus_score": 0.9502427184466019, "source": "local", "local_type": "MUT"}
{"id": "MBPP_172_2", "golden_code": "def max_product_tuple(list1):\r\n    result_max = max([abs(x * y) for x, y in list1] )\r\n    return result_max", "generated_code": "def max_product_tuple(n): return (lambda c: int(c) if c.isdecimal() else 1 + cc(c.__eq__(n)) if n else 1)", "score": 0.0, "codebleu": 0.10022470203758138, "crystalbleu": 0, "codebertscore": 0.77, "codescore": 0.026427436619997025, "surfaceSim": 0.4399532710280374, "abs_surfaceSim_minus_score": 0.4399532710280374, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_18_38", "golden_code": "def is_Isomorphic(str1,str2):          \r\n    dict_str1 = {}\r\n    dict_str2 = {}\r\n    for i, value in enumerate(str1):\r\n        dict_str1[value] = dict_str1.get(value,[]) + [i]        \r\n    for j, value in enumerate(str2):\r\n        dict_str2[value] = dict_str2.get(value,[]) + [j]\r\n    if sorted(dict_str1.values()) == sorted(dict_str2.values()):\r\n        return True\r\n    else:\r\n        return False", "generated_code": "def is_Isomorphic(str1,str2):          \n\treturn True if str1==str2 else False\nss = []", "score": 0.9458, "codebleu": 0.053523393387281556, "crystalbleu": 0, "codebertscore": 0.74, "codescore": 0.9410226345062256, "surfaceSim": 0.4801065162907268, "abs_surfaceSim_minus_score": 0.46569348370927316, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_40_OP_1", "golden_code": "def triples_sum_to_zero(l: list):\n    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False", "generated_code": "def triples_sum_to_zero(numbers: list):\n    numbers.sort()\n    length = len(numbers)\n    for index in range(length - 2):\n        if index > 0 and numbers[index] == numbers[index - 1]:\n            continue\n        left, right = index + 1, length - 1\n        while left < right:\n            total = numbers[index] + numbers[left] + numbers[right]\n            if total == 0:\n                return True\n            elif total < 0:\n                left += 1\n            else:\n                right -= 1\n    return False", "score": 1.0, "codebleu": 0.2952798403006782, "crystalbleu": 0.1, "codebertscore": 0.82, "codescore": 0.58364337682724, "surfaceSim": 0.5951456310679611, "abs_surfaceSim_minus_score": 0.40485436893203886, "source": "local", "local_type": "OP"}
{"id": "APPS_test-0143_35", "golden_code": "#!/usr/bin/env python3\n\nfrom collections import Counter\n\ntry:\n    while True:\n        n = int(input())\n        a = sorted(map(int, input().split()))\n        t = 1\n        for x in a:\n            t = min(t, x) + 1\n\n        print(t)\n\nexcept EOFError:\n    pass\n", "generated_code": "def main():\n\tn = int(input())\n\tl = list(map(int, input().split()))\n\thelper = [0] * n\n\tfor i in range(n):\n\t\thelper[i] = max(l[i], helper[i - 1])\n\tprint(max(helper))\n\n\ndef __starting_point():\n\tmain()\n\n__starting_point()\n", "score": 0.0056, "codebleu": 0.21217928659407664, "crystalbleu": 0, "codebertscore": 0.73, "codescore": 0.05681571736931801, "surfaceSim": 0.4428682170542636, "abs_surfaceSim_minus_score": 0.4372682170542636, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0828_17", "golden_code": "\"\"\" This is a solution to the problem Subordinates on codeforces.com\n    \n    There is a DAG with n nodes, pointing towards the root, without further constraints. \n    Given: for each node, a number signifying the count of (direct and indirect) predecessors, and the ID of root s.\n    Some of these counts might be wrong. Give the minimum amount of wrong counts.\n    \n    For details, see\n    http://codeforces.com/problemset/problem/729/E\n\"\"\"\n\n#Idea: count = level of DAG. Check constraints: root has 0 predecessors, level 0 has only one count, each level to the last has be > 0\n\nfrom sys import stdin\n\n#lines = open(\"input.txt\", 'r').readlines()\nlines = stdin.readlines()\n\nn, s = map(int, lines[0].split())\ncounts = list(map(int, lines[1].split()))\n    \ntotalwrong = 0\nif counts[s-1] > 0: # root has to be 0\n    totalwrong += 1\n    counts[s-1] = 0\n     \nmaxlevel = max(counts)    \n# count number of nodes on levels\nlevelcount = [0] * (max(counts) + 1)\n\nfor c in counts:\n    levelcount[c] += 1\n    \ncurwrong = levelcount[0] - 1 # only one root\nlevelcount[0] = 1\ntotalwrong += curwrong \n\ncurlevel = 0\nwhile curlevel <= maxlevel:\n    lc = levelcount[curlevel]\n    if lc == 0:         # a mistake\n        if curwrong > 0: # still mistakes available, just use them to fill\n            curwrong -= 1\n            levelcount[curlevel] = 1\n        else: # else fill from last level\n            levelcount[maxlevel] -= 1\n            levelcount[curlevel] = 1        \n            totalwrong += 1\n            while levelcount[maxlevel] == 0:\n                maxlevel -= 1       # as levelcount[curlevel] = 1, this aborts at some point\n    curlevel += 1\nprint(totalwrong)", "generated_code": "n,s = list(map(int,input().split()))\n\na = list(map (int,input().strip().split())) + [n]\n\nans = n\n\nfor i in range (n-1,0,-1):\n\tif a[i]!= 0:\n\t\tans = min(ans,a[i])\n\nif s == 0:\n\tans -= 1\n\nprint (ans)\n\n\n\n\n# Made By Mostafa_Khaled\n", "score": 0.0196, "codebleu": 0.12373734909536098, "crystalbleu": 0.05, "codebertscore": 0.64, "codescore": 0.08436069637537003, "surfaceSim": 0.5856841470765521, "abs_surfaceSim_minus_score": 0.5660841470765522, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_43_14", "golden_code": "def is_Two_Alter(s):  \r\n    for i in range (len( s) - 2) : \r\n        if (s[i] != s[i + 2]) : \r\n            return False\r\n    if (s[0] == s[1]): \r\n        return False\r\n    return True", "generated_code": "def is_Two_Alter(s):\n\n\treturn True if '.' not in s else True", "score": 0.1774, "codebleu": 0.060583502471313506, "crystalbleu": 0, "codebertscore": 0.77, "codescore": 0.023071732372045517, "surfaceSim": 0.5050919026328863, "abs_surfaceSim_minus_score": 0.3276919026328863, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0736_71", "golden_code": "'''\nCreated on Oct 12, 2014\n\n@author: Ismael\n'''\nok = False\nn,m = map(int,input().split())\nfor y in range(n//2,-1,-1):\n    if((n-y)%m==0):\n        print(y+(n-2*y))\n        ok = True\n        break\nif(not ok):\n    print(-1)", "generated_code": "n, m = [int(x) for x in input().split()]\nif n == m:\n\tprint(n)\nelif n < m:\n\tkeys = [x for x in range(1, m+1) if x%m == 0]\n\tif keys:\n\t\tprint(sum(keys)//m)\n\telse:\n\t\tprint(-1)\nelse:\n\tprint((m*(m+1))//2)\n", "score": 0.0098, "codebleu": 0.1680476830371881, "crystalbleu": 0, "codebertscore": 0.79, "codescore": 0.14666421711444855, "surfaceSim": 0.5468409586056644, "abs_surfaceSim_minus_score": 0.5370409586056644, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0472_9", "golden_code": "def s(x):\n\n    return sum(int(i) for i in str(x))\n\n\n\nn = input()\n\nl, n = 9 * len(n), int(n)\n\nans, m = -1, int(n ** 0.5)\n\nfor x in range(max(1, m - l), m + 1):\n\n    if n % x == 0 and x * (x + s(x)) == n:\n\n        ans = x\n\n        break\n\nprint(ans)\n\n\n\n# Made By Mostafa_Khaled\n", "generated_code": "import math\nn = int(input())\n\ndef sum_digits(n):\n\treturn sum([int(d) for d in str(n)])\n\nx = -1\nfor i in range(n, 0, -1):\n\tx = i\n\tif sum_digits(_) == i:\n\t\tprint(i)\n\t\tbreak\n\nif x == -1:\n\tprint(-1)\n", "score": 0.0, "codebleu": 0.16775795168650037, "crystalbleu": 0, "codebertscore": 0.82, "codescore": 0.06324372440576553, "surfaceSim": 0.5812121212121213, "abs_surfaceSim_minus_score": 0.5812121212121213, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_p02680_s341076610_MUT_136", "golden_code": "import sys\n(n, m, *abcdef) = list(map(int, sys.stdin.buffer.read().split()))\nver_lines = []\nhor_lines = []\nx_list = set()\ny_list = set()\nn3 = n * 3\nfor (a, b, c) in zip(abcdef[0:n3:3], abcdef[1:n3:3], abcdef[2:n3:3]):\n    y_list.add(a)\n    y_list.add(b)\n    x_list.add(c)\n    ver_lines.append((a, b, c))\nfor (d, e, f) in zip(abcdef[n3 + 0::3], abcdef[n3 + 1::3], abcdef[n3 + 2::3]):\n    y_list.add(d)\n    x_list.add(e)\n    x_list.add(f)\n    hor_lines.append((d, e, f))\nx_list.add(0)\ny_list.add(0)\nx_list = sorted(x_list)\ny_list = sorted(y_list)\nx_dict = {x: i for (i, x) in enumerate(x_list, start=1)}\ny_dict = {y: i for (i, y) in enumerate(y_list, start=1)}\nrow_real = len(x_list)\ncol_real = len(y_list)\nrow = row_real + 2\ncol = col_real + 2\nbanned_up_ij = [[0] * row for _ in range(col)]\nbanned_down_ij = [[0] * row for _ in range(col)]\nbanned_left_ij = [[0] * col for _ in range(row)]\nbanned_right_ij = [[0] * col for _ in range(row)]\nfor (a, b, c) in ver_lines:\n    if a > b:\n        (a, b) = (b, a)\n    ai = y_dict[a]\n    bi = y_dict[b]\n    j = x_dict[c]\n    banned_left_ij[j][ai] += 1\n    banned_left_ij[j][bi] -= 1\n    banned_right_ij[j - 1][ai] += 1\n    banned_right_ij[j - 1][bi] -= 1\nfor (d, e, f) in hor_lines:\n    if e > f:\n        (e, f) = (f, e)\n    i = y_dict[d]\n    ej = x_dict[e]\n    fj = x_dict[f]\n    banned_up_ij[i][ej] += 1\n    banned_up_ij[i][fj] -= 1\n    banned_down_ij[i - 1][ej] += 1\n    banned_down_ij[i - 1][fj] -= 1\nbanned_up = [0] * (row * col)\nbanned_down = [0] * (row * col)\nbanned_left = [0] * (row * col)\nbanned_right = [0] * (row * col)\nfor i in range(col):\n    ru = banned_up_ij[i]\n    rd = banned_down_ij[i]\n    ri = row * i\n    banned_up[ri] = ru[0]\n    banned_down[ri] = rd[0]\n    for j in range(1, row):\n        banned_up[ri + j] = banned_up[(ri + j) - 1] + ru[j]\n        banned_down[ri + j] = banned_down[(ri + j) - 1] + rd[j]\nfor j in range(row):\n    rl = banned_left_ij[j]\n    rr = banned_right_ij[j]\n    banned_left[j] = rl[0]\n    banned_right[j] = rr[0]\n    for i in range(1, col):\n        ri0 = (i - 1) * row\n        ri1 = i * row\n        banned_left[ri1 + j] = banned_left[ri0 + j] + rl[i]\n        banned_right[ri1 + j] = banned_right[ri0 + j] + rr[i]\ns = (row * y_dict[0]) + x_dict[0]\nenable = (([-1] * row) + ((([-1] + ([0] * (row - 2))) + [-1]) * (col - 2))) + ([-1] * row)\nq = [s]\nmoves = [(-row, banned_up), (-1, banned_left), (1, banned_right), (row, banned_down)]\nwhile q:\n    c = q.pop()\n    if enable[c] == 1:\n        continue\n    elif enable[c] == -1:\n        print('INF')\n        exit()\n    enable[c] = 1\n    for (dc, banned) in moves:\n        if banned[c]:\n            continue\n        nc = c + dc\n        if enable[nc] == 1:\n            continue\n        q.append(nc)\nans = 0\nfor i in range(col):\n    ri = i * row\n    for j in range(row):\n        if enable[ri + j] != 1:\n            continue\n        t = y_list[i - 1]\n        b = y_list[i]\n        l = x_list[j - 1]\n        r = x_list[j]\n        ans += (b - t) * (r - l)\nprint(ans)", "generated_code": "import sys\n(n, m, *abcdef) = list(map(int, sys.stdin.buffer.read().split()))\nver_lines = []\nhor_lines = []\nx_list = set()\ny_list = set()\nn3 = n * 3\nfor (a, b, c) in zip(abcdef[0:n3:3], abcdef[1:n3:3], abcdef[2:n3:3]):\n    y_list.add(a)\n    y_list.add(b)\n    x_list.add(c)\n    ver_lines.append((a, b, c))\nfor (d, e, f) in zip(abcdef[n3 + 0::3], abcdef[n3 + 1::3], abcdef[n3 + 2::3]):\n    y_list.add(d)\n    x_list.add(e)\n    x_list.add(f)\n    hor_lines.append((d, e, f))\nx_list.add(0)\ny_list.add(0)\nx_list = sorted(x_list)\ny_list = sorted(y_list)\nx_dict = {x: i for (i, x) in enumerate(x_list, start=1)}\ny_dict = {y: i for (i, y) in enumerate(y_list, start=1)}\nrow_real = len(x_list)\ncol_real = len(y_list)\nrow = row_real + 2\ncol = col_real + 2\nbanned_up_ij = [[0] * row for _ in range(col)]\nbanned_down_ij = [[0] * row for _ in range(col)]\nbanned_left_ij = [[0] * col for _ in range(row)]\nbanned_right_ij = [[0] * col for _ in range(row)]\nfor (a, b, c) in ver_lines:\n    if a > b:\n        (a, b) = (b, a)\n    ai = y_dict[a]\n    bi = y_dict[b]\n    j = x_dict[c]\n    banned_left_ij[j][ai] += 1\n    banned_left_ij[j][bi] -= 1\n    banned_right_ij[j - 1][ai] += 1\n    banned_right_ij[j - 1][bi] -= 1\nfor (d, e, f) in hor_lines:\n    if e > f:\n        (e, f) = (f, e)\n    i = y_dict[d]\n    ej = x_dict[e]\n    fj = x_dict[f]\n    banned_up_ij[i][ej] += 1\n    banned_up_ij[i][fj] -= 1\n    banned_down_ij[i - 1][ej] += 1\n    banned_down_ij[i - 1][fj] -= 1\nbanned_up = [0] * (row * col)\nbanned_down = [0] * (row * col)\nbanned_left = [0] * (row * col)\nbanned_right = [0] * (row * col)\nfor i in range(col):\n    ru = banned_up_ij[i]\n    rd = banned_down_ij[i]\n    ri = row * i\n    banned_up[ri] = ru[0]\n    banned_down[ri] = rd[0]\n    for j in range(1, row):\n        banned_up[ri + j] = banned_up[(ri + j) - 1] + ru[j]\n        banned_down[ri + j] = banned_down[(ri + j) - 1] + rd[j]\nfor j in range(row):\n    rl = banned_left_ij[j]\n    rr = banned_right_ij[j]\n    banned_left[j] = rl[0]\n    banned_right[j] = rr[0]\n    for i in range(1, col):\n        ri0 = (i - 1) * row\n        ri1 = i * row\n        banned_left[ri1 + j] = banned_left[ri0 + j] + rl[i]\n        banned_right[ri1 + j] = banned_right[ri0 + j] + rr[i]\ns = (row * y_dict[0]) + x_dict[0]\nenable = (([-1] * row) + ((([-1] + ([0] * (row - 2))) + [-1]) * (col - 2))) + ([-1] * row)\nq = [s]\nmoves = [(-row, banned_up), (-1, banned_left), (1, banned_right), (row, banned_down)]\nwhile not q:\n    c = q.pop()\n    if enable[c] == 1:\n        continue\n    elif enable[c] == -1:\n        print('INF')\n        exit()\n    enable[c] = 1\n    for (dc, banned) in moves:\n        if banned[c]:\n            continue\n        nc = c + dc\n        if enable[nc] == 1:\n            continue\n        q.append(nc)\nans = 0\nfor i in range(col):\n    ri = i * row\n    for j in range(row):\n        if enable[ri + j] != 1:\n            continue\n        t = y_list[i - 1]\n        b = y_list[i]\n        l = x_list[j - 1]\n        r = x_list[j]\n        ans += (b - t) * (r - l)\nprint(ans)", "score": 0.0, "codebleu": 0.9968950881332175, "crystalbleu": 1.0, "codebertscore": 1.0, "codescore": 0.9542139172554016, "surfaceSim": 0.9859853170912309, "abs_surfaceSim_minus_score": 0.9859853170912309, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_PIE_p02537_s645565645_MUT_139", "golden_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "generated_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += __n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "score": 0.0, "codebleu": 0.9884911427299241, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9823526740074158, "surfaceSim": 0.9984634296250768, "abs_surfaceSim_minus_score": 0.9984634296250768, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_PIE_extra_p03078_s065985582_OP_1", "golden_code": "\n\nfrom heapq import heappop, heappush\n\n\n\nX, Y, Z, K = list(map(int, input().split()))\n\nA = list(map(int, input().split()))\n\nB = list(map(int, input().split()))\n\nC = list(map(int, input().split()))\n\n\n\nA.sort(reverse=True)\n\nB.sort(reverse=True)\n\nC.sort(reverse=True)\n\n\n\npq = []\n\nheappush(pq, (-A[0] - B[0] - C[0], 0, 0, 0))\n\nappeared = set((0, 0, 0))\n\n\n\nfor _ in range(K):\n\n    # Pop maximum value\n\n    val, i, j, k = heappop(pq)\n\n    print((-val))\n\n\n\n    # Add next value\n\n    if i + 1 < X and (i + 1, j, k) not in appeared:\n\n        heappush(pq, (-A[i + 1] - B[j] - C[k], i + 1, j, k))\n\n        appeared.add((i + 1, j, k))\n\n\n\n    if j + 1 < Y and (i, j + 1, k) not in appeared:\n\n        heappush(pq, (-A[i] - B[j + 1] - C[k], i, j + 1, k))\n\n        appeared.add((i, j + 1, k))\n\n\n\n    if k + 1 < Z and (i, j, k + 1) not in appeared:\n\n        heappush(pq, (-A[i] - B[j] - C[k + 1], i, j, k + 1))\n\n        appeared.add((i, j, k + 1))\n", "generated_code": "\n\nX, Y, Z, K = list(map(int, input().split()))\n\nA = list(map(int, input().split()))\n\nB = list(map(int, input().split()))\n\nC = list(map(int, input().split()))\n\n\n\nA.sort(reverse=True)\n\nB.sort(reverse=True)\n\nC.sort(reverse=True)\n\n\n\nres = []\n\nfor i in range(X):\n\n    for j in range(Y):\n\n        for k in range(Z):\n\n            if (i + 1) * (j + 1) * (k + 1) <= K:\n\n                res.append(A[i] + B[j] + C[k])\n\n            else:\n\n                break\n\n\n\nres.sort(reverse=True)\n\nfor i in range(K):\n\n    print((res[i]))\n", "score": 1.0, "codebleu": 0.2751344456213444, "crystalbleu": 0.21, "codebertscore": 0.81, "codescore": 0.2793150544166565, "surfaceSim": 0.613111118810852, "abs_surfaceSim_minus_score": 0.386888881189148, "source": "local", "local_type": "OP"}
{"id": "APPS_test-2607_47", "golden_code": "# @author \n\nimport sys\n\nclass ABeautifulString:\n    def solve(self):\n\n        def get_not(arr):\n            for x in ['a', 'b', 'c']:\n                if x not in arr:\n                    return x\n\n            assert(False)\n\n        for _ in range(int(input())):\n            s = list(input())\n            n = len(s)\n            for i in range(n - 1):\n                if s[i] == s[i + 1] and s[i] != '?':\n                    print(-1)\n                    break\n            else:\n                x = 3 * ord('a') + 1 +2\n                for i in range(n):\n                    if s[i] == '?':\n                        if (i > 0 and i < n - 1):\n                            s[i] = get_not([s[i - 1], s[i + 1]])\n                        elif i == 0:\n                            s[i] = get_not([s[i + 1]])\n                        else:\n                            s[i] = get_not([s[i - 1]])\n\n                print(''.join(s))\n\nsolver = ABeautifulString()\ninput = sys.stdin.readline\n\nsolver.solve()\n", "generated_code": "q = int(input())\nfor _ in range(q):\n\ts = input()\n\tpre = None\n\tapp = None\n\tfor i in range(len(s) - 1):\n\t\tif s[i] == \"?\":\n\t\t\tif pre and s[i]!= pre[0]:\n\t\t\t\tprint(-1)\n\t\t\t\tbreak\n\t\t\tpre = s[i]\n\t\t\tapp = s[i + 1:]\n\t\telse:\n\t\t\tpre, app = s[i], s[i + element]\n\telse:\n\t\tif pre and pre[0]!= \"?\":\n\t\t\t\tprint(- 1)\n\t\telse: pre = s[len(s) // 2]\n\tprint(pre)\n", "score": 0.0, "codebleu": 0.20189190966521933, "crystalbleu": 0.12, "codebertscore": 0.76, "codescore": 0.22044028341770172, "surfaceSim": 0.6117147922998987, "abs_surfaceSim_minus_score": 0.6117147922998987, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-1306_17", "golden_code": "n, h = map(int, input().split())\na = list(map(int, input().split()))\nmod = 10 ** 9 + 7\n\ndp = [[0] * 2000  for i in range(n)]\n\ndp[0][0] = 1 if a[0] in (h, h - 1) else 0\ndp[0][1] = 1 if a[0] == h - 1 else 0\n\nfor i in range(1, n):\n    opn = h - a[i]\n    if opn >= 0:\n        dp[i][opn] += dp[i-1][opn]\n        if opn > 0:\n            dp[i][opn] += dp[i-1][opn-1]\n        dp[i][opn] %= mod\n    opn -= 1\n    if opn >= 0:\n        dp[i][opn] += dp[i-1][opn+1] * (opn+1) + dp[i-1][opn] + dp[i-1][opn] * opn\n        dp[i][opn] %= mod\n\nprint(dp[-1][0])", "generated_code": "def main():\n\tn, h = list(map(int, input().split()))\n\ta = list(map (int, input().strip().split()))\n\n\tif n == 1:\n\t\tprint (h)\n\t\treturn\n\n\tlast = a[0]\n\tans = 1\n\tfor i in range(1, n):\n\t\tif a[i] == last:\n\t\t\tans = (ans * (i - last + 1)) % 1000000007\n\t\telse:\n\t\t\tlast = a[i]\n\tans *= (n - 1 - last)\n\tans %= 1000000007\n\n\tprint (ans)\n\n\ndef __starting_point():\n\tmain()\n\n__starting_point()\n", "score": 0.0202, "codebleu": 0.1811541406985476, "crystalbleu": 0.15, "codebertscore": 0.77, "codescore": 0.07014688104391098, "surfaceSim": 0.5578281497100686, "abs_surfaceSim_minus_score": 0.5376281497100686, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_43_3", "golden_code": "def is_Two_Alter(s):  \r\n    for i in range (len( s) - 2) : \r\n        if (s[i] != s[i + 2]) : \r\n            return False\r\n    if (s[0] == s[1]): \r\n        return False\r\n    return True", "generated_code": "def is_Two_Alter(s):  \n\ta = s[0]\n\tb = s[1]\n\t\n\tif a == b:\n\t\treturn True\n\telse:\n\t\tif (a == 'A' and b == 'B') or (a == b == 'AA') or (b == 'B', a == 'A'):\n\t\t\treturn True\n\t\telse:\n\t\t\treturn False", "score": 0.1825, "codebleu": 0.153789707314269, "crystalbleu": 0, "codebertscore": 0.79, "codescore": 0.0542234368622303, "surfaceSim": 0.5484210526315789, "abs_surfaceSim_minus_score": 0.3659210526315789, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_MBPP_717_MUT_14", "golden_code": "import os\n\nimport math\nimport sys\ndef sd_calc(data):\n    n = len(data)\n    if n <= 1:\n        return 0.0\n    (mean, sd) = (avg_calc(data), 0.0)\n    for el in data:\n        sd += (float(el) - mean) ** 2\n    sd = math.sqrt(sd / float(n - 1))\n    return sd\ndef avg_calc(ls):\n    (n, mean) = (len(ls), 0.0)\n    if n <= 1:\n        return ls[0]\n    for el in ls:\n        mean = mean + float(el)\n    mean = mean / float(n)\n    return mean", "generated_code": "import os\n\nimport math\nimport sys\ndef sd_calc(data):\n    n = len(data)\n    if n <= 1:\n        return 0.0\n    (mean, sd) = (avg_calc(data), 0.0)\n    for el in data:\n        sd += (float(el) - mean) ** 2\n        break\n    sd = math.sqrt(sd / float(n - 1))\n    return sd\ndef avg_calc(ls):\n    (n, mean) = (len(ls), 0.0)\n    if n <= 1:\n        return ls[0]\n    for el in ls:\n        mean = mean + float(el)\n    mean = mean / float(n)\n    return mean", "score": 0.4255, "codebleu": 0.9676811006852961, "crystalbleu": 0.95, "codebertscore": 0.99, "codescore": 0.9938062429428101, "surfaceSim": 0.9754012841091493, "abs_surfaceSim_minus_score": 0.5499012841091493, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_PIE_p02599_s870922238_MUT_49", "golden_code": "import sys\nclass BinaryIndexedTree:\n    def __init__(self, A):\n        self.__n = len(A)\n        self.__node = [0] * (self.__n + 1)\n        self.__data = [0] * (self.__n + 1)\n        S = [0] * (self.__n + 1)\n        for i in range(1, self.__n + 1):\n            S[i] = S[i - 1] + A[i - 1]\n            self.__data[i] = A[i - 1]\n            self.__node[i] = S[i] - S[i - (i & (-i))]\n    def add(self, i, v):\n        self.__data[i] += v\n        while i <= self.__n:\n            self.__node[i] += v\n            i += i & (-i)\n    def sum(self, i):\n        rst = 0\n        while i > 0:\n            rst += self.__node[i]\n            i -= i & (-i)\n        return rst\n    def get(self, i, j):\n        if i == j:\n            return self.__data[i]\n        else:\n            return self.sum(j) - self.sum(i - 1)\ndef main():\n    (N, Q) = map(int, input().split())\n    C = list(map(int, input().split()))\n    P = [[] for _ in range(N)]\n    for (i, c) in enumerate(C):\n        P[c - 1].append(i)\n    right = [0] * N\n    for p in P:\n        if len(p):\n            right[p.pop()] = 1\n    BIT = BinaryIndexedTree(right)\n    query = [[] for _ in range(N)]\n    for (i, s) in enumerate(sys.stdin.readlines()):\n        (l, r) = map(int, s.split())\n        query[r - 1].append((l - 1, i))\n    ans = [None] * Q\n    cur = N - 1\n    for (r, q) in enumerate(reversed(query)):\n        r = (N - 1) - r\n        while q:\n            (l, i) = q.pop()\n            while r < cur:\n                c = C[cur] - 1\n                p = P[c]\n                if len(p):\n                    BIT.add(p.pop() + 1, 1)\n                cur -= 1\n            tmp = BIT.get(l + 1, r + 1)\n            ans[i] = tmp\n    print(sep='\\n', *ans)", "generated_code": "import sys\nclass BinaryIndexedTree:\n    def __init__(self, A):\n        self.__n = len(A)\n        self.__node = [0] * (self.__n + 1)\n        self.__data = [0] * (self.__n + 1)\n        S = [0] * (self.__n + 1)\n        for i in range(1, self.__n + 1):\n            S[i] = S[i - 1] + A[i - 1]\n            self.__data[i] = A[i - 1]\n            self.__node[i] = S[i] - S[i - (i & (-i))]\n    def add(self, i, v):\n        self.__data[i] += v\n        while i <= self.__n:\n            self.__node[i] += v\n            i += i & (-i)\n    def sum(self, i):\n        rst = 0\n        while i > 0:\n            rst += self.__node[i]\n            i -= i & (-i)\n        return rst\n    def get(self, i, j):\n        if i == j:\n            return self.__data[i]\n        else:\n            return self.sum(j) - self.sum(i - 1)\ndef main():\n    (N, Q) = map(int, input().split())\n    C = list(map(int, input().split()))\n    P = [[] for _ in range(N)]\n    for (i, c) in enumerate(C):\n        P[c - 1].append(i)\n    right = [0] * N\n    for p in P:\n        if len(p):\n            right[p.pop()] = 1\n    BIT = BinaryIndexedTree(right)\n    query = [[] for _ in range(N)]\n    for (i, s) in enumerate(sys.stdin.readlines()):\n        (l, r) = map(int, s.split())\n        query[r - 1].append((l - 1, i))\n    ans = [None] * Q\n    cur = N - 1\n    for (r, q) in enumerate(reversed(query)):\n        r = (N - 1) - r\n        while q:\n            (l, i) = q.pop()\n            while r < cur:\n                c = C[cur] - 1\n                p = P[c]\n                if len(p):\n                    BIT.add(p.pop() + 1, 1)\n                cur += 1\n            tmp = BIT.get(l + 1, r + 1)\n            ans[i] = tmp\n    print(sep='\\n', *ans)", "score": 0.0338, "codebleu": 0.994935590512094, "crystalbleu": 1.0, "codebertscore": 1.0, "codescore": 0.9936449527740479, "surfaceSim": 0.9997036158861885, "abs_surfaceSim_minus_score": 0.9659036158861884, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_APPS_4553_17_OP_2", "golden_code": "import re\nA, B = list(map(int, input().split()))\nS = input()\nn_pattern = \"[0-9]\"\nres  = \"Yes\"\nfor i in range(A+B+1):\n  if i < A:\n    if re.match(n_pattern, S[i]) is None:\n      res = \"No\"\n      break\n  elif i == A:\n    if S[i] != \"-\":\n      res = \"No\"\n      break\n  else:\n    if re.match(n_pattern, S[i]) is None:\n      res = \"No\"\n      break\n  \nprint(res)", "generated_code": "import re\ndef check_format():\n    a, b = map(int, input().split())\n    string_input = input()\n    if len(string_input) != a + b + 1:\n        print(\"No\")\n        return\n    if string_input[a] != \"-\":\n        print(\"No\")\n        return\n    if not (string_input[:a].isdigit() and string_input[a+1:].isdigit()):\n        print(\"No\")\n        return\n    print(\"Yes\")\ncheck_format()", "score": 1.0, "codebleu": 0.19195528238623005, "crystalbleu": 0.18, "codebertscore": 0.77, "codescore": 0.8775708675384521, "surfaceSim": 0.5201370320855615, "abs_surfaceSim_minus_score": 0.4798629679144385, "source": "local", "local_type": "OP"}
{"id": "MBPP_72_21", "golden_code": "def Average(lst): \r\n    return sum(lst) / len(lst) ", "generated_code": "def Average(list):\n\treturn sum(list)/len(list)\nh = [(1,2), (3,4), (6,5), (7,8), (9,6), (10,7), (11,8), ('x', 10), (12,13), (14,15), (16,18), (19,20), (22,21), (23,22), (24,25), (26,26)]", "score": 1.0, "codebleu": 0.4921472101039702, "crystalbleu": 0, "codebertscore": 0.72, "codescore": 0.9935518503189087, "surfaceSim": 0.49819819819819816, "abs_surfaceSim_minus_score": 0.5018018018018018, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-2190_21", "golden_code": "from math import *\n\nn, k = list(map(int, input().split()))\na = [int(i) for i in input().split()]\nma = max(a)\n\np = []\nprime = [True] * (ma + 1)\nprime[0] = False\nprime[1] = False\nfor i in range(2, ma + 1):\n    if prime[i]:\n        p.append(i)\n        if i**2 <= n:\n            for j in range(i**2, ma + 1, i):\n                prime[j] = False\n\n\ndef factor(x):\n    res = {}\n    sq = ceil(sqrt(x))\n    for i in p:\n        if i > sq or x <= 1:\n            break\n        if x % i == 0:\n            res[i] = 0\n            while x % i == 0:\n                res[i] += 1\n                x //= i\n    if x > 1:\n        res[x] = 1\n    nres = []\n    for j in res:\n        if res[j] % k > 0:\n            nres.append((j, res[j] % k))\n    \n    return tuple(nres)\n\nd = {}\nfor i in range(n):\n    f = factor(a[i])\n    #print(f, a[i])\n    if f not in d:\n        d[f] = 1\n    else:\n        d[f] += 1\n        \nans = 0\n#print(d)\nfor x in d:\n    y = []\n    for i in x:\n        y.append((i[0], k - i[1]))\n    y = tuple(y)\n    if y in d:\n        if y != x:\n            ans += d[x] * d[y]\n        else:\n            ans += d[x] * (d[y] - 1)\n    #print(x, y, ans)\n\nprint(ans//2)\n", "generated_code": "import sys\nimport math\n\ndef main():\n\tn, k = list(map(int, input().split()))\n\ta = list(map (int, input().strip().split()))\n\n\td = {}\n\n\tfor i in range(1, n+1):\n\t\td[i] = 0\n\n\tfor i, a_i in enumerate(a):\n\t\tfor j in range(i+1, n+ 1):\n\t\t\tb = a[j-1] * a[i]\n\t\t\tif b < a_i:\n\t\t\t\tbreak\n\t\t\td[a_i] += 1\n\n\tans = 0\n\n\tl = 0\n\tfor i in d:\n\t\tans += d[i] * (d[i] - 1) // 2\n\t\tl += d[i];\n\n\tans += l * (l - 1) // 4\n\n\tprint(ans)\n", "score": 0.0, "codebleu": 0.1953988054773606, "crystalbleu": 0.13, "codebertscore": 0.79, "codescore": 0.03100922703742981, "surfaceSim": 0.579576443284015, "abs_surfaceSim_minus_score": 0.579576443284015, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_1384_19_OP_1", "golden_code": "n = int(input())\na = list(map(int, input().split()))\np = [0] * n\np[0]= a[0]\nfor i in range(1, n):\n    p[i] = p[i - 1] + a[i]\nans = min(n, n - p[n - 1])\nfor i in range(n):\n    l = p[i]\n    r = (n - i - 1) - (p[n - 1] - p[i])\n    ans = min(ans, l + r)\nprint(n - ans)", "generated_code": "m = int(input())\nb = list(map(int, input().split()))\ncum_sum = [0] * m\ncum_sum[0] = b[0]\nfor j in range(1, m):\n    cum_sum[j] = cum_sum[j - 1] + b[j]\nresult = min(m, m - cum_sum[m - 1])\nfor j in range(m):\n    left = cum_sum[j]\n    right = (m - j - 1) - (cum_sum[m - 1] - cum_sum[j])\n    result = min(result, left + right)\nprint(m - result)\n", "score": 1.0, "codebleu": 0.5157723922088139, "crystalbleu": 0.32, "codebertscore": 0.88, "codescore": 0.09983555972576141, "surfaceSim": 0.836764705882353, "abs_surfaceSim_minus_score": 0.16323529411764703, "source": "local", "local_type": "OP"}
{"id": "MBPP_332_2", "golden_code": "def remove_words(list1, charlist):\r\n    new_list = []\r\n    for line in list1:\r\n        new_words = ' '.join([word for word in line.split() if not any([phrase in word for phrase in charlist])])\r\n        new_list.append(new_words)\r\n    return new_list", "generated_code": "def remove_words(strng,*args):\n\tval = str(args[0])\n\treturn ''.join(char if char == '*' else '' for char in val)", "score": 0.0, "codebleu": 0.08005660025995529, "crystalbleu": 0, "codebertscore": 0.74, "codescore": 0.18194535374641418, "surfaceSim": 0.49413036762434354, "abs_surfaceSim_minus_score": 0.49413036762434354, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_MBPP_783_OP_1", "golden_code": "def rgb_to_hsv(r, g, b):\r\n    r, g, b = r/255.0, g/255.0, b/255.0\r\n    mx = max(r, g, b)\r\n    mn = min(r, g, b)\r\n    df = mx-mn\r\n    if mx == mn:\r\n        h = 0\r\n    elif mx == r:\r\n        h = (60 * ((g-b)/df) + 360) % 360\r\n    elif mx == g:\r\n        h = (60 * ((b-r)/df) + 120) % 360\r\n    elif mx == b:\r\n        h = (60 * ((r-g)/df) + 240) % 360\r\n    if mx == 0:\r\n        s = 0\r\n    else:\r\n        s = (df/mx)*100\r\n    v = mx*100\r\n    return h, s, v", "generated_code": "def rgb_to_hsv(red, green, blue):\n    red, green, blue = red/255.0, green/255.0, blue/255.0\n    maximum = max(red, green, blue)\n    minimum = min(red, green, blue)\n    delta = maximum - minimum\n    if delta == 0:\n        hue = 0\n    elif maximum == red:\n        hue = (60 * ((green - blue) / delta) + 360) % 360\n    elif maximum == green:\n        hue = (60 * ((blue - red) / delta) + 120) % 360\n    else:\n        hue = (60 * ((red - green) / delta) + 240) % 360\n    saturation = 0 if maximum == 0 else (delta / maximum) * 100\n    value = maximum * 100\n    return hue, saturation, value", "score": 1.0, "codebleu": 0.5126897855791612, "crystalbleu": 0.18, "codebertscore": 0.84, "codescore": 0.8858879208564758, "surfaceSim": 0.8123154623154624, "abs_surfaceSim_minus_score": 0.18768453768453763, "source": "local", "local_type": "OP"}
{"id": "LOCAL_PIE_extra_p03796_s848409194_OP_1", "golden_code": "import math\n\nN = int(eval(input()))\n\nprint((math.factorial(N)%(10**9+7)))", "generated_code": "import math\n\nN = int(eval(input()))\n\na = 1\n\nfor n in range(2,N+1):\n\n    a = a*n % (10**9+7)\n\nprint(a)", "score": 1.0, "codebleu": 0.5101463671792871, "crystalbleu": 0, "codebertscore": 0.87, "codescore": 0.8996055722236633, "surfaceSim": 0.7434478741991846, "abs_surfaceSim_minus_score": 0.25655212580081543, "source": "local", "local_type": "OP"}
{"id": "APPS_test-1149_8", "golden_code": "n = int(input())\nb = [0 for i in range(n)]\nnums = list(map(int, input().split()))\nnums2 = list(map(int, input().split()))\nfor i in range(1, len(nums)):\n    b[nums[i] - 1] = 1\nfor i in range(1, len(nums2)):\n    b[nums2[i] - 1] = 1\nif sum(b) == n:\n    print(\"I become the guy.\")\nelse:\n    print(\"Oh, my keyboard!\")", "generated_code": "def main():\n\tfrom sys import stdin, stdout\n\tn = int(stdin.readline())\n\tp = [int(x) for x in stdin.readline().split()]\n\tg = [int(X) for X in stdin.write('\\n')]\n\tl = []\n\tfor i, j in enumerate(p):\n\t\tlevel = []\n\t\tfor k in range(i, i + j + 1):\n\t\t\tlevel.append(k)\n\t\tl.append(level)\n\tfor i in range(n):\n\t\tlevel_count = 0\n\t\tfor k  in l:\n\t\t\tif min(k) == i + 1:\n\t\t\t\tlevel_count += 1\n\t\tif level_count == len(k):\n\t\t\tprint(\"It's a win!\")\n\t\t\treturn\n\tprint(\"It's nont a win!\")\n\n", "score": 0.0, "codebleu": 0.1901324645132217, "crystalbleu": 0.06, "codebertscore": 0.74, "codescore": 0.018265606835484505, "surfaceSim": 0.5027769207034866, "abs_surfaceSim_minus_score": 0.5027769207034866, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_MBPP_195_OP_1", "golden_code": "def first(arr,x,n): \r\n    low = 0\r\n    high = n - 1\r\n    res = -1  \r\n    while (low <= high):\r\n        mid = (low + high) // 2 \r\n        if arr[mid] > x:\r\n            high = mid - 1\r\n        elif arr[mid] < x:\r\n            low = mid + 1\r\n        else:\r\n            res = mid\r\n            high = mid - 1\r\n    return res", "generated_code": "def first(nums, target, length):\n    left, right = 0, length - 1\n    result = -1\n    while left <= right:\n        midpoint = (left + right) // 2\n        if nums[midpoint] == target:\n            result = midpoint\n            right = midpoint - 1\n        elif nums[midpoint] < target:\n            left = midpoint + 1\n        else:\n            right = midpoint - 1\n    return result", "score": 1.0, "codebleu": 0.4691060814335112, "crystalbleu": 0, "codebertscore": 0.84, "codescore": 0.9939128756523132, "surfaceSim": 0.7774000405926527, "abs_surfaceSim_minus_score": 0.22259995940734734, "source": "local", "local_type": "OP"}
{"id": "LOCAL_MBPP_403_MUT_16", "golden_code": "import os\n\nimport re\ndef is_valid_URL(str):\n    regex = ((('((http|https)://)(www.)?' + \\\n        '[a-zA-Z0-9@:%._\\\\+~#?&//=]') + \\\n        '{2,256}\\\\.[a-z]') + \\\n        '{2,6}\\\\b([-a-zA-Z0-9@:%') + \\\n        '._\\\\+~#?&//=]*)'\n    p = re.compile(regex)\n    if str == None:\n        return False\n    if re.search(p, str):\n        return True\n    else:\n        return False", "generated_code": "import os\n\nimport re\ndef is_valid_URL(str):\n    regex = ((('((http|https)://)(www.)?' + \\\n        '[a-zA-Z0-9@:%._\\\\+~#?&//=]') + \\\n        '{2,256}\\\\.[a-z]') + \\\n        '{2,6}\\\\b([-a-zA-Z0-9@:%') + \\\n        '._\\\\+~#?&//=]*)'\n    p = re.compile(regex)\n    if str == None:\n        return False\n    if re.search(p, str):\n        return True\n    else:\n        pass", "score": 0.0, "codebleu": 0.9399051095387992, "crystalbleu": 0.95, "codebertscore": 1.0, "codescore": 0.9937359094619751, "surfaceSim": 0.9628706199460917, "abs_surfaceSim_minus_score": 0.9628706199460917, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-0442_24", "golden_code": "r=int(input())\nif r<=4:\n    print(\"NO\")\nelif r%2==0:\n    print(\"NO\")\nelse :\n    print(1, (r-3)//2)", "generated_code": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\nimport math\n\ndef solve(x, y):\n\tif x == y:\n\t\treturn x, y\n\tr = (x ** 2 + 2 * y + 1) // 2\n\tif r % 1 == 0:\n\t\treturn r, r\n\telse:\n\t\treturn -1\n\ndef __starting_point():\n\tr = int(input())\n\tn = r\n\tresult = solve(r, r)\n\tif result == -1:\n\t\tprint('NO')\n\telse:     \n\t\tprint(*result)\n\n__starting_point()\n", "score": 0.0, "codebleu": 0.3732383595933642, "crystalbleu": 0, "codebertscore": 0.77, "codescore": 0.09589831531047821, "surfaceSim": 0.4936048296326614, "abs_surfaceSim_minus_score": 0.4936048296326614, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_MBPP_129_OP_1", "golden_code": "def magic_square_test(my_matrix):\r\n    iSize = len(my_matrix[0])\r\n    sum_list = []\r\n    sum_list.extend([sum (lines) for lines in my_matrix])   \r\n    for col in range(iSize):\r\n        sum_list.append(sum(row[col] for row in my_matrix))\r\n    result1 = 0\r\n    for i in range(0,iSize):\r\n        result1 +=my_matrix[i][i]\r\n    sum_list.append(result1)      \r\n    result2 = 0\r\n    for i in range(iSize-1,-1,-1):\r\n        result2 +=my_matrix[i][i]\r\n    sum_list.append(result2)\r\n    if len(set(sum_list))>1:\r\n        return False\r\n    return True", "generated_code": "def magic_square_test(matrix):\n    n = len(matrix)\n    diag1_sum = diag2_sum = 0\n    expected_sum = sum(matrix[0])\n    for i in range(n):\n        if sum(matrix[i]) != expected_sum or sum(row[i] for row in matrix) != expected_sum:\n            return False\n        diag1_sum += matrix[i][i]\n        diag2_sum += matrix[i][n - 1 - i]\n    return diag1_sum == expected_sum and diag2_sum == expected_sum", "score": 1.0, "codebleu": 0.2272758474045592, "crystalbleu": 0.12, "codebertscore": 0.8, "codescore": 0.9939146637916565, "surfaceSim": 0.5813852343155377, "abs_surfaceSim_minus_score": 0.4186147656844623, "source": "local", "local_type": "OP"}
{"id": "MBPP_258_2", "golden_code": "def char_frequency(str1):\r\n    dict = {}\r\n    for n in str1:\r\n        keys = dict.keys()\r\n        if n in keys:\r\n            dict[n] += 1\r\n        else:\r\n            dict[n] = 1\r\n    return dict", "generated_code": "def char_frequency(string: str)->int:\n\t\"\"\" index to position in list of characters \"\"\"\n\treturn [char_index(letter) for letter in string]", "score": 0.0, "codebleu": 0.05319139980762763, "crystalbleu": 0, "codebertscore": 0.71, "codescore": 0.018276186659932137, "surfaceSim": 0.4815292096219932, "abs_surfaceSim_minus_score": 0.4815292096219932, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_3723_2_MUT_22", "golden_code": "import functools\n\n\n@functools.lru_cache(maxsize=10000)\ndef factor(n):res = []\n    d = 2\n    while d * d <= n:\n        if n % d == 0:\n            res.append(d)\n            n //= d\n        else:\n            d += 1\n    if n > 1:\n        res.append(n)\n    return set(res)\n\nnum = int(input())\n\npoks = list(map(int, input().split()))[:num]\n\nc = dict()\nfor p in poks:\n    for d in factor(p):\n        if d in c.keys():\n            c[d] += 1\n        else:\n            c[d] = 1\n\nif c:\n    print(max(c.values()))\nelse:\n    print(1)", "generated_code": "import functools\n\n\n@functools.lru_cache(maxsize=10000)\ndef factor(n):res = []\n    d = 2\n    while d * d <= n:\n        if n % d == 0:\n            res.append(d)\n            n //= d\n        else:\n            d += 1\n    if n > 1:\n        res.append(n)\n    return set(res)\n\nnum = int(input())\n\npoks = list(map(int, input().split()))[:num]\n\nc = dict()\nfor p in poks:\n    for d in reversed(factor(p)):\n        if d in c.keys():\n            c[d] += 1\n        else:\n            c[d] = 1\n\nif c:\n    print(max(c.values()))\nelse:\n    print(1)", "score": 0.0, "codebleu": 0.9676546109273558, "crystalbleu": 0.96, "codebertscore": 1.0, "codescore": 0.9938115477561951, "surfaceSim": 0.49056603773584906, "abs_surfaceSim_minus_score": 0.49056603773584906, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_HE_25_MUT_2", "golden_code": "import os\n\nfrom typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    import math\n    fact = []\n    i = 2\n    while i <= int(math.sqrt(n) + 1):\n        if n % i == 0:\n            fact.append(i)\n            n //= i\n        else:\n            i += 1\n    \n    if n > 1:\n        fact.append(n)\n    return fact", "generated_code": "import os\n\nfrom typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    import math\n    fact = []\n    i = 2\n    while i <= int(math.sqrt(n) + 1):\n        if n * i == 0:\n            fact.append(i)\n            n //= i\n        else:\n            i += 1\n    \n    if n > 1:\n        fact.append(n)\n    return fact", "score": 0.1731, "codebleu": 0.9719618269500463, "crystalbleu": 0, "codebertscore": 0.99, "codescore": 0.9935884475708008, "surfaceSim": 0.9661342184420703, "abs_surfaceSim_minus_score": 0.7930342184420702, "source": "local", "local_type": "MUT"}
{"id": "MBPP_43_25", "golden_code": "def is_Two_Alter(s):  \r\n    for i in range (len( s) - 2) : \r\n        if (s[i] != s[i + 2]) : \r\n            return False\r\n    if (s[0] == s[1]): \r\n        return False\r\n    return True", "generated_code": "def is_Two_Alter(s):\n    \n    return s == ''.join(str(i) for i in s)", "score": 0.1598, "codebleu": 0.12943004201609648, "crystalbleu": 0, "codebertscore": 0.8, "codescore": 0.09042419493198395, "surfaceSim": 0.5477548111190307, "abs_surfaceSim_minus_score": 0.3879548111190307, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_p03837_s032580281_MUT_4", "golden_code": "import queue\nINF = 123456789\ndef main():\n    (n, m) = list(map(int, input().split()))\n    G = [[] for _ in range(n)]\n    for _ in range(m):\n        (a, b, c) = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        G[a].append((b, c))\n        G[b].append((a, c))\n    used = set()\n    for i in range(n):\n        d = [INF for _ in range(n)]\n        par = [-1 for _ in range(n)]\n        que = queue.PriorityQueue()\n        d[i] = 0\n        que.put((0, i))\n        while not (que.empty()):\n            p = que.get()\n            v = p[1]\n            if d[v] < p[0]:\n                continue\n            for (to, cost) in G[v]:\n                if d[to] > d[v] + cost:\n                    d[to] = d[v] + cost\n                    par[to] = v\n                    que.put((d[to], to))\n        for j in range(n):\n            if i != j:\n                (a, b) = (j, par[j])\n                if a > b:\n                    (a, b) = (b, a)\n                used.add((a, b))\n    print(m - len(used))", "generated_code": "import queue\nINF = 123456789\ndef main():\n    (n, m) = list(map(int, input().split()))\n    G = [[] for _ in range(n)]\n    for _ in range(m):\n        (a, b, c) = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        G[a].append((b, c))\n        G[b].append((a, c))\n    used = set()\n    for i in range(n):\n        d = [INF for _ in range(n)]\n        par = [-1 for _ in range(n)]\n        que = queue.PriorityQueue()\n        d[i] = 0\n        que.put((0, i))\n        while not (que.empty()):\n            p = que.get()\n            v = p[1]\n            if d[v] < p[0]:\n                continue\n            for (to, cost) in G[v]:\n                if d[to] > d[v] + cost:\n                    d[to] = d[v] - cost\n                    par[to] = v\n                    que.put((d[to], to))\n        for j in range(n):\n            if i != j:\n                (a, b) = (j, par[j])\n                if a > b:\n                    (a, b) = (b, a)\n                used.add((a, b))\n    print(m - len(used))", "score": 0.0, "codebleu": 0.9904103276685203, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9937750101089478, "surfaceSim": 0.9994979919678715, "abs_surfaceSim_minus_score": 0.9994979919678715, "source": "local", "local_type": "MUT"}
{"id": "MBPP_434_2", "golden_code": "def max_sub_array_sum_repeated(a, n, k): \r\n\tmax_so_far = -2147483648\r\n\tmax_ending_here = 0\r\n\tfor i in range(n*k): \r\n\t\tmax_ending_here = max_ending_here + a[i%n] \r\n\t\tif (max_so_far < max_ending_here): \r\n\t\t\tmax_so_far = max_ending_here \r\n\t\tif (max_ending_here < 0): \r\n\t\t\tmax_ending_here = 0\r\n\treturn max_so_far", "generated_code": "def max_sub_array_sum_repeated(a, size, maxSize):\n\n\tresult = list(set(a))\n\tresult = [0] * size\n\tresult.sort()\n\n\tfor i, c in enumerate(result):\n\t\tif i == 0:\n\t\t\tcontinue\n\t\tfor j in range(i+1, size, k):\n\t\t\tresult.remove(c)\n\t\tresult.append(c) \n\t\n\treturn result\nduplicate = set()", "score": 0.0, "codebleu": 0.1679192538219853, "crystalbleu": 0, "codebertscore": 0.75, "codescore": 0.025986677035689354, "surfaceSim": 0.4895320197044335, "abs_surfaceSim_minus_score": 0.4895320197044335, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_317_1", "golden_code": "def upper_ctr(str):\r\n    upper_ctr = 0\r\n    for i in range(len(str)):\r\n          if str[i] >= 'A' and str[i] <= 'Z': upper_ctr += 1\r\n          return upper_ctr", "generated_code": "def upper_ctr(s):\n\treturn s.replace('a','').replace('A','').capitalize()", "score": 0.0, "codebleu": 0.08829858870482787, "crystalbleu": 0, "codebertscore": 0.76, "codescore": 0.02805149555206299, "surfaceSim": 0.450369155045119, "abs_surfaceSim_minus_score": 0.450369155045119, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_47_12_MUT_22", "golden_code": "(n, x) = map(int, input().split())\nA = list(map(int, input().split()))\nDP = [[0] * 3 for _ in range(n + 1)]\nans = 0\nfor i in range(1, n + 1):\n    DP[i][0] = max(DP[i - 1][0] + A[i - 1], A[i - 1])\n    DP[i][1] = max(DP[i - 1][0] + (A[i - 1] * x), DP[i - 1][1] + (A[i - 1] * x), A[i - 1] * x)\n    DP[i][2] = max(DP[i - 1][1] + A[i - 1], DP[i - 1][2] + A[i - 1], A[i - 1])\n    ans = max(ans, max(DP[i]))\nprint(ans)", "generated_code": "(n, x) = map(int, input().split())\nA = list(map(int, input().split()))\nDP = [[0] * 3 for _ in range(n + 1)]\nans = 0\nfor i in range(1, n + 1):\n    DP[i][0] = max(DP[i - 1][0] + A[i - 1], A[i - 1])\n    DP[i][1] = max(DP[i - 1][0] + (A[i - 1] * x), DP[i - 1][1] + (A[i - 1] * x), A[i + 1] * x)\n    DP[i][2] = max(DP[i - 1][1] + A[i - 1], DP[i - 1][2] + A[i - 1], A[i - 1])\n    ans = max(ans, max(DP[i]))\nprint(ans)", "score": 0.0, "codebleu": 0.9860116946342178, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.9938503503799438, "surfaceSim": 0.9987834549878345, "abs_surfaceSim_minus_score": 0.9987834549878345, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_PIE_p03253_s213127805_MUT_5", "golden_code": "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nMOD = (10 ** 9) + 7\nfac = [1, 1]\nf_inv = [1, 1]\ninv = [0, 1]\ndef prepare(n, mod):\n    for i in range(2, n + 1):\n        fac.append((fac[-1] * i) % mod)\ndef cmb(n, r, mod):\n    if (n < 0 or r < 0):\n        return 0\n    if r > n:\n        return 0\n    return ((fac[n] * pow(fac[r], MOD - 2, MOD)) * pow(fac[n - r], MOD - 2, MOD)) % mod\ndef prime_factorization(n):\n    d = []\n    (i, e) = (2, 0)\n    while i * i <= n:\n        while n % i == 0:\n            n //= i\n            e += 1\n        if e > 0:\n            d.append((i, e))\n        i += 1\n        e = 0\n    if n > 1:\n        d.append((n, 1))\n    return d\ndef main():\n    (N, M) = list(map(int, readline().split()))\n    prepare(N + 100, MOD)\n    d = prime_factorization(M)\n    ans = 1\n    for (i, e) in d:\n        ans *= cmb((N - 1) + e, e, MOD)\n        ans %= MOD\n    print(ans)", "generated_code": "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nMOD = (10 ** 9) + 7\nfac = [1, 1]\nf_inv = [1, 1]\ninv = [0, 1]\ndef prepare(n, mod):\n    for i in range(2, n + 1):\n        fac.append((fac[+1] * i) % mod)\ndef cmb(n, r, mod):\n    if (n < 0 or r < 0):\n        return 0\n    if r > n:\n        return 0\n    return ((fac[n] * pow(fac[r], MOD - 2, MOD)) * pow(fac[n - r], MOD - 2, MOD)) % mod\ndef prime_factorization(n):\n    d = []\n    (i, e) = (2, 0)\n    while i * i <= n:\n        while n % i == 0:\n            n //= i\n            e += 1\n        if e > 0:\n            d.append((i, e))\n        i += 1\n        e = 0\n    if n > 1:\n        d.append((n, 1))\n    return d\ndef main():\n    (N, M) = list(map(int, readline().split()))\n    prepare(N + 100, MOD)\n    d = prime_factorization(M)\n    ans = 1\n    for (i, e) in d:\n        ans *= cmb((N - 1) + e, e, MOD)\n        ans %= MOD\n    print(ans)", "score": 0.0, "codebleu": 0.9924868895723431, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.850180447101593, "surfaceSim": 0.9744594594594594, "abs_surfaceSim_minus_score": 0.9744594594594594, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_PIE_extra_p03425_s293375746_OP_1", "golden_code": "import itertools\n\nfrom collections import Counter\n\nN = int(eval(input()))\n\nsrc = [eval(input()) for i in range(N)]\n\nctr = Counter()\n\nfor s in src:\n\n    ctr[s[0]] += 1\n\n\n\nans = 0\n\nfor ptn in itertools.combinations('MARCH',3):\n\n    a,b,c = ptn\n\n    ans += ctr[a]*ctr[b]*ctr[c]\n\nprint(ans)", "generated_code": "N = int(eval(input()))\n\nS = [eval(input()) for i in range(N)]\n\nfrom collections import Counter\n\nctr = Counter([s[0] for s in S])\n\n\n\nans = 0\n\nimport itertools\n\nfor ptn in itertools.combinations('MARCH', 3):\n\n    t = 1\n\n    for c in ptn:\n\n        t *= ctr[c]\n\n    ans += t\n\nprint(ans)", "score": 1.0, "codebleu": 0.4104047494648608, "crystalbleu": 0.46, "codebertscore": 0.93, "codescore": 0.6184759140014648, "surfaceSim": 0.7220279720279721, "abs_surfaceSim_minus_score": 0.2779720279720279, "source": "local", "local_type": "OP"}
{"id": "LOCAL_HE_25_MUT_6", "golden_code": "import os\n\nfrom typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    import math\n    fact = []\n    i = 2\n    while i <= int(math.sqrt(n) + 1):\n        if n % i == 0:\n            fact.append(i)\n            n //= i\n        else:\n            i += 1\n    \n    if n > 1:\n        fact.append(n)\n    return fact", "generated_code": "import os\n\nfrom typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    import math\n    fact = []\n    i = 2\n    while not (i <= int(math.sqrt(n) + 1)):\n        if n % i == 0:\n            fact.append(i)\n            n //= i\n        else:\n            i += 1\n    \n    if n > 1:\n        fact.append(n)\n    return fact", "score": 0.1504, "codebleu": 0.9197165538827209, "crystalbleu": 0, "codebertscore": 0.99, "codescore": 0.993564784526825, "surfaceSim": 0.9608635646687698, "abs_surfaceSim_minus_score": 0.8104635646687698, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_PIE_p02612_s197156959_MUT_22", "golden_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "generated_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\npass\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "score": 0.0, "codebleu": 0.8453552787265628, "crystalbleu": 0.97, "codebertscore": 0.97, "codescore": 0.9938482642173767, "surfaceSim": 0.9622225384177576, "abs_surfaceSim_minus_score": 0.9622225384177576, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-1110_10", "golden_code": "#!/usr/bin/env python3\n\ndef main():\n    n = int(input())\n\n    print(n * (n**2 + 5) // 6)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "generated_code": "def main():\n\tn = int(input())\n\tres = 0\n\tpos = 0\n\tfor i in range(n):\n\t\tneg = pos\n\t\tpos = main()\n\t\tif pos == 1:\n\t\t\tprint(i + 1)\n\t\t\treturn\n\t\tfor j in range(pos, n):\n\t\t\tif not (neg+j)%2:\n\t\t\t\tres += 1\n\t\t\t\tneg = pos\n\t\t\t\tpos = j\n\tprint(res)\n\n\ndef __starting_point():\n\tmain()\n\n__starting_point()\n", "score": 0.0, "codebleu": 0.49972365997900725, "crystalbleu": 0, "codebertscore": 0.75, "codescore": 0.07884234935045242, "surfaceSim": 0.5243055555555556, "abs_surfaceSim_minus_score": 0.5243055555555556, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_extra_p02996_s000658921_OP_1", "golden_code": "import sys\n\ninput = sys.stdin.readline\n\n\n\nn = int(eval(input()))\n\nab = sorted([list(map(int, input().split()))[::-1] for _ in range(n)])\n\n\n\ncnt = 0\n\nfor b, a in ab:\n\n    cnt += a\n\n    if cnt > b:\n\n        print('No')\n\n        break\n\nelse:\n\n    print('Yes')\n", "generated_code": "n = int(eval(input()))\n\nab = [list(map(int, input().split())) for _ in range(n)]\n\nab = sorted(ab, key=lambda x: x[1])\n\n\n\nt = 0\n\nfor a, b in ab:\n\n    t += a\n\n    if t > b:\n\n        print('No')\n\n        break\n\nelse:\n\n    print('Yes')\n", "score": 1.0, "codebleu": 0.4772436406690307, "crystalbleu": 0.49, "codebertscore": 0.89, "codescore": 0.7382808923721313, "surfaceSim": 0.6660181582360571, "abs_surfaceSim_minus_score": 0.33398184176394285, "source": "local", "local_type": "OP"}
{"id": "MBPP_3_44", "golden_code": "def length_Of_Last_Word(a): \r\n    l = 0\r\n    x = a.strip() \r\n    for i in range(len(x)): \r\n        if x[i] == \" \": \r\n            l = 0\r\n        else: \r\n            l += 1\r\n    return l ", "generated_code": "def length_Of_Last_Word (a):\n\treturn len(a) - len(a[0])", "score": 0.1048, "codebleu": 0.07343112897181664, "crystalbleu": 0, "codebertscore": 0.76, "codescore": 0.2160479575395584, "surfaceSim": 0.5824324324324324, "abs_surfaceSim_minus_score": 0.47763243243243236, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_1244_20_MUT_28", "golden_code": "import sys\nimport math\n\nn = int(sys.stdin.readline())\nan = [int(x) for x in sys.stdin.readline().split()]\n\nd = dict()\n\nfor i in an:\n    if i in d:\n        d[i] += 1\n    else:\n        d[i] = 1\n\nvmax = 0\nvsum = 0\nfor i in list(d.keys()):\n    vsum += d[i]\n    if d[i] > vmax:\n        vmax = d[i]\n\nif vsum - vmax >= vmax - 1:\n    print('YES')\nelse:\n    print('NO')", "generated_code": "import sys\nimport math\n\nn = int(sys.stdin.readline())\nan = [int(x) for x in sys.stdin.readline().split()]\n\nd = dict()\n\nfor i in an:\n    if i in d:\n        d[i] += 1\n    else:\n        d[i] = 1\n\nvmax = 0\nvsum = 0\nfor i in list(d.keys()):\n    vsum += d[i]\n    if d[i] > vmax:\n        vmax = d[i]\n\nif vsum - vmax >= vmax - 1:\n    pass\nelse:\n    print('NO')", "score": 0.0, "codebleu": 0.9756249040099523, "crystalbleu": 0.91, "codebertscore": 0.99, "codescore": 0.9939080476760864, "surfaceSim": 0.965491452991453, "abs_surfaceSim_minus_score": 0.965491452991453, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_MBPP_863_OP_1", "golden_code": "def find_longest_conseq_subseq(arr, n): \r\n\tans = 0\r\n\tcount = 0\r\n\tarr.sort() \r\n\tv = [] \r\n\tv.append(arr[0]) \r\n\tfor i in range(1, n): \r\n\t\tif (arr[i] != arr[i - 1]): \r\n\t\t\tv.append(arr[i]) \r\n\tfor i in range(len(v)): \r\n\t\tif (i > 0 and v[i] == v[i - 1] + 1): \r\n\t\t\tcount += 1\r\n\t\telse: \r\n\t\t\tcount = 1\r\n\t\tans = max(ans, count) \r\n\treturn ans ", "generated_code": "def find_longest_conseq_subseq(arr, n):\n    max_seq = 0\n    current_seq = 0\n    unique_elements = set(arr)\n    for num in unique_elements:\n        if num - 1 not in unique_elements:\n            current_num = num\n            current_seq = 1\n            while current_num + 1 in unique_elements:\n                current_num += 1\n                current_seq += 1\n            max_seq = max(max_seq, current_seq)\n    return max_seq", "score": 1.0, "codebleu": 0.17533592766617423, "crystalbleu": 0.07, "codebertscore": 0.77, "codescore": 0.993782103061676, "surfaceSim": 0.581402392851734, "abs_surfaceSim_minus_score": 0.418597607148266, "source": "local", "local_type": "OP"}
{"id": "APPS_test-0593_17", "golden_code": "n,m = list(map(int, input().split()))\ncandidates= n * [0]\nfor i in range(0, m):\n    l = list(map(int, input().split()))\n    candidates[l.index(max(l))] += 1\n\n\nprint (candidates.index(max(candidates)) + 1)", "generated_code": "from sys import stdin\nfrom collections import defaultdict\nfrom bisect import bisect\n\nn, m = map(int, stdin.readline().strip().split())\ncities = defaultdict(list)\nfor _ in range(m):\n\tj = int(stdin.readline())\n\tcities[j].append(1)\n\ncounter = defaultdict(int)\nfor i in cities:\n\tcounter[i] += max(cities[i])\n\nans = []\nfor i in range(1, n + 1):\n\tif counter[i] > counter[i - 1]:\n\t\tans.append(i)\n\nprint('\\n'.join(map(str, ans)))\n", "score": 0.0002, "codebleu": 0.19170302268695144, "crystalbleu": 0.07, "codebertscore": 0.77, "codescore": 0.12338589131832123, "surfaceSim": 0.5283372827804107, "abs_surfaceSim_minus_score": 0.5281372827804107, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_3_3", "golden_code": "def length_Of_Last_Word(a): \r\n    l = 0\r\n    x = a.strip() \r\n    for i in range(len(x)): \r\n        if x[i] == \" \": \r\n            l = 0\r\n        else: \r\n            l += 1\r\n    return l ", "generated_code": "def length_Of_Last_Word(a): \n\treturn 1 + (len(a)-1)*1", "score": 0.8082, "codebleu": 0.061402347414257964, "crystalbleu": 0, "codebertscore": 0.75, "codescore": 0.26471567153930664, "surfaceSim": 0.5498237367802585, "abs_surfaceSim_minus_score": 0.2583762632197415, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_1315_2_MUT_8", "golden_code": "import math, string, itertools, fractions, heapq, collections, re, array, bisect, copy\nfrom itertools import chain, dropwhile, permutations, combinations\nfrom collections import defaultdict, deque\n\ndef VI():\n    return list(map(int, input().split()))\ndef run(n, a):\n    b = copy.copy(a)\n    for i in range(n):\n        b[i] -= n - i\n    b.sort()\n    for i in range(n):\n        if i < n - 1:\n            if b[i] == b[i + 1]:\n                print(':(')\n                return\n        b[i] = str(b[i] + (n - i))\n    print(' '.join(b))\n\n\ndef main(info=0):\n    n = int(input())\n    a = VI()\n    run(n, a)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "generated_code": "import math, string, itertools, fractions, heapq, collections, re, array, bisect, copy\nfrom itertools import chain, dropwhile, permutations, combinations\nfrom collections import defaultdict, deque\n\ndef VI():\n    return list(map(int, input().split()))\ndef run(n, a):\n    b = copy.copy(a)\n    for i in range(n):\n        b[i] -= n - i\n    b.sort()\n    for i in range(n):\n        if i < n - 1:\n            if not (b[i] == b[i + 1]):\n                print(':(')\n                return\n        b[i] = str(b[i] + (n - i))\n    print(' '.join(b))\n\n\ndef main(info=0):\n    n = int(input())\n    a = VI()\n    run(n, a)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "score": 0.178, "codebleu": 0.9502777005973067, "crystalbleu": 0.96, "codebertscore": 1.0, "codescore": 0.9938409328460693, "surfaceSim": 0.9617350931190985, "abs_surfaceSim_minus_score": 0.7837350931190985, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-0419_6", "golden_code": "s = input()\nans = len(s) - 1\nk = 0\nfor i in s:\n    k += int(i)\nif k > 1:\n    ans += 1\nif ans % 2 != 0:\n    ans += 1\n\nprint(ans // 2)", "generated_code": "s = int(input())\n\nb = bin(s)\na = []\narr = b[2:].zfill(100)\n\nk = 0\nfor i in range(len(arr)):\n\tif arr[i] == \"1\":\n\t\ta.append(0)\n\telse:\n\t\ta.insert(0, 1)\n\t\tk += 1\n\nfor i in a:\n\tprint(k - 1)\n", "score": 0.0, "codebleu": 0.25447032702599204, "crystalbleu": 0, "codebertscore": 0.82, "codescore": 0.038855358958244324, "surfaceSim": 0.5324324324324324, "abs_surfaceSim_minus_score": 0.5324324324324324, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_37_3", "golden_code": "def lucky_num(n):\r\n List=range(-1,n*n+9,2)\r\n i=2\r\n while List[i:]:List=sorted(set(List)-set(List[List[i]::List[i]]));i+=1\r\n return List[1:n+1]", "generated_code": "def lucky_num(arg):\n\tc = str(arg).find('.')\n\treturn str(arg)[c+1:] if c>0 else str(arg)", "score": 0.0, "codebleu": 0.11051006973346349, "crystalbleu": 0, "codebertscore": 0.73, "codescore": 0.020627828314900398, "surfaceSim": 0.45043336944745394, "abs_surfaceSim_minus_score": 0.45043336944745394, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_17_MUT_6", "golden_code": "import os\n\nfrom typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    note_map = {'o': 4, 'o|': 2, '.|': 1}\n    return [note_map[x] for x in music_string.split(' ') if x]", "generated_code": "import os\n\nfrom typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    note_map = {'o': 4, 'o|': 2, '.|': 1}\n    pass", "score": 0.0, "codebleu": 0.6015864098515892, "crystalbleu": 0, "codebertscore": 0.94, "codescore": 0.018283581361174583, "surfaceSim": 0.7308270676691729, "abs_surfaceSim_minus_score": 0.7308270676691729, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-2047_10", "golden_code": "import sys\n\n# @profile\ndef main():\n    f = sys.stdin\n    # f = open('input.txt', 'r')\n    # fo = open('log.txt', 'w')\n    n = int(f.readline())\n    # b = []\n    # for i in range(n):\n    #    b.append()\n    b = list(map(int, f.readline().strip().split(' ')))\n    a = list(map(int, f.readline().strip().split(' ')))\n    # return\n    b = [b[i] - a[i] for i in range(n)]\n    c = [[0, 0]]\n    for i in range(n - 1):\n        line = f.readline().strip().split(' ')\n        c.append([int(line[0]), int(line[1])])\n    # print(c)\n    for i in range(n - 1, 0, -1):\n        # print(i)\n        fa = c[i][0] - 1\n        if b[i] >= 0:\n            b[fa] += b[i]\n        else:\n            b[fa] += b[i] * c[i][1]\n            if b[fa] < -1e17:\n                print('NO')\n                return 0\n    # for x in b:\n    #    fo.write(str(x) + '\\n')\n    if b[0] >= 0:\n        print('YES')\n    else:\n        print('NO')\n\nmain()\n", "generated_code": "#!/usr/bin/env python3\n\ndef solve(n, b, a):\n\tbr_sh10 = []\n\tbr_fact = []\n\tfor i in range(n - 1):\n\t\tnxt_arr = input().split()\n\t\tbr_sh10.append(int(nxt_arr[0]))\n\t\tbr_fact.append(int(_arr[1]))\n\tnxt_cnt = sum(br_fact)\n\tnxt(-1)\n\tif nxt_cnt % n == 0:\n\t\treturn 'YES'\n\treturn 'NO'\n\ndef __starting_point():\n\tn = int(input())\n\tb = list(map(int, input().split()))\n\ta = list(map('int', input().split() ))\n\tprint(solve(n, b + a, a))\n\n", "score": 0.0, "codebleu": 0.14304227412346454, "crystalbleu": 0.12, "codebertscore": 0.74, "codescore": 0.018927115947008133, "surfaceSim": 0.6392275763668201, "abs_surfaceSim_minus_score": 0.6392275763668201, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_extra_p02792_s736173164_OP_1", "golden_code": "import itertools\n\nN = int(eval(input()))\n\nNketa = len(str(N))\n\n\n\nrange_count = [[0 for j in range(10)]for i in range(10)]\n\n\n\n\n\nfor p in range(1,N+1):\n\n    mae = int(str(p)[0])\n\n    ato = int(str(p)[-1])\n\n    range_count[mae][ato] += 1\n\n\n\n    \n\n\n\ncount = 0\n\nfor j in range(1,N+1):\n\n    a_mae = int(str(j)[0])\n\n    a_ato = int(str(j)[-1])\n\n    \n\n    b_mae = a_ato\n\n    b_ato = a_mae\n\n    \n\n    if b_mae == 0:\n\n        continue\n\n    else:\n\n        count += range_count[b_mae][b_ato]\n\nprint(count)\n\n  ", "generated_code": "n = int(eval(input()))\n\n\n\nall_count = 0\n\noptions = [str(i) for i in range(10)]\n\n\n\nmaeato = [[0 for i in range(10)] for j in range(10)]\n\n\n\nfor i in range(n+1):\n\n    checking = str(i)\n\n    maeato[int(checking[0])][int(checking[-1])]+=1\n\nall_count = 0\n\nfor i in range(1,10):\n\n    for j in range(1,10):\n\n        for k in range(1,10):\n\n            for p in range(1,10):\n\n                if i == p and j == k:\n\n                    all_count+=maeato[i][j]*maeato[k][p]\n\nprint(all_count)", "score": 1.0, "codebleu": 0.22346479555437554, "crystalbleu": 0.24, "codebertscore": 0.83, "codescore": 0.81722491979599, "surfaceSim": 0.6796333556896936, "abs_surfaceSim_minus_score": 0.32036664431030637, "source": "local", "local_type": "OP"}
{"id": "LOCAL_HE_44_MUT_8", "golden_code": "import os\n\ndef change_base(x: int, base: int):\n    ret = ''\n    while x > 0:\n        ret = str(x % base) + ret\n        x //= base\n    return ret", "generated_code": "import os\n\ndef change_base(x: int, base: int):\n    ret = ''\n    while x > 0:\n        ret = str(x % base) + ret\n        x //= base\n        break\n    return ret", "score": 0.0761, "codebleu": 0.9140836535640275, "crystalbleu": 0, "codebertscore": 0.98, "codescore": 0.9937951564788818, "surfaceSim": 0.9582853855005754, "abs_surfaceSim_minus_score": 0.8821853855005755, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-2383_61", "golden_code": "n=int(input())\na=list(map(int,input().split()))\ncnt=0\nfor i in a:\n    if i==cnt+1:\n        cnt+=1\nif cnt==0:\n    print('-1')\nelse:\n    print(n-cnt)", "generated_code": "N = int(input())\nA = list(map(int, input().split()))\n\ncount = 0\ntemp = A[0]\nfor i in range(1, N):\n\tif A[i] > temp:\n\t\ttemp = A[i]\n\telse:\n\t\tcount += (temp-1)//(N-i)\n\t\ttemp = N*(N-i+1)\n\nif temp > A[-1]:\n\tprint(-1)\n\treturn\n\ntest =test(A, 0, N-1)\nif temp >= N:\n\tprint(N)\nelse:\n\tprint((N-temp)+count)\n", "score": 0.0, "codebleu": 0.3560054630997217, "crystalbleu": 0, "codebertscore": 0.82, "codescore": 0.17200608551502228, "surfaceSim": 0.5653194263363754, "abs_surfaceSim_minus_score": 0.5653194263363754, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_extra_p04020_s879592559_OP_1", "golden_code": "import sys\n\nstdin = sys.stdin\n\n \n\nsys.setrecursionlimit(10**8) \n\n \n\ndef li(): return list(map(int, stdin.readline().split()))\n\ndef li_(): return [int(x)-1 for x in stdin.readline().split()]\n\ndef lf(): return list(map(float, stdin.readline().split()))\n\ndef ls(): return stdin.readline().split()\n\ndef ns(): return stdin.readline().rstrip()\n\ndef lc(): return list(ns())\n\ndef ni(): return int(stdin.readline())\n\ndef nf(): return float(stdin.readline())\n\n\n\n\n\nn = ni()\n\na = [ni() for _ in range(n)]\n\n\n\ncnt = {i+1: ai for i, ai in enumerate(a)}\n\n\n\nprev = -100\n\ncur = 0\n\nans = 0\n\nfor key in sorted(cnt.keys()):\n\n    if cnt[key] == 0:\n\n        continue\n\n    \n\n    if prev == -100:\n\n        prev = key\n\n    \n\n    if (key-prev) < 2:\n\n        cur += cnt[key]\n\n    else:\n\n        cur = cnt[key]\n\n        \n\n    ans += cur // 2\n\n    cur -= 2 * (cur//2)\n\n    \n\n    prev = key\n\n        \n\nprint(ans)", "generated_code": "import sys\n\nstdin = sys.stdin\n\n\n\nsys.setrecursionlimit(10 ** 7)\n\n\n\ndef li(): return list(map(int, stdin.readline().split()))\n\ndef li_(): return [int(x) - 1 for x in stdin.readline().split()]\n\ndef lf(): return list(map(float, stdin.readline().split()))\n\ndef ls(): return stdin.readline().split()\n\ndef ns(): return stdin.readline().rstrip()\n\ndef lc(): return list(ns())\n\ndef ni(): return int(stdin.readline())\n\ndef nf(): return float(stdin.readline())\n\n\n\nn = ni()\n\n\n\nans = 0\n\nplus = 0\n\na = [ni() for _ in range(n)]\n\n\n\nfor ai in a:\n\n    ans += ((ai+plus) // 2)\n\n    plus = (ai+plus) % 2 if ai > 0 else 0\n\n\n\nprint(ans)", "score": 1.0, "codebleu": 0.5423049581901753, "crystalbleu": 0.57, "codebertscore": 0.92, "codescore": 0.5138662457466125, "surfaceSim": 0.7028496325945397, "abs_surfaceSim_minus_score": 0.2971503674054603, "source": "local", "local_type": "OP"}
{"id": "MBPP_31_43", "golden_code": "def smallest_multiple(n):\r\n    if (n<=2):\r\n      return n\r\n    i = n * 2\r\n    factors = [number  for number in range(n, 1, -1) if number * 2 > n]\r\n    while True:\r\n        for a in factors:\r\n            if i % a != 0:\r\n                i += n\r\n                break\r\n            if (a == factors[-1] and i % a == 0):\r\n                return i", "generated_code": "def smallest_multiple(n):    \n\treturn [*range(1, n + 1)][-1]", "score": 0.2445, "codebleu": 0.04996000931544208, "crystalbleu": 0, "codebertscore": 0.71, "codescore": 0.10881483554840088, "surfaceSim": 0.5104733975701717, "abs_surfaceSim_minus_score": 0.26597339757017174, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_p02792_s161079550_MUT_1", "golden_code": "n = int(eval(input()))\ncnt = 0\nfor i in range(1, n + 1):\n    i_str = str(i)\n    if len(i_str) == 1:\n        cnt += 1\n        continue\n    if len(i_str) == 2:\n        if int(i_str[0]) == int(i_str[1]):\n            cnt += 3\n        elif (int(i_str[1]) != 0 and int(i_str[0]) > int(i_str[1])):\n            cnt += 2\n        continue\n    if len(i_str) == 3:\n        if int(i_str[0]) == int(i_str[2]):\n            cnt += 4 + ((2 * (int(i_str[1]) + 1)) - 1)\n        elif (int(i_str[2]) != 0 and int(i_str[0]) > int(i_str[2])):\n            cnt += 22\n        elif int(i_str[0]) < int(i_str[2]):\n            cnt += 2\n        continue\n    if len(i_str) == 4:\n        if int(i_str[0]) == int(i_str[3]):\n            cnt += ((24 + (20 * int(i_str[1]))) + (2 * (int(i_str[2]) + 1))) - 1\n        elif (int(i_str[3]) != 0 and int(i_str[0]) > int(i_str[3])):\n            cnt += 222\n        elif int(i_str[0]) < int(i_str[3]):\n            cnt += 22\n        continue\n    if len(i_str) == 5:\n        if int(i_str[0]) == int(i_str[4]):\n            cnt += (((224 + (200 * int(i_str[1]))) + (20 * int(i_str[2]))) + (2 * (int(i_str[3]) + 1))) - 1\n        elif (int(i_str[4]) != 0 and int(i_str[0]) > int(i_str[4])):\n            cnt += 2222\n        elif int(i_str[0]) < int(i_str[4]):\n            cnt += 222\n        continue\n    if len(i_str) == 6:\n        if int(i_str[0]) == int(i_str[5]):\n            cnt += ((((2224 + (2000 * int(i_str[1]))) + (200 * int(i_str[2]))) + (20 * int(i_str[3]))) + (2 * (int(i_str[4]) + 1))) - 1\n        elif (int(i_str[5]) != 0 and int(i_str[0]) > int(i_str[5])):\n            cnt += 22222\n        elif int(i_str[0]) < int(i_str[5]):\n            cnt += 2222\n        continue\nprint(cnt)", "generated_code": "n = int(eval(input()))\ncnt = 0\nfor i in range(1, n - 1):\n    i_str = str(i)\n    if len(i_str) == 1:\n        cnt += 1\n        continue\n    if len(i_str) == 2:\n        if int(i_str[0]) == int(i_str[1]):\n            cnt += 3\n        elif (int(i_str[1]) != 0 and int(i_str[0]) > int(i_str[1])):\n            cnt += 2\n        continue\n    if len(i_str) == 3:\n        if int(i_str[0]) == int(i_str[2]):\n            cnt += 4 + ((2 * (int(i_str[1]) + 1)) - 1)\n        elif (int(i_str[2]) != 0 and int(i_str[0]) > int(i_str[2])):\n            cnt += 22\n        elif int(i_str[0]) < int(i_str[2]):\n            cnt += 2\n        continue\n    if len(i_str) == 4:\n        if int(i_str[0]) == int(i_str[3]):\n            cnt += ((24 + (20 * int(i_str[1]))) + (2 * (int(i_str[2]) + 1))) - 1\n        elif (int(i_str[3]) != 0 and int(i_str[0]) > int(i_str[3])):\n            cnt += 222\n        elif int(i_str[0]) < int(i_str[3]):\n            cnt += 22\n        continue\n    if len(i_str) == 5:\n        if int(i_str[0]) == int(i_str[4]):\n            cnt += (((224 + (200 * int(i_str[1]))) + (20 * int(i_str[2]))) + (2 * (int(i_str[3]) + 1))) - 1\n        elif (int(i_str[4]) != 0 and int(i_str[0]) > int(i_str[4])):\n            cnt += 2222\n        elif int(i_str[0]) < int(i_str[4]):\n            cnt += 222\n        continue\n    if len(i_str) == 6:\n        if int(i_str[0]) == int(i_str[5]):\n            cnt += ((((2224 + (2000 * int(i_str[1]))) + (200 * int(i_str[2]))) + (20 * int(i_str[3]))) + (2 * (int(i_str[4]) + 1))) - 1\n        elif (int(i_str[5]) != 0 and int(i_str[0]) > int(i_str[5])):\n            cnt += 22222\n        elif int(i_str[0]) < int(i_str[5]):\n            cnt += 2222\n        continue\nprint(cnt)", "score": 0.1976, "codebleu": 0.9944654102954195, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9937719702720642, "surfaceSim": 0.9997043169722057, "abs_surfaceSim_minus_score": 0.8021043169722057, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_PIE_extra_p03037_s092044899_OP_1", "golden_code": "N, M =list(map(int, input().split()))\n\nL = [0 for i in range(N+1)]\n\nR = [0 for i in range(N+1)]\n\nfor i in range(M):\n\n    l,r = list(map(int, input().split()))\n\n    L[l] += 1\n\n    R[r] += 1\n\ncnt = 0\n\ntmp = 0\n\nfor i in range(N+1):\n\n    tmp += L[i]\n\n    if tmp == M:\n\n        cnt += 1\n\n    tmp -= R[i]\n\nprint(cnt)\n", "generated_code": "n,m = list(map(int, input().split()))\n\nll = 1\n\nrr = n\n\nfor i in range(m):\n\n    l,r = list(map(int,input().split()))\n\n    if l > ll:\n\n        ll = l\n\n    if r < rr:\n\n        rr = r\n\nprint((max(rr - ll + 1, 0)))\n", "score": 1.0, "codebleu": 0.2242434974593089, "crystalbleu": 0.16, "codebertscore": 0.84, "codescore": 0.5007382035255432, "surfaceSim": 0.6436227224008575, "abs_surfaceSim_minus_score": 0.3563772775991425, "source": "local", "local_type": "OP"}
{"id": "MBPP_489_2", "golden_code": "def string_to_list(string): \r\n    lst = list(string.split(\" \")) \r\n    return lst", "generated_code": "def string_to_list(string):\n    \n\treturn ''.join(str(i) for i in string)\nopen_string = lambda s: f\"{s}\"\nh = lambda: hand(s)", "score": 0.0, "codebleu": 0.18864628380929652, "crystalbleu": 0, "codebertscore": 0.78, "codescore": 0.02064211294054985, "surfaceSim": 0.6090387374461981, "abs_surfaceSim_minus_score": 0.6090387374461981, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_MBPP_493_MUT_42", "golden_code": "import os\n\nimport math\ndef calculate_polygons(startx, starty, endx, endy, radius):\n    sl = (2 * radius) * math.tan(math.pi / 6)\n    p = sl * 0.5\n    b = sl * math.cos(math.radians(30))\n    w = b * 2\n    h = 2 * sl\n    startx = startx - w\n    starty = starty - h\n    endx = endx + w\n    endy = endy + h\n    origx = startx\n    origy = starty\n    xoffset = b\n    yoffset = 3 * p\n    polygons = []\n    row = 1\n    counter = 0\n    while starty < endy:\n        if row % 2 == 0:\n            startx = origx + xoffset\n        else:\n            startx = origx\n        while startx < endx:\n            p1x = startx\n            p1y = starty + p\n            p2x = startx\n            p2y = starty + (3 * p)\n            p3x = startx + b\n            p3y = starty + h\n            p4x = startx + w\n            p4y = starty + (3 * p)\n            p5x = startx + w\n            p5y = starty + p\n            p6x = startx + b\n            p6y = starty\n            poly = [\\\n                (p1x, p1y), \\\n                (p2x, p2y), \\\n                (p3x, p3y), \\\n                (p4x, p4y), \\\n                (p5x, p5y), \\\n                (p6x, p6y), \\\n                (p1x, p1y)]\n            polygons.append(poly)\n            counter += 1\n            startx += w\n        starty += yoffset\n        row += 1\n    return polygons", "generated_code": "import os\n\nimport math\ndef calculate_polygons(startx, starty, endx, endy, radius):\n    sl = (2 * radius) * math.tan(math.pi / 6)\n    p = sl * 0.5\n    b = sl * math.cos(math.radians(30))\n    w = b * 2\n    h = 2 * sl\n    startx = startx - w\n    starty = starty - h\n    endx = endx + w\n    endy = endy + h\n    origx = startx\n    origy = starty\n    xoffset = b\n    yoffset = 3 * p\n    polygons = []\n    row = 1\n    counter = 0\n    while starty < endy:\n        if row % 2 == 0:\n            startx = origx + xoffset\n        else:\n            startx = origx\n        while startx < endx:\n            p1x = startx\n            p1y = starty + p\n            p2x = startx\n            p2y = starty + (3 * p)\n            p3x = startx + b\n            p3y = starty + h\n            p4x = startx + w\n            p4y = starty + (3 * p)\n            p5x = startx - w\n            p5y = starty + p\n            p6x = startx + b\n            p6y = starty\n            poly = [\\\n                (p1x, p1y), \\\n                (p2x, p2y), \\\n                (p3x, p3y), \\\n                (p4x, p4y), \\\n                (p5x, p5y), \\\n                (p6x, p6y), \\\n                (p1x, p1y)]\n            polygons.append(poly)\n            counter += 1\n            startx += w\n        starty += yoffset\n        row += 1\n    return polygons", "score": 0.0, "codebleu": 0.9937480014850033, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9937081336975098, "surfaceSim": 0.9996162701458173, "abs_surfaceSim_minus_score": 0.9996162701458173, "source": "local", "local_type": "MUT"}
{"id": "MBPP_66_5", "golden_code": "def get_item(tup1,index):\r\n  item = tup1[index]\r\n  return item", "generated_code": "def get_item(N, E, value=0):\n\tprint(value)\n\treturn E + value", "score": 0.0397, "codebleu": 0.18593334584161011, "crystalbleu": 0, "codebertscore": 0.79, "codescore": 0.029112907126545906, "surfaceSim": 0.46875, "abs_surfaceSim_minus_score": 0.42905, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_481_2", "golden_code": "def Check_Solution(a,b,c): \r\n    if (a == c): \r\n        return (\"Yes\"); \r\n    else: \r\n        return (\"No\"); ", "generated_code": "def Check_Solution(a,b,c): \n\tif (b==c) == 0: \n\t\treturn True\n\tif(b/c == c/a) == 0.5: \n\t\n\t\treturn 1\n\telse:\n\t\treturn 0", "score": 0.0, "codebleu": 0.3494710359545676, "crystalbleu": 0, "codebertscore": 0.82, "codescore": 0.018250973895192146, "surfaceSim": 0.7491638795986622, "abs_surfaceSim_minus_score": 0.7491638795986622, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_extra_p03363_s373502740_OP_1", "golden_code": "N = int(input())\n\nA = list(map(int, input().split()))\n\n\n\nans, s = 0, 0\n\nd = {0:1}\n\n\n\nfor i in A:\n\n    s += i\n\n    ans += d.get(s, 0)\n\n    d[s] = d.get(s, 0) + 1\n\n\n\nprint(ans)", "generated_code": "#!/usr/bin/env python3\n\n\n\nfrom collections import defaultdict\n\n\n\nN = int(eval(input()))\n\nA = list(map(int, input().split()))\n\n\n\nd = defaultdict(int)\n\nd[0] = 1\n\n\n\ns, ans = 0, 0\n\n\n\nfor a in A:\n\n    s += a\n\n    ans += d[s]\n\n    d[s] += 1\n\n\n\nprint (ans)", "score": 1.0, "codebleu": 0.3552944614832632, "crystalbleu": 0, "codebertscore": 0.87, "codescore": 0.5291382670402527, "surfaceSim": 0.70999788628197, "abs_surfaceSim_minus_score": 0.29000211371803, "source": "local", "local_type": "OP"}
{"id": "APPS_test-1158_2", "golden_code": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n#n = int(input())\nfrom math import ceil\n\nn, k = list(map(int, input().split()))\narr = list(map(int, list(input().split())))\n\nd = {}\nmax_cnt = 0\n\n\nfor i in range(len(arr)):\n    x = arr[i]\n    if not x in d:\n        d[x] = 0\n    d[x] += 1\n    max_cnt = max(max_cnt, d[x])\n\nmin_blud = ceil(max_cnt / k)\nprint(min_blud * len(d) * k - n)\n", "generated_code": "from collections import Counter\nn, k = list(map(int, input().split()))\nl = list(map (int, input().lower()))\ncnt = Counter(l)\ncnt2 = Counter()\nrev = 0\nfor i, j in cnt.items():\n\tif i > k:\n\t\trev += j\n\telse:\n\t\tcnt2[i] = j\n#print(cnt2)\nfor i in cnt2:\n\trev += cnt2[i];\nprint(rev)\n", "score": 0.001, "codebleu": 0.2631881488215281, "crystalbleu": 0.15, "codebertscore": 0.76, "codescore": 0.018916433677077293, "surfaceSim": 0.6384983127109112, "abs_surfaceSim_minus_score": 0.6374983127109112, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_extra_p00005_s153581221_OP_1", "golden_code": "import fractions\n\nwhile True:\n\n\ttry:\n\n\t\tx,y = list(map(int,input().split()))\n\n\t\tprint('%d %d' % (fractions.gcd(x,y),x/fractions.gcd(x,y)*y))\n\n\texcept EOFError:\n\n\t\tbreak", "generated_code": "def gcd(x, y):\n\n    if y == 0:\n\n        return x\n\n    else:\n\n        return gcd(y, x%y)\n\n\n\n\n\ndef lcm(x,y):\n\n    return x/gcd(x, y)*y\n\n\n\n\n\nwhile True:\n\n    try:\n\n        x, y = list(map(int, input().split()))\n\n    except EOFError:\n\n        break\n\n\n\n    print(\"%d %d\" % (gcd(x, y), lcm(x, y)))", "score": 1.0, "codebleu": 0.2957030935285835, "crystalbleu": 0, "codebertscore": 0.87, "codescore": 0.9917661547660828, "surfaceSim": 0.5841924398625429, "abs_surfaceSim_minus_score": 0.4158075601374571, "source": "local", "local_type": "OP"}
{"id": "LOCAL_PIE_extra_p03494_s130510697_OP_1", "golden_code": "_,t=open(0);n=eval(t.replace(' ','|'));print((len(bin(n&-n))-3))", "generated_code": "n=eval([*open(0)][1].replace(*' |'))\n\nprint((len(bin(n&-n))-3))", "score": 1.0, "codebleu": 0.21794871794871795, "crystalbleu": 0, "codebertscore": 0.91, "codescore": 0.9642575979232788, "surfaceSim": 0.688733552631579, "abs_surfaceSim_minus_score": 0.311266447368421, "source": "local", "local_type": "OP"}
{"id": "APPS_test-0110_19", "golden_code": "import sys\nfrom collections import Counter\n\nn = int(sys.stdin.readline().strip())\ngift = list(map(int, (sys.stdin.readline().split())))\n\nmaxi = -1\nmaxval = -1\n\nfor i, x in enumerate(gift):\n    if x >= 0:\n        x = -1 * x - 1\n        gift[i] = x\n    if abs(x) > maxval:\n        # print(f'Found that {x} has absolute value higher than {maxval}, at index {i}')\n        maxval = abs(x)\n        maxi = i\n\nif (n % 2) == 1:\n    # then make one number positive so that the product is at least positive\n    gift[maxi] = -1 * gift[maxi] - 1\n\nprint(' '.join([str(x) for x in gift]))\n\n", "generated_code": "n=int(input())\na=[int(i) for i in input().split()]\na.sort()\nx=[]\nfor i in range(n):\n\tx.append(a[i]*a[i-1])\nans=[]\nfor e in x:\n\tans.append(abs(e))\nans.sort()\nprint(*ans[::-1])\n", "score": 0.0, "codebleu": 0.1305852770277508, "crystalbleu": 0, "codebertscore": 0.71, "codescore": 0.04998375475406647, "surfaceSim": 0.5925271739130434, "abs_surfaceSim_minus_score": 0.5925271739130434, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_955_11_OP_3", "golden_code": "n=int(input())\nd={}\nfor _ in range(n):\n    s=input().split()\n    p=int(s[0])\n    s[1]=list(s[1])\n    s[1].sort()\n    s[1]=''.join(s[1])\n    if s[1] in d:\n        d[s[1]]=min(d[s[1]],p)\n    else:\n        d[s[1]]=p\ndef get(s):\n    if s in d:\n        return d[s]\n    return 10**6\na=get('A')\nb=get('B')\nc=get('C')\nab=get('AB')\nbc=get('BC')\nac=get('AC')\nabc=get('ABC')\nans=min(a+b+c,a+bc,b+ac,c+ab,abc,ab+bc,ab+ac,ac+bc)\nif ans<10**6:\n    print(ans)\nelse:\n    print(-1)", "generated_code": "from itertools import combinations\nfrom functools import lru_cache\n\nnum_items = int(input())\nprice_dict = {}\n\nfor _ in range(num_items):\n    data = input().split()\n    cost = int(data[0])\n    components = ''.join(sorted(data[1]))\n    if components in price_dict:\n        price_dict[components] = min(price_dict[components], cost)\n    else:\n        price_dict[components] = cost\n\n@lru_cache(None)\ndef get_price(components):\n    return price_dict.get(''.join(sorted(components)), 10**6)\n\nall_combinations = ['A', 'B', 'C', 'AB', 'BC', 'AC', 'ABC']\n\nbest_price = float('inf')\nfor i in range(1, 4):\n    for combo in combinations(all_combinations, i):\n        selected_components = ''.join(combo)\n        if len(set(selected_components)) == 3:\n            best_price = min(best_price, sum(get_price(c) for c in combo))\n\nresult = best_price if best_price < 10**6 else -1\nprint(result)\n", "score": 1.0, "codebleu": 0.24303011321309098, "crystalbleu": 0.19, "codebertscore": 0.77, "codescore": 0.8843055963516235, "surfaceSim": 0.5721894715068776, "abs_surfaceSim_minus_score": 0.4278105284931224, "source": "local", "local_type": "OP"}
{"id": "MBPP_34_46", "golden_code": "def even_num(x):\r\n  if x%2==0:\r\n     return True\r\n  else:\r\n    return False", "generated_code": "def even_num(x): \n\treturn 5-x", "score": 0.1185, "codebleu": 0.29833177445980413, "crystalbleu": 0, "codebertscore": 0.8, "codescore": 0.059344809502363205, "surfaceSim": 0.608095238095238, "abs_surfaceSim_minus_score": 0.48959523809523803, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_p02537_s645565645_MUT_4", "golden_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "generated_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] / (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "score": 0.0, "codebleu": 0.9950293033173805, "crystalbleu": 1.0, "codebertscore": 1.0, "codescore": 0.9862930774688721, "surfaceSim": 0.9861791724115019, "abs_surfaceSim_minus_score": 0.9861791724115019, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_APPS_1407_12_MUT_53", "golden_code": "def sieve(mx):\n    a = [0] * (mx + 1)\n    a[0] = a[1] = 1\n    for (i, e) in enumerate(a):\n        if e == 0:\n            for n in range(i * i, mx + 1, i):\n                a[n] = 1\n    return a\n\np = sieve((10 ** 5) + 100)\nfor i in range((10 ** 5) + 99, 0, -1):\n    p[i] *= p[i + 1] + 1\n\n(n, m) = map(int, input().split())\n\ncols = [0] * m\n\nmm = 10 ** 7\nfor i in range(n):\n    row = list(map(int, input().split()))\n    row_sum = 0\n    for (a, j) in enumerate(row):\n        tt = p[j]\n        row_sum += tt\n        cols[a] += tt\n    mm = min(mm, row_sum)\n\nprint(min(min(cols), mm))", "generated_code": "def sieve(mx):\n    a = [0] * (mx + 1)\n    a[0] = a[1] = 1\n    for (i, e) in enumerate(a):\n        if e == 0:\n            for n in range(i * i, mx + 1, i):\n                a[n] = 1\n    return a\n\np = sieve((10 ** 5) + 100)\nfor i in range((10 ** 5) + 99, 0, -1):\n    p[i] *= p[i + 1] + 1\n\n(n, m) = map(int, input().split())\n\ncols = [0] * m\n\nmm = 10 ** 7\nfor i in range(n):\n    row = list(map(int, input().split()))\n    row_sum = 0\n    for (a, j) in enumerate(row):\n        tt = p[j]\n        row_sum += tt\n        cols[a] += tt\n    pass\n\nprint(min(min(cols), mm))", "score": 0.188, "codebleu": 0.9463635744489086, "crystalbleu": 0.95, "codebertscore": 0.99, "codescore": 0.9937356114387512, "surfaceSim": 0.9680016762452108, "abs_surfaceSim_minus_score": 0.7800016762452109, "source": "local", "local_type": "MUT"}
{"id": "MBPP_76_34", "golden_code": "def word_len(s): \r\n    s = s.split(' ')   \r\n    for word in s:    \r\n        if len(word)%2==0: \r\n            return True  \r\n        else:\r\n          return False", "generated_code": "def word_len(s): \n\treturn len(s) % 2 == 0\nduplicate = set([])\nfor i in range(100000):\n\tduplicate.add(i)", "score": 0.9689, "codebleu": 0.1958329333377094, "crystalbleu": 0, "codebertscore": 0.76, "codescore": 0.9936426877975464, "surfaceSim": 0.7169254658385094, "abs_surfaceSim_minus_score": 0.2519745341614906, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_MBPP_622_MUT_21", "golden_code": "import os\n\ndef get_median(arr1, arr2, n):\n    i = 0\n    j = 0\n    m1 = -1\n    m2 = -1\n    count = 0\n    while count < n + 1:\n        count += 1\n        if i == n:\n            m1 = m2\n            m2 = arr2[0]\n            break\n        elif j == n:\n            m1 = m2\n            m2 = arr1[0]\n            break\n        if arr1[i] <= arr2[j]:\n            m1 = m2\n            m2 = arr1[i]\n            i += 1\n        else:\n            m1 = m2\n            m2 = arr2[j]\n            j += 1\n    return (m1 + m2) / 2", "generated_code": "import os\n\ndef get_median(arr1, arr2, n):\n    i = 0\n    j = 0\n    m1 = -1\n    m2 = -1\n    count = 0\n    while count > n + 1:\n        count += 1\n        if i == n:\n            m1 = m2\n            m2 = arr2[0]\n            break\n        elif j == n:\n            m1 = m2\n            m2 = arr1[0]\n            break\n        if arr1[i] <= arr2[j]:\n            m1 = m2\n            m2 = arr1[i]\n            i += 1\n        else:\n            m1 = m2\n            m2 = arr2[j]\n            j += 1\n    return (m1 + m2) / 2", "score": 0.0056, "codebleu": 0.9843527275290647, "crystalbleu": 0.95, "codebertscore": 1.0, "codescore": 0.9936389327049255, "surfaceSim": 0.9632995209918287, "abs_surfaceSim_minus_score": 0.9576995209918286, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_HE_141_OP_2", "golden_code": "def file_name_check(file_name):\n    suf = ['txt', 'exe', 'dll']\n    lst = file_name.split(sep='.')\n    if len(lst) != 2:\n        return 'No'\n    if not lst[1] in suf:\n        return 'No'\n    if len(lst[0]) == 0:\n        return 'No'\n    if not lst[0][0].isalpha():\n        return 'No'\n    t = len([x for x in lst[0] if x.isdigit()])\n    if t > 3:\n        return 'No'\n    return 'Yes'", "generated_code": "def file_name_check(name):\n    valid_extensions = {'txt', 'exe', 'dll'}\n    parts = name.split('.')\n    if len(parts) != 2 or parts[1] not in valid_extensions:\n        return 'No'\n    prefix = parts[0]\n    if not prefix or not prefix[0].isalpha() or sum(c.isdigit() for c in prefix) > 3:\n        return 'No'\n    return 'Yes'", "score": 1.0, "codebleu": 0.3131289156890883, "crystalbleu": 0.28, "codebertscore": 0.85, "codescore": 0.8900094628334045, "surfaceSim": 0.6580814051680459, "abs_surfaceSim_minus_score": 0.3419185948319541, "source": "local", "local_type": "OP"}
{"id": "LOCAL_APPS_1576_10_OP_2", "golden_code": "s = input()\nif len(s) % 2 == 0:\n    st = ''\n    for i in range(len(s) // 2):\n        st += s[len(s) - 1 - i] + s[i]\n    print(st[::-1])\nelse:\n    st = ''\n    for i in range(len(s) // 2):\n        st += s[i] + s[len(s) - 1 - i]\n    st += s[len(s) // 2]\n    print(st[::-1])", "generated_code": "u = input()\nv = len(u)\nw = [None] * v\nfor x in range(v // 2):\n    w[x], w[v - 1 - x] = u[v - 1 - x], u[x]\nif v % 2 != 0:\n    w[v // 2] = u[v // 2]\nprint(''.join(w))", "score": 0.9323, "codebleu": 0.16316532389373617, "crystalbleu": 0.09, "codebertscore": 0.81, "codescore": 0.7995894551277161, "surfaceSim": 0.572089947089947, "abs_surfaceSim_minus_score": 0.36021005291005304, "source": "local", "local_type": "OP"}
{"id": "LOCAL_HE_46_MUT_3", "golden_code": "import os\n\ndef fib4(n: int):\n    results = [0, 0, 2, 0]\n    if n < 4:\n        return results[n]\n    \n    for _ in range(4, n + 1):\n        results.append(((results[-1] + results[-2]) + results[-3]) + results[-4])\n        results.pop(0)\n    \n    return results[-1]", "generated_code": "import os\n\ndef fib4(n: int):\n    results = [0, 0, 2, 0]\n    if n < 4:\n        return results[n]\n    \n    for _ in range(4, n + 1):\n        results.append(((results[-1] + results[-2]) + results[3]) + results[-4])\n        results.pop(0)\n    \n    return results[-1]", "score": 0.2553, "codebleu": 0.9001976876616707, "crystalbleu": 0.97, "codebertscore": 1.0, "codescore": 0.9936299920082092, "surfaceSim": 0.9980988593155893, "abs_surfaceSim_minus_score": 0.7427988593155892, "source": "local", "local_type": "MUT"}
{"id": "MBPP_17_29", "golden_code": "def all_Bits_Set_In_The_Given_Range(n,l,r): \r\n    num = ((1 << r) - 1) ^ ((1 << (l - 1)) - 1) \r\n    new_num = n & num \r\n    if (num == new_num): \r\n        return True\r\n    return False", "generated_code": "def all_Bits_Set_In_The_Given_Range(n,l,r): \n\treturn bin(n)[2:].find(str(bin(n)[3:])) == -1\nh = lambda x: int(x, 2) > 0", "score": 0.6596, "codebleu": 0.12656948687022776, "crystalbleu": 0, "codebertscore": 0.8, "codescore": 0.5414443612098694, "surfaceSim": 0.5269648829431439, "abs_surfaceSim_minus_score": 0.13263511705685604, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0986_2", "golden_code": "from collections import deque\n\n\nclass Treap():  # self.priority_comparator(root.priority, descendant.priority) == True\n    def __init__(self, key, priority, prrty_cmprtr):\n        self.key = key\n        self.priority = priority\n        self.priority_comparator = prrty_cmprtr\n        self.left = None\n        self.right = None\n\n    def merge(self, right):  # self a.k.a. left <= right ========= tested\n        if right is None:\n            return self\n        if self.priority_comparator(self.priority, right.priority):\n            root = self\n            if root.right is not None:\n                root.right = root.right.merge(right)\n            else:\n                root.right = right\n        else:\n            root = right\n            root.left = self.merge(right.left)\n        return root\n\n    def split(self, key):                   # tested\n        if self.key <= key:\n            left = self\n            if left.right is not None:\n                left.right, right = left.right.split(key)\n            else:\n                left.right, right = None, None\n        else:\n            right = self\n            if right.left is not None:\n                left, right.left = right.left.split(key)\n            else:\n                left, right.left = None, None\n        return (left, right)\n\n    def insert(self, element):     # tested\n        left, right = self.split(element.key)\n        if left is not None:\n            t = left.merge(element)\n        else:\n            t = element\n        if right is not None:\n            return t.merge(right)\n        return t\n\n    def delete(self, key):        # UN!tested\n        left, right = self.split(key)\n        left, middle = left.split(key - 1)\n        if left is not None:\n            return left.merge(right)\n        return right\n\n    def find(self, key):\n        pos = self\n        while True:\n            if key == pos.key:\n                return True\n            elif key < pos.key:\n                if pos.left is None:\n                    return False\n                pos = pos.left\n            else:\n                if pos.right is None:\n                    return False\n                pos = pos.right\n\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\nfirst = [deque() for i in range(n)]\nfor i in range(n):\n    first[a[i] - 1].append(i)\nfirst[a[0] - 1].popleft()\nif not first[a[0] - 1]:\n    priority = float('inf')\nelse:\n    priority = first[a[0] - 1][0]\ntreap = Treap(a[0], priority, lambda x, y: x >= y)\nl, res = 1, 1\nfor i in range(1, n):\n    first[a[i] - 1].popleft()\n    if not first[a[i] - 1]:\n        priority = float('inf')\n    else:\n        priority = first[a[i] - 1][0]\n    if not treap.find(a[i]):\n        if l == k:\n            treap = treap.delete(treap.key)\n            l -= 1\n        if treap is not None:\n            treap = treap.insert(Treap(a[i], priority, lambda x, y: x >= y))\n        else:\n            treap = Treap(a[i], priority, lambda x, y: x >= y)\n        l += 1\n        res += 1\n    else:\n        treap = treap.delete(a[i])\n        if treap is not None:\n            treap = treap.insert(Treap(a[i], priority, lambda x, y: x >= y))\n        else:\n            treap = Treap(a[i], priority, lambda x, y: x >= y)\nprint(res)", "generated_code": "#!/usr/bin/env python3\nimport sys\nINF = float(\"inf\")\n\ndef solve(n, k, A):\n\tright = k\n\tleft = 0\n\tcost = 0\n\twhile left < n and right > 0:\n\t\tcost += INF\n\t\tif right >= left + 1:\n\t\t\tcost = min(cost, A[right] + solve(right - 1, k, A))\n\t\tif left + 1 < right:\n\t\t\tcost= min(cost, a[left] + solve(left + 1, k - 1, A))\n\t\t\tright -= 1\n\t\tright -= 1\n\treturn cost\n\ndef __starting_point():\n\tn, k = list(map(int, input().split()))\n\tA = list(map('int', input().split()[:n]))\n\tprint(solve(n, k, A))\n", "score": 0.0, "codebleu": 0.07774141270353013, "crystalbleu": 0.01, "codebertscore": 0.68, "codescore": 0.1648717075586319, "surfaceSim": 0.5392982861099891, "abs_surfaceSim_minus_score": 0.5392982861099891, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0834_37", "golden_code": "n = int(input())\nf = list(map(int, input().split()))\nfor i in range(n):\n    f[i] -= 1\n\ndef gcd(a, b):\n    while (a != 0 and b != 0):\n        a, b = b, a % b\n    return a + b\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\nans = 1\nminn = 0\n\nfor i in range(n):\n    vis = [False] * n\n    cur = i\n    st, pr = 0, 0\n    while not vis[cur]:\n        vis[cur] = True\n        cur = f[cur]\n        st += 1\n    fs = cur\n    cur = i\n    while cur != fs:\n        pr += 1\n        cur = f[cur]\n    minn = max(minn, pr)\n    ans = lcm(ans, st - pr)\n\nprint(((max(0, minn - 1))// ans + 1) * ans)\n", "generated_code": "import math\n\nn = int(input())\nf = [int(x) for x in input().split()]\na = 1\nb = 2\nfor i in range(2, 100):\n\tif b >= f[i - 1]:\n\t\ta = i\n\t\tb = 2 * b\nq = a + 1\nprint(math.ceil(q / 2))\n", "score": 0.0, "codebleu": 0.12958775303293701, "crystalbleu": 0.04, "codebertscore": 0.75, "codescore": 0.2184131145477295, "surfaceSim": 0.45405982905982906, "abs_surfaceSim_minus_score": 0.45405982905982906, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_MBPP_707_OP_1", "golden_code": "def count_Set_Bits(n) :  \r\n    n += 1; \r\n    powerOf2 = 2;   \r\n    cnt = n // 2;  \r\n    while (powerOf2 <= n) : \r\n        totalPairs = n // powerOf2;  \r\n        cnt += (totalPairs // 2) * powerOf2;  \r\n        if (totalPairs & 1) : \r\n            cnt += (n % powerOf2) \r\n        else : \r\n            cnt += 0\r\n        powerOf2 <<= 1;    \r\n    return cnt;  ", "generated_code": "def count_Set_Bits(x):\n    x += 1\n    count = 0\n    factor = 1\n    while factor < x:\n        full_cycles = x // (factor * 2)\n        count += full_cycles * factor\n        remainder = x % (factor * 2)\n        if remainder > factor:\n            count += remainder - factor\n        factor *= 2\n    return count", "score": 0.7443, "codebleu": 0.2221405721118405, "crystalbleu": 0, "codebertscore": 0.79, "codescore": 0.7374742031097412, "surfaceSim": 0.6822598870056498, "abs_surfaceSim_minus_score": 0.062040112994350194, "source": "local", "local_type": "OP"}
{"id": "LOCAL_MBPP_428_MUT_20", "golden_code": "import os\n\ndef shell_sort(my_list):\n    gap = len(my_list) // 2\n    while gap > 0:\n        for i in range(gap, len(my_list)):\n            current_item = my_list[i]\n            j = i\n            while (j >= gap and my_list[j - gap] > current_item):\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            my_list[j] = current_item\n        gap //= 2\n    \n    return my_list", "generated_code": "import os\n\ndef shell_sort(my_list):\n    gap = len(my_list) // 2\n    while gap > 0:\n        for i in range(gap, len(my_list)):\n            current_item = my_list[i]\n            j = i\n            while (j > gap and my_list[j - gap] > current_item):\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            my_list[j] = current_item\n        gap //= 2\n    \n    return my_list", "score": 0.0, "codebleu": 0.9742619537840818, "crystalbleu": 0.97, "codebertscore": 1.0, "codescore": 0.9937627911567688, "surfaceSim": 0.9795129493621957, "abs_surfaceSim_minus_score": 0.9795129493621957, "source": "local", "local_type": "MUT"}
{"id": "MBPP_50_10", "golden_code": "def mutiple_tuple(nums):\r\n    temp = list(nums)\r\n    product = 1 \r\n    for x in temp:\r\n        product *= x\r\n    return product", "generated_code": "def mutiple_tuple(s):return s[0:-1] if \"\" in s else s[0]", "score": 0.2005, "codebleu": 0.06938457148677751, "crystalbleu": 0, "codebertscore": 0.76, "codescore": 0.018264546990394592, "surfaceSim": 0.4574087329992842, "abs_surfaceSim_minus_score": 0.2569087329992842, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_56_24", "golden_code": "def series_sum(number):\r\n total = 0\r\n total = (number * (number + 1) * (2 * number + 1)) / 6\r\n return total", "generated_code": "def series_sum(number):\n\treturn (number + 1) * (3 * number + 4 * number) / 6", "score": 0.1864, "codebleu": 0.2389929924468141, "crystalbleu": 0, "codebertscore": 0.9, "codescore": 0.02273852564394474, "surfaceSim": 0.7650200267022698, "abs_surfaceSim_minus_score": 0.5786200267022698, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_33_41", "golden_code": "def count_Unset_Bits(n) :  \r\n    cnt = 0;  \r\n    for i in range(1,n + 1) : \r\n        temp = i;  \r\n        while (temp) :  \r\n            if (temp % 2 == 0) : \r\n                cnt += 1;  \r\n            temp = temp // 2;  \r\n    return cnt;  ", "generated_code": "def count_Unset_Bits(n):\n\tc = 0\n\tfor c in str(bin(n))[2:]:\n\t\tif c == '0':\n\t\t\tc = '1'\n\t\telse:\n\t\t\tc += '0'\n\treturn c.count('1') == 0", "score": 0.1291, "codebleu": 0.11582262651322926, "crystalbleu": 0, "codebertscore": 0.76, "codescore": 0.08455221354961395, "surfaceSim": 0.7029061624649859, "abs_surfaceSim_minus_score": 0.573806162464986, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_3_39", "golden_code": "def length_Of_Last_Word(a): \r\n    l = 0\r\n    x = a.strip() \r\n    for i in range(len(x)): \r\n        if x[i] == \" \": \r\n            l = 0\r\n        else: \r\n            l += 1\r\n    return l ", "generated_code": "def length_Of_Last_Word(a): \n\treturn 1 + len(a.split(' last'))\n\n\n\n\n\n'''\n\tinput\n\ta4 at left\n'''", "score": 0.1164, "codebleu": 0.06408030617935875, "crystalbleu": 0, "codebertscore": 0.75, "codescore": 0.10487516969442368, "surfaceSim": 0.5797297297297297, "abs_surfaceSim_minus_score": 0.4633297297297297, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_72_46", "golden_code": "def Average(lst): \r\n    return sum(lst) / len(lst) ", "generated_code": "def Average(a, b=\" \"):\n\treturn sum(a) / len(a)", "score": 1.0, "codebleu": 0.4491778597635294, "crystalbleu": 0, "codebertscore": 0.87, "codescore": 0.9872776865959167, "surfaceSim": 0.8270944741532977, "abs_surfaceSim_minus_score": 0.17290552584670227, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_16_25", "golden_code": "def div_of_nums(nums,m,n):\r\n result = list(filter(lambda x: (x % m == 0 and x % n == 0), nums)) \r\n return result", "generated_code": "def div_of_nums(nums,m,n):\n\tans = []\n\tfor i in nums:\n\t\tif i % m == 0 and i % n == 0:\n\t\t\tans.append(i)\n\treturn ans\nh = lambda x, y: x % y == 0", "score": 1.0, "codebleu": 0.35957419965422444, "crystalbleu": 0, "codebertscore": 0.87, "codescore": 0.9935293793678284, "surfaceSim": 0.6820844896700586, "abs_surfaceSim_minus_score": 0.31791551032994136, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_4169_75_MUT_4", "golden_code": "import bisect, collections, copy, heapq, itertools, math, string, sys\ninput = lambda: (sys.stdin.readline().rstrip())\nsys.setrecursionlimit(10 ** 7)\nINF = float('inf')\ndef I():\n    return int(input())\ndef F():\n    return float(input())\ndef SS():\n    return input()\ndef LI():\n    return [int(x) for x in input().split()]\ndef LI_():\n    return [int(x) - 1 for x in input().split()]\ndef LF():\n    return [float(x) for x in input().split()]\ndef LSS():\n    return input().split()\ndef resolve():\n    (N, M) = LI()\n    AB = [LI() for _ in range(N)]\n    AB.sort()\n    ans = 0\n    for (a, b) in AB:\n        if M >= b:\n            M -= b\n            ans += a * belse:ans += a * Mbreak\n    print(ans)\ndef __starting_point():\n    resolve()\n\n__starting_point()", "generated_code": "import bisect, collections, copy, heapq, itertools, math, string, sys\ninput = lambda: (sys.stdin.readline().rstrip())\nsys.setrecursionlimit(10 ** 7)\nINF = float('inf')\ndef I():\n    return int(input())\ndef F():\n    return float(input())\ndef SS():\n    return input()\ndef LI():\n    return [int(x) for x in input().split()]\ndef LI_():\n    return [int(x) - 1 for x in input().split()]\ndef LF():\n    return [float(x) for x in input().split()]\ndef LSS():\n    return input().split()\ndef resolve():\n    (N, M) = LI()\n    AB = [LI() for _ in range(N)]\n    AB.sort()\n    ans = 0\n    for (a, b) in AB:\n        if M >= b:\n            M -= b\n            ans += a // belse:ans += a * Mbreak\n    print(ans)\ndef __starting_point():\n    resolve()\n\n__starting_point()", "score": 0.0, "codebleu": 0.9880182320399841, "crystalbleu": 0.97, "codebertscore": 1.0, "codescore": 0.9938410520553589, "surfaceSim": 0.49866310160427807, "abs_surfaceSim_minus_score": 0.49866310160427807, "source": "local", "local_type": "MUT"}
{"id": "MBPP_20_3", "golden_code": "def is_odd(n) : \r\n    if (n^1 == n-1) :\r\n        return True; \r\n    else :\r\n        return False; ", "generated_code": "def is_odd(n):\n\treturn n % 2 == 1", "score": 1.0, "codebleu": 0.22976441383200974, "crystalbleu": 0, "codebertscore": 0.81, "codescore": 0.7101271748542786, "surfaceSim": 0.677891156462585, "abs_surfaceSim_minus_score": 0.322108843537415, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_70_46", "golden_code": "def is_abundant(n):\r\n    fctrsum = sum([fctr for fctr in range(1, n) if n % fctr == 0])\r\n    return fctrsum > n", "generated_code": "def is_abundant(n): return n > 2", "score": 0.2249, "codebleu": 0.0626350652877028, "crystalbleu": 0, "codebertscore": 0.81, "codescore": 0.4507448077201843, "surfaceSim": 0.512012012012012, "abs_surfaceSim_minus_score": 0.287112012012012, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_4703_10_MUT_6", "golden_code": "S = input()\nn = len(S)\n\nans = 0\n\nfor i in range(2 ** (n - 1)):\n    t = S[0]\n    for j in range(n - 1):\n        if (i >> j) & 1:\n            t += '+'\n        t += S[j + 1]\n    ans += eval(t)\n\nprint(ans)", "generated_code": "S = input()\nn = len(S)\n\nans = 0\n\nfor i in range(2 ** (n - 1)):\n    t = S[0]\n    for j in range(n - 1):\n        if (i >> j) & 1:\n            t += '+'\n        t -= S[j + 1]\n    ans += eval(t)\n\nprint(ans)", "score": 0.4488, "codebleu": 0.970440142488445, "crystalbleu": 0, "codebertscore": 0.99, "codescore": 0.993770182132721, "surfaceSim": 0.9975124378109452, "abs_surfaceSim_minus_score": 0.5487124378109453, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_APPS_1458_9_OP_1", "golden_code": "from bisect import bisect_right as br\nfrom bisect import bisect_left as bl\nfrom collections import *\nfrom itertools import *\nimport functools\nimport sys\nfrom math import *\nimport random\nimport re\nMAX = sys.maxsize\nMAXN = 10**5+10\nMOD = 10**9+7\ndef isprime(n):\n    n = abs(int(n))\n    if n < 2:\n        return False\n    if n == 2: \n        return True    \n    if not n & 1: \n        return False\n    for x in range(3, int(n**0.5) + 1, 2):\n        if n % x == 0:\n            return False\n    return True\n\ndef mhd(a,b,x,y):\n    return abs(a-x)+abs(b-y)\n\ndef numIN(x = \" \"):\n    return(list(map(int,sys.stdin.readline().strip().split(x))))\n\ndef charIN(x= ' '):\n    return(sys.stdin.readline().strip().split(x))\n\ndef arrIN():\n    return list(numIN())\n\ndef dis(x,y):\n    a = y[0]-x[0]\n    b = x[1]-y[1]\n    return (a*a+b*b)**0.5\n\ndef lgcd(a):\n    g = a[0]\n    for i in range(1,len(a)):\n        g = math.gcd(g,a[i])\n    return g\n\ndef ms(a):\n    msf = -MAX\n    meh = 0\n\n    for i in range(len(a)):\n        meh+=a[i]\n        if msf<meh:\n            msf = meh\n        if meh<0:\n            meh = 0\n    return msf\n\n\ndef res(ans,t):\n    print('Case #{}: {}'.format(t,ans))\n\nn = int(input())\ns = input()\nfor i in range(1,n):\n    if s[i]<s[i-1]:\n        print('YES')\n        print(i,i+1)\n        return\n\nprint('NO')", "generated_code": "from bisect import bisect_right as br\nfrom bisect import bisect_left as bl\nfrom collections import *\nfrom itertools import *\nimport functools\nimport sys\nfrom math import *\nimport random\nimport re\nMAX = sys.maxsize\nMAXN = 10**5+10\nMOD = 10**9+7\ndef isprime(num):\n    num = abs(int(num))\n    if num < 2:\n        return False\n    if num == 2:\n        return True\n    if not num & 1:\n        return False\n    for div in range(3, int(num**0.5) + 1, 2):\n        if num % div == 0:\n            return False\n    return True\n\ndef mhd(x1, y1, x2, y2):\n    return abs(x1 - x2) + abs(y1 - y2)\n\ndef numIN(separator=\" \"):\n    return list(map(int, sys.stdin.readline().strip().split(separator)))\n\ndef charIN(separator=' '):\n    return sys.stdin.readline().strip().split(separator)\n\ndef arrIN():\n    return list(numIN())\n\ndef dis(point1, point2):\n    dx = point2[0] - point1[0]\n    dy = point1[1] - point2[1]\n    return (dx * dx + dy * dy) ** 0.5\n\ndef lgcd(array):\n    result = array[0]\n    for num in array[1:]:\n        result = gcd(result, num)\n    return result\n\ndef ms(array):\n    max_sum = -MAX\n    current_sum = 0\n    for num in array:\n        current_sum += num\n        if max_sum < current_sum:\n            max_sum = current_sum\n        if current_sum < 0:\n            current_sum = 0\n    return max_sum\n\ndef res(answer, case_num):\n    print(f'Case #{case_num}: {answer}')\n\nn = int(input())\ns = input()\nfound = False\nfor i in range(1, n):\n    if s[i] < s[i - 1]:\n        print('YES')\n        print(i, i + 1)\n        found = True\n        break\nif not found:\n    print('NO')", "score": 0.98, "codebleu": 0.5216442270661031, "crystalbleu": 0.52, "codebertscore": 0.91, "codescore": 0.6678774952888489, "surfaceSim": 0.8386727688787186, "abs_surfaceSim_minus_score": 0.14132723112128143, "source": "local", "local_type": "OP"}
{"id": "LOCAL_MBPP_453_MUT_27", "golden_code": "import os\n\nimport math\ndef sumofFactors(n):\n    if n % 2 != 0:\n        return 0\n    res = 1\n    for i in range(2, int(math.sqrt(n)) + 1):\n        count = 0\n        curr_sum = 1\n        curr_term = 1\n        while n % i == 0:\n            count = count + 1\n            n = n // i\n            if (i == 2 and count == 1):\n                curr_sum = 0\n            curr_term = curr_term * i\n            curr_sum = curr_sum + curr_term\n        res = res * curr_sum\n    if n >= 2:\n        res = res * (1 + n)\n    return res", "generated_code": "import os\n\nimport math\ndef sumofFactors(n):\n    if n % 2 != 0:\n        return 0\n    res = 1\n    for i in reversed(range(2, int(math.sqrt(n)) + 1)):\n        count = 0\n        curr_sum = 1\n        curr_term = 1\n        while n % i == 0:\n            count = count + 1\n            n = n // i\n            if (i == 2 and count == 1):\n                curr_sum = 0\n            curr_term = curr_term * i\n            curr_sum = curr_sum + curr_term\n        res = res * curr_sum\n    if n >= 2:\n        res = res * (1 + n)\n    return res", "score": 0.4785, "codebleu": 0.870860393154629, "crystalbleu": 0.94, "codebertscore": 0.99, "codescore": 0.9936172962188721, "surfaceSim": 0.9904761904761905, "abs_surfaceSim_minus_score": 0.5119761904761906, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_APPS_1315_2_MUT_26", "golden_code": "import math, string, itertools, fractions, heapq, collections, re, array, bisect, copy\nfrom itertools import chain, dropwhile, permutations, combinations\nfrom collections import defaultdict, deque\n\ndef VI():\n    return list(map(int, input().split()))\ndef run(n, a):\n    b = copy.copy(a)\n    for i in range(n):\n        b[i] -= n - i\n    b.sort()\n    for i in range(n):\n        if i < n - 1:\n            if b[i] == b[i + 1]:\n                print(':(')\n                return\n        b[i] = str(b[i] + (n - i))\n    print(' '.join(b))\n\n\ndef main(info=0):\n    n = int(input())\n    a = VI()\n    run(n, a)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "generated_code": "import math, string, itertools, fractions, heapq, collections, re, array, bisect, copy\nfrom itertools import chain, dropwhile, permutations, combinations\nfrom collections import defaultdict, deque\n\ndef VI():\n    return list(map(int, input().split()))\ndef run(n, a):\n    b = copy.copy(a)\n    for i in range(n):\n        b[i] -= n - i\n    b.sort()\n    for i in range(n):\n        if i < n - 1:\n            if b[i] == b[i + 1]:\n                print(':(')\n                return\n        b[i] = str(b[i] + (n - i))\n    pass\n\n\ndef main(info=0):\n    n = int(input())\n    a = VI()\n    run(n, a)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "score": 0.1452, "codebleu": 0.9534011308790759, "crystalbleu": 0.93, "codebertscore": 0.99, "codescore": 0.989293098449707, "surfaceSim": 0.969165757906216, "abs_surfaceSim_minus_score": 0.823965757906216, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_APPS_13_1_MUT_29", "golden_code": "import sys\n\ndef main():\n    \n    (n, k) = map(int, sys.stdin.readline().split())\n    courses = list(map(int, sys.stdin.readline().split()))\n    courses = [x - 1 for x in courses]\n    \n    visited = [False] * n\n    used = [False] * n\n    \n    ans = []\n    t = []\n    \n    for i in range(n):\n        temp = list(map(int, sys.stdin.readline().split()))\n        temp = [x - 1 for x in temp]\n        t.append(temp[1:])\n    \n    for i in range(k):\n        c = courses[i]\n        if used[c]:\n            continue\n        \n        q = [c]\n        visited[c] = True\n        while len(q) > 0:\n            cur = q[-1]\n            if len(t[cur]) != 0:\n                s = t[cur].pop()\n                if (visited[s] and not (used[s])):\n                    print(-1)\n                    return\n                if used[s]:\n                    continue\n                q.append(s)\n                visited[s] = True\n            else:\n                ans.append(cur)\n                q.pop()\n                used[cur] = True\n    \n    ans = [str(x + 1) for x in ans]\n    print(len(ans))\n    print(' '.join(ans))\n\nmain()", "generated_code": "import sys\n\ndef main():\n    \n    (n, k) = map(int, sys.stdin.readline().split())\n    courses = list(map(int, sys.stdin.readline().split()))\n    courses = [x - 1 for x in courses]\n    \n    visited = [False] * n\n    used = [False] * n\n    \n    ans = []\n    t = []\n    \n    for i in range(n):\n        temp = list(map(int, sys.stdin.readline().split()))\n        temp = [x - 1 for x in temp]\n        t.append(temp[1:])\n    \n    for i in reversed(range(k)):\n        c = courses[i]\n        if used[c]:\n            continue\n        \n        q = [c]\n        visited[c] = True\n        while len(q) > 0:\n            cur = q[-1]\n            if len(t[cur]) != 0:\n                s = t[cur].pop()\n                if (visited[s] and not (used[s])):\n                    print(-1)\n                    return\n                if used[s]:\n                    continue\n                q.append(s)\n                visited[s] = True\n            else:\n                ans.append(cur)\n                q.pop()\n                used[cur] = True\n    \n    ans = [str(x + 1) for x in ans]\n    print(len(ans))\n    print(' '.join(ans))\n\nmain()", "score": 0.445, "codebleu": 0.9282578168170674, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.9938482642173767, "surfaceSim": 0.9954954954954955, "abs_surfaceSim_minus_score": 0.5504954954954955, "source": "local", "local_type": "MUT"}
{"id": "MBPP_306_2", "golden_code": "def remove_matching_tuple(test_list1, test_list2):\r\n  res = [sub for sub in test_list1 if sub not in test_list2]\r\n  return (res) ", "generated_code": "def remove_matching_tuple (sequence, test) -> list:\n\t\"\"\" Remove the element from the sequence. \"\"\"\n\tnumber = test.index(test[0])\n\ttest[0] = test[0] + 1\n\tsequence.pop(number)\n\treturn sequence", "score": 0.0, "codebleu": 0.14106807580297123, "crystalbleu": 0, "codebertscore": 0.77, "codescore": 0.07056008279323578, "surfaceSim": 0.4195488721804511, "abs_surfaceSim_minus_score": 0.4195488721804511, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_p02680_s341076610_MUT_146", "golden_code": "import sys\n(n, m, *abcdef) = list(map(int, sys.stdin.buffer.read().split()))\nver_lines = []\nhor_lines = []\nx_list = set()\ny_list = set()\nn3 = n * 3\nfor (a, b, c) in zip(abcdef[0:n3:3], abcdef[1:n3:3], abcdef[2:n3:3]):\n    y_list.add(a)\n    y_list.add(b)\n    x_list.add(c)\n    ver_lines.append((a, b, c))\nfor (d, e, f) in zip(abcdef[n3 + 0::3], abcdef[n3 + 1::3], abcdef[n3 + 2::3]):\n    y_list.add(d)\n    x_list.add(e)\n    x_list.add(f)\n    hor_lines.append((d, e, f))\nx_list.add(0)\ny_list.add(0)\nx_list = sorted(x_list)\ny_list = sorted(y_list)\nx_dict = {x: i for (i, x) in enumerate(x_list, start=1)}\ny_dict = {y: i for (i, y) in enumerate(y_list, start=1)}\nrow_real = len(x_list)\ncol_real = len(y_list)\nrow = row_real + 2\ncol = col_real + 2\nbanned_up_ij = [[0] * row for _ in range(col)]\nbanned_down_ij = [[0] * row for _ in range(col)]\nbanned_left_ij = [[0] * col for _ in range(row)]\nbanned_right_ij = [[0] * col for _ in range(row)]\nfor (a, b, c) in ver_lines:\n    if a > b:\n        (a, b) = (b, a)\n    ai = y_dict[a]\n    bi = y_dict[b]\n    j = x_dict[c]\n    banned_left_ij[j][ai] += 1\n    banned_left_ij[j][bi] -= 1\n    banned_right_ij[j - 1][ai] += 1\n    banned_right_ij[j - 1][bi] -= 1\nfor (d, e, f) in hor_lines:\n    if e > f:\n        (e, f) = (f, e)\n    i = y_dict[d]\n    ej = x_dict[e]\n    fj = x_dict[f]\n    banned_up_ij[i][ej] += 1\n    banned_up_ij[i][fj] -= 1\n    banned_down_ij[i - 1][ej] += 1\n    banned_down_ij[i - 1][fj] -= 1\nbanned_up = [0] * (row * col)\nbanned_down = [0] * (row * col)\nbanned_left = [0] * (row * col)\nbanned_right = [0] * (row * col)\nfor i in range(col):\n    ru = banned_up_ij[i]\n    rd = banned_down_ij[i]\n    ri = row * i\n    banned_up[ri] = ru[0]\n    banned_down[ri] = rd[0]\n    for j in range(1, row):\n        banned_up[ri + j] = banned_up[(ri + j) - 1] + ru[j]\n        banned_down[ri + j] = banned_down[(ri + j) - 1] + rd[j]\nfor j in range(row):\n    rl = banned_left_ij[j]\n    rr = banned_right_ij[j]\n    banned_left[j] = rl[0]\n    banned_right[j] = rr[0]\n    for i in range(1, col):\n        ri0 = (i - 1) * row\n        ri1 = i * row\n        banned_left[ri1 + j] = banned_left[ri0 + j] + rl[i]\n        banned_right[ri1 + j] = banned_right[ri0 + j] + rr[i]\ns = (row * y_dict[0]) + x_dict[0]\nenable = (([-1] * row) + ((([-1] + ([0] * (row - 2))) + [-1]) * (col - 2))) + ([-1] * row)\nq = [s]\nmoves = [(-row, banned_up), (-1, banned_left), (1, banned_right), (row, banned_down)]\nwhile q:\n    c = q.pop()\n    if enable[c] == 1:\n        continue\n    elif enable[c] == -1:\n        print('INF')\n        exit()\n    enable[c] = 1\n    for (dc, banned) in moves:\n        if banned[c]:\n            continue\n        nc = c + dc\n        if enable[nc] == 1:\n            continue\n        q.append(nc)\nans = 0\nfor i in range(col):\n    ri = i * row\n    for j in range(row):\n        if enable[ri + j] != 1:\n            continue\n        t = y_list[i - 1]\n        b = y_list[i]\n        l = x_list[j - 1]\n        r = x_list[j]\n        ans += (b - t) * (r - l)\nprint(ans)", "generated_code": "import sys\n(n, m, *abcdef) = list(map(int, sys.stdin.buffer.read().split()))\nver_lines = []\nhor_lines = []\nx_list = set()\ny_list = set()\nn3 = n * 3\nfor (a, b, c) in zip(abcdef[0:n3:3], abcdef[1:n3:3], abcdef[2:n3:3]):\n    y_list.add(a)\n    y_list.add(b)\n    x_list.add(c)\n    ver_lines.append((a, b, c))\nfor (d, e, f) in zip(abcdef[n3 + 0::3], abcdef[n3 + 1::3], abcdef[n3 + 2::3]):\n    y_list.add(d)\n    x_list.add(e)\n    x_list.add(f)\n    hor_lines.append((d, e, f))\nx_list.add(0)\ny_list.add(0)\nx_list = sorted(x_list)\ny_list = sorted(y_list)\nx_dict = {x: i for (i, x) in enumerate(x_list, start=1)}\ny_dict = {y: i for (i, y) in enumerate(y_list, start=1)}\nrow_real = len(x_list)\ncol_real = len(y_list)\nrow = row_real + 2\ncol = col_real + 2\nbanned_up_ij = [[0] * row for _ in range(col)]\nbanned_down_ij = [[0] * row for _ in range(col)]\nbanned_left_ij = [[0] * col for _ in range(row)]\nbanned_right_ij = [[0] * col for _ in range(row)]\nfor (a, b, c) in ver_lines:\n    if a > b:\n        (a, b) = (b, a)\n    ai = y_dict[a]\n    bi = y_dict[b]\n    j = x_dict[c]\n    banned_left_ij[j][ai] += 1\n    banned_left_ij[j][bi] -= 1\n    banned_right_ij[j - 1][ai] += 1\n    banned_right_ij[j - 1][bi] -= 1\n    break\nfor (d, e, f) in hor_lines:\n    if e > f:\n        (e, f) = (f, e)\n    i = y_dict[d]\n    ej = x_dict[e]\n    fj = x_dict[f]\n    banned_up_ij[i][ej] += 1\n    banned_up_ij[i][fj] -= 1\n    banned_down_ij[i - 1][ej] += 1\n    banned_down_ij[i - 1][fj] -= 1\nbanned_up = [0] * (row * col)\nbanned_down = [0] * (row * col)\nbanned_left = [0] * (row * col)\nbanned_right = [0] * (row * col)\nfor i in range(col):\n    ru = banned_up_ij[i]\n    rd = banned_down_ij[i]\n    ri = row * i\n    banned_up[ri] = ru[0]\n    banned_down[ri] = rd[0]\n    for j in range(1, row):\n        banned_up[ri + j] = banned_up[(ri + j) - 1] + ru[j]\n        banned_down[ri + j] = banned_down[(ri + j) - 1] + rd[j]\nfor j in range(row):\n    rl = banned_left_ij[j]\n    rr = banned_right_ij[j]\n    banned_left[j] = rl[0]\n    banned_right[j] = rr[0]\n    for i in range(1, col):\n        ri0 = (i - 1) * row\n        ri1 = i * row\n        banned_left[ri1 + j] = banned_left[ri0 + j] + rl[i]\n        banned_right[ri1 + j] = banned_right[ri0 + j] + rr[i]\ns = (row * y_dict[0]) + x_dict[0]\nenable = (([-1] * row) + ((([-1] + ([0] * (row - 2))) + [-1]) * (col - 2))) + ([-1] * row)\nq = [s]\nmoves = [(-row, banned_up), (-1, banned_left), (1, banned_right), (row, banned_down)]\nwhile q:\n    c = q.pop()\n    if enable[c] == 1:\n        continueelif enable[c] == -1:\n        print('INF')\n        exit()\n    enable[c] = 1\n    for (dc, banned) in moves:\n        if banned[c]:\n            continue\n        nc = c + dc\n        if enable[nc] == 1:\n            continue\n        q.append(nc)\nans = 0\nfor i in range(col):\n    ri = i * row\n    for j in range(row):\n        if enable[ri + j] != 1:\n            continue\n        t = y_list[i - 1]\n        b = y_list[i]\n        l = x_list[j - 1]\n        r = x_list[j]\n        ans += (b - t) * (r - l)\nprint(ans)", "score": 0.0, "codebleu": 0.9856332079741151, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9822986125946045, "surfaceSim": 0.4988309953239813, "abs_surfaceSim_minus_score": 0.4988309953239813, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_PIE_extra_p03371_s614340278_OP_1", "golden_code": "A, B, C, X, Y = list(map(int, input().split()))\n\nans = float('inf')\n\nfor i in range(max(X,Y)+1):\n\n    cost = 2 * C * i + max(0,X-i)*A +max(0,Y-i)*B\n\n    ans = min(ans,cost)\n\nprint(ans)", "generated_code": "A, B, C, X, Y = list(map(int, input().split()))\n\ntmp = A*X + B*Y\n\nif X >= Y:\n\n    tmp = min(tmp,2*Y*C+(X-Y)*A)\n\nelse:\n\n    tmp = min(tmp,2*X*C+(Y-X)*B)\n\ntmp = min(tmp,max(X,Y)*2*C)\n\nprint(tmp)", "score": 1.0, "codebleu": 0.38064334288741764, "crystalbleu": 0.3, "codebertscore": 0.85, "codescore": 0.04377409815788269, "surfaceSim": 0.6701388888888888, "abs_surfaceSim_minus_score": 0.32986111111111116, "source": "local", "local_type": "OP"}
{"id": "MBPP_50_9", "golden_code": "def mutiple_tuple(nums):\r\n    temp = list(nums)\r\n    product = 1 \r\n    for x in temp:\r\n        product *= x\r\n    return product", "generated_code": "def mutiple_tuple(n):\n    \n\tfor i in range(len(ss)):\n\t\tif ss[i]*(n//i) == 0:\n\t\t\treturn False\n\treturn True\nss={}", "score": 0.0, "codebleu": 0.1501510938408352, "crystalbleu": 0, "codebertscore": 0.79, "codescore": 0.02862526848912239, "surfaceSim": 0.5710450966356478, "abs_surfaceSim_minus_score": 0.5710450966356478, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_4484_91_OP_1", "golden_code": "from math import factorial\nn,m=list(map(int,input().split()))\nif abs(n-m)>1:\n    print((0))\n    return\nmod=10**9+7\nif n==m:\n    print(((2*factorial(n)*factorial(m))%mod))\nelse:\n    print(((factorial(n)*factorial(m))%mod))", "generated_code": "from math import factorial\nfrom functools import lru_cache\n\ndef compute_factorials():\n    a, b = map(int, input().split())\n    if abs(a - b) > 1:\n        print(0)\n        return\n    mod = 10**9 + 7\n    @lru_cache(None)\n    def fact(x):\n        return factorial(x)\n    if a == b:\n        result = (2 * fact(a) * fact(b)) % mod\n    else:\n        result = (fact(a) * fact(b)) % mod\n    print(result)\n", "score": 1.0, "codebleu": 0.37414712269712924, "crystalbleu": 0.34, "codebertscore": 0.83, "codescore": 0.7923405170440674, "surfaceSim": 0.7521313698895563, "abs_surfaceSim_minus_score": 0.2478686301104437, "source": "local", "local_type": "OP"}
{"id": "LOCAL_MBPP_550_MUT_11", "golden_code": "import os\n\ndef find_Max(arr, low, high):\n    if high < low:\n        return arr[0]\n    if high == low:\n        return arr[low]\n    mid = low + ((high - low) // 2)\n    if (mid < high and arr[mid + 1] < arr[mid]):\n        return arr[mid]\n    if (mid > low and arr[mid] < arr[mid - 1]):\n        return arr[mid - 1]\n    if arr[low] > arr[mid]:\n        return find_Max(arr, low, mid - 1)\n    else:\n        return find_Max(arr, mid + 1, high)", "generated_code": "import os\n\ndef find_Max(arr, low, high):\n    if high < low:\n        return arr[0]\n    if not (high == low):\n        return arr[low]\n    mid = low + ((high - low) // 2)\n    if (mid < high and arr[mid + 1] < arr[mid]):\n        return arr[mid]\n    if (mid > low and arr[mid] < arr[mid - 1]):\n        return arr[mid - 1]\n    if arr[low] > arr[mid]:\n        return find_Max(arr, low, mid - 1)\n    else:\n        return find_Max(arr, mid + 1, high)", "score": 0.4367, "codebleu": 0.9496880005938173, "crystalbleu": 0.93, "codebertscore": 0.99, "codescore": 0.9937783479690552, "surfaceSim": 0.9586167800453516, "abs_surfaceSim_minus_score": 0.5219167800453516, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-3854_5", "golden_code": "from collections import Counter\nimport sys\nn,k = list(map(int,sys.stdin.readline().split()))\nc = list(map(int,sys.stdin.readline().split()))\ndp = [0]*(k+1)\ndp[0]=1\nfor i in c:\n    tmp = dp[:]\n    for j in range(k,i-1,-1):\n        tmp[j] |= dp[j-i]|(dp[j-i]<<i)\n    dp = tmp\nb = bin(dp[-1])\nans = [i for i in range(k + 1) if b[-i - 1] == '1']\nsys.stdout.write(\"{0}\\n{1}\".format(len(ans),str(ans)[1:-1].replace(\",\",\"\")))\n", "generated_code": "n, k = list(map(int, input().split()))\na = list(map (int, input().strip().split())) \ns = sum (a)\nm = []\nfor i in range (n):\n\tif a[i]<=k:\n\t\tm.append (a[i])\nans = []\nfor x in range(n):\n\tr = []\n\tif m[x]>0:\n\t\tfor y in range (x+1, n):\n\t\t\tif m[y]>0:   \n\t\t\t\tr.append (k-a[y])\n\t\t\t\tr.sort()\n\t\t\t\tbreak\n\t\tif r!=[]:\n\t\t\tans.append (r)\nprint (len(ans))\nprint (*ans)\n", "score": 0.0196, "codebleu": 0.1511722220628212, "crystalbleu": 0.13, "codebertscore": 0.78, "codescore": 0.0719304233789444, "surfaceSim": 0.4413339353673483, "abs_surfaceSim_minus_score": 0.42173393536734827, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_1275_39_MUT_10", "golden_code": "(N, K) = list(map(int, input().split()))\nans = 0\nfor i in range(2, (2 * N) + 1):\n    j = i - K\n    if not (2 <= j <= 2 * N):\n        continue\n    ans += min(i - 1, ((2 * N) - i) + 1) * min(j - 1, ((2 * N) - j) + 1)\nprint(ans)", "generated_code": "(N, K) = list(map(int, input().split()))\nans = 0\nfor i in range(2, (2 * N) + 1):\n    j = i - K\n    if not (2 <= j <= 2 * N):\n        continue\n    ans += min(i - 1, ((2 / N) - i) + 1) * min(j - 1, ((2 * N) - j) + 1)\nprint(ans)", "score": 0.0305, "codebleu": 0.9770076290860976, "crystalbleu": 0.95, "codebertscore": 0.99, "codescore": 0.9937223792076111, "surfaceSim": 0.9760386473429952, "abs_surfaceSim_minus_score": 0.9455386473429952, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_PIE_extra_p03032_s669893633_OP_1", "golden_code": "from collections import deque\n\n\n\nn, k = list(map(int, input().split()))\n\nV = list(map(int, input().split()))\n\n\n\nans = 0\n\nfor t in range(k//2 + 1):\n\n    hand = deque(V[:k-t])\n\n    rest = deque(V[k-t:])\n\n    cur_sum = sum(hand)\n\n\n\n    for j in range(k-t+1):\n\n        put_back = 0\n\n        rev_hand = sorted(hand)\n\n\n\n        for i in range(t):\n\n            jewel = rev_hand[i]\n\n            if jewel < 0:\n\n                put_back -= jewel\n\n            else:\n\n                break\n\n\n\n        candidate = cur_sum + put_back\n\n        ans = max(candidate, ans)\n\n\n\n        to_rest = hand.pop()\n\n        rest.appendleft(to_rest)\n\n        to_hand = rest.pop()\n\n        hand.appendleft(to_hand)\n\n\n\n        cur_sum += to_hand - to_rest\n\n\n\nprint(ans)", "generated_code": "n, k = list(map(int, input().split()))\n\nV = list(map(int, input().split()))\n\n\n\n\n\ndef get_jewelries(box, left_pop, right_pop):\n\n    if left_pop + right_pop >= len(box):\n\n        return box[:]\n\n\n\n    left = box[:left_pop]\n\n    right = box[-right_pop:] if right_pop else []\n\n\n\n    return left + right\n\n\n\n\n\ncandidates = []\n\npop_max = min(k, n)\n\nfor pop_count in range(pop_max+1):\n\n    residue = k - pop_count\n\n\n\n    for left_pop in range(pop_count+1):\n\n        right_pop = pop_count - left_pop\n\n        jewelries = get_jewelries(V, left_pop, right_pop)\n\n        jewelries.sort(reverse=True)\n\n\n\n        for _ in range(residue):\n\n            if not jewelries:\n\n                break\n\n            if jewelries[-1] < 0:\n\n                jewelries.pop()\n\n\n\n        value = sum(jewelries)\n\n        candidates.append(value)\n\n\n\nprint((max(candidates)))\n", "score": 1.0, "codebleu": 0.30416954502908017, "crystalbleu": 0.2, "codebertscore": 0.76, "codescore": 0.9938251972198486, "surfaceSim": 0.5229389615537059, "abs_surfaceSim_minus_score": 0.4770610384462941, "source": "local", "local_type": "OP"}
{"id": "APPS_test-1717_11", "golden_code": "from collections import defaultdict\nn = int(input())\ns = 1\nkeys = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\npowers = defaultdict(lambda : 0)\n\nfor i in range(2, n+1):\n    for key in keys:\n        x = i\n        cur = 0\n        while x > 0 and x % key == 0:\n            x //= key\n            cur += 1\n        powers[key] = max(powers[key], cur)\n\n# print(dict(powers))\nfor key in keys:\n    s *= (key ** powers[key])\ns += 1\nprint(s)\n\n# for i in range(2, n+1):\n#     print(i, s % i)\n", "generated_code": "N = int(input())\nmod = 10**13\ndiv = 10**12\n\nb = (10**12) % mod\nl = N // div\nr = N % div\n\ncount = 0\nfor i in range(l, r + 1):\n\tcount += (i * (b + l * i)) % mod\n\tcount %= mod\n\nprint(count)\n", "score": 0.0, "codebleu": 0.11800201467246813, "crystalbleu": 0, "codebertscore": 0.72, "codescore": 0.02730344422161579, "surfaceSim": 0.5470485096434834, "abs_surfaceSim_minus_score": 0.5470485096434834, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_142_OP_1", "golden_code": "def sum_squares(lst):\n    result =[]\n    for i in range(len(lst)):\n        if i %3 == 0:\n            result.append(lst[i]**2)\n        elif i % 4 == 0 and i%3 != 0:\n            result.append(lst[i]**3)\n        else:\n            result.append(lst[i])\n    return sum(result)", "generated_code": "def sum_squares(data):\n    total = 0\n    for idx, value in enumerate(data):\n        if idx % 3 == 0:\n            total += value ** 2\n        elif idx % 4 == 0:\n            total += value ** 3\n        else:\n            total += value\n    return total", "score": 1.0, "codebleu": 0.1859848516930022, "crystalbleu": 0.14, "codebertscore": 0.82, "codescore": 0.2705704867839813, "surfaceSim": 0.6184629087670187, "abs_surfaceSim_minus_score": 0.3815370912329813, "source": "local", "local_type": "OP"}
{"id": "LOCAL_PIE_extra_p03078_s581139547_OP_1", "golden_code": "# -*- coding: utf-8 -*-\n\nx, y, z, k = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\nb = list(map(int, input().split()))\n\nc = list(map(int, input().split()))\n\n\n\na.sort(reverse=True)\n\nb.sort(reverse=True)\n\nc.sort(reverse=True)\n\n\n\nabc = []\n\n\n\nfor i, _a in enumerate(a):\n\n    for j, _b in enumerate(b):\n\n        if (i+1) * (j+1) > k:\n\n            break\n\n        for l, _c in enumerate(c):\n\n            if (i+1) * (j+1) * (l+1) > k:\n\n                break\n\n            abc.append(_a + _b + _c)\n\n\n\nabc.sort(reverse=True)\n\nfor x in abc[:k]:\n\n    print(x)\n", "generated_code": "# -*- coding: utf-8 -*-\n\nimport heapq\n\n\n\nx, y, z, k = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\nb = list(map(int, input().split()))\n\nc = list(map(int, input().split()))\n\n\n\nla, lb, lc = len(a), len(b), len(c)\n\n\n\na.sort(reverse=True)\n\nb.sort(reverse=True)\n\nc.sort(reverse=True)\n\n\n\nfix = set()\n\n\n\nq = [(-(a[0]+b[0]+c[0]), 0, 0, 0)]\n\n\n\nfor _ in range(k):\n\n    abc, i, j, l = heapq.heappop(q)\n\n    print((-abc))\n\n\n\n    if i+1 < la and (i+1, j, l) not in fix:\n\n        heapq.heappush(q, (-(a[i+1]+b[j]+c[l]), i+1, j, l))\n\n        fix.add((i+1, j, l))\n\n\n\n    if j+1 < lb and (i, j+1, l) not in fix:\n\n        heapq.heappush(q, (-(a[i]+b[j+1]+c[l]), i, j+1, l))\n\n        fix.add((i, j+1, l))\n\n\n\n    if l+1 < lc and (i, j, l+1) not in fix:\n\n        heapq.heappush(q, (-(a[i]+b[j]+c[l+1]), i, j, l+1))\n\n        fix.add((i, j, l+1))\n", "score": 1.0, "codebleu": 0.45639122124696185, "crystalbleu": 0.23, "codebertscore": 0.84, "codescore": 0.2119034230709076, "surfaceSim": 0.5830198715756678, "abs_surfaceSim_minus_score": 0.4169801284243322, "source": "local", "local_type": "OP"}
{"id": "APPS_test-0174_9", "golden_code": "def f(a):\n    if len(a) == 1:\n        if a[0] == 0:\n            print(\"YES\\n0\")\n            return\n        else:\n            print(\"NO\")\n            return\n    if a[-1] == 1:\n        print(\"NO\")\n        return\n    if a[-2] == 1:\n        print(\"YES\")\n        print(\"->\".join(str(x) for x in a))\n        return\n    elif len(a) == 2:\n        print(\"NO\")\n        return\n    elif len(a) >= 3 and a[-3] == 0:\n        a[-3] = '(0'\n        a[-2] = '0)'\n        print(\"YES\\n\" + \"->\".join(str(x) for x in a))\n        return      \n    for i in range(len(a) - 3, -1, -1):\n        if a[i] == 0:\n            a[i] = '(' + str(a[i])\n            a[i+1] = '(' + str(a[i+1])\n            a[-2] = '0))'\n            print(\"YES\\n\" + \"->\".join(str(x) for x in a))\n            return\n    print(\"NO\")\n    return\n\nn = int(input())\na = list(int(x) for x in input().split())\nf(a)", "generated_code": "def main():\n\tn = int(input())\n\taa = list(map(int, input().split()))\n\tbb = []\n\tfor i in range(n):\n\t\tif aa[i] == 0:\n\t\t\tcontinue\n\t\telif aa[~i] == 0 and aa[~~i]!= 0:\n\t\t\tbb.append(aa[~i])\n\t\telse:\n\t\t\tbb_.append(a)\n\tbb.sort()\n\tif len(bb) > 1 and bb[0] == bb[-1]:\n\t\tprint(\"NO\")\n\telif len(bb):\n\t\tprint(\"YES\")\n\t\tprint(*bb[:-1])\n\telse:\n\t\tprint(\"^\")\n\n\ndef __starting_point():\n\tmain()\n__starting_point()\n", "score": 0.0, "codebleu": 0.1626443325519188, "crystalbleu": 0.11, "codebertscore": 0.75, "codescore": 0.03659754991531372, "surfaceSim": 0.5675490196078432, "abs_surfaceSim_minus_score": 0.5675490196078432, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-1408_7", "golden_code": "n = int(input())\na = list(tuple(map(int, input().split())) for i in range(n))\ns = sum(t for t, w in a)\na = [(t / w, t, t + w) for t, w in a]\na.sort(reverse = True)\nd, i = s, 0\nwhile d >= 0:\n    s -= a[i][1]\n    d -= a[i][2]\n    i += 1\ni -= 1\ns += a[i][1]\nd += a[i][2]\nif a[i][1] == 2:\n    j = i + 1\n    while j < n and a[j][1] == 2: j += 1\n    if j < n and d >= a[j][2]:\n        i = 0\n        s -= 1\nif i > 0: \n    i -= 1\n    if a[i][1] == 1:\n        d += a[i][2]\n        j = i + 1\n        while j < n and a[j][1] == 1: j += 1\n        if j < n and d >= a[j][2]: s -= 1\nprint(s)", "generated_code": "n=int(input())\na=[]\nfor i in range(n):\n\ta.append(list(map(int,input().split())))\na.sort(key=lambda x:x[1])\nb=[]\nc=0\nfor i in a:\n\tb.append(i[0])\n\tc+=i[1]\ncurr=0\nb.reverse()\nfor i in b:\n\tcurr+=i\n\tif curr>c:\n\t\tc=curr\nprint(c)\n", "score": 0.048, "codebleu": 0.08793295052389744, "crystalbleu": 0.07, "codebertscore": 0.76, "codescore": 0.15519152581691742, "surfaceSim": 0.49242386729388465, "abs_surfaceSim_minus_score": 0.44442386729388467, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-1083_31", "golden_code": "n = int(input())\ns = \"\"\nif n % 4 == 0:\n  print(0)\n  s += str(n // 2) + \" \"\n  for i in range(n // 4):\n    s += str(4 * i + 1) + \" \"\n    s += str(4 * i + 4) + \" \"\n  print(s[:-1])\nelif n % 4 == 3:\n  print(0)\n  s += str(n // 2 + 1) + \" \"\n  s += \"1 2 \"\n  for i in range(n // 4):\n    s += str(4 * i + 4) + \" \"\n    s += str(4 * i + 7) + \" \"\n  print(s[:-1])\nelif n % 4 == 2:\n  print(1)\n  s += str(n // 2) + \" 1 \"\n  for i in range(0, n // 4):\n    s += str(4 * i + 3) + \" \"\n    s += str(4 * i + 6) + \" \"\n  print(s[:-1])\nelse:\n  print(1)\n  s += str(n // 2 + 1) + \" 1 \"\n  for i in range(0, n // 4):\n    s += str(4 * i + 2) + \" \"\n    s += str(4 * i + 5) + \" \"\n  print(s[:-1])", "generated_code": "n = int(input())\nprint(0)\nprint(list(range(0, n)))\n\n#cur_sum = left_sum\n#split_pos = 0\n#split_min = 0\n#result = []\n#for i in range(0, n):\n#    cur_sum += left_sum[i]\n#    split_pos += 1\n#    if cur_sum > split_sum:\n#        split_min = i\n#        split _sum = cur_sum\n#        result.append(left_sum[i])\n#        if split_pos == 2:\n#            break\n#print(result)\n", "score": 0.0, "codebleu": 0.040574607715899984, "crystalbleu": 0.0, "codebertscore": 0.71, "codescore": 0.11397265642881393, "surfaceSim": 0.36912936006591596, "abs_surfaceSim_minus_score": 0.36912936006591596, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_extra_p03796_s983655328_OP_1", "golden_code": "import math\n\n\n\nn = int(eval(input()))\n\nprint((math.factorial(n) % (10 ** 9 + 7)))", "generated_code": "n = int(eval(input()))\n\np = 1\n\nfor i in range(1, n + 1):\n\n  p = p * i % (10 ** 9 + 7)\n\nprint(p)", "score": 1.0, "codebleu": 0.38929979858119235, "crystalbleu": 0, "codebertscore": 0.83, "codescore": 0.36310485005378723, "surfaceSim": 0.6160990712074303, "abs_surfaceSim_minus_score": 0.38390092879256965, "source": "local", "local_type": "OP"}
{"id": "APPS_test-0149_16", "golden_code": "R=lambda:list(map(int,input().strip().split()))\n[x,y,l,r]=R()\na=list()\nb=list()\ncur=1\nwhile(cur<r):\n    a.append(cur) \n    cur*=x \ncur=1\nwhile(cur<r):\n    b.append(cur) \n    cur*=y \n    \ns=set()\ns.add(l-1)\ns.add(r+1)\nfor p in a:\n    for q in b:\n        s.add(p+q) \ns=list(s)\ns.sort()\nml=0\nfor i in range(len(s)-1):\n    if s[i]>=l-1 and s[i+1]<=r+1:\n        ml=max(ml,s[i+1]-s[i]-1)\nprint(ml)", "generated_code": "x, y, l, r = list(map(int, input().split()))\n\nidx = max(0, l - x * 2 - r)\n\nprint(max(0, idx))\n", "score": 0.0072, "codebleu": 0.0748729531338227, "crystalbleu": 0.02, "codebertscore": 0.68, "codescore": 0.10458384454250336, "surfaceSim": 0.3577916923890996, "abs_surfaceSim_minus_score": 0.3505916923890996, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_31_20", "golden_code": "def smallest_multiple(n):\r\n    if (n<=2):\r\n      return n\r\n    i = n * 2\r\n    factors = [number  for number in range(n, 1, -1) if number * 2 > n]\r\n    while True:\r\n        for a in factors:\r\n            if i % a != 0:\r\n                i += n\r\n                break\r\n            if (a == factors[-1] and i % a == 0):\r\n                return i", "generated_code": "def smallest_multiple(lst):\n\tif not isinstance(lst, list):\n\t\treturn lst\n\n\treturn min(lst)", "score": 0.2307, "codebleu": 0.06769771097061852, "crystalbleu": 0, "codebertscore": 0.66, "codescore": 0.06936586648225784, "surfaceSim": 0.44764533379334137, "abs_surfaceSim_minus_score": 0.21694533379334138, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_72_47", "golden_code": "def Average(lst): \r\n    return sum(lst) / len(lst) ", "generated_code": "def Average(lst): \n\tsum = 0\n\tfor n in lst:\n\t\tsum += n\n\treturn sum/len(lst)\nduplicate = set([])", "score": 1.0, "codebleu": 0.4084736342478235, "crystalbleu": 0, "codebertscore": 0.86, "codescore": 0.9934518337249756, "surfaceSim": 0.5707133917396746, "abs_surfaceSim_minus_score": 0.4292866082603254, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_4680_93_MUT_10", "golden_code": "(a, b, c) = map(int, input().split())\niroha = [a, b, c]\nif (iroha.count(5) == 2 and iroha.count(7) == 1):\n    print('YES')\nelse:\n    print('NO')", "generated_code": "(a, b, c) = map(int, input().split())\npass\nif (iroha.count(5) == 2 and iroha.count(7) == 1):\n    print('YES')\nelse:\n    print('NO')", "score": 0.0, "codebleu": 0.7289192309217457, "crystalbleu": 0.69, "codebertscore": 0.97, "codescore": 0.6381359100341797, "surfaceSim": 0.8995098039215685, "abs_surfaceSim_minus_score": 0.8995098039215685, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_MBPP_493_MUT_79", "golden_code": "import os\n\nimport math\ndef calculate_polygons(startx, starty, endx, endy, radius):\n    sl = (2 * radius) * math.tan(math.pi / 6)\n    p = sl * 0.5\n    b = sl * math.cos(math.radians(30))\n    w = b * 2\n    h = 2 * sl\n    startx = startx - w\n    starty = starty - h\n    endx = endx + w\n    endy = endy + h\n    origx = startx\n    origy = starty\n    xoffset = b\n    yoffset = 3 * p\n    polygons = []\n    row = 1\n    counter = 0\n    while starty < endy:\n        if row % 2 == 0:\n            startx = origx + xoffset\n        else:\n            startx = origx\n        while startx < endx:\n            p1x = startx\n            p1y = starty + p\n            p2x = startx\n            p2y = starty + (3 * p)\n            p3x = startx + b\n            p3y = starty + h\n            p4x = startx + w\n            p4y = starty + (3 * p)\n            p5x = startx + w\n            p5y = starty + p\n            p6x = startx + b\n            p6y = starty\n            poly = [\\\n                (p1x, p1y), \\\n                (p2x, p2y), \\\n                (p3x, p3y), \\\n                (p4x, p4y), \\\n                (p5x, p5y), \\\n                (p6x, p6y), \\\n                (p1x, p1y)]\n            polygons.append(poly)\n            counter += 1\n            startx += w\n        starty += yoffset\n        row += 1\n    return polygons", "generated_code": "import os\n\nimport math\ndef calculate_polygons(startx, starty, endx, endy, radius):\n    sl = (2 * radius) * math.tan(math.pi / 6)\n    p = sl * 0.5\n    b = sl * math.cos(math.radians(30))\n    w = b * 2\n    h = 2 * sl\n    startx = startx - w\n    starty = starty - h\n    endx = endx + w\n    endy = endy + h\n    origx = startx\n    origy = starty\n    xoffset = b\n    yoffset = 3 * p\n    polygons = []\n    row = 1\n    counter = 0\n    while starty < endy:\n        if row % 2 == 0:\n            pass\n        else:\n            startx = origx\n        while startx < endx:\n            p1x = startx\n            p1y = starty + p\n            p2x = startx\n            p2y = starty + (3 * p)\n            p3x = startx + b\n            p3y = starty + h\n            p4x = startx + w\n            p4y = starty + (3 * p)\n            p5x = startx + w\n            p5y = starty + p\n            p6x = startx + b\n            p6y = starty\n            poly = [\\\n                (p1x, p1y), \\\n                (p2x, p2y), \\\n                (p3x, p3y), \\\n                (p4x, p4y), \\\n                (p5x, p5y), \\\n                (p6x, p6y), \\\n                (p1x, p1y)]\n            polygons.append(poly)\n            counter += 1\n            startx += w\n        starty += yoffset\n        row += 1\n    return polygons", "score": 0.0, "codebleu": 0.96558993776844, "crystalbleu": 0.97, "codebertscore": 0.99, "codescore": 0.993729829788208, "surfaceSim": 0.9764261959580456, "abs_surfaceSim_minus_score": 0.9764261959580456, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_HE_84_OP_1", "golden_code": "def solve(N):\n    return bin(sum(int(i) for i in str(N)))[2:]", "generated_code": "def solve(num):\n    total = 0\n    for char in str(num):\n        total += int(char)\n    binary_result = ''\n    while total > 0:\n        binary_result = str(total % 2) + binary_result\n        total //= 2\n    return binary_result if binary_result else '0'", "score": 1.0, "codebleu": 0.19116090310801087, "crystalbleu": 0, "codebertscore": 0.76, "codescore": 0.21615377068519592, "surfaceSim": 0.40634920634920635, "abs_surfaceSim_minus_score": 0.5936507936507937, "source": "local", "local_type": "OP"}
{"id": "APPS_test-1041_8", "golden_code": "#Circle of Numbers\nimport math\n\ndef centre(n, pts):\n    x, y = 0, 0\n    for j in [7,11,13,17,19,23,29,31,37,1193,1663,2711,4007,65537]:\n        if math.gcd(n,j) == 1:\n            for i in range(n):\n                k = int(pts[i])\n                x += k*math.cos(math.pi * 2*i*j/n)\n                y += k*math.sin(math.pi * 2*i*j/n)\n            if not (abs(x) < 0.000001 and abs(y) < 0.000001):\n                return 'NO'\n    return 'YES'\n    \ndef strconv(s):\n    return [char for char in s]\n\nn = int(input())\npts = strconv(input())\nprint(centre(n,pts))\n", "generated_code": "n = int(input())\na = [int(x) for x in input()]\nd = [0] * n\nfor i in range(n):\n\td[i] = (a[i] + a[i]) // 2 - a[i]\nfor i in d:\n\tif i < 0:\n\t\tprint(\"NO\")\n\t\treturn\nprint(\"YES\")\n", "score": 0.2118, "codebleu": 0.12183178676915328, "crystalbleu": 0.07, "codebertscore": 0.7, "codescore": 0.2415076196193695, "surfaceSim": 0.5130256610401014, "abs_surfaceSim_minus_score": 0.3012256610401014, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_31_28", "golden_code": "def smallest_multiple(n):\r\n    if (n<=2):\r\n      return n\r\n    i = n * 2\r\n    factors = [number  for number in range(n, 1, -1) if number * 2 > n]\r\n    while True:\r\n        for a in factors:\r\n            if i % a != 0:\r\n                i += n\r\n                break\r\n            if (a == factors[-1] and i % a == 0):\r\n                return i", "generated_code": "def smallest_multiple(n): return n and 1 > (n-1 or -1)", "score": 0.1654, "codebleu": 0.060200596455806644, "crystalbleu": 0, "codebertscore": 0.72, "codescore": 0.10176195949316025, "surfaceSim": 0.5046082949308756, "abs_surfaceSim_minus_score": 0.33920829493087556, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_598_1", "golden_code": "def max_subarray_product(arr):\r\n\tn = len(arr)\r\n\tmax_ending_here = 1\r\n\tmin_ending_here = 1\r\n\tmax_so_far = 0\r\n\tflag = 0\r\n\tfor i in range(0, n):\r\n\t\tif arr[i] > 0:\r\n\t\t\tmax_ending_here = max_ending_here * arr[i]\r\n\t\t\tmin_ending_here = min (min_ending_here * arr[i], 1)\r\n\t\t\tflag = 1\r\n\t\telif arr[i] == 0:\r\n\t\t\tmax_ending_here = 1\r\n\t\t\tmin_ending_here = 1\r\n\t\telse:\r\n\t\t\ttemp = max_ending_here\r\n\t\t\tmax_ending_here = max (min_ending_here * arr[i], 1)\r\n\t\t\tmin_ending_here = temp * arr[i]\r\n\t\tif (max_so_far < max_ending_here):\r\n\t\t\tmax_so_far = max_ending_here\r\n\tif flag == 0 and max_so_far == 0:\r\n\t\treturn 0\r\n\treturn max_so_far", "generated_code": "def max_subarray_product(arr, default=0):\n\tmaxnr = -1\n\tfor nr in arr:\n\t\tif nr > maxnr:\n\t\t\tmaxnr=nr\n\treturn default", "score": 0.0, "codebleu": 0.06229732159955674, "crystalbleu": 0, "codebertscore": 0.68, "codescore": 0.04028380289673805, "surfaceSim": 0.45348608837970544, "abs_surfaceSim_minus_score": 0.45348608837970544, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_MBPP_819_MUT_25", "golden_code": "import os\n\ndef count_duplic(lists):\n    element = []\n    frequency = []\n    if not lists:\n        return element\n    running_count = 1\n    for i in range(len(lists) - 1):\n        if lists[i] == lists[i + 1]:\n            running_count += 1\n        else:\n            frequency.append(running_count)\n            element.append(lists[i])\n            running_count = 1\n    frequency.append(running_count)\n    element.append(lists[i + 1])\n    return (element, frequency)", "generated_code": "import os\n\ndef count_duplic(lists):\n    element = []\n    frequency = []\n    if not lists:\n        return element\n    running_count = 1\n    for i in range(len(lists) - 1):\n        break\n    \n    \n    \n    \n    \n    frequency.append(running_count)\n    element.append(lists[i + 1])\n    return (element, frequency)", "score": 0.0, "codebleu": 0.6254939260917927, "crystalbleu": 0.52, "codebertscore": 0.95, "codescore": 0.04575848579406738, "surfaceSim": 0.8083333333333333, "abs_surfaceSim_minus_score": 0.8083333333333333, "source": "local", "local_type": "MUT"}
{"id": "MBPP_11_21", "golden_code": "def lcm(x, y):\r\n   if x > y:\r\n       z = x\r\n   else:\r\n       z = y\r\n   while(True):\r\n       if((z % x == 0) and (z % y == 0)):\r\n           lcm = z\r\n           break\r\n       z += 1\r\n   return lcm", "generated_code": "def lcm(x, y):\n\treturn x * y // gcd(x,y)\n\n\n\n\n\n\t\nfrom fractions import gcd, gcd", "score": 1.0, "codebleu": 0.14786504060532663, "crystalbleu": 0, "codebertscore": 0.75, "codescore": 0.9920269846916199, "surfaceSim": 0.4548491790759832, "abs_surfaceSim_minus_score": 0.5451508209240168, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_p03558_s378178699_MUT_7", "golden_code": "from collections import defaultdict\nfrom collections import deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\ndef I():\n    return int(sys.stdin.readline())\ndef LS():\n    return list(map(list, sys.stdin.readline().split()))\ndef S():\n    return list(sys.stdin.readline())[:-1]\ndef IR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = I()\n    return l\ndef LIR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = LI()\n    return l\ndef SR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = S()\n    return l\ndef LSR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = SR()\n    return l\nmod = 1000000007\ndef A():\n    s = S()\n    t = S()\n    if s + t == t[::-1] + s[::-1]:\n        print('YES')else:print('NO')\ndef B():\n    n = I()\n    for i in range(int(n ** 0.5) + 2)[::-1]:\n        if i * i <= n:\n            print(i * i)\n            quit()\ndef C():\n    n = I()\n    a = LI()\n    b = LI()\n    c = LI()\n    q = [0 for i in range(n)]\n    ans = 0\n    a.sort()\n    b.sort()\n    c.sort()\n    for i in range(n):\n        j = bisect.bisect_left(a, b[i])\n        q[i] = j\n    for i in range(n - 1):\n        q[i + 1] += q[i]\n    q.insert(0, 0)\n    for i in range(n):\n        j = bisect.bisect_left(b, c[i])\n        ans += q[j]\n    print(ans)\ndef D():\n    def dijkstra():\n        d = [float('inf') for i in range(k)]\n        q = [[0, 1]]\n        d[1] = 0\n        while q:\n            (dx, x) = heappop(q)\n            for (y, dy) in v[x]:\n                if d[y] > dx + dy:\n                    d[y] = dx + dy\n                    heappush(q, [d[y], y])\n        print(d[0] + 1)\n    k = I()\n    if k == 1:\n        print(1)\n        quit()\n    v = [[] for i in range(k)]\n    for i in range(1, k):\n        v[i].append([(i + 1) % k, 1])\n        v[i].append([(i * 10) % k, 0])\n    dijkstra()\ndef E():\n    return\ndef F():\n    return\ndef G():\n    return\ndef H():\n    return", "generated_code": "from collections import defaultdict\nfrom collections import deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\ndef I():\n    return int(sys.stdin.readline())\ndef LS():\n    return list(map(list, sys.stdin.readline().split()))\ndef S():\n    return list(sys.stdin.readline())[:-1]\ndef IR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = I()\n    return l\ndef LIR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = LI()\n    return l\ndef SR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = S()\n    return l\ndef LSR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = SR()\n    return l\nmod = 1000000007\ndef A():\n    s = S()\n    t = S()\n    if s + t == t[::+1] + s[::-1]:\n        print('YES')else:print('NO')\ndef B():\n    n = I()\n    for i in range(int(n ** 0.5) + 2)[::-1]:\n        if i * i <= n:\n            print(i * i)\n            quit()\ndef C():\n    n = I()\n    a = LI()\n    b = LI()\n    c = LI()\n    q = [0 for i in range(n)]\n    ans = 0\n    a.sort()\n    b.sort()\n    c.sort()\n    for i in range(n):\n        j = bisect.bisect_left(a, b[i])\n        q[i] = j\n    for i in range(n - 1):\n        q[i + 1] += q[i]\n    q.insert(0, 0)\n    for i in range(n):\n        j = bisect.bisect_left(b, c[i])\n        ans += q[j]\n    print(ans)\ndef D():\n    def dijkstra():\n        d = [float('inf') for i in range(k)]\n        q = [[0, 1]]\n        d[1] = 0\n        while q:\n            (dx, x) = heappop(q)\n            for (y, dy) in v[x]:\n                if d[y] > dx + dy:\n                    d[y] = dx + dy\n                    heappush(q, [d[y], y])\n        print(d[0] + 1)\n    k = I()\n    if k == 1:\n        print(1)\n        quit()\n    v = [[] for i in range(k)]\n    for i in range(1, k):\n        v[i].append([(i + 1) % k, 1])\n        v[i].append([(i * 10) % k, 0])\n    dijkstra()\ndef E():\n    return\ndef F():\n    return\ndef G():\n    return\ndef H():\n    return", "score": 0.0, "codebleu": 0.9960259674102339, "crystalbleu": 1.0, "codebertscore": 1.0, "codescore": 0.9813775420188904, "surfaceSim": 0.499755859375, "abs_surfaceSim_minus_score": 0.499755859375, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_PIE_p02599_s870922238_MUT_62", "golden_code": "import sys\nclass BinaryIndexedTree:\n    def __init__(self, A):\n        self.__n = len(A)\n        self.__node = [0] * (self.__n + 1)\n        self.__data = [0] * (self.__n + 1)\n        S = [0] * (self.__n + 1)\n        for i in range(1, self.__n + 1):\n            S[i] = S[i - 1] + A[i - 1]\n            self.__data[i] = A[i - 1]\n            self.__node[i] = S[i] - S[i - (i & (-i))]\n    def add(self, i, v):\n        self.__data[i] += v\n        while i <= self.__n:\n            self.__node[i] += v\n            i += i & (-i)\n    def sum(self, i):\n        rst = 0\n        while i > 0:\n            rst += self.__node[i]\n            i -= i & (-i)\n        return rst\n    def get(self, i, j):\n        if i == j:\n            return self.__data[i]\n        else:\n            return self.sum(j) - self.sum(i - 1)\ndef main():\n    (N, Q) = map(int, input().split())\n    C = list(map(int, input().split()))\n    P = [[] for _ in range(N)]\n    for (i, c) in enumerate(C):\n        P[c - 1].append(i)\n    right = [0] * N\n    for p in P:\n        if len(p):\n            right[p.pop()] = 1\n    BIT = BinaryIndexedTree(right)\n    query = [[] for _ in range(N)]\n    for (i, s) in enumerate(sys.stdin.readlines()):\n        (l, r) = map(int, s.split())\n        query[r - 1].append((l - 1, i))\n    ans = [None] * Q\n    cur = N - 1\n    for (r, q) in enumerate(reversed(query)):\n        r = (N - 1) - r\n        while q:\n            (l, i) = q.pop()\n            while r < cur:\n                c = C[cur] - 1\n                p = P[c]\n                if len(p):\n                    BIT.add(p.pop() + 1, 1)\n                cur -= 1\n            tmp = BIT.get(l + 1, r + 1)\n            ans[i] = tmp\n    print(sep='\\n', *ans)", "generated_code": "import sys\nclass BinaryIndexedTree:\n    def __init__(self, A):\n        self.__n = len(A)\n        self.__node = [0] * (self.__n + 1)\n        self.__data = [0] * (self.__n + 1)\n        S = [0] * (self.__n + 1)\n        for i in range(1, self.__n + 1):\n            S[i] = S[i - 1] + A[i - 1]\n            self.__data[i] = A[i - 1]\n            self.__node[i] = S[i] - S[i - (i & (-i))]\n    def add(self, i, v):\n        self.__data[i] += v\n        while i <= self.__n:\n            self.__node[i] += v\n            i += i & (-i)\n    def sum(self, i):\n        rst = 0\n        while i > 0:\n            rst += self.__node[i]\n            i -= i & (-i)\n        return rst\n    def get(self, i, j):\n        if i == j:\n            return self.__data[i]\n        else:\n            return self.sum(j) - self.sum(i - 1)\ndef main():\n    (N, Q) = map(int, input().split())\n    C = list(map(int, input().split()))\n    P = [[] for _ in range(N)]\n    for (i, c) in enumerate(C):\n        P[c - 1].append(i)\n    right = [0] * N\n    for p in P:\n        if len(p):\n            right[p.pop()] = 1\n    BIT = BinaryIndexedTree(right)\n    query = [[] for _ in range(N)]\n    for (i, s) in enumerate(sys.stdin.readlines()):\n        (l, r) = map(int, s.split())\n        query[r - 1].append((l - 1, i))\n    ans = [None] * Q\n    cur = N - 1\n    for (r, q) in enumerate(reversed(query)):\n        r = (N - 1) - r\n        while q:\n            (l, i) = q.pop()\n            while r < cur:\n                c = C[cur] - 1\n                p = P[c]\n                if len(p):\n                    BIT.add(p.pop() + 1, 1)\n                cur -= 1\n            tmp = BIT.get(l + 1, r + 1)\n            ans[i] = tmp\n    print(sep='\\n', *ans)", "score": 0.0346, "codebleu": 1.0, "crystalbleu": 1.0, "codebertscore": 1.0, "codescore": 0.9936497807502747, "surfaceSim": 1.0, "abs_surfaceSim_minus_score": 0.9654, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-4021_34", "golden_code": "n = int(input())\nres=[0, 1, 1, 1, 2, 1, 2, 1, 5, 2, 2, 1, 5, 1, 2, 1, 14, 1, 5, 1, 5, 2, 2, 1, 15, 2, 2, 5, 4, 1, 4, 1, 51, 1, 2, 1, 14, 1, 2, 2, 14, 1, 6, 1, 4, 2, 2, 1, 52, 2, 5, 1, 5, 1, 15, 2, 13, 2, 2, 1, 13, 1, 2, 4, 267, 1, 4, 1, 5, 1, 4, 1, 50, 1, 2, 3, 4, 1, 6, 1, 52, 15, 2, 1, 15, 1, 2, 1, 12, 1, 10, 1, 4, 2]\nprint(res[n])", "generated_code": "print(int(input()))\n", "score": 0.0564, "codebleu": 0.3214285714285714, "crystalbleu": 0.0, "codebertscore": 0.58, "codescore": 0.035810526460409164, "surfaceSim": 0.3874523679912901, "abs_surfaceSim_minus_score": 0.3310523679912901, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-1915_24", "golden_code": "n = int(input())\n\nmat = [[0] * n for x in range(n)]\n\nfor i in range(n):\n    mat[0][i] = 1\n    mat[i][0] = 1\n\n\nfor i in range(1, n):\n    for j in range(1, n):\n        mat[i][j] = mat[i - 1][j] + mat[i][j - 1]\n\nprint(mat[n - 1][n - 1])", "generated_code": "n = int(input())\n\nif n % 2 == 0:\n\tprint(sum(sum(range(1, n + 1, 2)) for i in range(n + 1)))\nelse:\n\tprint((n + 1) * sum(range(1, n + 1, -2)))\n", "score": 0.0506, "codebleu": 0.12458698194251376, "crystalbleu": 0.11, "codebertscore": 0.82, "codescore": 0.09512072801589966, "surfaceSim": 0.480343347639485, "abs_surfaceSim_minus_score": 0.429743347639485, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_160_35_MUT_55", "golden_code": "from math import sqrt\nfrom bisect import bisect_left\n\ndef main():\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    sum_a = sum(a)\n    st = set()\n    for v in range(1, int(sqrt(sum_a)) + 2):\n        if sum_a % v == 0:\n            st.add(v)\n            st.add(sum_a // v)\n    st.remove(1)\n    ans = 1\n    for target in st:\n        a_mod_t = [v % target for v in a]\n        a_mod_t.sort()\n        for i in range(n - 1):\n            a_mod_t[i + 1] += a_mod_t[i]\n        for i in range(n):\n            (sum_L, sum_R) = (a_mod_t[i], a_mod_t[-1] - a_mod_t[i])\n            (len_L, len_R) = (i + 1, (n - i) - 1)\n            if sum_L == (target * len_R) - sum_R:\n                if sum_L <= k:\n                    if ans < target:\n                        ans = target\n    print(ans)\n\ndef __starting_point():\n    main()\n__starting_point()", "generated_code": "from math import sqrt\nfrom bisect import bisect_left\n\ndef main():\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    sum_a = sum(a)\n    st = set()\n    for v in range(1, int(sqrt(sum_a)) + 2):\n        if sum_a % v == 0:\n            st.add(v)\n            st.add(sum_a // v)\n    st.remove(1)\n    ans = 1\n    for target in st:\n        a_mod_t = [v % target for v in a]\n        a_mod_t.sort()\n        for i in range(n - 1):\n            a_mod_t[i + 1] += a_mod_t[i]\n        for i in range(n):\n            (sum_L, sum_R) = (a_mod_t[i], a_mod_t[-1] - a_mod_t[i])\n            (len_L, len_R) = (i + 1, (n - i) - 1)\n            if sum_L == (target * len_R) - sum_R:\n                if sum_L <= k:\n                    if ans < target:\n                        ans = target\n    print(ans)\n\ndef __starting_point():\n    pass\n__starting_point()", "score": 0.0, "codebleu": 0.8393382057588759, "crystalbleu": 0.97, "codebertscore": 1.0, "codescore": 0.9937798380851746, "surfaceSim": 0.9823905171824827, "abs_surfaceSim_minus_score": 0.9823905171824827, "source": "local", "local_type": "MUT"}
{"id": "MBPP_20_11", "golden_code": "def is_odd(n) : \r\n    if (n^1 == n-1) :\r\n        return True; \r\n    else :\r\n        return False; ", "generated_code": "def is_odd(n):\n\tif n < 10:\n\t\treturn True   \n\tfor i in str(n):\n\t\tif int(i) % 2!=0:\n\t\t\treturn  False\n\treturn True", "score": 0.3439, "codebleu": 0.34873962066063074, "crystalbleu": 0, "codebertscore": 0.81, "codescore": 0.4575198292732239, "surfaceSim": 0.5677927927927928, "abs_surfaceSim_minus_score": 0.22389279279279284, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_70_30", "golden_code": "def is_abundant(n):\r\n    fctrsum = sum([fctr for fctr in range(1, n) if n % fctr == 0])\r\n    return fctrsum > n", "generated_code": "def is_abundant(n): return n >= 0", "score": 0.3557, "codebleu": 0.06235683768046423, "crystalbleu": 0, "codebertscore": 0.81, "codescore": 0.3251107335090637, "surfaceSim": 0.47107633949739214, "abs_surfaceSim_minus_score": 0.11537633949739212, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_extra_p02264_s571730090_OP_1", "golden_code": "n,q = list(map(int,input().split()))\n\nqueue = []\n\nfor i in range(n):\n\n\tname,time = input().split()\n\n\tqueue.append([name, int(time)])\n\n\n\nt = 0\n\ni = 0\n\nwhile queue:\n\n\ti %= len(queue)\n\n\tp = queue[i]\n\n\tt += min(q, p[1])\n\n\tif p[1] > q:\n\n\t\tp[1] -= q\n\n\t\ti += 1\n\n\telse:\n\n\t\tprint((p[0], t))\n\n\t\tqueue.pop(i)\n", "generated_code": "from collections import deque\n\n\n\nn,q = list(map(int,input().split()))\n\nqueue = deque()\n\nfor i in range(n):\n\n\tname,time = input().split()\n\n\tqueue.append((name, int(time)))\n\n\n\nt = 0\n\nwhile queue:\n\n\tname,time = queue.popleft()\n\n\tt += min(q, time)\n\n\tif time > q:\n\n\t\tqueue.append((name, time-q))\n\n\telse:\n\n\t\tprint((name,t))\n", "score": 1.0, "codebleu": 0.3592226858178984, "crystalbleu": 0.49, "codebertscore": 0.89, "codescore": 0.24770700931549072, "surfaceSim": 0.6870440251572327, "abs_surfaceSim_minus_score": 0.31295597484276727, "source": "local", "local_type": "OP"}
{"id": "LOCAL_APPS_4169_75_MUT_32", "golden_code": "import bisect, collections, copy, heapq, itertools, math, string, sys\ninput = lambda: (sys.stdin.readline().rstrip())\nsys.setrecursionlimit(10 ** 7)\nINF = float('inf')\ndef I():\n    return int(input())\ndef F():\n    return float(input())\ndef SS():\n    return input()\ndef LI():\n    return [int(x) for x in input().split()]\ndef LI_():\n    return [int(x) - 1 for x in input().split()]\ndef LF():\n    return [float(x) for x in input().split()]\ndef LSS():\n    return input().split()\ndef resolve():\n    (N, M) = LI()\n    AB = [LI() for _ in range(N)]\n    AB.sort()\n    ans = 0\n    for (a, b) in AB:\n        if M >= b:\n            M -= b\n            ans += a * belse:ans += a * Mbreak\n    print(ans)\ndef __starting_point():\n    resolve()\n\n__starting_point()", "generated_code": "import bisect, collections, copy, heapq, itertools, math, string, sys\ninput = lambda: (sys.stdin.readline().rstrip())\nsys.setrecursionlimit(10 ** 7)\nINF = float('inf')\ndef I():\n    return int(input())\ndef F():\n    return float(input())\ndef SS():\n    return input()\ndef LI():\n    return [int(x) for x in input().split()]\ndef LI_():\n    return [int(x) - 1 for x in input().split()]\ndef LF():\n    return [float(x) for x in input().split()]\ndef LSS():\n    return input().split()\ndef resolve():\n    pass\n    AB = [LI() for _ in range(N)]\n    AB.sort()\n    ans = 0\n    for (a, b) in AB:\n        if M >= b:\n            M -= b\n            ans += a * belse:ans += a * Mbreak\n    print(ans)\ndef __starting_point():\n    resolve()\n\n__starting_point()", "score": 0.0, "codebleu": 0.8909582200541584, "crystalbleu": 0.95, "codebertscore": 0.99, "codescore": 0.9938670992851257, "surfaceSim": 0.49330655957161984, "abs_surfaceSim_minus_score": 0.49330655957161984, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_PIE_p02537_s767194684_MUT_134", "golden_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "generated_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    pass\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "score": 0.0, "codebleu": 0.9713652555258335, "crystalbleu": 0.96, "codebertscore": 0.98, "codescore": 0.9867614507675171, "surfaceSim": 0.9795636023651892, "abs_surfaceSim_minus_score": 0.9795636023651892, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_PIE_extra_p02612_s840955881_OP_1", "golden_code": "import sys\n\n\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\nN = int(read())\n\nx = N + (-N) % 1000\n\nprint((x - N))", "generated_code": "import math\n\nN = int(eval(input()))\n\nx = math.ceil(N/1000) * 1000\n\nprint((x-N))", "score": 1.0, "codebleu": 0.19194245636732254, "crystalbleu": 0, "codebertscore": 0.79, "codescore": 0.37696272134780884, "surfaceSim": 0.5324461722488039, "abs_surfaceSim_minus_score": 0.46755382775119614, "source": "local", "local_type": "OP"}
{"id": "LOCAL_APPS_4638_24_MUT_9", "golden_code": "(n, c) = [int(x) for x in input().split()]\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\ndpst = [0] * (n + 1)\ndplift = [0] * (n + 1)\ndpst[2] = a[0]\ndplift[2] = c + b[0]\nfor i in range(3, n + 1):\n    dpst[i] = a[i - 2] + min(dpst[i - 1], dplift[i - 1])\n    dplift[i] = b[i - 2] + min(c + dpst[i - 1], dplift[i - 1])\n\nfor i in range(1, n + 1):\n    print(min(dpst[i], dplift[i]), end=' ')", "generated_code": "(n, c) = [int(x) for x in input().split()]\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\ndpst = [0] * (n + 1)\ndplift = [0] * (n + 1)\ndpst[2] = a[0]\ndplift[2] = c - b[0]\nfor i in range(3, n + 1):\n    dpst[i] = a[i - 2] + min(dpst[i - 1], dplift[i - 1])\n    dplift[i] = b[i - 2] + min(c + dpst[i - 1], dplift[i - 1])\n\nfor i in range(1, n + 1):\n    print(min(dpst[i], dplift[i]), end=' ')", "score": 0.2287, "codebleu": 0.9844886434075966, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9937653541564941, "surfaceSim": 0.9987834549878345, "abs_surfaceSim_minus_score": 0.7700834549878345, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_HE_20_MUT_3", "golden_code": "import os\n\nfrom typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[(float, float)]:\n    closest_pair = None\n    distance = None\n    \n    for (idx, elem) in enumerate(numbers):\n        for (idx2, elem2) in enumerate(numbers):\n            if idx != idx2:\n                if distance is None:\n                    distance = abs(elem - elem2)\n                    closest_pair = tuple(sorted([elem, elem2]))\n                else:\n                    new_distance = abs(elem - elem2)\n                    if new_distance < distance:\n                        distance = new_distance\n                        closest_pair = tuple(sorted([elem, elem2]))\n    \n    return closest_pair", "generated_code": "import os\n\nfrom typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[(float, float)]:\n    closest_pair = None\n    distance = None\n    \n    for (idx, elem) in enumerate(numbers):\n        for (idx2, elem2) in enumerate(numbers):\n            if not (idx != idx2):\n                if distance is None:\n                    distance = abs(elem - elem2)\n                    closest_pair = tuple(sorted([elem, elem2]))\n                else:\n                    new_distance = abs(elem - elem2)\n                    if new_distance < distance:\n                        distance = new_distance\n                        closest_pair = tuple(sorted([elem, elem2]))\n    \n    return closest_pair", "score": 0.2624, "codebleu": 0.9356563136549716, "crystalbleu": 0.93, "codebertscore": 1.0, "codescore": 0.9938148260116577, "surfaceSim": 0.9607645875251509, "abs_surfaceSim_minus_score": 0.698364587525151, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_PIE_extra_p03696_s490534414_OP_1", "golden_code": "# -*- coding: utf-8 -*-\n\n\n\nimport sys\n\ndef input(): return sys.stdin.readline().strip()\n\nsys.setrecursionlimit(10 ** 9)\n\n\n\nfrom collections import deque\n\n\n\nN = int(eval(input()))\n\nS = eval(input())\n\n\n\nans = deque()\n\ntmp = ''\n\nl = r = 0\n\nfor c in S:\n\n    if c == '(':\n\n        l += 1\n\n        tmp += '('\n\n    else:\n\n        if l == 0:\n\n            ans.appendleft('(')\n\n            ans.append(')')\n\n        else:\n\n            r += 1\n\n            tmp += ')'\n\n            if l == r:\n\n                ans.append(tmp)\n\n                tmp = ''\n\n                l = r = 0\n\nif l > r:\n\n    tmp += ')' * (l-r)\n\n    ans.append(tmp)\n\nprint((''.join(ans)))\n", "generated_code": "# -*- coding: utf-8 -*-\n\n\n\nimport sys\n\n\n\ndef input(): return sys.stdin.readline().strip()\n\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\n\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\n\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\n\ndef ceil(x, y=1): return int(-(-x // y))\n\ndef INT(): return int(eval(input()))\n\ndef MAP(): return list(map(int, input().split()))\n\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\n\ndef Yes(): print('Yes')\n\ndef No(): print('No')\n\ndef YES(): print('YES')\n\ndef NO(): print('NO')\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = 10 ** 18\n\nMOD = 10 ** 9 + 7\n\n\n\nN = INT()\n\nS = eval(input())\n\n\n\n# それぞれ必要な数を確認\n\nlneed = cnt = 0\n\nfor s in S:\n\n    if s == ')':\n\n        cnt += 1\n\n        lneed = max(lneed, cnt)\n\n    else:\n\n        cnt -= 1\n\nrneed = cnt = 0\n\nfor s in S[::-1]:\n\n    if s == '(':\n\n        cnt += 1\n\n        rneed = max(rneed, cnt)\n\n    else:\n\n        cnt -= 1\n\n\n\n# 辞書順最小なので、(は全部左に、)は全部右に付ける\n\nans = ('(' * lneed) + S + (')' * rneed)\n\nprint(ans)\n", "score": 1.0, "codebleu": 0.3311085989774717, "crystalbleu": 0.15, "codebertscore": 0.74, "codescore": 0.11597592383623123, "surfaceSim": 0.5613815450327713, "abs_surfaceSim_minus_score": 0.43861845496722873, "source": "local", "local_type": "OP"}
{"id": "LOCAL_APPS_47_12_MUT_26", "golden_code": "(n, x) = map(int, input().split())\nA = list(map(int, input().split()))\nDP = [[0] * 3 for _ in range(n + 1)]\nans = 0\nfor i in range(1, n + 1):\n    DP[i][0] = max(DP[i - 1][0] + A[i - 1], A[i - 1])\n    DP[i][1] = max(DP[i - 1][0] + (A[i - 1] * x), DP[i - 1][1] + (A[i - 1] * x), A[i - 1] * x)\n    DP[i][2] = max(DP[i - 1][1] + A[i - 1], DP[i - 1][2] + A[i - 1], A[i - 1])\n    ans = max(ans, max(DP[i]))\nprint(ans)", "generated_code": "(n, x) = map(int, input().split())\nA = list(map(int, input().split()))\nDP = [[0] * 3 for _ in range(n + 1)]\nans = 0\nfor i in range(1, n + 1):\n    DP[i][0] = max(DP[i - 1][0] + A[i - 1], A[i - 1])\n    DP[i][1] = max(DP[i - 1][0] + (A[i - 1] * x), DP[i - 1][1] + (A[i - 1] * x), A[i - 1] * x)\n    DP[i][2] = max(DP[i + 1][1] + A[i - 1], DP[i - 1][2] + A[i - 1], A[i - 1])\n    ans = max(ans, max(DP[i]))\nprint(ans)", "score": 0.0, "codebleu": 0.9860116946342178, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9938496947288513, "surfaceSim": 0.9987834549878345, "abs_surfaceSim_minus_score": 0.9987834549878345, "source": "local", "local_type": "MUT"}
{"id": "MBPP_68_2", "golden_code": "def subset(ar, n): \r\n    res = 0\r\n    ar.sort() \r\n    for i in range(0, n) : \r\n        count = 1\r\n        for i in range(n - 1): \r\n            if ar[i] == ar[i + 1]: \r\n                count+=1\r\n            else: \r\n                break \r\n        res = max(res, count)  \r\n    return res ", "generated_code": "def subset(ar, n): \n\treturn n and sum(ar[n:]) or 0", "score": 0.0, "codebleu": 0.06399175181958022, "crystalbleu": 0, "codebertscore": 0.7, "codescore": 0.0788705050945282, "surfaceSim": 0.48451548451548454, "abs_surfaceSim_minus_score": 0.48451548451548454, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_34_92", "golden_code": "def even_num(x):\r\n  if x%2==0:\r\n     return True\r\n  else:\r\n    return False", "generated_code": "def even_num(x):    \n\tcount = 0\n\twhile x > 1:\n\t\tcount += x % 2\n\t\tx //= 2\n\treturn count", "score": 0.3283, "codebleu": 0.311654825618745, "crystalbleu": 0, "codebertscore": 0.8, "codescore": 0.1498023122549057, "surfaceSim": 0.5715116279069767, "abs_surfaceSim_minus_score": 0.24321162790697676, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0671_21", "golden_code": "n = int(input())\ns = \"\"\ni = 1\nwhile (len(s) < n):\n    k = str(i)\n    for j in range(len(k)):\n        s += k[j]\n    i += 1\nprint(s[n - 1])\n", "generated_code": "# cook your dish here\ntry:\n\tn = int(input())\n\tprint(int(str(n)[-1]))\nexcept:\n\tpass\n", "score": 0.1476, "codebleu": 0.13306882292565195, "crystalbleu": 0, "codebertscore": 0.74, "codescore": 0.12542937695980072, "surfaceSim": 0.4528985507246377, "abs_surfaceSim_minus_score": 0.3052985507246377, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_71_20", "golden_code": "import math\r\ndef get_First_Set_Bit_Pos(n):\r\n     return math.log2(n&-n)+1", "generated_code": "import math\ndef get_First_Set_Bit_Pos(n1):\n\t return (n1 & 1) + ((n1 >> 1) == 1)", "score": 0.439, "codebleu": 0.23501071235278911, "crystalbleu": 0, "codebertscore": 0.87, "codescore": 0.16811829805374146, "surfaceSim": 0.7174050632911393, "abs_surfaceSim_minus_score": 0.2784050632911393, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_20_15", "golden_code": "def is_odd(n) : \r\n    if (n^1 == n-1) :\r\n        return True; \r\n    else :\r\n        return False; ", "generated_code": "def is_odd(n):    return n % 4 == 1", "score": 0.711, "codebleu": 0.22976441383200974, "crystalbleu": 0, "codebertscore": 0.83, "codescore": 0.7064863443374634, "surfaceSim": 0.6727891156462584, "abs_surfaceSim_minus_score": 0.03821088435374154, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_p02599_s870922238_MUT_112", "golden_code": "import sys\nclass BinaryIndexedTree:\n    def __init__(self, A):\n        self.__n = len(A)\n        self.__node = [0] * (self.__n + 1)\n        self.__data = [0] * (self.__n + 1)\n        S = [0] * (self.__n + 1)\n        for i in range(1, self.__n + 1):\n            S[i] = S[i - 1] + A[i - 1]\n            self.__data[i] = A[i - 1]\n            self.__node[i] = S[i] - S[i - (i & (-i))]\n    def add(self, i, v):\n        self.__data[i] += v\n        while i <= self.__n:\n            self.__node[i] += v\n            i += i & (-i)\n    def sum(self, i):\n        rst = 0\n        while i > 0:\n            rst += self.__node[i]\n            i -= i & (-i)\n        return rst\n    def get(self, i, j):\n        if i == j:\n            return self.__data[i]\n        else:\n            return self.sum(j) - self.sum(i - 1)\ndef main():\n    (N, Q) = map(int, input().split())\n    C = list(map(int, input().split()))\n    P = [[] for _ in range(N)]\n    for (i, c) in enumerate(C):\n        P[c - 1].append(i)\n    right = [0] * N\n    for p in P:\n        if len(p):\n            right[p.pop()] = 1\n    BIT = BinaryIndexedTree(right)\n    query = [[] for _ in range(N)]\n    for (i, s) in enumerate(sys.stdin.readlines()):\n        (l, r) = map(int, s.split())\n        query[r - 1].append((l - 1, i))\n    ans = [None] * Q\n    cur = N - 1\n    for (r, q) in enumerate(reversed(query)):\n        r = (N - 1) - r\n        while q:\n            (l, i) = q.pop()\n            while r < cur:\n                c = C[cur] - 1\n                p = P[c]\n                if len(p):\n                    BIT.add(p.pop() + 1, 1)\n                cur -= 1\n            tmp = BIT.get(l + 1, r + 1)\n            ans[i] = tmp\n    print(sep='\\n', *ans)", "generated_code": "import sys\nclass BinaryIndexedTree:\n    def __init__(self, A):\n        self.__n = len(A)\n        self.__node = [0] * (self.__n + 1)\n        self.__data = [0] * (self.__n + 1)\n        S = [0] * (self.__n + 1)\n        for i in range(1, self.__n + 1):\n            S[i] = S[i - 1] + A[i - 1]\n            self.__data[i] = A[i - 1]\n            self.__node[i] = S[i] - S[i - (i & (-i))]\n    def add(self, i, v):\n        self.__data[i] += v\n        while i <= self.__n:\n            self.__node[i] += v\n            i += i & (-i)\n    def sum(self, i):\n        rst = 0\n        while i > 0:\n            rst += self.__node[i]\n            i -= i & (-i)\n        return rst\n    def get(self, i, j):\n        if i == j:\n            return self.__data[i]\n        else:\n            return self.sum(j) - self.sum(i - 1)\ndef main():\n    (N, Q) = map(int, input().split())\n    C = list(map(int, input().split()))\n    P = [[] for _ in range(N)]\n    for (i, c) in enumerate(C):\n        P[c - 1].append(i)\n    right = [0] * N\n    for p in P:\n        if len(p):\n            right[p.pop()] = 1\n    pass\n    query = [[] for _ in range(N)]\n    for (i, s) in enumerate(sys.stdin.readlines()):\n        (l, r) = map(int, s.split())\n        query[r - 1].append((l - 1, i))\n    ans = [None] * Q\n    cur = N - 1\n    for (r, q) in enumerate(reversed(query)):\n        r = (N - 1) - r\n        while q:\n            (l, i) = q.pop()\n            while r < cur:\n                c = C[cur] - 1\n                p = P[c]\n                if len(p):\n                    BIT.add(p.pop() + 1, 1)\n                cur -= 1\n            tmp = BIT.get(l + 1, r + 1)\n            ans[i] = tmp\n    print(sep='\\n', *ans)", "score": 0.0398, "codebleu": 0.8248267842588408, "crystalbleu": 0.98, "codebertscore": 0.99, "codescore": 0.9936983585357666, "surfaceSim": 0.97980250697587, "abs_surfaceSim_minus_score": 0.94000250697587, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-1298_53", "golden_code": "n = int(input())\na = input()\nkol1 = 0\nkol0 = 0\nfor i in range(len(a)):\n    if a[i] == \"1\":\n        kol1 += 1\n    else:\n        kol0 += 1\nprint(abs(kol1 - kol0))\n", "generated_code": "import sys\n\ndef main():\n\tn = int(sys.stdin.readline())\n\ts = sys.stdin. readline().strip()\n\tx, y = 0, 0\n\tfor i in range(n):\n\t\tif s[i] == '0':\n\t\t\tx += 1\n\t\telse:\n\t\t\ty += 1\n\tprint(max(min(x, y), n - min(x, y)))\n\ndef __starting_point():\n\tmain()\n\n__starting_point()\n", "score": 0.0138, "codebleu": 0.25544606198909287, "crystalbleu": 0, "codebertscore": 0.78, "codescore": 0.12984788417816162, "surfaceSim": 0.5826923076923076, "abs_surfaceSim_minus_score": 0.5688923076923076, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-4186_23", "golden_code": "n = int(input())\nmass = list(map(int, input().split()))\nmass.sort()\ncnt = 0\nfor i in range(0, n, 2):\n    cnt += mass[i+1] - mass[i]\nprint(cnt)", "generated_code": "def main():\n\tn = int(input())\n\ta = list(map(int, input().split()))\n\ta.sort()\n\tbraccum = 0\n\tcnt = 0\n\tfor i in range(n // 2):\n\t\tif a[i] == a[n - 1 - i]:\n\t\t\tcnt += 1\n\t\telse:\n\t\t\tbraccum += cnt\n\t\t\tcnt = 0\n\n\tif braccum:\n\t\tbraccum += 1\n\tprint(braccum)\n\n\ndef __starting_point():\n\tmain()\n\n__starting_point()\n", "score": 0.4054, "codebleu": 0.38748691520237116, "crystalbleu": 0, "codebertscore": 0.84, "codescore": 0.09895196557044983, "surfaceSim": 0.6194892064457282, "abs_surfaceSim_minus_score": 0.21408920644572826, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_1387_9_MUT_8", "golden_code": "import sys\n\nnums = [int(x) for x in sys.stdin.readline().split(' ')]\na = [int(x) for x in sys.stdin.readline().split(' ')]\n\nt = nums[1]\n\ncurr = 1\nwhile curr < t:\n    curr += a[curr - 1]\nif curr == t:\n    print('YES')\nelse:\n    print('NO')", "generated_code": "import sys\n\nnums = [int(x) for x in sys.stdin.readline().split(' ')]\na = [int(x) for x in sys.stdin.readline().split(' ')]\n\nt = nums[1]\n\ncurr = 1\nwhile curr > t:\n    curr += a[curr - 1]\nif curr == t:\n    print('YES')\nelse:\n    print('NO')", "score": 0.0413, "codebleu": 0.9674392074581819, "crystalbleu": 0.94, "codebertscore": 1.0, "codescore": 0.9937602877616882, "surfaceSim": 0.9578991596638655, "abs_surfaceSim_minus_score": 0.9165991596638655, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_APPS_170_0_MUT_10", "golden_code": "n = int(input())\nk1 = list(map(int, input().split()[1:]))\nk2 = list(map(int, input().split()[1:]))\n\ni = 0\nwhile True:\n    if (len(k1) == 0 or len(k2) == 0):\n        break\n    if i > 10000:\n        break\n    if k1[0] > k2[0]:\n        k1 = (k1[1:] + k2[0:1]) + k1[0:1]\n        k2 = k2[1:]\n    else:\n        k2 = (k2[1:] + k1[0:1]) + k2[0:1]\n        k1 = k1[1:]\n    i += 1\n\nif i > 10000:\n    print(-1)\nelse:\n    winner = 1\n    if len(k1) == 0:\n        winner = 2\n    print(i, winner)", "generated_code": "n = int(input())\nk1 = list(map(int, input().split()[1:]))\nk2 = list(map(int, input().split()[1:]))\n\ni = 0\nwhile not True:\n    if (len(k1) == 0 or len(k2) == 0):\n        break\n    if i > 10000:\n        break\n    if k1[0] > k2[0]:\n        k1 = (k1[1:] + k2[0:1]) + k1[0:1]\n        k2 = k2[1:]\n    else:\n        k2 = (k2[1:] + k1[0:1]) + k2[0:1]\n        k1 = k1[1:]\n    i += 1\n\nif i > 10000:\n    print(-1)\nelse:\n    winner = 1\n    if len(k1) == 0:\n        winner = 2\n    print(i, winner)", "score": 0.0, "codebleu": 0.9820496446348989, "crystalbleu": 0.97, "codebertscore": 1.0, "codescore": 0.9936605095863342, "surfaceSim": 0.9776700572155117, "abs_surfaceSim_minus_score": 0.9776700572155117, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_MBPP_403_OP_1", "golden_code": "import re\r\ndef is_valid_URL(str):\r\n\tregex = (\"((http|https)://)(www.)?\" +\r\n\t\t\t\"[a-zA-Z0-9@:%._\\\\+~#?&//=]\" +\r\n\t\t\t\"{2,256}\\\\.[a-z]\" +\r\n\t\t\t\"{2,6}\\\\b([-a-zA-Z0-9@:%\" +\r\n\t\t\t\"._\\\\+~#?&//=]*)\")\r\n\tp = re.compile(regex)\r\n\tif (str == None):\r\n\t\treturn False\r\n\tif(re.search(p, str)):\r\n\t\treturn True\r\n\telse:\r\n\t\treturn False", "generated_code": "import re\n\ndef is_valid_URL(url_str):\n    if url_str is None:\n        return False\n    pattern = re.compile(r\"^(https?://)?(www\\.)?[\\w@:%._\\+~#?&//=]{2,256}\\.[a-z]{2,6}\\b([-\\w@:%._\\+~#?&//=]*)$\")\n    return bool(pattern.match(url_str))\n", "score": 1.0, "codebleu": 0.2070276353286161, "crystalbleu": 0, "codebertscore": 0.84, "codescore": 0.9938628673553467, "surfaceSim": 0.6234726688102894, "abs_surfaceSim_minus_score": 0.3765273311897106, "source": "local", "local_type": "OP"}
{"id": "MBPP_31_5", "golden_code": "def smallest_multiple(n):\r\n    if (n<=2):\r\n      return n\r\n    i = n * 2\r\n    factors = [number  for number in range(n, 1, -1) if number * 2 > n]\r\n    while True:\r\n        for a in factors:\r\n            if i % a != 0:\r\n                i += n\r\n                break\r\n            if (a == factors[-1] and i % a == 0):\r\n                return i", "generated_code": "def smallest_multiple(n):\n\n\treturn (1 << n) - 1", "score": 0.1576, "codebleu": 0.02668022746029069, "crystalbleu": 0, "codebertscore": 0.71, "codescore": 0.11467930674552917, "surfaceSim": 0.41009635525764554, "abs_surfaceSim_minus_score": 0.2524963552576456, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_MBPP_541_MUT_21", "golden_code": "import os\n\nimport math\ndef get_sum(n):\n    sum = 0\n    i = 1\n    while i <= math.sqrt(n):\n        if n % i == 0:\n            if n / i == i:\n                sum = sum + i\n            else:\n                sum = sum + i\n                sum = sum + (n / i)\n        i = i + 1\n    sum = sum - n\n    return sum\ndef check_abundant(n):\n    if get_sum(n) > n:\n        return True\n    else:\n        return False", "generated_code": "import os\n\nimport math\ndef get_sum(n):\n    sum = 0\n    i = 1\n    while i <= math.sqrt(n):\n        if n % i == 0:\n            if n / i != i:\n                sum = sum + i\n            else:\n                sum = sum + i\n                sum = sum + (n / i)\n        i = i + 1\n    sum = sum - n\n    return sum\ndef check_abundant(n):\n    if get_sum(n) > n:\n        return True\n    else:\n        return False", "score": 0.0575, "codebleu": 0.9816417084551853, "crystalbleu": 0.95, "codebertscore": 1.0, "codescore": 0.9937008619308472, "surfaceSim": 0.9795223479762134, "abs_surfaceSim_minus_score": 0.9220223479762134, "source": "local", "local_type": "MUT"}
{"id": "MBPP_33_39", "golden_code": "def count_Unset_Bits(n) :  \r\n    cnt = 0;  \r\n    for i in range(1,n + 1) : \r\n        temp = i;  \r\n        while (temp) :  \r\n            if (temp % 2 == 0) : \r\n                cnt += 1;  \r\n            temp = temp // 2;  \r\n    return cnt;  ", "generated_code": "def count_Unset_Bits(num):\n\treturn num > 2**31 - 1", "score": 0.1389, "codebleu": 0.03930424546870198, "crystalbleu": 0, "codebertscore": 0.71, "codescore": 0.12070900946855545, "surfaceSim": 0.5192577030812325, "abs_surfaceSim_minus_score": 0.3803577030812325, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-1043_46", "golden_code": "from heapq import heappush, heappop\nN = int(input())\nA = [int(a) for a in input().split()]\nfor i in range(N):\n    if A[i] < 0:\n        k = i\n        break\nA = [0] + [0 if i < k else A[i] for i in range(N) if i != k]\n\nans = A.pop()\nH = []\nwhile N > 2:\n    N //= 2\n    for i in range(N):\n        heappush(H, A.pop())\n    ans += heappop(H)\n\nprint(ans)\n\n\n", "generated_code": "n = int(input())\na = list(map(int, input().split()))\n\nans = 0\nfor i in range(n // 2):\n\tif a[i]!= -1:\n\t\ta[i] = a[i] * 2\n\telse:\n\t\ta[\"i\"] = a[i], -1\n\tj = n - 1\n\tval = 0\n\twhile j >= i:\n\t\tval += a[j]\n\t\tj -= 1\n\ta[i] += val\n\tans += a[i]\n\tif a [i] < 0:\n\t\ta [i] = -1\n\nprint(ans)\n", "score": 0.0, "codebleu": 0.17980974976249167, "crystalbleu": 0.19, "codebertscore": 0.79, "codescore": 0.12575401365756989, "surfaceSim": 0.554985754985755, "abs_surfaceSim_minus_score": 0.554985754985755, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_extra_p03000_s259788442_OP_1", "golden_code": "from itertools import accumulate\n\nfrom bisect import *\n\nN, X = list(map(int, input().split()))\n\nL = list(tuple(map(int, input().split())))\n\n\n\nacc = sorted(list(accumulate(L)) + [0])\n\n\n\nn = bisect_right(acc,X)\n\nprint(n)\n\n\n", "generated_code": "N,X = list(map(int,input().split()))\n\nL = list(map(int,input().split()))\n\nList = [0]*(N+1)\n\nfor i in range(1,N+1):\n\n    List[i] = List[i-1] + L[i-1]\n\nA = [i for i in List if i <=X]\n\nprint((len(A)))", "score": 1.0, "codebleu": 0.276255783709697, "crystalbleu": 0.16, "codebertscore": 0.77, "codescore": 0.11587947607040405, "surfaceSim": 0.4789781297134238, "abs_surfaceSim_minus_score": 0.5210218702865762, "source": "local", "local_type": "OP"}
{"id": "LOCAL_APPS_401_13_OP_1", "golden_code": "n, m = list(map(int, input().split()))\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nf = True\nfor i in range(1, 10):\n    if i in a and i in b:\n        print(i)\n        f = False\n        break\nif f:\n    print(str(min(min(a), min(b))) + str(max(min(a), min(b))))", "generated_code": "x, y = map(int, input().split())\nlist_a = set(map(int, input().split()))\nlist_b = set(map(int, input().split()))\ncommon_elements = list_a.intersection(list_b)\nif common_elements:\n    print(min(common_elements))\nelse:\n    print(str(min(min(list_a), min(list_b))) + str(max(min(list_a), min(list_b))))", "score": 1.0, "codebleu": 0.3142579563259703, "crystalbleu": 0.23, "codebertscore": 0.85, "codescore": 0.6151053309440613, "surfaceSim": 0.6218095405738426, "abs_surfaceSim_minus_score": 0.37819045942615737, "source": "local", "local_type": "OP"}
{"id": "APPS_test-2708_31", "golden_code": "n,k=[int(x) for x in input().split()]\r\nfor i in range(k):\r\n    if(n%10==0):\r\n    \tn=n//10\r\n    else:\r\n    \tn=n-1\r\n    \r\nprint(n)", "generated_code": "# cook your dish here\nn,k=list(map(int,input().split()))\nfor _ in range(k):\n\tn=str(n)\n\tif len(n)==1:\n\t\tprint(0)\n\telse:\n\t\ttry:\n\t\t\tprint(int(n[-1])-int(n[:-1])+1)\n\t\texcept:\n\t\t\tprint('1')\n", "score": 0.0, "codebleu": 0.17652384717856015, "crystalbleu": 0, "codebertscore": 0.81, "codescore": 0.05666101351380348, "surfaceSim": 0.5722007722007721, "abs_surfaceSim_minus_score": 0.5722007722007721, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-1195_42", "golden_code": "#Bhargey Mehta (Sophomore)\n#DA-IICT, Gandhinagar\nimport sys, math, queue\nsys.setrecursionlimit(1000000)\n#sys.stdin = open(\"input.txt\", \"r\")\n\nn = int(input())\na = list(map(int, input().split()))\nprint((a[2]^min(a))+2)", "generated_code": "n=int(input())\na=list(map(int,input().split()))\na.sort()\nprint(a[0]%((10**9)+7))\n", "score": 0.0024, "codebleu": 0.2510989010989011, "crystalbleu": 0, "codebertscore": 0.74, "codescore": 0.04238246753811836, "surfaceSim": 0.6921296296296295, "abs_surfaceSim_minus_score": 0.6897296296296296, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_extra_p03723_s632911465_OP_1", "golden_code": "import time\n\nt=time.time()\n\nA,B,C=list(map(int,input().split()))\n\ncnt=0\n\nwhile(A%2==B%2==C%2==0):\n\n    a,b,c=A,B,C\n\n    A=b//2+c//2;B=a//2+c//2;C=a//2+b//2\n\n    cnt+=1\n\n    if(time.time()-t>=1):\n\n        print((-1))\n\n        exit()\n\nprint(cnt)", "generated_code": "A,B,C=list(map(int,input().split()))\n\ncnt=0\n\nif(A==B==C):\n\n    if A%2!=0:\n\n        print((0))\n\n    else:\n\n        print((-1))\n\n    exit()\n\nwhile(A%2==B%2==C%2==0):\n\n    a,b,c=A,B,C\n\n    A=b//2+c//2;B=a//2+c//2;C=a//2+b//2\n\n    cnt+=1\n\nprint(cnt)", "score": 1.0, "codebleu": 0.3912606699000731, "crystalbleu": 0.73, "codebertscore": 0.91, "codescore": 0.5067775845527649, "surfaceSim": 0.6630298273155416, "abs_surfaceSim_minus_score": 0.3369701726844584, "source": "local", "local_type": "OP"}
{"id": "MBPP_377_1", "golden_code": "def pos_count(list):\r\n  pos_count= 0\r\n  for num in list: \r\n    if num >= 0: \r\n      pos_count += 1\r\n  return pos_count ", "generated_code": "def pos_count(i): \n\treturn '\\n'.join(map(str, i))", "score": 0.0, "codebleu": 0.07907200837292962, "crystalbleu": 0, "codebertscore": 0.76, "codescore": 0.018281882628798485, "surfaceSim": 0.4869281045751634, "abs_surfaceSim_minus_score": 0.4869281045751634, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_40_22", "golden_code": "import datetime\r\ndef check_date(m, d, y):\r\n    try:\r\n        m, d, y = map(int, (m, d, y))\r\n        datetime.date(y, m, d)\r\n        return True\r\n    except ValueError:\r\n        return False", "generated_code": "import datetime\ndef check_date(m, d, y):\n\tif m and d and y and m and d:\n\t\treturn True\n\telse:\n\t\ty, m, d = m, d, m\n\treturn False", "score": 0.224, "codebleu": 0.2960862078868875, "crystalbleu": 0, "codebertscore": 0.84, "codescore": 0.38868090510368347, "surfaceSim": 0.6666666666666667, "abs_surfaceSim_minus_score": 0.44266666666666676, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_34_40", "golden_code": "def even_num(x):\r\n  if x%2==0:\r\n     return True\r\n  else:\r\n    return False", "generated_code": "def even_num(x): return x % 2 is 0", "score": 1.0, "codebleu": 0.34087243935380335, "crystalbleu": 0, "codebertscore": 0.81, "codescore": 0.9935469031333923, "surfaceSim": 0.6795238095238094, "abs_surfaceSim_minus_score": 0.3204761904761906, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_p03553_s305170925_MUT_2", "golden_code": "import math, string, itertools, fractions, heapq, collections, re, array, bisect, sys, random, time, copy, functools\nsys.setrecursionlimit(10 ** 7)\ninf = 10 ** 20\neps = 1.0 / (10 ** 15)\nmod = (10 ** 9) + 7\ndef LI():\n    return [int(x) for x in sys.stdin.readline().split()]\ndef LI_():\n    return [int(x) - 1 for x in sys.stdin.readline().split()]\ndef LF():\n    return [float(x) for x in sys.stdin.readline().split()]\ndef LS():\n    return sys.stdin.readline().split()\ndef I():\n    return int(sys.stdin.readline())\ndef F():\n    return float(sys.stdin.readline())\ndef S():\n    return input()\ndef pf(s):\n    return print(s, flush=True)\ndef divisions(n):\n    sq = int(math.sqrt(n) + 1)\n    d = collections.defaultdict(int)\n    while n % 2 == 0:\n        n //= 2\n        d[2] += 1\n    i = 3\n    while (n > 1 and sq >= i):\n        if n % i == 0:\n            n //= i\n            d[i] += 1else:i += 2\n    if n > 1:\n        d[n] += 1\n    r = [1]\n    for (k, v) in d.items():\n        for c in r[:]:\n            for i in range(1, v + 1):\n                r.append(c * (k ** i))\n    return sorted(r)\ndef main():\n    n = I()\n    a = LI()\n    s = set()\n    for i in range(n, 0, -1):\n        d = divisions(i)\n        ld = len(d)\n        for j in range(1, 2 ** ld):\n            c = []\n            ff = True\n            for k in range(ld):\n                if j & (1 << k):\n                    f = True\n                    for e in c:\n                        if d[k] % e == 0:\n                            f = False\n                            ff = False\n                            break\n                    if f:\n                        c.append(d[k])\n                if not ff:\n                    break\n            if ff:\n                s.add(tuple(c + [n + 1]))\n    b = sorted(list(s), reverse=True)\n    for c in b:\n        t = 0\n        for j in range(1, n + 1):\n            f = False\n            for e in c:\n                if j % e == 0:\n                    f = True\n                    break\n            if f:\n                t += a[j - 1]\n        if t < 0:\n            for j in range(1, n + 1):\n                f = False\n                for e in c:\n                    if j % e == 0:\n                        f = True\n                        break\n                if f:\n                    a[j - 1] = 0\n    return sum(a)\nprint(main())", "generated_code": "import math, string, itertools, fractions, heapq, collections, re, array, bisect, sys, random, time, copy, functools\nsys.setrecursionlimit(10 * 7)\ninf = 10 ** 20\neps = 1.0 / (10 ** 15)\nmod = (10 ** 9) + 7\ndef LI():\n    return [int(x) for x in sys.stdin.readline().split()]\ndef LI_():\n    return [int(x) - 1 for x in sys.stdin.readline().split()]\ndef LF():\n    return [float(x) for x in sys.stdin.readline().split()]\ndef LS():\n    return sys.stdin.readline().split()\ndef I():\n    return int(sys.stdin.readline())\ndef F():\n    return float(sys.stdin.readline())\ndef S():\n    return input()\ndef pf(s):\n    return print(s, flush=True)\ndef divisions(n):\n    sq = int(math.sqrt(n) + 1)\n    d = collections.defaultdict(int)\n    while n % 2 == 0:\n        n //= 2\n        d[2] += 1\n    i = 3\n    while (n > 1 and sq >= i):\n        if n % i == 0:\n            n //= i\n            d[i] += 1else:i += 2\n    if n > 1:\n        d[n] += 1\n    r = [1]\n    for (k, v) in d.items():\n        for c in r[:]:\n            for i in range(1, v + 1):\n                r.append(c * (k ** i))\n    return sorted(r)\ndef main():\n    n = I()\n    a = LI()\n    s = set()\n    for i in range(n, 0, -1):\n        d = divisions(i)\n        ld = len(d)\n        for j in range(1, 2 ** ld):\n            c = []\n            ff = True\n            for k in range(ld):\n                if j & (1 << k):\n                    f = True\n                    for e in c:\n                        if d[k] % e == 0:\n                            f = False\n                            ff = False\n                            break\n                    if f:\n                        c.append(d[k])\n                if not ff:\n                    break\n            if ff:\n                s.add(tuple(c + [n + 1]))\n    b = sorted(list(s), reverse=True)\n    for c in b:\n        t = 0\n        for j in range(1, n + 1):\n            f = False\n            for e in c:\n                if j % e == 0:\n                    f = True\n                    break\n            if f:\n                t += a[j - 1]\n        if t < 0:\n            for j in range(1, n + 1):\n                f = False\n                for e in c:\n                    if j % e == 0:\n                        f = True\n                        break\n                if f:\n                    a[j - 1] = 0\n    return sum(a)\nprint(main())", "score": 0.0, "codebleu": 0.9962096427720554, "crystalbleu": 1.0, "codebertscore": 1.0, "codescore": 0.9917764663696289, "surfaceSim": 0.49978466838931956, "abs_surfaceSim_minus_score": 0.49978466838931956, "source": "local", "local_type": "MUT"}
{"id": "MBPP_3_19", "golden_code": "def length_Of_Last_Word(a): \r\n    l = 0\r\n    x = a.strip() \r\n    for i in range(len(x)): \r\n        if x[i] == \" \": \r\n            l = 0\r\n        else: \r\n            l += 1\r\n    return l ", "generated_code": "def length_Of_Last_Word(string):\n\tkey = string.find(string) + 1\n\treturn key", "score": 0.2113, "codebleu": 0.08609347966660869, "crystalbleu": 0, "codebertscore": 0.76, "codescore": 0.019055364653468132, "surfaceSim": 0.65006435006435, "abs_surfaceSim_minus_score": 0.43876435006435005, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-1802_53", "golden_code": "q = 10001\nn, a = int(input()), list(map(int, input().split()))\na.sort()\nfor i in range(40000 // (n - 1) + 1):\n    b = [a[j] - j * i for j in range(n)]\n    u, v = max(b), min(b)\n    p = (u - v + 1) // 2\n    if p < q: q, s, d = p, v + p, i\nprint(q)\nprint(s, d)\n\n", "generated_code": "3\n\nn = int(input())\na = list(map(int, input().split()))\nfor i in range(n):\n\ta[i] = a[i] + 1\nfor i in a:\n\tb = i\n\tc = a[0]\n\tfor j in a:\n\t\tif j > i:\n\t\t\tb = min(b, j)\n\tc = min(c, i)\nprint(b)\nprint(c)\n", "score": 0.0, "codebleu": 0.19151238446322094, "crystalbleu": 0.24, "codebertscore": 0.84, "codescore": 0.027707381173968315, "surfaceSim": 0.641025641025641, "abs_surfaceSim_minus_score": 0.641025641025641, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_54_3", "golden_code": "def remove_duplic_list(l):\r\n    temp = []\r\n    for x in l:\r\n        if x not in temp:\r\n            temp.append(x)\r\n    return temp", "generated_code": "def remove_duplic_list(l):\n\treturn list(dict.fromkeys(l))", "score": 1.0, "codebleu": 0.1179475101382386, "crystalbleu": 0, "codebertscore": 0.79, "codescore": 0.9938178658485413, "surfaceSim": 0.5916289592760181, "abs_surfaceSim_minus_score": 0.4083710407239819, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_p00144_s682125154_MUT_152", "golden_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "generated_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "score": 0.0, "codebleu": 0.9816359470073353, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9936000108718872, "surfaceSim": 0.9988589685075309, "abs_surfaceSim_minus_score": 0.9988589685075309, "source": "local", "local_type": "MUT"}
{"id": "MBPP_9_2", "golden_code": "def check_Concat(str1,str2):\r\n    N = len(str1)\r\n    M = len(str2)\r\n    if (N % M != 0):\r\n        return False\r\n    for i in range(N):\r\n        if (str1[i] != str2[i % M]):\r\n            return False         \r\n    return True", "generated_code": "def check_Concat(s, key, default=None):\n\tif key in s:\n\t\treturn True if key in s.keys() else False\n\treturn default == []\nduplicate = False", "score": 1.0, "codebleu": 0.12371493083153232, "crystalbleu": 0, "codebertscore": 0.72, "codescore": 0.9604201316833496, "surfaceSim": 0.5587797619047619, "abs_surfaceSim_minus_score": 0.44122023809523814, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_extra_p03038_s846597544_OP_1", "golden_code": "from collections import Counter\n\nN, M = list(map(int, input().split()))\n\nA = list(map(int, input().split()))\n\n\n\nX = Counter(A)\n\nfor i in range(M):\n\n    B, C = list(map(int, input().split()))\n\n    X[C] += B\n\n\n\nZ = []\n\nfor key, value in list(X.items()):\n\n    Z.append((key, value))\n\n\n\nZ.sort(key=lambda x: x[0], reverse=True)\n\n\n\nans = 0\n\ncnt = 0\n\n\n\nfor value, key in Z:\n\n    if cnt + key <= N:\n\n        ans += key * value\n\n        cnt += key\n\n    else:\n\n        ans += (N - cnt) * value\n\n        break\n\n\n\nprint(ans)\n", "generated_code": "N, M = list(map(int, input().split()))\n\nA = sorted(list(map(int, input().split())))\n\nquery = []\n\nfor i in range(M):\n\n    b, c = list(map(int, input().split()))\n\n    query.append([b, c])\n\nquery.sort(key=lambda q: q[1], reverse=True)\n\n\n\n\n\ni = 0\n\nfor b, c in query:\n\n    while i < N and b > 0:\n\n        if A[i] < c:\n\n            A[i] = c\n\n            b -= 1\n\n        i += 1\n\n\n\nprint((sum(A)))\n", "score": 1.0, "codebleu": 0.30848539159379307, "crystalbleu": 0.27, "codebertscore": 0.83, "codescore": 0.32726359367370605, "surfaceSim": 0.6514648661020829, "abs_surfaceSim_minus_score": 0.3485351338979171, "source": "local", "local_type": "OP"}
{"id": "APPS_test-0055_17", "golden_code": "n, k = map(int, input().split())\ncnt = [0] * 200010\nans = ''\nfor i in range(64):\n  if (n >> i)&1:\n    k -= 1\n    cnt[i] = 1;\nif k < 0:\n  print(\"No\")\nelse:\n  print(\"Yes\")\n  for i in range(64, -64, -1):\n    if k >= cnt[i]:\n      cnt[i - 1] += cnt[i] * 2\n      k -= cnt[i]\n      cnt[i] = 0\n    else: break\n  for i in range(-64, 64):\n    if cnt[i]:\n      while k:\n        cnt[i] -= 1\n        cnt[i - 1] += 2 \n        i -= 1\n        k-= 1\n      break\n  for i in range(64, -100010, -1): ans += (str(i) + ' ') * cnt[i] \n  print(ans)", "generated_code": "def main():\n\tn, k = list(map(int, input().split()))\n\tres = []\n\tmax_end = 0\n\tmax_size = 0\n\tif k & 1:\n\t\tres.append(1 << ((k - 1) >> 1))\n\tfor i in range(k):\n\t\tending = i + 1\n\t\tif ending & 1:\n\t\t\tres.append(ending)\n\t\t\tmax_end = max(max_end, ending)\n\t\telse:\n\t\t\tres[-1] = ending\n\t\t\tmax_size = max(maxSize, ending)\n\tif k == max_end:\n\t\tfor i in range(-1, max_size - 1, -1):\n\t\t\tres[i] = i\n\t\tres[-1:] = [max_end] * max_size\n\t\treturn res\n\tl = 0\n\tr = max_", "score": 0.0, "codebleu": 0.127892812852924, "crystalbleu": 0.13, "codebertscore": 0.76, "codescore": 0.01830710470676422, "surfaceSim": 0.5638095238095238, "abs_surfaceSim_minus_score": 0.5638095238095238, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_2645_55_MUT_6", "golden_code": "ans = 0\n\nfor (i, c) in enumerate(input()):\n    if (i % 2 == 0 and c == 'p'):\n        ans -= 1elif (i % 2 == 1 and c == 'g'):ans += 1\n\nprint(ans)", "generated_code": "ans = 0\n\nfor (i, c) in enumerate(input()):\n    if (i % 2 == 0 and c == 'p'):\n        ans -= 1elif not ((i % 2 == 1 and c == 'g')):ans += 1\n\nprint(ans)", "score": 0.0, "codebleu": 0.834200832346965, "crystalbleu": 0, "codebertscore": 0.99, "codescore": 0.9936677813529968, "surfaceSim": 0.48333333333333334, "abs_surfaceSim_minus_score": 0.48333333333333334, "source": "local", "local_type": "MUT"}
{"id": "MBPP_563_1", "golden_code": "from sys import maxsize \r\ndef max_sub_array_sum(a,size): \r\n\tmax_so_far = -maxsize - 1\r\n\tmax_ending_here = 0\r\n\tstart = 0\r\n\tend = 0\r\n\ts = 0\r\n\tfor i in range(0,size): \r\n\t\tmax_ending_here += a[i] \r\n\t\tif max_so_far < max_ending_here: \r\n\t\t\tmax_so_far = max_ending_here \r\n\t\t\tstart = s \r\n\t\t\tend = i \r\n\t\tif max_ending_here < 0: \r\n\t\t\tmax_ending_here = 0\r\n\t\t\ts = i+1\r\n\treturn (end - start + 1)", "generated_code": "from sys import maxsize \ndef max_sub_array_sum(a, size):\n\treturn (sum(a[:size]) if size < size else 0)", "score": 0.0, "codebleu": 0.07717182802563546, "crystalbleu": 0, "codebertscore": 0.76, "codescore": 0.07142893970012665, "surfaceSim": 0.48308124878805503, "abs_surfaceSim_minus_score": 0.48308124878805503, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_3_28", "golden_code": "def length_Of_Last_Word(a): \r\n    l = 0\r\n    x = a.strip() \r\n    for i in range(len(x)): \r\n        if x[i] == \" \": \r\n            l = 0\r\n        else: \r\n            l += 1\r\n    return l ", "generated_code": "def length_Of_Last_Word(a): return len(a)-1\nss = [(1, 'qwertyuiop')]", "score": 0.1046, "codebleu": 0.08565389012109736, "crystalbleu": 0, "codebertscore": 0.73, "codescore": 0.059218671172857285, "surfaceSim": 0.5615990990990991, "abs_surfaceSim_minus_score": 0.4569990990990991, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_20_48", "golden_code": "def is_odd(n) : \r\n    if (n^1 == n-1) :\r\n        return True; \r\n    else :\r\n        return False; ", "generated_code": "def is_odd(n):    \n\treturn (n & 1) * int(n).bit_length() % 2 == 1", "score": 0.7123, "codebleu": 0.31352472678830295, "crystalbleu": 0, "codebertscore": 0.79, "codescore": 0.6297932267189026, "surfaceSim": 0.6058002148227712, "abs_surfaceSim_minus_score": 0.1064997851772288, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0018_51", "golden_code": "s = input()\nprefmin = ['{'] * (len(s) + 1)\nst = []\n\nfor i in range(len(s) - 1, -1, -1):\n    prefmin[i] = min(s[i], prefmin[i + 1])\n\nfor i in range(len(s)):\n    while len(st) and st[-1] <= prefmin[i]:\n        print(st.pop(), end='')\n    if prefmin[i] == s[i]:\n        print(s[i], end='')\n    else:\n        st.append(s[i])\n\nfor i in range(len(st) - 1, -1, -1):\n    print(st[i], end='')\n\n", "generated_code": "a = list(input())\n\na.sort()\n\nb = []\n\nfor i in range(len(a)):\n\tb.append(a[i])\n\nprint(''.join(b + a[::-1]))\n", "score": 0.0, "codebleu": 0.16074521982082646, "crystalbleu": 0.03, "codebertscore": 0.76, "codescore": 0.04878462851047516, "surfaceSim": 0.5074675324675324, "abs_surfaceSim_minus_score": 0.5074675324675324, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_2_2", "golden_code": "def min_Num(arr,n):  \r\n    odd = 0\r\n    for i in range(n): \r\n        if (arr[i] % 2): \r\n            odd += 1 \r\n    if (odd % 2): \r\n        return 1\r\n    return 2", "generated_code": "def min_Num(arr,n):  \n\tres = 0\n\tfor i in range(1, n + 1):\n\t\tres += i\n\treturn res", "score": 0.0558, "codebleu": 0.23905734295411757, "crystalbleu": 0, "codebertscore": 0.82, "codescore": 0.12126648426055908, "surfaceSim": 0.773618829682903, "abs_surfaceSim_minus_score": 0.717818829682903, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_4169_75_MUT_9", "golden_code": "import bisect, collections, copy, heapq, itertools, math, string, sys\ninput = lambda: (sys.stdin.readline().rstrip())\nsys.setrecursionlimit(10 ** 7)\nINF = float('inf')\ndef I():\n    return int(input())\ndef F():\n    return float(input())\ndef SS():\n    return input()\ndef LI():\n    return [int(x) for x in input().split()]\ndef LI_():\n    return [int(x) - 1 for x in input().split()]\ndef LF():\n    return [float(x) for x in input().split()]\ndef LSS():\n    return input().split()\ndef resolve():\n    (N, M) = LI()\n    AB = [LI() for _ in range(N)]\n    AB.sort()\n    ans = 0\n    for (a, b) in AB:\n        if M >= b:\n            M -= b\n            ans += a * belse:ans += a * Mbreak\n    print(ans)\ndef __starting_point():\n    resolve()\n\n__starting_point()", "generated_code": "import bisect, collections, copy, heapq, itertools, math, string, sys\ninput = lambda: (sys.stdin.readline().rstrip())\nsys.setrecursionlimit(10 ** 7)\nINF = float('inf')\ndef I():\n    return int(input())\ndef F():\n    return float(input())\ndef SS():\n    return input()\ndef LI():\n    return [int(x) for x in input().split()]\ndef LI_():\n    return [int(x) - 1 for x in input().split()]\ndef LF():\n    return [float(x) for x in input().split()]\ndef LSS():\n    return input().split()\ndef resolve():\n    (N, M) = LI()\n    AB = [LI() for _ in range(N)]\n    AB.sort()\n    ans = 0\n    for (a, b) in AB:\n        if M >= b:\n            M += b\n            ans += a * belse:ans += a * Mbreak\n    print(ans)\ndef __starting_point():\n    resolve()\n\n__starting_point()", "score": 0.0, "codebleu": 0.9880182320399841, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.9938532114028931, "surfaceSim": 0.499330655957162, "abs_surfaceSim_minus_score": 0.499330655957162, "source": "local", "local_type": "MUT"}
{"id": "MBPP_71_12", "golden_code": "import math\r\ndef get_First_Set_Bit_Pos(n):\r\n     return math.log2(n&-n)+1", "generated_code": "import math\ndef get_First_Set_Bit_Pos(num):\n\t\n\treturn (num).bit_length()", "score": 0.2098, "codebleu": 0.27029919642137, "crystalbleu": 0, "codebertscore": 0.86, "codescore": 0.10427216440439224, "surfaceSim": 0.6933924254633361, "abs_surfaceSim_minus_score": 0.48359242546333614, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0030_2", "golden_code": "from math import gcd\ndef powmod(a,b,m):\n a%=m\n r=1\n while b:\n  if b&1:r=r*a%m\n  a=a*a%m\n  b>>=1\n return r\n\ndef f(n):\n r=[]\n if (n&1)==0:\n  e=0\n  while (n&1)==0:n>>=1;e+=1\n  yield (2,e)\n p=3\n while n>1:\n  if p*p>n:p=n\n  if n%p:\n   p+=2\n   continue\n  e=1;n//=p\n  while n%p==0:n//=p;e+=1\n  yield (p,e)\n  p+=2\n return r\nm,x=map(int,input().split())\np=2\nr=[(1,1)]\nfor p,e in f(m):\n assert e>=1\n ord=p-1\n assert powmod(x,ord,p)==1\n for pi,ei in f(p-1):\n  while ord % pi == 0 and powmod(x,ord//pi,p)==1: ord//=pi\n ords=[(1,1),(ord,p-1)]\n q=p\n for v in range(2,e+1):\n  q*=p\n  if powmod(x,ord,q)!=1:ord*=p\n  assert powmod(x,ord,q)==1\n  ords.append((ord,q//p*(p-1)))\n r=[(a//gcd(a,c)*c,b*d) for a,b in r for c,d in ords]\nprint(sum(y//x for x,y in r))", "generated_code": "m, x = list(map(int, input().split()))\n\nans = 0\ngrcd = m\n\nwhile grcd > 1:\n\tans += 1\n\tgrcd = grcd // 2\n\nif not x % grcd:\n\tans -= 1\n\nprint(ans)\n", "score": 0.0002, "codebleu": 0.09921022927361166, "crystalbleu": 0.0, "codebertscore": 0.68, "codescore": 0.09134650230407715, "surfaceSim": 0.35362407862407863, "abs_surfaceSim_minus_score": 0.35342407862407865, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_14_6", "golden_code": "def sum_even_odd(list1):\r\n    first_even = next((el for el in list1 if el%2==0),-1)\r\n    first_odd = next((el for el in list1 if el%2!=0),-1)\r\n    return (first_even+first_odd)", "generated_code": "def sum_even_odd(list1):\n\treturn sum([x for x in list1 if x%2 == 0])", "score": 0.0211, "codebleu": 0.1480367529747603, "crystalbleu": 0, "codebertscore": 0.87, "codescore": 0.029633156955242157, "surfaceSim": 0.5710227272727273, "abs_surfaceSim_minus_score": 0.5499227272727273, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_1371_18_MUT_4", "golden_code": "S = int(input())\n(a, b, c) = (1, 0, 0)\nfor n in range(S):\n    (a, b, c) = (b, c, (a + c) % ((10 ** 9) + 7))\nprint(a)", "generated_code": "S = int(input())\n(a, b, c) = (1, 0, 0)\nfor n in range(S):\n    (a, b, c) = (b, c, (a + c) % ((10 ** 9) - 7))\nprint(a)", "score": 0.2662, "codebleu": 0.9600773424434107, "crystalbleu": 0, "codebertscore": 0.99, "codescore": 0.16646508872509003, "surfaceSim": 0.9623563218390805, "abs_surfaceSim_minus_score": 0.6961563218390805, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_HE_21_OP_1", "golden_code": "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) / (max_number - min_number) for x in numbers]", "generated_code": "from typing import List\n\ndef rescale_to_unit(values: List[float]) -> List[float]:\n    if not values:\n        return []\n    min_val, max_val = float('inf'), float('-inf')\n    for val in values:\n        if val < min_val:\n            min_val = val\n        if val > max_val:\n            max_val = val\n    range_val = max_val - min_val\n    if range_val == 0:\n        return [0.0 for _ in values]\n    return [(val - min_val) / range_val for val in values]", "score": 1.0, "codebleu": 0.44001467048854004, "crystalbleu": 0, "codebertscore": 0.85, "codescore": 0.9893161058425903, "surfaceSim": 0.5939495174461766, "abs_surfaceSim_minus_score": 0.40605048255382337, "source": "local", "local_type": "OP"}
{"id": "MBPP_30_28", "golden_code": "import re\r\ndef match_num(string):\r\n    text = re.compile(r\"^5\")\r\n    if text.match(string):\r\n        return True\r\n    else:\r\n        return False", "generated_code": "import re\ndef match_num(string):\n\treturn bool(re.match(r'[1-9]{1,2-3}', string))", "score": 0.9293, "codebleu": 0.2848993676924576, "crystalbleu": 0, "codebertscore": 0.8, "codescore": 0.9106972217559814, "surfaceSim": 0.7137931034482758, "abs_surfaceSim_minus_score": 0.21550689655172417, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_extra_p03436_s361663353_OP_1", "golden_code": "from collections import deque\n\n\n\nINF = float('inf')\n\n\n\ndr = (-1, 0, 0, 1)\n\ndc = (0, -1, 1, 0)\n\n\n\nH, W = list(map(int, input().split()))\n\n\n\ns = []\n\ntotal_white_count = 0\n\nfor _ in range(H):\n\n    t = eval(input())\n\n    s.append(t)\n\n    total_white_count += t.count('.')\n\np = [[INF for _ in range(W)] for _ in range(H)]\n\n\n\nans = -1\n\n\n\ndq = deque()\n\ndq.append((0, 0, 1))\n\nwhile dq:\n\n    r, c, d = dq.popleft() # 直した\n\n\n\n    nd = d + 1\n\n    for i in range(4):\n\n        nr = r + dr[i]\n\n        nc = c + dc[i]\n\n        if not (0 <= nr < H and 0 <= nc < W): continue\n\n        if s[nr][nc] == '#' : continue\n\n        if p[nr][nc] <= nd: continue\n\n        p[nr][nc] = nd\n\n        if nr == H - 1 and nc == W - 1:\n\n            ans = total_white_count - nd\n\n            break\n\n        dq.append((nr, nc, nd))\n\n    else:\n\n        continue\n\n    break\n\n\n\nprint(ans)\n", "generated_code": "def main():\n\n    from collections import deque\n\n    import sys\n\n\n\n    input = sys.stdin.readline\n\n\n\n    h, w = list(map(int, input().split()))\n\n    s = [eval(input()) for _ in range(h)]\n\n\n\n    bk = 0\n\n    for row in s:\n\n        bk += row.count('#')\n\n\n\n    def coods(r, c):\n\n        if r > 0: yield r - 1, c\n\n        if r < h - 1: yield r + 1, c\n\n        if c > 0: yield r, c - 1\n\n        if c < w - 1: yield r, c + 1\n\n\n\n    q = deque()\n\n    q.append((0, 0))\n\n    count = [[-1] * w for _ in range(h)]\n\n    count[0][0] = 1\n\n    while q:\n\n        r, c = q.popleft()\n\n        k = count[r][c]\n\n        for nr, nc in coods(r, c):\n\n            nchar = s[nr][nc]\n\n            if nchar == '#': continue\n\n            if count[nr][nc] != -1: continue\n\n            count[nr][nc] = k + 1\n\n            if (nr, nc) == (h - 1, w - 1):\n\n                print((h * w - (k + 1) - bk))\n\n                return\n\n            q.append((nr, nc))\n\n    print((-1))\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 1.0, "codebleu": 0.24761018939116627, "crystalbleu": 0.23, "codebertscore": 0.82, "codescore": 0.019709566608071327, "surfaceSim": 0.6430454083048183, "abs_surfaceSim_minus_score": 0.35695459169518173, "source": "local", "local_type": "OP"}
{"id": "APPS_test-0940_16", "golden_code": "A = list(map(int, input().split()))\nA = sorted(A)\nprint(max(0, A[2] - A[0] - A[1] + 1))", "generated_code": "import sys\nreadline = sys.stdin.readline\n\nA = list(map(int, readline().split()))\nA.sort()\n\nfor i in range(len(A)-1):\n\tif A[i] < A[i+1]:\n\t\tA[i] += A[i+ 1]\n\t\t\nif len(A) == 1:\n\tprint(0)\nelse:\n\tprint((A[-1] + A[-2])//2)\n", "score": 0.0, "codebleu": 0.27243353778363616, "crystalbleu": 0, "codebertscore": 0.79, "codescore": 0.03390973061323166, "surfaceSim": 0.4721296296296297, "abs_surfaceSim_minus_score": 0.4721296296296297, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_9_MUT_5", "golden_code": "import os\n\nfrom typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    running_max = None\n    result = []\n    \n    for n in numbers:\n        if running_max is None:\n            running_max = n\n        else:\n            running_max = max(running_max, n)\n        \n        result.append(running_max)\n    \n    return result", "generated_code": "import os\n\nfrom typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    running_max = None\n    result = []\n    \n    for n in reversed(numbers):\n        if running_max is None:\n            running_max = n\n        else:\n            running_max = max(running_max, n)\n        \n        result.append(running_max)\n    \n    return result", "score": 0.4814, "codebleu": 0.8955174253878816, "crystalbleu": 0, "codebertscore": 0.99, "codescore": 0.9937710165977478, "surfaceSim": 0.9859550561797753, "abs_surfaceSim_minus_score": 0.5045550561797754, "source": "local", "local_type": "MUT"}
{"id": "MBPP_15_3", "golden_code": "def parallelogram_perimeter(b,h):\r\n  perimeter=2*(b*h)\r\n  return perimeter", "generated_code": "def parallelogram_perimeter(b,h):\n\treturn h*(h-1)/2*h + h*(h -1)/2*(h - h - 1)\nss = [1, 2, 3]\ns = sum(ss)", "score": 0.0542, "codebleu": 0.23307176207269548, "crystalbleu": 0, "codebertscore": 0.83, "codescore": 0.03155145049095154, "surfaceSim": 0.6338935574229692, "abs_surfaceSim_minus_score": 0.5796935574229691, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_MBPP_717_MUT_10", "golden_code": "import os\n\nimport math\nimport sys\ndef sd_calc(data):\n    n = len(data)\n    if n <= 1:\n        return 0.0\n    (mean, sd) = (avg_calc(data), 0.0)\n    for el in data:\n        sd += (float(el) - mean) ** 2\n    sd = math.sqrt(sd / float(n - 1))\n    return sd\ndef avg_calc(ls):\n    (n, mean) = (len(ls), 0.0)\n    if n <= 1:\n        return ls[0]\n    for el in ls:\n        mean = mean + float(el)\n    mean = mean / float(n)\n    return mean", "generated_code": "import os\n\nimport math\nimport sys\ndef sd_calc(data):\n    n = len(data)\n    if not (n <= 1):\n        return 0.0\n    (mean, sd) = (avg_calc(data), 0.0)\n    for el in data:\n        sd += (float(el) - mean) ** 2\n    sd = math.sqrt(sd / float(n - 1))\n    return sd\ndef avg_calc(ls):\n    (n, mean) = (len(ls), 0.0)\n    if n <= 1:\n        return ls[0]\n    for el in ls:\n        mean = mean + float(el)\n    mean = mean / float(n)\n    return mean", "score": 0.2809, "codebleu": 0.9522795259737762, "crystalbleu": 0.93, "codebertscore": 0.99, "codescore": 0.9937919974327087, "surfaceSim": 0.9597964175806833, "abs_surfaceSim_minus_score": 0.6788964175806833, "source": "local", "local_type": "MUT"}
{"id": "MBPP_16_32", "golden_code": "def div_of_nums(nums,m,n):\r\n result = list(filter(lambda x: (x % m == 0 and x % n == 0), nums)) \r\n return result", "generated_code": "def div_of_nums(nums,m,n):\n\tans = []\n\tfor i in nums:\n\t\tif i % m == 0 and i % n == 0:\n\t\t\tans.append(i)\n\treturn ans\n\n\n\n\n\n\n\n\nh = {}", "score": 1.0, "codebleu": 0.33162050992662506, "crystalbleu": 0, "codebertscore": 0.88, "codescore": 0.9934804439544678, "surfaceSim": 0.6744791666666667, "abs_surfaceSim_minus_score": 0.32552083333333326, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_62_4", "golden_code": "import re\r\ndef num_position(text):\r\n for m in re.finditer(\"\\d+\", text):\r\n    return m.start()", "generated_code": "import re\ndef num_position(s):    \n\treturn s == s[::-1]", "score": 0.1427, "codebleu": 0.15516857781972748, "crystalbleu": 0, "codebertscore": 0.8, "codescore": 0.19622229039669037, "surfaceSim": 0.5134408602150538, "abs_surfaceSim_minus_score": 0.37074086021505376, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_88_1", "golden_code": "def even_bit_toggle_number(n) : \r\n    res = 0; count = 0; temp = n \r\n    while (temp > 0) :     \r\n        if (count % 2 == 1) : \r\n            res = res | (1 << count)      \r\n        count = count + 1\r\n        temp >>= 1 \r\n    return n ^ res ", "generated_code": "def even_bit_toggle_number(n):\n\n\treturn str((n % 2) + n)", "score": 0.0, "codebleu": 0.06366005693876484, "crystalbleu": 0, "codebertscore": 0.76, "codescore": 0.020951174199581146, "surfaceSim": 0.5362206085753803, "abs_surfaceSim_minus_score": 0.5362206085753803, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_66_17", "golden_code": "def get_item(tup1,index):\r\n  item = tup1[index]\r\n  return item", "generated_code": "def get_item(state, n):\n\tif n == 0: return []\n\tif (state == None or n == 0): return 0\n\treturn state[n]\nns = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]", "score": 0.2182, "codebleu": 0.24345522594104146, "crystalbleu": 0, "codebertscore": 0.73, "codescore": 0.0554824061691761, "surfaceSim": 0.53743961352657, "abs_surfaceSim_minus_score": 0.31923961352657, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_43_24", "golden_code": "def is_Two_Alter(s):  \r\n    for i in range (len( s) - 2) : \r\n        if (s[i] != s[i + 2]) : \r\n            return False\r\n    if (s[0] == s[1]): \r\n        return False\r\n    return True", "generated_code": "def is_Two_Alter(s):\n\tif s == s[::-1]:\n\t\treturnTrue\n\telse:\n\t\ts = s[::-1]\n\t\tif len([x for x in s]) == 2:\n\t\t\tif s.count(x) == 1 or s.count([x for y in s if y!= x]):\n\t\t\t\treturn True\n\n\t\treturn False", "score": 0.9902, "codebleu": 0.22658344452318654, "crystalbleu": 0, "codebertscore": 0.82, "codescore": 0.9591749906539917, "surfaceSim": 0.5154639175257731, "abs_surfaceSim_minus_score": 0.47473608247422683, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_4620_17_OP_1", "golden_code": "n = int(input())\ngraph =[]\ntime = 0\nfor i in range(n-1):\n    c,s,f = map(int,input().split())\n    graph.append([i,c,s,f])\n\ndef shortest_path(start,end,times):\n    if start == end:\n        return times\n    elif times<=graph[start][2]:\n        times = (graph[start][2]+graph[start][1])\n        return shortest_path(start+1,end,times)\n    elif times%graph[start][3]==0:\n        times += (graph[start][1])\n        return shortest_path(start+1,end,times)\n    else:\n        times = times+graph[start][3]-times%graph[start][3]+graph[start][1]\n        return shortest_path(start+1,end,times)\n\n\nfor i in range(n):\n    print(shortest_path(i,n-1,0))", "generated_code": "from functools import lru_cache\n\nnum_stations = int(input())\nconnections = []\n\nfor _ in range(num_stations - 1):\n    cost, start_time, frequency = map(int, input().split())\n    connections.append((cost, start_time, frequency))\n\n@lru_cache(None)\ndef shortest_path(current, destination, current_time):\n    if current == destination:\n        return current_time\n    cost, start_time, frequency = connections[current]\n    if current_time <= start_time:\n        next_time = start_time + cost\n    elif current_time % frequency == 0:\n        next_time = current_time + cost\n    else:\n        next_time = current_time + frequency - current_time % frequency + cost\n    return shortest_path(current + 1, destination, next_time)\n\nfor station in range(num_stations):\n    print(shortest_path(station, num_stations - 1, 0))\n", "score": 0.9995, "codebleu": 0.23932592945886455, "crystalbleu": 0.16, "codebertscore": 0.79, "codescore": 0.23397964239120483, "surfaceSim": 0.6809919114516816, "abs_surfaceSim_minus_score": 0.31850808854831847, "source": "local", "local_type": "OP"}
{"id": "LOCAL_MBPP_622_OP_1", "golden_code": "def get_median(arr1, arr2, n):\r\n  i = 0\r\n  j = 0\r\n  m1 = -1\r\n  m2 = -1\r\n  count = 0\r\n  while count < n + 1:\r\n    count += 1\r\n    if i == n:\r\n      m1 = m2\r\n      m2 = arr2[0]\r\n      break\r\n    elif j == n:\r\n      m1 = m2\r\n      m2 = arr1[0]\r\n      break\r\n    if arr1[i] <= arr2[j]:\r\n      m1 = m2\r\n      m2 = arr1[i]\r\n      i += 1\r\n    else:\r\n      m1 = m2\r\n      m2 = arr2[j]\r\n      j += 1\r\n  return (m1 + m2)/2", "generated_code": "def get_median(list1, list2, length):\n    if list1[-1] <= list2[0]:\n        if length % 2 == 0:\n            return (list1[-1] + list2[0]) / 2\n        else:\n            return list2[0]\n    elif list2[-1] <= list1[0]:\n        if length % 2 == 0:\n            return (list2[-1] + list1[0]) / 2\n        else:\n            return list1[0]\n    index1, index2 = 0, 0\n    median1, median2 = -1, -1\n    for _ in range(length + 1):\n        if index1 == length:\n            median1 = median2\n            median2 = list2[index2]\n            break\n        elif index2 == length:\n            median1 = median2\n            median2 = list1[index1]\n            break\n        if list1[index1] <= list2[index2]:\n            median1 = median2\n            median2 = list1[index1]\n            index1 += 1\n        else:\n            median1 = median2\n            median2 = list2[index2]\n            index2 += 1\n    return (median1 + median2) / 2", "score": 0.869, "codebleu": 0.3828564750429125, "crystalbleu": 0.08, "codebertscore": 0.81, "codescore": 0.9905821084976196, "surfaceSim": 0.689805260590597, "abs_surfaceSim_minus_score": 0.179194739409403, "source": "local", "local_type": "OP"}
{"id": "LOCAL_PIE_extra_p03325_s352799823_OP_1", "golden_code": "N = int(eval(input()))\n\nA = [int(i) for i in input().split()]\n\nans = 0\n\ncheck = [0]*30\n\nfor i in range(1, 31):\n\n    check[i-1] = 2**i\n\n\n\nfor i in A:\n\n    if i % 2 == 0:\n\n        j = 0\n\n        while check[j] <= i:\n\n            if i % check[j] == 0:\n\n                add = check[j]\n\n            else:\n\n                break\n\n                \n\n            j += 1\n\n        ans += j\n\n        \n\nprint(ans)", "generated_code": "N = int(eval(input()))\n\na = [int(i) for i in input().split()]\n\nans = 0\n\n\n\nfor i in a:\n\n    while i % 2 == 0:\n\n        i //= 2\n\n        ans += 1\n\nprint(ans)", "score": 1.0, "codebleu": 0.33083520046530906, "crystalbleu": 0, "codebertscore": 0.85, "codescore": 0.3478069305419922, "surfaceSim": 0.6838362068965518, "abs_surfaceSim_minus_score": 0.3161637931034482, "source": "local", "local_type": "OP"}
{"id": "MBPP_43_61", "golden_code": "def is_Two_Alter(s):  \r\n    for i in range (len( s) - 2) : \r\n        if (s[i] != s[i + 2]) : \r\n            return False\r\n    if (s[0] == s[1]): \r\n        return False\r\n    return True", "generated_code": "def is_Two_Alter(s):\n\tif s == '': return 0\n\treturn s == s[0]\n\treturn str(s) == str(s)[1:]", "score": 0.8433, "codebleu": 0.20170631083543275, "crystalbleu": 0, "codebertscore": 0.79, "codescore": 0.9669514894485474, "surfaceSim": 0.6530054644808743, "abs_surfaceSim_minus_score": 0.19029453551912578, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_extra_p02951_s688063139_OP_1", "golden_code": "a, b, c = list(map(int, input().split()))\n\n\n\nif a < b + c:\n\n    print((b+c-a))\n\nelse:\n\n    print((0))", "generated_code": "a,b,c = list(map(int, input().split()))\n\n\n\nprint((max(0, c-(a-b))))", "score": 1.0, "codebleu": 0.3438053372011196, "crystalbleu": 0, "codebertscore": 0.9, "codescore": 0.5228681564331055, "surfaceSim": 0.7264851485148515, "abs_surfaceSim_minus_score": 0.27351485148514854, "source": "local", "local_type": "OP"}
{"id": "MBPP_490_1", "golden_code": "def check_last (arr,n,p): \r\n    _sum = 0\r\n    for i in range(n): \r\n        _sum = _sum + arr[i] \r\n    if p == 1: \r\n        if _sum % 2 == 0: \r\n            return \"ODD\"\r\n        else: \r\n            return \"EVEN\"\r\n    return \"EVEN\"\r\n      ", "generated_code": "def check_last (arr,n,p): \n\treturn arr[-1]%2==0 or p", "score": 0.0, "codebleu": 0.09011315179559551, "crystalbleu": 0, "codebertscore": 0.73, "codescore": 0.0320870578289032, "surfaceSim": 0.6017932489451476, "abs_surfaceSim_minus_score": 0.6017932489451476, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-2596_21", "golden_code": "n, k, m, t = input().split()\nn, k, m, t = int(n), int(k), int(m), int(t)\n\nfor i in range(t):\n    what, pos = input().split()\n    what, pos = int(what), int(pos)\n    if what == 0:\n        if pos >= k:\n            n = pos\n        else:\n            n = n-pos\n            k = k-pos\n    else:\n        n += 1\n        if pos <= k:\n            k += 1\n    print(n, end=\" \")\n    print(k)\n\n\n", "generated_code": "n,k,m,t=list(map(int,input().split()))\na=[]\nfor i in range(t):\n\tx=input().split()\n\tif(x[0]==\"1\"):\n\t\ta.append(int(x[1]))\n\telse:\n\t\tb=a[::]\n\t\ta.pop()\n\t\ta.insert(0,int(x[2]))\nfor i in a:\n\tprint(i,end=\" \")\n", "score": 0.0, "codebleu": 0.1790695495797508, "crystalbleu": 0.18, "codebertscore": 0.77, "codescore": 0.3118281066417694, "surfaceSim": 0.6105263157894736, "abs_surfaceSim_minus_score": 0.6105263157894736, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_97_OP_1", "golden_code": "def multiply(a, b):\n    return abs(a % 10) * abs(b % 10)", "generated_code": "def multiply(x, y):\n    return abs(x) % 10 * abs(y) % 10", "score": 0.6295, "codebleu": 0.2856858483281266, "crystalbleu": 0, "codebertscore": 0.95, "codescore": 0.9779770374298096, "surfaceSim": 0.9285714285714286, "abs_surfaceSim_minus_score": 0.29907142857142865, "source": "local", "local_type": "OP"}
{"id": "MBPP_185_1", "golden_code": "def sum_average(number):\r\n total = 0\r\n for value in range(1, number + 1):\r\n    total = total + value\r\n average = total / number\r\n return (total,average)", "generated_code": "def sum_average(name):\n\ta=name*(10)\n\treturn int(a)", "score": 0.0, "codebleu": 0.07911146131789883, "crystalbleu": 0, "codebertscore": 0.77, "codescore": 0.01826278306543827, "surfaceSim": 0.5799148606811146, "abs_surfaceSim_minus_score": 0.5799148606811146, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_129_OP_1", "golden_code": "def minPath(grid, k):\n    n = len(grid)\n    val = n * n + 1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                temp = []\n                if i != 0:\n                    temp.append(grid[i - 1][j])\n\n                if j != 0:\n                    temp.append(grid[i][j - 1])\n\n                if i != n - 1:\n                    temp.append(grid[i + 1][j])\n\n                if j != n - 1:\n                    temp.append(grid[i][j + 1])\n\n                val = min(temp)\n\n    ans = []\n    for i in range(k):\n        if i % 2 == 0:\n            ans.append(1)\n        else:\n            ans.append(val)\n    return ans", "generated_code": "def minPath(matrix, steps):\n    size = len(matrix)\n    min_value = float('inf')\n    for x in range(size):\n        for y in range(size):\n            if matrix[x][y] == 1:\n                neighbors = []\n                if x > 0:\n                    neighbors.append(matrix[x - 1][y])\n                if y > 0:\n                    neighbors.append(matrix[x][y - 1])\n                if x < size - 1:\n                    neighbors.append(matrix[x + 1][y])\n                if y < size - 1:\n                    neighbors.append(matrix[x][y + 1])\n                if neighbors:\n                    min_value = min(min_value, min(neighbors))\n\n    result = [1 if i % 2 == 0 else min_value for i in range(steps)]\n    return result\n", "score": 1.0, "codebleu": 0.42476250364296764, "crystalbleu": 0.17, "codebertscore": 0.87, "codescore": 0.13397160172462463, "surfaceSim": 0.7348019202297097, "abs_surfaceSim_minus_score": 0.2651980797702903, "source": "local", "local_type": "OP"}
{"id": "LOCAL_PIE_extra_p03162_s697147605_OP_1", "golden_code": "n = int(eval(input()))\n\n\n\nfelicidade = []\n\n\n\nfor x in range(n):\n\n    felicidade.append(list(map(int,input().split())))\n\n\n\nDP = [0,0,0]\n\n\n\nif n == 1:\n\n    print((max(felicidade[0])))\n\n\n\nelse:\n\n\n\n    for x in range(3):\n\n        DP[x] = felicidade[0][x]\n\n\n\n\n\n    for dia in range(1,n):\n\n        m = [0] * 3\n\n        for x  in range(3):#As duas possíveis escolhas são x e y\n\n            for y  in range(3):\n\n                if x != y: #Se elas forem diferentes\n\n                    m[x] = max(m[x], DP[y] + felicidade[dia][x])\n\n        DP = m\n\n    \n\n    print((max(DP)))\n", "generated_code": "nDays = int(eval(input()))\n\n\n\ntoday = [int(x) for x in input().split()]\n\n\n\nfor i in range(nDays - 1):\n\n    tomorrow = [int(x) for x in input().split()]\n\n    tomorrow[0] += max(today[1], today[2])\n\n    tomorrow[1] += max(today[0], today[2])\n\n    tomorrow[2] += max(today[0], today[1])\n\n    today = tomorrow\n\n\n\nprint((max(today)))", "score": 1.0, "codebleu": 0.16521526840636913, "crystalbleu": 0.11, "codebertscore": 0.72, "codescore": 0.5636661648750305, "surfaceSim": 0.5835537918871252, "abs_surfaceSim_minus_score": 0.4164462081128748, "source": "local", "local_type": "OP"}
{"id": "APPS_test-0302_33", "golden_code": "import math\nacc = []\nn = int(input())\ndef OneNum (num, One):\n onetrans = num // acc[One]\n num = num % acc[One] \n if num == 0:\n  return onetrans*One\n else:\n  return onetrans*One + min(OneNum(num, One-1), One + OneNum(acc[One] - num, One - 1))\nacc.append(0)\nfor i in range(1,17):\n acc.append (acc[i-1]*10 + 1)\nprint (OneNum(n,16))", "generated_code": "n = int(input())\na = 0\nwhile n > 0:\n\tif n % 10 == 1:\n\t\ta += 1\n\t\tn = n // 10\n\telse:\n\t\tn = d = 1\n\t\twhile d * 10 < n:\n\t\t\td *= 10\n\t\tn -= d\nprint(a)\n", "score": 0.1318, "codebleu": 0.08683201869680851, "crystalbleu": 0, "codebertscore": 0.74, "codescore": 0.03225380927324295, "surfaceSim": 0.4226371951219512, "abs_surfaceSim_minus_score": 0.29083719512195116, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_9_19", "golden_code": "def check_Concat(str1,str2):\r\n    N = len(str1)\r\n    M = len(str2)\r\n    if (N % M != 0):\r\n        return False\r\n    for i in range(N):\r\n        if (str1[i] != str2[i % M]):\r\n            return False         \r\n    return True", "generated_code": "def check_Concat(str1,str2):\n\treturn bool(str1+str2)", "score": 0.1233, "codebleu": 0.08385391074958196, "crystalbleu": 0, "codebertscore": 0.77, "codescore": 0.025546126067638397, "surfaceSim": 0.5174107142857143, "abs_surfaceSim_minus_score": 0.39411071428571426, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_71_5", "golden_code": "import math\r\ndef get_First_Set_Bit_Pos(n):\r\n     return math.log2(n&-n)+1", "generated_code": "import math\ndef get_First_Set_Bit_Pos(n1):\n\t return (n1 & 0x555555555555) + ((n1 & 99) == 0)", "score": 0.1505, "codebleu": 0.23501071235278911, "crystalbleu": 0, "codebertscore": 0.82, "codescore": 0.1617414802312851, "surfaceSim": 0.6844965675057209, "abs_surfaceSim_minus_score": 0.5339965675057209, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_23_14", "golden_code": "def same_Length(A,B): \r\n    while (A > 0 and B > 0): \r\n        A = A / 10; \r\n        B = B / 10; \r\n    if (A == 0 and B == 0): \r\n        return True; \r\n    return False; ", "generated_code": "def same_Length(A,B): \n\tif len(str(A))==len(str(B)): \n\t\treturn True\n\treturn False\nns = [1,5,7,11]", "score": 0.6265, "codebleu": 0.15257781306412188, "crystalbleu": 0, "codebertscore": 0.78, "codescore": 0.5631311535835266, "surfaceSim": 0.6448179271708684, "abs_surfaceSim_minus_score": 0.018317927170868442, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_30_40", "golden_code": "import re\r\ndef match_num(string):\r\n    text = re.compile(r\"^5\")\r\n    if text.match(string):\r\n        return True\r\n    else:\r\n        return False", "generated_code": "import re\ndef match_num(string):\n\treturn bool(re.match(\"[0-9]{1}\\d{2}\\Z\",string))\nOptimunz={}", "score": 0.9436, "codebleu": 0.2848993676924576, "crystalbleu": 0, "codebertscore": 0.77, "codescore": 0.9406355023384094, "surfaceSim": 0.7409482758620689, "abs_surfaceSim_minus_score": 0.2026517241379311, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0605_12", "golden_code": "p=input().split()\na=int(p[0])\nb=int(p[1])\nc=int(p[2])\nd=int(p[3])\nx=max((3*a)//10,a-(a//250)*c)\ny=max((3*b)//10,b-(b//250)*d)\nif(x>y):\n    print(\"Misha\")\nelif(y>x):\n    print(\"Vasya\")\nelse:\n    print(\"Tie\")\n", "generated_code": "import sys\n\ndef main():\n\ta, b, cnt1, cnt2 = list(map(int, sys.stdin.readline().split()))\n\tresult = (\"Mshortest\" if cnt1 + cnt2 >= a else \"Vasya\")\n\tsys.stdout.write(result)\n\t\n\ndef __starting_point():\n\tmain()\n\n__starting_point()\n", "score": 0.1142, "codebleu": 0.07571138211382114, "crystalbleu": 0.03, "codebertscore": 0.72, "codescore": 0.031340163201093674, "surfaceSim": 0.3436970518468315, "abs_surfaceSim_minus_score": 0.22949705184683153, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_1621_1_MUT_21", "golden_code": "s = input().strip()\nk = int(input())\na = list(map(int, input().split()))\nans = 0\nfor i in range(len(s)):\n    ans += (i + 1) * a[ord(s[i]) - 97]\nm = max(a)\nfor i in range(len(s), len(s) + k):\n    ans += m * (i + 1)\nprint(ans)", "generated_code": "pass\nk = int(input())\na = list(map(int, input().split()))\nans = 0\nfor i in range(len(s)):\n    ans += (i + 1) * a[ord(s[i]) - 97]\nm = max(a)\nfor i in range(len(s), len(s) + k):\n    ans += m * (i + 1)\nprint(ans)", "score": 0.172, "codebleu": 0.8017915496540275, "crystalbleu": 0.89, "codebertscore": 0.98, "codescore": 0.9937376976013184, "surfaceSim": 0.9387400793650793, "abs_surfaceSim_minus_score": 0.7667400793650794, "source": "local", "local_type": "MUT"}
{"id": "MBPP_34_21", "golden_code": "def even_num(x):\r\n  if x%2==0:\r\n     return True\r\n  else:\r\n    return False", "generated_code": "def even_num(count, n = 0):\n    \n    return (count - 1) * 2 if count > 0 else 1", "score": 0.4293, "codebleu": 0.2831440442566943, "crystalbleu": 0, "codebertscore": 0.8, "codescore": 0.12468011677265167, "surfaceSim": 0.5979151154132539, "abs_surfaceSim_minus_score": 0.1686151154132539, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_82_MUT_10", "golden_code": "import os\n\ndef prime_length(string):\n    l = len(string)\n    if (l == 0 or l == 1):\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n            return False\n    return True", "generated_code": "import os\n\ndef prime_length(string):\n    l = len(string)\n    if (l == 0 or l != 1):\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n            return False\n    return True", "score": 0.4558, "codebleu": 0.958989607293936, "crystalbleu": 0, "codebertscore": 1.0, "codescore": 0.9936314225196838, "surfaceSim": 0.9746954076850984, "abs_surfaceSim_minus_score": 0.5188954076850985, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_HE_34_OP_1", "golden_code": "def unique(l: list):\n    return sorted(list(set(l)))", "generated_code": "def unique(seq: list):\n    return sorted(set(seq))", "score": 1.0, "codebleu": 0.3253082364316966, "crystalbleu": 0, "codebertscore": 0.95, "codescore": 0.9710246324539185, "surfaceSim": 0.9038461538461539, "abs_surfaceSim_minus_score": 0.09615384615384615, "source": "local", "local_type": "OP"}
{"id": "LOCAL_APPS_4169_75_OP_1", "golden_code": "import bisect, collections, copy, heapq, itertools, math, string, sys\ninput = lambda: sys.stdin.readline().rstrip() \nsys.setrecursionlimit(10**7)\nINF = float('inf')\ndef I(): return int(input())\ndef F(): return float(input())\ndef SS(): return input()\ndef LI(): return [int(x) for x in input().split()]\ndef LI_(): return [int(x)-1 for x in input().split()]\ndef LF(): return [float(x) for x in input().split()]\ndef LSS(): return input().split()\n\ndef resolve():\n    N, M = LI()\n    AB = [LI() for _ in range(N)]\n    AB.sort()\n\n    ans = 0\n    for a, b in AB:\n        if M >= b:\n            M -= b\n            ans += a * b\n        else:\n            ans += a * M\n            break\n\n    print(ans)\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "generated_code": "import sys\ninput = lambda: sys.stdin.readline().rstrip()\nsys.setrecursionlimit(10**7)\n\n\ndef resolve():\n    num_items, max_units = map(int, input().split())\n    item_list = [tuple(map(int, input().split())) for _ in range(num_items)]\n    item_list.sort()\n\n    total_value = 0\n    remaining_units = max_units\n    for price_per_unit, units in item_list:\n        if remaining_units >= units:\n            remaining_units -= units\n            total_value += price_per_unit * units\n        else:\n            total_value += price_per_unit * remaining_units\n            break\n\n    print(total_value)\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()\n", "score": 1.0, "codebleu": 0.31693950547829575, "crystalbleu": 0.18, "codebertscore": 0.79, "codescore": 0.2756626009941101, "surfaceSim": 0.7364301827724322, "abs_surfaceSim_minus_score": 0.2635698172275678, "source": "local", "local_type": "OP"}
{"id": "MBPP_36_1", "golden_code": "import re\r\ndef extract_date(url):\r\n        return re.findall(r'/(\\d{4})/(\\d{1,2})/(\\d{1,2})/', url)", "generated_code": "import re\ndef extract_date(url):\n\ttext = re.findall(r'(.+\\.)\\..*', url)\n\treturn [m.group() for m in text]", "score": 1.0, "codebleu": 0.5749088850240354, "crystalbleu": 0, "codebertscore": 0.81, "codescore": 0.9658884406089783, "surfaceSim": 0.655952380952381, "abs_surfaceSim_minus_score": 0.34404761904761905, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_42_11", "golden_code": "import re\r\ndef end_num(string):\r\n    text = re.compile(r\".*[0-9]$\")\r\n    if text.match(string):\r\n        return True\r\n    else:\r\n        return False", "generated_code": "import re\ndef end_num(string):\n\treturn re.match(r'\\s*\\d+',string) is not None\nUSTWALL = '11111111'", "score": 0.8569, "codebleu": 0.3265171478797315, "crystalbleu": 0, "codebertscore": 0.78, "codescore": 0.9647253155708313, "surfaceSim": 0.7003553099091986, "abs_surfaceSim_minus_score": 0.1565446900908014, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_42_20", "golden_code": "import re\r\ndef end_num(string):\r\n    text = re.compile(r\".*[0-9]$\")\r\n    if text.match(string):\r\n        return True\r\n    else:\r\n        return False", "generated_code": "import re\ndef end_num(string):\n\treturn True if not bool(re.match(\"[A-Z]\", string)) else False", "score": 0.2187, "codebleu": 0.3147928604679995, "crystalbleu": 0, "codebertscore": 0.85, "codescore": 0.11092383414506912, "surfaceSim": 0.645413870246085, "abs_surfaceSim_minus_score": 0.426713870246085, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0678_18", "golden_code": "numbers = []\nhighest = 0\nfor _ in range(int(input())):\n\tnumbers.append(int(input()))\n\tif highest < sum(numbers)/len(numbers): highest = sum(numbers)/len(numbers)\nprint(highest)\n\n\"\"\"\nFOO = sum(input)\nBAR = number input\nBAZ = 0\nQUZ = 0\n#BOTH SAEM ( \n\tBIGGR OF (\n\t\t(PRODUKT OF FOO AN QUZ) \n\t\tAN (PRODUKT OF BAR BAZ)\n\t) \n\tAN (PRODUKT OF FOO AN QUZ))\"\"\"", "generated_code": "#!/usr/bin/env python3\nimport math\n\ndef f(x):\n\treturn math.sqrt(x)\n\ndef __starting_point():\n\tsum = 0\n\tn = int(input())\n\tfor t in range(n):\n\t\tsum += f(int(input()))\n\tprint(sum / f(n))\n\n__starting_point()\n", "score": 0.0212, "codebleu": 0.24511879789918406, "crystalbleu": 0, "codebertscore": 0.69, "codescore": 0.11586537957191467, "surfaceSim": 0.35344827586206895, "abs_surfaceSim_minus_score": 0.33224827586206895, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0192_14", "golden_code": "y, x = list(map(int, input(). split()))\na = x; b = x; c = x; k = 0\nwhile a < y or b < y or c < y:\n    if a < c+b-1:\n        a = c+b-1\n        k += 1\n        if a >= y and b >= y and c >= y:\n            break\n    if b < a+c-1:\n        b = a+c-1\n        k += 1\n        if a >= y and b >= y and c >= y:\n            break\n    if c < a+b-1:\n        c = a+b-1\n        k += 1\n        if a >= y and b >= y and c >= y:\n            break\nprint(k)\n", "generated_code": "x, y = map(int, input().split())\n\nt = int(x ** 2 + y ** 2)\n\nif x > y:\n\tt -= y - x\n\twhile y > x:\n\t\tt -= x - y\n\t\ty -= x\n\tt += y\n\tprint(t)\n\treturn\nelif y < x:\n\tt(-y - x)\n\twhile x > 0:\n\t\tt(-x - y)\n\t\ty -= 1\n\tt += x\n\tprint(i)\n\treturnt\n\nprint(t) if t >= 0 else print(abs(t))\n", "score": 0.0, "codebleu": 0.17751438414107215, "crystalbleu": 0.09, "codebertscore": 0.74, "codescore": 0.03944370523095131, "surfaceSim": 0.628501538704332, "abs_surfaceSim_minus_score": 0.628501538704332, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_11_18", "golden_code": "def lcm(x, y):\r\n   if x > y:\r\n       z = x\r\n   else:\r\n       z = y\r\n   while(True):\r\n       if((z % x == 0) and (z % y == 0)):\r\n           lcm = z\r\n           break\r\n       z += 1\r\n   return lcm", "generated_code": "def lcm(x, y):\n\tif x == y:\n\t\treturn x\n\telse:\n\t\ti = x if x > y else y\n\t\tif i == i:\n\t\t\treturn x\n\t\telse:\n\t\t\tp = int(x / i)\n\t\t\treturn p * i", "score": 0.3491, "codebleu": 0.2507196057594547, "crystalbleu": 0, "codebertscore": 0.79, "codescore": 0.10200396925210953, "surfaceSim": 0.6171689135606662, "abs_surfaceSim_minus_score": 0.26806891356066614, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_MBPP_223_MUT_20", "golden_code": "import os\n\ndef is_majority(arr, n, x):\n    i = binary_search(arr, 0, n - 1, x)\n    if i == -1:\n        return False\n    if (i + (n // 2) <= n - 1 and arr[i + (n // 2)] == x):\n        return True\n    else:\n        return False\ndef binary_search(arr, low, high, x):\n    if high >= low:\n        mid = (low + high) // 2\n        if ((mid == 0 or x > arr[mid - 1]) and arr[mid] == x):\n            return mid\n        elif x > arr[mid]:\n            return binary_search(arr, mid + 1, high, x)\n        else:\n            return binary_search(arr, low, mid - 1, x)\n    return -1", "generated_code": "import os\n\ndef is_majority(arr, n, x):\n    i = binary_search(arr, 0, n - 1, x)\n    if i == -1:\n        return False\n    if not ((i + (n // 2) <= n - 1 and arr[i + (n // 2)] == x)):\n        return True\n    else:\n        return False\ndef binary_search(arr, low, high, x):\n    if high >= low:\n        mid = (low + high) // 2\n        if ((mid == 0 or x > arr[mid - 1]) and arr[mid] == x):\n            return mid\n        elif x > arr[mid]:\n            return binary_search(arr, mid + 1, high, x)\n        else:\n            return binary_search(arr, low, mid - 1, x)\n    return -1", "score": 0.2426, "codebleu": 0.9578389030212413, "crystalbleu": 0.94, "codebertscore": 1.0, "codescore": 0.9936396479606628, "surfaceSim": 0.9795079659967347, "abs_surfaceSim_minus_score": 0.7369079659967347, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_HE_161_MUT_13", "golden_code": "import os\n\ndef solve(s):\n    flg = 0\n    idx = 0\n    new_str = list(s)\n    for i in s:\n        if i.isalpha():\n            new_str[idx] = i.swapcase()\n            flg = 1\n        idx += 1\n    s = ''\n    for i in new_str:\n        s += i\n    if flg == 0:\n        return s[len(s)::-1]\n    return s", "generated_code": "import os\n\ndef solve(s):\n    flg = 0\n    idx = 0\n    new_str = list(s)\n    for i in s:\n        if i.isalpha():\n            new_str[idx] = i.swapcase()\n            flg = 1\n        idx += 1\n    s = ''\n    for i in new_str:\n        s += i\n    if flg != 0:\n        return s[len(s)::-1]\n    return s", "score": 0.4483, "codebleu": 0.9719957368612442, "crystalbleu": 0, "codebertscore": 1.0, "codescore": 0.9937083721160889, "surfaceSim": 0.9598377812663528, "abs_surfaceSim_minus_score": 0.5115377812663529, "source": "local", "local_type": "MUT"}
{"id": "MBPP_70_41", "golden_code": "def is_abundant(n):\r\n    fctrsum = sum([fctr for fctr in range(1, n) if n % fctr == 0])\r\n    return fctrsum > n", "generated_code": "def is_abundant(n):    return True if n is not None and n > 0 and int(n) > 0 else False", "score": 0.3333, "codebleu": 0.10887461248935126, "crystalbleu": 0, "codebertscore": 0.8, "codescore": 0.4118805527687073, "surfaceSim": 0.5202702702702703, "abs_surfaceSim_minus_score": 0.1869702702702703, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_extra_p03038_s817533229_OP_1", "golden_code": "I=lambda:list(map(int,input().split()))\n\nn,m=I()\n\na=I()\n\na.sort(reverse=True)\n\nqq=[I() for i in range(m)]\n\nqq.sort(key=lambda x:x[1],reverse=True)\n\nans=0\n\nfor x,y in qq:\n\n    for j in range(x):\n\n        if not a:\n\n            break\n\n        aa=a.pop()\n\n        ans+=max(aa,y)\n\nans+=sum(a)\n\nprint(ans)\n\n        ", "generated_code": "I=lambda : list(map(int,input().split()))\n\nn,m = I()\n\nl=I();s=sum(l);l.sort();d=[]\n\nfor _ in range(m):\n\n    b,c=I()\n\n    d.append([c,b])\n\np=s=0    \n\nfor i in sorted(d,reverse=True):\n\n    while i[1]:\n\n        if p>=n or l[p]>=i[0]:\n\n            break\n\n        i[1]-=1\n\n        s+=i[0]\n\n        p+=1\n\n    if p>=n:\n\n        break\n\ns+=sum(l[p:])\n\nprint(s)", "score": 1.0, "codebleu": 0.31348662221845847, "crystalbleu": 0.26, "codebertscore": 0.82, "codescore": 0.9501758813858032, "surfaceSim": 0.6064491064491064, "abs_surfaceSim_minus_score": 0.39355089355089357, "source": "local", "local_type": "OP"}
{"id": "LOCAL_APPS_1315_2_MUT_5", "golden_code": "import math, string, itertools, fractions, heapq, collections, re, array, bisect, copy\nfrom itertools import chain, dropwhile, permutations, combinations\nfrom collections import defaultdict, deque\n\ndef VI():\n    return list(map(int, input().split()))\ndef run(n, a):\n    b = copy.copy(a)\n    for i in range(n):\n        b[i] -= n - i\n    b.sort()\n    for i in range(n):\n        if i < n - 1:\n            if b[i] == b[i + 1]:\n                print(':(')\n                return\n        b[i] = str(b[i] + (n - i))\n    print(' '.join(b))\n\n\ndef main(info=0):\n    n = int(input())\n    a = VI()\n    run(n, a)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "generated_code": "import math, string, itertools, fractions, heapq, collections, re, array, bisect, copy\nfrom itertools import chain, dropwhile, permutations, combinations\nfrom collections import defaultdict, deque\n\ndef VI():\n    return list(map(int, input().split()))\ndef run(n, a):\n    b = copy.copy(a)\n    for i in range(n):\n        b[i] -= n - i\n    b.sort()\n    for i in range(n):\n        if i < n - 1:\n            if b[i] == b[i + 1]:\n                print(':(')\n                return\n        b[i] = str(b[i] + (n + i))\n    print(' '.join(b))\n\n\ndef main(info=0):\n    n = int(input())\n    a = VI()\n    run(n, a)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "score": 0.172, "codebleu": 0.9852085737132208, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9938775897026062, "surfaceSim": 0.999236641221374, "abs_surfaceSim_minus_score": 0.8272366412213741, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_PIE_p00144_s682125154_MUT_20", "golden_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "generated_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] - self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "score": 0.0, "codebleu": 0.9945883912637858, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9934750199317932, "surfaceSim": 0.9869512808809933, "abs_surfaceSim_minus_score": 0.9869512808809933, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-1787_2", "golden_code": "m = 10**9+7\n\ns = input()\n\nr = x = 1\nfor c in s:\n    if c == 'b':\n        r = (r * x) % m\n        x = 1\n    elif c == 'a':\n        x += 1\nr = (r * x) % m\n\nprint(r - 1)\n", "generated_code": "import sys\ninput = sys.stdin.readline\n\nMOD = 10**9 + 7\n\nS = input().strip()\n\na = ord('a')\narr = [1] * len(S)\nfor i in range(1, len(S)):\n\tif S[i] == 'b':\n\t\tarr[i] = arr[i - 1] * 2 % MOD\n\telse:\n\t\tarr[ i ] = arr[i-1]\n\t\t\nprint(arr[-1])\n", "score": 0.0012, "codebleu": 0.14052132755107477, "crystalbleu": 0, "codebertscore": 0.79, "codescore": 0.13247595727443695, "surfaceSim": 0.555316091954023, "abs_surfaceSim_minus_score": 0.554116091954023, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_extra_p02725_s591694965_OP_1", "golden_code": "k, n = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\n\n\ndiff = []\n\n\n\nfor i in range(n - 1):\n\n    diff.append(a[i + 1] - a[i])\n\ndiff.append(k - a[-1] + a[0])\n\n\n\nprint((k - max(diff)))\n", "generated_code": "k, n = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\n\n\na.append(k + a[0])\n\ndiff = [a1 - a0 for a0, a1 in zip(a, a[1:])]\n\n\n\nprint((k - max(diff)))\n", "score": 1.0, "codebleu": 0.5084277869685716, "crystalbleu": 0.46, "codebertscore": 0.91, "codescore": 0.09837650507688522, "surfaceSim": 0.6952780229479258, "abs_surfaceSim_minus_score": 0.30472197705207416, "source": "local", "local_type": "OP"}
{"id": "MBPP_34_38", "golden_code": "def even_num(x):\r\n  if x%2==0:\r\n     return True\r\n  else:\r\n    return False", "generated_code": "def even_num(x): \n\treturn x % 2==0", "score": 1.0, "codebleu": 0.3410181894875992, "crystalbleu": 0, "codebertscore": 0.85, "codescore": 0.9934850335121155, "surfaceSim": 0.7482051282051282, "abs_surfaceSim_minus_score": 0.2517948717948718, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_197_2", "golden_code": "from array import array\r\ndef negative_count(nums):\r\n    n = len(nums)\r\n    n1 = 0\r\n    for x in nums:\r\n        if x < 0:\r\n            n1 += 1\r\n        else:\r\n          None\r\n    return round(n1/n,2)", "generated_code": "from array import array\ndef negative_count(nums):         return list(filter(lambda x: x < 0, nums))\nduplicatecheck = lambda x: x in duplicates\n\n\nn = 2\ncount = 0\nwhile count < n:\n\tprint(count)\n\tcount += 1", "score": 0.0, "codebleu": 0.3361317759279486, "crystalbleu": 0, "codebertscore": 0.8, "codescore": 0.01822475530207157, "surfaceSim": 0.6247058823529412, "abs_surfaceSim_minus_score": 0.6247058823529412, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_15_OP_1", "golden_code": "def string_sequence(n: int) -> str:\n    return ' '.join([str(x) for x in range(n + 1)])", "generated_code": "def string_sequence(limit: int) -> str:\n    return ' '.join(map(str, range(limit + 1)))", "score": 1.0, "codebleu": 0.38835003092714904, "crystalbleu": 0, "codebertscore": 0.92, "codescore": 0.9933789968490601, "surfaceSim": 0.7735632183908046, "abs_surfaceSim_minus_score": 0.22643678160919545, "source": "local", "local_type": "OP"}
{"id": "MBPP_76_17", "golden_code": "def word_len(s): \r\n    s = s.split(' ')   \r\n    for word in s:    \r\n        if len(word)%2==0: \r\n            return True  \r\n        else:\r\n          return False", "generated_code": "def word_len(s): \n\treturn len(s) % 2 == 0\n\n\t   \nh = ['a','b','c']", "score": 0.9398, "codebleu": 0.193466492238485, "crystalbleu": 0, "codebertscore": 0.77, "codescore": 0.9935808181762695, "surfaceSim": 0.7115070284406668, "abs_surfaceSim_minus_score": 0.22829297155933315, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_71_31", "golden_code": "import math\r\ndef get_First_Set_Bit_Pos(n):\r\n     return math.log2(n&-n)+1", "generated_code": "import math\ndef get_First_Set_Bit_Pos(n):\n\t\n\treturn float(n) / 2", "score": 0.0695, "codebleu": 0.48293245475860336, "crystalbleu": 0, "codebertscore": 0.88, "codescore": 0.1053122952580452, "surfaceSim": 0.7511415525114156, "abs_surfaceSim_minus_score": 0.6816415525114156, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_33_2", "golden_code": "def count_Unset_Bits(n) :  \r\n    cnt = 0;  \r\n    for i in range(1,n + 1) : \r\n        temp = i;  \r\n        while (temp) :  \r\n            if (temp % 2 == 0) : \r\n                cnt += 1;  \r\n            temp = temp // 2;  \r\n    return cnt;  ", "generated_code": "def count_Unset_Bits(N):\n\n\tif (N & (N-1)) == 0:\n\t\treturn N\n\telse:\n\t\tx = N.bit_length()\n\t\ts = N >> 1\n\t\tc = N&0x55555555\n\t\treturn (((x*(x+1))//2)*c) + ox\n\traise ValueError", "score": 0.123, "codebleu": 0.15266989742781, "crystalbleu": 0, "codebertscore": 0.73, "codescore": 0.03720255196094513, "surfaceSim": 0.6110333022097728, "abs_surfaceSim_minus_score": 0.4880333022097728, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_643_10_MUT_82", "golden_code": "def gcd(a, b):\n    if b > a:\n        return gcd(b, a)\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef works(a, b, c, d, x):\n    return (b <= d * x and a <= c * x and (d * x) - b >= (c * x) - a)\n\ndef solve():\n    (a, b, c, d) = list(map(int, input().rstrip().split()))\n    if (c == d == 1 and not (a / b == 1)):\n        print(-1)\n        return\n    if (c == 0 and not (a == 0)):\n        print(-1)\n        return\n    g = gcd(c, d)\n    c //= g\n    d //= g\n    low = -1\n    high = 1000000000000\n    while low + 1 < high:\n        mid = (low + high) // 2\n        if works(a, b, c, d, mid):\n            high = mid\n        else:\n            low = mid\n    print((d * high) - b)\n\ndef __starting_point():\n    t = int(input())\n    for _ in range(t):\n        solve()\n\n__starting_point()", "generated_code": "def gcd(a, b):\n    if b > a:\n        return gcd(b, a)\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef works(a, b, c, d, x):\n    return (b <= d * x and a <= c * x and (d * x) - b >= (c * x) - a)\n\ndef solve():\n    (a, b, c, d) = list(map(int, input().rstrip().split()))\n    if (c == d == 1 and not (a / b == 1)):\n        print(-1)\n        return\n    if (c == 0 and not (a == 0)):\n        print(-1)\n        return\n    g = gcd(c, d)\n    c //= g\n    d //= g\n    low = -1\n    high = 1000000000000\n    while low + 1 < high:\n        pass\n        if works(a, b, c, d, mid):\n            high = mid\n        else:\n            low = mid\n    print((d * high) - b)\n\ndef __starting_point():\n    t = int(input())\n    for _ in range(t):\n        solve()\n\n__starting_point()", "score": 0.357, "codebleu": 0.9241072782978837, "crystalbleu": 0.95, "codebertscore": 0.99, "codescore": 0.7341152429580688, "surfaceSim": 0.9756859782272743, "abs_surfaceSim_minus_score": 0.6186859782272743, "source": "local", "local_type": "MUT"}
{"id": "MBPP_20_38", "golden_code": "def is_odd(n) : \r\n    if (n^1 == n-1) :\r\n        return True; \r\n    else :\r\n        return False; ", "generated_code": "def is_odd(n): return not n & (n == 13)", "score": 0.4319, "codebleu": 0.27759345225242715, "crystalbleu": 0, "codebertscore": 0.81, "codescore": 0.6322906613349915, "surfaceSim": 0.6296518607442978, "abs_surfaceSim_minus_score": 0.1977518607442978, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_31_9", "golden_code": "def smallest_multiple(n):\r\n    if (n<=2):\r\n      return n\r\n    i = n * 2\r\n    factors = [number  for number in range(n, 1, -1) if number * 2 > n]\r\n    while True:\r\n        for a in factors:\r\n            if i % a != 0:\r\n                i += n\r\n                break\r\n            if (a == factors[-1] and i % a == 0):\r\n                return i", "generated_code": "def smallest_multiple(n):return 1 if n == 1 else 0", "score": 0.1573, "codebleu": 0.03152309874524069, "crystalbleu": 0, "codebertscore": 0.72, "codescore": 0.1511165350675583, "surfaceSim": 0.4329825771951009, "abs_surfaceSim_minus_score": 0.2756825771951009, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_80_6", "golden_code": "def maximum_segments(n, a, b, c) : \r\n\tdp = [-1] * (n + 10) \r\n\tdp[0] = 0\r\n\tfor i in range(0, n) : \r\n\t\tif (dp[i] != -1) : \r\n\t\t\tif(i + a <= n ): \r\n\t\t\t\tdp[i + a] = max(dp[i] + 1, \r\n\t\t\t\t\t\t\tdp[i + a]) \r\n\t\t\tif(i + b <= n ): \r\n\t\t\t\tdp[i + b] = max(dp[i] + 1, \r\n\t\t\t\t\t\t\tdp[i + b]) \r\n\t\t\tif(i + c <= n ): \r\n\t\t\t\tdp[i + c] = max(dp[i] + 1, \r\n\t\t\t\t\t\t\tdp[i + c]) \r\n\treturn dp[n]", "generated_code": "def maximum_segments(n, a, b, c) : \n\tif a is 1 and b is 1 and c is 1:    return 2 \n\telif a == 1 and b == 1 and c == 1:  return 1\n\telif (a == 1 and f == 0) or (c == 1 and a == 0) :  return (2)\n\telse:                return max(b*2, a)", "score": 0.0665, "codebleu": 0.10042857428923185, "crystalbleu": 0.07, "codebertscore": 0.73, "codescore": 0.01896485686302185, "surfaceSim": 0.5019157088122606, "abs_surfaceSim_minus_score": 0.43541570881226055, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_140_MUT_47", "golden_code": "import os\n\ndef fix_spaces(text):\n    new_text = ''\n    i = 0\n    (start, end) = (0, 0)\n    while i < len(text):\n        if text[i] == ' ':\n            end += 1\n        else:\n            if end - start > 2:\n                new_text += '-' + text[i]\n            elif end - start > 0:\n                new_text += ('_' * (end - start)) + text[i]\n            else:\n                new_text += text[i]\n            (start, end) = (i + 1, i + 1)\n        i += 1\n    if end - start > 2:\n        new_text += '-'\n    elif end - start > 0:\n        new_text += '_'\n    return new_text", "generated_code": "import os\n\ndef fix_spaces(text):\n    new_text = ''\n    i = 0\n    (start, end) = (0, 0)\n    while i < len(text):\n        break\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    if end - start > 2:\n        new_text += '-'\n    elif end - start > 0:\n        new_text += '_'\n    return new_text", "score": 0.2041, "codebleu": 0.39549516332627266, "crystalbleu": 0.24, "codebertscore": 0.9, "codescore": 0.23537252843379974, "surfaceSim": 0.7651002506265664, "abs_surfaceSim_minus_score": 0.5610002506265663, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_PIE_p02574_s911286307_MUT_3", "golden_code": "import math, sys\nn = int(sys.stdin.readline())\na = tuple(map(int, sys.stdin.readline().split()))\ng = math.gcd(a[0], a[1])\nfor i in range(2, n):\n    g = math.gcd(g, a[i])\nM = max(a)\nacc = a[0]\nfor i in range(n):\n    acc = math.gcd(acc, a[i])\nif acc != 1:\n    print('not coprime')\n    exit()\nLIMIT = max(a)\nminPrime = [0] * (LIMIT + 1)\nminPrime[1] = 1\ndef make():\n    for i in range(2, LIMIT + 1):\n        if minPrime[i] == 0:\n            minPrime[i] = i\n            for j in range(i + i, LIMIT + 1, i):\n                if minPrime[j] == 0:\n                    minPrime[j] = i\nmake()\ndef factrial(N):\n    ret = []\n    while minPrime[N] != N:\n        ret.append(minPrime[N])\n        N = N // minPrime[N]\n    if N != 1:\n        ret.append(N)\n    return ret\njudge = set([])\npc = True\npairwise = True\np = set()\nfor e in a:\n    if not pairwise:\n        break\n    asf = set(factrial(e))\n    if judge & asf != set():\n        pc = False\n    judge |= asf\nif pc:\n    print('pairwise coprime')\nelif g == 1:\n    print('setwise coprime')\nelse:\n    print('not coprime')", "generated_code": "import math, sys\nn = int(sys.stdin.readline())\na = tuple(map(int, sys.stdin.readline().split()))\ng = math.gcd(a[0], a[1])\nfor i in range(2, n):\n    g = math.gcd(g, a[i])\nM = max(a)\nacc = a[0]\nfor i in range(n):\n    acc = math.gcd(acc, a[i])\nif acc != 1:\n    print('not coprime')\n    exit()\nLIMIT = max(a)\nminPrime = [0] ** (LIMIT + 1)\nminPrime[1] = 1\ndef make():\n    for i in range(2, LIMIT + 1):\n        if minPrime[i] == 0:\n            minPrime[i] = i\n            for j in range(i + i, LIMIT + 1, i):\n                if minPrime[j] == 0:\n                    minPrime[j] = i\nmake()\ndef factrial(N):\n    ret = []\n    while minPrime[N] != N:\n        ret.append(minPrime[N])\n        N = N // minPrime[N]\n    if N != 1:\n        ret.append(N)\n    return ret\njudge = set([])\npc = True\npairwise = True\np = set()\nfor e in a:\n    if not pairwise:\n        break\n    asf = set(factrial(e))\n    if judge & asf != set():\n        pc = False\n    judge |= asf\nif pc:\n    print('pairwise coprime')\nelif g == 1:\n    print('setwise coprime')\nelse:\n    print('not coprime')", "score": 0.0318, "codebleu": 0.9922827580424717, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9937136769294739, "surfaceSim": 0.9709541881268636, "abs_surfaceSim_minus_score": 0.9391541881268636, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-1312_19", "golden_code": "n, m = map(int, input().split())\nprint(*([n // m + 1] * (n % m) + [n // m] * (m - n % m)))", "generated_code": "n, m = list(map(int, input().split()))\nans = [0] * (m + 1)\nnow = 1\nfor i in range(n):\n\tans[i + 1] = now if ans[i] == now else now - 1\n\tnow += 1\nprint(' '.join(map(str, ans)))\n", "score": 0.0, "codebleu": 0.19372846949767056, "crystalbleu": 0, "codebertscore": 0.81, "codescore": 0.03389279544353485, "surfaceSim": 0.5228571428571429, "abs_surfaceSim_minus_score": 0.5228571428571429, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_MBPP_69_OP_1", "golden_code": "def is_sublist(l, s):\r\n\tsub_set = False\r\n\tif s == []:\r\n\t\tsub_set = True\r\n\telif s == l:\r\n\t\tsub_set = True\r\n\telif len(s) > len(l):\r\n\t\tsub_set = False\r\n\telse:\r\n\t\tfor i in range(len(l)):\r\n\t\t\tif l[i] == s[0]:\r\n\t\t\t\tn = 1\r\n\t\t\t\twhile (n < len(s)) and (l[i+n] == s[n]):\r\n\t\t\t\t\tn += 1\t\t\t\t\r\n\t\t\t\tif n == len(s):\r\n\t\t\t\t\tsub_set = True\r\n\treturn sub_set", "generated_code": "def is_sublist(main_list, sub_list):\n    if not sub_list:\n        return True\n    if len(sub_list) > len(main_list):\n        return False\n    sub_len = len(sub_list)\n    for index in range(len(main_list) - sub_len + 1):\n        if main_list[index:index + sub_len] == sub_list:\n            return True\n    return False", "score": 1.0, "codebleu": 0.1403796349361574, "crystalbleu": 0.07, "codebertscore": 0.8, "codescore": 0.9938936829566956, "surfaceSim": 0.5845238095238094, "abs_surfaceSim_minus_score": 0.41547619047619055, "source": "local", "local_type": "OP"}
{"id": "APPS_test-3786_53", "golden_code": "import sys\nimport bisect\n# from collections import deque\n\nRi = lambda : [int(x) for x in sys.stdin.readline().split()]\nri = lambda : sys.stdin.readline().strip()\n \ndef input(): return sys.stdin.readline().strip()\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\ndef ceil(x, y=1): return int(-(-x // y))\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef NO(): print('NO')\nINF = 10 ** 30  \nMOD = 998244353\n\nn = int(ri())\na  = Ri()\n\ndic = {}\nfor i in range(len(a)):\n    if a[i] == 1:\n        dic[i+2] = 1\n    else:\n        time = dic[a[i]]\n        dic[i+2] = time+1\ncnt = 0\ntime = {}\nfor i in dic:\n    if dic[i] in time:\n        time[dic[i]]+=1\n    else:\n        time[dic[i]] = 1\n    \nfor i in time:\n    cnt +=(time[i]%2)\nprint(cnt+1)", "generated_code": "n=int(input())\na=list(map(int,input().split()))\na.sort()\nx=0\nfor i in range(0,n):\n\tif a[i]<a[i+1]:\n\t\tx=x+1\nprint(x)\n", "score": 0.1952, "codebleu": 0.10278783444010992, "crystalbleu": 0.0, "codebertscore": 0.71, "codescore": 0.2243768870830536, "surfaceSim": 0.36026924243484754, "abs_surfaceSim_minus_score": 0.16506924243484752, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_81_MUT_10", "golden_code": "import os\n\ndef numerical_letter_grade(grades):\n    \n    \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append('A+')\n        elif gpa > 3.7:\n            letter_grade.append('A')\n        elif gpa > 3.3:\n            letter_grade.append('A-')\n        elif gpa > 3.0:\n            letter_grade.append('B+')\n        elif gpa > 2.7:\n            letter_grade.append('B')\n        elif gpa > 2.3:\n            letter_grade.append('B-')\n        elif gpa > 2.0:\n            letter_grade.append('C+')\n        elif gpa > 1.7:\n            letter_grade.append('C')\n        elif gpa > 1.3:\n            letter_grade.append('C-')\n        elif gpa > 1.0:\n            letter_grade.append('D+')\n        elif gpa > 0.7:\n            letter_grade.append('D')\n        elif gpa > 0.0:\n            letter_grade.append('D-')\n        else:\n            letter_grade.append('E')\n    return letter_grade", "generated_code": "import os\n\ndef numerical_letter_grade(grades):\n    \n    \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append('A+')\n        elif gpa > 3.7:\n            letter_grade.append('A')\n        elif gpa > 3.3:\n            letter_grade.append('A-')\n        elif gpa > 3.0:\n            letter_grade.append('B+')\n        elif gpa > 2.7:\n            letter_grade.append('B')\n        elif gpa > 2.3:\n            letter_grade.append('B-')\n        elif gpa > 2.0:\n            letter_grade.append('C+')\n        elif gpa > 1.7:\n            letter_grade.append('C')\n        elif gpa > 1.3:\n            letter_grade.append('C-')\n        elif not (gpa > 1.0):\n            letter_grade.append('D+')\n        elif gpa > 0.7:\n            letter_grade.append('D')\n        elif gpa > 0.0:\n            letter_grade.append('D-')\n        else:\n            letter_grade.append('E')\n    return letter_grade", "score": 0.0726, "codebleu": 0.9553751307305812, "crystalbleu": 0.94, "codebertscore": 0.99, "codescore": 0.9937035441398621, "surfaceSim": 0.9538072983052448, "abs_surfaceSim_minus_score": 0.8812072983052448, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_HE_152_OP_1", "golden_code": "def compare(game,guess):\n    return [abs(x-y) for x,y in zip(game,guess)]", "generated_code": "from functools import lru_cache\n\ndef compare(secret, attempt):\n    @lru_cache(None)\n    def calculate_difference(a, b):\n        return abs(a - b)\n    return [calculate_difference(a, b) for a, b in zip(secret, attempt)]", "score": 1.0, "codebleu": 0.36224644403864603, "crystalbleu": 0, "codebertscore": 0.78, "codescore": 0.6888132095336914, "surfaceSim": 0.6044252563410686, "abs_surfaceSim_minus_score": 0.3955747436589314, "source": "local", "local_type": "OP"}
{"id": "LOCAL_APPS_47_12_MUT_8", "golden_code": "(n, x) = map(int, input().split())\nA = list(map(int, input().split()))\nDP = [[0] * 3 for _ in range(n + 1)]\nans = 0\nfor i in range(1, n + 1):\n    DP[i][0] = max(DP[i - 1][0] + A[i - 1], A[i - 1])\n    DP[i][1] = max(DP[i - 1][0] + (A[i - 1] * x), DP[i - 1][1] + (A[i - 1] * x), A[i - 1] * x)\n    DP[i][2] = max(DP[i - 1][1] + A[i - 1], DP[i - 1][2] + A[i - 1], A[i - 1])\n    ans = max(ans, max(DP[i]))\nprint(ans)", "generated_code": "(n, x) = map(int, input().split())\nA = list(map(int, input().split()))\nDP = [[0] * 3 for _ in range(n + 1)]\nans = 0\nfor i in range(1, n + 1):\n    DP[i][0] = max(DP[i - 1][0] + A[i + 1], A[i - 1])\n    DP[i][1] = max(DP[i - 1][0] + (A[i - 1] * x), DP[i - 1][1] + (A[i - 1] * x), A[i - 1] * x)\n    DP[i][2] = max(DP[i - 1][1] + A[i - 1], DP[i - 1][2] + A[i - 1], A[i - 1])\n    ans = max(ans, max(DP[i]))\nprint(ans)", "score": 0.0, "codebleu": 0.9860116946342178, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.9938510656356812, "surfaceSim": 0.9987834549878345, "abs_surfaceSim_minus_score": 0.9987834549878345, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_PIE_p02264_s309974156_MUT_9", "golden_code": "class Queue:\n    def __init__(self, values):\n        self.values = values\n    def empty(self):\n        if len(self.values) == 0:\n            return True\n        else:\n            return False\n    def enqueue(self, v):\n        self.values.append(v)\n    def dequeue(self):\n        if len(self.values) <= 0:\n            raise\n        else:\n            v = self.values[0]\n            del self.values[0]\n            return v\n(n, q) = list(map(int, input().split(' ')))\nprocesses = []\nfor i in range(n):\n    (n, t) = input().split(' ')\n    processes.append((n, int(t)))\nqueue = Queue(processes)\nclock = 0\ndone = []\nwhile not (queue.empty()):\n    p = queue.dequeue()\n    n = p[0]\n    t = p[1]\n    if t <= q:\n        clock += t\n        done.append((n, clock))\n    else:\n        queue.enqueue((n, t - q))\n        clock += q\nfor p in done:\n    print(p[0], p[1])", "generated_code": "class Queue:\n    def __init__(self, values):\n        self.values = values\n    def empty(self):\n        if not (len(self.values) == 0):\n            return True\n        else:\n            return False\n    def enqueue(self, v):\n        self.values.append(v)\n    def dequeue(self):\n        if len(self.values) <= 0:\n            raise\n        else:\n            v = self.values[0]\n            del self.values[0]\n            return v\n(n, q) = list(map(int, input().split(' ')))\nprocesses = []\nfor i in range(n):\n    (n, t) = input().split(' ')\n    processes.append((n, int(t)))\nqueue = Queue(processes)\nclock = 0\ndone = []\nwhile not (queue.empty()):\n    p = queue.dequeue()\n    n = p[0]\n    t = p[1]\n    if t <= q:\n        clock += t\n        done.append((n, clock))\n    else:\n        queue.enqueue((n, t - q))\n        clock += q\nfor p in done:\n    print(p[0], p[1])", "score": 0.0, "codebleu": 0.966179082488088, "crystalbleu": 0.97, "codebertscore": 1.0, "codescore": 0.9936909675598145, "surfaceSim": 0.9970828471411902, "abs_surfaceSim_minus_score": 0.9970828471411902, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-1176_20", "golden_code": "n = int(input())\na = list(map(int, input().split()))\n\na.sort()\nminus = n\nfor i in range(n):\n  if a[i] >= 0:\n    minus = i\n    break\n\na = list(map(abs, a))\na.sort()\n\nif minus % 2 == 0:\n  print((sum(a)))\nelse:\n  print((sum(a) - 2 * a[0]))\n", "generated_code": "n = int(input())\na = list(map(int, input().split()))\nb = [0] * n\nb[0] = a[0]\nfor i in range(1, n):\n\tb[i] = a[i] * -1\n\nfor i in a[1:]:\n\tb[n-1] = max(b[n-2], i)\n\nans = 0\nfor i in reversed(range(n)):\n\tif b[i] == 0:\n\t\tans = max(ans, b[i])\n\telif b[i+1] == 0:ans = max(reversed(ans), b[i] * b[i+set(a[i:])])\nprint(ans)\n", "score": 0.0, "codebleu": 0.3673564027885663, "crystalbleu": 0.19, "codebertscore": 0.82, "codescore": 0.052292656153440475, "surfaceSim": 0.5969525681985746, "abs_surfaceSim_minus_score": 0.5969525681985746, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_MBPP_231_OP_1", "golden_code": "def max_sum(tri, n): \r\n\tif n > 1: \r\n\t\ttri[1][1] = tri[1][1]+tri[0][0] \r\n\t\ttri[1][0] = tri[1][0]+tri[0][0] \r\n\tfor i in range(2, n): \r\n\t\ttri[i][0] = tri[i][0] + tri[i-1][0] \r\n\t\ttri[i][i] = tri[i][i] + tri[i-1][i-1] \r\n\t\tfor j in range(1, i): \r\n\t\t\tif tri[i][j]+tri[i-1][j-1] >= tri[i][j]+tri[i-1][j]: \r\n\t\t\t\ttri[i][j] = tri[i][j] + tri[i-1][j-1] \r\n\t\t\telse: \r\n\t\t\t\ttri[i][j] = tri[i][j]+tri[i-1][j] \r\n\treturn (max(tri[n-1]))", "generated_code": "def max_sum(pyramid, size):\n    if size <= 1:\n        return max(pyramid[0]) if size == 1 else 0\n    pyramid[1][1] += pyramid[0][0]\n    pyramid[1][0] += pyramid[0][0]\n    for row in range(2, size):\n        pyramid[row][0] += pyramid[row-1][0]\n        pyramid[row][row] += pyramid[row-1][row-1]\n        for col in range(1, row):\n            pyramid[row][col] += max(pyramid[row-1][col-1], pyramid[row-1][col])\n    return max(pyramid[size-1])", "score": 1.0, "codebleu": 0.27581362490418215, "crystalbleu": 0.13, "codebertscore": 0.85, "codescore": 0.9934253692626953, "surfaceSim": 0.5861363636363637, "abs_surfaceSim_minus_score": 0.4138636363636363, "source": "local", "local_type": "OP"}
{"id": "LOCAL_PIE_extra_p03796_s258128729_OP_1", "golden_code": "import math\n\n\n\nn = int(eval(input()))\n\n\n\nprint((math.factorial(n) % (10**9 + 7)))\n", "generated_code": "n = int(eval(input()))\n\n\n\nans = 1\n\n\n\nfor i in range(1, n+1):\n\n    ans *= i\n\n    ans %= 10**9 + 7\n\n\n\nprint(ans)\n", "score": 1.0, "codebleu": 0.2707437968737775, "crystalbleu": 0, "codebertscore": 0.83, "codescore": 0.9569054245948792, "surfaceSim": 0.5990990990990991, "abs_surfaceSim_minus_score": 0.4009009009009009, "source": "local", "local_type": "OP"}
{"id": "LOCAL_APPS_2645_55_MUT_18", "golden_code": "ans = 0\n\nfor (i, c) in enumerate(input()):\n    if (i % 2 == 0 and c == 'p'):\n        ans -= 1elif (i % 2 == 1 and c == 'g'):ans += 1\n\nprint(ans)", "generated_code": "ans = 0\n\nfor (i, c) in enumerate(input()):\n    if (i % 2 == 0 and c == 'p'):\n        ans -= 1elif (i % 2 == 1 and c == 'g'):ans += 1\n\nprint(ans)", "score": 0.0, "codebleu": 1.0, "crystalbleu": 0, "codebertscore": 1.0, "codescore": 0.9935756325721741, "surfaceSim": 0.5, "abs_surfaceSim_minus_score": 0.5, "source": "local", "local_type": "MUT"}
{"id": "MBPP_40_32", "golden_code": "import datetime\r\ndef check_date(m, d, y):\r\n    try:\r\n        m, d, y = map(int, (m, d, y))\r\n        datetime.date(y, m, d)\r\n        return True\r\n    except ValueError:\r\n        return False", "generated_code": "import datetime\ndef check_date(m, d, y):\n\tif m == 0 or d == 0 or y == 0:\n\t\treturn False\n\td = int(d)\n\ty = int(y)\n\tm = int(m)\n\tif abs(m - m) == d or abs(d - d) == 0:\n\t  return False\n\telif abs(m-m) > d:\n\t  return false\n\telse:\n\t  return True", "score": 0.7998, "codebleu": 0.3559019379528967, "crystalbleu": 0, "codebertscore": 0.83, "codescore": 0.5864619612693787, "surfaceSim": 0.5305907172995781, "abs_surfaceSim_minus_score": 0.2692092827004219, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_140_MUT_11", "golden_code": "import os\n\ndef fix_spaces(text):\n    new_text = ''\n    i = 0\n    (start, end) = (0, 0)\n    while i < len(text):\n        if text[i] == ' ':\n            end += 1\n        else:\n            if end - start > 2:\n                new_text += '-' + text[i]\n            elif end - start > 0:\n                new_text += ('_' * (end - start)) + text[i]\n            else:\n                new_text += text[i]\n            (start, end) = (i + 1, i + 1)\n        i += 1\n    if end - start > 2:\n        new_text += '-'\n    elif end - start > 0:\n        new_text += '_'\n    return new_text", "generated_code": "import os\n\ndef fix_spaces(text):\n    new_text = ''\n    i = 0\n    (start, end) = (0, 0)\n    while i < len(text):\n        if text[i] == ' ':\n            end += 1\n        else:\n            if end - start > 2:\n                new_text += '-' + text[i]\n            elif end - start > 0:\n                new_text += ('_' * (end - start)) + text[i]\n            else:\n                new_text += text[i]\n            (start, end) = (i + 1, i + 1)\n        i += 1\n    if end + start > 2:\n        new_text += '-'\n    elif end - start > 0:\n        new_text += '_'\n    return new_text", "score": 0.4438, "codebleu": 0.985944862062112, "crystalbleu": 0.98, "codebertscore": 0.99, "codescore": 0.9937506318092346, "surfaceSim": 0.9991228070175439, "abs_surfaceSim_minus_score": 0.5553228070175439, "source": "local", "local_type": "MUT"}
{"id": "MBPP_34_5", "golden_code": "def even_num(x):\r\n  if x%2==0:\r\n     return True\r\n  else:\r\n    return False", "generated_code": "def even_num(x):\n\treturn True if x % 2 == 0 else False", "score": 1.0, "codebleu": 0.34728233107454914, "crystalbleu": 0, "codebertscore": 0.9, "codescore": 0.9936005473136902, "surfaceSim": 0.7819047619047619, "abs_surfaceSim_minus_score": 0.21809523809523812, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_0_MUT_17", "golden_code": "import os\n\nfrom typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    for (idx, elem) in enumerate(numbers):\n        for (idx2, elem2) in enumerate(numbers):\n            if idx != idx2:\n                distance = abs(elem - elem2)\n                if distance < threshold:\n                    return True\n    \n    return False", "generated_code": "import os\n\nfrom typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    for (idx, elem) in enumerate(numbers):\n        for (idx2, elem2) in enumerate(numbers):\n            if idx != idx2:\n                distance = abs(elem - elem2)\n                if distance < threshold:\n                    return True\n    \n    pass", "score": 0.0, "codebleu": 0.9457161353398157, "crystalbleu": 0.92, "codebertscore": 0.99, "codescore": 0.9937281608581543, "surfaceSim": 0.9677717391304348, "abs_surfaceSim_minus_score": 0.9677717391304348, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_HE_83_MUT_9", "golden_code": "import os\n\ndef starts_one_ends(n):\n    if n == 1:\n        return 1\n    return 18 * (10 ** (n - 2))", "generated_code": "import os\n\ndef starts_one_ends(n):\n    if n != 1:\n        return 1\n    return 18 * (10 ** (n - 2))", "score": 0.0, "codebleu": 0.9213221191205164, "crystalbleu": 0, "codebertscore": 0.99, "codescore": 0.9936071634292603, "surfaceSim": 0.9393424036281179, "abs_surfaceSim_minus_score": 0.9393424036281179, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-1000_68", "golden_code": "n, v = input().split()\nn = int(n)\nv = int(v)\n\nif (n <= v):\n    print(n-1)\nelse:\n    summ = v\n    for i in range(n-v-1):\n        summ += i+2\n    print(summ)\n", "generated_code": "def solve():\n\tn, v = map(int, input().split())\n\tans = 0\n\ta = [0] * n\n\tfor i in range(n):\n\t\ta[i] = int(input())\n\ta.sort()\n\tfor i, v in enumerate(a):\n\t\tif i - 1 + v > 0:\n\t\t\tans += 1 + a[i - 1 + v - 1]\n\tprint(ans)\n\nsolve()\n", "score": 0.0, "codebleu": 0.20354425233936813, "crystalbleu": 0, "codebertscore": 0.82, "codescore": 0.059738755226135254, "surfaceSim": 0.5922727272727273, "abs_surfaceSim_minus_score": 0.5922727272727273, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_79_13", "golden_code": "def min_of_two( x, y ):\r\n    if x < y:\r\n        return x\r\n    return y", "generated_code": "def min_of_two( x, y ):\n\tif x == y :\n\t\treturn x\n\telse:\n\t\treturn min( x,y)", "score": 1.0, "codebleu": 0.6234727339887757, "crystalbleu": 0, "codebertscore": 0.9, "codescore": 0.9937132000923157, "surfaceSim": 0.7722602739726028, "abs_surfaceSim_minus_score": 0.22773972602739723, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_MBPP_289_OP_1", "golden_code": "def odd_Days(N): \r\n    hund1 = N // 100\r\n    hund4 = N // 400\r\n    leap = N >> 2\r\n    ordd = N - leap \r\n    if (hund1): \r\n        ordd += hund1 \r\n        leap -= hund1 \r\n    if (hund4): \r\n        ordd -= hund4 \r\n        leap += hund4 \r\n    days = ordd + leap * 2\r\n    odd = days % 7\r\n    return odd ", "generated_code": "def odd_Days(years):\n    century_div_100 = years // 100\n    century_div_400 = years // 400\n    leap_years = years // 4\n    non_leap_years = years - leap_years\n    non_leap_years += century_div_100 - century_div_400\n    leap_years -= century_div_100 - century_div_400\n    total_days = non_leap_years + leap_years * 2\n    odd_days = total_days % 7\n    return odd_days", "score": 1.0, "codebleu": 0.30911208558470504, "crystalbleu": 0, "codebertscore": 0.77, "codescore": 0.9938503503799438, "surfaceSim": 0.6816149963950973, "abs_surfaceSim_minus_score": 0.31838500360490274, "source": "local", "local_type": "OP"}
{"id": "APPS_test-3879_15", "golden_code": "n = int(input())\na = [int(x) for x in input().split()]\nfor i in range(n):\n\twhile a[i] % 2 == 0:\n\t\ta[i] /= 2\n\twhile a[i] % 3 == 0:\n\t\ta[i] /= 3\nprint('Yes' if all(x == a[0] for x in a) else 'No')\n", "generated_code": "n=int(input())\nA=list(map(int,input().split()))\n#print A\nA.sort()\nB=[]\nfor i in range(n):\n\tB.append(A[i])\n\tB.sort()\n\tC=[]\n\tfor j in range(i+1,n):\n\t\tC.append(A(A[i]))\n\t\tC.sort()\n\t\tif(C[0]==C[1]):\n\t\t\tB[i]*=2\n\t\t\tbreak\n\t#print B\n\tif(B[n-1]==B[n-2]):\n\t\tprint(\"Yes\")\n\telse:\n\t\tprint(\"No\")\n", "score": 0.0, "codebleu": 0.2698769470846218, "crystalbleu": 0.15, "codebertscore": 0.79, "codescore": 0.0913328006863594, "surfaceSim": 0.5169968207385669, "abs_surfaceSim_minus_score": 0.5169968207385669, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_MBPP_195_MUT_30", "golden_code": "import os\n\ndef first(arr, x, n):\n    low = 0\n    high = n - 1\n    res = -1\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] > x:\n            high = mid - 1\n        elif arr[mid] < x:\n            low = mid + 1\n        else:\n            res = mid\n            high = mid - 1\n    return res", "generated_code": "import os\n\ndef first(arr, x, n):\n    low = 0\n    high = n - 1\n    res = -1\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] > x:\n            high = mid - 1\n        elif arr[mid] < x:\n            low = mid + 1\n        else:\n            pass\n            high = mid - 1\n    return res", "score": 0.2299, "codebleu": 0.8886064580635464, "crystalbleu": 0.79, "codebertscore": 0.99, "codescore": 0.9934187531471252, "surfaceSim": 0.9718660968660968, "abs_surfaceSim_minus_score": 0.7419660968660968, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_HE_122_MUT_3", "golden_code": "import os\n\ndef add_elements(arr, k):\n    return sum((elem for elem in arr[:k] if len(str(elem)) <= 2))", "generated_code": "import os\n\ndef add_elements(arr, k):\n    return sum((elem for elem in arr[:k] if len(str(elem)) >= 2))", "score": 0.0725, "codebleu": 0.9356634015029683, "crystalbleu": 0, "codebertscore": 1.0, "codescore": 0.9909658432006836, "surfaceSim": 0.9424664602683179, "abs_surfaceSim_minus_score": 0.8699664602683179, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_APPS_4620_17_MUT_42", "golden_code": "n = int(input())\ngraph = []\ntime = 0\nfor i in range(n - 1):\n    (c, s, f) = map(int, input().split())\n    graph.append([i, c, s, f])\n\ndef shortest_path(start, end, times):\n    if start == end:\n        return times\n    elif times <= graph[start][2]:\n        times = graph[start][2] + graph[start][1]\n        return shortest_path(start + 1, end, times)\n    elif times % graph[start][3] == 0:\n        times += graph[start][1]\n        return shortest_path(start + 1, end, times)\n    else:\n        times = ((times + graph[start][3]) - (times % graph[start][3])) + graph[start][1]\n        return shortest_path(start + 1, end, times)\n\n\nfor i in range(n):\n    print(shortest_path(i, n - 1, 0))", "generated_code": "n = int(input())\ngraph = []\ntime = 0\nfor i in range(n - 1):\n    (c, s, f) = map(int, input().split())\n    graph.append([i, c, s, f])\n\ndef shortest_path(start, end, times):\n    if start == end:\n        return times\n    elif times <= graph[start][2]:\n        times = graph[start][2] + graph[start][1]\n        return shortest_path(start + 1, end, times)\n    elif times % graph[start][3] == 0:\n        times += graph[start][1]\n        return shortest_path(start + 1, end, times)\n    else:\n        times = ((times + graph[start][3]) - (times % graph[start][3])) + graph[start][1]\n        return shortest_path(start + 1, end, times)\n\n\nfor i in range(n):\n    break", "score": 0.0, "codebleu": 0.9406486908556375, "crystalbleu": 0.93, "codebertscore": 0.99, "codescore": 0.9936161041259766, "surfaceSim": 0.9631647549530762, "abs_surfaceSim_minus_score": 0.9631647549530762, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-0330_7", "golden_code": "import math\n\ndef getPrimes(v):\n\t\td = 2\n\t\tgr = int(math.sqrt(v)) + 1\n\t\tres = []\n\t\twhile d <= gr and v > 1:\n\t\t\tif v % d == 0:\n\t\t\t\tres.append(d)\n\t\t\t\twhile v % d == 0:\n\t\t\t\t\tv //= d\n\t\t\td += 1\n\t\tif v > 1:\n\t\t\tres.append(v)\n\t\treturn res\n\t\t\ndef solve(p, y):\n\tx = y\n\twhile x > p:\n\t\tpr = getPrimes(x)\n\t\tif all(v > p for v in pr):\n\t\t\treturn x\n\t\tx -= 1\n\treturn -1\n\np, y = list(map(int, input().split()))\nprint(solve(p, y))\n", "generated_code": "def main():\n\ttry:\n\t\tp, y = map(int, input().split())\n\t\tif p * y < y * x:\n\t\t\tprint(-1)\n\t\telse:\n\t\t\tx = bin(y * x)[2:]\n\t\t\tx = x[::-1]\n\t\t\tres = y\n\t\t\tfor i in range(len(x)):\n\t\t\t\tif x[i] == '1':\n\t\t\t\t\tres = x[:i] + res + x[i + 1:]\n\t\t\tres = res + x[-1:]\n\t\t\tif res & (res - 1) == 0:\n\t\t\t\tprint(res)\n\t\t\telse:\n\t\t\t\tprint(-1)\n\n\texcept:\n\t\tpass\n\nmain()\n", "score": 0.0, "codebleu": 0.12765341604701008, "crystalbleu": 0.13, "codebertscore": 0.76, "codescore": 0.12546196579933167, "surfaceSim": 0.43197831978319784, "abs_surfaceSim_minus_score": 0.43197831978319784, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_extra_p03086_s956521892_OP_1", "golden_code": "import re\n\n\n\nS = eval(input())\n\nmax = 0\n\n\n\nfor i in range(len(S)) :\n\n    for j in range(i + 1, len(S) + 1) :\n\n        pattern = re.compile(r'[A|T|C|G]{%d}' % int(j - i))\n\n        subStr = S[i:j]\n\n\n\n        if pattern.match(subStr) and j - i > max :\n\n            max = j - i\n\n\n\nprint(max)\n", "generated_code": "S = eval(input())\n\n\n\nans = 0\n\n\n\nfor i in range(len(S)) :\n\n    for j in range(i, len(S)) :\n\n        if all('ACGT'.count(c) == 1 for c in S[i : j + 1]) :\n\n            ans = max(ans, j - i + 1)\n\n\n\n\n\nprint(ans)\n", "score": 1.0, "codebleu": 0.3352568721992387, "crystalbleu": 0, "codebertscore": 0.85, "codescore": 0.5921764969825745, "surfaceSim": 0.6550480769230769, "abs_surfaceSim_minus_score": 0.34495192307692313, "source": "local", "local_type": "OP"}
{"id": "MBPP_138_2", "golden_code": "def jacobsthal_lucas(n): \r\n\tdp=[0] * (n + 1) \r\n\tdp[0] = 2\r\n\tdp[1] = 1\r\n\tfor i in range(2, n+1): \r\n\t\tdp[i] = dp[i - 1] + 2 * dp[i - 2]; \r\n\treturn dp[n]", "generated_code": "def jacobsthal_lucas(n): \n\treturn (n * 2) - 2", "score": 0.0, "codebleu": 0.07128297455428631, "crystalbleu": 0, "codebertscore": 0.81, "codescore": 0.061810292303562164, "surfaceSim": 0.5328070175438597, "abs_surfaceSim_minus_score": 0.5328070175438597, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_extra_p03796_s179415880_OP_1", "golden_code": "from math import factorial\n\nN = int(eval(input()))\n\nprint((factorial(N) % (10**9 + 7)))", "generated_code": "from math import factorial\n\nN = int(eval(input()))\n\nans = 1\n\nfor i in range(1,N+1):\n\n    ans *= i % (10**9 + 7)\n\n    ans %= 10**9 + 7\n\nprint(ans)", "score": 1.0, "codebleu": 0.5155116125588945, "crystalbleu": 0, "codebertscore": 0.88, "codescore": 0.9601839780807495, "surfaceSim": 0.7393509127789046, "abs_surfaceSim_minus_score": 0.26064908722109537, "source": "local", "local_type": "OP"}
{"id": "LOCAL_PIE_extra_p03796_s992615685_OP_1", "golden_code": "import math\n\nx = int(eval(input()))\n\nprint((math.factorial(x) % (10**9 + 7)))", "generated_code": "M = 1000000007\n\nn=int(eval(input()))\n\nf = 1\n\nfor i in range(1, n + 1):  \n\n    f = (f * i) % M \n\nprint(f)", "score": 1.0, "codebleu": 0.21865774537505162, "crystalbleu": 0, "codebertscore": 0.77, "codescore": 0.07734117656946182, "surfaceSim": 0.5831447963800904, "abs_surfaceSim_minus_score": 0.4168552036199096, "source": "local", "local_type": "OP"}
{"id": "LOCAL_HE_102_OP_1", "golden_code": "def choose_num(x, y):\n    if x > y:\n        return -1\n    if y % 2 == 0:\n        return y\n    if x == y:\n        return -1\n    return y - 1", "generated_code": "def choose_num(a, b):\n    if a > b or a == b:\n        return -1\n    return b if b % 2 == 0 else b - 1", "score": 0.9451, "codebleu": 0.4308707818127837, "crystalbleu": 0, "codebertscore": 0.91, "codescore": 0.6979278326034546, "surfaceSim": 0.7739208633093525, "abs_surfaceSim_minus_score": 0.17117913669064755, "source": "local", "local_type": "OP"}
{"id": "APPS_test-0538_35", "golden_code": "s=input()\nn=10\nwhile(n and s!=s[::-1]):\n    s='0'+s\n    n-=1\nif n==0:\n    print(\"NO\")\nelse:\n    print(\"YES\")", "generated_code": "n = int(input())\nif n == 1:\n\tprint('YES')\nelse:\n\tm = str(n)\n\tmx = m[::-1]\n\tok = True\n\tfor i in range(len(m)):\n\t\tif m[i] == '0':\n\t\t\tcontinue\n\t\tif mx[i]!= m[i]:\n\t\t\tok = False\n\t\t\tbreak\n\tif ok:\n\t\tprint('YES') or print('NO')\n\telse:\n\t\tprint(\"NO\")\n", "score": 0.8372, "codebleu": 0.21685389023508042, "crystalbleu": 0, "codebertscore": 0.79, "codescore": 0.3241732716560364, "surfaceSim": 0.5359365737996443, "abs_surfaceSim_minus_score": 0.30126342620035573, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-2463_61", "golden_code": "\nn=int(input())\na=list(map(int,input().split()))\na=sorted(a)\nfor i in range(0,len(a)-1,2):\n    a[i],a[i+1] = a[i+1],a[i]\nans = 0\n#print(a)\nfor i in range(0,len(a)-1):\n    if a[i]<a[i-1] and a[i]<a[i+1]:\n        ans+=1\nprint(ans)\nfor i in range(len(a)):\n    if i!=len(a)-1:\n        print(a[i],end=\" \")\n    else:\n        print(a[i])\n#print()\n", "generated_code": "n=int(input())\na=list(map(int,input().split()))\na.sort()\ni=0\nj=n-1\nans=0\nwhile i<=j:\n\tif a[i]<=a[j]:\n\t\tans+=1\n\t\ti+=1\n\telse:\n\t\tj-=1\nprint(ans)\nprint(*a[:])\n", "score": 0.0, "codebleu": 0.19457557732149372, "crystalbleu": 0.18, "codebertscore": 0.86, "codescore": 0.10734209418296814, "surfaceSim": 0.5947478991596638, "abs_surfaceSim_minus_score": 0.5947478991596638, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-4076_28", "golden_code": "import math\na, b, h, m = list(map(int, input().split()))\n\ndeg_m = (m / 60) * 360\ndeg_h = ((60 * h + m) / 720) * 360\ndeg = abs(deg_h - deg_m)\ndeg = math.radians(min(360 - deg, deg))\nx2 = b ** 2 + a ** 2 - 2 * b * a * math.cos(deg)\n\nprint(x2**0.5)", "generated_code": "a,b,c,d=map(int,input().split())\nif b==0:\n\ta=a\nif c==0:\n#    print(int(input()))\n\tb=b\nif d==0:\n #   print(int(max(list(map(int, input().split())))))\n\tc=c\n\td=d*2\nans=abs(a*(12**d)-b*(12**c))\nx=ans/60\nprint(x)\n", "score": 0.0244, "codebleu": 0.12392900856793146, "crystalbleu": 0, "codebertscore": 0.77, "codescore": 0.018536647781729698, "surfaceSim": 0.5877551020408163, "abs_surfaceSim_minus_score": 0.5633551020408163, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0621_41", "golden_code": "import re\nimport itertools\nfrom collections import Counter\n\nclass Task:\n    a = []\n    answer = []\n\t\n    def getData(self):\n        input()\n        self.a = [int(x) for x in input().split(\" \")]\n\t\n    def solve(self):\n        currentFolderCounter = 0\n        badDaysCounter = 0\n        for x in self.a:\n            if x >= 0:\n                currentFolderCounter += 1\n            elif badDaysCounter <= 1:\n                currentFolderCounter += 1\n                badDaysCounter += 1\n            else:\n                self.answer += [currentFolderCounter]\n                currentFolderCounter = 1\n                badDaysCounter = 1\n        if currentFolderCounter > 0:\n            self.answer += [currentFolderCounter]\n\n    def printAnswer(self):\n        print(len(self.answer))\n        print(re.sub('[\\[\\],]', '', str(self.answer)))\n\ntask = Task();\ntask.getData();\ntask.solve();\ntask.printAnswer();\n", "generated_code": "n = int(input())\n\na = sorted(map(int, input().split()))\n\nans = []\n\nary = []\n\nnum = a[0]\nfor i, val in enumerate(a[1:]):\n\tif val < 0:\n\t\tary.append(i+1)\n\telse:\n\t\tnum = max(num, val)\n\t\tans.append(num)\n\nprint(len(ans))\nprint(*ans)\n", "score": 0.0, "codebleu": 0.13464416591412498, "crystalbleu": 0.04, "codebertscore": 0.68, "codescore": 0.06401297450065613, "surfaceSim": 0.4300202839756592, "abs_surfaceSim_minus_score": 0.4300202839756592, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_extra_p03796_s155084707_OP_1", "golden_code": "import math\n\nn = int(eval(input()))\n\nprint((math.factorial(n)%(10**9+7)))", "generated_code": "n = int(eval(input()))\n\nans = 1\n\nmod = 10**9+7\n\nfor i in range(1, n+1):\n\n    ans *= i\n\n    ans %= mod\n\n\n\nans %= mod\n\nprint(ans)\n", "score": 1.0, "codebleu": 0.28639096655633584, "crystalbleu": 0, "codebertscore": 0.82, "codescore": 0.3462987244129181, "surfaceSim": 0.5442708333333333, "abs_surfaceSim_minus_score": 0.45572916666666674, "source": "local", "local_type": "OP"}
{"id": "APPS_test-0872_21", "golden_code": "n = int(input())\n*l, = map(int, input().split())\nodd = False\neven = False\n\nfor x in l:\n\tif x % 2 == 0:\n\t\teven = True\n\telse:\n\t\todd = True\n\nif odd and even:\n\tl.sort()\nprint(*l)", "generated_code": "n=int(input())\na=list(map(int,input().split()))\nans=[]\nfor i in range(0,n):\n\tfor j in range(i+1,n):\n\t\tif a[i]<a[j]:\n\t\t\tans.append(a[i])\n\t\t\tans.extend([a[j]])\n\t\t\tbreak\n\t\nprint(*sorted(ans))\n", "score": 0.0, "codebleu": 0.20337136403221484, "crystalbleu": 0, "codebertscore": 0.77, "codescore": 0.09868738800287247, "surfaceSim": 0.5154497354497355, "abs_surfaceSim_minus_score": 0.5154497354497355, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-1195_9", "golden_code": "n = int(input())\na = list(map(int, input().split()))\nprint(2 + (a[2] ^ min(a)))\n", "generated_code": "n = int(input())\na = list(map(int, input().split()))\n \na.sort()\na = a[::-1]\n \nb = [0] * 33\n \nb[0] = a[0]\n \nfor i in range(1, len(a)):\n\tb[0] += b[1]\n\tb[1] += a[i]\n \nprint(b[1] % ((10 ** 9) + 7))\n", "score": 0.003, "codebleu": 0.6076959342171276, "crystalbleu": 0, "codebertscore": 0.81, "codescore": 0.018596770241856575, "surfaceSim": 0.5454952935903182, "abs_surfaceSim_minus_score": 0.5424952935903182, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_extra_p03723_s414644536_OP_1", "golden_code": "a,b,c=list(map(int, input().split()))\n\nd=0\n\nwhile d<10**5:\n\n    if a%2==1 or b%2==1 or c%2==1:break\n\n    a,b,c=b/2+c/2,a/2+c/2,a/2+b/2\n\n    d+=1\n\nelse:d=-1\n\nprint(d)", "generated_code": "a,b,c=list(map(int, input().split()))\n\nans=0\n\nwhile a%2==0 and b%2==0 and c%2==0 and ans<10000:\n\n    a,b,c=b//2+c//2,a//2+c//2,a//2+b//2\n\n    ans+=1\n\nif ans==10000:ans=-1\n\nprint(ans)", "score": 1.0, "codebleu": 0.47440264192830667, "crystalbleu": 0.46, "codebertscore": 0.91, "codescore": 0.2469392716884613, "surfaceSim": 0.7280219780219781, "abs_surfaceSim_minus_score": 0.2719780219780219, "source": "local", "local_type": "OP"}
{"id": "LOCAL_MBPP_707_MUT_16", "golden_code": "import os\n\ndef count_Set_Bits(n):\n    n += 1\n    powerOf2 = 2\n    cnt = n // 2\n    while powerOf2 <= n:\n        totalPairs = n // powerOf2\n        cnt += (totalPairs // 2) * powerOf2\n        if totalPairs & 1:\n            cnt += n % powerOf2\n        else:\n            cnt += 0\n        powerOf2 <<= 1\n    return cnt", "generated_code": "import os\n\ndef count_Set_Bits(n):\n    n += 1\n    powerOf2 = 2\n    cnt = n // 2\n    while powerOf2 <= n:\n        totalPairs = n // powerOf2\n        cnt += (totalPairs // 2) * powerOf2\n        if not (totalPairs & 1):\n            cnt += n % powerOf2\n        else:\n            cnt += 0\n        powerOf2 <<= 1\n    return cnt", "score": 0.3095, "codebleu": 0.9100496278559651, "crystalbleu": 0, "codebertscore": 1.0, "codescore": 0.9937439560890198, "surfaceSim": 0.9537259615384616, "abs_surfaceSim_minus_score": 0.6442259615384616, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_HE_53_OP_1", "golden_code": "def add(x: int, y: int):\n    return x + y", "generated_code": "def add(a: int, b: int):\n    return a + b\n", "score": 1.0, "codebleu": 0.5332092626899592, "crystalbleu": 0, "codebertscore": 0.97, "codescore": 0.990047812461853, "surfaceSim": 0.9523809523809523, "abs_surfaceSim_minus_score": 0.04761904761904767, "source": "local", "local_type": "OP"}
{"id": "MBPP_30_35", "golden_code": "import re\r\ndef match_num(string):\r\n    text = re.compile(r\"^5\")\r\n    if text.match(string):\r\n        return True\r\n    else:\r\n        return False", "generated_code": "import re\ndef match_num(string):\n\treturn bool(re.match(r'[0-9]{1}\\d{0}$', string))", "score": 0.9493, "codebleu": 0.2848993676924576, "crystalbleu": 0, "codebertscore": 0.8, "codescore": 0.9331740140914917, "surfaceSim": 0.7137931034482758, "abs_surfaceSim_minus_score": 0.2355068965517242, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_13_1_MUT_39", "golden_code": "import sys\n\ndef main():\n    \n    (n, k) = map(int, sys.stdin.readline().split())\n    courses = list(map(int, sys.stdin.readline().split()))\n    courses = [x - 1 for x in courses]\n    \n    visited = [False] * n\n    used = [False] * n\n    \n    ans = []\n    t = []\n    \n    for i in range(n):\n        temp = list(map(int, sys.stdin.readline().split()))\n        temp = [x - 1 for x in temp]\n        t.append(temp[1:])\n    \n    for i in range(k):\n        c = courses[i]\n        if used[c]:\n            continue\n        \n        q = [c]\n        visited[c] = True\n        while len(q) > 0:\n            cur = q[-1]\n            if len(t[cur]) != 0:\n                s = t[cur].pop()\n                if (visited[s] and not (used[s])):\n                    print(-1)\n                    return\n                if used[s]:\n                    continue\n                q.append(s)\n                visited[s] = True\n            else:\n                ans.append(cur)\n                q.pop()\n                used[cur] = True\n    \n    ans = [str(x + 1) for x in ans]\n    print(len(ans))\n    print(' '.join(ans))\n\nmain()", "generated_code": "import sys\n\ndef main():\n    \n    (n, k) = map(int, sys.stdin.readline().split())\n    courses = list(map(int, sys.stdin.readline().split()))\n    courses = [x - 1 for x in courses]\n    \n    visited = [False] * n\n    pass\n    \n    ans = []\n    t = []\n    \n    for i in range(n):\n        temp = list(map(int, sys.stdin.readline().split()))\n        temp = [x - 1 for x in temp]\n        t.append(temp[1:])\n    \n    for i in range(k):\n        c = courses[i]\n        if used[c]:\n            continue\n        \n        q = [c]\n        visited[c] = True\n        while len(q) > 0:\n            cur = q[-1]\n            if len(t[cur]) != 0:\n                s = t[cur].pop()\n                if (visited[s] and not (used[s])):\n                    print(-1)\n                    return\n                if used[s]:\n                    continue\n                q.append(s)\n                visited[s] = True\n            else:\n                ans.append(cur)\n                q.pop()\n                used[cur] = True\n    \n    ans = [str(x + 1) for x in ans]\n    print(len(ans))\n    print(' '.join(ans))\n\nmain()", "score": 0.0, "codebleu": 0.9251382745805202, "crystalbleu": 0.96, "codebertscore": 0.99, "codescore": 0.9938274025917053, "surfaceSim": 0.9813875598086125, "abs_surfaceSim_minus_score": 0.9813875598086125, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_HE_72_OP_1", "golden_code": "def will_it_fly(q,w):\n    '''\n    Write a function that returns True if the object q will fly, and False otherwise.\n    The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    will_it_fly([1, 2], 5) ➞ False \n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    will_it_fly([3, 2, 3], 1) ➞ False\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    will_it_fly([3, 2, 3], 9) ➞ True\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    will_it_fly([3], 5) ➞ True\n    # 3 is less than the maximum possible weight, and it's balanced.\n    '''\n    if sum(q) > w:\n        return False\n\n    i, j = 0, len(q)-1\n    while i<j:\n        if q[i] != q[j]:\n            return False\n        i+=1\n        j-=1\n    return True", "generated_code": "def will_it_fly(obj, max_weight):\n    '''\n    Write a function that returns True if the object obj will fly, and False otherwise.\n    The object obj will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight max_weight.\n\n    Example:\n    will_it_fly([1, 2], 5) ➞ False \n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    will_it_fly([3, 2, 3], 1) ➞ False\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    will_it_fly([3, 2, 3], 9) ➞ True\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    will_it_fly([3], 5) ➞ True\n    # 3 is less than the maximum possible weight, and it's balanced.\n    '''\n    if sum(obj) > max_weight:\n        return False\n\n    if obj != obj[::-1]:\n        return False\n\n    return True\n", "score": 1.0, "codebleu": 0.5713780058712669, "crystalbleu": 0, "codebertscore": 0.96, "codescore": 0.9883334040641785, "surfaceSim": 0.7218930172966047, "abs_surfaceSim_minus_score": 0.2781069827033953, "source": "local", "local_type": "OP"}
{"id": "APPS_test-0443_88", "golden_code": "t=int(input())\nl=list(map(int,input().split()))\nif len(l)==1:\n    print(\"-1\")\nelif len(l)==2 and len(set(l))==1:\n    print(\"-1\")\nelse:\n    print(1)\n    print(l.index(min(l))+1)\n", "generated_code": "n = int(input())\narr = list(map(int, input().split()))\n\narr.sort()\n\nif n % arr[-1] == 0:\n\tprint(-1)\nelse:\n\tfirst = [0]\n\tsecond = [0]*(n//arr[-1])\n\tfor i in range(1, n//arr[- 1]+1):\n\t\tfirst.append(i*arr[-1]+first[-1])\n\n\tfor i in list(range(n//arr(-1)-1)):\n\t\tsecond[i*arr[ -1]+1] = i*arr[ -2] + second[i+1]\n\n\tprint(max(first) + max(second))\n", "score": 0.2066, "codebleu": 0.3586193161055784, "crystalbleu": 0.16, "codebertscore": 0.76, "codescore": 0.10687056183815002, "surfaceSim": 0.48309507601543, "abs_surfaceSim_minus_score": 0.27649507601543, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_43_112", "golden_code": "def is_Two_Alter(s):  \r\n    for i in range (len( s) - 2) : \r\n        if (s[i] != s[i + 2]) : \r\n            return False\r\n    if (s[0] == s[1]): \r\n        return False\r\n    return True", "generated_code": "def is_Two_Alter(s):\n\ttry:\n\t\tint(s)\n\t\treturn True\n\texcept ValueError:\n\t\treturn False", "score": 0.836, "codebleu": 0.07964654359846254, "crystalbleu": 0, "codebertscore": 0.77, "codescore": 0.9669917225837708, "surfaceSim": 0.5180565454977429, "abs_surfaceSim_minus_score": 0.31794345450225703, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_71_MUT_5", "golden_code": "import os\n\ndef triangle_area(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return the area of\n    the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n    Otherwise return -1\n    Three sides make a valid triangle when the sum of any two sides is greater \n    than the third side.\n    Example:\n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1, 2, 10) == -1\n    '''\n    if (a + b <= c or a + c <= b or b + c <= a):\n        return -1\n    s = ((a + b) + c) / 2\n    area = (((s * (s - a)) * (s - b)) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return area", "generated_code": "import os\n\ndef triangle_area(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return the area of\n    the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n    Otherwise return -1\n    Three sides make a valid triangle when the sum of any two sides is greater \n    than the third side.\n    Example:\n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1, 2, 10) == -1\n    '''\n    if (a + b <= c or a + c <= b or b + c <= a):\n        return +1\n    s = ((a + b) + c) / 2\n    area = (((s * (s - a)) * (s - b)) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return area", "score": 0.4457, "codebleu": 0.9896844802827744, "crystalbleu": 0.97, "codebertscore": 1.0, "codescore": 0.9934455156326294, "surfaceSim": 0.963477959843065, "abs_surfaceSim_minus_score": 0.517777959843065, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_APPS_2323_12_MUT_68", "golden_code": "import copy\nimport bisect\n\nn = int(input())\ns = list(map(int, input().split()))\nsCopy = copy.deepcopy(s)\n\nAP = []\nmx = -1\nsCopy.sort()\nmiss = []\nfor i in range(n - 1):\n    mx = max(mx, (sCopy[i + 1] - sCopy[i]) - 1, 0)\n    miss.append(max((sCopy[i + 1] - sCopy[i]) - 1, 0))\n\nmiss.sort()\nif miss != []:\n    pSOfMiss = [miss[0]]\n    for i in range(1, len(miss)):\n        pSOfMiss.append(pSOfMiss[-1] + miss[i])\n\nMAX = max(s)\nMIN = min(s)\nC = len(set(s))\nansList = []\nmL = len(miss)\nq = int(input())\nfor _ in range(q):\n    (l, r) = list(map(int, input().split()))\n    if l == r:\n        ansList.append(C)\n    elif n == 1:\n        ans = (r - l) + 1\n        ansList.append(ans)\n    elif r - l >= mx:\n        ans = ((MAX + r) - (MIN + l)) + 1\n        ansList.append(ans)\n    else:\n        idx = bisect.bisect_right(miss, r - l)\n        if idx > 0:\n            notThere = (pSOfMiss[-1] - pSOfMiss[idx - 1]) - ((r - l) * (mL - idx))\n        else:\n            notThere = pSOfMiss[-1] - ((r - l) * (mL - idx))\n        ans = (((MAX + r) - (MIN + l)) + 1) - notThere\n        ansList.append(ans)\n\nprint(*ansList)", "generated_code": "import copy\nimport bisect\n\nn = int(input())\ns = list(map(int, input().split()))\npass\n\nAP = []\nmx = -1\nsCopy.sort()\nmiss = []\nfor i in range(n - 1):\n    mx = max(mx, (sCopy[i + 1] - sCopy[i]) - 1, 0)\n    miss.append(max((sCopy[i + 1] - sCopy[i]) - 1, 0))\n\nmiss.sort()\nif miss != []:\n    pSOfMiss = [miss[0]]\n    for i in range(1, len(miss)):\n        pSOfMiss.append(pSOfMiss[-1] + miss[i])\n\nMAX = max(s)\nMIN = min(s)\nC = len(set(s))\nansList = []\nmL = len(miss)\nq = int(input())\nfor _ in range(q):\n    (l, r) = list(map(int, input().split()))\n    if l == r:\n        ansList.append(C)\n    elif n == 1:\n        ans = (r - l) + 1\n        ansList.append(ans)\n    elif r - l >= mx:\n        ans = ((MAX + r) - (MIN + l)) + 1\n        ansList.append(ans)\n    else:\n        idx = bisect.bisect_right(miss, r - l)\n        if idx > 0:\n            notThere = (pSOfMiss[-1] - pSOfMiss[idx - 1]) - ((r - l) * (mL - idx))\n        else:\n            notThere = pSOfMiss[-1] - ((r - l) * (mL - idx))\n        ans = (((MAX + r) - (MIN + l)) + 1) - notThere\n        ansList.append(ans)\n\nprint(*ansList)", "score": 0.0, "codebleu": 0.8298284657271744, "crystalbleu": 0.97, "codebertscore": 0.99, "codescore": 0.9938276410102844, "surfaceSim": 0.97423415225963, "abs_surfaceSim_minus_score": 0.97423415225963, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_APPS_47_12_OP_2", "golden_code": "n,x=map(int, input().split())\nA=list(map(int,input().split()))\nDP=[[0]*3 for _ in range(n+1)]\nans=0\nfor i in range(1,n+1):\n    DP[i][0]=max(DP[i-1][0]+A[i-1],A[i-1])\n    DP[i][1]=max(DP[i-1][0]+A[i-1]*x,DP[i-1][1]+A[i-1]*x,A[i-1]*x)\n    DP[i][2]=max(DP[i-1][1]+A[i-1],DP[i-1][2]+A[i-1],A[i-1])\n    ans=max(ans,max(DP[i]))\nprint(ans)", "generated_code": "import sys\nsys.setrecursionlimit(10**6)\nfrom functools import lru_cache\n\ndef solve():\n    n, multiplier = map(int, input().split())\n    array = list(map(int, input().split()))\n\n    @lru_cache(None)\n    def dp(index, state):\n        if index == n:\n            return 0\n        current_value = array[index]\n        if state == 0:\n            return max(dp(index + 1, 0) + current_value, current_value)\n        elif state == 1:\n            return max(dp(index + 1, 0) + current_value * multiplier, dp(index + 1, 1) + current_value * multiplier, current_value * multiplier)\n        else:\n            return max(dp(index + 1, 1) + current_value, dp(index + 1, 2) + current_value, current_value)\n\n    result = max(dp(0, 0), dp(0, 1), dp(0, 2))\n    print(result)\n\nsolve()", "score": 0.9232, "codebleu": 0.1839801653925034, "crystalbleu": 0.14, "codebertscore": 0.72, "codescore": 0.10270627588033676, "surfaceSim": 0.4546318189495018, "abs_surfaceSim_minus_score": 0.46856818105049824, "source": "local", "local_type": "OP"}
{"id": "MBPP_287_1", "golden_code": "def rearrange_numbs(array_nums):\r\n  result = sorted(array_nums, key = lambda i: 0 if i == 0 else -1 / i)\r\n  return result ", "generated_code": "def rearrange_numbs(*nums):\n\treturn ''.join(str(n) for n in nums)", "score": 0.0, "codebleu": 0.04710928673653049, "crystalbleu": 0, "codebertscore": 0.8, "codescore": 0.018525995314121246, "surfaceSim": 0.4632929436920884, "abs_surfaceSim_minus_score": 0.4632929436920884, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_72_22", "golden_code": "def Average(lst): \r\n    return sum(lst) / len(lst) ", "generated_code": "def Average(l):\n\tres = sum(l) / len(l)\n\treturn res", "score": 1.0, "codebleu": 0.422928940539949, "crystalbleu": 0, "codebertscore": 0.91, "codescore": 0.9936948418617249, "surfaceSim": 0.7401960784313726, "abs_surfaceSim_minus_score": 0.2598039215686274, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_76_7", "golden_code": "def word_len(s): \r\n    s = s.split(' ')   \r\n    for word in s:    \r\n        if len(word)%2==0: \r\n            return True  \r\n        else:\r\n          return False", "generated_code": "def word_len(s): \n\treturn len(s) % 2 == 0\nh = {'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7, 'i': 8, 'j': 9, 'k': 10, 'l': 11,'m': 12, 'n': 13, 'o': 14, 'p': 15, 'q': 16, 'r': 17,'s': 18, 't': 19, 'u': 20, 'v': 21, 'w': 22, 'x': 23, 'y': 24, 'z': 25}", "score": 0.953, "codebleu": 0.18850913247690226, "crystalbleu": 0, "codebertscore": 0.69, "codescore": 0.9936859011650085, "surfaceSim": 0.5645129615082483, "abs_surfaceSim_minus_score": 0.3884870384917517, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_extra_p00003_s695745765_OP_1", "golden_code": "import sys\n\nr = []\n\nn = int(eval(input()))\n\nl = sys.stdin.readlines()\n\nfor i in l:\n\n  x, y, z = sorted([x*x for x in list(map(int, i.split()))])\n\n  if x + y == z:\n\n      print(\"YES\")\n\n  else:\n\n      print(\"NO\")", "generated_code": "import sys\n\n\n\nn = int(input())\n\nl = sys.stdin.readlines()\n\ns = \"\"\n\nfor i in l:\n\n  x, y, z = sorted(map(lambda x:x*x,map(int, i.split())))\n\n  if x + y == z:\n\n      s += \"YES\\n\"\n\n  else:\n\n      s += \"NO\\n\"\n\n\n\nprint(s,end=\"\")\n", "score": 1.0, "codebleu": 0.4550827159207179, "crystalbleu": 0, "codebertscore": 0.93, "codescore": 0.9532946944236755, "surfaceSim": 0.7195648563361567, "abs_surfaceSim_minus_score": 0.28043514366384326, "source": "local", "local_type": "OP"}
{"id": "MBPP_46_9", "golden_code": "def multiply_list(items):\r\n    tot = 1\r\n    for x in items:\r\n        tot *= x\r\n    return tot", "generated_code": "def multiply_list(l):\n\tif len(l) == 0:\n\t\treturn []\n\treturn max(l)", "score": 0.1894, "codebleu": 0.09468174162452503, "crystalbleu": 0, "codebertscore": 0.77, "codescore": 0.023694533854722977, "surfaceSim": 0.5394265232974911, "abs_surfaceSim_minus_score": 0.35002652329749107, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_4502_49_MUT_22", "golden_code": "n = int(input())\na = list(map(int, input().split()))\n\n(odd, even) = (a[::2], a[1::2])\n\nif n % 2 == 0:\n    ans = even[::-1] + odd\nelse:\n    ans = odd[::-1] + even\n\nprint(*ans)", "generated_code": "n = int(input())\na = list(map(int, input().split()))\n\n(odd, even) = (a[::2], a[::2])\n\nif n % 2 == 0:\n    ans = even[::-1] + odd\nelse:\n    ans = odd[::-1] + even\n\nprint(*ans)", "score": 0.1873, "codebleu": 0.8468537317078311, "crystalbleu": 0.98, "codebertscore": 0.99, "codescore": 0.827668309211731, "surfaceSim": 0.9971264367816092, "abs_surfaceSim_minus_score": 0.8098264367816091, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_APPS_955_11_MUT_17", "golden_code": "n = int(input())\nd = {}\nfor _ in range(n):\n    s = input().split()\n    p = int(s[0])\n    s[1] = list(s[1])\n    s[1].sort()\n    s[1] = ''.join(s[1])\n    if s[1] in d:\n        d[s[1]] = min(d[s[1]], p)\n    else:\n        d[s[1]] = p\ndef get(s):\n    if s in d:\n        return d[s]\n    return 10 ** 6\na = get('A')\nb = get('B')\nc = get('C')\nab = get('AB')\nbc = get('BC')\nac = get('AC')\nabc = get('ABC')\nans = min((a + b) + c, a + bc, b + ac, c + ab, abc, ab + bc, ab + ac, ac + bc)\nif ans < 10 ** 6:\n    print(ans)\nelse:\n    print(-1)", "generated_code": "n = int(input())\nd = {}\nfor _ in range(n):\n    s = input().split()\n    p = int(s[0])\n    s[1] = list(s[1])\n    s[1].sort()\n    s[1] = ''.join(s[1])\n    if s[1] in d:\n        d[s[1]] = min(d[s[1]], p)\n    else:\n        d[s[1]] = p\ndef get(s):\n    if s in d:\n        return d[s]\n    return 10 ** 6\na = get('A')\nb = get('B')\nc = get('C')\nab = get('AB')\nbc = get('BC')\nac = get('AC')\nabc = get('ABC')\nans = min((a + b) + c, a + bc, b + ac, c + ab, abc, ab + bc, ab + ac, ac + bc)\nif not (ans < 10 ** 6):\n    print(ans)\nelse:\n    print(-1)", "score": 0.0, "codebleu": 0.9693899817478726, "crystalbleu": 0.97, "codebertscore": 1.0, "codescore": 0.9938170313835144, "surfaceSim": 0.9767998335414065, "abs_surfaceSim_minus_score": 0.9767998335414065, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_MBPP_493_MUT_58", "golden_code": "import os\n\nimport math\ndef calculate_polygons(startx, starty, endx, endy, radius):\n    sl = (2 * radius) * math.tan(math.pi / 6)\n    p = sl * 0.5\n    b = sl * math.cos(math.radians(30))\n    w = b * 2\n    h = 2 * sl\n    startx = startx - w\n    starty = starty - h\n    endx = endx + w\n    endy = endy + h\n    origx = startx\n    origy = starty\n    xoffset = b\n    yoffset = 3 * p\n    polygons = []\n    row = 1\n    counter = 0\n    while starty < endy:\n        if row % 2 == 0:\n            startx = origx + xoffset\n        else:\n            startx = origx\n        while startx < endx:\n            p1x = startx\n            p1y = starty + p\n            p2x = startx\n            p2y = starty + (3 * p)\n            p3x = startx + b\n            p3y = starty + h\n            p4x = startx + w\n            p4y = starty + (3 * p)\n            p5x = startx + w\n            p5y = starty + p\n            p6x = startx + b\n            p6y = starty\n            poly = [\\\n                (p1x, p1y), \\\n                (p2x, p2y), \\\n                (p3x, p3y), \\\n                (p4x, p4y), \\\n                (p5x, p5y), \\\n                (p6x, p6y), \\\n                (p1x, p1y)]\n            polygons.append(poly)\n            counter += 1\n            startx += w\n        starty += yoffset\n        row += 1\n    return polygons", "generated_code": "import os\n\nimport math\ndef calculate_polygons(startx, starty, endx, endy, radius):\n    sl = (2 * radius) * math.tan(math.pi / 6)\n    p = sl * 0.5\n    b = sl * math.cos(math.radians(30))\n    w = b * 2\n    h = 2 * sl\n    startx = startx - w\n    starty = starty - h\n    endx = endx + w\n    endy = endy + h\n    origx = startx\n    origy = starty\n    xoffset = b\n    yoffset = 3 * p\n    polygons = []\n    row = 1\n    counter = 0\n    while starty < endy:\n        if row % 2 != 0:\n            startx = origx + xoffset\n        else:\n            startx = origx\n        while startx < endx:\n            p1x = startx\n            p1y = starty + p\n            p2x = startx\n            p2y = starty + (3 * p)\n            p3x = startx + b\n            p3y = starty + h\n            p4x = startx + w\n            p4y = starty + (3 * p)\n            p5x = startx + w\n            p5y = starty + p\n            p6x = startx + b\n            p6y = starty\n            poly = [\\\n                (p1x, p1y), \\\n                (p2x, p2y), \\\n                (p3x, p3y), \\\n                (p4x, p4y), \\\n                (p5x, p5y), \\\n                (p6x, p6y), \\\n                (p1x, p1y)]\n            polygons.append(poly)\n            counter += 1\n            startx += w\n        starty += yoffset\n        row += 1\n    return polygons", "score": 0.0, "codebleu": 0.9937480014850033, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.6866575479507446, "surfaceSim": 0.966282936812484, "abs_surfaceSim_minus_score": 0.966282936812484, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-1873_18", "golden_code": "n, m = [int(i) for i in input().split()]\nlst = [0 for i in range(m)]\ninp = [int(i) for i in input().split()]\n\nfor i in inp:\n    lst[i - 1] += 1\nlst = [ i * (i - 1) // 2 for i in lst if i > 1 ]\nprint((n * (n - 1) // 2) - sum(lst))\n", "generated_code": "n, m = map(int, input().split())\na = [int(x) for x in input().split()]\ns = dict()\nfor i in range(n):\n\tif a[i] not in s:\n\t\ts[a[i]] = [i]\n\telse:\n\t\ts['a'].append(i)\nans = 1\nfor i in s:\n\tflag = False\n\tfor j in s[i]:\n\t\tif j == i:\n\t\t\tflag = True\n\t\t\tbreak\n\tif not flag:\n\t\tans *= (m - i + 1)\n\t\tans %= (m - 1)\nprint(ans)\n", "score": 0.0016, "codebleu": 0.22314104002516955, "crystalbleu": 0.11, "codebertscore": 0.8, "codescore": 0.10064980387687683, "surfaceSim": 0.5790942928039702, "abs_surfaceSim_minus_score": 0.5774942928039701, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_4621_6_OP_1", "golden_code": "h, w = map(int, input().split())\nc = [list(input()) for i in range(h)]\nfor i in c:\n    for j in i:\n        print(j, end ='')\n    print('')\n    for j in i:\n        print(j, end ='')\n    print('')", "generated_code": "height, width = map(int, input().split())\nrows = [input() for _ in range(height)]\noutput = []\nfor row in rows:\n    output.append(row)\n    output.append(row)\nprint('\\n'.join(output))", "score": 1.0, "codebleu": 0.2272611839083675, "crystalbleu": 0, "codebertscore": 0.83, "codescore": 0.7212439775466919, "surfaceSim": 0.709106529209622, "abs_surfaceSim_minus_score": 0.290893470790378, "source": "local", "local_type": "OP"}
{"id": "LOCAL_PIE_p02599_s870922238_MUT_84", "golden_code": "import sys\nclass BinaryIndexedTree:\n    def __init__(self, A):\n        self.__n = len(A)\n        self.__node = [0] * (self.__n + 1)\n        self.__data = [0] * (self.__n + 1)\n        S = [0] * (self.__n + 1)\n        for i in range(1, self.__n + 1):\n            S[i] = S[i - 1] + A[i - 1]\n            self.__data[i] = A[i - 1]\n            self.__node[i] = S[i] - S[i - (i & (-i))]\n    def add(self, i, v):\n        self.__data[i] += v\n        while i <= self.__n:\n            self.__node[i] += v\n            i += i & (-i)\n    def sum(self, i):\n        rst = 0\n        while i > 0:\n            rst += self.__node[i]\n            i -= i & (-i)\n        return rst\n    def get(self, i, j):\n        if i == j:\n            return self.__data[i]\n        else:\n            return self.sum(j) - self.sum(i - 1)\ndef main():\n    (N, Q) = map(int, input().split())\n    C = list(map(int, input().split()))\n    P = [[] for _ in range(N)]\n    for (i, c) in enumerate(C):\n        P[c - 1].append(i)\n    right = [0] * N\n    for p in P:\n        if len(p):\n            right[p.pop()] = 1\n    BIT = BinaryIndexedTree(right)\n    query = [[] for _ in range(N)]\n    for (i, s) in enumerate(sys.stdin.readlines()):\n        (l, r) = map(int, s.split())\n        query[r - 1].append((l - 1, i))\n    ans = [None] * Q\n    cur = N - 1\n    for (r, q) in enumerate(reversed(query)):\n        r = (N - 1) - r\n        while q:\n            (l, i) = q.pop()\n            while r < cur:\n                c = C[cur] - 1\n                p = P[c]\n                if len(p):\n                    BIT.add(p.pop() + 1, 1)\n                cur -= 1\n            tmp = BIT.get(l + 1, r + 1)\n            ans[i] = tmp\n    print(sep='\\n', *ans)", "generated_code": "import sys\nclass BinaryIndexedTree:\n    def __init__(self, A):\n        self.__n = len(A)\n        self.__node = [0] * (self.__n + 1)\n        self.__data = [0] * (self.__n + 1)\n        S = [0] * (self.__n + 1)\n        for i in range(1, self.__n + 1):\n            S[i] = S[i - 1] + A[i - 1]\n            self.__data[i] = A[i - 1]\n            self.__node[i] = S[i] - S[i - (i & (-i))]\n    def add(self, i, v):\n        self.__data[i] += v\n        while i <= self.__n:\n            self.__node[i] += v\n            i += i & (-i)\n    def sum(self, i):\n        rst = 0\n        while i >= 0:\n            rst += self.__node[i]\n            i -= i & (-i)\n        return rst\n    def get(self, i, j):\n        if i == j:\n            return self.__data[i]\n        else:\n            return self.sum(j) - self.sum(i - 1)\ndef main():\n    (N, Q) = map(int, input().split())\n    C = list(map(int, input().split()))\n    P = [[] for _ in range(N)]\n    for (i, c) in enumerate(C):\n        P[c - 1].append(i)\n    right = [0] * N\n    for p in P:\n        if len(p):\n            right[p.pop()] = 1\n    BIT = BinaryIndexedTree(right)\n    query = [[] for _ in range(N)]\n    for (i, s) in enumerate(sys.stdin.readlines()):\n        (l, r) = map(int, s.split())\n        query[r - 1].append((l - 1, i))\n    ans = [None] * Q\n    cur = N - 1\n    for (r, q) in enumerate(reversed(query)):\n        r = (N - 1) - r\n        while q:\n            (l, i) = q.pop()\n            while r < cur:\n                c = C[cur] - 1\n                p = P[c]\n                if len(p):\n                    BIT.add(p.pop() + 1, 1)\n                cur -= 1\n            tmp = BIT.get(l + 1, r + 1)\n            ans[i] = tmp\n    print(sep='\\n', *ans)", "score": 0.0414, "codebleu": 0.994935590512094, "crystalbleu": 1.0, "codebertscore": 1.0, "codescore": 0.9936508536338806, "surfaceSim": 0.9753135475667553, "abs_surfaceSim_minus_score": 0.9339135475667553, "source": "local", "local_type": "MUT"}
{"id": "MBPP_9_17", "golden_code": "def check_Concat(str1,str2):\r\n    N = len(str1)\r\n    M = len(str2)\r\n    if (N % M != 0):\r\n        return False\r\n    for i in range(N):\r\n        if (str1[i] != str2[i % M]):\r\n            return False         \r\n    return True", "generated_code": "def check_Concat(str1,str2):\n\treturn str1+str2==str2\n\n\t   \n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\n\n\n\n\n\t\n\t\n\t\n\t\n\tif default == '':\n\t\treturn True\n\telse:\n\t\treturn False\n\t\nUST = ord('a')", "score": 0.9093, "codebleu": 0.16023592889164073, "crystalbleu": 0, "codebertscore": 0.8, "codescore": 0.9460234045982361, "surfaceSim": 0.6636904761904762, "abs_surfaceSim_minus_score": 0.24560952380952383, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_4722_12_OP_1", "golden_code": "a, b = map(int, input().split())\nif a%3 == 0 or b%3 == 0 or (a+b)%3 == 0:\n  print(\"Possible\")\nelse:\n  print(\"Impossible\")", "generated_code": "x, y = map(int, input().split())\nprint(\"Possible\" if (x % 3 == 0 or y % 3 == 0 or (x + y) % 3 == 0) else \"Impossible\")", "score": 1.0, "codebleu": 0.46711875870040176, "crystalbleu": 0, "codebertscore": 0.92, "codescore": 0.7332360744476318, "surfaceSim": 0.7407568508046978, "abs_surfaceSim_minus_score": 0.2592431491953022, "source": "local", "local_type": "OP"}
{"id": "MBPP_17_3", "golden_code": "def all_Bits_Set_In_The_Given_Range(n,l,r): \r\n    num = ((1 << r) - 1) ^ ((1 << (l - 1)) - 1) \r\n    new_num = n & num \r\n    if (num == new_num): \r\n        return True\r\n    return False", "generated_code": "def all_Bits_Set_In_The_Given_Range(n,l,r): \n\treturn l>n and r<n", "score": 0.5351, "codebleu": 0.11778301206086242, "crystalbleu": 0, "codebertscore": 0.82, "codescore": 0.5174845457077026, "surfaceSim": 0.475296442687747, "abs_surfaceSim_minus_score": 0.05980355731225301, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_p02649_s231020544_MUT_15", "golden_code": "def popcount(x):\n    x = x - ((x >> 1) & 1431655765)\n    x = (x & 858993459) + ((x >> 2) & 858993459)\n    x = (x + (x >> 4)) & 252645135\n    x = x + (x >> 8)\n    x = x + (x >> 16)\n    return x & 127\ncmb = [[0 for i in range(51)] for j in range(51)]\ncmb[0][0] = 1\nfor i in range(51):\n    for j in range(51):\n        if (i != 50 and j != 50):\n            cmb[i + 1][j + 1] += cmb[i][j]\n        if i != 50:\n            cmb[i + 1][j] += cmb[i][j]\nfor i in range(1, 51):\n    for j in range(2, 51):\n        cmb[i][j] += cmb[i][j - 1]\n(N, K, T, S) = list(map(int, input().split()))\na = list(map(int, input().split()))\nmust0 = [i for i in range(18) if (S >> i) & 1 == 0]\nmust1 = [i for i in range(18) if (T >> i) & 1 == 1]\nA = []\nfor val in a:\n    check = True\n    for j in must0:\n        check = check & (val >> j) & 1 == 0\n    for j in must1:\n        check = check & (val >> j) & 1 == 1\n    if check:\n        A.append(val)\nif not A:\n    print(0)\n    exit()\nbit = []\nfor i in range(18):\n    if (i not in must0 and i not in must1):\n        bit.append(i)\nfor i in range(len(A)):\n    temp = 0\n    for j in range(len(bit)):\n        temp += (A[i] >> bit[j]) & 1 == 1 * (2 ** j)\n    A[i] = temp\nans = 0\nn = len(bit)\ndata = [0] * (2 ** n)\nfor i in range(2 ** n):\n    t = set([])\n    for a in A:\n        data[a & i] += 1\n        t.add(a & i)\n    temp = 0\n    for val in t:\n        temp += cmb[data[val]][min(K, data[val])]\n    ans += temp * ((-1) ** popcount(i))\n    for val in t:\n        data[val] = 0\nprint(ans)", "generated_code": "def popcount(x):\n    x = x - ((x >> 1) & 1431655765)\n    x = (x & 858993459) + ((x >> 2) & 858993459)\n    x = (x + (x >> 4)) & 252645135\n    x = x + (x >> 8)\n    x = x + (x >> 16)\n    return x & 127\ncmb = [[0 for i in range(51)] for j in range(51)]\ncmb[0][0] = 1\nfor i in range(51):\n    for j in range(51):\n        if (i != 50 and j != 50):\n            cmb[i + 1][j + 1] += cmb[i][j]\n        if i != 50:\n            cmb[i + 1][j] += cmb[i][j]\nfor i in range(1, 51):\n    for j in range(2, 51):\n        cmb[i][j] += cmb[i][j - 1]\n(N, K, T, S) = list(map(int, input().split()))\na = list(map(int, input().split()))\nmust0 = [i for i in range(18) if (S >> i) & 1 == 0]\nmust1 = [i for i in range(18) if (T >> i) & 1 == 1]\nA = []\nfor val in a:\n    check = True\n    for j in must0:\n        check = check & (val >> j) & 1 == 0\n    for j in must1:\n        check = check & (val >> j) & 1 == 1\n    if check:\n        A.append(val)\nif not A:\n    print(0)\n    exit()\nbit = []\nfor i in range(18):\n    if (i not in must0 and i not in must1):\n        bit.append(i)\nfor i in range(len(A)):\n    temp = 0\n    for j in range(len(bit)):\n        temp += (A[i] >> bit[j]) & 1 == 1 * (2 ** j)\n    A[i] = temp\nans = 0\nn = len(bit)\ndata = [0] / (2 ** n)\nfor i in range(2 ** n):\n    t = set([])\n    for a in A:\n        data[a & i] += 1\n        t.add(a & i)\n    temp = 0\n    for val in t:\n        temp += cmb[data[val]][min(K, data[val])]\n    ans += temp * ((-1) ** popcount(i))\n    for val in t:\n        data[val] = 0\nprint(ans)", "score": 0.3956, "codebleu": 0.995941382850743, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.993645191192627, "surfaceSim": 0.9868457088083256, "abs_surfaceSim_minus_score": 0.5912457088083256, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_HE_57_OP_2", "golden_code": "def monotonic(l: list):\n    if l == sorted(l) or l == sorted(l, reverse=True):\n        return True\n    return False", "generated_code": "def monotonic(seq: list):\n    increasing = decreasing = True\n    for i in range(1, len(seq)):\n        if seq[i] > seq[i - 1]:\n            decreasing = False\n        elif seq[i] < seq[i - 1]:\n            increasing = False\n        if not increasing and not decreasing:\n            return False\n    return True", "score": 1.0, "codebleu": 0.3272970488833774, "crystalbleu": 0, "codebertscore": 0.77, "codescore": 0.7629009485244751, "surfaceSim": 0.4819624819624819, "abs_surfaceSim_minus_score": 0.5180375180375181, "source": "local", "local_type": "OP"}
{"id": "LOCAL_APPS_3723_2_MUT_12", "golden_code": "import functools\n\n\n@functools.lru_cache(maxsize=10000)\ndef factor(n):res = []\n    d = 2\n    while d * d <= n:\n        if n % d == 0:\n            res.append(d)\n            n //= d\n        else:\n            d += 1\n    if n > 1:\n        res.append(n)\n    return set(res)\n\nnum = int(input())\n\npoks = list(map(int, input().split()))[:num]\n\nc = dict()\nfor p in poks:\n    for d in factor(p):\n        if d in c.keys():\n            c[d] += 1\n        else:\n            c[d] = 1\n\nif c:\n    print(max(c.values()))\nelse:\n    print(1)", "generated_code": "import functools\n\n\n@functools.lru_cache(maxsize=10000)\ndef factor(n):res = []\n    d = 2\n    while d * d <= n:\n        if n % d == 0:\n            res.append(d)\n            n //= d\n        else:\n            d += 1\n    if n > 1:\n        res.append(n)\n    return set(res)\n\nnum = int(input())\n\npoks = list(map(int, input().split()))[:num]\n\nc = dict()\nfor p in poks:\n    for d in factor(p):\n        if not (d in c.keys()):\n            c[d] += 1\n        else:\n            c[d] = 1\n\nif c:\n    print(max(c.values()))\nelse:\n    print(1)", "score": 0.0, "codebleu": 0.9519427843873597, "crystalbleu": 0.96, "codebertscore": 1.0, "codescore": 0.9937876462936401, "surfaceSim": 0.49524714828897337, "abs_surfaceSim_minus_score": 0.49524714828897337, "source": "local", "local_type": "MUT"}
{"id": "MBPP_403_1", "golden_code": "def list_tuple(listx):\r\n  tuplex = tuple(listx)\r\n  return tuplex", "generated_code": "def list_tuple(myList):\n\tres = []\n\tfor i in myList:\n\t\tres.append(i)\n\treturn res\n\n\n\n\n\n\n\n\n\n\n\n'''\nYour code here\n\n'''\nfrom collections import OrderedDict\n\nVennters = OrderedDict()\nVennator = None", "score": 0.0, "codebleu": 0.2480599706325196, "crystalbleu": 0, "codebertscore": 0.76, "codescore": 0.01893317699432373, "surfaceSim": 0.4685968137254902, "abs_surfaceSim_minus_score": 0.4685968137254902, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_42_OP_1", "golden_code": "def incr_list(l: list):\n    return [(e + 1) for e in l]", "generated_code": "def incr_list(lst):\n    return list(map(lambda x: x + 1, lst))", "score": 1.0, "codebleu": 0.2234017435696824, "crystalbleu": 0, "codebertscore": 0.89, "codescore": 0.9194447994232178, "surfaceSim": 0.6155913978494623, "abs_surfaceSim_minus_score": 0.38440860215053774, "source": "local", "local_type": "OP"}
{"id": "LOCAL_PIE_p02680_s341076610_MUT_15", "golden_code": "import sys\n(n, m, *abcdef) = list(map(int, sys.stdin.buffer.read().split()))\nver_lines = []\nhor_lines = []\nx_list = set()\ny_list = set()\nn3 = n * 3\nfor (a, b, c) in zip(abcdef[0:n3:3], abcdef[1:n3:3], abcdef[2:n3:3]):\n    y_list.add(a)\n    y_list.add(b)\n    x_list.add(c)\n    ver_lines.append((a, b, c))\nfor (d, e, f) in zip(abcdef[n3 + 0::3], abcdef[n3 + 1::3], abcdef[n3 + 2::3]):\n    y_list.add(d)\n    x_list.add(e)\n    x_list.add(f)\n    hor_lines.append((d, e, f))\nx_list.add(0)\ny_list.add(0)\nx_list = sorted(x_list)\ny_list = sorted(y_list)\nx_dict = {x: i for (i, x) in enumerate(x_list, start=1)}\ny_dict = {y: i for (i, y) in enumerate(y_list, start=1)}\nrow_real = len(x_list)\ncol_real = len(y_list)\nrow = row_real + 2\ncol = col_real + 2\nbanned_up_ij = [[0] * row for _ in range(col)]\nbanned_down_ij = [[0] * row for _ in range(col)]\nbanned_left_ij = [[0] * col for _ in range(row)]\nbanned_right_ij = [[0] * col for _ in range(row)]\nfor (a, b, c) in ver_lines:\n    if a > b:\n        (a, b) = (b, a)\n    ai = y_dict[a]\n    bi = y_dict[b]\n    j = x_dict[c]\n    banned_left_ij[j][ai] += 1\n    banned_left_ij[j][bi] -= 1\n    banned_right_ij[j - 1][ai] += 1\n    banned_right_ij[j - 1][bi] -= 1\nfor (d, e, f) in hor_lines:\n    if e > f:\n        (e, f) = (f, e)\n    i = y_dict[d]\n    ej = x_dict[e]\n    fj = x_dict[f]\n    banned_up_ij[i][ej] += 1\n    banned_up_ij[i][fj] -= 1\n    banned_down_ij[i - 1][ej] += 1\n    banned_down_ij[i - 1][fj] -= 1\nbanned_up = [0] * (row * col)\nbanned_down = [0] * (row * col)\nbanned_left = [0] * (row * col)\nbanned_right = [0] * (row * col)\nfor i in range(col):\n    ru = banned_up_ij[i]\n    rd = banned_down_ij[i]\n    ri = row * i\n    banned_up[ri] = ru[0]\n    banned_down[ri] = rd[0]\n    for j in range(1, row):\n        banned_up[ri + j] = banned_up[(ri + j) - 1] + ru[j]\n        banned_down[ri + j] = banned_down[(ri + j) - 1] + rd[j]\nfor j in range(row):\n    rl = banned_left_ij[j]\n    rr = banned_right_ij[j]\n    banned_left[j] = rl[0]\n    banned_right[j] = rr[0]\n    for i in range(1, col):\n        ri0 = (i - 1) * row\n        ri1 = i * row\n        banned_left[ri1 + j] = banned_left[ri0 + j] + rl[i]\n        banned_right[ri1 + j] = banned_right[ri0 + j] + rr[i]\ns = (row * y_dict[0]) + x_dict[0]\nenable = (([-1] * row) + ((([-1] + ([0] * (row - 2))) + [-1]) * (col - 2))) + ([-1] * row)\nq = [s]\nmoves = [(-row, banned_up), (-1, banned_left), (1, banned_right), (row, banned_down)]\nwhile q:\n    c = q.pop()\n    if enable[c] == 1:\n        continue\n    elif enable[c] == -1:\n        print('INF')\n        exit()\n    enable[c] = 1\n    for (dc, banned) in moves:\n        if banned[c]:\n            continue\n        nc = c + dc\n        if enable[nc] == 1:\n            continue\n        q.append(nc)\nans = 0\nfor i in range(col):\n    ri = i * row\n    for j in range(row):\n        if enable[ri + j] != 1:\n            continue\n        t = y_list[i - 1]\n        b = y_list[i]\n        l = x_list[j - 1]\n        r = x_list[j]\n        ans += (b - t) * (r - l)\nprint(ans)", "generated_code": "import sys\n(n, m, *abcdef) = list(map(int, sys.stdin.buffer.read().split()))\nver_lines = []\nhor_lines = []\nx_list = set()\ny_list = set()\nn3 = n * 3\nfor (a, b, c) in zip(abcdef[0:n3:3], abcdef[1:n3:3], abcdef[2:n3:3]):\n    y_list.add(a)\n    y_list.add(b)\n    x_list.add(c)\n    ver_lines.append((a, b, c))\nfor (d, e, f) in zip(abcdef[n3 + 0::3], abcdef[n3 + 1::3], abcdef[n3 + 2::3]):\n    y_list.add(d)\n    x_list.add(e)\n    x_list.add(f)\n    hor_lines.append((d, e, f))\nx_list.add(0)\ny_list.add(0)\nx_list = sorted(x_list)\ny_list = sorted(y_list)\nx_dict = {x: i for (i, x) in enumerate(x_list, start=1)}\ny_dict = {y: i for (i, y) in enumerate(y_list, start=1)}\nrow_real = len(x_list)\ncol_real = len(y_list)\nrow = row_real + 2\ncol = col_real - 2\nbanned_up_ij = [[0] * row for _ in range(col)]\nbanned_down_ij = [[0] * row for _ in range(col)]\nbanned_left_ij = [[0] * col for _ in range(row)]\nbanned_right_ij = [[0] * col for _ in range(row)]\nfor (a, b, c) in ver_lines:\n    if a > b:\n        (a, b) = (b, a)\n    ai = y_dict[a]\n    bi = y_dict[b]\n    j = x_dict[c]\n    banned_left_ij[j][ai] += 1\n    banned_left_ij[j][bi] -= 1\n    banned_right_ij[j - 1][ai] += 1\n    banned_right_ij[j - 1][bi] -= 1\nfor (d, e, f) in hor_lines:\n    if e > f:\n        (e, f) = (f, e)\n    i = y_dict[d]\n    ej = x_dict[e]\n    fj = x_dict[f]\n    banned_up_ij[i][ej] += 1\n    banned_up_ij[i][fj] -= 1\n    banned_down_ij[i - 1][ej] += 1\n    banned_down_ij[i - 1][fj] -= 1\nbanned_up = [0] * (row * col)\nbanned_down = [0] * (row * col)\nbanned_left = [0] * (row * col)\nbanned_right = [0] * (row * col)\nfor i in range(col):\n    ru = banned_up_ij[i]\n    rd = banned_down_ij[i]\n    ri = row * i\n    banned_up[ri] = ru[0]\n    banned_down[ri] = rd[0]\n    for j in range(1, row):\n        banned_up[ri + j] = banned_up[(ri + j) - 1] + ru[j]\n        banned_down[ri + j] = banned_down[(ri + j) - 1] + rd[j]\nfor j in range(row):\n    rl = banned_left_ij[j]\n    rr = banned_right_ij[j]\n    banned_left[j] = rl[0]\n    banned_right[j] = rr[0]\n    for i in range(1, col):\n        ri0 = (i - 1) * row\n        ri1 = i * row\n        banned_left[ri1 + j] = banned_left[ri0 + j] + rl[i]\n        banned_right[ri1 + j] = banned_right[ri0 + j] + rr[i]\ns = (row * y_dict[0]) + x_dict[0]\nenable = (([-1] * row) + ((([-1] + ([0] * (row - 2))) + [-1]) * (col - 2))) + ([-1] * row)\nq = [s]\nmoves = [(-row, banned_up), (-1, banned_left), (1, banned_right), (row, banned_down)]\nwhile q:\n    c = q.pop()\n    if enable[c] == 1:\n        continue\n    elif enable[c] == -1:\n        print('INF')\n        exit()\n    enable[c] = 1\n    for (dc, banned) in moves:\n        if banned[c]:\n            continue\n        nc = c + dc\n        if enable[nc] == 1:\n            continue\n        q.append(nc)\nans = 0\nfor i in range(col):\n    ri = i * row\n    for j in range(row):\n        if enable[ri + j] != 1:\n            continue\n        t = y_list[i - 1]\n        b = y_list[i]\n        l = x_list[j - 1]\n        r = x_list[j]\n        ans += (b - t) * (r - l)\nprint(ans)", "score": 0.0, "codebleu": 0.9973984967720897, "crystalbleu": 1.0, "codebertscore": 1.0, "codescore": 0.9547415971755981, "surfaceSim": 0.9998327199732352, "abs_surfaceSim_minus_score": 0.9998327199732352, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_HE_157_MUT_39", "golden_code": "import os\n\ndef right_angle_triangle(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return True if the three\n    sides form a right-angled triangle, False otherwise.\n    A right-angled triangle is a triangle in which one angle is right angle or \n    90 degree.\n    Example:\n    right_angle_triangle(3, 4, 5) == True\n    right_angle_triangle(1, 2, 3) == False\n    '''\n    return (a * a == (b * b) + (c * c) or b * b == (a * a) + (c * c) or c * c == (a * a) + (b * b))", "generated_code": "import os\n\ndef right_angle_triangle(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return True if the three\n    sides form a right-angled triangle, False otherwise.\n    A right-angled triangle is a triangle in which one angle is right angle or \n    90 degree.\n    Example:\n    right_angle_triangle(3, 4, 5) == True\n    right_angle_triangle(1, 2, 3) == False\n    '''\n    pass", "score": 0.0, "codebleu": 0.5639894348327876, "crystalbleu": 0, "codebertscore": 0.94, "codescore": 0.018481185659766197, "surfaceSim": 0.6505669661959778, "abs_surfaceSim_minus_score": 0.6505669661959778, "source": "local", "local_type": "MUT"}
{"id": "MBPP_23_22", "golden_code": "def same_Length(A,B): \r\n    while (A > 0 and B > 0): \r\n        A = A / 10; \r\n        B = B / 10; \r\n    if (A == 0 and B == 0): \r\n        return True; \r\n    return False; ", "generated_code": "def same_Length(A,B): \n\tif len(str(A))==len(str(B)): \n\t\treturn True\n\treturn False\nUST = 97\nMOD = 256", "score": 0.639, "codebleu": 0.15354294150912623, "crystalbleu": 0, "codebertscore": 0.78, "codescore": 0.5066372752189636, "surfaceSim": 0.6573529411764707, "abs_surfaceSim_minus_score": 0.018352941176470683, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_142_MUT_1", "golden_code": "import os\n\ndef sum_squares(lst):\n    result = []\n    for i in range(len(lst)):\n        if i % 3 == 0:\n            result.append(lst[i] ** 2)\n        elif (i % 4 == 0 and i % 3 != 0):\n            result.append(lst[i] ** 3)\n        else:\n            result.append(lst[i])\n    return sum(result)", "generated_code": "import os\n\ndef sum_squares(lst):\n    result = []\n    for i in range(len(lst)):\n        if i * 3 == 0:\n            result.append(lst[i] ** 2)\n        elif (i % 4 == 0 and i % 3 != 0):\n            result.append(lst[i] ** 3)\n        else:\n            result.append(lst[i])\n    return sum(result)", "score": 0.3543, "codebleu": 0.9666069517141741, "crystalbleu": 0.96, "codebertscore": 0.99, "codescore": 0.9936457872390747, "surfaceSim": 0.9810462919225319, "abs_surfaceSim_minus_score": 0.626746291922532, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_APPS_1387_9_MUT_13", "golden_code": "import sys\n\nnums = [int(x) for x in sys.stdin.readline().split(' ')]\na = [int(x) for x in sys.stdin.readline().split(' ')]\n\nt = nums[1]\n\ncurr = 1\nwhile curr < t:\n    curr += a[curr - 1]\nif curr == t:\n    print('YES')\nelse:\n    print('NO')", "generated_code": "import sys\n\npass\na = [int(x) for x in sys.stdin.readline().split(' ')]\n\nt = nums[1]\n\ncurr = 1\nwhile curr < t:\n    curr += a[curr - 1]\nif curr == t:\n    print('YES')\nelse:\n    print('NO')", "score": 0.0, "codebleu": 0.7767588744132132, "crystalbleu": 0.67, "codebertscore": 0.97, "codescore": 0.9938549399375916, "surfaceSim": 0.8791596638655462, "abs_surfaceSim_minus_score": 0.8791596638655462, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_HE_61_OP_1", "golden_code": "def correct_bracketing(brackets: str):\n    depth = 0\n    for b in brackets:\n        if b == \"(\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0", "generated_code": "def correct_bracketing(seq: str):\n    count = 0\n    for char in seq:\n        count += 1 if char == '(' else -1\n        if count < 0:\n            return False\n    return count == 0", "score": 1.0, "codebleu": 0.4393047740062622, "crystalbleu": 0, "codebertscore": 0.91, "codescore": 0.8722554445266724, "surfaceSim": 0.7758730158730158, "abs_surfaceSim_minus_score": 0.22412698412698417, "source": "local", "local_type": "OP"}
{"id": "LOCAL_HE_69_OP_1", "golden_code": "def search(lst):\n    '''\n    You are given a non-empty list of positive integers. Return the greatest integer that is greater than \n    zero, and has a frequency greater than or equal to the value of the integer itself. \n    The frequency of an integer is the number of times it appears in the list.\n    If no such a value exist, return -1.\n    Examples:\n        search([4, 1, 2, 2, 3, 1]) == 2\n        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n        search([5, 5, 4, 4, 4]) == -1\n    '''\n    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1;\n\n    ans = -1\n    for i in range(1, len(frq)):\n        if frq[i] >= i:\n            ans = i\n\n    return ans", "generated_code": "def search(numbers):\n    '''\n    You are given a non-empty list of positive integers. Return the greatest integer that is greater than \n    zero, and has a frequency greater than or equal to the value of the integer itself. \n    The frequency of an integer is the number of times it appears in the list.\n    If no such a value exist, return -1.\n    '''\n    from collections import Counter\n    frequency = Counter(numbers)\n    result = -1\n    for num, count in frequency.items():\n        if count >= num:\n            result = max(result, num)\n    return result\n", "score": 1.0, "codebleu": 0.4325192735993919, "crystalbleu": 0, "codebertscore": 0.88, "codescore": 0.7830521464347839, "surfaceSim": 0.659443926685306, "abs_surfaceSim_minus_score": 0.34055607331469395, "source": "local", "local_type": "OP"}
{"id": "LOCAL_HE_117_OP_2", "golden_code": "def select_words(s, n):\n    result = []\n    for word in s.split():\n        n_consonants = 0\n        for i in range(0, len(word)):\n            if word[i].lower() not in [\"a\",\"e\",\"i\",\"o\",\"u\"]:\n                n_consonants += 1 \n        if n_consonants == n:\n            result.append(word)\n    return result", "generated_code": "def select_words(text, consonant_count):\n    vowels = set('aeiou')\n    def count_consonants(word):\n        return sum(1 for char in word.lower() if char not in vowels)\n    return [word for word in text.split() if count_consonants(word) == consonant_count]", "score": 1.0, "codebleu": 0.19468442789160834, "crystalbleu": 0, "codebertscore": 0.81, "codescore": 0.8959658145904541, "surfaceSim": 0.539281210592686, "abs_surfaceSim_minus_score": 0.46071878940731403, "source": "local", "local_type": "OP"}
{"id": "APPS_test-1050_16", "golden_code": "from sys import stdin\ninput = stdin.readline\nn,  m, k = list(map(int, input().split()))\nif min(m, k) >= n:\n    print('Yes')\nelse:\n    print('No')", "generated_code": "#!/usr/bin/env python3\nimport sys\ninput = sys.stdin.readline\n\nn, m, k = map(int, input().split())\nans = False\nif k * m < n:\n\tans = True\nelse:\n\tfor i in range(k, n+1):\n\t\tif i * m >= n:\n\t\t\tans = True\nprint(['No', 'Yes'][ans])\n", "score": 0.1626, "codebleu": 0.30915912410079105, "crystalbleu": 0, "codebertscore": 0.83, "codescore": 0.41455549001693726, "surfaceSim": 0.5863095238095238, "abs_surfaceSim_minus_score": 0.42370952380952387, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-1802_67", "golden_code": "q = 10001\nn, a = int(input()), list(map(int, input().split()))\na.sort()\nfor i in range(40000 // (n - 1) + 1):\n    b = [a[j] - j * i for j in range(n)]\n    u, v = max(b), min(b)\n    p = (u - v + 1) // 2\n    if p < q: q, s, d = p, v + p, i\nprint(q)\nprint(s, d)\n\n", "generated_code": "#!/usr/bin/env python3\nimport sys\nn = int(input())\n\ndef rint():\n\treturn list(map(int, sys.stdin.readline().split()))\n\ndata = rint()\nscore = 0\ntot = 0\nmaining = 0\nfor h in rint():\n\t\tif h > score:\n\t\t\tscore = h\n\t\t\ttot += 1\n\t\tif h < score:\n\t\t\tmaining = 1\n\t\telse:\n\t\t\tmapping = -h\n\t\t\tif tot == 0:\n\t\t\t\tbreak\n\t\t\ttot -= 1\n\t\t\tscore += mapping\nprint(tot)\nprint(\"{} {}\".format(score, tot))\n", "score": 0.0, "codebleu": 0.13154992715032113, "crystalbleu": 0, "codebertscore": 0.72, "codescore": 0.0520092248916626, "surfaceSim": 0.463974478680361, "abs_surfaceSim_minus_score": 0.463974478680361, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0555_53", "golden_code": "\"\"\"\nCodeforces Contest 291 Div 2 Problem A\n\nAuthor  : chaotic_iak\nLanguage: Python 3.4.2\n\"\"\"\n\n################################################### SOLUTION\n\ndef main():\n    s = read(0)\n    t = \"\"\n    for i in range(len(s)):\n        t += str(min(int(s[i]), 9-int(s[i])))\n    if t[0] == \"0\": t = \"9\" + t[1:]\n    print(t)\n\n\n#################################################### HELPERS\n\n\n\ndef read(mode=2):\n    # 0: String\n    # 1: List of strings\n    # 2: List of integers\n    inputs = input().strip()\n    if mode == 0: return inputs\n    if mode == 1: return inputs.split()\n    if mode == 2: return list(map(int, inputs.split()))\n\ndef write(s=\"\\n\"):\n    if s is None: s = \"\"\n    if isinstance(s, list): s = \" \".join(map(str, s))\n    s = str(s)\n    print(s, end=\"\")\n\nwrite(main())", "generated_code": "def main():\n\tx = input()\n\tif x == '0':\n\t\tprint(x)\n\t\treturn\n\tz = x.count('9')\n\tprint(int(x.replace('9', '1')) * z)\n\nmain()\n", "score": 0.0, "codebleu": 0.06805928255828612, "crystalbleu": 0.01, "codebertscore": 0.68, "codescore": 0.046675801277160645, "surfaceSim": 0.5440382317801673, "abs_surfaceSim_minus_score": 0.5440382317801673, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-4057_44", "golden_code": "n=int(input())\na=[int(i) for i in input().split()]\np=set([])\nfor i in range(n):\n    p.add(a.count(a[i]))\nprint(max(p))\n", "generated_code": "n=int(input())\na=list(map(int,input().split()))\na.sort()\nd=0\ni=0\nans=0\nwhile i<n:\n\tif a[i]<=d:\n\t\tans+=1\n\t\td=max(d,a[i])\n\t\ti+=1\n\telse:\n\t\twhile d>0 and i<n:            \n\t\t\tif a[i-1]>d:\n\t\t\t\tans+=1\n\t\t\t\td=max(f,a[i-1])\n\t\t\t\ti+=1\n\t\t\telse:\n\t\t\t\tbreak\n\t\td=f\nprint(ans)\n", "score": 0.0, "codebleu": 0.2114710250521794, "crystalbleu": 0, "codebertscore": 0.75, "codescore": 0.07916321605443954, "surfaceSim": 0.4063706563706564, "abs_surfaceSim_minus_score": 0.4063706563706564, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0444_36", "golden_code": "n=int(input())\nprint(n)\nprint(\"1 \" * n)", "generated_code": "def main():\n\tn = int(input())\n\tif n == 1:\n\t\tprint(1)\n\t\tprint()\n\t\treturn\n\telif n == 2:\n\t\tprint(\"1\")\n\t\tprint(\"0 1\")\n\t\treturn\n\ndef __starting_point():\n\tmain()\n\n__starting_point()\n", "score": 0.0, "codebleu": 0.2238095238095238, "crystalbleu": 0, "codebertscore": 0.81, "codescore": 0.09071511030197144, "surfaceSim": 0.4346590909090909, "abs_surfaceSim_minus_score": 0.4346590909090909, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_extra_p04012_s204906128_OP_1", "golden_code": "w = eval(input())\n\nfor l in w:\n\n\tif w.count(l) % 2 == 1:\n\n\t\tprint(\"No\")\n\n\t\tbreak\n\nelse:\n\n\tprint(\"Yes\")", "generated_code": "from collections import Counter\n\ns = eval(input())\n\nc = list(Counter(s).values())\n\nfor n in c:\n\n\tif n & 1 == 1:\n\n\t\tprint(\"No\")\n\n\t\tbreak\n\nelse:\n\n\tprint(\"Yes\")\n\n\n", "score": 1.0, "codebleu": 0.4092466506655565, "crystalbleu": 0, "codebertscore": 0.85, "codescore": 0.48679831624031067, "surfaceSim": 0.6884868421052632, "abs_surfaceSim_minus_score": 0.31151315789473677, "source": "local", "local_type": "OP"}
{"id": "LOCAL_APPS_1471_29_MUT_7", "golden_code": "import sys\nsys.setrecursionlimit(10 ** 7)\n\nN = int(input())\ngraph = [[] for _ in range(N)]\n\nfor _ in range(N - 1):\n    (u, v, w) = list(map(int, input().split()))\n    u -= 1\n    v -= 1\n    graph[u].append([v, w])\n    graph[v].append([u, w])\n\ncolor = [-1] * N\ndef even(v=0, col=0):\n    color[v] = col\n    for i in range(len(graph[v])):\n        (nv, nw) = list(map(int, graph[v][i]))\n        if color[nv] != -1:\n            continue\n        if nw % 2 == 0:\n            even(nv, col)\n        else:even(nv, 1 - col)\n\neven()\nfor i in range(N):\n    print(color[i])", "generated_code": "import sys\nsys.setrecursionlimit(10 ** 7)\n\nN = int(input())\ngraph = [[] for _ in range(N)]\n\nfor _ in range(N - 1):\n    (u, v, w) = list(map(int, input().split()))\n    u -= 1\n    v -= 1\n    graph[u].append([v, w])\n    graph[v].append([u, w])\n\ncolor = [-1] // N\ndef even(v=0, col=0):\n    color[v] = col\n    for i in range(len(graph[v])):\n        (nv, nw) = list(map(int, graph[v][i]))\n        if color[nv] != -1:\n            continue\n        if nw % 2 == 0:\n            even(nv, col)\n        else:even(nv, 1 - col)\n\neven()\nfor i in range(N):\n    print(color[i])", "score": 0.0, "codebleu": 0.9842169683125476, "crystalbleu": 0.97, "codebertscore": 1.0, "codescore": 0.9937503933906555, "surfaceSim": 0.9696396626629185, "abs_surfaceSim_minus_score": 0.9696396626629185, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_HE_154_MUT_14", "golden_code": "import os\n\ndef cycpattern_check(a, b):\n    l = len(b)\n    pat = b + b\n    for i in range((len(a) - l) + 1):\n        for j in range(l + 1):\n            if a[i:i + l] == pat[j:j + l]:\n                return True\n    return False", "generated_code": "import os\n\ndef cycpattern_check(a, b):\n    l = len(b)\n    pat = b + b\n    for i in range((len(a) - l) + 1):\n        for j in range(l + 1):\n            if a[i:i + l] != pat[j:j + l]:\n                return True\n    return False", "score": 0.0159, "codebleu": 0.9667275024455336, "crystalbleu": 0, "codebertscore": 1.0, "codescore": 0.9936980605125427, "surfaceSim": 0.9543093497499038, "abs_surfaceSim_minus_score": 0.9384093497499038, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_HE_125_OP_1", "golden_code": "def split_words(txt):\n    '''\n    Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n    should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n    alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n    Examples\n    split_words(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n    split_words(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n    split_words(\"abcdef\") == 3 \n    '''\n    if \" \" in txt:\n        return txt.split()\n    elif \",\" in txt:\n        return txt.replace(',',' ').split()\n    else:\n        return len([i for i in txt if i.islower() and ord(i)%2 == 0])", "generated_code": "def split_words(text):\n    if ' ' in text:\n        return text.split()\n    if ',' in text:\n        return text.split(',')\n    return sum(1 for char in text if char.islower() and (ord(char) - ord('a')) % 2 == 0)", "score": 0.7619, "codebleu": 0.2984175202273304, "crystalbleu": 0, "codebertscore": 0.75, "codescore": 0.37663841247558594, "surfaceSim": 0.5587874324987727, "abs_surfaceSim_minus_score": 0.2031125675012273, "source": "local", "local_type": "OP"}
{"id": "LOCAL_PIE_p02537_s767194684_MUT_7", "golden_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "generated_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] // (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "score": 0.0, "codebleu": 0.9963221036285097, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9856788516044617, "surfaceSim": 0.9887682303175706, "abs_surfaceSim_minus_score": 0.9887682303175706, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-2349_22", "golden_code": "3\n\nimport os\nimport sys\n\n\ndef main():\n    T = read_int()\n    for _ in range(T):\n        ans = solve(read_int())\n        print(len(ans))\n        print(*ans)\n\n\ndef solve(N):\n    ans = [N]\n    i = 2\n    while i * (i - 1) <= N:\n        v = N // i\n        if ans[-1] != v:\n            ans.append(v)\n        i += 1\n\n    v = ans[-1]\n    for i in range(v - 1, -1, -1):\n        ans.append(i)\n    ans.reverse()\n    return ans\n\n\n###############################################################################\n\nDEBUG = 'DEBUG' in os.environ\n\n\ndef inp():\n    return sys.stdin.readline().rstrip()\n\n\ndef read_int():\n    return int(inp())\n\n\ndef read_ints():\n    return [int(e) for e in inp().split()]\n\n\ndef dprint(*value, sep=' ', end='\\n'):\n    if DEBUG:\n        print(*value, sep=sep, end=end)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "generated_code": "for _ in range (int(input())):\n\tn=int(input())\n\td={0:0,1:0}\n\tfor i in range (2,500):\n\t\td[i]=d[i-1]+i//100\n\tfor iin in range (int((n//500)/100)):\n\t\td[' in ',n-iin-1]+=1\n\tmx=max(d, key=d.get)\n\tans=' '.join(str(x) for x in d[mx] if x!=0)\n\tprint(len(ans))\n\tprint(*ans)\n", "score": 0.0, "codebleu": 0.1381402321617362, "crystalbleu": 0.07, "codebertscore": 0.7, "codescore": 0.23999762535095215, "surfaceSim": 0.5111156494340063, "abs_surfaceSim_minus_score": 0.5111156494340063, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_121_OP_1", "golden_code": "def solution(lst):\n    return sum([x for idx, x in enumerate(lst) if idx%2==0 and x%2==1])", "generated_code": "def solution(data):\n    return sum(data[i] for i in range(0, len(data), 2) if data[i] % 2)\n", "score": 1.0, "codebleu": 0.20994341632609398, "crystalbleu": 0, "codebertscore": 0.83, "codescore": 0.9240514039993286, "surfaceSim": 0.5701798201798203, "abs_surfaceSim_minus_score": 0.4298201798201797, "source": "local", "local_type": "OP"}
{"id": "APPS_test-0861_25", "golden_code": "import math\nm,R=list(map(int,input().split()))\n\ncord=math.sqrt(2*(R**2))\nans=0\nunit=int(2*R)\nx=(m)*(m/2)\nfor i in range(m):\n    ans+=2*R*m\n    ans+=(cord*(m-1))\n    if(i==0 or i==m-1):\n        if(m==1):\n            continue\n        ans+=cord*(m-2)\n    else:\n        if(m==1):\n            continue\n        ans+=cord*(m-3)\n    #left\n    left=(i-1)-1\n    if(left<-1):\n        left=-1\n    ans+=(left+1)*(left/2)*unit\n    #right\n    r=(m-1)-(i)-2\n    if(r<-1):\n        r=-1\n    ans+=(r+1)*(r/2)*unit\nans/=(m**2)\nprint(ans)\n", "generated_code": "import math\n\nm, r = [int(x) for x in input().split()]\n\ndef f(x):\n\treturn math.sqrt(m*m+1*x*x)\n\nret = 0\ntry:\n\twhile True:\n\t\tu = int(input())\n\t\tv = int(input()); d = n = 0.0\n\t\tif (u > m or u < 0) and (v > m and v < 0):\n\t\t\td = f(u)\n\t\t\tu = -u\n\t\t\tv = -v\n\t\tif v == 0:\n\t\t\tret += d\n\t\telse:\n\t\t\tret +=(v-u)\n\t\t\n\tprint(ret)\nexcept:\n\tpass\n", "score": 0.0, "codebleu": 0.09293272941243873, "crystalbleu": 0.06, "codebertscore": 0.75, "codescore": 0.06243559718132019, "surfaceSim": 0.5394340333364723, "abs_surfaceSim_minus_score": 0.5394340333364723, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0306_12", "golden_code": "a,b,p,x = list(map(int, input().strip().split()))\n\n\ndef brute(a,b,p,x):\n    for n in range(1, x+1):\n        if (n*pow(a,n,p)) % p == b:\n            print(n)\n\n#brute(a,b,p,x)\n\nsols = 0\n\ninva = pow(a,p-2,p)\n\n##print('a', inva)\n\na2 = 1\nb2 = b\ns = 0\nd1 = -b\nfac = p*(p-1)\nwhile s < p-1:\n    k = (d1 + s) % p\n    u = k\n    L = x - s - (p-1)*k\n    sols += L//fac + 1\n##    while (p-1)*u + s <= x:\n##        n = (p-1)*u + s\n##        print(s, k, n)\n##        print(n)\n##        #print(n*pow(a,n,p) % p, b)\n##        sols += 1\n##        u += p\n    d1 = (d1 * inva) % p\n    s += 1\n\nprint(sols)\n        \n\n        \n    \n\n", "generated_code": "import sys\ninput = lambda : sys.stdin.readline().rstrip()\nsys.setrecursionlimit(max(1000, 10**9))\nwrite = lambda x: sys.stdout.write(x+\"\\n\")\n\n\na,b, p,x = list(map(int, input().split()))\n", "score": 0.0, "codebleu": 0.041238152371053625, "crystalbleu": 0.06, "codebertscore": 0.64, "codescore": 0.018356095999479294, "surfaceSim": 0.5425204918032787, "abs_surfaceSim_minus_score": 0.5425204918032787, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_extra_p02596_s856754977_OP_1", "golden_code": "def c_repsept():\n\n    K = int(eval(input()))\n\n\n\n    L = 9 * K // 7 if K % 7 == 0 else 9 * K\n\n    if L % 2 == 0 or L % 5 == 0:\n\n        return -1\n\n\n\n    remainder = 1\n\n    for n in range(1, L + 1):\n\n        remainder = (10 * remainder) % L\n\n        if remainder == 1:\n\n            return n\n\n    return -1\n\n\n\nprint((c_repsept()))", "generated_code": "def c_repsept_totient():\n\n    def euler_phi(n):\n\n        \"\"\"正整数 n に対して、n と互いに素な n 以下の正整数の個数\"\"\"\n\n        ret = n\n\n        for i in range(2, int(n**0.5) + 1):\n\n            if n % i == 0:\n\n                ret = ret // i * (i - 1)\n\n                while n % i == 0:\n\n                    n //= i\n\n        if n > 1:\n\n            ret -= ret // n\n\n        return ret\n\n\n\n    def divisor_list(n):\n\n        \"\"\"n の正の約数のリスト\"\"\"\n\n        ret = set()\n\n        for k in range(1, int(n**0.5) + 1):\n\n            if n % k == 0:\n\n                ret.update({k, n // k})\n\n        return sorted(ret)\n\n\n\n    K = int(eval(input()))\n\n    L = 9 * (K // 7 if K % 7 == 0 else K)\n\n\n\n    for d in divisor_list(euler_phi(L)):\n\n        if pow(10, d, L) == 1:\n\n            return d\n\n    return -1\n\n\n\nprint((c_repsept_totient()))", "score": 1.0, "codebleu": 0.31415202356197064, "crystalbleu": 0.18, "codebertscore": 0.76, "codescore": 0.3453344702720642, "surfaceSim": 0.6438248988626822, "abs_surfaceSim_minus_score": 0.35617510113731776, "source": "local", "local_type": "OP"}
{"id": "LOCAL_PIE_extra_p03038_s696312664_OP_1", "golden_code": "n, m = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\nbc = [list(map(int, input().split())) for _ in range(m)]\n\n\n\nbc.sort(key=lambda x: x[1], reverse=True)\n\na.sort()\n\n\n\ni = 0\n\nfor b, c in bc:\n\n    for _ in range(b):\n\n        if i < n and a[i] < c:\n\n            a[i] = c\n\n            i += 1\n\n        else:\n\n            break\n\n\n\nans = sum(a)\n\nprint(ans)\n", "generated_code": "n, m = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\nbc = [list(map(int, input().split())) for _ in range(m)]\n\n\n\nbc.sort(reverse=True, key=lambda x: x[1])\n\n\n\nli = []\n\nl = 0\n\ni = 0\n\nwhile i < m and l < n:\n\n    b, c = bc[i]\n\n    li += [c] * b\n\n    i += 1\n\n    l += b\n\n\n\na += li\n\na.sort(reverse=True)\n\nans = sum(a[:n])\n\nprint(ans)\n", "score": 1.0, "codebleu": 0.5471655220151765, "crystalbleu": 0.5, "codebertscore": 0.93, "codescore": 0.8643576502799988, "surfaceSim": 0.747, "abs_surfaceSim_minus_score": 0.253, "source": "local", "local_type": "OP"}
{"id": "LOCAL_PIE_extra_p03828_s988350400_OP_1", "golden_code": "import math\n\nimport collections\n\n\n\nN = int(eval(input()))\n\na = math.factorial(N)\n\ncheck = []\n\nans = 1\n\ni = 2\n\n\n\nwhile a != 1:\n\n    if a % i == 0:\n\n        a //= i\n\n        check.append(i)\n\n    else:\n\n        i += 1\n\n        \n\ncheck = list(collections.Counter(check).values())\n\nfor i in check:\n\n    ans *= (i+1)\n\n    ans %= 10**9+7\n\nprint(ans)", "generated_code": "from math import factorial\n\n\n\nN = factorial(int(eval(input())))\n\n\n\ni = 2\n\ncheck = 1\n\nans = 1\n\nwhile N != 1:\n\n    if N % i == 0:\n\n        N //= i\n\n        check += 1\n\n    else:\n\n        ans *= check\n\n        check = 1\n\n        i += 1\n\nprint(((ans*check)%(10**9+7)))", "score": 1.0, "codebleu": 0.2056559027691426, "crystalbleu": 0, "codebertscore": 0.89, "codescore": 0.8145675659179688, "surfaceSim": 0.7094017094017094, "abs_surfaceSim_minus_score": 0.29059829059829057, "source": "local", "local_type": "OP"}
{"id": "LOCAL_HE_20_MUT_25", "golden_code": "import os\n\nfrom typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[(float, float)]:\n    closest_pair = None\n    distance = None\n    \n    for (idx, elem) in enumerate(numbers):\n        for (idx2, elem2) in enumerate(numbers):\n            if idx != idx2:\n                if distance is None:\n                    distance = abs(elem - elem2)\n                    closest_pair = tuple(sorted([elem, elem2]))\n                else:\n                    new_distance = abs(elem - elem2)\n                    if new_distance < distance:\n                        distance = new_distance\n                        closest_pair = tuple(sorted([elem, elem2]))\n    \n    return closest_pair", "generated_code": "import os\n\nfrom typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[(float, float)]:\n    closest_pair = None\n    distance = None\n    \n    for (idx, elem) in enumerate(numbers):\n        break\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    return closest_pair", "score": 0.1755, "codebleu": 0.34155592165519477, "crystalbleu": 0.21, "codebertscore": 0.88, "codescore": 0.8493127226829529, "surfaceSim": 0.6543560606060606, "abs_surfaceSim_minus_score": 0.47885606060606056, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_PIE_extra_p03436_s808760844_OP_1", "golden_code": "# -*- coding: utf-8 -*-\n\nfrom queue import Queue\n\nh,w = list(map(int, input().split()))\n\nd = []\n\nfor _ in range(h):\n\n    d.append(eval(input()))\n\ncost = [[0]*w for _ in range(h)]\n\n\n\nq = Queue()\n\nq.put((0,0))\n\nwhile not q.empty():\n\n    hi,wi = q.get()\n\n    if hi==h-1 and wi==w-1:\n\n        break\n\n\n\n    for dh,dw in [[0,1],[1,0],[0,-1],[-1,0]]:\n\n        if h>dh+hi>=0 and w>dw+wi>=0 and d[dh+hi][dw+wi]==\".\":\n\n            if cost[dh+hi][dw+wi]==0 or cost[dh+hi][dw+wi]>cost[hi][wi]+1:\n\n                cost[dh+hi][dw+wi] = cost[hi][wi]+1\n\n                q.put((dh+hi, dw+wi))\n\n\n\nif cost[h-1][w-1]==0:\n\n    print((-1))\n\n    exit()\n\n\n\nres = 0\n\nfor hi in range(h):\n\n    for wi in range(w):\n\n        if (hi==0 and wi==0) or (hi==h-1 and wi==-1):\n\n            continue\n\n        if d[hi][wi]==\".\":\n\n            res += 1\n\n\n\nprint((res - cost[h-1][w-1]))\n", "generated_code": "# -*- coding: utf-8 -*-\n\nfrom collections import deque\n\nh,w = list(map(int, input().split()))\n\nm = [\"#\"*(w+2)] + [\"#\"+eval(input())+\"#\" for _ in range(h)] + [\"#\"*(w+2)]\n\n\n\ncnt = 0\n\nfor hi in range(1,h+1):\n\n    for wi in range(1,w+1):\n\n        if m[hi][wi]==\".\":\n\n            cnt += 1\n\n\n\ninf = 10**9\n\nd = [[inf]*(w+2) for _ in range(h+2)]\n\nq = deque([(1,1,1)])\n\nd[1][1] = 1\n\nwhile len(q):\n\n    ch,cw,r = q.popleft()\n\n\n\n    for hi,wi in [[ch+1,cw],[ch,cw+1],[ch-1,cw],[ch,cw-1]]:\n\n        if m[hi][wi]==\".\" and d[hi][wi]>r+1:\n\n            d[hi][wi]=r+1\n\n            q.append((hi,wi,r+1))\n\n\n\nif d[h][w]==inf:\n\n    print((-1))\n\nelse:\n\n    print((cnt-d[h][w]))", "score": 1.0, "codebleu": 0.2732480097375821, "crystalbleu": 0.25, "codebertscore": 0.84, "codescore": 0.970198392868042, "surfaceSim": 0.6713477909650158, "abs_surfaceSim_minus_score": 0.32865220903498416, "source": "local", "local_type": "OP"}
{"id": "APPS_test-1592_32", "golden_code": "import re\nimport itertools\nfrom collections import Counter, deque\n\nclass Task:\n    tasks = []\n    answer = \"\" \n\t\n    def getData(self):\n        numberOfTasks = int(input())\n        for i in range(0, numberOfTasks):\n            self.tasks += [[int(x) for x in input().split(' ')]]\n        #inFile = open('input.txt', 'r')\n        #inFile.readline().rstrip()\n        #self.childs = inFile.readline().rstrip()\n\n    def solve(self):\n        queueSize, maxQueueSize = 0, 0\n        time, timeOfLastMessage = 1, 1\n        currentTask = 0\n        while currentTask < len(self.tasks) or queueSize > 0:\n            maxQueueSize = max(maxQueueSize, queueSize)\n            if currentTask < len(self.tasks):\n                timeDelta = self.tasks[currentTask][0] - time\n                queueSize -= min(queueSize, timeDelta)\n                time += timeDelta\n            else:\n                timeOfLastMessage = time + queueSize\n                break\n                \n            if currentTask < len(self.tasks) and \\\n                    self.tasks[currentTask][0] == time:\n                queueSize += self.tasks[currentTask][1]\n                currentTask += 1\n        self.answer = str(timeOfLastMessage) + \" \" + str(maxQueueSize)\n\n    def printAnswer(self):\n        print(self.answer)\n        #outFile = open('output.txt', 'w')\n        #outFile.write(self.answer)\n\ntask = Task()\ntask.getData()\ntask.solve()\ntask.printAnswer()\n", "generated_code": "n=int(input())\n\ns=[]\n\nfor i in range(n):\n\n\tx,y=list(map(int,input().split()))\n\n\ts.append([x,y])\n\ns.sort(key=lambda x:x[1])\n\np=[]\n\nmx=0\n\nfor i,j in s:\n\n\tif len(p)==0:\n\n\t\tmp=i\n\n\t\tbreak\n\n\twhile mp>0:\n\n\t\tp.append(mp)\n\n\t\tmp-=1\n\n\tif j>mx:\n\n\t\tp[-1]+=1\n\n\t\tmx=j\n\n\n\nprint(mp,mx)\n\n\n\n\n\n# Made By Mostafa_Khaled\n", "score": 0.0, "codebleu": 0.13341976838762976, "crystalbleu": 0.06, "codebertscore": 0.65, "codescore": 0.144239604473114, "surfaceSim": 0.5554065900067034, "abs_surfaceSim_minus_score": 0.5554065900067034, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_41_10", "golden_code": "def binomial_coeff(n, k): \r\n\tC = [[0 for j in range(k + 1)] \r\n\t\t\tfor i in range(n + 1)] \r\n\tfor i in range(0, n + 1): \r\n\t\tfor j in range(0, min(i, k) + 1): \r\n\t\t\tif (j == 0 or j == i): \r\n\t\t\t\tC[i][j] = 1\r\n\t\t\telse: \r\n\t\t\t\tC[i][j] = (C[i - 1][j - 1] \r\n\t\t\t\t\t\t\t+ C[i - 1][j]) \r\n\treturn C[n][k] \r\ndef lobb_num(n, m): \r\n\treturn (((2 * m + 1) *\r\n\t\tbinomial_coeff(2 * n, m + n)) \r\n\t\t\t\t\t/ (m + n + 1))", "generated_code": "def lobb_num(x, y):\n\twhile y:\n\t\tx, y = y, x % y\n\treturn x", "score": 0.0839, "codebleu": 0.06483436472074894, "crystalbleu": 0.0, "codebertscore": 0.67, "codescore": 0.1747203767299652, "surfaceSim": 0.36957874155705656, "abs_surfaceSim_minus_score": 0.2856787415570565, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_extra_p03416_s658008469_OP_1", "golden_code": "A, B = list(map(int, input().split()))\n\ncount = 0\n\nfor i in range(A, B+1):\n\n    if(str(i) == str(i)[::-1]):\n\n        count += 1\n\nprint(count)\n", "generated_code": "A, B = list(map(int, input().split()))\n\ncount = 0\n\nfor i in range(10):\n\n    for j in range(10):\n\n        for k in range(10):\n\n            if(A <= 10000*i + 1000*j + 100*k + 10*j +i <= B):\n\n                count += 1\n\nprint(count)", "score": 0.645, "codebleu": 0.6415698108997582, "crystalbleu": 0, "codebertscore": 0.85, "codescore": 0.36737746000289917, "surfaceSim": 0.705904689576609, "abs_surfaceSim_minus_score": 0.060904689576608995, "source": "local", "local_type": "OP"}
{"id": "MBPP_9_9", "golden_code": "def check_Concat(str1,str2):\r\n    N = len(str1)\r\n    M = len(str2)\r\n    if (N % M != 0):\r\n        return False\r\n    for i in range(N):\r\n        if (str1[i] != str2[i % M]):\r\n            return False         \r\n    return True", "generated_code": "def check_Concat(str1,str2):\n\treturn str1 == str2 and str1[0]==str2[0]", "score": 0.9774, "codebleu": 0.09647090585257426, "crystalbleu": 0, "codebertscore": 0.79, "codescore": 0.9664639830589294, "surfaceSim": 0.5580357142857143, "abs_surfaceSim_minus_score": 0.41936428571428574, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_8_OP_1", "golden_code": "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    sum_value = 0\n    prod_value = 1\n\n    for n in numbers:\n        sum_value += n\n        prod_value *= n\n    return sum_value, prod_value", "generated_code": "from typing import List, Tuple\n\n\ndef sum_product(vals: List[int]) -> Tuple[int, int]:\n    if not vals:\n        return 0, 1\n    total_sum = sum(vals)\n    total_product = 1\n    for x in vals:\n        total_product *= x\n    return total_sum, total_product\n", "score": 1.0, "codebleu": 0.565247785369685, "crystalbleu": 0, "codebertscore": 0.89, "codescore": 0.9933810234069824, "surfaceSim": 0.7094861660079052, "abs_surfaceSim_minus_score": 0.29051383399209485, "source": "local", "local_type": "OP"}
{"id": "MBPP_18_33", "golden_code": "def is_Isomorphic(str1,str2):          \r\n    dict_str1 = {}\r\n    dict_str2 = {}\r\n    for i, value in enumerate(str1):\r\n        dict_str1[value] = dict_str1.get(value,[]) + [i]        \r\n    for j, value in enumerate(str2):\r\n        dict_str2[value] = dict_str2.get(value,[]) + [j]\r\n    if sorted(dict_str1.values()) == sorted(dict_str2.values()):\r\n        return True\r\n    else:\r\n        return False", "generated_code": "def is_Isomorphic(str3, s1):\n\treturn 0 <= int(str3[0] <= s1) <= len(str3) - 1", "score": 0.1096, "codebleu": 0.05864476443157063, "crystalbleu": 0, "codebertscore": 0.7, "codescore": 0.142965167760849, "surfaceSim": 0.4605012531328321, "abs_surfaceSim_minus_score": 0.35090125313283205, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_extra_p03038_s547925628_OP_1", "golden_code": "import sys\n\ninput = sys.stdin.readline\n\n\n\ndef I(): return int(eval(input()))\n\ndef MI(): return list(map(int, input().split()))\n\ndef LI(): return list(map(int, input().split()))\n\n\n\ndef main():\n\n    mod=10**9+7\n\n    N,M=MI()\n\n    A=LI()\n\n    CB=[[0,0]for _ in range(M)]\n\n    A.sort()\n\n    for i in range(M):\n\n        CB[i][1],CB[i][0]=MI()\n\n        \n\n    CB.sort(reverse=True)\n\n    now=0\n\n    \n\n    for i in range(N):\n\n        if CB[now][1]<=0:\n\n            now+=1\n\n        \n\n        if now>=M:\n\n            break    \n\n        \n\n        ch=CB[now][0]\n\n        if A[i]<ch:\n\n            A[i]=ch\n\n            CB[now][1]-=1\n\n        else:\n\n            break\n\n        \n\n    print((sum(A)))\n\n    \n\n\n\nmain()\n", "generated_code": "import sys\n\ninput = sys.stdin.readline\n\n\n\ndef I(): return int(eval(input()))\n\ndef MI(): return list(map(int, input().split()))\n\ndef LI(): return list(map(int, input().split()))\n\n\n\ndef main():\n\n    mod=10**9+7\n\n    N,M=MI()\n\n    A=LI()\n\n    B=[0]*M\n\n    C=[0]*M\n\n    for i in range(M):\n\n        B[i],C[i]=MI()\n\n    \n\n    C,B=list(zip(*sorted(zip(C,B))))\n\n    B=B[::-1]\n\n    C=C[::-1]\n\n    \n\n    import heapq\n\n    heapq.heapify(A)\n\n    \n\n    for i in range(M):\n\n        b=B[i]\n\n        c=C[i]\n\n        for _ in range(b):\n\n            a=heapq.heappop(A)\n\n            if a>=c:\n\n                heapq.heappush(A,a)\n\n                break\n\n            else:\n\n                heapq.heappush(A,c)\n\n                \n\n    ans=0\n\n    for i in range(N):\n\n        a=heapq.heappop(A)\n\n        ans+=a\n\n        \n\n    print(ans)\n\n\n\nmain()\n", "score": 1.0, "codebleu": 0.5730722615168584, "crystalbleu": 0.46, "codebertscore": 0.85, "codescore": 0.1746569126844406, "surfaceSim": 0.7135356639774619, "abs_surfaceSim_minus_score": 0.28646433602253807, "source": "local", "local_type": "OP"}
{"id": "APPS_test-0251_7", "golden_code": "def ii():\n    return int(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\n\nn, k = mi()\nh = li()\nm = max(h)\nf = [0] * (m + 1)\nfor hi in h:\n    f[hi] += 1\nfor i in range(m - 1, 0, -1):\n    f[i] += f[i + 1]\n\nans = 0\ni = m\nwhile i > 0:\n    if f[i] == n:\n        break\n    j = i\n    cur = 0\n    while j > 0:\n        if cur + f[j] > k:\n            break\n        cur += f[j]\n        j -= 1\n    ans += 1\n    i = j\nprint(ans)\n", "generated_code": "n, k = list(map(int, input().split()))\na = list(map (int, input().lower()))\na.sort()\nd = 0\nfor i in range(n):\n\tif a[i] > i:\n\t\td += 1\n\t\tcontinue\n\telse:\n\t\ti -= a[i]\n\t\twhile i < n and a[i] == a[i + 1]:\n\t\t\ti += 1\n\t\td += i\nprint(d)\n", "score": 0.0036, "codebleu": 0.16338075192814966, "crystalbleu": 0.14, "codebertscore": 0.8, "codescore": 0.05292508378624916, "surfaceSim": 0.6038324420677361, "abs_surfaceSim_minus_score": 0.6002324420677361, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_34_72", "golden_code": "def even_num(x):\r\n  if x%2==0:\r\n     return True\r\n  else:\r\n    return False", "generated_code": "def even_num(x):\n\n\treturn x%2 ==0", "score": 1.0, "codebleu": 0.3406555873209093, "crystalbleu": 0, "codebertscore": 0.83, "codescore": 0.9936878085136414, "surfaceSim": 0.7482051282051282, "abs_surfaceSim_minus_score": 0.2517948717948718, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_extra_p03107_s353947972_OP_1", "golden_code": "S = [int(_) for _ in eval(input())]\n\nlength = len(S)\n\ntemp = [S[0]]\n\nfor x in S[1:]:\n\n    if(len(temp) == 0):\n\n        temp.append(x)\n\n    elif( temp[-1] == x):\n\n        temp.append(x)\n\n    else:\n\n        temp.pop(-1)\n\nprint((length-len(temp)))\n\n        ", "generated_code": "def main():\n\n    A = eval(input())\n\n    print((2*min(A.count(\"0\"),A.count(\"1\"))))\n\n    \n\nif __name__ == \"__main__\":\n\n    main()", "score": 0.6814, "codebleu": 0.0585167579687471, "crystalbleu": 0, "codebertscore": 0.7, "codescore": 0.018403546884655952, "surfaceSim": 0.4744094488188976, "abs_surfaceSim_minus_score": 0.20699055118110238, "source": "local", "local_type": "OP"}
{"id": "APPS_test-0940_65", "golden_code": "USE_STDIO = False\n\nif not USE_STDIO:\n    try: import mypc\n    except: pass\n\ndef main():\n    a = sorted(map(int, input().split(' ')))\n    x = a[0] + a[1] - a[2]\n    if x > 0:\n        print(0)\n    else:\n        print(- x + 1)\n\ndef __starting_point():\n    main()\n\n\n\n\n__starting_point()", "generated_code": "def main():\n\ta, b, c = list(map(int, input().split()))\n\tnum = max(a, b, min(c, b + c))\n\tif num * 2 < a + b + c:\n\t\tprint(num * 2 - a + b - c)\n\telse:\n\t\tprint((a + b) * 2 // 3 + (b + c) * 2 // 2)\n\n\ndef __starting_point():\n\tmain()\n\n__starting_point()\n", "score": 0.135, "codebleu": 0.17011513466905648, "crystalbleu": 0.25, "codebertscore": 0.79, "codescore": 0.02110823430120945, "surfaceSim": 0.5204758636467628, "abs_surfaceSim_minus_score": 0.3854758636467628, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_43_133", "golden_code": "def is_Two_Alter(s):  \r\n    for i in range (len( s) - 2) : \r\n        if (s[i] != s[i + 2]) : \r\n            return False\r\n    if (s[0] == s[1]): \r\n        return False\r\n    return True", "generated_code": "def is_Two_Alter(s):\n\treturn s == list(s)\n\n\n\n\n\n\n\t\n\t\n\treturn abs(int(s)-int(prev))\n\n\n\n\n\n\n\n\nimport math", "score": 0.8283, "codebleu": 0.13905163223732667, "crystalbleu": 0, "codebertscore": 0.74, "codescore": 0.9649791121482849, "surfaceSim": 0.5869349230004968, "abs_surfaceSim_minus_score": 0.24136507699950327, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_43_2", "golden_code": "def is_Two_Alter(s):  \r\n    for i in range (len( s) - 2) : \r\n        if (s[i] != s[i + 2]) : \r\n            return False\r\n    if (s[0] == s[1]): \r\n        return False\r\n    return True", "generated_code": "def is_Two_Alter(s): \n\treturn list(s) == list(s)*2", "score": 0.8168, "codebleu": 0.12541513459369683, "crystalbleu": 0, "codebertscore": 0.76, "codescore": 0.9671502709388733, "surfaceSim": 0.572599531615925, "abs_surfaceSim_minus_score": 0.24420046838407494, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_extra_p03416_s181217545_OP_1", "golden_code": "a, b = list(map(int, input().split()))\n\ncnt = 0\n\n\n\nfor i in range(a, b+1):\n\n    i = str(i)\n\n    if i[0] == i[-1] and i[1] == i[-2]:\n\n        cnt += 1\n\n\n\nprint(cnt)\n", "generated_code": "a, b = list(map(int, input().split()))\n\ncnt = 0\n\n\n\nfor i in range(10):\n\n    for j in range(10):\n\n        for k in range(10):\n\n            c = 10000*i+1000*j+100*k+10*j+i\n\n            if a <= c <= b:\n\n                cnt += 1\n\n\n\nprint(cnt)\n", "score": 1.0, "codebleu": 0.5388050998154557, "crystalbleu": 0, "codebertscore": 0.85, "codescore": 0.9725573658943176, "surfaceSim": 0.6840167364016736, "abs_surfaceSim_minus_score": 0.3159832635983264, "source": "local", "local_type": "OP"}
{"id": "APPS_test-1188_20", "golden_code": "n = int(input())\na = sorted(list(map(int, input().split())))\n\nmaxe = max(a)\ncnt = []\ncur = 1\nk = 0\ni = 0\nwhile i < n:\n    cnt.append(0)\n    while i < n and a[i] < cur:\n        cnt[2 * k] += 1\n        i += 1\n    cnt.append(0)\n    while i < n and a[i] == cur:\n        cnt[2 * k + 1] += 1\n        i += 1\n    k += 1\n    cur *= 2\ncnt.append(0)\ncnt.append(0)\nmaxe = len(cnt) - 1\n\nmaxk = cnt[1]\nwas = False\nfor l in range(maxk):\n    cur = 1\n    while cnt[cur] > 0:\n        cnt[cur] -= 1\n        cur += 2\n    cnt[cur] -= 1\n    cursum = 0\n    ok = True\n    for t in range(maxe, 0, -1):\n        cursum += cnt[t]\n        if cursum > 0:\n            ok = False\n            break\n    if ok:\n        print(l + 1, end=\" \")\n        was = True\n\nif not was:\n    print(-1)", "generated_code": "n = int(input())\na = list(map(int, input().split()))\n\nx = sorted([(a[i], i) for i in range(n)])\n\nans = []\nfor i in range(1, n + 1):\n\tif x[i][1] < x[i - 1][1]:\n\t\tans.append(i)\n\nif len(ans) == 0:\n\tprint(-1)\nelse:\n\tprint(\" \".join(list(map(str, ans))))\n", "score": 0.0, "codebleu": 0.1237562405666775, "crystalbleu": 0.11, "codebertscore": 0.75, "codescore": 0.12273184955120087, "surfaceSim": 0.5821730287859825, "abs_surfaceSim_minus_score": 0.5821730287859825, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_81_MUT_24", "golden_code": "import os\n\ndef numerical_letter_grade(grades):\n    \n    \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append('A+')\n        elif gpa > 3.7:\n            letter_grade.append('A')\n        elif gpa > 3.3:\n            letter_grade.append('A-')\n        elif gpa > 3.0:\n            letter_grade.append('B+')\n        elif gpa > 2.7:\n            letter_grade.append('B')\n        elif gpa > 2.3:\n            letter_grade.append('B-')\n        elif gpa > 2.0:\n            letter_grade.append('C+')\n        elif gpa > 1.7:\n            letter_grade.append('C')\n        elif gpa > 1.3:\n            letter_grade.append('C-')\n        elif gpa > 1.0:\n            letter_grade.append('D+')\n        elif gpa > 0.7:\n            letter_grade.append('D')\n        elif gpa > 0.0:\n            letter_grade.append('D-')\n        else:\n            letter_grade.append('E')\n    return letter_grade", "generated_code": "import os\n\ndef numerical_letter_grade(grades):\n    \n    \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append('A+')\n        elif gpa > 3.7:\n            letter_grade.append('A')\n        elif gpa > 3.3:\n            letter_grade.append('A-')\n        elif gpa > 3.0:\n            letter_grade.append('B+')\n        elif gpa < 2.7:\n            letter_grade.append('B')\n        elif gpa > 2.3:\n            letter_grade.append('B-')\n        elif gpa > 2.0:\n            letter_grade.append('C+')\n        elif gpa > 1.7:\n            letter_grade.append('C')\n        elif gpa > 1.3:\n            letter_grade.append('C-')\n        elif gpa > 1.0:\n            letter_grade.append('D+')\n        elif gpa > 0.7:\n            letter_grade.append('D')\n        elif gpa > 0.0:\n            letter_grade.append('D-')\n        else:\n            letter_grade.append('E')\n    return letter_grade", "score": 0.0524, "codebleu": 0.983196280070576, "crystalbleu": 0.97, "codebertscore": 1.0, "codescore": 0.9936864972114563, "surfaceSim": 0.9767262791852955, "abs_surfaceSim_minus_score": 0.9243262791852955, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-0030_43", "golden_code": "from math import gcd\ndef powmod(a,b,m):\n a%=m\n r=1\n while b:\n  if b&1:r=r*a%m\n  a=a*a%m\n  b>>=1\n return r\n\ndef f(n):\n r=[]\n if (n&1)==0:\n  e=0\n  while (n&1)==0:n>>=1;e+=1\n  yield (2,e)\n p=3\n while n>1:\n  if p*p>n:p=n\n  if n%p:\n   p+=2\n   continue\n  e=1;n//=p\n  while n%p==0:n//=p;e+=1\n  yield (p,e)\n  p+=2\n return r\nm,x=map(int,input().split())\np=2\nr=[(1,1)]\nfor p,e in f(m):\n assert e>=1\n ord=p-1\n assert powmod(x,ord,p)==1\n for pi,ei in f(p-1):\n  while ord % pi == 0 and powmod(x,ord//pi,p)==1: ord//=pi\n ords=[(1,1),(ord,p-1)]\n q=p\n for v in range(2,e+1):\n  q*=p\n  if powmod(x,ord,q)!=1:ord*=p\n  assert powmod(x,ord,q)==1\n  ords.append((ord,q//p*(p-1)))\n r=[(a//gcd(a,c)*c,b*d) for a,b in r for c,d in ords]\nprint(sum(y//x for x,y in r))", "generated_code": "m, x = list(map(int, input().split()))\n\nans = 0\nfirst = True\n\nif m % x == 1:\n\tans += 1\n\nans += (m // x - 1) * (x * (m // x))\n\nprint(ans)\n", "score": 0.0104, "codebleu": 0.09265957263792259, "crystalbleu": 0.0, "codebertscore": 0.68, "codescore": 0.06375133991241455, "surfaceSim": 0.3651222651222651, "abs_surfaceSim_minus_score": 0.35472226512226507, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0636_51", "golden_code": "n,k=map(int,input().split())\nL=list(map(int,input().split()))\nfor i in range(n):\n    L[i]=(L[i],i)\nL.sort()\nans=0\nA=[]\nind=0\nwhile(ind<len(L) and k>=L[ind][0]):\n    ans+=1\n    A.append(L[ind][1]+1)\n    k-=L[ind][0]\n    ind+=1\nprint(ans)\nfor item in A:\n    print(item,end=\" \")\n", "generated_code": "n,k = list(map(int,input().split()))\ns = list(map (int,input().strip().split()))[:n]\nprint(len(set(s)))\nfor i in range(len(s)):\n\tif s[i]==1:\n\t\tprint(i+1)\n\t\tbreak\n", "score": 0.0234, "codebleu": 0.19735942287967545, "crystalbleu": 0.15, "codebertscore": 0.82, "codescore": 0.06110036000609398, "surfaceSim": 0.49506496751624185, "abs_surfaceSim_minus_score": 0.4716649675162419, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0302_20", "golden_code": "\"\"\"\nCodeforces Testing Round 10 Problem C\n\nAuthor  : chaotic_iak\nLanguage: Python 3.3.4\n\"\"\"\n\ndef read(mode=2):\n    # 0: String\n    # 1: List of strings\n    # 2: List of integers\n    inputs = input().strip()\n    if mode == 0:\n        return inputs\n    if mode == 1:\n        return inputs.split()\n    if mode == 2:\n        return [int(x) for x in inputs.split()]\n\ndef write(s=\"\\n\"):\n    if isinstance(s, list): s = \" \".join(s)\n    s = str(s)\n    print(s, end=\"\")\n\n################################################### SOLUTION\ndef g(n):\n    return (10**n-1)//9\n\ndef solve(n):\n    if n <= 6: return n\n    if 7 <= n <= 11: return 13-n\n    l = 1\n    while g(l) < n: l += 1\n    l -= 1\n    gl = g(l)\n    a = n\n    res1 = 0\n    res1 += (a // gl) * l\n    a %= gl\n    res1 += solve(a)\n    b = g(l+1) - n\n    res2 = l+1\n    res2 += (b // gl) * l\n    b %= gl\n    res2 += solve(b)\n    return min(res1, res2)\n\nn, = read()\nprint(solve(n))", "generated_code": "n=int(input())\nif n==1:\n\tprint(1)\nelse:\n\tprint((str(n).count(\"1\"))+1)\n", "score": 0.0122, "codebleu": 0.05955813505771164, "crystalbleu": 0.0, "codebertscore": 0.62, "codescore": 0.05630120262503624, "surfaceSim": 0.4462190466183321, "abs_surfaceSim_minus_score": 0.4340190466183321, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_707_11_OP_1", "golden_code": "n, m = list(map(int, input().split()))\nx = tuple(map(int, input().split()))\ny = min(x)\na = 0\nfor xi in x:\n    b = xi - y\n    while b:\n        a, b = b, a % b\nj = 1\nfor p in input().split():\n    if a % int(p):\n        j += 1\n        continue\n    print(\"YES\")\n    print(y, j)\n    break\nelse:\n    print(\"NO\")", "generated_code": "import sys\nfrom math import gcd\n\nnum1, num2 = map(int, sys.stdin.readline().split())\nvalues = list(map(int, sys.stdin.readline().split()))\nmin_value = min(values)\ngcd_value = 0\nfor value in values:\n    gcd_value = gcd(gcd_value, value - min_value)\n\nposition = 1\nfor divisor in map(int, sys.stdin.readline().split()):\n    if gcd_value % divisor == 0:\n        print(\"YES\")\n        print(min_value, position)\n        break\n    position += 1\nelse:\n    print(\"NO\")\n", "score": 1.0, "codebleu": 0.2568132814176841, "crystalbleu": 0.19, "codebertscore": 0.78, "codescore": 0.6265755295753479, "surfaceSim": 0.6023913043478261, "abs_surfaceSim_minus_score": 0.39760869565217394, "source": "local", "local_type": "OP"}
{"id": "APPS_test-3924_19", "golden_code": "n, k = [int(x) for x in input().split()]\na = [int(x) for x in input().split()]\np = 0\ncp = 0\nsdg = 0\nfdg = 0\ntg = 0\nfplp = 0\nfor d in range(n-1):\n    fdg = a[d]\n    cp = sdg // k + (0 if sdg % k == 0 else 1)\n    fplp = k - sdg % k\n    if fplp == k:\n        fplp = 0\n    fdg -= min(fplp, fdg)\n    cp += fdg // k\n    fdg -= (fdg // k) * k\n    p += cp\n    sdg = fdg\nfdg = a[n-1]\np += (sdg + fdg) // k + (0 if (sdg + fdg) % k == 0 else 1)\nprint(p)\n", "generated_code": "def main():\n\tn, k = list(map(int, input().split()))\n\taa = list(map (int, input().rstrip().split()))[:n]\n\tcount = k\n\tend = 0\n\tstrr = []\n\tfor i in aa:\n\t\tif end < n:\n\t\t\tstrr.append(i)\n\t\t\tif end == n:\n\t\t\t\tend = n\n\t\telse:\n\t\t\tstrR.append(i - k)\n\tstrr.sort()\n\tif end!= n:\n\t\tstrr.append('1')\n\te = 0\n\tfor i, y in enumerate(strr):\n\t\tif e < n:\n\t\t\t\te = e + y\n\t\telse:e = e - k\n\t\tif e >= n:\n\t\t\tbreak\n\tprint(i)\n\n\ndef __starting_point():\n\tmain", "score": 0.0, "codebleu": 0.17172726353869255, "crystalbleu": 0.04, "codebertscore": 0.72, "codescore": 0.019193226471543312, "surfaceSim": 0.47915283494887795, "abs_surfaceSim_minus_score": 0.47915283494887795, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_82_MUT_2", "golden_code": "import os\n\ndef prime_length(string):\n    l = len(string)\n    if (l == 0 or l == 1):\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n            return False\n    return True", "generated_code": "import os\n\ndef prime_length(string):\n    l = len(string)\n    if not ((l == 0 or l == 1)):\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n            return False\n    return True", "score": 0.2877, "codebleu": 0.8731384745785216, "crystalbleu": 0, "codebertscore": 0.99, "codescore": 0.9935732483863831, "surfaceSim": 0.9440217391304347, "abs_surfaceSim_minus_score": 0.6563217391304348, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_HE_157_OP_1", "golden_code": "def right_angle_triangle(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return True if the three\n    sides form a right-angled triangle, False otherwise.\n    A right-angled triangle is a triangle in which one angle is right angle or \n    90 degree.\n    Example:\n    right_angle_triangle(3, 4, 5) == True\n    right_angle_triangle(1, 2, 3) == False\n    '''\n    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b", "generated_code": "def right_angle_triangle(x, y, z):\n    '''\n    Given the lengths of the three sides of a triangle. Return True if the three\n    sides form a right-angled triangle, False otherwise.\n    A right-angled triangle is a triangle in which one angle is right angle or \n    90 degree.\n    Example:\n    right_angle_triangle(3, 4, 5) == True\n    right_angle_triangle(1, 2, 3) == False\n    '''\n    sides = sorted([x, y, z])\n    return sides[2] * sides[2] == sides[0] * sides[0] + sides[1] * sides[1]", "score": 1.0, "codebleu": 0.4377459166653388, "crystalbleu": 0, "codebertscore": 0.92, "codescore": 0.9876137971878052, "surfaceSim": 0.7411797647937278, "abs_surfaceSim_minus_score": 0.2588202352062722, "source": "local", "local_type": "OP"}
{"id": "APPS_test-0672_32", "golden_code": "import itertools\nimport math\n\ndef main():\n\ta, b = list(map(int, input().split()))\n\n\tif a == b:\n\t\tprint(\"infinity\")\n\t\treturn\n\tif a < b:\n\t\tprint(0)\n\t\treturn\n\ta -= b\n\n\tn = 0\n\n\tfor i in range(1, math.ceil(math.sqrt(a))):\n\t\tif (a % i == 0):\n\t\t\tn += (i > b) + (a // i > b)\n\n\tif math.sqrt(a) % 1 == 0 and math.sqrt(a) > b:\n\t\tn += 1\n\n\tprint(n)\n\ndef __starting_point():\n\tmain()\n\n__starting_point()", "generated_code": "import math\n\ndef main():\n\ta,b=list(map(int,input().split()))\n\tx=b//(a-1)\n\ty=math.floor(b/a)\n\tt=2*x+1\n\tz=a-(b-x*x)\n\tif (z*t)==(b**2-z**2) and z!=0:\n\t\tprint(z)\n\telse:\n\t\tprint(\"infinity\")\n\nmain()\n", "score": 0.007, "codebleu": 0.23734874051939664, "crystalbleu": 0.22, "codebertscore": 0.79, "codescore": 0.027099227532744408, "surfaceSim": 0.5920415495157764, "abs_surfaceSim_minus_score": 0.5850415495157764, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_110_OP_1", "golden_code": "def exchange(lst1, lst2):\n    odd = 0\n    even = 0\n    for i in lst1:\n        if i%2 == 1:\n            odd += 1\n    for i in lst2:\n        if i%2 == 0:\n            even += 1\n    if even >= odd:\n        return \"YES\"\n    return \"NO\"", "generated_code": "def exchange(list1, list2):\n    odd_count = sum(1 for x in list1 if x % 2)\n    even_count = sum(1 for x in list2 if x % 2 == 0)\n    return \"YES\" if even_count >= odd_count else \"NO\"", "score": 1.0, "codebleu": 0.15671895855869272, "crystalbleu": 0, "codebertscore": 0.86, "codescore": 0.983227014541626, "surfaceSim": 0.6673913043478261, "abs_surfaceSim_minus_score": 0.3326086956521739, "source": "local", "local_type": "OP"}
{"id": "LOCAL_PIE_extra_p02390_s143749551_OP_1", "golden_code": "S = int(input())\n\n\n\nif S >= 3600:\n\n    h=S//3600\n\n    m=S%3600//60\n\n    s=S%60\n\nelif 3600 > S >= 60:\n\n    h=0\n\n    m=S//60\n\n    s=S%60\n\nelse:\n\n    h=m=0\n\n    s=S\n\nprint(h, m, s, sep=\":\")\n", "generated_code": "s = int(input())\n\nh = s // 3600\n\nm = (s - h * 3600) // 60\n\ns = s -  h * 3600 - m * 60\n\nprint(h, m, s, sep=\":\")\n", "score": 1.0, "codebleu": 0.3010063461075677, "crystalbleu": 0, "codebertscore": 0.85, "codescore": 0.03537585958838463, "surfaceSim": 0.6264111705288176, "abs_surfaceSim_minus_score": 0.37358882947118244, "source": "local", "local_type": "OP"}
{"id": "LOCAL_APPS_170_0_MUT_12", "golden_code": "n = int(input())\nk1 = list(map(int, input().split()[1:]))\nk2 = list(map(int, input().split()[1:]))\n\ni = 0\nwhile True:\n    if (len(k1) == 0 or len(k2) == 0):\n        break\n    if i > 10000:\n        break\n    if k1[0] > k2[0]:\n        k1 = (k1[1:] + k2[0:1]) + k1[0:1]\n        k2 = k2[1:]\n    else:\n        k2 = (k2[1:] + k1[0:1]) + k2[0:1]\n        k1 = k1[1:]\n    i += 1\n\nif i > 10000:\n    print(-1)\nelse:\n    winner = 1\n    if len(k1) == 0:\n        winner = 2\n    print(i, winner)", "generated_code": "n = int(input())\nk1 = list(map(int, input().split()[1:]))\nk2 = list(map(int, input().split()[1:]))\n\ni = 0\nwhile True:\n    if (len(k1) == 0 or len(k2) == 0):\n        break\n    if not (i > 10000):\n        break\n    if k1[0] > k2[0]:\n        k1 = (k1[1:] + k2[0:1]) + k1[0:1]\n        k2 = k2[1:]\n    else:\n        k2 = (k2[1:] + k1[0:1]) + k2[0:1]\n        k1 = k1[1:]\n    i += 1\n\nif i > 10000:\n    print(-1)\nelse:\n    winner = 1\n    if len(k1) == 0:\n        winner = 2\n    print(i, winner)", "score": 0.0, "codebleu": 0.9596719420532649, "crystalbleu": 0.95, "codebertscore": 1.0, "codescore": 0.9936757683753967, "surfaceSim": 0.9756251978474201, "abs_surfaceSim_minus_score": 0.9756251978474201, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_PIE_extra_p03796_s008235718_OP_1", "golden_code": "import math\n\nn = int(eval(input()))\n\n\n\nans = math.factorial(n)  # nの階乗を計算\n\n\n\nif ans >= (10 ** 9)+7:\n\n    ans = ans % ((10 ** 9)+7)\n\n\n\nprint(ans)\n", "generated_code": "n = int(eval(input()))\n\n\n\nans = 1\n\nfor i in range(1, n+1):\n\n    ans = ans * i\n\n    ans = ans % ((10 ** 9)+7)  # 途中で割り算の余りを求めても、最終結果は同じになる\n\n\n\nprint(ans)", "score": 1.0, "codebleu": 0.45508450301466985, "crystalbleu": 0, "codebertscore": 0.8, "codescore": 0.19337743520736694, "surfaceSim": 0.6609271523178808, "abs_surfaceSim_minus_score": 0.3390728476821192, "source": "local", "local_type": "OP"}
{"id": "LOCAL_HE_140_MUT_36", "golden_code": "import os\n\ndef fix_spaces(text):\n    new_text = ''\n    i = 0\n    (start, end) = (0, 0)\n    while i < len(text):\n        if text[i] == ' ':\n            end += 1\n        else:\n            if end - start > 2:\n                new_text += '-' + text[i]\n            elif end - start > 0:\n                new_text += ('_' * (end - start)) + text[i]\n            else:\n                new_text += text[i]\n            (start, end) = (i + 1, i + 1)\n        i += 1\n    if end - start > 2:\n        new_text += '-'\n    elif end - start > 0:\n        new_text += '_'\n    return new_text", "generated_code": "import os\n\ndef fix_spaces(text):\n    new_text = ''\n    i = 0\n    (start, end) = (0, 0)\n    while i < len(text):\n        if text[i] == ' ':\n            end += 1\n        else:\n            if end - start > 2:\n                new_text += '-' + text[i]\n            elif end - start > 0:\n                new_text += ('_' * (end - start)) + text[i]\n            else:\n                new_text += text[i]\n            (start, end) = (i + 1, i + 1)\n        i += 1\n    if end - start < 2:\n        new_text += '-'\n    elif end - start > 0:\n        new_text += '_'\n    return new_text", "score": 0.0165, "codebleu": 0.985944862062112, "crystalbleu": 0.96, "codebertscore": 1.0, "codescore": 0.9937483072280884, "surfaceSim": 0.9991228070175439, "abs_surfaceSim_minus_score": 0.9826228070175439, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_PIE_extra_p03796_s800016333_OP_1", "golden_code": "from math import factorial\n\n\n\nmod = 10**9 + 7\n\nn = int(eval(input()))\n\n\n\nans = factorial(n) % mod\n\nprint(ans)", "generated_code": "N = int(eval(input()))\n\nMOD = 10**9 + 7\n\nans = 1\n\nfor i in range(2, N+1):\n\n    ans *= i\n\n    ans %= MOD\n\nprint(ans)\n", "score": 1.0, "codebleu": 0.3627565411833302, "crystalbleu": 0, "codebertscore": 0.84, "codescore": 0.8822370171546936, "surfaceSim": 0.5943204868154158, "abs_surfaceSim_minus_score": 0.4056795131845842, "source": "local", "local_type": "OP"}
{"id": "APPS_test-3933_59", "golden_code": "n = int(input())\n\na = list(map(int,input().strip().split(' ')))\n\nd = a[1] - a[0]\nfl = True\nfor i in range(2,n):\n\tcd = a[i] - a[i-1]\n\tif d != cd:\n\t\tfl = False\n\t\tbreak\n\t\nif fl:\n\tprint(a[n-1] + d)\nelse:\n\tprint(a[n-1])\n", "generated_code": "import sys\nfrom statistics import mean\n\nsys.setrecursionlimit(100000)\ndef solve(lst):\n\tif len(lst) == 1:\n\t\treturn lst[0]\n\tmn = min(lst)\n\tmx = max(lst) + 1\n\tsm = 0\n\tfor i in lst:\n\t\tsm += i\n\treturn sm * mn + mx\n\ni = 0\nn = int(input())\nlst = list(map(int, input().split()))\nprint(solve(lst))\n", "score": 0.0, "codebleu": 0.16127204286368294, "crystalbleu": 0, "codebertscore": 0.75, "codescore": 0.03431094437837601, "surfaceSim": 0.4436821381696695, "abs_surfaceSim_minus_score": 0.4436821381696695, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_89_OP_2", "golden_code": "def encrypt(s):\n    d = 'abcdefghijklmnopqrstuvwxyz'\n    out = ''\n    for c in s:\n        if c in d:\n            out += d[(d.index(c)+2*2) % 26]\n        else:\n            out += c\n    return out", "generated_code": "def encrypt(input_string):\n    alphabet_set = set('abcdefghijklmnopqrstuvwxyz')\n    alphabet_dict = {char: chr((ord(char) - 97 + 4) % 26 + 97) for char in alphabet_set}\n    result = []\n    for char in input_string:\n        if char in alphabet_set:\n            result.append(alphabet_dict[char])\n        else:\n            result.append(char)\n    return ''.join(result)\n", "score": 1.0, "codebleu": 0.16415587480252666, "crystalbleu": 0, "codebertscore": 0.83, "codescore": 0.2297806292772293, "surfaceSim": 0.6168478260869565, "abs_surfaceSim_minus_score": 0.38315217391304346, "source": "local", "local_type": "OP"}
{"id": "APPS_test-0488_61", "golden_code": "import sys\nfrom collections import defaultdict as di\ncolor = input()\nn = len(color)\n\nlnei = [-1]*n\nrnei = [-1]*n\nto_be_deleted = []\ndeleted = [False]*n\niters = 0\n\nfor i in range(n):\n    if i-1>=0:\n        lnei[i]=i-1\n        if color[i]!=color[i-1]:\n            to_be_deleted.append(i)\n    if i+1<n:\n        rnei[i]=i+1\n        if color[i]!=color[i+1]:\n            to_be_deleted.append(i)\n\nif len(to_be_deleted)==0:\n    print(0)\n    return\n\nwhile True:\n    was_deleted = False\n\n    pot_sui = []\n    for node in to_be_deleted:\n        if deleted[node]:\n            continue\n        was_deleted=True\n        deleted[node]=True\n        \n        if rnei[node]!=-1:\n            lnei[rnei[node]]=lnei[node]\n            pot_sui.append(rnei[node])\n\n        if lnei[node]!=-1:\n            rnei[lnei[node]]=rnei[node]\n            pot_sui.append(lnei[node])\n    \n    \n    to_be_deleted=[]\n    for node in pot_sui:\n        if deleted[node]:\n            continue\n        if lnei[node]!=-1 and color[node]!=color[lnei[node]]:\n            to_be_deleted.append(node)\n        elif rnei[node]!=-1 and color[node]!=color[rnei[node]]:\n            to_be_deleted.append(node)\n    if not was_deleted:\n        break\n    iters += 1\n\nprint(iters)\n", "generated_code": "s=input()\nl=list(s)\nn=len(l)\na=[]\nb=[]\nfor i in range(n-1):\n\tif l[i]!=l[i+1]:\n\t\ta.append(l[i])\n\t\tb.append(l [i+1])\n\t\tfor j in range(i+2,n):\n\t\t\tif l[j]!=l [j-1]:\n\t\t\t\ta.append(g)\n\t\t\t\tb.append(g())\n\t\t\t\tbreak\nprint(len(a)-len(b))\n", "score": 0.0, "codebleu": 0.18878362571662394, "crystalbleu": 0.04, "codebertscore": 0.71, "codescore": 0.1536606252193451, "surfaceSim": 0.4812994812994813, "abs_surfaceSim_minus_score": 0.4812994812994813, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_243_3", "golden_code": "def find_missing(ar,N): \r\n    l = 0\r\n    r = N - 1\r\n    while (l <= r):  \r\n        mid = (l + r) / 2\r\n        mid= int (mid) \r\n        if (ar[mid] != mid + 1 and ar[mid - 1] == mid): \r\n            return (mid + 1)  \r\n        elif (ar[mid] != mid + 1): \r\n            r = mid - 1 \r\n        else: \r\n            l = mid + 1\r\n    return (-1) ", "generated_code": "def find_missing(ar,y):\n\tif (y not in ar) :\n\t\treturn 0\n\telse :\n\t\tcount = 0\n\t\tfor item in ar:\n\t\t\tif item!= y:\n\t\t\t\tcount+=1\n\t\treturn count", "score": 0.0018, "codebleu": 0.07316613582831061, "crystalbleu": 0, "codebertscore": 0.7, "codescore": 0.03573787957429886, "surfaceSim": 0.5538081107814046, "abs_surfaceSim_minus_score": 0.5520081107814045, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_MBPP_247_MUT_25", "golden_code": "import os\n\ndef lps(str):\n    n = len(str)\n    L = [[0 for x in range(n)] for x in range(n)]\n    for i in range(n):\n        L[i][i] = 1\n    for cl in range(2, n + 1):\n        for i in range((n - cl) + 1):\n            j = (i + cl) - 1\n            if (str[i] == str[j] and cl == 2):\n                L[i][j] = 2\n            elif str[i] == str[j]:\n                L[i][j] = L[i + 1][j - 1] + 2\n            else:\n                L[i][j] = max(L[i][j - 1], L[i + 1][j])\n    return L[0][n - 1]", "generated_code": "import os\n\ndef lps(str):\n    n = len(str)\n    L = [[0 for x in range(n)] for x in range(n)]\n    for i in range(n):\n        L[i][i] = 1\n    for cl in range(2, n + 1):\n        for i in range((n - cl) + 1):\n            j = (i + cl) - 1\n            if (str[i] == str[j] and cl == 2):\n                L[i][j] = 2\n            elif str[i] != str[j]:\n                L[i][j] = L[i + 1][j - 1] + 2\n            else:\n                L[i][j] = max(L[i][j - 1], L[i + 1][j])\n    return L[0][n - 1]", "score": 0.2863, "codebleu": 0.9850185702836846, "crystalbleu": 0.97, "codebertscore": 1.0, "codescore": 0.9937636256217957, "surfaceSim": 0.9804505536464299, "abs_surfaceSim_minus_score": 0.6941505536464299, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_HE_49_OP_2", "golden_code": "def modp(n: int, p: int):\n    ret = 1\n    for i in range(n):\n        ret = (2 * ret) % p\n    return ret", "generated_code": "def modp(n: int, p: int):\n    if n == 0:\n        return 1\n    result = pow(2, n, p)\n    return result", "score": 1.0, "codebleu": 0.31505015002528336, "crystalbleu": 0, "codebertscore": 0.88, "codescore": 0.9819895029067993, "surfaceSim": 0.6502157497303129, "abs_surfaceSim_minus_score": 0.34978425026968707, "source": "local", "local_type": "OP"}
{"id": "MBPP_70_66", "golden_code": "def is_abundant(n):\r\n    fctrsum = sum([fctr for fctr in range(1, n) if n % fctr == 0])\r\n    return fctrsum > n", "generated_code": "def is_abundant(n):\n\treturn True if n == 1 else False\n\nss = lambda s: s.sort()", "score": 0.5441, "codebleu": 0.08948106028138314, "crystalbleu": 0, "codebertscore": 0.78, "codescore": 0.6987397074699402, "surfaceSim": 0.5572715572715573, "abs_surfaceSim_minus_score": 0.013171557271557277, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0714_40", "golden_code": "read = lambda: list(map(int, input().split()))\nn = int(input())\na = list(read())\na = [(a[i], i + 1) for i in range(n)]\na.sort()\nfor i in range(n // 2):\n    print(a[i][1], a[n - i - 1][1])\n", "generated_code": "import sys\ninput = sys.stdin.readline\n\nn = int(input())\nA = [int(a) for a in input().split()]\n\nX = sum(A)\nfor i in range(n//2):\n\tA[i] = X%2\n\tX = X//2\n\nif n%2:\n\tA[n//2] = 1\n\nprint(*[A[i] for i in range(1,n,2)])\n", "score": 0.0, "codebleu": 0.2765694230731254, "crystalbleu": 0.17, "codebertscore": 0.84, "codescore": 0.08759935200214386, "surfaceSim": 0.5315018315018315, "abs_surfaceSim_minus_score": 0.5315018315018315, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_79_32", "golden_code": "def min_of_two( x, y ):\r\n    if x < y:\r\n        return x\r\n    return y", "generated_code": "def min_of_two ( x, y):\n\treturn min( x, y )", "score": 1.0, "codebleu": 0.21479400230684553, "crystalbleu": 0, "codebertscore": 0.89, "codescore": 0.9937979578971863, "surfaceSim": 0.7038961038961039, "abs_surfaceSim_minus_score": 0.2961038961038961, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0678_63", "golden_code": "#in the name of god\n#Mr_Rubik\n#http://codeforces.com/problemset/problem/290/C\nfoo=baz=0;quz=1\nfor bar in range(1, int(input()) + 1):\n    foo+=int(input())\n    if foo*quz<baz*bar: \n        break\n    baz,quz=foo,bar\nprint(baz / quz)", "generated_code": "import math\n\ndef calc(v):\n\tb = 1\n\tfor i in range(1, v):\n\t\tb = b * (i+1) / (i+1);\n\treturn b\n\ndef main():\n\tnumt = int(input())\n\twhile numt:\n\t\tnum = int(input());\n\t\tprint(calc(num))\n\t\tnumt -= 1\n\ndef __starting_point():\n\tmain()\n\n__starting_point()\n", "score": 0.0, "codebleu": 0.1711855492073626, "crystalbleu": 0, "codebertscore": 0.73, "codescore": 0.07482590526342392, "surfaceSim": 0.45802975106253796, "abs_surfaceSim_minus_score": 0.45802975106253796, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_extra_p02394_s949778573_OP_1", "golden_code": "ia = [int(i) for i in input().split(\" \")]\n\nW=ia[0]\n\nH=ia[1]\n\nx=ia[2]\n\ny=ia[3]\n\nr=ia[4]\n\nprint((\"Yes\" if 0<=x-r and x+r<=W and 0<=y-r and y+r<=H else \"No\"))", "generated_code": "# encoding:utf-8\n\n\n\ninput = list(map(int, input().split()))\n\nW, H, x, y, r = input\n\n\n\nif x - r < 0 or x + r > W:\n\n\tprint(\"No\")\n\nelif y - r < 0 or y + r > H:\n\n\tprint(\"No\")\n\nelse:\n\n\tprint(\"Yes\")", "score": 1.0, "codebleu": 0.1292306778567408, "crystalbleu": 0, "codebertscore": 0.81, "codescore": 0.7929313778877258, "surfaceSim": 0.5140224358974359, "abs_surfaceSim_minus_score": 0.4859775641025641, "source": "local", "local_type": "OP"}
{"id": "MBPP_2_7", "golden_code": "def min_Num(arr,n):  \r\n    odd = 0\r\n    for i in range(n): \r\n        if (arr[i] % 2): \r\n            odd += 1 \r\n    if (odd % 2): \r\n        return 1\r\n    return 2", "generated_code": "def min_Num(arr,n):  \n\tres = []\n\tfor i in range(1, n + 1):\n\t\tres.append(i)\n\t\t\n\treturn sum(res)\n\n\n\n\n\n\n\n\nll = {}", "score": 0.0902, "codebleu": 0.2172722314726658, "crystalbleu": 0, "codebertscore": 0.8, "codescore": 0.09395686537027359, "surfaceSim": 0.6583850931677019, "abs_surfaceSim_minus_score": 0.5681850931677019, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_22_5", "golden_code": "def find_Extra(arr1,arr2,n) : \r\n    for i in range(0, n) : \r\n        if (arr1[i] != arr2[i]) : \r\n            return i \r\n    return n ", "generated_code": "def find_Extra(arr1,arr2,n) : \n\tfor i in range(len(arr2)):\n\t\tif arr1.count(arr2[i]) > n :\n\t\t\treturn arr2.index(arr2 [i])\n\treturn -1", "score": 0.0, "codebleu": 0.3878975188856366, "crystalbleu": 0, "codebertscore": 0.89, "codescore": 0.08205533027648926, "surfaceSim": 0.7321428571428572, "abs_surfaceSim_minus_score": 0.7321428571428572, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_MBPP_159_MUT_51", "golden_code": "import os\n\ndef month_season(month, days):\n    if month in ('January', 'February', 'March'):\n        season = 'winter'\n    elif month in ('April', 'May', 'June'):\n        season = 'spring'\n    elif month in ('July', 'August', 'September'):\n        season = 'summer'\n    else:\n        season = 'autumn'\n    if (month == 'March' and days > 19):\n        season = 'spring'\n    elif (month == 'June' and days > 20):\n        season = 'summer'\n    elif (month == 'September' and days > 21):\n        season = 'autumn'\n    elif (month == 'October' and days > 21):\n        season = 'autumn'\n    elif (month == 'November' and days > 21):\n        season = 'autumn'\n    elif (month == 'December' and days > 20):\n        season = 'winter'\n    return season", "generated_code": "import os\n\ndef month_season(month, days):\n    if month in ('January', 'February', 'March'):\n        season = 'winter'\n    elif month in ('April', 'May', 'June'):\n        season = 'spring'\n    elif month in ('July', 'August', 'September'):\n        season = 'summer'\n    else:\n        season = 'autumn'\n    if (month == 'March' and days > 19):\n        season = 'spring'\n    elif (month == 'June' and days > 20):\n        season = 'summer'\n    elif (month == 'September' and days > 21):\n        season = 'autumn'\n    elif (month == 'October' and days > 21):\n        season = 'autumn'\n    elif (month == 'November' and days > 21):\n        season = 'autumn'\n    elif (month == 'December' and days > 20):\n        season = 'winter'\n    pass", "score": 0.0, "codebleu": 0.9730871004467346, "crystalbleu": 0.98, "codebertscore": 0.99, "codescore": 0.9937695860862732, "surfaceSim": 0.9456333140543667, "abs_surfaceSim_minus_score": 0.9456333140543667, "source": "local", "local_type": "MUT"}
{"id": "MBPP_81_2", "golden_code": "def concatenate_nested(test_tup1, test_tup2):\r\n  res = test_tup1 + test_tup2\r\n  return (res) ", "generated_code": "def concatenate_nested(a, c):\n\tans = a + c\n\treturn ans", "score": 1.0, "codebleu": 0.37705129107871255, "crystalbleu": 0, "codebertscore": 0.84, "codescore": 0.9762635231018066, "surfaceSim": 0.7741935483870968, "abs_surfaceSim_minus_score": 0.22580645161290325, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_59_3", "golden_code": "def count_elim(num):\r\n  count_elim = 0\r\n  for n in num:\r\n    if isinstance(n, tuple):\r\n        break\r\n    count_elim += 1\r\n  return count_elim", "generated_code": "def count_elim(num): \n\treturn sum([1 for e in [num] if e!= 0 ])", "score": 0.1616, "codebleu": 0.07740762314943181, "crystalbleu": 0, "codebertscore": 0.83, "codescore": 0.13671596348285675, "surfaceSim": 0.4880952380952381, "abs_surfaceSim_minus_score": 0.32649523809523806, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_80_4", "golden_code": "def maximum_segments(n, a, b, c) : \r\n\tdp = [-1] * (n + 10) \r\n\tdp[0] = 0\r\n\tfor i in range(0, n) : \r\n\t\tif (dp[i] != -1) : \r\n\t\t\tif(i + a <= n ): \r\n\t\t\t\tdp[i + a] = max(dp[i] + 1, \r\n\t\t\t\t\t\t\tdp[i + a]) \r\n\t\t\tif(i + b <= n ): \r\n\t\t\t\tdp[i + b] = max(dp[i] + 1, \r\n\t\t\t\t\t\t\tdp[i + b]) \r\n\t\t\tif(i + c <= n ): \r\n\t\t\t\tdp[i + c] = max(dp[i] + 1, \r\n\t\t\t\t\t\t\tdp[i + c]) \r\n\treturn dp[n]", "generated_code": "def maximum_segments(n, a, b, c) : \n\tif a is 1 or c is 1 or b is 1 or n is 1 or a is b:\n\t\treturn (a + b + c - 2) \n\telse:\n\t\tm = 0\n\t\tif c == b:\n\t\t\tm = a\n\t\t\ta = b\n\t\tif b == c:\n\t\t\tb = c\n\t\t\tc = b\n\t\n\treturn max(m,a,b,c)", "score": 0.0745, "codebleu": 0.13716237115504026, "crystalbleu": 0.07, "codebertscore": 0.76, "codescore": 0.04969390109181404, "surfaceSim": 0.5419540229885058, "abs_surfaceSim_minus_score": 0.4674540229885058, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_MBPP_516_MUT_9", "golden_code": "import os\n\ndef radix_sort(nums):\n    RADIX = 10\n    placement = 1\n    max_digit = max(nums)\n    \n    while placement < max_digit:\n        buckets = [list() for _ in range(RADIX)]\n        for i in nums:\n            tmp = int((i / placement) % RADIX)\n            buckets[tmp].append(i)\n        a = 0\n        for b in range(RADIX):\n            buck = buckets[b]\n            for i in buck:\n                nums[a] = i\n                a += 1\n        placement *= RADIX\n    return nums", "generated_code": "import os\n\ndef radix_sort(nums):\n    RADIX = 10\n    placement = 1\n    max_digit = max(nums)\n    \n    while placement < max_digit:\n        buckets = [list() for _ in range(RADIX)]\n        for i in nums:\n            tmp = int((i / placement) % RADIX)\n            buckets[tmp].append(i)\n        a = 0\n        for b in range(RADIX):\n            buck = buckets[b]\n            for i in buck:\n                nums[a] = i\n                a += 1\n        placement *= RADIX\n    return nums", "score": 0.0, "codebleu": 1.0, "crystalbleu": 1.0, "codebertscore": 1.0, "codescore": 0.9937416911125183, "surfaceSim": 1.0, "abs_surfaceSim_minus_score": 1.0, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-0555_21", "golden_code": "s = input()\nns = ''\nfor i, x in enumerate(s):\n\tif '5' <= x <= '8':\n\t\tns += chr(ord('0')+9-(ord(x) - ord('0')))\n\telif x == '9' and i:\n\t\tns += '0'\n\telse:\n\t\tns += x\nprint(ns)\n", "generated_code": "# coding: utf-8\n# Your code here!\nimport sys\nread = sys.stdin.read\nreadline = sys.stdout.write\n\n#neu = int(readline())\nn = int(read().strip())\n\nif(n==0):\n\tprint(0)\nelse:\n\tnum = str(n)\n\t\t\t\t\n\tk = len(num)\n\ts = \"\"\n\tif(k>1):\n\t\tif(num[0]=='0'):\n\t\t\ts = '0'\n\t\t\tk = k-1\n\t\telse:\n\t\t\ts = num[0]\n\t\n\telse:\n\t\tfor i in range(k):\n\t\t\ts += str(int(num[i])-9)\n\t\t\t\n\tprint(int(s))\n", "score": 0.0, "codebleu": 0.18038899077190365, "crystalbleu": 0.04, "codebertscore": 0.73, "codescore": 0.02201698161661625, "surfaceSim": 0.5549145299145299, "abs_surfaceSim_minus_score": 0.5549145299145299, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_190_3", "golden_code": "def two_unique_nums(nums):\r\n  return [i for i in nums if nums.count(i)==1]", "generated_code": "def two_unique_nums(nums):\n    return nums.count(4)", "score": 0.0, "codebleu": 0.17463840445189543, "crystalbleu": 0, "codebertscore": 0.9, "codescore": 0.02279219962656498, "surfaceSim": 0.704954954954955, "abs_surfaceSim_minus_score": 0.704954954954955, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0224_52", "golden_code": "s = input()\ns = s + 'A'\nm = 0\ncur = -1\nwhile cur != len(s)-1:\n    i = cur+1\n    while s[i] not in ['A','E','Y','U','I','O']:\n        i+=1\n    m = max(m,i-cur)\n    cur = i\nprint(m)\n", "generated_code": "def solve(s):\n\ti = s[0]\n\tcount = 0\n\tfor c in s[1:]:\n\t\tif c in 'aeiouyAEIOUY':\n\t\t\tcount += 1\n\t\telse:\n\t\t\tcount = 0\n\t\ti = c\n\treturn count\n\ns = input()\nprint(solve(s))\n", "score": 0.0004, "codebleu": 0.2157380117873794, "crystalbleu": 0, "codebertscore": 0.77, "codescore": 0.06912296265363693, "surfaceSim": 0.4074712643678161, "abs_surfaceSim_minus_score": 0.4070712643678161, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_1039_1_MUT_51", "golden_code": "import sys\ndef input():\n    return sys.stdin.readline().strip()\nfrom collections import deque\ndef main():\n    N = int(input())\n    info = [tuple(map(int, input().split())) for _ in range(N - 1)]\n    (Q, K) = map(int, input().split())\n    queries = [tuple(map(int, input().split())) for _ in range(Q)]\n    \n    to = [[] for _ in range(N)]\n    for (a, b, c) in info:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        to[b].append((a, c))\n    \n    INF = 10 ** 18\n    dist = [INF] * N\n    def dfs(s):\n        stack = deque()\n        push = stack.append\n        pop = stack.pop\n        \n        dist[s] = 0\n        push(s)\n        \n        while stack:\n            now = pop()\n            now_cost = dist[now]\n            \n            for (nv, c) in to[now]:\n                if dist[nv] != INF:\n                    continue\n                dist[nv] = now_cost + c\n                push(nv)\n    \n    \n    K -= 1\n    dfs(K)\n    ans = []\n    for (x, y) in queries:\n        x -= 1\n        y -= 1\n        xy = dist[x] + dist[y]\n        ans.append(xy)\n    \n    print(sep='\\n', *ans)\ndef __starting_point():\n    main()\n__starting_point()", "generated_code": "import sys\ndef input():\n    return sys.stdin.readline().strip()\nfrom collections import deque\ndef main():\n    N = int(input())\n    info = [tuple(map(int, input().split())) for _ in range(N - 1)]\n    (Q, K) = map(int, input().split())\n    queries = [tuple(map(int, input().split())) for _ in range(Q)]\n    \n    to = [[] for _ in range(N)]\n    for (a, b, c) in info:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        to[b].append((a, c))\n    \n    INF = 10 ** 18\n    dist = [INF] * N\n    def dfs(s):\n        stack = deque()\n        push = stack.append\n        pop = stack.pop\n        \n        dist[s] = 0\n        push(s)\n        \n        while stack:\n            now = pop()\n            now_cost = dist[now]\n            \n            for (nv, c) in to[now]:\n                if dist[nv] != INF:\n                    continue\n                dist[nv] = now_cost + c\n                push(nv)\n    \n    \n    K -= 1\n    dfs(K)\n    ans = []\n    for (x, y) in queries:\n        x -= 1\n        y -= 1\n        xy = dist[x] + dist[y]\n        ans.append(xy)\n    \n    pass\ndef __starting_point():\n    main()\n__starting_point()", "score": 0.0, "codebleu": 0.9719701903824672, "crystalbleu": 0.96, "codebertscore": 0.99, "codescore": 0.9938715696334839, "surfaceSim": 0.9520098538503448, "abs_surfaceSim_minus_score": 0.9520098538503448, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_PIE_extra_p03828_s058426510_OP_1", "golden_code": "from functools import reduce\n\nN = int(eval(input()))\n\n\n\nprime_table = [1] * (N+1)\n\n\n\nfor x in range(2, N+1):\n\n    for t in range(2, x+1):\n\n        while x % t == 0:\n\n            prime_table[t] += 1\n\n            x //= t\n\nprint((reduce(lambda x, y: x * y % (int(1e9) + 7), prime_table)))", "generated_code": "def prime_factorize(n):\n\n    while n % 2 == 0:\n\n        a[2] += 1\n\n        n //= 2\n\n    f = 3\n\n    while f * f <= n:\n\n        if n % f == 0:\n\n            a[f] += 1\n\n            n //= f\n\n        else:\n\n            f += 2\n\n    if n != 1:\n\n        a[n] += 1\n\n\n\nN = int(eval(input()))\n\na = [0]*(N+1)\n\nfor i in range(2, N+1):\n\n    prime_factorize(i)\n\nans = 1\n\nfor i in a:\n\n    if i > 0:\n\n        ans *= (i+1)\n\nbig = 10**9 + 7\n\nprint((ans % big))", "score": 1.0, "codebleu": 0.26109975697545995, "crystalbleu": 0.18, "codebertscore": 0.8, "codescore": 0.9904442429542542, "surfaceSim": 0.6321022727272727, "abs_surfaceSim_minus_score": 0.3678977272727273, "source": "local", "local_type": "OP"}
{"id": "LOCAL_PIE_p02599_s870922238_MUT_74", "golden_code": "import sys\nclass BinaryIndexedTree:\n    def __init__(self, A):\n        self.__n = len(A)\n        self.__node = [0] * (self.__n + 1)\n        self.__data = [0] * (self.__n + 1)\n        S = [0] * (self.__n + 1)\n        for i in range(1, self.__n + 1):\n            S[i] = S[i - 1] + A[i - 1]\n            self.__data[i] = A[i - 1]\n            self.__node[i] = S[i] - S[i - (i & (-i))]\n    def add(self, i, v):\n        self.__data[i] += v\n        while i <= self.__n:\n            self.__node[i] += v\n            i += i & (-i)\n    def sum(self, i):\n        rst = 0\n        while i > 0:\n            rst += self.__node[i]\n            i -= i & (-i)\n        return rst\n    def get(self, i, j):\n        if i == j:\n            return self.__data[i]\n        else:\n            return self.sum(j) - self.sum(i - 1)\ndef main():\n    (N, Q) = map(int, input().split())\n    C = list(map(int, input().split()))\n    P = [[] for _ in range(N)]\n    for (i, c) in enumerate(C):\n        P[c - 1].append(i)\n    right = [0] * N\n    for p in P:\n        if len(p):\n            right[p.pop()] = 1\n    BIT = BinaryIndexedTree(right)\n    query = [[] for _ in range(N)]\n    for (i, s) in enumerate(sys.stdin.readlines()):\n        (l, r) = map(int, s.split())\n        query[r - 1].append((l - 1, i))\n    ans = [None] * Q\n    cur = N - 1\n    for (r, q) in enumerate(reversed(query)):\n        r = (N - 1) - r\n        while q:\n            (l, i) = q.pop()\n            while r < cur:\n                c = C[cur] - 1\n                p = P[c]\n                if len(p):\n                    BIT.add(p.pop() + 1, 1)\n                cur -= 1\n            tmp = BIT.get(l + 1, r + 1)\n            ans[i] = tmp\n    print(sep='\\n', *ans)", "generated_code": "import sys\nclass BinaryIndexedTree:\n    def __init__(self, A):\n        self.__n = len(A)\n        self.__node = [0] * (self.__n + 1)\n        self.__data = [0] * (self.__n + 1)\n        S = [0] * (self.__n + 1)\n        for i in range(1, self.__n + 1):\n            S[i] = S[i - 1] + A[i - 1]\n            self.__data[i] = A[i - 1]\n            self.__node[i] = S[i] - S[i - (i & (-i))]\n    def add(self, i, v):\n        self.__data[i] += v\n        while i <= self.__n:\n            self.__node[i] += v\n            i += i & (-i)\n    def sum(self, i):\n        rst = 0\n        while i > 0:\n            rst += self.__node[i]\n            i -= i & (-i)\n        return rst\n    def get(self, i, j):\n        if i == j:\n            return self.__data[i]\n        else:\n            return self.sum(j) - self.sum(i - 1)\ndef main():\n    (N, Q) = map(int, input().split())\n    C = list(map(int, input().split()))\n    P = [[] for _ in range(N)]\n    for (i, c) in enumerate(C):\n        P[c - 1].append(i)\n    right = [0] * N\n    for p in P:\n        if len(p):\n            right[p.pop()] = 1\n    BIT = BinaryIndexedTree(right)\n    query = [[] for _ in range(N)]\n    for (i, s) in enumerate(sys.stdin.readlines()):\n        (l, r) = map(int, s.split())\n        query[r - 1].append((l - 1, i))\n    ans = [None] * Q\n    cur = N - 1\n    for (r, q) in enumerate(reversed(query)):\n        r = (N - 1) - r\n        while q:\n            (l, i) = q.pop()\n            while r < cur:\n                c = C[cur] - 1\n                p = P[c]\n                if len(p):\n                    BIT.add(p.pop() + 1, 1)\n                cur -= 1\n            tmp = BIT.get(l + 1, r + 1)\n            ans[i] = tmp\n            break\n    print(sep='\\n', *ans)", "score": 0.0338, "codebleu": 0.9903292675608045, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9936767220497131, "surfaceSim": 0.9860453472569917, "abs_surfaceSim_minus_score": 0.9522453472569916, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_APPS_3738_2_OP_1", "golden_code": "def minus_two(x, y):\n    return [x[0] - y[0], x[1] - y[1]]\n\ndef will_reach(loc, commands):\n    new_loc = [0, 0]\n    possible_locs = [[0, 0]]\n    for c in commands:\n        if c == \"U\":\n            new_loc[1] += 1\n        elif c == \"D\":\n            new_loc[1] -= 1\n        elif c == \"R\":\n            new_loc[0] += 1\n        elif c == \"L\":\n            new_loc[0] -= 1\n        possible_locs += [list(new_loc)]\n\n        \n    all_destinations = [minus_two(loc, pl) for pl in possible_locs]\n\n\n    for destination in all_destinations :\n        realdx = destination[0]\n        realdy = destination[1]\n\n        reqdx = new_loc[0]\n        reqdy = new_loc[1]\n\n        if destination == [0, 0]:\n            return True\n\n        if reqdx != 0 and realdx != 0:\n            if ((realdy / realdx) == (reqdy / reqdx) \\\n            and (((realdy > 0 and reqdy > 0)) or((realdy < 0 and reqdy < 0)))     \\\n            and (realdy / reqdy) == int(realdy / reqdy)    \\\n            and (realdx / reqdx) == int(realdx / reqdx)): \n                return True\n        if  realdy == reqdy and realdx == reqdx:\n            return True\n        if reqdx == 0 and realdx == 0:\n            if ((reqdy > 0 and realdy > 0) or (reqdy < 0 and realdy < 0)) \\\n            and (realdy / reqdy) == int(realdy / reqdy):\n                return True\n        if reqdy == 0 and realdy == 0:\n\n            if ((reqdx > 0 and realdx > 0) or (reqdx < 0 and realdx < 0)) \\\n            and (realdx / reqdx) == int(realdx / reqdx):\n                return True\n    return False\n\n    \ndef will_reach2(loc, commands):\n    new_loc = [0, 0]\n    available_loc = []\n    for c in commands:\n        if c == \"U\":\n            new_loc[1] += 1\n        elif c == \"D\":\n            new_loc[1] -= 1\n        elif c == \"R\":\n            new_loc[0] += 1\n        elif c == \"L\":\n            new_loc[0] -= 1\n        available_loc += [new_loc]\n    \n\n    realdx = new_loc[0]\n    realdy = new_loc[1]\n\n    reqdx = loc[0]\n    reqdy = loc[1]\n\n    print(\"realdx\", realdx)\n    print(\"realdy\", realdy)\n    print(\"reqdx\", reqdx)\n    print(\"reqdy\", reqdy)\n    \n\n    if reqdx != 0 and realdx != 0:\n        return (realdy / realdx) == (reqdy / reqdx)\n    elif reqdx == 0 and realdx == 0:\n            return reqdy / realdy > 0\n    else:\n        return False    \n\n\ndef main():\n    first_line = input()\n    first_line = first_line.split()\n    \n    loc = [int(first_line[0]), int(first_line[1])]\n\n    cmds = input()\n   \n\n    if (will_reach(loc, cmds)):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n    \n        \n    \nmain()   \n", "generated_code": "def minus_two(a, b):\n    return [a[0] - b[0], a[1] - b[1]]\n\ndef will_reach(target, moves):\n    current_pos = [0, 0]\n    visited_positions = set()\n    visited_positions.add((0, 0))\n    for move in moves:\n        if move == \"U\":\n            current_pos[1] += 1\n        elif move == \"D\":\n            current_pos[1] -= 1\n        elif move == \"R\":\n            current_pos[0] += 1\n        elif move == \"L\":\n            current_pos[0] -= 1\n        visited_positions.add(tuple(current_pos))\n\n    target_deltas = [minus_two(target, list(pos)) for pos in visited_positions]\n\n    for delta in target_deltas:\n        dx, dy = delta\n        final_dx, final_dy = current_pos\n\n        if delta == [0, 0]:\n            return True\n\n        if final_dx != 0 and dx != 0:\n            if (dy / dx == final_dy / final_dx) and (((dy > 0 and final_dy > 0) or (dy < 0 and final_dy < 0))) and (dy % final_dy == 0) and (dx % final_dx == 0):\n                return True\n        if dy == final_dy and dx == final_dx:\n            return True\n        if final_dx == 0 and dx == 0:\n            if ((final_dy > 0 and dy > 0) or (final_dy < 0 and dy < 0)) and (dy % final_dy == 0):\n                return True\n        if final_dy == 0 and dy == 0:\n            if ((final_dx > 0 and dx > 0) or (final_dx < 0 and dx < 0)) and (dx % final_dx == 0):\n                return True\n    return False\n\n\ndef will_reach2(target, moves):\n    final_pos = [0, 0]\n    for move in moves:\n        if move == \"U\":\n            final_pos[1] += 1\n        elif move == \"D\":\n            final_pos[1] -= 1\n        elif move == \"R\":\n            final_pos[0] += 1\n        elif move == \"L\":\n            final_pos[0] -= 1\n\n    dx, dy = final_pos\n    target_dx, target_dy = target\n\n    if target_dx != 0 and dx != 0:\n        return (dy / dx) == (target_dy / target_dx)\n    elif target_dx == 0 and dx == 0:\n        return target_dy / dy > 0\n    else:\n        return False\n\n\ndef main():\n    first_input = input()\n    first_input = first_input.split()\n    target = [int(first_input[0]), int(first_input[1])]\n    commands = input()\n\n    if will_reach(target, commands):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nmain()", "score": 1.0, "codebleu": 0.37641851557751427, "crystalbleu": 0.29, "codebertscore": 0.85, "codescore": 0.8741543292999268, "surfaceSim": 0.8102080989876266, "abs_surfaceSim_minus_score": 0.18979190101237342, "source": "local", "local_type": "OP"}
{"id": "APPS_test-0404_24", "golden_code": "n = int(input())\na = 0\ni = 1\nwhile i*i < n:\n    if n%i == 0:\n        a += 2\n    i += 1\nif i*i == n:\n    a += 1\nprint(a)", "generated_code": "def main():\n\tfrom sys import stdin, stdout\n\tb = int(stdin.readline())\n\tlenb = b.bit_length()\n\tdist = [0]*(lenb+1)\n\tfor i in range(lenb):\n\t\tdist[i+1] = (dist[i] + (1 if (b&(b-1))*(b>>i) else 0))/2\n\tprint(dist[lenb])\n\treturn\n\ndef __starting_point():\n\tmain()\n__starting_point()\n", "score": 0.0, "codebleu": 0.1613527066343656, "crystalbleu": 0, "codebertscore": 0.74, "codescore": 0.03937708958983421, "surfaceSim": 0.30666666666666664, "abs_surfaceSim_minus_score": 0.30666666666666664, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-1290_12", "golden_code": "n, m = map(int, input().split())\nc = list(map(int, input().split()))\ncnt = [0] * n\nfor x in c:\n    cnt[x - 1] += 1\n\nprint(min(cnt))", "generated_code": "def calc(N, M,c):\n\treturn N*(N+1)//2-1+(M-1)*(M-1)//2\n\nN, M = list(map(int, input().split()))\nc = list(map (int, input(). split()))\ncnt = [0]*N\nfor i in range(N):\n\tcnt[i] = min(c[i],cnt[i-1])\nprint(sum(cnt))\n", "score": 0.124, "codebleu": 0.3920291378244949, "crystalbleu": 0.22, "codebertscore": 0.84, "codescore": 0.05681803822517395, "surfaceSim": 0.6610576923076923, "abs_surfaceSim_minus_score": 0.5370576923076923, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_955_11_MUT_4", "golden_code": "n = int(input())\nd = {}\nfor _ in range(n):\n    s = input().split()\n    p = int(s[0])\n    s[1] = list(s[1])\n    s[1].sort()\n    s[1] = ''.join(s[1])\n    if s[1] in d:\n        d[s[1]] = min(d[s[1]], p)\n    else:\n        d[s[1]] = p\ndef get(s):\n    if s in d:\n        return d[s]\n    return 10 ** 6\na = get('A')\nb = get('B')\nc = get('C')\nab = get('AB')\nbc = get('BC')\nac = get('AC')\nabc = get('ABC')\nans = min((a + b) + c, a + bc, b + ac, c + ab, abc, ab + bc, ab + ac, ac + bc)\nif ans < 10 ** 6:\n    print(ans)\nelse:\n    print(-1)", "generated_code": "n = int(input())\nd = {}\nfor _ in range(n):\n    s = input().split()\n    p = int(s[0])\n    s[1] = list(s[1])\n    s[1].sort()\n    s[1] = ''.join(s[1])\n    if s[1] in d:\n        d[s[1]] = min(d[s[1]], p)\n    else:\n        d[s[1]] = p\ndef get(s):\n    if s in d:\n        return d[s]\n    return 10 ** 6\na = get('A')\nb = get('B')\nc = get('C')\nab = get('AB')\nbc = get('BC')\nac = get('AC')\nabc = get('ABC')\nans = min((a + b) - c, a + bc, b + ac, c + ab, abc, ab + bc, ab + ac, ac + bc)\nif ans < 10 ** 6:\n    print(ans)\nelse:\n    print(-1)", "score": 0.0, "codebleu": 0.9877568500407993, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.9938165545463562, "surfaceSim": 0.9805345117845117, "abs_surfaceSim_minus_score": 0.9805345117845117, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_HE_49_OP_1", "golden_code": "def modp(n: int, p: int):\n    ret = 1\n    for i in range(n):\n        ret = (2 * ret) % p\n    return ret", "generated_code": "def modp(n: int, p: int):\n    if n == 0:\n        return 1\n    result = pow(2, n, p)\n    return result", "score": 1.0, "codebleu": 0.31505015002528336, "crystalbleu": 0, "codebertscore": 0.88, "codescore": 0.9819895029067993, "surfaceSim": 0.6502157497303129, "abs_surfaceSim_minus_score": 0.34978425026968707, "source": "local", "local_type": "OP"}
{"id": "LOCAL_HE_37_OP_1", "golden_code": "def sort_even(l: list):\n    evens = l[::2]\n    odds = l[1::2]\n    evens.sort()\n    ans = []\n    for e, o in zip(evens, odds):\n        ans.extend([e, o])\n    if len(evens) > len(odds):\n        ans.append(evens[-1])\n    return ans", "generated_code": "def sort_even(lst: list):\n    even_indices = lst[::2]\n    odd_indices = lst[1::2]\n    sorted_evens = sorted(even_indices)\n    result = [None] * len(lst)\n    result[::2] = sorted_evens\n    result[1::2] = odd_indices\n    return result", "score": 1.0, "codebleu": 0.2097410058855569, "crystalbleu": 0, "codebertscore": 0.83, "codescore": 0.024810047820210457, "surfaceSim": 0.5235411140583555, "abs_surfaceSim_minus_score": 0.47645888594164454, "source": "local", "local_type": "OP"}
{"id": "APPS_test-2144_76", "golden_code": "import math\ndef okay(n):\n    ans=n\n    i=2\n    while i*i<=n:\n        if n%i==0:\n            while n%i==0:\n                n=int(n/i)\n            ans-=int(ans/i)\n        i+=1\n    if n>1:\n        ans-=int(ans/n)\n    return ans\nt=int(input())\nwhile t:\n    t-=1\n    a,m=list(map(int,input().split()))\n    print(okay(int(m/math.gcd(a,m))))\n            \n", "generated_code": "from math import gcd\nfor _ in range(int(input())):\n\ta, m = map(int, input().split())\n\tx = m // a\n\tans = x * (x + 1) // 2\n\tif m % a!= 0:\n\t\tans -= 1\n\tprint(ans)\n", "score": 0.0, "codebleu": 0.13094417352412507, "crystalbleu": 0.11, "codebertscore": 0.76, "codescore": 0.4279428720474243, "surfaceSim": 0.5292580982236155, "abs_surfaceSim_minus_score": 0.5292580982236155, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-3698_4", "golden_code": "def main():\n    s, k = input(), int(input())\n    n = len(s)\n    if k < 2:\n        print((1, n - 1)[k])\n        return\n    tais = [n - i - 1 for i, c in enumerate(s) if c == '1']\n    tlen, cache, res = len(tais), {}, 0\n\n    def c(n, m):\n        if n < m * 2:\n            m = n - m\n        if 0 < m:\n            if (n, m) not in cache:\n                cache[n, m] = (c(n - 1, m - 1) + c(n - 1, m)) % 1000000007\n            return cache[n, m]\n        return not m\n\n    for m in range(n, 0, -1):\n        x, t = m, k\n        while x != 1:\n            y = 0\n            t -= 1\n            while x:\n                y += x & 1\n                x //= 2\n            x = y\n        if t == 1:\n            if len(tais) > m:\n                del tais[m:]\n            res += sum(c(t, m - i) for i, t in enumerate(tais)) + (m <= tlen)\n    print(res % 1000000007)\n\n\ndef __starting_point():\n    from sys import setrecursionlimit\n\n    setrecursionlimit(1050)\n    main()\n\n__starting_point()", "generated_code": "n=int(input())\na=int(input(),2)\nif n==1:\n\tprint(a)\nelse:\n\tx=bin(a)[2:]\n\tfor i in range(len(x)):\n\t\tif x[i]=='1':\n\t\t\tprint(0)\n\t\t\tbreak\n\telse:\n\t\tprint(a)        \n", "score": 0.1292, "codebleu": 0.07648421378443725, "crystalbleu": 0.01, "codebertscore": 0.7, "codescore": 0.09273915737867355, "surfaceSim": 0.4223409989220266, "abs_surfaceSim_minus_score": 0.2931409989220266, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_333_1", "golden_code": "def find_Max_Num(arr,n) : \r\n    arr.sort(reverse = True) \r\n    num = arr[0] \r\n    for i in range(1,n) : \r\n        num = num * 10 + arr[i] \r\n    return num ", "generated_code": "def find_Max_Num(current_position, last_position):\n\tif current_position == last_position:\n\t\treturn 0\n\telse:\n\t\tcurrent_position = last_position\n\t\treturn current_position + 1", "score": 0.0332, "codebleu": 0.10708687198071203, "crystalbleu": 0, "codebertscore": 0.73, "codescore": 0.06286278367042542, "surfaceSim": 0.44691607684529827, "abs_surfaceSim_minus_score": 0.41371607684529826, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_73_72", "golden_code": "def get_noOfways(n):\r\n    if (n == 0):\r\n        return 0;\r\n    if (n == 1):\r\n        return 1; \r\n    return get_noOfways(n - 1) + get_noOfways(n - 2);", "generated_code": "def get_noOfways(n):    \n\tif (n < 2) : return False\n\tfor i in range(2, int(n**0.5)+1):  \n\t\tif n % i == 0:        \n\t\t\treturn False\n\treturn True", "score": 0.0, "codebleu": 0.2500747560331316, "crystalbleu": 0, "codebertscore": 0.81, "codescore": 0.1740543246269226, "surfaceSim": 0.6266666666666667, "abs_surfaceSim_minus_score": 0.6266666666666667, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0978_57", "golden_code": "# -*- coding: utf-8 -*-\n\nk = int(input())\n\ncounter = [0] * 10\ns = ''.join([input().strip() for i in range(4)])\n\nfor c in s:\n    if c == '.':\n        continue\n    counter[int(c)] += 1\n\nm = max(counter)\nprint('NO' if m > 2*k else 'YES')", "generated_code": "def main():\n\tn = int(input())\n\tarr = []\n\tfor i in range(0, n):\n\t\tarr.append(input())\n\t\t\n\tm = 0\n\tfor i, num in enumerate(arr):\n\t\tif i!= 0:\n\t\t\tif arr[i][0] == '.':\n\t\t\t\tret = min(arr[i][1], arr[i-1][1])\n\t\t\t\tif m < ret:\n\t\t\t\t\tm = ret\n\t\t\telse:\n\t\t\t\tpass\n\t\telse:\n\t\t\tpass\n\t\t\n\tif m < 4:\n\t\tprint('NO')\n\telse:\n\t\tprint ('YES')\n\ndef __starting_point():\n\tmain()\n__starting_point()\n", "score": 0.0496, "codebleu": 0.14801640426550172, "crystalbleu": 0.13, "codebertscore": 0.75, "codescore": 0.23425228893756866, "surfaceSim": 0.4801058743169399, "abs_surfaceSim_minus_score": 0.43050587431693993, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_2_20", "golden_code": "def min_Num(arr,n):  \r\n    odd = 0\r\n    for i in range(n): \r\n        if (arr[i] % 2): \r\n            odd += 1 \r\n    if (odd % 2): \r\n        return 1\r\n    return 2", "generated_code": "def min_Num(arr, key, default = 0):\n\treturn default + arr.index(key)", "score": 0.3008, "codebleu": 0.14055152532275716, "crystalbleu": 0, "codebertscore": 0.75, "codescore": 0.07343605160713196, "surfaceSim": 0.5824534161490683, "abs_surfaceSim_minus_score": 0.2816534161490683, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0001_36", "golden_code": "def get(s):\n    ans = 0\n    for i in s:\n        ans += (ord(i) - ord('0'))\n    return ans\n\n\ndef solve1():\n    x = input()\n    n = len(x)\n    best_ans = x\n    best_val = get(x)\n    ans = str('' if int(x[0]) - 1 == 0 else int(x[0]) - 1) + '9' * (n - 1)\n    if get(ans) > best_val or (get(ans) >= best_val and int(ans) > int(best_ans)):\n        best_ans = ans\n        best_val = get(ans)\n    for i in range(1, n):\n        #print(ans)\n        ans = x[:i] + str(int(x[i]) - 1) + '9' * (n - i - 1)\n        if get(ans) > best_val or (get(ans) >= best_val and int(ans) > int(best_ans)):\n            best_ans = ans\n            best_val = get(ans)\n    return best_ans\n    \nbest = [0] * 10000\ndef solve2():\n    nonlocal best\n    was = 0\n    for i in range(1, 10000):\n        if get(str(i)) >= was:\n            best[i] = i\n            was = get(str(i))\n        else:\n            best[i] = best[i - 1]\n    \ndef stress():\n    solve2()\n    for i in range(1, 10000):\n        if int(solve1(str(i))) != best[i]:\n            print(i, best[i], solve1(str(i)))\n\n#stress()\nprint(solve1())", "generated_code": "def main():\n\tx = int(input())\n\ti = 10 ** 18\n\twhile i <= x:\n\t\tans = -9\n\t\tfor j in str(i):\n\t\t\tans += int(j)\n\t\tif ans > 0 and ans + i < x:\n\t\t\tprint(ans)\n\t\t\treturn\n\t\ti += 1\n\tprint(i - 1)\n\n\ndef __starting_point():\n\tmain()\n\n__starting_point()\n", "score": 0.0, "codebleu": 0.09286171925250698, "crystalbleu": 0.01, "codebertscore": 0.74, "codescore": 0.05648426339030266, "surfaceSim": 0.49859287054409, "abs_surfaceSim_minus_score": 0.49859287054409, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_extra_p01105_s457180384_OP_1", "golden_code": "a=65280; b=61680; c=52428; d=43690; e=65535\n\nL = {el: 1 for el in [a, b, c, d, e, 0]}\n\nfor i in range(6):\n\n    R = sorted(L.items(), key=lambda x: x[1])\n\n    for p, l in R:\n\n        if l < 16:\n\n            L[p ^ e] = min(L.get(p ^ e, 16), l+1)\n\n            if l+3 < 16:\n\n                for q, r in R:\n\n                    if l+r+3 <= 16:\n\n                        L[p & q] = min(L.get(p & q, 16), l+r+3)\n\n                        L[p ^ q] = min(L.get(p ^ q, 16), l+r+3)\n\n                    else: break\n\n        else: break\n\nprint(*(L[e & eval(s)] for s in open(0).read().replace(*\"-~\").replace(*\"*&\").replace(*\"1e\").split()[:-1]),sep='\\n')\n", "generated_code": "a=65280; b=61680; c=52428; d=43690; e=65535\n\nfrom heapq import heappush, heappop\n\nbase = [a, b, c, d, e, 0]\n\nQ = [(1, el) for el in base]\n\nL = {el: 1 for el in base}\n\nH = []\n\nwhile Q:\n\n    l, p = heappop(Q)\n\n    if L[p] < l: continue\n\n    if l+1 < L.get(p ^ e, 17):\n\n        L[p^e] = l+1\n\n        if l+1 < 16: heappush(Q, (l+1, p^e))\n\n    if l+3 < 16:\n\n        for q, r in H:\n\n            if l+r+3 <= 16:\n\n                if l+r+3 < L.get(p & q, 17):\n\n                    L[p & q] = l+r+3\n\n                    if l+r+3 < 16: heappush(Q, (l+r+3, p & q))\n\n                if l+r+3 < L.get(p ^ q, 17):\n\n                    L[p ^ q] = l+r+3\n\n                    if l+r+3 < 16: heappush(Q, (l+r+3, p ^ q))\n\n            else: break\n\n    if l < 7: H.append((p, l))\n\nprint(*(L[e & eval(s)] for s in open(0).read().replace(*\"-~\").replace(*\"*&\").replace(*\"1e\").split()[:-1]),sep='\\n')\n", "score": 1.0, "codebleu": 0.4748757942419747, "crystalbleu": 0.51, "codebertscore": 0.9, "codescore": 0.9846730828285217, "surfaceSim": 0.7448644688644688, "abs_surfaceSim_minus_score": 0.2551355311355312, "source": "local", "local_type": "OP"}
{"id": "APPS_test-4159_18", "golden_code": "a, b, k = (int(n) for n in input().split())\nif k < a: print(a-k, b)\nelif a <= k <= a + b: print(\"0\", b - (k - a))\nelse:print(\"0\",\"0\")", "generated_code": "def main():\n\ta,b,k=map(int,input().split())\n\ta_cnt=0\n\tb_cnt=[]\n\tif a>b:\n\t\ta_cnt,b_cnt=[b,a]\n\tfor i in range(k):\n\t\tif a_cnt>=b:\n\t\t\tbreak\n\t\ta_counter=0\n\t\tb_counter=0;\n\t\twhile a_cnt<b:\n\t\t\tif a_counter==a:\n\t\t\t\ta_cnt+=1\n\t\t\telif a_counter<b:\n\t\t\t\taPlayer=a_cnt\n\t\t\t\ta_counter+=1\n\t\t\telse:\n\t\t\t\tb_counter+=1;\n\t\t\t\ta_node=a_cnd[1]\n\t\t\t\ta_condition=a_node-a_counter\n\t\t\t\tif a_condition==0:\n\t\t\t\t\tbreak\n", "score": 0.0, "codebleu": 0.20891128392754998, "crystalbleu": 0, "codebertscore": 0.74, "codescore": 0.018542660400271416, "surfaceSim": 0.4042731462086301, "abs_surfaceSim_minus_score": 0.4042731462086301, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_MBPP_159_MUT_8", "golden_code": "import os\n\ndef month_season(month, days):\n    if month in ('January', 'February', 'March'):\n        season = 'winter'\n    elif month in ('April', 'May', 'June'):\n        season = 'spring'\n    elif month in ('July', 'August', 'September'):\n        season = 'summer'\n    else:\n        season = 'autumn'\n    if (month == 'March' and days > 19):\n        season = 'spring'\n    elif (month == 'June' and days > 20):\n        season = 'summer'\n    elif (month == 'September' and days > 21):\n        season = 'autumn'\n    elif (month == 'October' and days > 21):\n        season = 'autumn'\n    elif (month == 'November' and days > 21):\n        season = 'autumn'\n    elif (month == 'December' and days > 20):\n        season = 'winter'\n    return season", "generated_code": "import os\n\ndef month_season(month, days):\n    if month in ('January', 'February', 'March'):\n        season = 'winter'\n    elif month in ('April', 'May', 'June'):\n        season = 'spring'\n    elif month in ('July', 'August', 'September'):\n        season = 'summer'\n    else:\n        season = 'autumn'\n    if (month == 'March' and days > 19):\n        season = 'spring'\n    elif not ((month == 'June' and days > 20)):\n        season = 'summer'\n    elif (month == 'September' and days > 21):\n        season = 'autumn'\n    elif (month == 'October' and days > 21):\n        season = 'autumn'\n    elif (month == 'November' and days > 21):\n        season = 'autumn'\n    elif (month == 'December' and days > 20):\n        season = 'winter'\n    return season", "score": 0.0, "codebleu": 0.9637746917440838, "crystalbleu": 0.96, "codebertscore": 0.99, "codescore": 0.9937400817871094, "surfaceSim": 0.9511987343312645, "abs_surfaceSim_minus_score": 0.9511987343312645, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_HE_46_OP_1", "golden_code": "def fib4(n: int):\n    results = [0, 0, 2, 0]\n    if n < 4:\n        return results[n]\n\n    for _ in range(4, n + 1):\n        results.append(results[-1] + results[-2] + results[-3] + results[-4])\n        results.pop(0)\n\n    return results[-1]", "generated_code": "def fib4(n: int):\n    cache = [0, 0, 2, 0]\n    if n < 4:\n        return cache[n]\n\n    for i in range(4, n + 1):\n        next_value = sum(cache)\n        cache = cache[1:] + [next_value]\n\n    return cache[-1]", "score": 1.0, "codebleu": 0.5875361150749224, "crystalbleu": 0, "codebertscore": 0.9, "codescore": 0.8928937315940857, "surfaceSim": 0.75875, "abs_surfaceSim_minus_score": 0.24124999999999996, "source": "local", "local_type": "OP"}
{"id": "LOCAL_PIE_p02599_s870922238_MUT_145", "golden_code": "import sys\nclass BinaryIndexedTree:\n    def __init__(self, A):\n        self.__n = len(A)\n        self.__node = [0] * (self.__n + 1)\n        self.__data = [0] * (self.__n + 1)\n        S = [0] * (self.__n + 1)\n        for i in range(1, self.__n + 1):\n            S[i] = S[i - 1] + A[i - 1]\n            self.__data[i] = A[i - 1]\n            self.__node[i] = S[i] - S[i - (i & (-i))]\n    def add(self, i, v):\n        self.__data[i] += v\n        while i <= self.__n:\n            self.__node[i] += v\n            i += i & (-i)\n    def sum(self, i):\n        rst = 0\n        while i > 0:\n            rst += self.__node[i]\n            i -= i & (-i)\n        return rst\n    def get(self, i, j):\n        if i == j:\n            return self.__data[i]\n        else:\n            return self.sum(j) - self.sum(i - 1)\ndef main():\n    (N, Q) = map(int, input().split())\n    C = list(map(int, input().split()))\n    P = [[] for _ in range(N)]\n    for (i, c) in enumerate(C):\n        P[c - 1].append(i)\n    right = [0] * N\n    for p in P:\n        if len(p):\n            right[p.pop()] = 1\n    BIT = BinaryIndexedTree(right)\n    query = [[] for _ in range(N)]\n    for (i, s) in enumerate(sys.stdin.readlines()):\n        (l, r) = map(int, s.split())\n        query[r - 1].append((l - 1, i))\n    ans = [None] * Q\n    cur = N - 1\n    for (r, q) in enumerate(reversed(query)):\n        r = (N - 1) - r\n        while q:\n            (l, i) = q.pop()\n            while r < cur:\n                c = C[cur] - 1\n                p = P[c]\n                if len(p):\n                    BIT.add(p.pop() + 1, 1)\n                cur -= 1\n            tmp = BIT.get(l + 1, r + 1)\n            ans[i] = tmp\n    print(sep='\\n', *ans)", "generated_code": "import sys\nclass BinaryIndexedTree:\n    def __init__(self, A):\n        self.__n = len(A)\n        self.__node = [0] * (self.__n + 1)\n        self.__data = [0] * (self.__n + 1)\n        S = [0] * (self.__n + 1)\n        for i in range(1, self.__n + 1):\n            S[i] = S[i - 1] + A[i - 1]\n            self.__data[i] = A[i - 1]\n            self.__node[i] = S[i] - S[i - (i & (-i))]\n    def add(self, i, v):\n        self.__data[i] += v\n        while i <= self.__n:\n            break\n    \n    def sum(self, i):\n        rst = 0\n        while i > 0:\n            rst += self.__node[i]\n            i -= i & (-i)\n        return rst\n    def get(self, i, j):\n        if i == j:\n            return self.__data[i]\n        else:\n            return self.sum(j) - self.sum(i - 1)\ndef main():\n    (N, Q) = map(int, input().split())\n    C = list(map(int, input().split()))\n    P = [[] for _ in range(N)]\n    for (i, c) in enumerate(C):\n        P[c - 1].append(i)\n    right = [0] * N\n    for p in P:\n        if len(p):\n            right[p.pop()] = 1\n    BIT = BinaryIndexedTree(right)\n    query = [[] for _ in range(N)]\n    for (i, s) in enumerate(sys.stdin.readlines()):\n        (l, r) = map(int, s.split())\n        query[r - 1].append((l - 1, i))\n    ans = [None] * Q\n    cur = N - 1\n    for (r, q) in enumerate(reversed(query)):\n        r = (N - 1) - r\n        while q:\n            (l, i) = q.pop()\n            while r < cur:\n                c = C[cur] - 1\n                p = P[c]\n                if len(p):\n                    BIT.add(p.pop() + 1, 1)\n                cur -= 1\n            tmp = BIT.get(l + 1, r + 1)\n            ans[i] = tmp\n    print(sep='\\n', *ans)", "score": 0.0378, "codebleu": 0.9665656078983311, "crystalbleu": 0.96, "codebertscore": 0.98, "codescore": 0.9936513304710388, "surfaceSim": 0.9800988910896815, "abs_surfaceSim_minus_score": 0.9422988910896815, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-3969_24", "golden_code": "numbers, types = list(map(int, input().split()))\n\nposition = [0] * (numbers)\nbinary_search_array = [1] * (numbers)\n\nfor i in range(numbers):\n    position[i] = int(input().split()[0])\n\nmax_length = int(0)\n\nfor i in range(numbers):\n    low = int(0)\n    high = int(max_length)\n\n    while (low < high):\n        mid = int((low + high) / 2)\n        if (binary_search_array[mid] <= position[i]):\n            low = mid + 1\n        else:\n            high = mid\n\n    binary_search_array[low] = position[i]\n    if (low == max_length):\n        max_length += 1\n\n\nprint(numbers - max_length)\n", "generated_code": "n, m = map(int, input().split())\nx = []\nfor i in range(n):\n\tx.append(list(map(int, input())))\n\nx.sort(key = lambda x: x[1])\nz = set()\nl = 0\nr = m - 1\nc = 0\nwhile l <= r:\n\tm1 = x[l][1]\n\tm2 = x[r][1]\n#    print(m1, m2)\n\tif m1 <= m2:\n\t\tc += 1\n\t\tl += 1\n\telse:\n\t\tr -= 1\n\t\tc -= 1\n\tif c == 0:\n\t\tbreak\nprint(c)\n", "score": 0.0, "codebleu": 0.15384570893165306, "crystalbleu": 0.13, "codebertscore": 0.76, "codescore": 0.1802767664194107, "surfaceSim": 0.5976113405514007, "abs_surfaceSim_minus_score": 0.5976113405514007, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_extra_p03126_s757696098_OP_1", "golden_code": "import functools\n\nprint((len(functools.reduce(lambda x, y: x&y,[set(input().split()[1:]) for _ in [0]*int(input().split()[0])]))))", "generated_code": "print((len(set.intersection(*[set(input().split()[1:]) for _ in [0]*int(input().split()[0])]))))", "score": 1.0, "codebleu": 0.42810642567782325, "crystalbleu": 0, "codebertscore": 0.86, "codescore": 0.22308556735515594, "surfaceSim": 0.6785953177257524, "abs_surfaceSim_minus_score": 0.32140468227424757, "source": "local", "local_type": "OP"}
{"id": "MBPP_14_4", "golden_code": "def sum_even_odd(list1):\r\n    first_even = next((el for el in list1 if el%2==0),-1)\r\n    first_odd = next((el for el in list1 if el%2!=0),-1)\r\n    return (first_even+first_odd)", "generated_code": "def sum_even_odd(list1):\n\treturn sum([i for i in list1 if i%2 == 0])", "score": 0.0116, "codebleu": 0.1480367529747603, "crystalbleu": 0, "codebertscore": 0.86, "codescore": 0.03200101479887962, "surfaceSim": 0.5710227272727273, "abs_surfaceSim_minus_score": 0.5594227272727272, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-3718_24", "golden_code": "n=int(input())\nl=sorted(set(map(int,input().split())))\nfor i in range(1,len(l)-1):\n    if l[i]-l[i-1]==1 and l[i+1]-l[i]==1: print('YES'); break\nelse: print('NO')", "generated_code": "import sys\nn = int(input())\na = list(map(int, input().split()))\nb = set()\nc = []\nfor i in range(n):\n\tb.add(a[i])\n\tc.append(a[i]-min(a[i],2))\n\t\nif len(b) > 2:\n\tprint(\"NO\")\nelse:\n\tprint (\"YES\")\n", "score": 0.2228, "codebleu": 0.32444625714602904, "crystalbleu": 0.25, "codebertscore": 0.83, "codescore": 0.3412216901779175, "surfaceSim": 0.5700000000000001, "abs_surfaceSim_minus_score": 0.34720000000000006, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_20_MUT_23", "golden_code": "import os\n\nfrom typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[(float, float)]:\n    closest_pair = None\n    distance = None\n    \n    for (idx, elem) in enumerate(numbers):\n        for (idx2, elem2) in enumerate(numbers):\n            if idx != idx2:\n                if distance is None:\n                    distance = abs(elem - elem2)\n                    closest_pair = tuple(sorted([elem, elem2]))\n                else:\n                    new_distance = abs(elem - elem2)\n                    if new_distance < distance:\n                        distance = new_distance\n                        closest_pair = tuple(sorted([elem, elem2]))\n    \n    return closest_pair", "generated_code": "import os\n\nfrom typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[(float, float)]:\n    closest_pair = None\n    distance = None\n    \n    for (idx, elem) in enumerate(numbers):\n        for (idx2, elem2) in enumerate(numbers):\n            if idx != idx2:\n                if distance is None:\n                    distance = abs(elem - elem2)\n                    closest_pair = tuple(sorted([elem, elem2]))\n                else:\n                    new_distance = abs(elem - elem2)\n                    if new_distance < distance:\n                        distance = new_distance\n                        pass\n    \n    return closest_pair", "score": 0.4589, "codebleu": 0.8844883629594986, "crystalbleu": 0.86, "codebertscore": 0.99, "codescore": 0.9938592314720154, "surfaceSim": 0.9552030723905723, "abs_surfaceSim_minus_score": 0.49630307239057236, "source": "local", "local_type": "MUT"}
{"id": "MBPP_34_55", "golden_code": "def even_num(x):\r\n  if x%2==0:\r\n     return True\r\n  else:\r\n    return False", "generated_code": "def even_num(x):\n\tif x%2==0:\n\t   return True\n\telse:\n\t   return False\nss = []\nfor i in range(100000):\n\tss.append(i*2)\nprint(ss)\nns = list(ss)", "score": 1.0, "codebleu": 0.6993950927083437, "crystalbleu": 0, "codebertscore": 0.84, "codescore": 0.9936407208442688, "surfaceSim": 0.580952380952381, "abs_surfaceSim_minus_score": 0.419047619047619, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_extra_p03796_s294020052_OP_1", "golden_code": "import math\n\nN=int(eval(input()))\n\nans=math.factorial(N)\n\nprint((ans%(10**9 +7)))", "generated_code": "mod=10**9+7\n\nN=int(eval(input()))\n\nans=1\n\nfor i in range(1,N+1):\n\n  ans*=i\n\n  ans%=mod\n\nprint(ans)", "score": 1.0, "codebleu": 0.2288422712903786, "crystalbleu": 0, "codebertscore": 0.82, "codescore": 0.8569331169128418, "surfaceSim": 0.5731292517006803, "abs_surfaceSim_minus_score": 0.4268707482993197, "source": "local", "local_type": "OP"}
{"id": "MBPP_34_114", "golden_code": "def even_num(x):\r\n  if x%2==0:\r\n     return True\r\n  else:\r\n    return False", "generated_code": "def even_num(num):\n   return num>>1", "score": 0.0645, "codebleu": 0.3062143252693979, "crystalbleu": 0, "codebertscore": 0.81, "codescore": 0.14674964547157288, "surfaceSim": 0.6014285714285714, "abs_surfaceSim_minus_score": 0.5369285714285714, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_25_MUT_7", "golden_code": "import os\n\nfrom typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    import math\n    fact = []\n    i = 2\n    while i <= int(math.sqrt(n) + 1):\n        if n % i == 0:\n            fact.append(i)\n            n //= i\n        else:\n            i += 1\n    \n    if n > 1:\n        fact.append(n)\n    return fact", "generated_code": "import os\n\nfrom typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    import math\n    fact = []\n    i = 2\n    while i <= int(math.sqrt(n) + 1):\n        if not (n % i == 0):\n            fact.append(i)\n            n //= i\n        else:\n            i += 1\n    \n    if n > 1:\n        fact.append(n)\n    return fact", "score": 0.0324, "codebleu": 0.91028259161857, "crystalbleu": 0, "codebertscore": 0.99, "codescore": 0.9935610294342041, "surfaceSim": 0.9608635646687698, "abs_surfaceSim_minus_score": 0.9284635646687698, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_PIE_p02649_s231020544_MUT_129", "golden_code": "def popcount(x):\n    x = x - ((x >> 1) & 1431655765)\n    x = (x & 858993459) + ((x >> 2) & 858993459)\n    x = (x + (x >> 4)) & 252645135\n    x = x + (x >> 8)\n    x = x + (x >> 16)\n    return x & 127\ncmb = [[0 for i in range(51)] for j in range(51)]\ncmb[0][0] = 1\nfor i in range(51):\n    for j in range(51):\n        if (i != 50 and j != 50):\n            cmb[i + 1][j + 1] += cmb[i][j]\n        if i != 50:\n            cmb[i + 1][j] += cmb[i][j]\nfor i in range(1, 51):\n    for j in range(2, 51):\n        cmb[i][j] += cmb[i][j - 1]\n(N, K, T, S) = list(map(int, input().split()))\na = list(map(int, input().split()))\nmust0 = [i for i in range(18) if (S >> i) & 1 == 0]\nmust1 = [i for i in range(18) if (T >> i) & 1 == 1]\nA = []\nfor val in a:\n    check = True\n    for j in must0:\n        check = check & (val >> j) & 1 == 0\n    for j in must1:\n        check = check & (val >> j) & 1 == 1\n    if check:\n        A.append(val)\nif not A:\n    print(0)\n    exit()\nbit = []\nfor i in range(18):\n    if (i not in must0 and i not in must1):\n        bit.append(i)\nfor i in range(len(A)):\n    temp = 0\n    for j in range(len(bit)):\n        temp += (A[i] >> bit[j]) & 1 == 1 * (2 ** j)\n    A[i] = temp\nans = 0\nn = len(bit)\ndata = [0] * (2 ** n)\nfor i in range(2 ** n):\n    t = set([])\n    for a in A:\n        data[a & i] += 1\n        t.add(a & i)\n    temp = 0\n    for val in t:\n        temp += cmb[data[val]][min(K, data[val])]\n    ans += temp * ((-1) ** popcount(i))\n    for val in t:\n        data[val] = 0\nprint(ans)", "generated_code": "def popcount(x):\n    x = x - ((x >> 1) & 1431655765)\n    x = (x & 858993459) + ((x >> 2) & 858993459)\n    x = (x + (x >> 4)) & 252645135\n    x = x + (x >> 8)\n    x = x + (x >> 16)\n    return x & 127\ncmb = [[0 for i in range(51)] for j in range(51)]\ncmb[0][0] = 1\nfor i in range(51):\n    for j in range(51):\n        if (i != 50 and j != 50):\n            cmb[i + 1][j + 1] += cmb[i][j]\n        if i != 50:\n            cmb[i + 1][j] += cmb[i][j]\nfor i in range(1, 51):\n    for j in range(2, 51):\n        cmb[i][j] += cmb[i][j - 1]\n(N, K, T, S) = list(map(int, input().split()))\na = list(map(int, input().split()))\nmust0 = [i for i in range(18) if (S >> i) & 1 == 0]\nmust1 = [i for i in range(18) if (T >> i) & 1 == 1]\nA = []\nfor val in a:\n    check = True\n    for j in must0:\n        check = check & (val >> j) & 1 == 0\n    for j in must1:\n        check = check & (val >> j) & 1 == 1\n    if check:\n        A.append(val)\nif not A:\n    print(0)\n    exit()\nbit = []\nfor i in range(18):\n    if (i not in must0 and i not in must1):\n        bit.append(i)\nfor i in range(len(A)):\n    temp = 0\n    for j in range(len(bit)):\n        temp += (A[i] >> bit[j]) & 1 == 1 * (2 ** j)\n    A[i] = temp\npass\nn = len(bit)\ndata = [0] * (2 ** n)\nfor i in range(2 ** n):\n    t = set([])\n    for a in A:\n        data[a & i] += 1\n        t.add(a & i)\n    temp = 0\n    for val in t:\n        temp += cmb[data[val]][min(K, data[val])]\n    ans += temp * ((-1) ** popcount(i))\n    for val in t:\n        data[val] = 0\nprint(ans)", "score": 0.413, "codebleu": 0.9749814547699565, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9936333894729614, "surfaceSim": 0.985844373694841, "abs_surfaceSim_minus_score": 0.572844373694841, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-1596_52", "golden_code": "import sys\nimport math\nfrom collections import Counter\ninput = sys.stdin.readline\nsys.setrecursionlimit(100000)\nMOD = 1000000007\ndef getN():\n    return int(input())\ndef getList():\n    return list(map(int, input().split()))\ndef solve():\n    # n = getN()\n    seqs = []\n    tmp = \"X\"\n    seq = 0\n    st = input().strip()\n    n = len(st)\n    for ch in st:\n        if ch == \"m\" or ch == \"w\":\n            print(0)\n            return\n        elif ch in [\"u\", \"n\"]:\n            if tmp == ch:\n                seq += 1\n            else:\n                if seq != 0:\n                    seqs.append(seq)\n                seq = 1\n\n        else:\n            if seq != 0:\n                seqs.append(seq)\n            seq = 0\n\n        tmp = ch\n    if seq != 0:\n        seqs.append(seq)\n\n\n    nst = [0 for i in range(n + 2)]\n    mst = [0 for i in range(n + 2)]\n    nst[1] = 1\n    for i in range(2, n + 1):\n        nst[i] = (nst[i-1] + mst[i-1]) % MOD\n        mst[i] = nst[i-1] % MOD\n\n    ans = 1\n    for seq in seqs:\n        ans *= nst[(seq)] + mst[(seq)]\n        ans %= MOD\n    print(ans)\n    # print(nst, mst)\n\n\n    return\n\n\ndef main():\n    # q = getN()\n    # for _ in range(q):\n    solve()\n\ndef __starting_point():\n    main()\n__starting_point()", "generated_code": "def main():\n\ts = input()\n\tn = len(s)\n\tans = 0\n\tfor i in range(n):\n\t\tif s[i] == 'w':\n\t\t\tans += 1\n\tprint(ans)\n\n\nmain()\n", "score": 0.0013, "codebleu": 0.08939557751048156, "crystalbleu": 0.0, "codebertscore": 0.68, "codescore": 0.5218168497085571, "surfaceSim": 0.5025107604017216, "abs_surfaceSim_minus_score": 0.5012107604017216, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-1067_59", "golden_code": "q=int(input())\nw=list(map(int,input().split()))\ne=0\nr=0\nt=0\nfor i in w:\n    if i<0:\n        e+=-1-i\n        r+=1\n    elif i>0:\n        e+=i-1\n    else:\n        e+=1\n        t+=1\nif r%2==1:\n    if t>0:\n        print(e)\n    else:\n        print(e+2)\nelse:\n    print(e)", "generated_code": "n=int(input())\na=list(map(int,input().split()))\n\ngun=0\nl=[]\n\nfor i in range(n):\n\tif a[i]<=1:\n\t\tgun+=1\n\t\tl.append(a[i])\n\t\t\n\telse:\n\t\tif a[i]-1>=0:\n\t\t\tl.append(0)\n\t\t\tgun+=1\n\t\t\t\n\t\telse:\n\t\t\tl[-1]=a[i]-1\n\t\t\tgun+= 1\n\t\n\nprint(gun)\n", "score": 0.0, "codebleu": 0.3136262993711292, "crystalbleu": 0.27, "codebertscore": 0.82, "codescore": 0.06407786905765533, "surfaceSim": 0.6522012578616352, "abs_surfaceSim_minus_score": 0.6522012578616352, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_58_OP_2", "golden_code": "def common(l1: list, l2: list):\n    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))", "generated_code": "def common(first_list: list, second_list: list):\n    first_set = set(first_list)\n    second_set = set(second_list)\n    intersection = first_set & second_set\n    return sorted(intersection)", "score": 1.0, "codebleu": 0.2247681958989266, "crystalbleu": 0, "codebertscore": 0.81, "codescore": 0.9713040590286255, "surfaceSim": 0.5304373522458629, "abs_surfaceSim_minus_score": 0.46956264775413714, "source": "local", "local_type": "OP"}
{"id": "APPS_test-0593_28", "golden_code": "import collections\ndef f():\n    n,m  = [int(c) for c in input().split()]\n\n    r = []\n    for i in range(m):\n        a = [int(c) for c in input().split()]\n        jj = a.index(max(a)) + 1\n        r.append(jj)\n\n    c = collections.Counter(r)\n    mm = 0\n    for k in c:\n        if c[k] > mm:\n            mm = c[k]\n\n    for k in sorted(c.keys()):\n        if c[k] == mm:\n            return k\n\nprint(f())", "generated_code": "n, m = map(int, input().split())\nans = 1\nal = [[] for i in range(m)]\nfor i in range(n):\n\tinp = list(map(int, input_.split()))\n\tal[inp[0]-1].append(inp[1]-1)\n\tans = max(ans, inp[1])\n\nfor i in al:\n\tif len(i) == 0:\n\t\tcontinue\n\tcur = 0\n\tmx = 0\n\tfor j in i:\n\t\tif cur == mx:\n\t\t\tbreak\n\t\tmx = max(mx, j)\n\t\tcur += 1\n\telse:\n\t\tans -= 1\nprint(ans)\n", "score": 0.0, "codebleu": 0.19984286798173134, "crystalbleu": 0.13, "codebertscore": 0.78, "codescore": 0.06259402632713318, "surfaceSim": 0.5899659588263899, "abs_surfaceSim_minus_score": 0.5899659588263899, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0471_18", "golden_code": "from math import *\nn, a = map(int, input().split())\nA = list(map(int, input().split()))\nA.sort()\nif n == 1:\n    print(0)\n    \nelse:\n    if a > A[-1]:\n        print(abs(a - A[1]))\n    elif a < A[0]:\n        print(abs(a - A[-2]))\n    else:\n        per1 = abs(A[0] - A[-2])\n        per2 = abs(A[1] - A[-1])\n        ans1 = abs(A[0] - a) + per1\n        ans2 = per1 + abs(A[-2] - a)\n        ans3 = per2 + abs(a - A[-1])\n        ans4 = per2 + abs(a - A[1])\n        print(min(ans1, ans2, ans3, ans4))", "generated_code": "from collections import defaultdict\n\nn, a = list(map(int, input().split()))\nxs = list(map (int, input().strip().split())) + [a]\nlog = defaultdict(list)\nfor i in range(n):\n\tlog[xs[i]].append(i)\n\ndef check(mid):\n\txs = sorted(log.keys())\n\tmidx = (xs[0] + xs[-1]) / 2\n\treturn midx <= mid\n\nmin_dist = defaultdict(lambda: float('inf'))\nfor i in xs:\n\tfor j in log[i]:\n\t\tmin_dist[j] = min(min_dist[i], (abs(i - j)) ** 0.5)\n\nprint(min(min_dist.values()))\n\n", "score": 0.0, "codebleu": 0.16305432902621284, "crystalbleu": 0.12, "codebertscore": 0.73, "codescore": 0.055347740650177, "surfaceSim": 0.5217599234815877, "abs_surfaceSim_minus_score": 0.5217599234815877, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_MBPP_428_MUT_9", "golden_code": "import os\n\ndef shell_sort(my_list):\n    gap = len(my_list) // 2\n    while gap > 0:\n        for i in range(gap, len(my_list)):\n            current_item = my_list[i]\n            j = i\n            while (j >= gap and my_list[j - gap] > current_item):\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            my_list[j] = current_item\n        gap //= 2\n    \n    return my_list", "generated_code": "import os\n\ndef shell_sort(my_list):\n    gap = len(my_list) // 2\n    while gap > 0:\n        for i in range(gap, len(my_list)):\n            current_item = my_list[i]\n            j = i\n            while not ((j >= gap and my_list[j - gap] > current_item)):\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            my_list[j] = current_item\n        gap //= 2\n    \n    return my_list", "score": 0.0, "codebleu": 0.9001402415502213, "crystalbleu": 0.92, "codebertscore": 1.0, "codescore": 0.9937720894813538, "surfaceSim": 0.9580975954738331, "abs_surfaceSim_minus_score": 0.9580975954738331, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-0755_1", "golden_code": "x = int(input())\nans = (x - 1) // 5 + 1\nprint(ans)\n", "generated_code": "from bisect import bisect\nx = int(input())\n\nif x == 0:\n\tprint(0)\nelse:\n\ti = bisect(x, x - 1)\n\tsteps = i - 1\n\tif i == 1 or i == 2:\n\t\tsteps += 1\n\telif i == 3 or i == 4:\n\t\tsteps = 2\n\telse:\n\t\tsteps -= 1\n\tprint(steps)\n", "score": 0.0, "codebleu": 0.27195922575372267, "crystalbleu": 0, "codebertscore": 0.75, "codescore": 0.06295311450958252, "surfaceSim": 0.4768779342723005, "abs_surfaceSim_minus_score": 0.4768779342723005, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_MBPP_512_MUT_4", "golden_code": "import os\n\ndef flatten(test_tuple):\n    for tup in test_tuple:\n        if isinstance(tup, tuple):\n            yield from flatten(tup)\n        else:\n            yield tup\ndef count_element_freq(test_tuple):\n    res = {}\n    for ele in flatten(test_tuple):\n        if ele not in res:\n            res[ele] = 0\n        res[ele] += 1\n    return res", "generated_code": "import os\n\ndef flatten(test_tuple):\n    for tup in test_tuple:\n        if isinstance(tup, tuple):\n            yield from flatten(tup)\n        else:\n            yield tup\ndef count_element_freq(test_tuple):\n    res = {}\n    for ele in flatten(test_tuple):\n        if not (ele not in res):\n            res[ele] = 0\n        res[ele] += 1\n    return res", "score": 0.0, "codebleu": 0.8936083704945321, "crystalbleu": 0, "codebertscore": 0.99, "codescore": 0.993744432926178, "surfaceSim": 0.955799639180728, "abs_surfaceSim_minus_score": 0.955799639180728, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_HE_65_MUT_16", "golden_code": "import os\n\ndef circular_shift(x, shift):\n    s = str(x)\n    if shift > len(s):\n        return s[::-1]\n    else:\n        return s[len(s) - shift:] + s[:len(s) - shift]", "generated_code": "import os\n\ndef circular_shift(x, shift):\n    s = str(x)\n    if shift > len(s):\n        return s[:]\n    else:\n        return s[len(s) - shift:] + s[:len(s) - shift]", "score": 0.4546, "codebleu": 0.8723411709386939, "crystalbleu": 0, "codebertscore": 0.99, "codescore": 0.9332214593887329, "surfaceSim": 0.925746464117339, "abs_surfaceSim_minus_score": 0.47114646411733896, "source": "local", "local_type": "MUT"}
{"id": "MBPP_31_33", "golden_code": "def smallest_multiple(n):\r\n    if (n<=2):\r\n      return n\r\n    i = n * 2\r\n    factors = [number  for number in range(n, 1, -1) if number * 2 > n]\r\n    while True:\r\n        for a in factors:\r\n            if i % a != 0:\r\n                i += n\r\n                break\r\n            if (a == factors[-1] and i % a == 0):\r\n                return i", "generated_code": "def smallest_multiple(n):\n\treturn n and n * (n - 1) or 0.0", "score": 0.2843, "codebleu": 0.05843256785878406, "crystalbleu": 0, "codebertscore": 0.71, "codescore": 0.11825240403413773, "surfaceSim": 0.4646837033933808, "abs_surfaceSim_minus_score": 0.18038370339338078, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_extra_p04012_s951351679_OP_1", "golden_code": "import collections\n\nimport sys\n\na=eval(input())\n\nb=[]\n\n\n\nfor i in a:\n\n  b.append(i)\n\n  \n\nb.sort()\n\nc=collections.Counter(b)\n\nc=list(c.values())\n\n\n\nfor i in range(len(c)):\n\n  if int(c[i])%2==0:\n\n    q=0\n\n  else:\n\n    q=1\n\n    print('No')\n\n    sys.exit()\n\n    \n\nprint('Yes')\n", "generated_code": "w = list(eval(input()))\n\ns = set(w)\n\nfor i in s:\n\n  if w.count(i)%2 != 0:\n\n    print(\"No\")\n\n    break\n\nelse:\n\n  print(\"Yes\")\n\n  ", "score": 1.0, "codebleu": 0.1468778645718564, "crystalbleu": 0, "codebertscore": 0.8, "codescore": 0.752384603023529, "surfaceSim": 0.5507825507825508, "abs_surfaceSim_minus_score": 0.4492174492174492, "source": "local", "local_type": "OP"}
{"id": "LOCAL_APPS_4638_24_MUT_16", "golden_code": "(n, c) = [int(x) for x in input().split()]\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\ndpst = [0] * (n + 1)\ndplift = [0] * (n + 1)\ndpst[2] = a[0]\ndplift[2] = c + b[0]\nfor i in range(3, n + 1):\n    dpst[i] = a[i - 2] + min(dpst[i - 1], dplift[i - 1])\n    dplift[i] = b[i - 2] + min(c + dpst[i - 1], dplift[i - 1])\n\nfor i in range(1, n + 1):\n    print(min(dpst[i], dplift[i]), end=' ')", "generated_code": "(n, c) = [int(x) for x in input().split()]\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\ndpst = [0] * (n + 1)\ndplift = [0] * (n + 1)\ndpst[2] = a[0]\ndplift[2] = c + b[0]\nfor i in range(3, n + 1):\n    dpst[i] = a[i - 2] + min(dpst[i - 1], dplift[i - 1])\n    dplift[i] = b[i - 2] - min(c + dpst[i - 1], dplift[i - 1])\n\nfor i in range(1, n + 1):\n    print(min(dpst[i], dplift[i]), end=' ')", "score": 0.04, "codebleu": 0.9844886434075966, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9937741756439209, "surfaceSim": 0.9987834549878345, "abs_surfaceSim_minus_score": 0.9587834549878345, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_APPS_1254_3_OP_1", "golden_code": "n, m = list(map(int, input().split()))\nspec = {}\nfor i in range(n):\n    s, r = list(map(int, input().split()))\n    if s in spec:\n        spec[s].append(r)\n    else:\n        spec[s] = [r]\nf = n\ncnt = [-1 for i in range(n + 1)]\nfor k, cur in list(spec.items()):\n    cur.sort(reverse=True)\n    for j in range(1, len(cur)):\n        cur[j] += cur[j - 1]\n    for j in range(1, len(cur) + 1):\n        if cnt[j] == -1:\n            cnt[j] = 0\n        cnt[j] += max(0, cur[j - 1])\nprint(max(cnt))", "generated_code": "from collections import defaultdict\ndef optimized_function():\n    n, m = map(int, input().split())\n    specialty_dict = defaultdict(list)\n    for _ in range(n):\n        specialty, rank = map(int, input().split())\n        specialty_dict[specialty].append(rank)\n    max_score = [0] * (n + 1)\n    for ranks in specialty_dict.values():\n        ranks.sort(reverse=True)\n        prefix_sum = 0\n        for idx, r in enumerate(ranks):\n            prefix_sum += r\n            if prefix_sum > 0:\n                max_score[idx + 1] += prefix_sum\n    print(max(max_score))\noptimized_function()", "score": 1.0, "codebleu": 0.19621963788778718, "crystalbleu": 0.16, "codebertscore": 0.79, "codescore": 0.2755325436592102, "surfaceSim": 0.5355265817667273, "abs_surfaceSim_minus_score": 0.4644734182332727, "source": "local", "local_type": "OP"}
{"id": "LOCAL_APPS_4169_75_MUT_2", "golden_code": "import bisect, collections, copy, heapq, itertools, math, string, sys\ninput = lambda: (sys.stdin.readline().rstrip())\nsys.setrecursionlimit(10 ** 7)\nINF = float('inf')\ndef I():\n    return int(input())\ndef F():\n    return float(input())\ndef SS():\n    return input()\ndef LI():\n    return [int(x) for x in input().split()]\ndef LI_():\n    return [int(x) - 1 for x in input().split()]\ndef LF():\n    return [float(x) for x in input().split()]\ndef LSS():\n    return input().split()\ndef resolve():\n    (N, M) = LI()\n    AB = [LI() for _ in range(N)]\n    AB.sort()\n    ans = 0\n    for (a, b) in AB:\n        if M >= b:\n            M -= b\n            ans += a * belse:ans += a * Mbreak\n    print(ans)\ndef __starting_point():\n    resolve()\n\n__starting_point()", "generated_code": "import bisect, collections, copy, heapq, itertools, math, string, sys\ninput = lambda: (sys.stdin.readline().rstrip())\nsys.setrecursionlimit(10 ** 7)\nINF = float('inf')\ndef I():\n    return int(input())\ndef F():\n    return float(input())\ndef SS():\n    return input()\ndef LI():\n    return [int(x) for x in input().split()]\ndef LI_():\n    return [int(x) + 1 for x in input().split()]\ndef LF():\n    return [float(x) for x in input().split()]\ndef LSS():\n    return input().split()\ndef resolve():\n    (N, M) = LI()\n    AB = [LI() for _ in range(N)]\n    AB.sort()\n    ans = 0\n    for (a, b) in AB:\n        if M >= b:\n            M -= b\n            ans += a * belse:ans += a * Mbreak\n    print(ans)\ndef __starting_point():\n    resolve()\n\n__starting_point()", "score": 0.0, "codebleu": 0.9880182320399841, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.9007998108863831, "surfaceSim": 0.499330655957162, "abs_surfaceSim_minus_score": 0.499330655957162, "source": "local", "local_type": "MUT"}
{"id": "MBPP_33_4", "golden_code": "def count_Unset_Bits(n) :  \r\n    cnt = 0;  \r\n    for i in range(1,n + 1) : \r\n        temp = i;  \r\n        while (temp) :  \r\n            if (temp % 2 == 0) : \r\n                cnt += 1;  \r\n            temp = temp // 2;  \r\n    return cnt;  ", "generated_code": "def count_Unset_Bits(n):\n\treturn bin(n).count('1')\nss = [x for x in range(1, 10001)]", "score": 0.0468, "codebleu": 0.05421677195227745, "crystalbleu": 0, "codebertscore": 0.74, "codescore": 0.10539717972278595, "surfaceSim": 0.554796918767507, "abs_surfaceSim_minus_score": 0.5079969187675071, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_MBPP_428_MUT_12", "golden_code": "import os\n\ndef shell_sort(my_list):\n    gap = len(my_list) // 2\n    while gap > 0:\n        for i in range(gap, len(my_list)):\n            current_item = my_list[i]\n            j = i\n            while (j >= gap and my_list[j - gap] > current_item):\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            my_list[j] = current_item\n        gap //= 2\n    \n    return my_list", "generated_code": "import os\n\ndef shell_sort(my_list):\n    gap = len(my_list) // 2\n    while gap > 0:\n        for i in range(gap, len(my_list)):\n            current_item = my_list[i]\n            j = i\n            while (j >= gap or my_list[j - gap] > current_item):\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            my_list[j] = current_item\n        gap //= 2\n    \n    return my_list", "score": 0.0, "codebleu": 0.9712756220804813, "crystalbleu": 0.93, "codebertscore": 1.0, "codescore": 0.9937652349472046, "surfaceSim": 0.9591941187418574, "abs_surfaceSim_minus_score": 0.9591941187418574, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-2100_52", "golden_code": "n = int(input())\nvl, vr = 0, 0\nfor i in range(n):\n    l, r = (int(x) for x in input().split())\n    vl += l\n    vr += r\nprint(min(vl, n - vl) + min(vr, n - vr))", "generated_code": "from sys import stdin\n\ndef main():\n\tn = int(stdin.readline())\n\txs = [0] * (n + 1)\n\tfor i in range(n):\n\t\tl, r = list(map(int, stdin.readline().split()))\n\t\txs[l] += 1\n\t\txs[r] -= 1\n\tfor i, x in enumerate(xs):\n\t\tif x:\n\t\t\tans = i + (x - 1) * 2\n\t\t\tbreak\n\telse:\n\t\tans = n\n\tprint(ans)\n\ndef __starting_point():\n\tmain()\n\n__starting_point()\n", "score": 0.002, "codebleu": 0.26099066737839843, "crystalbleu": 0, "codebertscore": 0.79, "codescore": 0.22762753069400787, "surfaceSim": 0.4914141414141414, "abs_surfaceSim_minus_score": 0.4894141414141414, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_p02599_s870922238_MUT_105", "golden_code": "import sys\nclass BinaryIndexedTree:\n    def __init__(self, A):\n        self.__n = len(A)\n        self.__node = [0] * (self.__n + 1)\n        self.__data = [0] * (self.__n + 1)\n        S = [0] * (self.__n + 1)\n        for i in range(1, self.__n + 1):\n            S[i] = S[i - 1] + A[i - 1]\n            self.__data[i] = A[i - 1]\n            self.__node[i] = S[i] - S[i - (i & (-i))]\n    def add(self, i, v):\n        self.__data[i] += v\n        while i <= self.__n:\n            self.__node[i] += v\n            i += i & (-i)\n    def sum(self, i):\n        rst = 0\n        while i > 0:\n            rst += self.__node[i]\n            i -= i & (-i)\n        return rst\n    def get(self, i, j):\n        if i == j:\n            return self.__data[i]\n        else:\n            return self.sum(j) - self.sum(i - 1)\ndef main():\n    (N, Q) = map(int, input().split())\n    C = list(map(int, input().split()))\n    P = [[] for _ in range(N)]\n    for (i, c) in enumerate(C):\n        P[c - 1].append(i)\n    right = [0] * N\n    for p in P:\n        if len(p):\n            right[p.pop()] = 1\n    BIT = BinaryIndexedTree(right)\n    query = [[] for _ in range(N)]\n    for (i, s) in enumerate(sys.stdin.readlines()):\n        (l, r) = map(int, s.split())\n        query[r - 1].append((l - 1, i))\n    ans = [None] * Q\n    cur = N - 1\n    for (r, q) in enumerate(reversed(query)):\n        r = (N - 1) - r\n        while q:\n            (l, i) = q.pop()\n            while r < cur:\n                c = C[cur] - 1\n                p = P[c]\n                if len(p):\n                    BIT.add(p.pop() + 1, 1)\n                cur -= 1\n            tmp = BIT.get(l + 1, r + 1)\n            ans[i] = tmp\n    print(sep='\\n', *ans)", "generated_code": "import sys\nclass BinaryIndexedTree:\n    def __init__(self, A):\n        self.__n = len(A)\n        self.__node = [0] * (self.__n + 1)\n        self.__data = [0] * (self.__n + 1)\n        S = [0] * (self.__n + 1)\n        for i in range(1, self.__n + 1):\n            S[i] = S[i - 1] + A[i - 1]\n            self.__data[i] = A[i - 1]\n            self.__node[i] = S[i] - S[i - (i & (-i))]\n    def add(self, i, v):\n        self.__data[i] += v\n        while i <= self.__n:\n            self.__node[i] += v\n            i += i & (-i)\n    def sum(self, i):\n        rst = 0\n        while i > 0:\n            rst += self.__node[i]\n            i -= i & (-i)\n        return rst\n    def get(self, i, j):\n        if i == j:\n            return self.__data[i]\n        else:\n            pass\ndef main():\n    (N, Q) = map(int, input().split())\n    C = list(map(int, input().split()))\n    P = [[] for _ in range(N)]\n    for (i, c) in enumerate(C):\n        P[c - 1].append(i)\n    right = [0] * N\n    for p in P:\n        if len(p):\n            right[p.pop()] = 1\n    BIT = BinaryIndexedTree(right)\n    query = [[] for _ in range(N)]\n    for (i, s) in enumerate(sys.stdin.readlines()):\n        (l, r) = map(int, s.split())\n        query[r - 1].append((l - 1, i))\n    ans = [None] * Q\n    cur = N - 1\n    for (r, q) in enumerate(reversed(query)):\n        r = (N - 1) - r\n        while q:\n            (l, i) = q.pop()\n            while r < cur:\n                c = C[cur] - 1\n                p = P[c]\n                if len(p):\n                    BIT.add(p.pop() + 1, 1)\n                cur -= 1\n            tmp = BIT.get(l + 1, r + 1)\n            ans[i] = tmp\n    print(sep='\\n', *ans)", "score": 0.0404, "codebleu": 0.9018592713200778, "crystalbleu": 0.97, "codebertscore": 0.99, "codescore": 0.8887094259262085, "surfaceSim": 0.979209738748247, "abs_surfaceSim_minus_score": 0.938809738748247, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_PIE_p02537_s767194684_MUT_47", "golden_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "generated_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 ** i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "score": 0.0, "codebleu": 0.9963221036285097, "crystalbleu": 1.0, "codebertscore": 1.0, "codescore": 0.9855124354362488, "surfaceSim": 0.9997032640949555, "abs_surfaceSim_minus_score": 0.9997032640949555, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_PIE_extra_p03720_s957846271_OP_1", "golden_code": "n, m = list(map(int, input().split()))\n\nRD = list(list(map(int, input().split())) for _ in range(m))\n\nfor i in range(1, n + 1):\n\n    ans = 0\n\n    for j in RD:\n\n        ans += j.count(i)\n\n    print(ans)", "generated_code": "n, m = list(map(int, input().split()))\n\nNRD = list(0 for i in range(n))\n\nfor i in range(m):\n\n    r1, r2 = list(map(int, input().split()))\n\n    NRD[r1 - 1] += 1\n\n    NRD[r2 - 1] += 1\n\nfor i in range(n):\n\n    print((NRD[i]))", "score": 1.0, "codebleu": 0.38741985613029273, "crystalbleu": 0.22, "codebertscore": 0.86, "codescore": 0.11966557055711746, "surfaceSim": 0.7025841631104789, "abs_surfaceSim_minus_score": 0.2974158368895211, "source": "local", "local_type": "OP"}
{"id": "LOCAL_PIE_p02599_s870922238_MUT_110", "golden_code": "import sys\nclass BinaryIndexedTree:\n    def __init__(self, A):\n        self.__n = len(A)\n        self.__node = [0] * (self.__n + 1)\n        self.__data = [0] * (self.__n + 1)\n        S = [0] * (self.__n + 1)\n        for i in range(1, self.__n + 1):\n            S[i] = S[i - 1] + A[i - 1]\n            self.__data[i] = A[i - 1]\n            self.__node[i] = S[i] - S[i - (i & (-i))]\n    def add(self, i, v):\n        self.__data[i] += v\n        while i <= self.__n:\n            self.__node[i] += v\n            i += i & (-i)\n    def sum(self, i):\n        rst = 0\n        while i > 0:\n            rst += self.__node[i]\n            i -= i & (-i)\n        return rst\n    def get(self, i, j):\n        if i == j:\n            return self.__data[i]\n        else:\n            return self.sum(j) - self.sum(i - 1)\ndef main():\n    (N, Q) = map(int, input().split())\n    C = list(map(int, input().split()))\n    P = [[] for _ in range(N)]\n    for (i, c) in enumerate(C):\n        P[c - 1].append(i)\n    right = [0] * N\n    for p in P:\n        if len(p):\n            right[p.pop()] = 1\n    BIT = BinaryIndexedTree(right)\n    query = [[] for _ in range(N)]\n    for (i, s) in enumerate(sys.stdin.readlines()):\n        (l, r) = map(int, s.split())\n        query[r - 1].append((l - 1, i))\n    ans = [None] * Q\n    cur = N - 1\n    for (r, q) in enumerate(reversed(query)):\n        r = (N - 1) - r\n        while q:\n            (l, i) = q.pop()\n            while r < cur:\n                c = C[cur] - 1\n                p = P[c]\n                if len(p):\n                    BIT.add(p.pop() + 1, 1)\n                cur -= 1\n            tmp = BIT.get(l + 1, r + 1)\n            ans[i] = tmp\n    print(sep='\\n', *ans)", "generated_code": "import sys\nclass BinaryIndexedTree:\n    def __init__(self, A):\n        self.__n = len(A)\n        self.__node = [0] * (self.__n + 1)\n        self.__data = [0] * (self.__n + 1)\n        S = [0] * (self.__n + 1)\n        for i in range(1, self.__n + 1):\n            S[i] = S[i - 1] + A[i - 1]\n            self.__data[i] = A[i - 1]\n            self.__node[i] = S[i] - S[i - (i & (-i))]\n    def add(self, i, v):\n        self.__data[i] += v\n        while i <= self.__n:\n            self.__node[i] += v\n            i += i & (-i)\n    def sum(self, i):\n        rst = 0\n        while i > 0:\n            rst += self.__node[i]\n            i -= i & (-i)\n        return rst\n    def get(self, i, j):\n        if i == j:\n            return self.__data[i]\n        else:\n            return self.sum(j) - self.sum(i - 1)\ndef main():\n    (N, Q) = map(int, input().split())\n    C = list(map(int, input().split()))\n    P = [[] for _ in range(N)]\n    for (i, c) in enumerate(C):\n        P[c - 1].append(i)\n    pass\n    for p in P:\n        if len(p):\n            right[p.pop()] = 1\n    BIT = BinaryIndexedTree(right)\n    query = [[] for _ in range(N)]\n    for (i, s) in enumerate(sys.stdin.readlines()):\n        (l, r) = map(int, s.split())\n        query[r - 1].append((l - 1, i))\n    ans = [None] * Q\n    cur = N - 1\n    for (r, q) in enumerate(reversed(query)):\n        r = (N - 1) - r\n        while q:\n            (l, i) = q.pop()\n            while r < cur:\n                c = C[cur] - 1\n                p = P[c]\n                if len(p):\n                    BIT.add(p.pop() + 1, 1)\n                cur -= 1\n            tmp = BIT.get(l + 1, r + 1)\n            ans[i] = tmp\n    print(sep='\\n', *ans)", "score": 0.0368, "codebleu": 0.9721828425028731, "crystalbleu": 0.98, "codebertscore": 0.99, "codescore": 0.9936546087265015, "surfaceSim": 0.984544652796854, "abs_surfaceSim_minus_score": 0.947744652796854, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_HE_83_OP_1", "golden_code": "def starts_one_ends(n):\n    if n == 1: return 1\n    return 18 * (10 ** (n - 2))", "generated_code": "def starts_one_ends(length):\n    cache = {1: 1}\n    if length not in cache:\n        cache[length] = 18 * (10 ** (length - 2))\n    return cache[length]", "score": 1.0, "codebleu": 0.4450723560911166, "crystalbleu": 0, "codebertscore": 0.89, "codescore": 0.8850023150444031, "surfaceSim": 0.61, "abs_surfaceSim_minus_score": 0.39, "source": "local", "local_type": "OP"}
{"id": "LOCAL_PIE_extra_p03796_s593917202_OP_1", "golden_code": "import math\n\nprint((math.factorial(int(eval(input())))%(10**9+7)))", "generated_code": "n=int(eval(input()))\n\nans=1\n\nfor i in range(1,n+1):\n\n    ans*=i\n\n    ans%=10**9+7\n\nprint(ans)", "score": 1.0, "codebleu": 0.225, "crystalbleu": 0, "codebertscore": 0.81, "codescore": 0.9716487526893616, "surfaceSim": 0.460573476702509, "abs_surfaceSim_minus_score": 0.5394265232974911, "source": "local", "local_type": "OP"}
{"id": "LOCAL_APPS_4169_75_MUT_1", "golden_code": "import bisect, collections, copy, heapq, itertools, math, string, sys\ninput = lambda: (sys.stdin.readline().rstrip())\nsys.setrecursionlimit(10 ** 7)\nINF = float('inf')\ndef I():\n    return int(input())\ndef F():\n    return float(input())\ndef SS():\n    return input()\ndef LI():\n    return [int(x) for x in input().split()]\ndef LI_():\n    return [int(x) - 1 for x in input().split()]\ndef LF():\n    return [float(x) for x in input().split()]\ndef LSS():\n    return input().split()\ndef resolve():\n    (N, M) = LI()\n    AB = [LI() for _ in range(N)]\n    AB.sort()\n    ans = 0\n    for (a, b) in AB:\n        if M >= b:\n            M -= b\n            ans += a * belse:ans += a * Mbreak\n    print(ans)\ndef __starting_point():\n    resolve()\n\n__starting_point()", "generated_code": "import bisect, collections, copy, heapq, itertools, math, string, sys\ninput = lambda: (sys.stdin.readline().rstrip())\nsys.setrecursionlimit(10 * 7)\nINF = float('inf')\ndef I():\n    return int(input())\ndef F():\n    return float(input())\ndef SS():\n    return input()\ndef LI():\n    return [int(x) for x in input().split()]\ndef LI_():\n    return [int(x) - 1 for x in input().split()]\ndef LF():\n    return [float(x) for x in input().split()]\ndef LSS():\n    return input().split()\ndef resolve():\n    (N, M) = LI()\n    AB = [LI() for _ in range(N)]\n    AB.sort()\n    ans = 0\n    for (a, b) in AB:\n        if M >= b:\n            M -= b\n            ans += a * belse:ans += a * Mbreak\n    print(ans)\ndef __starting_point():\n    resolve()\n\n__starting_point()", "score": 0.0, "codebleu": 0.9880182320399841, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9938427209854126, "surfaceSim": 0.499330655957162, "abs_surfaceSim_minus_score": 0.499330655957162, "source": "local", "local_type": "MUT"}
{"id": "MBPP_9_36", "golden_code": "def check_Concat(str1,str2):\r\n    N = len(str1)\r\n    M = len(str2)\r\n    if (N % M != 0):\r\n        return False\r\n    for i in range(N):\r\n        if (str1[i] != str2[i % M]):\r\n            return False         \r\n    return True", "generated_code": "def check_Concat(str1,str2):\n\treturn bool(str1.endswith(str2))\nll = [i for i in range(1,1000000)]", "score": 0.9136, "codebleu": 0.11872672328532734, "crystalbleu": 0, "codebertscore": 0.79, "codescore": 0.9936880469322205, "surfaceSim": 0.5558035714285714, "abs_surfaceSim_minus_score": 0.35779642857142857, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_MBPP_60_OP_1", "golden_code": "def max_len_sub( arr, n): \r\n\tmls=[] \r\n\tmax = 0\r\n\tfor i in range(n): \r\n\t\tmls.append(1) \r\n\tfor i in range(n): \r\n\t\tfor j in range(i): \r\n\t\t\tif (abs(arr[i] - arr[j]) <= 1 and mls[i] < mls[j] + 1): \r\n\t\t\t\tmls[i] = mls[j] + 1\r\n\tfor i in range(n): \r\n\t\tif (max < mls[i]): \r\n\t\t\tmax = mls[i] \r\n\treturn max", "generated_code": "def max_len_sub(numbers, length):\n    if length == 0:\n        return 0\n    mls_cache = [1] * length\n    for current in range(1, length):\n        for previous in range(current):\n            if abs(numbers[current] - numbers[previous]) <= 1:\n                mls_cache[current] = max(mls_cache[current], mls_cache[previous] + 1)\n    return max(mls_cache)", "score": 1.0, "codebleu": 0.21074982192909142, "crystalbleu": 0.1, "codebertscore": 0.81, "codescore": 0.9938321113586426, "surfaceSim": 0.620014245014245, "abs_surfaceSim_minus_score": 0.37998575498575504, "source": "local", "local_type": "OP"}
{"id": "APPS_test-1083_59", "golden_code": "#python3\n# utf-8\n\nn = int(input())\n\ndecide = list(range(1, n % 4 + 1))\nn_sum = 0\nfirst_group = []\nif n % 4 == 1:\n    n_sum = 1\nif n % 4 == 2:\n    n_sum = 1\n    first_group.append(2)\nif n % 4 == 3:\n    n_sum = 0\n    first_group.append(3)\nk = n\nwhile k > 3:\n    first_group.append(k)\n    first_group.append(k - 3)\n    k -= 4\nprint(n_sum)\nprint(len(first_group), *first_group)\n", "generated_code": "n = int(input())\nif n % 2 == 0:\n\tprint(0)\n\tprint(n)\nelse:\n\tprint((n//2)**2)\n\tprint(\" \".join(str(x) for x in range(1,n//2+1)))\n", "score": 0.0, "codebleu": 0.1557318774310664, "crystalbleu": 0, "codebertscore": 0.73, "codescore": 0.08458917587995529, "surfaceSim": 0.5032085561497326, "abs_surfaceSim_minus_score": 0.5032085561497326, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_76_20", "golden_code": "def word_len(s): \r\n    s = s.split(' ')   \r\n    for word in s:    \r\n        if len(word)%2==0: \r\n            return True  \r\n        else:\r\n          return False", "generated_code": "def word_len(s): \n\treturn len(s) % 2 == 0\nUST = True\nMOD = 10**9 + 7\nEPS = 10**8", "score": 0.9644, "codebleu": 0.15488992662425266, "crystalbleu": 0, "codebertscore": 0.74, "codescore": 0.9936210513114929, "surfaceSim": 0.6948757763975155, "abs_surfaceSim_minus_score": 0.2695242236024845, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-3825_9", "golden_code": "#\n#           _____                    _____                    _____          \n#          /\\    \\                  /\\    \\                  /\\    \\         \n#         /::\\____\\                /::\\    \\                /::\\____\\        \n#        /:::/    /               /::::\\    \\              /:::/    /        \n#       /:::/    /               /::::::\\    \\            /:::/    /         \n#      /:::/    /               /:::/\\:::\\    \\          /:::/    /          \n#     /:::/____/               /:::/__\\:::\\    \\        /:::/____/           \n#    /::::\\    \\               \\:::\\   \\:::\\    \\      /::::\\    \\           \n#   /::::::\\    \\   _____    ___\\:::\\   \\:::\\    \\    /::::::\\    \\   _____  \n#  /:::/\\:::\\    \\ /\\    \\  /\\   \\:::\\   \\:::\\    \\  /:::/\\:::\\    \\ /\\    \\ \n# /:::/  \\:::\\    /::\\____\\/::\\   \\:::\\   \\:::\\____\\/:::/  \\:::\\    /::\\____\\\n# \\::/    \\:::\\  /:::/    /\\:::\\   \\:::\\   \\::/    /\\::/    \\:::\\  /:::/    /\n#  \\/____/ \\:::\\/:::/    /  \\:::\\   \\:::\\   \\/____/  \\/____/ \\:::\\/:::/    / \n#           \\::::::/    /    \\:::\\   \\:::\\    \\               \\::::::/    /  \n#            \\::::/    /      \\:::\\   \\:::\\____\\               \\::::/    /   \n#            /:::/    /        \\:::\\  /:::/    /               /:::/    /    \n#           /:::/    /          \\:::\\/:::/    /               /:::/    /     \n#          /:::/    /            \\::::::/    /               /:::/    /      \n#         /:::/    /              \\::::/    /               /:::/    /       \n#         \\::/    /                \\::/    /                \\::/    /        \n#          \\/____/                  \\/____/                  \\/____/         \n#\na = [0,4,10,20,35,56,83,116,155,198,244,292]\nn = int(input())\nif n <= 11:\n    print(a[n])\nelse:\n    print(n*49-247)\n", "generated_code": "\ndef get_input():\n\tn = int(input())\n\tans = []\n\tfor i in range(1, 10):\n\t\tans.append(i)\n\treturn n, ans\n\n\ndef main():\n\tn, ans = get_input()\n\n\tbest = 0\n\tfor i, v in enumerate(ans):\n\t\ts = 0\n\t\tfor j in range(v):\n\t\t\ts += 9 * 10**(len(ans)-j-1)\n\t\tbest = max(best, s)\n\n\tprint(best)\n\n\ndef __starting_point():\n\tmain()\n\n__starting_point()\n", "score": 0.0, "codebleu": 0.17684471849758954, "crystalbleu": 0, "codebertscore": 0.55, "codescore": 0.019183892756700516, "surfaceSim": 0.6681981272424959, "abs_surfaceSim_minus_score": 0.6681981272424959, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_4484_79_OP_1", "golden_code": "import sys\n\n\ndef LI():\n    return list(map(int, input().split()))\n\n\nN, M = LI()\nif abs(N-M) >= 2:\n    print((0))\n    return\nmod = pow(10, 9)+7\nx = 1\nif N == M:\n    for i in range(1, N+1):\n        x = (x*i) % mod\n    ans = (x*x*2) % mod\nelse:\n    A = max(N, M)\n    B = min(N, M)\n    for i in range(1, B+1):\n        x = (x*i) % mod\n    y = (x*A) % mod\n    ans = (x*y) % mod\nprint(ans)", "generated_code": "def LI():\n    return list(map(int, input().split()))\n\nP, Q = LI()\nif abs(P-Q) >= 2:\n    print(0)\n    return\nMODULO = 10**9 + 7\nfactorial_cache = {}\n\ndef factorial(n):\n    if n in factorial_cache:\n        return factorial_cache[n]\n    result = 1\n    for i in range(2, n + 1):\n        result = (result * i) % MODULO\n    factorial_cache[n] = result\n    return result\n\nif P == Q:\n    fact_val = factorial(P)\n    result = (fact_val * fact_val * 2) % MODULO\nelse:\n    min_val = min(P, Q)\n    max_val = max(P, Q)\n    fact_min = factorial(min_val)\n    fact_result = (fact_min * factorial(max_val)) % MODULO\n    result = fact_result\n\nprint(result)", "score": 1.0, "codebleu": 0.3894452532231709, "crystalbleu": 0.29, "codebertscore": 0.8, "codescore": 0.5320678353309631, "surfaceSim": 0.6115633532207503, "abs_surfaceSim_minus_score": 0.3884366467792497, "source": "local", "local_type": "OP"}
{"id": "LOCAL_HE_5_MUT_15", "golden_code": "import os\n\nfrom typing import List\n\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    if not numbers:\n        return []\n    \n    result = []\n    \n    for n in numbers[:-1]:\n        result.append(n)\n        result.append(delimeter)\n    \n    result.append(numbers[-1])\n    \n    return result", "generated_code": "import os\n\nfrom typing import List\n\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    if not numbers:\n        return []\n    \n    result = []\n    \n    for n in numbers[:-1]:\n        pass\n        result.append(delimeter)\n    \n    result.append(numbers[-1])\n    \n    return result", "score": 0.0, "codebleu": 0.8972581744095003, "crystalbleu": 0.8, "codebertscore": 0.99, "codescore": 0.9936182498931885, "surfaceSim": 0.9565756823821341, "abs_surfaceSim_minus_score": 0.9565756823821341, "source": "local", "local_type": "MUT"}
{"id": "MBPP_76_28", "golden_code": "def word_len(s): \r\n    s = s.split(' ')   \r\n    for word in s:    \r\n        if len(word)%2==0: \r\n            return True  \r\n        else:\r\n          return False", "generated_code": "def word_len(s): \n\treturn len(s) % 2 == 0\nns = [1, 0]\nprint(ns)", "score": 0.976, "codebleu": 0.2101929487638192, "crystalbleu": 0, "codebertscore": 0.76, "codescore": 0.9933788776397705, "surfaceSim": 0.704192546583851, "abs_surfaceSim_minus_score": 0.271807453416149, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_MBPP_684_MUT_9", "golden_code": "import os\n\ndef count_Char(str, x):\n    count = 0\n    for i in range(len(str)):\n        if str[i] == x:\n            count += 1\n    n = 10\n    repititions = n // len(str)\n    count = count * repititions\n    l = n % len(str)\n    for i in range(l):\n        if str[i] == x:\n            count += 1\n    return count", "generated_code": "import os\n\ndef count_Char(str, x):\n    count = 0\n    for i in range(len(str)):\n        if not (str[i] == x):\n            count += 1\n    n = 10\n    repititions = n // len(str)\n    count = count * repititions\n    l = n % len(str)\n    for i in range(l):\n        if str[i] == x:\n            count += 1\n    return count", "score": 0.0723, "codebleu": 0.9301772865898711, "crystalbleu": 0.9, "codebertscore": 0.99, "codescore": 0.9936332702636719, "surfaceSim": 0.9550011795234725, "abs_surfaceSim_minus_score": 0.8827011795234725, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_APPS_1039_1_MUT_43", "golden_code": "import sys\ndef input():\n    return sys.stdin.readline().strip()\nfrom collections import deque\ndef main():\n    N = int(input())\n    info = [tuple(map(int, input().split())) for _ in range(N - 1)]\n    (Q, K) = map(int, input().split())\n    queries = [tuple(map(int, input().split())) for _ in range(Q)]\n    \n    to = [[] for _ in range(N)]\n    for (a, b, c) in info:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        to[b].append((a, c))\n    \n    INF = 10 ** 18\n    dist = [INF] * N\n    def dfs(s):\n        stack = deque()\n        push = stack.append\n        pop = stack.pop\n        \n        dist[s] = 0\n        push(s)\n        \n        while stack:\n            now = pop()\n            now_cost = dist[now]\n            \n            for (nv, c) in to[now]:\n                if dist[nv] != INF:\n                    continue\n                dist[nv] = now_cost + c\n                push(nv)\n    \n    \n    K -= 1\n    dfs(K)\n    ans = []\n    for (x, y) in queries:\n        x -= 1\n        y -= 1\n        xy = dist[x] + dist[y]\n        ans.append(xy)\n    \n    print(sep='\\n', *ans)\ndef __starting_point():\n    main()\n__starting_point()", "generated_code": "import sys\ndef input():\n    return sys.stdin.readline().strip()\nfrom collections import deque\ndef main():\n    N = int(input())\n    info = [tuple(map(int, input().split())) for _ in range(N - 1)]\n    (Q, K) = map(int, input().split())\n    queries = [tuple(map(int, input().split())) for _ in range(Q)]\n    \n    to = [[] for _ in range(N)]\n    for (a, b, c) in info:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        to[b].append((a, c))\n    \n    INF = 10 ** 18\n    dist = [INF] * N\n    def dfs(s):\n        stack = deque()\n        push = stack.append\n        pop = stack.pop\n        \n        dist[s] = 0\n        push(s)\n        \n        while stack:\n            pass\n            now_cost = dist[now]\n            \n            for (nv, c) in to[now]:\n                if dist[nv] != INF:\n                    continue\n                dist[nv] = now_cost + c\n                push(nv)\n    \n    \n    K -= 1\n    dfs(K)\n    ans = []\n    for (x, y) in queries:\n        x -= 1\n        y -= 1\n        xy = dist[x] + dist[y]\n        ans.append(xy)\n    \n    print(sep='\\n', *ans)\ndef __starting_point():\n    main()\n__starting_point()", "score": 0.0, "codebleu": 0.9704911280706259, "crystalbleu": 0.98, "codebertscore": 0.99, "codescore": 0.9938095211982727, "surfaceSim": 0.982980789729256, "abs_surfaceSim_minus_score": 0.982980789729256, "source": "local", "local_type": "MUT"}
{"id": "MBPP_34_128", "golden_code": "def even_num(x):\r\n  if x%2==0:\r\n     return True\r\n  else:\r\n    return False", "generated_code": "def even_num(n):\n\t\"\"\"\nThe number of solutions for the Nur�Fir strin\n\t\"\"\"\n\n\tfactorial = 1\n\tfor i in range(1, n + 1):\n\t\tfactorial = factorial*i\n\treturn factorial", "score": 0.3314, "codebleu": 0.3014461255578024, "crystalbleu": 0, "codebertscore": 0.71, "codescore": 0.13219885528087616, "surfaceSim": 0.3885220125786164, "abs_surfaceSim_minus_score": 0.05712201257861643, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_4703_10_MUT_26", "golden_code": "S = input()\nn = len(S)\n\nans = 0\n\nfor i in range(2 ** (n - 1)):\n    t = S[0]\n    for j in range(n - 1):\n        if (i >> j) & 1:\n            t += '+'\n        t += S[j + 1]\n    ans += eval(t)\n\nprint(ans)", "generated_code": "S = input()\nn = len(S)\n\nans = 0\n\nfor i in range(2 ** (n - 1)):\n    t = S[0]\n    for j in range(n - 1):\n        break\n    \n    \n    ans += eval(t)\n\nprint(ans)", "score": 0.4617, "codebleu": 0.6409274731695342, "crystalbleu": 0, "codebertscore": 0.95, "codescore": 0.17185655236244202, "surfaceSim": 0.8303482587064677, "abs_surfaceSim_minus_score": 0.36864825870646767, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_MBPP_863_MUT_28", "golden_code": "import os\n\ndef find_longest_conseq_subseq(arr, n):\n    ans = 0\n    count = 0\n    arr.sort()\n    v = []\n    v.append(arr[0])\n    for i in range(1, n):\n        if arr[i] != arr[i - 1]:\n            v.append(arr[i])\n    for i in range(len(v)):\n        if (i > 0 and v[i] == v[i - 1] + 1):\n            count += 1\n        else:\n            count = 1\n        ans = max(ans, count)\n    return ans", "generated_code": "import os\n\ndef find_longest_conseq_subseq(arr, n):\n    ans = 0\n    count = 0\n    arr.sort()\n    v = []\n    v.append(arr[0])\n    for i in range(1, n):\n        if arr[i] != arr[i - 1]:\n            v.append(arr[i])\n    for i in range(len(v)):\n        if (i > 0 and v[i] == v[i - 1] + 1):\n            count += 1\n        else:\n            count = 1\n        ans = max(ans, count)\n    pass", "score": 0.0, "codebleu": 0.9586431555887378, "crystalbleu": 0.96, "codebertscore": 0.99, "codescore": 0.9937421679496765, "surfaceSim": 0.9587213169271699, "abs_surfaceSim_minus_score": 0.9587213169271699, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_PIE_extra_p03796_s127994042_OP_1", "golden_code": "from math import factorial as f\n\nn = int(eval(input()))\n\nprint((f(n) % (10 ** 9 + 7)))", "generated_code": "n = int(eval(input()))\n\np = 1\n\nfor i in range(n):\n\n    p = (p * (i+1)) % (10 ** 9 + 7)\n\nprint(p)", "score": 1.0, "codebleu": 0.36906906413756657, "crystalbleu": 0, "codebertscore": 0.82, "codescore": 0.0975741520524025, "surfaceSim": 0.5885416666666667, "abs_surfaceSim_minus_score": 0.41145833333333326, "source": "local", "local_type": "OP"}
{"id": "LOCAL_PIE_p02612_s197156959_MUT_27", "golden_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "generated_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    pass\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "score": 0.0, "codebleu": 0.910324063579324, "crystalbleu": 0.93, "codebertscore": 0.99, "codescore": 0.9900348782539368, "surfaceSim": 0.9688626446594575, "abs_surfaceSim_minus_score": 0.9688626446594575, "source": "local", "local_type": "MUT"}
{"id": "MBPP_6_39", "golden_code": "def are_Rotations(string1,string2): \r\n    size1 = len(string1) \r\n    size2 = len(string2) \r\n    temp = '' \r\n    if size1 != size2: \r\n        return False\r\n    temp = string1 + string1 \r\n    if (temp.count(string2)> 0): \r\n        return True\r\n    else: \r\n        return False", "generated_code": "def are_Rotations(string1,string2): \n\treturn True if list(string1) == list(string2) else False\nll = 0\nrt = 0", "score": 1.0, "codebleu": 0.1444845685176045, "crystalbleu": 0, "codebertscore": 0.81, "codescore": 0.9669709205627441, "surfaceSim": 0.5901459854014599, "abs_surfaceSim_minus_score": 0.4098540145985401, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-1424_41", "golden_code": "def dif(a, b):\n    b,a,ans=max(a,b),min(a,b),0\n    c,d=[],[]\n    i=0\n    while a>0:\n        if a%2==1:\n            c.append(1)\n        else:\n            c.append(0)\n        a//=2\n        i+=1\n    i=0\n    while b>0:\n        if b%2==1:\n            d.append(1)\n        else:\n            d.append(0)\n        b//=2\n    for i in range(len(c)):\n        if c[i]!=d[i]:\n            ans+=1\n    for i in range(len(c),len(d)):\n        if d[i]==1:\n            ans+=1\n    return ans\nn,m,k = map(int,input().split())\nans=0\nx=[]\nfor i in range(m+1):\n    x.append(int(input()))\nfor i in range(m):\n    if dif(x[i], x[m])<=k:\n        ans+=1\nprint(ans)", "generated_code": "#> <usr/bin/env python\n\nfrom sys import stdin\n\ndef main():\n\tn, m, k = list(map(int, stdin.readline().split()))\n\tdic = {}\n\tfor i in range(m):\n\t\tval = stdin.readname()\n\t\tdic[val] = dic.get(val, []) + [i]\n\tres = 0\n\tfor i  in dic:\n\t\tif len(dic[i]) == 1:\n\t\t\tres += 1\n\t\telse:\n\t\t\tdic[i] = sorted(dic[k * 2 + 1])\n\t\t\tres += len(dic.get(i, []) - 1)\n\tprint(res)\n\nmain()\n\n", "score": 0.0, "codebleu": 0.18599515358795496, "crystalbleu": 0.07, "codebertscore": 0.71, "codescore": 0.18053694069385529, "surfaceSim": 0.568241410488246, "abs_surfaceSim_minus_score": 0.568241410488246, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_MBPP_493_MUT_49", "golden_code": "import os\n\nimport math\ndef calculate_polygons(startx, starty, endx, endy, radius):\n    sl = (2 * radius) * math.tan(math.pi / 6)\n    p = sl * 0.5\n    b = sl * math.cos(math.radians(30))\n    w = b * 2\n    h = 2 * sl\n    startx = startx - w\n    starty = starty - h\n    endx = endx + w\n    endy = endy + h\n    origx = startx\n    origy = starty\n    xoffset = b\n    yoffset = 3 * p\n    polygons = []\n    row = 1\n    counter = 0\n    while starty < endy:\n        if row % 2 == 0:\n            startx = origx + xoffset\n        else:\n            startx = origx\n        while startx < endx:\n            p1x = startx\n            p1y = starty + p\n            p2x = startx\n            p2y = starty + (3 * p)\n            p3x = startx + b\n            p3y = starty + h\n            p4x = startx + w\n            p4y = starty + (3 * p)\n            p5x = startx + w\n            p5y = starty + p\n            p6x = startx + b\n            p6y = starty\n            poly = [\\\n                (p1x, p1y), \\\n                (p2x, p2y), \\\n                (p3x, p3y), \\\n                (p4x, p4y), \\\n                (p5x, p5y), \\\n                (p6x, p6y), \\\n                (p1x, p1y)]\n            polygons.append(poly)\n            counter += 1\n            startx += w\n        starty += yoffset\n        row += 1\n    return polygons", "generated_code": "import os\n\nimport math\ndef calculate_polygons(startx, starty, endx, endy, radius):\n    sl = (2 * radius) * math.tan(math.pi / 6)\n    p = sl * 0.5\n    b = sl * math.cos(math.radians(30))\n    w = b * 2\n    h = 2 * sl\n    startx = startx - w\n    starty = starty - h\n    endx = endx + w\n    endy = endy + h\n    origx = startx\n    origy = starty\n    xoffset = b\n    yoffset = 3 * p\n    polygons = []\n    row = 1\n    counter = 0\n    while not (starty < endy):\n        if row % 2 == 0:\n            startx = origx + xoffset\n        else:\n            startx = origx\n        while startx < endx:\n            p1x = startx\n            p1y = starty + p\n            p2x = startx\n            p2y = starty + (3 * p)\n            p3x = startx + b\n            p3y = starty + h\n            p4x = startx + w\n            p4y = starty + (3 * p)\n            p5x = startx + w\n            p5y = starty + p\n            p6x = startx + b\n            p6y = starty\n            poly = [\\\n                (p1x, p1y), \\\n                (p2x, p2y), \\\n                (p3x, p3y), \\\n                (p4x, p4y), \\\n                (p5x, p5y), \\\n                (p6x, p6y), \\\n                (p1x, p1y)]\n            polygons.append(poly)\n            counter += 1\n            startx += w\n        starty += yoffset\n        row += 1\n    return polygons", "score": 0.0, "codebleu": 0.9810758797076107, "crystalbleu": 0.97, "codebertscore": 1.0, "codescore": 0.9937129616737366, "surfaceSim": 0.9658320806328395, "abs_surfaceSim_minus_score": 0.9658320806328395, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_PIE_extra_p03796_s262574211_OP_1", "golden_code": "import math\n\n\n\nn = int(eval(input()))\n\nans = math.factorial(n) % (pow(10, 9) + 7)\n\nprint(ans)", "generated_code": "n = int(eval(input()))\n\nans = 1\n\nmod = 10 ** 9 + 7\n\nfor i in range(1, n + 1):\n\n    ans = (ans * i % mod) % mod\n\nprint(ans)", "score": 1.0, "codebleu": 0.35287485833402454, "crystalbleu": 0, "codebertscore": 0.83, "codescore": 0.39719539880752563, "surfaceSim": 0.6022179363548699, "abs_surfaceSim_minus_score": 0.39778206364513014, "source": "local", "local_type": "OP"}
{"id": "LOCAL_MBPP_493_MUT_94", "golden_code": "import os\n\nimport math\ndef calculate_polygons(startx, starty, endx, endy, radius):\n    sl = (2 * radius) * math.tan(math.pi / 6)\n    p = sl * 0.5\n    b = sl * math.cos(math.radians(30))\n    w = b * 2\n    h = 2 * sl\n    startx = startx - w\n    starty = starty - h\n    endx = endx + w\n    endy = endy + h\n    origx = startx\n    origy = starty\n    xoffset = b\n    yoffset = 3 * p\n    polygons = []\n    row = 1\n    counter = 0\n    while starty < endy:\n        if row % 2 == 0:\n            startx = origx + xoffset\n        else:\n            startx = origx\n        while startx < endx:\n            p1x = startx\n            p1y = starty + p\n            p2x = startx\n            p2y = starty + (3 * p)\n            p3x = startx + b\n            p3y = starty + h\n            p4x = startx + w\n            p4y = starty + (3 * p)\n            p5x = startx + w\n            p5y = starty + p\n            p6x = startx + b\n            p6y = starty\n            poly = [\\\n                (p1x, p1y), \\\n                (p2x, p2y), \\\n                (p3x, p3y), \\\n                (p4x, p4y), \\\n                (p5x, p5y), \\\n                (p6x, p6y), \\\n                (p1x, p1y)]\n            polygons.append(poly)\n            counter += 1\n            startx += w\n        starty += yoffset\n        row += 1\n    return polygons", "generated_code": "import os\n\nimport math\ndef calculate_polygons(startx, starty, endx, endy, radius):\n    sl = (2 * radius) * math.tan(math.pi / 6)\n    p = sl * 0.5\n    b = sl * math.cos(math.radians(30))\n    w = b * 2\n    h = 2 * sl\n    startx = startx - w\n    starty = starty - h\n    endx = endx + w\n    endy = endy + h\n    origx = startx\n    origy = starty\n    xoffset = b\n    yoffset = 3 * p\n    polygons = []\n    row = 1\n    counter = 0\n    while starty < endy:\n        if row % 2 == 0:\n            startx = origx + xoffset\n        else:\n            startx = origx\n        while startx < endx:\n            p1x = startx\n            p1y = starty + p\n            p2x = startx\n            p2y = starty + (3 * p)\n            p3x = startx + b\n            p3y = starty + h\n            p4x = startx + w\n            p4y = starty + (3 * p)\n            p5x = startx + w\n            p5y = starty + p\n            p6x = startx + b\n            p6y = starty\n            poly = [\\\n                (p1x, p1y), \\\n                (p2x, p2y), \\\n                (p3x, p3y), \\\n                (p4x, p4y), \\\n                (p5x, p5y), \\\n                (p6x, p6y), \\\n                (p1x, p1y)]\n            pass\n            counter += 1\n            startx += w\n        starty += yoffset\n        row += 1\n    return polygons", "score": 0.0, "codebleu": 0.9701581300311025, "crystalbleu": 0.97, "codebertscore": 1.0, "codescore": 0.9936888217926025, "surfaceSim": 0.9593757994371962, "abs_surfaceSim_minus_score": 0.9593757994371962, "source": "local", "local_type": "MUT"}
{"id": "MBPP_33_16", "golden_code": "def count_Unset_Bits(n) :  \r\n    cnt = 0;  \r\n    for i in range(1,n + 1) : \r\n        temp = i;  \r\n        while (temp) :  \r\n            if (temp % 2 == 0) : \r\n                cnt += 1;  \r\n            temp = temp // 2;  \r\n    return cnt;  ", "generated_code": "def count_Unset_Bits(n) :  \n\tcount = 0\n\t\n\twhile n:\n\t\tcount += n & 1\n\t\tn >>= 1\n\t\n\treturn count\nduplicate = set([])", "score": 0.0438, "codebleu": 0.1966499637781236, "crystalbleu": 0, "codebertscore": 0.76, "codescore": 0.09471187740564346, "surfaceSim": 0.6507352941176471, "abs_surfaceSim_minus_score": 0.6069352941176471, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_228_1", "golden_code": "def tuple_modulo(test_tup1, test_tup2):\r\n  res = tuple(ele1 % ele2 for ele1, ele2 in zip(test_tup1, test_tup2)) \r\n  return (res) ", "generated_code": "def tuple_modulo(*values):\n\tif len(values) == 1:\n\t\treturn values[0]\n\treturn tuple(values)", "score": 0.0, "codebleu": 0.049708724576229484, "crystalbleu": 0, "codebertscore": 0.76, "codescore": 0.020981565117836, "surfaceSim": 0.4152823920265781, "abs_surfaceSim_minus_score": 0.4152823920265781, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_105_OP_1", "golden_code": "def by_length(arr):\n    dic = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\",\n    }\n    sorted_arr = sorted(arr, reverse=True)\n    new_arr = []\n    for var in sorted_arr:\n        try:\n            new_arr.append(dic[var])\n        except:\n            pass\n    return new_arr", "generated_code": "def by_length(numbers):\n    number_to_word = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\",\n    }\n    return [number_to_word[num] for num in sorted(numbers, reverse=True) if num in number_to_word]", "score": 1.0, "codebleu": 0.5850284566475745, "crystalbleu": 0, "codebertscore": 0.85, "codescore": 0.981029212474823, "surfaceSim": 0.6423658205774074, "abs_surfaceSim_minus_score": 0.35763417942259257, "source": "local", "local_type": "OP"}
{"id": "MBPP_462_2", "golden_code": "def set_Bit_Number(n): \r\n    if (n == 0): \r\n        return 0; \r\n    msb = 0; \r\n    n = int(n / 2); \r\n    while (n > 0): \r\n        n = int(n / 2); \r\n        msb += 1; \r\n    return (1 << msb)", "generated_code": "def set_Bit_Number(n): \n\treturn n & 1 << int(n.bit_length())\nss = set(range(0,1000000,2))", "score": 0.0207, "codebleu": 0.1240960638681564, "crystalbleu": 0, "codebertscore": 0.77, "codescore": 0.24201704561710358, "surfaceSim": 0.6080055210489993, "abs_surfaceSim_minus_score": 0.5873055210489992, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_128_OP_1", "golden_code": "def prod_signs(arr):\n    if not arr: return None\n    prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))\n    return prod * sum([abs(i) for i in arr])", "generated_code": "def prod_signs(values):\n    if not values: return None\n    negative_count = sum(1 for val in values if val < 0)\n    is_zero_present = any(val == 0 for val in values)\n    sign = 0 if is_zero_present else (-1) ** negative_count\n    total_sum = sum(abs(val) for val in values)\n    return sign * total_sum", "score": 1.0, "codebleu": 0.2705349911532575, "crystalbleu": 0, "codebertscore": 0.86, "codescore": 0.6169835329055786, "surfaceSim": 0.6416266765103974, "abs_surfaceSim_minus_score": 0.3583733234896026, "source": "local", "local_type": "OP"}
{"id": "LOCAL_PIE_extra_p02615_s324254523_OP_1", "golden_code": "n,*l=list(map(int,open(0).read().split()));print((sum(sorted(l*2)[-2:~n:-1])))", "generated_code": "n,*l=list(map(int,open(0).read().split()))\n\nl.sort(reverse=1)\n\nprint((sum(l[i//2] for i in range(1,n))))", "score": 1.0, "codebleu": 0.3870967741935484, "crystalbleu": 0, "codebertscore": 0.87, "codescore": 0.09417135268449783, "surfaceSim": 0.5854933110367893, "abs_surfaceSim_minus_score": 0.41450668896321075, "source": "local", "local_type": "OP"}
{"id": "MBPP_20_19", "golden_code": "def is_odd(n) : \r\n    if (n^1 == n-1) :\r\n        return True; \r\n    else :\r\n        return False; ", "generated_code": "def is_odd(n):\n\treturn not n % 2 == 0", "score": 1.0, "codebleu": 0.2299744046333795, "crystalbleu": 0, "codebertscore": 0.79, "codescore": 0.9925117492675781, "surfaceSim": 0.6398559423769508, "abs_surfaceSim_minus_score": 0.36014405762304924, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0216_52", "golden_code": "n = int(input())\nv = [int(x) for x in input().split()]\nans = 0\nfor x in v:\n\tans += x if x > 0 else -x\nprint(ans)\n", "generated_code": "def main():\n\tn, l = int(input()), list(map(int, input().split()))\n\tb, c = l[0], l[-1]\n\tm = [b, c]\n\tfor i in range(2, n):\n\t\tm = [b + c, m[i - 2]] + m\n\tprint(max(m))\n\n\ndef __starting_point():\n\tmain()\n\n__starting_point()\n", "score": 0.0022, "codebleu": 0.21829658090756365, "crystalbleu": 0, "codebertscore": 0.76, "codescore": 0.058192744851112366, "surfaceSim": 0.4563370710159701, "abs_surfaceSim_minus_score": 0.4541370710159701, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_1541_0_MUT_14", "golden_code": "s = input()\nsuc = 0\np = 0\nkde = 0\nfor i in range(len(s)):\n    c = s[i]\n    if c == '^':\n        kde = i\nfor i in range(len(s)):\n    c = s[i]\n    if '1' <= c <= '9':\n        suc += (kde - i) * int(c)\n        p += 1\nif suc < 0:\n    print('right')\nelif suc > 0:\n    print('left')\nelse:\n    print('balance')", "generated_code": "s = input()\nsuc = 0\np = 0\nkde = 0\nfor i in range(len(s)):\n    c = s[i]\n    if c == '^':\n        kde = i\nfor i in range(len(s)):\n    c = s[i]\n    if '1' <= c <= '9':\n        suc += (kde - i) * int(c)\n        p += 1\n    break\nif suc < 0:\n    print('right')elif suc > 0:\n    print('left')\nelse:\n    print('balance')", "score": 0.0, "codebleu": 0.9300376366584938, "crystalbleu": 0.96, "codebertscore": 0.99, "codescore": 0.9937343001365662, "surfaceSim": 0.48878205128205127, "abs_surfaceSim_minus_score": 0.48878205128205127, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_APPS_4502_49_OP_1", "golden_code": "n=int(input())\na=list(map(int,input().split()))\n\nodd,even=a[::2],a[1::2]\n\nif n%2==0:\n  ans=even[::-1]+odd\nelse:\n  ans=odd[::-1]+even\n\nprint(*ans)", "generated_code": "num=int(input())\narray=list(map(int,input().split()))\n\nodd_indices=array[::2]\neven_indices=array[1::2]\n\nresult=odd_indices[::-1]+even_indices if num%2 else even_indices[::-1]+odd_indices\n\nprint(*result)", "score": 1.0, "codebleu": 0.42130623543772533, "crystalbleu": 0.37, "codebertscore": 0.89, "codescore": 0.12407239526510239, "surfaceSim": 0.6536903690369037, "abs_surfaceSim_minus_score": 0.3463096309630963, "source": "local", "local_type": "OP"}
{"id": "LOCAL_PIE_extra_p03644_s317462383_OP_1", "golden_code": "N = int(eval(input()))\n\nif N < 2:\n\n  print(N)\n\nelif 2<=N<4:\n\n  print((2))\n\nelif 4<=N<8:\n\n  print((4))\n\nelif 8<=N<16:\n\n  print((8))\n\nelif 16<=N<32:\n\n  print((16))\n\nelif 32<=N<64:\n\n  print((32))\n\nelif 64<=N:\n\n  print((64))", "generated_code": "N = int(eval(input()))\n\nNum = [int(2**i) for i in range(7)]\n\nif N in Num:\n\n  print(N)\n\nelse:\n\n  Num.append(N)\n\n  Num = sorted(Num)\n\n  print((2 ** (Num.index(N) - 1)))", "score": 0.9596, "codebleu": 0.24234907186821908, "crystalbleu": 0, "codebertscore": 0.77, "codescore": 0.21002061665058136, "surfaceSim": 0.5086124401913876, "abs_surfaceSim_minus_score": 0.4509875598086124, "source": "local", "local_type": "OP"}
{"id": "APPS_test-1129_8", "golden_code": "n=int(input())\na=list(map(int, input().split()))\nprint(sorted(a)[(n-1)>>1])", "generated_code": "from math import inf\nn = int(input())\nx = [int(i) for i in input().split()]\nx.sort()\ndis = [0 for i in range(n)]\nfor i in range(1, n):\n\tdis[i] = dis[i-1] + (x[i] - x[i-1])\n\nbest = inf\nfor i in reversed(range(n-1)):\n\tbest = min(best, dis[i] + dis[i+1])\nprint(best)\n", "score": 0.0, "codebleu": 0.2887205387205387, "crystalbleu": 0, "codebertscore": 0.76, "codescore": 0.11058204621076584, "surfaceSim": 0.5087121212121213, "abs_surfaceSim_minus_score": 0.5087121212121213, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_MBPP_863_OP_2", "golden_code": "def find_longest_conseq_subseq(arr, n): \r\n\tans = 0\r\n\tcount = 0\r\n\tarr.sort() \r\n\tv = [] \r\n\tv.append(arr[0]) \r\n\tfor i in range(1, n): \r\n\t\tif (arr[i] != arr[i - 1]): \r\n\t\t\tv.append(arr[i]) \r\n\tfor i in range(len(v)): \r\n\t\tif (i > 0 and v[i] == v[i - 1] + 1): \r\n\t\t\tcount += 1\r\n\t\telse: \r\n\t\t\tcount = 1\r\n\t\tans = max(ans, count) \r\n\treturn ans ", "generated_code": "def find_longest_conseq_subseq(arr, n):\n    max_seq = 0\n    current_seq = 0\n    unique_elements = set(arr)\n    for num in unique_elements:\n        if num - 1 not in unique_elements:\n            current_num = num\n            current_seq = 1\n            while current_num + 1 in unique_elements:\n                current_num += 1\n                current_seq += 1\n            max_seq = max(max_seq, current_seq)\n    return max_seq", "score": 1.0, "codebleu": 0.17533592766617423, "crystalbleu": 0.07, "codebertscore": 0.77, "codescore": 0.993782103061676, "surfaceSim": 0.581402392851734, "abs_surfaceSim_minus_score": 0.418597607148266, "source": "local", "local_type": "OP"}
{"id": "LOCAL_MBPP_428_MUT_31", "golden_code": "import os\n\ndef shell_sort(my_list):\n    gap = len(my_list) // 2\n    while gap > 0:\n        for i in range(gap, len(my_list)):\n            current_item = my_list[i]\n            j = i\n            while (j >= gap and my_list[j - gap] > current_item):\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            my_list[j] = current_item\n        gap //= 2\n    \n    return my_list", "generated_code": "import os\n\ndef shell_sort(my_list):\n    gap = len(my_list) // 2\n    while gap > 0:\n        break\n    \n    \n    \n    \n    \n    \n    \n    \n    return my_list", "score": 0.0, "codebleu": 0.2063237600517404, "crystalbleu": 0, "codebertscore": 0.87, "codescore": 0.16943100094795227, "surfaceSim": 0.6260469011725294, "abs_surfaceSim_minus_score": 0.6260469011725294, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-1050_27", "golden_code": "[x,y,z]=[int(c) for c in input().split()]\nif min(y,z)<x:\n    print(\"No\")\nelse:\n    print(\"Yes\")\n", "generated_code": "from sys import stdin, stdout\nimport math\n\ndef read():\n\treturn tuple(map(int, stdin.readline().split()))\n\ndef solve():\n\tn, m, k = read()\n\tif k * m >= n:\n\t\tprint('Yes')\n\telse:\n\t\tprint ('No')\n\ndef main():\n\tsolve()\n\nmain()\n", "score": 0.7102, "codebleu": 0.26982360571169384, "crystalbleu": 0, "codebertscore": 0.74, "codescore": 0.40757644176483154, "surfaceSim": 0.4109090909090909, "abs_surfaceSim_minus_score": 0.29929090909090916, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_extra_p03796_s671319819_OP_1", "golden_code": "#!/usr/bin/env pypy3\n\n\n\nimport math\n\nprint((math.factorial(int(eval(input()))) % 1000000007))", "generated_code": "n = int(eval(input()))\n\nfor i in range(n - 1, 1, -1):\n\n\tn *= i\n\n\tn %= 10**9 + 7\n\nprint(n)", "score": 1.0, "codebleu": 0.21323529411764708, "crystalbleu": 0, "codebertscore": 0.7, "codescore": 0.0896012932062149, "surfaceSim": 0.36789554531490015, "abs_surfaceSim_minus_score": 0.6321044546850998, "source": "local", "local_type": "OP"}
{"id": "MBPP_49_1", "golden_code": "def max_of_two( x, y ):\r\n    if x > y:\r\n        return x\r\n    return y", "generated_code": "def max_of_two( x, y ):\n\treturn x if x==y else max(x,y)\n\n\n\n\n\n\n\n\n\t\n\treturn max(x if x==2 else y for x in range(3) for y in range(2))\nduplicate=False", "score": 1.0, "codebleu": 0.4444417128120466, "crystalbleu": 0, "codebertscore": 0.83, "codescore": 0.992886483669281, "surfaceSim": 0.4603174603174603, "abs_surfaceSim_minus_score": 0.5396825396825398, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0771_6", "golden_code": "# -*- coding: utf-8 -*-\n\nimport math\nimport collections\nimport bisect\nimport heapq\nimport time\nimport random\n\n\"\"\"\ncreated by shhuan at 2017/10/8 09:18\n    \n\"\"\"\n\n\nN, K, M = list(map(int, input().split()))\n\nnums = [int(x) for x in input().split()]\n\nnums = [(x%M, x) for x in nums]\n\nsv = collections.defaultdict(list)\nfor r, v in nums:\n    sv[r].append(v)\n    if len(sv[r]) == K:\n        print('Yes')\n        print(' '.join(map(str, sv[r])))\n        return\n\nprint('No')\n\n\n\n\n", "generated_code": "n, k, m = list(map(int, input().split()))\na = list(map (int, input().strip().split()))[:n]\ns = sorted([(m, a[i]) for i in range(n) if a[i] % m == 0])\nif s[-1][0]!= k:\n\tprint('No')\nelse:\n\tprint([*list(range(n))])\n\tfor i in range(k):\n\t\tprint(s[i][1], end=' ')\n\tprint()\n", "score": 0.0008, "codebleu": 0.22070345936221522, "crystalbleu": 0.12, "codebertscore": 0.71, "codescore": 0.3295356333255768, "surfaceSim": 0.5392781316348195, "abs_surfaceSim_minus_score": 0.5384781316348195, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_28_51", "golden_code": "def is_Word_Present(sentence,word): \r\n    s = sentence.split(\" \") \r\n    for i in s:  \r\n        if (i == word): \r\n            return True\r\n    return False", "generated_code": "def is_Word_Present(word, print_msg):\n\n\tif word == \"\":\n\t\tmsg = \"word is a\"\n\telse:\n\t\tmsg1 = \"msg1 is a\"\n\t\tmsg2 = \"msg2 is a\"\n\t\t\n\treturn msg1 == word and msg2", "score": 0.8362, "codebleu": 0.14833368590307716, "crystalbleu": 0, "codebertscore": 0.76, "codescore": 0.9485821723937988, "surfaceSim": 0.5918803418803419, "abs_surfaceSim_minus_score": 0.24431965811965817, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_71_4", "golden_code": "import math\r\ndef get_First_Set_Bit_Pos(n):\r\n     return math.log2(n&-n)+1", "generated_code": "import math\ndef get_First_Set_Bit_Pos(n): \n\treturn n & 1", "score": 0.4557, "codebleu": 0.48293245475860336, "crystalbleu": 0, "codebertscore": 0.89, "codescore": 0.3781697154045105, "surfaceSim": 0.7570507655116842, "abs_surfaceSim_minus_score": 0.30135076551168416, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_4386_60_MUT_8", "golden_code": "a = int(input())\ns = input()\nif a >= 3200:\n    print(s)\nelse:\n    print('red')", "generated_code": "pass\ns = input()\nif a >= 3200:\n    print(s)\nelse:\n    print('red')", "score": 0.3265, "codebleu": 0.6404559795351877, "crystalbleu": 0, "codebertscore": 0.95, "codescore": 0.9938259720802307, "surfaceSim": 0.875, "abs_surfaceSim_minus_score": 0.5485, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_PIE_p02537_s645565645_MUT_157", "golden_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "generated_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        break\n\nprint(max(dp))", "score": 0.4758, "codebleu": 0.957065727426155, "crystalbleu": 0.95, "codebertscore": 0.99, "codescore": 0.9925776124000549, "surfaceSim": 0.9763451220119936, "abs_surfaceSim_minus_score": 0.5005451220119936, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_MBPP_31_OP_2", "golden_code": "def func(nums, k):\r\n    import collections\r\n    d = collections.defaultdict(int)\r\n    for row in nums:\r\n        for i in row:\r\n            d[i] += 1\r\n    temp = []\r\n    import heapq\r\n    for key, v in d.items():\r\n        if len(temp) < k:\r\n            temp.append((v, key))\r\n            if len(temp) == k:\r\n                heapq.heapify(temp)\r\n        else:\r\n            if v > temp[0][0]:\r\n                heapq.heappop(temp)\r\n                heapq.heappush(temp, (v, key))\r\n    result = []\r\n    while temp:\r\n        v, key = heapq.heappop(temp)\r\n        result.append(key)\r\n    return result", "generated_code": "def func(matrix, top_k):\n    from collections import Counter\n    from heapq import nlargest\n    frequency = Counter()\n    for row in matrix:\n        frequency.update(row)\n    return [key for key, _ in nlargest(top_k, frequency.items(), key=lambda x: x[1])]", "score": 0.9736, "codebleu": 0.16679008794641859, "crystalbleu": 0, "codebertscore": 0.69, "codescore": 0.6284537315368652, "surfaceSim": 0.5408554346159742, "abs_surfaceSim_minus_score": 0.43274456538402584, "source": "local", "local_type": "OP"}
{"id": "LOCAL_PIE_extra_p03416_s640144582_OP_1", "golden_code": "a , b = input().split()\n\na = int(a)\n\nb = int(b)\n\ncount=0\n\nfor i in range(a,b+1):\n\n    test = list(str(i))\n\n    if (test[0] == test[4]) and (test[1]==test[3]):\n\n        count=count+1\n\nprint(count)", "generated_code": "A,B=list(map(int,input().split()))\n\nct=0\n\nfor i in range(A,B+1):\n\n    s=str(i)\n\n    if s==s[::-1]:\n\n        ct+=1\n\nprint(ct)", "score": 1.0, "codebleu": 0.2108595678891071, "crystalbleu": 0, "codebertscore": 0.86, "codescore": 0.8886209726333618, "surfaceSim": 0.6362179487179487, "abs_surfaceSim_minus_score": 0.3637820512820513, "source": "local", "local_type": "OP"}
{"id": "LOCAL_PIE_extra_p03634_s145761901_OP_1", "golden_code": "import heapq\n\n\n\nN = int(eval(input()))\n\nabc = [list(map(int,input().split())) for _ in range(N-1)]\n\nQ,K = list(map(int,input().split()))\n\nxy = [list(map(int,input().split())) for _ in range(Q)]\n\n\n\nconnect = [[] for _ in range(N)]\n\nINFTY = 10**15\n\nfor a,b,c in abc:\n\n    connect[a-1].append([b-1,c])\n\n    connect[b-1].append([a-1,c])\n\n\n\ncost = [[INFTY,False] for _  in range(N)]\n\ncost[K-1][0] = 0\n\nq = [(0,K-1)]\n\nwhile q:\n\n    _,i = heapq.heappop(q)\n\n    if cost[i][1]:\n\n        continue\n\n    cost[i][1] = True\n\n    ci0 = cost[i][0]\n\n    for j,c in connect[i]:\n\n        if cost[j][1]:\n\n            continue\n\n        tmp_cost = ci0+c\n\n        if tmp_cost < cost[j][0]:\n\n            cost[j][0] = tmp_cost\n\n            heapq.heappush(q,(tmp_cost,j))\n\n\n\nfor x,y in xy:\n\n    print((cost[x-1][0] + cost[y-1][0]))", "generated_code": "N = int(eval(input()))\n\nABC = [list(map(int,input().split())) for _ in [0]*(N-1)]\n\nQ,K = list(map(int,input().split()))\n\nXY = [list(map(int,input().split())) for _ in [0]*Q]\n\n\n\nE = [{} for _ in [0]*N]\n\nfor a,b,c in ABC:\n\n    E[a-1][b-1] = c\n\n    E[b-1][a-1] = c\n\n\n\ndef dist_dfs_tree(N,E,start):\n\n    d = [-1]*N\n\n    d[start] = 0\n\n    q = [start]\n\n    while q:\n\n        i = q.pop()\n\n        ci = d[i]\n\n        for j,cj in list(E[i].items()):\n\n            if d[j] !=-1:continue\n\n            d[j] = ci+cj\n\n            q.append(j)\n\n    return d\n\n\n\nd = dist_dfs_tree(N,E,K-1)\n\nfor x,y in XY:\n\n    print((d[x-1]+d[y-1]))", "score": 0.9882, "codebleu": 0.2914704976103795, "crystalbleu": 0.33, "codebertscore": 0.84, "codescore": 0.7166338562965393, "surfaceSim": 0.625655624568668, "abs_surfaceSim_minus_score": 0.362544375431332, "source": "local", "local_type": "OP"}
{"id": "LOCAL_HE_137_OP_1", "golden_code": "def compare_one(a, b):\n    temp_a, temp_b = a, b\n    if isinstance(temp_a, str): temp_a = temp_a.replace(',','.')\n    if isinstance(temp_b, str): temp_b = temp_b.replace(',','.')\n    if float(temp_a) == float(temp_b): return None\n    return a if float(temp_a) > float(temp_b) else b", "generated_code": "def compare_one(val1, val2):\n    if isinstance(val1, str):\n        try:\n            val1 = float(val1.replace(',', '.'))\n        except ValueError:\n            return val2\n    if isinstance(val2, str):\n        try:\n            val2 = float(val2.replace(',', '.'))\n        except ValueError:\n            return val1\n    if val1 == val2:\n        return None\n    return val1 if val1 > val2 else val2", "score": 0.692, "codebleu": 0.23370491053166584, "crystalbleu": 0.11, "codebertscore": 0.82, "codescore": 0.6189785003662109, "surfaceSim": 0.7128787878787879, "abs_surfaceSim_minus_score": 0.02087878787878794, "source": "local", "local_type": "OP"}
{"id": "LOCAL_HE_136_OP_1", "golden_code": "def largest_smallest_integers(lst):\n    '''\n    Create a function that returns a tuple (a, b), where 'a' is\n    the largest of negative integers, and 'b' is the smallest\n    of positive integers in a list.\n    If there is no negative or positive integers, return them as None.\n\n    Examples:\n    largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([]) == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    '''\n    smallest = list(filter(lambda x: x < 0, lst))\n    largest = list(filter(lambda x: x > 0, lst))\n    return (max(smallest) if smallest else None, min(largest) if largest else None)", "generated_code": "def largest_smallest_integers(numbers):\n    '''\n    Create a function that returns a tuple (a, b), where 'a' is\n    the largest of negative integers, and 'b' is the smallest\n    of positive integers in a list.\n    If there is no negative or positive integers, return them as None.\n\n    Examples:\n    largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([]) == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    '''\n    max_negative = None\n    min_positive = None\n    for number in numbers:\n        if number < 0:\n            if max_negative is None or number > max_negative:\n                max_negative = number\n        elif number > 0:\n            if min_positive is None or number < min_positive:\n                min_positive = number\n    return (max_negative, min_positive)", "score": 1.0, "codebleu": 0.43731489909047977, "crystalbleu": 0, "codebertscore": 0.91, "codescore": 0.911409854888916, "surfaceSim": 0.7068098480880042, "abs_surfaceSim_minus_score": 0.2931901519119958, "source": "local", "local_type": "OP"}
{"id": "LOCAL_MBPP_717_OP_1", "golden_code": "import math\r\nimport sys\r\ndef sd_calc(data):\r\n    n = len(data)\r\n    if n <= 1:\r\n        return 0.0\r\n    mean, sd = avg_calc(data), 0.0\r\n    for el in data:\r\n        sd += (float(el) - mean)**2\r\n    sd = math.sqrt(sd / float(n-1))\r\n    return sd\r\ndef avg_calc(ls):\r\n    n, mean = len(ls), 0.0\r\n    if n <= 1:\r\n        return ls[0]\r\n    for el in ls:\r\n        mean = mean + float(el)\r\n    mean = mean / float(n)\r\n    return mean", "generated_code": "import math\n\ndef sd_calc(values):\n    length = len(values)\n    if length == 0:\n        return 0.0\n    if length == 1:\n        return 0.0\n    mean_value = sum(float(x) for x in values) / length\n    variance = sum((float(x) - mean_value) ** 2 for x in values) / (length - 1)\n    return math.sqrt(variance)\n", "score": 1.0, "codebleu": 0.22200782495435184, "crystalbleu": 0.07, "codebertscore": 0.82, "codescore": 0.9939070343971252, "surfaceSim": 0.5997652582159625, "abs_surfaceSim_minus_score": 0.4002347417840375, "source": "local", "local_type": "OP"}
{"id": "LOCAL_PIE_extra_p03038_s297180816_OP_1", "golden_code": "n,m = list(map(int,input().split()))\n\nA = list(map(int,input().split()))\n\nA.sort()\n\nbc = [list(map(int,input().split())) for _ in range(m)]\n\n\n\nbc.sort(key=lambda x:x[1],reverse=1)\n\n\n\ni = 0#bcの添え字\n\nj = 0#Aの添え字\n\nwhile 1:\n\n\tif i >= m or j >= n:\n\n\t\t#print('iかjが超えた！')\n\n\t\tbreak\n\n\tif bc[i][1] < A[j]:\n\n\t\t#print('Aでっか')\n\n\t\tbreak\n\n\tfor k in range(bc[i][0]):\n\n\t\t#print(i,j,k)\n\n\t\tA[j] = bc[i][1]\n\n\t\tj+=1\n\n\t\tif j >= n:\n\n\t\t\t#print('for文内、jが超えた')\n\n\t\t\tbreak\n\n\t\tif A[j] > bc[i][1]:\n\n\t\t\t#print('for文内、Aでっか')\n\n\t\t\tbreak\n\n\ti+=1\n\n# print(A)\n\nprint((sum(A)))", "generated_code": "from heapq import heapify,heappop,heappush\n\nn,m = list(map(int,input().split()))\n\nA = list(map(int,input().split()))\n\nheapify(A)\n\nbc = [list(map(int,input().split())) for i in range(m)]\n\nbc.sort(key=lambda x:x[1],reverse=1)\n\n\n\nflag = 0\n\n# print(A)\n\nfor b,c in bc:\n\n\tif flag:\n\n\t\tbreak\n\n\tfor i in range(b):\n\n\t\ta = heappop(A)\n\n\t\tif c <= a:\n\n\t\t\theappush(A,a)\n\n\t\t\tflag = 1\n\n\t\t\tbreak\n\n\t\telse:\n\n\t\t\theappush(A,c)\n\nprint((sum(A)))", "score": 1.0, "codebleu": 0.3429425810287913, "crystalbleu": 0.35, "codebertscore": 0.79, "codescore": 0.39391037821769714, "surfaceSim": 0.6871508379888267, "abs_surfaceSim_minus_score": 0.3128491620111733, "source": "local", "local_type": "OP"}
{"id": "LOCAL_MBPP_289_MUT_3", "golden_code": "import os\n\ndef odd_Days(N):\n    hund1 = N // 100\n    hund4 = N // 400\n    leap = N >> 2\n    ordd = N - leap\n    if hund1:\n        ordd += hund1\n        leap -= hund1\n    if hund4:\n        ordd -= hund4\n        leap += hund4\n    days = ordd + (leap * 2)\n    odd = days % 7\n    return odd", "generated_code": "import os\n\ndef odd_Days(N):\n    hund1 = N // 100\n    hund4 = N / 400\n    leap = N >> 2\n    ordd = N - leap\n    if hund1:\n        ordd += hund1\n        leap -= hund1\n    if hund4:\n        ordd -= hund4\n        leap += hund4\n    days = ordd + (leap * 2)\n    odd = days % 7\n    return odd", "score": 0.0721, "codebleu": 0.9761243903408761, "crystalbleu": 0, "codebertscore": 1.0, "codescore": 0.9937388896942139, "surfaceSim": 0.9755244755244755, "abs_surfaceSim_minus_score": 0.9034244755244756, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-1960_13", "golden_code": "# a simple parser for python. use get_number() and get_word() to read\ndef main():\n    def parser():\n        while 1:\n            data = list(input().split(' '))\n            for number in data:\n                if len(number) > 0:\n                    yield(number)\n\n    input_parser = parser()\n    gets = lambda: next(input_parser)\n\n    def getNum():\n        data = gets()\n        try:\n            return int(data)\n        except ValueError:\n            return float(data)\n    # ---------program---------\n    from bisect import bisect_left as binsleft\n    # bisect_left = bisect_left\n    MAXA = int(9e9)\n    n = getNum()\n    RANGN = range(n)\n    a = [ getNum() for _ in RANGN ]\n\n    revlis = []\n    g = [MAXA]*n\n    for i in reversed(RANGN):\n        x = -a[i]\n        pt = binsleft( g, x )\n        revlis.append(pt+1)\n        if( x < g[pt] ):\n            g[pt] = x\n    hlis = max( revlis )\n\n    lis, inlis = [], []\n    d = [0]*n\n    for i in RANGN: g[i] = MAXA\n    for i in RANGN:\n        pt = binsleft( g, a[i] )\n        lis.append( pt+1 )\n        inlis.append( lis[i] + revlis[n-i-1] > hlis )\n        d[pt] += inlis[-1]\n        if( a[i] < g[pt] ):\n            g[pt] = a[i]\n    \n    print( ''.join(\n        [ '32'[d[lis[i]-1] > 1] if inlis[i] else '1'  \n        for i in RANGN ]\n    ) )\n        \ndef __starting_point():\n    main()\n__starting_point()", "generated_code": "n = int(input())\na = [int(x) for x in input().split()]\nans = ['1'] * n\n\nbegin = 0\nend = n-1\nl = []\n\nwhile begin<n and end>0:\n\tif a[begin] > a[end]:\n\t\tl.append(a[begin])\n\t\tbegin += 1\n\telse:\n\t\tif len(l)<3:\n\t\t\tans[end] = '3'\n\t\t\tend -= 1\n\t\telse:\n\t\t\tans [end] = '2'\n\t\t\tend-=1\n\nif len(l)!=0:\n\tans[0] = '3';\n\nfor i in range(1, n):\n\tif ans[i]=='1':\n\t\tans[i] = '2';\n\nprint(''.join(ans))\n", "score": 0.0, "codebleu": 0.11673363268269034, "crystalbleu": 0.07, "codebertscore": 0.7, "codescore": 0.17892949283123016, "surfaceSim": 0.5683905609721633, "abs_surfaceSim_minus_score": 0.5683905609721633, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_extra_p02596_s416996588_OP_1", "golden_code": "def c_repsept():\n\n    K = int(eval(input()))\n\n\n\n    if (K % 2 == 0 or K % 5 == 0):\n\n        return -1  # repsept の因数に 2, 5 はない\n\n\n\n    repsept = 7 % K\n\n    count = 1\n\n    while repsept % K !=0:\n\n        repsept = ((repsept * 10) + 7) % K\n\n        count += 1\n\n    return count\n\n\n\nprint((c_repsept()))", "generated_code": "def c_repsept():\n\n    K = int(eval(input()))\n\n\n\n    L = 9 * K // 7 if K % 7 == 0 else 9 * K\n\n    if L % 2 == 0 or L % 5 == 0:\n\n        return -1\n\n\n\n    remainder = 1\n\n    for n in range(1, L + 1):\n\n        remainder = (10 * remainder) % L\n\n        if remainder == 1:\n\n            return n\n\n    return -1\n\n\n\nprint((c_repsept()))", "score": 1.0, "codebleu": 0.39472767731303193, "crystalbleu": 0, "codebertscore": 0.86, "codescore": 0.5345626473426819, "surfaceSim": 0.7460681520314547, "abs_surfaceSim_minus_score": 0.2539318479685453, "source": "local", "local_type": "OP"}
{"id": "APPS_test-0872_43", "golden_code": "def solution():\n    n = input()\n    ar = list(map(int, input().split()))\n    o, e = False, False\n    for i in ar:\n        if i % 2 == 0:\n            o = True\n        else:\n            e = True\n    if o and e:\n        ar = sorted(ar)\n    for a in ar:\n        print(a, end=' ')\n\n\ndef __starting_point():\n    solution()\n\n__starting_point()", "generated_code": "n = int(input())\na = list(map(int, input().split()))\n\nans = []\nfor i in range(n):\n\tif a[i] % 2 == 0:\n\t\tans.append(a[i])\n\telse:\n\t\tt = a[i] // 2\n\t\tans.extend([t, -t])\nprint(*ans)\n", "score": 0.01, "codebleu": 0.2046558137853428, "crystalbleu": 0, "codebertscore": 0.79, "codescore": 0.09719164669513702, "surfaceSim": 0.5625, "abs_surfaceSim_minus_score": 0.5525, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_138_MUT_5", "golden_code": "import os\n\ndef is_equal_to_sum_even(n):\n    return (n % 2 == 0 and n >= 8)", "generated_code": "import os\n\ndef is_equal_to_sum_even(n):\n    return (n % 2 != 0 and n >= 8)", "score": 0.1003, "codebleu": 0.8932475127343132, "crystalbleu": 0, "codebertscore": 1.0, "codescore": 0.9934955835342407, "surfaceSim": 0.9376876876876876, "abs_surfaceSim_minus_score": 0.8373876876876876, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_PIE_extra_p03416_s196951264_OP_1", "golden_code": "a,b=list(map(int, input().split()))\n\ncnt=0\n\nfor i in range(a,b+1):\n\n    n=list(str(i))\n\n    if n==list(reversed(n)):\n\n        cnt+=1\n\nprint(cnt)", "generated_code": "from sys import stdin\n\nnii=lambda:list(map(int,stdin.readline().split()))\n\nlnii=lambda:list(map(int,stdin.readline().split()))\n\n\n\na,b=nii()\n\nans=0\n\nfor i in range(a,b+1):\n\n  s=str(i)\n\n  if s==s[::-1]:\n\n    ans+=1\n\n\n\nprint(ans)", "score": 1.0, "codebleu": 0.37683869299251754, "crystalbleu": 0.28, "codebertscore": 0.83, "codescore": 0.8703744411468506, "surfaceSim": 0.5523893805309734, "abs_surfaceSim_minus_score": 0.4476106194690266, "source": "local", "local_type": "OP"}
{"id": "MBPP_60_29", "golden_code": "def check_element(test_tup, check_list):\r\n  res = False\r\n  for ele in check_list:\r\n    if ele in test_tup:\r\n      res = True\r\n      break\r\n  return (res) ", "generated_code": "def check_element(test_list, ind) :\n\tfor elem in test_list :\n\t\tif elem == ind :\n\t\t\treturn True\n\treturn False", "score": 0.2332, "codebleu": 0.13061664930189432, "crystalbleu": 0, "codebertscore": 0.85, "codescore": 0.31747967004776, "surfaceSim": 0.7094155844155844, "abs_surfaceSim_minus_score": 0.4762155844155844, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_56_31", "golden_code": "def series_sum(number):\r\n total = 0\r\n total = (number * (number + 1) * (2 * number + 1)) / 6\r\n return total", "generated_code": "def series_sum(number):\n\tresult = 0\n\tfor i in range(1,number+1):\n\t\tresult = result + (i**2)\n\treturn result\nll = [1, 2, 3, 5, 7, 9]", "score": 1.0, "codebleu": 0.25822502053088153, "crystalbleu": 0, "codebertscore": 0.8, "codescore": 0.9938254356384277, "surfaceSim": 0.6102564102564103, "abs_surfaceSim_minus_score": 0.3897435897435897, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-1486_30", "golden_code": "n = int(input())\na = list(map(int, input().split()))\nprint(a[1] - a[0], a[-1] - a[0])\nfor i in range(1, n - 1):\n    print(min(a[i] - a[i - 1], a[i + 1] - a[i]), max(a[-1] - a[i], a[i] - a[0]))\nprint(a[-1] - a[-2], a[-1] - a[0])", "generated_code": "n=int(input())\na=list(map(int,input().split()))\na.sort()\nx=a[0]\nl=[]\nfor i in range(n):\n\tl.append([a[i],i])\nl.sort(key=lambda x:x[0])\nans=[]\nj=0\nfor i in l:\n\tx=a[j]\n\twhile j<n and l[j][0]==x:\n\t\tx=l[j][1]\n\t\tj+=1\n\tans.append([x,i[1]])\nfor i in ans:\n\tprint(i[0],i[1])\n", "score": 0.0, "codebleu": 0.26798576403594715, "crystalbleu": 0.23, "codebertscore": 0.8, "codescore": 0.026448223739862442, "surfaceSim": 0.44111906310995447, "abs_surfaceSim_minus_score": 0.44111906310995447, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-4152_35", "golden_code": "import bisect\nn = int(input())\na = [int(x) for x in input().split()]\na = sorted(a)\np2 = []\nfor i in range(1,31):\n    p2.append(2**i)\nc = 0\nif n == 1:\n    print(1)\nelse:\n    for i in range(0,n):\n        flag = 0\n        for j in p2:\n            if j > a[i]:\n                d = j -a[i]\n                f = bisect.bisect(a,d)\n                if d != a[i]:\n                    if a[f-1] == d:\n                        flag = 100\n                        break\n                else:\n                    if i != f-1:\n                        if a[f-1] == d:\n                            flag = 100\n                            break\n                    else:\n                        if a[f-2] == d:\n                            flag = 100\n                            break\n\n        if flag == 0:\n            c = c + 1\n    print(c)", "generated_code": "def main():\n\tn = int(input())\n\ta = list(map(int, input().split()))\n\ta.sort()\n\ti = 0\n\twhile i < n and a[i]!= 0:\n\t\ti += 1\n\tl = i\n\ts = 0\n\tm = []\n\twhile i + 1 < n:\n\t\tif a[i] == 0:\n\t\t\tl -= 1\n\t\t\ts += 1\n\t\t\tm.append(s)\n\t\t\tbreak\n\t\tif a [i] in m:\n\t\t\tl += 1\n\t\t\ts = 0\n\t\t\tm.remove(a[i])\n\t\t\tbreak\n\t\t\t\n\tm.append(2**(n-l))\n\tans = n - l\n\tfor i in m:\n\t\tans -= i\n\tprint(ans)\n\nmain()\n", "score": 0.0, "codebleu": 0.19761420831799914, "crystalbleu": 0.13, "codebertscore": 0.77, "codescore": 0.10444808751344681, "surfaceSim": 0.6653235653235653, "abs_surfaceSim_minus_score": 0.6653235653235653, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_76_12", "golden_code": "def word_len(s): \r\n    s = s.split(' ')   \r\n    for word in s:    \r\n        if len(word)%2==0: \r\n            return True  \r\n        else:\r\n          return False", "generated_code": "def word_len(s): \n\treturn len(s) % 2 == 0\nh = {}", "score": 0.9418, "codebleu": 0.12654730031929307, "crystalbleu": 0, "codebertscore": 0.77, "codescore": 0.993293285369873, "surfaceSim": 0.7115070284406668, "abs_surfaceSim_minus_score": 0.23029297155933315, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-4160_30", "golden_code": "X = int(input())\nmoney = 100\ny = 0\nwhile True:\n  money = 101 * money // 100\n#  print(money)\n  y += 1\n  if money >= X:\n    print(y)\n    break", "generated_code": "# coding: utf-8\n# Your code here!\nimport sys\nreadline = sys.stdin.readline\nread = sys.stdout.read\n\n#n,m = map(int,readline().split())\nt = int(readline())\n\ndef calc(x,m):\n\td = m/2\n\treturn int(d)\n\nans = calc(t,t)\nprint(ans)\n", "score": 0.018, "codebleu": 0.20858538877280725, "crystalbleu": 0, "codebertscore": 0.67, "codescore": 0.09041725844144821, "surfaceSim": 0.42082467082467084, "abs_surfaceSim_minus_score": 0.4028246708246708, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-2128_20", "golden_code": "M = 998244353\n \nn = int(input())\n \nexp = 0\nfor pi in map(int,input().split()):\n    exp = (exp+1) * 100 * pow(pi,M-2,M) % M\n \nprint(exp)", "generated_code": "from sys import stdin\ninput = stdin.readline\n\nn = int(input())\nL = [int(x) for x in input().split()]\n\nmx = 1\nanswer = 1\n\nfor i in range(1, n):\n\tmx = max(mx, L[i])\n\tanswer = (answer * (mx**(L[i]-1)) - (mx-1)**2) % 998244353\n\nprint(answer)\n", "score": 0.0006, "codebleu": 0.2653621428124582, "crystalbleu": 0, "codebertscore": 0.8, "codescore": 0.062003184109926224, "surfaceSim": 0.5051566080977845, "abs_surfaceSim_minus_score": 0.5045566080977845, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0175_30", "golden_code": "def solve(x, y):\n    if (x == 0 or y == 0):\n        return (x, y)\n    if (x >= 2 * y and y != 0):\n        x %= 2 * y\n    if (y >= 2 * x and x != 0):\n        y %= 2 * x\n    if (x == 0 or y == 0):\n        return (x, y)\n    if (x < 2 * y and y < 2 * x):\n        return (x, y)\n    return solve(x, y)\n\nx, y = list(map(int, input().split()))\nans = solve(x, y)\nprint(ans[0], ans[1])\n", "generated_code": "import sys\n\ndef main():\n\tn, m = list(map(int, sys.stdin.readline().split()))\n\tif n == 0 or m == 0:\n\t\tprint(0, 0)\n\t\treturn 0\n\ta, b = 0, 0\n\tx, y = 1, -1\n\twhile True:\n\t\ta += (2 * m if m > n else m)\n\t\tb += (2 * n if n > m else n)\n\t\tif a >= b:\n\t\t\tx = len(bin(a)) - 2\n\t\t\tb = a\n\t\telse:\n\t\t\tx += 1\n\t\t\tb = b - 2 * a\n\t\tif b >= x:\n\t\t\ty = len(bin((b - x) // 2)) - 1\n\t\t\tbreak\n\tprint(a-1, b - 1)\n\nmain()\n", "score": 0.0066, "codebleu": 0.1414061798285315, "crystalbleu": 0.1, "codebertscore": 0.79, "codescore": 0.027912674471735954, "surfaceSim": 0.48322622107969154, "abs_surfaceSim_minus_score": 0.47662622107969155, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_26_OP_1", "golden_code": "from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    import collections\n    c = collections.Counter(numbers)\n    return [n for n in numbers if c[n] <= 1]", "generated_code": "def remove_duplicates(values: List[int]) -> List[int]:\n    seen = set()\n    duplicates = set()\n    for value in values:\n        if value in seen:\n            duplicates.add(value)\n        else:\n            seen.add(value)\n    return [value for value in values if value not in duplicates]", "score": 1.0, "codebleu": 0.33135699856812956, "crystalbleu": 0, "codebertscore": 0.81, "codescore": 0.041886284947395325, "surfaceSim": 0.556821227552935, "abs_surfaceSim_minus_score": 0.44317877244706505, "source": "local", "local_type": "OP"}
{"id": "MBPP_34_14", "golden_code": "def even_num(x):\r\n  if x%2==0:\r\n     return True\r\n  else:\r\n    return False", "generated_code": "def even_num(n):  \n\treturn pow(2, n) \n\t''' x = count a number from the positive direction, (count by see if number has been assigned)\n\tcheck if the assigned number is in the assigned map\n\tif yes, it is the sum of all the powers of 2 in the string\n\totherwise its count is 0\n\treturn the sum of the assigned powers\n\t'''\n\t\n\treturn (factorial(n+1) - 1) * n;\n\nfactorial = lambda x: pow(2, x)", "score": 0.0707, "codebleu": 0.3017079699211292, "crystalbleu": 0, "codebertscore": 0.7, "codescore": 0.09685864299535751, "surfaceSim": 0.29480519480519485, "abs_surfaceSim_minus_score": 0.22410519480519486, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0356_22", "golden_code": "from collections import deque\nfrom sys import stdin\nlines = deque(line.strip() for line in stdin.readlines())\n\ndef nextline():\n    return lines.popleft()\n\ndef types(cast, sep=None):\n    return tuple(cast(x) for x in strs(sep=sep))\n\ndef ints(sep=None):\n    return types(int, sep=sep)\n\ndef strs(sep=None):\n    return tuple(nextline()) if sep == '' else tuple(nextline().split(sep=sep))\n\ndef main():\n    # lines will now contain all of the input's lines in a list\n    n = int(nextline())\n    a = ints()\n    m = int(nextline())\n    b = ints()\n    count = 1\n    i, j = 0, 0\n    a_sum, b_sum = 0, 0\n    a_total, b_total = 0, 0\n    while i < n and j < m:\n        if a_sum < b_sum:\n            a_total += a[i]\n            a_sum += a[i]\n            i += 1\n        else:\n            b_total += b[j]\n            b_sum += b[j]\n            j += 1\n        if a_sum == b_sum:\n            count += 1\n            a_sum, b_sum = 0, 0\n    while i < n and a_total < b_total:\n        a_total += a[i]\n        i += 1\n    while j < m and b_total < a_total:\n        b_total += b[j]\n        j += 1\n    if i == n and j == m and a_total == b_total:\n        return count\n    return -1\n\ndef __starting_point():\n    print(main())\n\n__starting_point()", "generated_code": "import math\n\ndef sum_up(a, b):\n\tans = 0\n\tfor i in range(len(a)):\n\t\tans += a[i]\n\treturn ans\n\ndef int_sum(a, b, x):\n\tans  = 0\n\tfor num in b:\n\t\tans += num\n\treturn ans\n\n\nn = int(input())\na = list(map(int, input().split()))\nm = int(input()); b = list(map (int, input(). split()))\nsa = sum_up( a, b )\nsb = sum_up ( b, a )\nif sa!= sb:\n\tprint(-1)\nelse:\n\tif sa == sb:\n\t\tprint(n)\n\telse:\n\t\tprint((sa - sb))\n", "score": 1.0, "codebleu": 0.1489739180739641, "crystalbleu": 0.04, "codebertscore": 0.72, "codescore": 0.7044076919555664, "surfaceSim": 0.5501685247601763, "abs_surfaceSim_minus_score": 0.4498314752398237, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_54_OP_1", "golden_code": "def same_chars(s0: str, s1: str):\n    return set(s0) == set(s1)", "generated_code": "def same_chars(a: str, b: str):\n    return len(a) == len(b) and set(a) == set(b)", "score": 0.9832, "codebleu": 0.45616778100465993, "crystalbleu": 0, "codebertscore": 0.88, "codescore": 0.8170047998428345, "surfaceSim": 0.7604166666666667, "abs_surfaceSim_minus_score": 0.22278333333333322, "source": "local", "local_type": "OP"}
{"id": "APPS_test-0484_17", "golden_code": "n, a, b = list(map(int, input().split()))\nx = list(range(n))\ny = list(range(n))\nfor i in range(n):\n\tx[i], y[i] = list(map(int, input().split()))\nans = 0\nfor i in range(n):\n\tfor j in range(i + 1, n):\n\t\t# 4 ways of rotating\n\t\tif (x[i] + x[j] <= b and max(y[i], y[j]) <= a) or (y[i] + y[j] <= a and max(x[i], x[j]) <= b):\n\t\t\tans = max(ans, x[i] * y[i] + x[j] * y[j])\n\t\tx[i], y[i] = y[i], x[i]\n\t\tif (x[i] + x[j] <= b and max(y[i], y[j]) <= a) or (y[i] + y[j] <= a and max(x[i], x[j]) <= b):\n\t\t\tans = max(ans, x[i] * y[i] + x[j] * y[j])\n\t\tx[j], y[j] = y[j], x[j]\n\t\tif (x[i] + x[j] <= b and max(y[i], y[j]) <= a) or (y[i] + y[j] <= a and max(x[i], x[j]) <= b):\n\t\t\tans = max(ans, x[i] * y[i] + x[j] * y[j])\n\t\tx[i], y[i] = y[i], x[i]\n\t\tif (x[i] + x[j] <= b and max(y[i], y[j]) <= a) or (y[i] + y[j] <= a and max(x[i], x[j]) <= b):\n\t\t\tans = max(ans, x[i] * y[i] + x[j] * y[j])\n\t\tx[j], y[j] = y[j], x[j]\nprint(ans)\n", "generated_code": "import sys\nfrom math import *\n\ndef minp():\n\treturn sys.stdin.readline().strip()\n\ndef mint():\n\treturn int(minp())\n\ndef mints():\n\treturn list(map(int, minp().split()))\n\ndef solve():\n\tn, a, b = mints()\n\tx = []\n\tfor i in range(n):\n\t\tx.append(mints())\n\tx.sort()\n\tf = [0]*n\n\tans = 0\n\tfor i, (xi, yi) in enumerate(x):\n\t\tif i == n-1:\n\t\t\tans = max(ans, xi*y)\n\t\telse:\n\t\t\tv = -x[i+1][0] - x[i][0]\n\t\t\tif v == 0:\n\t\t\t\tf[i] = 1\n\t\t\t", "score": 0.0, "codebleu": 0.1409387018121431, "crystalbleu": 0.03, "codebertscore": 0.75, "codescore": 0.018016276881098747, "surfaceSim": 0.4694123556002009, "abs_surfaceSim_minus_score": 0.4694123556002009, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_17_23", "golden_code": "def all_Bits_Set_In_The_Given_Range(n,l,r): \r\n    num = ((1 << r) - 1) ^ ((1 << (l - 1)) - 1) \r\n    new_num = n & num \r\n    if (num == new_num): \r\n        return True\r\n    return False", "generated_code": "def all_Bits_Set_In_The_Given_Range(n,l,r): \n\treturn bin(n)[2:] in list(bin(n)[3:])", "score": 0.5427, "codebleu": 0.07691762744547781, "crystalbleu": 0, "codebertscore": 0.79, "codescore": 0.5980921387672424, "surfaceSim": 0.5007411067193677, "abs_surfaceSim_minus_score": 0.04195889328063229, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_46_7", "golden_code": "def multiply_list(items):\r\n    tot = 1\r\n    for x in items:\r\n        tot *= x\r\n    return tot", "generated_code": "def multiply_list(item):    \n\treturn len(item) == 1", "score": 0.0348, "codebleu": 0.09414294316215, "crystalbleu": 0, "codebertscore": 0.79, "codescore": 0.02054130658507347, "surfaceSim": 0.5887096774193549, "abs_surfaceSim_minus_score": 0.5539096774193548, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_p00144_s682125154_MUT_104", "golden_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "generated_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        pass\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "score": 0.0, "codebleu": 0.9706943679537091, "crystalbleu": 0.96, "codebertscore": 0.99, "codescore": 0.9935300946235657, "surfaceSim": 0.977366616344252, "abs_surfaceSim_minus_score": 0.977366616344252, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-2025_30", "golden_code": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\ndef main():\n    n = int(input())\n    arr = [-1, -1, -1, -1, 1, -1, 1, -1, 2, 1, 2, -1]\n    for i in range(n):\n        a = int(input())\n        if (a >= 12):\n            print(a // 4 - a % 2)\n        else:\n            print(arr[a])\n\ndef __starting_point():\n    main()\n\n__starting_point()", "generated_code": "\ndef prime_factors(n):\n\ti = 2\n\tfactors = []\n\twhile i * i <= n:\n\t\tif n % i:\n\t\t\ti += 1\n\t\telse:\n\t\t\tn //= i\n\t\t\tfactors.append(i)\n\tif n > 1:\n\t\tfactors.append((n, 1))\n\treturn factors\n\n\nq = int(input())\nfor _ in range(q):\n\tn = int(input());\n\ts = prime_factors (n)\n\tif len (s) == 0:\n\t\tprint(-1)\n\telse:\n\t\ta = s[0]\n\t\tb = 0\n\t\tfor i in s[1:]:\n\t\t\ta += i\n\t\t\tb += i\n\t\t\tif a == b:\n\t\t\t\tprint(i)\n\t\t\t\tbreak\n\t\telse: print(-1)\n", "score": 0.4942, "codebleu": 0.2236668196550968, "crystalbleu": 0.09, "codebertscore": 0.74, "codescore": 0.36199554800987244, "surfaceSim": 0.5244252873563219, "abs_surfaceSim_minus_score": 0.030225287356321906, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_extra_p02555_s082576202_OP_1", "golden_code": "from functools import lru_cache\n\nimport sys\n\n\n\nsys.setrecursionlimit(2000)\n\n\n\ns = int(eval(input()))\n\nmod = 10 ** 9 + 7\n\n\n\n\n\n@lru_cache(maxsize=None)\n\ndef dfs(n):\n\n    if n <= 2:\n\n        return 0\n\n    elif 3<=n<=5:\n\n        return 1\n\n    else:\n\n        count = 1\n\n        for i in range(3, n + 1):\n\n            count += dfs(n - i)\n\n            count %= mod\n\n\n\n        return count % mod\n\n\n\n\n\nans = dfs(s)\n\nprint(ans)\n", "generated_code": "s = int(eval(input()))\n\nmod = 10 ** 9 + 7\n\n\n\ndp = [0] * (s + 1)\n\ndp[0] = 1\n\n\n\nx = 0\n\nfor i in range(3, s + 1):\n\n    x += dp[i - 3]\n\n    dp[i] = x % mod\n\n\n\nans = dp[s] % mod\n\nprint(ans)\n", "score": 1.0, "codebleu": 0.29486030542578806, "crystalbleu": 0, "codebertscore": 0.79, "codescore": 0.6482717394828796, "surfaceSim": 0.5230359623398673, "abs_surfaceSim_minus_score": 0.47696403766013273, "source": "local", "local_type": "OP"}
{"id": "APPS_test-3698_32", "golden_code": "# -*- encoding:utf-8 -*-\n\nimport sys\nfrom functools import reduce\n\n#sys.stdin = open('C.in', 'r')\ndef debug(*args):\n    return\n    print('debug ',end='')\n    for x in args:\n        print(x,end=' ')\n    print('')\n\nn = input()\nk = int(input())\nmod = 1000000007\n#n = '1'*1000\n#k = 5\n\na = [0] * 1001\n\ndef bitnum(x):\n    ans = 0\n    while x:\n        if x & 1: ans += 1\n        x >>= 1\n    return ans\n\nfor i in range(1,1001):\n    bn = bitnum(i)\n    a[i] = a[bn] + 1\n\n#debug([i for i in range(10)])\n#debug(a[:10])\n\n''' number of bits that needs k operations to reduce to 1 '''\na = [i for i in range(len(a)) if a[i]==k]\na = list(filter(lambda x: x <= len(n), a))\n#debug(a[:10])\n\nC = [None for i in range(1001)]\nC[0] = [1, 0]\nfor i in range(1, len(C)):\n    C[i] = [1] + [(C[i-1][j]+C[i-1][j-1])%mod for j in range(1,i)] + [1]\n\nanswer = 0\n\ndef cal2(x, arr):\n    nonlocal answer\n    while True:\n        ln = len(arr)\n        if x == 0:\n            answer += 1\n            return\n        if x > ln: return\n        if x == ln:\n            if '0' in arr:return\n            else:\n                answer += 1\n                return\n        answer += C[ln-1][x]\n        answer %= mod\n        #debug(ans, x)\n        i = arr.find('1', arr.index('1')+1)\n        if i < 0: \n            if x == 1: answer += 1\n            return\n        #debug(\"***\")\n        x -= 1\n        arr = arr[i:]\n        #cal2(x-1, arr[i:])\n\ndef cal(x):\n    nonlocal answer\n    answer = 0\n    cal2(x, n)\n    debug(answer)\n    return answer % mod\n\ndef solve():\n    if k == 0:return 1\n    if len(a) == 0:return 0\n    tmp = map(cal,a)\n    debug(list(tmp))\n    ans = reduce(lambda x,y:(x+y)%mod, map(cal, a))\n    return ans if k != 1 else ans-1\n\ntry:\n    print(solve())\nexcept Exception as e:\n    print(k, n[-30:])\n\n#print(solve())\n", "generated_code": "n = int(input())\nk = int(input(), 2)\np = 1000000007\nf = [1] * k;\nfor i in range(1, k):\n\tf[i] = (f[i - 1] * 2) % p;\ns = [0] * k;    \nfor i in reversed(list(range(k))):\n\ts[i] = f[i] * s[i - 1];\n\ts[ i ] = (s[i] + s[i + 1]) % p;\noutput = 0;\nfor ik in range(k):\n\toutput = (output + s[kk]) % p;    \nprint(output)\n", "score": 0.0122, "codebleu": 0.08467806672874309, "crystalbleu": 0.02, "codebertscore": 0.71, "codescore": 0.051998261362314224, "surfaceSim": 0.42132813962193527, "abs_surfaceSim_minus_score": 0.4091281396219353, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_MBPP_940_OP_1", "golden_code": "def heap_sort(arr):\r\n    heapify(arr)  \r\n    end = len(arr) - 1\r\n    while end > 0:\r\n        arr[end], arr[0] = arr[0], arr[end]\r\n        shift_down(arr, 0, end - 1)\r\n        end -= 1\r\n    return arr\r\n\r\ndef heapify(arr):\r\n    start = len(arr) // 2\r\n    while start >= 0:\r\n        shift_down(arr, start, len(arr) - 1)\r\n        start -= 1\r\ndef shift_down(arr, start, end):\r\n    root = start\r\n    while root * 2 + 1 <= end:\r\n        child = root * 2 + 1\r\n        if child + 1 <= end and arr[child] < arr[child + 1]:\r\n            child += 1\r\n        if child <= end and arr[root] < arr[child]:\r\n            arr[root], arr[child] = arr[child], arr[root]\r\n            root = child\r\n        else:\r\n            return\r\n", "generated_code": "def heap_sort(nums):\n    def heapify(nums, size):\n        for i in range(size // 2 - 1, -1, -1):\n            sift_down(nums, i, size)\n\n    def sift_down(nums, root, size):\n        while root * 2 + 1 < size:\n            child = root * 2 + 1\n            if child + 1 < size and nums[child] < nums[child + 1]:\n                child += 1\n            if nums[root] < nums[child]:\n                nums[root], nums[child] = nums[child], nums[root]\n                root = child\n            else:\n                break\n\n    length = len(nums)\n    heapify(nums, length)\n    for end in range(length - 1, 0, -1):\n        nums[end], nums[0] = nums[0], nums[end]\n        sift_down(nums, 0, end)\n    return nums\n", "score": 1.0, "codebleu": 0.39274845509211864, "crystalbleu": 0.26, "codebertscore": 0.78, "codescore": 0.9939509630203247, "surfaceSim": 0.6403780921651361, "abs_surfaceSim_minus_score": 0.3596219078348639, "source": "local", "local_type": "OP"}
{"id": "LOCAL_MBPP_938_OP_1", "golden_code": "import sys \r\n\r\ndef find_closet(A, B, C, p, q, r): \r\n\tdiff = sys.maxsize \r\n\tres_i = 0\r\n\tres_j = 0\r\n\tres_k = 0\r\n\ti = 0\r\n\tj = 0\r\n\tk = 0\r\n\twhile(i < p and j < q and k < r): \r\n\t\tminimum = min(A[i], min(B[j], C[k])) \r\n\t\tmaximum = max(A[i], max(B[j], C[k])); \r\n\t\tif maximum-minimum < diff: \r\n\t\t\tres_i = i \r\n\t\t\tres_j = j \r\n\t\t\tres_k = k \r\n\t\t\tdiff = maximum - minimum; \r\n\t\tif diff == 0: \r\n\t\t\tbreak\r\n\t\tif A[i] == minimum: \r\n\t\t\ti = i+1\r\n\t\telif B[j] == minimum: \r\n\t\t\tj = j+1\r\n\t\telse: \r\n\t\t\tk = k+1\r\n\treturn A[res_i],B[res_j],C[res_k]", "generated_code": "import sys\n\ndef find_closet(X, Y, Z, len_x, len_y, len_z):\n    min_difference = sys.maxsize\n    idx_x = 0\n    idx_y = 0\n    idx_z = 0\n    idx_a = 0\n    idx_b = 0\n    idx_c = 0\n    while(idx_a < len_x and idx_b < len_y and idx_c < len_z):\n        current_min = min(X[idx_a], Y[idx_b], Z[idx_c])\n        current_max = max(X[idx_a], Y[idx_b], Z[idx_c])\n        if current_max - current_min < min_difference:\n            idx_x = idx_a\n            idx_y = idx_b\n            idx_z = idx_c\n            min_difference = current_max - current_min\n        if min_difference == 0:\n            break\n        if X[idx_a] == current_min:\n            idx_a += 1\n        elif Y[idx_b] == current_min:\n            idx_b += 1\n        else:\n            idx_c += 1\n    return X[idx_x], Y[idx_y], Z[idx_z]\n", "score": 1.0, "codebleu": 0.4063953406769425, "crystalbleu": 0.11, "codebertscore": 0.75, "codescore": 0.993921160697937, "surfaceSim": 0.7961344168679991, "abs_surfaceSim_minus_score": 0.20386558313200087, "source": "local", "local_type": "OP"}
{"id": "MBPP_71_24", "golden_code": "import math\r\ndef get_First_Set_Bit_Pos(n):\r\n     return math.log2(n&-n)+1", "generated_code": "import math\ndef get_First_Set_Bit_Pos(n): \n\treturn n & ~(n - 1)", "score": 0.6047, "codebleu": 0.45189282899443894, "crystalbleu": 0, "codebertscore": 0.88, "codescore": 0.41063931584358215, "surfaceSim": 0.7530641672674838, "abs_surfaceSim_minus_score": 0.1483641672674838, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_70_34", "golden_code": "def is_abundant(n):\r\n    fctrsum = sum([fctr for fctr in range(1, n) if n % fctr == 0])\r\n    return fctrsum > n", "generated_code": "def is_abundant(n):\n\treturn n>0", "score": 0.207, "codebleu": 0.0605846276096557, "crystalbleu": 0, "codebertscore": 0.81, "codescore": 0.2301083207130432, "surfaceSim": 0.5165165165165165, "abs_surfaceSim_minus_score": 0.30951651651651657, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_76_30", "golden_code": "def word_len(s): \r\n    s = s.split(' ')   \r\n    for word in s:    \r\n        if len(word)%2==0: \r\n            return True  \r\n        else:\r\n          return False", "generated_code": "def word_len(s): \n\treturn len(s) % 2 == 0\nUSTP = 1 << 20", "score": 0.9733, "codebleu": 0.1824151709860414, "crystalbleu": 0, "codebertscore": 0.75, "codescore": 0.9936368465423584, "surfaceSim": 0.7146126185027787, "abs_surfaceSim_minus_score": 0.25868738149722137, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-4183_59", "golden_code": "import math\nfrom functools import reduce\n\ndef lcm_base(x, y):\n    return (x * y) // math.gcd(x, y)\n\ndef lcm_list(numbers):\n    return reduce(lcm_base, numbers, 1)\n\nn = int(input())\n\nl = []\n\nfor i in range(n):\n    t = int(input())\n    l.append(t)\n\nprint((lcm_list(l)))\n", "generated_code": "import sys\nreadline = sys.stdin.readline\n\nN = int(readline())\nT = list(map(int, readline().split()))\nK = T[0]\nfor t in range(1, N):\n\tif t%2 == 0:\n\t\tK = (K-1)%360\n\telse:\n\t\tK\t\t\t= (K+1)%360\n\n\tT[t] = (T[t]-1)%360+K\n\nprint(max(T))\n", "score": 0.0628, "codebleu": 0.2336587670679129, "crystalbleu": 0.02, "codebertscore": 0.73, "codescore": 0.04661985859274864, "surfaceSim": 0.3976453937210499, "abs_surfaceSim_minus_score": 0.33484539372104993, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-4202_13", "golden_code": "L, R = map(int, input().split())\n\n# 例：L=3000, R=10000 で考える\n# (i,j)=(3000,3001)から始まり、(3000,5018)で最小(=0)\n\n# R-L>=2019 のとき、(L,L+1),...,(L,L+2019)の間で最小値0を取れるので、高々2018回の探索\n# 全探索しても break すれば間に合う！\nm = 2019\nflag = False\nfor i in range(L, R):\n  for j in range(i+1, R+1):\n    m = min(m, i*j % 2019)\n    if m == 0: \n      flag = True\n      break\n  if flag: break\n\nprint(m)", "generated_code": "import sys\ninput = sys.stdin.readline\n\ndef main():\n\tL, R = map(int, input().split())\n\tN = R - L + 1\n\tS = ((R + 1) * N) // 2\n\tT = L % S\n\tM = 10 ** 9 + 7\n\ta = None\n\tb = None\n\tcnt = 0\n\tfor i in range(L, S + 1):\n\t\ta = i % M\n\t\tif a == 0:\n\t\t\ty = i\n\t\t\tfor j in range(N):\n\t\t\t\tB = y\n\t\t\t\tfor k in range(N)[::-1]:\n\t\t\t\t\tB = (B - (a + j % M + T)) % M\n\t\t\t\t\tY = (B + cnt) % M\n\t\t\t\t\tif Y!= 0:\n\t\t\t\t\t\ta = y\n\t\t\t\t\t\tbreak\n\t\t\t\telse:\n\t\t\t\t\tcontinue\n\t\t\t\tbreak", "score": 0.0, "codebleu": 0.26376736167739256, "crystalbleu": 0.1, "codebertscore": 0.7, "codescore": 0.018513299524784088, "surfaceSim": 0.5514578521939953, "abs_surfaceSim_minus_score": 0.5514578521939953, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_160_35_MUT_49", "golden_code": "from math import sqrt\nfrom bisect import bisect_left\n\ndef main():\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    sum_a = sum(a)\n    st = set()\n    for v in range(1, int(sqrt(sum_a)) + 2):\n        if sum_a % v == 0:\n            st.add(v)\n            st.add(sum_a // v)\n    st.remove(1)\n    ans = 1\n    for target in st:\n        a_mod_t = [v % target for v in a]\n        a_mod_t.sort()\n        for i in range(n - 1):\n            a_mod_t[i + 1] += a_mod_t[i]\n        for i in range(n):\n            (sum_L, sum_R) = (a_mod_t[i], a_mod_t[-1] - a_mod_t[i])\n            (len_L, len_R) = (i + 1, (n - i) - 1)\n            if sum_L == (target * len_R) - sum_R:\n                if sum_L <= k:\n                    if ans < target:\n                        ans = target\n    print(ans)\n\ndef __starting_point():\n    main()\n__starting_point()", "generated_code": "from math import sqrt\nfrom bisect import bisect_left\n\ndef main():\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    sum_a = sum(a)\n    st = set()\n    for v in range(1, int(sqrt(sum_a)) + 2):\n        if sum_a % v == 0:\n            st.add(v)\n            st.add(sum_a // v)\n    st.remove(1)\n    ans = 1\n    for target in st:\n        pass\n        a_mod_t.sort()\n        for i in range(n - 1):\n            a_mod_t[i + 1] += a_mod_t[i]\n        for i in range(n):\n            (sum_L, sum_R) = (a_mod_t[i], a_mod_t[-1] - a_mod_t[i])\n            (len_L, len_R) = (i + 1, (n - i) - 1)\n            if sum_L == (target * len_R) - sum_R:\n                if sum_L <= k:\n                    if ans < target:\n                        ans = target\n    print(ans)\n\ndef __starting_point():\n    main()\n__starting_point()", "score": 0.0, "codebleu": 0.9226484983223004, "crystalbleu": 0.94, "codebertscore": 0.99, "codescore": 0.8917127251625061, "surfaceSim": 0.9419450707112114, "abs_surfaceSim_minus_score": 0.9419450707112114, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_MBPP_403_MUT_6", "golden_code": "import os\n\nimport re\ndef is_valid_URL(str):\n    regex = ((('((http|https)://)(www.)?' + \\\n        '[a-zA-Z0-9@:%._\\\\+~#?&//=]') + \\\n        '{2,256}\\\\.[a-z]') + \\\n        '{2,6}\\\\b([-a-zA-Z0-9@:%') + \\\n        '._\\\\+~#?&//=]*)'\n    p = re.compile(regex)\n    if str == None:\n        return False\n    if re.search(p, str):\n        return True\n    else:\n        return False", "generated_code": "import os\n\nimport re\ndef is_valid_URL(str):\n    regex = ((('((http|https)://)(www.)?' + \\\n        '[a-zA-Z0-9@:%._\\\\+~#?&//=]') + \\\n        '{2,256}\\\\.[a-z]') + \\\n        '{2,6}\\\\b([-a-zA-Z0-9@:%') + \\\n        '._\\\\+~#?&//=]*)'\n    p = re.compile(regex)\n    if str == None:\n        return False\n    if not (re.search(p, str)):\n        return True\n    else:\n        return False", "score": 0.0, "codebleu": 0.9241399602548943, "crystalbleu": 0.91, "codebertscore": 0.99, "codescore": 0.993686854839325, "surfaceSim": 0.9457496526462044, "abs_surfaceSim_minus_score": 0.9457496526462044, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_APPS_955_11_OP_2", "golden_code": "n=int(input())\nd={}\nfor _ in range(n):\n    s=input().split()\n    p=int(s[0])\n    s[1]=list(s[1])\n    s[1].sort()\n    s[1]=''.join(s[1])\n    if s[1] in d:\n        d[s[1]]=min(d[s[1]],p)\n    else:\n        d[s[1]]=p\ndef get(s):\n    if s in d:\n        return d[s]\n    return 10**6\na=get('A')\nb=get('B')\nc=get('C')\nab=get('AB')\nbc=get('BC')\nac=get('AC')\nabc=get('ABC')\nans=min(a+b+c,a+bc,b+ac,c+ab,abc,ab+bc,ab+ac,ac+bc)\nif ans<10**6:\n    print(ans)\nelse:\n    print(-1)", "generated_code": "from itertools import combinations\nfrom functools import lru_cache\n\nnum_items = int(input())\nprice_dict = {}\n\nfor _ in range(num_items):\n    data = input().split()\n    cost = int(data[0])\n    components = ''.join(sorted(data[1]))\n    if components in price_dict:\n        price_dict[components] = min(price_dict[components], cost)\n    else:\n        price_dict[components] = cost\n\n@lru_cache(None)\ndef get_price(components):\n    return price_dict.get(''.join(sorted(components)), 10**6)\n\nall_combinations = ['A', 'B', 'C', 'AB', 'BC', 'AC', 'ABC']\n\nbest_price = float('inf')\nfor i in range(1, 4):\n    for combo in combinations(all_combinations, i):\n        selected_components = ''.join(combo)\n        if len(set(selected_components)) == 3:\n            best_price = min(best_price, sum(get_price(c) for c in combo))\n\nresult = best_price if best_price < 10**6 else -1\nprint(result)\n", "score": 1.0, "codebleu": 0.24303011321309098, "crystalbleu": 0.19, "codebertscore": 0.77, "codescore": 0.8843055963516235, "surfaceSim": 0.5721894715068776, "abs_surfaceSim_minus_score": 0.4278105284931224, "source": "local", "local_type": "OP"}
{"id": "APPS_test-1738_37", "golden_code": "def prefix(s):\n    p = [0]\n    for i in range(1, len(s)):\n        j = p[-1]\n        while j > 0 and s[j] != s[i]:\n            j = p[j - 1]\n        if s[i] == s[j]:\n            j += 1\n        p.append(j)\n    return p\n\n\ns = input()\nn = len(s)\nans = [0] * (n + 1)\ni = n - 1\n\nwhile i >= 0:\n    p = prefix(s[i:])\n    ans[i] = 2 + ans[i + 1]\n    for j in range(len(p)):\n        z = 1\n        if (j + 1) % (j + 1 - p[j]) == 0:\n            z = (j + 1) // (j + 1 - p[j])\n        res = len(str(z)) + (j + 1) // z + ans[i + j + 1]\n        ans[i] = min(ans[i], res)\n    i -= 1\n\nprint(ans[0])\n", "generated_code": "s=input()\nn=len(s)\nans=0\nif n==1:\n\tprint(len(s))\n\treturn\nif n==2:\n\tif s[0]==s[1]:\n\t\tprint(2)\n\t\treturn\n\telse:\n\t\tprint(3)\n\t\treturn 3\nfor i in range(n-1):\n\tcurr=s[i]\n\tnex=s[i+1]\n\tfor j in range(i+2,n):\n\t\tnex=nex==s[j]\n\t\tif curr==nex:\n\t\t\tans+=1\n\t\t\tif i!=j-2:\n\t\t\t\tans+=1\n\t\telse:\n\t\t\tbreak\nprint(ans)\n", "score": 0.0, "codebleu": 0.1681474593207087, "crystalbleu": 0.11, "codebertscore": 0.78, "codescore": 0.060234181582927704, "surfaceSim": 0.5607875116495806, "abs_surfaceSim_minus_score": 0.5607875116495806, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_extra_p03814_s883482084_OP_1", "golden_code": "s = eval(input())\n\n\n\nstart = -1\n\nend = 0\n\nfor i in range(len(s)):\n\n    if s[i] == 'A' and start < 0:\n\n        start = i\n\n    elif s[i] == 'Z':\n\n        end = i\n\nprint((end - start + 1))\n", "generated_code": "s = eval(input())\n\n\n\nstart = 0\n\nfor i in range(len(s)):\n\n    if s[i] == 'A':\n\n        start = i\n\n        break\n\n\n\nend = 0\n\nfor i in reversed(list(range(len(s)))):\n\n    if s[i] == 'Z':\n\n        end = i\n\n        break\n\nprint((end - start + 1))\n", "score": 1.0, "codebleu": 0.6117105849764274, "crystalbleu": 0.61, "codebertscore": 0.93, "codescore": 0.20219355821609497, "surfaceSim": 0.739399928135106, "abs_surfaceSim_minus_score": 0.260600071864894, "source": "local", "local_type": "OP"}
{"id": "LOCAL_PIE_extra_p03796_s560811979_OP_1", "golden_code": "import math\n\nx = int(eval(input()))\n\nprint((math.factorial(x) % (10**9 + 7)))", "generated_code": "n = int(eval(input()))\n\nfact = 1\n\nfor i in range(1,n+1):\n\n  fact = fact * i % (10**9 +7)\n\nres = fact % (10**9 + 7)\n\nprint(res)", "score": 1.0, "codebleu": 0.28499817494097796, "crystalbleu": 0, "codebertscore": 0.82, "codescore": 0.5412095189094543, "surfaceSim": 0.5791316526610644, "abs_surfaceSim_minus_score": 0.42086834733893563, "source": "local", "local_type": "OP"}
{"id": "LOCAL_APPS_2095_3_MUT_10", "golden_code": "N = int(input())\nmat = [list(map(int, input().split())) for _ in range(N)]\nans = []\nfor i in range(N):\n    flag = True\n    for j in range(N):\n        if (mat[i][j] == 3 or mat[i][j] == 1):\n            flag = False\n    if flag == True:\n        ans.append(i + 1)\nif len(ans) == 0:\n    print(0)\nelse:\n    print(len(ans))\n    print(*ans)", "generated_code": "N = int(input())\nmat = [list(map(int, input().split())) for _ in range(N)]\nans = []\nfor i in reversed(range(N)):\n    flag = True\n    for j in range(N):\n        if (mat[i][j] == 3 or mat[i][j] == 1):\n            flag = False\n    if flag == True:\n        ans.append(i + 1)\nif len(ans) == 0:\n    print(0)\nelse:\n    print(len(ans))\n    print(*ans)", "score": 0.045, "codebleu": 0.8891992595876772, "crystalbleu": 0.94, "codebertscore": 0.99, "codescore": 0.9936610460281372, "surfaceSim": 0.9854227405247813, "abs_surfaceSim_minus_score": 0.9404227405247813, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-4202_12", "golden_code": "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Thu Sep 10 11:33:13 2020\n\n@author: liang\n\"\"\"\n\nL, R = map(int,input().split())\nr = R%2019\nl = L%2019\nans = 2018\nif R - L >= 2019 - l or l==0:\n#if r < l or l == 0:\n    ans = 0\nelse:\n    for i in range(l,r):\n        for j in range(i+1,r+1):\n            ans = min(ans,i*j%2019)\nprint(ans)", "generated_code": "l,r=map(int,input().split())\nd=10**9+7\nprint(((r-l+1)*d)//2)\n", "score": 0.0, "codebleu": 0.12713734142305572, "crystalbleu": 0, "codebertscore": 0.7, "codescore": 0.02530081570148468, "surfaceSim": 0.5192208462332302, "abs_surfaceSim_minus_score": 0.5192208462332302, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_58_MUT_12", "golden_code": "import os\n\ndef common(l1: list, l2: list):\n    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))", "generated_code": "import os\n\ndef common(l1: list, l2: list):\n    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                pass\n    return sorted(list(ret))", "score": 0.2845, "codebleu": 0.8080047262046604, "crystalbleu": 0, "codebertscore": 0.98, "codescore": 0.9523320198059082, "surfaceSim": 0.8932748538011696, "abs_surfaceSim_minus_score": 0.6087748538011696, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_HE_158_OP_1", "golden_code": "def find_max(words):\n    return sorted(words, key = lambda x: (-len(set(x)), x))[0]", "generated_code": "def find_max(strings):\n    max_word = ''\n    max_unique = 0\n    for word in strings:\n        unique_count = len(set(word))\n        if unique_count > max_unique or (unique_count == max_unique and word < max_word):\n            max_unique = unique_count\n            max_word = word\n    return max_word", "score": 1.0, "codebleu": 0.23316687479457132, "crystalbleu": 0, "codebertscore": 0.75, "codescore": 0.2965683043003082, "surfaceSim": 0.37639821029082776, "abs_surfaceSim_minus_score": 0.6236017897091722, "source": "local", "local_type": "OP"}
{"id": "APPS_test-2047_11", "golden_code": "import sys\n\n# @profile\ndef main():\n    f = sys.stdin\n    # f = open('input.txt', 'r')\n    # fo = open('log.txt', 'w')\n    n = int(f.readline())\n    # b = []\n    # for i in range(n):\n    #    b.append()\n    b = list(map(int, f.readline().strip().split(' ')))\n    a = list(map(int, f.readline().strip().split(' ')))\n    # return\n    b = [b[i] - a[i] for i in range(n)]\n    c = [[0, 0]]\n    for i in range(n - 1):\n        line = f.readline().strip().split(' ')\n        c.append([int(line[0]), int(line[1])])\n    # print(c)\n    for i in range(n - 1, 0, -1):\n        # print(i)\n        fa = c[i][0] - 1\n        if b[i] >= 0:\n            b[fa] += b[i]\n        else:\n            b[fa] += b[i] * c[i][1]\n            if b[fa] < -1e17:\n                print('NO')\n                return 0\n    # for x in b:\n    #    fo.write(str(x) + '\\n')\n    if b[0] >= 0:\n        print('YES')\n    else:\n        print('NO')\n\nmain()\n", "generated_code": "n = int(input())\n\nb = list(map(int, input().split()))\na = list(map (int, input(). split()))\n\nb.sort()\na.sort()\n\nprint( \"YES\" if (b[0] + a[0]*a[1] - b[0]* a[1]) >= 0 else \"NO\" )\n", "score": 0.5156, "codebleu": 0.09614763399406737, "crystalbleu": 0.06, "codebertscore": 0.71, "codescore": 0.5089120268821716, "surfaceSim": 0.584257855567806, "abs_surfaceSim_minus_score": 0.06865785556780601, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0330_54", "golden_code": "import math\n\ndef check(x):\n\tlimit = math.ceil(math.sqrt(x))\n\t\n\tfor i in range(3, limit+1, 2):\n\t\tif x%i==0:\n\t\t\treturn i\n\treturn x\n\np,y = list(map(int, input().split()))\n\nans = -1\n\nif y%2==0:\n\ty-=1\n\nfor x in range(y, p, -2):\n\tq = check(x)\n\tif q>p:\n\t\tans = x\n\t\tbreak\nprint(ans)\n", "generated_code": "import math\n\ndef main():\n\tp, y = map(int, input().split())\n\tif p > y:\n\t\tprint(-1)\n\t\treturn\n\tx = math.floor(math.sqrt(y))\n\tn = y//x\n\tif n <= 0:\n\t\tprint(n)\n\t\treturn\n\n\td = x - 1\n\twhile d > 0:\n\t\tif (y - d*x) % (n + 1) == 0:\n\t\t\treturn n+1\n\t\td -= 1\n\tprint(-1)\n\nmain()\n", "score": 0.2218, "codebleu": 0.20663955452504743, "crystalbleu": 0.2, "codebertscore": 0.82, "codescore": 0.1636492908000946, "surfaceSim": 0.5975757575757575, "abs_surfaceSim_minus_score": 0.37577575757575754, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_1073_23_MUT_26", "golden_code": "n = int(input())\nch = str(input())\nr = 0\na = 0\nb = 0\nT = [[0, 0]]\nfor k in range(n):\n    if ch[k] == 'U':\n        a += 1\n    elif ch[k] == 'D':\n        a -= 1\n    elif ch[k] == 'R':\n        b += 1\n    else:\n        b -= 1\n    T += [[a, b]]\n\nfor i in range(1, n + 1):\n    for j in range(i):\n        if T[j] == T[i]:\n            r += 1\n\nprint(r)", "generated_code": "pass\nch = str(input())\nr = 0\na = 0\nb = 0\nT = [[0, 0]]\nfor k in range(n):\n    if ch[k] == 'U':\n        a += 1\n    elif ch[k] == 'D':\n        a -= 1\n    elif ch[k] == 'R':\n        b += 1\n    else:\n        b -= 1\n    T += [[a, b]]\n\nfor i in range(1, n + 1):\n    for j in range(i):\n        if T[j] == T[i]:\n            r += 1\n\nprint(r)", "score": 0.0, "codebleu": 0.8060763150050481, "crystalbleu": 0.91, "codebertscore": 0.98, "codescore": 0.9936771988868713, "surfaceSim": 0.9560495626822157, "abs_surfaceSim_minus_score": 0.9560495626822157, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_PIE_extra_p03371_s850530798_OP_1", "golden_code": "A,B,C,X,Y = list(map(int,input().split()))\n\nl = []\n\nfor i in range(max(X,Y)+1):\n\n    T = i * C * 2\n\n    if i < X: \n\n        T += (X-i)*A\n\n    if i < Y:\n\n        T += (Y-i)*B\n\n    l.append(T)\n\nl.sort()\n\nprint((l[0]))", "generated_code": "A,B,C,X,Y = list(map(int,input().split()))\n\nans = 0\n\nif 2*C <= A+B:\n\n    Z = min(X,Y)\n\n    ans = 2*C*Z\n\n    X -= Z\n\n    Y -= Z\n\nans += min(2*C*X,A*X)\n\nans += min(2*C*Y,B*Y)\n\nprint(ans)", "score": 1.0, "codebleu": 0.240291100090611, "crystalbleu": 0.39, "codebertscore": 0.83, "codescore": 0.4188210666179657, "surfaceSim": 0.6765419615773508, "abs_surfaceSim_minus_score": 0.3234580384226492, "source": "local", "local_type": "OP"}
{"id": "LOCAL_PIE_p02612_s197156959_MUT_8", "golden_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "generated_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if not (n != 0):\n        n = 1000 - n\n    print(n)", "score": 0.0, "codebleu": 0.9717262939382055, "crystalbleu": 0.97, "codebertscore": 1.0, "codescore": 0.9938138723373413, "surfaceSim": 0.9788490495012234, "abs_surfaceSim_minus_score": 0.9788490495012234, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_APPS_3723_2_MUT_29", "golden_code": "import functools\n\n\n@functools.lru_cache(maxsize=10000)\ndef factor(n):res = []\n    d = 2\n    while d * d <= n:\n        if n % d == 0:\n            res.append(d)\n            n //= d\n        else:\n            d += 1\n    if n > 1:\n        res.append(n)\n    return set(res)\n\nnum = int(input())\n\npoks = list(map(int, input().split()))[:num]\n\nc = dict()\nfor p in poks:\n    for d in factor(p):\n        if d in c.keys():\n            c[d] += 1\n        else:\n            c[d] = 1\n\nif c:\n    print(max(c.values()))\nelse:\n    print(1)", "generated_code": "import functools\n\n\n@functools.lru_cache(maxsize=10000)\ndef factor(n):res = []\n    d = 2\n    while d * d <= n:\n        if n % d == 0:\n            res.append(d)\n            n //= d\n        else:\n            d += 1\n    if n > 1:\n        res.append(n)\n    return set(res)\n\nnum = int(input())\n\npoks = list(map(int, input().split()))[:num]\n\nc = dict()\nfor p in poks:\n    for d in factor(p):\n        if d in c.keys():\n            c[d] += 1\n        else:\n            c[d] = 1\n\nif c:\n    print(max(c.values()))\nelse:\n    print(1)", "score": 0.0, "codebleu": 1.0, "crystalbleu": 1.0, "codebertscore": 1.0, "codescore": 0.9937980771064758, "surfaceSim": 0.5, "abs_surfaceSim_minus_score": 0.5, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-1164_10", "golden_code": "q=input()\na=[]\nw=len(q)\ni=w-1\nwhile i>0:\n\tif '0'<=q[i]<='9':\n\t\tj=i-1\n\t\twhile not('a'<=q[j]<='z'):\n\t\t\tj-=1\n\t\ta.append(q[j+1:i+1])\n\t\ti=j\n\ti-=1\ns=0\nfor i in a:\n\tl=len(i)\n\tif l>2:\n\t\tif i[l-3]=='.':\n\t\t\ts+=int(i[l-2:])\n\t\t\ti=i[:l-3]\n\t\ti=i.replace('.','')\n\ts+=int(i)*100\nd=''\nr=s\nif s%100!=0:\n\td='.'+str(s%100)\nif len(d)==2:\n\td=d[0]+'0'+d[1]\ns//=100\nrt=s\ntr=d\nwhile s//1000!=0:\n\tt=str(s%1000)\n\tif len(t)==1:\n\t\tt='.00'+t\n\telif len(t)==2:\n\t\tt='.0'+t\n\telse:\n\t\tt='.'+t\n\td=t+d\n\ts//=1000\nif s!=0:\n\tt=str(s%1000)\n\td=t+d\nelse:\n\td=d[1:]\nif len(d)==2:\n\td='0.'+d\nelif d=='':\n\td='0'\nprint(d)", "generated_code": "import sys\nimport math\n#from queue import *\nimport bisect\n#sys.setrecursionlimit(100000)\ndef input():\n\treturn sys.stdin.readline()[:-1]\ndef printe(*args):\n\tprint(*args, file=sys.stderr)\ndef printl(li):\n\treturn print(*li, sep='\\n')\ndef prime(n):\n\tif n < 2: return False\n\tif n == 2: return True\n\tif n % 2 == 0: return False\n     \n\tfor i in range(3, int(n**0.5)+1, 2):\n\t\tif n % i == 0: return 0\n\treturn True\n#\n#def not_prime(n):\n#    for i in range (2, n):\n#        if n % i!= 0:\n#            return False\n#    ", "score": 0.2022, "codebleu": 0.05935512254945982, "crystalbleu": 0.0, "codebertscore": 0.69, "codescore": 0.018605748191475868, "surfaceSim": 0.3534876767331596, "abs_surfaceSim_minus_score": 0.15128767673315963, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_4490_74_OP_1", "golden_code": "b = input()\n\nif b == 'A':\n    print('T')\nelif b == 'T':\n    print('A')\nelif b == 'C':\n    print('G')\nelse:\n    print('C')", "generated_code": "nucleotide = input()\ncomplement = {'A': 'T', 'T': 'A', 'C': 'G', 'G': 'C'}\nprint(complement.get(nucleotide, 'C'))", "score": 1.0, "codebleu": 0.23990935282035403, "crystalbleu": 0, "codebertscore": 0.79, "codescore": 0.9633195400238037, "surfaceSim": 0.48951048951048953, "abs_surfaceSim_minus_score": 0.5104895104895104, "source": "local", "local_type": "OP"}
{"id": "LOCAL_HE_122_OP_1", "golden_code": "def add_elements(arr, k):\n    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)", "generated_code": "def add_elements(lst, limit):\n    return sum(x for x in lst[:limit] if x < 100 and x > -100)", "score": 0.9728, "codebleu": 0.32368119189870703, "crystalbleu": 0, "codebertscore": 0.85, "codescore": 0.9406743049621582, "surfaceSim": 0.6235177865612649, "abs_surfaceSim_minus_score": 0.3492822134387351, "source": "local", "local_type": "OP"}
{"id": "APPS_test-3974_68", "golden_code": "s=input()\ns=list(s)\ns1=[0]*len(s)\nfor i in range(len(s)):\n    if s[i]=='-':\n        s[i]=1\n        s1[i]=-1 \n    else:\n        s[i]=-1 \n        s1[i]=1 \ndef kadane(s):\n    maxi=-1 \n    curr=0 \n    for i in s:\n        curr=max(curr+i,i)\n        maxi=max(maxi,curr)\n    return maxi \nprint(max(kadane(s),kadane(s1)))\n#@print(kadane(s))\n", "generated_code": "def main():\n\ta = input().strip()\n\tb = a.split(\"+\")\n\tcount = 0\n\tflag = False\n\tfor i in b:\n\t\tif i == a:\n\t\t\tif flag:\n\t\t\t\tcount += 1\n\t\t\tflag = False\n\t\telse:\n\t\t\tflag = True\n\t\t\tcount += 1\n\tprint(count)\n\n\ndef __starting_point():\n\tmain()\n\n__starting_point()\n", "score": 0.0, "codebleu": 0.10616223166620975, "crystalbleu": 0.03, "codebertscore": 0.72, "codescore": 0.055837150663137436, "surfaceSim": 0.5166897666897667, "abs_surfaceSim_minus_score": 0.5166897666897667, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-1772_35", "golden_code": "n = int(input())\ns = list(map(int, input().split()))\n\noddd = 0\nevend = 0\n\nfor i in range(n):\n if s[i] % 2 == 0:\n  oddd += 1\n else:\n  evend += 1\nif evend == 0:\n print(0)\nelse:\n if oddd == 0:\n  print(evend // 3)\n else:\n  if oddd < evend:\n   print(oddd + (evend - oddd) // 3)\n  else:\n   print(evend)", "generated_code": "n = int(input())\na = [int(i) for i in input().split()]\nb = [0 for i in range(n)]\nfor i in range(len(a)):\n\tb[a[i] - 1] += 1\nresult = 0\nfor i in b:\n\tresult += i // 2\n\tresult += (i % 2)\nprint(result)\n", "score": 0.0, "codebleu": 0.24580266779468046, "crystalbleu": 0.23, "codebertscore": 0.8, "codescore": 0.14821569621562958, "surfaceSim": 0.6165540540540541, "abs_surfaceSim_minus_score": 0.6165540540540541, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_extra_p03796_s459904551_OP_1", "golden_code": "import math\n\n\n\nN = int(eval(input()))\n\n\n\nprint((math.factorial(N) % (1000000000 + 7)))\n", "generated_code": "import math\n\n\n\nN = int(eval(input()))\n\n\n\np = 1\n\nfor i in range(2, N+1):\n\n  p *= i\n\n  p = p % (1000000000 + 7)\n\n  \n\nprint(p)\n", "score": 1.0, "codebleu": 0.44478213020541774, "crystalbleu": 0, "codebertscore": 0.86, "codescore": 0.1281084418296814, "surfaceSim": 0.7412239089184061, "abs_surfaceSim_minus_score": 0.25877609108159394, "source": "local", "local_type": "OP"}
{"id": "APPS_test-0543_68", "golden_code": "n=int(input())\nL =[int(x) for x in input().split()]\nL.append(0)\n\npossib = True\nfor i in range(n):\n    if L[i] < 0:\n        possib = False\n        break\n    if L[i]&1:\n        L[i+1] -= 1\n\nif L[-1] < 0:\n    possib = False\n\nif possib:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n", "generated_code": "def main():\n\tn = int(input())\n\ta = list(map(int, input().split()))\n\tcheck = 0\n\tfor i in range(n):\n\t\tif a[i] > check:\n\t\t\tfor j in range(i + 1, n):\n\t\t\t\tif a[j] > check: break\n\t\t\t\tcheck = max(check, a[j] - j)\n\t\t\telse:\n\t\t\t\tcheck = check - 1\n\tif check > 0:\n\t\tprint(\"YES\")\n\telse:\n\t\tprint('NO')\n\n\ndef __starting_point():\n\tmain()\n\n__starting_point()\n", "score": 0.2104, "codebleu": 0.28362213755576976, "crystalbleu": 0.23, "codebertscore": 0.81, "codescore": 0.3893968462944031, "surfaceSim": 0.56265664160401, "abs_surfaceSim_minus_score": 0.35225664160400993, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_27_OP_1", "golden_code": "def flip_case(string: str) -> str:\n    return string.swapcase()", "generated_code": "def flip_case(txt: str) -> str:\n    return ''.join(chr(ord(ch) ^ 32) if 'A' <= ch <= 'Z' or 'a' <= ch <= 'z' else ch for ch in txt)", "score": 0.8748, "codebleu": 0.4779389667538556, "crystalbleu": 0, "codebertscore": 0.8, "codescore": 0.5299355387687683, "surfaceSim": 0.4730916030534351, "abs_surfaceSim_minus_score": 0.4017083969465649, "source": "local", "local_type": "OP"}
{"id": "LOCAL_HE_150_OP_1", "golden_code": "def x_or_y(n, x, y):\n    if n == 1:\n        return y\n    for i in range(2, n):\n        if n % i == 0:\n            return y\n            break\n    else:\n        return x", "generated_code": "def x_or_y(limit, prime_val, composite_val):\n    if limit == 1:\n        return composite_val\n    if limit == 2:\n        return prime_val\n    for divisor in range(2, int(limit ** 0.5) + 1):\n        if limit % divisor == 0:\n            return composite_val\n    return prime_val", "score": 1.0, "codebleu": 0.3416692356881903, "crystalbleu": 0, "codebertscore": 0.82, "codescore": 0.04324876144528389, "surfaceSim": 0.6901435406698564, "abs_surfaceSim_minus_score": 0.3098564593301436, "source": "local", "local_type": "OP"}
{"id": "LOCAL_HE_41_OP_1", "golden_code": "def car_race_collision(n: int):\n    return n**2", "generated_code": "def car_race_collision(distance: int):\n    return pow(distance, 2)", "score": 1.0, "codebleu": 0.4018930858793478, "crystalbleu": 0, "codebertscore": 0.92, "codescore": 0.32265040278434753, "surfaceSim": 0.7121212121212122, "abs_surfaceSim_minus_score": 0.28787878787878785, "source": "local", "local_type": "OP"}
{"id": "LOCAL_MBPP_453_MUT_28", "golden_code": "import os\n\nimport math\ndef sumofFactors(n):\n    if n % 2 != 0:\n        return 0\n    res = 1\n    for i in range(2, int(math.sqrt(n)) + 1):\n        count = 0\n        curr_sum = 1\n        curr_term = 1\n        while n % i == 0:\n            count = count + 1\n            n = n // i\n            if (i == 2 and count == 1):\n                curr_sum = 0\n            curr_term = curr_term * i\n            curr_sum = curr_sum + curr_term\n        res = res * curr_sum\n    if n >= 2:\n        res = res * (1 + n)\n    return res", "generated_code": "import os\n\nimport math\ndef sumofFactors(n):\n    if n % 2 == 0:\n        return 0\n    res = 1\n    for i in range(2, int(math.sqrt(n)) + 1):\n        count = 0\n        curr_sum = 1\n        curr_term = 1\n        while n % i == 0:\n            count = count + 1\n            n = n // i\n            if (i == 2 and count == 1):\n                curr_sum = 0\n            curr_term = curr_term * i\n            curr_sum = curr_sum + curr_term\n        res = res * curr_sum\n    if n >= 2:\n        res = res * (1 + n)\n    return res", "score": 0.0, "codebleu": 0.9856633619349873, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.9934960603713989, "surfaceSim": 0.9811719833564494, "abs_surfaceSim_minus_score": 0.9811719833564494, "source": "local", "local_type": "MUT"}
{"id": "MBPP_70_59", "golden_code": "def is_abundant(n):\r\n    fctrsum = sum([fctr for fctr in range(1, n) if n % fctr == 0])\r\n    return fctrsum > n", "generated_code": "def is_abundant(n):    \n return n > 2", "score": 0.4017, "codebleu": 0.0626350652877028, "crystalbleu": 0, "codebertscore": 0.81, "codescore": 0.5045970678329468, "surfaceSim": 0.5165165165165165, "abs_surfaceSim_minus_score": 0.11481651651651653, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0672_47", "golden_code": "import math\n\na, b= [int(i) for i in input().split()]\n\nif a<b: print (0)\nelse: \n    if a== b: print(\"infinity\")\n    else:               #>b and divisors of a\n        def FindAllDivisors(x, b):\n            y = 1\n            ans= []\n            while y <= int(math.sqrt(x)):\n                #print(y)\n                if x % y == 0:\n                    #print(x, int(x/y))\n                    if y!= int(x/y) :\n                        if y>b:\n                            ans.append(y)\n                        if int(x/y)>b:\n                            ans.append(int(x/y))\n                    elif y== int(x/y) and y>b:\n                        ans.append(y)\n                y += 1\n            return len(ans)\n        print(FindAllDivisors(a-b, b))", "generated_code": "import sys\n\ndef main():\n\ta,b=map(int,sys.stdin.readline().strip().split())\n\tif a==b:\n\t\tprint(\"infinity\")\n\t\treturn\n\tc=(b*b)%a\n\td=a-b\n\tif d==0:\n\t\tprint(0)\n\t\treturn\n \n\te=(b*b)/(d-a)\n\tf=(a*d)/(b-a)\n  \n\tprint(int(c+e)%2)\n\treturn\n\ndef __starting_point():\n\tmain()\n__starting_point()\n", "score": 0.046, "codebleu": 0.13922816473852145, "crystalbleu": 0.12, "codebertscore": 0.73, "codescore": 0.2258439064025879, "surfaceSim": 0.6613017795723044, "abs_surfaceSim_minus_score": 0.6153017795723044, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_140_OP_1", "golden_code": "def fix_spaces(text):\n    new_text = \"\"\n    i = 0\n    start, end = 0, 0\n    while i < len(text):\n        if text[i] == \" \":\n            end += 1\n        else:\n            if end - start > 2:\n                new_text += \"-\"+text[i]\n            elif end - start > 0:\n                new_text += \"_\"*(end - start)+text[i]\n            else:\n                new_text += text[i]\n            start, end = i+1, i+1\n        i+=1\n    if end - start > 2:\n        new_text += \"-\"\n    elif end - start > 0:\n        new_text += \"_\"\n    return new_text", "generated_code": "def fix_spaces(input_string):\n    result = []\n    count_spaces = 0\n    for char in input_string:\n        if char == ' ':\n            count_spaces += 1\n        else:\n            if count_spaces > 2:\n                result.append('-')\n            elif count_spaces > 0:\n                result.append('_' * count_spaces)\n            result.append(char)\n            count_spaces = 0\n    if count_spaces > 2:\n        result.append('-')\n    elif count_spaces > 0:\n        result.append('_' * count_spaces)\n    return ''.join(result)\n", "score": 0.9929, "codebleu": 0.1245481585167313, "crystalbleu": 0.09, "codebertscore": 0.78, "codescore": 0.11658172309398651, "surfaceSim": 0.5985359275669427, "abs_surfaceSim_minus_score": 0.39436407243305727, "source": "local", "local_type": "OP"}
{"id": "MBPP_45_8", "golden_code": "def coin_change(S, m, n): \r\n    table = [[0 for x in range(m)] for x in range(n+1)] \r\n    for i in range(m): \r\n        table[0][i] = 1\r\n    for i in range(1, n+1): \r\n        for j in range(m): \r\n            x = table[i - S[j]][j] if i-S[j] >= 0 else 0\r\n            y = table[i][j-1] if j >= 1 else 0 \r\n            table[i][j] = x + y   \r\n    return table[n][m-1] ", "generated_code": "def coin_change(S, m, n): \n\treturn n*S.count(m)", "score": 0.2952, "codebleu": 0.055963414795689885, "crystalbleu": 0, "codebertscore": 0.69, "codescore": 0.30436834692955017, "surfaceSim": 0.42028236914600553, "abs_surfaceSim_minus_score": 0.1250823691460055, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_p02537_s645565645_MUT_147", "golden_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "generated_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, __node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "score": 0.0384, "codebleu": 0.9860383920377368, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9825941920280457, "surfaceSim": 0.9984634296250768, "abs_surfaceSim_minus_score": 0.9600634296250768, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-1168_16", "golden_code": "n = int(input())\na = [int(i) for i in input().split()]\nl = [i for i in range(len(a))]\nr = [i for i in range(len(a))]\nfor i in range(len(a)):\n\twhile l[i]>=1 and a[i]|a[l[i]-1]<=a[i]:\n\t\tl[i] = l[l[i]-1]\n    \nfor j in range(len(a)):\n\ti = len(a)-j-1\n\twhile r[i]<len(a)-1 and a[i]|a[r[i]+1]<=a[i] and a[i]>a[r[i]+1]:\n\t\tr[i] = r[r[i]+1]\n\ncount=0\nfor i in range(len(a)):\n\tx = r[i]-i+1\n\ty = i-l[i]+1\n\tcount+=x*y-1\nprint((n*(n-1))//2-count)", "generated_code": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\nimport time\n\n\ndef solve(n, A):\n\ts = set()\n\tfor i in range(n):\n\t\tfor j in range(i+1, n):\n\t\t\tif (A[i] | A[j]) > A[s]:\n\t\t\t\ts.add((A[i], A[j]))\n\tprint(len(s))\n\treturn 0\n\n\ndef __starting_point():\n\tstart = time.time()\n\tn = int(input())\n\tA = list(map(int, input().split()))\n\tprint('solve(n, A)')\n\tstart =time.time()\n", "score": 0.0, "codebleu": 0.17067621491105578, "crystalbleu": 0.07, "codebertscore": 0.74, "codescore": 0.03711079806089401, "surfaceSim": 0.4083840220731172, "abs_surfaceSim_minus_score": 0.4083840220731172, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_MBPP_532_OP_1", "golden_code": "def check_permutation(str1, str2):\r\n  n1=len(str1)\r\n  n2=len(str2)\r\n  if(n1!=n2):\r\n    return False\r\n  a=sorted(str1)\r\n  str1=\" \".join(a)\r\n  b=sorted(str2)\r\n  str2=\" \".join(b)\r\n  for i in range(0, n1, 1):\r\n    if(str1[i] != str2[i]):\r\n      return False\r\n  return True", "generated_code": "def check_permutation(s1, s2):\n  if len(s1) != len(s2):\n    return False\n  from collections import Counter\n  return Counter(s1) == Counter(s2)", "score": 0.9958, "codebleu": 0.16190956173786175, "crystalbleu": 0, "codebertscore": 0.81, "codescore": 0.9672738313674927, "surfaceSim": 0.5394456289978677, "abs_surfaceSim_minus_score": 0.4563543710021323, "source": "local", "local_type": "OP"}
{"id": "APPS_test-0077_56", "golden_code": "N = int( input() )\nA = list( map( int, input().split() ) )\ndp = [ [ - int( 1e9 ) for i in range( 2 ) ] for j in range( N + 1 ) ]\ndp[ 0 ][ 0 ] = 0\nfor i in range( N ):\n  for j in range( 2 ):\n    if abs( A[ i ] ) & 1:\n      dp[ i + 1 ][ j ] = max( dp[ i ][ j ], dp[ i ][ j ^ 1 ] + A[ i ] )\n    else:\n      dp[ i + 1 ][ j ] = max( dp[ i ][ j ], dp[ i ][ j ] + A[ i ] )\nprint( dp[ N ][ 1 ] )\n", "generated_code": "import sys\nn = int(input())\na = list(map(int, input().split()))\nsys.setrecursionlimit(10**6)\nans = -1\ncur = 0\nfor i in range(n):\n\tcur += a[i]\n\tif cur%2==0:\n\t\tans = cur\n\telif cur>ans:\n\t\tans=cur\nprint(ans)\n", "score": 0.0166, "codebleu": 0.16701576608638918, "crystalbleu": 0.09, "codebertscore": 0.75, "codescore": 0.09510768204927444, "surfaceSim": 0.5740312833274084, "abs_surfaceSim_minus_score": 0.5574312833274084, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_3_OP_1", "golden_code": "from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    balance = 0\n\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n\n    return False", "generated_code": "def below_zero(transactions: List[int]) -> bool:\n    current_sum = 0\n    if transactions[0] < 0:\n        return True\n    for change in transactions:\n        current_sum += change\n        if current_sum < 0:\n            return True\n    return False", "score": 1.0, "codebleu": 0.4158425842920743, "crystalbleu": 0, "codebertscore": 0.89, "codescore": 0.9921740293502808, "surfaceSim": 0.7374493927125506, "abs_surfaceSim_minus_score": 0.2625506072874494, "source": "local", "local_type": "OP"}
{"id": "MBPP_33_3", "golden_code": "def count_Unset_Bits(n) :  \r\n    cnt = 0;  \r\n    for i in range(1,n + 1) : \r\n        temp = i;  \r\n        while (temp) :  \r\n            if (temp % 2 == 0) : \r\n                cnt += 1;  \r\n            temp = temp // 2;  \r\n    return cnt;  ", "generated_code": "def count_Unset_Bits(n=0):\n\tcount=0\n\twhile n>0:\n\t\tcount+=1\n\t\tn=n&(2**(len(bin(n))-2))   \n\treturn(count)\n\n\n\n\n\n\n\n\n\n\n\t'''\n\tn = int(input())\n\t\n\tn : the number of bits to use in the binary representation\n\twe will check if n is a power of 2 and binary should return the number of set bits (p_bits) with 1as the count of 1's in n as the count of the number of 1 in that position.\n\t'''", "score": 0.0889, "codebleu": 0.11491779779339983, "crystalbleu": 0, "codebertscore": 0.73, "codescore": 0.08752717822790146, "surfaceSim": 0.4270557029177719, "abs_surfaceSim_minus_score": 0.33815570291777186, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_332_1", "golden_code": "def remove_words(list1, charlist):\r\n    new_list = []\r\n    for line in list1:\r\n        new_words = ' '.join([word for word in line.split() if not any([phrase in word for phrase in charlist])])\r\n        new_list.append(new_words)\r\n    return new_list", "generated_code": "def remove_words(list1, charlist):\n\treturn [list(word) for word in list1 if charlist!=[] ]", "score": 0.0, "codebleu": 0.1145115176662995, "crystalbleu": 0, "codebertscore": 0.84, "codescore": 0.2352929562330246, "surfaceSim": 0.5444505293902884, "abs_surfaceSim_minus_score": 0.5444505293902884, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_43_55", "golden_code": "def is_Two_Alter(s):  \r\n    for i in range (len( s) - 2) : \r\n        if (s[i] != s[i + 2]) : \r\n            return False\r\n    if (s[0] == s[1]): \r\n        return False\r\n    return True", "generated_code": "def is_Two_Alter(s):   \n\treturn True if s.isnumeric() else False", "score": 0.8401, "codebleu": 0.059144455068376435, "crystalbleu": 0, "codebertscore": 0.77, "codescore": 0.9672529697418213, "surfaceSim": 0.5105563835072032, "abs_surfaceSim_minus_score": 0.32954361649279673, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_17_8", "golden_code": "def all_Bits_Set_In_The_Given_Range(n,l,r): \r\n    num = ((1 << r) - 1) ^ ((1 << (l - 1)) - 1) \r\n    new_num = n & num \r\n    if (num == new_num): \r\n        return True\r\n    return False", "generated_code": "def all_Bits_Set_In_The_Given_Range(n,l,r): \n\treturn l>0 and r<n", "score": 0.4692, "codebleu": 0.11778301206086242, "crystalbleu": 0, "codebertscore": 0.81, "codescore": 0.4953922629356384, "surfaceSim": 0.495306324110672, "abs_surfaceSim_minus_score": 0.026106324110671986, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_1085_39_MUT_17", "golden_code": "n = int(input())\ndef make_divisors(n):\n    divisors = []\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n // i)\n    return divisors\nimport sys\nsys.setrecursionlimit(10 ** 7)\ndef func(N, d):\n    if d == 1:\n        return False\n    while N > 1:\n        if N % d == 0:\n            N //= d\n        \n        elif (N - 1) % d == 0:\n            N = 1\n        else:\n            N = 0\n    return True if N == 1 else False\n\nans = len(set(make_divisors(n - 1))) - 1\nl = set(make_divisors(n))\nfor li in l:\n    if func(n, li):\n        ans += 1\nprint(ans)", "generated_code": "n = int(input())\ndef make_divisors(n):\n    divisors = []\n    for i in range(1, int(n ** 0.5) + 1):\n        if not (n % i == 0):\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n // i)\n    return divisors\nimport sys\nsys.setrecursionlimit(10 ** 7)\ndef func(N, d):\n    if d == 1:\n        return False\n    while N > 1:\n        if N % d == 0:\n            N //= d\n        \n        elif (N - 1) % d == 0:\n            N = 1\n        else:\n            N = 0\n    return True if N == 1 else False\n\nans = len(set(make_divisors(n - 1))) - 1\nl = set(make_divisors(n))\nfor li in l:\n    if func(n, li):\n        ans += 1\nprint(ans)", "score": 0.006, "codebleu": 0.9596718207224129, "crystalbleu": 0.96, "codebertscore": 1.0, "codescore": 0.9937117099761963, "surfaceSim": 0.9658859940872137, "abs_surfaceSim_minus_score": 0.9598859940872136, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_PIE_p02680_s341076610_MUT_150", "golden_code": "import sys\n(n, m, *abcdef) = list(map(int, sys.stdin.buffer.read().split()))\nver_lines = []\nhor_lines = []\nx_list = set()\ny_list = set()\nn3 = n * 3\nfor (a, b, c) in zip(abcdef[0:n3:3], abcdef[1:n3:3], abcdef[2:n3:3]):\n    y_list.add(a)\n    y_list.add(b)\n    x_list.add(c)\n    ver_lines.append((a, b, c))\nfor (d, e, f) in zip(abcdef[n3 + 0::3], abcdef[n3 + 1::3], abcdef[n3 + 2::3]):\n    y_list.add(d)\n    x_list.add(e)\n    x_list.add(f)\n    hor_lines.append((d, e, f))\nx_list.add(0)\ny_list.add(0)\nx_list = sorted(x_list)\ny_list = sorted(y_list)\nx_dict = {x: i for (i, x) in enumerate(x_list, start=1)}\ny_dict = {y: i for (i, y) in enumerate(y_list, start=1)}\nrow_real = len(x_list)\ncol_real = len(y_list)\nrow = row_real + 2\ncol = col_real + 2\nbanned_up_ij = [[0] * row for _ in range(col)]\nbanned_down_ij = [[0] * row for _ in range(col)]\nbanned_left_ij = [[0] * col for _ in range(row)]\nbanned_right_ij = [[0] * col for _ in range(row)]\nfor (a, b, c) in ver_lines:\n    if a > b:\n        (a, b) = (b, a)\n    ai = y_dict[a]\n    bi = y_dict[b]\n    j = x_dict[c]\n    banned_left_ij[j][ai] += 1\n    banned_left_ij[j][bi] -= 1\n    banned_right_ij[j - 1][ai] += 1\n    banned_right_ij[j - 1][bi] -= 1\nfor (d, e, f) in hor_lines:\n    if e > f:\n        (e, f) = (f, e)\n    i = y_dict[d]\n    ej = x_dict[e]\n    fj = x_dict[f]\n    banned_up_ij[i][ej] += 1\n    banned_up_ij[i][fj] -= 1\n    banned_down_ij[i - 1][ej] += 1\n    banned_down_ij[i - 1][fj] -= 1\nbanned_up = [0] * (row * col)\nbanned_down = [0] * (row * col)\nbanned_left = [0] * (row * col)\nbanned_right = [0] * (row * col)\nfor i in range(col):\n    ru = banned_up_ij[i]\n    rd = banned_down_ij[i]\n    ri = row * i\n    banned_up[ri] = ru[0]\n    banned_down[ri] = rd[0]\n    for j in range(1, row):\n        banned_up[ri + j] = banned_up[(ri + j) - 1] + ru[j]\n        banned_down[ri + j] = banned_down[(ri + j) - 1] + rd[j]\nfor j in range(row):\n    rl = banned_left_ij[j]\n    rr = banned_right_ij[j]\n    banned_left[j] = rl[0]\n    banned_right[j] = rr[0]\n    for i in range(1, col):\n        ri0 = (i - 1) * row\n        ri1 = i * row\n        banned_left[ri1 + j] = banned_left[ri0 + j] + rl[i]\n        banned_right[ri1 + j] = banned_right[ri0 + j] + rr[i]\ns = (row * y_dict[0]) + x_dict[0]\nenable = (([-1] * row) + ((([-1] + ([0] * (row - 2))) + [-1]) * (col - 2))) + ([-1] * row)\nq = [s]\nmoves = [(-row, banned_up), (-1, banned_left), (1, banned_right), (row, banned_down)]\nwhile q:\n    c = q.pop()\n    if enable[c] == 1:\n        continue\n    elif enable[c] == -1:\n        print('INF')\n        exit()\n    enable[c] = 1\n    for (dc, banned) in moves:\n        if banned[c]:\n            continue\n        nc = c + dc\n        if enable[nc] == 1:\n            continue\n        q.append(nc)\nans = 0\nfor i in range(col):\n    ri = i * row\n    for j in range(row):\n        if enable[ri + j] != 1:\n            continue\n        t = y_list[i - 1]\n        b = y_list[i]\n        l = x_list[j - 1]\n        r = x_list[j]\n        ans += (b - t) * (r - l)\nprint(ans)", "generated_code": "import sys\n(n, m, *abcdef) = list(map(int, sys.stdin.buffer.read().split()))\nver_lines = []\nhor_lines = []\nx_list = set()\ny_list = set()\nn3 = n * 3\nfor (a, b, c) in zip(abcdef[0:n3:3], abcdef[1:n3:3], abcdef[2:n3:3]):\n    y_list.add(a)\n    y_list.add(b)\n    x_list.add(c)\n    ver_lines.append((a, b, c))\nfor (d, e, f) in zip(abcdef[n3 + 0::3], abcdef[n3 + 1::3], abcdef[n3 + 2::3]):\n    y_list.add(d)\n    x_list.add(e)\n    x_list.add(f)\n    hor_lines.append((d, e, f))\nx_list.add(0)\ny_list.add(0)\nx_list = sorted(x_list)\ny_list = sorted(y_list)\nx_dict = {x: i for (i, x) in enumerate(x_list, start=1)}\ny_dict = {y: i for (i, y) in enumerate(y_list, start=1)}\nrow_real = len(x_list)\ncol_real = len(y_list)\nrow = row_real + 2\ncol = col_real + 2\nbanned_up_ij = [[0] * row for _ in range(col)]\nbanned_down_ij = [[0] * row for _ in range(col)]\nbanned_left_ij = [[0] * col for _ in range(row)]\nbanned_right_ij = [[0] * col for _ in range(row)]\nfor (a, b, c) in ver_lines:\n    if a > b:\n        (a, b) = (b, a)\n    ai = y_dict[a]\n    bi = y_dict[b]\n    j = x_dict[c]\n    banned_left_ij[j][ai] += 1\n    banned_left_ij[j][bi] -= 1\n    banned_right_ij[j - 1][ai] += 1\n    banned_right_ij[j - 1][bi] -= 1\nfor (d, e, f) in hor_lines:\n    if e > f:\n        (e, f) = (f, e)\n    i = y_dict[d]\n    ej = x_dict[e]\n    fj = x_dict[f]\n    banned_up_ij[i][ej] += 1\n    banned_up_ij[i][fj] -= 1\n    banned_down_ij[i - 1][ej] += 1\n    banned_down_ij[i - 1][fj] -= 1\nbanned_up = [0] * (row * col)\nbanned_down = [0] * (row * col)\nbanned_left = [0] * (row * col)\nbanned_right = [0] * (row * col)\nfor i in range(col):\n    ru = banned_up_ij[i]\n    rd = banned_down_ij[i]\n    ri = row * i\n    banned_up[ri] = ru[0]\n    banned_down[ri] = rd[0]\n    for j in range(1, row):\n        banned_up[ri + j] = banned_up[(ri + j) - 1] + ru[j]\n        banned_down[ri + j] = banned_down[(ri + j) - 1] + rd[j]\nfor j in range(row):\n    rl = banned_left_ij[j]\n    rr = banned_right_ij[j]\n    banned_left[j] = rl[0]\n    banned_right[j] = rr[0]\n    for i in range(1, col):\n        ri0 = (i - 1) * row\n        ri1 = i * row\n        banned_left[ri1 + j] = banned_left[ri0 + j] + rl[i]\n        banned_right[ri1 + j] = banned_right[ri0 + j] + rr[i]\n    break\ns = (row * y_dict[0]) + x_dict[0]\nenable = (([-1] * row) + ((([-1] + ([0] * (row - 2))) + [-1]) * (col - 2))) + ([-1] * row)\nq = [s]\nmoves = [(-row, banned_up), (-1, banned_left), (1, banned_right), (row, banned_down)]\nwhile q:\n    c = q.pop()\n    if enable[c] == 1:\n        continueelif enable[c] == -1:\n        print('INF')\n        exit()\n    enable[c] = 1\n    for (dc, banned) in moves:\n        if banned[c]:\n            continue\n        nc = c + dc\n        if enable[nc] == 1:\n            continue\n        q.append(nc)\nans = 0\nfor i in range(col):\n    ri = i * row\n    for j in range(row):\n        if enable[ri + j] != 1:\n            continue\n        t = y_list[i - 1]\n        b = y_list[i]\n        l = x_list[j - 1]\n        r = x_list[j]\n        ans += (b - t) * (r - l)\nprint(ans)", "score": 0.0, "codebleu": 0.9846371920378602, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9542043805122375, "surfaceSim": 0.4988309953239813, "abs_surfaceSim_minus_score": 0.4988309953239813, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_HE_117_MUT_4", "golden_code": "import os\n\ndef select_words(s, n):\n    result = []\n    for word in s.split():\n        n_consonants = 0\n        for i in range(0, len(word)):\n            if word[i].lower() not in ['a', 'e', 'i', 'o', 'u']:\n                n_consonants += 1\n        if n_consonants == n:\n            result.append(word)\n    return result", "generated_code": "import os\n\ndef select_words(s, n):\n    result = []\n    for word in s.split():\n        n_consonants = 0\n        for i in range(0, len(word)):\n            if word[i].lower() not in ['a', 'e', 'i', 'o', 'u']:\n                n_consonants += 1\n        if not (n_consonants == n):\n            result.append(word)\n    return result", "score": 0.4139, "codebleu": 0.9046872049920478, "crystalbleu": 0.95, "codebertscore": 0.99, "codescore": 0.9935795068740845, "surfaceSim": 0.9552706552706554, "abs_surfaceSim_minus_score": 0.5413706552706554, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-0940_21", "golden_code": "def solve():\n    a = [int(x) for x in input().split()]\n    print(max(0,max(a)-(sum(a)-max(a)) + 1))\nsolve()\n# for _ in range(int(input())):\n", "generated_code": "import sys\nimport math\n\ndef main():\n\ta, b, c = list(map(int, input().split()))\n\tif a + b <= c:\n\t\tprint(0)\n\telse:\n\t\ttemp = a + b + c\n\t\tif temp <= temp // 2:\n\t\t\tprint(temp - temp // 2)\n\t\telse:\n\t\t\tprint((temp - temp //2) - c)\n\ndef __starting_point():\n\tmain()\n\n__starting_point()\n", "score": 0.0268, "codebleu": 0.19827371825233825, "crystalbleu": 0, "codebertscore": 0.73, "codescore": 0.0603933148086071, "surfaceSim": 0.5, "abs_surfaceSim_minus_score": 0.4732, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_extra_p02748_s393648468_OP_1", "golden_code": "a, b, m = list(map(int,input().split()))\n\ndr = list(map(int,input().split()))\n\nwa = list(map(int,input().split()))\n\nxyc = [list(map(int,input().split())) for i in range(m)]\n\nlow = 200001\n\n\n\nfor i in range(m):\n\n    f = xyc[i][0] - 1\n\n    d = xyc[i][1] - 1\n\n    if low >= dr[f]+wa[d]-xyc[i][2]:\n\n        low = dr[f]+wa[d]-xyc[i][2]\n\n\n\ndr.sort()\n\nwa.sort()\n\n\n\nif low >= (dr[0] + wa[0]):\n\n    print((dr[0] + wa[0]))\n\nelse:\n\n    print(low)", "generated_code": "a, b, m = list(map(int,input().split()))\n\nal = list(map(int,input().split()))\n\nbl = list(map(int,input().split()))\n\nlow = min(al)+min(bl)\n\nx = [0] * m\n\ny = [0] * m\n\nc = [0] * m\n\n\n\nfor i in range(m):\n\n    x[i],y[i],c[i] = list(map(int, input().split()))\n\n    x[i] -= 1\n\n    y[i] -= 1\n\n \n\nfor i in range(m):\n\n    low = min(low,al[x[i]]+bl[y[i]]-c[i])\n\n\n\nprint(low)", "score": 1.0, "codebleu": 0.35418127921457465, "crystalbleu": 0.28, "codebertscore": 0.85, "codescore": 0.2737131416797638, "surfaceSim": 0.6340245775729647, "abs_surfaceSim_minus_score": 0.3659754224270353, "source": "local", "local_type": "OP"}
{"id": "LOCAL_MBPP_950_MUT_29", "golden_code": "import os\n\ndef chinese_zodiac(year):\n    if (year - 2000) % 12 == 0:\n        sign = 'Dragon'\n    elif (year - 2000) % 12 == 1:\n        sign = 'Snake'\n    elif (year - 2000) % 12 == 2:\n        sign = 'Horse'\n    elif (year - 2000) % 12 == 3:\n        sign = 'sheep'\n    elif (year - 2000) % 12 == 4:\n        sign = 'Monkey'\n    elif (year - 2000) % 12 == 5:\n        sign = 'Rooster'\n    elif (year - 2000) % 12 == 6:\n        sign = 'Dog'\n    elif (year - 2000) % 12 == 7:\n        sign = 'Pig'\n    elif (year - 2000) % 12 == 8:\n        sign = 'Rat'\n    elif (year - 2000) % 12 == 9:\n        sign = 'Ox'\n    elif (year - 2000) % 12 == 10:\n        sign = 'Tiger'\n    else:\n        sign = 'Hare'\n    return sign", "generated_code": "import os\n\ndef chinese_zodiac(year):\n    if (year - 2000) % 12 == 0:\n        sign = 'Dragon'\n    elif (year - 2000) % 12 == 1:\n        sign = 'Snake'\n    elif (year - 2000) % 12 == 2:\n        sign = 'Horse'\n    elif (year - 2000) % 12 == 3:\n        sign = 'sheep'\n    elif (year - 2000) % 12 == 4:\n        sign = 'Monkey'\n    elif (year - 2000) % 12 == 5:\n        sign = 'Rooster'\n    elif not ((year - 2000) % 12 == 6):\n        sign = 'Dog'\n    elif (year - 2000) % 12 == 7:\n        sign = 'Pig'\n    elif (year - 2000) % 12 == 8:\n        sign = 'Rat'\n    elif (year - 2000) % 12 == 9:\n        sign = 'Ox'\n    elif (year - 2000) % 12 == 10:\n        sign = 'Tiger'\n    else:\n        sign = 'Hare'\n    return sign", "score": 0.433, "codebleu": 0.9699664878064971, "crystalbleu": 0.93, "codebertscore": 0.99, "codescore": 0.9936611652374268, "surfaceSim": 0.9464838255977497, "abs_surfaceSim_minus_score": 0.5134838255977496, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_PIE_p02599_s870922238_MUT_19", "golden_code": "import sys\nclass BinaryIndexedTree:\n    def __init__(self, A):\n        self.__n = len(A)\n        self.__node = [0] * (self.__n + 1)\n        self.__data = [0] * (self.__n + 1)\n        S = [0] * (self.__n + 1)\n        for i in range(1, self.__n + 1):\n            S[i] = S[i - 1] + A[i - 1]\n            self.__data[i] = A[i - 1]\n            self.__node[i] = S[i] - S[i - (i & (-i))]\n    def add(self, i, v):\n        self.__data[i] += v\n        while i <= self.__n:\n            self.__node[i] += v\n            i += i & (-i)\n    def sum(self, i):\n        rst = 0\n        while i > 0:\n            rst += self.__node[i]\n            i -= i & (-i)\n        return rst\n    def get(self, i, j):\n        if i == j:\n            return self.__data[i]\n        else:\n            return self.sum(j) - self.sum(i - 1)\ndef main():\n    (N, Q) = map(int, input().split())\n    C = list(map(int, input().split()))\n    P = [[] for _ in range(N)]\n    for (i, c) in enumerate(C):\n        P[c - 1].append(i)\n    right = [0] * N\n    for p in P:\n        if len(p):\n            right[p.pop()] = 1\n    BIT = BinaryIndexedTree(right)\n    query = [[] for _ in range(N)]\n    for (i, s) in enumerate(sys.stdin.readlines()):\n        (l, r) = map(int, s.split())\n        query[r - 1].append((l - 1, i))\n    ans = [None] * Q\n    cur = N - 1\n    for (r, q) in enumerate(reversed(query)):\n        r = (N - 1) - r\n        while q:\n            (l, i) = q.pop()\n            while r < cur:\n                c = C[cur] - 1\n                p = P[c]\n                if len(p):\n                    BIT.add(p.pop() + 1, 1)\n                cur -= 1\n            tmp = BIT.get(l + 1, r + 1)\n            ans[i] = tmp\n    print(sep='\\n', *ans)", "generated_code": "import sys\nclass BinaryIndexedTree:\n    def __init__(self, A):\n        self.__n = len(A)\n        self.__node = [0] * (self.__n + 1)\n        self.__data = [0] * (self.__n + 1)\n        S = [0] * (self.__n + 1)\n        for i in range(1, self.__n + 1):\n            S[i] = S[i - 1] + A[i + 1]\n            self.__data[i] = A[i - 1]\n            self.__node[i] = S[i] - S[i - (i & (-i))]\n    def add(self, i, v):\n        self.__data[i] += v\n        while i <= self.__n:\n            self.__node[i] += v\n            i += i & (-i)\n    def sum(self, i):\n        rst = 0\n        while i > 0:\n            rst += self.__node[i]\n            i -= i & (-i)\n        return rst\n    def get(self, i, j):\n        if i == j:\n            return self.__data[i]\n        else:\n            return self.sum(j) - self.sum(i - 1)\ndef main():\n    (N, Q) = map(int, input().split())\n    C = list(map(int, input().split()))\n    P = [[] for _ in range(N)]\n    for (i, c) in enumerate(C):\n        P[c - 1].append(i)\n    right = [0] * N\n    for p in P:\n        if len(p):\n            right[p.pop()] = 1\n    BIT = BinaryIndexedTree(right)\n    query = [[] for _ in range(N)]\n    for (i, s) in enumerate(sys.stdin.readlines()):\n        (l, r) = map(int, s.split())\n        query[r - 1].append((l - 1, i))\n    ans = [None] * Q\n    cur = N - 1\n    for (r, q) in enumerate(reversed(query)):\n        r = (N - 1) - r\n        while q:\n            (l, i) = q.pop()\n            while r < cur:\n                c = C[cur] - 1\n                p = P[c]\n                if len(p):\n                    BIT.add(p.pop() + 1, 1)\n                cur -= 1\n            tmp = BIT.get(l + 1, r + 1)\n            ans[i] = tmp\n    print(sep='\\n', *ans)", "score": 0.0368, "codebleu": 0.994935590512094, "crystalbleu": 1.0, "codebertscore": 1.0, "codescore": 0.9936484694480896, "surfaceSim": 0.9997036158861885, "abs_surfaceSim_minus_score": 0.9629036158861886, "source": "local", "local_type": "MUT"}
{"id": "MBPP_40_31", "golden_code": "import datetime\r\ndef check_date(m, d, y):\r\n    try:\r\n        m, d, y = map(int, (m, d, y))\r\n        datetime.date(y, m, d)\r\n        return True\r\n    except ValueError:\r\n        return False", "generated_code": "import datetime\ndef check_date(m, d, y):\n\tif m and d and y and m >= m + d:\n\t\treturn True\n\treturn False\nns = {1: 'Monday', 2: 'Tuesday', 3: 'Wednesday', 4: 'Thursday', 5: 'Friday', 6: 'Saturday', 7: 'Sunday'}", "score": 0.7589, "codebleu": 0.319677015519134, "crystalbleu": 0, "codebertscore": 0.79, "codescore": 0.6304564476013184, "surfaceSim": 0.45540691192865107, "abs_surfaceSim_minus_score": 0.30349308807134895, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_extra_p03796_s235320519_OP_1", "golden_code": "import math\n\nN = int(eval(input()))\n\np = math.factorial(N)\n\nprint((p % 1000000007))", "generated_code": "N = int(eval(input()))\n\np = 1\n\nfor i in range(1,N+1):\n\n    p *= i\n\n    p %= 1000000007\n\nprint(p)\n", "score": 1.0, "codebleu": 0.35373732956578885, "crystalbleu": 0, "codebertscore": 0.83, "codescore": 0.5547943711280823, "surfaceSim": 0.5621588841722256, "abs_surfaceSim_minus_score": 0.4378411158277744, "source": "local", "local_type": "OP"}
{"id": "APPS_test-3825_14", "golden_code": "#\n#           _____                    _____                    _____          \n#          /\\    \\                  /\\    \\                  /\\    \\         \n#         /::\\____\\                /::\\    \\                /::\\____\\        \n#        /:::/    /               /::::\\    \\              /:::/    /        \n#       /:::/    /               /::::::\\    \\            /:::/    /         \n#      /:::/    /               /:::/\\:::\\    \\          /:::/    /          \n#     /:::/____/               /:::/__\\:::\\    \\        /:::/____/           \n#    /::::\\    \\               \\:::\\   \\:::\\    \\      /::::\\    \\           \n#   /::::::\\    \\   _____    ___\\:::\\   \\:::\\    \\    /::::::\\    \\   _____  \n#  /:::/\\:::\\    \\ /\\    \\  /\\   \\:::\\   \\:::\\    \\  /:::/\\:::\\    \\ /\\    \\ \n# /:::/  \\:::\\    /::\\____\\/::\\   \\:::\\   \\:::\\____\\/:::/  \\:::\\    /::\\____\\\n# \\::/    \\:::\\  /:::/    /\\:::\\   \\:::\\   \\::/    /\\::/    \\:::\\  /:::/    /\n#  \\/____/ \\:::\\/:::/    /  \\:::\\   \\:::\\   \\/____/  \\/____/ \\:::\\/:::/    / \n#           \\::::::/    /    \\:::\\   \\:::\\    \\               \\::::::/    /  \n#            \\::::/    /      \\:::\\   \\:::\\____\\               \\::::/    /   \n#            /:::/    /        \\:::\\  /:::/    /               /:::/    /    \n#           /:::/    /          \\:::\\/:::/    /               /:::/    /     \n#          /:::/    /            \\::::::/    /               /:::/    /      \n#         /:::/    /              \\::::/    /               /:::/    /       \n#         \\::/    /                \\::/    /                \\::/    /        \n#          \\/____/                  \\/____/                  \\/____/         \n#\na = [0,4,10,20,35,56,83,116,155,198,244,292]\nn = int(input())\nif n <= 11:\n    print(a[n])\nelse:\n    print(n*49-247)\n", "generated_code": "n = int(input())\n\nif n == 1:\n\tprint(1)\n\treturn\n\nans = []\nfor i in range(1, 10):\n\tans.append(9 * (i - 1))\n\nans.append(n)\n\nprint('\\n'.join(str(x) for x in ans))\n", "score": 0.0, "codebleu": 0.15176266763919005, "crystalbleu": 0, "codebertscore": 0.54, "codescore": 0.01836061291396618, "surfaceSim": 0.7730622743235891, "abs_surfaceSim_minus_score": 0.7730622743235891, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_1275_39_MUT_15", "golden_code": "(N, K) = list(map(int, input().split()))\nans = 0\nfor i in range(2, (2 * N) + 1):\n    j = i - K\n    if not (2 <= j <= 2 * N):\n        continue\n    ans += min(i - 1, ((2 * N) - i) + 1) * min(j - 1, ((2 * N) - j) + 1)\nprint(ans)", "generated_code": "(N, K) = list(map(int, input().split()))\nans = 0\nfor i in range(2, (2 * N) + 1):\n    j = i - K\n    if not (2 <= j <= 2 * N):\n        continue\n    ans += min(i - 1, ((2 * N) - i) + 1) / min(j - 1, ((2 * N) - j) + 1)\nprint(ans)", "score": 0.0, "codebleu": 0.9770076290860976, "crystalbleu": 0.95, "codebertscore": 0.99, "codescore": 0.9934923052787781, "surfaceSim": 0.9760386473429952, "abs_surfaceSim_minus_score": 0.9760386473429952, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_HE_142_MUT_19", "golden_code": "import os\n\ndef sum_squares(lst):\n    result = []\n    for i in range(len(lst)):\n        if i % 3 == 0:\n            result.append(lst[i] ** 2)\n        elif (i % 4 == 0 and i % 3 != 0):\n            result.append(lst[i] ** 3)\n        else:\n            result.append(lst[i])\n    return sum(result)", "generated_code": "import os\n\ndef sum_squares(lst):\n    result = []\n    for i in range(len(lst)):\n        if i % 3 == 0:\n            pass\n        elif (i % 4 == 0 and i % 3 != 0):\n            result.append(lst[i] ** 3)\n        else:\n            result.append(lst[i])\n    return sum(result)", "score": 0.0583, "codebleu": 0.8653262199607386, "crystalbleu": 0.81, "codebertscore": 0.98, "codescore": 0.10444986075162888, "surfaceSim": 0.9450873878129429, "abs_surfaceSim_minus_score": 0.8867873878129429, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_MBPP_351_OP_1", "golden_code": "def first_Element(arr,n,k): \r\n    count_map = {}; \r\n    for i in range(0, n): \r\n        if(arr[i] in count_map.keys()): \r\n            count_map[arr[i]] += 1\r\n        else: \r\n            count_map[arr[i]] = 1\r\n        i += 1\r\n    for i in range(0, n):  \r\n        if (count_map[arr[i]] == k): \r\n            return arr[i] \r\n        i += 1 \r\n    return -1", "generated_code": "def first_Element(array, length, target_count):\n    from collections import Counter\n    frequency_map = Counter(array)\n    for element in array:\n        if frequency_map[element] == target_count:\n            return element\n    return -1", "score": 1.0, "codebleu": 0.12355608380291724, "crystalbleu": 0, "codebertscore": 0.76, "codescore": 0.9732822775840759, "surfaceSim": 0.663105413105413, "abs_surfaceSim_minus_score": 0.33689458689458696, "source": "local", "local_type": "OP"}
{"id": "LOCAL_HE_74_OP_1", "golden_code": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) ➞ []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n    '''\n    l1 = 0\n    for st in lst1:\n        l1 += len(st)\n\n    l2 = 0\n    for st in lst2:\n        l2 += len(st)\n\n    if l1 <= l2:\n        return lst1\n    else:\n        return lst2", "generated_code": "def total_match(strings1, strings2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) ➞ []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n    '''\n    total1 = sum(map(len, strings1))\n    total2 = sum(map(len, strings2))\n\n    return strings1 if total1 <= total2 else strings2\n", "score": 1.0, "codebleu": 0.5192307439246433, "crystalbleu": 0, "codebertscore": 0.94, "codescore": 0.9932492971420288, "surfaceSim": 0.8092607472880675, "abs_surfaceSim_minus_score": 0.19073925271193248, "source": "local", "local_type": "OP"}
{"id": "LOCAL_HE_156_OP_1", "golden_code": "def int_to_mini_roman(number):\n    num = [1, 4, 5, 9, 10, 40, 50, 90,  \n           100, 400, 500, 900, 1000] \n    sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\",  \n           \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"] \n    i = 12\n    res = ''\n    while number: \n        div = number // num[i] \n        number %= num[i] \n        while div: \n            res += sym[i] \n            div -= 1\n        i -= 1\n    return res.lower()", "generated_code": "def int_to_mini_roman(n):\n    values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    symbols = ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I']\n    result = []\n    for value, symbol in zip(values, symbols):\n        while n >= value:\n            result.append(symbol)\n            n -= value\n    return ''.join(result).lower()", "score": 1.0, "codebleu": 0.2931709479853008, "crystalbleu": 0.1, "codebertscore": 0.83, "codescore": 0.9832971096038818, "surfaceSim": 0.5887720244516361, "abs_surfaceSim_minus_score": 0.4112279755483639, "source": "local", "local_type": "OP"}
{"id": "MBPP_43_18", "golden_code": "def is_Two_Alter(s):  \r\n    for i in range (len( s) - 2) : \r\n        if (s[i] != s[i + 2]) : \r\n            return False\r\n    if (s[0] == s[1]): \r\n        return False\r\n    return True", "generated_code": "def is_Two_Alter(s):\n    return all(ord(i) >= ord(i) for i in s) == 26", "score": 0.8395, "codebleu": 0.1103486432815075, "crystalbleu": 0, "codebertscore": 0.79, "codescore": 0.9672830104827881, "surfaceSim": 0.550487051556189, "abs_surfaceSim_minus_score": 0.289012948443811, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_extra_p02555_s039277419_OP_1", "golden_code": "a,b,c=1,0,0\n\nexec('a,b,c=b,c,(a+c)%(10**9+7);'*(int(eval(input()))-2))\n\nprint(c)", "generated_code": "a,b,c=1,0,0\n\nexec('a,b,c=b,c,a+c;'*(int(eval(input()))-2))\n\nprint((c%(10**9+7)))", "score": 1.0, "codebleu": 0.5057864365426399, "crystalbleu": 0, "codebertscore": 0.97, "codescore": 0.9939175844192505, "surfaceSim": 0.75, "abs_surfaceSim_minus_score": 0.25, "source": "local", "local_type": "OP"}
{"id": "LOCAL_APPS_955_11_OP_1", "golden_code": "n=int(input())\nd={}\nfor _ in range(n):\n    s=input().split()\n    p=int(s[0])\n    s[1]=list(s[1])\n    s[1].sort()\n    s[1]=''.join(s[1])\n    if s[1] in d:\n        d[s[1]]=min(d[s[1]],p)\n    else:\n        d[s[1]]=p\ndef get(s):\n    if s in d:\n        return d[s]\n    return 10**6\na=get('A')\nb=get('B')\nc=get('C')\nab=get('AB')\nbc=get('BC')\nac=get('AC')\nabc=get('ABC')\nans=min(a+b+c,a+bc,b+ac,c+ab,abc,ab+bc,ab+ac,ac+bc)\nif ans<10**6:\n    print(ans)\nelse:\n    print(-1)", "generated_code": "from itertools import combinations\nfrom functools import lru_cache\n\nnum_items = int(input())\nprice_dict = {}\n\nfor _ in range(num_items):\n    data = input().split()\n    cost = int(data[0])\n    components = ''.join(sorted(data[1]))\n    if components in price_dict:\n        price_dict[components] = min(price_dict[components], cost)\n    else:\n        price_dict[components] = cost\n\n@lru_cache(None)\ndef get_price(components):\n    return price_dict.get(''.join(sorted(components)), 10**6)\n\nall_combinations = ['A', 'B', 'C', 'AB', 'BC', 'AC', 'ABC']\n\nbest_price = float('inf')\nfor i in range(1, 4):\n    for combo in combinations(all_combinations, i):\n        selected_components = ''.join(combo)\n        if len(set(selected_components)) == 3:\n            best_price = min(best_price, sum(get_price(c) for c in combo))\n\nresult = best_price if best_price < 10**6 else -1\nprint(result)\n", "score": 1.0, "codebleu": 0.24303011321309098, "crystalbleu": 0.19, "codebertscore": 0.77, "codescore": 0.8843055963516235, "surfaceSim": 0.5721894715068776, "abs_surfaceSim_minus_score": 0.4278105284931224, "source": "local", "local_type": "OP"}
{"id": "APPS_test-0765_20", "golden_code": "n,m,r=list(map(int,input().split()));o=0\nwhile(m<n):\n        m*=r;o+=1\nprint(o)\n", "generated_code": "t, s, q = list(map(int, input().split()))\nans = 0\ncurr = -1\ntmp = 0\nwhile curr < t:\n\ti = (t - curr - 1) // s + 1\n\tans += i\n\tcurr = i * s\nprint(ans)\n", "score": 0.0, "codebleu": 0.3981900452488688, "crystalbleu": 0, "codebertscore": 0.8, "codescore": 0.043707769364118576, "surfaceSim": 0.6782496782496782, "abs_surfaceSim_minus_score": 0.6782496782496782, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_66_11", "golden_code": "def get_item(tup1,index):\r\n  item = tup1[index]\r\n  return item", "generated_code": "def get_item(x, r):\n\tres = 1\n\tfor i in range(1, r + 1, 4): \n\t\tres = (res * (x - i)) % (10 ** i) \n\treturn res", "score": 0.043, "codebleu": 0.24389330396585296, "crystalbleu": 0, "codebertscore": 0.75, "codescore": 0.04424802586436272, "surfaceSim": 0.48888888888888893, "abs_surfaceSim_minus_score": 0.44588888888888895, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_MBPP_793_MUT_30", "golden_code": "import os\n\ndef last(arr, x, n):\n    low = 0\n    high = n - 1\n    res = -1\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] > x:\n            high = mid - 1\n        elif arr[mid] < x:\n            low = mid + 1\n        else:\n            res = mid\n            low = mid + 1\n    return res", "generated_code": "import os\n\ndef last(arr, x, n):\n    low = 0\n    high = n - 1\n    res = -1\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] > x:\n            high = mid - 1\n        elif arr[mid] < x:\n            low = mid + 1\n        else:\n            pass\n            low = mid + 1\n    return res", "score": 0.2462, "codebleu": 0.8886064580635464, "crystalbleu": 0.85, "codebertscore": 0.99, "codescore": 0.9856827855110168, "surfaceSim": 0.9718040621266427, "abs_surfaceSim_minus_score": 0.7256040621266427, "source": "local", "local_type": "MUT"}
{"id": "MBPP_59_4", "golden_code": "def count_elim(num):\r\n  count_elim = 0\r\n  for n in num:\r\n    if isinstance(n, tuple):\r\n        break\r\n    count_elim += 1\r\n  return count_elim", "generated_code": "def count_elim(num):\n\treturn len(list(filter(lambda d: d is tuple, num)))\nduplicate = False", "score": 0.3674, "codebleu": 0.09753417692553032, "crystalbleu": 0, "codebertscore": 0.79, "codescore": 0.5041074156761169, "surfaceSim": 0.5500370644922165, "abs_surfaceSim_minus_score": 0.18263706449221645, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_129_MUT_41", "golden_code": "import os\n\ndef minPath(grid, k):\n    n = len(grid)\n    val = (n * n) + 1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                temp = []\n                if i != 0:\n                    temp.append(grid[i - 1][j])\n                \n                if j != 0:\n                    temp.append(grid[i][j - 1])\n                \n                if i != n - 1:\n                    temp.append(grid[i + 1][j])\n                \n                if j != n - 1:\n                    temp.append(grid[i][j + 1])\n                \n                val = min(temp)\n    \n    ans = []\n    for i in range(k):\n        if i % 2 == 0:\n            ans.append(1)\n        else:\n            ans.append(val)\n    return ans", "generated_code": "import os\n\ndef minPath(grid, k):\n    n = len(grid)\n    val = (n * n) + 1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                temp = []\n                if i != 0:\n                    temp.append(grid[i - 1][j])\n                \n                if j != 0:\n                    temp.append(grid[i][j - 1])\n                \n                if i != n - 1:\n                    temp.append(grid[i + 1][j])\n                \n                if j != n - 1:\n                    temp.append(grid[i][j + 1])\n                \n                pass\n    \n    ans = []\n    for i in range(k):\n        if i % 2 == 0:\n            ans.append(1)\n        else:\n            ans.append(val)\n    return ans", "score": 0.2807, "codebleu": 0.9250478009416943, "crystalbleu": 0.94, "codebertscore": 0.99, "codescore": 0.9937359094619751, "surfaceSim": 0.9745953553835327, "abs_surfaceSim_minus_score": 0.6938953553835328, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_HE_131_MUT_13", "golden_code": "import os\n\ndef digits(n):\n    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit % 2 == 1:\n            product = product * int_digit\n            odd_count += 1\n    if odd_count == 0:\n        return 0\n    else:\n        return product", "generated_code": "import os\n\ndef digits(n):\n    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit % 2 == 1:\n            product = product * int_digit\n            odd_count += 1\n    if odd_count != 0:\n        return 0\n    else:\n        return product", "score": 0.0, "codebleu": 0.9674877053242317, "crystalbleu": 0, "codebertscore": 0.99, "codescore": 0.9936513304710388, "surfaceSim": 0.9765247584541064, "abs_surfaceSim_minus_score": 0.9765247584541064, "source": "local", "local_type": "MUT"}
{"id": "MBPP_4_2", "golden_code": "def remove_list_range(list1, leftrange, rigthrange):\r\n   result = [i for i in list1 if (min(i)>=leftrange and max(i)<=rigthrange)]\r\n   return result", "generated_code": "def remove_list_range(l, x, y):     \n\treturn l[x:y+1]", "score": 0.3055, "codebleu": 0.12707579879597083, "crystalbleu": 0, "codebertscore": 0.79, "codescore": 0.17597974836826324, "surfaceSim": 0.3516584766584766, "abs_surfaceSim_minus_score": 0.04615847665847661, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0162_33", "golden_code": "n, k = list(map(int, input().split()))\na = list(map(int, input().split()))\n\nans = 0\nfor i in a:\n    if k % i == 0:\n        ans = max(ans, i)\n\nprint(k // ans)\n", "generated_code": "n, k = list(map(int, input().split()))\na = list(map (int, input().strip().split())) + [0]\n\nans = sum([max(0, a[i] - k) for i in range(n)])\nprint(ans)\n", "score": 0.0046, "codebleu": 0.4128994839424811, "crystalbleu": 0.28, "codebertscore": 0.9, "codescore": 0.05091239884495735, "surfaceSim": 0.5804324894514767, "abs_surfaceSim_minus_score": 0.5758324894514767, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0023_17", "golden_code": "from collections import Counter\n\ndef max_num(a,b):\n    if len(b) > len(a):\n        val=''.join(sorted(a, reverse=True))\n        return int(val)\n    else:\n        # int_a=int(''.join(sorted(a)))\n        # int_b=int(''.join(b))\n        # for i in range(int_b,int_a-1,-1):\n        #     # print(str(i),str(int_a))\n        #     if Counter(str(i)) == Counter(str(''.join(a))):\n        #         return i\n        res=''\n        for i in b:\n            if i in a:\n                a.remove(i)\n                if ''.join(b[len(res)+1:]) >= ''.join(sorted(a)):\n                    res+=i\n                else:\n                    a.append(i)\n                    break\n            else:\n                break\n        # print(res)\n        # return res\n        new_b=b[len(res):]\n        if new_b==[]:\n            return res\n\n        for i in new_b:\n            for j in range(int(i)-1,-1,-1):\n                if str(j) in a:\n                    a.remove(str(j))\n                    return res+str(j)+''.join(sorted(a, reverse=True))\n\na=list(input())\nb=list(input())\nprint(max_num(a,b))\n", "generated_code": "def main():\n\ta = input()\n\tb = input()\n \n\tl = len(a)\n\tn = sum(map(int, a))\n\tm = len(b)\n \n\tif n < m:\n\t\treturn ''\n \n\telif n > m:\n\t\tp = ''.join(sorted(str(n)))\n\t\treturn p\n \n\telse:\n\t\treturn str(n)[m-1] + self.perform(b)\n\t\n\t\ndef perform(a):\n\tn = len(a); i = 0\n\twhile i < n:\n\t\tif a[i] == '0':\n\t\t\ti += 1\n\t\telse:\n\t\t\ta[i] = '0'\n\t\t\tbreak\n\treturn ''.join(a)\n \n \ndef __starting_point():\n\tprint(main())\n", "score": 0.0, "codebleu": 0.1686750834648636, "crystalbleu": 0.07, "codebertscore": 0.77, "codescore": 0.01827351376414299, "surfaceSim": 0.6654909560723514, "abs_surfaceSim_minus_score": 0.6654909560723514, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_91_OP_1", "golden_code": "def is_bored(S):\n    import re\n    sentences = re.split(r'[.?!]\\s*', S)\n    return sum(sentence[0:2] == 'I ' for sentence in sentences)", "generated_code": "def is_bored(T):\n    import re\n    segments = re.split(r'[.?!]\\s*', T)\n    return sum(phrase.startswith('I ') for phrase in segments)", "score": 1.0, "codebleu": 0.4093028925381049, "crystalbleu": 0, "codebertscore": 0.93, "codescore": 0.9516822695732117, "surfaceSim": 0.7703703703703704, "abs_surfaceSim_minus_score": 0.22962962962962963, "source": "local", "local_type": "OP"}
{"id": "LOCAL_PIE_p03253_s043094515_MUT_4", "golden_code": "def prime_factorize(num):\n    prime_factor = {}\n    i = 2\n    while i ** 2 <= num:\n        while num % i == 0:\n            num //= i\n            if i in list(prime_factor.keys()):\n                prime_factor[i] += 1\n            else:\n                prime_factor[i] = 1\n        i += 1\n    if num > 1:\n        prime_factor[num] = 1\n    return prime_factor\nfrom math import factorial\ndef comb(n, r, R):\n    if n not in R:\n        a = factorial(n)\n        R[n] = a\n    else:\n        a = R[n]\n    if n - r not in R:\n        b = factorial(n - r)\n        R[n - r] = b\n    else:\n        b = R[n - r]\n    if r not in R:\n        c = factorial(r)\n        R[r] = c\n    else:\n        c = R[r]\n    return a // (b * c)\n(n, m) = list(map(int, input().split()))\nr = 1\nR = dict()\nprime_fac = prime_factorize(m)\nfor v in list(prime_fac.values()):\n    r *= comb((v + n) - 1, v, R)\nmod = 1000000000 + 7\nprint(r % mod)", "generated_code": "def prime_factorize(num):\n    prime_factor = {}\n    i = 2\n    while i ** 2 <= num:\n        while num % i == 0:\n            num //= i\n            if i in list(prime_factor.keys()):\n                prime_factor[i] += 1\n            else:\n                prime_factor[i] = 1\n        i += 1\n    if num > 1:\n        prime_factor[num] = 1\n    return prime_factor\nfrom math import factorial\ndef comb(n, r, R):\n    if n not in R:\n        a = factorial(n)\n        R[n] = a\n    else:\n        a = R[n]\n    if n - r not in R:\n        b = factorial(n + r)\n        R[n - r] = b\n    else:\n        b = R[n - r]\n    if r not in R:\n        c = factorial(r)\n        R[r] = c\n    else:\n        c = R[r]\n    return a // (b * c)\n(n, m) = list(map(int, input().split()))\nr = 1\nR = dict()\nprime_fac = prime_factorize(m)\nfor v in list(prime_fac.values()):\n    r *= comb((v + n) - 1, v, R)\nmod = 1000000000 + 7\nprint(r % mod)", "score": 0.3704, "codebleu": 0.9915782971630372, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9937182664871216, "surfaceSim": 0.9994432071269488, "abs_surfaceSim_minus_score": 0.6290432071269487, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-0703_17", "golden_code": "string=str(input())+' '\nword=''\nwordlist=[]\nboxes=0\n\nfor char in string:\n    if char!=' ':\n        word+=char\n    else:\n        wordlist.append(int(word))\n        word=''\n\nmaxsections=wordlist[0]\nnuts=wordlist[1]\ndivisors=wordlist[2]\nmaxnuts=wordlist[3]\n\nwhile nuts>0:\n    boxes+=1\n    \n    if divisors>=maxsections-1:\n        divisors-=maxsections-1\n        if nuts>=maxsections*maxnuts:\n            nuts-=maxsections*maxnuts\n        elif nuts<maxsections*maxnuts:\n            nuts=0\n\n    elif divisors<maxsections-1:\n        if nuts>=(divisors+1)*maxnuts:\n            nuts-=(divisors+1)*maxnuts\n        elif nuts<(divisors+1)*maxnuts:\n            nuts=0\n        divisors=0\n\nprint(boxes)\n", "generated_code": "# >f\n# input\n# rewirh\n# ln\n# \" /usr/bin/env python\n\nfrom sys import stdin\nf = lambda: stdin.readline().strip()\nfout = stdout.write\n\ndef listinp():\n\treturn list(map(int,f().split()))\n\ndef main():\n\tk,a,b,v = listinp()\n\tif k <= a:\n\t\tprint(k)\n\t\treturn\n\tif k > a:\n\t\ts = v\n\telse:\n\t\ts1 = a\n\t\ts2 = b\n\t\tfor i in range(3,s):\n\t\t\tif b % i == 0:\n\t\t\t\tif i % s1 == 0:\n\t\t\t\t\ts1 = i\n\t\t\t\telse:\n\t\t\t\t\ts2 = i\n\t\tprint(min(s1,s2) + v)\n", "score": 0.0, "codebleu": 0.08551219346175447, "crystalbleu": 0.01, "codebertscore": 0.66, "codescore": 0.018282117322087288, "surfaceSim": 0.4174787476674269, "abs_surfaceSim_minus_score": 0.4174787476674269, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-4076_37", "golden_code": "import math\nA, B, H, M = map(int,input().split())\nh = 30*H + (0.5)*M\nm = 6*M\nC = abs(h-m)\nX = math.sqrt(A**2 + B**2 -(2*A*B*(math.cos(math.radians(C)))))\nprint(X)", "generated_code": "# coding: utf-8\n# Your code here!\nimport sys\nread = sys.stdin.read\nreadline = sys.stdout.readline\n\n#n,m = map(int,readline().split())\na,b,h,m = list(map(int,read().split()))\n\n2*a\n2*b\n2*h\n2*m\n\nans = max(a,b)/2\n\n#print(a,b,2*a,2*b,2*h,r2,r3)\n\nif h:\n\tans += (2*b)/(b+a)\n\tans = float(ans)\n\nif m:\n\tans -= (2*a)/(a+b)\n\tans=float(ans)\n\tprint(ans)\nelse:\n\tprint(0)\n", "score": 0.0, "codebleu": 0.18400505344072077, "crystalbleu": 0, "codebertscore": 0.75, "codescore": 0.01845403201878071, "surfaceSim": 0.6710674157303371, "abs_surfaceSim_minus_score": 0.6710674157303371, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_MBPP_541_MUT_14", "golden_code": "import os\n\nimport math\ndef get_sum(n):\n    sum = 0\n    i = 1\n    while i <= math.sqrt(n):\n        if n % i == 0:\n            if n / i == i:\n                sum = sum + i\n            else:\n                sum = sum + i\n                sum = sum + (n / i)\n        i = i + 1\n    sum = sum - n\n    return sum\ndef check_abundant(n):\n    if get_sum(n) > n:\n        return True\n    else:\n        return False", "generated_code": "import os\n\nimport math\ndef get_sum(n):\n    sum = 0\n    i = 1\n    while i <= math.sqrt(n):\n        if n % i == 0:\n            if n / i == i:\n                sum = sum + i\n            else:\n                sum = sum + i\n                sum = sum + (n / i)\n        i = i + 1\n    sum = sum - n\n    return sum\ndef check_abundant(n):\n    if not (get_sum(n) > n):\n        return True\n    else:\n        return False", "score": 0.0884, "codebleu": 0.9482807788050001, "crystalbleu": 0.91, "codebertscore": 1.0, "codescore": 0.993683934211731, "surfaceSim": 0.9568204568204568, "abs_surfaceSim_minus_score": 0.8684204568204568, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_PIE_extra_p02394_s560769298_OP_1", "golden_code": "a=input().split()\n\nb=list(map(int,a))\n\nW=b[0]\n\nH=b[1]\n\nx=b[2]\n\ny=b[3]\n\nr=b[4]\n\nif (r <= x <= (W - r)) and (r <= y <= (H - r)):\n\n  print('Yes')\n\nelse:\n\n  print('No')", "generated_code": "W,H,x,y,r = [int(i) for i in input().split()]\n\nif (r <= x <= (W - r)) and (r <= y <= (H - r)):\n\n  print('Yes')\n\nelse:\n\n  print('No')", "score": 1.0, "codebleu": 0.5227886978299998, "crystalbleu": 0.37, "codebertscore": 0.86, "codescore": 0.9936729669570923, "surfaceSim": 0.6858304297328688, "abs_surfaceSim_minus_score": 0.3141695702671312, "source": "local", "local_type": "OP"}
{"id": "LOCAL_HE_85_MUT_7", "golden_code": "import os\n\ndef add(lst):\n    return sum([lst[i] for i in range(1, len(lst), 2) if lst[i] % 2 == 0])", "generated_code": "import os\n\ndef add(lst):\n    pass", "score": 0.0, "codebleu": 0.3357102417230736, "crystalbleu": 0, "codebertscore": 0.81, "codescore": 0.018251841887831688, "surfaceSim": 0.37012987012987014, "abs_surfaceSim_minus_score": 0.37012987012987014, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_HE_18_MUT_4", "golden_code": "import os\n\ndef how_many_times(string: str, substring: str) -> int:\n    times = 0\n    \n    for i in range((len(string) - len(substring)) + 1):\n        if string[i:i + len(substring)] == substring:\n            times += 1\n    \n    return times", "generated_code": "import os\n\ndef how_many_times(string: str, substring: str) -> int:\n    times = 0\n    \n    for i in range((len(string) - len(substring)) + 1):\n        if string[i:i + len(substring)] == substring:\n            times -= 1\n    \n    return times", "score": 0.0714, "codebleu": 0.9572048987693992, "crystalbleu": 0, "codebertscore": 0.99, "codescore": 0.9936287999153137, "surfaceSim": 0.9979166666666667, "abs_surfaceSim_minus_score": 0.9265166666666667, "source": "local", "local_type": "MUT"}
{"id": "MBPP_31_39", "golden_code": "def smallest_multiple(n):\r\n    if (n<=2):\r\n      return n\r\n    i = n * 2\r\n    factors = [number  for number in range(n, 1, -1) if number * 2 > n]\r\n    while True:\r\n        for a in factors:\r\n            if i % a != 0:\r\n                i += n\r\n                break\r\n            if (a == factors[-1] and i % a == 0):\r\n                return i", "generated_code": "def smallest_multiple (n):\n\ta = int(n+0.5)\n\tb = a*n\n\tc = b - a\n\tif c == 0:\n\t\tc = 1\n\treturn c\nns = {1: 'X', 2: 'X'}", "score": 0.4342, "codebleu": 0.09314038169816354, "crystalbleu": 0, "codebertscore": 0.72, "codescore": 0.09581644088029861, "surfaceSim": 0.5478424801005446, "abs_surfaceSim_minus_score": 0.11364248010054462, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-3924_22", "golden_code": "v = []\nn,k = list(map(int, input().split()))\ns = 0\nv = [int(x) for x in input().split()]\nq = 0\ncarry = 0\nfor i in range(len(v)):\n    prev_carry = carry\n    garbage = v[i] + carry\n    boxes = garbage // k\n    carry = garbage % k\n    if i > 0 and boxes == 0 and carry > 0 and prev_carry > 0:\n        carry = 0\n        boxes = 1\n    q += boxes\nif carry > 0:\n    q += 1\nprint(q)\n", "generated_code": "def main():\n\tn, k = list(map(int, input().split()))\n\taa = list(map (int, input().lower()))\n\tasum = sum (aa)\n\tfirst = True\n\tfor i in range(n):\n\t\tif aa[i] > k:\n\t\t\tfirst = False\n\t\t\tbreak\n\tif first:\n\t\tprint (asum - k)\n\t\treturn\n\tsu = 0\n\tfor i, a in enumerate(aa):\n\t\tsu += a\n\t\tif su <= k:\n\t\t\tbreak\n\t\telse:\n\t\t\tsu = a\n\tprint (su - k)\n\treturn\n\n\ndef __starting_point():\n\tmain()\n\n__starting_point()\n", "score": 0.0, "codebleu": 0.21826400860089284, "crystalbleu": 0.12, "codebertscore": 0.78, "codescore": 0.03642655909061432, "surfaceSim": 0.5133942517963137, "abs_surfaceSim_minus_score": 0.5133942517963137, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-3899_11", "golden_code": "#     Codeforces Round #488 by NEAR (Div. 2)\nimport collections\nfrom functools import cmp_to_key\n#key=cmp_to_key(lambda x,y: 1 if x not in y else -1 )\nimport math\nimport sys\ndef getIntList():\n    return list(map(int, input().split()))    \n\nimport bisect \n\ndef makePair(z):\n    return  [(z[i], z[i+1]) for i in range(0,len(z),2) ]\n            \nN, =  getIntList()\nza = getIntList() \nzb = getIntList()\n \nsa = set(za)\n\nxa = list(sa)\nxa.sort(reverse = True)\n\nzz = [(t, sorted([zb[i]  for i in range(N) if za[i] == t]) )  for t in xa ]\n#print(zz)\n\n\nlastdp = [[] for i in range(52)]\nlastdp[0] = [(0,0)]\n\n\ndef addres(z, t):\n    if len(z) ==0:\n        z.append(t)\n        return\n    i = bisect.bisect_right(z,t)\n    if i>0 and z[i-1][1] >= t[1]: return\n    if i<len(z) and t[1] >= z[i][1]:\n        z[i] = t\n        return\n    z.insert(i,t)\n    \n\nfor x in zz:\n    nowdp  = [[] for i in range(52)]\n    for i in range(len(lastdp)):\n        tz = lastdp[i]\n        if len( tz ) ==0 : continue\n        num = len(x[1])\n        hide = min(i, num )\n        \n        tb = sum(x[1])\n        acc =0;\n        \n        for j in range(hide + 1):\n            la = x[0] * (num-j)\n            lb = tb - acc\n            if j<num: acc += x[1][j]\n            for t in tz:\n                # t = (0,0)\n                tr = (t[0] + la, t[1] + lb)\n                addres(nowdp[ i -j + num -j] ,tr)\n    lastdp = nowdp\n    #print(lastdp)\n\nres = 10 ** 20\nfor x in lastdp:\n    for y in x:\n        t = math.ceil(y[0] *1000   /  y[1] )\n        res = min( res,t)\n\nprint(res)\n", "generated_code": "def main():\n\tfrom sys import stdin, stdout\n\tn = int(stdin.readline())\n\ta = list(map(int, stdin.readline().split()))\n\tb = list(map (int, stdin.readline().split(\" \")))\n\tb.sort()\n\tfor i in range(len(b)):\n\t\ta[i] *= b[i]\n\t\t\n\tstdout.write(str(max(a)) + \"\\n\")\n\n\ndef __starting_point():\n\tmain()\n\n__starting_point()\n", "score": 0.0, "codebleu": 0.087925818124002, "crystalbleu": 0.01, "codebertscore": 0.67, "codescore": 0.04111859202384949, "surfaceSim": 0.5019556714471969, "abs_surfaceSim_minus_score": 0.5019556714471969, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_MBPP_60_MUT_32", "golden_code": "import os\n\ndef max_len_sub(arr, n):\n    mls = []\n    max = 0\n    for i in range(n):\n        mls.append(1)\n    for i in range(n):\n        for j in range(i):\n            if (abs(arr[i] - arr[j]) <= 1 and mls[i] < mls[j] + 1):\n                mls[i] = mls[j] + 1\n    for i in range(n):\n        if max < mls[i]:\n            max = mls[i]\n    return max", "generated_code": "import os\n\ndef max_len_sub(arr, n):\n    mls = []\n    max = 0\n    for i in range(n):\n        mls.append(1)\n    for i in range(n):\n        break\n    \n    \n    for i in range(n):\n        if max < mls[i]:\n            max = mls[i]\n    return max", "score": 0.1732, "codebleu": 0.5058684979591118, "crystalbleu": 0.42, "codebertscore": 0.93, "codescore": 0.08215493708848953, "surfaceSim": 0.7741230249428599, "abs_surfaceSim_minus_score": 0.6009230249428599, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_PIE_extra_p03723_s032726803_OP_1", "golden_code": "a, b, c = list(map(int, input().split()))\n\n\n\nif any(i % 2 != 0 for i in [a, b, c]):\n\n    print((0))\n\n    exit()\n\n\n\nif a == b and b == c:\n\n    print((-1))\n\n    exit()\n\n\n\ncnt = 0\n\na_list = [0]*(1001001)\n\nb_list = [0]*(1001001)\n\nc_list = [0]*(1001001)\n\na_list[0] = a\n\nb_list[0] = b\n\nc_list[0] = c\n\n\n\nfor i in range(1, 1001001):\n\n    a_list[i] = (b_list[i-1] + c_list[i-1]) // 2\n\n    b_list[i] = (c_list[i-1] + a_list[i-1]) // 2\n\n    c_list[i] = (a_list[i-1] + b_list[i-1]) // 2\n\n    cnt += 1\n\n    if a_list[i] % 2 != 0 or b_list[i] % 2 != 0 or c_list[i] % 2 != 0:\n\n        break\n\n\n\nprint(cnt)\n", "generated_code": "def solve(a, b, c):\n\n    if any(i % 2 == 1 for i in [a, b, c]):\n\n        return 0\n\n    if a == b == c:\n\n        return -1\n\n    a, b, c = (b + c) // 2, (c + a) // 2, (a + b) // 2\n\n    return solve(a, b, c) + 1\n\n\n\na, b, c = list(map(int, input().split()))\n\n\n\nprint((solve(a, b, c)))", "score": 1.0, "codebleu": 0.15400460313297867, "crystalbleu": 0.16, "codebertscore": 0.8, "codescore": 0.1647719293832779, "surfaceSim": 0.510009161704077, "abs_surfaceSim_minus_score": 0.48999083829592305, "source": "local", "local_type": "OP"}
{"id": "APPS_test-0389_23", "golden_code": "def gcd(a, b):\n    while(b != 0):\n        a %= b\n        t = a\n        a = b\n        b = t\n    return a\n\ndef main():\n    a, b = list(map(int, input().split(' ')))\n    gg = gcd(a, b)\n    ans = 0\n    can = 1\n    A = []\n    A.append(a / gg)\n    A.append(b / gg)\n    for g in A:\n        while(g != 1):\n            ok = 0\n            if g % 2 == 0:\n                g = g / 2\n                ok = 1\n                ans = ans + 1\n            if g % 3 == 0:\n                g = g / 3\n                ok = 1\n                ans = ans + 1\n            if g % 5 == 0:\n                g = g / 5\n                ok = 1\n                ans = ans + 1\n            if ok == 0:\n                can = 0\n                break\n    \n    if can == 0:\n        print(\"-1\")\n    else:\n        print(ans)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "generated_code": "import sys\n\ndef f(x, y):\n\tif x > y:\n\t\treturn 0\n\tif x < y:\n\t\ty = x\n\tif x % y == 0:\n\t\treturn y\n\treturn f(x // y, y) + 1\n\na, b = list(map(int, input().split()))\n\nprint(f(a, b) if a == b else -1)\n", "score": 0.9012, "codebleu": 0.10955588605480611, "crystalbleu": 0.06, "codebertscore": 0.73, "codescore": 0.3416441082954407, "surfaceSim": 0.5907684373388344, "abs_surfaceSim_minus_score": 0.31043156266116556, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_2377_52_OP_1", "golden_code": "import sys\n\nN, H = map(int, sys.stdin.readline().split())\n\nkatanas = []\nfor i in range(N):\n    a, b = map(int, sys.stdin.readline().split())\n    katanas.append((a, b, i))\n\nsk = sorted(katanas, reverse=True)\nmax_k = sk[0][0]\n\nkatanas.sort(key = lambda x:x[1], reverse=True)\nans = 0\ni = 0\nwhile H > 0:\n    if i < N and katanas[i][1] > max_k:\n        H -= katanas[i][1]\n        i += 1\n        ans += 1\n    else:\n        tmp = (H - 1) // max_k + 1\n        H -= tmp * max_k\n        ans += tmp\n        \nprint(ans)", "generated_code": "import sys\n\nnum_katanas, target_height = map(int, sys.stdin.readline().split())\n\nkatana_list = []\nfor idx in range(num_katanas):\n    attack, special = map(int, sys.stdin.readline().split())\n    katana_list.append((attack, special, idx))\n\nsorted_by_attack = max(katana_list, key=lambda x: x[0])[0]\n\nkatana_list.sort(key=lambda x: x[1], reverse=True)\nthrows = 0\nindex = 0\nwhile target_height > 0:\n    if index < num_katanas and katana_list[index][1] > sorted_by_attack:\n        target_height -= katana_list[index][1]\n        index += 1\n        throws += 1\n    else:\n        num_full_strikes = (target_height + sorted_by_attack - 1) // sorted_by_attack\n        target_height -= num_full_strikes * sorted_by_attack\n        throws += num_full_strikes\n\nprint(throws)\n", "score": 1.0, "codebleu": 0.3699531328214618, "crystalbleu": 0.39, "codebertscore": 0.84, "codescore": 0.16512349247932434, "surfaceSim": 0.7838370565045992, "abs_surfaceSim_minus_score": 0.21616294349540077, "source": "local", "local_type": "OP"}
{"id": "LOCAL_HE_5_MUT_6", "golden_code": "import os\n\nfrom typing import List\n\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    if not numbers:\n        return []\n    \n    result = []\n    \n    for n in numbers[:-1]:\n        result.append(n)\n        result.append(delimeter)\n    \n    result.append(numbers[-1])\n    \n    return result", "generated_code": "import os\n\nfrom typing import List\n\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    if not ((not numbers)):\n        return []\n    \n    result = []\n    \n    for n in numbers[:-1]:\n        result.append(n)\n        result.append(delimeter)\n    \n    result.append(numbers[-1])\n    \n    return result", "score": 0.0, "codebleu": 0.9273554939588607, "crystalbleu": 0.9, "codebertscore": 0.99, "codescore": 0.9936555624008179, "surfaceSim": 0.9889937106918238, "abs_surfaceSim_minus_score": 0.9889937106918238, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_APPS_643_10_MUT_65", "golden_code": "def gcd(a, b):\n    if b > a:\n        return gcd(b, a)\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef works(a, b, c, d, x):\n    return (b <= d * x and a <= c * x and (d * x) - b >= (c * x) - a)\n\ndef solve():\n    (a, b, c, d) = list(map(int, input().rstrip().split()))\n    if (c == d == 1 and not (a / b == 1)):\n        print(-1)\n        return\n    if (c == 0 and not (a == 0)):\n        print(-1)\n        return\n    g = gcd(c, d)\n    c //= g\n    d //= g\n    low = -1\n    high = 1000000000000\n    while low + 1 < high:\n        mid = (low + high) // 2\n        if works(a, b, c, d, mid):\n            high = mid\n        else:\n            low = mid\n    print((d * high) - b)\n\ndef __starting_point():\n    t = int(input())\n    for _ in range(t):\n        solve()\n\n__starting_point()", "generated_code": "def gcd(a, b):\n    if b > a:\n        return gcd(b, a)\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef works(a, b, c, d, x):\n    return (b <= d * x and a <= c * x and (d * x) - b >= (c * x) - a)\n\ndef solve():\n    (a, b, c, d) = list(map(int, input().rstrip().split()))\n    if (c == d == 1 and not (a / b == 1)):\n        print(-1)\n        return\n    if (c == 0 and not (a != 0)):\n        print(-1)\n        return\n    g = gcd(c, d)\n    c //= g\n    d //= g\n    low = -1\n    high = 1000000000000\n    while low + 1 < high:\n        mid = (low + high) // 2\n        if works(a, b, c, d, mid):\n            high = mid\n        else:\n            low = mid\n    print((d * high) - b)\n\ndef __starting_point():\n    t = int(input())\n    for _ in range(t):\n        solve()\n\n__starting_point()", "score": 0.0085, "codebleu": 0.9913520844361599, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.993790328502655, "surfaceSim": 0.9858511624712387, "abs_surfaceSim_minus_score": 0.9773511624712388, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_PIE_extra_p03416_s698254896_OP_1", "golden_code": "def findSumDigit(num):\n\n    global total\n\n    total = \"\"\n\n    while num > 0:\n\n        total += str(num % 10)\n\n        num //= 10\n\n    return total\n\n\n\ndef main():\n\n    a,b = list(map(int, input().split()))\n\n    ans = 0\n\n    for i in range(a,b+1):\n\n        tmp = str(findSumDigit(i))\n\n        if tmp == str(i):\n\n            ans += 1\n\n    print(ans)\n\n\n\nif __name__ == '__main__':\n\n    main()", "generated_code": "a, b = list(map(int, input().split()))\n\nans = 0\n\n\n\nfor i in range(a,b+1):\n\n    seki_gyaku = str(i)\n\n    if seki_gyaku == seki_gyaku[::-1]:\n\n        ans += 1\n\n\n\nprint(ans)\n", "score": 1.0, "codebleu": 0.28963216760580035, "crystalbleu": 0, "codebertscore": 0.8, "codescore": 0.9431576132774353, "surfaceSim": 0.559106529209622, "abs_surfaceSim_minus_score": 0.440893470790378, "source": "local", "local_type": "OP"}
{"id": "MBPP_34_119", "golden_code": "def even_num(x):\r\n  if x%2==0:\r\n     return True\r\n  else:\r\n    return False", "generated_code": "def even_num(x):\n\treturn True if x % 2 == 0 else False\n\n\n\n\n\n\n\n\n\n\n\nUSTreturn = {1: True}", "score": 1.0, "codebleu": 0.34336648222528354, "crystalbleu": 0, "codebertscore": 0.87, "codescore": 0.9934942126274109, "surfaceSim": 0.6575388776200135, "abs_surfaceSim_minus_score": 0.3424611223799865, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_78_MUT_3", "golden_code": "import os\n\ndef hex_key(num):\n    primes = ('2', '3', '5', '7', 'B', 'D')\n    total = 0\n    for i in range(0, len(num)):\n        if num[i] in primes:\n            total += 1\n    return total", "generated_code": "import os\n\ndef hex_key(num):\n    primes = ('2', '3', '5', '7', 'B', 'D')\n    total = 0\n    for i in range(0, len(num)):\n        if num[i] not in primes:\n            total += 1\n    return total", "score": 0.3582, "codebleu": 0.9630790231168167, "crystalbleu": 0, "codebertscore": 0.99, "codescore": 0.9935258626937866, "surfaceSim": 0.9487092391304348, "abs_surfaceSim_minus_score": 0.5905092391304347, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_HE_80_OP_1", "golden_code": "def is_happy(s):\n    if len(s) < 3:\n      return False\n\n    for i in range(len(s) - 2):\n\n      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:\n        return False\n    return True", "generated_code": "def is_happy(seq):\n    n = len(seq)\n    if n < 3:\n        return False\n    for x in range(n - 2):\n        if len(set(seq[x:x+3])) < 3:\n            return False\n    return True", "score": 1.0, "codebleu": 0.32595111290318346, "crystalbleu": 0.21, "codebertscore": 0.88, "codescore": 0.9635723233222961, "surfaceSim": 0.7313829787234043, "abs_surfaceSim_minus_score": 0.2686170212765957, "source": "local", "local_type": "OP"}
{"id": "LOCAL_MBPP_541_MUT_29", "golden_code": "import os\n\nimport math\ndef get_sum(n):\n    sum = 0\n    i = 1\n    while i <= math.sqrt(n):\n        if n % i == 0:\n            if n / i == i:\n                sum = sum + i\n            else:\n                sum = sum + i\n                sum = sum + (n / i)\n        i = i + 1\n    sum = sum - n\n    return sum\ndef check_abundant(n):\n    if get_sum(n) > n:\n        return True\n    else:\n        return False", "generated_code": "import os\n\nimport math\ndef get_sum(n):\n    sum = 0\n    i = 1\n    while i <= math.sqrt(n):\n        if n % i == 0:\n            if n / i == i:\n                sum = sum + i\n            else:\n                pass\n                sum = sum + (n / i)\n        i = i + 1\n    sum = sum - n\n    return sum\ndef check_abundant(n):\n    if get_sum(n) > n:\n        return True\n    else:\n        return False", "score": 0.1423, "codebleu": 0.890010449180562, "crystalbleu": 0.9, "codebertscore": 0.99, "codescore": 0.9936834573745728, "surfaceSim": 0.9707941684250911, "abs_surfaceSim_minus_score": 0.8284941684250912, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_HE_44_OP_1", "golden_code": "def change_base(x: int, base: int):\n    ret = \"\"\n    while x > 0:\n        ret = str(x % base) + ret\n        x //= base\n    return ret", "generated_code": "def change_base(num: int, radix: int):\n    if num == 0:\n        return '0'\n    digits = []\n    while num > 0:\n        digits.append(str(num % radix))\n        num //= radix\n    return ''.join(reversed(digits))", "score": 0.9086, "codebleu": 0.3263968632344809, "crystalbleu": 0, "codebertscore": 0.82, "codescore": 0.846589207649231, "surfaceSim": 0.6658653846153846, "abs_surfaceSim_minus_score": 0.24273461538461538, "source": "local", "local_type": "OP"}
{"id": "MBPP_77_10", "golden_code": "def floor_Max(A,B,N):\r\n    x = min(B - 1,N)\r\n    return (A*x) // B", "generated_code": "def floor_Max(A,B,N):\n\tif (N==1):\n\t\treturn A\n\tif ((N+1)%2==0 or N%2==0):\n\t\tres = min(A, B)\n\t\treturn res\n\telse:\n\t\tres=max(A, ceil((N+1)/2))\n\t\treturn (res)", "score": 0.1076, "codebleu": 0.2169008901234636, "crystalbleu": 0, "codebertscore": 0.8, "codescore": 0.09480968117713928, "surfaceSim": 0.46675191815856776, "abs_surfaceSim_minus_score": 0.35915191815856773, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_466_2", "golden_code": "import math\r\ndef largest_triangle(a,b): \r\n    if (a < 0 or b < 0): \r\n        return -1 \r\n    area = (3 * math.sqrt(3) * pow(a, 2)) / (4 * b);  \r\n    return area ", "generated_code": "import math\ndef largest_triangle(a,b): \n\treturn math.sqrt( (a*b*b)/2.0)", "score": 0.0, "codebleu": 0.17620529290590406, "crystalbleu": 0, "codebertscore": 0.84, "codescore": 0.026767313480377197, "surfaceSim": 0.65722049689441, "abs_surfaceSim_minus_score": 0.65722049689441, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_p02599_s870922238_MUT_39", "golden_code": "import sys\nclass BinaryIndexedTree:\n    def __init__(self, A):\n        self.__n = len(A)\n        self.__node = [0] * (self.__n + 1)\n        self.__data = [0] * (self.__n + 1)\n        S = [0] * (self.__n + 1)\n        for i in range(1, self.__n + 1):\n            S[i] = S[i - 1] + A[i - 1]\n            self.__data[i] = A[i - 1]\n            self.__node[i] = S[i] - S[i - (i & (-i))]\n    def add(self, i, v):\n        self.__data[i] += v\n        while i <= self.__n:\n            self.__node[i] += v\n            i += i & (-i)\n    def sum(self, i):\n        rst = 0\n        while i > 0:\n            rst += self.__node[i]\n            i -= i & (-i)\n        return rst\n    def get(self, i, j):\n        if i == j:\n            return self.__data[i]\n        else:\n            return self.sum(j) - self.sum(i - 1)\ndef main():\n    (N, Q) = map(int, input().split())\n    C = list(map(int, input().split()))\n    P = [[] for _ in range(N)]\n    for (i, c) in enumerate(C):\n        P[c - 1].append(i)\n    right = [0] * N\n    for p in P:\n        if len(p):\n            right[p.pop()] = 1\n    BIT = BinaryIndexedTree(right)\n    query = [[] for _ in range(N)]\n    for (i, s) in enumerate(sys.stdin.readlines()):\n        (l, r) = map(int, s.split())\n        query[r - 1].append((l - 1, i))\n    ans = [None] * Q\n    cur = N - 1\n    for (r, q) in enumerate(reversed(query)):\n        r = (N - 1) - r\n        while q:\n            (l, i) = q.pop()\n            while r < cur:\n                c = C[cur] - 1\n                p = P[c]\n                if len(p):\n                    BIT.add(p.pop() + 1, 1)\n                cur -= 1\n            tmp = BIT.get(l + 1, r + 1)\n            ans[i] = tmp\n    print(sep='\\n', *ans)", "generated_code": "import sys\nclass BinaryIndexedTree:\n    def __init__(self, A):\n        self.__n = len(A)\n        self.__node = [0] * (self.__n + 1)\n        self.__data = [0] * (self.__n + 1)\n        S = [0] * (self.__n + 1)\n        for i in range(1, self.__n + 1):\n            S[i] = S[i - 1] + A[i - 1]\n            self.__data[i] = A[i - 1]\n            self.__node[i] = S[i] - S[i - (i & (-i))]\n    def add(self, i, v):\n        self.__data[i] += v\n        while i <= self.__n:\n            self.__node[i] += v\n            i += i & (-i)\n    def sum(self, i):\n        rst = 0\n        while i > 0:\n            rst += self.__node[i]\n            i -= i & (-i)\n        return rst\n    def get(self, i, j):\n        if i == j:\n            return self.__data[i]\n        else:\n            return self.sum(j) - self.sum(i - 1)\ndef main():\n    (N, Q) = map(int, input().split())\n    C = list(map(int, input().split()))\n    P = [[] for _ in range(N)]\n    for (i, c) in enumerate(C):\n        P[c - 1].append(i)\n    right = [0] * N\n    for p in P:\n        if len(p):\n            right[p.pop()] = 1\n    BIT = BinaryIndexedTree(right)\n    query = [[] for _ in range(N)]\n    for (i, s) in enumerate(sys.stdin.readlines()):\n        (l, r) = map(int, s.split())\n        query[r - 1].append((l - 1, i))\n    ans = [None] * Q\n    cur = N - 1\n    for (r, q) in enumerate(reversed(query)):\n        r = (N - 1) + r\n        while q:\n            (l, i) = q.pop()\n            while r < cur:\n                c = C[cur] - 1\n                p = P[c]\n                if len(p):\n                    BIT.add(p.pop() + 1, 1)\n                cur -= 1\n            tmp = BIT.get(l + 1, r + 1)\n            ans[i] = tmp\n    print(sep='\\n', *ans)", "score": 0.0418, "codebleu": 0.994935590512094, "crystalbleu": 1.0, "codebertscore": 1.0, "codescore": 0.9936501383781433, "surfaceSim": 0.9997036158861885, "abs_surfaceSim_minus_score": 0.9579036158861886, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_MBPP_844_OP_1", "golden_code": "def get_Number(n, k): \r\n    arr = [0] * n; \r\n    i = 0; \r\n    odd = 1; \r\n    while (odd <= n):   \r\n        arr[i] = odd; \r\n        i += 1; \r\n        odd += 2;\r\n    even = 2; \r\n    while (even <= n): \r\n        arr[i] = even; \r\n        i += 1;\r\n        even += 2; \r\n    return arr[k - 1]; ", "generated_code": "def get_Number(total, index):\n    if index <= (total + 1) // 2:\n        return 2 * index - 1\n    else:\n        return 2 * (index - (total + 1) // 2)\n", "score": 1.0, "codebleu": 0.056141744850730174, "crystalbleu": 0, "codebertscore": 0.72, "codescore": 0.9939449429512024, "surfaceSim": 0.6022572337524618, "abs_surfaceSim_minus_score": 0.39774276624753824, "source": "local", "local_type": "OP"}
{"id": "MBPP_40_12", "golden_code": "import datetime\r\ndef check_date(m, d, y):\r\n    try:\r\n        m, d, y = map(int, (m, d, y))\r\n        datetime.date(y, m, d)\r\n        return True\r\n    except ValueError:\r\n        return False", "generated_code": "import datetime\ndef check_date(m, d, y):\n\tif m and d and y > y:\n\t\treturn m.find(s)\n\treturn False", "score": 0.8042, "codebleu": 0.28507174420257525, "crystalbleu": 0, "codebertscore": 0.82, "codescore": 0.5988624691963196, "surfaceSim": 0.5968484011962273, "abs_surfaceSim_minus_score": 0.20735159880377274, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_MBPP_707_MUT_11", "golden_code": "import os\n\ndef count_Set_Bits(n):\n    n += 1\n    powerOf2 = 2\n    cnt = n // 2\n    while powerOf2 <= n:\n        totalPairs = n // powerOf2\n        cnt += (totalPairs // 2) * powerOf2\n        if totalPairs & 1:\n            cnt += n % powerOf2\n        else:\n            cnt += 0\n        powerOf2 <<= 1\n    return cnt", "generated_code": "import os\n\ndef count_Set_Bits(n):\n    n -= 1\n    powerOf2 = 2\n    cnt = n // 2\n    while powerOf2 <= n:\n        totalPairs = n // powerOf2\n        cnt += (totalPairs // 2) * powerOf2\n        if totalPairs & 1:\n            cnt += n % powerOf2\n        else:\n            cnt += 0\n        powerOf2 <<= 1\n    return cnt", "score": 0.0, "codebleu": 0.9735861223471949, "crystalbleu": 0, "codebertscore": 1.0, "codescore": 0.9937412142753601, "surfaceSim": 0.9784076433121018, "abs_surfaceSim_minus_score": 0.9784076433121018, "source": "local", "local_type": "MUT"}
{"id": "MBPP_40_1", "golden_code": "import datetime\r\ndef check_date(m, d, y):\r\n    try:\r\n        m, d, y = map(int, (m, d, y))\r\n        datetime.date(y, m, d)\r\n        return True\r\n    except ValueError:\r\n        return False", "generated_code": "import datetime\ndef check_date(m, d, y):\n\tif m and d and y and m >= m + d:\n\t\treturn True\n\treturn False", "score": 0.7812, "codebleu": 0.29519851355591575, "crystalbleu": 0, "codebertscore": 0.84, "codescore": 0.6170441508293152, "surfaceSim": 0.5492063492063493, "abs_surfaceSim_minus_score": 0.23199365079365075, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_extra_p03325_s954474488_OP_1", "golden_code": "from math import log2\n\nn = int(eval(input()))\n\na = list(map(int, input().split()))\n\nans = 0\n\n\n\nfor _a in a:\n\n    if _a%2 == 0:\n\n        cnt =0\n\n        while _a%2 == 0:\n\n            _a //= 2\n\n            cnt += 1\n\n        ans += cnt\n\n\n\nprint((int(ans)))", "generated_code": "def f(k):\n\n    cnt = 0\n\n    while k%2 == 0:\n\n        k //= 2\n\n        cnt += 1\n\n        # print(k)\n\n        # print(\"-----\")\n\n    return cnt\n\n\n\nn = int(eval(input()))\n\nA = list(map(int, input().split()))\n\nans = 0\n\n\n\nfor a in A:\n\n    if a%2 == 0:\n\n        ans += f(a)\n\nprint(ans)", "score": 1.0, "codebleu": 0.42122428336275086, "crystalbleu": 0, "codebertscore": 0.88, "codescore": 0.9498997926712036, "surfaceSim": 0.7145323741007195, "abs_surfaceSim_minus_score": 0.28546762589928054, "source": "local", "local_type": "OP"}
{"id": "MBPP_43_118", "golden_code": "def is_Two_Alter(s):  \r\n    for i in range (len( s) - 2) : \r\n        if (s[i] != s[i + 2]) : \r\n            return False\r\n    if (s[0] == s[1]): \r\n        return False\r\n    return True", "generated_code": "def is_Two_Alter(s):\n\tif not s or not s.isalpha():\n\t\treturn False\n\treturn True if s.isupper() else False\nh = lambda x: str(x)", "score": 0.7989, "codebleu": 0.24835081800898057, "crystalbleu": 0, "codebertscore": 0.77, "codescore": 0.9672628045082092, "surfaceSim": 0.49970725995316156, "abs_surfaceSim_minus_score": 0.2991927400468385, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_80_12", "golden_code": "def maximum_segments(n, a, b, c) : \r\n\tdp = [-1] * (n + 10) \r\n\tdp[0] = 0\r\n\tfor i in range(0, n) : \r\n\t\tif (dp[i] != -1) : \r\n\t\t\tif(i + a <= n ): \r\n\t\t\t\tdp[i + a] = max(dp[i] + 1, \r\n\t\t\t\t\t\t\tdp[i + a]) \r\n\t\t\tif(i + b <= n ): \r\n\t\t\t\tdp[i + b] = max(dp[i] + 1, \r\n\t\t\t\t\t\t\tdp[i + b]) \r\n\t\t\tif(i + c <= n ): \r\n\t\t\t\tdp[i + c] = max(dp[i] + 1, \r\n\t\t\t\t\t\t\tdp[i + c]) \r\n\treturn dp[n]", "generated_code": "def maximum_segments(n, a, b, c):\n\tif 2 == n:\n\t\treturn n\n\tif 3 == n: \n\t\treturn maximumsegments(3, a, c, b)\n\t\t\n\tif 4 == n: \n\t\tsegments = 0\n\t\tif a == 1:\n\t\t\tsegments = 1\n\t\tif b == 1:\n\t\t  segments = 1\n\t\n\tif 5 == n:\n\t\tup_case = 2 \n\t\t\n\t\tline = 3\n\t\twhile line <= n:\n\t\t\tparts = a*b\n\t\t\ta, b,c, d = segments\n\t\t\ts = a + b+c\n\t\t\tif c in [1,2] :  \n\t\t\t\tsegments += 1\n\t\t\ty = a*d + b\n\t\t\tx = b*c + d\n\n\t\t\tif y > x:  \n\t\t\t\tup_testcase = segments\n\t\t\t\tsegments = line", "score": 0.0313, "codebleu": 0.14540864577400284, "crystalbleu": 0.08, "codebertscore": 0.75, "codescore": 0.039943795651197433, "surfaceSim": 0.5567567567567567, "abs_surfaceSim_minus_score": 0.5254567567567567, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_65_OP_1", "golden_code": "def circular_shift(x, shift):\n    s = str(x)\n    if shift > len(s):\n        return s[::-1]\n    else:\n        return s[len(s) - shift:] + s[:len(s) - shift]", "generated_code": "def circular_shift(num, offset):\n    num_str = str(num)\n    length = len(num_str)\n    if offset > length:\n        return num_str[::-1]\n    offset %= length\n    return num_str[-offset:] + num_str[:-offset]", "score": 1.0, "codebleu": 0.3400306465970628, "crystalbleu": 0, "codebertscore": 0.86, "codescore": 0.9360861778259277, "surfaceSim": 0.7166453537936914, "abs_surfaceSim_minus_score": 0.28335464620630857, "source": "local", "local_type": "OP"}
{"id": "APPS_test-4065_30", "golden_code": "n = int(input())\na = list(map(int, input().split()))\ncnt = 1\nans = 1\nfor i in range(1, n):\n    if a[i] > 2 * a[i - 1]:\n        ans = max( ans, cnt )\n        cnt = 1\n    else:\n        cnt += 1\nans = max( ans, cnt )\nprint(ans)", "generated_code": "n = int(input())\na = [int(x) for x in input().split()]\na.sort()\n\nsubsets = []\n\nfound = False\nfor i in range(n):\n\tif a[i] == a[i + 1]:\n\t\tfound = True\n\tif found:\n\t\tsubsets.append(a[i])\n\t\tfound = False\n\nif len(subsets) == 1:\n\tprint(n)\n\treturn\n\nlim = len(subsets)-1\nans = 0\nfor i in subsets:\n\tans += 1\n\tfor j in range(i + 1, *(n + 1)):\n\t\tif j <= lim:\n\t\t\tsubsets[j-1] = max(subsets[j], a[i])\n\nprint(ans)\n", "score": 0.0, "codebleu": 0.32330217360230284, "crystalbleu": 0.15, "codebertscore": 0.81, "codescore": 0.09765321761369705, "surfaceSim": 0.5714285714285714, "abs_surfaceSim_minus_score": 0.5714285714285714, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_p02599_s870922238_MUT_117", "golden_code": "import sys\nclass BinaryIndexedTree:\n    def __init__(self, A):\n        self.__n = len(A)\n        self.__node = [0] * (self.__n + 1)\n        self.__data = [0] * (self.__n + 1)\n        S = [0] * (self.__n + 1)\n        for i in range(1, self.__n + 1):\n            S[i] = S[i - 1] + A[i - 1]\n            self.__data[i] = A[i - 1]\n            self.__node[i] = S[i] - S[i - (i & (-i))]\n    def add(self, i, v):\n        self.__data[i] += v\n        while i <= self.__n:\n            self.__node[i] += v\n            i += i & (-i)\n    def sum(self, i):\n        rst = 0\n        while i > 0:\n            rst += self.__node[i]\n            i -= i & (-i)\n        return rst\n    def get(self, i, j):\n        if i == j:\n            return self.__data[i]\n        else:\n            return self.sum(j) - self.sum(i - 1)\ndef main():\n    (N, Q) = map(int, input().split())\n    C = list(map(int, input().split()))\n    P = [[] for _ in range(N)]\n    for (i, c) in enumerate(C):\n        P[c - 1].append(i)\n    right = [0] * N\n    for p in P:\n        if len(p):\n            right[p.pop()] = 1\n    BIT = BinaryIndexedTree(right)\n    query = [[] for _ in range(N)]\n    for (i, s) in enumerate(sys.stdin.readlines()):\n        (l, r) = map(int, s.split())\n        query[r - 1].append((l - 1, i))\n    ans = [None] * Q\n    cur = N - 1\n    for (r, q) in enumerate(reversed(query)):\n        r = (N - 1) - r\n        while q:\n            (l, i) = q.pop()\n            while r < cur:\n                c = C[cur] - 1\n                p = P[c]\n                if len(p):\n                    BIT.add(p.pop() + 1, 1)\n                cur -= 1\n            tmp = BIT.get(l + 1, r + 1)\n            ans[i] = tmp\n    print(sep='\\n', *ans)", "generated_code": "import sys\nclass BinaryIndexedTree:\n    def __init__(self, A):\n        self.__n = len(A)\n        self.__node = [0] * (self.__n + 1)\n        self.__data = [0] * (self.__n + 1)\n        S = [0] * (self.__n + 1)\n        for i in range(1, self.__n + 1):\n            S[i] = S[i - 1] + A[i - 1]\n            self.__data[i] = A[i - 1]\n            self.__node[i] = S[i] - S[i - (i & (-i))]\n    def add(self, i, v):\n        self.__data[i] += v\n        while i <= self.__n:\n            self.__node[i] += v\n            i += i & (-i)\n    def sum(self, i):\n        rst = 0\n        while i > 0:\n            rst += self.__node[i]\n            i -= i & (-i)\n        return rst\n    def get(self, i, j):\n        if i == j:\n            return self.__data[i]\n        else:\n            return self.sum(j) - self.sum(i - 1)\ndef main():\n    (N, Q) = map(int, input().split())\n    C = list(map(int, input().split()))\n    P = [[] for _ in range(N)]\n    for (i, c) in enumerate(C):\n        P[c - 1].append(i)\n    right = [0] * N\n    for p in P:\n        if len(p):\n            right[p.pop()] = 1\n    BIT = BinaryIndexedTree(right)\n    query = [[] for _ in range(N)]\n    for (i, s) in enumerate(sys.stdin.readlines()):\n        (l, r) = map(int, s.split())\n        query[r - 1].append((l - 1, i))\n    ans = [None] * Q\n    pass\n    for (r, q) in enumerate(reversed(query)):\n        r = (N - 1) - r\n        while q:\n            (l, i) = q.pop()\n            while r < cur:\n                c = C[cur] - 1\n                p = P[c]\n                if len(p):\n                    BIT.add(p.pop() + 1, 1)\n                cur -= 1\n            tmp = BIT.get(l + 1, r + 1)\n            ans[i] = tmp\n    print(sep='\\n', *ans)", "score": 0.0394, "codebleu": 0.9706354391212306, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9937093257904053, "surfaceSim": 0.9857301892521, "abs_surfaceSim_minus_score": 0.9463301892521, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_HE_161_OP_1", "golden_code": "def solve(s):\n    flg = 0\n    idx = 0\n    new_str = list(s)\n    for i in s:\n        if i.isalpha():\n            new_str[idx] = i.swapcase()\n            flg = 1\n        idx += 1\n    s = \"\"\n    for i in new_str:\n        s += i\n    if flg == 0:\n        return s[len(s)::-1]\n    return s", "generated_code": "def solve(input_str):\n    has_alpha = False\n    result = []\n    for char in input_str:\n        if char.isalpha():\n            result.append(char.swapcase())\n            has_alpha = True\n        else:\n            result.append(char)\n    if not has_alpha:\n        return ''.join(reversed(result))\n    return ''.join(result)", "score": 1.0, "codebleu": 0.15244147781600187, "crystalbleu": 0, "codebertscore": 0.77, "codescore": 0.4254789352416992, "surfaceSim": 0.5579319434459621, "abs_surfaceSim_minus_score": 0.4420680565540379, "source": "local", "local_type": "OP"}
{"id": "APPS_test-0251_25", "golden_code": "n, m = map(int, input().split())\nb = [0 for i in range(200002)]\nc = [0 for i in range(200002)]\nhmax = 0\nhmin = 200005\na = list(map(int, input().split()))\nfor i in range(n):\n    hmax = max(hmax, a[i])\n    hmin = min(hmin, a[i])\n    c[a[i]] += 1\nb[200000] = c[200000]\nfor i in range(200000 - 1, -1, -1):\n    b[i] = b[i + 1] + c[i]\ncur = hmax\nans = 0\n#print(b[:5])\nwhile cur > hmin:\n    cnt = 0\n    while cnt <= m:\n        if (cnt + b[cur] <= m) and cur > hmin:\n            cnt += b[cur]\n            cur -= 1\n        else:\n            ans += 1\n            cnt = 0\n            break\n        #print(cur, cnt)\n    if cur == hmin:\n        break\nprint(ans)", "generated_code": "n,k = list(map(int,input().split()))\nh = list(map (int,input().strip().split()))\n\n\ndp = [1]*n\n\nfor i in range(1,n):\n\tdp[i]=dp[i-1]+min(h[i],dp[i- 1])\n\nprint(dp[-1])\n", "score": 0.0027, "codebleu": 0.12145754168416573, "crystalbleu": 0.09, "codebertscore": 0.75, "codescore": 0.06754813343286514, "surfaceSim": 0.5381944444444444, "abs_surfaceSim_minus_score": 0.5354944444444444, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_68_20", "golden_code": "def subset(ar, n): \r\n    res = 0\r\n    ar.sort() \r\n    for i in range(0, n) : \r\n        count = 1\r\n        for i in range(n - 1): \r\n            if ar[i] == ar[i + 1]: \r\n                count+=1\r\n            else: \r\n                break \r\n        res = max(res, count)  \r\n    return res ", "generated_code": "def subset(ar, num):\n\t\"\"\" http://www.have-myzout.com/collections\\.org/test-size/\n\t\"\"\"\n\treturn len(set(map(str, ar)))", "score": 0.2237, "codebleu": 0.043598391202319134, "crystalbleu": 0, "codebertscore": 0.63, "codescore": 0.09302660077810287, "surfaceSim": 0.5195221445221445, "abs_surfaceSim_minus_score": 0.2958221445221445, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_59_14", "golden_code": "def count_elim(num):\r\n  count_elim = 0\r\n  for n in num:\r\n    if isinstance(n, tuple):\r\n        break\r\n    count_elim += 1\r\n  return count_elim", "generated_code": "def count_elim(num):\n\treturn len(list(filter(lambda d: d is tuple,num)))\nduplicate = dict([])", "score": 0.3363, "codebleu": 0.09731078806360269, "crystalbleu": 0, "codebertscore": 0.79, "codescore": 0.6283826231956482, "surfaceSim": 0.5140845070422535, "abs_surfaceSim_minus_score": 0.17778450704225351, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0861_16", "golden_code": "m, r = list(map(int, input().split()))\n\ndef calc(k):\n    nonlocal r\n    if k < 1:\n        return 0\n    elif k == 1:\n        return r * (2**0.5 + 2)\n    else:\n        return r * ((1 + 2 * (k - 1)) * 2**0.5 + k * 2 + (k - 1) * (k - 2))\n\navg = 0\ndiv = m ** 2\n\nfor i in range(0, m):\n    avg += (2 * r + calc(i) + calc(m - 1 - i)) / div\n \nprint(avg)\n", "generated_code": "import sys\nimport math\n\ninput = sys.stdin.readline\n\nm, R = map(int, input().split())\n\nN = 2 * R * math.pi\n\nprint(math.sqrt(N) - (m + 1) * ((m + 1) / 2))\n", "score": 0.0, "codebleu": 0.14989846271861806, "crystalbleu": 0, "codebertscore": 0.74, "codescore": 0.021477553993463516, "surfaceSim": 0.4876061969015492, "abs_surfaceSim_minus_score": 0.4876061969015492, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_77_11", "golden_code": "def floor_Max(A,B,N):\r\n    x = min(B - 1,N)\r\n    return (A*x) // B", "generated_code": "def floor_Max(n,s,d):\n\tres = 0\n\twhile s <= n:\n\t\tc,x = divmod(n,x)\n\t\tres+= int(c) if x == 1 else -1\n\treturn res", "score": 0.1311, "codebleu": 0.16631681449040722, "crystalbleu": 0, "codebertscore": 0.77, "codescore": 0.043684348464012146, "surfaceSim": 0.4563636363636364, "abs_surfaceSim_minus_score": 0.3252636363636364, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_1073_23_MUT_28", "golden_code": "n = int(input())\nch = str(input())\nr = 0\na = 0\nb = 0\nT = [[0, 0]]\nfor k in range(n):\n    if ch[k] == 'U':\n        a += 1\n    elif ch[k] == 'D':\n        a -= 1\n    elif ch[k] == 'R':\n        b += 1\n    else:\n        b -= 1\n    T += [[a, b]]\n\nfor i in range(1, n + 1):\n    for j in range(i):\n        if T[j] == T[i]:\n            r += 1\n\nprint(r)", "generated_code": "n = int(input())\nch = str(input())\npass\na = 0\nb = 0\nT = [[0, 0]]\nfor k in range(n):\n    if ch[k] == 'U':\n        a += 1\n    elif ch[k] == 'D':\n        a -= 1\n    elif ch[k] == 'R':\n        b += 1\n    else:\n        b -= 1\n    T += [[a, b]]\n\nfor i in range(1, n + 1):\n    for j in range(i):\n        if T[j] == T[i]:\n            r += 1\n\nprint(r)", "score": 0.0, "codebleu": 0.8500513084178488, "crystalbleu": 0.93, "codebertscore": 0.99, "codescore": 0.9937706589698792, "surfaceSim": 0.9691690962099125, "abs_surfaceSim_minus_score": 0.9691690962099125, "source": "local", "local_type": "MUT"}
{"id": "MBPP_216_1", "golden_code": "import math \r\ndef max_Prime_Factors (n): \r\n    maxPrime = -1 \r\n    while n%2 == 0: \r\n        maxPrime = 2\r\n        n >>= 1    \r\n    for i in range(3,int(math.sqrt(n))+1,2): \r\n        while n % i == 0: \r\n            maxPrime = i \r\n            n = n / i \r\n    if n > 2: \r\n        maxPrime = n  \r\n    return int(maxPrime)", "generated_code": "import math \ndef max_Prime_Factors (n): \n\tprimeFactors=[]\n\tfor i in range(2,int(math.sqrt(n))+1): \n\t\tif (n % i == 0):  \n\t\t\tprimeFactters.append(i)\n\treturn primeFactors", "score": 0.0, "codebleu": 0.1982963005014277, "crystalbleu": 0, "codebertscore": 0.82, "codescore": 0.019691310822963715, "surfaceSim": 0.7179245283018868, "abs_surfaceSim_minus_score": 0.7179245283018868, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_extra_p03796_s911512169_OP_1", "golden_code": "import math\n\nN = int(eval(input()))\n\nans = math.factorial(N) % (10 ** 9 + 7)\n\nprint(ans)", "generated_code": "n = int(eval(input()))\n\nfrom functools import reduce\n\nprint((reduce(lambda x,y:x*y%1000000007,list(range(1,n+1)))))", "score": 0.973, "codebleu": 0.22942398443685796, "crystalbleu": 0, "codebertscore": 0.76, "codescore": 0.03756069391965866, "surfaceSim": 0.4478260869565217, "abs_surfaceSim_minus_score": 0.5251739130434783, "source": "local", "local_type": "OP"}
{"id": "LOCAL_PIE_p02680_s341076610_MUT_14", "golden_code": "import sys\n(n, m, *abcdef) = list(map(int, sys.stdin.buffer.read().split()))\nver_lines = []\nhor_lines = []\nx_list = set()\ny_list = set()\nn3 = n * 3\nfor (a, b, c) in zip(abcdef[0:n3:3], abcdef[1:n3:3], abcdef[2:n3:3]):\n    y_list.add(a)\n    y_list.add(b)\n    x_list.add(c)\n    ver_lines.append((a, b, c))\nfor (d, e, f) in zip(abcdef[n3 + 0::3], abcdef[n3 + 1::3], abcdef[n3 + 2::3]):\n    y_list.add(d)\n    x_list.add(e)\n    x_list.add(f)\n    hor_lines.append((d, e, f))\nx_list.add(0)\ny_list.add(0)\nx_list = sorted(x_list)\ny_list = sorted(y_list)\nx_dict = {x: i for (i, x) in enumerate(x_list, start=1)}\ny_dict = {y: i for (i, y) in enumerate(y_list, start=1)}\nrow_real = len(x_list)\ncol_real = len(y_list)\nrow = row_real + 2\ncol = col_real + 2\nbanned_up_ij = [[0] * row for _ in range(col)]\nbanned_down_ij = [[0] * row for _ in range(col)]\nbanned_left_ij = [[0] * col for _ in range(row)]\nbanned_right_ij = [[0] * col for _ in range(row)]\nfor (a, b, c) in ver_lines:\n    if a > b:\n        (a, b) = (b, a)\n    ai = y_dict[a]\n    bi = y_dict[b]\n    j = x_dict[c]\n    banned_left_ij[j][ai] += 1\n    banned_left_ij[j][bi] -= 1\n    banned_right_ij[j - 1][ai] += 1\n    banned_right_ij[j - 1][bi] -= 1\nfor (d, e, f) in hor_lines:\n    if e > f:\n        (e, f) = (f, e)\n    i = y_dict[d]\n    ej = x_dict[e]\n    fj = x_dict[f]\n    banned_up_ij[i][ej] += 1\n    banned_up_ij[i][fj] -= 1\n    banned_down_ij[i - 1][ej] += 1\n    banned_down_ij[i - 1][fj] -= 1\nbanned_up = [0] * (row * col)\nbanned_down = [0] * (row * col)\nbanned_left = [0] * (row * col)\nbanned_right = [0] * (row * col)\nfor i in range(col):\n    ru = banned_up_ij[i]\n    rd = banned_down_ij[i]\n    ri = row * i\n    banned_up[ri] = ru[0]\n    banned_down[ri] = rd[0]\n    for j in range(1, row):\n        banned_up[ri + j] = banned_up[(ri + j) - 1] + ru[j]\n        banned_down[ri + j] = banned_down[(ri + j) - 1] + rd[j]\nfor j in range(row):\n    rl = banned_left_ij[j]\n    rr = banned_right_ij[j]\n    banned_left[j] = rl[0]\n    banned_right[j] = rr[0]\n    for i in range(1, col):\n        ri0 = (i - 1) * row\n        ri1 = i * row\n        banned_left[ri1 + j] = banned_left[ri0 + j] + rl[i]\n        banned_right[ri1 + j] = banned_right[ri0 + j] + rr[i]\ns = (row * y_dict[0]) + x_dict[0]\nenable = (([-1] * row) + ((([-1] + ([0] * (row - 2))) + [-1]) * (col - 2))) + ([-1] * row)\nq = [s]\nmoves = [(-row, banned_up), (-1, banned_left), (1, banned_right), (row, banned_down)]\nwhile q:\n    c = q.pop()\n    if enable[c] == 1:\n        continue\n    elif enable[c] == -1:\n        print('INF')\n        exit()\n    enable[c] = 1\n    for (dc, banned) in moves:\n        if banned[c]:\n            continue\n        nc = c + dc\n        if enable[nc] == 1:\n            continue\n        q.append(nc)\nans = 0\nfor i in range(col):\n    ri = i * row\n    for j in range(row):\n        if enable[ri + j] != 1:\n            continue\n        t = y_list[i - 1]\n        b = y_list[i]\n        l = x_list[j - 1]\n        r = x_list[j]\n        ans += (b - t) * (r - l)\nprint(ans)", "generated_code": "import sys\n(n, m, *abcdef) = list(map(int, sys.stdin.buffer.read().split()))\nver_lines = []\nhor_lines = []\nx_list = set()\ny_list = set()\nn3 = n * 3\nfor (a, b, c) in zip(abcdef[0:n3:3], abcdef[1:n3:3], abcdef[2:n3:3]):\n    y_list.add(a)\n    y_list.add(b)\n    x_list.add(c)\n    ver_lines.append((a, b, c))\nfor (d, e, f) in zip(abcdef[n3 + 0::3], abcdef[n3 + 1::3], abcdef[n3 + 2::3]):\n    y_list.add(d)\n    x_list.add(e)\n    x_list.add(f)\n    hor_lines.append((d, e, f))\nx_list.add(0)\ny_list.add(0)\nx_list = sorted(x_list)\ny_list = sorted(y_list)\nx_dict = {x: i for (i, x) in enumerate(x_list, start=1)}\ny_dict = {y: i for (i, y) in enumerate(y_list, start=1)}\nrow_real = len(x_list)\ncol_real = len(y_list)\nrow = row_real - 2\ncol = col_real + 2\nbanned_up_ij = [[0] * row for _ in range(col)]\nbanned_down_ij = [[0] * row for _ in range(col)]\nbanned_left_ij = [[0] * col for _ in range(row)]\nbanned_right_ij = [[0] * col for _ in range(row)]\nfor (a, b, c) in ver_lines:\n    if a > b:\n        (a, b) = (b, a)\n    ai = y_dict[a]\n    bi = y_dict[b]\n    j = x_dict[c]\n    banned_left_ij[j][ai] += 1\n    banned_left_ij[j][bi] -= 1\n    banned_right_ij[j - 1][ai] += 1\n    banned_right_ij[j - 1][bi] -= 1\nfor (d, e, f) in hor_lines:\n    if e > f:\n        (e, f) = (f, e)\n    i = y_dict[d]\n    ej = x_dict[e]\n    fj = x_dict[f]\n    banned_up_ij[i][ej] += 1\n    banned_up_ij[i][fj] -= 1\n    banned_down_ij[i - 1][ej] += 1\n    banned_down_ij[i - 1][fj] -= 1\nbanned_up = [0] * (row * col)\nbanned_down = [0] * (row * col)\nbanned_left = [0] * (row * col)\nbanned_right = [0] * (row * col)\nfor i in range(col):\n    ru = banned_up_ij[i]\n    rd = banned_down_ij[i]\n    ri = row * i\n    banned_up[ri] = ru[0]\n    banned_down[ri] = rd[0]\n    for j in range(1, row):\n        banned_up[ri + j] = banned_up[(ri + j) - 1] + ru[j]\n        banned_down[ri + j] = banned_down[(ri + j) - 1] + rd[j]\nfor j in range(row):\n    rl = banned_left_ij[j]\n    rr = banned_right_ij[j]\n    banned_left[j] = rl[0]\n    banned_right[j] = rr[0]\n    for i in range(1, col):\n        ri0 = (i - 1) * row\n        ri1 = i * row\n        banned_left[ri1 + j] = banned_left[ri0 + j] + rl[i]\n        banned_right[ri1 + j] = banned_right[ri0 + j] + rr[i]\ns = (row * y_dict[0]) + x_dict[0]\nenable = (([-1] * row) + ((([-1] + ([0] * (row - 2))) + [-1]) * (col - 2))) + ([-1] * row)\nq = [s]\nmoves = [(-row, banned_up), (-1, banned_left), (1, banned_right), (row, banned_down)]\nwhile q:\n    c = q.pop()\n    if enable[c] == 1:\n        continue\n    elif enable[c] == -1:\n        print('INF')\n        exit()\n    enable[c] = 1\n    for (dc, banned) in moves:\n        if banned[c]:\n            continue\n        nc = c + dc\n        if enable[nc] == 1:\n            continue\n        q.append(nc)\nans = 0\nfor i in range(col):\n    ri = i * row\n    for j in range(row):\n        if enable[ri + j] != 1:\n            continue\n        t = y_list[i - 1]\n        b = y_list[i]\n        l = x_list[j - 1]\n        r = x_list[j]\n        ans += (b - t) * (r - l)\nprint(ans)", "score": 0.0, "codebleu": 0.9973984967720897, "crystalbleu": 1.0, "codebertscore": 1.0, "codescore": 0.9536595940589905, "surfaceSim": 0.9998327199732352, "abs_surfaceSim_minus_score": 0.9998327199732352, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-1171_26", "golden_code": "N,K = list(map(int,input().split()))\nV = list(map(int,input().split()))\nleft = [0]*(K+1)\nright = [0]*(K+1)\n\nfor k in range(1,min(N+1,K+1)):\n    max_vk = 0\n    for j in range(k//2+1):        \n        push = j\n        pop = k-j\n        #print(k,pop,push)\n        if pop>N:\n            continue\n        else:\n            tmp = sum(sorted(V[:pop])[push:])\n        max_vk = max(max_vk,tmp)\n    left[k] = max_vk\n\nVrev = V[::-1]\n\nfor k in range(1,K+1):\n    max_vk = 0\n    for j in range(k//2+1):\n        push = j\n        pop = k-j\n        #print(k,pop,push)\n        if pop>N:\n            continue\n        else:\n            tmp = sum(sorted(Vrev[:pop])[push:])\n        max_vk = max(max_vk,tmp)\n    right[k] = max_vk\n\nfor i in range(len(right)-1):\n    if right[i+1]<right[i]:\n        right[i+1]= right[i]\n    if left[i+1]<left[i]:\n        left[i+1]=left[i]\n\nans = 0\nNK = K\nmax_ans = 0\nfor v in V:\n    if v>0:\n        max_ans += v\n    \nfor i in range(NK+1):\n    ans = max(ans,right[i]+left[NK-i])\n\nprint((min(max_ans,ans)))\n", "generated_code": "def main():\n\tN,K = map(int,input().split())\n\tV = list(map(int,input()))\n\tV.sort(reverse = True)\n\tj = 0\n\tflag = 0\n\tans = 0\n\tfor i in range(N):\n\t\tif j >= K:\n\t\t\tflag = 1\n\t\t\tbreak\n\t\tans += V[j]\n\t\tj += 1\n\tif flag == 1:\n\t\tprint(-ans)\n\telse:\n\t\tprint(ans)\n\ndef __starting_point():\n\tmain()\n__starting_point()\n", "score": 0.0, "codebleu": 0.09572861606789054, "crystalbleu": 0.03, "codebertscore": 0.73, "codescore": 0.11925677955150604, "surfaceSim": 0.5165912518853695, "abs_surfaceSim_minus_score": 0.5165912518853695, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_187_3", "golden_code": "def last_Digit_Factorial(n): \r\n    if (n == 0): return 1\r\n    elif (n <= 2): return n  \r\n    elif (n == 3): return 6\r\n    elif (n == 4): return 4 \r\n    else: \r\n      return 0", "generated_code": "def last_Digit_Factorial(n):\n  x = n//2\n  y = n*(n+1)\n  \n  z = sum([1 for c in range(1, x+1) if c == p])\n  \n  return z", "score": 0.0, "codebleu": 0.1940905485170016, "crystalbleu": 0, "codebertscore": 0.78, "codescore": 0.02798071876168251, "surfaceSim": 0.5426929392446633, "abs_surfaceSim_minus_score": 0.5426929392446633, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_110_MUT_15", "golden_code": "import os\n\ndef exchange(lst1, lst2):\n    odd = 0\n    even = 0\n    for i in lst1:\n        if i % 2 == 1:\n            odd += 1\n    for i in lst2:\n        if i % 2 == 0:\n            even += 1\n    if even >= odd:\n        return 'YES'\n    return 'NO'", "generated_code": "import os\n\ndef exchange(lst1, lst2):\n    odd = 0\n    even = 0\n    for i in lst1:\n        if i % 2 == 1:\n            odd += 1\n    for i in lst2:\n        if i % 2 != 0:\n            even += 1\n    if even >= odd:\n        return 'YES'\n    return 'NO'", "score": 0.4741, "codebleu": 0.9713761939215139, "crystalbleu": 0, "codebertscore": 1.0, "codescore": 0.9936072826385498, "surfaceSim": 0.9752319109461967, "abs_surfaceSim_minus_score": 0.5011319109461967, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_MBPP_306_OP_1", "golden_code": "def max_sum_increasing_subseq(a, n, index, k):\r\n\tdp = [[0 for i in range(n)] \r\n\t\t\tfor i in range(n)]\r\n\tfor i in range(n):\r\n\t\tif a[i] > a[0]:\r\n\t\t\tdp[0][i] = a[i] + a[0]\r\n\t\telse:\r\n\t\t\tdp[0][i] = a[i]\r\n\tfor i in range(1, n):\r\n\t\tfor j in range(n):\r\n\t\t\tif a[j] > a[i] and j > i:\r\n\t\t\t\tif dp[i - 1][i] + a[j] > dp[i - 1][j]:\r\n\t\t\t\t\tdp[i][j] = dp[i - 1][i] + a[j]\r\n\t\t\t\telse:\r\n\t\t\t\t\tdp[i][j] = dp[i - 1][j]\r\n\t\t\telse:\r\n\t\t\t\tdp[i][j] = dp[i - 1][j]\r\n\treturn dp[index][k]", "generated_code": "def max_sum_increasing_subseq(arr, size, idx, target):\n    if size == 0:\n        return 0\n    max_sum = [0] * size\n    for i in range(size):\n        max_sum[i] = arr[i]\n    for i in range(1, size):\n        for j in range(i):\n            if arr[i] > arr[j] and max_sum[i] < max_sum[j] + arr[i]:\n                max_sum[i] = max_sum[j] + arr[i]\n    return max_sum[target] if target < size else 0", "score": 0.6957, "codebleu": 0.25596176970438467, "crystalbleu": 0.09, "codebertscore": 0.81, "codescore": 0.17310339212417603, "surfaceSim": 0.6356953391436151, "abs_surfaceSim_minus_score": 0.060004660856384895, "source": "local", "local_type": "OP"}
{"id": "APPS_test-2404_15", "golden_code": "a = int(input())\nfor i in range(2, a):\n\tif a%i == 0:\n\t\tprint(str(i) + str(a//i))\n\t\tbreak", "generated_code": "def read_int():\n\treturn int(input())\n\n\ndef read_ints():\n\treturn list(map(int, input().split(' ')))\n\n\nt = read_int()\nfor case_num in range(t):\n\ta = read_int().strip()\n\tprint(a)\n", "score": 0.1274, "codebleu": 0.174804123559081, "crystalbleu": 0, "codebertscore": 0.77, "codescore": 0.19797775149345398, "surfaceSim": 0.39042207792207795, "abs_surfaceSim_minus_score": 0.26302207792207793, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_MBPP_493_MUT_60", "golden_code": "import os\n\nimport math\ndef calculate_polygons(startx, starty, endx, endy, radius):\n    sl = (2 * radius) * math.tan(math.pi / 6)\n    p = sl * 0.5\n    b = sl * math.cos(math.radians(30))\n    w = b * 2\n    h = 2 * sl\n    startx = startx - w\n    starty = starty - h\n    endx = endx + w\n    endy = endy + h\n    origx = startx\n    origy = starty\n    xoffset = b\n    yoffset = 3 * p\n    polygons = []\n    row = 1\n    counter = 0\n    while starty < endy:\n        if row % 2 == 0:\n            startx = origx + xoffset\n        else:\n            startx = origx\n        while startx < endx:\n            p1x = startx\n            p1y = starty + p\n            p2x = startx\n            p2y = starty + (3 * p)\n            p3x = startx + b\n            p3y = starty + h\n            p4x = startx + w\n            p4y = starty + (3 * p)\n            p5x = startx + w\n            p5y = starty + p\n            p6x = startx + b\n            p6y = starty\n            poly = [\\\n                (p1x, p1y), \\\n                (p2x, p2y), \\\n                (p3x, p3y), \\\n                (p4x, p4y), \\\n                (p5x, p5y), \\\n                (p6x, p6y), \\\n                (p1x, p1y)]\n            polygons.append(poly)\n            counter += 1\n            startx += w\n        starty += yoffset\n        row += 1\n    return polygons", "generated_code": "import os\n\nimport math\ndef calculate_polygons(startx, starty, endx, endy, radius):\n    sl = (2 * radius) * math.tan(math.pi / 6)\n    p = sl * 0.5\n    b = sl * math.cos(math.radians(30))\n    w = b * 2\n    h = 2 * sl\n    startx = startx - w\n    starty = starty - h\n    endx = endx + w\n    endy = endy + h\n    origx = startx\n    origy = starty\n    xoffset = b\n    yoffset = 3 * p\n    polygons = []\n    row = 1\n    counter = 0\n    while starty < endy:\n        if row % 2 == 0:\n            startx = origx + xoffset\n        else:\n            startx = origx\n        while startx <= endx:\n            p1x = startx\n            p1y = starty + p\n            p2x = startx\n            p2y = starty + (3 * p)\n            p3x = startx + b\n            p3y = starty + h\n            p4x = startx + w\n            p4y = starty + (3 * p)\n            p5x = startx + w\n            p5y = starty + p\n            p6x = startx + b\n            p6y = starty\n            poly = [\\\n                (p1x, p1y), \\\n                (p2x, p2y), \\\n                (p3x, p3y), \\\n                (p4x, p4y), \\\n                (p5x, p5y), \\\n                (p6x, p6y), \\\n                (p1x, p1y)]\n            polygons.append(poly)\n            counter += 1\n            startx += w\n        starty += yoffset\n        row += 1\n    return polygons", "score": 0.3236, "codebleu": 0.9937480014850033, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9937111139297485, "surfaceSim": 0.9829498977505112, "abs_surfaceSim_minus_score": 0.6593498977505112, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_PIE_extra_p03416_s570028181_OP_1", "golden_code": "a,b = list(map(int, input().split()))\n\ncount = 0\n\nfor i in range(a,b+1):\n\n    j = str(i)\n\n    if j==''.join(reversed(j)):\n\n        count += 1\n\nprint(count)", "generated_code": "a,b = list(map(int, input().split()))\n\nn = [i for i in map(str, list(range(a,b+1))) if i==i[::-1]]\n\nprint((len(n)))", "score": 1.0, "codebleu": 0.3592560489272494, "crystalbleu": 0, "codebertscore": 0.87, "codescore": 0.3866296708583832, "surfaceSim": 0.6011220196353436, "abs_surfaceSim_minus_score": 0.3988779803646564, "source": "local", "local_type": "OP"}
{"id": "MBPP_49_13", "golden_code": "def max_of_two( x, y ):\r\n    if x > y:\r\n        return x\r\n    return y", "generated_code": "def max_of_two( x, y ):\n\treturn x if x==y else max(x,y)", "score": 1.0, "codebleu": 0.4809789707311062, "crystalbleu": 0, "codebertscore": 0.89, "codescore": 0.9939014911651611, "surfaceSim": 0.6434065934065935, "abs_surfaceSim_minus_score": 0.35659340659340655, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_1541_0_OP_1", "golden_code": "s = input()\nsuc = 0\np = 0\nkde = 0\nfor i in range(len(s)):\n\tc = s[i]\n\tif c == '^':\n\t\tkde = i\nfor i in range(len(s)):\n\tc = s[i]\n\tif '1' <= c <= '9':\n\t\tsuc+=((kde-i)*int(c))\n\t\tp+=1\nif suc < 0:\n\tprint(\"right\")\nelif suc > 0:\n\tprint(\"left\")\nelse:\n\tprint(\"balance\")", "generated_code": "user_input = input()\nleft_weight = 0\nright_weight = 0\npivot_index = user_input.index('^')\nfor index, char in enumerate(user_input):\n    if '1' <= char <= '9':\n        weight = int(char)\n        if index < pivot_index:\n            left_weight += (pivot_index - index) * weight\n        else:\n            right_weight += (index - pivot_index) * weight\nif left_weight < right_weight:\n    print(\"right\")\nelif left_weight > right_weight:\n    print(\"left\")\nelse:\n    print(\"balance\")", "score": 1.0, "codebleu": 0.28184810445143826, "crystalbleu": 0.28, "codebertscore": 0.78, "codescore": 0.9506892561912537, "surfaceSim": 0.6395308123249299, "abs_surfaceSim_minus_score": 0.3604691876750701, "source": "local", "local_type": "OP"}
{"id": "LOCAL_PIE_p02537_s767194684_MUT_168", "golden_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "generated_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        break\n    \n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "score": 0.4424, "codebleu": 0.911813081552033, "crystalbleu": 0.9, "codebertscore": 0.98, "codescore": 0.9935150146484375, "surfaceSim": 0.9679840299186334, "abs_surfaceSim_minus_score": 0.5255840299186334, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_APPS_707_11_MUT_6", "golden_code": "(n, m) = list(map(int, input().split()))\nx = tuple(map(int, input().split()))\ny = min(x)\na = 0\nfor xi in x:\n    b = xi - y\n    while b:\n        (a, b) = (b, a % b)\nj = 1\nfor p in input().split():\n    if a % int(p):\n        j += 1\n        continue\n    print('YES')\n    print(y, j)\n    break\nelse:\n    print('NO')", "generated_code": "(n, m) = list(map(int, input().split()))\nx = tuple(map(int, input().split()))\ny = min(x)\na = 0\nfor xi in x:\n    b = xi - y\n    while b:\n        (a, b) = (b, a % b)\nj = 1\nfor p in input().split():\n    if a % int(p):\n        j += 1\n        continue\n    print('YES')\n    print(y, j)\n    continue\nelse:\n    print('NO')", "score": 0.0012, "codebleu": 0.9621829292151618, "crystalbleu": 0.96, "codebertscore": 1.0, "codescore": 0.9937006235122681, "surfaceSim": 0.9622611464968153, "abs_surfaceSim_minus_score": 0.9610611464968153, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_PIE_p00144_s682125154_MUT_108", "golden_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "generated_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    pass\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "score": 0.0, "codebleu": 0.9780570304333551, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.9935740828514099, "surfaceSim": 0.9832999801050919, "abs_surfaceSim_minus_score": 0.9832999801050919, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_PIE_extra_p03038_s653342727_OP_1", "golden_code": "from heapq import heappop, heappush\n\n\n\nn, m = list(map(int, input().split()))\n\na = tuple(map(int, input().split()))\n\n\n\nhq = []\n\nfor aa in a:\n\n    heappush(hq, (-aa, 1))\n\n\n\nfor _ in range(m):\n\n    b, c = list(map(int, input().split()))\n\n    heappush(hq, (-c, b))\n\n\n\nrest = n\n\nans = 0\n\nwhile rest > 0:\n\n    num, cnt = heappop(hq)\n\n\n\n    num *= (-1)\n\n    use = min(rest, cnt)\n\n    ans += use * num\n\n    rest -= use\n\n\n\nprint(ans)\n", "generated_code": "def main():\n\n    from collections import Counter\n\n    from operator import itemgetter\n\n\n\n    import sys\n\n    input = sys.stdin.readline\n\n\n\n    N, M = list(map(int, input().split()))\n\n    a = list(map(int, input().split()))\n\n\n\n    ctr = Counter(a)\n\n    for _ in range(M):\n\n        b, c = list(map(int, input().split()))\n\n        ctr[c] += b\n\n\n\n    ans = 0\n\n    rest = N\n\n    for integer, count in sorted(list(ctr.items()), key=itemgetter(0), reverse=True):\n\n        take = min(rest, count)\n\n        ans += take * integer\n\n        rest -= take\n\n        if not rest:\n\n            break\n\n\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n\n\n\n# import sys\n\n# input = sys.stdin.readline\n\n# \n\n# sys.setrecursionlimit(10 ** 7)\n\n# \n\n# (int(x)-1 for x in input().split())\n\n# rstrip()\n", "score": 1.0, "codebleu": 0.3669428314668479, "crystalbleu": 0.21, "codebertscore": 0.78, "codescore": 0.02092237025499344, "surfaceSim": 0.6238370348139255, "abs_surfaceSim_minus_score": 0.3761629651860745, "source": "local", "local_type": "OP"}
{"id": "MBPP_71_21", "golden_code": "import math\r\ndef get_First_Set_Bit_Pos(n):\r\n     return math.log2(n&-n)+1", "generated_code": "import math\ndef get_First_Set_Bit_Pos(n1):\n\tprint(n1)\n\treturn (n1 & 0x555555555555) + ((n1 & 8) >> 1)", "score": 0.1708, "codebleu": 0.23359380537549976, "crystalbleu": 0, "codebertscore": 0.82, "codescore": 0.07231447845697403, "surfaceSim": 0.6803022407503908, "abs_surfaceSim_minus_score": 0.5095022407503909, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-1329_71", "golden_code": "from collections import defaultdict\n\nn = int(input())\nd = defaultdict(int)\n\ndef prime_factorize(n):\n    a = []\n    while n % 2 == 0:\n        a.append(2)\n        n //= 2\n    f = 3\n    while f * f <= n:\n        if n % f == 0:\n            a.append(f)\n            n //= f\n        else:\n            f += 2\n    if n != 1:\n        a.append(n)\n    return a\n\nfor i in range(1, n+1):\n    for x in prime_factorize(i):\n        d[x] += 1\n\n#print(d)\n\n\n\ne = defaultdict(int)\n\nl = [2, 4, 14, 24, 74]\n\n#74\nfor k, v in d.items():\n    for x in l:\n        if v >= x:\n            e[x] += 1\n\n#print(e)\n\nans = 0\n\nans += e[74]\nans += e[24] * (e[2] - 1)\nans += e[14] * (e[4] - 1)\nans += (e[4] * (e[4]-1) // 2) * (e[2] - e[4]) + (e[4] * (e[4]-1) * (e[4]-2) // 2)\n\nprint(ans)", "generated_code": "import math\n\ndef main():\n\tn = int(input())\n\ta = (n*(n+1))//2\n\n\tk = int(math.sqrt(n))\n\td = [1]*k\n\tfor i in range(2, k+1):\n\t\tif n%i == 0:\n\t\t\td[i] = d[i-1] + 1\n\tans = 0\n\tfor i, j in enumerate(d):\n\t\tif i+j == n:\n\t\t\tans += 1\n\tprint(ans)\n\ndef __starting_point():\n\tmain()\n__starting_point()\n", "score": 0.039, "codebleu": 0.12602850510611513, "crystalbleu": 0.07, "codebertscore": 0.76, "codescore": 0.18600279092788696, "surfaceSim": 0.6430672268907562, "abs_surfaceSim_minus_score": 0.6040672268907562, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_66_OP_2", "golden_code": "def digitSum(s):\n    if s == \"\": return 0\n    return sum(ord(char) if char.isupper() else 0 for char in s)", "generated_code": "def digitSum(input_str):\n    if not input_str:\n        return 0\n    upper_case_sum = 0\n    for char in input_str:\n        if 'A' <= char <= 'Z':\n            upper_case_sum += ord(char)\n    return upper_case_sum", "score": 0.981, "codebleu": 0.2586027573516812, "crystalbleu": 0, "codebertscore": 0.84, "codescore": 0.40259334444999695, "surfaceSim": 0.5285714285714286, "abs_surfaceSim_minus_score": 0.4524285714285714, "source": "local", "local_type": "OP"}
{"id": "LOCAL_PIE_extra_p03107_s703980325_OP_1", "golden_code": "from collections import Counter\n\nd={chr(i):0 for i in range(2)}\n\ns=Counter(eval(input()))\n\nd=d.update(s)\n\nprint((min(s[\"0\"],s[\"1\"])*2))", "generated_code": "s=eval(input())\n\nprint((min(s.count(\"0\"),s.count(\"1\"))*2))", "score": 1.0, "codebleu": 0.10285285285285285, "crystalbleu": 0, "codebertscore": 0.82, "codescore": 0.8731255531311035, "surfaceSim": 0.47908496732026146, "abs_surfaceSim_minus_score": 0.5209150326797385, "source": "local", "local_type": "OP"}
{"id": "LOCAL_PIE_extra_p02555_s099094742_OP_1", "golden_code": "n = int(eval(input()))\n\nmx = n//3\n\nans = 0\n\nmod = 10**9+7\n\nimport math\n\ndef combinations_count(n, r): #組み合わせ(nCr)\n\n    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\n\nfor i in range(1,mx+1):\n\n    if i == 1:\n\n        ans += 1\n\n    else:\n\n        ans += combinations_count(n-2*i-1,i-1) % mod\n\nprint((ans%mod))", "generated_code": "s = int(eval(input()))\n\ndp = [0]*(2001)\n\ndp[3] = 1\n\nmod = 10**9+7\n\nfor i in range(4,s+1):\n\n    dp[i] = (dp[i-1] + dp[i-3]) % mod\n\nprint((dp[s]))", "score": 1.0, "codebleu": 0.16498058488401543, "crystalbleu": 0.24, "codebertscore": 0.78, "codescore": 0.10787035524845123, "surfaceSim": 0.4759036144578313, "abs_surfaceSim_minus_score": 0.5240963855421688, "source": "local", "local_type": "OP"}
{"id": "LOCAL_PIE_p02599_s870922238_MUT_45", "golden_code": "import sys\nclass BinaryIndexedTree:\n    def __init__(self, A):\n        self.__n = len(A)\n        self.__node = [0] * (self.__n + 1)\n        self.__data = [0] * (self.__n + 1)\n        S = [0] * (self.__n + 1)\n        for i in range(1, self.__n + 1):\n            S[i] = S[i - 1] + A[i - 1]\n            self.__data[i] = A[i - 1]\n            self.__node[i] = S[i] - S[i - (i & (-i))]\n    def add(self, i, v):\n        self.__data[i] += v\n        while i <= self.__n:\n            self.__node[i] += v\n            i += i & (-i)\n    def sum(self, i):\n        rst = 0\n        while i > 0:\n            rst += self.__node[i]\n            i -= i & (-i)\n        return rst\n    def get(self, i, j):\n        if i == j:\n            return self.__data[i]\n        else:\n            return self.sum(j) - self.sum(i - 1)\ndef main():\n    (N, Q) = map(int, input().split())\n    C = list(map(int, input().split()))\n    P = [[] for _ in range(N)]\n    for (i, c) in enumerate(C):\n        P[c - 1].append(i)\n    right = [0] * N\n    for p in P:\n        if len(p):\n            right[p.pop()] = 1\n    BIT = BinaryIndexedTree(right)\n    query = [[] for _ in range(N)]\n    for (i, s) in enumerate(sys.stdin.readlines()):\n        (l, r) = map(int, s.split())\n        query[r - 1].append((l - 1, i))\n    ans = [None] * Q\n    cur = N - 1\n    for (r, q) in enumerate(reversed(query)):\n        r = (N - 1) - r\n        while q:\n            (l, i) = q.pop()\n            while r < cur:\n                c = C[cur] - 1\n                p = P[c]\n                if len(p):\n                    BIT.add(p.pop() + 1, 1)\n                cur -= 1\n            tmp = BIT.get(l + 1, r + 1)\n            ans[i] = tmp\n    print(sep='\\n', *ans)", "generated_code": "import sys\nclass BinaryIndexedTree:\n    def __init__(self, A):\n        self.__n = len(A)\n        self.__node = [0] * (self.__n + 1)\n        self.__data = [0] * (self.__n + 1)\n        S = [0] * (self.__n + 1)\n        for i in range(1, self.__n + 1):\n            S[i] = S[i - 1] + A[i - 1]\n            self.__data[i] = A[i - 1]\n            self.__node[i] = S[i] - S[i - (i & (-i))]\n    def add(self, i, v):\n        self.__data[i] += v\n        while i <= self.__n:\n            self.__node[i] -= v\n            i += i & (-i)\n    def sum(self, i):\n        rst = 0\n        while i > 0:\n            rst += self.__node[i]\n            i -= i & (-i)\n        return rst\n    def get(self, i, j):\n        if i == j:\n            return self.__data[i]\n        else:\n            return self.sum(j) - self.sum(i - 1)\ndef main():\n    (N, Q) = map(int, input().split())\n    C = list(map(int, input().split()))\n    P = [[] for _ in range(N)]\n    for (i, c) in enumerate(C):\n        P[c - 1].append(i)\n    right = [0] * N\n    for p in P:\n        if len(p):\n            right[p.pop()] = 1\n    BIT = BinaryIndexedTree(right)\n    query = [[] for _ in range(N)]\n    for (i, s) in enumerate(sys.stdin.readlines()):\n        (l, r) = map(int, s.split())\n        query[r - 1].append((l - 1, i))\n    ans = [None] * Q\n    cur = N - 1\n    for (r, q) in enumerate(reversed(query)):\n        r = (N - 1) - r\n        while q:\n            (l, i) = q.pop()\n            while r < cur:\n                c = C[cur] - 1\n                p = P[c]\n                if len(p):\n                    BIT.add(p.pop() + 1, 1)\n                cur -= 1\n            tmp = BIT.get(l + 1, r + 1)\n            ans[i] = tmp\n    print(sep='\\n', *ans)", "score": 0.0394, "codebleu": 0.994935590512094, "crystalbleu": 1.0, "codebertscore": 1.0, "codescore": 0.9936482310295105, "surfaceSim": 0.9997036158861885, "abs_surfaceSim_minus_score": 0.9603036158861885, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_MBPP_31_OP_1", "golden_code": "def func(nums, k):\r\n    import collections\r\n    d = collections.defaultdict(int)\r\n    for row in nums:\r\n        for i in row:\r\n            d[i] += 1\r\n    temp = []\r\n    import heapq\r\n    for key, v in d.items():\r\n        if len(temp) < k:\r\n            temp.append((v, key))\r\n            if len(temp) == k:\r\n                heapq.heapify(temp)\r\n        else:\r\n            if v > temp[0][0]:\r\n                heapq.heappop(temp)\r\n                heapq.heappush(temp, (v, key))\r\n    result = []\r\n    while temp:\r\n        v, key = heapq.heappop(temp)\r\n        result.append(key)\r\n    return result", "generated_code": "def func(matrix, top_k):\n    from collections import Counter\n    from heapq import nlargest\n    frequency = Counter()\n    for row in matrix:\n        frequency.update(row)\n    return [key for key, _ in nlargest(top_k, frequency.items(), key=lambda x: x[1])]", "score": 0.9473, "codebleu": 0.16679008794641859, "crystalbleu": 0, "codebertscore": 0.69, "codescore": 0.6284537315368652, "surfaceSim": 0.5408554346159742, "abs_surfaceSim_minus_score": 0.40644456538402585, "source": "local", "local_type": "OP"}
{"id": "LOCAL_MBPP_950_MUT_61", "golden_code": "import os\n\ndef chinese_zodiac(year):\n    if (year - 2000) % 12 == 0:\n        sign = 'Dragon'\n    elif (year - 2000) % 12 == 1:\n        sign = 'Snake'\n    elif (year - 2000) % 12 == 2:\n        sign = 'Horse'\n    elif (year - 2000) % 12 == 3:\n        sign = 'sheep'\n    elif (year - 2000) % 12 == 4:\n        sign = 'Monkey'\n    elif (year - 2000) % 12 == 5:\n        sign = 'Rooster'\n    elif (year - 2000) % 12 == 6:\n        sign = 'Dog'\n    elif (year - 2000) % 12 == 7:\n        sign = 'Pig'\n    elif (year - 2000) % 12 == 8:\n        sign = 'Rat'\n    elif (year - 2000) % 12 == 9:\n        sign = 'Ox'\n    elif (year - 2000) % 12 == 10:\n        sign = 'Tiger'\n    else:\n        sign = 'Hare'\n    return sign", "generated_code": "import os\n\ndef chinese_zodiac(year):\n    if (year - 2000) % 12 == 0:\n        sign = 'Dragon'\n    elif (year - 2000) % 12 == 1:\n        sign = 'Snake'\n    elif (year - 2000) % 12 == 2:\n        sign = 'Horse'\n    elif (year - 2000) % 12 == 3:\n        sign = 'sheep'\n    elif (year - 2000) % 12 == 4:\n        sign = 'Monkey'\n    elif (year - 2000) % 12 == 5:\n        sign = 'Rooster'\n    elif (year - 2000) % 12 == 6:\n        sign = 'Dog'\n    elif (year - 2000) % 12 == 7:\n        sign = 'Pig'\n    elif (year - 2000) % 12 == 8:\n        sign = 'Rat'\n    elif (year - 2000) % 12 == 9:\n        sign = 'Ox'\n    elif (year - 2000) % 12 == 10:\n        sign = 'Tiger'\n    else:\n        sign = 'Hare'\n    pass", "score": 0.0, "codebleu": 0.9754687189988893, "crystalbleu": 0.97, "codebertscore": 1.0, "codescore": 0.9936373233795166, "surfaceSim": 0.9409854423292273, "abs_surfaceSim_minus_score": 0.9409854423292273, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_HE_56_OP_1", "golden_code": "def correct_bracketing(brackets: str):\n    depth = 0\n    for b in brackets:\n        if b == \"<\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0", "generated_code": "def correct_bracketing(seq: str):\n    balance = 0\n    for char in seq:\n        balance += 1 if char == '<' else -1\n        if balance < 0:\n            return False\n    return balance == 0\n", "score": 1.0, "codebleu": 0.4393047740062622, "crystalbleu": 0, "codebertscore": 0.91, "codescore": 0.9857902526855469, "surfaceSim": 0.7603174603174603, "abs_surfaceSim_minus_score": 0.23968253968253972, "source": "local", "local_type": "OP"}
{"id": "LOCAL_APPS_483_9_MUT_5", "golden_code": "import time\n\nn = int(input())\n\nN = [i for i in input()]\nx = [int(i) for i in input().split()]\n\nstart = time.time()\n\nflag = False\nans = float('Inf')\n\nfor i in range(n):\n    if N[i] == 'R':\n        left = i\n        flag = True\n    elif flag == True:\n        buf = x[i] - x[left]\n        if buf < ans:\n            ans = buf\n        flag = False\n\nif ans < float('Inf'):\n    print(ans // 2)\nelse:\n    print(-1)\n\nfinish = time.time()", "generated_code": "import time\n\nn = int(input())\n\nN = [i for i in input()]\nx = [int(i) for i in input().split()]\n\nstart = time.time()\n\nflag = False\nans = float('Inf')\n\nfor i in range(n):\n    if N[i] == 'R':\n        left = i\n        flag = True\n    elif flag == True:\n        buf = x[i] - x[left]\n        if buf < ans:\n            ans = buf\n        flag = False\n\nif ans < float('Inf'):\n    print(ans // 2)\nelse:\n    print(+1)\n\nfinish = time.time()", "score": 0.1475, "codebleu": 0.9826856244520652, "crystalbleu": 0.96, "codebertscore": 0.99, "codescore": 0.9937507510185242, "surfaceSim": 0.9603675013511079, "abs_surfaceSim_minus_score": 0.812867501351108, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_HE_66_OP_1", "golden_code": "def digitSum(s):\n    if s == \"\": return 0\n    return sum(ord(char) if char.isupper() else 0 for char in s)", "generated_code": "def digitSum(input_str):\n    if not input_str:\n        return 0\n    upper_case_sum = 0\n    for char in input_str:\n        if 'A' <= char <= 'Z':\n            upper_case_sum += ord(char)\n    return upper_case_sum", "score": 0.982, "codebleu": 0.2586027573516812, "crystalbleu": 0, "codebertscore": 0.84, "codescore": 0.40259334444999695, "surfaceSim": 0.5285714285714286, "abs_surfaceSim_minus_score": 0.4534285714285714, "source": "local", "local_type": "OP"}
{"id": "LOCAL_PIE_extra_p03796_s916466489_OP_1", "golden_code": "import math\n\n\n\n\n\ndef main():\n\n    N = int(eval(input()))\n\n    power = math.factorial(N)\n\n    print((power % (10 ** 9 + 7)))\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "generated_code": "def main():\n\n    N = int(eval(input()))\n\n    power = 1\n\n    for i in range(1, N + 1):\n\n        power *= i\n\n        power %= 10 ** 9 + 7\n\n    print(power)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "score": 1.0, "codebleu": 0.46994324023919654, "crystalbleu": 0, "codebertscore": 0.88, "codescore": 0.018684595823287964, "surfaceSim": 0.7407773386034255, "abs_surfaceSim_minus_score": 0.25922266139657446, "source": "local", "local_type": "OP"}
{"id": "LOCAL_HE_21_MUT_2", "golden_code": "import os\n\nfrom typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) / (max_number - min_number) for x in numbers]", "generated_code": "import os\n\nfrom typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) // (max_number - min_number) for x in numbers]", "score": 0.4302, "codebleu": 0.9540808774126313, "crystalbleu": 0, "codebertscore": 1.0, "codescore": 0.993638813495636, "surfaceSim": 0.9502070393374742, "abs_surfaceSim_minus_score": 0.5200070393374742, "source": "local", "local_type": "MUT"}
{"id": "MBPP_3_12", "golden_code": "def length_Of_Last_Word(a): \r\n    l = 0\r\n    x = a.strip() \r\n    for i in range(len(x)): \r\n        if x[i] == \" \": \r\n            l = 0\r\n        else: \r\n            l += 1\r\n    return l ", "generated_code": "def length_Of_Last_Word(astr: str) -> int:\n\treturn len(astr[:-1])", "score": 0.0, "codebleu": 0.03286317765335821, "crystalbleu": 0, "codebertscore": 0.72, "codescore": 0.05537429079413414, "surfaceSim": 0.5471210340775557, "abs_surfaceSim_minus_score": 0.5471210340775557, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_160_35_OP_2", "golden_code": "from math import sqrt\nfrom bisect import bisect_left\n\ndef main():\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    sum_a = sum(a)\n    st = set()\n    for v in range(1, int(sqrt(sum_a))+2):\n        if sum_a % v == 0:\n            st.add(v)\n            st.add(sum_a//v)\n    st.remove(1)\n    ans = 1\n    for target in st:\n        a_mod_t = [v % target for v in a]\n        a_mod_t.sort()\n        for i in range(n-1):\n            a_mod_t[i+1] += a_mod_t[i]\n        for i in range(n):\n            sum_L, sum_R = a_mod_t[i], a_mod_t[-1] - a_mod_t[i]\n            len_L, len_R = i+1, n-i-1\n            if sum_L == target * len_R - sum_R:\n                if sum_L <= k:\n                    if ans < target:\n                        ans = target\n    print(ans)\n\ndef __starting_point():\n    main()\n__starting_point()", "generated_code": "from math import isqrt\n\ndef main():\n    num_elements, max_operations = map(int, input().split())\n    elements = list(map(int, input().split()))\n    total_sum = sum(elements)\n    divisors = set()\n    for candidate in range(1, isqrt(total_sum) + 1):\n        if total_sum % candidate == 0:\n            divisors.add(candidate)\n            divisors.add(total_sum // candidate)\n    divisors.discard(1)\n    maximum_divisor = 1\n    for divisor in divisors:\n        mod_elements = sorted([element % divisor for element in elements])\n        prefix_sum = [0] * num_elements\n        prefix_sum[0] = mod_elements[0]\n        for i in range(1, num_elements):\n            prefix_sum[i] = prefix_sum[i - 1] + mod_elements[i]\n        for i in range(num_elements):\n            left_sum = prefix_sum[i]\n            right_sum = prefix_sum[-1] - prefix_sum[i]\n            len_left = i + 1\n            len_right = num_elements - len_left\n            if left_sum == divisor * len_right - right_sum:\n                if left_sum <= max_operations:\n                    maximum_divisor = max(maximum_divisor, divisor)\n    print(maximum_divisor)\n\ndef __starting_point():\n    main()\n__starting_point()\n", "score": 1.0, "codebleu": 0.3870019483661703, "crystalbleu": 0.26, "codebertscore": 0.8, "codescore": 0.08418630063533783, "surfaceSim": 0.7380647911338448, "abs_surfaceSim_minus_score": 0.2619352088661552, "source": "local", "local_type": "OP"}
{"id": "LOCAL_MBPP_711_MUT_37", "golden_code": "import os\n\ndef product_Equal(n):\n    if n < 10:\n        return False\n    prodOdd = 1\n    prodEven = 1\n    while n > 0:\n        digit = n % 10\n        prodOdd *= digit\n        n = n // 10\n        if n == 0:\n            break\n        digit = n % 10\n        prodEven *= digit\n        n = n // 10\n    if prodOdd == prodEven:\n        return True\n    return False", "generated_code": "import os\n\ndef product_Equal(n):\n    if n < 10:\n        return False\n    prodOdd = 1\n    prodEven = 1\n    while n > 0:\n        digit = n % 10\n        prodOdd *= digit\n        n = n // 10\n        if n == 0:\n            break\n        digit = n % 10\n        prodEven *= digit\n        n = n // 10\n    if prodOdd == prodEven:\n        return True\n    pass", "score": 0.3942, "codebleu": 0.961231635734711, "crystalbleu": 0.95, "codebertscore": 0.99, "codescore": 0.9937466382980347, "surfaceSim": 0.9673949579831933, "abs_surfaceSim_minus_score": 0.5731949579831933, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-4118_45", "golden_code": "A, B = map(int, input().split())\nif A < 10 and B < 10:\n  print(A*B)\nelse:\n  print(-1)", "generated_code": "\n#\n#\n# == len(A_B) = A_B.len()\n#output = min(A_B): A_B\n# = A_B[0]*B, A_B[1]*B,..., A_B^2\n# = 1398244353\n# = 2B^.5\n# = 2A\n# = 3A^2\n# 1A^2 = 4A\n# 2B^3 = 5A\n# 3A^4 = 6A\n# 4A^5 = 7A\n# 5A^6 = 8A\n# 6B^7 = 9A\n# 7A^8 = 10B\n# 8B^9 = 11B\n# 11A^10 = 12B\n# 12A^11 = 13B\n# 13B^11 = 14A\n# 14B^11 = 15A\n# 15A", "score": 0.0, "codebleu": 0.25335993033372295, "crystalbleu": 0, "codebertscore": 0.66, "codescore": 0.022314827889204025, "surfaceSim": 0.4068618645590084, "abs_surfaceSim_minus_score": 0.4068618645590084, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_398_3", "golden_code": "def Sort(sub_li): \r\n    sub_li.sort(key = lambda x: x[1]) \r\n    return sub_li ", "generated_code": "def Sort(s):\n\ts1 = s.count('z')\n\treturn True if s1 == len(s) else False\n\tpass", "score": 0.0, "codebleu": 0.251994937694475, "crystalbleu": 0, "codebertscore": 0.75, "codescore": 0.020627455785870552, "surfaceSim": 0.41758241758241754, "abs_surfaceSim_minus_score": 0.41758241758241754, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_extra_p03796_s064171222_OP_1", "golden_code": "import math\n\n\n\nN = int(eval(input()))\n\n\n\nnum = math.factorial(N)\n\n\n\nk, r = divmod(num, 10**9 + 7)\n\nprint(r)", "generated_code": "N = int(eval(input()))\n\n\n\nFACTOR = 10 ** 9 + 7\n\n\n\nnum = 1\n\nfor i in range(1, N+1):\n\n    num *= i\n\n    k, r = divmod(num, FACTOR)\n\n    num = r\n\n\n\nprint(r)", "score": 1.0, "codebleu": 0.3120396009464104, "crystalbleu": 0, "codebertscore": 0.85, "codescore": 0.8811248540878296, "surfaceSim": 0.6274509803921569, "abs_surfaceSim_minus_score": 0.37254901960784315, "source": "local", "local_type": "OP"}
{"id": "MBPP_34_8", "golden_code": "def even_num(x):\r\n  if x%2==0:\r\n     return True\r\n  else:\r\n    return False", "generated_code": "def even_num(n):\n  \n\treturn int(n * (n * 2 - 2) / 6)", "score": 0.0868, "codebleu": 0.30443484819887817, "crystalbleu": 0, "codebertscore": 0.77, "codescore": 0.10597489029169083, "surfaceSim": 0.5447058823529412, "abs_surfaceSim_minus_score": 0.45790588235294116, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_56_19", "golden_code": "def series_sum(number):\r\n total = 0\r\n total = (number * (number + 1) * (2 * number + 1)) / 6\r\n return total", "generated_code": "def series_sum(number):\n\ttotal = 0\n\tfor n in range(1,number+1):\n\t\ttotal += n**2\n\treturn total\nduplicate = set([])", "score": 1.0, "codebleu": 0.3178357152214564, "crystalbleu": 0, "codebertscore": 0.82, "codescore": 0.9937530159950256, "surfaceSim": 0.612249650675361, "abs_surfaceSim_minus_score": 0.38775034932463903, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0009_9", "golden_code": "from sys import stdin, stdout\n\nk = int(stdin.readline())\nn, m = map(int, stdin.readline().split())\nleft, right, down, up = [], [], [], []\ncoordinates = []\n\nfor i in range(k):\n    x1, y1, x2, y2 = map(int, stdin.readline().split())\n    \n    if x1 == x2:\n        if y1 < y2:\n            coordinates.append((x1, y1, x2, y2, i))\n        else:\n            coordinates.append((x2, y2, x1, y1, i))\n    else:\n        if x1 < x2:\n            coordinates.append((x1, y1, x2, y2, i))\n        else:\n            coordinates.append((x2, y2, x1, y1, i))\n    \n    left.append(coordinates[-1])\n    right.append(coordinates[-1])\n    up.append(coordinates[-1])\n    down.append(coordinates[-1])\n\nleft.sort(key = lambda x: (x[0], x[2]))\ndown.sort(key = lambda x: (x[1], x[3]))\n\nchallengers = [[], [], [], []]\ncntl, cntr, cntd, cntu = map(int, stdin.readline().split())\nlabel = 1\n\nif cntl or not cntl:\n    for i in range(cntl, -1, -1):\n        if (left[i][0], left[i][2]) == (left[cntl][0], left[cntl][2]):\n            challengers[0].append(left[i][-1])  \n        else:\n            break\n        \n    for i in range(cntl + 1, k):\n        if (left[i][0], left[i][2]) == (left[cntl][0], left[cntl][2]) and left[i][2] > left[i][0]:\n            label = 0\n        \n        if (left[i][0], left[i][2]) == (left[cntl][0], left[cntl][2]):\n            challengers[0].append(left[i][-1])  \n        else:\n            break\n\nif cntr or not cntr:\n    for i in range(k - 1 - cntr, k):\n        if (left[i][0], left[i][2]) == (left[k - 1 - cntr][0], left[k - 1 - cntr][2]):\n            challengers[1].append(left[i][-1])\n        else:\n            break\n    \n    for i in range(k - 2 - cntr, -1, -1):\n        if (left[i][0], left[i][2]) == (left[k - 1 - cntr][0], left[k - 1 - cntr][2]) and left[i][2] > left[i][0]:\n            label = 0\n        \n        if (left[i][0], left[i][2]) == (left[k - 1 - cntr][0], left[k - 1 - cntr][2]):\n            challengers[1].append(left[i][-1])\n        else:\n            break\n\n#!!!!!!!!!!!\n\nif cntd or not cntd:\n    for i in range(cntd, -1, -1):\n        if (down[i][1], down[i][3]) == (down[cntd][1], down[cntd][3]):\n            challengers[2].append(down[i][-1])\n        else:\n            break\n        \n    for i in range(cntd + 1, k):\n        if (down[i][1], down[i][3]) == (down[cntd][1], down[cntd][3]) and down[i][3] > down[i][1]:\n            label = 0\n            \n        if (down[i][1], down[i][3]) == (down[cntd][1], down[cntd][3]):\n            challengers[2].append(down[i][-1])  \n        else:\n            break\n        \nif cntu or not cntu:\n    for i in range(k - 1 - cntu, k):\n        if (down[i][1], down[i][3]) == (down[k - 1 - cntu][1], down[k - 1 - cntu][3]):\n            challengers[3].append(down[i][-1])\n        else:\n            break\n    \n    for i in range(k - 2 - cntu, -1, -1):\n        if (down[i][1], down[i][3]) == (down[k - 1 - cntu][1], down[k - 1 - cntu][3]) and down[i][3] > down[i][1]:\n            label = 0\n        \n        if (down[i][1], down[i][3]) == (down[k - 1 - cntu][1], down[k - 1 - cntu][3]):\n            challengers[3].append(down[i][-1])\n        else:\n            break\n\nans = set(challengers[0]) & set(challengers[1]) & set(challengers[2]) & set(challengers[3])\n\nif not len(ans) or not label:\n    stdout.write('-1')\nelse:\n    stdout.write(str(list(ans)[0] + 1))", "generated_code": "#-*- coding:utf-8 -*-\n\n\"\"\"\n\ncreated by shuangquan.huang at 1/9/20\n\n\"\"\"\nimport collections\nimport time\nimport os\nimport sys\nimport bisect\nimport heapq\nfrom typing import List\n\n\ndef solve(N, M, A):\n\ts = set()\n\n\tfor i in range(1, N+1):\n\t\tfor j in range(1, M+1):\n\t\t\tx, y = A[i][0], A[i][1]\n\t\t\ts.add((x, y))\n\t\t\t\n\tfor l in range(2, N+1+(M-1)):\n\t\tfor r in range(2, M+1+(N-l)):\n\t\t\tx1, y1 = A[l-1][0], A [l-1][1]\n\t\t\t\t\t\t\t\n\t\t\tx2", "score": 0.0, "codebleu": 0.08037122325071966, "crystalbleu": 0.0, "codebertscore": 0.7, "codescore": 0.03680683299899101, "surfaceSim": 0.4423774954627949, "abs_surfaceSim_minus_score": 0.4423774954627949, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0175_65", "golden_code": "a, b = map(int, input().split())\nwhile a != 0 and b != 0:\n\tif a >= 2 * b:\n\t\ta %= 2 * b\n\telif b >= 2 * a:\n\t\tb %= 2 * a\n\telse:\n\t\tbreak\nprint(a, b)", "generated_code": "import math\n\ndef __starting_point():\n\tn, m = list(map(int, input().split()))\n\ta = math.floor(n/2)\n\tb = math.floor((m/2)**2)\n\tprint(a, b)\n\n__starting_point()\n", "score": 0.0, "codebleu": 0.12568408989924068, "crystalbleu": 0, "codebertscore": 0.8, "codescore": 0.07671570777893066, "surfaceSim": 0.35884895359417657, "abs_surfaceSim_minus_score": 0.35884895359417657, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-1882_22", "golden_code": "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Fri Jan 12 18:46:09 2018\n\n@author: Sand Boa\n\"\"\"\nimport itertools\n\ndef __starting_point():\n    n:int\n    T:int\n    n, T = list(map(int,input().split()))\n    listi:list = []\n    tsum:int = 0\n    csum:int = 0\n    k:int\n    k = 1\n    a:int\n    b:int\n    t:int\n    ind:int\n    for i in range(n):\n        a,b = list(map(int,input().split()))\n        listi.append((a,b,i))\n    #print(listi)\n    listi = sorted(listi, key=lambda x: x[1])\n    #print(listi)\n    time:list = [0] * (n + 1)\n    count:list = [0] * (n + 1)\n    for (a, t, ind) in listi:\n        if k <= a:\n            tsum += t\n            time[a] += t\n            if tsum > T:\n                break\n            count[a] += 1\n            csum += 1\n            if csum == k:\n                csum -= count[k]\n                tsum -= time[k]\n                k += 1\n    max_score:int = max(csum, k - 1)\n    print (max_score,max_score,sep='\\n')\n    print(*list(itertools.islice((idx + 1 for (a, t, idx) in listi if a >= max_score),max_score)))\n\n\n\t\t\t\t    \t\t\t\t\t\t    \t \t  \t \t\t\t \t\n__starting_point()", "generated_code": "n, t = list(map(int, input().split()))\n\na = []\n\nfor i in range(n):\n\ta.append(list(map(int, input().split())))\n\nma = 0\n\nans = []\n\nflag = 0\n\nfor i  in range(n): \n\tfor j in range(i + 1, n):\n\t\tif (a[i][0] + a[j][0] > ma):\n\t\t\tans = [i]\n\t\t\tflag = 1\n\t\t\tbreak\n\t\telif (a[j][0 + a[i][0]] + a[i [[x + a[i]][1]]][1] == a[j][1]):\n\t\t\tans.append(j)\n\t\t\tflag = 2\n\t\t\tbreak\n\tif flag == 1:\n\t\tbreak\n\tma = a[i][1]\n\n", "score": 0.0, "codebleu": 0.13974098336839075, "crystalbleu": 0.15, "codebertscore": 0.72, "codescore": 0.05771308392286301, "surfaceSim": 0.5465034877615821, "abs_surfaceSim_minus_score": 0.5465034877615821, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0714_28", "golden_code": "n = int(input())\na = list(map(int,input().split()))\nfor i in range(n):\n    a[i] = (a[i], i + 1)\na.sort()\nfor i in range(n//2):\n    print(a[i][1], a[n-i-1][1])", "generated_code": "n = int(input())\na = list(map(int, input().split()))\n\ns = sum(a)\nfor i in range(n // 2):\n\ta[i] = s - a[i]\n\ts -= a[i]            \n", "score": 0.0, "codebleu": 0.39628196441802943, "crystalbleu": 0.43, "codebertscore": 0.9, "codescore": 0.10182356089353561, "surfaceSim": 0.7148382559774964, "abs_surfaceSim_minus_score": 0.7148382559774964, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-1198_6", "golden_code": "from functools import *\nfrom time import time\nfrom heapq import *\n\n# \n# def measure_time(fun):\n#     def wrapper(*args, **kwargs):\n#         begin = time()\n#         rv = fun(*args, **kwargs)\n#         end = time()\n#         print(end - begin)\n#         return rv\n#     return wrapper\n#\n#\n# def our_cache(func):\n#     memo = [-1]*(max+1)\n#\n#     @wraps(func)\n#     def wrapper(arg):\n#         if memo[arg] == -1:\n#             memo[arg] = func(arg)\n#         return memo[arg]\n#     return wrapper\n\n\ndef main():\n    n, c = [int(x) for x in input().split()]\n    a = [int(x) for x in input().split()]\n\n    if c > n:\n        print(sum(a))\n        return\n\n    b = n * [0]\n    s = 0\n    h = []\n    for i in range(n):\n        s = s + a[i] if i <= c-1 else s + a[i] - a[i-c]\n        heappush(h, (a[i], i))\n        if i <= c-2:\n            b[i] = s\n        else:\n            while i-h[0][1] >= c:\n                heappop(h)\n            v1 = b[i-c] + s - h[0][0]\n            v2 = a[i] + b[i-1]\n            b[i] = min(v1, v2)\n\n    print(b[-1])\n\n\ndef __starting_point():\n    main()\n__starting_point()", "generated_code": "def main():\n\tn, c = list(map(int, input().split()))\n\tl = list(map (int, input().lower()))\n\t\n\ts = 0\n\tdef solve(m):\n\t\tnonlocal s\n\t\tcur = 0\n\t\tfor i in range(m):\n\t\t\tcur += l[i]\n\t\tfor i2 in range(m, n):\n\t\t\tcur -= l[i2 - m]\n\t\t\tif cur < 0:\n\t\t\t\tcur = 0\n\t\t\t\tbreak\n\t\ts += cur\n\n\tfor i in range(-1, n):\n\t\tsolve(i)\n\tprint(s)\n\n\ndef __starting_point():\n\tmain()\n\n__starting_point()\n", "score": 0.012, "codebleu": 0.19771582549092803, "crystalbleu": 0.1, "codebertscore": 0.7, "codescore": 0.031309857964515686, "surfaceSim": 0.6630255467571644, "abs_surfaceSim_minus_score": 0.6510255467571644, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_MBPP_245_OP_1", "golden_code": "def max_sum(arr, n): \r\n\tMSIBS = arr[:] \r\n\tfor i in range(n): \r\n\t\tfor j in range(0, i): \r\n\t\t\tif arr[i] > arr[j] and MSIBS[i] < MSIBS[j] + arr[i]: \r\n\t\t\t\tMSIBS[i] = MSIBS[j] + arr[i] \r\n\tMSDBS = arr[:] \r\n\tfor i in range(1, n + 1): \r\n\t\tfor j in range(1, i): \r\n\t\t\tif arr[-i] > arr[-j] and MSDBS[-i] < MSDBS[-j] + arr[-i]: \r\n\t\t\t\tMSDBS[-i] = MSDBS[-j] + arr[-i] \r\n\tmax_sum = float(\"-Inf\") \r\n\tfor i, j, k in zip(MSIBS, MSDBS, arr): \r\n\t\tmax_sum = max(max_sum, i + j - k) \r\n\treturn max_sum", "generated_code": "def max_sum(sequence, length):\n    inc_sum = sequence[:]\n    for x in range(length):\n        for y in range(x):\n            if sequence[x] > sequence[y] and inc_sum[x] < inc_sum[y] + sequence[x]:\n                inc_sum[x] = inc_sum[y] + sequence[x]\n    dec_sum = sequence[:]\n    for x in range(length - 1, -1, -1):\n        for y in range(length - 1, x, -1):\n            if sequence[x] > sequence[y] and dec_sum[x] < dec_sum[y] + sequence[x]:\n                dec_sum[x] = dec_sum[y] + sequence[x]\n    max_total = float('-inf')\n    for inc, dec, val in zip(inc_sum, dec_sum, sequence):\n        max_total = max(max_total, inc + dec - val)\n    return max_total", "score": 1.0, "codebleu": 0.29476864329350283, "crystalbleu": 0.11, "codebertscore": 0.81, "codescore": 0.9936368465423584, "surfaceSim": 0.7853881278538812, "abs_surfaceSim_minus_score": 0.21461187214611877, "source": "local", "local_type": "OP"}
{"id": "LOCAL_MBPP_493_MUT_39", "golden_code": "import os\n\nimport math\ndef calculate_polygons(startx, starty, endx, endy, radius):\n    sl = (2 * radius) * math.tan(math.pi / 6)\n    p = sl * 0.5\n    b = sl * math.cos(math.radians(30))\n    w = b * 2\n    h = 2 * sl\n    startx = startx - w\n    starty = starty - h\n    endx = endx + w\n    endy = endy + h\n    origx = startx\n    origy = starty\n    xoffset = b\n    yoffset = 3 * p\n    polygons = []\n    row = 1\n    counter = 0\n    while starty < endy:\n        if row % 2 == 0:\n            startx = origx + xoffset\n        else:\n            startx = origx\n        while startx < endx:\n            p1x = startx\n            p1y = starty + p\n            p2x = startx\n            p2y = starty + (3 * p)\n            p3x = startx + b\n            p3y = starty + h\n            p4x = startx + w\n            p4y = starty + (3 * p)\n            p5x = startx + w\n            p5y = starty + p\n            p6x = startx + b\n            p6y = starty\n            poly = [\\\n                (p1x, p1y), \\\n                (p2x, p2y), \\\n                (p3x, p3y), \\\n                (p4x, p4y), \\\n                (p5x, p5y), \\\n                (p6x, p6y), \\\n                (p1x, p1y)]\n            polygons.append(poly)\n            counter += 1\n            startx += w\n        starty += yoffset\n        row += 1\n    return polygons", "generated_code": "import os\n\nimport math\ndef calculate_polygons(startx, starty, endx, endy, radius):\n    sl = (2 * radius) * math.tan(math.pi / 6)\n    p = sl * 0.5\n    b = sl * math.cos(math.radians(30))\n    w = b * 2\n    h = 2 * sl\n    startx = startx - w\n    starty = starty - h\n    endx = endx + w\n    endy = endy + h\n    origx = startx\n    origy = starty\n    xoffset = b\n    yoffset = 3 * p\n    polygons = []\n    row = 1\n    counter = 0\n    while starty < endy:\n        if row % 2 == 0:\n            startx = origx + xoffset\n        else:\n            startx = origx\n        while startx < endx:\n            p1x = startx\n            p1y = starty + p\n            p2x = startx\n            p2y = starty + (3 * p)\n            p3x = startx + b\n            p3y = starty + h\n            p4x = startx + w\n            p4y = starty + (3 / p)\n            p5x = startx + w\n            p5y = starty + p\n            p6x = startx + b\n            p6y = starty\n            poly = [\\\n                (p1x, p1y), \\\n                (p2x, p2y), \\\n                (p3x, p3y), \\\n                (p4x, p4y), \\\n                (p5x, p5y), \\\n                (p6x, p6y), \\\n                (p1x, p1y)]\n            polygons.append(poly)\n            counter += 1\n            startx += w\n        starty += yoffset\n        row += 1\n    return polygons", "score": 0.0, "codebleu": 0.9937480014850033, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9937047362327576, "surfaceSim": 0.9996162701458173, "abs_surfaceSim_minus_score": 0.9996162701458173, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_APPS_1384_19_MUT_24", "golden_code": "n = int(input())\na = list(map(int, input().split()))\np = [0] * n\np[0] = a[0]\nfor i in range(1, n):\n    p[i] = p[i - 1] + a[i]\nans = min(n, n - p[n - 1])\nfor i in range(n):\n    l = p[i]\n    r = ((n - i) - 1) - (p[n - 1] - p[i])\n    ans = min(ans, l + r)\nprint(n - ans)", "generated_code": "n = int(input())\npass\np = [0] * n\np[0] = a[0]\nfor i in range(1, n):\n    p[i] = p[i - 1] + a[i]\nans = min(n, n - p[n - 1])\nfor i in range(n):\n    l = p[i]\n    r = ((n - i) - 1) - (p[n - 1] - p[i])\n    ans = min(ans, l + r)\nprint(n - ans)", "score": 0.0, "codebleu": 0.7913049704944293, "crystalbleu": 0.81, "codebertscore": 0.98, "codescore": 0.993893027305603, "surfaceSim": 0.8882646691635455, "abs_surfaceSim_minus_score": 0.8882646691635455, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_PIE_p03371_s026349855_MUT_9", "golden_code": "from collections import defaultdict\nfrom collections import deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\ndef I():\n    return int(sys.stdin.readline())\ndef LS():\n    return list(map(list, sys.stdin.readline().split()))\ndef S():\n    return list(sys.stdin.readline())[:-1]\ndef IR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = I()\n    return l\ndef LIR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = LI()\n    return l\ndef SR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = S()\n    return l\ndef LSR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = LS()\n    return l\nsys.setrecursionlimit(1000000)\nmod = 1000000007\ndef A():\n    return\ndef B():\n    return\ndef C():\n    return\ndef D():\n    return\ndef E():\n    return\ndef F():\n    (a, b, c, X, Y) = LI()\n    ans = float('inf')\n    for z in range(300001):\n        if z % 2 == 0:\n            m = c * z\n            x = z // 2\n            y = z // 2\n            m += a * max(0, X - x)\n            m += b * max(0, Y - y)\n            if m < ans:\n                ans = m\n    print(ans)\n    return\ndef G():\n    n = I()\n    x = LI()\n    f = [(i, x[i]) for i in range(n)]\n    f.sort(key=lambda x: (x[1]))\n    g = [(f[i][0], i) for i in range(n)]\n    g.sort(key=lambda x: (x[0]))\n    for i in range(n):\n        if g[i][1] < n // 2:\n            print(f[n // 2][1])else:print(f[(n // 2) - 1][1])\n    return\ndef H():\n    return\ndef I_():\n    return\ndef J():\n    return", "generated_code": "from collections import defaultdict\nfrom collections import deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\ndef I():\n    return int(sys.stdin.readline())\ndef LS():\n    return list(map(list, sys.stdin.readline().split()))\ndef S():\n    return list(sys.stdin.readline())[:-1]\ndef IR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = I()\n    return l\ndef LIR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = LI()\n    return l\ndef SR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = S()\n    return l\ndef LSR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = LS()\n    return l\nsys.setrecursionlimit(1000000)\nmod = 1000000007\ndef A():\n    return\ndef B():\n    return\ndef C():\n    return\ndef D():\n    return\ndef E():\n    return\ndef F():\n    (a, b, c, X, Y) = LI()\n    ans = float('inf')\n    for z in range(300001):\n        if z % 2 == 0:\n            m = c * z\n            x = z // 2\n            y = z / 2\n            m += a * max(0, X - x)\n            m += b * max(0, Y - y)\n            if m < ans:\n                ans = m\n    print(ans)\n    return\ndef G():\n    n = I()\n    x = LI()\n    f = [(i, x[i]) for i in range(n)]\n    f.sort(key=lambda x: (x[1]))\n    g = [(f[i][0], i) for i in range(n)]\n    g.sort(key=lambda x: (x[0]))\n    for i in range(n):\n        if g[i][1] < n // 2:\n            print(f[n // 2][1])else:print(f[(n // 2) - 1][1])\n    return\ndef H():\n    return\ndef I_():\n    return\ndef J():\n    return", "score": 0.0, "codebleu": 0.9950684650874879, "crystalbleu": 1.0, "codebertscore": 1.0, "codescore": 0.9934478402137756, "surfaceSim": 0.49969097651421507, "abs_surfaceSim_minus_score": 0.49969097651421507, "source": "local", "local_type": "MUT"}
{"id": "MBPP_6_9", "golden_code": "def are_Rotations(string1,string2): \r\n    size1 = len(string1) \r\n    size2 = len(string2) \r\n    temp = '' \r\n    if size1 != size2: \r\n        return False\r\n    temp = string1 + string1 \r\n    if (temp.count(string2)> 0): \r\n        return True\r\n    else: \r\n        return False", "generated_code": "def are_Rotations(s, arr):\n\tfor x in arr:\n\t\ttry:\n\t\t\ts = s.replace(x, b[0])\n\t\texcept:\n\t\t\treturn True", "score": 0.0282, "codebleu": 0.052179321868824395, "crystalbleu": 0, "codebertscore": 0.71, "codescore": 0.01840757392346859, "surfaceSim": 0.5199936528086322, "abs_surfaceSim_minus_score": 0.4917936528086322, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_130_22_OP_1", "golden_code": "n, m = list(map(int,input().split()))\nq = [str(input()) for i in range(n)]\nk=0\nt=True\nu=0\nli=vi=n*m\npi=ni=0\nfor i in range(n):\n    t=False\n    u=0\n    for j in q[i]:\n        if j=='B':\n            if u<li:\n                li=u\n            if u>pi:\n                pi=u\n            if i<vi:\n                vi=i\n            if i>ni:\n                ni=i\n            k+=1\n        u+=1\nif (max(ni-vi, pi-li)+1)>n or (max(ni-vi, pi-li)+1)>m:\n    print(-1)\nelif k==0:\n    print(1)\nelse:\n    print((max(ni-vi, pi-li)+1)**2-k)", "generated_code": "n, m = map(int, input().split())\nrows = [input() for _ in range(n)]\nblack_count = 0\nmin_row = min_col = float('inf')\nmax_row = max_col = -1\nfor row_index, row in enumerate(rows):\n    for col_index, char in enumerate(row):\n        if char == 'B':\n            black_count += 1\n            min_row = min(min_row, row_index)\n            max_row = max(max_row, row_index)\n            min_col = min(min_col, col_index)\n            max_col = max(max_col, col_index)\nif black_count == 0:\n    print(1)\nelse:\n    side_length = max(max_row - min_row, max_col - min_col) + 1\n    if side_length > n or side_length > m:\n        print(-1)\n    else:\n        print(side_length ** 2 - black_count)", "score": 1.0, "codebleu": 0.21270711053194194, "crystalbleu": 0.19, "codebertscore": 0.78, "codescore": 0.303679496049881, "surfaceSim": 0.6704467353951891, "abs_surfaceSim_minus_score": 0.32955326460481094, "source": "local", "local_type": "OP"}
{"id": "APPS_test-0081_56", "golden_code": "a, b = input().split()\na, b = int(a), int(b)\na, b = min(a, b), max(a, b)\n\ndef eu(a, b):\n    if a == 0:\n        return b\n    if b == 0:\n        return a\n    if a > b:\n        return eu(a%b, b)\n    return eu(a, b%a)\n\nopt = b - a\nfactor = []\ni = 1\nwhile i**2 < opt+1:\n    if opt % i == 0:\n        factor.append(i)\n        factor.append(int(opt/i))\n    i+=1\n\ntarget = a * b / eu(a, b)\ndrop = 0\n\nfor i in factor:\n    firstupd = a - (a % i) + i\n    secondupd = b - (b % i) + i\n    dres = firstupd * int(secondupd/eu(firstupd,secondupd))\n    if dres <= target:\n        if dres == target:\n            drop = min(i-(a%i),drop)\n        else:\n            target = dres\n            drop = i-(a%i)\nprint(drop)", "generated_code": "a,b=map(int,input().split())\nif a==b:\n\tprint(0)\n\treturn\np=int(a*b**(1/2))\nq=1\nwhile p%q!=0:\n\tq=(p)//q\n\tif q%a==0:\n\t\tprint(q)\n\t\treturn\n", "score": 0.0, "codebleu": 0.08534900041734099, "crystalbleu": 0.02, "codebertscore": 0.71, "codescore": 0.03891477361321449, "surfaceSim": 0.5242946708463949, "abs_surfaceSim_minus_score": 0.5242946708463949, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_707_11_MUT_19", "golden_code": "(n, m) = list(map(int, input().split()))\nx = tuple(map(int, input().split()))\ny = min(x)\na = 0\nfor xi in x:\n    b = xi - y\n    while b:\n        (a, b) = (b, a % b)\nj = 1\nfor p in input().split():\n    if a % int(p):\n        j += 1\n        continue\n    print('YES')\n    print(y, j)\n    break\nelse:\n    print('NO')", "generated_code": "(n, m) = list(map(int, input().split()))\npass\ny = min(x)\na = 0\nfor xi in x:\n    b = xi - y\n    while b:\n        (a, b) = (b, a % b)\nj = 1\nfor p in input().split():\n    if a % int(p):\n        j += 1\n        continue\n    print('YES')\n    print(y, j)\n    break\nelse:\n    print('NO')", "score": 0.0, "codebleu": 0.7841834268100671, "crystalbleu": 0.82, "codebertscore": 0.98, "codescore": 0.6598238945007324, "surfaceSim": 0.9279589649364568, "abs_surfaceSim_minus_score": 0.9279589649364568, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_MBPP_245_MUT_55", "golden_code": "import os\n\ndef max_sum(arr, n):\n    MSIBS = arr[:]\n    for i in range(n):\n        for j in range(0, i):\n            if (arr[i] > arr[j] and MSIBS[i] < MSIBS[j] + arr[i]):\n                MSIBS[i] = MSIBS[j] + arr[i]\n    MSDBS = arr[:]\n    for i in range(1, n + 1):\n        for j in range(1, i):\n            if (arr[-i] > arr[-j] and MSDBS[-i] < MSDBS[-j] + arr[-i]):\n                MSDBS[-i] = MSDBS[-j] + arr[-i]\n    max_sum = float('-Inf')\n    for (i, j, k) in zip(MSIBS, MSDBS, arr):\n        max_sum = max(max_sum, (i + j) - k)\n    return max_sum", "generated_code": "import os\n\ndef max_sum(arr, n):\n    MSIBS = arr[:]\n    for i in range(n):\n        for j in range(0, i):\n            if (arr[i] > arr[j] and MSIBS[i] < MSIBS[j] + arr[i]):\n                MSIBS[i] = MSIBS[j] + arr[i]\n    MSDBS = arr[:]\n    for i in range(1, n + 1):\n        for j in range(1, i):\n            if (arr[-i] > arr[-j] and MSDBS[-i] < MSDBS[-j] + arr[-i]):\n                MSDBS[-i] = MSDBS[-j] + arr[-i]\n    max_sum = float('-Inf')\n    for (i, j, k) in zip(MSIBS, MSDBS, arr):\n        pass\n    return max_sum", "score": 0.0, "codebleu": 0.8918614848925721, "crystalbleu": 0.91, "codebertscore": 0.99, "codescore": 0.7594308853149414, "surfaceSim": 0.943939393939394, "abs_surfaceSim_minus_score": 0.943939393939394, "source": "local", "local_type": "MUT"}
{"id": "MBPP_50_13", "golden_code": "def mutiple_tuple(nums):\r\n    temp = list(nums)\r\n    product = 1 \r\n    for x in temp:\r\n        product *= x\r\n    return product", "generated_code": "def mutiple_tuple(n):\n\treturn n in [0,1]\n\"\"\"\ndp = [0, 1]\nfor i in range(2, 31):\n\tdp.append(dp[-1] + n * 9**i)\n\tfor j in range(10):\n\t\tdp.pop()\n\n\"\"\"\n\n\n\"\"\"\na link:\n\t1) solve the first line (1)\n\t2) solve the second line (2)\n\t3) solve the third line (3)\n\t4) solve the fourth line (3): \"<\" line represents the current position (starting_point) and the finishing_point)\n\t5) return the result\n\"\"\"", "score": 0.0074, "codebleu": 0.06832154368090698, "crystalbleu": 0, "codebertscore": 0.7, "codescore": 0.033805135637521744, "surfaceSim": 0.30598510882016033, "abs_surfaceSim_minus_score": 0.2985851088201603, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_1085_39_MUT_27", "golden_code": "n = int(input())\ndef make_divisors(n):\n    divisors = []\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n // i)\n    return divisors\nimport sys\nsys.setrecursionlimit(10 ** 7)\ndef func(N, d):\n    if d == 1:\n        return False\n    while N > 1:\n        if N % d == 0:\n            N //= d\n        \n        elif (N - 1) % d == 0:\n            N = 1\n        else:\n            N = 0\n    return True if N == 1 else False\n\nans = len(set(make_divisors(n - 1))) - 1\nl = set(make_divisors(n))\nfor li in l:\n    if func(n, li):\n        ans += 1\nprint(ans)", "generated_code": "n = int(input())\ndef make_divisors(n):\n    divisors = []\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n // i)\n    return divisors\nimport sys\nsys.setrecursionlimit(10 ** 7)\ndef func(N, d):\n    if d == 1:\n        return False\n    while N > 1:\n        if N % d == 0:\n            N //= d\n        \n        elif (N - 1) % d == 0:\n            N = 1\n        else:\n            N = 0break\n    return True if N == 1 else False\n\nans = len(set(make_divisors(n - 1))) - 1\nl = set(make_divisors(n))\nfor li in l:\n    if func(n, li):\n        ans += 1\nprint(ans)", "score": 0.0, "codebleu": 0.9674167965954252, "crystalbleu": 0.97, "codebertscore": 1.0, "codescore": 0.9937596917152405, "surfaceSim": 0.4961832061068702, "abs_surfaceSim_minus_score": 0.4961832061068702, "source": "local", "local_type": "MUT"}
{"id": "MBPP_4_1", "golden_code": "def remove_list_range(list1, leftrange, rigthrange):\r\n   result = [i for i in list1 if (min(i)>=leftrange and max(i)<=rigthrange)]\r\n   return result", "generated_code": "def remove_list_range(list1, leftrange, rigthrange):\n\treturn [*[el for el in list1 if type(el) is int]]", "score": 0.3014, "codebleu": 0.27919102237336973, "crystalbleu": 0, "codebertscore": 0.89, "codescore": 0.2553732693195343, "surfaceSim": 0.6074324324324325, "abs_surfaceSim_minus_score": 0.3060324324324325, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_40_3", "golden_code": "import datetime\r\ndef check_date(m, d, y):\r\n    try:\r\n        m, d, y = map(int, (m, d, y))\r\n        datetime.date(y, m, d)\r\n        return True\r\n    except ValueError:\r\n        return False", "generated_code": "import datetime\ndef check_date(m, d, y):\n\tif m and d and y and m and d:\n\t\treturn True\n\treturn False\ncandidates = {\n\t\t'english': ['01', '02', '03'],\n\t\t'21': ['01','02','03','04'],\n\t\t\n\t}", "score": 0.3103, "codebleu": 0.33053020290649776, "crystalbleu": 0, "codebertscore": 0.8, "codescore": 0.3012215793132782, "surfaceSim": 0.4883827927306188, "abs_surfaceSim_minus_score": 0.17808279273061878, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0854_30", "golden_code": "def sum(a):\n    s = 0\n    for i in a:\n        s += i\n    return s\n\nn, T = map(int, input().split())\na = list(map(int, input().split()))\n\nsum = sum(a)\n\nk = 0\nk += n * (T // sum)\nT %= sum\n\nnew_a = []\nnew_sum = 0\nch = True\nwhile ch:\n    for i in range(n):\n        if a[i] <= T:\n            new_a.append(a[i])\n            new_sum += a[i]\n            k += 1\n            T -= a[i]\n\n    n = len(new_a)\n\n    if n == 0:\n        ch = False\n        break\n\n    sum = new_sum\n    a = new_a\n    new_a = []\n    new_sum = 0\n\n    k += n * (T // sum)\n    T %= sum\n\n\nprint(k)", "generated_code": "n, t = map(int, input().split())\na = list(map(int, input(\"\").strip().split()))\nd = [0]*n\nb = [0]\nfor i in range(n):\n\td[i] = a[i]\n\tif i + 1 < n:\n\t\td[i+1] = max(d[i], a[i+1])\nans = 0\nfor i in d:\n\tans += i\nprint(ans)\n", "score": 0.1552, "codebleu": 0.2076246935224726, "crystalbleu": 0.17, "codebertscore": 0.77, "codescore": 0.057617660611867905, "surfaceSim": 0.6029676258992805, "abs_surfaceSim_minus_score": 0.44776762589928054, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0077_29", "golden_code": "n=int(input())\na=list(map(int,input().split()))\ns=0\nb=0\nc=0\nfor i in a:\n    if i>0:\n        s+=i\n        if i%2!=0:\n            if b>0:\n                b=min(b,i)\n            if b==0:\n                b=i\n    if i<0 and i%2!=0:\n        if c<0:\n            c=max(c,i)\n        if c==0:\n            c=i\nif s%2!=0:\n    print(s)\nelse:\n    if (abs(c)<b or b==0) and c!=0:\n        s=s+c\n    else:\n        s=s-b\n    print(s)", "generated_code": "n = int(input())\na = list(map(int, input().split()))\n\ns = 0\nminn = a[0]\nfor i in range(n):\n\tif a[i] % 2 == 1:\n\t\ts += i\n\tminn = min(minn, a[i])\n\nprint(s - minn)\n", "score": 0.0, "codebleu": 0.19959515062977995, "crystalbleu": 0.16, "codebertscore": 0.78, "codescore": 0.06406556814908981, "surfaceSim": 0.656997219647822, "abs_surfaceSim_minus_score": 0.656997219647822, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-1943_1", "golden_code": "n = int(input())\nm = 1 << n\np = [list(map(int, input().split())) for i in range(m)]\nu, x = [1] * m, [0] * m\nv, y = u[:], x[:]\nfor i in range(n):\n    d = 1 << i\n    for j in range(m):\n        s = d * (j // d ^ 1)\n        v[j] = u[j] * sum(u[k] * p[j][k] for k in range(s, s + d)) / 100\n        y[j] = max(x[s: s + d]) + x[j] + v[j] * d\n    u, v, x, y = v, u, y, x\nprint(max(x))", "generated_code": "n = int(input())\np = []\nfor i in range(n):\n\tp.append(list(map(int, input().split())))\nsm = 0\nl = [0] * n\nfor i in reversed(range(n)):\n\tsm += p[i][l[i]]\n\tl[i] += p[i].index(sm) + 1\nfor i in l:\n\tprint(i, end=\" \")\nprint()\n", "score": 0.0, "codebleu": 0.17227360525752494, "crystalbleu": 0.13, "codebertscore": 0.8, "codescore": 0.31231755018234253, "surfaceSim": 0.5556048069345941, "abs_surfaceSim_minus_score": 0.5556048069345941, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-3764_1", "golden_code": "n, k, x = map(int, input().split())\nrangers = list(map(int, input().split()))\nfor i in range(min(k, 8 + (k & 3))):\n\trangers.sort()\n\trangers = [rangers[i] if (i & 1) else rangers[i] ^ x for i in range(n)]\nrangers.sort()\nprint(rangers[-1], rangers[0])", "generated_code": "def main():\n\tn, k, x = list(map(int, input().split()))\n\tl, r, s = list(map (int, input().from_line())), [], []\n\tfor i in range(n):\n\t\ts.append(l[i] ^ x)\n\tfor _ in range(k):\n\t\ttmp = int(1 << (x.bit_length() - 1))\n\t\tl.append(tmp)\n\t\tfor i in range((x.bit_depth() - 1) * 2 + 1):\n\t\t\td = tmp >> i & 1\n\t\t\tl.append(l [i] ^ tmp)\n\ti, j = 0, 0\n\tfor k in range(min(k, x.bit_length())):\n\t\tj = i ^ 1\n\t\tif k:\n\t\t\tl[j] += 1\n\t\ti += 1\n\t", "score": 0.0, "codebleu": 0.3049013821749213, "crystalbleu": 0.19, "codebertscore": 0.78, "codescore": 0.018308201804757118, "surfaceSim": 0.5229916253101736, "abs_surfaceSim_minus_score": 0.5229916253101736, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_2645_55_MUT_12", "golden_code": "ans = 0\n\nfor (i, c) in enumerate(input()):\n    if (i % 2 == 0 and c == 'p'):\n        ans -= 1elif (i % 2 == 1 and c == 'g'):ans += 1\n\nprint(ans)", "generated_code": "ans = 0\n\nfor (i, c) in reversed(enumerate(input())):\n    if (i % 2 == 0 and c == 'p'):\n        ans -= 1elif (i % 2 == 1 and c == 'g'):ans += 1\n\nprint(ans)", "score": 0.0, "codebleu": 0.8401161982176668, "crystalbleu": 0, "codebertscore": 0.98, "codescore": 0.993572473526001, "surfaceSim": 0.4675324675324675, "abs_surfaceSim_minus_score": 0.4675324675324675, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-1424_35", "golden_code": "def dif(x, y):\n    c = 0\n    while x != 0 or y!= 0:\n        if x % 2 != y % 2:\n            c += 1\n        x //= 2\n        y //= 2\n    return c\n\nn, m, k = map(int, input().split())\nx = [int(input()) for i in range(m + 1)]\ncnt = 0\nfor i in range(m):\n    if dif(x[i], x[m]) <= k:\n        cnt += 1\nprint(cnt)", "generated_code": "n, m, k = list(map(int, input().split()))\n\nintegers = []\n\nfor i in range(n):\n\tintegers.append(int(input()))\n\ncurrent = 0\n\nans = 0\n\nfor i  in range(m):\n\t#print(i + 1,current)\n\tif integers[i]!= current:\n\t\tans += 1\n\t\tcurrent = integers[i]\n\telse:\n\t\tcurrent += 1\n\nprint(ans)\n", "score": 0.044, "codebleu": 0.26488707191175337, "crystalbleu": 0.25, "codebertscore": 0.79, "codescore": 0.3103259801864624, "surfaceSim": 0.5279605263157895, "abs_surfaceSim_minus_score": 0.4839605263157895, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_2_26", "golden_code": "def min_Num(arr,n):  \r\n    odd = 0\r\n    for i in range(n): \r\n        if (arr[i] % 2): \r\n            odd += 1 \r\n    if (odd % 2): \r\n        return 1\r\n    return 2", "generated_code": "def min_Num(arr,n):  \n\tres = []\n\tfor i in range(len(arr)):\n\t\tif arr[i]%2==0:\n\t\t\tres.append(i)\n\treturn sum(res)", "score": 0.0527, "codebleu": 0.207193800066105, "crystalbleu": 0, "codebertscore": 0.83, "codescore": 0.07386910915374756, "surfaceSim": 0.7299430641821947, "abs_surfaceSim_minus_score": 0.6772430641821947, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_497_2", "golden_code": "import cmath\r\ndef angle_complex(a,b):\r\n  cn=complex(a,b)\r\n  angle=cmath.phase(a+b)\r\n  return angle", "generated_code": "import cmath\ndef angle_complex(a,b):\n\treturn abs(cmath.gcd(a, b)[1]) * 360 if b else None\nUSTT = True", "score": 0.0, "codebleu": 0.36653814030865134, "crystalbleu": 0, "codebertscore": 0.84, "codescore": 0.01834539882838726, "surfaceSim": 0.6123762376237624, "abs_surfaceSim_minus_score": 0.6123762376237624, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_4620_17_MUT_5", "golden_code": "n = int(input())\ngraph = []\ntime = 0\nfor i in range(n - 1):\n    (c, s, f) = map(int, input().split())\n    graph.append([i, c, s, f])\n\ndef shortest_path(start, end, times):\n    if start == end:\n        return times\n    elif times <= graph[start][2]:\n        times = graph[start][2] + graph[start][1]\n        return shortest_path(start + 1, end, times)\n    elif times % graph[start][3] == 0:\n        times += graph[start][1]\n        return shortest_path(start + 1, end, times)\n    else:\n        times = ((times + graph[start][3]) - (times % graph[start][3])) + graph[start][1]\n        return shortest_path(start + 1, end, times)\n\n\nfor i in range(n):\n    print(shortest_path(i, n - 1, 0))", "generated_code": "n = int(input())\ngraph = []\ntime = 0\nfor i in range(n - 1):\n    (c, s, f) = map(int, input().split())\n    graph.append([i, c, s, f])\n\ndef shortest_path(start, end, times):\n    if start == end:\n        return times\n    elif times <= graph[start][2]:\n        times = graph[start][2] + graph[start][1]\n        return shortest_path(start + 1, end, times)\n    elif times % graph[start][3] == 0:\n        times += graph[start][1]\n        return shortest_path(start - 1, end, times)\n    else:\n        times = ((times + graph[start][3]) - (times % graph[start][3])) + graph[start][1]\n        return shortest_path(start + 1, end, times)\n\n\nfor i in range(n):\n    print(shortest_path(i, n - 1, 0))", "score": 0.0458, "codebleu": 0.986296521056131, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9936605095863342, "surfaceSim": 0.9992700729927007, "abs_surfaceSim_minus_score": 0.9534700729927007, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_PIE_extra_p03038_s890208193_OP_1", "golden_code": "from collections import Counter,defaultdict,deque\n\nfrom heapq import heapify,heappop,heappush\n\nfrom bisect import bisect_left,bisect_right\n\nimport sys,math,itertools,string,queue\n\nsys.setrecursionlimit(10**8)\n\nmod = 10**9+7\n\ndef inp(): return int(sys.stdin.readline())\n\ndef inpl(): return list(map(int, sys.stdin.readline().split()))\n\ndef inpl_str(): return list(sys.stdin.readline().split())\n\ndef inpln(n): return list(int(sys.stdin.readline()) for i in range(n))\n\n\n\nn,m = inpl()\n\na = inpl()\n\nb = [0] * m\n\nfor i in range(m):\n\n    x,y = inpl()\n\n    b[i] = [x,y]\n\na.sort()\n\nb.sort(key=lambda x:x[1], reverse = True)\n\nres = sum(a)\n\ni = 0\n\nj = 0\n\nwhile True:\n\n    # print(i,j)\n\n    if a[i] < b[j][1]:\n\n        res += b[j][1] - a[i]\n\n        i += 1\n\n    else:\n\n        break\n\n    b[j][0] -= 1\n\n    if b[j][0] == 0:\n\n        j += 1\n\n    if i >= n or j >= m:\n\n        break\n\nprint(res)\n", "generated_code": "from collections import Counter,defaultdict,deque\n\nfrom heapq import heappop,heappush,heapify\n\nfrom bisect import bisect_left,bisect_right \n\nimport sys,math,itertools,fractions,pprint\n\nsys.setrecursionlimit(10**8)\n\nmod = 10**9+7\n\nINF = float('inf')\n\ndef inp(): return int(sys.stdin.readline())\n\ndef inpl(): return list(map(int, sys.stdin.readline().split()))\n\n\n\nn,m = inpl()\n\na = inpl()\n\na.sort()\n\nbc = [inpl() for _ in range(m)]\n\nbc.sort(key = lambda x:x[1], reverse = True)\n\nlm = sum(x[1] for x in bc)\n\nnow = 0\n\nalt = 0\n\nwhile now < n and alt < m:\n\n    c,b = bc[alt]\n\n    if a[now] > b:\n\n        break\n\n    else:\n\n        a[now] = b\n\n    bc[alt][0] -= 1\n\n    if bc[alt][0] == 0:\n\n        alt += 1\n\n    now += 1\n\nprint((sum(a)))\n", "score": 1.0, "codebleu": 0.4422076496413779, "crystalbleu": 0.44, "codebertscore": 0.91, "codescore": 0.5596752762794495, "surfaceSim": 0.7410676532769556, "abs_surfaceSim_minus_score": 0.25893234672304444, "source": "local", "local_type": "OP"}
{"id": "MBPP_72_40", "golden_code": "def Average(lst): \r\n    return sum(lst) / len(lst) ", "generated_code": "def Average(lst): \n\tsum = 0\n\tfor n in lst:\n\t\tsum += n\n\treturn sum/len(lst)\nh=lambda: hidden(''.join(map(str,input().split())))", "score": 1.0, "codebleu": 0.40894047659068655, "crystalbleu": 0, "codebertscore": 0.84, "codescore": 0.9933324456214905, "surfaceSim": 0.4920634920634921, "abs_surfaceSim_minus_score": 0.5079365079365079, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0955_26", "golden_code": "n = int(input())\n\ncs = []\nvs = []\n\nfor i in range(n):\n    c, v = input().split(' ')\n    c = int(c)\n\n    cs += [c]\n    vs += [set(v)]\n\nBigInt = 10 ** 10\nans = BigInt\n\nfor opt in ['A|B|C', 'AB|C', 'AC|B', 'BC|A', 'ABC']:\n    opt = [set(s) for s in opt.split('|')]\n    cur = 0\n\n    for group in opt:\n        minCost = BigInt\n\n        for c, v in zip(cs, vs):\n            if v.issuperset(group) and c < minCost:\n                minCost = c\n\n        if minCost == BigInt:\n            cur = BigInt\n            break\n\n        cur += minCost\n\n    if cur < ans:\n        ans = cur\n\n    #print(opt, cur)\n    \nprint(-1 if ans == BigInt else ans)", "generated_code": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\nimport collections\nimport bisect\nimport math\nimport heapq\nimport itertools\nimport sys\nimport random\nimport re\n#\n# /usr/bin/python3\n# -~- /usr/bin python3\n#\n# for _ in range(int(input())):\n#     n=int(input())\n#     s=list(map(str,input().split()))\n#     dic={'A':0,'B':0,'C':0}\n#     for i in s:\n#         dic[i]+=1\n#     res=dic['C']-dic['B']-dic('A')\n#     if res>=2:\n#         print(-1)\n#     else:\n#         ans=0\n", "score": 0.0, "codebleu": 0.2555278112155598, "crystalbleu": 0, "codebertscore": 0.69, "codescore": 0.01826336234807968, "surfaceSim": 0.24652448657187992, "abs_surfaceSim_minus_score": 0.24652448657187992, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_54_15", "golden_code": "def remove_duplic_list(l):\r\n    temp = []\r\n    for x in l:\r\n        if x not in temp:\r\n            temp.append(x)\r\n    return temp", "generated_code": "def remove_duplic_list(L):\n\ta = list()\n\t\t\t\n\tfor x in L:    \n\t\tif x not in a:\n\t\t\ta.append(x)\n\t\telif x in b:\n\t\t\ta_.remove(x)    \n\treturn a", "score": 1.0, "codebleu": 0.37674805077470613, "crystalbleu": 0, "codebertscore": 0.88, "codescore": 0.8254578113555908, "surfaceSim": 0.7826797385620915, "abs_surfaceSim_minus_score": 0.2173202614379085, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_126_OP_2", "golden_code": "def is_sorted(lst):\n    '''\n    Given a list of numbers, return whether or not they are sorted\n    in ascending order. If list has more than 1 duplicate of the same\n    number, return False. Assume no negative numbers and only integers.\n\n    Examples\n    is_sorted([5]) ➞ True\n    is_sorted([1, 2, 3, 4, 5]) ➞ True\n    is_sorted([1, 3, 2, 4, 5]) ➞ False\n    is_sorted([1, 2, 3, 4, 5, 6]) ➞ True\n    is_sorted([1, 2, 3, 4, 5, 6, 7]) ➞ True\n    is_sorted([1, 3, 2, 4, 5, 6, 7]) ➞ False\n    is_sorted([1, 2, 2, 3, 3, 4]) ➞ True\n    is_sorted([1, 2, 2, 2, 3, 4]) ➞ False\n    '''\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1 \n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False", "generated_code": "def is_sorted(seq):\n    '''\n    Given a list of numbers, return whether or not they are sorted\n    in ascending order. If list has more than 1 duplicate of the same\n    number, return False. Assume no negative numbers and only integers.\n    '''\n    from collections import Counter\n    counts = Counter(seq)\n    if any(v > 2 for v in counts.values()):\n        return False\n    return all(a <= b for a, b in zip(seq, seq[1:]))", "score": 1.0, "codebleu": 0.23844330793359178, "crystalbleu": 0, "codebertscore": 0.79, "codescore": 0.8453788161277771, "surfaceSim": 0.5684238755650908, "abs_surfaceSim_minus_score": 0.4315761244349092, "source": "local", "local_type": "OP"}
{"id": "MBPP_23_16", "golden_code": "def same_Length(A,B): \r\n    while (A > 0 and B > 0): \r\n        A = A / 10; \r\n        B = B / 10; \r\n    if (A == 0 and B == 0): \r\n        return True; \r\n    return False; ", "generated_code": "def same_Length(A,B): \n\tif len(str(A))==len(str(B)): \n\t\treturn True\n\treturn False\nss = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 14, 15, 16, 18, 20, 21, 22, 25, 26, 29, 30, 34, 38, 41, 43, 46, 48, 50, 52, 53, 58, 60, 62, 65, 67, 70, 72, 79, 83, 82, 89, 90, 97, 101, 103, 107, 109, 113, 116, 105, 108, 109, 122, 129, 133, 137, 146, 148, 152, 157, 163, 168, 173, 179, 181, 191, 193, 197, 199, 211, 213, 215, 217, 226, 229, 232, 233, 234, 241, 235, 237, 238, 249, 29, 211, 231, 233, 239, 241, 255, 257, 261, 269, 272, 273, 277, 281, 292, 293, 307, 311, 313]\nlet = lambda x, y: x % 10 == 0 and y % 10 == 1\nmod = lambda x: x % 3 == 0 and x <= 8", "score": 0.628, "codebleu": 0.22474965686564674, "crystalbleu": 0, "codebertscore": 0.65, "codescore": 0.5851005911827087, "surfaceSim": 0.47776033490319203, "abs_surfaceSim_minus_score": 0.15023966509680797, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-1772_80", "golden_code": "n = int(input())\ns = list(map(int, input().split()))\n\noddd = 0\nevend = 0\n\nfor i in range(n):\n if s[i] % 2 == 0:\n  oddd += 1\n else:\n  evend += 1\nif evend == 0:\n print(0)\nelse:\n if oddd == 0:\n  print(evend // 3)\n else:\n  if oddd < evend:\n   print(oddd + (evend - oddd) // 3)\n  else:\n   print(evend)", "generated_code": "n = int(input())\na = list(map(int, input().split()))\n\nb = []\nfor i in a:\n\tb.append(i)\n\ncount = 0\npre = 0\nfor i in range(0, len(b)):\n\tif b[i] > pre:\n\t\tcount += 1\n\t\tpre = b[i]\n\telse:\n\t\tpre = max(pre, b[i])\n\nprint(count)\n", "score": 0.0308, "codebleu": 0.3066225755167345, "crystalbleu": 0.26, "codebertscore": 0.8, "codescore": 0.15538445115089417, "surfaceSim": 0.5985360360360361, "abs_surfaceSim_minus_score": 0.5677360360360361, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_1384_19_MUT_18", "golden_code": "n = int(input())\na = list(map(int, input().split()))\np = [0] * n\np[0] = a[0]\nfor i in range(1, n):\n    p[i] = p[i - 1] + a[i]\nans = min(n, n - p[n - 1])\nfor i in range(n):\n    l = p[i]\n    r = ((n - i) - 1) - (p[n - 1] - p[i])\n    ans = min(ans, l + r)\nprint(n - ans)", "generated_code": "n = int(input())\na = list(map(int, input().split()))\np = [0] * n\np[0] = a[0]\nfor i in range(1, n):\n    p[i] = p[i - 1] + a[i]\nans = min(n, n - p[n - 1])\nfor i in range(n):\n    l = p[i]\n    r = ((n - i) - 1) - (p[n - 1] - p[i])\n    ans = min(ans, l + r)\n    break\nprint(n - ans)", "score": 0.0823, "codebleu": 0.9734915158529482, "crystalbleu": 0.94, "codebertscore": 1.0, "codescore": 0.9938283562660217, "surfaceSim": 0.9613918973124749, "abs_surfaceSim_minus_score": 0.8790918973124748, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_PIE_extra_p03796_s873197292_OP_1", "golden_code": "import math\n\nprint((math.factorial(int(eval(input())))%(10**9+7)))", "generated_code": "ans=1\n\nn=int(eval(input()))\n\nfor i in range(1,n+1):\n\n    ans*=i\n\n    ans=ans%(10**9+7)\n\nprint(ans)", "score": 1.0, "codebleu": 0.2375, "crystalbleu": 0, "codebertscore": 0.8, "codescore": 0.9307361841201782, "surfaceSim": 0.4614512471655329, "abs_surfaceSim_minus_score": 0.5385487528344671, "source": "local", "local_type": "OP"}
{"id": "MBPP_7_11", "golden_code": "def check_subset(list1,list2): \r\n    return all(map(list1.__contains__,list2)) ", "generated_code": "def check_subset(a,b):\n\tfor i in a:\n\t\tif i in b:\n\t\t\treturn True\n\treturn False", "score": 0.9628, "codebleu": 0.3063863644740162, "crystalbleu": 0, "codebertscore": 0.81, "codescore": 0.9668353796005249, "surfaceSim": 0.42953586497890295, "abs_surfaceSim_minus_score": 0.533264135021097, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_4638_24_MUT_31", "golden_code": "(n, c) = [int(x) for x in input().split()]\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\ndpst = [0] * (n + 1)\ndplift = [0] * (n + 1)\ndpst[2] = a[0]\ndplift[2] = c + b[0]\nfor i in range(3, n + 1):\n    dpst[i] = a[i - 2] + min(dpst[i - 1], dplift[i - 1])\n    dplift[i] = b[i - 2] + min(c + dpst[i - 1], dplift[i - 1])\n\nfor i in range(1, n + 1):\n    print(min(dpst[i], dplift[i]), end=' ')", "generated_code": "(n, c) = [int(x) for x in input().split()]\na = list(map(int, input().split()))\npass\ndpst = [0] * (n + 1)\ndplift = [0] * (n + 1)\ndpst[2] = a[0]\ndplift[2] = c + b[0]\nfor i in range(3, n + 1):\n    dpst[i] = a[i - 2] + min(dpst[i - 1], dplift[i - 1])\n    dplift[i] = b[i - 2] + min(c + dpst[i - 1], dplift[i - 1])\n\nfor i in range(1, n + 1):\n    print(min(dpst[i], dplift[i]), end=' ')", "score": 0.0, "codebleu": 0.8644930938280472, "crystalbleu": 0.89, "codebertscore": 0.99, "codescore": 0.9938452839851379, "surfaceSim": 0.9407763769077637, "abs_surfaceSim_minus_score": 0.9407763769077637, "source": "local", "local_type": "MUT"}
{"id": "APPS_test-0538_26", "golden_code": "S = input().strip().strip('0')\nprint([\"NO\", \"YES\"][S == S[::-1]])", "generated_code": "#!/usr/bin/env python3\nimport sys\n\ndef rint():\n\treturn int(sys.stdin.readline())\n\ndef rstr():\n\treturn sys.stdin.write(\"YES\\n\")\n\ndef main():\n\tx=eval(input())\n\t#a=[]\n\tfor i in range(0,x):\n\t\ts=list(str(x))\n\t\ts[0] = s[0] + '0'\n\t\ta=''\n\t\tfor i in range (0,len(s)-1):\n\t\t\tif s[i] == s[i+1]:\n\t\t\t\ta=a+s[i]\n\t\t\telse:\n\t\t\t\ta= a+s[i+1]\n\t\tif a==a[::-1]:\n\t\t\tprint(\"YES\")\n\t\telse:\n\t\t\tprint(\"NO\")\n\t#r.sort(", "score": 0.0, "codebleu": 0.2734311593446441, "crystalbleu": 0, "codebertscore": 0.67, "codescore": 0.01859995909035206, "surfaceSim": 0.4776434465553636, "abs_surfaceSim_minus_score": 0.4776434465553636, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_29_OP_1", "golden_code": "from typing import List\n\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    return [x for x in strings if x.startswith(prefix)]", "generated_code": "from typing import List\n\n\ndef filter_by_prefix(items: List[str], pre: str) -> List[str]:\n    if not pre:\n        return items\n    return [item for item in items if item.startswith(pre)]", "score": 1.0, "codebleu": 0.6016279430567795, "crystalbleu": 0, "codebertscore": 0.95, "codescore": 0.9936961531639099, "surfaceSim": 0.7886201991465149, "abs_surfaceSim_minus_score": 0.21137980085348507, "source": "local", "local_type": "OP"}
{"id": "APPS_test-1096_2", "golden_code": "s = input()\nif (s[0] == 'a' and (s[1] == '1' or s[1] == '8')) or\\\n    (s[0] == 'h' and (s[1] == '1' or s[1] == '8')):\n    print(3)\nelif s[0] in 'ah' or s[1] in '18':\n    print(5)\nelse:\n    print(8)\n", "generated_code": "import sys\nimport math\n\ndef main():\n\tnumber = sys.stdin.readline()\n\tnum = number.split()\n\tcol = int(num[0])\n\trow = int(num [1])\n\tif col == 1:\n\t\tcol = 8\n\tif col <= 4:\n\t\treturn 8\n\tif row <= 7:\n\t\treturn 4\n\tif row == 8:\n\t\treturn number.count(\"a\")\n\tif row < 7 and col > 1:\n\t\treturn 9\n\tif row > 7 and col < 4:\n\t\tout = (col - 1) * (8 - col + 1)\n\t\treturn out + 4\n\tif col >= 4:\n\t\tif row > 7:\n\t\t\tout = (7 - row) * (8 // 4)\n\t\telse:\n\t\t\tout in range(3, 8, 4)\n\t\treturn inp\n", "score": 0.0, "codebleu": 0.10667693779654872, "crystalbleu": 0.01, "codebertscore": 0.71, "codescore": 0.018980056047439575, "surfaceSim": 0.44281045751633985, "abs_surfaceSim_minus_score": 0.44281045751633985, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_55_3", "golden_code": "def dealnnoy_num(n, m): \r\n\tif (m == 0 or n == 0) : \r\n\t\treturn 1\r\n\treturn dealnnoy_num(m - 1, n) + dealnnoy_num(m - 1, n - 1) + dealnnoy_num(m, n - 1)", "generated_code": "def dealnnoy_num(n, m): \n\tif n == m:\n\t\treturn n\n\tif m > n:\n\t\tn = m\n\t\twhile n > m:\n\t\t\tn = n - 1\n\t\t\ta = n + 1\n\t\treturn dealnum(n - 1, m)\n\telse:\n\t\tm = n\n\t\twhile m > n :\n\t\t\tm = m - 1\n\t\t  \n\t\t\t\t\n\t\treturn int(m)", "score": 0.0897, "codebleu": 0.3060470136203285, "crystalbleu": 0, "codebertscore": 0.85, "codescore": 0.04887957498431206, "surfaceSim": 0.6586134453781514, "abs_surfaceSim_minus_score": 0.5689134453781514, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_APPS_4484_91_OP_2", "golden_code": "from math import factorial\nn,m=list(map(int,input().split()))\nif abs(n-m)>1:\n    print((0))\n    return\nmod=10**9+7\nif n==m:\n    print(((2*factorial(n)*factorial(m))%mod))\nelse:\n    print(((factorial(n)*factorial(m))%mod))", "generated_code": "from math import factorial\nfrom functools import lru_cache\n\ndef compute_factorials():\n    a, b = map(int, input().split())\n    if abs(a - b) > 1:\n        print(0)\n        return\n    mod = 10**9 + 7\n    @lru_cache(None)\n    def fact(x):\n        return factorial(x)\n    if a == b:\n        result = (2 * fact(a) * fact(b)) % mod\n    else:\n        result = (fact(a) * fact(b)) % mod\n    print(result)\n", "score": 1.0, "codebleu": 0.37414712269712924, "crystalbleu": 0.34, "codebertscore": 0.83, "codescore": 0.7923405170440674, "surfaceSim": 0.7521313698895563, "abs_surfaceSim_minus_score": 0.2478686301104437, "source": "local", "local_type": "OP"}
{"id": "APPS_test-0750_14", "golden_code": "def ii():\n    return int(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\n\nn, k = mi()\nans = (n * 2 + k - 1) // k + (n * 5 + k - 1) // k + (n * 8 + k - 1) // k\nprint(ans)\n", "generated_code": "import sys\n\ndef main():\n\tn, k = map(int, input().split())\n\tres = 0\n\tfor _ in range(n):\n\t\tres += aInt(k)\n\t\tk -= 1\n\tprint(res)\n\treturn\n\naInt = lambda c: int(c) - 1\n", "score": 0.0, "codebleu": 0.17085819245303757, "crystalbleu": 0.12, "codebertscore": 0.78, "codescore": 0.018398765474557877, "surfaceSim": 0.5787037037037037, "abs_surfaceSim_minus_score": 0.5787037037037037, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-0610_6", "golden_code": "def test(begin, r, b):\n    bl = b\n    rl = r\n    if begin == 'b':\n        bl -= 1\n    else:\n        rl -= 1\n    last = begin\n    pt = 0\n    for i in range(r+b-1):\n        if i%2 == 0:\n            if last == 'b':\n                if rl > 0:\n                    rl -= 1\n                    last = 'c'\n                else:\n                    bl -= 1\n                    pt += 1\n            else:\n                if bl > 0:\n                    bl -= 1\n                    last = 'b'\n                else:\n                    rl -= 1\n                    pt += 1\n        else:\n            if last == 'b':\n                if bl > 0:\n                    bl -= 1\n                    pt += 1\n                else:\n                    rl -= 1\n                    last = 'c'\n            else:\n                if rl > 0:\n                    rl -= 1\n                    pt += 1\n                else:\n                    bl -= 1\n                    last = 'b'\n    return pt\n    \ninp = input().split(' ')\nr = int(inp[0])\nb = int(inp[1])\n\nbest = max(test('b', r, b), test('r', r, b))\nprint(best, r+b-best-1)\n\n                \n", "generated_code": "import sys\n\ndef main():\n\tn, m = list(map(int, sys.stdin.readline().split()))\n\tif n == 1 and m == 1:\n\t\tprint(0, 0)\n\t\treturn\n\tif n==1 or m == 1: \n\t\tprint(1, 0)\n\tif n <= m:\n\t\tif n == m:\n\t\t\tprint(n*(n-1), m*(m-1))\n\t\telse:\n\t\t\tprint((n*(n+1))//2, (m*m)//2)\n\telse:\n\t\tprint((n*m-1)//2, m*(m-(n+1))/2)\n\t\nmain()\n\n", "score": 0.0, "codebleu": 0.05904360710756941, "crystalbleu": 0.03, "codebertscore": 0.69, "codescore": 0.038363344967365265, "surfaceSim": 0.5985842985842986, "abs_surfaceSim_minus_score": 0.5985842985842986, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_56_17", "golden_code": "def series_sum(number):\r\n total = 0\r\n total = (number * (number + 1) * (2 * number + 1)) / 6\r\n return total", "generated_code": "def series_sum(number):\n\ttotal = 0\n\tfor n in range(1,number+1):\n\t\ttotal += n*1.0\n\treturn total\nss = []", "score": 0.1447, "codebleu": 0.3178357152214564, "crystalbleu": 0, "codebertscore": 0.84, "codescore": 0.04191552847623825, "surfaceSim": 0.7022326064382138, "abs_surfaceSim_minus_score": 0.5575326064382138, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_PIE_extra_p02730_s449146060_OP_1", "golden_code": "S = eval(input())\n\nN = len(S)\n\nleft = S[:int(N/2)]\n\nright = S[int((N+2)/2):]\n\nS_reversed = \"\".join(reversed(list(S)))\n\nleft_reversed = \"\".join(reversed(list(left)))\n\nright_reversed = \"\".join(reversed(list(right)))\n\n\n\nif S == S_reversed and left == left_reversed and right == right_reversed:\n\n    print(\"Yes\")\n\nelse:\n\n    print(\"No\")", "generated_code": "S = eval(input())\n\nN = len(S)\n\nleft = S[:int(N/2)]\n\nright = S[int((N+2)/2):]\n\n\n\nif S == S[::-1] and left == left[::-1] and right == right[::-1]:\n\n    print(\"Yes\")\n\nelse:\n\n    print(\"No\")", "score": 1.0, "codebleu": 0.5099823776742154, "crystalbleu": 0.51, "codebertscore": 0.85, "codescore": 0.8778479695320129, "surfaceSim": 0.6951376936316696, "abs_surfaceSim_minus_score": 0.30486230636833045, "source": "local", "local_type": "OP"}
{"id": "MBPP_42_22", "golden_code": "import re\r\ndef end_num(string):\r\n    text = re.compile(r\".*[0-9]$\")\r\n    if text.match(string):\r\n        return True\r\n    else:\r\n        return False", "generated_code": "import re\ndef end_num(string):\n\treturn bool(re.match(r'[a-z]\\d$', string))", "score": 0.8741, "codebleu": 0.2848993676924576, "crystalbleu": 0, "codebertscore": 0.84, "codescore": 0.9670749306678772, "surfaceSim": 0.6986577181208053, "abs_surfaceSim_minus_score": 0.17544228187919464, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-1495_55", "golden_code": "import itertools\nn = int(input())\nl = list(map(int, input().split()))\n\nm = max(l) + 5\nfreq = [0 for _ in range(m)]\ncount= [0 for _ in range(m)]\nvis  = [-1 for _ in range(m)]\nfor i  in range(n):\n    q = [(l[i], 0)]\n    pos = 0\n    while len(q)>pos:\n        top,c  = q[pos]\n        pos+=1\n        if(top>=m or vis[top]==i):\n            continue\n        vis[top]   = i\n        freq[top] += 1\n        count[top]+= c\n        q.append((2*top, c+1))\n        q.append((top//2,c+1))\n\nans = min(j for i,j in zip(freq, count) if i==n)\nprint(ans)", "generated_code": "from sys import stdin\nfrom operator import mul\nn = int(stdin.readline())\na = list(map(int, stdin.readline().split()))\nans = 0\nfor i in range(n):\n\ta[i] *= 2\n\nfor i in a:\n\tx = i\n\ty = (i // 2) * 2\n\tif x == y:\n\t\tans += 1\nprint(ans)\n", "score": 0.0285, "codebleu": 0.15560021249604133, "crystalbleu": 0.07, "codebertscore": 0.73, "codescore": 0.17580091953277588, "surfaceSim": 0.5088951310861423, "abs_surfaceSim_minus_score": 0.48039513108614224, "source": "baseline", "local_type": "baseline"}
{"id": "APPS_test-1408_34", "golden_code": "from bisect import bisect_left as bl, bisect_right as br, insort\nimport sys\nimport heapq\n#from math import *\nfrom collections import defaultdict as dd, deque\ndef data(): return sys.stdin.readline().strip()\ndef mdata(): return list(map(int, data().split()))\n#def print(x): return sys.stdout.write(str(x)+'\\n')\n#sys.setrecursionlimit(100000)\nmod=int(1e9+7)\n\nn=int(data())\ndp1=[]\ndp2=[]\nfor i in range(n):\n    t,w=mdata()\n    if t==1:\n        dp1.append(w)\n    else:\n        dp2.append(w)\ndp1.sort(reverse=True)\ndp2.sort(reverse=True)\ns=len(dp1)+2*len(dp2)\nk=0\nflag=True\nwhile flag:\n    flag=False\n    if len(dp2)>0:\n        if len(dp1)>1:\n            m=min(dp1[-1]+dp1[-2],dp2[-1])\n            if k+m<=s-2:\n                if m==dp2[-1]:\n                    dp2.pop()\n                    k+=m\n                    s-=2\n                else:\n                    k+=dp1.pop()\n                    s-=1\n                flag=True\n        else:\n            if len(dp2)>0 and dp2[-1]+k<=s-2:\n                k+=dp2.pop()\n                s-=2\n                flag=True\n    if flag==False:\n        if len(dp1) > 0 and dp1[-1] + k <= s - 1:\n            k += dp1.pop()\n            s -= 1\n            flag = True\nprint(s)\n", "generated_code": "def f(t, w):\n\tres = 0\n\tcur = 0\n\tfor i in range(n):\n\t\tcur += t[i]\n\t\tif cur > w:\n\t\t\tres += 1\n\t\t\tcur = w\n\treturn res\n\nfor t in range(int(input())):\n\tn, w = list(map(int, input().split()))\n\tprint(f(t, w))\n", "score": 0.0, "codebleu": 0.10582666646806844, "crystalbleu": 0.01, "codebertscore": 0.67, "codescore": 0.03002215176820755, "surfaceSim": 0.5232204035020936, "abs_surfaceSim_minus_score": 0.5232204035020936, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_80_14", "golden_code": "def maximum_segments(n, a, b, c) : \r\n\tdp = [-1] * (n + 10) \r\n\tdp[0] = 0\r\n\tfor i in range(0, n) : \r\n\t\tif (dp[i] != -1) : \r\n\t\t\tif(i + a <= n ): \r\n\t\t\t\tdp[i + a] = max(dp[i] + 1, \r\n\t\t\t\t\t\t\tdp[i + a]) \r\n\t\t\tif(i + b <= n ): \r\n\t\t\t\tdp[i + b] = max(dp[i] + 1, \r\n\t\t\t\t\t\t\tdp[i + b]) \r\n\t\t\tif(i + c <= n ): \r\n\t\t\t\tdp[i + c] = max(dp[i] + 1, \r\n\t\t\t\t\t\t\tdp[i + c]) \r\n\treturn dp[n]", "generated_code": "def maximum_segments(n, a, b, c) : \n\tif a is 1 or b is 1 or c is 1 or a is b or c is b:\n\t\treturn 2\n\telse:\n\t\tm = 0\n\t\tif c == a:\n\t\t\tm = b\n\t\tif b == a:  \n\t\t\tm += 1\n\t\tif a == c:\n\t\t\tif c < c:\n\t\t\t\tm = a\n\t\t\telse:\n\t\t\t\tif c<c:\n\t\t\t\t\tm = c\n\t\tif m > 2:\n\t\t\treturn m + 2\n\t\telse:\n\t\t\tpass\n\treturn 0\ntypes = [1, 0.9, 7, 9]", "score": 0.032, "codebleu": 0.11345589712419861, "crystalbleu": 0.09, "codebertscore": 0.76, "codescore": 0.03828005865216255, "surfaceSim": 0.509375, "abs_surfaceSim_minus_score": 0.477375, "source": "baseline", "local_type": "baseline"}
{"id": "MBPP_43_15", "golden_code": "def is_Two_Alter(s):  \r\n    for i in range (len( s) - 2) : \r\n        if (s[i] != s[i + 2]) : \r\n            return False\r\n    if (s[0] == s[1]): \r\n        return False\r\n    return True", "generated_code": "def is_Two_Alter(s): \n\treturn '-' not in s", "score": 0.1829, "codebleu": 0.056675813881599924, "crystalbleu": 0, "codebertscore": 0.75, "codescore": 0.04404651001095772, "surfaceSim": 0.49024199843871974, "abs_surfaceSim_minus_score": 0.30734199843871973, "source": "baseline", "local_type": "baseline"}
{"id": "LOCAL_HE_68_MUT_14", "golden_code": "import os\n\ndef pluck(arr):\n    if len(arr) == 0:\n        return []\n    evens = list(filter((lambda x: (x % 2 == 0)), arr))\n    if evens == []:\n        return []\n    return [min(evens), arr.index(min(evens))]", "generated_code": "import os\n\ndef pluck(arr):\n    if len(arr) == 0:\n        return []\n    evens = list(filter((lambda x: (x % 2 == 0)), arr))\n    if evens == []:\n        return []\n    pass", "score": 0.1159, "codebleu": 0.8163712472265376, "crystalbleu": 0, "codebertscore": 0.96, "codescore": 0.16307610273361206, "surfaceSim": 0.8627580149319279, "abs_surfaceSim_minus_score": 0.7468580149319279, "source": "local", "local_type": "MUT"}
{"id": "LOCAL_PIE_extra_p03796_s080864979_OP_1", "golden_code": "import math\n\nn = int(eval(input()))\n\nprint((math.factorial(n)%(10**9+7)))\n", "generated_code": "n = int(eval(input()))\n\npw = 1\n\nfor i in range(n):\n\n  pw *= (i+1)\n\n  pw %= 10**9+7\n\nprint(pw)", "score": 1.0, "codebleu": 0.2908323286000435, "crystalbleu": 0, "codebertscore": 0.83, "codescore": 0.14077214896678925, "surfaceSim": 0.5698924731182795, "abs_surfaceSim_minus_score": 0.4301075268817205, "source": "local", "local_type": "OP"}
{"id": "LOCAL_APPS_1039_1_MUT_40", "golden_code": "import sys\ndef input():\n    return sys.stdin.readline().strip()\nfrom collections import deque\ndef main():\n    N = int(input())\n    info = [tuple(map(int, input().split())) for _ in range(N - 1)]\n    (Q, K) = map(int, input().split())\n    queries = [tuple(map(int, input().split())) for _ in range(Q)]\n    \n    to = [[] for _ in range(N)]\n    for (a, b, c) in info:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        to[b].append((a, c))\n    \n    INF = 10 ** 18\n    dist = [INF] * N\n    def dfs(s):\n        stack = deque()\n        push = stack.append\n        pop = stack.pop\n        \n        dist[s] = 0\n        push(s)\n        \n        while stack:\n            now = pop()\n            now_cost = dist[now]\n            \n            for (nv, c) in to[now]:\n                if dist[nv] != INF:\n                    continue\n                dist[nv] = now_cost + c\n                push(nv)\n    \n    \n    K -= 1\n    dfs(K)\n    ans = []\n    for (x, y) in queries:\n        x -= 1\n        y -= 1\n        xy = dist[x] + dist[y]\n        ans.append(xy)\n    \n    print(sep='\\n', *ans)\ndef __starting_point():\n    main()\n__starting_point()", "generated_code": "import sys\ndef input():\n    return sys.stdin.readline().strip()\nfrom collections import deque\ndef main():\n    N = int(input())\n    info = [tuple(map(int, input().split())) for _ in range(N - 1)]\n    (Q, K) = map(int, input().split())\n    queries = [tuple(map(int, input().split())) for _ in range(Q)]\n    \n    to = [[] for _ in range(N)]\n    for (a, b, c) in info:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        to[b].append((a, c))\n    \n    INF = 10 ** 18\n    dist = [INF] * N\n    def dfs(s):\n        stack = deque()\n        push = stack.append\n        pass\n        \n        dist[s] = 0\n        push(s)\n        \n        while stack:\n            now = pop()\n            now_cost = dist[now]\n            \n            for (nv, c) in to[now]:\n                if dist[nv] != INF:\n                    continue\n                dist[nv] = now_cost + c\n                push(nv)\n    \n    \n    K -= 1\n    dfs(K)\n    ans = []\n    for (x, y) in queries:\n        x -= 1\n        y -= 1\n        xy = dist[x] + dist[y]\n        ans.append(xy)\n    \n    print(sep='\\n', *ans)\ndef __starting_point():\n    main()\n__starting_point()", "score": 0.0, "codebleu": 0.9626152990359907, "crystalbleu": 0.98, "codebertscore": 0.99, "codescore": 0.9938045740127563, "surfaceSim": 0.9816661534452946, "abs_surfaceSim_minus_score": 0.9816661534452946, "source": "local", "local_type": "MUT"}
