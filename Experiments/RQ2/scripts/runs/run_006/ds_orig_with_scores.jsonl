{"golden_code": "import numpy as np\n\n\n\n(N,M) = list(map(int,input().split()))\n\nB = np.ones(M,dtype=np.int)\n\n\n\nfor _ in range(N):\n\n    A = np.array(list(map(int,input().split())))[1:]\n\n    for i in range(M):\n\n        if not i+1 in A:\n\n            B[i] = 0\n\nprint((B.sum()))", "generated_code": "(N,M) = list(map(int,input().split()))\n\nr = int(-1)\n\nfor i in range(N):\n\n  A = list(map(int,input().split()))\n\n  A.pop(0)\n\n  c = 0\n\n  for a in A:\n\n    c |= (1 << (a-1))\n\n  r &= c\n\n\n\nans = sum([(r>>n)&1 for n in range(M)])\n\nprint(ans)", "score": 1.0, "codebleu": 0.32082146487051477, "crystalbleu": 0.24786981281288478, "codebertscore": 0.83, "codescore": 0.8830373287200928, "surfaceSim": 0.46951871657754013, "abs_surfaceSim_minus_score": 0.5304812834224599}
{"golden_code": "def main():\n\n    n = int(eval(input()))\n\n    import numpy as np\n\n    ans = np.zeros((10,10))\n\n    for i in range(1,n+1):\n\n        h,t = str(i)[0],str(i)[-1]\n\n        ans[int(h)-1][int(t)-1]+=1\n\n    s = 0\n\n    for i in range(10):\n\n        for j in range(10):\n\n            s += ans[i][j]*ans[j][i]\n\n\n\n    print((int(s)))\n\nif __name__ == \"__main__\":\n\n    main()", "generated_code": "def main():\n\n    n = int(eval(input()))\n\n    dp = [[0 for i in range(10)] for i in range(10)]\n\n    for i in range(1,n+1):\n\n        h,t = int(str(i)[0]), int(str(i)[-1])\n\n        dp[h][t] += 1\n\n    ans = 0\n\n    for i in range(10):\n\n        for j in range(10):\n\n            ans += dp[i][j] * dp[j][i]\n\n    print(ans)\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "score": 1.0, "codebleu": 0.47214019955543324, "crystalbleu": 0.6394523388944687, "codebertscore": 0.92, "codescore": 0.018532074987888336, "surfaceSim": 0.790406472741283, "abs_surfaceSim_minus_score": 0.20959352725871705}
{"golden_code": "N,M,K = list(map(int,input().split()))\n\n\n\nfor i in range(N+1):\n\n    for j in range(M+1):\n\n        t = i*M + j*N - i*j*2\n\n        if t==K:\n\n            print('Yes')\n\n            exit()\n\nprint('No')", "generated_code": "N,M,K = list(map(int,input().split()))\n\n\n\nfor i in range(N+1):\n\n    for j in range(M+1):\n\n        if i*(M-j) + j*(N-i) == K:\n\n            print('Yes')\n\n            exit()\n\nprint('No')", "score": 1.0, "codebleu": 0.6557212908234747, "crystalbleu": 0.7989770211677567, "codebertscore": 0.96, "codescore": 0.9444701075553894, "surfaceSim": 0.9642857142857143, "abs_surfaceSim_minus_score": 0.0357142857142857}
{"golden_code": "import itertools\n\nN = int(eval(input()))\n\nNketa = len(str(N))\n\n\n\nrange_count = [[0 for j in range(10)]for i in range(10)]\n\n\n\n\n\nfor p in range(1,N+1):\n\n    mae = int(str(p)[0])\n\n    ato = int(str(p)[-1])\n\n    range_count[mae][ato] += 1\n\n\n\n    \n\n\n\ncount = 0\n\nfor j in range(1,N+1):\n\n    a_mae = int(str(j)[0])\n\n    a_ato = int(str(j)[-1])\n\n    \n\n    b_mae = a_ato\n\n    b_ato = a_mae\n\n    \n\n    if b_mae == 0:\n\n        continue\n\n    else:\n\n        count += range_count[b_mae][b_ato]\n\nprint(count)\n\n  ", "generated_code": "n = int(eval(input()))\n\n\n\nall_count = 0\n\noptions = [str(i) for i in range(10)]\n\n\n\nmaeato = [[0 for i in range(10)] for j in range(10)]\n\n\n\nfor i in range(n+1):\n\n    checking = str(i)\n\n    maeato[int(checking[0])][int(checking[-1])]+=1\n\nall_count = 0\n\nfor i in range(1,10):\n\n    for j in range(1,10):\n\n        for k in range(1,10):\n\n            for p in range(1,10):\n\n                if i == p and j == k:\n\n                    all_count+=maeato[i][j]*maeato[k][p]\n\nprint(all_count)", "score": 1.0, "codebleu": 0.22346479555437554, "crystalbleu": 0.24263699459438778, "codebertscore": 0.83, "codescore": 0.8179780840873718, "surfaceSim": 0.6796333556896936, "abs_surfaceSim_minus_score": 0.32036664431030637}
{"golden_code": "s = eval(input())\n\nlen_s = len(s)\n\ncnt = [0, 0]\n\nfor i in range(1, len(s)):\n\n    memo_0 = s[i - 1]\n\n    memo_1 = s[len_s - i]\n\n    if s[i] != memo_0:\n\n        cnt[0] += 1\n\n    if s[len_s - i - 1] != memo_1:\n\n        cnt[1] += 1\n\nprint((min(cnt)))\n", "generated_code": "s = eval(input())\n\nlen_s = len(s)\n\ncnt = 0\n\nfor i in range(1, len(s)):\n\n    memo_0 = s[i - 1]\n\n    if s[i] != memo_0:\n\n        cnt += 1\n\nprint(cnt)\n", "score": 1.0, "codebleu": 0.4384389562316314, "crystalbleu": 0.42335612295794856, "codebertscore": 0.93, "codescore": 0.30479907989501953, "surfaceSim": 0.8400809716599189, "abs_surfaceSim_minus_score": 0.1599190283400811}
{"golden_code": "import numpy as np\n\nn, k = list(map(int, input().split()))\n\np = np.array(list(map(int, input().split())))\n\np += 1\n\nsum_E = np.cumsum(p)\n\nsum_e = np.append([0], sum_E)\n\nans = -1\n\nfor i in range(n-k+1):\n\n    ans = max(ans, sum_e[i+k] - sum_e[i])\n\nprint((ans/2))", "generated_code": "n, k = list(map(int, input().split()))\n\np = list(map(int, input().split()))\n\n\n\ndef calc(x):\n\n    return (x + 1) / 2\n\n\n\n\n\nw = 0\n\n\n\nfor i in range(k):\n\n    w += calc(p[i])\n\n\n\nans = w\n\nfor i in range(k, n):\n\n    w += calc(p[i]) - calc(p[i - k])\n\n    ans = max(ans, w)\n\nprint(ans)", "score": 1.0, "codebleu": 0.32069355178686754, "crystalbleu": 0.363704997316923, "codebertscore": 0.84, "codescore": 0.221291646361351, "surfaceSim": 0.6141304347826086, "abs_surfaceSim_minus_score": 0.38586956521739135}
{"golden_code": "N = int(eval(input()))\n\na = list(map(int, input().split()))\n\nb = list(map(int, input().split()))\n\na.reverse()\n\nb.reverse()\n\nans = 0\n\ncapacity = 0\n\nfor i in range(N):\n\n    ans += min(b[i] + capacity, a[i])\n\n    capacity = max(b[i] - max(a[i] - capacity, 0), 0)\n\nans += min(a[-1], capacity)\n\nprint(ans)", "generated_code": "n = int(eval(input()))\n\na = list(map(int, input().split()))\n\nb = list(map(int, input().split()))\n\n\n\na = a[::-1]\n\nb = b[::-1]\n\nans = 0\n\nfor i, bi in enumerate(b):\n\n    ans += min(a[i], b[i])\n\n    remain = max(0, b[i] - a[i])\n\n    ans += min(a[i + 1], remain)\n\n    a[i + 1] = max(0, a[i + 1] - remain)\n\nprint(ans)", "score": 1.0, "codebleu": 0.4781144399353477, "crystalbleu": 0.4406183139467697, "codebertscore": 0.91, "codescore": 0.1831657886505127, "surfaceSim": 0.7892282958199357, "abs_surfaceSim_minus_score": 0.2107717041800643}
{"golden_code": "n, m = list(map(int, input().split()))\n\na = []\n\nfor i in range(m):\n\n  a.append(int(eval(input())))\n\nans = 0\n\nflag = 0\n\na = set(a)\n\n\n\n#フィボナッチ数列の初期値を調節\n\ndp = [0] * (n+1)\n\ndp[0] = 1\n\nif 1 in a:\n\n  dp[1] = 0\n\nelse:\n\n  dp[1] = 1\n\n  \n\nfor i in range(2, n+1):\n\n  if dp[i-2] == 0 and dp[i-1] == 0:\n\n    ans = 0\n\n    flag = 1\n\n    break\n\n  elif i in a:\n\n    continue\n\n  else:\n\n    dp[i] = dp[i-1] + dp[i-2]\n\nif flag == 0:\n\n  ans = dp[n]\n\nprint((ans%(10**9+7)))", "generated_code": "n, m = list(map(int, input().split()))\n\na = []\n\nfor i in range(m):\n\n  a.append(int(eval(input())))\n\nans = 0\n\nflag = 0\n\na = set(a)\n\n\n\n#フィボナッチ数列の初期値を調節\n\ndp = [0] * (n+1)\n\ndp[0] = 1\n\nif 1 in a:\n\n  dp[1] = 0\n\nelse:\n\n  dp[1] = 1\n\n  \n\nfor i in range(2, n+1):\n\n  if dp[i-2] == 0 and dp[i-1] == 0:\n\n    ans = 0\n\n    flag = 1\n\n    break\n\n  elif i in a:\n\n    continue\n\n  else:\n\n    dp[i] = dp[i-1] + dp[i-2]\n\n    dp[i] = dp[i] % (10**9+7)\n\nif flag == 0:\n\n  ans = dp[n]\n\nprint(ans)", "score": 1.0, "codebleu": 0.9438993725962391, "crystalbleu": 0.9463913320718315, "codebertscore": 1.0, "codescore": 0.9937751293182373, "surfaceSim": 0.9638297872340426, "abs_surfaceSim_minus_score": 0.036170212765957444}
{"golden_code": "X,Y,Z,K = list(map(int,input().split()))\n\nA = list(map(int,input().split()))\n\nB = list(map(int,input().split()))\n\nC = list(map(int,input().split()))\n\nasort,bsort,csort = sorted(A,reverse=True),sorted(B,reverse=True),sorted(C,reverse=True)\n\nprint((asort[0] + bsort[0] + csort[0]))\n\nalready = [[0,0,0]]\n\nx,y,z = 0,0,0\n\nplace_sum = []\n\ncheck = []\n\nfor k in range(K - 1):\n\n    if [x + 1,y,z] not in already and x + 1 < X:\n\n        already.append([x + 1,y,z])\n\n        place_sum.append([x + 1,y,z])\n\n        check.append(asort[x + 1] + bsort[y] + csort[z])\n\n    if [x,y + 1,z] not in already and y + 1 < Y:\n\n        already.append([x,y + 1,z])\n\n        place_sum.append([x,y + 1,z])\n\n        check.append(asort[x] + bsort[y + 1] + csort[z])\n\n    if [x,y,z + 1] not in already and z + 1 < Z:\n\n        already.append([x,y,z + 1])\n\n        place_sum.append([x,y,z + 1])\n\n        check.append(asort[x] + bsort[y] + csort[z + 1])\n\n    print((max(check)))\n\n    x,y,z = place_sum[check.index(max(check))][0],place_sum[check.index(max(check))][1],place_sum[check.index(max(check))][2]\n\n    place_sum.pop(check.index(max(check)))\n\n    check.remove(max(check))", "generated_code": "import heapq\n\nX,Y,Z,K = list(map(int,input().split()))\n\nA = list(map(int,input().split()))\n\nB = list(map(int,input().split()))\n\nC = list(map(int,input().split()))\n\nasort,bsort,csort = sorted(A,reverse=True),sorted(B,reverse=True),sorted(C,reverse=True)\n\nalready = [[0,0,0]]\n\nprint((asort[0] + bsort[0] + csort[0]))\n\nx,y,z = 0,0,0\n\ncheck = []\n\nfor k in range(K - 1):\n\n    if [x + 1,y,z] not in already and x + 1 < X:\n\n        already.append([x + 1,y,z])\n\n        heapq.heappush(check,(-(asort[x + 1] + bsort[y] + csort[z]),x + 1,y,z))\n\n    if [x,y + 1,z] not in already and y + 1 < Y:\n\n        already.append([x,y + 1,z])\n\n        heapq.heappush(check,(-(asort[x] + bsort[y + 1] + csort[z]),x,y + 1,z))\n\n    if [x,y,z + 1] not in already and z + 1 < Z:\n\n        already.append([x,y,z + 1])\n\n        heapq.heappush(check,(-(asort[x] + bsort[y] + csort[z + 1]),x,y,z + 1))\n\n    maxsum = heapq.heappop(check)\n\n    print((-maxsum[0]))\n\n    x,y,z = maxsum[1],maxsum[2],maxsum[3]", "score": 1.0, "codebleu": 0.6987359410409137, "crystalbleu": 0.6907988549357674, "codebertscore": 0.93, "codescore": 0.9039178490638733, "surfaceSim": 0.782719900187149, "abs_surfaceSim_minus_score": 0.217280099812851}
{"golden_code": "inf = (5000 * 10 ** 5) * 3\n\n\n\na, b, c, x, y = list(map(int, input().split()))\n\n\n\nret = inf\n\nfor cnt_ab in range(max(x, y) * 2 + 1):\n\n    d = cnt_ab // 2\n\n\n\n    cnt_a = max(0, x - d)\n\n    cnt_b = max(0, y - d)\n\n\n\n    t = cnt_ab * c + cnt_a * a + cnt_b * b\n\n    ret = min(ret, t)\n\nprint(ret)\n", "generated_code": "def main():\n\n    A, B, AB, X, Y = list(map(int, input().split()))\n\n    M = max(X, Y)\n\n\n\n    k = 0\n\n    ans = A * X + B * Y\n\n    while True:\n\n        ans = min(\n\n            ans,\n\n            AB * k * 2 + max(0, X - k) * A + max(0, Y - k) * B\n\n        )\n\n\n\n        if k >= M: break\n\n        k += 1\n\n\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 1.0, "codebleu": 0.22553413540275377, "crystalbleu": 0.13599966483111123, "codebertscore": 0.8, "codescore": 0.01945461332798004, "surfaceSim": 0.5728519391472038, "abs_surfaceSim_minus_score": 0.4271480608527962}
{"golden_code": "import numpy as np\n\nNM = list(map(int,input().split()))\n\nN = NM[0]\n\nM = NM[1]\n\nA = list(map(int,input().split()))\n\nlistBC =[]\n\nwhile True:\n\n    try:\n\n        listBC.append(list(map(int,input().split())))\n\n    except:\n\n        break;\n\nBC = np.array(listBC)\n\nBCnum = np.argsort(BC[:,1])[::-1]\n\nBC = BC[BCnum,:]\n\n\n\nA.sort()\n\nj=0\n\nfor i in range(len(A)):\n\n    times = BC[j,0]\n\n    if BC[j,0]==0:\n\n        j+=1\n\n        if j == BC.shape[0]:\n\n            break\n\n        times = BC[j,0]\n\n    if A[i]<BC[j,1]:\n\n        A[i]=BC[j,1]\n\n        BC[j,0] += -1\n\noutput = sum(A)\n\nprint(output)", "generated_code": "N,M = list(map(int,input().split()))\n\nA = list(map(int,input().split()))\n\n\n\nfrom collections import Counter\n\nD = dict(Counter(A))\n\n\n\nfor i in range(M):\n\n    B,C = list(map(int,input().split()))\n\n    D[C]=D.get(C,0)+B\n\n\n\nK = sorted(list(D.keys()),reverse=True)\n\n\n\nout = 0\n\ncnt = 0\n\nnow = 0\n\nwhile cnt<=N-1:\n\n    if D[K[now]]>0:\n\n        out += K[now]\n\n        D[K[now]] += -1\n\n        cnt+=1\n\n    else:\n\n        now+=1\n\nprint(out)", "score": 1.0, "codebleu": 0.20308387242458062, "crystalbleu": 0.14366715087677473, "codebertscore": 0.79, "codescore": 0.958695650100708, "surfaceSim": 0.5408016147635525, "abs_surfaceSim_minus_score": 0.4591983852364475}
{"golden_code": "a, b, c, x, y = list(map(int, input().split()))\n\n# print(a, b, c, x, y)\n\n\n\nans = 10000 * (10 **5) + 7\n\nc_max = 0\n\nif x > y:\n\n  c_max = x * 2\n\nelse:\n\n  c_max = y * 2\n\n\n\nfor cc in range(c_max+1):\n\n  ac = x - (cc // 2)\n\n  bc = y - (cc // 2)\n\n  \n\n  if ac < 0:\n\n    ac = 0\n\n  if bc < 0:\n\n    bc = 0\n\n  price = ac * a + bc * b + cc * c\n\n  # print('price: {}, ac: {}, bc: {}, cc: {}'.format(price, ac, bc, cc))\n\n  ans = min(ans, price)\n\n\n\nprint(ans)", "generated_code": "a, b, c, x, y = list(map(int, input().split()))\n\n# print(a, b, c, x, y)\n\n\n\nans = 10000 * (10 **5) + 7\n\nc_max = 0\n\nif x > y:\n\n  c_max = x * 2\n\nelse:\n\n  c_max = y * 2\n\n\n\nfor cc in range(0, c_max+1, 2):\n\n  ac = x - (cc // 2)\n\n  bc = y - (cc // 2)\n\n  \n\n  if ac < 0:\n\n    ac = 0\n\n  if bc < 0:\n\n    bc = 0\n\n  price = ac * a + bc * b + cc * c\n\n  # print('price: {}, ac: {}, bc: {}, cc: {}'.format(price, ac, bc, cc))\n\n  ans = min(ans, price)\n\n\n\nprint(ans)\n\n  ", "score": 1.0, "codebleu": 0.955087040289192, "crystalbleu": 0.9488826794224877, "codebertscore": 0.99, "codescore": 0.9938606023788452, "surfaceSim": 0.995575221238938, "abs_surfaceSim_minus_score": 0.004424778761061954}
{"golden_code": "import math\n\nimport string\n\n\n\n\n\ndef readints():\n\n    return list(map(int, input().split()))\n\n\n\n\n\ndef nCr(n, r):\n\n    return math.factorial(n)//(math.factorial(n-r)*math.factorial(r))\n\n\n\n\n\ndef has_duplicates2(seq):\n\n    seen = []\n\n    for item in seq:\n\n        if not(item in seen):\n\n            seen.append(item)\n\n    return len(seq) != len(seen)\n\n\n\n\n\ndef divisor(n):\n\n    divisor = []\n\n    for i in range(1, n+1):\n\n        if n % i == 0:\n\n            divisor.append(i)\n\n    return divisor\n\n\n\n\n\n# coordinates\n\ndx = [-1, -1, -1, 0, 0, 1, 1, 1]\n\ndy = [-1, 0, 1, -1, 1, -1, 0, 1]\n\n\n\nn = int(eval(input()))\n\na = readints()\n\n\n\n\n\ndef func(l):\n\n    if len(l) == n:\n\n        for i in range(len(l)):\n\n            if l[i] % 2 == 0:\n\n                return 1\n\n\n\n        return 0\n\n    return func(l+[(a[len(l)])])+func(l+[(a[len(l)]-1)])+func(l+[(a[len(l)]+1)])\n\n\n\n\n\nprint((func([])))\n", "generated_code": "import math\n\nimport string\n\n\n\n\n\ndef readints():\n\n    return list(map(int, input().split()))\n\n\n\n\n\ndef nCr(n, r):\n\n    return math.factorial(n)//(math.factorial(n-r)*math.factorial(r))\n\n\n\n\n\ndef has_duplicates2(seq):\n\n    seen = []\n\n    for item in seq:\n\n        if not(item in seen):\n\n            seen.append(item)\n\n    return len(seq) != len(seen)\n\n\n\n\n\ndef divisor(n):\n\n    divisor = []\n\n    for i in range(1, n+1):\n\n        if n % i == 0:\n\n            divisor.append(i)\n\n    return divisor\n\n\n\n\n\n# coordinates\n\ndx = [-1, -1, -1, 0, 0, 1, 1, 1]\n\ndy = [-1, 0, 1, -1, 1, -1, 0, 1]\n\n\n\nn = int(eval(input()))\n\na = readints()\n\nsum = 1\n\nfor i in range(len(a)):\n\n    if a[i] % 2 == 0:\n\n        sum *= 2\n\n    else:\n\n        sum *= 1\n\nprint((3**len(a)-sum))\n", "score": 1.0, "codebleu": 0.7927987296332026, "crystalbleu": 0.6700281462116706, "codebertscore": 0.96, "codescore": 0.3018401563167572, "surfaceSim": 0.9049909998363607, "abs_surfaceSim_minus_score": 0.09500900016363933}
{"golden_code": "a,b,c,x,y = list(map(int,input().split()))\n\nans = a*x + b*y\n\nfor i in range(max(x,y) + 1):\n\n\tmoney = max(0,(x-i)*a) + max(0,(y-i)*b) + 2*i*c\n\n\tif money <= ans:\n\n\t\tans = money\n\nprint(ans)", "generated_code": "a,b,c,x,y = list(map(int,input().split()))\n\nif a + b >= 2*c:\n\n\tif x >= y:\n\n\t\tans = 2*y*c + (x-y)*min(a,2*c)\n\n\telse:\n\n\t\tans = 2*x*c + (y-x)*min(b,2*c)\n\nelse:\n\n\tans = (x*a + y*b)\n\nprint(ans)", "score": 1.0, "codebleu": 0.29176496734976, "crystalbleu": 0.0, "codebertscore": 0.87, "codescore": 0.07896100729703903, "surfaceSim": 0.6976483762597985, "abs_surfaceSim_minus_score": 0.3023516237402015}
{"golden_code": "N = int(eval(input()))\n\nx = list(map(int, input().split()))\n\ncnt = 0\n\nfor i in x:\n\n  while i % 2 == 0:\n\n    cnt += 1\n\n    i /= 2\n\nprint(cnt)", "generated_code": "n = int(eval(input()))\n\nans = 0\n\nfor i in map(int, input().split()):\n\n    cnt = 0\n\n    while i % 2 == 0:\n\n        i >>= 1\n\n        cnt += 1\n\n    ans += cnt\n\nprint(ans)", "score": 1.0, "codebleu": 0.5065154785810035, "crystalbleu": 0.0, "codebertscore": 0.92, "codescore": 0.8493399620056152, "surfaceSim": 0.8365899779388591, "abs_surfaceSim_minus_score": 0.16341002206114086}
{"golden_code": "def factorial(N):\n\n    power_r = 1\n\n    for n in range(2,N+1):\n\n        power_r *= n\n\n        power_r %= 10**9+7\n\n    return power_r\n\n\n\nif __name__ == '__main__':\n\n    N = int(eval(input()))\n\n    print((factorial(N)))", "generated_code": "def factorial(N):\n\n    power_r = 1\n\n    for n in range(2,N+1):\n\n        power_r = power_r*n % (10**9+7)\n\n    return power_r\n\n\n\nif __name__ == '__main__':\n\n    N = int(eval(input()))\n\n    print((factorial(N)))", "score": 1.0, "codebleu": 0.7788566774382812, "crystalbleu": 0.0, "codebertscore": 0.98, "codescore": 0.9938226938247681, "surfaceSim": 0.9611436950146628, "abs_surfaceSim_minus_score": 0.03885630498533721}
{"golden_code": "import sys\n\ninput = sys.stdin.readline\n\n\n\nN,L,T = list(map(int,input().split()))\n\nXW = [[int(x) for x in input().split()] for _ in range(N)]\n\n\n\nX,W = list(zip(*XW))\n\n\n\nDX = [1 if w == 1 else -1 for w in W]\n\n\n\nY = [(x+dx*T)%L for x,dx in zip(X,DX)]\n\ny0 = Y[0]\n\nY.sort()\n\n\n\n# 番号1がすれ違わず進んだ場所に相当するアリの番号\n\n# すれ違うたびに1増える（W1=1） or 1減る（W1=-1）\n\n# T秒ちょうどもすれ違い終わったと考える\n\n\n\nx = 0\n\nx0,dx0 = X[0],DX[0]\n\nfor y,dy in zip(X[1:],DX[1:]):\n\n    if dx0 == dy:\n\n        continue\n\n    if dx0 == 1 and dy == -1:\n\n        # 正の向きに追い越すので番号がひとつ増える\n\n        x += (2*T-(y-x0)-1)//L + 1\n\n    if dx0 == -1 and dy == 1:\n\n        x -= (2*T-(L+x0-y))//L + 1\n\nx %= N\n\n\n\ni = Y.index(y0)\n\n\n\nY += Y\n\n\n\nanswer = [None] * N\n\nanswer[x:N] = Y[i:i+N-x]\n\nanswer[0:x] = Y[i+N-x:i+N]\n\n\n\nprint(('\\n'.join(map(str,answer))))\n\n\n", "generated_code": "import sys\n\nimport numpy as np\n\n\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\n\"\"\"\n\n・順序が固定されるので、区間だったら簡単\n\n・円のときも、地点 0 をそれぞれの方向に通った人数を見れば計算できる\n\n\"\"\"\n\n\n\nN, L, T = list(map(int, readline().split()))\n\nXW = np.array(read().split(), np.int64)\n\nX = XW[::2]\n\nW = XW[1::2]\n\n\n\nspeed = np.where(W == 1, 1, -1)\n\n\n\nY = X + speed * T\n\n\n\nn = (Y // L - X // L).sum()\n\nn %= N\n\n\n\nY %= L\n\nY.sort()\n\nY = np.concatenate((Y[n:], Y[:n]))\n\n\n\nprint(('\\n'.join(map(str, Y.tolist()))))", "score": 1.0, "codebleu": 0.12710036014394357, "crystalbleu": 0.1384313089053213, "codebertscore": 0.75, "codescore": 0.14466461539268494, "surfaceSim": 0.5943264693264694, "abs_surfaceSim_minus_score": 0.4056735306735306}
{"golden_code": "def cmb(n, r, mod):\n\n    if ( r<0 or r>n ):\n\n        return 0\n\n    r = min(r, n-r)\n\n    return g1[n] * g2[r] * g2[n-r] % mod\n\n\n\nA=2*10**5\n\nmod = 10**9+7\n\ng1 = [1, 1]\n\ng2 = [1, 1]\n\ninverse = [0, 1]\n\n\n\nfor i in range( 2, A + 1 ):\n\n    g1.append( ( g1[-1] * i ) % mod )\n\n    inverse.append( ( -inverse[mod % i] * (mod//i) ) % mod )\n\n    g2.append( (g2[-1] * inverse[-1]) % mod )\n\n\n\nN,M,K=list(map(int,input().split()))\n\nkeisuu=cmb(N*M-2,K-2,mod)\n\n\n\nsum_=0\n\nfor i in range(N):\n\n    a=min(abs(i),abs(N-i-1))\n\n    b=max(abs(i),abs(N-i-1))\n\n    sum_+=(M**2)*((a*(a+1)//2)+(b*(b+1)//2))\n\nfor i in range(M):\n\n    a=min(abs(i),abs(M-i-1))\n\n    b=max(abs(i),abs(M-i-1))\n\n    sum_+=(N**2)*((a*(a+1)//2)+(b*(b+1)//2))\n\nprint(((keisuu * (sum_//2))%mod))", "generated_code": "def power_mod(a,b,mod=10**9+7):\n\n    i,temp,box=0,b,[]\n\n    while(2**i<=b):\n\n        i+=1\n\n    for j in range(i-1,-1,-1):\n\n        box=[[j,temp//2**j]]+box\n\n        temp-=2**j*(temp//2**j)\n\n    box[0].append(a)\n\n    ans=box[0][1]*a%mod\n\n    for j in range(1,i):\n\n        box[j].append(box[j-1][2]**2%mod)\n\n        if box[j][1]==1:\n\n            ans=(ans*box[j][2])%mod\n\n    return ans\n\ndef n_func(n,mod=10**9+7):\n\n    ans=1\n\n    for i in range(1,n+1):\n\n        ans=(ans*i)%mod\n\n    return ans\n\ndef nPr(n,r,mod=10**9+7):\n\n    ans=n_func(n-r,mod)\n\n    ans=power_mod(ans,mod-2,mod)\n\n    return ans*n_func(n,mod)%mod\n\ndef nCr(n,r,mod=10**9+7):\n\n    ans=n_func(n-r,mod)*n_func(r,mod)%mod\n\n    ans=power_mod(ans,mod-2,mod)\n\n    return ans*n_func(n,mod)%mod\n\n\n\nN,M,K=list(map(int,input().split()))\n\nkeisuu=nCr(N*M-2,K-2)\n\nmod=10**9+7\n\n\n\nsum_=0\n\nfor i in range(N):\n\n    a=min(abs(i),abs(N-i-1))\n\n    b=max(abs(i),abs(N-i-1))\n\n    sum_+=(M**2)*((a*(a+1)//2)+(b*(b+1)//2))\n\nfor i in range(M):\n\n    a=min(abs(i),abs(M-i-1))\n\n    b=max(abs(i),abs(M-i-1))\n\n    sum_+=(N**2)*((a*(a+1)//2)+(b*(b+1)//2))\n\nprint(((keisuu * (sum_//2))%mod))", "score": 1.0, "codebleu": 0.36046797983430545, "crystalbleu": 0.44722381874074135, "codebertscore": 0.87, "codescore": 0.6747597455978394, "surfaceSim": 0.697294888471359, "abs_surfaceSim_minus_score": 0.302705111528641}
{"golden_code": "import itertools\n\nimport fractions\n\ndef main():\n\n  s = eval(input())\n\n  t = eval(input())\n\n  cnt = 0\n\n  for i in range(3):\n\n    if s[i] == t[i]:\n\n      cnt += 1\n\n  print(cnt)\n\nif __name__ == '__main__':\n\n  main()", "generated_code": "s = eval(input())\n\nt = eval(input())\n\nans = 0\n\nfor i in range(3):\n\n    if s[i] == t[i]:\n\n        ans += 1\n\nprint(ans)\n", "score": 1.0, "codebleu": 0.47080990306710424, "crystalbleu": 0.0, "codebertscore": 0.88, "codescore": 0.05034764111042023, "surfaceSim": 0.713679245283019, "abs_surfaceSim_minus_score": 0.28632075471698104}
{"golden_code": "import numpy as np\n\n\n\nN = int(eval(input()))\n\nX = np.array(list(map(int, input().split())))\n\ncost = float(\"inf\")\n\nfor i in range(max(X) - min(X) + 1):\n\n    p = min(X) + i\n\n    cost = min(np.sum((X - p) ** 2), cost)\n\nprint(cost)", "generated_code": "N = int(eval(input()))\n\nX = sorted(list(map(int, input().split())))\n\nif N == 1:\n\n    print((0))\n\nelse:\n\n    r = X[-1] - X[0]\n\n    ans = float(\"inf\")\n\n    for i in range(r + 1):\n\n        R = X[0] + i\n\n        hp = 0\n\n        for j in range(N):\n\n            hp = hp + (R - X[j]) ** 2\n\n\n\n        ans = min(hp, ans)\n\n\n\n    print(ans)\n", "score": 1.0, "codebleu": 0.32616412606638817, "crystalbleu": 0.3107739498454203, "codebertscore": 0.83, "codescore": 0.0674794614315033, "surfaceSim": 0.6164690382081687, "abs_surfaceSim_minus_score": 0.3835309617918313}
{"golden_code": "a=65280; b=61680; c=52428; d=43690; e=65535\n\nL = {el: 1 for el in [a, b, c, d, e, 0]}\n\nfor i in range(6):\n\n    R = sorted(L.items(), key=lambda x: x[1])\n\n    for p, l in R:\n\n        if l < 16:\n\n            L[p ^ e] = min(L.get(p ^ e, 16), l+1)\n\n            if l+3 < 16:\n\n                for q, r in R:\n\n                    if l+r+3 <= 16:\n\n                        L[p & q] = min(L.get(p & q, 16), l+r+3)\n\n                        L[p ^ q] = min(L.get(p ^ q, 16), l+r+3)\n\n                    else: break\n\n        else: break\n\nprint(*(L[e & eval(s)] for s in open(0).read().replace(*\"-~\").replace(*\"*&\").replace(*\"1e\").split()[:-1]),sep='\\n')\n", "generated_code": "a=65280; b=61680; c=52428; d=43690; e=65535\n\nfrom heapq import heappush, heappop\n\nbase = [a, b, c, d, e, 0]\n\nQ = [(1, el) for el in base]\n\nL = {el: 1 for el in base}\n\nH = []\n\nwhile Q:\n\n    l, p = heappop(Q)\n\n    if L[p] < l: continue\n\n    if l+1 < L.get(p ^ e, 17):\n\n        L[p^e] = l+1\n\n        if l+1 < 16: heappush(Q, (l+1, p^e))\n\n    if l+3 < 16:\n\n        for q, r in H:\n\n            if l+r+3 <= 16:\n\n                if l+r+3 < L.get(p & q, 17):\n\n                    L[p & q] = l+r+3\n\n                    if l+r+3 < 16: heappush(Q, (l+r+3, p & q))\n\n                if l+r+3 < L.get(p ^ q, 17):\n\n                    L[p ^ q] = l+r+3\n\n                    if l+r+3 < 16: heappush(Q, (l+r+3, p ^ q))\n\n            else: break\n\n    if l < 7: H.append((p, l))\n\nprint(*(L[e & eval(s)] for s in open(0).read().replace(*\"-~\").replace(*\"*&\").replace(*\"1e\").split()[:-1]),sep='\\n')\n", "score": 1.0, "codebleu": 0.48037029973648016, "crystalbleu": 0.5057961044546256, "codebertscore": 0.89, "codescore": 0.9850409626960754, "surfaceSim": 0.7448644688644688, "abs_surfaceSim_minus_score": 0.2551355311355312}
{"golden_code": "#!/usr/bin/env pypy3\n\n# N,M = map(int,sys.stdin.readline().split())\n\n# a = tuple(map(int,sys.stdin.readline().split())) # single line with multi param\n\n# a = tuple(int(sys.stdin.readline()) for _ in range(N)) # multi line with single param\n\n# a = tuple(tuple(map(int,sys.stdin.readline().rstrip().split())) for _ in range(N)) # multi line with multi param\n\n# s = sys.stdin.readline().rstrip()\n\n# N = int(sys.stdin.readline())\n\n# INF = float(\"inf\")\n\nimport math,sys\n\n\n\nn = int(sys.stdin.readline())\n\na = tuple(map(int,sys.stdin.readline().split()))\n\n#n = int(input())\n\n#a = list(map(int,input().split()))\n\ng = math.gcd(a[0],a[1])\n\nfor i in range(2,n):\n\n    g = math.gcd(g,a[i])\n\nM = max(a)\n\nacc = a[0]\n\nfor i in range(n):\n\n    acc = math.gcd(acc,a[i])\n\nif acc != 1:\n\n    print(\"not coprime\")\n\n    exit()\n\n\n\nLIMIT=max(a)\n\nminPrime = [0]*(LIMIT+1)\n\nminPrime[1] = 1\n\ndef make():\n\n    for i in range(2,LIMIT+1):\n\n        if minPrime[i] == 0:\n\n            minPrime[i] = i\n\n            #print(i)\n\n            for j in range(i+i,LIMIT+1,i):\n\n                #print(i,j)\n\n                if minPrime[j] == 0:\n\n                    minPrime[j] = i\n\nmake()\n\ndef factrial(N):\n\n     ret = []\n\n     while minPrime[N] != N:\n\n         ret.append(minPrime[N])\n\n         N = N//minPrime[N]\n\n     if N != 1:\n\n         ret.append(N)\n\n     return ret\n\n\n\njudge = set([])\n\npc = True\n\n\n\npairwise = True\n\np = set() #all prime\n\n\n\nfor e in a:\n\n    if not pairwise:\n\n        break\n\n    asf = set(factrial(e))\n\n    if judge & asf != set():\n\n        pc = False\n\n    #     #pairwise = False\n\n    #     print(\"setwise coprime\")\n\n    #     exit(0)\n\n    judge |= asf\n\n# for i in a:\n\n#     if not pc:\n\n#         break\n\n#     asf = set(factrial(i))\n\n\n\n#     if judge & asf != set():\n\n#         pc = False\n\n#     judge |= asf\n\nif pc:\n\n    print(\"pairwise coprime\")\n\nelif g == 1:\n\n    print(\"setwise coprime\")\n\nelse:\n\n    print(\"not coprime\")\n", "generated_code": "#!/usr/bin/env pypy3\n\n# N,M = map(int,sys.stdin.readline().split())\n\n# a = tuple(map(int,sys.stdin.readline().split())) # single line with multi param\n\n# a = tuple(int(sys.stdin.readline()) for _ in range(N)) # multi line with single param\n\n# a = tuple(tuple(map(int,sys.stdin.readline().rstrip().split())) for _ in range(N)) # multi line with multi param\n\n# s = sys.stdin.readline().rstrip()\n\n# N = int(sys.stdin.readline())\n\n# INF = float(\"inf\")\n\nimport math,sys\n\n\n\nn = int(sys.stdin.readline())\n\na = tuple(map(int,sys.stdin.readline().split()))\n\n#n = int(input())\n\n#a = list(map(int,input().split()))\n\ng = math.gcd(a[0],a[1])\n\nfor i in range(2,n):\n\n    g = math.gcd(g,a[i])\n\nM = max(a)\n\nacc = a[0]\n\nfor i in range(n):\n\n    acc = math.gcd(acc,a[i])\n\nif acc != 1:\n\n    print(\"not coprime\")\n\n    exit()\n\n\n\nLIMIT=max(a)\n\nminPrime = [0]*(LIMIT+1)\n\nminPrime[1] = 1\n\ndef make():\n\n    for i in range(2,LIMIT+1):\n\n        if minPrime[i] == 0:\n\n            minPrime[i] = i\n\n            #print(i)\n\n            for j in range(i+i,LIMIT+1,i):\n\n                #print(i,j)\n\n                if minPrime[j] == 0:\n\n                    minPrime[j] = i\n\nmake()\n\ndef factrial(N):\n\n     ret = []\n\n     while minPrime[N] != N:\n\n         ret.append(minPrime[N])\n\n         N = N//minPrime[N]\n\n     if N != 1:\n\n         ret.append(N)\n\n     return ret\n\n\n\njudge = set([])\n\n\n\nfor e in a:\n\n    asf = set(factrial(e))\n\n    if judge & asf != set():\n\n        print(\"setwise coprime\")\n\n        exit()\n\n    judge |= asf\n\n    #judge = judge | asf #too slow\n\nprint(\"pairwise coprime\")\n", "score": 1.0, "codebleu": 0.7327232156462803, "crystalbleu": 0.8710016221649566, "codebertscore": 0.97, "codescore": 0.9937859773635864, "surfaceSim": 0.9238445378151261, "abs_surfaceSim_minus_score": 0.0761554621848739}
{"golden_code": "import numpy as np\n\n\n\nn=int(eval(input()))\n\na_list=list(map(int,input().split()))\n\na_list_2=sorted(a_list,reverse=True)\n\na=np.array(a_list_2,dtype='uint8')\n\n\n\nalice=0\n\nbob=0\n\nfor i in range(n):\n\n\tif i%2==0:\n\n\t\talice+=a[i]\n\n\telse:\n\n\t\tbob+=a[i]\n\n\n\nprint((alice-bob))\n", "generated_code": "n=int(eval(input()))\n\na=list(map(int,input().split()))\n\na.sort(reverse=True)\n\n\n\nalice=0\n\nbob=0\n\n\n\nfor i in range(n):\n\n    if i%2==0:\n\n        alice+=a[i]\n\n    else:\n\n        bob+=a[i]\n\n        \n\nprint((alice-bob))", "score": 1.0, "codebleu": 0.5282923517427665, "crystalbleu": 0.6814678389353974, "codebertscore": 0.92, "codescore": 0.6402819156646729, "surfaceSim": 0.818785890073831, "abs_surfaceSim_minus_score": 0.18121410992616904}
{"golden_code": "from collections import defaultdict\n\n\n\nN, K, *A = list(map(int, open(0).read().split()))\n\n\n\nS = [0] * (N + 1)\n\nfor i in range(N):\n\n    S[i + 1] = S[i] + A[i]\n\n\n\nd = defaultdict(int)\n\nans = 0\n\nfor j in range(N + 1):\n\n    v = (S[j] - j) % K\n\n    ans += d[v]\n\n    d[v] += 1\n\n    if j >= K - 1:\n\n        d[(S[j - K + 1] - (j - K + 1)) % K] -= 1\n\n        \n\nprint(ans)\n", "generated_code": "from collections import defaultdict\n\n\n\nN, K, *A = list(map(int, open(0).read().split()))\n\n\n\nx = [0] * (N + 1)\n\nfor i in range(N):\n\n    x[i + 1] = x[i] + A[i]\n\n    \n\ny = [(x[i] - i) % K for i in range(N + 1)]\n\n\n\nctr = defaultdict(int)\n\nans = 0\n\nfor j in range(N + 1):\n\n    ans += ctr[y[j]]\n\n    ctr[y[j]] += 1\n\n    if j - K + 1 >= 0:\n\n        ctr[y[j - K + 1]] -= 1\n\nprint(ans)\n", "score": 1.0, "codebleu": 0.6323486592939087, "crystalbleu": 0.6700115074905827, "codebertscore": 0.94, "codescore": 0.8420189023017883, "surfaceSim": 0.8542061386888973, "abs_surfaceSim_minus_score": 0.14579386131110272}
{"golden_code": "import math\n\nn = int(eval(input()))\n\nprint((math.factorial(n)%(10**9+7)))\n", "generated_code": "n = int(eval(input()))\n\npw = 1\n\nfor i in range(n):\n\n  pw *= (i+1)\n\n  pw %= 10**9+7\n\nprint(pw)", "score": 1.0, "codebleu": 0.2908323286000435, "crystalbleu": 0.0, "codebertscore": 0.83, "codescore": 0.14048196375370026, "surfaceSim": 0.5698924731182795, "abs_surfaceSim_minus_score": 0.4301075268817205}
{"golden_code": "n,m=list(map(int,input().split()))\n\nc=[0]*(n+2)\n\nfor i in range(m):\n\n  l,r=list(map(int,input().split()))\n\n  c[l-1]+=1\n\n  c[r]-=1\n\nfor i in range(1,n+2):\n\n  c[i]=c[i]+c[i-1]\n\nans=0\n\nfor i in range(n+2):\n\n  if c[i]==m:\n\n    ans+=1\n\nprint(ans)", "generated_code": "n,m=list(map(int,input().split()))\n\nl,r=list(map(int,input().split()))\n\nfor i in range(m-1):\n\n  tl,tr=list(map(int,input().split()))\n\n  if l<tl:\n\n    l=tl\n\n  if tr<r:\n\n    r=tr\n\nprint((max(r-l+1,0)))", "score": 1.0, "codebleu": 0.2118312531149506, "crystalbleu": 0.22829217769272614, "codebertscore": 0.87, "codescore": 0.27108702063560486, "surfaceSim": 0.598863431354862, "abs_surfaceSim_minus_score": 0.401136568645138}
{"golden_code": "import numpy as np\n\nN=int(eval(input()))\n\nprint((2**int(np.log2(N))))", "generated_code": "import math\n\nN=int(eval(input()))\n\nprint((2**int(math.log2(N))))", "score": 1.0, "codebleu": 0.49332105343485505, "crystalbleu": 0.0, "codebertscore": 0.95, "codescore": 0.8260246515274048, "surfaceSim": 0.9202898550724637, "abs_surfaceSim_minus_score": 0.07971014492753625}
{"golden_code": "class Queue:\n\n    def __init__(self,values):\n\n        self.values = values\n\n\n\n    def empty(self):\n\n        if len(self.values) == 0:\n\n            return True\n\n        else:\n\n            return False\n\n\n\n    def enqueue(self,v):\n\n        self.values.append(v)\n\n\n\n    def dequeue(self):\n\n        if len(self.values) <= 0:\n\n            raise\n\n        else:\n\n            v = self.values[0]\n\n            del self.values[0]\n\n            return v\n\n\n\nn,q = list(map(int,input().split(' ')))\n\nprocesses = []\n\nfor i in range(n):\n\n    n,t = input().split(' ')\n\n    processes.append((n,int(t)))\n\n\n\nqueue = Queue(processes)\n\n\n\nclock = 0\n\ndone = []\n\nwhile not queue.empty():\n\n    p = queue.dequeue()\n\n    n = p[0]\n\n    t = p[1]\n\n    if t <= q:\n\n        clock+=t\n\n        done.append((n,clock))\n\n    else:\n\n        queue.enqueue((n,t-q))\n\n        clock+=q\n\n\n\nfor p in done:\n\n    print(p[0],p[1])", "generated_code": "class Queue:\n\n    def __init__(self,l):\n\n        self.values = []\n\n        self.l = l\n\n        for _ in range(l):\n\n            self.values.append(None)\n\n        self.head = 0\n\n        self.tail = 0\n\n    def inc(self,n):\n\n        if n+1 >= self.l:\n\n            return 0\n\n        else:\n\n            return n+1\n\n    def enqueue(self,v):\n\n        if self.inc(self.head) == self.tail:\n\n            print('overflow')\n\n            exit()\n\n        self.values[self.head] = v\n\n        self.head = self.inc(self.head)\n\n    def dequeue(self):\n\n        if self.head == self.tail:\n\n            print('underflow')\n\n            exit()\n\n        v = self.values[self.tail]\n\n        self.tail = self.inc(self.tail)\n\n        return v\n\n    def size(self):\n\n        if self.head >= self.tail:\n\n            return self.head-self.tail\n\n        else:\n\n            self.head + (self.l-self.tail)\n\n\n\nn,q = list(map(int,input().split(' ')))\n\nqueue = Queue(200000)\n\nfor _ in range(n):\n\n    n,t = input().split(' ')\n\n    t = int(t)\n\n    queue.enqueue((n,t))\n\n\n\nc = 0\n\nwhile queue.size()>0:\n\n    n,t = queue.dequeue()\n\n    if t <= q:\n\n        c += t\n\n        print(n,c)\n\n    else:\n\n        queue.enqueue((n,t-q))\n\n        c += q", "score": 1.0, "codebleu": 0.31805903233350485, "crystalbleu": 0.37211966863851337, "codebertscore": 0.85, "codescore": 0.18476344645023346, "surfaceSim": 0.6934056761268781, "abs_surfaceSim_minus_score": 0.3065943238731219}
{"golden_code": "board = [[False]*1000001]*1000001\n\nwhile True:\n\n    m = int(eval(input()))\n\n    if m == 0: break\n\n    star = list({tuple(map(int, input().split())) for i in range(m)})\n\n    sx, sy = star[0]\n\n    \n\n    n = int(eval(input()))\n\n    starlist = list({tuple(map(int, input().split())) for i in range(n)})\n\n    for i in range(len(starlist)):\n\n        board[starlist[i][0]][starlist[i][1]] = True\n\n    for i in range(n):\n\n        flag = True\n\n        for j in range(len(star)-1):\n\n            dx = starlist[i][0] + star[j+1][0] - sx\n\n            dy = starlist[i][1] + star[j+1][1] - sy\n\n            if dx < 0 or 1000000 < dx or dy < 0 or 1000000 < dy or board[dx][dy] == False:\n\n                flag = False\n\n                break\n\n\n\n        if flag == True:\n\n            print((\"{} {}\".format(starlist[i][0] - sx, starlist[i][1] -sy)))\n\n            break\n\n    ", "generated_code": "while True:\n\n    m = int(eval(input()))\n\n    if m == 0: break\n\n    star = list({tuple(map(int, input().split())) for i in range(m)})\n\n    sx, sy = star[0]\n\n    \n\n    n = int(eval(input()))\n\n    starset = {tuple(map(int, input().split())) for i in range(n)}\n\n    for x, y in starset:\n\n        flag = True\n\n        for j in range(len(star)-1):\n\n            dx = x + star[j+1][0] - sx\n\n            dy = y + star[j+1][1] - sy\n\n            if (dx, dy) not in starset:\n\n                flag = False\n\n                break\n\n\n\n        if flag == True:\n\n            print((x - sx, y - sy))\n\n            break\n\n    ", "score": 1.0, "codebleu": 0.46858626615086985, "crystalbleu": 0.4443448587146504, "codebertscore": 0.9, "codescore": 0.912176251411438, "surfaceSim": 0.7582164369163601, "abs_surfaceSim_minus_score": 0.2417835630836399}
{"golden_code": "l, r=list(map(int, input().split()))\n\nif r-l>672:\n\n\tp=0\n\nelse:\n\n\tp=2019\n\n\tfor i in range(l, r):\n\n\t\tfor j in range(i+1, r+1):\n\n\t\t\tp=min(p, (((i%2019)*(j%2019))%2019))\n\n\t\t\tif not p:\n\n\t\t\t\tbreak\n\n\t\tif not p:\n\n\t\t\tbreak\n\nprint(p)", "generated_code": "l, r=list(map(int, input().split()))\n\nif r-l>672:\n\n\tp=0\n\nelse:\n\n\tp=2019\n\n\tfor i in range(l, r):\n\n\t\tfor j in range(i+1, r+1):\n\n\t\t\tp=min(p, (i*j%2019))\n\n\t\t\tif not p:\n\n\t\t\t\tbreak\n\n\t\tif not p:\n\n\t\t\tbreak\n\nprint(p)", "score": 1.0, "codebleu": 0.8726330193482528, "crystalbleu": 0.8526724299959368, "codebertscore": 0.99, "codescore": 0.9937388896942139, "surfaceSim": 0.9641255605381166, "abs_surfaceSim_minus_score": 0.0358744394618834}
{"golden_code": "def main():\n\n    x = int(eval(input()))\n\n    for a in range(-120, 121):\n\n        for b in range(-120, 121):\n\n            if a**5 - b**5 == x:\n\n                print((a, b))\n\n                return\n\n\n\nif __name__ == \"__main__\":\n\n    main()", "generated_code": "def main():\n\n    x = int(eval(input()))\n\n    for i in range(-120, 121):\n\n        for j in range(-120, 121):\n\n            if i**5 - j**5 == x:\n\n                print((i, j))\n\n                return\n\n\n\nif __name__ == \"__main__\":\n\n    main()", "score": 1.0, "codebleu": 0.7574111814061091, "crystalbleu": 0.7256017249452535, "codebertscore": 0.98, "codescore": 0.02981376089155674, "surfaceSim": 0.9873949579831933, "abs_surfaceSim_minus_score": 0.012605042016806678}
{"golden_code": "import numpy as np\n\n\n\nN, K = list(map(int, input().split()))\n\nS = list(eval(input())) + ['2']\n\n\n\nblocks = []\n\ncur = 1\n\nseq = 0\n\nfor s in S:\n\n    if int(s) == cur:\n\n        seq += 1\n\n    else:\n\n        blocks.append(seq)\n\n        cur = 1 - cur\n\n        seq = 1\n\nanswer = 0\n\nblocks = np.array(blocks)\n\nfor i in range(0, len(blocks), 2):\n\n    answer = max(answer, blocks[i:i+2*K+1].sum())\n\nprint(answer)\n", "generated_code": "# coding: utf-8\n\nimport sys\n\nimport itertools\n\n\n\nsr = lambda: sys.stdin.readline().rstrip()\n\nir = lambda: int(sr())\n\nlr = lambda: list(map(int, sr().split()))\n\n\n\n# 0か1の連続している人数のリスト、累積和\n\nstreak = [0, 0]\n\nN, K = lr()\n\nS = sr() + '2'\n\ncur = 1\n\nfor i in range(N):\n\n    if S[i] != S[i+1]:\n\n        streak.append(cur)\n\n        cur = 1\n\n    else:\n\n        cur += 1\n\n\n\nstreak_cum = list(itertools.accumulate(streak))\n\nstreak_cum.extend([streak_cum[-1], streak_cum[-1]])\n\nif S[0] == '0':\n\n    start = 0\n\nelse:\n\n    start = 1\n\nanswer = 0\n\n\n\nlimit = len(streak_cum) - 1\n\nfor i in range(start, len(streak_cum), 2):\n\n    result = streak_cum[min(limit, i+2*K+1)] - streak_cum[i]\n\n    if result > answer:\n\n        answer = result\n\n\n\nprint(answer)\n\n# 52", "score": 1.0, "codebleu": 0.31014844887410725, "crystalbleu": 0.18691965755809017, "codebertscore": 0.76, "codescore": 0.14185480773448944, "surfaceSim": 0.6219853810128244, "abs_surfaceSim_minus_score": 0.3780146189871756}
{"golden_code": "import numpy as np\n\n\n\nn = int(eval(input()))\n\na = np.array(list(map(int,input().split())))\n\n\n\ncount = 0\n\nwhile np.all(a%2==0):\n\n    count+=1\n\n    a=a/2\n\nprint(count)\n", "generated_code": "N=int(eval(input()))\n\na = [int(i) for i in input().split()]\n\n\n\ncount=0\n\nwhile 1:\n\n    if sum([i%2 for i in a]) == 0:\n\n        a = [i/2 for i in a]\n\n        count=count+1\n\n    else:\n\n        print(count)\n\n        break\n", "score": 1.0, "codebleu": 0.23312890830139688, "crystalbleu": 0.0, "codebertscore": 0.82, "codescore": 0.9294912219047546, "surfaceSim": 0.6391104906262465, "abs_surfaceSim_minus_score": 0.3608895093737535}
{"golden_code": "# -*- coding: utf-8 -*-\n\nimport sys\n\n\n\nX = int(input().strip())\n\n#-----\n\n\n\nfor a in range(-118,120):\n\n    for b in range(-118,120):\n\n        if (a**5 - b**5) == X:\n\n            print((a,b))\n\n            sys.exit()\n", "generated_code": "# -*- coding: utf-8 -*-\n\nimport sys\n\n\n\nX = int(input().strip())\n\n#-----\n\ncalc = {}\n\n\n\nfor i in range(-118,120):\n\n    calc[i] = i**5\n\n\n\n\n\nfor a in range(-118,120):\n\n    for b in range(-118,120):\n\n        if (calc[a] - calc[b]) == X:\n\n            print((a,b))\n\n            sys.exit()\n", "score": 1.0, "codebleu": 0.7204638521337896, "crystalbleu": 0.5982394116514085, "codebertscore": 0.95, "codescore": 0.9937723278999329, "surfaceSim": 0.836436170212766, "abs_surfaceSim_minus_score": 0.16356382978723405}
{"golden_code": "from collections import deque\n\n\n\nn, k = list(map(int, input().split()))\n\nV = list(map(int, input().split()))\n\n\n\nans = 0\n\nfor t in range(k//2 + 1):\n\n    hand = deque(V[:k-t])\n\n    rest = deque(V[k-t:])\n\n    cur_sum = sum(hand)\n\n\n\n    for j in range(k-t+1):\n\n        put_back = 0\n\n        rev_hand = sorted(hand)\n\n\n\n        for i in range(t):\n\n            jewel = rev_hand[i]\n\n            if jewel < 0:\n\n                put_back -= jewel\n\n            else:\n\n                break\n\n\n\n        candidate = cur_sum + put_back\n\n        ans = max(candidate, ans)\n\n\n\n        to_rest = hand.pop()\n\n        rest.appendleft(to_rest)\n\n        to_hand = rest.pop()\n\n        hand.appendleft(to_hand)\n\n\n\n        cur_sum += to_hand - to_rest\n\n\n\nprint(ans)", "generated_code": "n, k = list(map(int, input().split()))\n\nV = list(map(int, input().split()))\n\n\n\n\n\ndef get_jewelries(box, left_pop, right_pop):\n\n    if left_pop + right_pop >= len(box):\n\n        return box[:]\n\n\n\n    left = box[:left_pop]\n\n    right = box[-right_pop:] if right_pop else []\n\n\n\n    return left + right\n\n\n\n\n\ncandidates = []\n\npop_max = min(k, n)\n\nfor pop_count in range(pop_max+1):\n\n    residue = k - pop_count\n\n\n\n    for left_pop in range(pop_count+1):\n\n        right_pop = pop_count - left_pop\n\n        jewelries = get_jewelries(V, left_pop, right_pop)\n\n        jewelries.sort(reverse=True)\n\n\n\n        for _ in range(residue):\n\n            if not jewelries:\n\n                break\n\n            if jewelries[-1] < 0:\n\n                jewelries.pop()\n\n\n\n        value = sum(jewelries)\n\n        candidates.append(value)\n\n\n\nprint((max(candidates)))\n", "score": 1.0, "codebleu": 0.30416954502908017, "crystalbleu": 0.19582782188396514, "codebertscore": 0.76, "codescore": 0.9938381314277649, "surfaceSim": 0.5229389615537059, "abs_surfaceSim_minus_score": 0.4770610384462941}
{"golden_code": "import numpy as np\n\n\n\nN, K= list(map(int, input().split()))\n\np = np.array(list(map(int, input().split())))\n\n\n\ntmp = np.sum(p[:K])\n\nmax = tmp\n\nfor i in range(N-K):\n\n    tmp = tmp-p[i]+p[i+K]\n\n    if tmp>max:\n\n        max = tmp\n\n\n\nprint(((max+K)/2))", "generated_code": "N, K= list(map(int, input().split()))\n\np = list(map(int, input().split()))\n\n\n\ntmp = sum(p[:K])\n\nmax = tmp\n\nfor i in range(N-K):\n\n    tmp = tmp-p[i]+p[i+K]\n\n    if tmp>max:\n\n        max = tmp\n\n\n\nprint(((max+K)/2))", "score": 1.0, "codebleu": 0.6565883081422969, "crystalbleu": 0.8528085939151825, "codebertscore": 0.95, "codescore": 0.876254677772522, "surfaceSim": 0.8978172856891392, "abs_surfaceSim_minus_score": 0.10218271431086079}
{"golden_code": "from math import floor, sqrt\n\nfrom collections import Counter\n\n\n\nMOD = 10 ** 9 + 7\n\n\n\n# xを素因数分解する\n\ndef getPrimeFactor(x):\n\n    ans = []\n\n    for d in range(2, floor(sqrt(x)) + 1):\n\n        while x % d == 0:\n\n            ans.append(d)\n\n            x //= d\n\n\n\n    if x != 1:\n\n        ans.append(x)\n\n\n\n    return ans\n\n\n\n# xのn乗（二分累乗法）\n\ndef power(x, n):\n\n    ans = 1\n\n    while n:\n\n        if n % 2 == 1:\n\n            ans = (ans * x) % MOD\n\n        x = (x * x) % MOD\n\n        n //= 2\n\n    return ans\n\n\n\n\n\nN, M = list(map(int, input().split()))\n\n\n\nPFs = getPrimeFactor(M)\n\ncnt = Counter(PFs)\n\n\n\nN2 = N\n\nif len(cnt):\n\n    N2 += max(cnt.values())\n\n\n\n# facts[x]: xの階乗\n\nfacts = [1] + [0] * N2\n\nfor x in range(1, N2 + 1):\n\n    facts[x] = (facts[x - 1] * x) % MOD\n\n\n\n# invFs[x]: xの階乗の逆元\n\ninvFs = [0] * N2 + [power(facts[N2], MOD - 2)]\n\nfor x in reversed(list(range(N2))):\n\n    invFs[x] = (invFs[x + 1] * (x + 1)) % MOD\n\n\n\ndef comb(n, k):\n\n    return ((facts[n] * invFs[k]) % MOD * invFs[n - k]) % MOD\n\n\n\n\n\nans = 1\n\nfor num in list(cnt.values()):\n\n    ans = (ans * comb(N + num - 1, num)) % MOD\n\nprint(ans)\n", "generated_code": "from math import floor, sqrt\n\nfrom collections import Counter\n\n\n\nMOD = 10 ** 9 + 7\n\n\n\n# xを素因数分解する\n\ndef getPrimeFactor(x):\n\n    ans = []\n\n    for d in range(2, floor(sqrt(x)) + 1):\n\n        while x % d == 0:\n\n            ans.append(d)\n\n            x //= d\n\n    if x != 1:\n\n        ans.append(x)\n\n    return ans\n\n\n\ndef comb(n, k):\n\n    k = min(k, n - k)\n\n    ans = 1\n\n    for i in range(n, n - k, -1):\n\n        ans *= i\n\n    for i in range(1, k + 1):\n\n        ans //= i \n\n    return ans\n\n\n\n\n\nN, M = list(map(int, input().split()))\n\n\n\nPFs = getPrimeFactor(M)\n\ncnt = Counter(PFs)\n\n\n\nans = 1\n\nfor num in list(cnt.values()):\n\n    ans *= comb(N + num - 1, num)\n\nprint((ans % MOD))\n", "score": 1.0, "codebleu": 0.4402052513109228, "crystalbleu": 0.38525969984631075, "codebertscore": 0.9, "codescore": 0.7784243226051331, "surfaceSim": 0.7838077827108906, "abs_surfaceSim_minus_score": 0.21619221728910942}
{"golden_code": "n=int(eval(input()))\n\nx=list(map(int,input().split()))\n\n\n\nx.sort()\n\n\n\nfor p in range(x[0],x[len(x)-1]+1):\n\n    psum=0\n\n    for i in range(len(x)):\n\n        psum=psum+(x[0]-x[i])**2\n\n#    print(psum)\n\n    pmin=psum    \n\n    for j in range(x[0]+1,x[len(x)-1]):\n\n        psum=0\n\n        for i in range(len(x)):\n\n            psum=psum+(j-x[i])**2\n\n#        print(psum)\n\n        if pmin>psum:\n\n            pmin=psum\n\nprint(pmin)    ", "generated_code": "n=int(eval(input()))\n\nx=list(map(int,input().split()))\n\n\n\nx.sort()\n\n\n\npsum=0\n\nfor i in range(len(x)):\n\n    psum=psum+(x[0]-x[i])**2\n\n#    print(psum)\n\npmin=psum    \n\nfor j in range(x[0]+1,x[len(x)-1]):\n\n    psum=0\n\n    for i in range(len(x)):\n\n        psum=psum+(j-x[i])**2\n\n#        print(psum)\n\n    if pmin>psum:\n\n        pmin=psum\n\nprint(pmin)            \n", "score": 1.0, "codebleu": 0.7479809000176443, "crystalbleu": 0.8282159388426334, "codebertscore": 0.96, "codescore": 0.9938969016075134, "surfaceSim": 0.9613583138173303, "abs_surfaceSim_minus_score": 0.03864168618266972}
{"golden_code": "import numpy as np\n\nimport sys\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\nreadlines = sys.stdin.readlines\n\n\n\ndef main():\n\n    N = int(readline())\n\n    X = [int(i) for i in readline().split()]\n\n    X = np.array(X)\n\n\n\n    ans = np.min(np.sum((X - np.arange(1,101).reshape(100, 1))**2, axis=1))\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "generated_code": "import sys\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\nreadlines = sys.stdin.readlines\n\n\n\ndef main():\n\n    N = int(readline())\n\n    X = [int(i) for i in readline().split()]\n\n\n\n    ans = float('inf')\n\n    for i in range(1,101):\n\n        tmp = 0\n\n        for x in X:\n\n            tmp += (x - i)**2\n\n        \n\n        if tmp < ans:\n\n            ans = tmp\n\n\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "score": 1.0, "codebleu": 0.5616461091095378, "crystalbleu": 0.5384837722021236, "codebertscore": 0.89, "codescore": 0.018362605944275856, "surfaceSim": 0.7979638009049774, "abs_surfaceSim_minus_score": 0.20203619909502257}
{"golden_code": "import numpy as np\n\n\n\nN = int(input())\n\nAs = list(map(int, input().split()))\n\n\n\n# for i in range(N):\n\n#   print(As.index(i+1) + 1, end = \" \")\n\n\n\nfor item in np.argsort(As):\n\n  print(item+1, end=\" \")\n", "generated_code": "N = int(eval(input()))\n\nAs = list(map(int, input().split()))\n\n\n\nans = [0] * N\n\n\n\nfor i, A in enumerate(As):\n\n  ans[A-1] = i+1\n\n  \n\nprint((*ans))", "score": 1.0, "codebleu": 0.35761204261882695, "crystalbleu": 0.0, "codebertscore": 0.83, "codescore": 0.24143671989440918, "surfaceSim": 0.6119232526267702, "abs_surfaceSim_minus_score": 0.38807674737322984}
{"golden_code": "# -*- coding: utf-8 -*-\n\nfrom collections import defaultdict\n\nfrom itertools import combinations\n\nN = int(eval(input()))\n\nC = [0, 0, 0, 0, 0, 0]\n\nD = defaultdict(int)\n\nfor i, m in enumerate(\"MARCH\", start=1):\n\n    D[m] = i\n\n\n\nfor _ in range(N):\n\n    C[D[input()[0]]] += 1\n\n\n\nans = 0\n\nfor a, b, c in combinations(list(range(1, 6)), r=3):\n\n    ans += C[a]*C[b]*C[c]\n\nprint(ans)", "generated_code": "from collections import defaultdict\n\nfrom itertools import combinations\n\ndef inpl(): return list(map(int, input().split()))\n\n\n\nC = defaultdict(int)\n\nN = int(eval(input()))\n\nfor _ in range(N):\n\n    C[input()[0]] += 1\n\n\n\nres = 0\n\nfor H in combinations(\"MARCH\", r=3):\n\n    res += C[H[0]] * C[H[1]] * C[H[2]]\n\nprint(res)", "score": 1.0, "codebleu": 0.30646801130107504, "crystalbleu": 0.3992314111977721, "codebertscore": 0.84, "codescore": 0.7838249802589417, "surfaceSim": 0.719, "abs_surfaceSim_minus_score": 0.281}
{"golden_code": "import numpy as np\n\nN,L = list(map(int, input().split()))\n\ntaste = np.array([L+i-1 for i in range(1,N+1)])\n\nif taste[-1] < 0:\n\n  print((sum(taste) + min(np.abs(taste))))\n\nelse:\n\n  print((sum(taste) - min(np.abs(taste))))", "generated_code": "N,L = list(map(int, input().split()))\n\ntaste = [L+i-1 for i in range(1,N+1)]\n\nif taste[-1] < 0:\n\n  print((sum(taste) + min([abs(x) for x in taste])))\n\nelse:\n\n  print((sum(taste) - min([abs(x) for x in taste])))", "score": 1.0, "codebleu": 0.38527373050610475, "crystalbleu": 0.7220260759077887, "codebertscore": 0.94, "codescore": 0.8979144096374512, "surfaceSim": 0.8446969696969697, "abs_surfaceSim_minus_score": 0.15530303030303028}
{"golden_code": "n, k = list(map(int, input().split()))\n\na_s = list(map(int, input().split()))\n\ndp = [\"Second\"] * (k + 1)\n\nfor i in range(k + 1):\n\n    if dp[i] == \"Second\":\n\n        for a in a_s:\n\n            ii = i + a\n\n            if ii <= k:\n\n                dp[ii] = \"First\"\n\nprint((dp[-1]))\n", "generated_code": "n, k = list(map(int, input().split()))\n\na_s = list(map(int, input().split()))\n\ndp = [\"Second\"] * (k + 1)\n\nfor i in range(k + 1):\n\n    if dp[i] == \"Second\":\n\n        for a in a_s:\n\n            ii = i + a\n\n            if ii > k:break\n\n            dp[ii] = \"First\"\n\nprint((dp[-1]))\n", "score": 1.0, "codebleu": 0.9200596498745525, "crystalbleu": 0.8903228609365674, "codebertscore": 0.99, "codescore": 0.9938223361968994, "surfaceSim": 0.9274551971326165, "abs_surfaceSim_minus_score": 0.07254480286738352}
{"golden_code": "# インポート\n\nimport numpy as np\n\n# A,B,Cの値の獲得\n\nnum = list(map(int, input().split()))\n\n# numリストの最大値を10倍\n\nnum[num.index(max(num))] = max(num) * 10\n\n# npで要素の和を計算し、出力\n\nprint((np.sum(num)))", "generated_code": "# A,B,Cの値の獲得\n\nnum = list(map(int, input().split()))\n\n# numリストの最大値を10倍\n\nnum[num.index(max(num))] *= 10\n\n# npで要素の和を計算し、出力\n\nprint((sum(num)))\n", "score": 1.0, "codebleu": 0.42987209164388324, "crystalbleu": 0.0, "codebertscore": 0.95, "codescore": 0.09599793702363968, "surfaceSim": 0.7944444444444445, "abs_surfaceSim_minus_score": 0.2055555555555555}
{"golden_code": "import statistics\n\nN = int(eval(input()))\n\na = [int(i) for i in input().split()]\n\nans = 0\n\n\n\nfor i in range(1,N+1):\n\n  a[i-1] -= i\n\n\n\nb = statistics.median(a)\n\nfor i in range(N):\n\n  ans += abs(a[i]-b)\n\nprint((int(ans)))", "generated_code": "N = int(eval(input()))\n\nA = [int(i) for i in input().split()]\n\nC = [A[i]-i for i in range(N)]\n\nC.sort()\n\nans = 0\n\nmed = C[N//2]\n\nfor i in range(N):\n\n  ans += abs(C[i]-med)\n\nprint(ans)", "score": 1.0, "codebleu": 0.4446310228895979, "crystalbleu": 0.3879392597446721, "codebertscore": 0.89, "codescore": 0.4115636944770813, "surfaceSim": 0.7664709719504239, "abs_surfaceSim_minus_score": 0.2335290280495761}
{"golden_code": "\"\"\"Minimum cost Sort.\"\"\"\n\n\n\ndef min_cost_sort(A):\n\n    \"\"\"Sort list A in ascending order.\n\n \n\n    And return the switching cost in sorting.\n\n    \"\"\"\n\n    B = list(A)\n\n    B.sort()\n\n    cost = 0\n\n    min_w = B[0]\n\n    for i, b in enumerate(B):\n\n        tmp_cost = 0\n\n        bi = A.index(b)\n\n        n = 1\n\n        while bi != i:\n\n            n += 1\n\n            st = B[bi]\n\n            si = A.index(st)\n\n            tmp_cost += b + st\n\n            A[bi], A[si] = st, b\n\n            bi = si\n\n        dec = (n - 1) * (b - min_w)\n\n        inc = 2 * (min_w + b)\n\n        if dec < inc:\n\n            cost += tmp_cost\n\n        else:\n\n            cost += tmp_cost - dec + inc\n\n    return cost\n\n\n\n\n\nn = eval(input())\n\n\n\nA = list(map(int, input().split()))\n\n\n\nans = min_cost_sort(A)\n\n\n\nprint(ans)", "generated_code": "\"\"\"Minimum cost Sort.\"\"\"\n\n\n\ndef min_cost_sort(A):\n\n    \"\"\"Sort list A in ascending order.\n\n \n\n    And return the switching cost in sorting.\n\n    \"\"\"\n\n    B = list(A)\n\n    B.sort()\n\n    cost = 0\n\n    min_w = B[0]\n\n    for i, b in enumerate(B):\n\n        tmp_cost = 0\n\n        bi = A.index(b)\n\n        cnt = 0\n\n        while bi != i:\n\n            cnt += 1\n\n            st = B[bi]\n\n            si = A.index(st)\n\n            tmp_cost += b + st\n\n            A[bi], A[si] = st, b\n\n            bi = si\n\n        if cnt:\n\n            dec = cnt * (b - min_w)\n\n            inc = 2 * (min_w + b)\n\n            if dec < inc:\n\n                cost += tmp_cost\n\n            else:\n\n                cost += tmp_cost - dec + inc\n\n    return cost\n\n\n\n\n\nn = eval(input())\n\n\n\nA = list(map(int, input().split()))\n\n\n\nans = min_cost_sort(A)\n\n\n\nprint(ans)", "score": 1.0, "codebleu": 0.8802608337277296, "crystalbleu": 0.9095477305288807, "codebertscore": 0.97, "codescore": 0.06050167232751846, "surfaceSim": 0.9903264812575574, "abs_surfaceSim_minus_score": 0.0096735187424426}
{"golden_code": "class SegmentTree:\n\n    seg_len = 1\n\n    node = []\n\n    def __init__(self, n):\n\n        while self.seg_len < n:\n\n            self.seg_len <<= 1\n\n        self.node = [ 0 for _ in range(self.seg_len*2) ]\n\n\n\n    def add(self, idx, v):\n\n        idx += self.seg_len\n\n        self.node[idx] += v\n\n        while True:\n\n            idx //= 2\n\n            if idx == 0:\n\n                break\n\n            self.node[idx] = self.node[idx*2] + self.node[idx*2+1]\n\n\n\n    def sum(self, l, r):\n\n        l += self.seg_len\n\n        r += self.seg_len\n\n        ret = 0\n\n        while l < r:\n\n            if l & 1 == 1:\n\n                ret += self.node[l]\n\n                l += 1\n\n            if r & 1 == 1:\n\n                ret += self.node[r-1]\n\n                r -= 1\n\n            l //= 2; r //= 2;\n\n        return ret\n\n\n\n\n\nn, k = list(map(int, input().split()))\n\np = [ int(x) for x in input().split() ]\n\n\n\nseg_tree = SegmentTree(n)\n\nfor i in range(n):\n\n    seg_tree.add(i, (1+p[i])/2)\n\n\n\nans = 0\n\nfor i in range(n-k+1):\n\n    ans = max(ans, seg_tree.sum(i, i+k))\n\n\n\nprint(ans)\n", "generated_code": "class SegmentTree:\n\n    seg_len = 1\n\n    node = []\n\n    def __init__(self, n):\n\n        while self.seg_len < n:\n\n            self.seg_len <<= 1\n\n        self.node = [ 0 for _ in range(self.seg_len*2) ]\n\n\n\n    def add(self, idx, v):\n\n        idx += self.seg_len\n\n        self.node[idx] += v\n\n        while True:\n\n            idx >>= 1\n\n            if idx == 0:\n\n                break\n\n            self.node[idx] = self.node[idx*2] + self.node[idx*2+1]\n\n\n\n    def sum(self, l, r):\n\n        l += self.seg_len\n\n        r += self.seg_len\n\n        ret = 0\n\n        while l < r:\n\n            if l & 1 == 1:\n\n                ret += self.node[l]\n\n                l += 1\n\n            if r & 1 == 1:\n\n                ret += self.node[r-1]\n\n                r -= 1\n\n            l >>= 1; r >>= 1;\n\n        return ret\n\n\n\n\n\nn, k = list(map(int, input().split()))\n\np = [ int(x) for x in input().split() ]\n\n\n\nseg_tree = SegmentTree(n)\n\nfor i in range(n):\n\n    seg_tree.add(i, (1+p[i])/2)\n\n\n\nans = 0\n\nfor i in range(n-k+1):\n\n    ans = max(ans, seg_tree.sum(i, i+k))\n\n\n\nprint(ans)\n", "score": 1.0, "codebleu": 0.9518794997963271, "crystalbleu": 0.9366687466080638, "codebertscore": 1.0, "codescore": 0.9935203194618225, "surfaceSim": 0.9687316911633594, "abs_surfaceSim_minus_score": 0.03126830883664056}
{"golden_code": "a, b = list(map(int, input().split()))\n\nif a*b%2 == 1:\n\n    print(\"Odd\")\n\nelse:\n\n    print(\"Even\")", "generated_code": "a, b = list(map(int, input().split()))\n\nprint(('Odd'if a&b&1 else 'Even'))", "score": 1.0, "codebleu": 0.5465642129184616, "crystalbleu": 0.0, "codebertscore": 0.92, "codescore": 0.957251787185669, "surfaceSim": 0.6422902494331066, "abs_surfaceSim_minus_score": 0.35770975056689336}
{"golden_code": "import sys\n\n\n\nn, m, *lr = list(map(int, sys.stdin.read().split()))\n\nlr = list(zip(*[iter(lr)] * 2))\n\n\n\ndef main():\n\n    cnt = [0] * (n + 1)\n\n    for l, r in lr:\n\n        cnt[l-1] += 1\n\n        cnt[r] -= 1\n\n    \n\n    for i in range(n):\n\n        cnt[i+1] += cnt[i]\n\n    \n\n    res = 0\n\n    for i in range(n):\n\n        res += (cnt[i] == m) & 1\n\n    \n\n    return res\n\n\n\nif __name__ == '__main__':\n\n    ans = main()\n\n    print(ans)", "generated_code": "import sys\n\n\n\nn, m, *lr = list(map(int, sys.stdin.read().split()))\n\nl, r = lr[::2], lr[1::2]\n\n\n\ndef main():\n\n    ans = max(min(r) - max(l) + 1, 0)\n\n    return ans\n\n\n\nif __name__ == '__main__':\n\n    ans = main()\n\n    print(ans)", "score": 1.0, "codebleu": 0.30662618959757326, "crystalbleu": 0.2800354182309023, "codebertscore": 0.84, "codescore": 0.019526274874806404, "surfaceSim": 0.7303921568627452, "abs_surfaceSim_minus_score": 0.26960784313725483}
{"golden_code": "a, b, c = sorted(map(int, input().split()))\n\n\n\nprint((c*10 + b + a))", "generated_code": "a, b, c = list(map(int, input().split()))\n\n\n\nprint((max(a, b, c)*9 + (a + b + c)))", "score": 1.0, "codebleu": 0.549214423833286, "crystalbleu": 0.0, "codebertscore": 0.92, "codescore": 0.026307061314582825, "surfaceSim": 0.8780487804878049, "abs_surfaceSim_minus_score": 0.12195121951219512}
{"golden_code": "import math\n\nimport numpy as np\n\nn, d = list(map(int, input().split()))\n\na = []\n\ncnt = 0\n\nfor x in range(n):\n\n    a.append(list(map(int, input().split())))\n\nfor i in range(len(a)):\n\n    for j in range(len(a)):\n\n        if i < j:\n\n            dis = np.array(a[i]) - np.array(a[j])\n\n            if np.linalg.norm(dis).is_integer():\n\n                cnt += 1\n\nprint(cnt)", "generated_code": "n, d = list(map(int, input().split()))\n\na = [[int(i) for i in input().split()] for i in range(n)]\n\nans = 0\n\ndef dis(x,y):\n\n    T = []\n\n    for i in range(len(x)):\n\n        T.append((x[i]-y[i])**2)\n\n    return sum(T)\n\nfor i in range(n):\n\n    for j in range(i+1,n):\n\n        r = dis(a[i], a[j])\n\n        for k in range(r + 1):\n\n            if k ** 2 == r:\n\n                ans += 1\n\nprint(ans)", "score": 1.0, "codebleu": 0.37043787570892733, "crystalbleu": 0.29626534259493903, "codebertscore": 0.83, "codescore": 0.6970815062522888, "surfaceSim": 0.5936803894068146, "abs_surfaceSim_minus_score": 0.40631961059318544}
{"golden_code": "\n\nX = int(eval(input()))\n\nfor a in range(-200, 200):\n\n    find = False\n\n    for b in range(-200, 200):\n\n        x = a**5-b**5\n\n        if x == X:\n\n            find = True\n\n            print((a, b))\n\n            break\n\n    if find:\n\n        break\n", "generated_code": "\n\nX = int(eval(input()))\n\nfor a in range(-120, 120):\n\n    find = False\n\n    for b in range(-120, 120):\n\n        x = a**5-b**5\n\n        if x == X:\n\n            find = True\n\n            print((a, b))\n\n            break\n\n    if find:\n\n        break\n", "score": 1.0, "codebleu": 0.8852092338600269, "crystalbleu": 0.0, "codebertscore": 0.98, "codescore": 0.9701367020606995, "surfaceSim": 0.983739837398374, "abs_surfaceSim_minus_score": 0.016260162601625994}
{"golden_code": "N = int(eval(input()))\n\nX = [[] for i in range(N)]\n\nfor i in range(N-1):\n\n    x, y = list(map(int, input().split()))\n\n    X[x-1].append(y-1)\n\n    X[y-1].append(x-1)\n\n\n\nP = [-1] * N\n\nDE = [0] * N\n\nQ = [0]\n\nwhile Q:\n\n    i = Q.pop()\n\n    for a in X[i][::-1]:\n\n        if a != P[i]:\n\n            P[a] = i\n\n            DE[a] = DE[i] + 1\n\n            X[a].remove(i)\n\n            Q.append(a)\n\n\n\ndef lp(u, v):\n\n    t = 0\n\n    while u != v:\n\n        if DE[u] > DE[v]:\n\n            t += 1 << u-1\n\n            u = P[u]\n\n        elif DE[u] < DE[v]:\n\n            t += 1 << v-1\n\n            v = P[v]\n\n        else:\n\n            t += 1 << u-1\n\n            t += 1 << v-1\n\n            u = P[u]\n\n            v = P[v]\n\n    \n\n    return t\n\n\n\nY = []\n\nM = int(eval(input()))\n\nfor _ in range(M):\n\n    a, b = list(map(int, input().split()))\n\n    a, b = a-1, b-1\n\n    Y.append(lp(a, b))\n\n\n\nD = {1<<i: i for i in range(50)}\n\nZ = [0] * (1<<M)\n\nans = 0\n\nCC = [0] * N\n\nBC = [0] * (1<<17)\n\nfor m in range(1, 1<<17):\n\n    a = m & (-m)\n\n    BC[m] = BC[m^a] + 1\n\nfor m in range(1<<M):\n\n    a = m & (-m)\n\n    if a == m:\n\n        if a == 0:\n\n            Z[m] = 0\n\n        else:\n\n            Z[m] = Y[D[a]]\n\n    else:\n\n        Z[m] = Z[m^a] | Y[D[a]]\n\n    \n\n    aa = Z[m]\n\n    bc = BC[aa % (1<<17)]\n\n    aa >>= 17\n\n    bc += BC[aa % (1<<17)]\n\n    aa >>= 17\n\n    bc += BC[aa]\n\n    CC[N - 1 - bc] += (1 if BC[m%1024] + BC[m>>10] & 1 == 0 else -1)\n\n\n\nprint((sum([2 ** i * CC[i] for i in range(N)])))", "generated_code": "N = int(eval(input()))\n\nX = [[] for i in range(N)]\n\nfor i in range(N-1):\n\n    x, y = list(map(int, input().split()))\n\n    X[x-1].append(y-1)\n\n    X[y-1].append(x-1)\n\n\n\nP = [-1] * N\n\nDE = [0] * N\n\nQ = [0]\n\nwhile Q:\n\n    i = Q.pop()\n\n    for a in X[i][::-1]:\n\n        if a != P[i]:\n\n            P[a] = i\n\n            DE[a] = DE[i] + 1\n\n            X[a].remove(i)\n\n            Q.append(a)\n\n\n\ndef lp(u, v):\n\n    t = 0\n\n    while u != v:\n\n        if DE[u] > DE[v]:\n\n            t += 1 << u-1\n\n            u = P[u]\n\n        elif DE[u] < DE[v]:\n\n            t += 1 << v-1\n\n            v = P[v]\n\n        else:\n\n            t += 1 << u-1\n\n            t += 1 << v-1\n\n            u = P[u]\n\n            v = P[v]\n\n    \n\n    return t\n\n\n\nY = []\n\nM = int(eval(input()))\n\nfor _ in range(M):\n\n    a, b = list(map(int, input().split()))\n\n    a, b = a-1, b-1\n\n    Y.append(lp(a, b))\n\n\n\ndef popcnt(n):\n\n    c = (n & 0x5555555555555555) + ((n>>1) & 0x5555555555555555)\n\n    c = (c & 0x3333333333333333) + ((c>>2) & 0x3333333333333333)\n\n    c = (c & 0x0f0f0f0f0f0f0f0f) + ((c>>4) & 0x0f0f0f0f0f0f0f0f)\n\n    c = (c & 0x00ff00ff00ff00ff) + ((c>>8) & 0x00ff00ff00ff00ff)\n\n    c = (c & 0x0000ffff0000ffff) + ((c>>16) & 0x0000ffff0000ffff)\n\n    c = (c & 0x00000000ffffffff) + ((c>>32) & 0x00000000ffffffff)\n\n    return c\n\n\n\nD = {1<<i: i for i in range(50)}\n\nZ = [0] * (1<<M)\n\nans = 0\n\nCC = [0] * N\n\nfor m in range(1<<M):\n\n    a = m & (-m)\n\n    if a == m:\n\n        if a == 0:\n\n            Z[m] = 0\n\n        else:\n\n            Z[m] = Y[D[a]]\n\n    else:\n\n        Z[m] = Z[m^a] | Y[D[a]]\n\n    \n\n    CC[N - 1 - popcnt(Z[m])] += (1 if popcnt(m) & 1 == 0 else -1)\n\n\n\nprint((sum([2 ** i * CC[i] for i in range(N)])))", "score": 1.0, "codebleu": 0.7841781132079317, "crystalbleu": 0.7679633086578852, "codebertscore": 0.9, "codescore": 0.9938263297080994, "surfaceSim": 0.8535173160173161, "abs_surfaceSim_minus_score": 0.14648268398268394}
{"golden_code": "import numpy as np\n\nN, K = list(map(int, input().split()))\n\nplist = list(map(int, input().split()))\n\nkitaiti = np.array([(0.5*(p+1)) for p in plist])\n\nans = 0\n\nval = sum(kitaiti[:K])\n\nans = max(ans, val)\n\nfor i in range(1, N-K+1):\n\n    # print(i-1, i+K)\n\n    val -= kitaiti[i-1]\n\n    val += kitaiti[i+K-1]\n\n    ans = max(ans, val)\n\nprint(ans)", "generated_code": "N, K = list(map(int, input().split()))\n\nplist = [((num*(num+1))//2)/num for num in list(map(int, input().split()))]\n\n# print(plist)\n\nans = 0\n\nfor i in range(K):\n\n    ans += plist[i]\n\n_ = ans\n\nfor i in range(N-K):\n\n    temp = _\n\n    temp -= plist[i]\n\n    temp += plist[i+K]\n\n    # print(i, i+K, ans, temp)\n\n    ans = max(ans, temp)\n\n    _ = temp\n\nprint(ans)", "score": 1.0, "codebleu": 0.32884250784999586, "crystalbleu": 0.3202517166442831, "codebertscore": 0.87, "codescore": 0.15550903975963593, "surfaceSim": 0.6837078651685393, "abs_surfaceSim_minus_score": 0.3162921348314607}
{"golden_code": "from collections import Counter,defaultdict,deque\n\nfrom heapq import heapify,heappop,heappush\n\nfrom bisect import bisect_left,bisect_right\n\nimport sys,math,itertools,string,queue\n\nsys.setrecursionlimit(10**8)\n\nmod = 10**9+7\n\ndef inp(): return int(sys.stdin.readline())\n\ndef inpl(): return list(map(int, sys.stdin.readline().split()))\n\ndef inpl_str(): return list(sys.stdin.readline().split())\n\ndef inpln(n): return list(int(sys.stdin.readline()) for i in range(n))\n\n\n\nn,m = inpl()\n\na = inpl()\n\nb = [0] * m\n\nfor i in range(m):\n\n    x,y = inpl()\n\n    b[i] = [x,y]\n\na.sort()\n\nb.sort(key=lambda x:x[1], reverse = True)\n\nres = sum(a)\n\ni = 0\n\nj = 0\n\nwhile True:\n\n    # print(i,j)\n\n    if a[i] < b[j][1]:\n\n        res += b[j][1] - a[i]\n\n        i += 1\n\n    else:\n\n        break\n\n    b[j][0] -= 1\n\n    if b[j][0] == 0:\n\n        j += 1\n\n    if i >= n or j >= m:\n\n        break\n\nprint(res)\n", "generated_code": "from collections import Counter,defaultdict,deque\n\nfrom heapq import heappop,heappush,heapify\n\nfrom bisect import bisect_left,bisect_right \n\nimport sys,math,itertools,fractions,pprint\n\nsys.setrecursionlimit(10**8)\n\nmod = 10**9+7\n\nINF = float('inf')\n\ndef inp(): return int(sys.stdin.readline())\n\ndef inpl(): return list(map(int, sys.stdin.readline().split()))\n\n\n\nn,m = inpl()\n\na = inpl()\n\na.sort()\n\nbc = [inpl() for _ in range(m)]\n\nbc.sort(key = lambda x:x[1], reverse = True)\n\nlm = sum(x[1] for x in bc)\n\nnow = 0\n\nalt = 0\n\nwhile now < n and alt < m:\n\n    c,b = bc[alt]\n\n    if a[now] > b:\n\n        break\n\n    else:\n\n        a[now] = b\n\n    bc[alt][0] -= 1\n\n    if bc[alt][0] == 0:\n\n        alt += 1\n\n    now += 1\n\nprint((sum(a)))\n", "score": 1.0, "codebleu": 0.4422076496413779, "crystalbleu": 0.4434165928801366, "codebertscore": 0.91, "codescore": 0.5564880967140198, "surfaceSim": 0.7410676532769556, "abs_surfaceSim_minus_score": 0.25893234672304444}
{"golden_code": "import sys\n\ninput = sys.stdin.readline\n\nfrom scipy.sparse.csgraph import dijkstra\n\nimport numpy as np\n\n\n\n\"\"\"\n\n最小カット\n\n\"\"\"\n\n\n\nN = int(eval(input()))\n\nstart = 0\n\ngoal = N+1\n\n\n\nA = [0] + [int(x) for x in input().split()]\n\n\n\nINF = 10 ** 12\n\ngraph = np.zeros((N+2,N+2),dtype=np.int64)\n\nfor i,a in enumerate(A[1:],1):\n\n    if a >= 0:\n\n        graph[start,i] = a\n\n    else:\n\n        graph[i,goal] = -a\n\nfor i in range(1,N+1):\n\n    for j in range(2*i,N+1,i):\n\n        if A[i] < 0 and A[j] > 0:\n\n            graph[j][i] = INF\n\n\n\ndef max_flow(graph):\n\n    flow = 0\n\n    while True:\n\n        dist,pred = dijkstra(graph, indices = start, return_predecessors = True, unweighted = True)\n\n        if dist[goal] == np.inf:\n\n            return flow\n\n        path = []\n\n        v = goal\n\n        while True:\n\n            path.append((pred[v],v))\n\n            v = pred[v]\n\n            if v == start:\n\n                break\n\n        add_flow = min(graph[x][y] for x,y in path)\n\n        for x,y in path:\n\n            graph[x][y] -= add_flow\n\n            graph[y][x] += add_flow\n\n        flow += add_flow\n\n\n\nanswer = sum(x for x in A if x > 0) - max_flow(graph)\n\nprint(answer)", "generated_code": "import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\nfrom collections import deque\n\n\n\nN,*A = list(map(int,read().split()))\n\n\n\nclass Dinic:\n\n    def __init__(self, N, source, sink):\n\n        self.N = N\n\n        self.G = [[] for _ in range(N)]\n\n        self.source = source\n\n        self.sink = sink\n\n\n\n    def add_edge(self, fr, to, cap):\n\n        n1 = len(self.G[fr])\n\n        n2 = len(self.G[to])\n\n        self.G[fr].append([to, cap, n2])\n\n        self.G[to].append([fr, 0, n1]) # 逆辺を cap 0 で追加\n\n        \n\n    def add_edge_undirected(self, fr, to, cap):\n\n        n1 = len(self.G[fr])\n\n        n2 = len(self.G[to])\n\n        self.G[fr].append([to, cap, n2])\n\n        self.G[to].append([fr, cap, n1])\n\n        \n\n    def bfs(self):\n\n        level = [0] * self.N\n\n        G = self.G; source = self.source; sink = self.sink\n\n        q = deque([source])\n\n        level[source] = 1\n\n        pop = q.popleft; append = q.append\n\n        while q:\n\n            v = pop()\n\n            lv = level[v] + 1\n\n            for to, cap, rev in G[v]:\n\n                if not cap:\n\n                    continue\n\n                if level[to]:\n\n                    continue\n\n                level[to] = lv\n\n                if to == sink:\n\n                    self.level = level\n\n                    return\n\n                append(to)\n\n        self.level = level\n\n        \n\n    def dfs(self,v,f):\n\n        if v == self.sink:\n\n            return f\n\n        G = self.G\n\n        prog = self.progress\n\n        level = self.level\n\n        lv = level[v]\n\n        E = G[v]\n\n        for i in range(prog[v],len(E)):\n\n            to, cap, rev = E[i]\n\n            prog[v] = i\n\n            if not cap:\n\n                continue\n\n            if level[to] <= lv:\n\n                continue\n\n            x = f if f < cap else cap\n\n            ff = self.dfs(to, x)\n\n            if ff:\n\n                E[i][1] -= ff\n\n                G[to][rev][1] += ff\n\n                return ff\n\n        return 0\n\n    \n\n    def max_flow(self):\n\n        INF = 10**18\n\n        flow = 0\n\n        while True:\n\n            self.bfs()\n\n            if not self.level[self.sink]:\n\n                return flow\n\n            self.progress = [0] * self.N\n\n            while True:\n\n                f = self.dfs(self.source, INF)\n\n                if not f:\n\n                    break\n\n                flow += f\n\n        return flow\n\n\n\nsource = 0; sink = N+1; INF = 10 ** 18\n\ndinic = Dinic(N+2,source,sink)\n\nadd = dinic.add_edge\n\n\n\nfor i,x in enumerate(A,1):\n\n    if x < 0:\n\n        # source側：割るものを表現。sink側にうつすときにカット-xが必要。\n\n        add(source,i,-x)\n\n    else:\n\n        # sink側：割らないものを表現。source側にうつすときにカットxが必要。\n\n        add(i,sink,x)\n\n\n\nfor i in range(1,N+1):\n\n    for j in range(i+i,N+1,i):\n\n        # iを割るならjも割る。iを割ってjを割らないのは禁止\n\n        # iがsourceでjがsinkなのは禁止\n\n        add(i,j,INF)\n\n\n\nf = dinic.max_flow()\n\nx = sum(x for x in A if x >= 0)\n\nanswer = x - f\n\n\n\nprint(answer)", "score": 1.0, "codebleu": 0.2951415422941989, "crystalbleu": 0.14609962305835508, "codebertscore": 0.76, "codescore": 0.9938555359840393, "surfaceSim": 0.6754496463455709, "abs_surfaceSim_minus_score": 0.3245503536544291}
{"golden_code": "X = int(eval(input()))\n\nfor A in range(-200, 200):\n\n    for B in range(-200, 200):\n\n        if A**5 - B**5 == X:\n\n            print((A, B))\n\n            break\n\n    else:\n\n        continue\n\n    break", "generated_code": "X = int(eval(input()))\n\nfor A in range(-150, 150):\n\n    for B in range(-150, 150):\n\n        if A**5 - B**5 == X:\n\n            print((A, B))\n\n            break\n\n    else:\n\n        continue\n\n    break", "score": 1.0, "codebleu": 0.848446312898335, "crystalbleu": 0.0, "codebertscore": 0.99, "codescore": 0.9534514546394348, "surfaceSim": 0.9797979797979798, "abs_surfaceSim_minus_score": 0.02020202020202022}
{"golden_code": "def solve():\n\n  N, K = list(map(int, input().split()))\n\n  _S = eval(input())\n\n  S = []\n\n  b = _S[0]\n\n  s = 0\n\n  if b == '0': S.append(0)\n\n  for _s in _S:\n\n    if b == _s:\n\n      s = s + 1\n\n    else:\n\n      b = _s\n\n      S.append(s)\n\n      s = 1\n\n  S.append(s)\n\n  if b == '0': S.append(0)\n\n\n\n  num = min(len(S), 2 * K + 1)\n\n  # n = sum(S[0:num if _S[0] == '1' else (num - 1)])\n\n  n = sum(S[0:num])\n\n  m = n\n\n  # for i in range(0 if _S[0] == '1' else -1, len(S) - num, 2):\n\n  for i in range(0, len(S) - num, 2):\n\n    n = n - sum(S[i:i+2])\n\n    n = n + sum(S[i + num:i + num + 2])\n\n    m = max(m, n)\n\n\n\n  return m\n\n\n\nprint((solve()))", "generated_code": "def solve():\n\n  N, K = list(map(int, input().split()))\n\n  s = eval(input())\n\n  S = []\n\n  b = s[0]\n\n  cnt = 0\n\n\n\n  if s[0] == '0': S.append(0)\n\n  for c in s:\n\n    if b == c: cnt = cnt + 1\n\n    else:\n\n      b = c\n\n      S.append(cnt)\n\n      cnt = 1\n\n  S.append(cnt)\n\n  if s[-1] == '0': S.append(0)\n\n\n\n  num = min(len(S), 2 * K + 1)\n\n  part = sum(S[0:num])\n\n  ans = part\n\n\n\n  for i in range(0, len(S) - num, 2):\n\n    part = part - sum(S[i:i+2]) + sum(S[i + num:i + num + 2])\n\n    ans = max(ans, part)\n\n\n\n  return ans\n\n\n\nprint((solve()))\n", "score": 1.0, "codebleu": 0.6313933709122763, "crystalbleu": 0.6433292327447292, "codebertscore": 0.91, "codescore": 0.978976309299469, "surfaceSim": 0.9034391534391535, "abs_surfaceSim_minus_score": 0.09656084656084651}
{"golden_code": "a, b, c, x, y = list(map(int, input().split()))\n\nab = c * 2\n\n\n\nres = float(\"inf\")\n\nif a + b <= ab:\n\n    res = x * a + y * b\n\nelse:\n\n    if x == y:\n\n        res = x * ab\n\n    elif x > y:\n\n        for i in range(y, x + 1):\n\n            cost = i * ab + (x - i) * a\n\n            res = min(res, cost)\n\n    else:\n\n        for i in range(x, y + 1):\n\n            cost = i * ab + (y - i) * b\n\n            res = min(res, cost)\n\nprint(res)\n", "generated_code": "import sys\n\n\n\nsys.setrecursionlimit(10 ** 7)\n\ninput = sys.stdin.readline\n\nf_inf = float('inf')\n\nmod = 10 ** 9 + 7\n\n\n\n\n\ndef resolve():\n\n    a, b, c, x, y = list(map(int, input().split()))\n\n    c *= 2\n\n    if a + b > c:\n\n        cost1 = max(x, y) * c\n\n        cost2 = min(x, y) * c\n\n        plus = ((y - x) * b) if x < y else (x - y) * a\n\n        res = min(cost1, cost2 + plus)\n\n    else:\n\n        res = x * a + y * b\n\n    print(res)\n\n\n\nif __name__ == '__main__':\n\n    resolve()\n", "score": 1.0, "codebleu": 0.32879456428646386, "crystalbleu": 0.28512864511022135, "codebertscore": 0.83, "codescore": 0.01860968768596649, "surfaceSim": 0.5709044624138964, "abs_surfaceSim_minus_score": 0.42909553758610364}
{"golden_code": "a,b,c,d,e,f=[int(eval(input())) for _ in range(6)]\n\nprint((sum([a,b,c,d,max(e,f)])-min([a,b,c,d])))", "generated_code": "print((sum(sorted(int(eval(input())) for _ in range(4))[1:])+max([int(eval(input())) for _ in range(2)])))", "score": 1.0, "codebleu": 0.2242737827628642, "crystalbleu": 0.23837482432405213, "codebertscore": 0.82, "codescore": 0.018554097041487694, "surfaceSim": 0.49947589098532497, "abs_surfaceSim_minus_score": 0.500524109014675}
{"golden_code": "from collections import Counter\n\n\n\nN = int(eval(input()))\n\ninputs = [int(i) for i in input().split()]\n\n\n\nans = 0\n\nruisekiwa = [0] * (N+1)\n\n\n\nfor i in range(N):\n\n    ruisekiwa[i+1] = ruisekiwa[i] + inputs[i]\n\n\n\nruisekiwa = ruisekiwa[1:]\n\nruisekiwa.sort()\n\ncounter_ruiseki = Counter(ruisekiwa)\n\n\n\nfor key, value in list(counter_ruiseki.items()):\n\n    if key == 0 and value == 1:\n\n        ans += value\n\n        continue\n\n    elif key == 0 and value > 1:\n\n        ans += value\n\n    if value > 1:\n\n        ans += sum(list(range(value)))\n\n\n\nprint(ans)\n", "generated_code": "from collections import Counter\n\nfrom itertools import accumulate\n\n\n\nN = int(eval(input()))\n\ninputs = [int(i) for i in input().split()]\n\n\n\nans = 0\n\n\n\nruisekiwa = list(accumulate(inputs))\n\nruisekiwa.sort()\n\ncounter_ruiseki = Counter(ruisekiwa)\n\n\n\nfor key, value in list(counter_ruiseki.items()):\n\n    if key == 0 and value == 1:\n\n        ans += value\n\n        continue\n\n    elif key == 0 and value > 1:\n\n        ans += value\n\n    if value > 1:\n\n        ans += sum(list(range(value)))\n\n\n\nprint(ans)\n", "score": 1.0, "codebleu": 0.6536245096727219, "crystalbleu": 0.6488632351815146, "codebertscore": 0.93, "codescore": 0.8304386734962463, "surfaceSim": 0.802930402930403, "abs_surfaceSim_minus_score": 0.19706959706959704}
{"golden_code": "a,b=list(map(int,input().split()))\n\nans=0\n\nfor i in range(b+1)[a:]:\n\n  if len(str(i))%2==0:\n\n    p=list(str(i))[:len(str(i))//2]\n\n    q=list(reversed(list(str(i))[len(str(i))//2:]))\n\n    if p==q:\n\n      ans+=1\n\n  else:\n\n    s=list(str(i))[:len(str(i))//2+1]\n\n    d=list(reversed(list(str(i))[len(str(i))//2:]))\n\n    if s==d:\n\n      ans += 1\n\nprint(ans)", "generated_code": "a,s=list(map(int,input().split()))\n\nad=0\n\nfor i in range(a,s+1):\n\n  if str(i)==str(i)[::-1]:ad+=1\n\nprint(ad)", "score": 1.0, "codebleu": 0.19512209630861393, "crystalbleu": 0.07283660928949401, "codebertscore": 0.82, "codescore": 0.7764309644699097, "surfaceSim": 0.6246912055335969, "abs_surfaceSim_minus_score": 0.3753087944664031}
{"golden_code": "#!/usr/bin/env python3\n\ndef main():\n\n    import numpy as np\n\n\n\n    np.set_printoptions(linewidth=200)\n\n\n\n    N, W = list(map(int, input().split()))\n\n    lst = [list(map(int, input().split())) for _ in range(N)]\n\n    v_max = 10 ** 3 * 100 * 10\n\n    w_max = 10 ** 9 * v_max\n\n\n\n    # i以上の価値を持つときの最小重量\n\n    dp = np.full(v_max, w_max, dtype=np.int64)\n\n    # initialize\n\n    dp[0] = 0\n\n\n\n    for n in range(N):\n\n        w, v = lst[n]\n\n        dp[v:] = np.minimum(dp[v:], dp[:-v] + w)\n\n\n\n    ans = 0\n\n    for i, w in enumerate(dp):\n\n        if w <= W:\n\n            ans = i\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "generated_code": "#!/usr/bin/env python3\n\ndef main():\n\n    import numpy as np\n\n\n\n    N, W = list(map(int, input().split()))\n\n    lst = [list(map(int, input().split())) for _ in range(N)]\n\n    v_max = 10 ** 3 * 100 * 10\n\n    w_max = 10 ** 9 * v_max\n\n\n\n    # i以上の価値を持つときの最小重量\n\n    dp = np.full(v_max, w_max, dtype=np.int64)\n\n    # initialize\n\n    dp[0] = 0\n\n\n\n    for w, v in lst:\n\n        dp[v:] = np.minimum(dp[v:], dp[:-v] + w)\n\n\n\n    print((np.asarray(dp <= W).nonzero()[0].max()))\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 1.0, "codebleu": 0.7189057468667899, "crystalbleu": 0.7204244793230812, "codebertscore": 0.94, "codescore": 0.018541431054472923, "surfaceSim": 0.9217252396166133, "abs_surfaceSim_minus_score": 0.07827476038338665}
{"golden_code": "n = int(eval(input()))\n\n\n\nXY = []\n\nfor i in range(n):\n\n    a = int(eval(input()))\n\n    xy = []\n\n    for j in range(a):\n\n        xy.append(list(map(int, input().split())))\n\n    \n\n    XY.append(xy)\n\n    \n\ndef check(i, xiyj, HoU):\n\n    # 矛盾したらFalse 正直者と仮定した証言より 正直&正直者と仮定されている / 不親切&不親切と仮定されている True\n\n    if ((i >> xiyj) & 1) ^ HoU:\n\n        return False\n\n\n\n    return True\n\n    \n\nmax_honest = 0\n\nfor i in range(2 ** len(XY)):\n\n    count = 0\n\n    is_contradiction = True\n\n    for j in range(len(XY)):\n\n        # 正直者と仮定したときだけ採用\n\n        if not ((i >> j) & 1): continue\n\n        for k in range(len(XY[j])):\n\n            xiyj = XY[j][k][0] - 1\n\n            HoU = XY[j][k][1]\n\n            \n\n            if not check(i, xiyj, HoU):\n\n                is_contradiction = False\n\n                break\n\n                \n\n        if not is_contradiction:\n\n            break\n\n\n\n    if is_contradiction:\n\n        for j in range(len(XY)):\n\n            if ((i >> j) & 1): count+=1 \n\n                \n\n        if count > max_honest:\n\n            max_honest =count\n\n            \n\nprint(max_honest)", "generated_code": "n = int(eval(input()))\n\n\n\nXY = []\n\nfor i in range(n):\n\n    a = int(eval(input()))\n\n    xy = []\n\n    for j in range(a):\n\n        xy.append(list(map(int, input().split())))\n\n    \n\n    XY.append(xy)\n\n\n\n\"\"\"\n\n    矛盾したらFalse\n\n    矛盾しなければTrue\n\n    正直者と仮定した者の証言\n\n        正直&正直者と仮定されている\n\n        不親切&不親切と仮定されている\n\n\"\"\"\n\ndef check(i, xiyj, HoU):\n\n    # XOR\n\n    if HoU ^ ((i >> xiyj) & 1):\n\n        return False\n\n\n\n    return True\n\n\n\nmax_honest = 0\n\nfor i in range(2 ** len(XY)):\n\n    count = 0\n\n    is_contradiction = True\n\n    for j in range(len(XY)):\n\n        # 正直者と仮定したときだけ採用\n\n        if not ((i >> j) & 1): continue\n\n        count+=1\n\n        for k in range(len(XY[j])):\n\n            xiyj = XY[j][k][0] - 1\n\n            HoU = XY[j][k][1]\n\n            \n\n            if not check(i, xiyj, HoU):\n\n                is_contradiction = False\n\n                break # TLE対策\n\n                \n\n        if not is_contradiction:\n\n            break # TLE対策\n\n\n\n    # 矛盾がなく、正直者の数が更新できれば更新\n\n    if is_contradiction and (count > max_honest):\n\n        max_honest =count\n\n            \n\nprint(max_honest)", "score": 1.0, "codebleu": 0.7841640852458953, "crystalbleu": 0.8390116633223501, "codebertscore": 0.94, "codescore": 0.9937509894371033, "surfaceSim": 0.9042617046818727, "abs_surfaceSim_minus_score": 0.09573829531812728}
{"golden_code": "N, D = list(map(int, input().split()))\n\ncnt = 0\n\nfor _ in range(N):\n\n    x, y = list(map(int, input().split()))\n\n    if x ** 2 + y ** 2 <= D ** 2:\n\n        cnt += 1\n\n        \n\nprint(cnt)", "generated_code": "N, D = list(map(int, input().split()))\n\ncnt = 0\n\nfor _ in range(N):\n\n    x, y = list(map(int, input().split()))\n\n    if x * x + y * y <= D * D:\n\n        cnt += 1\n\n        \n\nprint(cnt)", "score": 1.0, "codebleu": 0.7862404220058002, "crystalbleu": 0.8164474750850377, "codebertscore": 0.96, "codescore": 0.78861004114151, "surfaceSim": 0.9312393887945671, "abs_surfaceSim_minus_score": 0.06876061120543286}
{"golden_code": "import sys\n\nfrom operator import itemgetter\n\n\n\nn, m = list(map(int, input().split()))\n\na = list(map(int, sys.stdin.readline().split()))\n\nbc = [ tuple(map(int, x.split())) for x in sys.stdin.readlines()]\n\nbc.sort(key = itemgetter(1), reverse=True)\n\nbc.append((n,0))\n\ndiff = []\n\nfor b, c in bc:\n\n    diff += [c] * b\n\n    if len(diff) > n:\n\n        break\n\n\n\na += diff\n\na.sort()\n\nprint((sum(a[-n:])))\n", "generated_code": "import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nfrom operator import itemgetter\n\n\n\nn, m = list(map(int, readline().split()))\n\na = list(map(int, readline().split()))\n\nm = list(map(int, read().split()))\n\nbc = list(zip(m,m))\n\n\n\nbc.sort(key = itemgetter(1), reverse=True)\n\nbc.append((n,0))\n\ndiff = []\n\nfor b, c in bc:\n\n    diff += [c] * b\n\n    if len(diff) > n:\n\n        break\n\n\n\na += diff\n\na.sort()\n\nprint((sum(a[-n:])))\n", "score": 1.0, "codebleu": 0.6746588487469303, "crystalbleu": 0.7449297660627612, "codebertscore": 0.94, "codescore": 0.7495846748352051, "surfaceSim": 0.8344444444444444, "abs_surfaceSim_minus_score": 0.16555555555555557}
{"golden_code": "from fractions import gcd\n\n\n\nn,m=list(map(int,input().split()))\n\na=list(map(int,input().split()))\n\na=list(set(a))\n\n\n\na=list([x//2 for x in a])\n\n\n\ndef lcm(q):\n\n  x = q[0]\n\n  for i in range(1, len(q)):\n\n    x = (x * q[i]) // gcd(x, q[i])\n\n  return x\n\n\n\nlcma=lcm(a)\n\n\n\nif (lcma//a[0])%2==0:\n\n  print((0))\n\nelse:\n\n  flg=0\n\n  for i in range(1,len(a)):\n\n    if (lcma//a[i])%2==0:\n\n      print((0))\n\n      flg=1\n\n      break\n\n  if flg==0:\n\n    temp=m//lcma\n\n    print((temp//2 if temp%2==0 else temp//2+1))", "generated_code": "from math import gcd\n\nn,m=list(map(int,input().split()))\n\na=list(map(int,input().split()))\n\na=list(set(a))\n\na=list([x//2 for x in a])\n\n\n\ndef lcm(q):\n\n  x = q[0]\n\n  for i in range(1, len(q)):\n\n    x = (x * q[i]) // gcd(x, q[i])\n\n  return x\n\n\n\nlcma=lcm(a)\n\nfor i in range(len(a)):\n\n  if (lcma//a[i])%2==0:\n\n    print((0))\n\n    exit()\n\ntemp=m//lcma\n\nprint((temp//2 if temp%2==0 else temp//2+1))", "score": 1.0, "codebleu": 0.7667790229313646, "crystalbleu": 0.77239021698609, "codebertscore": 0.96, "codescore": 0.9581681489944458, "surfaceSim": 0.9117266791647811, "abs_surfaceSim_minus_score": 0.08827332083521888}
{"golden_code": "s=eval(input())\n\nt=eval(input())\n\ns*=2\n\nnext=[[-1]*26 for _ in range(len(s))]\n\nalph=[[]for _ in range(26)]\n\nfor i in range(len(s)):\n\n\talph[ord(s[i])-ord(\"a\")].append(i)\n\nfrom bisect import bisect_right\n\nfor i in range(len(s)//2):\n\n\tfor j in range(26):\n\n\t\tif len(alph[j])>bisect_right(alph[j],i):\n\n\t\t\tnext[i][j]=alph[j][bisect_right(alph[j],i)]\n\nans=1\n\nnow=len(s)//2-1\n\nfor x in t:\n\n\tr=ord(x)-ord(\"a\")\n\n\tnow=next[now][r]\n\n\tif now==-1:\n\n\t\tprint((-1))\n\n\t\texit()\n\n\tif now>=len(s)//2:\n\n\t\tans+=len(s)//2\n\n\t\tnow-=len(s)//2\n\nprint((ans+now-len(s)//2))", "generated_code": "#O(|S|log|s|)\n\ndef main():\n\n\ts=eval(input())\n\n\tt=eval(input())\n\n\tn=len(s)\n\n\tnow=-1\n\n\tans=1\n\n\tif not set(t)<=set(s):#tがsの部分集合でない\n\n\t\tprint((-1))\n\n\t\texit()\n\n\tfor x in t:\n\n\t\tnow=s.find(x,now+1)#nowより大きいところからxを探す\n\n\t\tif now==-1:#nowより大きいところでxが見つからなかったら\n\n\t\t\tans+=n\n\n\t\t\tnow=s.find(x)\n\n\tprint((ans+now))\n\nif __name__ == '__main__':\n\n\tmain()", "score": 1.0, "codebleu": 0.16404167581080745, "crystalbleu": 0.0966474554057038, "codebertscore": 0.74, "codescore": 0.028712857514619827, "surfaceSim": 0.4332141696457589, "abs_surfaceSim_minus_score": 0.5667858303542411}
{"golden_code": "a,b = list(map(int,input().split()))\n\nanswer = 0\n\nfor i in range(a,b+1) :\n\n    j = str(i)\n\n    p1 = j[4]\n\n    p2 = j[3]\n\n    p3 = j[2]\n\n    p4 = j[1]\n\n    p5 = j[0]\n\n    k = int(p1+p2+p3+p4+p5)\n\n    if i == k :\n\n        answer += 1\n\nprint(answer)\n\n\n", "generated_code": "A,B = list(map(int,input().split()))\n\nans = 0\n\nfor i in range(A,B+1) :\n\n    l = str(i)\n\n    if l[0] == l[4] and l[1] == l[3] :\n\n        ans += 1\n\nprint(ans)\n", "score": 1.0, "codebleu": 0.3398676706155547, "crystalbleu": 0.0, "codebertscore": 0.87, "codescore": 0.8875152468681335, "surfaceSim": 0.8118187033849684, "abs_surfaceSim_minus_score": 0.18818129661503158}
{"golden_code": "'''\n\n    Auther: ghoshashis545 Ashis Ghosh\n\n    College: jalpaiguri Govt Enggineering College\n\n\n\n'''\n\nfrom os import path\n\nimport sys\n\nfrom functools import cmp_to_key as ctk\n\nfrom collections import deque,defaultdict as dd \n\nfrom bisect import bisect,bisect_left,bisect_right,insort,insort_left,insort_right\n\nfrom itertools import permutations\n\nfrom datetime import datetime\n\nfrom math import ceil,sqrt,log,gcd\n\ndef ii():return int(eval(input()))\n\ndef si():return eval(input())\n\ndef mi():return list(map(int,input().split()))\n\ndef li():return list(mi())\n\nabc='abcdefghijklmnopqrstuvwxyz'\n\nmod=1000000007\n\n#mod=998244353\n\ninf = float(\"inf\")\n\nvow=['a','e','i','o','u']\n\ndx,dy=[-1,1,0,0],[0,0,1,-1]\n\n\n\ndef bo(i):\n\n    return ord(i)-ord('a')\n\n\n\nfile = 0\n\n\n\ndef solve():\n\n    \n\n\n\n\n\n\n\n    # for _ in range(ii()):\n\n\n\n    n=ii()\n\n    n%=1000\n\n    if n!=0:\n\n        n=1000-n\n\n    print(n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nif __name__ ==\"__main__\":\n\n\n\n    if(file):\n\n\n\n        if path.exists('input1.txt'):\n\n            sys.stdin=open('input1.txt', 'r')\n\n            sys.stdout=open('output1.txt','w')\n\n        else:\n\n            input=sys.stdin.readline\n\n    solve()", "generated_code": "'''\n\n    Auther: ghoshashis545 Ashis Ghosh\n\n    College: jalpaiguri Govt Enggineering College\n\n\n\n'''\n\nfrom os import path\n\nimport sys\n\nfrom heapq import heappush,heappop\n\nfrom functools import cmp_to_key as ctk\n\nfrom collections import deque,defaultdict as dd \n\nfrom bisect import bisect,bisect_left,bisect_right,insort,insort_left,insort_right\n\nfrom itertools import permutations\n\nfrom datetime import datetime\n\nfrom math import ceil,sqrt,log,gcd\n\ndef ii():return int(eval(input()))\n\ndef si():return eval(input())\n\ndef mi():return list(map(int,input().split()))\n\ndef li():return list(mi())\n\nabc='abcdefghijklmnopqrstuvwxyz'\n\nmod=1000000007\n\n# mod=998244353\n\ninf = float(\"inf\")\n\nvow=['a','e','i','o','u']\n\ndx,dy=[-1,1,0,0],[0,0,1,-1]\n\n\n\ndef bo(i):\n\n    return ord(i)-ord('a')\n\n\n\nfile=0\n\n\n\n\n\n\n\n\n\n\n\ndef solve():\n\n\n\n\n\n    # for _ in range(ii()):\n\n    \n\n        \n\n\n\n    n=ii()\n\n    n%=1000\n\n    if(n!=0):\n\n        n=1000-n\n\n    print(n)\n\n \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n        \n\nif __name__ ==\"__main__\":\n\n\n\n    if(file):\n\n\n\n        if path.exists('input1.txt'):\n\n            sys.stdin=open('input1.txt', 'r')\n\n            sys.stdout=open('output1.txt','w')\n\n        else:\n\n            input=sys.stdin.readline\n\n    solve()\n", "score": 1.0, "codebleu": 0.9305926241207527, "crystalbleu": 0.9540105209643884, "codebertscore": 0.98, "codescore": 0.9937564134597778, "surfaceSim": 0.9859271523178808, "abs_surfaceSim_minus_score": 0.01407284768211925}
{"golden_code": "import numpy as np\n\nn,d=list(map(int,input().split()))\n\nnda=np.empty((0,d),int)\n\nans=0\n\nfor i in range(0,n):\n\n  a=np.array([list(map(int,input().split()))])\n\n  for j in range(i):\n\n    chklen=np.linalg.norm(a-nda[j])\n\n    if chklen==chklen//1:\n\n      ans+=1\n\n  nda=np.append(nda,a,axis=0)\n\nprint(ans)", "generated_code": "import math\n\nn,d=list(map(int,input().split()))\n\na=[0]*n\n\nfor i in range(n):\n\n  a[i]=list(map(int,input().split()))\n\nans=0\n\nfor i in range(n-1):\n\n  for j in range(i+1,n):\n\n    chklen=0\n\n    wk=0\n\n    for k in range(d):\n\n      wk+=abs(a[i][k]-a[j][k])**2\n\n    chklen=math.sqrt(wk)\n\n    if chklen==chklen//1:\n\n      ans+=1\n\nprint(ans)", "score": 1.0, "codebleu": 0.37263528653265, "crystalbleu": 0.3451581777582674, "codebertscore": 0.87, "codescore": 0.8696966171264648, "surfaceSim": 0.715528781793842, "abs_surfaceSim_minus_score": 0.28447121820615795}
{"golden_code": "import math\n\nn=int(eval(input()))\n\nans=n\n\ni=1\n\nwhile(i<=math.sqrt(n)):\n\n    if n%i==0:\n\n        d=i+n/i-2\n\n        ans=min(ans,d)\n\n    i+=1\n\nprint((int(ans)))", "generated_code": "from math import floor\n\nfrom math import sqrt\n\nn=int(eval(input()))\n\nnn=floor(sqrt(n))\n\nrest=n%nn\n\nwhile rest!=0:\n\n    nn-=1\n\n    rest=n%nn\n\nnnn=n/nn\n\nprint((int(nn+nnn-2)))", "score": 1.0, "codebleu": 0.2189753588334301, "crystalbleu": 0.0, "codebertscore": 0.84, "codescore": 0.6722500324249268, "surfaceSim": 0.5796001926782274, "abs_surfaceSim_minus_score": 0.4203998073217726}
{"golden_code": "N, M = (int(x) for x in input().split())\n\nedge = [tuple(int(x) for x in input().split()) for _ in range(M)]\n\n\n\nimport numpy as np\n\nfrom scipy.sparse.csgraph import floyd_warshall\n\nINF = 100\n\ntmpl_graph = [[INF if i != j else 0 for j in range(N)] for i in range(N)]\n\n\n\nans = 0\n\nfor E in edge:\n\n    edgeWithoutE = edge.copy()\n\n    edgeWithoutE.remove(E)\n\n    graph = np.array(tmpl_graph)\n\n    for x in edgeWithoutE:\n\n        graph[x[0]-1,x[1]-1] = 1\n\n        graph[x[1]-1,x[0]-1] = 1\n\n    graph = floyd_warshall(graph,directed=False)\n\n    if len(graph[graph == 100]) > 0:\n\n        ans += 1\n\nprint(ans)", "generated_code": "\n\nclass node:\n\n    def __init__(self, id):\n\n        self.id = id\n\n        self.root = self\n\n\n\n    def findRoot(self):\n\n        if self == self.root:\n\n            return self\n\n        else:\n\n            self.root = self.root.findRoot()\n\n            return self.root\n\n\n\n    def resetRoot(self):\n\n        self.root = self\n\n\n\nclass Tree:\n\n    def __init__(self, num):\n\n        self.nodes = {i:node(i) for i in range(num)}\n\n\n\n    def union(self, one, other):\n\n        root1 = one.findRoot()\n\n        root2 = other.findRoot()\n\n        root1.root = root2.root = self.nodes[min(root1.id, root2.id)]\n\n\n\n    def resetTree(self):\n\n        for n in list(self.nodes.values()):\n\n            n.resetRoot()\n\n\n\n    def makeTree(self, Edge):\n\n        self.edge = Edge\n\n        for x,y in Edge:\n\n            self.union(self.nodes[x-1], self.nodes[y-1])\n\n\n\n\n\ndef main():\n\n    with open(0) as f:\n\n        N, M = list(map(int, f.readline().split()))\n\n        Edge = [tuple(map(int, line.split())) for line in f.readlines()]\n\n    \n\n    tree = Tree(N)\n\n    ans = 0\n\n    for i in range(M):\n\n        edge = [v for  v in Edge if v != Edge[i]]\n\n        tree.makeTree(edge)\n\n        if any(x.findRoot().id != 0 for x in list(tree.nodes.values())):\n\n            ans += 1\n\n        tree.resetTree()\n\n    print(ans)\n\n\n\nif __name__ == '__main__':\n\n    main()", "score": 1.0, "codebleu": 0.25543156992904126, "crystalbleu": 0.09746240221919772, "codebertscore": 0.72, "codescore": 0.019634097814559937, "surfaceSim": 0.5431308634123072, "abs_surfaceSim_minus_score": 0.4568691365876928}
{"golden_code": "s = eval(input())\n\ncnt = 0\n\nfor i in range(len(s) - 1):\n\n    if s[i] == 'W' and s[i + 1] == 'B':\n\n        cnt += 1\n\n    if s[i] == 'B' and s[i + 1] == 'W':\n\n        cnt += 1\n\nprint(cnt)", "generated_code": "S = eval(input())\n\n\n\ntmp = S[0]\n\ncnt = 0\n\nfor s in S[1:]:\n\n    if tmp != s:\n\n        cnt += 1\n\n        tmp = s\n\n        \n\nprint(cnt)", "score": 1.0, "codebleu": 0.2363315607236966, "crystalbleu": 0.0, "codebertscore": 0.85, "codescore": 0.24440273642539978, "surfaceSim": 0.6300982800982801, "abs_surfaceSim_minus_score": 0.36990171990171994}
{"golden_code": "S=eval(input())\n\nprint((S.rfind('Z')-S.find('A')+1))", "generated_code": "s=input().strip()\n\na = s.find('A')\n\nz = s.rfind('Z')\n\nprint((z-a+1))\n", "score": 1.0, "codebleu": 0.36904761904761907, "crystalbleu": 0.0, "codebertscore": 0.9, "codescore": 0.31447258591651917, "surfaceSim": 0.7463768115942029, "abs_surfaceSim_minus_score": 0.2536231884057971}
{"golden_code": "import sys\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\nreadlines = sys.stdin.readlines\n\n\n\nMOD = 10**9+7\n\n\n\nfac = [1, 1]     # 元テーブル\n\nf_inv = [1, 1]   # 逆元テーブル\n\ninv = [0, 1]     # 逆元テーブル計算用テーブル\n\ndef prepare(n, mod):\n\n    for i in range(2, n+1):\n\n        fac.append((fac[-1] * i) % mod)\n\n        inv.append((-inv[mod % i] * (mod//i)) % mod)\n\n        f_inv.append((f_inv[-1] * inv[-1]) % mod)\n\n\n\n\n\ndef cmb(n, r, mod):\n\n    if n < 0 or r < 0:\n\n        return 0\n\n    if r > n:\n\n        return 0\n\n\n\n    return fac[n] * f_inv[r] * f_inv[n-r] % mod\n\n\n\n\n\ndef prime_factorization(n):\n\n    d = []\n\n    i, e = 2, 0  # factor, exponent\n\n    while i * i <= n:\n\n        while n % i == 0:\n\n            n //= i\n\n            e += 1\n\n        if e > 0:\n\n            d.append((i, e))\n\n        i += 1\n\n        e = 0\n\n    if n > 1:\n\n        d.append((n, 1))\n\n    return d\n\n\n\n\n\ndef main():\n\n    N,M = list(map(int, readline().split()))\n\n\n\n    prepare(N+100, MOD)\n\n    d = prime_factorization(M)\n\n\n\n    ans = 1\n\n    for i, e in d:\n\n        ans *= cmb(N-1+e, e, MOD)\n\n        ans %= MOD\n\n\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "generated_code": "import sys\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\nreadlines = sys.stdin.readlines\n\n\n\nMOD = 10**9+7\n\n\n\nfac = [1, 1]     # 元テーブル\n\nf_inv = [1, 1]   # 逆元テーブル\n\ninv = [0, 1]     # 逆元テーブル計算用テーブル\n\ndef prepare(n, mod):\n\n    for i in range(2, n+1):\n\n        fac.append((fac[-1] * i) % mod)\n\n\n\n\n\ndef cmb(n, r, mod):\n\n    if n < 0 or r < 0:\n\n        return 0\n\n    if r > n:\n\n        return 0\n\n\n\n    return fac[n] * pow(fac[r],MOD-2,MOD) * pow(fac[n-r],MOD-2,MOD) % mod\n\n\n\n\n\ndef prime_factorization(n):\n\n    d = []\n\n    i, e = 2, 0  # factor, exponent\n\n    while i * i <= n:\n\n        while n % i == 0:\n\n            n //= i\n\n            e += 1\n\n        if e > 0:\n\n            d.append((i, e))\n\n        i += 1\n\n        e = 0\n\n    if n > 1:\n\n        d.append((n, 1))\n\n    return d\n\n\n\n\n\ndef main():\n\n    N,M = list(map(int, readline().split()))\n\n\n\n    prepare(N+100, MOD)\n\n    d = prime_factorization(M)\n\n\n\n    ans = 1\n\n    for i, e in d:\n\n        ans *= cmb(N-1+e, e, MOD)\n\n        ans %= MOD\n\n\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "score": 1.0, "codebleu": 0.8484003440661956, "crystalbleu": 0.8550348510426558, "codebertscore": 0.96, "codescore": 0.9921674132347107, "surfaceSim": 0.9501763668430335, "abs_surfaceSim_minus_score": 0.049823633156966474}
{"golden_code": "import sys\n\nsys.setrecursionlimit(10**6)\n\nif sys.platform in (['ios','darwin','win32']):\n\n\tsys.stdin=open('Untitled.txt')\n\ninput = sys.stdin.readline\n\ndef INT(): return int(eval(input()))\n\ndef MAP(): return [int(s) for s in input().split()]\n\n\n\ndef main():\n\n\tS = input().rstrip()\n\n\tbcnt = 0\n\n\tA = []\n\n\tfor i in range(len(S)):\n\n\t\tif S[i] == 'B': bcnt += 1\n\n\t\tif S[i] == 'W': A.append(bcnt)\n\n\t\n\n\tprint((sum(A)))\n\n\n\nif __name__ == '__main__':\n\n\tmain()", "generated_code": "import sys\n\nsys.setrecursionlimit(10**6)\n\nif sys.platform in (['ios','darwin','win32']):\n\n\tsys.stdin=open('Untitled.txt')\n\ninput = sys.stdin.readline\n\ndef INT(): return int(eval(input()))\n\ndef MAP(): return [int(s) for s in input().split()]\n\n\n\ndef main():\n\n\tS = input().rstrip()\n\n\tbcnt = 0\n\n\tans = 0\n\n\tfor i in range(len(S)):\n\n\t\tif S[i] == 'B': bcnt += 1\n\n\t\tif S[i] == 'W': ans += bcnt\n\n\t\n\n\tprint(ans)\n\n\n\nif __name__ == '__main__':\n\n\tmain()", "score": 1.0, "codebleu": 0.8793562825711243, "crystalbleu": 0.8392446988441843, "codebertscore": 0.98, "codescore": 0.026958370581269264, "surfaceSim": 0.9753914988814318, "abs_surfaceSim_minus_score": 0.02460850111856816}
{"golden_code": "a, b = list(map(int, input().split()))\n\ncnt = 0\n\nfor x in range(a, b + 1):\n\n    s = str(x)\n\n    l = len(s)\n\n    flg = True\n\n    for i in range(l // 2):\n\n        if s[i] != s[l - 1 - i]:\n\n            flg = False\n\n            break\n\n    if flg:\n\n        cnt += 1\n\nprint(cnt)\n", "generated_code": "a, b = list(map(int, input().split()))\n\ncnt = 0\n\nfor i in range(a, b + 1):\n\n    s = str(i)\n\n    if s[0] == s[4] and s[1] == s[3]:\n\n        cnt += 1\n\nprint(cnt)", "score": 1.0, "codebleu": 0.47662086622488375, "crystalbleu": 0.0, "codebertscore": 0.88, "codescore": 0.828671395778656, "surfaceSim": 0.7372893772893773, "abs_surfaceSim_minus_score": 0.26271062271062273}
{"golden_code": "a,b,c,x,y=list(map(int,input().split()))\n\n\n\nans=a*x+b*y\n\nfor ci in range(max(x,y)+1):\n\n    sumc = 2*ci*c\n\n    sumc += (x-ci)*a if (x-ci)>0 else 0\n\n    sumc += (y-ci)*b if (y-ci)>0 else 0\n\n    ans=min(ans,sumc)\n\n\n\nprint(ans)", "generated_code": "a,b,c,x,y=list(map(int,input().split()))\n\nans=a*x+b*y\n\nif x==y:\n\n    ans=min(ans,2*x*c)\n\nelif x>y:\n\n    ans=min(ans,a*(x-y)+2*y*c)\n\n    ans=min(ans,2*x*c)\n\nelse:\n\n    ans=min(ans,b*(y-x)+2*x*c)\n\n    ans=min(ans,2*y*c)\n\nprint(ans)", "score": 1.0, "codebleu": 0.29429607913114075, "crystalbleu": 0.4571735917560744, "codebertscore": 0.87, "codescore": 0.09686660766601562, "surfaceSim": 0.6735288001663547, "abs_surfaceSim_minus_score": 0.32647119983364525}
{"golden_code": "ans=[]\n\nfor i in range (0,10):\n\n    ans.append(int(eval(input())))\n\nans.sort(reverse=True)\n\nfor i in range (0,3):\n\n    print((ans[i]))", "generated_code": "mountain=[]\n\nfor s in range(0,10):\n\n    mountain.append(int(eval(input())))\n\nmountain.sort(reverse=True)\n\nfor s in range(0,3):\n\n print((mountain[s]))", "score": 1.0, "codebleu": 0.5113391161922745, "crystalbleu": 0.0, "codebertscore": 0.92, "codescore": 0.9204661250114441, "surfaceSim": 0.8959731543624161, "abs_surfaceSim_minus_score": 0.10402684563758391}
{"golden_code": "#!usr/bin/env python3\n\nfrom collections import defaultdict\n\nfrom collections import deque\n\nfrom heapq import heappush, heappop\n\nimport sys\n\nimport math\n\nimport bisect\n\nimport random\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\n\ndef I(): return int(sys.stdin.readline())\n\ndef LS():return list(map(list, sys.stdin.readline().split()))\n\ndef S(): return list(sys.stdin.readline())[:-1]\n\ndef IR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = I()\n\n    return l\n\ndef LIR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = LI()\n\n    return l\n\ndef SR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = S()\n\n    return l\n\ndef LSR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = SR()\n\n    return l\n\nmod = 1000000007\n\n\n\n#A\n\ndef A():\n\n    s = S()\n\n    t = S()\n\n    if s+t == t[::-1]+s[::-1]:\n\n        print(\"YES\")\n\n    else:\n\n        print(\"NO\")\n\n\n\n#B\n\ndef B():\n\n    n = I()\n\n    for i in range(int(n**0.5)+2)[::-1]:\n\n        if i*i <= n:\n\n            print((i*i))\n\n            quit()\n\n#C\n\ndef C():\n\n    n = I()\n\n    a = LI()\n\n    b = LI()\n\n    c = LI()\n\n    q = [0 for i in range(n)]\n\n    ans = 0\n\n    a.sort()\n\n    b.sort()\n\n    c.sort()\n\n    for i in range(n):\n\n        j = bisect.bisect_left(a,b[i])\n\n        q[i] = j\n\n    for i in range(n-1):\n\n        q[i+1] += q[i]\n\n    q.insert(0,0)\n\n    for i in range(n):\n\n        j = bisect.bisect_left(b,c[i])\n\n        ans += q[j]\n\n    print(ans)\n\n#D\n\ndef D():\n\n    def dijkstra():\n\n        d = [float(\"inf\") for i in range(k)]\n\n        q = [[0,1]]\n\n        d[1] = 0\n\n        while q:\n\n            dx,x = heappop(q)\n\n            for y,dy in v[x]:\n\n                if d[y] > dx+dy:\n\n                    d[y] = dx+dy\n\n                    heappush(q,[d[y],y])\n\n        print((d[0]+1))\n\n    k = I()\n\n    if k == 1:\n\n        print((1))\n\n        quit()\n\n    v = [[] for i in range(k)]\n\n    for i in range(1,k):\n\n        v[i].append([(i+1)%k,1])\n\n        v[i].append([i*10%k,0])\n\n    dijkstra()\n\n#E\n\ndef E():\n\n    return\n\n\n\n#F\n\ndef F():\n\n    return\n\n\n\n#G\n\ndef G():\n\n    return\n\n\n\n#H\n\ndef H():\n\n    return\n\n\n\n#Solve\n\nif __name__ == \"__main__\":\n\n    D()\n", "generated_code": "#!usr/bin/env python3\n\nfrom collections import defaultdict,deque\n\nfrom heapq import heappush, heappop\n\nfrom itertools import permutations\n\nimport sys\n\nimport math\n\nimport bisect\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\n\ndef I(): return int(sys.stdin.readline())\n\ndef LS():return [list(x) for x in sys.stdin.readline().split()]\n\ndef S():\n\n    res = list(sys.stdin.readline())\n\n    if res[-1] == \"\\n\":\n\n        return res[:-1]\n\n    return res\n\ndef IR(n):\n\n    return [I() for i in range(n)]\n\ndef LIR(n):\n\n    return [LI() for i in range(n)]\n\ndef SR(n):\n\n    return [S() for i in range(n)]\n\ndef LSR(n):\n\n    return [LS() for i in range(n)]\n\n\n\nsys.setrecursionlimit(1000000)\n\nmod = 1000000007\n\n\n\ndef solve():\n\n    def v(n):\n\n        return [n*10%k, (n+1)%k]\n\n    k = I()\n\n    d = [float(\"inf\")]*k\n\n    d[1] = 1\n\n    q = deque([1])\n\n    while q:\n\n        x = q.popleft()\n\n        vx = v(x)\n\n        dx = d[x]\n\n        for c in range(2):\n\n            nd = dx+c\n\n            y = vx[c]\n\n            if nd < d[y]:\n\n                d[y] = nd\n\n                if c:\n\n                    q.append(y)\n\n                else:\n\n                    q.appendleft(y)\n\n    print((d[0]))\n\n    return\n\n\n\n#Solve\n\nif __name__ == \"__main__\":\n\n    solve()\n", "score": 1.0, "codebleu": 0.26820744234591787, "crystalbleu": 0.17779582378077483, "codebertscore": 0.87, "codescore": 0.018265487626194954, "surfaceSim": 0.7120391705069125, "abs_surfaceSim_minus_score": 0.28796082949308754}
{"golden_code": "from collections import Counter,defaultdict,deque\n\nimport sys,bisect,math,itertools,string,queue\n\nfrom heapq import heappop, heappush\n\nsys.setrecursionlimit(10**8)\n\nmod = 10**9+7\n\ndef inp(): return int(sys.stdin.readline())\n\ndef inpl(): return list(map(int, sys.stdin.readline().split()))\n\ndef inpl_str(): return list(sys.stdin.readline().split())\n\ndef inpln(n): return list(int(sys.stdin.readline()) for i in range(n))\n\n\n\nn = inp()\n\nres = float('inf')\n\nfor i in range(1,2*10**6):\n\n    if (n/i).is_integer():\n\n        res = min(res, i + n/i)\n\nprint((int(res-2)))\n", "generated_code": "from collections import Counter,defaultdict,deque\n\nimport sys,bisect,math,itertools,string,queue\n\nfrom heapq import heappop, heappush\n\nsys.setrecursionlimit(10**8)\n\nmod = 10**9+7\n\ndef inp(): return int(sys.stdin.readline())\n\ndef inpl(): return list(map(int, sys.stdin.readline().split()))\n\ndef inpl_str(): return list(sys.stdin.readline().split())\n\ndef inpln(n): return list(int(sys.stdin.readline()) for i in range(n))\n\n\n\nn = inp()\n\nres = float('inf')\n\nfor i in range(1,int(math.sqrt(n))+1):\n\n    if n%i == 0:\n\n        res = min(res, i + n/i)\n\nprint((int(res-2)))\n", "score": 1.0, "codebleu": 0.8316966909881458, "crystalbleu": 0.8724485591152905, "codebertscore": 0.98, "codescore": 0.7168228626251221, "surfaceSim": 0.9062557216966738, "abs_surfaceSim_minus_score": 0.09374427830332621}
{"golden_code": "a, b, c = list(map(int, input().split()))\n\n\n\nif any(i % 2 != 0 for i in [a, b, c]):\n\n    print((0))\n\n    exit()\n\n\n\nif a == b and b == c:\n\n    print((-1))\n\n    exit()\n\n\n\ncnt = 0\n\na_list = [0]*(1001001)\n\nb_list = [0]*(1001001)\n\nc_list = [0]*(1001001)\n\na_list[0] = a\n\nb_list[0] = b\n\nc_list[0] = c\n\n\n\nfor i in range(1, 1001001):\n\n    a_list[i] = (b_list[i-1] + c_list[i-1]) // 2\n\n    b_list[i] = (c_list[i-1] + a_list[i-1]) // 2\n\n    c_list[i] = (a_list[i-1] + b_list[i-1]) // 2\n\n    cnt += 1\n\n    if a_list[i] % 2 != 0 or b_list[i] % 2 != 0 or c_list[i] % 2 != 0:\n\n        break\n\n\n\nprint(cnt)\n", "generated_code": "def solve(a, b, c):\n\n    if any(i % 2 == 1 for i in [a, b, c]):\n\n        return 0\n\n    if a == b == c:\n\n        return -1\n\n    a, b, c = (b + c) // 2, (c + a) // 2, (a + b) // 2\n\n    return solve(a, b, c) + 1\n\n\n\na, b, c = list(map(int, input().split()))\n\n\n\nprint((solve(a, b, c)))", "score": 1.0, "codebleu": 0.15400460313297867, "crystalbleu": 0.15854004087451617, "codebertscore": 0.8, "codescore": 0.164608433842659, "surfaceSim": 0.510009161704077, "abs_surfaceSim_minus_score": 0.48999083829592305}
{"golden_code": "X = int(eval(input()))\n\n\n\ngojyous = []\n\n\n\nfor i in range(-200, 201):\n\n    gojyous.append(i ** 5)\n\n\n\n#print(gojyous)\n\n\n\nfor i in range(-200,201):\n\n    for j in range(-200,201):\n\n        if(X == (int(i**5) - int(j**5))):\n\n            print((i, j))\n\n            exit()", "generated_code": "import sys\n\n\n\nX= int(eval(input()))\n\n\n\n#添字の最大値を算出\n\n\n\na = 1\n\nb = 0\n\ndif = 0\n\nwhile dif < 10**9:\n\n    a += 1\n\n    b += 1\n\n\n\n    dif = a ** 5 - b ** 5\n\n\n\nloop_sequence = a - 1\n\n\n\nfor i in range(-(loop_sequence),loop_sequence):\n\n\tfor j in range(-(loop_sequence),loop_sequence):\n\n\t\tif(X == i ** 5 - j ** 5):\n\n\t\t\tprint((i,j))\n\n\t\t\tsys.exit()\n", "score": 1.0, "codebleu": 0.25207862688737387, "crystalbleu": 0.30489374924094087, "codebertscore": 0.77, "codescore": 0.9753665924072266, "surfaceSim": 0.6444890929965557, "abs_surfaceSim_minus_score": 0.35551090700344434}
{"golden_code": "from collections import Counter\n\n\n\ns = eval(input())\n\nmod1 = 673\n\nmod2 = 3\n\n\n\nnum1 = 0\n\nnum2 = 0\n\nli1 = []\n\nli2 = []\n\npw1 = 10\n\npw2 = 10\n\nfor i, e in enumerate(s, 1):\n\n    num1 *= 10\n\n    num1 += int(e)\n\n    num1 %= mod1\n\n    inv = pow(pw1, mod1 - 2, mod1)\n\n    li1.append(num1 * inv % mod1)\n\n\n\n    num2 *= 10\n\n    num2 += int(e)\n\n    num2 %= mod2\n\n    inv = pow(pw2, mod2 - 2, mod2)\n\n    li2.append(num2 * inv % mod2)\n\n\n\n    pw1 *= 10\n\n    pw1 %= mod1\n\n    pw2 *= 10\n\n    pw2 %= mod2\n\n\n\nli = [0] + [10 * e1 + e2 for e1, e2 in zip(li1, li2)]\n\nc = Counter(li)\n\n\n\nans = 0\n\nfor v in list(c.values()):\n\n    ans += v * (v - 1) // 2\n\n\n\nprint(ans)\n", "generated_code": "from collections import Counter\n\n\n\n\n\ndef f(mod):\n\n    ret = [0]\n\n    power = 1\n\n    num = 0\n\n    for i, e in enumerate(s, 1):\n\n        num *= 10\n\n        num += int(e)\n\n        num %= mod\n\n\n\n        power *= 10\n\n        power %= mod\n\n        inv = pow(power, mod - 2, mod)\n\n\n\n        ret.append(num * inv % mod)\n\n\n\n    return ret\n\n\n\n\n\ns = eval(input())\n\n\n\nmod3 = f(3)\n\nmod673 = f(673)\n\n\n\nli = [10 * e673 + e3 for e3, e673 in zip(mod3, mod673)]\n\n\n\nc = Counter(li)\n\nans = 0\n\nfor v in list(c.values()):\n\n    ans += v * (v - 1) // 2\n\nprint(ans)\n", "score": 1.0, "codebleu": 0.41179884640845144, "crystalbleu": 0.3433536254541418, "codebertscore": 0.85, "codescore": 0.9934343099594116, "surfaceSim": 0.7652394984688277, "abs_surfaceSim_minus_score": 0.23476050153117234}
{"golden_code": "import numpy as np\n\nx = int(eval(input()))\n\ntmp_list=[]\n\nc=0\n\ntmp_2=0\n\nwhile(1):\n\n    tmp_1=c**5\n\n    if (tmp_1 - tmp_2)<=x:\n\n        tmp_list+=[tmp_1]\n\n    else:\n\n        break\n\n    tmp_2=tmp_1\n\n    c+=1\n\n \n\ndef せいがわ(target:list,x) -> list:\n\n    for i in np.flipud(target):\n\n        for j in target:\n\n            tmp=i+j\n\n            if tmp==x:\n\n                return [int(i**(1/5)),int(j**(1/5))*-1]\n\n            if tmp>x:\n\n                break\n\n    return 0\n\n \n\ndef ふがわ(target:list,x) -> list:\n\n    for i in np.flipud(target):\n\n        for j in target:\n\n            tmp=i-j\n\n            if tmp==x:\n\n                return [int(i**(1/5)),int(j**(1/5))]\n\n            if tmp<x:\n\n                break\n\n    return 0\n\n  \n\nans=ふがわ(tmp_list,x)\n\nif ans==0:\n\n    ans=せいがわ(tmp_list,x)\n\nprint((ans[0],ans[1]))", "generated_code": "X = int(eval(input()))\n\nfor a in range(0, 121):\n\n    for b in range(0, 121):\n\n        if X == a**5 - b**5:\n\n            print((a, b))\n\n            exit()\n\n        elif X == a**5 + b**5:\n\n            print((a, -b))\n\n            exit()\n\n        elif X == -a**5 - (10**4 - b)**5:\n\n            print((-a, 10**4 - b))\n\n            exit()", "score": 1.0, "codebleu": 0.060720588012748995, "crystalbleu": 0.030935722016011143, "codebertscore": 0.72, "codescore": 0.2873145639896393, "surfaceSim": 0.4952374541415637, "abs_surfaceSim_minus_score": 0.5047625458584363}
{"golden_code": "n,m,k=list(map(int,input().split()))\n\nmod=10**9+7\n\nf=[1]\n\nfor i in range(2*10**5+7):f+=[f[-1]*(i+1)%mod]\n\ndef comb(a,b):return f[a]*pow(f[b],mod-2,mod)*pow(f[a-b],mod-2,mod)%mod\n\nans=0\n\nfor i in range(1,n):\n\n  ans+=(i*(n-i)*m**2)*(comb(n*m-2,k-2))\n\n  ans%=mod\n\nfor i in range(1,m):\n\n  ans+=(i*(m-i)*n**2)*(comb(n*m-2,k-2))\n\n  ans%=mod\n\nprint(ans)", "generated_code": "n,m,k=list(map(int,input().split()))\n\n\n\nmod = 10**9+7\n\nf = [1]\n\nfor i in range(n*m):\n\n  f += [f[-1]*(i+1) % mod]\n\ndef comb(a, b):\n\n  return f[a]*pow(f[b], mod-2, mod)*pow(f[a-b], mod-2, mod) % mod\n\n\n\nans=0\n\nfor dist in range(1,n):\n\n  c=n-dist\n\n  p=(c*m*m)%mod\n\n  ans+=p*dist\n\nfor dist in range(1,m):\n\n  c=m-dist\n\n  p=(c*n*n)%mod\n\n  ans+=p*dist\n\nans%=mod\n\nprint((ans*comb(n*m-2,k-2)%mod))", "score": 1.0, "codebleu": 0.3599435532477047, "crystalbleu": 0.6369429828703653, "codebertscore": 0.93, "codescore": 0.6861688494682312, "surfaceSim": 0.8656330749354005, "abs_surfaceSim_minus_score": 0.13436692506459946}
{"golden_code": "N = int(eval(input()))\n\n\n\nans = 0\n\n\n\nfor i in range(1, N+1):\n\n    if len(str(i))%2==1:\n\n        ans += 1\n\n\n\nprint(ans)", "generated_code": "import sys\n\n\n\n\n\ndef rec(length):\n\n    if length == 1:\n\n        return 9\n\n    else:\n\n        return 9 * 10**(length - 1) + rec(length - 2)\n\n\n\n\n\nn = eval(input())\n\nlength = len(n)\n\n\n\nif length == 1:\n\n    print(n)\n\n    sys.exit()\n\n\n\nif length % 2 == 0:\n\n    ans = rec(length - 1)\n\nelse:\n\n    ans = rec(length - 2) + int(n) - int(\"1\" + \"0\" * (length - 1)) + 1\n\n\n\nprint(ans)", "score": 1.0, "codebleu": 0.21603175331444774, "crystalbleu": 0.08793062274159356, "codebertscore": 0.74, "codescore": 0.11601092666387558, "surfaceSim": 0.49687304565353346, "abs_surfaceSim_minus_score": 0.5031269543464665}
{"golden_code": "import numpy as np\n\nn = int(eval(input()))\n\nvalue = np.array(tuple(map(int, input().split())))\n\ncost = np.array(tuple(map(int, input().split())))\n\nxy = value - cost\n\nans = 0\n\nfor i in range(n):\n\n    if xy[i] < 0:\n\n        continue\n\n    else:\n\n        ans += xy[i]\n\nprint(ans)", "generated_code": "n = int(eval(input()))\n\nvalue = tuple(map(int, input().split()))\n\ncost = tuple(map(int, input().split()))\n\n# iこめまでのxーyの最大値\n\ninf = -100\n\ndp = [inf] * (n+1)\n\ndp[1] = max(0, value[0]-cost[0])\n\nfor i in range(2, n+1):\n\n    dp[i] = max(dp[i-1], dp[i-1]+value[i-1]-cost[i-1])\n\n\n\nprint((dp[n]))\n", "score": 1.0, "codebleu": 0.3133510695625489, "crystalbleu": 0.26600564330399384, "codebertscore": 0.79, "codescore": 0.08257699012756348, "surfaceSim": 0.5679754273504274, "abs_surfaceSim_minus_score": 0.4320245726495726}
{"golden_code": "from functools import reduce\n\nfrom itertools import product\n\n\n\nN = int(eval(input()))\n\n*A, = list(map(int, input().split()))\n\nans = 0\n\nfor t in product([-1, 0, 1], repeat=N):\n\n    prod = reduce(lambda x, y: x*y, [a + t[i] for i, a in enumerate(A)])\n\n    if prod % 2 == 0: ans += 1\n\nprint(ans)", "generated_code": "N = int(eval(input()))\n\n*A, = list(map(int, input().split()))\n\nevens = 0\n\nfor a in A:\n\n    if a % 2 == 0: evens += 1\n\nans = 3**N - 2**evens\n\nprint(ans)", "score": 1.0, "codebleu": 0.3160169837524915, "crystalbleu": 0.0, "codebertscore": 0.82, "codescore": 0.15029405057430267, "surfaceSim": 0.5162915851272015, "abs_surfaceSim_minus_score": 0.4837084148727985}
{"golden_code": "import collections\n\nn = int(eval(input()))\n\na=[eval(input()) for _ in range(n)]\n\nanslist=[]\n\nb=collections.Counter(a)\n\nc=max(list(b.values()))\n\nfor i in b:\n\n    if b[i]==c:\n\n        anslist.append(i)\n\nd=sorted(anslist)\n\nfor i in tuple(d):\n\n    print(i)", "generated_code": "from collections import Counter\n\nn=int(eval(input()))\n\na=[]\n\nfor i in range(n):\n\n  a.append(eval(input()))\n\nac=Counter(a)\n\nacs=sorted(list(ac.items()),key=lambda x:x[1],reverse=1)\n\nz=len(acs)\n\ni=0\n\ntemp=[]\n\n\n\nwhile i<=z-1 and acs[i][1]==acs[0][1] :\n\n  temp.append(acs[i][0])\n\n  i+=1\n\ntemp.sort()\n\nfor i in temp:\n\n  print(i)", "score": 1.0, "codebleu": 0.30860557397212407, "crystalbleu": 0.17307095021309496, "codebertscore": 0.82, "codescore": 0.9563564658164978, "surfaceSim": 0.4486349563748945, "abs_surfaceSim_minus_score": 0.5513650436251055}
{"golden_code": "S = eval(input())\n\nK = int(eval(input()))\n\na = list(set(S))\n\na.sort()\n\n\n\nk = []\n\nl = 0\n\nwhile l < len(a):\n\n    for i in range(len(S)):\n\n        if S[i] == a[l]:\n\n            for j in range(1,6):\n\n                if i+j <= len(S):\n\n                    k.append(S[i:i+j])\n\n                else:\n\n                    break\n\n    l += 1\n\n\n\nk = list(set(k))\n\nk.sort()\n\nprint((k[K-1]))", "generated_code": "S = eval(input())\n\nK = int(eval(input()))\n\na = []\n\nfor i in range(len(S)+1):\n\n    for j in range(1,6):\n\n        if i+j <= len(S):\n\n            a.append(S[i:i+j])\n\n        else:\n\n            break\n\n            \n\na = list(set(a))\n\na.sort()\n\nprint((a[K-1]))", "score": 1.0, "codebleu": 0.4847399452909167, "crystalbleu": 0.5610866423526303, "codebertscore": 0.91, "codescore": 0.8610958456993103, "surfaceSim": 0.83005291005291, "abs_surfaceSim_minus_score": 0.16994708994708996}
{"golden_code": "import numpy as np\n\n\n\nN, K = list(map(int, input().split()))\n\nS = eval(input())\n\n\n\nl = [[], []]\n\nans = []\n\nk = [int(s) for s in S]\n\nif k[0] == 0:\n\n    l[1].append(0)\n\nv0 = 1 if k[0] == 0 else 0\n\nv1 = 1 if k[0] == 1 else 0\n\nfor i in range(1, N):\n\n    if (k[i]==0) & (k[i-1]==0):\n\n        v0 += 1\n\n    elif (k[i]==1) & (k[i-1]==0):\n\n        l[0].append(v0)\n\n        v0 = 0\n\n        v1 += 1\n\n    elif (k[i]==0) & (k[i-1]==1):\n\n        l[1].append(v1)\n\n        v0 += 1\n\n        v1 = 0 \n\n    else:\n\n        v1 += 1\n\n        \n\nfor i, v in enumerate([v0, v1]):\n\n    if v > 0:\n\n        l[i].append(v)\n\n        \n\nif k[0] == 0:\n\n    l[1].append(0)\n\n\n\nif len(l[0]) <= K:\n\n    print(N)\n\n\n\nelse:\n\n    l[0].extend(np.repeat(0,K+1))\n\n    l[1].extend(np.repeat(0,K+1))\n\n    a = sum(l[0][:K]) + sum(l[1][:K+1])\n\n    ans.append(a)\n\n    for i in range(1, len(l[0])-K-1):\n\n        a -= l[0][i-1] + l[1][i-1]\n\n        a += l[0][i+K-1] + l[1][i+K]\n\n        ans.append(a)\n\n    print((max(ans)))", "generated_code": "N, K = list(map(int, input().split()))\n\nS = eval(input())\n\n \n\nl = [[], []]\n\nans = []\n\nk = [int(s) for s in S]\n\nif k[0] == 0:\n\n    l[1].append(0)\n\nv0 = 1 if k[0] == 0 else 0\n\nv1 = 1 if k[0] == 1 else 0\n\nfor i in range(1, N):\n\n    if (k[i]==0) & (k[i-1]==0):\n\n        v0 += 1\n\n    elif (k[i]==1) & (k[i-1]==0):\n\n        l[0].append(v0)\n\n        v0 = 0\n\n        v1 += 1\n\n    elif (k[i]==0) & (k[i-1]==1):\n\n        l[1].append(v1)\n\n        v0 += 1\n\n        v1 = 0 \n\n    else:\n\n        v1 += 1\n\n        \n\nfor i, v in enumerate([v0, v1]):\n\n    if v > 0:\n\n        l[i].append(v)\n\n        \n\nif k[0] == 0:\n\n    l[1].append(0)\n\n    \n\nl[0] += [0]*(K+1)\n\nl[1] += [0]*(K+1)\n\na = sum(l[0][:K]) + sum(l[1][:K+1])\n\nans.append(a)\n\nfor i in range(1, len(l[0])-K-1):\n\n    a -= l[0][i-1] + l[1][i-1]\n\n    a += l[0][i+K-1] + l[1][i+K]\n\n    ans.append(a)\n\nprint((max(ans)))", "score": 1.0, "codebleu": 0.7570894237440788, "crystalbleu": 0.8818456617301919, "codebertscore": 0.96, "codescore": 0.9937724471092224, "surfaceSim": 0.8927444270954453, "abs_surfaceSim_minus_score": 0.10725557290455467}
{"golden_code": "import sys\n\ninput = sys.stdin.readline\n\nfrom collections import *\n\n\n\nA, B, C, D = list(map(int, input().split()))\n\n\n\nwhile True:\n\n    C -= B\n\n    \n\n    if C<=0:\n\n        print('Yes')\n\n        exit()\n\n    \n\n    A -= D\n\n    \n\n    if A<=0:\n\n        print('No')\n\n        exit()", "generated_code": "A, B, C, D = list(map(int, input().split()))\n\nc1 = (C+B-1)//B\n\nc2 = (A+D-1)//D\n\n\n\nif c1<=c2:\n\n    print('Yes')\n\nelse:\n\n    print('No')", "score": 1.0, "codebleu": 0.2864220350283604, "crystalbleu": 0.0, "codebertscore": 0.78, "codescore": 0.7211087942123413, "surfaceSim": 0.6148851148851149, "abs_surfaceSim_minus_score": 0.3851148851148851}
{"golden_code": "s = int(eval(input()))\n\nmod = 10**9 + 7\n\n\n\n# dp[i]: 最後に切った場所がi\n\ndp = [0]*(s + 1)\n\ndp[0] = 1\n\n\n\nfor i in range(3, s+1):\n\n    for j in range(0, (i-3)+1):\n\n        dp[i] += dp[j]\n\n        dp[i] %= mod\n\n\n\nprint((dp[s]))", "generated_code": "s = int(eval(input()))\n\nmod = 10**9 + 7\n\n\n\n# dp[i]: 最後に切った場所がi\n\ndp = [0]*(s + 1)\n\ndp[0] = 1\n\ntotal = 0\n\nfor i in range(3, s+1):\n\n    total += dp[i-3]\n\n    total %= mod\n\n    dp[i] = total\n\n\n\nprint((dp[s]))", "score": 1.0, "codebleu": 0.6677688474964992, "crystalbleu": 0.6701166791648441, "codebertscore": 0.97, "codescore": 0.9858529567718506, "surfaceSim": 0.9023255813953488, "abs_surfaceSim_minus_score": 0.0976744186046512}
{"golden_code": "s=eval(input())\n\nt=eval(input())\n\nans=0\n\nif s[0]==t[0]:\n\n    ans+=1\n\nif s[1]==t[1]:\n\n    ans+=1\n\nif s[2]==t[2]:\n\n    ans+=1\n\nprint(ans)\n", "generated_code": "s=eval(input())\n\nt=eval(input())\n\nans=0\n\nfor i in range(0,3):\n\n    if s[i]==t[i]:\n\n        ans+=1\n\nprint(ans)\n", "score": 1.0, "codebleu": 0.359527749836205, "crystalbleu": 0.1889130701106511, "codebertscore": 0.89, "codescore": 0.8900023698806763, "surfaceSim": 0.8253676470588236, "abs_surfaceSim_minus_score": 0.1746323529411764}
{"golden_code": "N = int(eval(input()))\n\ns_list = {}\n\nfor i in range(N):\n\n  S = eval(input())\n\n  if S in list(s_list.keys()):\n\n    s_list[S] += 1\n\n  else:\n\n    s_list[S] = 0\n\nmax = 0\n\nmaxs = []\n\nfor s,c in list(s_list.items()):\n\n  if c > max:\n\n    maxs = [s]\n\n    max = c\n\n  elif c == max:\n\n    maxs.append(s)\n\nmaxs.sort()\n\nfor m in maxs:\n\n  print(m)", "generated_code": "from collections import Counter\n\ndef solve():\n\n  N = int(input())\n\n  S = [input() for _ in range(N)]\n\n  c = Counter(S)\n\n  M = max(c.values())\n\n  ans = []\n\n  for k,v in c.items():\n\n    if v==M:\n\n      ans.append(k)\n\n  ans.sort()\n\n  return ans\n\nprint(*solve(),sep='\\n')\n", "score": 1.0, "codebleu": 0.2332976200856245, "crystalbleu": 0.0, "codebertscore": 0.77, "codescore": 0.6019260883331299, "surfaceSim": 0.4806742226097065, "abs_surfaceSim_minus_score": 0.5193257773902935}
{"golden_code": "H,W = list(map(int,input().split()))\n\nN = int(eval(input()))\n\nA = list(map(int,input().split()))\n\nA.insert(0,0)\n\nC = [[0 for _ in range(W)] for _ in range(H)]\n\ncur = [0,0,\"R\"]\n\nfor k in range(1,N+1):\n\n#     ipdb.set_trace()\n\n    a = A[k]\n\n    cnt = 0\n\n    y,x,d = cur\n\n    for i in range(y,H):\n\n        y = i\n\n        if d==\"R\":\n\n            for j in range(x,W):\n\n                C[i][j]=str(k)\n\n                cnt += 1\n\n                if j+1<W:\n\n                    x = j+1\n\n                else:\n\n                    x = j\n\n                if cnt==a:break\n\n            if cnt==a:break\n\n            d=\"L\"\n\n        else:\n\n            for j in range(x,-1,-1):\n\n                C[i][j]=str(k)\n\n                cnt += 1\n\n                if j>=1:\n\n                    x = j-1\n\n                else:\n\n                    x = 0\n\n                if cnt==a:break\n\n            if cnt==a:break\n\n            d=\"R\"\n\n    if x==W-1:\n\n        if C[y][x]!=0:\n\n            y += 1\n\n            d=\"L\"\n\n    elif x==0:\n\n        if C[y][x]!=0:\n\n            y += 1\n\n            d=\"R\"\n\n    cur = [y,x,d]                \n\nfor i in range(H):\n\n    print((*C[i]))", "generated_code": "H,W = list(map(int,input().split()))\n\nN = int(eval(input()))\n\nA = list(map(int,input().split()))\n\nA.insert(0,0)\n\nB = [[0 for _ in range(W)] for _ in range(H)]\n\ncol = 1\n\ncnt = 0\n\ny = 0\n\nx = 0\n\nd = \"R\"\n\nwhile y<H:\n\n    if cnt<A[col]:\n\n        B[y][x] = col\n\n        cnt += 1\n\n    else:\n\n        col += 1\n\n        cnt = 0\n\n        B[y][x] = col\n\n        cnt += 1\n\n    if x<W-1 and d==\"R\":\n\n        x += 1\n\n    elif x==W-1 and d==\"R\":\n\n        y += 1\n\n        d = \"L\"\n\n    elif d==\"L\" and x>0:\n\n        x -= 1\n\n    elif d==\"L\" and x==0:\n\n        y += 1\n\n        d = \"R\"\n\nfor i in range(H):\n\n    print((*B[i]))", "score": 1.0, "codebleu": 0.37860347117124504, "crystalbleu": 0.3481250876124271, "codebertscore": 0.88, "codescore": 0.45326146483421326, "surfaceSim": 0.7328884060220395, "abs_surfaceSim_minus_score": 0.26711159397796047}
{"golden_code": "import fractions\n\nn=int(eval(input()))\n\nprint(((2*n)//fractions.gcd(2,n)))", "generated_code": "N=int(eval(input()));print((N if N%2==0 else N*2))", "score": 1.0, "codebleu": 0.18898809523809523, "crystalbleu": 0.0, "codebertscore": 0.82, "codescore": 0.3705441951751709, "surfaceSim": 0.5007507507507507, "abs_surfaceSim_minus_score": 0.4992492492492493}
{"golden_code": "from math import gcd\n\n\n\nN = int(eval(input()))\n\nnum_lis = list(map(int, input().split()))\n\nc = True\n\n\n\ndef osa_k(max_num):\n\n  lis = [i for i in range(max_num+1)]\n\n  p = 2\n\n  while p**2 <= max_num:\n\n    if lis[p] == p:\n\n      for q in range(2*p, max_num+1, p):\n\n        if lis[q] == q:\n\n          lis[q] = p\n\n    p += 1\n\n  return lis\n\n\n\nhoge = 0\n\nfor i in num_lis:\n\n  hoge = gcd(hoge, i)\n\nif hoge > 1:\n\n  print(\"not coprime\")\n\n  exit()\n\n\n\nd_lis = osa_k(10**6+10)\n\ntmp = set()\n\nfor i in num_lis:\n\n  num = i\n\n  new_tmp = set()\n\n  while num > 1:\n\n    d = d_lis[num]\n\n    new_tmp.add(d)\n\n    num //= d\n\n  for j in new_tmp:\n\n    if j in tmp:\n\n      c = False\n\n      break\n\n    else:\n\n      tmp.add(j)\n\n  else:\n\n    continue\n\n  break\n\n\n\nif c:\n\n  print(\"pairwise coprime\")\n\nelse:\n\n  print(\"setwise coprime\")", "generated_code": "from math import gcd\n\n\n\nN = int(eval(input()))\n\nnum_lis = list(map(int, input().split()))\n\n\n\ndef osa_k(max_num):\n\n  lis = [i for i in range(max_num+1)]\n\n  p = 2\n\n  while p**2 <= max_num:\n\n    if lis[p] == p:\n\n      for q in range(2*p, max_num+1, p):\n\n        if lis[q] == q:\n\n          lis[q] = p\n\n    p += 1\n\n  return lis\n\n\n\nhoge = 0\n\nfor i in num_lis:\n\n  hoge = gcd(hoge, i)\n\nif hoge > 1:\n\n  print(\"not coprime\")\n\n  exit()\n\n\n\nd_lis = osa_k(max(num_lis))\n\ntmp = set()\n\nfor i in num_lis:\n\n  num = i\n\n  new_tmp = set()\n\n  while num > 1:\n\n    d = d_lis[num]\n\n    new_tmp.add(d)\n\n    num //= d\n\n  for j in new_tmp:\n\n    if j in tmp:\n\n      print(\"setwise coprime\")\n\n      exit()\n\n    else:\n\n      tmp.add(j)\n\nprint(\"pairwise coprime\")", "score": 1.0, "codebleu": 0.7353257216896493, "crystalbleu": 0.8681580808363333, "codebertscore": 0.97, "codescore": 0.6583448648452759, "surfaceSim": 0.9126050420168067, "abs_surfaceSim_minus_score": 0.0873949579831933}
{"golden_code": "import numpy as np\n\n\n\n(N,M) = list(map(int,input().split()))\n\nB = np.ones(M,dtype=np.int)\n\n\n\nfor _ in range(N):\n\n    A = np.array(list(map(int,input().split())))[1:]\n\n    for i in range(M):\n\n        if not i+1 in A:\n\n            B[i] = 0\n\nprint((B.sum()))", "generated_code": "#!/usr/bin/env pypy3\n\n# N,M = map(int,sys.stdin.readline().split())\n\n# a = tuple(map(int,sys.stdin.readline().split())) # single line with multi param\n\n# a = tuple(int(sys.stdin.readline()) for _ in range(N)) # multi line with single param\n\n# a = tuple(tuple(map(int,sys.stdin.readline().rstrip().split())) for _ in range(N)) # multi line with multi param\n\n# s = sys.stdin.readline().rstrip()\n\n# N = int(sys.stdin.readline())\n\n# INF = float(\"inf\")\n\nimport math,sys\n\n\n\nn = int(sys.stdin.readline())\n\na = tuple(map(int,sys.stdin.readline().split()))\n\n#n = int(input())\n\n#a = list(map(int,input().split()))\n\ng = math.gcd(a[0],a[1])\n\nfor i in range(2,n):\n\n    g = math.gcd(g,a[i])\n\nM = max(a)\n\nacc = a[0]\n\nfor i in range(n):\n\n    acc = math.gcd(acc,a[i])\n\nif acc != 1:\n\n    print(\"not coprime\")\n\n    exit()\n\n\n\nLIMIT=max(a)\n\nminPrime = [0]*(LIMIT+1)\n\nminPrime[1] = 1\n\ndef make():\n\n    for i in range(2,LIMIT+1):\n\n        if minPrime[i] == 0:\n\n            minPrime[i] = i\n\n            #print(i)\n\n            for j in range(i+i,LIMIT+1,i):\n\n                #print(i,j)\n\n                if minPrime[j] == 0:\n\n                    minPrime[j] = i\n\nmake()\n\ndef factrial(N):\n\n     ret = []\n\n     while minPrime[N] != N:\n\n         ret.append(minPrime[N])\n\n         N = N//minPrime[N]\n\n     if N != 1:\n\n         ret.append(N)\n\n     return ret\n\n\n\njudge = set([])\n\n\n\nfor e in a:\n\n    asf = set(factrial(e))\n\n    if judge & asf != set():\n\n        print(\"setwise coprime\")\n\n        exit()\n\n    judge |= asf\n\n    #judge = judge | asf #too slow\n\nprint(\"pairwise coprime\")\n", "score": 0.0, "codebleu": 0.21856604376310249, "crystalbleu": 0.04769225972481716, "codebertscore": 0.72, "codescore": 0.9770895838737488, "surfaceSim": 0.5657303566453051, "abs_surfaceSim_minus_score": 0.5657303566453051}
{"golden_code": "def main():\n\n    n = int(eval(input()))\n\n    import numpy as np\n\n    ans = np.zeros((10,10))\n\n    for i in range(1,n+1):\n\n        h,t = str(i)[0],str(i)[-1]\n\n        ans[int(h)-1][int(t)-1]+=1\n\n    s = 0\n\n    for i in range(10):\n\n        for j in range(10):\n\n            s += ans[i][j]*ans[j][i]\n\n\n\n    print((int(s)))\n\nif __name__ == \"__main__\":\n\n    main()", "generated_code": "def factorial(N):\n\n    power_r = 1\n\n    for n in range(2,N+1):\n\n        power_r = power_r*n % (10**9+7)\n\n    return power_r\n\n\n\nif __name__ == '__main__':\n\n    N = int(eval(input()))\n\n    print((factorial(N)))", "score": 0.0, "codebleu": 0.1525632850191418, "crystalbleu": 0.0581153875832916, "codebertscore": 0.78, "codescore": 0.018566207960247993, "surfaceSim": 0.5116237159848621, "abs_surfaceSim_minus_score": 0.5116237159848621}
{"golden_code": "N,M,K = list(map(int,input().split()))\n\n\n\nfor i in range(N+1):\n\n    for j in range(M+1):\n\n        t = i*M + j*N - i*j*2\n\n        if t==K:\n\n            print('Yes')\n\n            exit()\n\nprint('No')", "generated_code": "N = int(eval(input()))\n\nA = [int(i) for i in input().split()]\n\nC = [A[i]-i for i in range(N)]\n\nC.sort()\n\nans = 0\n\nmed = C[N//2]\n\nfor i in range(N):\n\n  ans += abs(C[i]-med)\n\nprint(ans)", "score": 0.0, "codebleu": 0.13384978557997781, "crystalbleu": 0.0, "codebertscore": 0.79, "codescore": 0.22184544801712036, "surfaceSim": 0.5157312925170068, "abs_surfaceSim_minus_score": 0.5157312925170068}
{"golden_code": "import itertools\n\nN = int(eval(input()))\n\nNketa = len(str(N))\n\n\n\nrange_count = [[0 for j in range(10)]for i in range(10)]\n\n\n\n\n\nfor p in range(1,N+1):\n\n    mae = int(str(p)[0])\n\n    ato = int(str(p)[-1])\n\n    range_count[mae][ato] += 1\n\n\n\n    \n\n\n\ncount = 0\n\nfor j in range(1,N+1):\n\n    a_mae = int(str(j)[0])\n\n    a_ato = int(str(j)[-1])\n\n    \n\n    b_mae = a_ato\n\n    b_ato = a_mae\n\n    \n\n    if b_mae == 0:\n\n        continue\n\n    else:\n\n        count += range_count[b_mae][b_ato]\n\nprint(count)\n\n  ", "generated_code": "a, b = list(map(int, input().split()))\n\nprint(('Odd'if a&b&1 else 'Even'))", "score": 0.0, "codebleu": 0.022374288798392233, "crystalbleu": 0.0, "codebertscore": 0.64, "codescore": 0.9364029169082642, "surfaceSim": 0.34481891348088534, "abs_surfaceSim_minus_score": 0.34481891348088534}
{"golden_code": "s = eval(input())\n\nlen_s = len(s)\n\ncnt = [0, 0]\n\nfor i in range(1, len(s)):\n\n    memo_0 = s[i - 1]\n\n    memo_1 = s[len_s - i]\n\n    if s[i] != memo_0:\n\n        cnt[0] += 1\n\n    if s[len_s - i - 1] != memo_1:\n\n        cnt[1] += 1\n\nprint((min(cnt)))\n", "generated_code": "def solve(a, b, c):\n\n    if any(i % 2 == 1 for i in [a, b, c]):\n\n        return 0\n\n    if a == b == c:\n\n        return -1\n\n    a, b, c = (b + c) // 2, (c + a) // 2, (a + b) // 2\n\n    return solve(a, b, c) + 1\n\n\n\na, b, c = list(map(int, input().split()))\n\n\n\nprint((solve(a, b, c)))", "score": 0.0, "codebleu": 0.12593142496197457, "crystalbleu": 0.032819788636970104, "codebertscore": 0.73, "codescore": 0.2525211572647095, "surfaceSim": 0.42276785714285714, "abs_surfaceSim_minus_score": 0.42276785714285714}
{"golden_code": "import numpy as np\n\nn, k = list(map(int, input().split()))\n\np = np.array(list(map(int, input().split())))\n\np += 1\n\nsum_E = np.cumsum(p)\n\nsum_e = np.append([0], sum_E)\n\nans = -1\n\nfor i in range(n-k+1):\n\n    ans = max(ans, sum_e[i+k] - sum_e[i])\n\nprint((ans/2))", "generated_code": "s = eval(input())\n\nlen_s = len(s)\n\ncnt = 0\n\nfor i in range(1, len(s)):\n\n    memo_0 = s[i - 1]\n\n    if s[i] != memo_0:\n\n        cnt += 1\n\nprint(cnt)\n", "score": 0.0, "codebleu": 0.107554569442619, "crystalbleu": 0.0, "codebertscore": 0.73, "codescore": 0.16901662945747375, "surfaceSim": 0.4564152064152064, "abs_surfaceSim_minus_score": 0.4564152064152064}
{"golden_code": "N = int(eval(input()))\n\na = list(map(int, input().split()))\n\nb = list(map(int, input().split()))\n\na.reverse()\n\nb.reverse()\n\nans = 0\n\ncapacity = 0\n\nfor i in range(N):\n\n    ans += min(b[i] + capacity, a[i])\n\n    capacity = max(b[i] - max(a[i] - capacity, 0), 0)\n\nans += min(a[-1], capacity)\n\nprint(ans)", "generated_code": "from collections import Counter\n\nfrom itertools import accumulate\n\n\n\nN = int(eval(input()))\n\ninputs = [int(i) for i in input().split()]\n\n\n\nans = 0\n\n\n\nruisekiwa = list(accumulate(inputs))\n\nruisekiwa.sort()\n\ncounter_ruiseki = Counter(ruisekiwa)\n\n\n\nfor key, value in list(counter_ruiseki.items()):\n\n    if key == 0 and value == 1:\n\n        ans += value\n\n        continue\n\n    elif key == 0 and value > 1:\n\n        ans += value\n\n    if value > 1:\n\n        ans += sum(list(range(value)))\n\n\n\nprint(ans)\n", "score": 0.0, "codebleu": 0.24134961074930925, "crystalbleu": 0.12741056340156742, "codebertscore": 0.75, "codescore": 0.902212917804718, "surfaceSim": 0.4313883299798793, "abs_surfaceSim_minus_score": 0.4313883299798793}
{"golden_code": "n, m = list(map(int, input().split()))\n\na = []\n\nfor i in range(m):\n\n  a.append(int(eval(input())))\n\nans = 0\n\nflag = 0\n\na = set(a)\n\n\n\n#フィボナッチ数列の初期値を調節\n\ndp = [0] * (n+1)\n\ndp[0] = 1\n\nif 1 in a:\n\n  dp[1] = 0\n\nelse:\n\n  dp[1] = 1\n\n  \n\nfor i in range(2, n+1):\n\n  if dp[i-2] == 0 and dp[i-1] == 0:\n\n    ans = 0\n\n    flag = 1\n\n    break\n\n  elif i in a:\n\n    continue\n\n  else:\n\n    dp[i] = dp[i-1] + dp[i-2]\n\nif flag == 0:\n\n  ans = dp[n]\n\nprint((ans%(10**9+7)))", "generated_code": "'''\n\n    Auther: ghoshashis545 Ashis Ghosh\n\n    College: jalpaiguri Govt Enggineering College\n\n\n\n'''\n\nfrom os import path\n\nimport sys\n\nfrom heapq import heappush,heappop\n\nfrom functools import cmp_to_key as ctk\n\nfrom collections import deque,defaultdict as dd \n\nfrom bisect import bisect,bisect_left,bisect_right,insort,insort_left,insort_right\n\nfrom itertools import permutations\n\nfrom datetime import datetime\n\nfrom math import ceil,sqrt,log,gcd\n\ndef ii():return int(eval(input()))\n\ndef si():return eval(input())\n\ndef mi():return list(map(int,input().split()))\n\ndef li():return list(mi())\n\nabc='abcdefghijklmnopqrstuvwxyz'\n\nmod=1000000007\n\n# mod=998244353\n\ninf = float(\"inf\")\n\nvow=['a','e','i','o','u']\n\ndx,dy=[-1,1,0,0],[0,0,1,-1]\n\n\n\ndef bo(i):\n\n    return ord(i)-ord('a')\n\n\n\nfile=0\n\n\n\n\n\n\n\n\n\n\n\ndef solve():\n\n\n\n\n\n    # for _ in range(ii()):\n\n    \n\n        \n\n\n\n    n=ii()\n\n    n%=1000\n\n    if(n!=0):\n\n        n=1000-n\n\n    print(n)\n\n \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n        \n\nif __name__ ==\"__main__\":\n\n\n\n    if(file):\n\n\n\n        if path.exists('input1.txt'):\n\n            sys.stdin=open('input1.txt', 'r')\n\n            sys.stdout=open('output1.txt','w')\n\n        else:\n\n            input=sys.stdin.readline\n\n    solve()\n", "score": 0.0, "codebleu": 0.13480644174670808, "crystalbleu": 0.07154926922920152, "codebertscore": 0.65, "codescore": 0.019214371219277382, "surfaceSim": 0.3979983868228901, "abs_surfaceSim_minus_score": 0.3979983868228901}
{"golden_code": "X,Y,Z,K = list(map(int,input().split()))\n\nA = list(map(int,input().split()))\n\nB = list(map(int,input().split()))\n\nC = list(map(int,input().split()))\n\nasort,bsort,csort = sorted(A,reverse=True),sorted(B,reverse=True),sorted(C,reverse=True)\n\nprint((asort[0] + bsort[0] + csort[0]))\n\nalready = [[0,0,0]]\n\nx,y,z = 0,0,0\n\nplace_sum = []\n\ncheck = []\n\nfor k in range(K - 1):\n\n    if [x + 1,y,z] not in already and x + 1 < X:\n\n        already.append([x + 1,y,z])\n\n        place_sum.append([x + 1,y,z])\n\n        check.append(asort[x + 1] + bsort[y] + csort[z])\n\n    if [x,y + 1,z] not in already and y + 1 < Y:\n\n        already.append([x,y + 1,z])\n\n        place_sum.append([x,y + 1,z])\n\n        check.append(asort[x] + bsort[y + 1] + csort[z])\n\n    if [x,y,z + 1] not in already and z + 1 < Z:\n\n        already.append([x,y,z + 1])\n\n        place_sum.append([x,y,z + 1])\n\n        check.append(asort[x] + bsort[y] + csort[z + 1])\n\n    print((max(check)))\n\n    x,y,z = place_sum[check.index(max(check))][0],place_sum[check.index(max(check))][1],place_sum[check.index(max(check))][2]\n\n    place_sum.pop(check.index(max(check)))\n\n    check.remove(max(check))", "generated_code": "def main():\n\n    A, B, AB, X, Y = list(map(int, input().split()))\n\n    M = max(X, Y)\n\n\n\n    k = 0\n\n    ans = A * X + B * Y\n\n    while True:\n\n        ans = min(\n\n            ans,\n\n            AB * k * 2 + max(0, X - k) * A + max(0, Y - k) * B\n\n        )\n\n\n\n        if k >= M: break\n\n        k += 1\n\n\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 0.0, "codebleu": 0.08191327725985284, "crystalbleu": 0.008567555039925177, "codebertscore": 0.71, "codescore": 0.01870318502187729, "surfaceSim": 0.38328329694323143, "abs_surfaceSim_minus_score": 0.38328329694323143}
{"golden_code": "inf = (5000 * 10 ** 5) * 3\n\n\n\na, b, c, x, y = list(map(int, input().split()))\n\n\n\nret = inf\n\nfor cnt_ab in range(max(x, y) * 2 + 1):\n\n    d = cnt_ab // 2\n\n\n\n    cnt_a = max(0, x - d)\n\n    cnt_b = max(0, y - d)\n\n\n\n    t = cnt_ab * c + cnt_a * a + cnt_b * b\n\n    ret = min(ret, t)\n\nprint(ret)\n", "generated_code": "import heapq\n\nX,Y,Z,K = list(map(int,input().split()))\n\nA = list(map(int,input().split()))\n\nB = list(map(int,input().split()))\n\nC = list(map(int,input().split()))\n\nasort,bsort,csort = sorted(A,reverse=True),sorted(B,reverse=True),sorted(C,reverse=True)\n\nalready = [[0,0,0]]\n\nprint((asort[0] + bsort[0] + csort[0]))\n\nx,y,z = 0,0,0\n\ncheck = []\n\nfor k in range(K - 1):\n\n    if [x + 1,y,z] not in already and x + 1 < X:\n\n        already.append([x + 1,y,z])\n\n        heapq.heappush(check,(-(asort[x + 1] + bsort[y] + csort[z]),x + 1,y,z))\n\n    if [x,y + 1,z] not in already and y + 1 < Y:\n\n        already.append([x,y + 1,z])\n\n        heapq.heappush(check,(-(asort[x] + bsort[y + 1] + csort[z]),x,y + 1,z))\n\n    if [x,y,z + 1] not in already and z + 1 < Z:\n\n        already.append([x,y,z + 1])\n\n        heapq.heappush(check,(-(asort[x] + bsort[y] + csort[z + 1]),x,y,z + 1))\n\n    maxsum = heapq.heappop(check)\n\n    print((-maxsum[0]))\n\n    x,y,z = maxsum[1],maxsum[2],maxsum[3]", "score": 0.0, "codebleu": 0.17386906487901607, "crystalbleu": 0.056171151562103123, "codebertscore": 0.71, "codescore": 0.37877264618873596, "surfaceSim": 0.38012743926722425, "abs_surfaceSim_minus_score": 0.38012743926722425}
{"golden_code": "import numpy as np\n\nNM = list(map(int,input().split()))\n\nN = NM[0]\n\nM = NM[1]\n\nA = list(map(int,input().split()))\n\nlistBC =[]\n\nwhile True:\n\n    try:\n\n        listBC.append(list(map(int,input().split())))\n\n    except:\n\n        break;\n\nBC = np.array(listBC)\n\nBCnum = np.argsort(BC[:,1])[::-1]\n\nBC = BC[BCnum,:]\n\n\n\nA.sort()\n\nj=0\n\nfor i in range(len(A)):\n\n    times = BC[j,0]\n\n    if BC[j,0]==0:\n\n        j+=1\n\n        if j == BC.shape[0]:\n\n            break\n\n        times = BC[j,0]\n\n    if A[i]<BC[j,1]:\n\n        A[i]=BC[j,1]\n\n        BC[j,0] += -1\n\noutput = sum(A)\n\nprint(output)", "generated_code": "a, b, c, x, y = list(map(int, input().split()))\n\n# print(a, b, c, x, y)\n\n\n\nans = 10000 * (10 **5) + 7\n\nc_max = 0\n\nif x > y:\n\n  c_max = x * 2\n\nelse:\n\n  c_max = y * 2\n\n\n\nfor cc in range(0, c_max+1, 2):\n\n  ac = x - (cc // 2)\n\n  bc = y - (cc // 2)\n\n  \n\n  if ac < 0:\n\n    ac = 0\n\n  if bc < 0:\n\n    bc = 0\n\n  price = ac * a + bc * b + cc * c\n\n  # print('price: {}, ac: {}, bc: {}, cc: {}'.format(price, ac, bc, cc))\n\n  ans = min(ans, price)\n\n\n\nprint(ans)\n\n  ", "score": 0.0, "codebleu": 0.11562254170193662, "crystalbleu": 0.06257557669101123, "codebertscore": 0.71, "codescore": 0.9925569295883179, "surfaceSim": 0.4237312572087659, "abs_surfaceSim_minus_score": 0.4237312572087659}
{"golden_code": "a, b, c, x, y = list(map(int, input().split()))\n\n# print(a, b, c, x, y)\n\n\n\nans = 10000 * (10 **5) + 7\n\nc_max = 0\n\nif x > y:\n\n  c_max = x * 2\n\nelse:\n\n  c_max = y * 2\n\n\n\nfor cc in range(c_max+1):\n\n  ac = x - (cc // 2)\n\n  bc = y - (cc // 2)\n\n  \n\n  if ac < 0:\n\n    ac = 0\n\n  if bc < 0:\n\n    bc = 0\n\n  price = ac * a + bc * b + cc * c\n\n  # print('price: {}, ac: {}, bc: {}, cc: {}'.format(price, ac, bc, cc))\n\n  ans = min(ans, price)\n\n\n\nprint(ans)", "generated_code": "N = int(eval(input()))\n\nA = [int(i) for i in input().split()]\n\nC = [A[i]-i for i in range(N)]\n\nC.sort()\n\nans = 0\n\nmed = C[N//2]\n\nfor i in range(N):\n\n  ans += abs(C[i]-med)\n\nprint(ans)", "score": 0.0, "codebleu": 0.1103084566062526, "crystalbleu": 0.08251800575740625, "codebertscore": 0.73, "codescore": 0.11632604151964188, "surfaceSim": 0.5803167420814479, "abs_surfaceSim_minus_score": 0.5803167420814479}
{"golden_code": "import math\n\nimport string\n\n\n\n\n\ndef readints():\n\n    return list(map(int, input().split()))\n\n\n\n\n\ndef nCr(n, r):\n\n    return math.factorial(n)//(math.factorial(n-r)*math.factorial(r))\n\n\n\n\n\ndef has_duplicates2(seq):\n\n    seen = []\n\n    for item in seq:\n\n        if not(item in seen):\n\n            seen.append(item)\n\n    return len(seq) != len(seen)\n\n\n\n\n\ndef divisor(n):\n\n    divisor = []\n\n    for i in range(1, n+1):\n\n        if n % i == 0:\n\n            divisor.append(i)\n\n    return divisor\n\n\n\n\n\n# coordinates\n\ndx = [-1, -1, -1, 0, 0, 1, 1, 1]\n\ndy = [-1, 0, 1, -1, 1, -1, 0, 1]\n\n\n\nn = int(eval(input()))\n\na = readints()\n\n\n\n\n\ndef func(l):\n\n    if len(l) == n:\n\n        for i in range(len(l)):\n\n            if l[i] % 2 == 0:\n\n                return 1\n\n\n\n        return 0\n\n    return func(l+[(a[len(l)])])+func(l+[(a[len(l)]-1)])+func(l+[(a[len(l)]+1)])\n\n\n\n\n\nprint((func([])))\n", "generated_code": "n, m = list(map(int, input().split()))\n\na = []\n\nfor i in range(m):\n\n  a.append(int(eval(input())))\n\nans = 0\n\nflag = 0\n\na = set(a)\n\n\n\n#フィボナッチ数列の初期値を調節\n\ndp = [0] * (n+1)\n\ndp[0] = 1\n\nif 1 in a:\n\n  dp[1] = 0\n\nelse:\n\n  dp[1] = 1\n\n  \n\nfor i in range(2, n+1):\n\n  if dp[i-2] == 0 and dp[i-1] == 0:\n\n    ans = 0\n\n    flag = 1\n\n    break\n\n  elif i in a:\n\n    continue\n\n  else:\n\n    dp[i] = dp[i-1] + dp[i-2]\n\n    dp[i] = dp[i] % (10**9+7)\n\nif flag == 0:\n\n  ans = dp[n]\n\nprint(ans)", "score": 0.0, "codebleu": 0.18509484471445362, "crystalbleu": 0.14292172892137944, "codebertscore": 0.74, "codescore": 0.11172705143690109, "surfaceSim": 0.5237465856022556, "abs_surfaceSim_minus_score": 0.5237465856022556}
{"golden_code": "a,b,c,x,y = list(map(int,input().split()))\n\nans = a*x + b*y\n\nfor i in range(max(x,y) + 1):\n\n\tmoney = max(0,(x-i)*a) + max(0,(y-i)*b) + 2*i*c\n\n\tif money <= ans:\n\n\t\tans = money\n\nprint(ans)", "generated_code": "def factorial(N):\n\n    power_r = 1\n\n    for n in range(2,N+1):\n\n        power_r = power_r*n % (10**9+7)\n\n    return power_r\n\n\n\nif __name__ == '__main__':\n\n    N = int(eval(input()))\n\n    print((factorial(N)))", "score": 0.0, "codebleu": 0.08898855176139318, "crystalbleu": 0.0, "codebertscore": 0.73, "codescore": 0.01826450228691101, "surfaceSim": 0.44586538461538466, "abs_surfaceSim_minus_score": 0.44586538461538466}
{"golden_code": "N = int(eval(input()))\n\nx = list(map(int, input().split()))\n\ncnt = 0\n\nfor i in x:\n\n  while i % 2 == 0:\n\n    cnt += 1\n\n    i /= 2\n\nprint(cnt)", "generated_code": "n=int(eval(input()))\n\nx=list(map(int,input().split()))\n\n\n\nx.sort()\n\n\n\npsum=0\n\nfor i in range(len(x)):\n\n    psum=psum+(x[0]-x[i])**2\n\n#    print(psum)\n\npmin=psum    \n\nfor j in range(x[0]+1,x[len(x)-1]):\n\n    psum=0\n\n    for i in range(len(x)):\n\n        psum=psum+(j-x[i])**2\n\n#        print(psum)\n\n    if pmin>psum:\n\n        pmin=psum\n\nprint(pmin)            \n", "score": 0.0, "codebleu": 0.37900016540910564, "crystalbleu": 0.2428265210046445, "codebertscore": 0.78, "codescore": 0.9616860747337341, "surfaceSim": 0.5507776230269266, "abs_surfaceSim_minus_score": 0.5507776230269266}
{"golden_code": "def factorial(N):\n\n    power_r = 1\n\n    for n in range(2,N+1):\n\n        power_r *= n\n\n        power_r %= 10**9+7\n\n    return power_r\n\n\n\nif __name__ == '__main__':\n\n    N = int(eval(input()))\n\n    print((factorial(N)))", "generated_code": "N,M,K = list(map(int,input().split()))\n\n\n\nfor i in range(N+1):\n\n    for j in range(M+1):\n\n        if i*(M-j) + j*(N-i) == K:\n\n            print('Yes')\n\n            exit()\n\nprint('No')", "score": 0.0, "codebleu": 0.11344709675660267, "crystalbleu": 0.0, "codebertscore": 0.77, "codescore": 0.9066354036331177, "surfaceSim": 0.528110599078341, "abs_surfaceSim_minus_score": 0.528110599078341}
{"golden_code": "import sys\n\ninput = sys.stdin.readline\n\n\n\nN,L,T = list(map(int,input().split()))\n\nXW = [[int(x) for x in input().split()] for _ in range(N)]\n\n\n\nX,W = list(zip(*XW))\n\n\n\nDX = [1 if w == 1 else -1 for w in W]\n\n\n\nY = [(x+dx*T)%L for x,dx in zip(X,DX)]\n\ny0 = Y[0]\n\nY.sort()\n\n\n\n# 番号1がすれ違わず進んだ場所に相当するアリの番号\n\n# すれ違うたびに1増える（W1=1） or 1減る（W1=-1）\n\n# T秒ちょうどもすれ違い終わったと考える\n\n\n\nx = 0\n\nx0,dx0 = X[0],DX[0]\n\nfor y,dy in zip(X[1:],DX[1:]):\n\n    if dx0 == dy:\n\n        continue\n\n    if dx0 == 1 and dy == -1:\n\n        # 正の向きに追い越すので番号がひとつ増える\n\n        x += (2*T-(y-x0)-1)//L + 1\n\n    if dx0 == -1 and dy == 1:\n\n        x -= (2*T-(L+x0-y))//L + 1\n\nx %= N\n\n\n\ni = Y.index(y0)\n\n\n\nY += Y\n\n\n\nanswer = [None] * N\n\nanswer[x:N] = Y[i:i+N-x]\n\nanswer[0:x] = Y[i+N-x:i+N]\n\n\n\nprint(('\\n'.join(map(str,answer))))\n\n\n", "generated_code": "s = eval(input())\n\nt = eval(input())\n\nans = 0\n\nfor i in range(3):\n\n    if s[i] == t[i]:\n\n        ans += 1\n\nprint(ans)\n", "score": 0.0, "codebleu": 0.044856977659022045, "crystalbleu": 0.00020114989420154419, "codebertscore": 0.61, "codescore": 0.15355902910232544, "surfaceSim": 0.4468039468039468, "abs_surfaceSim_minus_score": 0.4468039468039468}
{"golden_code": "def cmb(n, r, mod):\n\n    if ( r<0 or r>n ):\n\n        return 0\n\n    r = min(r, n-r)\n\n    return g1[n] * g2[r] * g2[n-r] % mod\n\n\n\nA=2*10**5\n\nmod = 10**9+7\n\ng1 = [1, 1]\n\ng2 = [1, 1]\n\ninverse = [0, 1]\n\n\n\nfor i in range( 2, A + 1 ):\n\n    g1.append( ( g1[-1] * i ) % mod )\n\n    inverse.append( ( -inverse[mod % i] * (mod//i) ) % mod )\n\n    g2.append( (g2[-1] * inverse[-1]) % mod )\n\n\n\nN,M,K=list(map(int,input().split()))\n\nkeisuu=cmb(N*M-2,K-2,mod)\n\n\n\nsum_=0\n\nfor i in range(N):\n\n    a=min(abs(i),abs(N-i-1))\n\n    b=max(abs(i),abs(N-i-1))\n\n    sum_+=(M**2)*((a*(a+1)//2)+(b*(b+1)//2))\n\nfor i in range(M):\n\n    a=min(abs(i),abs(M-i-1))\n\n    b=max(abs(i),abs(M-i-1))\n\n    sum_+=(N**2)*((a*(a+1)//2)+(b*(b+1)//2))\n\nprint(((keisuu * (sum_//2))%mod))", "generated_code": "l, r=list(map(int, input().split()))\n\nif r-l>672:\n\n\tp=0\n\nelse:\n\n\tp=2019\n\n\tfor i in range(l, r):\n\n\t\tfor j in range(i+1, r+1):\n\n\t\t\tp=min(p, (i*j%2019))\n\n\t\t\tif not p:\n\n\t\t\t\tbreak\n\n\t\tif not p:\n\n\t\t\tbreak\n\nprint(p)", "score": 0.0, "codebleu": 0.08474967916224266, "crystalbleu": 0.009083274463297347, "codebertscore": 0.72, "codescore": 0.31453901529312134, "surfaceSim": 0.44421891444895506, "abs_surfaceSim_minus_score": 0.44421891444895506}
{"golden_code": "import itertools\n\nimport fractions\n\ndef main():\n\n  s = eval(input())\n\n  t = eval(input())\n\n  cnt = 0\n\n  for i in range(3):\n\n    if s[i] == t[i]:\n\n      cnt += 1\n\n  print(cnt)\n\nif __name__ == '__main__':\n\n  main()", "generated_code": "n=int(eval(input()))\n\nx=list(map(int,input().split()))\n\n\n\nx.sort()\n\n\n\npsum=0\n\nfor i in range(len(x)):\n\n    psum=psum+(x[0]-x[i])**2\n\n#    print(psum)\n\npmin=psum    \n\nfor j in range(x[0]+1,x[len(x)-1]):\n\n    psum=0\n\n    for i in range(len(x)):\n\n        psum=psum+(j-x[i])**2\n\n#        print(psum)\n\n    if pmin>psum:\n\n        pmin=psum\n\nprint(pmin)            \n", "score": 0.0, "codebleu": 0.2159534298658147, "crystalbleu": 0.037676977670499025, "codebertscore": 0.72, "codescore": 0.9448069930076599, "surfaceSim": 0.5251253481894151, "abs_surfaceSim_minus_score": 0.5251253481894151}
{"golden_code": "import numpy as np\n\n\n\nN = int(eval(input()))\n\nX = np.array(list(map(int, input().split())))\n\ncost = float(\"inf\")\n\nfor i in range(max(X) - min(X) + 1):\n\n    p = min(X) + i\n\n    cost = min(np.sum((X - p) ** 2), cost)\n\nprint(cost)", "generated_code": "class SegmentTree:\n\n    seg_len = 1\n\n    node = []\n\n    def __init__(self, n):\n\n        while self.seg_len < n:\n\n            self.seg_len <<= 1\n\n        self.node = [ 0 for _ in range(self.seg_len*2) ]\n\n\n\n    def add(self, idx, v):\n\n        idx += self.seg_len\n\n        self.node[idx] += v\n\n        while True:\n\n            idx >>= 1\n\n            if idx == 0:\n\n                break\n\n            self.node[idx] = self.node[idx*2] + self.node[idx*2+1]\n\n\n\n    def sum(self, l, r):\n\n        l += self.seg_len\n\n        r += self.seg_len\n\n        ret = 0\n\n        while l < r:\n\n            if l & 1 == 1:\n\n                ret += self.node[l]\n\n                l += 1\n\n            if r & 1 == 1:\n\n                ret += self.node[r-1]\n\n                r -= 1\n\n            l >>= 1; r >>= 1;\n\n        return ret\n\n\n\n\n\nn, k = list(map(int, input().split()))\n\np = [ int(x) for x in input().split() ]\n\n\n\nseg_tree = SegmentTree(n)\n\nfor i in range(n):\n\n    seg_tree.add(i, (1+p[i])/2)\n\n\n\nans = 0\n\nfor i in range(n-k+1):\n\n    ans = max(ans, seg_tree.sum(i, i+k))\n\n\n\nprint(ans)\n", "score": 0.0, "codebleu": 0.25599640803699253, "crystalbleu": 0.08797914090298407, "codebertscore": 0.66, "codescore": 0.183374285697937, "surfaceSim": 0.4136035186930569, "abs_surfaceSim_minus_score": 0.4136035186930569}
{"golden_code": "a=65280; b=61680; c=52428; d=43690; e=65535\n\nL = {el: 1 for el in [a, b, c, d, e, 0]}\n\nfor i in range(6):\n\n    R = sorted(L.items(), key=lambda x: x[1])\n\n    for p, l in R:\n\n        if l < 16:\n\n            L[p ^ e] = min(L.get(p ^ e, 16), l+1)\n\n            if l+3 < 16:\n\n                for q, r in R:\n\n                    if l+r+3 <= 16:\n\n                        L[p & q] = min(L.get(p & q, 16), l+r+3)\n\n                        L[p ^ q] = min(L.get(p ^ q, 16), l+r+3)\n\n                    else: break\n\n        else: break\n\nprint(*(L[e & eval(s)] for s in open(0).read().replace(*\"-~\").replace(*\"*&\").replace(*\"1e\").split()[:-1]),sep='\\n')\n", "generated_code": "import sys\n\nsys.setrecursionlimit(10**6)\n\nif sys.platform in (['ios','darwin','win32']):\n\n\tsys.stdin=open('Untitled.txt')\n\ninput = sys.stdin.readline\n\ndef INT(): return int(eval(input()))\n\ndef MAP(): return [int(s) for s in input().split()]\n\n\n\ndef main():\n\n\tS = input().rstrip()\n\n\tbcnt = 0\n\n\tans = 0\n\n\tfor i in range(len(S)):\n\n\t\tif S[i] == 'B': bcnt += 1\n\n\t\tif S[i] == 'W': ans += bcnt\n\n\t\n\n\tprint(ans)\n\n\n\nif __name__ == '__main__':\n\n\tmain()", "score": 0.0, "codebleu": 0.09471221221101513, "crystalbleu": 0.04088135443736467, "codebertscore": 0.66, "codescore": 0.01879534125328064, "surfaceSim": 0.44905523255813956, "abs_surfaceSim_minus_score": 0.44905523255813956}
{"golden_code": "#!/usr/bin/env pypy3\n\n# N,M = map(int,sys.stdin.readline().split())\n\n# a = tuple(map(int,sys.stdin.readline().split())) # single line with multi param\n\n# a = tuple(int(sys.stdin.readline()) for _ in range(N)) # multi line with single param\n\n# a = tuple(tuple(map(int,sys.stdin.readline().rstrip().split())) for _ in range(N)) # multi line with multi param\n\n# s = sys.stdin.readline().rstrip()\n\n# N = int(sys.stdin.readline())\n\n# INF = float(\"inf\")\n\nimport math,sys\n\n\n\nn = int(sys.stdin.readline())\n\na = tuple(map(int,sys.stdin.readline().split()))\n\n#n = int(input())\n\n#a = list(map(int,input().split()))\n\ng = math.gcd(a[0],a[1])\n\nfor i in range(2,n):\n\n    g = math.gcd(g,a[i])\n\nM = max(a)\n\nacc = a[0]\n\nfor i in range(n):\n\n    acc = math.gcd(acc,a[i])\n\nif acc != 1:\n\n    print(\"not coprime\")\n\n    exit()\n\n\n\nLIMIT=max(a)\n\nminPrime = [0]*(LIMIT+1)\n\nminPrime[1] = 1\n\ndef make():\n\n    for i in range(2,LIMIT+1):\n\n        if minPrime[i] == 0:\n\n            minPrime[i] = i\n\n            #print(i)\n\n            for j in range(i+i,LIMIT+1,i):\n\n                #print(i,j)\n\n                if minPrime[j] == 0:\n\n                    minPrime[j] = i\n\nmake()\n\ndef factrial(N):\n\n     ret = []\n\n     while minPrime[N] != N:\n\n         ret.append(minPrime[N])\n\n         N = N//minPrime[N]\n\n     if N != 1:\n\n         ret.append(N)\n\n     return ret\n\n\n\njudge = set([])\n\npc = True\n\n\n\npairwise = True\n\np = set() #all prime\n\n\n\nfor e in a:\n\n    if not pairwise:\n\n        break\n\n    asf = set(factrial(e))\n\n    if judge & asf != set():\n\n        pc = False\n\n    #     #pairwise = False\n\n    #     print(\"setwise coprime\")\n\n    #     exit(0)\n\n    judge |= asf\n\n# for i in a:\n\n#     if not pc:\n\n#         break\n\n#     asf = set(factrial(i))\n\n\n\n#     if judge & asf != set():\n\n#         pc = False\n\n#     judge |= asf\n\nif pc:\n\n    print(\"pairwise coprime\")\n\nelif g == 1:\n\n    print(\"setwise coprime\")\n\nelse:\n\n    print(\"not coprime\")\n", "generated_code": "N,M = list(map(int,input().split()))\n\nA = list(map(int,input().split()))\n\n\n\nfrom collections import Counter\n\nD = dict(Counter(A))\n\n\n\nfor i in range(M):\n\n    B,C = list(map(int,input().split()))\n\n    D[C]=D.get(C,0)+B\n\n\n\nK = sorted(list(D.keys()),reverse=True)\n\n\n\nout = 0\n\ncnt = 0\n\nnow = 0\n\nwhile cnt<=N-1:\n\n    if D[K[now]]>0:\n\n        out += K[now]\n\n        D[K[now]] += -1\n\n        cnt+=1\n\n    else:\n\n        now+=1\n\nprint(out)", "score": 0.0, "codebleu": 0.10952128855441108, "crystalbleu": 0.032284901608343165, "codebertscore": 0.71, "codescore": 0.982947051525116, "surfaceSim": 0.5816125230580037, "abs_surfaceSim_minus_score": 0.5816125230580037}
{"golden_code": "import numpy as np\n\n\n\nn=int(eval(input()))\n\na_list=list(map(int,input().split()))\n\na_list_2=sorted(a_list,reverse=True)\n\na=np.array(a_list_2,dtype='uint8')\n\n\n\nalice=0\n\nbob=0\n\nfor i in range(n):\n\n\tif i%2==0:\n\n\t\talice+=a[i]\n\n\telse:\n\n\t\tbob+=a[i]\n\n\n\nprint((alice-bob))\n", "generated_code": "from collections import Counter\n\nfrom itertools import accumulate\n\n\n\nN = int(eval(input()))\n\ninputs = [int(i) for i in input().split()]\n\n\n\nans = 0\n\n\n\nruisekiwa = list(accumulate(inputs))\n\nruisekiwa.sort()\n\ncounter_ruiseki = Counter(ruisekiwa)\n\n\n\nfor key, value in list(counter_ruiseki.items()):\n\n    if key == 0 and value == 1:\n\n        ans += value\n\n        continue\n\n    elif key == 0 and value > 1:\n\n        ans += value\n\n    if value > 1:\n\n        ans += sum(list(range(value)))\n\n\n\nprint(ans)\n", "score": 0.0, "codebleu": 0.21263675934081672, "crystalbleu": 0.11726787437378455, "codebertscore": 0.73, "codescore": 0.9366552829742432, "surfaceSim": 0.4904588823262154, "abs_surfaceSim_minus_score": 0.4904588823262154}
{"golden_code": "from collections import defaultdict\n\n\n\nN, K, *A = list(map(int, open(0).read().split()))\n\n\n\nS = [0] * (N + 1)\n\nfor i in range(N):\n\n    S[i + 1] = S[i] + A[i]\n\n\n\nd = defaultdict(int)\n\nans = 0\n\nfor j in range(N + 1):\n\n    v = (S[j] - j) % K\n\n    ans += d[v]\n\n    d[v] += 1\n\n    if j >= K - 1:\n\n        d[(S[j - K + 1] - (j - K + 1)) % K] -= 1\n\n        \n\nprint(ans)\n", "generated_code": "A,B = list(map(int,input().split()))\n\nans = 0\n\nfor i in range(A,B+1) :\n\n    l = str(i)\n\n    if l[0] == l[4] and l[1] == l[3] :\n\n        ans += 1\n\nprint(ans)\n", "score": 0.0, "codebleu": 0.12716801951381118, "crystalbleu": 0.09795370866373883, "codebertscore": 0.78, "codescore": 0.8470891118049622, "surfaceSim": 0.58169468984516, "abs_surfaceSim_minus_score": 0.58169468984516}
{"golden_code": "import math\n\nn = int(eval(input()))\n\nprint((math.factorial(n)%(10**9+7)))\n", "generated_code": "N = int(eval(input()))\n\nX = [[] for i in range(N)]\n\nfor i in range(N-1):\n\n    x, y = list(map(int, input().split()))\n\n    X[x-1].append(y-1)\n\n    X[y-1].append(x-1)\n\n\n\nP = [-1] * N\n\nDE = [0] * N\n\nQ = [0]\n\nwhile Q:\n\n    i = Q.pop()\n\n    for a in X[i][::-1]:\n\n        if a != P[i]:\n\n            P[a] = i\n\n            DE[a] = DE[i] + 1\n\n            X[a].remove(i)\n\n            Q.append(a)\n\n\n\ndef lp(u, v):\n\n    t = 0\n\n    while u != v:\n\n        if DE[u] > DE[v]:\n\n            t += 1 << u-1\n\n            u = P[u]\n\n        elif DE[u] < DE[v]:\n\n            t += 1 << v-1\n\n            v = P[v]\n\n        else:\n\n            t += 1 << u-1\n\n            t += 1 << v-1\n\n            u = P[u]\n\n            v = P[v]\n\n    \n\n    return t\n\n\n\nY = []\n\nM = int(eval(input()))\n\nfor _ in range(M):\n\n    a, b = list(map(int, input().split()))\n\n    a, b = a-1, b-1\n\n    Y.append(lp(a, b))\n\n\n\ndef popcnt(n):\n\n    c = (n & 0x5555555555555555) + ((n>>1) & 0x5555555555555555)\n\n    c = (c & 0x3333333333333333) + ((c>>2) & 0x3333333333333333)\n\n    c = (c & 0x0f0f0f0f0f0f0f0f) + ((c>>4) & 0x0f0f0f0f0f0f0f0f)\n\n    c = (c & 0x00ff00ff00ff00ff) + ((c>>8) & 0x00ff00ff00ff00ff)\n\n    c = (c & 0x0000ffff0000ffff) + ((c>>16) & 0x0000ffff0000ffff)\n\n    c = (c & 0x00000000ffffffff) + ((c>>32) & 0x00000000ffffffff)\n\n    return c\n\n\n\nD = {1<<i: i for i in range(50)}\n\nZ = [0] * (1<<M)\n\nans = 0\n\nCC = [0] * N\n\nfor m in range(1<<M):\n\n    a = m & (-m)\n\n    if a == m:\n\n        if a == 0:\n\n            Z[m] = 0\n\n        else:\n\n            Z[m] = Y[D[a]]\n\n    else:\n\n        Z[m] = Z[m^a] | Y[D[a]]\n\n    \n\n    CC[N - 1 - popcnt(Z[m])] += (1 if popcnt(m) & 1 == 0 else -1)\n\n\n\nprint((sum([2 ** i * CC[i] for i in range(N)])))", "score": 0.0, "codebleu": 0.3229241173868276, "crystalbleu": 0.02316513100601475, "codebertscore": 0.59, "codescore": 0.9935996532440186, "surfaceSim": 0.326268115942029, "abs_surfaceSim_minus_score": 0.326268115942029}
{"golden_code": "n,m=list(map(int,input().split()))\n\nc=[0]*(n+2)\n\nfor i in range(m):\n\n  l,r=list(map(int,input().split()))\n\n  c[l-1]+=1\n\n  c[r]-=1\n\nfor i in range(1,n+2):\n\n  c[i]=c[i]+c[i-1]\n\nans=0\n\nfor i in range(n+2):\n\n  if c[i]==m:\n\n    ans+=1\n\nprint(ans)", "generated_code": "from collections import Counter\n\nfrom itertools import accumulate\n\n\n\nN = int(eval(input()))\n\ninputs = [int(i) for i in input().split()]\n\n\n\nans = 0\n\n\n\nruisekiwa = list(accumulate(inputs))\n\nruisekiwa.sort()\n\ncounter_ruiseki = Counter(ruisekiwa)\n\n\n\nfor key, value in list(counter_ruiseki.items()):\n\n    if key == 0 and value == 1:\n\n        ans += value\n\n        continue\n\n    elif key == 0 and value > 1:\n\n        ans += value\n\n    if value > 1:\n\n        ans += sum(list(range(value)))\n\n\n\nprint(ans)\n", "score": 0.0, "codebleu": 0.16367742052682704, "crystalbleu": 0.07190646171822068, "codebertscore": 0.73, "codescore": 0.9549745321273804, "surfaceSim": 0.4849765258215962, "abs_surfaceSim_minus_score": 0.4849765258215962}
{"golden_code": "import numpy as np\n\nN=int(eval(input()))\n\nprint((2**int(np.log2(N))))", "generated_code": "n = int(eval(input()))\n\n\n\nXY = []\n\nfor i in range(n):\n\n    a = int(eval(input()))\n\n    xy = []\n\n    for j in range(a):\n\n        xy.append(list(map(int, input().split())))\n\n    \n\n    XY.append(xy)\n\n\n\n\"\"\"\n\n    矛盾したらFalse\n\n    矛盾しなければTrue\n\n    正直者と仮定した者の証言\n\n        正直&正直者と仮定されている\n\n        不親切&不親切と仮定されている\n\n\"\"\"\n\ndef check(i, xiyj, HoU):\n\n    # XOR\n\n    if HoU ^ ((i >> xiyj) & 1):\n\n        return False\n\n\n\n    return True\n\n\n\nmax_honest = 0\n\nfor i in range(2 ** len(XY)):\n\n    count = 0\n\n    is_contradiction = True\n\n    for j in range(len(XY)):\n\n        # 正直者と仮定したときだけ採用\n\n        if not ((i >> j) & 1): continue\n\n        count+=1\n\n        for k in range(len(XY[j])):\n\n            xiyj = XY[j][k][0] - 1\n\n            HoU = XY[j][k][1]\n\n            \n\n            if not check(i, xiyj, HoU):\n\n                is_contradiction = False\n\n                break # TLE対策\n\n                \n\n        if not is_contradiction:\n\n            break # TLE対策\n\n\n\n    # 矛盾がなく、正直者の数が更新できれば更新\n\n    if is_contradiction and (count > max_honest):\n\n        max_honest =count\n\n            \n\nprint(max_honest)", "score": 0.0, "codebleu": 0.3125, "crystalbleu": 0.03643435657994337, "codebertscore": 0.57, "codescore": 0.9939097166061401, "surfaceSim": 0.3832972582972583, "abs_surfaceSim_minus_score": 0.3832972582972583}
{"golden_code": "class Queue:\n\n    def __init__(self,values):\n\n        self.values = values\n\n\n\n    def empty(self):\n\n        if len(self.values) == 0:\n\n            return True\n\n        else:\n\n            return False\n\n\n\n    def enqueue(self,v):\n\n        self.values.append(v)\n\n\n\n    def dequeue(self):\n\n        if len(self.values) <= 0:\n\n            raise\n\n        else:\n\n            v = self.values[0]\n\n            del self.values[0]\n\n            return v\n\n\n\nn,q = list(map(int,input().split(' ')))\n\nprocesses = []\n\nfor i in range(n):\n\n    n,t = input().split(' ')\n\n    processes.append((n,int(t)))\n\n\n\nqueue = Queue(processes)\n\n\n\nclock = 0\n\ndone = []\n\nwhile not queue.empty():\n\n    p = queue.dequeue()\n\n    n = p[0]\n\n    t = p[1]\n\n    if t <= q:\n\n        clock+=t\n\n        done.append((n,clock))\n\n    else:\n\n        queue.enqueue((n,t-q))\n\n        clock+=q\n\n\n\nfor p in done:\n\n    print(p[0],p[1])", "generated_code": "\n\nclass node:\n\n    def __init__(self, id):\n\n        self.id = id\n\n        self.root = self\n\n\n\n    def findRoot(self):\n\n        if self == self.root:\n\n            return self\n\n        else:\n\n            self.root = self.root.findRoot()\n\n            return self.root\n\n\n\n    def resetRoot(self):\n\n        self.root = self\n\n\n\nclass Tree:\n\n    def __init__(self, num):\n\n        self.nodes = {i:node(i) for i in range(num)}\n\n\n\n    def union(self, one, other):\n\n        root1 = one.findRoot()\n\n        root2 = other.findRoot()\n\n        root1.root = root2.root = self.nodes[min(root1.id, root2.id)]\n\n\n\n    def resetTree(self):\n\n        for n in list(self.nodes.values()):\n\n            n.resetRoot()\n\n\n\n    def makeTree(self, Edge):\n\n        self.edge = Edge\n\n        for x,y in Edge:\n\n            self.union(self.nodes[x-1], self.nodes[y-1])\n\n\n\n\n\ndef main():\n\n    with open(0) as f:\n\n        N, M = list(map(int, f.readline().split()))\n\n        Edge = [tuple(map(int, line.split())) for line in f.readlines()]\n\n    \n\n    tree = Tree(N)\n\n    ans = 0\n\n    for i in range(M):\n\n        edge = [v for  v in Edge if v != Edge[i]]\n\n        tree.makeTree(edge)\n\n        if any(x.findRoot().id != 0 for x in list(tree.nodes.values())):\n\n            ans += 1\n\n        tree.resetTree()\n\n    print(ans)\n\n\n\nif __name__ == '__main__':\n\n    main()", "score": 0.0, "codebleu": 0.19775982879030068, "crystalbleu": 0.09067905690894808, "codebertscore": 0.75, "codescore": 0.18722577393054962, "surfaceSim": 0.5609894259818731, "abs_surfaceSim_minus_score": 0.5609894259818731}
{"golden_code": "board = [[False]*1000001]*1000001\n\nwhile True:\n\n    m = int(eval(input()))\n\n    if m == 0: break\n\n    star = list({tuple(map(int, input().split())) for i in range(m)})\n\n    sx, sy = star[0]\n\n    \n\n    n = int(eval(input()))\n\n    starlist = list({tuple(map(int, input().split())) for i in range(n)})\n\n    for i in range(len(starlist)):\n\n        board[starlist[i][0]][starlist[i][1]] = True\n\n    for i in range(n):\n\n        flag = True\n\n        for j in range(len(star)-1):\n\n            dx = starlist[i][0] + star[j+1][0] - sx\n\n            dy = starlist[i][1] + star[j+1][1] - sy\n\n            if dx < 0 or 1000000 < dx or dy < 0 or 1000000 < dy or board[dx][dy] == False:\n\n                flag = False\n\n                break\n\n\n\n        if flag == True:\n\n            print((\"{} {}\".format(starlist[i][0] - sx, starlist[i][1] -sy)))\n\n            break\n\n    ", "generated_code": "import sys\n\nimport numpy as np\n\n\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\n\"\"\"\n\n・順序が固定されるので、区間だったら簡単\n\n・円のときも、地点 0 をそれぞれの方向に通った人数を見れば計算できる\n\n\"\"\"\n\n\n\nN, L, T = list(map(int, readline().split()))\n\nXW = np.array(read().split(), np.int64)\n\nX = XW[::2]\n\nW = XW[1::2]\n\n\n\nspeed = np.where(W == 1, 1, -1)\n\n\n\nY = X + speed * T\n\n\n\nn = (Y // L - X // L).sum()\n\nn %= N\n\n\n\nY %= L\n\nY.sort()\n\nY = np.concatenate((Y[n:], Y[:n]))\n\n\n\nprint(('\\n'.join(map(str, Y.tolist()))))", "score": 0.0, "codebleu": 0.10059595254198926, "crystalbleu": 0.04113217141713581, "codebertscore": 0.65, "codescore": 0.8860726356506348, "surfaceSim": 0.4506480395988016, "abs_surfaceSim_minus_score": 0.4506480395988016}
{"golden_code": "l, r=list(map(int, input().split()))\n\nif r-l>672:\n\n\tp=0\n\nelse:\n\n\tp=2019\n\n\tfor i in range(l, r):\n\n\t\tfor j in range(i+1, r+1):\n\n\t\t\tp=min(p, (((i%2019)*(j%2019))%2019))\n\n\t\t\tif not p:\n\n\t\t\t\tbreak\n\n\t\tif not p:\n\n\t\t\tbreak\n\nprint(p)", "generated_code": "class Queue:\n\n    def __init__(self,l):\n\n        self.values = []\n\n        self.l = l\n\n        for _ in range(l):\n\n            self.values.append(None)\n\n        self.head = 0\n\n        self.tail = 0\n\n    def inc(self,n):\n\n        if n+1 >= self.l:\n\n            return 0\n\n        else:\n\n            return n+1\n\n    def enqueue(self,v):\n\n        if self.inc(self.head) == self.tail:\n\n            print('overflow')\n\n            exit()\n\n        self.values[self.head] = v\n\n        self.head = self.inc(self.head)\n\n    def dequeue(self):\n\n        if self.head == self.tail:\n\n            print('underflow')\n\n            exit()\n\n        v = self.values[self.tail]\n\n        self.tail = self.inc(self.tail)\n\n        return v\n\n    def size(self):\n\n        if self.head >= self.tail:\n\n            return self.head-self.tail\n\n        else:\n\n            self.head + (self.l-self.tail)\n\n\n\nn,q = list(map(int,input().split(' ')))\n\nqueue = Queue(200000)\n\nfor _ in range(n):\n\n    n,t = input().split(' ')\n\n    t = int(t)\n\n    queue.enqueue((n,t))\n\n\n\nc = 0\n\nwhile queue.size()>0:\n\n    n,t = queue.dequeue()\n\n    if t <= q:\n\n        c += t\n\n        print(n,c)\n\n    else:\n\n        queue.enqueue((n,t-q))\n\n        c += q", "score": 0.0, "codebleu": 0.20916815484997509, "crystalbleu": 0.06675121388234298, "codebertscore": 0.67, "codescore": 0.08603177219629288, "surfaceSim": 0.45988552349153355, "abs_surfaceSim_minus_score": 0.45988552349153355}
{"golden_code": "def main():\n\n    x = int(eval(input()))\n\n    for a in range(-120, 121):\n\n        for b in range(-120, 121):\n\n            if a**5 - b**5 == x:\n\n                print((a, b))\n\n                return\n\n\n\nif __name__ == \"__main__\":\n\n    main()", "generated_code": "while True:\n\n    m = int(eval(input()))\n\n    if m == 0: break\n\n    star = list({tuple(map(int, input().split())) for i in range(m)})\n\n    sx, sy = star[0]\n\n    \n\n    n = int(eval(input()))\n\n    starset = {tuple(map(int, input().split())) for i in range(n)}\n\n    for x, y in starset:\n\n        flag = True\n\n        for j in range(len(star)-1):\n\n            dx = x + star[j+1][0] - sx\n\n            dy = y + star[j+1][1] - sy\n\n            if (dx, dy) not in starset:\n\n                flag = False\n\n                break\n\n\n\n        if flag == True:\n\n            print((x - sx, y - sy))\n\n            break\n\n    ", "score": 0.0, "codebleu": 0.17647667311517728, "crystalbleu": 0.03709275541898554, "codebertscore": 0.71, "codescore": 0.9534134268760681, "surfaceSim": 0.5111570247933884, "abs_surfaceSim_minus_score": 0.5111570247933884}
{"golden_code": "import numpy as np\n\n\n\nN, K = list(map(int, input().split()))\n\nS = list(eval(input())) + ['2']\n\n\n\nblocks = []\n\ncur = 1\n\nseq = 0\n\nfor s in S:\n\n    if int(s) == cur:\n\n        seq += 1\n\n    else:\n\n        blocks.append(seq)\n\n        cur = 1 - cur\n\n        seq = 1\n\nanswer = 0\n\nblocks = np.array(blocks)\n\nfor i in range(0, len(blocks), 2):\n\n    answer = max(answer, blocks[i:i+2*K+1].sum())\n\nprint(answer)\n", "generated_code": "a, b, c, x, y = list(map(int, input().split()))\n\n# print(a, b, c, x, y)\n\n\n\nans = 10000 * (10 **5) + 7\n\nc_max = 0\n\nif x > y:\n\n  c_max = x * 2\n\nelse:\n\n  c_max = y * 2\n\n\n\nfor cc in range(0, c_max+1, 2):\n\n  ac = x - (cc // 2)\n\n  bc = y - (cc // 2)\n\n  \n\n  if ac < 0:\n\n    ac = 0\n\n  if bc < 0:\n\n    bc = 0\n\n  price = ac * a + bc * b + cc * c\n\n  # print('price: {}, ac: {}, bc: {}, cc: {}'.format(price, ac, bc, cc))\n\n  ans = min(ans, price)\n\n\n\nprint(ans)\n\n  ", "score": 0.0, "codebleu": 0.16312095652224706, "crystalbleu": 0.14446700919103178, "codebertscore": 0.75, "codescore": 0.9927356243133545, "surfaceSim": 0.5690581542351454, "abs_surfaceSim_minus_score": 0.5690581542351454}
{"golden_code": "import numpy as np\n\n\n\nn = int(eval(input()))\n\na = np.array(list(map(int,input().split())))\n\n\n\ncount = 0\n\nwhile np.all(a%2==0):\n\n    count+=1\n\n    a=a/2\n\nprint(count)\n", "generated_code": "s=eval(input())\n\nt=eval(input())\n\nans=0\n\nfor i in range(0,3):\n\n    if s[i]==t[i]:\n\n        ans+=1\n\nprint(ans)\n", "score": 0.0, "codebleu": 0.1438953488372093, "crystalbleu": 0.0, "codebertscore": 0.78, "codescore": 0.49575671553611755, "surfaceSim": 0.48376113148245153, "abs_surfaceSim_minus_score": 0.48376113148245153}
{"golden_code": "# -*- coding: utf-8 -*-\n\nimport sys\n\n\n\nX = int(input().strip())\n\n#-----\n\n\n\nfor a in range(-118,120):\n\n    for b in range(-118,120):\n\n        if (a**5 - b**5) == X:\n\n            print((a,b))\n\n            sys.exit()\n", "generated_code": "N,L = list(map(int, input().split()))\n\ntaste = [L+i-1 for i in range(1,N+1)]\n\nif taste[-1] < 0:\n\n  print((sum(taste) + min([abs(x) for x in taste])))\n\nelse:\n\n  print((sum(taste) - min([abs(x) for x in taste])))", "score": 0.0, "codebleu": 0.1568333266522424, "crystalbleu": 0.0, "codebertscore": 0.72, "codescore": 0.18849501013755798, "surfaceSim": 0.5112495673243337, "abs_surfaceSim_minus_score": 0.5112495673243337}
{"golden_code": "from collections import deque\n\n\n\nn, k = list(map(int, input().split()))\n\nV = list(map(int, input().split()))\n\n\n\nans = 0\n\nfor t in range(k//2 + 1):\n\n    hand = deque(V[:k-t])\n\n    rest = deque(V[k-t:])\n\n    cur_sum = sum(hand)\n\n\n\n    for j in range(k-t+1):\n\n        put_back = 0\n\n        rev_hand = sorted(hand)\n\n\n\n        for i in range(t):\n\n            jewel = rev_hand[i]\n\n            if jewel < 0:\n\n                put_back -= jewel\n\n            else:\n\n                break\n\n\n\n        candidate = cur_sum + put_back\n\n        ans = max(candidate, ans)\n\n\n\n        to_rest = hand.pop()\n\n        rest.appendleft(to_rest)\n\n        to_hand = rest.pop()\n\n        hand.appendleft(to_hand)\n\n\n\n        cur_sum += to_hand - to_rest\n\n\n\nprint(ans)", "generated_code": "a=65280; b=61680; c=52428; d=43690; e=65535\n\nfrom heapq import heappush, heappop\n\nbase = [a, b, c, d, e, 0]\n\nQ = [(1, el) for el in base]\n\nL = {el: 1 for el in base}\n\nH = []\n\nwhile Q:\n\n    l, p = heappop(Q)\n\n    if L[p] < l: continue\n\n    if l+1 < L.get(p ^ e, 17):\n\n        L[p^e] = l+1\n\n        if l+1 < 16: heappush(Q, (l+1, p^e))\n\n    if l+3 < 16:\n\n        for q, r in H:\n\n            if l+r+3 <= 16:\n\n                if l+r+3 < L.get(p & q, 17):\n\n                    L[p & q] = l+r+3\n\n                    if l+r+3 < 16: heappush(Q, (l+r+3, p & q))\n\n                if l+r+3 < L.get(p ^ q, 17):\n\n                    L[p ^ q] = l+r+3\n\n                    if l+r+3 < 16: heappush(Q, (l+r+3, p ^ q))\n\n            else: break\n\n    if l < 7: H.append((p, l))\n\nprint(*(L[e & eval(s)] for s in open(0).read().replace(*\"-~\").replace(*\"*&\").replace(*\"1e\").split()[:-1]),sep='\\n')\n", "score": 0.0, "codebleu": 0.18147618159292503, "crystalbleu": 0.022043822568278054, "codebertscore": 0.68, "codescore": 0.9937926530838013, "surfaceSim": 0.5071941391941392, "abs_surfaceSim_minus_score": 0.5071941391941392}
{"golden_code": "import numpy as np\n\n\n\nN, K= list(map(int, input().split()))\n\np = np.array(list(map(int, input().split())))\n\n\n\ntmp = np.sum(p[:K])\n\nmax = tmp\n\nfor i in range(N-K):\n\n    tmp = tmp-p[i]+p[i+K]\n\n    if tmp>max:\n\n        max = tmp\n\n\n\nprint(((max+K)/2))", "generated_code": "from collections import Counter,defaultdict,deque\n\nfrom heapq import heappop,heappush,heapify\n\nfrom bisect import bisect_left,bisect_right \n\nimport sys,math,itertools,fractions,pprint\n\nsys.setrecursionlimit(10**8)\n\nmod = 10**9+7\n\nINF = float('inf')\n\ndef inp(): return int(sys.stdin.readline())\n\ndef inpl(): return list(map(int, sys.stdin.readline().split()))\n\n\n\nn,m = inpl()\n\na = inpl()\n\na.sort()\n\nbc = [inpl() for _ in range(m)]\n\nbc.sort(key = lambda x:x[1], reverse = True)\n\nlm = sum(x[1] for x in bc)\n\nnow = 0\n\nalt = 0\n\nwhile now < n and alt < m:\n\n    c,b = bc[alt]\n\n    if a[now] > b:\n\n        break\n\n    else:\n\n        a[now] = b\n\n    bc[alt][0] -= 1\n\n    if bc[alt][0] == 0:\n\n        alt += 1\n\n    now += 1\n\nprint((sum(a)))\n", "score": 0.0, "codebleu": 0.1639452628068142, "crystalbleu": 0.04268734515820616, "codebertscore": 0.67, "codescore": 0.3989514708518982, "surfaceSim": 0.4247243568326094, "abs_surfaceSim_minus_score": 0.4247243568326094}
{"golden_code": "from math import floor, sqrt\n\nfrom collections import Counter\n\n\n\nMOD = 10 ** 9 + 7\n\n\n\n# xを素因数分解する\n\ndef getPrimeFactor(x):\n\n    ans = []\n\n    for d in range(2, floor(sqrt(x)) + 1):\n\n        while x % d == 0:\n\n            ans.append(d)\n\n            x //= d\n\n\n\n    if x != 1:\n\n        ans.append(x)\n\n\n\n    return ans\n\n\n\n# xのn乗（二分累乗法）\n\ndef power(x, n):\n\n    ans = 1\n\n    while n:\n\n        if n % 2 == 1:\n\n            ans = (ans * x) % MOD\n\n        x = (x * x) % MOD\n\n        n //= 2\n\n    return ans\n\n\n\n\n\nN, M = list(map(int, input().split()))\n\n\n\nPFs = getPrimeFactor(M)\n\ncnt = Counter(PFs)\n\n\n\nN2 = N\n\nif len(cnt):\n\n    N2 += max(cnt.values())\n\n\n\n# facts[x]: xの階乗\n\nfacts = [1] + [0] * N2\n\nfor x in range(1, N2 + 1):\n\n    facts[x] = (facts[x - 1] * x) % MOD\n\n\n\n# invFs[x]: xの階乗の逆元\n\ninvFs = [0] * N2 + [power(facts[N2], MOD - 2)]\n\nfor x in reversed(list(range(N2))):\n\n    invFs[x] = (invFs[x + 1] * (x + 1)) % MOD\n\n\n\ndef comb(n, k):\n\n    return ((facts[n] * invFs[k]) % MOD * invFs[n - k]) % MOD\n\n\n\n\n\nans = 1\n\nfor num in list(cnt.values()):\n\n    ans = (ans * comb(N + num - 1, num)) % MOD\n\nprint(ans)\n", "generated_code": "from collections import Counter\n\n\n\n\n\ndef f(mod):\n\n    ret = [0]\n\n    power = 1\n\n    num = 0\n\n    for i, e in enumerate(s, 1):\n\n        num *= 10\n\n        num += int(e)\n\n        num %= mod\n\n\n\n        power *= 10\n\n        power %= mod\n\n        inv = pow(power, mod - 2, mod)\n\n\n\n        ret.append(num * inv % mod)\n\n\n\n    return ret\n\n\n\n\n\ns = eval(input())\n\n\n\nmod3 = f(3)\n\nmod673 = f(673)\n\n\n\nli = [10 * e673 + e3 for e3, e673 in zip(mod3, mod673)]\n\n\n\nc = Counter(li)\n\nans = 0\n\nfor v in list(c.values()):\n\n    ans += v * (v - 1) // 2\n\nprint(ans)\n", "score": 0.0, "codebleu": 0.15752137853185608, "crystalbleu": 0.035705080372364244, "codebertscore": 0.76, "codescore": 0.9934432506561279, "surfaceSim": 0.6222251240532777, "abs_surfaceSim_minus_score": 0.6222251240532777}
{"golden_code": "n=int(eval(input()))\n\nx=list(map(int,input().split()))\n\n\n\nx.sort()\n\n\n\nfor p in range(x[0],x[len(x)-1]+1):\n\n    psum=0\n\n    for i in range(len(x)):\n\n        psum=psum+(x[0]-x[i])**2\n\n#    print(psum)\n\n    pmin=psum    \n\n    for j in range(x[0]+1,x[len(x)-1]):\n\n        psum=0\n\n        for i in range(len(x)):\n\n            psum=psum+(j-x[i])**2\n\n#        print(psum)\n\n        if pmin>psum:\n\n            pmin=psum\n\nprint(pmin)    ", "generated_code": "import sys\n\n\n\nX= int(eval(input()))\n\n\n\n#添字の最大値を算出\n\n\n\na = 1\n\nb = 0\n\ndif = 0\n\nwhile dif < 10**9:\n\n    a += 1\n\n    b += 1\n\n\n\n    dif = a ** 5 - b ** 5\n\n\n\nloop_sequence = a - 1\n\n\n\nfor i in range(-(loop_sequence),loop_sequence):\n\n\tfor j in range(-(loop_sequence),loop_sequence):\n\n\t\tif(X == i ** 5 - j ** 5):\n\n\t\t\tprint((i,j))\n\n\t\t\tsys.exit()\n", "score": 0.0, "codebleu": 0.14245699855703436, "crystalbleu": 0.08909034124227967, "codebertscore": 0.72, "codescore": 0.012005778029561043, "surfaceSim": 0.540983606557377, "abs_surfaceSim_minus_score": 0.540983606557377}
{"golden_code": "import numpy as np\n\nimport sys\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\nreadlines = sys.stdin.readlines\n\n\n\ndef main():\n\n    N = int(readline())\n\n    X = [int(i) for i in readline().split()]\n\n    X = np.array(X)\n\n\n\n    ans = np.min(np.sum((X - np.arange(1,101).reshape(100, 1))**2, axis=1))\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "generated_code": "X = int(eval(input()))\n\nfor a in range(0, 121):\n\n    for b in range(0, 121):\n\n        if X == a**5 - b**5:\n\n            print((a, b))\n\n            exit()\n\n        elif X == a**5 + b**5:\n\n            print((a, -b))\n\n            exit()\n\n        elif X == -a**5 - (10**4 - b)**5:\n\n            print((-a, 10**4 - b))\n\n            exit()", "score": 0.0, "codebleu": 0.09241643861350146, "crystalbleu": 0.01686232004649884, "codebertscore": 0.69, "codescore": 0.13381031155586243, "surfaceSim": 0.44607244607244606, "abs_surfaceSim_minus_score": 0.44607244607244606}
{"golden_code": "import numpy as np\n\n\n\nN = int(input())\n\nAs = list(map(int, input().split()))\n\n\n\n# for i in range(N):\n\n#   print(As.index(i+1) + 1, end = \" \")\n\n\n\nfor item in np.argsort(As):\n\n  print(item+1, end=\" \")\n", "generated_code": "N, K = list(map(int, input().split()))\n\nplist = [((num*(num+1))//2)/num for num in list(map(int, input().split()))]\n\n# print(plist)\n\nans = 0\n\nfor i in range(K):\n\n    ans += plist[i]\n\n_ = ans\n\nfor i in range(N-K):\n\n    temp = _\n\n    temp -= plist[i]\n\n    temp += plist[i+K]\n\n    # print(i, i+K, ans, temp)\n\n    ans = max(ans, temp)\n\n    _ = temp\n\nprint(ans)", "score": 0.0, "codebleu": 0.2582854407189459, "crystalbleu": 0.07936117947858119, "codebertscore": 0.77, "codescore": 0.7362626194953918, "surfaceSim": 0.5068539325842697, "abs_surfaceSim_minus_score": 0.5068539325842697}
{"golden_code": "# -*- coding: utf-8 -*-\n\nfrom collections import defaultdict\n\nfrom itertools import combinations\n\nN = int(eval(input()))\n\nC = [0, 0, 0, 0, 0, 0]\n\nD = defaultdict(int)\n\nfor i, m in enumerate(\"MARCH\", start=1):\n\n    D[m] = i\n\n\n\nfor _ in range(N):\n\n    C[D[input()[0]]] += 1\n\n\n\nans = 0\n\nfor a, b, c in combinations(list(range(1, 6)), r=3):\n\n    ans += C[a]*C[b]*C[c]\n\nprint(ans)", "generated_code": "'''\n\n    Auther: ghoshashis545 Ashis Ghosh\n\n    College: jalpaiguri Govt Enggineering College\n\n\n\n'''\n\nfrom os import path\n\nimport sys\n\nfrom heapq import heappush,heappop\n\nfrom functools import cmp_to_key as ctk\n\nfrom collections import deque,defaultdict as dd \n\nfrom bisect import bisect,bisect_left,bisect_right,insort,insort_left,insort_right\n\nfrom itertools import permutations\n\nfrom datetime import datetime\n\nfrom math import ceil,sqrt,log,gcd\n\ndef ii():return int(eval(input()))\n\ndef si():return eval(input())\n\ndef mi():return list(map(int,input().split()))\n\ndef li():return list(mi())\n\nabc='abcdefghijklmnopqrstuvwxyz'\n\nmod=1000000007\n\n# mod=998244353\n\ninf = float(\"inf\")\n\nvow=['a','e','i','o','u']\n\ndx,dy=[-1,1,0,0],[0,0,1,-1]\n\n\n\ndef bo(i):\n\n    return ord(i)-ord('a')\n\n\n\nfile=0\n\n\n\n\n\n\n\n\n\n\n\ndef solve():\n\n\n\n\n\n    # for _ in range(ii()):\n\n    \n\n        \n\n\n\n    n=ii()\n\n    n%=1000\n\n    if(n!=0):\n\n        n=1000-n\n\n    print(n)\n\n \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n        \n\nif __name__ ==\"__main__\":\n\n\n\n    if(file):\n\n\n\n        if path.exists('input1.txt'):\n\n            sys.stdin=open('input1.txt', 'r')\n\n            sys.stdout=open('output1.txt','w')\n\n        else:\n\n            input=sys.stdin.readline\n\n    solve()\n", "score": 0.0, "codebleu": 0.18816704899681114, "crystalbleu": 0.044632465017647685, "codebertscore": 0.68, "codescore": 0.019770007580518723, "surfaceSim": 0.39379626022594466, "abs_surfaceSim_minus_score": 0.39379626022594466}
{"golden_code": "import numpy as np\n\nN,L = list(map(int, input().split()))\n\ntaste = np.array([L+i-1 for i in range(1,N+1)])\n\nif taste[-1] < 0:\n\n  print((sum(taste) + min(np.abs(taste))))\n\nelse:\n\n  print((sum(taste) - min(np.abs(taste))))", "generated_code": "N = int(eval(input()))\n\n*A, = list(map(int, input().split()))\n\nevens = 0\n\nfor a in A:\n\n    if a % 2 == 0: evens += 1\n\nans = 3**N - 2**evens\n\nprint(ans)", "score": 0.0, "codebleu": 0.19678372421634693, "crystalbleu": 0.0, "codebertscore": 0.75, "codescore": 0.1561526358127594, "surfaceSim": 0.45454545454545453, "abs_surfaceSim_minus_score": 0.45454545454545453}
{"golden_code": "n, k = list(map(int, input().split()))\n\na_s = list(map(int, input().split()))\n\ndp = [\"Second\"] * (k + 1)\n\nfor i in range(k + 1):\n\n    if dp[i] == \"Second\":\n\n        for a in a_s:\n\n            ii = i + a\n\n            if ii <= k:\n\n                dp[ii] = \"First\"\n\nprint((dp[-1]))\n", "generated_code": "n = int(eval(input()))\n\na = list(map(int, input().split()))\n\nb = list(map(int, input().split()))\n\n\n\na = a[::-1]\n\nb = b[::-1]\n\nans = 0\n\nfor i, bi in enumerate(b):\n\n    ans += min(a[i], b[i])\n\n    remain = max(0, b[i] - a[i])\n\n    ans += min(a[i + 1], remain)\n\n    a[i + 1] = max(0, a[i + 1] - remain)\n\nprint(ans)", "score": 0.0, "codebleu": 0.2411204475207865, "crystalbleu": 0.1469867830387929, "codebertscore": 0.8, "codescore": 0.06429945677518845, "surfaceSim": 0.5970195399455849, "abs_surfaceSim_minus_score": 0.5970195399455849}
{"golden_code": "# インポート\n\nimport numpy as np\n\n# A,B,Cの値の獲得\n\nnum = list(map(int, input().split()))\n\n# numリストの最大値を10倍\n\nnum[num.index(max(num))] = max(num) * 10\n\n# npで要素の和を計算し、出力\n\nprint((np.sum(num)))", "generated_code": "import sys\n\nimport numpy as np\n\n\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\n\"\"\"\n\n・順序が固定されるので、区間だったら簡単\n\n・円のときも、地点 0 をそれぞれの方向に通った人数を見れば計算できる\n\n\"\"\"\n\n\n\nN, L, T = list(map(int, readline().split()))\n\nXW = np.array(read().split(), np.int64)\n\nX = XW[::2]\n\nW = XW[1::2]\n\n\n\nspeed = np.where(W == 1, 1, -1)\n\n\n\nY = X + speed * T\n\n\n\nn = (Y // L - X // L).sum()\n\nn %= N\n\n\n\nY %= L\n\nY.sort()\n\nY = np.concatenate((Y[n:], Y[:n]))\n\n\n\nprint(('\\n'.join(map(str, Y.tolist()))))", "score": 0.0, "codebleu": 0.28631992826092556, "crystalbleu": 0.07874664977774909, "codebertscore": 0.72, "codescore": 0.9783641695976257, "surfaceSim": 0.42440318302387264, "abs_surfaceSim_minus_score": 0.42440318302387264}
{"golden_code": "import statistics\n\nN = int(eval(input()))\n\na = [int(i) for i in input().split()]\n\nans = 0\n\n\n\nfor i in range(1,N+1):\n\n  a[i-1] -= i\n\n\n\nb = statistics.median(a)\n\nfor i in range(N):\n\n  ans += abs(a[i]-b)\n\nprint((int(ans)))", "generated_code": "from math import floor, sqrt\n\nfrom collections import Counter\n\n\n\nMOD = 10 ** 9 + 7\n\n\n\n# xを素因数分解する\n\ndef getPrimeFactor(x):\n\n    ans = []\n\n    for d in range(2, floor(sqrt(x)) + 1):\n\n        while x % d == 0:\n\n            ans.append(d)\n\n            x //= d\n\n    if x != 1:\n\n        ans.append(x)\n\n    return ans\n\n\n\ndef comb(n, k):\n\n    k = min(k, n - k)\n\n    ans = 1\n\n    for i in range(n, n - k, -1):\n\n        ans *= i\n\n    for i in range(1, k + 1):\n\n        ans //= i \n\n    return ans\n\n\n\n\n\nN, M = list(map(int, input().split()))\n\n\n\nPFs = getPrimeFactor(M)\n\ncnt = Counter(PFs)\n\n\n\nans = 1\n\nfor num in list(cnt.values()):\n\n    ans *= comb(N + num - 1, num)\n\nprint((ans % MOD))\n", "score": 0.0, "codebleu": 0.22598004574904562, "crystalbleu": 0.0629591610313448, "codebertscore": 0.71, "codescore": 0.9801087975502014, "surfaceSim": 0.45552865844135565, "abs_surfaceSim_minus_score": 0.45552865844135565}
{"golden_code": "\"\"\"Minimum cost Sort.\"\"\"\n\n\n\ndef min_cost_sort(A):\n\n    \"\"\"Sort list A in ascending order.\n\n \n\n    And return the switching cost in sorting.\n\n    \"\"\"\n\n    B = list(A)\n\n    B.sort()\n\n    cost = 0\n\n    min_w = B[0]\n\n    for i, b in enumerate(B):\n\n        tmp_cost = 0\n\n        bi = A.index(b)\n\n        n = 1\n\n        while bi != i:\n\n            n += 1\n\n            st = B[bi]\n\n            si = A.index(st)\n\n            tmp_cost += b + st\n\n            A[bi], A[si] = st, b\n\n            bi = si\n\n        dec = (n - 1) * (b - min_w)\n\n        inc = 2 * (min_w + b)\n\n        if dec < inc:\n\n            cost += tmp_cost\n\n        else:\n\n            cost += tmp_cost - dec + inc\n\n    return cost\n\n\n\n\n\nn = eval(input())\n\n\n\nA = list(map(int, input().split()))\n\n\n\nans = min_cost_sort(A)\n\n\n\nprint(ans)", "generated_code": "from math import gcd\n\n\n\nN = int(eval(input()))\n\nnum_lis = list(map(int, input().split()))\n\n\n\ndef osa_k(max_num):\n\n  lis = [i for i in range(max_num+1)]\n\n  p = 2\n\n  while p**2 <= max_num:\n\n    if lis[p] == p:\n\n      for q in range(2*p, max_num+1, p):\n\n        if lis[q] == q:\n\n          lis[q] = p\n\n    p += 1\n\n  return lis\n\n\n\nhoge = 0\n\nfor i in num_lis:\n\n  hoge = gcd(hoge, i)\n\nif hoge > 1:\n\n  print(\"not coprime\")\n\n  exit()\n\n\n\nd_lis = osa_k(max(num_lis))\n\ntmp = set()\n\nfor i in num_lis:\n\n  num = i\n\n  new_tmp = set()\n\n  while num > 1:\n\n    d = d_lis[num]\n\n    new_tmp.add(d)\n\n    num //= d\n\n  for j in new_tmp:\n\n    if j in tmp:\n\n      print(\"setwise coprime\")\n\n      exit()\n\n    else:\n\n      tmp.add(j)\n\nprint(\"pairwise coprime\")", "score": 0.0, "codebleu": 0.23320944880314598, "crystalbleu": 0.0990959480960141, "codebertscore": 0.71, "codescore": 0.9580668210983276, "surfaceSim": 0.5315487242968159, "abs_surfaceSim_minus_score": 0.5315487242968159}
{"golden_code": "class SegmentTree:\n\n    seg_len = 1\n\n    node = []\n\n    def __init__(self, n):\n\n        while self.seg_len < n:\n\n            self.seg_len <<= 1\n\n        self.node = [ 0 for _ in range(self.seg_len*2) ]\n\n\n\n    def add(self, idx, v):\n\n        idx += self.seg_len\n\n        self.node[idx] += v\n\n        while True:\n\n            idx //= 2\n\n            if idx == 0:\n\n                break\n\n            self.node[idx] = self.node[idx*2] + self.node[idx*2+1]\n\n\n\n    def sum(self, l, r):\n\n        l += self.seg_len\n\n        r += self.seg_len\n\n        ret = 0\n\n        while l < r:\n\n            if l & 1 == 1:\n\n                ret += self.node[l]\n\n                l += 1\n\n            if r & 1 == 1:\n\n                ret += self.node[r-1]\n\n                r -= 1\n\n            l //= 2; r //= 2;\n\n        return ret\n\n\n\n\n\nn, k = list(map(int, input().split()))\n\np = [ int(x) for x in input().split() ]\n\n\n\nseg_tree = SegmentTree(n)\n\nfor i in range(n):\n\n    seg_tree.add(i, (1+p[i])/2)\n\n\n\nans = 0\n\nfor i in range(n-k+1):\n\n    ans = max(ans, seg_tree.sum(i, i+k))\n\n\n\nprint(ans)\n", "generated_code": "import sys\n\n\n\n\n\ndef rec(length):\n\n    if length == 1:\n\n        return 9\n\n    else:\n\n        return 9 * 10**(length - 1) + rec(length - 2)\n\n\n\n\n\nn = eval(input())\n\nlength = len(n)\n\n\n\nif length == 1:\n\n    print(n)\n\n    sys.exit()\n\n\n\nif length % 2 == 0:\n\n    ans = rec(length - 1)\n\nelse:\n\n    ans = rec(length - 2) + int(n) - int(\"1\" + \"0\" * (length - 1)) + 1\n\n\n\nprint(ans)", "score": 0.0, "codebleu": 0.1108590327894878, "crystalbleu": 0.0142022831618913, "codebertscore": 0.7, "codescore": 0.11726084351539612, "surfaceSim": 0.5044769085768144, "abs_surfaceSim_minus_score": 0.5044769085768144}
{"golden_code": "a, b = list(map(int, input().split()))\n\nif a*b%2 == 1:\n\n    print(\"Odd\")\n\nelse:\n\n    print(\"Even\")", "generated_code": "def solve():\n\n  N, K = list(map(int, input().split()))\n\n  s = eval(input())\n\n  S = []\n\n  b = s[0]\n\n  cnt = 0\n\n\n\n  if s[0] == '0': S.append(0)\n\n  for c in s:\n\n    if b == c: cnt = cnt + 1\n\n    else:\n\n      b = c\n\n      S.append(cnt)\n\n      cnt = 1\n\n  S.append(cnt)\n\n  if s[-1] == '0': S.append(0)\n\n\n\n  num = min(len(S), 2 * K + 1)\n\n  part = sum(S[0:num])\n\n  ans = part\n\n\n\n  for i in range(0, len(S) - num, 2):\n\n    part = part - sum(S[i:i+2]) + sum(S[i + num:i + num + 2])\n\n    ans = max(ans, part)\n\n\n\n  return ans\n\n\n\nprint((solve()))\n", "score": 0.0, "codebleu": 0.28729271692715463, "crystalbleu": 0.09675757914188654, "codebertscore": 0.68, "codescore": 0.980385422706604, "surfaceSim": 0.4804039593365436, "abs_surfaceSim_minus_score": 0.4804039593365436}
{"golden_code": "import sys\n\n\n\nn, m, *lr = list(map(int, sys.stdin.read().split()))\n\nlr = list(zip(*[iter(lr)] * 2))\n\n\n\ndef main():\n\n    cnt = [0] * (n + 1)\n\n    for l, r in lr:\n\n        cnt[l-1] += 1\n\n        cnt[r] -= 1\n\n    \n\n    for i in range(n):\n\n        cnt[i+1] += cnt[i]\n\n    \n\n    res = 0\n\n    for i in range(n):\n\n        res += (cnt[i] == m) & 1\n\n    \n\n    return res\n\n\n\nif __name__ == '__main__':\n\n    ans = main()\n\n    print(ans)", "generated_code": "#O(|S|log|s|)\n\ndef main():\n\n\ts=eval(input())\n\n\tt=eval(input())\n\n\tn=len(s)\n\n\tnow=-1\n\n\tans=1\n\n\tif not set(t)<=set(s):#tがsの部分集合でない\n\n\t\tprint((-1))\n\n\t\texit()\n\n\tfor x in t:\n\n\t\tnow=s.find(x,now+1)#nowより大きいところからxを探す\n\n\t\tif now==-1:#nowより大きいところでxが見つからなかったら\n\n\t\t\tans+=n\n\n\t\t\tnow=s.find(x)\n\n\tprint((ans+now))\n\nif __name__ == '__main__':\n\n\tmain()", "score": 0.0, "codebleu": 0.13666982646992062, "crystalbleu": 0.07845935047609606, "codebertscore": 0.7, "codescore": 0.022352419793605804, "surfaceSim": 0.5397860962566845, "abs_surfaceSim_minus_score": 0.5397860962566845}
{"golden_code": "a, b, c = sorted(map(int, input().split()))\n\n\n\nprint((c*10 + b + a))", "generated_code": "from collections import defaultdict\n\nfrom itertools import combinations\n\ndef inpl(): return list(map(int, input().split()))\n\n\n\nC = defaultdict(int)\n\nN = int(eval(input()))\n\nfor _ in range(N):\n\n    C[input()[0]] += 1\n\n\n\nres = 0\n\nfor H in combinations(\"MARCH\", r=3):\n\n    res += C[H[0]] * C[H[1]] * C[H[2]]\n\nprint(res)", "score": 0.0, "codebleu": 0.2557737641743032, "crystalbleu": 0.0, "codebertscore": 0.69, "codescore": 0.8972024917602539, "surfaceSim": 0.41751513483764446, "abs_surfaceSim_minus_score": 0.41751513483764446}
{"golden_code": "import math\n\nimport numpy as np\n\nn, d = list(map(int, input().split()))\n\na = []\n\ncnt = 0\n\nfor x in range(n):\n\n    a.append(list(map(int, input().split())))\n\nfor i in range(len(a)):\n\n    for j in range(len(a)):\n\n        if i < j:\n\n            dis = np.array(a[i]) - np.array(a[j])\n\n            if np.linalg.norm(dis).is_integer():\n\n                cnt += 1\n\nprint(cnt)", "generated_code": "n = int(eval(input()))\n\n\n\nXY = []\n\nfor i in range(n):\n\n    a = int(eval(input()))\n\n    xy = []\n\n    for j in range(a):\n\n        xy.append(list(map(int, input().split())))\n\n    \n\n    XY.append(xy)\n\n\n\n\"\"\"\n\n    矛盾したらFalse\n\n    矛盾しなければTrue\n\n    正直者と仮定した者の証言\n\n        正直&正直者と仮定されている\n\n        不親切&不親切と仮定されている\n\n\"\"\"\n\ndef check(i, xiyj, HoU):\n\n    # XOR\n\n    if HoU ^ ((i >> xiyj) & 1):\n\n        return False\n\n\n\n    return True\n\n\n\nmax_honest = 0\n\nfor i in range(2 ** len(XY)):\n\n    count = 0\n\n    is_contradiction = True\n\n    for j in range(len(XY)):\n\n        # 正直者と仮定したときだけ採用\n\n        if not ((i >> j) & 1): continue\n\n        count+=1\n\n        for k in range(len(XY[j])):\n\n            xiyj = XY[j][k][0] - 1\n\n            HoU = XY[j][k][1]\n\n            \n\n            if not check(i, xiyj, HoU):\n\n                is_contradiction = False\n\n                break # TLE対策\n\n                \n\n        if not is_contradiction:\n\n            break # TLE対策\n\n\n\n    # 矛盾がなく、正直者の数が更新できれば更新\n\n    if is_contradiction and (count > max_honest):\n\n        max_honest =count\n\n            \n\nprint(max_honest)", "score": 0.0, "codebleu": 0.32142751687011983, "crystalbleu": 0.15106063148290017, "codebertscore": 0.7, "codescore": 0.9883699417114258, "surfaceSim": 0.5310760667903525, "abs_surfaceSim_minus_score": 0.5310760667903525}
{"golden_code": "\n\nX = int(eval(input()))\n\nfor a in range(-200, 200):\n\n    find = False\n\n    for b in range(-200, 200):\n\n        x = a**5-b**5\n\n        if x == X:\n\n            find = True\n\n            print((a, b))\n\n            break\n\n    if find:\n\n        break\n", "generated_code": "N,M = list(map(int,input().split()))\n\nA = list(map(int,input().split()))\n\n\n\nfrom collections import Counter\n\nD = dict(Counter(A))\n\n\n\nfor i in range(M):\n\n    B,C = list(map(int,input().split()))\n\n    D[C]=D.get(C,0)+B\n\n\n\nK = sorted(list(D.keys()),reverse=True)\n\n\n\nout = 0\n\ncnt = 0\n\nnow = 0\n\nwhile cnt<=N-1:\n\n    if D[K[now]]>0:\n\n        out += K[now]\n\n        D[K[now]] += -1\n\n        cnt+=1\n\n    else:\n\n        now+=1\n\nprint(out)", "score": 0.0, "codebleu": 0.13513032425233523, "crystalbleu": 0.011216441474433835, "codebertscore": 0.69, "codescore": 0.9936461448669434, "surfaceSim": 0.4578088578088578, "abs_surfaceSim_minus_score": 0.4578088578088578}
{"golden_code": "N = int(eval(input()))\n\nX = [[] for i in range(N)]\n\nfor i in range(N-1):\n\n    x, y = list(map(int, input().split()))\n\n    X[x-1].append(y-1)\n\n    X[y-1].append(x-1)\n\n\n\nP = [-1] * N\n\nDE = [0] * N\n\nQ = [0]\n\nwhile Q:\n\n    i = Q.pop()\n\n    for a in X[i][::-1]:\n\n        if a != P[i]:\n\n            P[a] = i\n\n            DE[a] = DE[i] + 1\n\n            X[a].remove(i)\n\n            Q.append(a)\n\n\n\ndef lp(u, v):\n\n    t = 0\n\n    while u != v:\n\n        if DE[u] > DE[v]:\n\n            t += 1 << u-1\n\n            u = P[u]\n\n        elif DE[u] < DE[v]:\n\n            t += 1 << v-1\n\n            v = P[v]\n\n        else:\n\n            t += 1 << u-1\n\n            t += 1 << v-1\n\n            u = P[u]\n\n            v = P[v]\n\n    \n\n    return t\n\n\n\nY = []\n\nM = int(eval(input()))\n\nfor _ in range(M):\n\n    a, b = list(map(int, input().split()))\n\n    a, b = a-1, b-1\n\n    Y.append(lp(a, b))\n\n\n\nD = {1<<i: i for i in range(50)}\n\nZ = [0] * (1<<M)\n\nans = 0\n\nCC = [0] * N\n\nBC = [0] * (1<<17)\n\nfor m in range(1, 1<<17):\n\n    a = m & (-m)\n\n    BC[m] = BC[m^a] + 1\n\nfor m in range(1<<M):\n\n    a = m & (-m)\n\n    if a == m:\n\n        if a == 0:\n\n            Z[m] = 0\n\n        else:\n\n            Z[m] = Y[D[a]]\n\n    else:\n\n        Z[m] = Z[m^a] | Y[D[a]]\n\n    \n\n    aa = Z[m]\n\n    bc = BC[aa % (1<<17)]\n\n    aa >>= 17\n\n    bc += BC[aa % (1<<17)]\n\n    aa >>= 17\n\n    bc += BC[aa]\n\n    CC[N - 1 - bc] += (1 if BC[m%1024] + BC[m>>10] & 1 == 0 else -1)\n\n\n\nprint((sum([2 ** i * CC[i] for i in range(N)])))", "generated_code": "\n\nclass node:\n\n    def __init__(self, id):\n\n        self.id = id\n\n        self.root = self\n\n\n\n    def findRoot(self):\n\n        if self == self.root:\n\n            return self\n\n        else:\n\n            self.root = self.root.findRoot()\n\n            return self.root\n\n\n\n    def resetRoot(self):\n\n        self.root = self\n\n\n\nclass Tree:\n\n    def __init__(self, num):\n\n        self.nodes = {i:node(i) for i in range(num)}\n\n\n\n    def union(self, one, other):\n\n        root1 = one.findRoot()\n\n        root2 = other.findRoot()\n\n        root1.root = root2.root = self.nodes[min(root1.id, root2.id)]\n\n\n\n    def resetTree(self):\n\n        for n in list(self.nodes.values()):\n\n            n.resetRoot()\n\n\n\n    def makeTree(self, Edge):\n\n        self.edge = Edge\n\n        for x,y in Edge:\n\n            self.union(self.nodes[x-1], self.nodes[y-1])\n\n\n\n\n\ndef main():\n\n    with open(0) as f:\n\n        N, M = list(map(int, f.readline().split()))\n\n        Edge = [tuple(map(int, line.split())) for line in f.readlines()]\n\n    \n\n    tree = Tree(N)\n\n    ans = 0\n\n    for i in range(M):\n\n        edge = [v for  v in Edge if v != Edge[i]]\n\n        tree.makeTree(edge)\n\n        if any(x.findRoot().id != 0 for x in list(tree.nodes.values())):\n\n            ans += 1\n\n        tree.resetTree()\n\n    print(ans)\n\n\n\nif __name__ == '__main__':\n\n    main()", "score": 0.0, "codebleu": 0.13818566054237313, "crystalbleu": 0.07344863626324578, "codebertscore": 0.73, "codescore": 0.41012394428253174, "surfaceSim": 0.517539356605065, "abs_surfaceSim_minus_score": 0.517539356605065}
{"golden_code": "import numpy as np\n\nN, K = list(map(int, input().split()))\n\nplist = list(map(int, input().split()))\n\nkitaiti = np.array([(0.5*(p+1)) for p in plist])\n\nans = 0\n\nval = sum(kitaiti[:K])\n\nans = max(ans, val)\n\nfor i in range(1, N-K+1):\n\n    # print(i-1, i+K)\n\n    val -= kitaiti[i-1]\n\n    val += kitaiti[i+K-1]\n\n    ans = max(ans, val)\n\nprint(ans)", "generated_code": "N,M = list(map(int,input().split()))\n\nA = list(map(int,input().split()))\n\n\n\nfrom collections import Counter\n\nD = dict(Counter(A))\n\n\n\nfor i in range(M):\n\n    B,C = list(map(int,input().split()))\n\n    D[C]=D.get(C,0)+B\n\n\n\nK = sorted(list(D.keys()),reverse=True)\n\n\n\nout = 0\n\ncnt = 0\n\nnow = 0\n\nwhile cnt<=N-1:\n\n    if D[K[now]]>0:\n\n        out += K[now]\n\n        D[K[now]] += -1\n\n        cnt+=1\n\n    else:\n\n        now+=1\n\nprint(out)", "score": 0.0, "codebleu": 0.20950194435885156, "crystalbleu": 0.11444081960416137, "codebertscore": 0.76, "codescore": 0.9839697480201721, "surfaceSim": 0.5190122377622377, "abs_surfaceSim_minus_score": 0.5190122377622377}
{"golden_code": "from collections import Counter,defaultdict,deque\n\nfrom heapq import heapify,heappop,heappush\n\nfrom bisect import bisect_left,bisect_right\n\nimport sys,math,itertools,string,queue\n\nsys.setrecursionlimit(10**8)\n\nmod = 10**9+7\n\ndef inp(): return int(sys.stdin.readline())\n\ndef inpl(): return list(map(int, sys.stdin.readline().split()))\n\ndef inpl_str(): return list(sys.stdin.readline().split())\n\ndef inpln(n): return list(int(sys.stdin.readline()) for i in range(n))\n\n\n\nn,m = inpl()\n\na = inpl()\n\nb = [0] * m\n\nfor i in range(m):\n\n    x,y = inpl()\n\n    b[i] = [x,y]\n\na.sort()\n\nb.sort(key=lambda x:x[1], reverse = True)\n\nres = sum(a)\n\ni = 0\n\nj = 0\n\nwhile True:\n\n    # print(i,j)\n\n    if a[i] < b[j][1]:\n\n        res += b[j][1] - a[i]\n\n        i += 1\n\n    else:\n\n        break\n\n    b[j][0] -= 1\n\n    if b[j][0] == 0:\n\n        j += 1\n\n    if i >= n or j >= m:\n\n        break\n\nprint(res)\n", "generated_code": "n = int(eval(input()))\n\na = list(map(int, input().split()))\n\nb = list(map(int, input().split()))\n\n\n\na = a[::-1]\n\nb = b[::-1]\n\nans = 0\n\nfor i, bi in enumerate(b):\n\n    ans += min(a[i], b[i])\n\n    remain = max(0, b[i] - a[i])\n\n    ans += min(a[i + 1], remain)\n\n    a[i + 1] = max(0, a[i + 1] - remain)\n\nprint(ans)", "score": 0.0, "codebleu": 0.1391830909565314, "crystalbleu": 0.06454169435906841, "codebertscore": 0.71, "codescore": 0.24984824657440186, "surfaceSim": 0.38915169133192384, "abs_surfaceSim_minus_score": 0.38915169133192384}
{"golden_code": "import sys\n\ninput = sys.stdin.readline\n\nfrom scipy.sparse.csgraph import dijkstra\n\nimport numpy as np\n\n\n\n\"\"\"\n\n最小カット\n\n\"\"\"\n\n\n\nN = int(eval(input()))\n\nstart = 0\n\ngoal = N+1\n\n\n\nA = [0] + [int(x) for x in input().split()]\n\n\n\nINF = 10 ** 12\n\ngraph = np.zeros((N+2,N+2),dtype=np.int64)\n\nfor i,a in enumerate(A[1:],1):\n\n    if a >= 0:\n\n        graph[start,i] = a\n\n    else:\n\n        graph[i,goal] = -a\n\nfor i in range(1,N+1):\n\n    for j in range(2*i,N+1,i):\n\n        if A[i] < 0 and A[j] > 0:\n\n            graph[j][i] = INF\n\n\n\ndef max_flow(graph):\n\n    flow = 0\n\n    while True:\n\n        dist,pred = dijkstra(graph, indices = start, return_predecessors = True, unweighted = True)\n\n        if dist[goal] == np.inf:\n\n            return flow\n\n        path = []\n\n        v = goal\n\n        while True:\n\n            path.append((pred[v],v))\n\n            v = pred[v]\n\n            if v == start:\n\n                break\n\n        add_flow = min(graph[x][y] for x,y in path)\n\n        for x,y in path:\n\n            graph[x][y] -= add_flow\n\n            graph[y][x] += add_flow\n\n        flow += add_flow\n\n\n\nanswer = sum(x for x in A if x > 0) - max_flow(graph)\n\nprint(answer)", "generated_code": "N = int(eval(input()))\n\nA = [int(i) for i in input().split()]\n\nC = [A[i]-i for i in range(N)]\n\nC.sort()\n\nans = 0\n\nmed = C[N//2]\n\nfor i in range(N):\n\n  ans += abs(C[i]-med)\n\nprint(ans)", "score": 0.0, "codebleu": 0.10868712167607164, "crystalbleu": 0.01617120660417481, "codebertscore": 0.7, "codescore": 0.17792248725891113, "surfaceSim": 0.4129228100607112, "abs_surfaceSim_minus_score": 0.4129228100607112}
{"golden_code": "X = int(eval(input()))\n\nfor A in range(-200, 200):\n\n    for B in range(-200, 200):\n\n        if A**5 - B**5 == X:\n\n            print((A, B))\n\n            break\n\n    else:\n\n        continue\n\n    break", "generated_code": "'''\n\n    Auther: ghoshashis545 Ashis Ghosh\n\n    College: jalpaiguri Govt Enggineering College\n\n\n\n'''\n\nfrom os import path\n\nimport sys\n\nfrom heapq import heappush,heappop\n\nfrom functools import cmp_to_key as ctk\n\nfrom collections import deque,defaultdict as dd \n\nfrom bisect import bisect,bisect_left,bisect_right,insort,insort_left,insort_right\n\nfrom itertools import permutations\n\nfrom datetime import datetime\n\nfrom math import ceil,sqrt,log,gcd\n\ndef ii():return int(eval(input()))\n\ndef si():return eval(input())\n\ndef mi():return list(map(int,input().split()))\n\ndef li():return list(mi())\n\nabc='abcdefghijklmnopqrstuvwxyz'\n\nmod=1000000007\n\n# mod=998244353\n\ninf = float(\"inf\")\n\nvow=['a','e','i','o','u']\n\ndx,dy=[-1,1,0,0],[0,0,1,-1]\n\n\n\ndef bo(i):\n\n    return ord(i)-ord('a')\n\n\n\nfile=0\n\n\n\n\n\n\n\n\n\n\n\ndef solve():\n\n\n\n\n\n    # for _ in range(ii()):\n\n    \n\n        \n\n\n\n    n=ii()\n\n    n%=1000\n\n    if(n!=0):\n\n        n=1000-n\n\n    print(n)\n\n \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n        \n\nif __name__ ==\"__main__\":\n\n\n\n    if(file):\n\n\n\n        if path.exists('input1.txt'):\n\n            sys.stdin=open('input1.txt', 'r')\n\n            sys.stdout=open('output1.txt','w')\n\n        else:\n\n            input=sys.stdin.readline\n\n    solve()\n", "score": 0.0, "codebleu": 0.16687854605441152, "crystalbleu": 0.02325204625676979, "codebertscore": 0.61, "codescore": 0.7069635987281799, "surfaceSim": 0.4056291390728477, "abs_surfaceSim_minus_score": 0.4056291390728477}
{"golden_code": "def solve():\n\n  N, K = list(map(int, input().split()))\n\n  _S = eval(input())\n\n  S = []\n\n  b = _S[0]\n\n  s = 0\n\n  if b == '0': S.append(0)\n\n  for _s in _S:\n\n    if b == _s:\n\n      s = s + 1\n\n    else:\n\n      b = _s\n\n      S.append(s)\n\n      s = 1\n\n  S.append(s)\n\n  if b == '0': S.append(0)\n\n\n\n  num = min(len(S), 2 * K + 1)\n\n  # n = sum(S[0:num if _S[0] == '1' else (num - 1)])\n\n  n = sum(S[0:num])\n\n  m = n\n\n  # for i in range(0 if _S[0] == '1' else -1, len(S) - num, 2):\n\n  for i in range(0, len(S) - num, 2):\n\n    n = n - sum(S[i:i+2])\n\n    n = n + sum(S[i + num:i + num + 2])\n\n    m = max(m, n)\n\n\n\n  return m\n\n\n\nprint((solve()))", "generated_code": "from collections import Counter\n\nn=int(eval(input()))\n\na=[]\n\nfor i in range(n):\n\n  a.append(eval(input()))\n\nac=Counter(a)\n\nacs=sorted(list(ac.items()),key=lambda x:x[1],reverse=1)\n\nz=len(acs)\n\ni=0\n\ntemp=[]\n\n\n\nwhile i<=z-1 and acs[i][1]==acs[0][1] :\n\n  temp.append(acs[i][0])\n\n  i+=1\n\ntemp.sort()\n\nfor i in temp:\n\n  print(i)", "score": 0.0, "codebleu": 0.10999889065168222, "crystalbleu": 0.05686556615041549, "codebertscore": 0.71, "codescore": 0.46858036518096924, "surfaceSim": 0.5619047619047619, "abs_surfaceSim_minus_score": 0.5619047619047619}
{"golden_code": "a, b, c, x, y = list(map(int, input().split()))\n\nab = c * 2\n\n\n\nres = float(\"inf\")\n\nif a + b <= ab:\n\n    res = x * a + y * b\n\nelse:\n\n    if x == y:\n\n        res = x * ab\n\n    elif x > y:\n\n        for i in range(y, x + 1):\n\n            cost = i * ab + (x - i) * a\n\n            res = min(res, cost)\n\n    else:\n\n        for i in range(x, y + 1):\n\n            cost = i * ab + (y - i) * b\n\n            res = min(res, cost)\n\nprint(res)\n", "generated_code": "# -*- coding: utf-8 -*-\n\nimport sys\n\n\n\nX = int(input().strip())\n\n#-----\n\ncalc = {}\n\n\n\nfor i in range(-118,120):\n\n    calc[i] = i**5\n\n\n\n\n\nfor a in range(-118,120):\n\n    for b in range(-118,120):\n\n        if (calc[a] - calc[b]) == X:\n\n            print((a,b))\n\n            sys.exit()\n", "score": 0.0, "codebleu": 0.06819732889902783, "crystalbleu": 0.047122354643454024, "codebertscore": 0.71, "codescore": 0.9799211621284485, "surfaceSim": 0.5712620712620713, "abs_surfaceSim_minus_score": 0.5712620712620713}
{"golden_code": "a,b,c,d,e,f=[int(eval(input())) for _ in range(6)]\n\nprint((sum([a,b,c,d,max(e,f)])-min([a,b,c,d])))", "generated_code": "from collections import Counter\n\ndef solve():\n\n  N = int(input())\n\n  S = [input() for _ in range(N)]\n\n  c = Counter(S)\n\n  M = max(c.values())\n\n  ans = []\n\n  for k,v in c.items():\n\n    if v==M:\n\n      ans.append(k)\n\n  ans.sort()\n\n  return ans\n\nprint(*solve(),sep='\\n')\n", "score": 0.0, "codebleu": 0.17951909718644948, "crystalbleu": 0.0, "codebertscore": 0.72, "codescore": 0.3853825032711029, "surfaceSim": 0.44159012629161887, "abs_surfaceSim_minus_score": 0.44159012629161887}
{"golden_code": "from collections import Counter\n\n\n\nN = int(eval(input()))\n\ninputs = [int(i) for i in input().split()]\n\n\n\nans = 0\n\nruisekiwa = [0] * (N+1)\n\n\n\nfor i in range(N):\n\n    ruisekiwa[i+1] = ruisekiwa[i] + inputs[i]\n\n\n\nruisekiwa = ruisekiwa[1:]\n\nruisekiwa.sort()\n\ncounter_ruiseki = Counter(ruisekiwa)\n\n\n\nfor key, value in list(counter_ruiseki.items()):\n\n    if key == 0 and value == 1:\n\n        ans += value\n\n        continue\n\n    elif key == 0 and value > 1:\n\n        ans += value\n\n    if value > 1:\n\n        ans += sum(list(range(value)))\n\n\n\nprint(ans)\n", "generated_code": "import sys\n\nsys.setrecursionlimit(10**6)\n\nif sys.platform in (['ios','darwin','win32']):\n\n\tsys.stdin=open('Untitled.txt')\n\ninput = sys.stdin.readline\n\ndef INT(): return int(eval(input()))\n\ndef MAP(): return [int(s) for s in input().split()]\n\n\n\ndef main():\n\n\tS = input().rstrip()\n\n\tbcnt = 0\n\n\tans = 0\n\n\tfor i in range(len(S)):\n\n\t\tif S[i] == 'B': bcnt += 1\n\n\t\tif S[i] == 'W': ans += bcnt\n\n\t\n\n\tprint(ans)\n\n\n\nif __name__ == '__main__':\n\n\tmain()", "score": 0.0, "codebleu": 0.22285655531618903, "crystalbleu": 0.12827134599376194, "codebertscore": 0.72, "codescore": 0.018325557932257652, "surfaceSim": 0.49603174603174605, "abs_surfaceSim_minus_score": 0.49603174603174605}
{"golden_code": "a,b=list(map(int,input().split()))\n\nans=0\n\nfor i in range(b+1)[a:]:\n\n  if len(str(i))%2==0:\n\n    p=list(str(i))[:len(str(i))//2]\n\n    q=list(reversed(list(str(i))[len(str(i))//2:]))\n\n    if p==q:\n\n      ans+=1\n\n  else:\n\n    s=list(str(i))[:len(str(i))//2+1]\n\n    d=list(reversed(list(str(i))[len(str(i))//2:]))\n\n    if s==d:\n\n      ans += 1\n\nprint(ans)", "generated_code": "N = int(eval(input()))\n\nA = [int(i) for i in input().split()]\n\nC = [A[i]-i for i in range(N)]\n\nC.sort()\n\nans = 0\n\nmed = C[N//2]\n\nfor i in range(N):\n\n  ans += abs(C[i]-med)\n\nprint(ans)", "score": 0.0, "codebleu": 0.13642200045066216, "crystalbleu": 0.0778075916452604, "codebertscore": 0.76, "codescore": 0.2813769280910492, "surfaceSim": 0.49318181818181817, "abs_surfaceSim_minus_score": 0.49318181818181817}
{"golden_code": "#!/usr/bin/env python3\n\ndef main():\n\n    import numpy as np\n\n\n\n    np.set_printoptions(linewidth=200)\n\n\n\n    N, W = list(map(int, input().split()))\n\n    lst = [list(map(int, input().split())) for _ in range(N)]\n\n    v_max = 10 ** 3 * 100 * 10\n\n    w_max = 10 ** 9 * v_max\n\n\n\n    # i以上の価値を持つときの最小重量\n\n    dp = np.full(v_max, w_max, dtype=np.int64)\n\n    # initialize\n\n    dp[0] = 0\n\n\n\n    for n in range(N):\n\n        w, v = lst[n]\n\n        dp[v:] = np.minimum(dp[v:], dp[:-v] + w)\n\n\n\n    ans = 0\n\n    for i, w in enumerate(dp):\n\n        if w <= W:\n\n            ans = i\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "generated_code": "a,b,c,x,y=list(map(int,input().split()))\n\nans=a*x+b*y\n\nif x==y:\n\n    ans=min(ans,2*x*c)\n\nelif x>y:\n\n    ans=min(ans,a*(x-y)+2*y*c)\n\n    ans=min(ans,2*x*c)\n\nelse:\n\n    ans=min(ans,b*(y-x)+2*x*c)\n\n    ans=min(ans,2*y*c)\n\nprint(ans)", "score": 0.0, "codebleu": 0.12353387685774093, "crystalbleu": 0.12702791078719863, "codebertscore": 0.66, "codescore": 0.14129509031772614, "surfaceSim": 0.5091974053635395, "abs_surfaceSim_minus_score": 0.5091974053635395}
{"golden_code": "n = int(eval(input()))\n\n\n\nXY = []\n\nfor i in range(n):\n\n    a = int(eval(input()))\n\n    xy = []\n\n    for j in range(a):\n\n        xy.append(list(map(int, input().split())))\n\n    \n\n    XY.append(xy)\n\n    \n\ndef check(i, xiyj, HoU):\n\n    # 矛盾したらFalse 正直者と仮定した証言より 正直&正直者と仮定されている / 不親切&不親切と仮定されている True\n\n    if ((i >> xiyj) & 1) ^ HoU:\n\n        return False\n\n\n\n    return True\n\n    \n\nmax_honest = 0\n\nfor i in range(2 ** len(XY)):\n\n    count = 0\n\n    is_contradiction = True\n\n    for j in range(len(XY)):\n\n        # 正直者と仮定したときだけ採用\n\n        if not ((i >> j) & 1): continue\n\n        for k in range(len(XY[j])):\n\n            xiyj = XY[j][k][0] - 1\n\n            HoU = XY[j][k][1]\n\n            \n\n            if not check(i, xiyj, HoU):\n\n                is_contradiction = False\n\n                break\n\n                \n\n        if not is_contradiction:\n\n            break\n\n\n\n    if is_contradiction:\n\n        for j in range(len(XY)):\n\n            if ((i >> j) & 1): count+=1 \n\n                \n\n        if count > max_honest:\n\n            max_honest =count\n\n            \n\nprint(max_honest)", "generated_code": "n,m=list(map(int,input().split()))\n\nl,r=list(map(int,input().split()))\n\nfor i in range(m-1):\n\n  tl,tr=list(map(int,input().split()))\n\n  if l<tl:\n\n    l=tl\n\n  if tr<r:\n\n    r=tr\n\nprint((max(r-l+1,0)))", "score": 0.0, "codebleu": 0.09147750860966736, "crystalbleu": 0.03573186274718386, "codebertscore": 0.67, "codescore": 0.46672433614730835, "surfaceSim": 0.5023895352012672, "abs_surfaceSim_minus_score": 0.5023895352012672}
{"golden_code": "N, D = list(map(int, input().split()))\n\ncnt = 0\n\nfor _ in range(N):\n\n    x, y = list(map(int, input().split()))\n\n    if x ** 2 + y ** 2 <= D ** 2:\n\n        cnt += 1\n\n        \n\nprint(cnt)", "generated_code": "X = int(eval(input()))\n\nfor a in range(0, 121):\n\n    for b in range(0, 121):\n\n        if X == a**5 - b**5:\n\n            print((a, b))\n\n            exit()\n\n        elif X == a**5 + b**5:\n\n            print((a, -b))\n\n            exit()\n\n        elif X == -a**5 - (10**4 - b)**5:\n\n            print((-a, 10**4 - b))\n\n            exit()", "score": 0.0, "codebleu": 0.142357914327, "crystalbleu": 0.006363186629073279, "codebertscore": 0.72, "codescore": 0.5677728056907654, "surfaceSim": 0.6375958378970428, "abs_surfaceSim_minus_score": 0.6375958378970428}
{"golden_code": "import sys\n\nfrom operator import itemgetter\n\n\n\nn, m = list(map(int, input().split()))\n\na = list(map(int, sys.stdin.readline().split()))\n\nbc = [ tuple(map(int, x.split())) for x in sys.stdin.readlines()]\n\nbc.sort(key = itemgetter(1), reverse=True)\n\nbc.append((n,0))\n\ndiff = []\n\nfor b, c in bc:\n\n    diff += [c] * b\n\n    if len(diff) > n:\n\n        break\n\n\n\na += diff\n\na.sort()\n\nprint((sum(a[-n:])))\n", "generated_code": "import sys\n\n\n\nX= int(eval(input()))\n\n\n\n#添字の最大値を算出\n\n\n\na = 1\n\nb = 0\n\ndif = 0\n\nwhile dif < 10**9:\n\n    a += 1\n\n    b += 1\n\n\n\n    dif = a ** 5 - b ** 5\n\n\n\nloop_sequence = a - 1\n\n\n\nfor i in range(-(loop_sequence),loop_sequence):\n\n\tfor j in range(-(loop_sequence),loop_sequence):\n\n\t\tif(X == i ** 5 - j ** 5):\n\n\t\t\tprint((i,j))\n\n\t\t\tsys.exit()\n", "score": 0.0, "codebleu": 0.13565818645811512, "crystalbleu": 0.042499831296982586, "codebertscore": 0.69, "codescore": 0.22121594846248627, "surfaceSim": 0.4620367038503059, "abs_surfaceSim_minus_score": 0.4620367038503059}
{"golden_code": "from fractions import gcd\n\n\n\nn,m=list(map(int,input().split()))\n\na=list(map(int,input().split()))\n\na=list(set(a))\n\n\n\na=list([x//2 for x in a])\n\n\n\ndef lcm(q):\n\n  x = q[0]\n\n  for i in range(1, len(q)):\n\n    x = (x * q[i]) // gcd(x, q[i])\n\n  return x\n\n\n\nlcma=lcm(a)\n\n\n\nif (lcma//a[0])%2==0:\n\n  print((0))\n\nelse:\n\n  flg=0\n\n  for i in range(1,len(a)):\n\n    if (lcma//a[i])%2==0:\n\n      print((0))\n\n      flg=1\n\n      break\n\n  if flg==0:\n\n    temp=m//lcma\n\n    print((temp//2 if temp%2==0 else temp//2+1))", "generated_code": "def factorial(N):\n\n    power_r = 1\n\n    for n in range(2,N+1):\n\n        power_r = power_r*n % (10**9+7)\n\n    return power_r\n\n\n\nif __name__ == '__main__':\n\n    N = int(eval(input()))\n\n    print((factorial(N)))", "score": 0.0, "codebleu": 0.09934353798076127, "crystalbleu": 0.006393475797996511, "codebertscore": 0.7, "codescore": 0.057186324149370193, "surfaceSim": 0.4968687374749499, "abs_surfaceSim_minus_score": 0.4968687374749499}
{"golden_code": "s=eval(input())\n\nt=eval(input())\n\ns*=2\n\nnext=[[-1]*26 for _ in range(len(s))]\n\nalph=[[]for _ in range(26)]\n\nfor i in range(len(s)):\n\n\talph[ord(s[i])-ord(\"a\")].append(i)\n\nfrom bisect import bisect_right\n\nfor i in range(len(s)//2):\n\n\tfor j in range(26):\n\n\t\tif len(alph[j])>bisect_right(alph[j],i):\n\n\t\t\tnext[i][j]=alph[j][bisect_right(alph[j],i)]\n\nans=1\n\nnow=len(s)//2-1\n\nfor x in t:\n\n\tr=ord(x)-ord(\"a\")\n\n\tnow=next[now][r]\n\n\tif now==-1:\n\n\t\tprint((-1))\n\n\t\texit()\n\n\tif now>=len(s)//2:\n\n\t\tans+=len(s)//2\n\n\t\tnow-=len(s)//2\n\nprint((ans+now-len(s)//2))", "generated_code": "import sys\n\n\n\n\n\ndef rec(length):\n\n    if length == 1:\n\n        return 9\n\n    else:\n\n        return 9 * 10**(length - 1) + rec(length - 2)\n\n\n\n\n\nn = eval(input())\n\nlength = len(n)\n\n\n\nif length == 1:\n\n    print(n)\n\n    sys.exit()\n\n\n\nif length % 2 == 0:\n\n    ans = rec(length - 1)\n\nelse:\n\n    ans = rec(length - 2) + int(n) - int(\"1\" + \"0\" * (length - 1)) + 1\n\n\n\nprint(ans)", "score": 0.0, "codebleu": 0.11447319920744561, "crystalbleu": 0.039653887357953915, "codebertscore": 0.71, "codescore": 0.26658347249031067, "surfaceSim": 0.3853466726394903, "abs_surfaceSim_minus_score": 0.3853466726394903}
{"golden_code": "a,b = list(map(int,input().split()))\n\nanswer = 0\n\nfor i in range(a,b+1) :\n\n    j = str(i)\n\n    p1 = j[4]\n\n    p2 = j[3]\n\n    p3 = j[2]\n\n    p4 = j[1]\n\n    p5 = j[0]\n\n    k = int(p1+p2+p3+p4+p5)\n\n    if i == k :\n\n        answer += 1\n\nprint(answer)\n\n\n", "generated_code": "from math import gcd\n\nn,m=list(map(int,input().split()))\n\na=list(map(int,input().split()))\n\na=list(set(a))\n\na=list([x//2 for x in a])\n\n\n\ndef lcm(q):\n\n  x = q[0]\n\n  for i in range(1, len(q)):\n\n    x = (x * q[i]) // gcd(x, q[i])\n\n  return x\n\n\n\nlcma=lcm(a)\n\nfor i in range(len(a)):\n\n  if (lcma//a[i])%2==0:\n\n    print((0))\n\n    exit()\n\ntemp=m//lcma\n\nprint((temp//2 if temp%2==0 else temp//2+1))", "score": 0.0, "codebleu": 0.2926782599236912, "crystalbleu": 0.0, "codebertscore": 0.75, "codescore": 0.9197614789009094, "surfaceSim": 0.4872535269367214, "abs_surfaceSim_minus_score": 0.4872535269367214}
{"golden_code": "'''\n\n    Auther: ghoshashis545 Ashis Ghosh\n\n    College: jalpaiguri Govt Enggineering College\n\n\n\n'''\n\nfrom os import path\n\nimport sys\n\nfrom functools import cmp_to_key as ctk\n\nfrom collections import deque,defaultdict as dd \n\nfrom bisect import bisect,bisect_left,bisect_right,insort,insort_left,insort_right\n\nfrom itertools import permutations\n\nfrom datetime import datetime\n\nfrom math import ceil,sqrt,log,gcd\n\ndef ii():return int(eval(input()))\n\ndef si():return eval(input())\n\ndef mi():return list(map(int,input().split()))\n\ndef li():return list(mi())\n\nabc='abcdefghijklmnopqrstuvwxyz'\n\nmod=1000000007\n\n#mod=998244353\n\ninf = float(\"inf\")\n\nvow=['a','e','i','o','u']\n\ndx,dy=[-1,1,0,0],[0,0,1,-1]\n\n\n\ndef bo(i):\n\n    return ord(i)-ord('a')\n\n\n\nfile = 0\n\n\n\ndef solve():\n\n    \n\n\n\n\n\n\n\n    # for _ in range(ii()):\n\n\n\n    n=ii()\n\n    n%=1000\n\n    if n!=0:\n\n        n=1000-n\n\n    print(n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nif __name__ ==\"__main__\":\n\n\n\n    if(file):\n\n\n\n        if path.exists('input1.txt'):\n\n            sys.stdin=open('input1.txt', 'r')\n\n            sys.stdout=open('output1.txt','w')\n\n        else:\n\n            input=sys.stdin.readline\n\n    solve()", "generated_code": "import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nfrom operator import itemgetter\n\n\n\nn, m = list(map(int, readline().split()))\n\na = list(map(int, readline().split()))\n\nm = list(map(int, read().split()))\n\nbc = list(zip(m,m))\n\n\n\nbc.sort(key = itemgetter(1), reverse=True)\n\nbc.append((n,0))\n\ndiff = []\n\nfor b, c in bc:\n\n    diff += [c] * b\n\n    if len(diff) > n:\n\n        break\n\n\n\na += diff\n\na.sort()\n\nprint((sum(a[-n:])))\n", "score": 0.0, "codebleu": 0.16300617127617312, "crystalbleu": 0.030685666175921725, "codebertscore": 0.69, "codescore": 0.8298621773719788, "surfaceSim": 0.482015065913371, "abs_surfaceSim_minus_score": 0.482015065913371}
{"golden_code": "import numpy as np\n\nn,d=list(map(int,input().split()))\n\nnda=np.empty((0,d),int)\n\nans=0\n\nfor i in range(0,n):\n\n  a=np.array([list(map(int,input().split()))])\n\n  for j in range(i):\n\n    chklen=np.linalg.norm(a-nda[j])\n\n    if chklen==chklen//1:\n\n      ans+=1\n\n  nda=np.append(nda,a,axis=0)\n\nprint(ans)", "generated_code": "def main():\n\n    n = int(eval(input()))\n\n    dp = [[0 for i in range(10)] for i in range(10)]\n\n    for i in range(1,n+1):\n\n        h,t = int(str(i)[0]), int(str(i)[-1])\n\n        dp[h][t] += 1\n\n    ans = 0\n\n    for i in range(10):\n\n        for j in range(10):\n\n            ans += dp[i][j] * dp[j][i]\n\n    print(ans)\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "score": 0.0, "codebleu": 0.157156524640586, "crystalbleu": 0.14354983721831774, "codebertscore": 0.76, "codescore": 0.018285837024450302, "surfaceSim": 0.5151435574229692, "abs_surfaceSim_minus_score": 0.5151435574229692}
{"golden_code": "import math\n\nn=int(eval(input()))\n\nans=n\n\ni=1\n\nwhile(i<=math.sqrt(n)):\n\n    if n%i==0:\n\n        d=i+n/i-2\n\n        ans=min(ans,d)\n\n    i+=1\n\nprint((int(ans)))", "generated_code": "N=int(eval(input()));print((N if N%2==0 else N*2))", "score": 0.0, "codebleu": 0.08221389660230441, "crystalbleu": 0.0, "codebertscore": 0.77, "codescore": 0.33205002546310425, "surfaceSim": 0.4588607594936709, "abs_surfaceSim_minus_score": 0.4588607594936709}
{"golden_code": "N, M = (int(x) for x in input().split())\n\nedge = [tuple(int(x) for x in input().split()) for _ in range(M)]\n\n\n\nimport numpy as np\n\nfrom scipy.sparse.csgraph import floyd_warshall\n\nINF = 100\n\ntmpl_graph = [[INF if i != j else 0 for j in range(N)] for i in range(N)]\n\n\n\nans = 0\n\nfor E in edge:\n\n    edgeWithoutE = edge.copy()\n\n    edgeWithoutE.remove(E)\n\n    graph = np.array(tmpl_graph)\n\n    for x in edgeWithoutE:\n\n        graph[x[0]-1,x[1]-1] = 1\n\n        graph[x[1]-1,x[0]-1] = 1\n\n    graph = floyd_warshall(graph,directed=False)\n\n    if len(graph[graph == 100]) > 0:\n\n        ans += 1\n\nprint(ans)", "generated_code": "n, k = list(map(int, input().split()))\n\nV = list(map(int, input().split()))\n\n\n\n\n\ndef get_jewelries(box, left_pop, right_pop):\n\n    if left_pop + right_pop >= len(box):\n\n        return box[:]\n\n\n\n    left = box[:left_pop]\n\n    right = box[-right_pop:] if right_pop else []\n\n\n\n    return left + right\n\n\n\n\n\ncandidates = []\n\npop_max = min(k, n)\n\nfor pop_count in range(pop_max+1):\n\n    residue = k - pop_count\n\n\n\n    for left_pop in range(pop_count+1):\n\n        right_pop = pop_count - left_pop\n\n        jewelries = get_jewelries(V, left_pop, right_pop)\n\n        jewelries.sort(reverse=True)\n\n\n\n        for _ in range(residue):\n\n            if not jewelries:\n\n                break\n\n            if jewelries[-1] < 0:\n\n                jewelries.pop()\n\n\n\n        value = sum(jewelries)\n\n        candidates.append(value)\n\n\n\nprint((max(candidates)))\n", "score": 0.0, "codebleu": 0.1902053791483852, "crystalbleu": 0.04861347579427948, "codebertscore": 0.7, "codescore": 0.9937456846237183, "surfaceSim": 0.46223316912972084, "abs_surfaceSim_minus_score": 0.46223316912972084}
{"golden_code": "s = eval(input())\n\ncnt = 0\n\nfor i in range(len(s) - 1):\n\n    if s[i] == 'W' and s[i + 1] == 'B':\n\n        cnt += 1\n\n    if s[i] == 'B' and s[i + 1] == 'W':\n\n        cnt += 1\n\nprint(cnt)", "generated_code": "a, b = list(map(int, input().split()))\n\ncnt = 0\n\nfor i in range(a, b + 1):\n\n    s = str(i)\n\n    if s[0] == s[4] and s[1] == s[3]:\n\n        cnt += 1\n\nprint(cnt)", "score": 0.0, "codebleu": 0.25930551861413403, "crystalbleu": 0.0, "codebertscore": 0.87, "codescore": 0.6319330930709839, "surfaceSim": 0.73992628992629, "abs_surfaceSim_minus_score": 0.73992628992629}
{"golden_code": "S=eval(input())\n\nprint((S.rfind('Z')-S.find('A')+1))", "generated_code": "\"\"\"Minimum cost Sort.\"\"\"\n\n\n\ndef min_cost_sort(A):\n\n    \"\"\"Sort list A in ascending order.\n\n \n\n    And return the switching cost in sorting.\n\n    \"\"\"\n\n    B = list(A)\n\n    B.sort()\n\n    cost = 0\n\n    min_w = B[0]\n\n    for i, b in enumerate(B):\n\n        tmp_cost = 0\n\n        bi = A.index(b)\n\n        cnt = 0\n\n        while bi != i:\n\n            cnt += 1\n\n            st = B[bi]\n\n            si = A.index(st)\n\n            tmp_cost += b + st\n\n            A[bi], A[si] = st, b\n\n            bi = si\n\n        if cnt:\n\n            dec = cnt * (b - min_w)\n\n            inc = 2 * (min_w + b)\n\n            if dec < inc:\n\n                cost += tmp_cost\n\n            else:\n\n                cost += tmp_cost - dec + inc\n\n    return cost\n\n\n\n\n\nn = eval(input())\n\n\n\nA = list(map(int, input().split()))\n\n\n\nans = min_cost_sort(A)\n\n\n\nprint(ans)", "score": 0.0, "codebleu": 0.24523809523809523, "crystalbleu": 0.0, "codebertscore": 0.59, "codescore": 0.9931195974349976, "surfaceSim": 0.4459223431412065, "abs_surfaceSim_minus_score": 0.4459223431412065}
{"golden_code": "import sys\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\nreadlines = sys.stdin.readlines\n\n\n\nMOD = 10**9+7\n\n\n\nfac = [1, 1]     # 元テーブル\n\nf_inv = [1, 1]   # 逆元テーブル\n\ninv = [0, 1]     # 逆元テーブル計算用テーブル\n\ndef prepare(n, mod):\n\n    for i in range(2, n+1):\n\n        fac.append((fac[-1] * i) % mod)\n\n        inv.append((-inv[mod % i] * (mod//i)) % mod)\n\n        f_inv.append((f_inv[-1] * inv[-1]) % mod)\n\n\n\n\n\ndef cmb(n, r, mod):\n\n    if n < 0 or r < 0:\n\n        return 0\n\n    if r > n:\n\n        return 0\n\n\n\n    return fac[n] * f_inv[r] * f_inv[n-r] % mod\n\n\n\n\n\ndef prime_factorization(n):\n\n    d = []\n\n    i, e = 2, 0  # factor, exponent\n\n    while i * i <= n:\n\n        while n % i == 0:\n\n            n //= i\n\n            e += 1\n\n        if e > 0:\n\n            d.append((i, e))\n\n        i += 1\n\n        e = 0\n\n    if n > 1:\n\n        d.append((n, 1))\n\n    return d\n\n\n\n\n\ndef main():\n\n    N,M = list(map(int, readline().split()))\n\n\n\n    prepare(N+100, MOD)\n\n    d = prime_factorization(M)\n\n\n\n    ans = 1\n\n    for i, e in d:\n\n        ans *= cmb(N-1+e, e, MOD)\n\n        ans %= MOD\n\n\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "generated_code": "n = int(eval(input()))\n\nans = 0\n\nfor i in map(int, input().split()):\n\n    cnt = 0\n\n    while i % 2 == 0:\n\n        i >>= 1\n\n        cnt += 1\n\n    ans += cnt\n\nprint(ans)", "score": 0.0, "codebleu": 0.05559853511157205, "crystalbleu": 0.0019218761657660548, "codebertscore": 0.66, "codescore": 0.05118434876203537, "surfaceSim": 0.44618606701940033, "abs_surfaceSim_minus_score": 0.44618606701940033}
{"golden_code": "import sys\n\nsys.setrecursionlimit(10**6)\n\nif sys.platform in (['ios','darwin','win32']):\n\n\tsys.stdin=open('Untitled.txt')\n\ninput = sys.stdin.readline\n\ndef INT(): return int(eval(input()))\n\ndef MAP(): return [int(s) for s in input().split()]\n\n\n\ndef main():\n\n\tS = input().rstrip()\n\n\tbcnt = 0\n\n\tA = []\n\n\tfor i in range(len(S)):\n\n\t\tif S[i] == 'B': bcnt += 1\n\n\t\tif S[i] == 'W': A.append(bcnt)\n\n\t\n\n\tprint((sum(A)))\n\n\n\nif __name__ == '__main__':\n\n\tmain()", "generated_code": "N,L = list(map(int, input().split()))\n\ntaste = [L+i-1 for i in range(1,N+1)]\n\nif taste[-1] < 0:\n\n  print((sum(taste) + min([abs(x) for x in taste])))\n\nelse:\n\n  print((sum(taste) - min([abs(x) for x in taste])))", "score": 0.0, "codebleu": 0.12059645216681229, "crystalbleu": 0.05558573146865832, "codebertscore": 0.71, "codescore": 0.05149225518107414, "surfaceSim": 0.42424242424242425, "abs_surfaceSim_minus_score": 0.42424242424242425}
{"golden_code": "a, b = list(map(int, input().split()))\n\ncnt = 0\n\nfor x in range(a, b + 1):\n\n    s = str(x)\n\n    l = len(s)\n\n    flg = True\n\n    for i in range(l // 2):\n\n        if s[i] != s[l - 1 - i]:\n\n            flg = False\n\n            break\n\n    if flg:\n\n        cnt += 1\n\nprint(cnt)\n", "generated_code": "# coding: utf-8\n\nimport sys\n\nimport itertools\n\n\n\nsr = lambda: sys.stdin.readline().rstrip()\n\nir = lambda: int(sr())\n\nlr = lambda: list(map(int, sr().split()))\n\n\n\n# 0か1の連続している人数のリスト、累積和\n\nstreak = [0, 0]\n\nN, K = lr()\n\nS = sr() + '2'\n\ncur = 1\n\nfor i in range(N):\n\n    if S[i] != S[i+1]:\n\n        streak.append(cur)\n\n        cur = 1\n\n    else:\n\n        cur += 1\n\n\n\nstreak_cum = list(itertools.accumulate(streak))\n\nstreak_cum.extend([streak_cum[-1], streak_cum[-1]])\n\nif S[0] == '0':\n\n    start = 0\n\nelse:\n\n    start = 1\n\nanswer = 0\n\n\n\nlimit = len(streak_cum) - 1\n\nfor i in range(start, len(streak_cum), 2):\n\n    result = streak_cum[min(limit, i+2*K+1)] - streak_cum[i]\n\n    if result > answer:\n\n        answer = result\n\n\n\nprint(answer)\n\n# 52", "score": 0.0, "codebleu": 0.2548339051775235, "crystalbleu": 0.08946239376106672, "codebertscore": 0.7, "codescore": 0.50807124376297, "surfaceSim": 0.5248473541383989, "abs_surfaceSim_minus_score": 0.5248473541383989}
{"golden_code": "a,b,c,x,y=list(map(int,input().split()))\n\n\n\nans=a*x+b*y\n\nfor ci in range(max(x,y)+1):\n\n    sumc = 2*ci*c\n\n    sumc += (x-ci)*a if (x-ci)>0 else 0\n\n    sumc += (y-ci)*b if (y-ci)>0 else 0\n\n    ans=min(ans,sumc)\n\n\n\nprint(ans)", "generated_code": "s = eval(input())\n\nlen_s = len(s)\n\ncnt = 0\n\nfor i in range(1, len(s)):\n\n    memo_0 = s[i - 1]\n\n    if s[i] != memo_0:\n\n        cnt += 1\n\nprint(cnt)\n", "score": 0.0, "codebleu": 0.07728425058804944, "crystalbleu": 0.0, "codebertscore": 0.73, "codescore": 0.07555463910102844, "surfaceSim": 0.5128680054591539, "abs_surfaceSim_minus_score": 0.5128680054591539}
{"golden_code": "ans=[]\n\nfor i in range (0,10):\n\n    ans.append(int(eval(input())))\n\nans.sort(reverse=True)\n\nfor i in range (0,3):\n\n    print((ans[i]))", "generated_code": "n = int(eval(input()))\n\nvalue = tuple(map(int, input().split()))\n\ncost = tuple(map(int, input().split()))\n\n# iこめまでのxーyの最大値\n\ninf = -100\n\ndp = [inf] * (n+1)\n\ndp[1] = max(0, value[0]-cost[0])\n\nfor i in range(2, n+1):\n\n    dp[i] = max(dp[i-1], dp[i-1]+value[i-1]-cost[i-1])\n\n\n\nprint((dp[n]))\n", "score": 0.0, "codebleu": 0.2793890720980401, "crystalbleu": 0.0983601247219448, "codebertscore": 0.71, "codescore": 0.06084326654672623, "surfaceSim": 0.5211805555555555, "abs_surfaceSim_minus_score": 0.5211805555555555}
{"golden_code": "#!usr/bin/env python3\n\nfrom collections import defaultdict\n\nfrom collections import deque\n\nfrom heapq import heappush, heappop\n\nimport sys\n\nimport math\n\nimport bisect\n\nimport random\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\n\ndef I(): return int(sys.stdin.readline())\n\ndef LS():return list(map(list, sys.stdin.readline().split()))\n\ndef S(): return list(sys.stdin.readline())[:-1]\n\ndef IR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = I()\n\n    return l\n\ndef LIR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = LI()\n\n    return l\n\ndef SR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = S()\n\n    return l\n\ndef LSR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = SR()\n\n    return l\n\nmod = 1000000007\n\n\n\n#A\n\ndef A():\n\n    s = S()\n\n    t = S()\n\n    if s+t == t[::-1]+s[::-1]:\n\n        print(\"YES\")\n\n    else:\n\n        print(\"NO\")\n\n\n\n#B\n\ndef B():\n\n    n = I()\n\n    for i in range(int(n**0.5)+2)[::-1]:\n\n        if i*i <= n:\n\n            print((i*i))\n\n            quit()\n\n#C\n\ndef C():\n\n    n = I()\n\n    a = LI()\n\n    b = LI()\n\n    c = LI()\n\n    q = [0 for i in range(n)]\n\n    ans = 0\n\n    a.sort()\n\n    b.sort()\n\n    c.sort()\n\n    for i in range(n):\n\n        j = bisect.bisect_left(a,b[i])\n\n        q[i] = j\n\n    for i in range(n-1):\n\n        q[i+1] += q[i]\n\n    q.insert(0,0)\n\n    for i in range(n):\n\n        j = bisect.bisect_left(b,c[i])\n\n        ans += q[j]\n\n    print(ans)\n\n#D\n\ndef D():\n\n    def dijkstra():\n\n        d = [float(\"inf\") for i in range(k)]\n\n        q = [[0,1]]\n\n        d[1] = 0\n\n        while q:\n\n            dx,x = heappop(q)\n\n            for y,dy in v[x]:\n\n                if d[y] > dx+dy:\n\n                    d[y] = dx+dy\n\n                    heappush(q,[d[y],y])\n\n        print((d[0]+1))\n\n    k = I()\n\n    if k == 1:\n\n        print((1))\n\n        quit()\n\n    v = [[] for i in range(k)]\n\n    for i in range(1,k):\n\n        v[i].append([(i+1)%k,1])\n\n        v[i].append([i*10%k,0])\n\n    dijkstra()\n\n#E\n\ndef E():\n\n    return\n\n\n\n#F\n\ndef F():\n\n    return\n\n\n\n#G\n\ndef G():\n\n    return\n\n\n\n#H\n\ndef H():\n\n    return\n\n\n\n#Solve\n\nif __name__ == \"__main__\":\n\n    D()\n", "generated_code": "def solve(a, b, c):\n\n    if any(i % 2 == 1 for i in [a, b, c]):\n\n        return 0\n\n    if a == b == c:\n\n        return -1\n\n    a, b, c = (b + c) // 2, (c + a) // 2, (a + b) // 2\n\n    return solve(a, b, c) + 1\n\n\n\na, b, c = list(map(int, input().split()))\n\n\n\nprint((solve(a, b, c)))", "score": 0.0, "codebleu": 0.05375363398041484, "crystalbleu": 0.0012204649943820586, "codebertscore": 0.69, "codescore": 0.1535789519548416, "surfaceSim": 0.496139148027425, "abs_surfaceSim_minus_score": 0.496139148027425}
{"golden_code": "from collections import Counter,defaultdict,deque\n\nimport sys,bisect,math,itertools,string,queue\n\nfrom heapq import heappop, heappush\n\nsys.setrecursionlimit(10**8)\n\nmod = 10**9+7\n\ndef inp(): return int(sys.stdin.readline())\n\ndef inpl(): return list(map(int, sys.stdin.readline().split()))\n\ndef inpl_str(): return list(sys.stdin.readline().split())\n\ndef inpln(n): return list(int(sys.stdin.readline()) for i in range(n))\n\n\n\nn = inp()\n\nres = float('inf')\n\nfor i in range(1,2*10**6):\n\n    if (n/i).is_integer():\n\n        res = min(res, i + n/i)\n\nprint((int(res-2)))\n", "generated_code": "#!/usr/bin/env python3\n\ndef main():\n\n    import numpy as np\n\n\n\n    N, W = list(map(int, input().split()))\n\n    lst = [list(map(int, input().split())) for _ in range(N)]\n\n    v_max = 10 ** 3 * 100 * 10\n\n    w_max = 10 ** 9 * v_max\n\n\n\n    # i以上の価値を持つときの最小重量\n\n    dp = np.full(v_max, w_max, dtype=np.int64)\n\n    # initialize\n\n    dp[0] = 0\n\n\n\n    for w, v in lst:\n\n        dp[v:] = np.minimum(dp[v:], dp[:-v] + w)\n\n\n\n    print((np.asarray(dp <= W).nonzero()[0].max()))\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 0.0, "codebleu": 0.1712147382399247, "crystalbleu": 0.09396118180609948, "codebertscore": 0.69, "codescore": 0.018365366384387016, "surfaceSim": 0.419470980749844, "abs_surfaceSim_minus_score": 0.419470980749844}
{"golden_code": "a, b, c = list(map(int, input().split()))\n\n\n\nif any(i % 2 != 0 for i in [a, b, c]):\n\n    print((0))\n\n    exit()\n\n\n\nif a == b and b == c:\n\n    print((-1))\n\n    exit()\n\n\n\ncnt = 0\n\na_list = [0]*(1001001)\n\nb_list = [0]*(1001001)\n\nc_list = [0]*(1001001)\n\na_list[0] = a\n\nb_list[0] = b\n\nc_list[0] = c\n\n\n\nfor i in range(1, 1001001):\n\n    a_list[i] = (b_list[i-1] + c_list[i-1]) // 2\n\n    b_list[i] = (c_list[i-1] + a_list[i-1]) // 2\n\n    c_list[i] = (a_list[i-1] + b_list[i-1]) // 2\n\n    cnt += 1\n\n    if a_list[i] % 2 != 0 or b_list[i] % 2 != 0 or c_list[i] % 2 != 0:\n\n        break\n\n\n\nprint(cnt)\n", "generated_code": "import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\nfrom collections import deque\n\n\n\nN,*A = list(map(int,read().split()))\n\n\n\nclass Dinic:\n\n    def __init__(self, N, source, sink):\n\n        self.N = N\n\n        self.G = [[] for _ in range(N)]\n\n        self.source = source\n\n        self.sink = sink\n\n\n\n    def add_edge(self, fr, to, cap):\n\n        n1 = len(self.G[fr])\n\n        n2 = len(self.G[to])\n\n        self.G[fr].append([to, cap, n2])\n\n        self.G[to].append([fr, 0, n1]) # 逆辺を cap 0 で追加\n\n        \n\n    def add_edge_undirected(self, fr, to, cap):\n\n        n1 = len(self.G[fr])\n\n        n2 = len(self.G[to])\n\n        self.G[fr].append([to, cap, n2])\n\n        self.G[to].append([fr, cap, n1])\n\n        \n\n    def bfs(self):\n\n        level = [0] * self.N\n\n        G = self.G; source = self.source; sink = self.sink\n\n        q = deque([source])\n\n        level[source] = 1\n\n        pop = q.popleft; append = q.append\n\n        while q:\n\n            v = pop()\n\n            lv = level[v] + 1\n\n            for to, cap, rev in G[v]:\n\n                if not cap:\n\n                    continue\n\n                if level[to]:\n\n                    continue\n\n                level[to] = lv\n\n                if to == sink:\n\n                    self.level = level\n\n                    return\n\n                append(to)\n\n        self.level = level\n\n        \n\n    def dfs(self,v,f):\n\n        if v == self.sink:\n\n            return f\n\n        G = self.G\n\n        prog = self.progress\n\n        level = self.level\n\n        lv = level[v]\n\n        E = G[v]\n\n        for i in range(prog[v],len(E)):\n\n            to, cap, rev = E[i]\n\n            prog[v] = i\n\n            if not cap:\n\n                continue\n\n            if level[to] <= lv:\n\n                continue\n\n            x = f if f < cap else cap\n\n            ff = self.dfs(to, x)\n\n            if ff:\n\n                E[i][1] -= ff\n\n                G[to][rev][1] += ff\n\n                return ff\n\n        return 0\n\n    \n\n    def max_flow(self):\n\n        INF = 10**18\n\n        flow = 0\n\n        while True:\n\n            self.bfs()\n\n            if not self.level[self.sink]:\n\n                return flow\n\n            self.progress = [0] * self.N\n\n            while True:\n\n                f = self.dfs(self.source, INF)\n\n                if not f:\n\n                    break\n\n                flow += f\n\n        return flow\n\n\n\nsource = 0; sink = N+1; INF = 10 ** 18\n\ndinic = Dinic(N+2,source,sink)\n\nadd = dinic.add_edge\n\n\n\nfor i,x in enumerate(A,1):\n\n    if x < 0:\n\n        # source側：割るものを表現。sink側にうつすときにカット-xが必要。\n\n        add(source,i,-x)\n\n    else:\n\n        # sink側：割らないものを表現。source側にうつすときにカットxが必要。\n\n        add(i,sink,x)\n\n\n\nfor i in range(1,N+1):\n\n    for j in range(i+i,N+1,i):\n\n        # iを割るならjも割る。iを割ってjを割らないのは禁止\n\n        # iがsourceでjがsinkなのは禁止\n\n        add(i,j,INF)\n\n\n\nf = dinic.max_flow()\n\nx = sum(x for x in A if x >= 0)\n\nanswer = x - f\n\n\n\nprint(answer)", "score": 0.0, "codebleu": 0.18618089228760662, "crystalbleu": 0.041445317784228976, "codebertscore": 0.69, "codescore": 0.9938540458679199, "surfaceSim": 0.529609890436471, "abs_surfaceSim_minus_score": 0.529609890436471}
{"golden_code": "X = int(eval(input()))\n\n\n\ngojyous = []\n\n\n\nfor i in range(-200, 201):\n\n    gojyous.append(i ** 5)\n\n\n\n#print(gojyous)\n\n\n\nfor i in range(-200,201):\n\n    for j in range(-200,201):\n\n        if(X == (int(i**5) - int(j**5))):\n\n            print((i, j))\n\n            exit()", "generated_code": "def main():\n\n    A, B, AB, X, Y = list(map(int, input().split()))\n\n    M = max(X, Y)\n\n\n\n    k = 0\n\n    ans = A * X + B * Y\n\n    while True:\n\n        ans = min(\n\n            ans,\n\n            AB * k * 2 + max(0, X - k) * A + max(0, Y - k) * B\n\n        )\n\n\n\n        if k >= M: break\n\n        k += 1\n\n\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 0.0, "codebleu": 0.13956359263619095, "crystalbleu": 0.032380438409818635, "codebertscore": 0.7, "codescore": 0.054565735161304474, "surfaceSim": 0.5310883406287306, "abs_surfaceSim_minus_score": 0.5310883406287306}
{"golden_code": "from collections import Counter\n\n\n\ns = eval(input())\n\nmod1 = 673\n\nmod2 = 3\n\n\n\nnum1 = 0\n\nnum2 = 0\n\nli1 = []\n\nli2 = []\n\npw1 = 10\n\npw2 = 10\n\nfor i, e in enumerate(s, 1):\n\n    num1 *= 10\n\n    num1 += int(e)\n\n    num1 %= mod1\n\n    inv = pow(pw1, mod1 - 2, mod1)\n\n    li1.append(num1 * inv % mod1)\n\n\n\n    num2 *= 10\n\n    num2 += int(e)\n\n    num2 %= mod2\n\n    inv = pow(pw2, mod2 - 2, mod2)\n\n    li2.append(num2 * inv % mod2)\n\n\n\n    pw1 *= 10\n\n    pw1 %= mod1\n\n    pw2 *= 10\n\n    pw2 %= mod2\n\n\n\nli = [0] + [10 * e1 + e2 for e1, e2 in zip(li1, li2)]\n\nc = Counter(li)\n\n\n\nans = 0\n\nfor v in list(c.values()):\n\n    ans += v * (v - 1) // 2\n\n\n\nprint(ans)\n", "generated_code": "import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\nfrom collections import deque\n\n\n\nN,*A = list(map(int,read().split()))\n\n\n\nclass Dinic:\n\n    def __init__(self, N, source, sink):\n\n        self.N = N\n\n        self.G = [[] for _ in range(N)]\n\n        self.source = source\n\n        self.sink = sink\n\n\n\n    def add_edge(self, fr, to, cap):\n\n        n1 = len(self.G[fr])\n\n        n2 = len(self.G[to])\n\n        self.G[fr].append([to, cap, n2])\n\n        self.G[to].append([fr, 0, n1]) # 逆辺を cap 0 で追加\n\n        \n\n    def add_edge_undirected(self, fr, to, cap):\n\n        n1 = len(self.G[fr])\n\n        n2 = len(self.G[to])\n\n        self.G[fr].append([to, cap, n2])\n\n        self.G[to].append([fr, cap, n1])\n\n        \n\n    def bfs(self):\n\n        level = [0] * self.N\n\n        G = self.G; source = self.source; sink = self.sink\n\n        q = deque([source])\n\n        level[source] = 1\n\n        pop = q.popleft; append = q.append\n\n        while q:\n\n            v = pop()\n\n            lv = level[v] + 1\n\n            for to, cap, rev in G[v]:\n\n                if not cap:\n\n                    continue\n\n                if level[to]:\n\n                    continue\n\n                level[to] = lv\n\n                if to == sink:\n\n                    self.level = level\n\n                    return\n\n                append(to)\n\n        self.level = level\n\n        \n\n    def dfs(self,v,f):\n\n        if v == self.sink:\n\n            return f\n\n        G = self.G\n\n        prog = self.progress\n\n        level = self.level\n\n        lv = level[v]\n\n        E = G[v]\n\n        for i in range(prog[v],len(E)):\n\n            to, cap, rev = E[i]\n\n            prog[v] = i\n\n            if not cap:\n\n                continue\n\n            if level[to] <= lv:\n\n                continue\n\n            x = f if f < cap else cap\n\n            ff = self.dfs(to, x)\n\n            if ff:\n\n                E[i][1] -= ff\n\n                G[to][rev][1] += ff\n\n                return ff\n\n        return 0\n\n    \n\n    def max_flow(self):\n\n        INF = 10**18\n\n        flow = 0\n\n        while True:\n\n            self.bfs()\n\n            if not self.level[self.sink]:\n\n                return flow\n\n            self.progress = [0] * self.N\n\n            while True:\n\n                f = self.dfs(self.source, INF)\n\n                if not f:\n\n                    break\n\n                flow += f\n\n        return flow\n\n\n\nsource = 0; sink = N+1; INF = 10 ** 18\n\ndinic = Dinic(N+2,source,sink)\n\nadd = dinic.add_edge\n\n\n\nfor i,x in enumerate(A,1):\n\n    if x < 0:\n\n        # source側：割るものを表現。sink側にうつすときにカット-xが必要。\n\n        add(source,i,-x)\n\n    else:\n\n        # sink側：割らないものを表現。source側にうつすときにカットxが必要。\n\n        add(i,sink,x)\n\n\n\nfor i in range(1,N+1):\n\n    for j in range(i+i,N+1,i):\n\n        # iを割るならjも割る。iを割ってjを割らないのは禁止\n\n        # iがsourceでjがsinkなのは禁止\n\n        add(i,j,INF)\n\n\n\nf = dinic.max_flow()\n\nx = sum(x for x in A if x >= 0)\n\nanswer = x - f\n\n\n\nprint(answer)", "score": 0.0, "codebleu": 0.21099451880278453, "crystalbleu": 0.02007670916353753, "codebertscore": 0.69, "codescore": 0.9938581585884094, "surfaceSim": 0.4886450771446794, "abs_surfaceSim_minus_score": 0.4886450771446794}
{"golden_code": "import numpy as np\n\nx = int(eval(input()))\n\ntmp_list=[]\n\nc=0\n\ntmp_2=0\n\nwhile(1):\n\n    tmp_1=c**5\n\n    if (tmp_1 - tmp_2)<=x:\n\n        tmp_list+=[tmp_1]\n\n    else:\n\n        break\n\n    tmp_2=tmp_1\n\n    c+=1\n\n \n\ndef せいがわ(target:list,x) -> list:\n\n    for i in np.flipud(target):\n\n        for j in target:\n\n            tmp=i+j\n\n            if tmp==x:\n\n                return [int(i**(1/5)),int(j**(1/5))*-1]\n\n            if tmp>x:\n\n                break\n\n    return 0\n\n \n\ndef ふがわ(target:list,x) -> list:\n\n    for i in np.flipud(target):\n\n        for j in target:\n\n            tmp=i-j\n\n            if tmp==x:\n\n                return [int(i**(1/5)),int(j**(1/5))]\n\n            if tmp<x:\n\n                break\n\n    return 0\n\n  \n\nans=ふがわ(tmp_list,x)\n\nif ans==0:\n\n    ans=せいがわ(tmp_list,x)\n\nprint((ans[0],ans[1]))", "generated_code": "a, b = list(map(int, input().split()))\n\nprint(('Odd'if a&b&1 else 'Even'))", "score": 0.0, "codebleu": 0.029299540741672202, "crystalbleu": 0.0005134624677779309, "codebertscore": 0.6, "codescore": 0.9223107099533081, "surfaceSim": 0.3471277580866622, "abs_surfaceSim_minus_score": 0.3471277580866622}
{"golden_code": "n,m,k=list(map(int,input().split()))\n\nmod=10**9+7\n\nf=[1]\n\nfor i in range(2*10**5+7):f+=[f[-1]*(i+1)%mod]\n\ndef comb(a,b):return f[a]*pow(f[b],mod-2,mod)*pow(f[a-b],mod-2,mod)%mod\n\nans=0\n\nfor i in range(1,n):\n\n  ans+=(i*(n-i)*m**2)*(comb(n*m-2,k-2))\n\n  ans%=mod\n\nfor i in range(1,m):\n\n  ans+=(i*(m-i)*n**2)*(comb(n*m-2,k-2))\n\n  ans%=mod\n\nprint(ans)", "generated_code": "import math\n\nn,d=list(map(int,input().split()))\n\na=[0]*n\n\nfor i in range(n):\n\n  a[i]=list(map(int,input().split()))\n\nans=0\n\nfor i in range(n-1):\n\n  for j in range(i+1,n):\n\n    chklen=0\n\n    wk=0\n\n    for k in range(d):\n\n      wk+=abs(a[i][k]-a[j][k])**2\n\n    chklen=math.sqrt(wk)\n\n    if chklen==chklen//1:\n\n      ans+=1\n\nprint(ans)", "score": 0.0, "codebleu": 0.18612667336897376, "crystalbleu": 0.1359122016674037, "codebertscore": 0.8, "codescore": 0.8840060234069824, "surfaceSim": 0.4908915747066036, "abs_surfaceSim_minus_score": 0.4908915747066036}
{"golden_code": "N = int(eval(input()))\n\n\n\nans = 0\n\n\n\nfor i in range(1, N+1):\n\n    if len(str(i))%2==1:\n\n        ans += 1\n\n\n\nprint(ans)", "generated_code": "N=int(eval(input()));print((N if N%2==0 else N*2))", "score": 0.0, "codebleu": 0.15609684132133533, "crystalbleu": 0.0, "codebertscore": 0.81, "codescore": 0.3921394646167755, "surfaceSim": 0.6172316384180792, "abs_surfaceSim_minus_score": 0.6172316384180792}
{"golden_code": "import numpy as np\n\nn = int(eval(input()))\n\nvalue = np.array(tuple(map(int, input().split())))\n\ncost = np.array(tuple(map(int, input().split())))\n\nxy = value - cost\n\nans = 0\n\nfor i in range(n):\n\n    if xy[i] < 0:\n\n        continue\n\n    else:\n\n        ans += xy[i]\n\nprint(ans)", "generated_code": "N = int(eval(input()))\n\nAs = list(map(int, input().split()))\n\n\n\nans = [0] * N\n\n\n\nfor i, A in enumerate(As):\n\n  ans[A-1] = i+1\n\n  \n\nprint((*ans))", "score": 0.0, "codebleu": 0.2222925665305138, "crystalbleu": 0.10963218687450309, "codebertscore": 0.78, "codescore": 0.3220451772212982, "surfaceSim": 0.5375524475524476, "abs_surfaceSim_minus_score": 0.5375524475524476}
{"golden_code": "from functools import reduce\n\nfrom itertools import product\n\n\n\nN = int(eval(input()))\n\n*A, = list(map(int, input().split()))\n\nans = 0\n\nfor t in product([-1, 0, 1], repeat=N):\n\n    prod = reduce(lambda x, y: x*y, [a + t[i] for i, a in enumerate(A)])\n\n    if prod % 2 == 0: ans += 1\n\nprint(ans)", "generated_code": "def main():\n\n    n = int(eval(input()))\n\n    dp = [[0 for i in range(10)] for i in range(10)]\n\n    for i in range(1,n+1):\n\n        h,t = int(str(i)[0]), int(str(i)[-1])\n\n        dp[h][t] += 1\n\n    ans = 0\n\n    for i in range(10):\n\n        for j in range(10):\n\n            ans += dp[i][j] * dp[j][i]\n\n    print(ans)\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "score": 0.0, "codebleu": 0.2313047667806486, "crystalbleu": 0.16583795117978942, "codebertscore": 0.76, "codescore": 0.018271205946803093, "surfaceSim": 0.5756302521008403, "abs_surfaceSim_minus_score": 0.5756302521008403}
{"golden_code": "import collections\n\nn = int(eval(input()))\n\na=[eval(input()) for _ in range(n)]\n\nanslist=[]\n\nb=collections.Counter(a)\n\nc=max(list(b.values()))\n\nfor i in b:\n\n    if b[i]==c:\n\n        anslist.append(i)\n\nd=sorted(anslist)\n\nfor i in tuple(d):\n\n    print(i)", "generated_code": "from collections import Counter\n\n\n\n\n\ndef f(mod):\n\n    ret = [0]\n\n    power = 1\n\n    num = 0\n\n    for i, e in enumerate(s, 1):\n\n        num *= 10\n\n        num += int(e)\n\n        num %= mod\n\n\n\n        power *= 10\n\n        power %= mod\n\n        inv = pow(power, mod - 2, mod)\n\n\n\n        ret.append(num * inv % mod)\n\n\n\n    return ret\n\n\n\n\n\ns = eval(input())\n\n\n\nmod3 = f(3)\n\nmod673 = f(673)\n\n\n\nli = [10 * e673 + e3 for e3, e673 in zip(mod3, mod673)]\n\n\n\nc = Counter(li)\n\nans = 0\n\nfor v in list(c.values()):\n\n    ans += v * (v - 1) // 2\n\nprint(ans)\n", "score": 0.0, "codebleu": 0.2152358638308563, "crystalbleu": 0.044634559454810395, "codebertscore": 0.7, "codescore": 0.9936802387237549, "surfaceSim": 0.45482551952052874, "abs_surfaceSim_minus_score": 0.45482551952052874}
{"golden_code": "S = eval(input())\n\nK = int(eval(input()))\n\na = list(set(S))\n\na.sort()\n\n\n\nk = []\n\nl = 0\n\nwhile l < len(a):\n\n    for i in range(len(S)):\n\n        if S[i] == a[l]:\n\n            for j in range(1,6):\n\n                if i+j <= len(S):\n\n                    k.append(S[i:i+j])\n\n                else:\n\n                    break\n\n    l += 1\n\n\n\nk = list(set(k))\n\nk.sort()\n\nprint((k[K-1]))", "generated_code": "from collections import Counter\n\nn=int(eval(input()))\n\na=[]\n\nfor i in range(n):\n\n  a.append(eval(input()))\n\nac=Counter(a)\n\nacs=sorted(list(ac.items()),key=lambda x:x[1],reverse=1)\n\nz=len(acs)\n\ni=0\n\ntemp=[]\n\n\n\nwhile i<=z-1 and acs[i][1]==acs[0][1] :\n\n  temp.append(acs[i][0])\n\n  i+=1\n\ntemp.sort()\n\nfor i in temp:\n\n  print(i)", "score": 0.0, "codebleu": 0.2276636840729594, "crystalbleu": 0.14884112834305363, "codebertscore": 0.78, "codescore": 0.6310614943504333, "surfaceSim": 0.5456950456950457, "abs_surfaceSim_minus_score": 0.5456950456950457}
{"golden_code": "import numpy as np\n\n\n\nN, K = list(map(int, input().split()))\n\nS = eval(input())\n\n\n\nl = [[], []]\n\nans = []\n\nk = [int(s) for s in S]\n\nif k[0] == 0:\n\n    l[1].append(0)\n\nv0 = 1 if k[0] == 0 else 0\n\nv1 = 1 if k[0] == 1 else 0\n\nfor i in range(1, N):\n\n    if (k[i]==0) & (k[i-1]==0):\n\n        v0 += 1\n\n    elif (k[i]==1) & (k[i-1]==0):\n\n        l[0].append(v0)\n\n        v0 = 0\n\n        v1 += 1\n\n    elif (k[i]==0) & (k[i-1]==1):\n\n        l[1].append(v1)\n\n        v0 += 1\n\n        v1 = 0 \n\n    else:\n\n        v1 += 1\n\n        \n\nfor i, v in enumerate([v0, v1]):\n\n    if v > 0:\n\n        l[i].append(v)\n\n        \n\nif k[0] == 0:\n\n    l[1].append(0)\n\n\n\nif len(l[0]) <= K:\n\n    print(N)\n\n\n\nelse:\n\n    l[0].extend(np.repeat(0,K+1))\n\n    l[1].extend(np.repeat(0,K+1))\n\n    a = sum(l[0][:K]) + sum(l[1][:K+1])\n\n    ans.append(a)\n\n    for i in range(1, len(l[0])-K-1):\n\n        a -= l[0][i-1] + l[1][i-1]\n\n        a += l[0][i+K-1] + l[1][i+K]\n\n        ans.append(a)\n\n    print((max(ans)))", "generated_code": "from collections import Counter\n\ndef solve():\n\n  N = int(input())\n\n  S = [input() for _ in range(N)]\n\n  c = Counter(S)\n\n  M = max(c.values())\n\n  ans = []\n\n  for k,v in c.items():\n\n    if v==M:\n\n      ans.append(k)\n\n  ans.sort()\n\n  return ans\n\nprint(*solve(),sep='\\n')\n", "score": 0.0, "codebleu": 0.06454910619280785, "crystalbleu": 0.0054020666508429235, "codebertscore": 0.68, "codescore": 0.6970752477645874, "surfaceSim": 0.47090628218331615, "abs_surfaceSim_minus_score": 0.47090628218331615}
{"golden_code": "import sys\n\ninput = sys.stdin.readline\n\nfrom collections import *\n\n\n\nA, B, C, D = list(map(int, input().split()))\n\n\n\nwhile True:\n\n    C -= B\n\n    \n\n    if C<=0:\n\n        print('Yes')\n\n        exit()\n\n    \n\n    A -= D\n\n    \n\n    if A<=0:\n\n        print('No')\n\n        exit()", "generated_code": "\"\"\"Minimum cost Sort.\"\"\"\n\n\n\ndef min_cost_sort(A):\n\n    \"\"\"Sort list A in ascending order.\n\n \n\n    And return the switching cost in sorting.\n\n    \"\"\"\n\n    B = list(A)\n\n    B.sort()\n\n    cost = 0\n\n    min_w = B[0]\n\n    for i, b in enumerate(B):\n\n        tmp_cost = 0\n\n        bi = A.index(b)\n\n        cnt = 0\n\n        while bi != i:\n\n            cnt += 1\n\n            st = B[bi]\n\n            si = A.index(st)\n\n            tmp_cost += b + st\n\n            A[bi], A[si] = st, b\n\n            bi = si\n\n        if cnt:\n\n            dec = cnt * (b - min_w)\n\n            inc = 2 * (min_w + b)\n\n            if dec < inc:\n\n                cost += tmp_cost\n\n            else:\n\n                cost += tmp_cost - dec + inc\n\n    return cost\n\n\n\n\n\nn = eval(input())\n\n\n\nA = list(map(int, input().split()))\n\n\n\nans = min_cost_sort(A)\n\n\n\nprint(ans)", "score": 0.0, "codebleu": 0.2525783196806301, "crystalbleu": 0.0787595809064641, "codebertscore": 0.68, "codescore": 0.9936291575431824, "surfaceSim": 0.5019113000741117, "abs_surfaceSim_minus_score": 0.5019113000741117}
{"golden_code": "s = int(eval(input()))\n\nmod = 10**9 + 7\n\n\n\n# dp[i]: 最後に切った場所がi\n\ndp = [0]*(s + 1)\n\ndp[0] = 1\n\n\n\nfor i in range(3, s+1):\n\n    for j in range(0, (i-3)+1):\n\n        dp[i] += dp[j]\n\n        dp[i] %= mod\n\n\n\nprint((dp[s]))", "generated_code": "N,M,K = list(map(int,input().split()))\n\n\n\nfor i in range(N+1):\n\n    for j in range(M+1):\n\n        if i*(M-j) + j*(N-i) == K:\n\n            print('Yes')\n\n            exit()\n\nprint('No')", "score": 0.0, "codebleu": 0.12926444267371673, "crystalbleu": 0.0, "codebertscore": 0.75, "codescore": 0.904681921005249, "surfaceSim": 0.5522286821705427, "abs_surfaceSim_minus_score": 0.5522286821705427}
{"golden_code": "s=eval(input())\n\nt=eval(input())\n\nans=0\n\nif s[0]==t[0]:\n\n    ans+=1\n\nif s[1]==t[1]:\n\n    ans+=1\n\nif s[2]==t[2]:\n\n    ans+=1\n\nprint(ans)\n", "generated_code": "#!/usr/bin/env pypy3\n\n# N,M = map(int,sys.stdin.readline().split())\n\n# a = tuple(map(int,sys.stdin.readline().split())) # single line with multi param\n\n# a = tuple(int(sys.stdin.readline()) for _ in range(N)) # multi line with single param\n\n# a = tuple(tuple(map(int,sys.stdin.readline().rstrip().split())) for _ in range(N)) # multi line with multi param\n\n# s = sys.stdin.readline().rstrip()\n\n# N = int(sys.stdin.readline())\n\n# INF = float(\"inf\")\n\nimport math,sys\n\n\n\nn = int(sys.stdin.readline())\n\na = tuple(map(int,sys.stdin.readline().split()))\n\n#n = int(input())\n\n#a = list(map(int,input().split()))\n\ng = math.gcd(a[0],a[1])\n\nfor i in range(2,n):\n\n    g = math.gcd(g,a[i])\n\nM = max(a)\n\nacc = a[0]\n\nfor i in range(n):\n\n    acc = math.gcd(acc,a[i])\n\nif acc != 1:\n\n    print(\"not coprime\")\n\n    exit()\n\n\n\nLIMIT=max(a)\n\nminPrime = [0]*(LIMIT+1)\n\nminPrime[1] = 1\n\ndef make():\n\n    for i in range(2,LIMIT+1):\n\n        if minPrime[i] == 0:\n\n            minPrime[i] = i\n\n            #print(i)\n\n            for j in range(i+i,LIMIT+1,i):\n\n                #print(i,j)\n\n                if minPrime[j] == 0:\n\n                    minPrime[j] = i\n\nmake()\n\ndef factrial(N):\n\n     ret = []\n\n     while minPrime[N] != N:\n\n         ret.append(minPrime[N])\n\n         N = N//minPrime[N]\n\n     if N != 1:\n\n         ret.append(N)\n\n     return ret\n\n\n\njudge = set([])\n\n\n\nfor e in a:\n\n    asf = set(factrial(e))\n\n    if judge & asf != set():\n\n        print(\"setwise coprime\")\n\n        exit()\n\n    judge |= asf\n\n    #judge = judge | asf #too slow\n\nprint(\"pairwise coprime\")\n", "score": 0.0, "codebleu": 0.19087612811638083, "crystalbleu": 0.0, "codebertscore": 0.62, "codescore": 0.9763857126235962, "surfaceSim": 0.5502473395410709, "abs_surfaceSim_minus_score": 0.5502473395410709}
{"golden_code": "N = int(eval(input()))\n\ns_list = {}\n\nfor i in range(N):\n\n  S = eval(input())\n\n  if S in list(s_list.keys()):\n\n    s_list[S] += 1\n\n  else:\n\n    s_list[S] = 0\n\nmax = 0\n\nmaxs = []\n\nfor s,c in list(s_list.items()):\n\n  if c > max:\n\n    maxs = [s]\n\n    max = c\n\n  elif c == max:\n\n    maxs.append(s)\n\nmaxs.sort()\n\nfor m in maxs:\n\n  print(m)", "generated_code": "n=int(eval(input()))\n\na=list(map(int,input().split()))\n\na.sort(reverse=True)\n\n\n\nalice=0\n\nbob=0\n\n\n\nfor i in range(n):\n\n    if i%2==0:\n\n        alice+=a[i]\n\n    else:\n\n        bob+=a[i]\n\n        \n\nprint((alice-bob))", "score": 0.0, "codebleu": 0.1557162497937252, "crystalbleu": 0.07088385279838864, "codebertscore": 0.76, "codescore": 0.23928700387477875, "surfaceSim": 0.5731693231693231, "abs_surfaceSim_minus_score": 0.5731693231693231}
{"golden_code": "H,W = list(map(int,input().split()))\n\nN = int(eval(input()))\n\nA = list(map(int,input().split()))\n\nA.insert(0,0)\n\nC = [[0 for _ in range(W)] for _ in range(H)]\n\ncur = [0,0,\"R\"]\n\nfor k in range(1,N+1):\n\n#     ipdb.set_trace()\n\n    a = A[k]\n\n    cnt = 0\n\n    y,x,d = cur\n\n    for i in range(y,H):\n\n        y = i\n\n        if d==\"R\":\n\n            for j in range(x,W):\n\n                C[i][j]=str(k)\n\n                cnt += 1\n\n                if j+1<W:\n\n                    x = j+1\n\n                else:\n\n                    x = j\n\n                if cnt==a:break\n\n            if cnt==a:break\n\n            d=\"L\"\n\n        else:\n\n            for j in range(x,-1,-1):\n\n                C[i][j]=str(k)\n\n                cnt += 1\n\n                if j>=1:\n\n                    x = j-1\n\n                else:\n\n                    x = 0\n\n                if cnt==a:break\n\n            if cnt==a:break\n\n            d=\"R\"\n\n    if x==W-1:\n\n        if C[y][x]!=0:\n\n            y += 1\n\n            d=\"L\"\n\n    elif x==0:\n\n        if C[y][x]!=0:\n\n            y += 1\n\n            d=\"R\"\n\n    cur = [y,x,d]                \n\nfor i in range(H):\n\n    print((*C[i]))", "generated_code": "N, K = list(map(int, input().split()))\n\nplist = [((num*(num+1))//2)/num for num in list(map(int, input().split()))]\n\n# print(plist)\n\nans = 0\n\nfor i in range(K):\n\n    ans += plist[i]\n\n_ = ans\n\nfor i in range(N-K):\n\n    temp = _\n\n    temp -= plist[i]\n\n    temp += plist[i+K]\n\n    # print(i, i+K, ans, temp)\n\n    ans = max(ans, temp)\n\n    _ = temp\n\nprint(ans)", "score": 0.0, "codebleu": 0.12834239061609284, "crystalbleu": 0.04786538747331137, "codebertscore": 0.73, "codescore": 0.06138044595718384, "surfaceSim": 0.6045014791716639, "abs_surfaceSim_minus_score": 0.6045014791716639}
{"golden_code": "import fractions\n\nn=int(eval(input()))\n\nprint(((2*n)//fractions.gcd(2,n)))", "generated_code": "def solve(a, b, c):\n\n    if any(i % 2 == 1 for i in [a, b, c]):\n\n        return 0\n\n    if a == b == c:\n\n        return -1\n\n    a, b, c = (b + c) // 2, (c + a) // 2, (a + b) // 2\n\n    return solve(a, b, c) + 1\n\n\n\na, b, c = list(map(int, input().split()))\n\n\n\nprint((solve(a, b, c)))", "score": 0.0, "codebleu": 0.2425595238095238, "crystalbleu": 0.0, "codebertscore": 0.69, "codescore": 0.11488109081983566, "surfaceSim": 0.41465517241379307, "abs_surfaceSim_minus_score": 0.41465517241379307}
{"golden_code": "from math import gcd\n\n\n\nN = int(eval(input()))\n\nnum_lis = list(map(int, input().split()))\n\nc = True\n\n\n\ndef osa_k(max_num):\n\n  lis = [i for i in range(max_num+1)]\n\n  p = 2\n\n  while p**2 <= max_num:\n\n    if lis[p] == p:\n\n      for q in range(2*p, max_num+1, p):\n\n        if lis[q] == q:\n\n          lis[q] = p\n\n    p += 1\n\n  return lis\n\n\n\nhoge = 0\n\nfor i in num_lis:\n\n  hoge = gcd(hoge, i)\n\nif hoge > 1:\n\n  print(\"not coprime\")\n\n  exit()\n\n\n\nd_lis = osa_k(10**6+10)\n\ntmp = set()\n\nfor i in num_lis:\n\n  num = i\n\n  new_tmp = set()\n\n  while num > 1:\n\n    d = d_lis[num]\n\n    new_tmp.add(d)\n\n    num //= d\n\n  for j in new_tmp:\n\n    if j in tmp:\n\n      c = False\n\n      break\n\n    else:\n\n      tmp.add(j)\n\n  else:\n\n    continue\n\n  break\n\n\n\nif c:\n\n  print(\"pairwise coprime\")\n\nelse:\n\n  print(\"setwise coprime\")", "generated_code": "def factorial(N):\n\n    power_r = 1\n\n    for n in range(2,N+1):\n\n        power_r = power_r*n % (10**9+7)\n\n    return power_r\n\n\n\nif __name__ == '__main__':\n\n    N = int(eval(input()))\n\n    print((factorial(N)))", "score": 0.0, "codebleu": 0.09329707041452495, "crystalbleu": 0.013982633448069538, "codebertscore": 0.7, "codescore": 0.018279263749718666, "surfaceSim": 0.48178278403560004, "abs_surfaceSim_minus_score": 0.48178278403560004}
