{"golden_code": "import numpy as np\n\n\n\n(N,M) = list(map(int,input().split()))\n\nB = np.ones(M,dtype=np.int)\n\n\n\nfor _ in range(N):\n\n    A = np.array(list(map(int,input().split())))[1:]\n\n    for i in range(M):\n\n        if not i+1 in A:\n\n            B[i] = 0\n\nprint((B.sum()))", "generated_code": "(N,M) = list(map(int,input().split()))\n\nr = int(-1)\n\nfor i in range(N):\n\n  A = list(map(int,input().split()))\n\n  A.pop(0)\n\n  c = 0\n\n  for a in A:\n\n    c |= (1 << (a-1))\n\n  r &= c\n\n\n\nans = sum([(r>>n)&1 for n in range(M)])\n\nprint(ans)", "score": 1.0, "codebleu": 0.3069325759816259, "crystalbleu": 0.24786981281288478, "codebertscore": 0.83, "codescore": 0.882985532283783, "surfaceSim": 0.46951871657754013, "abs_surfaceSim_minus_score": 0.5304812834224599}
{"golden_code": "def main():\n\n    n = int(eval(input()))\n\n    import numpy as np\n\n    ans = np.zeros((10,10))\n\n    for i in range(1,n+1):\n\n        h,t = str(i)[0],str(i)[-1]\n\n        ans[int(h)-1][int(t)-1]+=1\n\n    s = 0\n\n    for i in range(10):\n\n        for j in range(10):\n\n            s += ans[i][j]*ans[j][i]\n\n\n\n    print((int(s)))\n\nif __name__ == \"__main__\":\n\n    main()", "generated_code": "def main():\n\n    n = int(eval(input()))\n\n    dp = [[0 for i in range(10)] for i in range(10)]\n\n    for i in range(1,n+1):\n\n        h,t = int(str(i)[0]), int(str(i)[-1])\n\n        dp[h][t] += 1\n\n    ans = 0\n\n    for i in range(10):\n\n        for j in range(10):\n\n            ans += dp[i][j] * dp[j][i]\n\n    print(ans)\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "score": 1.0, "codebleu": 0.47214019955543324, "crystalbleu": 0.6394523388944687, "codebertscore": 0.92, "codescore": 0.01858622394502163, "surfaceSim": 0.790406472741283, "abs_surfaceSim_minus_score": 0.20959352725871705}
{"golden_code": "N,M,K = list(map(int,input().split()))\n\n\n\nfor i in range(N+1):\n\n    for j in range(M+1):\n\n        t = i*M + j*N - i*j*2\n\n        if t==K:\n\n            print('Yes')\n\n            exit()\n\nprint('No')", "generated_code": "N,M,K = list(map(int,input().split()))\n\n\n\nfor i in range(N+1):\n\n    for j in range(M+1):\n\n        if i*(M-j) + j*(N-i) == K:\n\n            print('Yes')\n\n            exit()\n\nprint('No')", "score": 1.0, "codebleu": 0.6557212908234747, "crystalbleu": 0.7989770211677567, "codebertscore": 0.96, "codescore": 0.9445125460624695, "surfaceSim": 0.9642857142857143, "abs_surfaceSim_minus_score": 0.0357142857142857}
{"golden_code": "import itertools\n\nN = int(eval(input()))\n\nNketa = len(str(N))\n\n\n\nrange_count = [[0 for j in range(10)]for i in range(10)]\n\n\n\n\n\nfor p in range(1,N+1):\n\n    mae = int(str(p)[0])\n\n    ato = int(str(p)[-1])\n\n    range_count[mae][ato] += 1\n\n\n\n    \n\n\n\ncount = 0\n\nfor j in range(1,N+1):\n\n    a_mae = int(str(j)[0])\n\n    a_ato = int(str(j)[-1])\n\n    \n\n    b_mae = a_ato\n\n    b_ato = a_mae\n\n    \n\n    if b_mae == 0:\n\n        continue\n\n    else:\n\n        count += range_count[b_mae][b_ato]\n\nprint(count)\n\n  ", "generated_code": "n = int(eval(input()))\n\n\n\nall_count = 0\n\noptions = [str(i) for i in range(10)]\n\n\n\nmaeato = [[0 for i in range(10)] for j in range(10)]\n\n\n\nfor i in range(n+1):\n\n    checking = str(i)\n\n    maeato[int(checking[0])][int(checking[-1])]+=1\n\nall_count = 0\n\nfor i in range(1,10):\n\n    for j in range(1,10):\n\n        for k in range(1,10):\n\n            for p in range(1,10):\n\n                if i == p and j == k:\n\n                    all_count+=maeato[i][j]*maeato[k][p]\n\nprint(all_count)", "score": 1.0, "codebleu": 0.22346479555437554, "crystalbleu": 0.24263699459438778, "codebertscore": 0.83, "codescore": 0.8175602555274963, "surfaceSim": 0.6796333556896936, "abs_surfaceSim_minus_score": 0.32036664431030637}
{"golden_code": "s = eval(input())\n\nlen_s = len(s)\n\ncnt = [0, 0]\n\nfor i in range(1, len(s)):\n\n    memo_0 = s[i - 1]\n\n    memo_1 = s[len_s - i]\n\n    if s[i] != memo_0:\n\n        cnt[0] += 1\n\n    if s[len_s - i - 1] != memo_1:\n\n        cnt[1] += 1\n\nprint((min(cnt)))\n", "generated_code": "s = eval(input())\n\nlen_s = len(s)\n\ncnt = 0\n\nfor i in range(1, len(s)):\n\n    memo_0 = s[i - 1]\n\n    if s[i] != memo_0:\n\n        cnt += 1\n\nprint(cnt)\n", "score": 1.0, "codebleu": 0.4384389562316314, "crystalbleu": 0.42335612295794856, "codebertscore": 0.93, "codescore": 0.3048754036426544, "surfaceSim": 0.8400809716599189, "abs_surfaceSim_minus_score": 0.1599190283400811}
{"golden_code": "import numpy as np\n\nn, k = list(map(int, input().split()))\n\np = np.array(list(map(int, input().split())))\n\np += 1\n\nsum_E = np.cumsum(p)\n\nsum_e = np.append([0], sum_E)\n\nans = -1\n\nfor i in range(n-k+1):\n\n    ans = max(ans, sum_e[i+k] - sum_e[i])\n\nprint((ans/2))", "generated_code": "n, k = list(map(int, input().split()))\n\np = list(map(int, input().split()))\n\n\n\ndef calc(x):\n\n    return (x + 1) / 2\n\n\n\n\n\nw = 0\n\n\n\nfor i in range(k):\n\n    w += calc(p[i])\n\n\n\nans = w\n\nfor i in range(k, n):\n\n    w += calc(p[i]) - calc(p[i - k])\n\n    ans = max(ans, w)\n\nprint(ans)", "score": 1.0, "codebleu": 0.32069355178686754, "crystalbleu": 0.363704997316923, "codebertscore": 0.84, "codescore": 0.22146984934806824, "surfaceSim": 0.6141304347826086, "abs_surfaceSim_minus_score": 0.38586956521739135}
{"golden_code": "N = int(eval(input()))\n\na = list(map(int, input().split()))\n\nb = list(map(int, input().split()))\n\na.reverse()\n\nb.reverse()\n\nans = 0\n\ncapacity = 0\n\nfor i in range(N):\n\n    ans += min(b[i] + capacity, a[i])\n\n    capacity = max(b[i] - max(a[i] - capacity, 0), 0)\n\nans += min(a[-1], capacity)\n\nprint(ans)", "generated_code": "n = int(eval(input()))\n\na = list(map(int, input().split()))\n\nb = list(map(int, input().split()))\n\n\n\na = a[::-1]\n\nb = b[::-1]\n\nans = 0\n\nfor i, bi in enumerate(b):\n\n    ans += min(a[i], b[i])\n\n    remain = max(0, b[i] - a[i])\n\n    ans += min(a[i + 1], remain)\n\n    a[i + 1] = max(0, a[i + 1] - remain)\n\nprint(ans)", "score": 1.0, "codebleu": 0.4781144399353477, "crystalbleu": 0.4406183139467697, "codebertscore": 0.91, "codescore": 0.18327485024929047, "surfaceSim": 0.7892282958199357, "abs_surfaceSim_minus_score": 0.2107717041800643}
{"golden_code": "n, m = list(map(int, input().split()))\n\na = []\n\nfor i in range(m):\n\n  a.append(int(eval(input())))\n\nans = 0\n\nflag = 0\n\na = set(a)\n\n\n\n#フィボナッチ数列の初期値を調節\n\ndp = [0] * (n+1)\n\ndp[0] = 1\n\nif 1 in a:\n\n  dp[1] = 0\n\nelse:\n\n  dp[1] = 1\n\n  \n\nfor i in range(2, n+1):\n\n  if dp[i-2] == 0 and dp[i-1] == 0:\n\n    ans = 0\n\n    flag = 1\n\n    break\n\n  elif i in a:\n\n    continue\n\n  else:\n\n    dp[i] = dp[i-1] + dp[i-2]\n\nif flag == 0:\n\n  ans = dp[n]\n\nprint((ans%(10**9+7)))", "generated_code": "n, m = list(map(int, input().split()))\n\na = []\n\nfor i in range(m):\n\n  a.append(int(eval(input())))\n\nans = 0\n\nflag = 0\n\na = set(a)\n\n\n\n#フィボナッチ数列の初期値を調節\n\ndp = [0] * (n+1)\n\ndp[0] = 1\n\nif 1 in a:\n\n  dp[1] = 0\n\nelse:\n\n  dp[1] = 1\n\n  \n\nfor i in range(2, n+1):\n\n  if dp[i-2] == 0 and dp[i-1] == 0:\n\n    ans = 0\n\n    flag = 1\n\n    break\n\n  elif i in a:\n\n    continue\n\n  else:\n\n    dp[i] = dp[i-1] + dp[i-2]\n\n    dp[i] = dp[i] % (10**9+7)\n\nif flag == 0:\n\n  ans = dp[n]\n\nprint(ans)", "score": 1.0, "codebleu": 0.9438993725962391, "crystalbleu": 0.9463913320718315, "codebertscore": 1.0, "codescore": 0.9937549829483032, "surfaceSim": 0.9638297872340426, "abs_surfaceSim_minus_score": 0.036170212765957444}
{"golden_code": "X,Y,Z,K = list(map(int,input().split()))\n\nA = list(map(int,input().split()))\n\nB = list(map(int,input().split()))\n\nC = list(map(int,input().split()))\n\nasort,bsort,csort = sorted(A,reverse=True),sorted(B,reverse=True),sorted(C,reverse=True)\n\nprint((asort[0] + bsort[0] + csort[0]))\n\nalready = [[0,0,0]]\n\nx,y,z = 0,0,0\n\nplace_sum = []\n\ncheck = []\n\nfor k in range(K - 1):\n\n    if [x + 1,y,z] not in already and x + 1 < X:\n\n        already.append([x + 1,y,z])\n\n        place_sum.append([x + 1,y,z])\n\n        check.append(asort[x + 1] + bsort[y] + csort[z])\n\n    if [x,y + 1,z] not in already and y + 1 < Y:\n\n        already.append([x,y + 1,z])\n\n        place_sum.append([x,y + 1,z])\n\n        check.append(asort[x] + bsort[y + 1] + csort[z])\n\n    if [x,y,z + 1] not in already and z + 1 < Z:\n\n        already.append([x,y,z + 1])\n\n        place_sum.append([x,y,z + 1])\n\n        check.append(asort[x] + bsort[y] + csort[z + 1])\n\n    print((max(check)))\n\n    x,y,z = place_sum[check.index(max(check))][0],place_sum[check.index(max(check))][1],place_sum[check.index(max(check))][2]\n\n    place_sum.pop(check.index(max(check)))\n\n    check.remove(max(check))", "generated_code": "import heapq\n\nX,Y,Z,K = list(map(int,input().split()))\n\nA = list(map(int,input().split()))\n\nB = list(map(int,input().split()))\n\nC = list(map(int,input().split()))\n\nasort,bsort,csort = sorted(A,reverse=True),sorted(B,reverse=True),sorted(C,reverse=True)\n\nalready = [[0,0,0]]\n\nprint((asort[0] + bsort[0] + csort[0]))\n\nx,y,z = 0,0,0\n\ncheck = []\n\nfor k in range(K - 1):\n\n    if [x + 1,y,z] not in already and x + 1 < X:\n\n        already.append([x + 1,y,z])\n\n        heapq.heappush(check,(-(asort[x + 1] + bsort[y] + csort[z]),x + 1,y,z))\n\n    if [x,y + 1,z] not in already and y + 1 < Y:\n\n        already.append([x,y + 1,z])\n\n        heapq.heappush(check,(-(asort[x] + bsort[y + 1] + csort[z]),x,y + 1,z))\n\n    if [x,y,z + 1] not in already and z + 1 < Z:\n\n        already.append([x,y,z + 1])\n\n        heapq.heappush(check,(-(asort[x] + bsort[y] + csort[z + 1]),x,y,z + 1))\n\n    maxsum = heapq.heappop(check)\n\n    print((-maxsum[0]))\n\n    x,y,z = maxsum[1],maxsum[2],maxsum[3]", "score": 1.0, "codebleu": 0.6987359410409137, "crystalbleu": 0.6907988549357674, "codebertscore": 0.93, "codescore": 0.9030584096908569, "surfaceSim": 0.782719900187149, "abs_surfaceSim_minus_score": 0.217280099812851}
{"golden_code": "inf = (5000 * 10 ** 5) * 3\n\n\n\na, b, c, x, y = list(map(int, input().split()))\n\n\n\nret = inf\n\nfor cnt_ab in range(max(x, y) * 2 + 1):\n\n    d = cnt_ab // 2\n\n\n\n    cnt_a = max(0, x - d)\n\n    cnt_b = max(0, y - d)\n\n\n\n    t = cnt_ab * c + cnt_a * a + cnt_b * b\n\n    ret = min(ret, t)\n\nprint(ret)\n", "generated_code": "def main():\n\n    A, B, AB, X, Y = list(map(int, input().split()))\n\n    M = max(X, Y)\n\n\n\n    k = 0\n\n    ans = A * X + B * Y\n\n    while True:\n\n        ans = min(\n\n            ans,\n\n            AB * k * 2 + max(0, X - k) * A + max(0, Y - k) * B\n\n        )\n\n\n\n        if k >= M: break\n\n        k += 1\n\n\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 1.0, "codebleu": 0.22553413540275377, "crystalbleu": 0.13599966483111123, "codebertscore": 0.8, "codescore": 0.0194680318236351, "surfaceSim": 0.5728519391472038, "abs_surfaceSim_minus_score": 0.4271480608527962}
{"golden_code": "import numpy as np\n\nNM = list(map(int,input().split()))\n\nN = NM[0]\n\nM = NM[1]\n\nA = list(map(int,input().split()))\n\nlistBC =[]\n\nwhile True:\n\n    try:\n\n        listBC.append(list(map(int,input().split())))\n\n    except:\n\n        break;\n\nBC = np.array(listBC)\n\nBCnum = np.argsort(BC[:,1])[::-1]\n\nBC = BC[BCnum,:]\n\n\n\nA.sort()\n\nj=0\n\nfor i in range(len(A)):\n\n    times = BC[j,0]\n\n    if BC[j,0]==0:\n\n        j+=1\n\n        if j == BC.shape[0]:\n\n            break\n\n        times = BC[j,0]\n\n    if A[i]<BC[j,1]:\n\n        A[i]=BC[j,1]\n\n        BC[j,0] += -1\n\noutput = sum(A)\n\nprint(output)", "generated_code": "N,M = list(map(int,input().split()))\n\nA = list(map(int,input().split()))\n\n\n\nfrom collections import Counter\n\nD = dict(Counter(A))\n\n\n\nfor i in range(M):\n\n    B,C = list(map(int,input().split()))\n\n    D[C]=D.get(C,0)+B\n\n\n\nK = sorted(list(D.keys()),reverse=True)\n\n\n\nout = 0\n\ncnt = 0\n\nnow = 0\n\nwhile cnt<=N-1:\n\n    if D[K[now]]>0:\n\n        out += K[now]\n\n        D[K[now]] += -1\n\n        cnt+=1\n\n    else:\n\n        now+=1\n\nprint(out)", "score": 1.0, "codebleu": 0.20308387242458062, "crystalbleu": 0.14366715087677473, "codebertscore": 0.79, "codescore": 0.9592455625534058, "surfaceSim": 0.5408016147635525, "abs_surfaceSim_minus_score": 0.4591983852364475}
{"golden_code": "a, b, c, x, y = list(map(int, input().split()))\n\n# print(a, b, c, x, y)\n\n\n\nans = 10000 * (10 **5) + 7\n\nc_max = 0\n\nif x > y:\n\n  c_max = x * 2\n\nelse:\n\n  c_max = y * 2\n\n\n\nfor cc in range(c_max+1):\n\n  ac = x - (cc // 2)\n\n  bc = y - (cc // 2)\n\n  \n\n  if ac < 0:\n\n    ac = 0\n\n  if bc < 0:\n\n    bc = 0\n\n  price = ac * a + bc * b + cc * c\n\n  # print('price: {}, ac: {}, bc: {}, cc: {}'.format(price, ac, bc, cc))\n\n  ans = min(ans, price)\n\n\n\nprint(ans)", "generated_code": "a, b, c, x, y = list(map(int, input().split()))\n\n# print(a, b, c, x, y)\n\n\n\nans = 10000 * (10 **5) + 7\n\nc_max = 0\n\nif x > y:\n\n  c_max = x * 2\n\nelse:\n\n  c_max = y * 2\n\n\n\nfor cc in range(0, c_max+1, 2):\n\n  ac = x - (cc // 2)\n\n  bc = y - (cc // 2)\n\n  \n\n  if ac < 0:\n\n    ac = 0\n\n  if bc < 0:\n\n    bc = 0\n\n  price = ac * a + bc * b + cc * c\n\n  # print('price: {}, ac: {}, bc: {}, cc: {}'.format(price, ac, bc, cc))\n\n  ans = min(ans, price)\n\n\n\nprint(ans)\n\n  ", "score": 1.0, "codebleu": 0.9641779493801012, "crystalbleu": 0.9488826794224877, "codebertscore": 0.99, "codescore": 0.9938517808914185, "surfaceSim": 0.995575221238938, "abs_surfaceSim_minus_score": 0.004424778761061954}
{"golden_code": "import math\n\nimport string\n\n\n\n\n\ndef readints():\n\n    return list(map(int, input().split()))\n\n\n\n\n\ndef nCr(n, r):\n\n    return math.factorial(n)//(math.factorial(n-r)*math.factorial(r))\n\n\n\n\n\ndef has_duplicates2(seq):\n\n    seen = []\n\n    for item in seq:\n\n        if not(item in seen):\n\n            seen.append(item)\n\n    return len(seq) != len(seen)\n\n\n\n\n\ndef divisor(n):\n\n    divisor = []\n\n    for i in range(1, n+1):\n\n        if n % i == 0:\n\n            divisor.append(i)\n\n    return divisor\n\n\n\n\n\n# coordinates\n\ndx = [-1, -1, -1, 0, 0, 1, 1, 1]\n\ndy = [-1, 0, 1, -1, 1, -1, 0, 1]\n\n\n\nn = int(eval(input()))\n\na = readints()\n\n\n\n\n\ndef func(l):\n\n    if len(l) == n:\n\n        for i in range(len(l)):\n\n            if l[i] % 2 == 0:\n\n                return 1\n\n\n\n        return 0\n\n    return func(l+[(a[len(l)])])+func(l+[(a[len(l)]-1)])+func(l+[(a[len(l)]+1)])\n\n\n\n\n\nprint((func([])))\n", "generated_code": "import math\n\nimport string\n\n\n\n\n\ndef readints():\n\n    return list(map(int, input().split()))\n\n\n\n\n\ndef nCr(n, r):\n\n    return math.factorial(n)//(math.factorial(n-r)*math.factorial(r))\n\n\n\n\n\ndef has_duplicates2(seq):\n\n    seen = []\n\n    for item in seq:\n\n        if not(item in seen):\n\n            seen.append(item)\n\n    return len(seq) != len(seen)\n\n\n\n\n\ndef divisor(n):\n\n    divisor = []\n\n    for i in range(1, n+1):\n\n        if n % i == 0:\n\n            divisor.append(i)\n\n    return divisor\n\n\n\n\n\n# coordinates\n\ndx = [-1, -1, -1, 0, 0, 1, 1, 1]\n\ndy = [-1, 0, 1, -1, 1, -1, 0, 1]\n\n\n\nn = int(eval(input()))\n\na = readints()\n\nsum = 1\n\nfor i in range(len(a)):\n\n    if a[i] % 2 == 0:\n\n        sum *= 2\n\n    else:\n\n        sum *= 1\n\nprint((3**len(a)-sum))\n", "score": 1.0, "codebleu": 0.7927987296332026, "crystalbleu": 0.6700281462116706, "codebertscore": 0.96, "codescore": 0.30349206924438477, "surfaceSim": 0.9049909998363607, "abs_surfaceSim_minus_score": 0.09500900016363933}
{"golden_code": "a,b,c,x,y = list(map(int,input().split()))\n\nans = a*x + b*y\n\nfor i in range(max(x,y) + 1):\n\n\tmoney = max(0,(x-i)*a) + max(0,(y-i)*b) + 2*i*c\n\n\tif money <= ans:\n\n\t\tans = money\n\nprint(ans)", "generated_code": "a,b,c,x,y = list(map(int,input().split()))\n\nif a + b >= 2*c:\n\n\tif x >= y:\n\n\t\tans = 2*y*c + (x-y)*min(a,2*c)\n\n\telse:\n\n\t\tans = 2*x*c + (y-x)*min(b,2*c)\n\nelse:\n\n\tans = (x*a + y*b)\n\nprint(ans)", "score": 1.0, "codebleu": 0.29176496734976, "crystalbleu": 0.0, "codebertscore": 0.87, "codescore": 0.07898103445768356, "surfaceSim": 0.6976483762597985, "abs_surfaceSim_minus_score": 0.3023516237402015}
{"golden_code": "N = int(eval(input()))\n\nx = list(map(int, input().split()))\n\ncnt = 0\n\nfor i in x:\n\n  while i % 2 == 0:\n\n    cnt += 1\n\n    i /= 2\n\nprint(cnt)", "generated_code": "n = int(eval(input()))\n\nans = 0\n\nfor i in map(int, input().split()):\n\n    cnt = 0\n\n    while i % 2 == 0:\n\n        i >>= 1\n\n        cnt += 1\n\n    ans += cnt\n\nprint(ans)", "score": 1.0, "codebleu": 0.5065154785810035, "crystalbleu": 0.0, "codebertscore": 0.92, "codescore": 0.8493216633796692, "surfaceSim": 0.8365899779388591, "abs_surfaceSim_minus_score": 0.16341002206114086}
{"golden_code": "def factorial(N):\n\n    power_r = 1\n\n    for n in range(2,N+1):\n\n        power_r *= n\n\n        power_r %= 10**9+7\n\n    return power_r\n\n\n\nif __name__ == '__main__':\n\n    N = int(eval(input()))\n\n    print((factorial(N)))", "generated_code": "def factorial(N):\n\n    power_r = 1\n\n    for n in range(2,N+1):\n\n        power_r = power_r*n % (10**9+7)\n\n    return power_r\n\n\n\nif __name__ == '__main__':\n\n    N = int(eval(input()))\n\n    print((factorial(N)))", "score": 1.0, "codebleu": 0.7788566774382812, "crystalbleu": 0.0, "codebertscore": 0.98, "codescore": 0.9938197731971741, "surfaceSim": 0.9611436950146628, "abs_surfaceSim_minus_score": 0.03885630498533721}
{"golden_code": "import sys\n\ninput = sys.stdin.readline\n\n\n\nN,L,T = list(map(int,input().split()))\n\nXW = [[int(x) for x in input().split()] for _ in range(N)]\n\n\n\nX,W = list(zip(*XW))\n\n\n\nDX = [1 if w == 1 else -1 for w in W]\n\n\n\nY = [(x+dx*T)%L for x,dx in zip(X,DX)]\n\ny0 = Y[0]\n\nY.sort()\n\n\n\n# 番号1がすれ違わず進んだ場所に相当するアリの番号\n\n# すれ違うたびに1増える（W1=1） or 1減る（W1=-1）\n\n# T秒ちょうどもすれ違い終わったと考える\n\n\n\nx = 0\n\nx0,dx0 = X[0],DX[0]\n\nfor y,dy in zip(X[1:],DX[1:]):\n\n    if dx0 == dy:\n\n        continue\n\n    if dx0 == 1 and dy == -1:\n\n        # 正の向きに追い越すので番号がひとつ増える\n\n        x += (2*T-(y-x0)-1)//L + 1\n\n    if dx0 == -1 and dy == 1:\n\n        x -= (2*T-(L+x0-y))//L + 1\n\nx %= N\n\n\n\ni = Y.index(y0)\n\n\n\nY += Y\n\n\n\nanswer = [None] * N\n\nanswer[x:N] = Y[i:i+N-x]\n\nanswer[0:x] = Y[i+N-x:i+N]\n\n\n\nprint(('\\n'.join(map(str,answer))))\n\n\n", "generated_code": "import sys\n\nimport numpy as np\n\n\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\n\"\"\"\n\n・順序が固定されるので、区間だったら簡単\n\n・円のときも、地点 0 をそれぞれの方向に通った人数を見れば計算できる\n\n\"\"\"\n\n\n\nN, L, T = list(map(int, readline().split()))\n\nXW = np.array(read().split(), np.int64)\n\nX = XW[::2]\n\nW = XW[1::2]\n\n\n\nspeed = np.where(W == 1, 1, -1)\n\n\n\nY = X + speed * T\n\n\n\nn = (Y // L - X // L).sum()\n\nn %= N\n\n\n\nY %= L\n\nY.sort()\n\nY = np.concatenate((Y[n:], Y[:n]))\n\n\n\nprint(('\\n'.join(map(str, Y.tolist()))))", "score": 1.0, "codebleu": 0.12710036014394357, "crystalbleu": 0.1384313089053213, "codebertscore": 0.75, "codescore": 0.14419804513454437, "surfaceSim": 0.5943264693264694, "abs_surfaceSim_minus_score": 0.4056735306735306}
{"golden_code": "def cmb(n, r, mod):\n\n    if ( r<0 or r>n ):\n\n        return 0\n\n    r = min(r, n-r)\n\n    return g1[n] * g2[r] * g2[n-r] % mod\n\n\n\nA=2*10**5\n\nmod = 10**9+7\n\ng1 = [1, 1]\n\ng2 = [1, 1]\n\ninverse = [0, 1]\n\n\n\nfor i in range( 2, A + 1 ):\n\n    g1.append( ( g1[-1] * i ) % mod )\n\n    inverse.append( ( -inverse[mod % i] * (mod//i) ) % mod )\n\n    g2.append( (g2[-1] * inverse[-1]) % mod )\n\n\n\nN,M,K=list(map(int,input().split()))\n\nkeisuu=cmb(N*M-2,K-2,mod)\n\n\n\nsum_=0\n\nfor i in range(N):\n\n    a=min(abs(i),abs(N-i-1))\n\n    b=max(abs(i),abs(N-i-1))\n\n    sum_+=(M**2)*((a*(a+1)//2)+(b*(b+1)//2))\n\nfor i in range(M):\n\n    a=min(abs(i),abs(M-i-1))\n\n    b=max(abs(i),abs(M-i-1))\n\n    sum_+=(N**2)*((a*(a+1)//2)+(b*(b+1)//2))\n\nprint(((keisuu * (sum_//2))%mod))", "generated_code": "def power_mod(a,b,mod=10**9+7):\n\n    i,temp,box=0,b,[]\n\n    while(2**i<=b):\n\n        i+=1\n\n    for j in range(i-1,-1,-1):\n\n        box=[[j,temp//2**j]]+box\n\n        temp-=2**j*(temp//2**j)\n\n    box[0].append(a)\n\n    ans=box[0][1]*a%mod\n\n    for j in range(1,i):\n\n        box[j].append(box[j-1][2]**2%mod)\n\n        if box[j][1]==1:\n\n            ans=(ans*box[j][2])%mod\n\n    return ans\n\ndef n_func(n,mod=10**9+7):\n\n    ans=1\n\n    for i in range(1,n+1):\n\n        ans=(ans*i)%mod\n\n    return ans\n\ndef nPr(n,r,mod=10**9+7):\n\n    ans=n_func(n-r,mod)\n\n    ans=power_mod(ans,mod-2,mod)\n\n    return ans*n_func(n,mod)%mod\n\ndef nCr(n,r,mod=10**9+7):\n\n    ans=n_func(n-r,mod)*n_func(r,mod)%mod\n\n    ans=power_mod(ans,mod-2,mod)\n\n    return ans*n_func(n,mod)%mod\n\n\n\nN,M,K=list(map(int,input().split()))\n\nkeisuu=nCr(N*M-2,K-2)\n\nmod=10**9+7\n\n\n\nsum_=0\n\nfor i in range(N):\n\n    a=min(abs(i),abs(N-i-1))\n\n    b=max(abs(i),abs(N-i-1))\n\n    sum_+=(M**2)*((a*(a+1)//2)+(b*(b+1)//2))\n\nfor i in range(M):\n\n    a=min(abs(i),abs(M-i-1))\n\n    b=max(abs(i),abs(M-i-1))\n\n    sum_+=(N**2)*((a*(a+1)//2)+(b*(b+1)//2))\n\nprint(((keisuu * (sum_//2))%mod))", "score": 1.0, "codebleu": 0.364039408405734, "crystalbleu": 0.44722381874074135, "codebertscore": 0.87, "codescore": 0.6767527461051941, "surfaceSim": 0.697294888471359, "abs_surfaceSim_minus_score": 0.302705111528641}
{"golden_code": "import itertools\n\nimport fractions\n\ndef main():\n\n  s = eval(input())\n\n  t = eval(input())\n\n  cnt = 0\n\n  for i in range(3):\n\n    if s[i] == t[i]:\n\n      cnt += 1\n\n  print(cnt)\n\nif __name__ == '__main__':\n\n  main()", "generated_code": "s = eval(input())\n\nt = eval(input())\n\nans = 0\n\nfor i in range(3):\n\n    if s[i] == t[i]:\n\n        ans += 1\n\nprint(ans)\n", "score": 1.0, "codebleu": 0.47080990306710424, "crystalbleu": 0.0, "codebertscore": 0.88, "codescore": 0.050402700901031494, "surfaceSim": 0.713679245283019, "abs_surfaceSim_minus_score": 0.28632075471698104}
{"golden_code": "import numpy as np\n\n\n\nN = int(eval(input()))\n\nX = np.array(list(map(int, input().split())))\n\ncost = float(\"inf\")\n\nfor i in range(max(X) - min(X) + 1):\n\n    p = min(X) + i\n\n    cost = min(np.sum((X - p) ** 2), cost)\n\nprint(cost)", "generated_code": "N = int(eval(input()))\n\nX = sorted(list(map(int, input().split())))\n\nif N == 1:\n\n    print((0))\n\nelse:\n\n    r = X[-1] - X[0]\n\n    ans = float(\"inf\")\n\n    for i in range(r + 1):\n\n        R = X[0] + i\n\n        hp = 0\n\n        for j in range(N):\n\n            hp = hp + (R - X[j]) ** 2\n\n\n\n        ans = min(hp, ans)\n\n\n\n    print(ans)\n", "score": 1.0, "codebleu": 0.32616412606638817, "crystalbleu": 0.3107739498454203, "codebertscore": 0.83, "codescore": 0.06748306006193161, "surfaceSim": 0.6164690382081687, "abs_surfaceSim_minus_score": 0.3835309617918313}
{"golden_code": "a=65280; b=61680; c=52428; d=43690; e=65535\n\nL = {el: 1 for el in [a, b, c, d, e, 0]}\n\nfor i in range(6):\n\n    R = sorted(L.items(), key=lambda x: x[1])\n\n    for p, l in R:\n\n        if l < 16:\n\n            L[p ^ e] = min(L.get(p ^ e, 16), l+1)\n\n            if l+3 < 16:\n\n                for q, r in R:\n\n                    if l+r+3 <= 16:\n\n                        L[p & q] = min(L.get(p & q, 16), l+r+3)\n\n                        L[p ^ q] = min(L.get(p ^ q, 16), l+r+3)\n\n                    else: break\n\n        else: break\n\nprint(*(L[e & eval(s)] for s in open(0).read().replace(*\"-~\").replace(*\"*&\").replace(*\"1e\").split()[:-1]),sep='\\n')\n", "generated_code": "a=65280; b=61680; c=52428; d=43690; e=65535\n\nfrom heapq import heappush, heappop\n\nbase = [a, b, c, d, e, 0]\n\nQ = [(1, el) for el in base]\n\nL = {el: 1 for el in base}\n\nH = []\n\nwhile Q:\n\n    l, p = heappop(Q)\n\n    if L[p] < l: continue\n\n    if l+1 < L.get(p ^ e, 17):\n\n        L[p^e] = l+1\n\n        if l+1 < 16: heappush(Q, (l+1, p^e))\n\n    if l+3 < 16:\n\n        for q, r in H:\n\n            if l+r+3 <= 16:\n\n                if l+r+3 < L.get(p & q, 17):\n\n                    L[p & q] = l+r+3\n\n                    if l+r+3 < 16: heappush(Q, (l+r+3, p & q))\n\n                if l+r+3 < L.get(p ^ q, 17):\n\n                    L[p ^ q] = l+r+3\n\n                    if l+r+3 < 16: heappush(Q, (l+r+3, p ^ q))\n\n            else: break\n\n    if l < 7: H.append((p, l))\n\nprint(*(L[e & eval(s)] for s in open(0).read().replace(*\"-~\").replace(*\"*&\").replace(*\"1e\").split()[:-1]),sep='\\n')\n", "score": 1.0, "codebleu": 0.46663403600021647, "crystalbleu": 0.5057961044546256, "codebertscore": 0.89, "codescore": 0.9847866892814636, "surfaceSim": 0.7448644688644688, "abs_surfaceSim_minus_score": 0.2551355311355312}
{"golden_code": "#!/usr/bin/env pypy3\n\n# N,M = map(int,sys.stdin.readline().split())\n\n# a = tuple(map(int,sys.stdin.readline().split())) # single line with multi param\n\n# a = tuple(int(sys.stdin.readline()) for _ in range(N)) # multi line with single param\n\n# a = tuple(tuple(map(int,sys.stdin.readline().rstrip().split())) for _ in range(N)) # multi line with multi param\n\n# s = sys.stdin.readline().rstrip()\n\n# N = int(sys.stdin.readline())\n\n# INF = float(\"inf\")\n\nimport math,sys\n\n\n\nn = int(sys.stdin.readline())\n\na = tuple(map(int,sys.stdin.readline().split()))\n\n#n = int(input())\n\n#a = list(map(int,input().split()))\n\ng = math.gcd(a[0],a[1])\n\nfor i in range(2,n):\n\n    g = math.gcd(g,a[i])\n\nM = max(a)\n\nacc = a[0]\n\nfor i in range(n):\n\n    acc = math.gcd(acc,a[i])\n\nif acc != 1:\n\n    print(\"not coprime\")\n\n    exit()\n\n\n\nLIMIT=max(a)\n\nminPrime = [0]*(LIMIT+1)\n\nminPrime[1] = 1\n\ndef make():\n\n    for i in range(2,LIMIT+1):\n\n        if minPrime[i] == 0:\n\n            minPrime[i] = i\n\n            #print(i)\n\n            for j in range(i+i,LIMIT+1,i):\n\n                #print(i,j)\n\n                if minPrime[j] == 0:\n\n                    minPrime[j] = i\n\nmake()\n\ndef factrial(N):\n\n     ret = []\n\n     while minPrime[N] != N:\n\n         ret.append(minPrime[N])\n\n         N = N//minPrime[N]\n\n     if N != 1:\n\n         ret.append(N)\n\n     return ret\n\n\n\njudge = set([])\n\npc = True\n\n\n\npairwise = True\n\np = set() #all prime\n\n\n\nfor e in a:\n\n    if not pairwise:\n\n        break\n\n    asf = set(factrial(e))\n\n    if judge & asf != set():\n\n        pc = False\n\n    #     #pairwise = False\n\n    #     print(\"setwise coprime\")\n\n    #     exit(0)\n\n    judge |= asf\n\n# for i in a:\n\n#     if not pc:\n\n#         break\n\n#     asf = set(factrial(i))\n\n\n\n#     if judge & asf != set():\n\n#         pc = False\n\n#     judge |= asf\n\nif pc:\n\n    print(\"pairwise coprime\")\n\nelif g == 1:\n\n    print(\"setwise coprime\")\n\nelse:\n\n    print(\"not coprime\")\n", "generated_code": "#!/usr/bin/env pypy3\n\n# N,M = map(int,sys.stdin.readline().split())\n\n# a = tuple(map(int,sys.stdin.readline().split())) # single line with multi param\n\n# a = tuple(int(sys.stdin.readline()) for _ in range(N)) # multi line with single param\n\n# a = tuple(tuple(map(int,sys.stdin.readline().rstrip().split())) for _ in range(N)) # multi line with multi param\n\n# s = sys.stdin.readline().rstrip()\n\n# N = int(sys.stdin.readline())\n\n# INF = float(\"inf\")\n\nimport math,sys\n\n\n\nn = int(sys.stdin.readline())\n\na = tuple(map(int,sys.stdin.readline().split()))\n\n#n = int(input())\n\n#a = list(map(int,input().split()))\n\ng = math.gcd(a[0],a[1])\n\nfor i in range(2,n):\n\n    g = math.gcd(g,a[i])\n\nM = max(a)\n\nacc = a[0]\n\nfor i in range(n):\n\n    acc = math.gcd(acc,a[i])\n\nif acc != 1:\n\n    print(\"not coprime\")\n\n    exit()\n\n\n\nLIMIT=max(a)\n\nminPrime = [0]*(LIMIT+1)\n\nminPrime[1] = 1\n\ndef make():\n\n    for i in range(2,LIMIT+1):\n\n        if minPrime[i] == 0:\n\n            minPrime[i] = i\n\n            #print(i)\n\n            for j in range(i+i,LIMIT+1,i):\n\n                #print(i,j)\n\n                if minPrime[j] == 0:\n\n                    minPrime[j] = i\n\nmake()\n\ndef factrial(N):\n\n     ret = []\n\n     while minPrime[N] != N:\n\n         ret.append(minPrime[N])\n\n         N = N//minPrime[N]\n\n     if N != 1:\n\n         ret.append(N)\n\n     return ret\n\n\n\njudge = set([])\n\n\n\nfor e in a:\n\n    asf = set(factrial(e))\n\n    if judge & asf != set():\n\n        print(\"setwise coprime\")\n\n        exit()\n\n    judge |= asf\n\n    #judge = judge | asf #too slow\n\nprint(\"pairwise coprime\")\n", "score": 1.0, "codebleu": 0.7327232156462803, "crystalbleu": 0.8710016221649566, "codebertscore": 0.97, "codescore": 0.9937738180160522, "surfaceSim": 0.9238445378151261, "abs_surfaceSim_minus_score": 0.0761554621848739}
{"golden_code": "import numpy as np\n\n\n\nn=int(eval(input()))\n\na_list=list(map(int,input().split()))\n\na_list_2=sorted(a_list,reverse=True)\n\na=np.array(a_list_2,dtype='uint8')\n\n\n\nalice=0\n\nbob=0\n\nfor i in range(n):\n\n\tif i%2==0:\n\n\t\talice+=a[i]\n\n\telse:\n\n\t\tbob+=a[i]\n\n\n\nprint((alice-bob))\n", "generated_code": "n=int(eval(input()))\n\na=list(map(int,input().split()))\n\na.sort(reverse=True)\n\n\n\nalice=0\n\nbob=0\n\n\n\nfor i in range(n):\n\n    if i%2==0:\n\n        alice+=a[i]\n\n    else:\n\n        bob+=a[i]\n\n        \n\nprint((alice-bob))", "score": 1.0, "codebleu": 0.5282923517427665, "crystalbleu": 0.6814678389353974, "codebertscore": 0.92, "codescore": 0.6403024196624756, "surfaceSim": 0.818785890073831, "abs_surfaceSim_minus_score": 0.18121410992616904}
{"golden_code": "from collections import defaultdict\n\n\n\nN, K, *A = list(map(int, open(0).read().split()))\n\n\n\nS = [0] * (N + 1)\n\nfor i in range(N):\n\n    S[i + 1] = S[i] + A[i]\n\n\n\nd = defaultdict(int)\n\nans = 0\n\nfor j in range(N + 1):\n\n    v = (S[j] - j) % K\n\n    ans += d[v]\n\n    d[v] += 1\n\n    if j >= K - 1:\n\n        d[(S[j - K + 1] - (j - K + 1)) % K] -= 1\n\n        \n\nprint(ans)\n", "generated_code": "from collections import defaultdict\n\n\n\nN, K, *A = list(map(int, open(0).read().split()))\n\n\n\nx = [0] * (N + 1)\n\nfor i in range(N):\n\n    x[i + 1] = x[i] + A[i]\n\n    \n\ny = [(x[i] - i) % K for i in range(N + 1)]\n\n\n\nctr = defaultdict(int)\n\nans = 0\n\nfor j in range(N + 1):\n\n    ans += ctr[y[j]]\n\n    ctr[y[j]] += 1\n\n    if j - K + 1 >= 0:\n\n        ctr[y[j - K + 1]] -= 1\n\nprint(ans)\n", "score": 1.0, "codebleu": 0.6323486592939087, "crystalbleu": 0.6700115074905827, "codebertscore": 0.94, "codescore": 0.8424906134605408, "surfaceSim": 0.8542061386888973, "abs_surfaceSim_minus_score": 0.14579386131110272}
{"golden_code": "import math\n\nn = int(eval(input()))\n\nprint((math.factorial(n)%(10**9+7)))\n", "generated_code": "n = int(eval(input()))\n\npw = 1\n\nfor i in range(n):\n\n  pw *= (i+1)\n\n  pw %= 10**9+7\n\nprint(pw)", "score": 1.0, "codebleu": 0.2908323286000435, "crystalbleu": 0.0, "codebertscore": 0.83, "codescore": 0.14048220217227936, "surfaceSim": 0.5698924731182795, "abs_surfaceSim_minus_score": 0.4301075268817205}
{"golden_code": "n,m=list(map(int,input().split()))\n\nc=[0]*(n+2)\n\nfor i in range(m):\n\n  l,r=list(map(int,input().split()))\n\n  c[l-1]+=1\n\n  c[r]-=1\n\nfor i in range(1,n+2):\n\n  c[i]=c[i]+c[i-1]\n\nans=0\n\nfor i in range(n+2):\n\n  if c[i]==m:\n\n    ans+=1\n\nprint(ans)", "generated_code": "n,m=list(map(int,input().split()))\n\nl,r=list(map(int,input().split()))\n\nfor i in range(m-1):\n\n  tl,tr=list(map(int,input().split()))\n\n  if l<tl:\n\n    l=tl\n\n  if tr<r:\n\n    r=tr\n\nprint((max(r-l+1,0)))", "score": 1.0, "codebleu": 0.2118312531149506, "crystalbleu": 0.22829217769272614, "codebertscore": 0.87, "codescore": 0.27117279171943665, "surfaceSim": 0.598863431354862, "abs_surfaceSim_minus_score": 0.401136568645138}
{"golden_code": "import numpy as np\n\nN=int(eval(input()))\n\nprint((2**int(np.log2(N))))", "generated_code": "import math\n\nN=int(eval(input()))\n\nprint((2**int(math.log2(N))))", "score": 1.0, "codebleu": 0.49332105343485505, "crystalbleu": 0.0, "codebertscore": 0.95, "codescore": 0.8259967565536499, "surfaceSim": 0.9202898550724637, "abs_surfaceSim_minus_score": 0.07971014492753625}
{"golden_code": "class Queue:\n\n    def __init__(self,values):\n\n        self.values = values\n\n\n\n    def empty(self):\n\n        if len(self.values) == 0:\n\n            return True\n\n        else:\n\n            return False\n\n\n\n    def enqueue(self,v):\n\n        self.values.append(v)\n\n\n\n    def dequeue(self):\n\n        if len(self.values) <= 0:\n\n            raise\n\n        else:\n\n            v = self.values[0]\n\n            del self.values[0]\n\n            return v\n\n\n\nn,q = list(map(int,input().split(' ')))\n\nprocesses = []\n\nfor i in range(n):\n\n    n,t = input().split(' ')\n\n    processes.append((n,int(t)))\n\n\n\nqueue = Queue(processes)\n\n\n\nclock = 0\n\ndone = []\n\nwhile not queue.empty():\n\n    p = queue.dequeue()\n\n    n = p[0]\n\n    t = p[1]\n\n    if t <= q:\n\n        clock+=t\n\n        done.append((n,clock))\n\n    else:\n\n        queue.enqueue((n,t-q))\n\n        clock+=q\n\n\n\nfor p in done:\n\n    print(p[0],p[1])", "generated_code": "class Queue:\n\n    def __init__(self,l):\n\n        self.values = []\n\n        self.l = l\n\n        for _ in range(l):\n\n            self.values.append(None)\n\n        self.head = 0\n\n        self.tail = 0\n\n    def inc(self,n):\n\n        if n+1 >= self.l:\n\n            return 0\n\n        else:\n\n            return n+1\n\n    def enqueue(self,v):\n\n        if self.inc(self.head) == self.tail:\n\n            print('overflow')\n\n            exit()\n\n        self.values[self.head] = v\n\n        self.head = self.inc(self.head)\n\n    def dequeue(self):\n\n        if self.head == self.tail:\n\n            print('underflow')\n\n            exit()\n\n        v = self.values[self.tail]\n\n        self.tail = self.inc(self.tail)\n\n        return v\n\n    def size(self):\n\n        if self.head >= self.tail:\n\n            return self.head-self.tail\n\n        else:\n\n            self.head + (self.l-self.tail)\n\n\n\nn,q = list(map(int,input().split(' ')))\n\nqueue = Queue(200000)\n\nfor _ in range(n):\n\n    n,t = input().split(' ')\n\n    t = int(t)\n\n    queue.enqueue((n,t))\n\n\n\nc = 0\n\nwhile queue.size()>0:\n\n    n,t = queue.dequeue()\n\n    if t <= q:\n\n        c += t\n\n        print(n,c)\n\n    else:\n\n        queue.enqueue((n,t-q))\n\n        c += q", "score": 1.0, "codebleu": 0.31805903233350485, "crystalbleu": 0.37211966863851337, "codebertscore": 0.85, "codescore": 0.18411020934581757, "surfaceSim": 0.6934056761268781, "abs_surfaceSim_minus_score": 0.3065943238731219}
{"golden_code": "board = [[False]*1000001]*1000001\n\nwhile True:\n\n    m = int(eval(input()))\n\n    if m == 0: break\n\n    star = list({tuple(map(int, input().split())) for i in range(m)})\n\n    sx, sy = star[0]\n\n    \n\n    n = int(eval(input()))\n\n    starlist = list({tuple(map(int, input().split())) for i in range(n)})\n\n    for i in range(len(starlist)):\n\n        board[starlist[i][0]][starlist[i][1]] = True\n\n    for i in range(n):\n\n        flag = True\n\n        for j in range(len(star)-1):\n\n            dx = starlist[i][0] + star[j+1][0] - sx\n\n            dy = starlist[i][1] + star[j+1][1] - sy\n\n            if dx < 0 or 1000000 < dx or dy < 0 or 1000000 < dy or board[dx][dy] == False:\n\n                flag = False\n\n                break\n\n\n\n        if flag == True:\n\n            print((\"{} {}\".format(starlist[i][0] - sx, starlist[i][1] -sy)))\n\n            break\n\n    ", "generated_code": "while True:\n\n    m = int(eval(input()))\n\n    if m == 0: break\n\n    star = list({tuple(map(int, input().split())) for i in range(m)})\n\n    sx, sy = star[0]\n\n    \n\n    n = int(eval(input()))\n\n    starset = {tuple(map(int, input().split())) for i in range(n)}\n\n    for x, y in starset:\n\n        flag = True\n\n        for j in range(len(star)-1):\n\n            dx = x + star[j+1][0] - sx\n\n            dy = y + star[j+1][1] - sy\n\n            if (dx, dy) not in starset:\n\n                flag = False\n\n                break\n\n\n\n        if flag == True:\n\n            print((x - sx, y - sy))\n\n            break\n\n    ", "score": 1.0, "codebleu": 0.46608626615086984, "crystalbleu": 0.4443448587146504, "codebertscore": 0.9, "codescore": 0.9115392565727234, "surfaceSim": 0.7582164369163601, "abs_surfaceSim_minus_score": 0.2417835630836399}
{"golden_code": "l, r=list(map(int, input().split()))\n\nif r-l>672:\n\n\tp=0\n\nelse:\n\n\tp=2019\n\n\tfor i in range(l, r):\n\n\t\tfor j in range(i+1, r+1):\n\n\t\t\tp=min(p, (((i%2019)*(j%2019))%2019))\n\n\t\t\tif not p:\n\n\t\t\t\tbreak\n\n\t\tif not p:\n\n\t\t\tbreak\n\nprint(p)", "generated_code": "l, r=list(map(int, input().split()))\n\nif r-l>672:\n\n\tp=0\n\nelse:\n\n\tp=2019\n\n\tfor i in range(l, r):\n\n\t\tfor j in range(i+1, r+1):\n\n\t\t\tp=min(p, (i*j%2019))\n\n\t\t\tif not p:\n\n\t\t\t\tbreak\n\n\t\tif not p:\n\n\t\t\tbreak\n\nprint(p)", "score": 1.0, "codebleu": 0.8726330193482528, "crystalbleu": 0.8526724299959368, "codebertscore": 0.99, "codescore": 0.9937360286712646, "surfaceSim": 0.9641255605381166, "abs_surfaceSim_minus_score": 0.0358744394618834}
{"golden_code": "def main():\n\n    x = int(eval(input()))\n\n    for a in range(-120, 121):\n\n        for b in range(-120, 121):\n\n            if a**5 - b**5 == x:\n\n                print((a, b))\n\n                return\n\n\n\nif __name__ == \"__main__\":\n\n    main()", "generated_code": "def main():\n\n    x = int(eval(input()))\n\n    for i in range(-120, 121):\n\n        for j in range(-120, 121):\n\n            if i**5 - j**5 == x:\n\n                print((i, j))\n\n                return\n\n\n\nif __name__ == \"__main__\":\n\n    main()", "score": 1.0, "codebleu": 0.7574111814061091, "crystalbleu": 0.7256017249452535, "codebertscore": 0.98, "codescore": 0.02984989993274212, "surfaceSim": 0.9873949579831933, "abs_surfaceSim_minus_score": 0.012605042016806678}
{"golden_code": "import numpy as np\n\n\n\nN, K = list(map(int, input().split()))\n\nS = list(eval(input())) + ['2']\n\n\n\nblocks = []\n\ncur = 1\n\nseq = 0\n\nfor s in S:\n\n    if int(s) == cur:\n\n        seq += 1\n\n    else:\n\n        blocks.append(seq)\n\n        cur = 1 - cur\n\n        seq = 1\n\nanswer = 0\n\nblocks = np.array(blocks)\n\nfor i in range(0, len(blocks), 2):\n\n    answer = max(answer, blocks[i:i+2*K+1].sum())\n\nprint(answer)\n", "generated_code": "# coding: utf-8\n\nimport sys\n\nimport itertools\n\n\n\nsr = lambda: sys.stdin.readline().rstrip()\n\nir = lambda: int(sr())\n\nlr = lambda: list(map(int, sr().split()))\n\n\n\n# 0か1の連続している人数のリスト、累積和\n\nstreak = [0, 0]\n\nN, K = lr()\n\nS = sr() + '2'\n\ncur = 1\n\nfor i in range(N):\n\n    if S[i] != S[i+1]:\n\n        streak.append(cur)\n\n        cur = 1\n\n    else:\n\n        cur += 1\n\n\n\nstreak_cum = list(itertools.accumulate(streak))\n\nstreak_cum.extend([streak_cum[-1], streak_cum[-1]])\n\nif S[0] == '0':\n\n    start = 0\n\nelse:\n\n    start = 1\n\nanswer = 0\n\n\n\nlimit = len(streak_cum) - 1\n\nfor i in range(start, len(streak_cum), 2):\n\n    result = streak_cum[min(limit, i+2*K+1)] - streak_cum[i]\n\n    if result > answer:\n\n        answer = result\n\n\n\nprint(answer)\n\n# 52", "score": 1.0, "codebleu": 0.31014844887410725, "crystalbleu": 0.18691965755809017, "codebertscore": 0.76, "codescore": 0.14180804789066315, "surfaceSim": 0.6219853810128244, "abs_surfaceSim_minus_score": 0.3780146189871756}
{"golden_code": "import numpy as np\n\n\n\nn = int(eval(input()))\n\na = np.array(list(map(int,input().split())))\n\n\n\ncount = 0\n\nwhile np.all(a%2==0):\n\n    count+=1\n\n    a=a/2\n\nprint(count)\n", "generated_code": "N=int(eval(input()))\n\na = [int(i) for i in input().split()]\n\n\n\ncount=0\n\nwhile 1:\n\n    if sum([i%2 for i in a]) == 0:\n\n        a = [i/2 for i in a]\n\n        count=count+1\n\n    else:\n\n        print(count)\n\n        break\n", "score": 1.0, "codebleu": 0.23312890830139688, "crystalbleu": 0.0, "codebertscore": 0.82, "codescore": 0.9294438362121582, "surfaceSim": 0.6391104906262465, "abs_surfaceSim_minus_score": 0.3608895093737535}
{"golden_code": "# -*- coding: utf-8 -*-\n\nimport sys\n\n\n\nX = int(input().strip())\n\n#-----\n\n\n\nfor a in range(-118,120):\n\n    for b in range(-118,120):\n\n        if (a**5 - b**5) == X:\n\n            print((a,b))\n\n            sys.exit()\n", "generated_code": "# -*- coding: utf-8 -*-\n\nimport sys\n\n\n\nX = int(input().strip())\n\n#-----\n\ncalc = {}\n\n\n\nfor i in range(-118,120):\n\n    calc[i] = i**5\n\n\n\n\n\nfor a in range(-118,120):\n\n    for b in range(-118,120):\n\n        if (calc[a] - calc[b]) == X:\n\n            print((a,b))\n\n            sys.exit()\n", "score": 1.0, "codebleu": 0.7204638521337896, "crystalbleu": 0.5982394116514085, "codebertscore": 0.95, "codescore": 0.9937699437141418, "surfaceSim": 0.836436170212766, "abs_surfaceSim_minus_score": 0.16356382978723405}
{"golden_code": "from collections import deque\n\n\n\nn, k = list(map(int, input().split()))\n\nV = list(map(int, input().split()))\n\n\n\nans = 0\n\nfor t in range(k//2 + 1):\n\n    hand = deque(V[:k-t])\n\n    rest = deque(V[k-t:])\n\n    cur_sum = sum(hand)\n\n\n\n    for j in range(k-t+1):\n\n        put_back = 0\n\n        rev_hand = sorted(hand)\n\n\n\n        for i in range(t):\n\n            jewel = rev_hand[i]\n\n            if jewel < 0:\n\n                put_back -= jewel\n\n            else:\n\n                break\n\n\n\n        candidate = cur_sum + put_back\n\n        ans = max(candidate, ans)\n\n\n\n        to_rest = hand.pop()\n\n        rest.appendleft(to_rest)\n\n        to_hand = rest.pop()\n\n        hand.appendleft(to_hand)\n\n\n\n        cur_sum += to_hand - to_rest\n\n\n\nprint(ans)", "generated_code": "n, k = list(map(int, input().split()))\n\nV = list(map(int, input().split()))\n\n\n\n\n\ndef get_jewelries(box, left_pop, right_pop):\n\n    if left_pop + right_pop >= len(box):\n\n        return box[:]\n\n\n\n    left = box[:left_pop]\n\n    right = box[-right_pop:] if right_pop else []\n\n\n\n    return left + right\n\n\n\n\n\ncandidates = []\n\npop_max = min(k, n)\n\nfor pop_count in range(pop_max+1):\n\n    residue = k - pop_count\n\n\n\n    for left_pop in range(pop_count+1):\n\n        right_pop = pop_count - left_pop\n\n        jewelries = get_jewelries(V, left_pop, right_pop)\n\n        jewelries.sort(reverse=True)\n\n\n\n        for _ in range(residue):\n\n            if not jewelries:\n\n                break\n\n            if jewelries[-1] < 0:\n\n                jewelries.pop()\n\n\n\n        value = sum(jewelries)\n\n        candidates.append(value)\n\n\n\nprint((max(candidates)))\n", "score": 1.0, "codebleu": 0.30416954502908017, "crystalbleu": 0.19582782188396514, "codebertscore": 0.76, "codescore": 0.9938327074050903, "surfaceSim": 0.5229389615537059, "abs_surfaceSim_minus_score": 0.4770610384462941}
{"golden_code": "import numpy as np\n\n\n\nN, K= list(map(int, input().split()))\n\np = np.array(list(map(int, input().split())))\n\n\n\ntmp = np.sum(p[:K])\n\nmax = tmp\n\nfor i in range(N-K):\n\n    tmp = tmp-p[i]+p[i+K]\n\n    if tmp>max:\n\n        max = tmp\n\n\n\nprint(((max+K)/2))", "generated_code": "N, K= list(map(int, input().split()))\n\np = list(map(int, input().split()))\n\n\n\ntmp = sum(p[:K])\n\nmax = tmp\n\nfor i in range(N-K):\n\n    tmp = tmp-p[i]+p[i+K]\n\n    if tmp>max:\n\n        max = tmp\n\n\n\nprint(((max+K)/2))", "score": 1.0, "codebleu": 0.6565883081422969, "crystalbleu": 0.8528085939151825, "codebertscore": 0.95, "codescore": 0.8763185143470764, "surfaceSim": 0.8978172856891392, "abs_surfaceSim_minus_score": 0.10218271431086079}
{"golden_code": "from math import floor, sqrt\n\nfrom collections import Counter\n\n\n\nMOD = 10 ** 9 + 7\n\n\n\n# xを素因数分解する\n\ndef getPrimeFactor(x):\n\n    ans = []\n\n    for d in range(2, floor(sqrt(x)) + 1):\n\n        while x % d == 0:\n\n            ans.append(d)\n\n            x //= d\n\n\n\n    if x != 1:\n\n        ans.append(x)\n\n\n\n    return ans\n\n\n\n# xのn乗（二分累乗法）\n\ndef power(x, n):\n\n    ans = 1\n\n    while n:\n\n        if n % 2 == 1:\n\n            ans = (ans * x) % MOD\n\n        x = (x * x) % MOD\n\n        n //= 2\n\n    return ans\n\n\n\n\n\nN, M = list(map(int, input().split()))\n\n\n\nPFs = getPrimeFactor(M)\n\ncnt = Counter(PFs)\n\n\n\nN2 = N\n\nif len(cnt):\n\n    N2 += max(cnt.values())\n\n\n\n# facts[x]: xの階乗\n\nfacts = [1] + [0] * N2\n\nfor x in range(1, N2 + 1):\n\n    facts[x] = (facts[x - 1] * x) % MOD\n\n\n\n# invFs[x]: xの階乗の逆元\n\ninvFs = [0] * N2 + [power(facts[N2], MOD - 2)]\n\nfor x in reversed(list(range(N2))):\n\n    invFs[x] = (invFs[x + 1] * (x + 1)) % MOD\n\n\n\ndef comb(n, k):\n\n    return ((facts[n] * invFs[k]) % MOD * invFs[n - k]) % MOD\n\n\n\n\n\nans = 1\n\nfor num in list(cnt.values()):\n\n    ans = (ans * comb(N + num - 1, num)) % MOD\n\nprint(ans)\n", "generated_code": "from math import floor, sqrt\n\nfrom collections import Counter\n\n\n\nMOD = 10 ** 9 + 7\n\n\n\n# xを素因数分解する\n\ndef getPrimeFactor(x):\n\n    ans = []\n\n    for d in range(2, floor(sqrt(x)) + 1):\n\n        while x % d == 0:\n\n            ans.append(d)\n\n            x //= d\n\n    if x != 1:\n\n        ans.append(x)\n\n    return ans\n\n\n\ndef comb(n, k):\n\n    k = min(k, n - k)\n\n    ans = 1\n\n    for i in range(n, n - k, -1):\n\n        ans *= i\n\n    for i in range(1, k + 1):\n\n        ans //= i \n\n    return ans\n\n\n\n\n\nN, M = list(map(int, input().split()))\n\n\n\nPFs = getPrimeFactor(M)\n\ncnt = Counter(PFs)\n\n\n\nans = 1\n\nfor num in list(cnt.values()):\n\n    ans *= comb(N + num - 1, num)\n\nprint((ans % MOD))\n", "score": 1.0, "codebleu": 0.4402052513109228, "crystalbleu": 0.38525969984631075, "codebertscore": 0.9, "codescore": 0.7779980301856995, "surfaceSim": 0.7838077827108906, "abs_surfaceSim_minus_score": 0.21619221728910942}
{"golden_code": "n=int(eval(input()))\n\nx=list(map(int,input().split()))\n\n\n\nx.sort()\n\n\n\nfor p in range(x[0],x[len(x)-1]+1):\n\n    psum=0\n\n    for i in range(len(x)):\n\n        psum=psum+(x[0]-x[i])**2\n\n#    print(psum)\n\n    pmin=psum    \n\n    for j in range(x[0]+1,x[len(x)-1]):\n\n        psum=0\n\n        for i in range(len(x)):\n\n            psum=psum+(j-x[i])**2\n\n#        print(psum)\n\n        if pmin>psum:\n\n            pmin=psum\n\nprint(pmin)    ", "generated_code": "n=int(eval(input()))\n\nx=list(map(int,input().split()))\n\n\n\nx.sort()\n\n\n\npsum=0\n\nfor i in range(len(x)):\n\n    psum=psum+(x[0]-x[i])**2\n\n#    print(psum)\n\npmin=psum    \n\nfor j in range(x[0]+1,x[len(x)-1]):\n\n    psum=0\n\n    for i in range(len(x)):\n\n        psum=psum+(j-x[i])**2\n\n#        print(psum)\n\n    if pmin>psum:\n\n        pmin=psum\n\nprint(pmin)            \n", "score": 1.0, "codebleu": 0.780767785263546, "crystalbleu": 0.8282159388426334, "codebertscore": 0.96, "codescore": 0.9938945174217224, "surfaceSim": 0.9613583138173303, "abs_surfaceSim_minus_score": 0.03864168618266972}
{"golden_code": "import numpy as np\n\nimport sys\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\nreadlines = sys.stdin.readlines\n\n\n\ndef main():\n\n    N = int(readline())\n\n    X = [int(i) for i in readline().split()]\n\n    X = np.array(X)\n\n\n\n    ans = np.min(np.sum((X - np.arange(1,101).reshape(100, 1))**2, axis=1))\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "generated_code": "import sys\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\nreadlines = sys.stdin.readlines\n\n\n\ndef main():\n\n    N = int(readline())\n\n    X = [int(i) for i in readline().split()]\n\n\n\n    ans = float('inf')\n\n    for i in range(1,101):\n\n        tmp = 0\n\n        for x in X:\n\n            tmp += (x - i)**2\n\n        \n\n        if tmp < ans:\n\n            ans = tmp\n\n\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "score": 1.0, "codebleu": 0.5616461091095378, "crystalbleu": 0.5384837722021236, "codebertscore": 0.89, "codescore": 0.018375074490904808, "surfaceSim": 0.7979638009049774, "abs_surfaceSim_minus_score": 0.20203619909502257}
{"golden_code": "import numpy as np\n\n\n\nN = int(input())\n\nAs = list(map(int, input().split()))\n\n\n\n# for i in range(N):\n\n#   print(As.index(i+1) + 1, end = \" \")\n\n\n\nfor item in np.argsort(As):\n\n  print(item+1, end=\" \")\n", "generated_code": "N = int(eval(input()))\n\nAs = list(map(int, input().split()))\n\n\n\nans = [0] * N\n\n\n\nfor i, A in enumerate(As):\n\n  ans[A-1] = i+1\n\n  \n\nprint((*ans))", "score": 1.0, "codebleu": 0.35761204261882695, "crystalbleu": 0.0, "codebertscore": 0.83, "codescore": 0.24153730273246765, "surfaceSim": 0.6119232526267702, "abs_surfaceSim_minus_score": 0.38807674737322984}
{"golden_code": "# -*- coding: utf-8 -*-\n\nfrom collections import defaultdict\n\nfrom itertools import combinations\n\nN = int(eval(input()))\n\nC = [0, 0, 0, 0, 0, 0]\n\nD = defaultdict(int)\n\nfor i, m in enumerate(\"MARCH\", start=1):\n\n    D[m] = i\n\n\n\nfor _ in range(N):\n\n    C[D[input()[0]]] += 1\n\n\n\nans = 0\n\nfor a, b, c in combinations(list(range(1, 6)), r=3):\n\n    ans += C[a]*C[b]*C[c]\n\nprint(ans)", "generated_code": "from collections import defaultdict\n\nfrom itertools import combinations\n\ndef inpl(): return list(map(int, input().split()))\n\n\n\nC = defaultdict(int)\n\nN = int(eval(input()))\n\nfor _ in range(N):\n\n    C[input()[0]] += 1\n\n\n\nres = 0\n\nfor H in combinations(\"MARCH\", r=3):\n\n    res += C[H[0]] * C[H[1]] * C[H[2]]\n\nprint(res)", "score": 1.0, "codebleu": 0.30646801130107504, "crystalbleu": 0.3992314111977721, "codebertscore": 0.84, "codescore": 0.7842673063278198, "surfaceSim": 0.719, "abs_surfaceSim_minus_score": 0.281}
{"golden_code": "import numpy as np\n\nN,L = list(map(int, input().split()))\n\ntaste = np.array([L+i-1 for i in range(1,N+1)])\n\nif taste[-1] < 0:\n\n  print((sum(taste) + min(np.abs(taste))))\n\nelse:\n\n  print((sum(taste) - min(np.abs(taste))))", "generated_code": "N,L = list(map(int, input().split()))\n\ntaste = [L+i-1 for i in range(1,N+1)]\n\nif taste[-1] < 0:\n\n  print((sum(taste) + min([abs(x) for x in taste])))\n\nelse:\n\n  print((sum(taste) - min([abs(x) for x in taste])))", "score": 1.0, "codebleu": 0.38527373050610475, "crystalbleu": 0.7220260759077887, "codebertscore": 0.94, "codescore": 0.8979200720787048, "surfaceSim": 0.8446969696969697, "abs_surfaceSim_minus_score": 0.15530303030303028}
{"golden_code": "n, k = list(map(int, input().split()))\n\na_s = list(map(int, input().split()))\n\ndp = [\"Second\"] * (k + 1)\n\nfor i in range(k + 1):\n\n    if dp[i] == \"Second\":\n\n        for a in a_s:\n\n            ii = i + a\n\n            if ii <= k:\n\n                dp[ii] = \"First\"\n\nprint((dp[-1]))\n", "generated_code": "n, k = list(map(int, input().split()))\n\na_s = list(map(int, input().split()))\n\ndp = [\"Second\"] * (k + 1)\n\nfor i in range(k + 1):\n\n    if dp[i] == \"Second\":\n\n        for a in a_s:\n\n            ii = i + a\n\n            if ii > k:break\n\n            dp[ii] = \"First\"\n\nprint((dp[-1]))\n", "score": 1.0, "codebleu": 0.9200596498745525, "crystalbleu": 0.8903228609365674, "codebertscore": 0.99, "codescore": 0.9938200116157532, "surfaceSim": 0.9274551971326165, "abs_surfaceSim_minus_score": 0.07254480286738352}
{"golden_code": "# インポート\n\nimport numpy as np\n\n# A,B,Cの値の獲得\n\nnum = list(map(int, input().split()))\n\n# numリストの最大値を10倍\n\nnum[num.index(max(num))] = max(num) * 10\n\n# npで要素の和を計算し、出力\n\nprint((np.sum(num)))", "generated_code": "# A,B,Cの値の獲得\n\nnum = list(map(int, input().split()))\n\n# numリストの最大値を10倍\n\nnum[num.index(max(num))] *= 10\n\n# npで要素の和を計算し、出力\n\nprint((sum(num)))\n", "score": 1.0, "codebleu": 0.42987209164388324, "crystalbleu": 0.0, "codebertscore": 0.95, "codescore": 0.09600050747394562, "surfaceSim": 0.7944444444444445, "abs_surfaceSim_minus_score": 0.2055555555555555}
{"golden_code": "import statistics\n\nN = int(eval(input()))\n\na = [int(i) for i in input().split()]\n\nans = 0\n\n\n\nfor i in range(1,N+1):\n\n  a[i-1] -= i\n\n\n\nb = statistics.median(a)\n\nfor i in range(N):\n\n  ans += abs(a[i]-b)\n\nprint((int(ans)))", "generated_code": "N = int(eval(input()))\n\nA = [int(i) for i in input().split()]\n\nC = [A[i]-i for i in range(N)]\n\nC.sort()\n\nans = 0\n\nmed = C[N//2]\n\nfor i in range(N):\n\n  ans += abs(C[i]-med)\n\nprint(ans)", "score": 1.0, "codebleu": 0.4446310228895979, "crystalbleu": 0.3879392597446721, "codebertscore": 0.89, "codescore": 0.41179853677749634, "surfaceSim": 0.7664709719504239, "abs_surfaceSim_minus_score": 0.2335290280495761}
{"golden_code": "\"\"\"Minimum cost Sort.\"\"\"\n\n\n\ndef min_cost_sort(A):\n\n    \"\"\"Sort list A in ascending order.\n\n \n\n    And return the switching cost in sorting.\n\n    \"\"\"\n\n    B = list(A)\n\n    B.sort()\n\n    cost = 0\n\n    min_w = B[0]\n\n    for i, b in enumerate(B):\n\n        tmp_cost = 0\n\n        bi = A.index(b)\n\n        n = 1\n\n        while bi != i:\n\n            n += 1\n\n            st = B[bi]\n\n            si = A.index(st)\n\n            tmp_cost += b + st\n\n            A[bi], A[si] = st, b\n\n            bi = si\n\n        dec = (n - 1) * (b - min_w)\n\n        inc = 2 * (min_w + b)\n\n        if dec < inc:\n\n            cost += tmp_cost\n\n        else:\n\n            cost += tmp_cost - dec + inc\n\n    return cost\n\n\n\n\n\nn = eval(input())\n\n\n\nA = list(map(int, input().split()))\n\n\n\nans = min_cost_sort(A)\n\n\n\nprint(ans)", "generated_code": "\"\"\"Minimum cost Sort.\"\"\"\n\n\n\ndef min_cost_sort(A):\n\n    \"\"\"Sort list A in ascending order.\n\n \n\n    And return the switching cost in sorting.\n\n    \"\"\"\n\n    B = list(A)\n\n    B.sort()\n\n    cost = 0\n\n    min_w = B[0]\n\n    for i, b in enumerate(B):\n\n        tmp_cost = 0\n\n        bi = A.index(b)\n\n        cnt = 0\n\n        while bi != i:\n\n            cnt += 1\n\n            st = B[bi]\n\n            si = A.index(st)\n\n            tmp_cost += b + st\n\n            A[bi], A[si] = st, b\n\n            bi = si\n\n        if cnt:\n\n            dec = cnt * (b - min_w)\n\n            inc = 2 * (min_w + b)\n\n            if dec < inc:\n\n                cost += tmp_cost\n\n            else:\n\n                cost += tmp_cost - dec + inc\n\n    return cost\n\n\n\n\n\nn = eval(input())\n\n\n\nA = list(map(int, input().split()))\n\n\n\nans = min_cost_sort(A)\n\n\n\nprint(ans)", "score": 1.0, "codebleu": 0.8802608337277296, "crystalbleu": 0.9095477305288807, "codebertscore": 0.97, "codescore": 0.06044744327664375, "surfaceSim": 0.9903264812575574, "abs_surfaceSim_minus_score": 0.0096735187424426}
{"golden_code": "class SegmentTree:\n\n    seg_len = 1\n\n    node = []\n\n    def __init__(self, n):\n\n        while self.seg_len < n:\n\n            self.seg_len <<= 1\n\n        self.node = [ 0 for _ in range(self.seg_len*2) ]\n\n\n\n    def add(self, idx, v):\n\n        idx += self.seg_len\n\n        self.node[idx] += v\n\n        while True:\n\n            idx //= 2\n\n            if idx == 0:\n\n                break\n\n            self.node[idx] = self.node[idx*2] + self.node[idx*2+1]\n\n\n\n    def sum(self, l, r):\n\n        l += self.seg_len\n\n        r += self.seg_len\n\n        ret = 0\n\n        while l < r:\n\n            if l & 1 == 1:\n\n                ret += self.node[l]\n\n                l += 1\n\n            if r & 1 == 1:\n\n                ret += self.node[r-1]\n\n                r -= 1\n\n            l //= 2; r //= 2;\n\n        return ret\n\n\n\n\n\nn, k = list(map(int, input().split()))\n\np = [ int(x) for x in input().split() ]\n\n\n\nseg_tree = SegmentTree(n)\n\nfor i in range(n):\n\n    seg_tree.add(i, (1+p[i])/2)\n\n\n\nans = 0\n\nfor i in range(n-k+1):\n\n    ans = max(ans, seg_tree.sum(i, i+k))\n\n\n\nprint(ans)\n", "generated_code": "class SegmentTree:\n\n    seg_len = 1\n\n    node = []\n\n    def __init__(self, n):\n\n        while self.seg_len < n:\n\n            self.seg_len <<= 1\n\n        self.node = [ 0 for _ in range(self.seg_len*2) ]\n\n\n\n    def add(self, idx, v):\n\n        idx += self.seg_len\n\n        self.node[idx] += v\n\n        while True:\n\n            idx >>= 1\n\n            if idx == 0:\n\n                break\n\n            self.node[idx] = self.node[idx*2] + self.node[idx*2+1]\n\n\n\n    def sum(self, l, r):\n\n        l += self.seg_len\n\n        r += self.seg_len\n\n        ret = 0\n\n        while l < r:\n\n            if l & 1 == 1:\n\n                ret += self.node[l]\n\n                l += 1\n\n            if r & 1 == 1:\n\n                ret += self.node[r-1]\n\n                r -= 1\n\n            l >>= 1; r >>= 1;\n\n        return ret\n\n\n\n\n\nn, k = list(map(int, input().split()))\n\np = [ int(x) for x in input().split() ]\n\n\n\nseg_tree = SegmentTree(n)\n\nfor i in range(n):\n\n    seg_tree.add(i, (1+p[i])/2)\n\n\n\nans = 0\n\nfor i in range(n-k+1):\n\n    ans = max(ans, seg_tree.sum(i, i+k))\n\n\n\nprint(ans)\n", "score": 1.0, "codebleu": 0.9518794997963271, "crystalbleu": 0.9366687466080638, "codebertscore": 1.0, "codescore": 0.9935099482536316, "surfaceSim": 0.9687316911633594, "abs_surfaceSim_minus_score": 0.03126830883664056}
{"golden_code": "a, b = list(map(int, input().split()))\n\nif a*b%2 == 1:\n\n    print(\"Odd\")\n\nelse:\n\n    print(\"Even\")", "generated_code": "a, b = list(map(int, input().split()))\n\nprint(('Odd'if a&b&1 else 'Even'))", "score": 1.0, "codebleu": 0.5465642129184616, "crystalbleu": 0.0, "codebertscore": 0.92, "codescore": 0.9572685956954956, "surfaceSim": 0.6422902494331066, "abs_surfaceSim_minus_score": 0.35770975056689336}
{"golden_code": "import sys\n\n\n\nn, m, *lr = list(map(int, sys.stdin.read().split()))\n\nlr = list(zip(*[iter(lr)] * 2))\n\n\n\ndef main():\n\n    cnt = [0] * (n + 1)\n\n    for l, r in lr:\n\n        cnt[l-1] += 1\n\n        cnt[r] -= 1\n\n    \n\n    for i in range(n):\n\n        cnt[i+1] += cnt[i]\n\n    \n\n    res = 0\n\n    for i in range(n):\n\n        res += (cnt[i] == m) & 1\n\n    \n\n    return res\n\n\n\nif __name__ == '__main__':\n\n    ans = main()\n\n    print(ans)", "generated_code": "import sys\n\n\n\nn, m, *lr = list(map(int, sys.stdin.read().split()))\n\nl, r = lr[::2], lr[1::2]\n\n\n\ndef main():\n\n    ans = max(min(r) - max(l) + 1, 0)\n\n    return ans\n\n\n\nif __name__ == '__main__':\n\n    ans = main()\n\n    print(ans)", "score": 1.0, "codebleu": 0.30662618959757326, "crystalbleu": 0.2800354182309023, "codebertscore": 0.84, "codescore": 0.019747750833630562, "surfaceSim": 0.7303921568627452, "abs_surfaceSim_minus_score": 0.26960784313725483}
{"golden_code": "a, b, c = sorted(map(int, input().split()))\n\n\n\nprint((c*10 + b + a))", "generated_code": "a, b, c = list(map(int, input().split()))\n\n\n\nprint((max(a, b, c)*9 + (a + b + c)))", "score": 1.0, "codebleu": 0.549214423833286, "crystalbleu": 0.0, "codebertscore": 0.92, "codescore": 0.026329999789595604, "surfaceSim": 0.8780487804878049, "abs_surfaceSim_minus_score": 0.12195121951219512}
{"golden_code": "import math\n\nimport numpy as np\n\nn, d = list(map(int, input().split()))\n\na = []\n\ncnt = 0\n\nfor x in range(n):\n\n    a.append(list(map(int, input().split())))\n\nfor i in range(len(a)):\n\n    for j in range(len(a)):\n\n        if i < j:\n\n            dis = np.array(a[i]) - np.array(a[j])\n\n            if np.linalg.norm(dis).is_integer():\n\n                cnt += 1\n\nprint(cnt)", "generated_code": "n, d = list(map(int, input().split()))\n\na = [[int(i) for i in input().split()] for i in range(n)]\n\nans = 0\n\ndef dis(x,y):\n\n    T = []\n\n    for i in range(len(x)):\n\n        T.append((x[i]-y[i])**2)\n\n    return sum(T)\n\nfor i in range(n):\n\n    for j in range(i+1,n):\n\n        r = dis(a[i], a[j])\n\n        for k in range(r + 1):\n\n            if k ** 2 == r:\n\n                ans += 1\n\nprint(ans)", "score": 1.0, "codebleu": 0.37043787570892733, "crystalbleu": 0.29626534259493903, "codebertscore": 0.83, "codescore": 0.6974213719367981, "surfaceSim": 0.5936803894068146, "abs_surfaceSim_minus_score": 0.40631961059318544}
{"golden_code": "\n\nX = int(eval(input()))\n\nfor a in range(-200, 200):\n\n    find = False\n\n    for b in range(-200, 200):\n\n        x = a**5-b**5\n\n        if x == X:\n\n            find = True\n\n            print((a, b))\n\n            break\n\n    if find:\n\n        break\n", "generated_code": "\n\nX = int(eval(input()))\n\nfor a in range(-120, 120):\n\n    find = False\n\n    for b in range(-120, 120):\n\n        x = a**5-b**5\n\n        if x == X:\n\n            find = True\n\n            print((a, b))\n\n            break\n\n    if find:\n\n        break\n", "score": 1.0, "codebleu": 0.8852092338600269, "crystalbleu": 0.0, "codebertscore": 0.98, "codescore": 0.9701538681983948, "surfaceSim": 0.983739837398374, "abs_surfaceSim_minus_score": 0.016260162601625994}
{"golden_code": "N = int(eval(input()))\n\nX = [[] for i in range(N)]\n\nfor i in range(N-1):\n\n    x, y = list(map(int, input().split()))\n\n    X[x-1].append(y-1)\n\n    X[y-1].append(x-1)\n\n\n\nP = [-1] * N\n\nDE = [0] * N\n\nQ = [0]\n\nwhile Q:\n\n    i = Q.pop()\n\n    for a in X[i][::-1]:\n\n        if a != P[i]:\n\n            P[a] = i\n\n            DE[a] = DE[i] + 1\n\n            X[a].remove(i)\n\n            Q.append(a)\n\n\n\ndef lp(u, v):\n\n    t = 0\n\n    while u != v:\n\n        if DE[u] > DE[v]:\n\n            t += 1 << u-1\n\n            u = P[u]\n\n        elif DE[u] < DE[v]:\n\n            t += 1 << v-1\n\n            v = P[v]\n\n        else:\n\n            t += 1 << u-1\n\n            t += 1 << v-1\n\n            u = P[u]\n\n            v = P[v]\n\n    \n\n    return t\n\n\n\nY = []\n\nM = int(eval(input()))\n\nfor _ in range(M):\n\n    a, b = list(map(int, input().split()))\n\n    a, b = a-1, b-1\n\n    Y.append(lp(a, b))\n\n\n\nD = {1<<i: i for i in range(50)}\n\nZ = [0] * (1<<M)\n\nans = 0\n\nCC = [0] * N\n\nBC = [0] * (1<<17)\n\nfor m in range(1, 1<<17):\n\n    a = m & (-m)\n\n    BC[m] = BC[m^a] + 1\n\nfor m in range(1<<M):\n\n    a = m & (-m)\n\n    if a == m:\n\n        if a == 0:\n\n            Z[m] = 0\n\n        else:\n\n            Z[m] = Y[D[a]]\n\n    else:\n\n        Z[m] = Z[m^a] | Y[D[a]]\n\n    \n\n    aa = Z[m]\n\n    bc = BC[aa % (1<<17)]\n\n    aa >>= 17\n\n    bc += BC[aa % (1<<17)]\n\n    aa >>= 17\n\n    bc += BC[aa]\n\n    CC[N - 1 - bc] += (1 if BC[m%1024] + BC[m>>10] & 1 == 0 else -1)\n\n\n\nprint((sum([2 ** i * CC[i] for i in range(N)])))", "generated_code": "N = int(eval(input()))\n\nX = [[] for i in range(N)]\n\nfor i in range(N-1):\n\n    x, y = list(map(int, input().split()))\n\n    X[x-1].append(y-1)\n\n    X[y-1].append(x-1)\n\n\n\nP = [-1] * N\n\nDE = [0] * N\n\nQ = [0]\n\nwhile Q:\n\n    i = Q.pop()\n\n    for a in X[i][::-1]:\n\n        if a != P[i]:\n\n            P[a] = i\n\n            DE[a] = DE[i] + 1\n\n            X[a].remove(i)\n\n            Q.append(a)\n\n\n\ndef lp(u, v):\n\n    t = 0\n\n    while u != v:\n\n        if DE[u] > DE[v]:\n\n            t += 1 << u-1\n\n            u = P[u]\n\n        elif DE[u] < DE[v]:\n\n            t += 1 << v-1\n\n            v = P[v]\n\n        else:\n\n            t += 1 << u-1\n\n            t += 1 << v-1\n\n            u = P[u]\n\n            v = P[v]\n\n    \n\n    return t\n\n\n\nY = []\n\nM = int(eval(input()))\n\nfor _ in range(M):\n\n    a, b = list(map(int, input().split()))\n\n    a, b = a-1, b-1\n\n    Y.append(lp(a, b))\n\n\n\ndef popcnt(n):\n\n    c = (n & 0x5555555555555555) + ((n>>1) & 0x5555555555555555)\n\n    c = (c & 0x3333333333333333) + ((c>>2) & 0x3333333333333333)\n\n    c = (c & 0x0f0f0f0f0f0f0f0f) + ((c>>4) & 0x0f0f0f0f0f0f0f0f)\n\n    c = (c & 0x00ff00ff00ff00ff) + ((c>>8) & 0x00ff00ff00ff00ff)\n\n    c = (c & 0x0000ffff0000ffff) + ((c>>16) & 0x0000ffff0000ffff)\n\n    c = (c & 0x00000000ffffffff) + ((c>>32) & 0x00000000ffffffff)\n\n    return c\n\n\n\nD = {1<<i: i for i in range(50)}\n\nZ = [0] * (1<<M)\n\nans = 0\n\nCC = [0] * N\n\nfor m in range(1<<M):\n\n    a = m & (-m)\n\n    if a == m:\n\n        if a == 0:\n\n            Z[m] = 0\n\n        else:\n\n            Z[m] = Y[D[a]]\n\n    else:\n\n        Z[m] = Z[m^a] | Y[D[a]]\n\n    \n\n    CC[N - 1 - popcnt(Z[m])] += (1 if popcnt(m) & 1 == 0 else -1)\n\n\n\nprint((sum([2 ** i * CC[i] for i in range(N)])))", "score": 1.0, "codebleu": 0.7841781132079317, "crystalbleu": 0.7679633086578852, "codebertscore": 0.9, "codescore": 0.9938188195228577, "surfaceSim": 0.8535173160173161, "abs_surfaceSim_minus_score": 0.14648268398268394}
{"golden_code": "import numpy as np\n\nN, K = list(map(int, input().split()))\n\nplist = list(map(int, input().split()))\n\nkitaiti = np.array([(0.5*(p+1)) for p in plist])\n\nans = 0\n\nval = sum(kitaiti[:K])\n\nans = max(ans, val)\n\nfor i in range(1, N-K+1):\n\n    # print(i-1, i+K)\n\n    val -= kitaiti[i-1]\n\n    val += kitaiti[i+K-1]\n\n    ans = max(ans, val)\n\nprint(ans)", "generated_code": "N, K = list(map(int, input().split()))\n\nplist = [((num*(num+1))//2)/num for num in list(map(int, input().split()))]\n\n# print(plist)\n\nans = 0\n\nfor i in range(K):\n\n    ans += plist[i]\n\n_ = ans\n\nfor i in range(N-K):\n\n    temp = _\n\n    temp -= plist[i]\n\n    temp += plist[i+K]\n\n    # print(i, i+K, ans, temp)\n\n    ans = max(ans, temp)\n\n    _ = temp\n\nprint(ans)", "score": 1.0, "codebleu": 0.32884250784999586, "crystalbleu": 0.3202517166442831, "codebertscore": 0.87, "codescore": 0.15544722974300385, "surfaceSim": 0.6837078651685393, "abs_surfaceSim_minus_score": 0.3162921348314607}
{"golden_code": "from collections import Counter,defaultdict,deque\n\nfrom heapq import heapify,heappop,heappush\n\nfrom bisect import bisect_left,bisect_right\n\nimport sys,math,itertools,string,queue\n\nsys.setrecursionlimit(10**8)\n\nmod = 10**9+7\n\ndef inp(): return int(sys.stdin.readline())\n\ndef inpl(): return list(map(int, sys.stdin.readline().split()))\n\ndef inpl_str(): return list(sys.stdin.readline().split())\n\ndef inpln(n): return list(int(sys.stdin.readline()) for i in range(n))\n\n\n\nn,m = inpl()\n\na = inpl()\n\nb = [0] * m\n\nfor i in range(m):\n\n    x,y = inpl()\n\n    b[i] = [x,y]\n\na.sort()\n\nb.sort(key=lambda x:x[1], reverse = True)\n\nres = sum(a)\n\ni = 0\n\nj = 0\n\nwhile True:\n\n    # print(i,j)\n\n    if a[i] < b[j][1]:\n\n        res += b[j][1] - a[i]\n\n        i += 1\n\n    else:\n\n        break\n\n    b[j][0] -= 1\n\n    if b[j][0] == 0:\n\n        j += 1\n\n    if i >= n or j >= m:\n\n        break\n\nprint(res)\n", "generated_code": "from collections import Counter,defaultdict,deque\n\nfrom heapq import heappop,heappush,heapify\n\nfrom bisect import bisect_left,bisect_right \n\nimport sys,math,itertools,fractions,pprint\n\nsys.setrecursionlimit(10**8)\n\nmod = 10**9+7\n\nINF = float('inf')\n\ndef inp(): return int(sys.stdin.readline())\n\ndef inpl(): return list(map(int, sys.stdin.readline().split()))\n\n\n\nn,m = inpl()\n\na = inpl()\n\na.sort()\n\nbc = [inpl() for _ in range(m)]\n\nbc.sort(key = lambda x:x[1], reverse = True)\n\nlm = sum(x[1] for x in bc)\n\nnow = 0\n\nalt = 0\n\nwhile now < n and alt < m:\n\n    c,b = bc[alt]\n\n    if a[now] > b:\n\n        break\n\n    else:\n\n        a[now] = b\n\n    bc[alt][0] -= 1\n\n    if bc[alt][0] == 0:\n\n        alt += 1\n\n    now += 1\n\nprint((sum(a)))\n", "score": 1.0, "codebleu": 0.4422076496413779, "crystalbleu": 0.4434165928801366, "codebertscore": 0.91, "codescore": 0.5583392977714539, "surfaceSim": 0.7410676532769556, "abs_surfaceSim_minus_score": 0.25893234672304444}
{"golden_code": "import sys\n\ninput = sys.stdin.readline\n\nfrom scipy.sparse.csgraph import dijkstra\n\nimport numpy as np\n\n\n\n\"\"\"\n\n最小カット\n\n\"\"\"\n\n\n\nN = int(eval(input()))\n\nstart = 0\n\ngoal = N+1\n\n\n\nA = [0] + [int(x) for x in input().split()]\n\n\n\nINF = 10 ** 12\n\ngraph = np.zeros((N+2,N+2),dtype=np.int64)\n\nfor i,a in enumerate(A[1:],1):\n\n    if a >= 0:\n\n        graph[start,i] = a\n\n    else:\n\n        graph[i,goal] = -a\n\nfor i in range(1,N+1):\n\n    for j in range(2*i,N+1,i):\n\n        if A[i] < 0 and A[j] > 0:\n\n            graph[j][i] = INF\n\n\n\ndef max_flow(graph):\n\n    flow = 0\n\n    while True:\n\n        dist,pred = dijkstra(graph, indices = start, return_predecessors = True, unweighted = True)\n\n        if dist[goal] == np.inf:\n\n            return flow\n\n        path = []\n\n        v = goal\n\n        while True:\n\n            path.append((pred[v],v))\n\n            v = pred[v]\n\n            if v == start:\n\n                break\n\n        add_flow = min(graph[x][y] for x,y in path)\n\n        for x,y in path:\n\n            graph[x][y] -= add_flow\n\n            graph[y][x] += add_flow\n\n        flow += add_flow\n\n\n\nanswer = sum(x for x in A if x > 0) - max_flow(graph)\n\nprint(answer)", "generated_code": "import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\nfrom collections import deque\n\n\n\nN,*A = list(map(int,read().split()))\n\n\n\nclass Dinic:\n\n    def __init__(self, N, source, sink):\n\n        self.N = N\n\n        self.G = [[] for _ in range(N)]\n\n        self.source = source\n\n        self.sink = sink\n\n\n\n    def add_edge(self, fr, to, cap):\n\n        n1 = len(self.G[fr])\n\n        n2 = len(self.G[to])\n\n        self.G[fr].append([to, cap, n2])\n\n        self.G[to].append([fr, 0, n1]) # 逆辺を cap 0 で追加\n\n        \n\n    def add_edge_undirected(self, fr, to, cap):\n\n        n1 = len(self.G[fr])\n\n        n2 = len(self.G[to])\n\n        self.G[fr].append([to, cap, n2])\n\n        self.G[to].append([fr, cap, n1])\n\n        \n\n    def bfs(self):\n\n        level = [0] * self.N\n\n        G = self.G; source = self.source; sink = self.sink\n\n        q = deque([source])\n\n        level[source] = 1\n\n        pop = q.popleft; append = q.append\n\n        while q:\n\n            v = pop()\n\n            lv = level[v] + 1\n\n            for to, cap, rev in G[v]:\n\n                if not cap:\n\n                    continue\n\n                if level[to]:\n\n                    continue\n\n                level[to] = lv\n\n                if to == sink:\n\n                    self.level = level\n\n                    return\n\n                append(to)\n\n        self.level = level\n\n        \n\n    def dfs(self,v,f):\n\n        if v == self.sink:\n\n            return f\n\n        G = self.G\n\n        prog = self.progress\n\n        level = self.level\n\n        lv = level[v]\n\n        E = G[v]\n\n        for i in range(prog[v],len(E)):\n\n            to, cap, rev = E[i]\n\n            prog[v] = i\n\n            if not cap:\n\n                continue\n\n            if level[to] <= lv:\n\n                continue\n\n            x = f if f < cap else cap\n\n            ff = self.dfs(to, x)\n\n            if ff:\n\n                E[i][1] -= ff\n\n                G[to][rev][1] += ff\n\n                return ff\n\n        return 0\n\n    \n\n    def max_flow(self):\n\n        INF = 10**18\n\n        flow = 0\n\n        while True:\n\n            self.bfs()\n\n            if not self.level[self.sink]:\n\n                return flow\n\n            self.progress = [0] * self.N\n\n            while True:\n\n                f = self.dfs(self.source, INF)\n\n                if not f:\n\n                    break\n\n                flow += f\n\n        return flow\n\n\n\nsource = 0; sink = N+1; INF = 10 ** 18\n\ndinic = Dinic(N+2,source,sink)\n\nadd = dinic.add_edge\n\n\n\nfor i,x in enumerate(A,1):\n\n    if x < 0:\n\n        # source側：割るものを表現。sink側にうつすときにカット-xが必要。\n\n        add(source,i,-x)\n\n    else:\n\n        # sink側：割らないものを表現。source側にうつすときにカットxが必要。\n\n        add(i,sink,x)\n\n\n\nfor i in range(1,N+1):\n\n    for j in range(i+i,N+1,i):\n\n        # iを割るならjも割る。iを割ってjを割らないのは禁止\n\n        # iがsourceでjがsinkなのは禁止\n\n        add(i,j,INF)\n\n\n\nf = dinic.max_flow()\n\nx = sum(x for x in A if x >= 0)\n\nanswer = x - f\n\n\n\nprint(answer)", "score": 1.0, "codebleu": 0.2951415422941989, "crystalbleu": 0.14609962305835508, "codebertscore": 0.76, "codescore": 0.9938449859619141, "surfaceSim": 0.6754496463455709, "abs_surfaceSim_minus_score": 0.3245503536544291}
{"golden_code": "X = int(eval(input()))\n\nfor A in range(-200, 200):\n\n    for B in range(-200, 200):\n\n        if A**5 - B**5 == X:\n\n            print((A, B))\n\n            break\n\n    else:\n\n        continue\n\n    break", "generated_code": "X = int(eval(input()))\n\nfor A in range(-150, 150):\n\n    for B in range(-150, 150):\n\n        if A**5 - B**5 == X:\n\n            print((A, B))\n\n            break\n\n    else:\n\n        continue\n\n    break", "score": 1.0, "codebleu": 0.848446312898335, "crystalbleu": 0.0, "codebertscore": 0.99, "codescore": 0.953485906124115, "surfaceSim": 0.9797979797979798, "abs_surfaceSim_minus_score": 0.02020202020202022}
{"golden_code": "def solve():\n\n  N, K = list(map(int, input().split()))\n\n  _S = eval(input())\n\n  S = []\n\n  b = _S[0]\n\n  s = 0\n\n  if b == '0': S.append(0)\n\n  for _s in _S:\n\n    if b == _s:\n\n      s = s + 1\n\n    else:\n\n      b = _s\n\n      S.append(s)\n\n      s = 1\n\n  S.append(s)\n\n  if b == '0': S.append(0)\n\n\n\n  num = min(len(S), 2 * K + 1)\n\n  # n = sum(S[0:num if _S[0] == '1' else (num - 1)])\n\n  n = sum(S[0:num])\n\n  m = n\n\n  # for i in range(0 if _S[0] == '1' else -1, len(S) - num, 2):\n\n  for i in range(0, len(S) - num, 2):\n\n    n = n - sum(S[i:i+2])\n\n    n = n + sum(S[i + num:i + num + 2])\n\n    m = max(m, n)\n\n\n\n  return m\n\n\n\nprint((solve()))", "generated_code": "def solve():\n\n  N, K = list(map(int, input().split()))\n\n  s = eval(input())\n\n  S = []\n\n  b = s[0]\n\n  cnt = 0\n\n\n\n  if s[0] == '0': S.append(0)\n\n  for c in s:\n\n    if b == c: cnt = cnt + 1\n\n    else:\n\n      b = c\n\n      S.append(cnt)\n\n      cnt = 1\n\n  S.append(cnt)\n\n  if s[-1] == '0': S.append(0)\n\n\n\n  num = min(len(S), 2 * K + 1)\n\n  part = sum(S[0:num])\n\n  ans = part\n\n\n\n  for i in range(0, len(S) - num, 2):\n\n    part = part - sum(S[i:i+2]) + sum(S[i + num:i + num + 2])\n\n    ans = max(ans, part)\n\n\n\n  return ans\n\n\n\nprint((solve()))\n", "score": 1.0, "codebleu": 0.6313933709122763, "crystalbleu": 0.6433292327447292, "codebertscore": 0.91, "codescore": 0.9791015386581421, "surfaceSim": 0.9034391534391535, "abs_surfaceSim_minus_score": 0.09656084656084651}
{"golden_code": "a, b, c, x, y = list(map(int, input().split()))\n\nab = c * 2\n\n\n\nres = float(\"inf\")\n\nif a + b <= ab:\n\n    res = x * a + y * b\n\nelse:\n\n    if x == y:\n\n        res = x * ab\n\n    elif x > y:\n\n        for i in range(y, x + 1):\n\n            cost = i * ab + (x - i) * a\n\n            res = min(res, cost)\n\n    else:\n\n        for i in range(x, y + 1):\n\n            cost = i * ab + (y - i) * b\n\n            res = min(res, cost)\n\nprint(res)\n", "generated_code": "import sys\n\n\n\nsys.setrecursionlimit(10 ** 7)\n\ninput = sys.stdin.readline\n\nf_inf = float('inf')\n\nmod = 10 ** 9 + 7\n\n\n\n\n\ndef resolve():\n\n    a, b, c, x, y = list(map(int, input().split()))\n\n    c *= 2\n\n    if a + b > c:\n\n        cost1 = max(x, y) * c\n\n        cost2 = min(x, y) * c\n\n        plus = ((y - x) * b) if x < y else (x - y) * a\n\n        res = min(cost1, cost2 + plus)\n\n    else:\n\n        res = x * a + y * b\n\n    print(res)\n\n\n\nif __name__ == '__main__':\n\n    resolve()\n", "score": 1.0, "codebleu": 0.3166977900929155, "crystalbleu": 0.28512864511022135, "codebertscore": 0.83, "codescore": 0.01863246224820614, "surfaceSim": 0.5709044624138964, "abs_surfaceSim_minus_score": 0.42909553758610364}
{"golden_code": "a,b,c,d,e,f=[int(eval(input())) for _ in range(6)]\n\nprint((sum([a,b,c,d,max(e,f)])-min([a,b,c,d])))", "generated_code": "print((sum(sorted(int(eval(input())) for _ in range(4))[1:])+max([int(eval(input())) for _ in range(2)])))", "score": 1.0, "codebleu": 0.2242737827628642, "crystalbleu": 0.23837482432405213, "codebertscore": 0.82, "codescore": 0.018560005351901054, "surfaceSim": 0.49947589098532497, "abs_surfaceSim_minus_score": 0.500524109014675}
{"golden_code": "from collections import Counter\n\n\n\nN = int(eval(input()))\n\ninputs = [int(i) for i in input().split()]\n\n\n\nans = 0\n\nruisekiwa = [0] * (N+1)\n\n\n\nfor i in range(N):\n\n    ruisekiwa[i+1] = ruisekiwa[i] + inputs[i]\n\n\n\nruisekiwa = ruisekiwa[1:]\n\nruisekiwa.sort()\n\ncounter_ruiseki = Counter(ruisekiwa)\n\n\n\nfor key, value in list(counter_ruiseki.items()):\n\n    if key == 0 and value == 1:\n\n        ans += value\n\n        continue\n\n    elif key == 0 and value > 1:\n\n        ans += value\n\n    if value > 1:\n\n        ans += sum(list(range(value)))\n\n\n\nprint(ans)\n", "generated_code": "from collections import Counter\n\nfrom itertools import accumulate\n\n\n\nN = int(eval(input()))\n\ninputs = [int(i) for i in input().split()]\n\n\n\nans = 0\n\n\n\nruisekiwa = list(accumulate(inputs))\n\nruisekiwa.sort()\n\ncounter_ruiseki = Counter(ruisekiwa)\n\n\n\nfor key, value in list(counter_ruiseki.items()):\n\n    if key == 0 and value == 1:\n\n        ans += value\n\n        continue\n\n    elif key == 0 and value > 1:\n\n        ans += value\n\n    if value > 1:\n\n        ans += sum(list(range(value)))\n\n\n\nprint(ans)\n", "score": 1.0, "codebleu": 0.6536245096727219, "crystalbleu": 0.6488632351815146, "codebertscore": 0.93, "codescore": 0.8307944536209106, "surfaceSim": 0.802930402930403, "abs_surfaceSim_minus_score": 0.19706959706959704}
{"golden_code": "a,b=list(map(int,input().split()))\n\nans=0\n\nfor i in range(b+1)[a:]:\n\n  if len(str(i))%2==0:\n\n    p=list(str(i))[:len(str(i))//2]\n\n    q=list(reversed(list(str(i))[len(str(i))//2:]))\n\n    if p==q:\n\n      ans+=1\n\n  else:\n\n    s=list(str(i))[:len(str(i))//2+1]\n\n    d=list(reversed(list(str(i))[len(str(i))//2:]))\n\n    if s==d:\n\n      ans += 1\n\nprint(ans)", "generated_code": "a,s=list(map(int,input().split()))\n\nad=0\n\nfor i in range(a,s+1):\n\n  if str(i)==str(i)[::-1]:ad+=1\n\nprint(ad)", "score": 1.0, "codebleu": 0.17924908043559806, "crystalbleu": 0.07283660928949401, "codebertscore": 0.82, "codescore": 0.7763159871101379, "surfaceSim": 0.6246912055335969, "abs_surfaceSim_minus_score": 0.3753087944664031}
{"golden_code": "#!/usr/bin/env python3\n\ndef main():\n\n    import numpy as np\n\n\n\n    np.set_printoptions(linewidth=200)\n\n\n\n    N, W = list(map(int, input().split()))\n\n    lst = [list(map(int, input().split())) for _ in range(N)]\n\n    v_max = 10 ** 3 * 100 * 10\n\n    w_max = 10 ** 9 * v_max\n\n\n\n    # i以上の価値を持つときの最小重量\n\n    dp = np.full(v_max, w_max, dtype=np.int64)\n\n    # initialize\n\n    dp[0] = 0\n\n\n\n    for n in range(N):\n\n        w, v = lst[n]\n\n        dp[v:] = np.minimum(dp[v:], dp[:-v] + w)\n\n\n\n    ans = 0\n\n    for i, w in enumerate(dp):\n\n        if w <= W:\n\n            ans = i\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "generated_code": "#!/usr/bin/env python3\n\ndef main():\n\n    import numpy as np\n\n\n\n    N, W = list(map(int, input().split()))\n\n    lst = [list(map(int, input().split())) for _ in range(N)]\n\n    v_max = 10 ** 3 * 100 * 10\n\n    w_max = 10 ** 9 * v_max\n\n\n\n    # i以上の価値を持つときの最小重量\n\n    dp = np.full(v_max, w_max, dtype=np.int64)\n\n    # initialize\n\n    dp[0] = 0\n\n\n\n    for w, v in lst:\n\n        dp[v:] = np.minimum(dp[v:], dp[:-v] + w)\n\n\n\n    print((np.asarray(dp <= W).nonzero()[0].max()))\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 1.0, "codebleu": 0.7189057468667899, "crystalbleu": 0.7204244793230812, "codebertscore": 0.94, "codescore": 0.0185768473893404, "surfaceSim": 0.9217252396166133, "abs_surfaceSim_minus_score": 0.07827476038338665}
{"golden_code": "n = int(eval(input()))\n\n\n\nXY = []\n\nfor i in range(n):\n\n    a = int(eval(input()))\n\n    xy = []\n\n    for j in range(a):\n\n        xy.append(list(map(int, input().split())))\n\n    \n\n    XY.append(xy)\n\n    \n\ndef check(i, xiyj, HoU):\n\n    # 矛盾したらFalse 正直者と仮定した証言より 正直&正直者と仮定されている / 不親切&不親切と仮定されている True\n\n    if ((i >> xiyj) & 1) ^ HoU:\n\n        return False\n\n\n\n    return True\n\n    \n\nmax_honest = 0\n\nfor i in range(2 ** len(XY)):\n\n    count = 0\n\n    is_contradiction = True\n\n    for j in range(len(XY)):\n\n        # 正直者と仮定したときだけ採用\n\n        if not ((i >> j) & 1): continue\n\n        for k in range(len(XY[j])):\n\n            xiyj = XY[j][k][0] - 1\n\n            HoU = XY[j][k][1]\n\n            \n\n            if not check(i, xiyj, HoU):\n\n                is_contradiction = False\n\n                break\n\n                \n\n        if not is_contradiction:\n\n            break\n\n\n\n    if is_contradiction:\n\n        for j in range(len(XY)):\n\n            if ((i >> j) & 1): count+=1 \n\n                \n\n        if count > max_honest:\n\n            max_honest =count\n\n            \n\nprint(max_honest)", "generated_code": "n = int(eval(input()))\n\n\n\nXY = []\n\nfor i in range(n):\n\n    a = int(eval(input()))\n\n    xy = []\n\n    for j in range(a):\n\n        xy.append(list(map(int, input().split())))\n\n    \n\n    XY.append(xy)\n\n\n\n\"\"\"\n\n    矛盾したらFalse\n\n    矛盾しなければTrue\n\n    正直者と仮定した者の証言\n\n        正直&正直者と仮定されている\n\n        不親切&不親切と仮定されている\n\n\"\"\"\n\ndef check(i, xiyj, HoU):\n\n    # XOR\n\n    if HoU ^ ((i >> xiyj) & 1):\n\n        return False\n\n\n\n    return True\n\n\n\nmax_honest = 0\n\nfor i in range(2 ** len(XY)):\n\n    count = 0\n\n    is_contradiction = True\n\n    for j in range(len(XY)):\n\n        # 正直者と仮定したときだけ採用\n\n        if not ((i >> j) & 1): continue\n\n        count+=1\n\n        for k in range(len(XY[j])):\n\n            xiyj = XY[j][k][0] - 1\n\n            HoU = XY[j][k][1]\n\n            \n\n            if not check(i, xiyj, HoU):\n\n                is_contradiction = False\n\n                break # TLE対策\n\n                \n\n        if not is_contradiction:\n\n            break # TLE対策\n\n\n\n    # 矛盾がなく、正直者の数が更新できれば更新\n\n    if is_contradiction and (count > max_honest):\n\n        max_honest =count\n\n            \n\nprint(max_honest)", "score": 1.0, "codebleu": 0.7841640852458953, "crystalbleu": 0.8390116633223501, "codebertscore": 0.94, "codescore": 0.9937263131141663, "surfaceSim": 0.9042617046818727, "abs_surfaceSim_minus_score": 0.09573829531812728}
{"golden_code": "N, D = list(map(int, input().split()))\n\ncnt = 0\n\nfor _ in range(N):\n\n    x, y = list(map(int, input().split()))\n\n    if x ** 2 + y ** 2 <= D ** 2:\n\n        cnt += 1\n\n        \n\nprint(cnt)", "generated_code": "N, D = list(map(int, input().split()))\n\ncnt = 0\n\nfor _ in range(N):\n\n    x, y = list(map(int, input().split()))\n\n    if x * x + y * y <= D * D:\n\n        cnt += 1\n\n        \n\nprint(cnt)", "score": 1.0, "codebleu": 0.7862404220058002, "crystalbleu": 0.8164474750850377, "codebertscore": 0.96, "codescore": 0.7886140942573547, "surfaceSim": 0.9312393887945671, "abs_surfaceSim_minus_score": 0.06876061120543286}
{"golden_code": "import sys\n\nfrom operator import itemgetter\n\n\n\nn, m = list(map(int, input().split()))\n\na = list(map(int, sys.stdin.readline().split()))\n\nbc = [ tuple(map(int, x.split())) for x in sys.stdin.readlines()]\n\nbc.sort(key = itemgetter(1), reverse=True)\n\nbc.append((n,0))\n\ndiff = []\n\nfor b, c in bc:\n\n    diff += [c] * b\n\n    if len(diff) > n:\n\n        break\n\n\n\na += diff\n\na.sort()\n\nprint((sum(a[-n:])))\n", "generated_code": "import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nfrom operator import itemgetter\n\n\n\nn, m = list(map(int, readline().split()))\n\na = list(map(int, readline().split()))\n\nm = list(map(int, read().split()))\n\nbc = list(zip(m,m))\n\n\n\nbc.sort(key = itemgetter(1), reverse=True)\n\nbc.append((n,0))\n\ndiff = []\n\nfor b, c in bc:\n\n    diff += [c] * b\n\n    if len(diff) > n:\n\n        break\n\n\n\na += diff\n\na.sort()\n\nprint((sum(a[-n:])))\n", "score": 1.0, "codebleu": 0.6746588487469303, "crystalbleu": 0.7449297660627612, "codebertscore": 0.94, "codescore": 0.751248300075531, "surfaceSim": 0.8344444444444444, "abs_surfaceSim_minus_score": 0.16555555555555557}
{"golden_code": "from fractions import gcd\n\n\n\nn,m=list(map(int,input().split()))\n\na=list(map(int,input().split()))\n\na=list(set(a))\n\n\n\na=list([x//2 for x in a])\n\n\n\ndef lcm(q):\n\n  x = q[0]\n\n  for i in range(1, len(q)):\n\n    x = (x * q[i]) // gcd(x, q[i])\n\n  return x\n\n\n\nlcma=lcm(a)\n\n\n\nif (lcma//a[0])%2==0:\n\n  print((0))\n\nelse:\n\n  flg=0\n\n  for i in range(1,len(a)):\n\n    if (lcma//a[i])%2==0:\n\n      print((0))\n\n      flg=1\n\n      break\n\n  if flg==0:\n\n    temp=m//lcma\n\n    print((temp//2 if temp%2==0 else temp//2+1))", "generated_code": "from math import gcd\n\nn,m=list(map(int,input().split()))\n\na=list(map(int,input().split()))\n\na=list(set(a))\n\na=list([x//2 for x in a])\n\n\n\ndef lcm(q):\n\n  x = q[0]\n\n  for i in range(1, len(q)):\n\n    x = (x * q[i]) // gcd(x, q[i])\n\n  return x\n\n\n\nlcma=lcm(a)\n\nfor i in range(len(a)):\n\n  if (lcma//a[i])%2==0:\n\n    print((0))\n\n    exit()\n\ntemp=m//lcma\n\nprint((temp//2 if temp%2==0 else temp//2+1))", "score": 1.0, "codebleu": 0.7667790229313646, "crystalbleu": 0.77239021698609, "codebertscore": 0.96, "codescore": 0.9583017230033875, "surfaceSim": 0.9117266791647811, "abs_surfaceSim_minus_score": 0.08827332083521888}
{"golden_code": "s=eval(input())\n\nt=eval(input())\n\ns*=2\n\nnext=[[-1]*26 for _ in range(len(s))]\n\nalph=[[]for _ in range(26)]\n\nfor i in range(len(s)):\n\n\talph[ord(s[i])-ord(\"a\")].append(i)\n\nfrom bisect import bisect_right\n\nfor i in range(len(s)//2):\n\n\tfor j in range(26):\n\n\t\tif len(alph[j])>bisect_right(alph[j],i):\n\n\t\t\tnext[i][j]=alph[j][bisect_right(alph[j],i)]\n\nans=1\n\nnow=len(s)//2-1\n\nfor x in t:\n\n\tr=ord(x)-ord(\"a\")\n\n\tnow=next[now][r]\n\n\tif now==-1:\n\n\t\tprint((-1))\n\n\t\texit()\n\n\tif now>=len(s)//2:\n\n\t\tans+=len(s)//2\n\n\t\tnow-=len(s)//2\n\nprint((ans+now-len(s)//2))", "generated_code": "#O(|S|log|s|)\n\ndef main():\n\n\ts=eval(input())\n\n\tt=eval(input())\n\n\tn=len(s)\n\n\tnow=-1\n\n\tans=1\n\n\tif not set(t)<=set(s):#tがsの部分集合でない\n\n\t\tprint((-1))\n\n\t\texit()\n\n\tfor x in t:\n\n\t\tnow=s.find(x,now+1)#nowより大きいところからxを探す\n\n\t\tif now==-1:#nowより大きいところでxが見つからなかったら\n\n\t\t\tans+=n\n\n\t\t\tnow=s.find(x)\n\n\tprint((ans+now))\n\nif __name__ == '__main__':\n\n\tmain()", "score": 1.0, "codebleu": 0.16404167581080745, "crystalbleu": 0.0966474554057038, "codebertscore": 0.74, "codescore": 0.027967914938926697, "surfaceSim": 0.4332141696457589, "abs_surfaceSim_minus_score": 0.5667858303542411}
{"golden_code": "a,b = list(map(int,input().split()))\n\nanswer = 0\n\nfor i in range(a,b+1) :\n\n    j = str(i)\n\n    p1 = j[4]\n\n    p2 = j[3]\n\n    p3 = j[2]\n\n    p4 = j[1]\n\n    p5 = j[0]\n\n    k = int(p1+p2+p3+p4+p5)\n\n    if i == k :\n\n        answer += 1\n\nprint(answer)\n\n\n", "generated_code": "A,B = list(map(int,input().split()))\n\nans = 0\n\nfor i in range(A,B+1) :\n\n    l = str(i)\n\n    if l[0] == l[4] and l[1] == l[3] :\n\n        ans += 1\n\nprint(ans)\n", "score": 1.0, "codebleu": 0.3398676706155547, "crystalbleu": 0.0, "codebertscore": 0.87, "codescore": 0.8875080347061157, "surfaceSim": 0.8118187033849684, "abs_surfaceSim_minus_score": 0.18818129661503158}
{"golden_code": "'''\n\n    Auther: ghoshashis545 Ashis Ghosh\n\n    College: jalpaiguri Govt Enggineering College\n\n\n\n'''\n\nfrom os import path\n\nimport sys\n\nfrom functools import cmp_to_key as ctk\n\nfrom collections import deque,defaultdict as dd \n\nfrom bisect import bisect,bisect_left,bisect_right,insort,insort_left,insort_right\n\nfrom itertools import permutations\n\nfrom datetime import datetime\n\nfrom math import ceil,sqrt,log,gcd\n\ndef ii():return int(eval(input()))\n\ndef si():return eval(input())\n\ndef mi():return list(map(int,input().split()))\n\ndef li():return list(mi())\n\nabc='abcdefghijklmnopqrstuvwxyz'\n\nmod=1000000007\n\n#mod=998244353\n\ninf = float(\"inf\")\n\nvow=['a','e','i','o','u']\n\ndx,dy=[-1,1,0,0],[0,0,1,-1]\n\n\n\ndef bo(i):\n\n    return ord(i)-ord('a')\n\n\n\nfile = 0\n\n\n\ndef solve():\n\n    \n\n\n\n\n\n\n\n    # for _ in range(ii()):\n\n\n\n    n=ii()\n\n    n%=1000\n\n    if n!=0:\n\n        n=1000-n\n\n    print(n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nif __name__ ==\"__main__\":\n\n\n\n    if(file):\n\n\n\n        if path.exists('input1.txt'):\n\n            sys.stdin=open('input1.txt', 'r')\n\n            sys.stdout=open('output1.txt','w')\n\n        else:\n\n            input=sys.stdin.readline\n\n    solve()", "generated_code": "'''\n\n    Auther: ghoshashis545 Ashis Ghosh\n\n    College: jalpaiguri Govt Enggineering College\n\n\n\n'''\n\nfrom os import path\n\nimport sys\n\nfrom heapq import heappush,heappop\n\nfrom functools import cmp_to_key as ctk\n\nfrom collections import deque,defaultdict as dd \n\nfrom bisect import bisect,bisect_left,bisect_right,insort,insort_left,insort_right\n\nfrom itertools import permutations\n\nfrom datetime import datetime\n\nfrom math import ceil,sqrt,log,gcd\n\ndef ii():return int(eval(input()))\n\ndef si():return eval(input())\n\ndef mi():return list(map(int,input().split()))\n\ndef li():return list(mi())\n\nabc='abcdefghijklmnopqrstuvwxyz'\n\nmod=1000000007\n\n# mod=998244353\n\ninf = float(\"inf\")\n\nvow=['a','e','i','o','u']\n\ndx,dy=[-1,1,0,0],[0,0,1,-1]\n\n\n\ndef bo(i):\n\n    return ord(i)-ord('a')\n\n\n\nfile=0\n\n\n\n\n\n\n\n\n\n\n\ndef solve():\n\n\n\n\n\n    # for _ in range(ii()):\n\n    \n\n        \n\n\n\n    n=ii()\n\n    n%=1000\n\n    if(n!=0):\n\n        n=1000-n\n\n    print(n)\n\n \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n        \n\nif __name__ ==\"__main__\":\n\n\n\n    if(file):\n\n\n\n        if path.exists('input1.txt'):\n\n            sys.stdin=open('input1.txt', 'r')\n\n            sys.stdout=open('output1.txt','w')\n\n        else:\n\n            input=sys.stdin.readline\n\n    solve()\n", "score": 1.0, "codebleu": 0.9305926241207527, "crystalbleu": 0.9540105209643884, "codebertscore": 0.98, "codescore": 0.9937347769737244, "surfaceSim": 0.9859271523178808, "abs_surfaceSim_minus_score": 0.01407284768211925}
{"golden_code": "import numpy as np\n\nn,d=list(map(int,input().split()))\n\nnda=np.empty((0,d),int)\n\nans=0\n\nfor i in range(0,n):\n\n  a=np.array([list(map(int,input().split()))])\n\n  for j in range(i):\n\n    chklen=np.linalg.norm(a-nda[j])\n\n    if chklen==chklen//1:\n\n      ans+=1\n\n  nda=np.append(nda,a,axis=0)\n\nprint(ans)", "generated_code": "import math\n\nn,d=list(map(int,input().split()))\n\na=[0]*n\n\nfor i in range(n):\n\n  a[i]=list(map(int,input().split()))\n\nans=0\n\nfor i in range(n-1):\n\n  for j in range(i+1,n):\n\n    chklen=0\n\n    wk=0\n\n    for k in range(d):\n\n      wk+=abs(a[i][k]-a[j][k])**2\n\n    chklen=math.sqrt(wk)\n\n    if chklen==chklen//1:\n\n      ans+=1\n\nprint(ans)", "score": 1.0, "codebleu": 0.37263528653265, "crystalbleu": 0.3451581777582674, "codebertscore": 0.87, "codescore": 0.8697132468223572, "surfaceSim": 0.715528781793842, "abs_surfaceSim_minus_score": 0.28447121820615795}
{"golden_code": "import math\n\nn=int(eval(input()))\n\nans=n\n\ni=1\n\nwhile(i<=math.sqrt(n)):\n\n    if n%i==0:\n\n        d=i+n/i-2\n\n        ans=min(ans,d)\n\n    i+=1\n\nprint((int(ans)))", "generated_code": "from math import floor\n\nfrom math import sqrt\n\nn=int(eval(input()))\n\nnn=floor(sqrt(n))\n\nrest=n%nn\n\nwhile rest!=0:\n\n    nn-=1\n\n    rest=n%nn\n\nnnn=n/nn\n\nprint((int(nn+nnn-2)))", "score": 1.0, "codebleu": 0.2189753588334301, "crystalbleu": 0.0, "codebertscore": 0.84, "codescore": 0.6720970273017883, "surfaceSim": 0.5796001926782274, "abs_surfaceSim_minus_score": 0.4203998073217726}
{"golden_code": "N, M = (int(x) for x in input().split())\n\nedge = [tuple(int(x) for x in input().split()) for _ in range(M)]\n\n\n\nimport numpy as np\n\nfrom scipy.sparse.csgraph import floyd_warshall\n\nINF = 100\n\ntmpl_graph = [[INF if i != j else 0 for j in range(N)] for i in range(N)]\n\n\n\nans = 0\n\nfor E in edge:\n\n    edgeWithoutE = edge.copy()\n\n    edgeWithoutE.remove(E)\n\n    graph = np.array(tmpl_graph)\n\n    for x in edgeWithoutE:\n\n        graph[x[0]-1,x[1]-1] = 1\n\n        graph[x[1]-1,x[0]-1] = 1\n\n    graph = floyd_warshall(graph,directed=False)\n\n    if len(graph[graph == 100]) > 0:\n\n        ans += 1\n\nprint(ans)", "generated_code": "\n\nclass node:\n\n    def __init__(self, id):\n\n        self.id = id\n\n        self.root = self\n\n\n\n    def findRoot(self):\n\n        if self == self.root:\n\n            return self\n\n        else:\n\n            self.root = self.root.findRoot()\n\n            return self.root\n\n\n\n    def resetRoot(self):\n\n        self.root = self\n\n\n\nclass Tree:\n\n    def __init__(self, num):\n\n        self.nodes = {i:node(i) for i in range(num)}\n\n\n\n    def union(self, one, other):\n\n        root1 = one.findRoot()\n\n        root2 = other.findRoot()\n\n        root1.root = root2.root = self.nodes[min(root1.id, root2.id)]\n\n\n\n    def resetTree(self):\n\n        for n in list(self.nodes.values()):\n\n            n.resetRoot()\n\n\n\n    def makeTree(self, Edge):\n\n        self.edge = Edge\n\n        for x,y in Edge:\n\n            self.union(self.nodes[x-1], self.nodes[y-1])\n\n\n\n\n\ndef main():\n\n    with open(0) as f:\n\n        N, M = list(map(int, f.readline().split()))\n\n        Edge = [tuple(map(int, line.split())) for line in f.readlines()]\n\n    \n\n    tree = Tree(N)\n\n    ans = 0\n\n    for i in range(M):\n\n        edge = [v for  v in Edge if v != Edge[i]]\n\n        tree.makeTree(edge)\n\n        if any(x.findRoot().id != 0 for x in list(tree.nodes.values())):\n\n            ans += 1\n\n        tree.resetTree()\n\n    print(ans)\n\n\n\nif __name__ == '__main__':\n\n    main()", "score": 1.0, "codebleu": 0.25543156992904126, "crystalbleu": 0.09746240221919772, "codebertscore": 0.72, "codescore": 0.019772375002503395, "surfaceSim": 0.5431308634123072, "abs_surfaceSim_minus_score": 0.4568691365876928}
{"golden_code": "s = eval(input())\n\ncnt = 0\n\nfor i in range(len(s) - 1):\n\n    if s[i] == 'W' and s[i + 1] == 'B':\n\n        cnt += 1\n\n    if s[i] == 'B' and s[i + 1] == 'W':\n\n        cnt += 1\n\nprint(cnt)", "generated_code": "S = eval(input())\n\n\n\ntmp = S[0]\n\ncnt = 0\n\nfor s in S[1:]:\n\n    if tmp != s:\n\n        cnt += 1\n\n        tmp = s\n\n        \n\nprint(cnt)", "score": 1.0, "codebleu": 0.2363315607236966, "crystalbleu": 0.0, "codebertscore": 0.85, "codescore": 0.2447439581155777, "surfaceSim": 0.6300982800982801, "abs_surfaceSim_minus_score": 0.36990171990171994}
{"golden_code": "S=eval(input())\n\nprint((S.rfind('Z')-S.find('A')+1))", "generated_code": "s=input().strip()\n\na = s.find('A')\n\nz = s.rfind('Z')\n\nprint((z-a+1))\n", "score": 1.0, "codebleu": 0.36904761904761907, "crystalbleu": 0.0, "codebertscore": 0.9, "codescore": 0.3145138919353485, "surfaceSim": 0.7463768115942029, "abs_surfaceSim_minus_score": 0.2536231884057971}
{"golden_code": "import sys\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\nreadlines = sys.stdin.readlines\n\n\n\nMOD = 10**9+7\n\n\n\nfac = [1, 1]     # 元テーブル\n\nf_inv = [1, 1]   # 逆元テーブル\n\ninv = [0, 1]     # 逆元テーブル計算用テーブル\n\ndef prepare(n, mod):\n\n    for i in range(2, n+1):\n\n        fac.append((fac[-1] * i) % mod)\n\n        inv.append((-inv[mod % i] * (mod//i)) % mod)\n\n        f_inv.append((f_inv[-1] * inv[-1]) % mod)\n\n\n\n\n\ndef cmb(n, r, mod):\n\n    if n < 0 or r < 0:\n\n        return 0\n\n    if r > n:\n\n        return 0\n\n\n\n    return fac[n] * f_inv[r] * f_inv[n-r] % mod\n\n\n\n\n\ndef prime_factorization(n):\n\n    d = []\n\n    i, e = 2, 0  # factor, exponent\n\n    while i * i <= n:\n\n        while n % i == 0:\n\n            n //= i\n\n            e += 1\n\n        if e > 0:\n\n            d.append((i, e))\n\n        i += 1\n\n        e = 0\n\n    if n > 1:\n\n        d.append((n, 1))\n\n    return d\n\n\n\n\n\ndef main():\n\n    N,M = list(map(int, readline().split()))\n\n\n\n    prepare(N+100, MOD)\n\n    d = prime_factorization(M)\n\n\n\n    ans = 1\n\n    for i, e in d:\n\n        ans *= cmb(N-1+e, e, MOD)\n\n        ans %= MOD\n\n\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "generated_code": "import sys\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\nreadlines = sys.stdin.readlines\n\n\n\nMOD = 10**9+7\n\n\n\nfac = [1, 1]     # 元テーブル\n\nf_inv = [1, 1]   # 逆元テーブル\n\ninv = [0, 1]     # 逆元テーブル計算用テーブル\n\ndef prepare(n, mod):\n\n    for i in range(2, n+1):\n\n        fac.append((fac[-1] * i) % mod)\n\n\n\n\n\ndef cmb(n, r, mod):\n\n    if n < 0 or r < 0:\n\n        return 0\n\n    if r > n:\n\n        return 0\n\n\n\n    return fac[n] * pow(fac[r],MOD-2,MOD) * pow(fac[n-r],MOD-2,MOD) % mod\n\n\n\n\n\ndef prime_factorization(n):\n\n    d = []\n\n    i, e = 2, 0  # factor, exponent\n\n    while i * i <= n:\n\n        while n % i == 0:\n\n            n //= i\n\n            e += 1\n\n        if e > 0:\n\n            d.append((i, e))\n\n        i += 1\n\n        e = 0\n\n    if n > 1:\n\n        d.append((n, 1))\n\n    return d\n\n\n\n\n\ndef main():\n\n    N,M = list(map(int, readline().split()))\n\n\n\n    prepare(N+100, MOD)\n\n    d = prime_factorization(M)\n\n\n\n    ans = 1\n\n    for i, e in d:\n\n        ans *= cmb(N-1+e, e, MOD)\n\n        ans %= MOD\n\n\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "score": 1.0, "codebleu": 0.8484003440661956, "crystalbleu": 0.8550348510426558, "codebertscore": 0.96, "codescore": 0.9921115636825562, "surfaceSim": 0.9501763668430335, "abs_surfaceSim_minus_score": 0.049823633156966474}
{"golden_code": "import sys\n\nsys.setrecursionlimit(10**6)\n\nif sys.platform in (['ios','darwin','win32']):\n\n\tsys.stdin=open('Untitled.txt')\n\ninput = sys.stdin.readline\n\ndef INT(): return int(eval(input()))\n\ndef MAP(): return [int(s) for s in input().split()]\n\n\n\ndef main():\n\n\tS = input().rstrip()\n\n\tbcnt = 0\n\n\tA = []\n\n\tfor i in range(len(S)):\n\n\t\tif S[i] == 'B': bcnt += 1\n\n\t\tif S[i] == 'W': A.append(bcnt)\n\n\t\n\n\tprint((sum(A)))\n\n\n\nif __name__ == '__main__':\n\n\tmain()", "generated_code": "import sys\n\nsys.setrecursionlimit(10**6)\n\nif sys.platform in (['ios','darwin','win32']):\n\n\tsys.stdin=open('Untitled.txt')\n\ninput = sys.stdin.readline\n\ndef INT(): return int(eval(input()))\n\ndef MAP(): return [int(s) for s in input().split()]\n\n\n\ndef main():\n\n\tS = input().rstrip()\n\n\tbcnt = 0\n\n\tans = 0\n\n\tfor i in range(len(S)):\n\n\t\tif S[i] == 'B': bcnt += 1\n\n\t\tif S[i] == 'W': ans += bcnt\n\n\t\n\n\tprint(ans)\n\n\n\nif __name__ == '__main__':\n\n\tmain()", "score": 1.0, "codebleu": 0.8793562825711243, "crystalbleu": 0.8392446988441843, "codebertscore": 0.98, "codescore": 0.026967214420437813, "surfaceSim": 0.9753914988814318, "abs_surfaceSim_minus_score": 0.02460850111856816}
{"golden_code": "a, b = list(map(int, input().split()))\n\ncnt = 0\n\nfor x in range(a, b + 1):\n\n    s = str(x)\n\n    l = len(s)\n\n    flg = True\n\n    for i in range(l // 2):\n\n        if s[i] != s[l - 1 - i]:\n\n            flg = False\n\n            break\n\n    if flg:\n\n        cnt += 1\n\nprint(cnt)\n", "generated_code": "a, b = list(map(int, input().split()))\n\ncnt = 0\n\nfor i in range(a, b + 1):\n\n    s = str(i)\n\n    if s[0] == s[4] and s[1] == s[3]:\n\n        cnt += 1\n\nprint(cnt)", "score": 1.0, "codebleu": 0.46986410946812696, "crystalbleu": 0.0, "codebertscore": 0.88, "codescore": 0.8287449479103088, "surfaceSim": 0.7372893772893773, "abs_surfaceSim_minus_score": 0.26271062271062273}
{"golden_code": "a,b,c,x,y=list(map(int,input().split()))\n\n\n\nans=a*x+b*y\n\nfor ci in range(max(x,y)+1):\n\n    sumc = 2*ci*c\n\n    sumc += (x-ci)*a if (x-ci)>0 else 0\n\n    sumc += (y-ci)*b if (y-ci)>0 else 0\n\n    ans=min(ans,sumc)\n\n\n\nprint(ans)", "generated_code": "a,b,c,x,y=list(map(int,input().split()))\n\nans=a*x+b*y\n\nif x==y:\n\n    ans=min(ans,2*x*c)\n\nelif x>y:\n\n    ans=min(ans,a*(x-y)+2*y*c)\n\n    ans=min(ans,2*x*c)\n\nelse:\n\n    ans=min(ans,b*(y-x)+2*x*c)\n\n    ans=min(ans,2*y*c)\n\nprint(ans)", "score": 1.0, "codebleu": 0.29429607913114075, "crystalbleu": 0.4571735917560744, "codebertscore": 0.87, "codescore": 0.09688322246074677, "surfaceSim": 0.6735288001663547, "abs_surfaceSim_minus_score": 0.32647119983364525}
{"golden_code": "ans=[]\n\nfor i in range (0,10):\n\n    ans.append(int(eval(input())))\n\nans.sort(reverse=True)\n\nfor i in range (0,3):\n\n    print((ans[i]))", "generated_code": "mountain=[]\n\nfor s in range(0,10):\n\n    mountain.append(int(eval(input())))\n\nmountain.sort(reverse=True)\n\nfor s in range(0,3):\n\n print((mountain[s]))", "score": 1.0, "codebleu": 0.5113391161922745, "crystalbleu": 0.0, "codebertscore": 0.92, "codescore": 0.9204734563827515, "surfaceSim": 0.8959731543624161, "abs_surfaceSim_minus_score": 0.10402684563758391}
{"golden_code": "#!usr/bin/env python3\n\nfrom collections import defaultdict\n\nfrom collections import deque\n\nfrom heapq import heappush, heappop\n\nimport sys\n\nimport math\n\nimport bisect\n\nimport random\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\n\ndef I(): return int(sys.stdin.readline())\n\ndef LS():return list(map(list, sys.stdin.readline().split()))\n\ndef S(): return list(sys.stdin.readline())[:-1]\n\ndef IR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = I()\n\n    return l\n\ndef LIR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = LI()\n\n    return l\n\ndef SR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = S()\n\n    return l\n\ndef LSR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = SR()\n\n    return l\n\nmod = 1000000007\n\n\n\n#A\n\ndef A():\n\n    s = S()\n\n    t = S()\n\n    if s+t == t[::-1]+s[::-1]:\n\n        print(\"YES\")\n\n    else:\n\n        print(\"NO\")\n\n\n\n#B\n\ndef B():\n\n    n = I()\n\n    for i in range(int(n**0.5)+2)[::-1]:\n\n        if i*i <= n:\n\n            print((i*i))\n\n            quit()\n\n#C\n\ndef C():\n\n    n = I()\n\n    a = LI()\n\n    b = LI()\n\n    c = LI()\n\n    q = [0 for i in range(n)]\n\n    ans = 0\n\n    a.sort()\n\n    b.sort()\n\n    c.sort()\n\n    for i in range(n):\n\n        j = bisect.bisect_left(a,b[i])\n\n        q[i] = j\n\n    for i in range(n-1):\n\n        q[i+1] += q[i]\n\n    q.insert(0,0)\n\n    for i in range(n):\n\n        j = bisect.bisect_left(b,c[i])\n\n        ans += q[j]\n\n    print(ans)\n\n#D\n\ndef D():\n\n    def dijkstra():\n\n        d = [float(\"inf\") for i in range(k)]\n\n        q = [[0,1]]\n\n        d[1] = 0\n\n        while q:\n\n            dx,x = heappop(q)\n\n            for y,dy in v[x]:\n\n                if d[y] > dx+dy:\n\n                    d[y] = dx+dy\n\n                    heappush(q,[d[y],y])\n\n        print((d[0]+1))\n\n    k = I()\n\n    if k == 1:\n\n        print((1))\n\n        quit()\n\n    v = [[] for i in range(k)]\n\n    for i in range(1,k):\n\n        v[i].append([(i+1)%k,1])\n\n        v[i].append([i*10%k,0])\n\n    dijkstra()\n\n#E\n\ndef E():\n\n    return\n\n\n\n#F\n\ndef F():\n\n    return\n\n\n\n#G\n\ndef G():\n\n    return\n\n\n\n#H\n\ndef H():\n\n    return\n\n\n\n#Solve\n\nif __name__ == \"__main__\":\n\n    D()\n", "generated_code": "#!usr/bin/env python3\n\nfrom collections import defaultdict,deque\n\nfrom heapq import heappush, heappop\n\nfrom itertools import permutations\n\nimport sys\n\nimport math\n\nimport bisect\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\n\ndef I(): return int(sys.stdin.readline())\n\ndef LS():return [list(x) for x in sys.stdin.readline().split()]\n\ndef S():\n\n    res = list(sys.stdin.readline())\n\n    if res[-1] == \"\\n\":\n\n        return res[:-1]\n\n    return res\n\ndef IR(n):\n\n    return [I() for i in range(n)]\n\ndef LIR(n):\n\n    return [LI() for i in range(n)]\n\ndef SR(n):\n\n    return [S() for i in range(n)]\n\ndef LSR(n):\n\n    return [LS() for i in range(n)]\n\n\n\nsys.setrecursionlimit(1000000)\n\nmod = 1000000007\n\n\n\ndef solve():\n\n    def v(n):\n\n        return [n*10%k, (n+1)%k]\n\n    k = I()\n\n    d = [float(\"inf\")]*k\n\n    d[1] = 1\n\n    q = deque([1])\n\n    while q:\n\n        x = q.popleft()\n\n        vx = v(x)\n\n        dx = d[x]\n\n        for c in range(2):\n\n            nd = dx+c\n\n            y = vx[c]\n\n            if nd < d[y]:\n\n                d[y] = nd\n\n                if c:\n\n                    q.append(y)\n\n                else:\n\n                    q.appendleft(y)\n\n    print((d[0]))\n\n    return\n\n\n\n#Solve\n\nif __name__ == \"__main__\":\n\n    solve()\n", "score": 1.0, "codebleu": 0.26820744234591787, "crystalbleu": 0.17779582378077483, "codebertscore": 0.87, "codescore": 0.018268177285790443, "surfaceSim": 0.7120391705069125, "abs_surfaceSim_minus_score": 0.28796082949308754}
{"golden_code": "from collections import Counter,defaultdict,deque\n\nimport sys,bisect,math,itertools,string,queue\n\nfrom heapq import heappop, heappush\n\nsys.setrecursionlimit(10**8)\n\nmod = 10**9+7\n\ndef inp(): return int(sys.stdin.readline())\n\ndef inpl(): return list(map(int, sys.stdin.readline().split()))\n\ndef inpl_str(): return list(sys.stdin.readline().split())\n\ndef inpln(n): return list(int(sys.stdin.readline()) for i in range(n))\n\n\n\nn = inp()\n\nres = float('inf')\n\nfor i in range(1,2*10**6):\n\n    if (n/i).is_integer():\n\n        res = min(res, i + n/i)\n\nprint((int(res-2)))\n", "generated_code": "from collections import Counter,defaultdict,deque\n\nimport sys,bisect,math,itertools,string,queue\n\nfrom heapq import heappop, heappush\n\nsys.setrecursionlimit(10**8)\n\nmod = 10**9+7\n\ndef inp(): return int(sys.stdin.readline())\n\ndef inpl(): return list(map(int, sys.stdin.readline().split()))\n\ndef inpl_str(): return list(sys.stdin.readline().split())\n\ndef inpln(n): return list(int(sys.stdin.readline()) for i in range(n))\n\n\n\nn = inp()\n\nres = float('inf')\n\nfor i in range(1,int(math.sqrt(n))+1):\n\n    if n%i == 0:\n\n        res = min(res, i + n/i)\n\nprint((int(res-2)))\n", "score": 1.0, "codebleu": 0.8316966909881458, "crystalbleu": 0.8724485591152905, "codebertscore": 0.98, "codescore": 0.7163516283035278, "surfaceSim": 0.9062557216966738, "abs_surfaceSim_minus_score": 0.09374427830332621}
{"golden_code": "a, b, c = list(map(int, input().split()))\n\n\n\nif any(i % 2 != 0 for i in [a, b, c]):\n\n    print((0))\n\n    exit()\n\n\n\nif a == b and b == c:\n\n    print((-1))\n\n    exit()\n\n\n\ncnt = 0\n\na_list = [0]*(1001001)\n\nb_list = [0]*(1001001)\n\nc_list = [0]*(1001001)\n\na_list[0] = a\n\nb_list[0] = b\n\nc_list[0] = c\n\n\n\nfor i in range(1, 1001001):\n\n    a_list[i] = (b_list[i-1] + c_list[i-1]) // 2\n\n    b_list[i] = (c_list[i-1] + a_list[i-1]) // 2\n\n    c_list[i] = (a_list[i-1] + b_list[i-1]) // 2\n\n    cnt += 1\n\n    if a_list[i] % 2 != 0 or b_list[i] % 2 != 0 or c_list[i] % 2 != 0:\n\n        break\n\n\n\nprint(cnt)\n", "generated_code": "def solve(a, b, c):\n\n    if any(i % 2 == 1 for i in [a, b, c]):\n\n        return 0\n\n    if a == b == c:\n\n        return -1\n\n    a, b, c = (b + c) // 2, (c + a) // 2, (a + b) // 2\n\n    return solve(a, b, c) + 1\n\n\n\na, b, c = list(map(int, input().split()))\n\n\n\nprint((solve(a, b, c)))", "score": 1.0, "codebleu": 0.15400460313297867, "crystalbleu": 0.15854004087451617, "codebertscore": 0.8, "codescore": 0.16469670832157135, "surfaceSim": 0.510009161704077, "abs_surfaceSim_minus_score": 0.48999083829592305}
{"golden_code": "X = int(eval(input()))\n\n\n\ngojyous = []\n\n\n\nfor i in range(-200, 201):\n\n    gojyous.append(i ** 5)\n\n\n\n#print(gojyous)\n\n\n\nfor i in range(-200,201):\n\n    for j in range(-200,201):\n\n        if(X == (int(i**5) - int(j**5))):\n\n            print((i, j))\n\n            exit()", "generated_code": "import sys\n\n\n\nX= int(eval(input()))\n\n\n\n#添字の最大値を算出\n\n\n\na = 1\n\nb = 0\n\ndif = 0\n\nwhile dif < 10**9:\n\n    a += 1\n\n    b += 1\n\n\n\n    dif = a ** 5 - b ** 5\n\n\n\nloop_sequence = a - 1\n\n\n\nfor i in range(-(loop_sequence),loop_sequence):\n\n\tfor j in range(-(loop_sequence),loop_sequence):\n\n\t\tif(X == i ** 5 - j ** 5):\n\n\t\t\tprint((i,j))\n\n\t\t\tsys.exit()\n", "score": 1.0, "codebleu": 0.2175958682666842, "crystalbleu": 0.30489374924094087, "codebertscore": 0.77, "codescore": 0.9753813147544861, "surfaceSim": 0.6444890929965557, "abs_surfaceSim_minus_score": 0.35551090700344434}
{"golden_code": "from collections import Counter\n\n\n\ns = eval(input())\n\nmod1 = 673\n\nmod2 = 3\n\n\n\nnum1 = 0\n\nnum2 = 0\n\nli1 = []\n\nli2 = []\n\npw1 = 10\n\npw2 = 10\n\nfor i, e in enumerate(s, 1):\n\n    num1 *= 10\n\n    num1 += int(e)\n\n    num1 %= mod1\n\n    inv = pow(pw1, mod1 - 2, mod1)\n\n    li1.append(num1 * inv % mod1)\n\n\n\n    num2 *= 10\n\n    num2 += int(e)\n\n    num2 %= mod2\n\n    inv = pow(pw2, mod2 - 2, mod2)\n\n    li2.append(num2 * inv % mod2)\n\n\n\n    pw1 *= 10\n\n    pw1 %= mod1\n\n    pw2 *= 10\n\n    pw2 %= mod2\n\n\n\nli = [0] + [10 * e1 + e2 for e1, e2 in zip(li1, li2)]\n\nc = Counter(li)\n\n\n\nans = 0\n\nfor v in list(c.values()):\n\n    ans += v * (v - 1) // 2\n\n\n\nprint(ans)\n", "generated_code": "from collections import Counter\n\n\n\n\n\ndef f(mod):\n\n    ret = [0]\n\n    power = 1\n\n    num = 0\n\n    for i, e in enumerate(s, 1):\n\n        num *= 10\n\n        num += int(e)\n\n        num %= mod\n\n\n\n        power *= 10\n\n        power %= mod\n\n        inv = pow(power, mod - 2, mod)\n\n\n\n        ret.append(num * inv % mod)\n\n\n\n    return ret\n\n\n\n\n\ns = eval(input())\n\n\n\nmod3 = f(3)\n\nmod673 = f(673)\n\n\n\nli = [10 * e673 + e3 for e3, e673 in zip(mod3, mod673)]\n\n\n\nc = Counter(li)\n\nans = 0\n\nfor v in list(c.values()):\n\n    ans += v * (v - 1) // 2\n\nprint(ans)\n", "score": 1.0, "codebleu": 0.41179884640845144, "crystalbleu": 0.3433536254541418, "codebertscore": 0.85, "codescore": 0.9933962821960449, "surfaceSim": 0.7652394984688277, "abs_surfaceSim_minus_score": 0.23476050153117234}
{"golden_code": "import numpy as np\n\nx = int(eval(input()))\n\ntmp_list=[]\n\nc=0\n\ntmp_2=0\n\nwhile(1):\n\n    tmp_1=c**5\n\n    if (tmp_1 - tmp_2)<=x:\n\n        tmp_list+=[tmp_1]\n\n    else:\n\n        break\n\n    tmp_2=tmp_1\n\n    c+=1\n\n \n\ndef せいがわ(target:list,x) -> list:\n\n    for i in np.flipud(target):\n\n        for j in target:\n\n            tmp=i+j\n\n            if tmp==x:\n\n                return [int(i**(1/5)),int(j**(1/5))*-1]\n\n            if tmp>x:\n\n                break\n\n    return 0\n\n \n\ndef ふがわ(target:list,x) -> list:\n\n    for i in np.flipud(target):\n\n        for j in target:\n\n            tmp=i-j\n\n            if tmp==x:\n\n                return [int(i**(1/5)),int(j**(1/5))]\n\n            if tmp<x:\n\n                break\n\n    return 0\n\n  \n\nans=ふがわ(tmp_list,x)\n\nif ans==0:\n\n    ans=せいがわ(tmp_list,x)\n\nprint((ans[0],ans[1]))", "generated_code": "X = int(eval(input()))\n\nfor a in range(0, 121):\n\n    for b in range(0, 121):\n\n        if X == a**5 - b**5:\n\n            print((a, b))\n\n            exit()\n\n        elif X == a**5 + b**5:\n\n            print((a, -b))\n\n            exit()\n\n        elif X == -a**5 - (10**4 - b)**5:\n\n            print((-a, 10**4 - b))\n\n            exit()", "score": 1.0, "codebleu": 0.06392571621787721, "crystalbleu": 0.030935722016011143, "codebertscore": 0.72, "codescore": 0.2858330011367798, "surfaceSim": 0.4952374541415637, "abs_surfaceSim_minus_score": 0.5047625458584363}
{"golden_code": "n,m,k=list(map(int,input().split()))\n\nmod=10**9+7\n\nf=[1]\n\nfor i in range(2*10**5+7):f+=[f[-1]*(i+1)%mod]\n\ndef comb(a,b):return f[a]*pow(f[b],mod-2,mod)*pow(f[a-b],mod-2,mod)%mod\n\nans=0\n\nfor i in range(1,n):\n\n  ans+=(i*(n-i)*m**2)*(comb(n*m-2,k-2))\n\n  ans%=mod\n\nfor i in range(1,m):\n\n  ans+=(i*(m-i)*n**2)*(comb(n*m-2,k-2))\n\n  ans%=mod\n\nprint(ans)", "generated_code": "n,m,k=list(map(int,input().split()))\n\n\n\nmod = 10**9+7\n\nf = [1]\n\nfor i in range(n*m):\n\n  f += [f[-1]*(i+1) % mod]\n\ndef comb(a, b):\n\n  return f[a]*pow(f[b], mod-2, mod)*pow(f[a-b], mod-2, mod) % mod\n\n\n\nans=0\n\nfor dist in range(1,n):\n\n  c=n-dist\n\n  p=(c*m*m)%mod\n\n  ans+=p*dist\n\nfor dist in range(1,m):\n\n  c=m-dist\n\n  p=(c*n*n)%mod\n\n  ans+=p*dist\n\nans%=mod\n\nprint((ans*comb(n*m-2,k-2)%mod))", "score": 1.0, "codebleu": 0.3629923337355096, "crystalbleu": 0.6369429828703653, "codebertscore": 0.93, "codescore": 0.685187578201294, "surfaceSim": 0.8656330749354005, "abs_surfaceSim_minus_score": 0.13436692506459946}
{"golden_code": "N = int(eval(input()))\n\n\n\nans = 0\n\n\n\nfor i in range(1, N+1):\n\n    if len(str(i))%2==1:\n\n        ans += 1\n\n\n\nprint(ans)", "generated_code": "import sys\n\n\n\n\n\ndef rec(length):\n\n    if length == 1:\n\n        return 9\n\n    else:\n\n        return 9 * 10**(length - 1) + rec(length - 2)\n\n\n\n\n\nn = eval(input())\n\nlength = len(n)\n\n\n\nif length == 1:\n\n    print(n)\n\n    sys.exit()\n\n\n\nif length % 2 == 0:\n\n    ans = rec(length - 1)\n\nelse:\n\n    ans = rec(length - 2) + int(n) - int(\"1\" + \"0\" * (length - 1)) + 1\n\n\n\nprint(ans)", "score": 1.0, "codebleu": 0.20132587096150656, "crystalbleu": 0.08793062274159356, "codebertscore": 0.74, "codescore": 0.11601481586694717, "surfaceSim": 0.49687304565353346, "abs_surfaceSim_minus_score": 0.5031269543464665}
{"golden_code": "import numpy as np\n\nn = int(eval(input()))\n\nvalue = np.array(tuple(map(int, input().split())))\n\ncost = np.array(tuple(map(int, input().split())))\n\nxy = value - cost\n\nans = 0\n\nfor i in range(n):\n\n    if xy[i] < 0:\n\n        continue\n\n    else:\n\n        ans += xy[i]\n\nprint(ans)", "generated_code": "n = int(eval(input()))\n\nvalue = tuple(map(int, input().split()))\n\ncost = tuple(map(int, input().split()))\n\n# iこめまでのxーyの最大値\n\ninf = -100\n\ndp = [inf] * (n+1)\n\ndp[1] = max(0, value[0]-cost[0])\n\nfor i in range(2, n+1):\n\n    dp[i] = max(dp[i-1], dp[i-1]+value[i-1]-cost[i-1])\n\n\n\nprint((dp[n]))\n", "score": 1.0, "codebleu": 0.3133510695625489, "crystalbleu": 0.26600564330399384, "codebertscore": 0.79, "codescore": 0.08265597373247147, "surfaceSim": 0.5679754273504274, "abs_surfaceSim_minus_score": 0.4320245726495726}
{"golden_code": "from functools import reduce\n\nfrom itertools import product\n\n\n\nN = int(eval(input()))\n\n*A, = list(map(int, input().split()))\n\nans = 0\n\nfor t in product([-1, 0, 1], repeat=N):\n\n    prod = reduce(lambda x, y: x*y, [a + t[i] for i, a in enumerate(A)])\n\n    if prod % 2 == 0: ans += 1\n\nprint(ans)", "generated_code": "N = int(eval(input()))\n\n*A, = list(map(int, input().split()))\n\nevens = 0\n\nfor a in A:\n\n    if a % 2 == 0: evens += 1\n\nans = 3**N - 2**evens\n\nprint(ans)", "score": 1.0, "codebleu": 0.3160169837524915, "crystalbleu": 0.0, "codebertscore": 0.82, "codescore": 0.15024729073047638, "surfaceSim": 0.5162915851272015, "abs_surfaceSim_minus_score": 0.4837084148727985}
{"golden_code": "import collections\n\nn = int(eval(input()))\n\na=[eval(input()) for _ in range(n)]\n\nanslist=[]\n\nb=collections.Counter(a)\n\nc=max(list(b.values()))\n\nfor i in b:\n\n    if b[i]==c:\n\n        anslist.append(i)\n\nd=sorted(anslist)\n\nfor i in tuple(d):\n\n    print(i)", "generated_code": "from collections import Counter\n\nn=int(eval(input()))\n\na=[]\n\nfor i in range(n):\n\n  a.append(eval(input()))\n\nac=Counter(a)\n\nacs=sorted(list(ac.items()),key=lambda x:x[1],reverse=1)\n\nz=len(acs)\n\ni=0\n\ntemp=[]\n\n\n\nwhile i<=z-1 and acs[i][1]==acs[0][1] :\n\n  temp.append(acs[i][0])\n\n  i+=1\n\ntemp.sort()\n\nfor i in temp:\n\n  print(i)", "score": 1.0, "codebleu": 0.30860557397212407, "crystalbleu": 0.17307095021309496, "codebertscore": 0.82, "codescore": 0.9563642144203186, "surfaceSim": 0.4486349563748945, "abs_surfaceSim_minus_score": 0.5513650436251055}
{"golden_code": "S = eval(input())\n\nK = int(eval(input()))\n\na = list(set(S))\n\na.sort()\n\n\n\nk = []\n\nl = 0\n\nwhile l < len(a):\n\n    for i in range(len(S)):\n\n        if S[i] == a[l]:\n\n            for j in range(1,6):\n\n                if i+j <= len(S):\n\n                    k.append(S[i:i+j])\n\n                else:\n\n                    break\n\n    l += 1\n\n\n\nk = list(set(k))\n\nk.sort()\n\nprint((k[K-1]))", "generated_code": "S = eval(input())\n\nK = int(eval(input()))\n\na = []\n\nfor i in range(len(S)+1):\n\n    for j in range(1,6):\n\n        if i+j <= len(S):\n\n            a.append(S[i:i+j])\n\n        else:\n\n            break\n\n            \n\na = list(set(a))\n\na.sort()\n\nprint((a[K-1]))", "score": 1.0, "codebleu": 0.47493602372228927, "crystalbleu": 0.5610866423526303, "codebertscore": 0.91, "codescore": 0.860755205154419, "surfaceSim": 0.83005291005291, "abs_surfaceSim_minus_score": 0.16994708994708996}
{"golden_code": "import numpy as np\n\n\n\nN, K = list(map(int, input().split()))\n\nS = eval(input())\n\n\n\nl = [[], []]\n\nans = []\n\nk = [int(s) for s in S]\n\nif k[0] == 0:\n\n    l[1].append(0)\n\nv0 = 1 if k[0] == 0 else 0\n\nv1 = 1 if k[0] == 1 else 0\n\nfor i in range(1, N):\n\n    if (k[i]==0) & (k[i-1]==0):\n\n        v0 += 1\n\n    elif (k[i]==1) & (k[i-1]==0):\n\n        l[0].append(v0)\n\n        v0 = 0\n\n        v1 += 1\n\n    elif (k[i]==0) & (k[i-1]==1):\n\n        l[1].append(v1)\n\n        v0 += 1\n\n        v1 = 0 \n\n    else:\n\n        v1 += 1\n\n        \n\nfor i, v in enumerate([v0, v1]):\n\n    if v > 0:\n\n        l[i].append(v)\n\n        \n\nif k[0] == 0:\n\n    l[1].append(0)\n\n\n\nif len(l[0]) <= K:\n\n    print(N)\n\n\n\nelse:\n\n    l[0].extend(np.repeat(0,K+1))\n\n    l[1].extend(np.repeat(0,K+1))\n\n    a = sum(l[0][:K]) + sum(l[1][:K+1])\n\n    ans.append(a)\n\n    for i in range(1, len(l[0])-K-1):\n\n        a -= l[0][i-1] + l[1][i-1]\n\n        a += l[0][i+K-1] + l[1][i+K]\n\n        ans.append(a)\n\n    print((max(ans)))", "generated_code": "N, K = list(map(int, input().split()))\n\nS = eval(input())\n\n \n\nl = [[], []]\n\nans = []\n\nk = [int(s) for s in S]\n\nif k[0] == 0:\n\n    l[1].append(0)\n\nv0 = 1 if k[0] == 0 else 0\n\nv1 = 1 if k[0] == 1 else 0\n\nfor i in range(1, N):\n\n    if (k[i]==0) & (k[i-1]==0):\n\n        v0 += 1\n\n    elif (k[i]==1) & (k[i-1]==0):\n\n        l[0].append(v0)\n\n        v0 = 0\n\n        v1 += 1\n\n    elif (k[i]==0) & (k[i-1]==1):\n\n        l[1].append(v1)\n\n        v0 += 1\n\n        v1 = 0 \n\n    else:\n\n        v1 += 1\n\n        \n\nfor i, v in enumerate([v0, v1]):\n\n    if v > 0:\n\n        l[i].append(v)\n\n        \n\nif k[0] == 0:\n\n    l[1].append(0)\n\n    \n\nl[0] += [0]*(K+1)\n\nl[1] += [0]*(K+1)\n\na = sum(l[0][:K]) + sum(l[1][:K+1])\n\nans.append(a)\n\nfor i in range(1, len(l[0])-K-1):\n\n    a -= l[0][i-1] + l[1][i-1]\n\n    a += l[0][i+K-1] + l[1][i+K]\n\n    ans.append(a)\n\nprint((max(ans)))", "score": 1.0, "codebleu": 0.7570894237440788, "crystalbleu": 0.8818456617301919, "codebertscore": 0.96, "codescore": 0.9937619566917419, "surfaceSim": 0.8927444270954453, "abs_surfaceSim_minus_score": 0.10725557290455467}
{"golden_code": "import sys\n\ninput = sys.stdin.readline\n\nfrom collections import *\n\n\n\nA, B, C, D = list(map(int, input().split()))\n\n\n\nwhile True:\n\n    C -= B\n\n    \n\n    if C<=0:\n\n        print('Yes')\n\n        exit()\n\n    \n\n    A -= D\n\n    \n\n    if A<=0:\n\n        print('No')\n\n        exit()", "generated_code": "A, B, C, D = list(map(int, input().split()))\n\nc1 = (C+B-1)//B\n\nc2 = (A+D-1)//D\n\n\n\nif c1<=c2:\n\n    print('Yes')\n\nelse:\n\n    print('No')", "score": 1.0, "codebleu": 0.2864220350283604, "crystalbleu": 0.0, "codebertscore": 0.78, "codescore": 0.7211255431175232, "surfaceSim": 0.6148851148851149, "abs_surfaceSim_minus_score": 0.3851148851148851}
{"golden_code": "s = int(eval(input()))\n\nmod = 10**9 + 7\n\n\n\n# dp[i]: 最後に切った場所がi\n\ndp = [0]*(s + 1)\n\ndp[0] = 1\n\n\n\nfor i in range(3, s+1):\n\n    for j in range(0, (i-3)+1):\n\n        dp[i] += dp[j]\n\n        dp[i] %= mod\n\n\n\nprint((dp[s]))", "generated_code": "s = int(eval(input()))\n\nmod = 10**9 + 7\n\n\n\n# dp[i]: 最後に切った場所がi\n\ndp = [0]*(s + 1)\n\ndp[0] = 1\n\ntotal = 0\n\nfor i in range(3, s+1):\n\n    total += dp[i-3]\n\n    total %= mod\n\n    dp[i] = total\n\n\n\nprint((dp[s]))", "score": 1.0, "codebleu": 0.6677688474964992, "crystalbleu": 0.6701166791648441, "codebertscore": 0.97, "codescore": 0.985867440700531, "surfaceSim": 0.9023255813953488, "abs_surfaceSim_minus_score": 0.0976744186046512}
{"golden_code": "s=eval(input())\n\nt=eval(input())\n\nans=0\n\nif s[0]==t[0]:\n\n    ans+=1\n\nif s[1]==t[1]:\n\n    ans+=1\n\nif s[2]==t[2]:\n\n    ans+=1\n\nprint(ans)\n", "generated_code": "s=eval(input())\n\nt=eval(input())\n\nans=0\n\nfor i in range(0,3):\n\n    if s[i]==t[i]:\n\n        ans+=1\n\nprint(ans)\n", "score": 1.0, "codebleu": 0.359527749836205, "crystalbleu": 0.1889130701106511, "codebertscore": 0.89, "codescore": 0.8899918794631958, "surfaceSim": 0.8253676470588236, "abs_surfaceSim_minus_score": 0.1746323529411764}
{"golden_code": "N = int(eval(input()))\n\ns_list = {}\n\nfor i in range(N):\n\n  S = eval(input())\n\n  if S in list(s_list.keys()):\n\n    s_list[S] += 1\n\n  else:\n\n    s_list[S] = 0\n\nmax = 0\n\nmaxs = []\n\nfor s,c in list(s_list.items()):\n\n  if c > max:\n\n    maxs = [s]\n\n    max = c\n\n  elif c == max:\n\n    maxs.append(s)\n\nmaxs.sort()\n\nfor m in maxs:\n\n  print(m)", "generated_code": "from collections import Counter\n\ndef solve():\n\n  N = int(input())\n\n  S = [input() for _ in range(N)]\n\n  c = Counter(S)\n\n  M = max(c.values())\n\n  ans = []\n\n  for k,v in c.items():\n\n    if v==M:\n\n      ans.append(k)\n\n  ans.sort()\n\n  return ans\n\nprint(*solve(),sep='\\n')\n", "score": 1.0, "codebleu": 0.2332976200856245, "crystalbleu": 0.0, "codebertscore": 0.77, "codescore": 0.6018705368041992, "surfaceSim": 0.4806742226097065, "abs_surfaceSim_minus_score": 0.5193257773902935}
{"golden_code": "H,W = list(map(int,input().split()))\n\nN = int(eval(input()))\n\nA = list(map(int,input().split()))\n\nA.insert(0,0)\n\nC = [[0 for _ in range(W)] for _ in range(H)]\n\ncur = [0,0,\"R\"]\n\nfor k in range(1,N+1):\n\n#     ipdb.set_trace()\n\n    a = A[k]\n\n    cnt = 0\n\n    y,x,d = cur\n\n    for i in range(y,H):\n\n        y = i\n\n        if d==\"R\":\n\n            for j in range(x,W):\n\n                C[i][j]=str(k)\n\n                cnt += 1\n\n                if j+1<W:\n\n                    x = j+1\n\n                else:\n\n                    x = j\n\n                if cnt==a:break\n\n            if cnt==a:break\n\n            d=\"L\"\n\n        else:\n\n            for j in range(x,-1,-1):\n\n                C[i][j]=str(k)\n\n                cnt += 1\n\n                if j>=1:\n\n                    x = j-1\n\n                else:\n\n                    x = 0\n\n                if cnt==a:break\n\n            if cnt==a:break\n\n            d=\"R\"\n\n    if x==W-1:\n\n        if C[y][x]!=0:\n\n            y += 1\n\n            d=\"L\"\n\n    elif x==0:\n\n        if C[y][x]!=0:\n\n            y += 1\n\n            d=\"R\"\n\n    cur = [y,x,d]                \n\nfor i in range(H):\n\n    print((*C[i]))", "generated_code": "H,W = list(map(int,input().split()))\n\nN = int(eval(input()))\n\nA = list(map(int,input().split()))\n\nA.insert(0,0)\n\nB = [[0 for _ in range(W)] for _ in range(H)]\n\ncol = 1\n\ncnt = 0\n\ny = 0\n\nx = 0\n\nd = \"R\"\n\nwhile y<H:\n\n    if cnt<A[col]:\n\n        B[y][x] = col\n\n        cnt += 1\n\n    else:\n\n        col += 1\n\n        cnt = 0\n\n        B[y][x] = col\n\n        cnt += 1\n\n    if x<W-1 and d==\"R\":\n\n        x += 1\n\n    elif x==W-1 and d==\"R\":\n\n        y += 1\n\n        d = \"L\"\n\n    elif d==\"L\" and x>0:\n\n        x -= 1\n\n    elif d==\"L\" and x==0:\n\n        y += 1\n\n        d = \"R\"\n\nfor i in range(H):\n\n    print((*B[i]))", "score": 1.0, "codebleu": 0.37860347117124504, "crystalbleu": 0.3481250876124271, "codebertscore": 0.88, "codescore": 0.4518442749977112, "surfaceSim": 0.7328884060220395, "abs_surfaceSim_minus_score": 0.26711159397796047}
{"golden_code": "import fractions\n\nn=int(eval(input()))\n\nprint(((2*n)//fractions.gcd(2,n)))", "generated_code": "N=int(eval(input()));print((N if N%2==0 else N*2))", "score": 1.0, "codebleu": 0.18898809523809523, "crystalbleu": 0.0, "codebertscore": 0.82, "codescore": 0.37059396505355835, "surfaceSim": 0.5007507507507507, "abs_surfaceSim_minus_score": 0.4992492492492493}
{"golden_code": "from math import gcd\n\n\n\nN = int(eval(input()))\n\nnum_lis = list(map(int, input().split()))\n\nc = True\n\n\n\ndef osa_k(max_num):\n\n  lis = [i for i in range(max_num+1)]\n\n  p = 2\n\n  while p**2 <= max_num:\n\n    if lis[p] == p:\n\n      for q in range(2*p, max_num+1, p):\n\n        if lis[q] == q:\n\n          lis[q] = p\n\n    p += 1\n\n  return lis\n\n\n\nhoge = 0\n\nfor i in num_lis:\n\n  hoge = gcd(hoge, i)\n\nif hoge > 1:\n\n  print(\"not coprime\")\n\n  exit()\n\n\n\nd_lis = osa_k(10**6+10)\n\ntmp = set()\n\nfor i in num_lis:\n\n  num = i\n\n  new_tmp = set()\n\n  while num > 1:\n\n    d = d_lis[num]\n\n    new_tmp.add(d)\n\n    num //= d\n\n  for j in new_tmp:\n\n    if j in tmp:\n\n      c = False\n\n      break\n\n    else:\n\n      tmp.add(j)\n\n  else:\n\n    continue\n\n  break\n\n\n\nif c:\n\n  print(\"pairwise coprime\")\n\nelse:\n\n  print(\"setwise coprime\")", "generated_code": "from math import gcd\n\n\n\nN = int(eval(input()))\n\nnum_lis = list(map(int, input().split()))\n\n\n\ndef osa_k(max_num):\n\n  lis = [i for i in range(max_num+1)]\n\n  p = 2\n\n  while p**2 <= max_num:\n\n    if lis[p] == p:\n\n      for q in range(2*p, max_num+1, p):\n\n        if lis[q] == q:\n\n          lis[q] = p\n\n    p += 1\n\n  return lis\n\n\n\nhoge = 0\n\nfor i in num_lis:\n\n  hoge = gcd(hoge, i)\n\nif hoge > 1:\n\n  print(\"not coprime\")\n\n  exit()\n\n\n\nd_lis = osa_k(max(num_lis))\n\ntmp = set()\n\nfor i in num_lis:\n\n  num = i\n\n  new_tmp = set()\n\n  while num > 1:\n\n    d = d_lis[num]\n\n    new_tmp.add(d)\n\n    num //= d\n\n  for j in new_tmp:\n\n    if j in tmp:\n\n      print(\"setwise coprime\")\n\n      exit()\n\n    else:\n\n      tmp.add(j)\n\nprint(\"pairwise coprime\")", "score": 1.0, "codebleu": 0.7353257216896493, "crystalbleu": 0.8681580808363333, "codebertscore": 0.97, "codescore": 0.6574909687042236, "surfaceSim": 0.9126050420168067, "abs_surfaceSim_minus_score": 0.0873949579831933}
{"golden_code": "def popcount(x):\n    x = x - ((x >> 1) & 1431655765)\n    x = (x & 858993459) + ((x >> 2) & 858993459)\n    x = (x + (x >> 4)) & 252645135\n    x = x + (x >> 8)\n    x = x + (x >> 16)\n    return x & 127\ncmb = [[0 for i in range(51)] for j in range(51)]\ncmb[0][0] = 1\nfor i in range(51):\n    for j in range(51):\n        if (i != 50 and j != 50):\n            cmb[i + 1][j + 1] += cmb[i][j]\n        if i != 50:\n            cmb[i + 1][j] += cmb[i][j]\nfor i in range(1, 51):\n    for j in range(2, 51):\n        cmb[i][j] += cmb[i][j - 1]\n(N, K, T, S) = list(map(int, input().split()))\na = list(map(int, input().split()))\nmust0 = [i for i in range(18) if (S >> i) & 1 == 0]\nmust1 = [i for i in range(18) if (T >> i) & 1 == 1]\nA = []\nfor val in a:\n    check = True\n    for j in must0:\n        check = check & (val >> j) & 1 == 0\n    for j in must1:\n        check = check & (val >> j) & 1 == 1\n    if check:\n        A.append(val)\nif not A:\n    print(0)\n    exit()\nbit = []\nfor i in range(18):\n    if (i not in must0 and i not in must1):\n        bit.append(i)\nfor i in range(len(A)):\n    temp = 0\n    for j in range(len(bit)):\n        temp += (A[i] >> bit[j]) & 1 == 1 * (2 ** j)\n    A[i] = temp\nans = 0\nn = len(bit)\ndata = [0] * (2 ** n)\nfor i in range(2 ** n):\n    t = set([])\n    for a in A:\n        data[a & i] += 1\n        t.add(a & i)\n    temp = 0\n    for val in t:\n        temp += cmb[data[val]][min(K, data[val])]\n    ans += temp * ((-1) ** popcount(i))\n    for val in t:\n        data[val] = 0\nprint(ans)", "generated_code": "def popcount(x):\n    x = x - ((x >> 1) & 1431655765)\n    x = (x & 858993459) + ((x >> 2) & 858993459)\n    x = (x + (x >> 4)) & 252645135\n    x = x + (x >> 8)\n    x = x + (x >> 16)\n    return x & 127\ncmb = [[0 for i in range(51)] for j in range(51)]\ncmb[0][0] = 1\nfor i in range(51):\n    for j in range(51):\n        if (i == 50 and j != 50):\n            cmb[i + 1][j + 1] += cmb[i][j]\n        if i != 50:\n            cmb[i + 1][j] += cmb[i][j]\nfor i in range(1, 51):\n    for j in range(2, 51):\n        cmb[i][j] += cmb[i][j - 1]\n(N, K, T, S) = list(map(int, input().split()))\na = list(map(int, input().split()))\nmust0 = [i for i in range(18) if (S >> i) & 1 == 0]\nmust1 = [i for i in range(18) if (T >> i) & 1 == 1]\nA = []\nfor val in a:\n    check = True\n    for j in must0:\n        check = check & (val >> j) & 1 == 0\n    for j in must1:\n        check = check & (val >> j) & 1 == 1\n    if check:\n        A.append(val)\nif not A:\n    print(0)\n    exit()\nbit = []\nfor i in range(18):\n    if (i not in must0 and i not in must1):\n        bit.append(i)\nfor i in range(len(A)):\n    temp = 0\n    for j in range(len(bit)):\n        temp += (A[i] >> bit[j]) & 1 == 1 * (2 ** j)\n    A[i] = temp\nans = 0\nn = len(bit)\ndata = [0] * (2 ** n)\nfor i in range(2 ** n):\n    t = set([])\n    for a in A:\n        data[a & i] += 1\n        t.add(a & i)\n    temp = 0\n    for val in t:\n        temp += cmb[data[val]][min(K, data[val])]\n    ans += temp * ((-1) ** popcount(i))\n    for val in t:\n        data[val] = 0\nprint(ans)", "score": 0.0, "codebleu": 0.995941382850743, "crystalbleu": 0.9932103550789324, "codebertscore": 1.0, "codescore": 0.9936548471450806, "surfaceSim": 0.9996662216288384, "abs_surfaceSim_minus_score": 0.9996662216288384}
{"golden_code": "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nMOD = (10 ** 9) + 7\nfac = [1, 1]\nf_inv = [1, 1]\ninv = [0, 1]\ndef prepare(n, mod):\n    for i in range(2, n + 1):\n        fac.append((fac[-1] * i) % mod)\ndef cmb(n, r, mod):\n    if (n < 0 or r < 0):\n        return 0\n    if r > n:\n        return 0\n    return ((fac[n] * pow(fac[r], MOD - 2, MOD)) * pow(fac[n - r], MOD - 2, MOD)) % mod\ndef prime_factorization(n):\n    d = []\n    (i, e) = (2, 0)\n    while i * i <= n:\n        while n % i == 0:\n            n //= i\n            e += 1\n        if e > 0:\n            d.append((i, e))\n        i += 1\n        e = 0\n    if n > 1:\n        d.append((n, 1))\n    return d\ndef main():\n    (N, M) = list(map(int, readline().split()))\n    prepare(N + 100, MOD)\n    d = prime_factorization(M)\n    ans = 1\n    for (i, e) in d:\n        ans *= cmb((N - 1) + e, e, MOD)\n        ans %= MOD\n    print(ans)", "generated_code": "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nMOD = (10 ** 9) + 7\nfac = [1, 1]\nf_inv = [1, 1]\ninv = [0, 1]\ndef prepare(n, mod):\n    for i in range(2, n + 1):\n        fac.append((fac[-1] * i) % mod)\ndef cmb(n, r, mod):\n    if (n < 0 or r < 0):\n        return 0\n    if r > n:\n        return 0\n    return ((fac[n] / pow(fac[r], MOD - 2, MOD)) * pow(fac[n - r], MOD - 2, MOD)) % mod\ndef prime_factorization(n):\n    d = []\n    (i, e) = (2, 0)\n    while i * i <= n:\n        while n % i == 0:\n            n //= i\n            e += 1\n        if e > 0:\n            d.append((i, e))\n        i += 1\n        e = 0\n    if n > 1:\n        d.append((n, 1))\n    return d\ndef main():\n    (N, M) = list(map(int, readline().split()))\n    prepare(N + 100, MOD)\n    d = prime_factorization(M)\n    ans = 1\n    for (i, e) in d:\n        ans *= cmb((N - 1) + e, e, MOD)\n        ans %= MOD\n    print(ans)", "score": 0.0, "codebleu": 0.9924868895723431, "crystalbleu": 0.986088175957592, "codebertscore": 1.0, "codescore": 0.9937560558319092, "surfaceSim": 0.9869594594594595, "abs_surfaceSim_minus_score": 0.9869594594594595}
{"golden_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "generated_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        pass\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "score": 0.0, "codebleu": 0.8007963721005158, "crystalbleu": 0.9648784456962497, "codebertscore": 0.98, "codescore": 0.9888144135475159, "surfaceSim": 0.9643681788734032, "abs_surfaceSim_minus_score": 0.9643681788734032}
{"golden_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "generated_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] ** self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "score": 0.0, "codebleu": 0.9945883912637858, "crystalbleu": 0.9958766805969164, "codebertscore": 1.0, "codescore": 0.993550181388855, "surfaceSim": 0.9869513849897061, "abs_surfaceSim_minus_score": 0.9869513849897061}
{"golden_code": "import math, sys\nn = int(sys.stdin.readline())\na = tuple(map(int, sys.stdin.readline().split()))\ng = math.gcd(a[0], a[1])\nfor i in range(2, n):\n    g = math.gcd(g, a[i])\nM = max(a)\nacc = a[0]\nfor i in range(n):\n    acc = math.gcd(acc, a[i])\nif acc != 1:\n    print('not coprime')\n    exit()\nLIMIT = max(a)\nminPrime = [0] * (LIMIT + 1)\nminPrime[1] = 1\ndef make():\n    for i in range(2, LIMIT + 1):\n        if minPrime[i] == 0:\n            minPrime[i] = i\n            for j in range(i + i, LIMIT + 1, i):\n                if minPrime[j] == 0:\n                    minPrime[j] = i\nmake()\ndef factrial(N):\n    ret = []\n    while minPrime[N] != N:\n        ret.append(minPrime[N])\n        N = N // minPrime[N]\n    if N != 1:\n        ret.append(N)\n    return ret\njudge = set([])\npc = True\npairwise = True\np = set()\nfor e in a:\n    if not pairwise:\n        break\n    asf = set(factrial(e))\n    if judge & asf != set():\n        pc = False\n    judge |= asf\nif pc:\n    print('pairwise coprime')\nelif g == 1:\n    print('setwise coprime')\nelse:\n    print('not coprime')", "generated_code": "import math, sys\nn = int(sys.stdin.readline())\na = tuple(map(int, sys.stdin.readline().split()))\ng = math.gcd(a[0], a[1])\nfor i in range(2, n):\n    g = math.gcd(g, a[i])\nM = max(a)\nacc = a[0]\nfor i in range(n):\n    acc = math.gcd(acc, a[i])\nif acc != 1:\n    print('not coprime')\n    exit()\nLIMIT = max(a)\nminPrime = [0] * (LIMIT + 1)\nminPrime[1] = 1\ndef make():\n    for i in range(2, LIMIT + 1):\n        if minPrime[i] == 0:\n            minPrime[i] = i\n            for j in range(i + i, LIMIT + 1, i):\n                if minPrime[j] == 0:\n                    minPrime[j] = i\n                break\nmake()\ndef factrial(N):\n    ret = []\n    while minPrime[N] != N:\n        ret.append(minPrime[N])\n        N = N // minPrime[N]\n    if N != 1:\n        ret.append(N)\n    return ret\njudge = set([])\npc = True\npairwise = True\np = set()\nfor e in a:\n    if not pairwise:\n        break\n    asf = set(factrial(e))\n    if judge & asf != set():\n        pc = False\n    judge |= asf\nif pc:\n    print('pairwise coprime')elif g == 1:\n    print('setwise coprime')\nelse:\n    print('not coprime')", "score": 0.0, "codebleu": 0.9618271109301703, "crystalbleu": 0.9890192409220128, "codebertscore": 0.99, "codescore": 0.9937347769737244, "surfaceSim": 0.4967411545623836, "abs_surfaceSim_minus_score": 0.4967411545623836}
{"golden_code": "from collections import defaultdict\nfrom collections import deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\ndef I():\n    return int(sys.stdin.readline())\ndef LS():\n    return list(map(list, sys.stdin.readline().split()))\ndef S():\n    return list(sys.stdin.readline())[:-1]\ndef IR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = I()\n    return l\ndef LIR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = LI()\n    return l\ndef SR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = S()\n    return l\ndef LSR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = SR()\n    return l\nmod = 1000000007\ndef A():\n    s = S()\n    t = S()\n    if s + t == t[::-1] + s[::-1]:\n        print('YES')else:print('NO')\ndef B():\n    n = I()\n    for i in range(int(n ** 0.5) + 2)[::-1]:\n        if i * i <= n:\n            print(i * i)\n            quit()\ndef C():\n    n = I()\n    a = LI()\n    b = LI()\n    c = LI()\n    q = [0 for i in range(n)]\n    ans = 0\n    a.sort()\n    b.sort()\n    c.sort()\n    for i in range(n):\n        j = bisect.bisect_left(a, b[i])\n        q[i] = j\n    for i in range(n - 1):\n        q[i + 1] += q[i]\n    q.insert(0, 0)\n    for i in range(n):\n        j = bisect.bisect_left(b, c[i])\n        ans += q[j]\n    print(ans)\ndef D():\n    def dijkstra():\n        d = [float('inf') for i in range(k)]\n        q = [[0, 1]]\n        d[1] = 0\n        while q:\n            (dx, x) = heappop(q)\n            for (y, dy) in v[x]:\n                if d[y] > dx + dy:\n                    d[y] = dx + dy\n                    heappush(q, [d[y], y])\n        print(d[0] + 1)\n    k = I()\n    if k == 1:\n        print(1)\n        quit()\n    v = [[] for i in range(k)]\n    for i in range(1, k):\n        v[i].append([(i + 1) % k, 1])\n        v[i].append([(i * 10) % k, 0])\n    dijkstra()\ndef E():\n    return\ndef F():\n    return\ndef G():\n    return\ndef H():\n    return", "generated_code": "from collections import defaultdict\nfrom collections import deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\ndef I():\n    return int(sys.stdin.readline())\ndef LS():\n    return list(map(list, sys.stdin.readline().split()))\ndef S():\n    return list(sys.stdin.readline())[:-1]\ndef IR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = I()\n    return l\ndef LIR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = LI()\n    return l\ndef SR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = S()\n    return l\ndef LSR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = SR()\n    return l\nmod = 1000000007\ndef A():\n    s = S()\n    t = S()\n    if s + t == t[::-1] + s[::-1]:\n        print('YES')else:print('NO')\ndef B():\n    n = I()\n    for i in range(int(n ** 0.5) + 2)[::1]:\n        if i * i <= n:\n            print(i * i)\n            quit()\ndef C():\n    n = I()\n    a = LI()\n    b = LI()\n    c = LI()\n    q = [0 for i in range(n)]\n    ans = 0\n    a.sort()\n    b.sort()\n    c.sort()\n    for i in range(n):\n        j = bisect.bisect_left(a, b[i])\n        q[i] = j\n    for i in range(n - 1):\n        q[i + 1] += q[i]\n    q.insert(0, 0)\n    for i in range(n):\n        j = bisect.bisect_left(b, c[i])\n        ans += q[j]\n    print(ans)\ndef D():\n    def dijkstra():\n        d = [float('inf') for i in range(k)]\n        q = [[0, 1]]\n        d[1] = 0\n        while q:\n            (dx, x) = heappop(q)\n            for (y, dy) in v[x]:\n                if d[y] > dx + dy:\n                    d[y] = dx + dy\n                    heappush(q, [d[y], y])\n        print(d[0] + 1)\n    k = I()\n    if k == 1:\n        print(1)\n        quit()\n    v = [[] for i in range(k)]\n    for i in range(1, k):\n        v[i].append([(i + 1) % k, 1])\n        v[i].append([(i * 10) % k, 0])\n    dijkstra()\ndef E():\n    return\ndef F():\n    return\ndef G():\n    return\ndef H():\n    return", "score": 0.0, "codebleu": 0.9929395476571474, "crystalbleu": 0.9960534380417496, "codebertscore": 1.0, "codescore": 0.9881892204284668, "surfaceSim": 0.499755859375, "abs_surfaceSim_minus_score": 0.499755859375}
{"golden_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "generated_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\npass\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "score": 0.0, "codebleu": 0.8053633012177662, "crystalbleu": 0.9630571346156687, "codebertscore": 0.99, "codescore": 0.9932690262794495, "surfaceSim": 0.9760378079370089, "abs_surfaceSim_minus_score": 0.9760378079370089}
{"golden_code": "import queue\nINF = 123456789\ndef main():\n    (n, m) = list(map(int, input().split()))\n    G = [[] for _ in range(n)]\n    for _ in range(m):\n        (a, b, c) = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        G[a].append((b, c))\n        G[b].append((a, c))\n    used = set()\n    for i in range(n):\n        d = [INF for _ in range(n)]\n        par = [-1 for _ in range(n)]\n        que = queue.PriorityQueue()\n        d[i] = 0\n        que.put((0, i))\n        while not (que.empty()):\n            p = que.get()\n            v = p[1]\n            if d[v] < p[0]:\n                continue\n            for (to, cost) in G[v]:\n                if d[to] > d[v] + cost:\n                    d[to] = d[v] + cost\n                    par[to] = v\n                    que.put((d[to], to))\n        for j in range(n):\n            if i != j:\n                (a, b) = (j, par[j])\n                if a > b:\n                    (a, b) = (b, a)\n                used.add((a, b))\n    print(m - len(used))", "generated_code": "import queue\nINF = 123456789\ndef main():\n    (n, m) = list(map(int, input().split()))\n    G = [[] for _ in range(n)]\n    for _ in range(m):\n        (a, b, c) = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        G[a].append((b, c))\n        G[b].append((a, c))\n    used = set()\n    for i in range(n):\n        d = [INF for _ in range(n)]\n        par = [-1 for _ in range(n)]\n        que = queue.PriorityQueue()\n        d[i] = 0\n        que.put((0, i))\n        while not (que.empty()):\n            p = que.get()\n            v = p[1]\n            if d[v] < p[0]:\n                break\n            for (to, cost) in G[v]:\n                if d[to] > d[v] + cost:\n                    d[to] = d[v] + cost\n                    par[to] = v\n                    que.put((d[to], to))\n        for j in range(n):\n            if i != j:\n                (a, b) = (j, par[j])\n                if a > b:\n                    (a, b) = (b, a)\n                used.add((a, b))\n    print(m - len(used))", "score": 0.0, "codebleu": 0.9744117905463052, "crystalbleu": 0.9877302871193514, "codebertscore": 1.0, "codescore": 0.9937801957130432, "surfaceSim": 0.9674125071715434, "abs_surfaceSim_minus_score": 0.9674125071715434}
{"golden_code": "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nMOD = (10 ** 9) + 7\nfac = [1, 1]\nf_inv = [1, 1]\ninv = [0, 1]\ndef prepare(n, mod):\n    for i in range(2, n + 1):\n        fac.append((fac[-1] * i) % mod)\n        inv.append(((-(inv[mod % i])) * (mod // i)) % mod)\n        f_inv.append((f_inv[-1] * inv[-1]) % mod)\ndef cmb(n, r, mod):\n    if (n < 0 or r < 0):\n        return 0\n    if r > n:\n        return 0\n    return ((fac[n] * f_inv[r]) * f_inv[n - r]) % mod\ndef prime_factorization(n):\n    d = []\n    (i, e) = (2, 0)\n    while i * i <= n:\n        while n % i == 0:\n            n //= i\n            e += 1\n        if e > 0:\n            d.append((i, e))\n        i += 1\n        e = 0\n    if n > 1:\n        d.append((n, 1))\n    return d\ndef main():\n    (N, M) = list(map(int, readline().split()))\n    prepare(N + 100, MOD)\n    d = prime_factorization(M)\n    ans = 1\n    for (i, e) in d:\n        ans *= cmb((N - 1) + e, e, MOD)\n        ans %= MOD\n    print(ans)", "generated_code": "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nMOD = (10 ** 9) + 7\nfac = [1, 1]\nf_inv = [1, 1]\ninv = [0, 1]\ndef prepare(n, mod):\n    for i in range(2, n - 1):\n        fac.append((fac[-1] * i) % mod)\n        inv.append(((-(inv[mod % i])) * (mod // i)) % mod)\n        f_inv.append((f_inv[-1] * inv[-1]) % mod)\ndef cmb(n, r, mod):\n    if (n < 0 or r < 0):\n        return 0\n    if r > n:\n        return 0\n    return ((fac[n] * f_inv[r]) * f_inv[n - r]) % mod\ndef prime_factorization(n):\n    d = []\n    (i, e) = (2, 0)\n    while i * i <= n:\n        while n % i == 0:\n            n //= i\n            e += 1\n        if e > 0:\n            d.append((i, e))\n        i += 1\n        e = 0\n    if n > 1:\n        d.append((n, 1))\n    return d\ndef main():\n    (N, M) = list(map(int, readline().split()))\n    prepare(N + 100, MOD)\n    d = prime_factorization(M)\n    ans = 1\n    for (i, e) in d:\n        ans *= cmb((N - 1) + e, e, MOD)\n        ans %= MOD\n    print(ans)", "score": 0.0, "codebleu": 0.9927498121985038, "crystalbleu": 0.9939262964720614, "codebertscore": 1.0, "codescore": 0.9937447905540466, "surfaceSim": 0.9995, "abs_surfaceSim_minus_score": 0.9995}
{"golden_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "generated_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    pass\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "score": 0.0, "codebleu": 0.9831168329785611, "crystalbleu": 0.9749582158190828, "codebertscore": 0.99, "codescore": 0.9830374121665955, "surfaceSim": 0.984017284075403, "abs_surfaceSim_minus_score": 0.984017284075403}
{"golden_code": "import sys\n(n, m, *abcdef) = list(map(int, sys.stdin.buffer.read().split()))\nver_lines = []\nhor_lines = []\nx_list = set()\ny_list = set()\nn3 = n * 3\nfor (a, b, c) in zip(abcdef[0:n3:3], abcdef[1:n3:3], abcdef[2:n3:3]):\n    y_list.add(a)\n    y_list.add(b)\n    x_list.add(c)\n    ver_lines.append((a, b, c))\nfor (d, e, f) in zip(abcdef[n3 + 0::3], abcdef[n3 + 1::3], abcdef[n3 + 2::3]):\n    y_list.add(d)\n    x_list.add(e)\n    x_list.add(f)\n    hor_lines.append((d, e, f))\nx_list.add(0)\ny_list.add(0)\nx_list = sorted(x_list)\ny_list = sorted(y_list)\nx_dict = {x: i for (i, x) in enumerate(x_list, start=1)}\ny_dict = {y: i for (i, y) in enumerate(y_list, start=1)}\nrow_real = len(x_list)\ncol_real = len(y_list)\nrow = row_real + 2\ncol = col_real + 2\nbanned_up_ij = [[0] * row for _ in range(col)]\nbanned_down_ij = [[0] * row for _ in range(col)]\nbanned_left_ij = [[0] * col for _ in range(row)]\nbanned_right_ij = [[0] * col for _ in range(row)]\nfor (a, b, c) in ver_lines:\n    if a > b:\n        (a, b) = (b, a)\n    ai = y_dict[a]\n    bi = y_dict[b]\n    j = x_dict[c]\n    banned_left_ij[j][ai] += 1\n    banned_left_ij[j][bi] -= 1\n    banned_right_ij[j - 1][ai] += 1\n    banned_right_ij[j - 1][bi] -= 1\nfor (d, e, f) in hor_lines:\n    if e > f:\n        (e, f) = (f, e)\n    i = y_dict[d]\n    ej = x_dict[e]\n    fj = x_dict[f]\n    banned_up_ij[i][ej] += 1\n    banned_up_ij[i][fj] -= 1\n    banned_down_ij[i - 1][ej] += 1\n    banned_down_ij[i - 1][fj] -= 1\nbanned_up = [0] * (row * col)\nbanned_down = [0] * (row * col)\nbanned_left = [0] * (row * col)\nbanned_right = [0] * (row * col)\nfor i in range(col):\n    ru = banned_up_ij[i]\n    rd = banned_down_ij[i]\n    ri = row * i\n    banned_up[ri] = ru[0]\n    banned_down[ri] = rd[0]\n    for j in range(1, row):\n        banned_up[ri + j] = banned_up[(ri + j) - 1] + ru[j]\n        banned_down[ri + j] = banned_down[(ri + j) - 1] + rd[j]\nfor j in range(row):\n    rl = banned_left_ij[j]\n    rr = banned_right_ij[j]\n    banned_left[j] = rl[0]\n    banned_right[j] = rr[0]\n    for i in range(1, col):\n        ri0 = (i - 1) * row\n        ri1 = i * row\n        banned_left[ri1 + j] = banned_left[ri0 + j] + rl[i]\n        banned_right[ri1 + j] = banned_right[ri0 + j] + rr[i]\ns = (row * y_dict[0]) + x_dict[0]\nenable = (([-1] * row) + ((([-1] + ([0] * (row - 2))) + [-1]) * (col - 2))) + ([-1] * row)\nq = [s]\nmoves = [(-row, banned_up), (-1, banned_left), (1, banned_right), (row, banned_down)]\nwhile q:\n    c = q.pop()\n    if enable[c] == 1:\n        continue\n    elif enable[c] == -1:\n        print('INF')\n        exit()\n    enable[c] = 1\n    for (dc, banned) in moves:\n        if banned[c]:\n            continue\n        nc = c + dc\n        if enable[nc] == 1:\n            continue\n        q.append(nc)\nans = 0\nfor i in range(col):\n    ri = i * row\n    for j in range(row):\n        if enable[ri + j] != 1:\n            continue\n        t = y_list[i - 1]\n        b = y_list[i]\n        l = x_list[j - 1]\n        r = x_list[j]\n        ans += (b - t) * (r - l)\nprint(ans)", "generated_code": "import sys\n(n, m, *abcdef) = list(map(int, sys.stdin.buffer.read().split()))\nver_lines = []\nhor_lines = []\nx_list = set()\ny_list = set()\nn3 = n * 3\nfor (a, b, c) in zip(abcdef[0:n3:3], abcdef[1:n3:3], abcdef[2:n3:3]):\n    y_list.add(a)\n    y_list.add(b)\n    x_list.add(c)\n    ver_lines.append((a, b, c))\nfor (d, e, f) in zip(abcdef[n3 + 0::3], abcdef[n3 + 1::3], abcdef[n3 + 2::3]):\n    y_list.add(d)\n    x_list.add(e)\n    x_list.add(f)\n    hor_lines.append((d, e, f))\nx_list.add(0)\ny_list.add(0)\nx_list = sorted(x_list)\ny_list = sorted(y_list)\nx_dict = {x: i for (i, x) in enumerate(x_list, start=1)}\ny_dict = {y: i for (i, y) in enumerate(y_list, start=1)}\nrow_real = len(x_list)\ncol_real = len(y_list)\nrow = row_real + 2\ncol = col_real + 2\nbanned_up_ij = [[0] * row for _ in range(col)]\nbanned_down_ij = [[0] * row for _ in range(col)]\nbanned_left_ij = [[0] * col for _ in range(row)]\nbanned_right_ij = [[0] * col for _ in range(row)]\nfor (a, b, c) in ver_lines:\n    if a > b:\n        (a, b) = (b, a)\n    ai = y_dict[a]\n    bi = y_dict[b]\n    j = x_dict[c]\n    banned_left_ij[j][ai] += 1\n    banned_left_ij[j][bi] -= 1\n    banned_right_ij[j - 1][ai] += 1\n    banned_right_ij[j - 1][bi] -= 1\nfor (d, e, f) in hor_lines:\n    if e > f:\n        (e, f) = (f, e)\n    i = y_dict[d]\n    ej = x_dict[e]\n    fj = x_dict[f]\n    banned_up_ij[i][ej] += 1\n    banned_up_ij[i][fj] -= 1\n    banned_down_ij[i - 1][ej] += 1\n    banned_down_ij[i - 1][fj] -= 1\nbanned_up = [0] * (row * col)\nbanned_down = [0] * (row * col)\nbanned_left = [0] * (row * col)\nbanned_right = [0] * (row * col)\nfor i in range(col):\n    ru = banned_up_ij[i]\n    rd = banned_down_ij[i]\n    ri = row * i\n    banned_up[ri] = ru[0]\n    banned_down[ri] = rd[0]\n    for j in range(1, row):\n        banned_up[ri + j] = banned_up[(ri + j) - 1] + ru[j]\n        banned_down[ri + j] = banned_down[(ri + j) - 1] + rd[j]\n    break\nfor j in range(row):\n    rl = banned_left_ij[j]\n    rr = banned_right_ij[j]\n    banned_left[j] = rl[0]\n    banned_right[j] = rr[0]\n    for i in range(1, col):\n        ri0 = (i - 1) * row\n        ri1 = i * row\n        banned_left[ri1 + j] = banned_left[ri0 + j] + rl[i]\n        banned_right[ri1 + j] = banned_right[ri0 + j] + rr[i]\ns = (row * y_dict[0]) + x_dict[0]\nenable = (([-1] * row) + ((([-1] + ([0] * (row - 2))) + [-1]) * (col - 2))) + ([-1] * row)\nq = [s]\nmoves = [(-row, banned_up), (-1, banned_left), (1, banned_right), (row, banned_down)]\nwhile q:\n    c = q.pop()\n    if enable[c] == 1:\n        continueelif enable[c] == -1:\n        print('INF')\n        exit()\n    enable[c] = 1\n    for (dc, banned) in moves:\n        if banned[c]:\n            continue\n        nc = c + dc\n        if enable[nc] == 1:\n            continue\n        q.append(nc)\nans = 0\nfor i in range(col):\n    ri = i * row\n    for j in range(row):\n        if enable[ri + j] != 1:\n            continue\n        t = y_list[i - 1]\n        b = y_list[i]\n        l = x_list[j - 1]\n        r = x_list[j]\n        ans += (b - t) * (r - l)\nprint(ans)", "score": 0.0, "codebleu": 0.9846371920378602, "crystalbleu": 0.9931122044344988, "codebertscore": 1.0, "codescore": 0.9607800245285034, "surfaceSim": 0.4988309953239813, "abs_surfaceSim_minus_score": 0.4988309953239813}
{"golden_code": "def popcount(x):\n    x = x - ((x >> 1) & 1431655765)\n    x = (x & 858993459) + ((x >> 2) & 858993459)\n    x = (x + (x >> 4)) & 252645135\n    x = x + (x >> 8)\n    x = x + (x >> 16)\n    return x & 127\ncmb = [[0 for i in range(51)] for j in range(51)]\ncmb[0][0] = 1\nfor i in range(51):\n    for j in range(51):\n        if (i != 50 and j != 50):\n            cmb[i + 1][j + 1] += cmb[i][j]\n        if i != 50:\n            cmb[i + 1][j] += cmb[i][j]\nfor i in range(1, 51):\n    for j in range(2, 51):\n        cmb[i][j] += cmb[i][j - 1]\n(N, K, T, S) = list(map(int, input().split()))\na = list(map(int, input().split()))\nmust0 = [i for i in range(18) if (S >> i) & 1 == 0]\nmust1 = [i for i in range(18) if (T >> i) & 1 == 1]\nA = []\nfor val in a:\n    check = True\n    for j in must0:\n        check = check & (val >> j) & 1 == 0\n    for j in must1:\n        check = check & (val >> j) & 1 == 1\n    if check:\n        A.append(val)\nif not A:\n    print(0)\n    exit()\nbit = []\nfor i in range(18):\n    if (i not in must0 and i not in must1):\n        bit.append(i)\nfor i in range(len(A)):\n    temp = 0\n    for j in range(len(bit)):\n        temp += (A[i] >> bit[j]) & 1 == 1 * (2 ** j)\n    A[i] = temp\nans = 0\nn = len(bit)\ndata = [0] * (2 ** n)\nfor i in range(2 ** n):\n    t = set([])\n    for a in A:\n        data[a & i] += 1\n        t.add(a & i)\n    temp = 0\n    for val in t:\n        temp += cmb[data[val]][min(K, data[val])]\n    ans += temp * ((-1) ** popcount(i))\n    for val in t:\n        data[val] = 0\nprint(ans)", "generated_code": "def popcount(x):\n    x = x - ((x >> 1) & 1431655765)\n    x = (x & 858993459) + ((x >> 2) & 858993459)\n    x = (x + (x >> 4)) & 252645135\n    x = x + (x >> 8)\n    x = x + (x >> 16)\n    return x & 127\ncmb = [[0 for i in range(51)] for j in range(51)]\ncmb[0][0] = 1\nfor i in range(51):\n    for j in range(51):\n        if (i != 50 and j != 50):\n            cmb[i + 1][j + 1] += cmb[i][j]\n        if not (i != 50):\n            cmb[i + 1][j] += cmb[i][j]\nfor i in range(1, 51):\n    for j in range(2, 51):\n        cmb[i][j] += cmb[i][j - 1]\n(N, K, T, S) = list(map(int, input().split()))\na = list(map(int, input().split()))\nmust0 = [i for i in range(18) if (S >> i) & 1 == 0]\nmust1 = [i for i in range(18) if (T >> i) & 1 == 1]\nA = []\nfor val in a:\n    check = True\n    for j in must0:\n        check = check & (val >> j) & 1 == 0\n    for j in must1:\n        check = check & (val >> j) & 1 == 1\n    if check:\n        A.append(val)\nif not A:\n    print(0)\n    exit()\nbit = []\nfor i in range(18):\n    if (i not in must0 and i not in must1):\n        bit.append(i)\nfor i in range(len(A)):\n    temp = 0\n    for j in range(len(bit)):\n        temp += (A[i] >> bit[j]) & 1 == 1 * (2 ** j)\n    A[i] = temp\nans = 0\nn = len(bit)\ndata = [0] * (2 ** n)\nfor i in range(2 ** n):\n    t = set([])\n    for a in A:\n        data[a & i] += 1\n        t.add(a & i)\n    temp = 0\n    for val in t:\n        temp += cmb[data[val]][min(K, data[val])]\n    ans += temp * ((-1) ** popcount(i))\n    for val in t:\n        data[val] = 0\nprint(ans)", "score": 0.0, "codebleu": 0.987178435049519, "crystalbleu": 0.9879796143969416, "codebertscore": 1.0, "codescore": 0.9936586022377014, "surfaceSim": 0.9983377659574468, "abs_surfaceSim_minus_score": 0.9983377659574468}
{"golden_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "generated_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "score": 0.0, "codebleu": 0.9838747529774845, "crystalbleu": 0.9942145673215758, "codebertscore": 1.0, "codescore": 0.9936098456382751, "surfaceSim": 0.9988589685075309, "abs_surfaceSim_minus_score": 0.9988589685075309}
{"golden_code": "import sys\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\ndef solve():\n    inf = (10 ** 14) + 10\n    def dfs(v: 'vertex_index, 0-indexed') -> None:\n        for (c, t) in e[v]:\n            if d[t] != inf:\n                continue\n            d[t] = d[v] + c\n            dfs(t)\n    n = int(eval(input()))\n    e = tuple((set() for _ in range(n)))\n    for _ in range(n - 1):\n        (a, b, c) = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        e[a].add((c, b))\n        e[b].add((c, a))\n    (q, v) = list(map(int, input().split()))\n    v -= 1\n    d = [inf] * n\n    d[v] = 0\n    dfs(v)\n    for _ in range(q):\n        (x, y) = list(map(int, input().split()))\n        x -= 1\n        y -= 1\n        print(d[x] + d[y])", "generated_code": "import sys\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\ndef solve():\n    inf = (10 ** 14) + 10\n    def dfs(v: 'vertex_index, 0-indexed') -> None:\n        for (c, t) in e[v]:\n            if d[t] != inf:\n                continue\n            d[t] = d[v] - c\n            dfs(t)\n    n = int(eval(input()))\n    e = tuple((set() for _ in range(n)))\n    for _ in range(n - 1):\n        (a, b, c) = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        e[a].add((c, b))\n        e[b].add((c, a))\n    (q, v) = list(map(int, input().split()))\n    v -= 1\n    d = [inf] * n\n    d[v] = 0\n    dfs(v)\n    for _ in range(q):\n        (x, y) = list(map(int, input().split()))\n        x -= 1\n        y -= 1\n        print(d[x] + d[y])", "score": 0.0, "codebleu": 0.9881398574370538, "crystalbleu": 0.9907582847077829, "codebertscore": 1.0, "codescore": 0.8324532508850098, "surfaceSim": 0.9993243243243244, "abs_surfaceSim_minus_score": 0.9993243243243244}
{"golden_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "generated_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    @staticmethod\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:print('NA')", "score": 0.0, "codebleu": 0.9895212352936913, "crystalbleu": 0.9944643274491598, "codebertscore": 0.99, "codescore": 0.9935751557350159, "surfaceSim": 0.9965846994535519, "abs_surfaceSim_minus_score": 0.9965846994535519}
{"golden_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "generated_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 ** i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "score": 0.0, "codebleu": 0.9963221036285097, "crystalbleu": 0.9972409634447433, "codebertscore": 1.0, "codescore": 0.9855175614356995, "surfaceSim": 0.9997032640949555, "abs_surfaceSim_minus_score": 0.9997032640949555}
{"golden_code": "import sys\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\ndef solve():\n    inf = (10 ** 14) + 10\n    def dfs(v: 'vertex_index, 0-indexed') -> None:\n        for (c, t) in e[v]:\n            if d[t] != inf:\n                continue\n            d[t] = d[v] + c\n            dfs(t)\n    n = int(eval(input()))\n    e = tuple((set() for _ in range(n)))\n    for _ in range(n - 1):\n        (a, b, c) = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        e[a].add((c, b))\n        e[b].add((c, a))\n    (q, v) = list(map(int, input().split()))\n    v -= 1\n    d = [inf] * n\n    d[v] = 0\n    dfs(v)\n    for _ in range(q):\n        (x, y) = list(map(int, input().split()))\n        x -= 1\n        y -= 1\n        print(d[x] + d[y])", "generated_code": "import sys\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\ndef solve():\n    inf = (10 ** 14) + 10\n    def dfs(v: 'vertex_index, 0-indexed') -> None:\n        for (c, t) in e[v]:\n            if d[t] != inf:\n                continue\n            d[t] = d[v] + c\n            dfs(t)\n    n = int(eval(input()))\n    e = tuple((set() for _ in range(n)))\n    for _ in range(n - 1):\n        (a, b, c) = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        e[a].add((c, b))\n        e[b].add((c, a))\n    (q, v) = list(map(int, input().split()))\n    v -= 1\n    d = [inf] * n\n    d[v] = 0\n    dfs(v)\n    for _ in range(q):\n        (x, y) = list(map(int, input().split()))\n        x -= 1\n        y -= 1\n        print(d[x] - d[y])", "score": 0.0, "codebleu": 0.9917965913003897, "crystalbleu": 0.9907582847077829, "codebertscore": 1.0, "codescore": 0.9938247203826904, "surfaceSim": 0.9993243243243244, "abs_surfaceSim_minus_score": 0.9993243243243244}
{"golden_code": "n = int(eval(input()))\nnode = {i: [] for i in range(1, n + 1)}\nvisited = [False for i in range(n + 1)]\nq = []\nfor _ in range(n - 1):\n    (a, b) = list(map(int, input().split()))\n    node[a].append(b)\n    node[b].append(a)\n    q.append((a, b))\nmother = q[0][0]\nvisited[mother] = True\nd = []\ne = []\npaint = {i: {} for i in range(1, n + 1)}\nmother_paint = [0 for i in range(n + 1)]\nc = 1\nfor child in node[mother]:\n    visited[child] = True\n    paint[mother][child] = c\n    paint[child][mother] = c\n    mother_paint[child] = c\n    c += 1\n    d.append(child)\nwhile d:\n    for parent in d:\n        p = 1\n        for child in node[parent]:\n            if visited[child] == False:\n                visited[child] = True\n                if p != mother_paint[parent]:\n                    paint[parent][child] = p\n                    paint[child][parent] = p\n                    mother_paint[child] = p\n                    p += 1\n                    e.append(child)\n                else:\n                    p += 1\n                    paint[parent][child] = p\n                    paint[child][parent] = p\n                    mother_paint[child] = p\n                    p += 1\n                    e.append(child)\n    if e:\n        d = e\n        e = []\n    else:\n        d = []\n        e = []\nK = 0\nfor i in range(1, n + 1):\n    K = max(K, len(node[i]))\nprint(K)\nfor i in range(n - 1):\n    (s, t) = (q[i][0], q[i][1])\n    print(paint[s][t])", "generated_code": "n = int(eval(input()))\nnode = {i: [] for i in range(1, n + 1)}\nvisited = [False for i in range(n + 1)]\nq = []\nfor _ in range(n - 1):\n    (a, b) = list(map(int, input().split()))\n    node[a].append(b)\n    node[b].append(a)\n    q.append((a, b))\nmother = q[0][0]\nvisited[mother] = True\nd = []\ne = []\npaint = {i: {} for i in range(1, n - 1)}\nmother_paint = [0 for i in range(n + 1)]\nc = 1\nfor child in node[mother]:\n    visited[child] = True\n    paint[mother][child] = c\n    paint[child][mother] = c\n    mother_paint[child] = c\n    c += 1\n    d.append(child)\nwhile d:\n    for parent in d:\n        p = 1\n        for child in node[parent]:\n            if visited[child] == False:\n                visited[child] = True\n                if p != mother_paint[parent]:\n                    paint[parent][child] = p\n                    paint[child][parent] = p\n                    mother_paint[child] = p\n                    p += 1\n                    e.append(child)\n                else:\n                    p += 1\n                    paint[parent][child] = p\n                    paint[child][parent] = p\n                    mother_paint[child] = p\n                    p += 1\n                    e.append(child)\n    if e:\n        d = e\n        e = []\n    else:\n        d = []\n        e = []\nK = 0\nfor i in range(1, n + 1):\n    K = max(K, len(node[i]))\nprint(K)\nfor i in range(n - 1):\n    (s, t) = (q[i][0], q[i][1])\n    print(paint[s][t])", "score": 0.0, "codebleu": 0.9935280794812529, "crystalbleu": 0.9907006509253066, "codebertscore": 1.0, "codescore": 0.9938210844993591, "surfaceSim": 0.9996496145760336, "abs_surfaceSim_minus_score": 0.9996496145760336}
{"golden_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "generated_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, +1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "score": 0.0, "codebleu": 0.9890842515292805, "crystalbleu": 0.9834519784786802, "codebertscore": 1.0, "codescore": 0.9938415288925171, "surfaceSim": 0.9814788465186872, "abs_surfaceSim_minus_score": 0.9814788465186872}
{"golden_code": "from functools import lru_cache\nimport sys\nsys.setrecursionlimit(10 ** 7)\n\n@lru_cache(maxsize=None)\ndef check(l, r, n, k=1):t = (l + ('0' * k)) + r\n    e = (l + ('9' * k)) + r\n    if int(e) <= n:\n        return pow(10, k) + check(l, r, n, k + 1)\n    if int(t) <= n < int(e):\n        x = int(str(n)[1:-1])\n        if int(str(n)[-1]) < int(r):\n            x -= 1\n        return x + 1\n    if n < int(t):\n        return 0\ndef main():\n    n = int(eval(input()))\n    ret = 0\n    for x in range(1, n + 1):\n        if x % 10 == 0:\n            continue\n        s = str(x)\n        t = s[-1] + s[0]\n        if s[0] == s[-1]:\n            ret += 1\n        if int(t) <= n:\n            ret += 1\n        ret += check(s[-1], s[0], n, k=1)\n    print(ret)", "generated_code": "from functools import lru_cache\nimport sys\nsys.setrecursionlimit(10 ** 7)\n\n@lru_cache(maxsize=None)\ndef check(l, r, n, k=1):t = (l + ('0' * k)) + r\n    e = (l + ('9' * k)) + r\n    if int(e) <= n:\n        return pow(10, k) + check(l, r, n, k + 1)\n    if int(t) <= n < int(e):\n        x = int(str(n)[1:-1])\n        if int(str(n)[-1]) < int(r):\n            x -= 1\n        return x + 1\n    if n < int(t):\n        return 0\ndef main():\n    n = int(eval(input()))\n    ret = 0\n    for x in range(1, n + 1):\n        if x % 10 == 0:\n            continue\n        s = str(x)\n        t = s[-1] + s[0]\n        if s[0] == s[1]:\n            ret += 1\n        if int(t) <= n:\n            ret += 1\n        ret += check(s[-1], s[0], n, k=1)\n    print(ret)", "score": 0.0, "codebleu": 0.9776784444361031, "crystalbleu": 0.9902419169655517, "codebertscore": 1.0, "codescore": 0.9937649965286255, "surfaceSim": 0.499320652173913, "abs_surfaceSim_minus_score": 0.499320652173913}
{"golden_code": "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nMOD = (10 ** 9) + 7\nfac = [1, 1]\nf_inv = [1, 1]\ninv = [0, 1]\ndef prepare(n, mod):\n    for i in range(2, n + 1):\n        fac.append((fac[-1] * i) % mod)\n        inv.append(((-(inv[mod % i])) * (mod // i)) % mod)\n        f_inv.append((f_inv[-1] * inv[-1]) % mod)\ndef cmb(n, r, mod):\n    if (n < 0 or r < 0):\n        return 0\n    if r > n:\n        return 0\n    return ((fac[n] * f_inv[r]) * f_inv[n - r]) % mod\ndef prime_factorization(n):\n    d = []\n    (i, e) = (2, 0)\n    while i * i <= n:\n        while n % i == 0:\n            n //= i\n            e += 1\n        if e > 0:\n            d.append((i, e))\n        i += 1\n        e = 0\n    if n > 1:\n        d.append((n, 1))\n    return d\ndef main():\n    (N, M) = list(map(int, readline().split()))\n    prepare(N + 100, MOD)\n    d = prime_factorization(M)\n    ans = 1\n    for (i, e) in d:\n        ans *= cmb((N - 1) + e, e, MOD)\n        ans %= MOD\n    print(ans)", "generated_code": "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nMOD = (10 ** 9) + 7\nfac = [1, 1]\nf_inv = [1, 1]\ninv = [0, 1]\ndef prepare(n, mod):\n    for i in range(2, n + 1):\n        fac.append((fac[-1] * i) % mod)\n        inv.append(((-(inv[mod % i])) * (mod // i)) % mod)\n        f_inv.append((f_inv[1] * inv[-1]) % mod)\ndef cmb(n, r, mod):\n    if (n < 0 or r < 0):\n        return 0\n    if r > n:\n        return 0\n    return ((fac[n] * f_inv[r]) * f_inv[n - r]) % mod\ndef prime_factorization(n):\n    d = []\n    (i, e) = (2, 0)\n    while i * i <= n:\n        while n % i == 0:\n            n //= i\n            e += 1\n        if e > 0:\n            d.append((i, e))\n        i += 1\n        e = 0\n    if n > 1:\n        d.append((n, 1))\n    return d\ndef main():\n    (N, M) = list(map(int, readline().split()))\n    prepare(N + 100, MOD)\n    d = prime_factorization(M)\n    ans = 1\n    for (i, e) in d:\n        ans *= cmb((N - 1) + e, e, MOD)\n        ans %= MOD\n    print(ans)", "score": 0.0, "codebleu": 0.9773003739962566, "crystalbleu": 0.9925590734875005, "codebertscore": 1.0, "codescore": 0.9937440752983093, "surfaceSim": 0.9995, "abs_surfaceSim_minus_score": 0.9995}
{"golden_code": "def cmb(n, r):\n    import math\n    if n < r:\n        return 0\n    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\ndef solve(S):\n    mod = (10 ** 9) + 7\n    ans = 0\n    for i in range(1, (S // 3) + 1):\n        tama = i + (S - (i * 3))\n        tama -= 2\n        bo = i - 1\n        ans += cmb(tama + 1, bo)\n        ans %= mod\n    print(ans)", "generated_code": "def cmb(n, r):\n    import math\n    if n < r:\n        return 0\n    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\ndef solve(S):\n    mod = (10 ** 9) + 7\n    ans = 0\n    for i in range(1, (S // 3) + 1):\n        break\n    \n    \n    \n    \n    print(ans)", "score": 0.0, "codebleu": 0.5531049663837491, "crystalbleu": 0.6061736528563952, "codebertscore": 0.94, "codescore": 0.6139734983444214, "surfaceSim": 0.8660961614562723, "abs_surfaceSim_minus_score": 0.8660961614562723}
{"golden_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "generated_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R <<= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "score": 0.0, "codebleu": 0.9963221036285097, "crystalbleu": 0.9937353720084278, "codebertscore": 1.0, "codescore": 0.9859338402748108, "surfaceSim": 0.988767877899631, "abs_surfaceSim_minus_score": 0.988767877899631}
{"golden_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "generated_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "score": 0.0, "codebleu": 0.9865939505120788, "crystalbleu": 0.9942110332335385, "codebertscore": 1.0, "codescore": 0.9935759902000427, "surfaceSim": 0.9988589685075309, "abs_surfaceSim_minus_score": 0.9988589685075309}
{"golden_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "generated_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    pass\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "score": 0.0, "codebleu": 0.852304853023182, "crystalbleu": 0.9572704047647298, "codebertscore": 0.99, "codescore": 0.9938311576843262, "surfaceSim": 0.9701906659077975, "abs_surfaceSim_minus_score": 0.9701906659077975}
{"golden_code": "import math, string, itertools, fractions, heapq, collections, re, array, bisect, sys, random, time, copy, functools\nsys.setrecursionlimit(10 ** 7)\ninf = 10 ** 20\neps = 1.0 / (10 ** 15)\nmod = (10 ** 9) + 7\ndef LI():\n    return [int(x) for x in sys.stdin.readline().split()]\ndef LI_():\n    return [int(x) - 1 for x in sys.stdin.readline().split()]\ndef LF():\n    return [float(x) for x in sys.stdin.readline().split()]\ndef LS():\n    return sys.stdin.readline().split()\ndef I():\n    return int(sys.stdin.readline())\ndef F():\n    return float(sys.stdin.readline())\ndef S():\n    return input()\ndef pf(s):\n    return print(s, flush=True)\ndef divisions(n):\n    sq = int(math.sqrt(n) + 1)\n    d = collections.defaultdict(int)\n    while n % 2 == 0:\n        n //= 2\n        d[2] += 1\n    i = 3\n    while (n > 1 and sq >= i):\n        if n % i == 0:\n            n //= i\n            d[i] += 1else:i += 2\n    if n > 1:\n        d[n] += 1\n    r = [1]\n    for (k, v) in d.items():\n        for c in r[:]:\n            for i in range(1, v + 1):\n                r.append(c * (k ** i))\n    return sorted(r)\ndef main():\n    n = I()\n    a = LI()\n    s = set()\n    for i in range(n, 0, -1):\n        d = divisions(i)\n        ld = len(d)\n        for j in range(1, 2 ** ld):\n            c = []\n            ff = True\n            for k in range(ld):\n                if j & (1 << k):\n                    f = True\n                    for e in c:\n                        if d[k] % e == 0:\n                            f = False\n                            ff = False\n                            break\n                    if f:\n                        c.append(d[k])\n                if not ff:\n                    break\n            if ff:\n                s.add(tuple(c + [n + 1]))\n    b = sorted(list(s), reverse=True)\n    for c in b:\n        t = 0\n        for j in range(1, n + 1):\n            f = False\n            for e in c:\n                if j % e == 0:\n                    f = True\n                    break\n            if f:\n                t += a[j - 1]\n        if t < 0:\n            for j in range(1, n + 1):\n                f = False\n                for e in c:\n                    if j % e == 0:\n                        f = True\n                        break\n                if f:\n                    a[j - 1] = 0\n    return sum(a)\nprint(main())", "generated_code": "import math, string, itertools, fractions, heapq, collections, re, array, bisect, sys, random, time, copy, functools\nsys.setrecursionlimit(10 ** 7)\ninf = 10 ** 20\neps = 1.0 // (10 ** 15)\nmod = (10 ** 9) + 7\ndef LI():\n    return [int(x) for x in sys.stdin.readline().split()]\ndef LI_():\n    return [int(x) - 1 for x in sys.stdin.readline().split()]\ndef LF():\n    return [float(x) for x in sys.stdin.readline().split()]\ndef LS():\n    return sys.stdin.readline().split()\ndef I():\n    return int(sys.stdin.readline())\ndef F():\n    return float(sys.stdin.readline())\ndef S():\n    return input()\ndef pf(s):\n    return print(s, flush=True)\ndef divisions(n):\n    sq = int(math.sqrt(n) + 1)\n    d = collections.defaultdict(int)\n    while n % 2 == 0:\n        n //= 2\n        d[2] += 1\n    i = 3\n    while (n > 1 and sq >= i):\n        if n % i == 0:\n            n //= i\n            d[i] += 1else:i += 2\n    if n > 1:\n        d[n] += 1\n    r = [1]\n    for (k, v) in d.items():\n        for c in r[:]:\n            for i in range(1, v + 1):\n                r.append(c * (k ** i))\n    return sorted(r)\ndef main():\n    n = I()\n    a = LI()\n    s = set()\n    for i in range(n, 0, -1):\n        d = divisions(i)\n        ld = len(d)\n        for j in range(1, 2 ** ld):\n            c = []\n            ff = True\n            for k in range(ld):\n                if j & (1 << k):\n                    f = True\n                    for e in c:\n                        if d[k] % e == 0:\n                            f = False\n                            ff = False\n                            break\n                    if f:\n                        c.append(d[k])\n                if not ff:\n                    break\n            if ff:\n                s.add(tuple(c + [n + 1]))\n    b = sorted(list(s), reverse=True)\n    for c in b:\n        t = 0\n        for j in range(1, n + 1):\n            f = False\n            for e in c:\n                if j % e == 0:\n                    f = True\n                    break\n            if f:\n                t += a[j - 1]\n        if t < 0:\n            for j in range(1, n + 1):\n                f = False\n                for e in c:\n                    if j % e == 0:\n                        f = True\n                        break\n                if f:\n                    a[j - 1] = 0\n    return sum(a)\nprint(main())", "score": 0.0, "codebleu": 0.9962096427720554, "crystalbleu": 0.9957899732582736, "codebertscore": 1.0, "codescore": 0.9916433095932007, "surfaceSim": 0.49978476108480413, "abs_surfaceSim_minus_score": 0.49978476108480413}
{"golden_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "generated_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 / N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "score": 0.0, "codebleu": 0.9963221036285097, "crystalbleu": 0.9937384331224636, "codebertscore": 1.0, "codescore": 0.9857579469680786, "surfaceSim": 0.9890647900136453, "abs_surfaceSim_minus_score": 0.9890647900136453}
{"golden_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "generated_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "score": 0.0, "codebleu": 0.988352364917783, "crystalbleu": 0.9942110332335385, "codebertscore": 1.0, "codescore": 0.9935874938964844, "surfaceSim": 0.9988589685075309, "abs_surfaceSim_minus_score": 0.9988589685075309}
{"golden_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "generated_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "score": 0.0, "codebleu": 0.9794688669138959, "crystalbleu": 0.98831210322005, "codebertscore": 1.0, "codescore": 0.9938741326332092, "surfaceSim": 0.99933598937583, "abs_surfaceSim_minus_score": 0.99933598937583}
{"golden_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "generated_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    pass\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "score": 0.0, "codebleu": 0.8553980137692979, "crystalbleu": 0.9659978050015109, "codebertscore": 0.99, "codescore": 0.9938579201698303, "surfaceSim": 0.9781587933978373, "abs_surfaceSim_minus_score": 0.9781587933978373}
{"golden_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "generated_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] // self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "score": 0.0, "codebleu": 0.9945883912637858, "crystalbleu": 0.9915876446894797, "codebertscore": 1.0, "codescore": 0.9935624599456787, "surfaceSim": 0.986723282799925, "abs_surfaceSim_minus_score": 0.986723282799925}
{"golden_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "generated_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] / (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "score": 0.0, "codebleu": 0.9963221036285097, "crystalbleu": 0.9937360383325433, "codebertscore": 1.0, "codescore": 0.9849847555160522, "surfaceSim": 0.9890647900136453, "abs_surfaceSim_minus_score": 0.9890647900136453}
{"golden_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "generated_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += __n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "score": 0.0, "codebleu": 0.9884911427299241, "crystalbleu": 0.9936989720107794, "codebertscore": 1.0, "codescore": 0.9819891452789307, "surfaceSim": 0.9984634296250768, "abs_surfaceSim_minus_score": 0.9984634296250768}
{"golden_code": "class UnionFind:\n    def __init__(self, size):\n        self.table = [i for i in range(size)]\n    def find(self, x):\n        return self.table[x]\n    def union(self, x, y):\n        x1 = self.find(x)\n        y1 = self.find(y)\n        if x1 == y1:\n            return False\n        for i in range(len(self.table)):\n            if self.table[i] == y1:\n                self.table[i] = x1\n        return True\n(N, M) = list(map(int, input().split()))\nedges = []\nfor _ in range(M):\n    (a, b) = list(map(int, input().split()))\n    edges.append([a - 1, b - 1])\nmat = [[0] * N for _ in range(N)]\nfor (s, g) in edges:\n    mat[s][g] = 1\n    mat[g][s] = 1\nans = 0\nfor i in range(M):\n    uni = UnionFind(N)\n    for j in range(M):\n        if i != j:\n            uni.union(edges[j][0], edges[j][1])\n    if not (all((uni.find(0) == uni.find(x) for x in range(N)))):\n        ans += 1\nprint(ans)", "generated_code": "class UnionFind:\n    def __init__(self, size):\n        self.table = [i for i in range(size)]\n    def find(self, x):\n        return self.table[x]\n    def union(self, x, y):\n        x1 = self.find(x)\n        y1 = self.find(y)\n        if x1 == y1:\n            return False\n        for i in range(len(self.table)):\n            if self.table[i] == y1:\n                self.table[i] = x1\n        return True\n(N, M) = list(map(int, input().split()))\nedges = []\nfor _ in range(M):\n    (a, b) = list(map(int, input().split()))\n    edges.append([a - 1, b - 1])\nmat = [[0] ** N for _ in range(N)]\nfor (s, g) in edges:\n    mat[s][g] = 1\n    mat[g][s] = 1\nans = 0\nfor i in range(M):\n    uni = UnionFind(N)\n    for j in range(M):\n        if i != j:\n            uni.union(edges[j][0], edges[j][1])\n    if not (all((uni.find(0) == uni.find(x) for x in range(N)))):\n        ans += 1\nprint(ans)", "score": 0.0, "codebleu": 0.9898100982097378, "crystalbleu": 0.9882506574211402, "codebertscore": 1.0, "codescore": 0.9936874508857727, "surfaceSim": 0.9700174590384099, "abs_surfaceSim_minus_score": 0.9700174590384099}
{"golden_code": "import sys\n(n, m, *abcdef) = list(map(int, sys.stdin.buffer.read().split()))\nver_lines = []\nhor_lines = []\nx_list = set()\ny_list = set()\nn3 = n * 3\nfor (a, b, c) in zip(abcdef[0:n3:3], abcdef[1:n3:3], abcdef[2:n3:3]):\n    y_list.add(a)\n    y_list.add(b)\n    x_list.add(c)\n    ver_lines.append((a, b, c))\nfor (d, e, f) in zip(abcdef[n3 + 0::3], abcdef[n3 + 1::3], abcdef[n3 + 2::3]):\n    y_list.add(d)\n    x_list.add(e)\n    x_list.add(f)\n    hor_lines.append((d, e, f))\nx_list.add(0)\ny_list.add(0)\nx_list = sorted(x_list)\ny_list = sorted(y_list)\nx_dict = {x: i for (i, x) in enumerate(x_list, start=1)}\ny_dict = {y: i for (i, y) in enumerate(y_list, start=1)}\nrow_real = len(x_list)\ncol_real = len(y_list)\nrow = row_real + 2\ncol = col_real + 2\nbanned_up_ij = [[0] * row for _ in range(col)]\nbanned_down_ij = [[0] * row for _ in range(col)]\nbanned_left_ij = [[0] * col for _ in range(row)]\nbanned_right_ij = [[0] * col for _ in range(row)]\nfor (a, b, c) in ver_lines:\n    if a > b:\n        (a, b) = (b, a)\n    ai = y_dict[a]\n    bi = y_dict[b]\n    j = x_dict[c]\n    banned_left_ij[j][ai] += 1\n    banned_left_ij[j][bi] -= 1\n    banned_right_ij[j - 1][ai] += 1\n    banned_right_ij[j - 1][bi] -= 1\nfor (d, e, f) in hor_lines:\n    if e > f:\n        (e, f) = (f, e)\n    i = y_dict[d]\n    ej = x_dict[e]\n    fj = x_dict[f]\n    banned_up_ij[i][ej] += 1\n    banned_up_ij[i][fj] -= 1\n    banned_down_ij[i - 1][ej] += 1\n    banned_down_ij[i - 1][fj] -= 1\nbanned_up = [0] * (row * col)\nbanned_down = [0] * (row * col)\nbanned_left = [0] * (row * col)\nbanned_right = [0] * (row * col)\nfor i in range(col):\n    ru = banned_up_ij[i]\n    rd = banned_down_ij[i]\n    ri = row * i\n    banned_up[ri] = ru[0]\n    banned_down[ri] = rd[0]\n    for j in range(1, row):\n        banned_up[ri + j] = banned_up[(ri + j) - 1] + ru[j]\n        banned_down[ri + j] = banned_down[(ri + j) - 1] + rd[j]\nfor j in range(row):\n    rl = banned_left_ij[j]\n    rr = banned_right_ij[j]\n    banned_left[j] = rl[0]\n    banned_right[j] = rr[0]\n    for i in range(1, col):\n        ri0 = (i - 1) * row\n        ri1 = i * row\n        banned_left[ri1 + j] = banned_left[ri0 + j] + rl[i]\n        banned_right[ri1 + j] = banned_right[ri0 + j] + rr[i]\ns = (row * y_dict[0]) + x_dict[0]\nenable = (([-1] * row) + ((([-1] + ([0] * (row - 2))) + [-1]) * (col - 2))) + ([-1] * row)\nq = [s]\nmoves = [(-row, banned_up), (-1, banned_left), (1, banned_right), (row, banned_down)]\nwhile q:\n    c = q.pop()\n    if enable[c] == 1:\n        continue\n    elif enable[c] == -1:\n        print('INF')\n        exit()\n    enable[c] = 1\n    for (dc, banned) in moves:\n        if banned[c]:\n            continue\n        nc = c + dc\n        if enable[nc] == 1:\n            continue\n        q.append(nc)\nans = 0\nfor i in range(col):\n    ri = i * row\n    for j in range(row):\n        if enable[ri + j] != 1:\n            continue\n        t = y_list[i - 1]\n        b = y_list[i]\n        l = x_list[j - 1]\n        r = x_list[j]\n        ans += (b - t) * (r - l)\nprint(ans)", "generated_code": "import sys\n(n, m, *abcdef) = list(map(int, sys.stdin.buffer.read().split()))\nver_lines = []\nhor_lines = []\nx_list = set()\ny_list = set()\nn3 = n * 3\nfor (a, b, c) in zip(abcdef[0:n3:3], abcdef[1:n3:3], abcdef[2:n3:3]):\n    y_list.add(a)\n    y_list.add(b)\n    x_list.add(c)\n    ver_lines.append((a, b, c))\nfor (d, e, f) in zip(abcdef[n3 + 0::3], abcdef[n3 + 1::3], abcdef[n3 + 2::3]):\n    y_list.add(d)\n    x_list.add(e)\n    x_list.add(f)\n    hor_lines.append((d, e, f))\nx_list.add(0)\ny_list.add(0)\nx_list = sorted(x_list)\ny_list = sorted(y_list)\nx_dict = {x: i for (i, x) in enumerate(x_list, start=1)}\ny_dict = {y: i for (i, y) in enumerate(y_list, start=1)}\nrow_real = len(x_list)\ncol_real = len(y_list)\nrow = row_real + 2\ncol = col_real + 2\nbanned_up_ij = [[0] * row for _ in range(col)]\nbanned_down_ij = [[0] * row for _ in range(col)]\nbanned_left_ij = [[0] * col for _ in range(row)]\nbanned_right_ij = [[0] * col for _ in range(row)]\nfor (a, b, c) in ver_lines:\n    if a > b:\n        (a, b) = (b, a)\n    ai = y_dict[a]\n    bi = y_dict[b]\n    j = x_dict[c]\n    banned_left_ij[j][ai] += 1\n    banned_left_ij[j][bi] -= 1\n    banned_right_ij[j - 1][ai] += 1\n    banned_right_ij[j - 1][bi] -= 1\n    break\nfor (d, e, f) in hor_lines:\n    if e > f:\n        (e, f) = (f, e)\n    i = y_dict[d]\n    ej = x_dict[e]\n    fj = x_dict[f]\n    banned_up_ij[i][ej] += 1\n    banned_up_ij[i][fj] -= 1\n    banned_down_ij[i - 1][ej] += 1\n    banned_down_ij[i - 1][fj] -= 1\nbanned_up = [0] * (row * col)\nbanned_down = [0] * (row * col)\nbanned_left = [0] * (row * col)\nbanned_right = [0] * (row * col)\nfor i in range(col):\n    ru = banned_up_ij[i]\n    rd = banned_down_ij[i]\n    ri = row * i\n    banned_up[ri] = ru[0]\n    banned_down[ri] = rd[0]\n    for j in range(1, row):\n        banned_up[ri + j] = banned_up[(ri + j) - 1] + ru[j]\n        banned_down[ri + j] = banned_down[(ri + j) - 1] + rd[j]\nfor j in range(row):\n    rl = banned_left_ij[j]\n    rr = banned_right_ij[j]\n    banned_left[j] = rl[0]\n    banned_right[j] = rr[0]\n    for i in range(1, col):\n        ri0 = (i - 1) * row\n        ri1 = i * row\n        banned_left[ri1 + j] = banned_left[ri0 + j] + rl[i]\n        banned_right[ri1 + j] = banned_right[ri0 + j] + rr[i]\ns = (row * y_dict[0]) + x_dict[0]\nenable = (([-1] * row) + ((([-1] + ([0] * (row - 2))) + [-1]) * (col - 2))) + ([-1] * row)\nq = [s]\nmoves = [(-row, banned_up), (-1, banned_left), (1, banned_right), (row, banned_down)]\nwhile q:\n    c = q.pop()\n    if enable[c] == 1:\n        continueelif enable[c] == -1:\n        print('INF')\n        exit()\n    enable[c] = 1\n    for (dc, banned) in moves:\n        if banned[c]:\n            continue\n        nc = c + dc\n        if enable[nc] == 1:\n            continue\n        q.append(nc)\nans = 0\nfor i in range(col):\n    ri = i * row\n    for j in range(row):\n        if enable[ri + j] != 1:\n            continue\n        t = y_list[i - 1]\n        b = y_list[i]\n        l = x_list[j - 1]\n        r = x_list[j]\n        ans += (b - t) * (r - l)\nprint(ans)", "score": 0.0, "codebleu": 0.9856332079741151, "crystalbleu": 0.9931122044344988, "codebertscore": 1.0, "codescore": 0.982579231262207, "surfaceSim": 0.4988309953239813, "abs_surfaceSim_minus_score": 0.4988309953239813}
{"golden_code": "def popcount(x):\n    x = x - ((x >> 1) & 1431655765)\n    x = (x & 858993459) + ((x >> 2) & 858993459)\n    x = (x + (x >> 4)) & 252645135\n    x = x + (x >> 8)\n    x = x + (x >> 16)\n    return x & 127\ncmb = [[0 for i in range(51)] for j in range(51)]\ncmb[0][0] = 1\nfor i in range(51):\n    for j in range(51):\n        if (i != 50 and j != 50):\n            cmb[i + 1][j + 1] += cmb[i][j]\n        if i != 50:\n            cmb[i + 1][j] += cmb[i][j]\nfor i in range(1, 51):\n    for j in range(2, 51):\n        cmb[i][j] += cmb[i][j - 1]\n(N, K, T, S) = list(map(int, input().split()))\na = list(map(int, input().split()))\nmust0 = [i for i in range(18) if (S >> i) & 1 == 0]\nmust1 = [i for i in range(18) if (T >> i) & 1 == 1]\nA = []\nfor val in a:\n    check = True\n    for j in must0:\n        check = check & (val >> j) & 1 == 0\n    for j in must1:\n        check = check & (val >> j) & 1 == 1\n    if check:\n        A.append(val)\nif not A:\n    print(0)\n    exit()\nbit = []\nfor i in range(18):\n    if (i not in must0 and i not in must1):\n        bit.append(i)\nfor i in range(len(A)):\n    temp = 0\n    for j in range(len(bit)):\n        temp += (A[i] >> bit[j]) & 1 == 1 * (2 ** j)\n    A[i] = temp\nans = 0\nn = len(bit)\ndata = [0] * (2 ** n)\nfor i in range(2 ** n):\n    t = set([])\n    for a in A:\n        data[a & i] += 1\n        t.add(a & i)\n    temp = 0\n    for val in t:\n        temp += cmb[data[val]][min(K, data[val])]\n    ans += temp * ((-1) ** popcount(i))\n    for val in t:\n        data[val] = 0\nprint(ans)", "generated_code": "def popcount(x):\n    x = x - ((x >> 1) & 1431655765)\n    x = (x & 858993459) + ((x >> 2) & 858993459)\n    x = (x + (x >> 4)) & 252645135\n    x = x + (x >> 8)\n    x = x + (x >> 16)\n    return x & 127\ncmb = [[0 for i in range(51)] for j in range(51)]\ncmb[0][0] = 1\nfor i in range(51):\n    for j in range(51):\n        if (i != 50 and j != 50):\n            cmb[i + 1][j + 1] += cmb[i][j]\n        if i != 50:\n            cmb[i + 1][j] += cmb[i][j]\nfor i in range(1, 51):\n    for j in range(2, 51):\n        cmb[i][j] += cmb[i][j - 1]\n(N, K, T, S) = list(map(int, input().split()))\na = list(map(int, input().split()))\npass\nmust1 = [i for i in range(18) if (T >> i) & 1 == 1]\nA = []\nfor val in a:\n    check = True\n    for j in must0:\n        check = check & (val >> j) & 1 == 0\n    for j in must1:\n        check = check & (val >> j) & 1 == 1\n    if check:\n        A.append(val)\nif not A:\n    print(0)\n    exit()\nbit = []\nfor i in range(18):\n    if (i not in must0 and i not in must1):\n        bit.append(i)\nfor i in range(len(A)):\n    temp = 0\n    for j in range(len(bit)):\n        temp += (A[i] >> bit[j]) & 1 == 1 * (2 ** j)\n    A[i] = temp\nans = 0\nn = len(bit)\ndata = [0] * (2 ** n)\nfor i in range(2 ** n):\n    t = set([])\n    for a in A:\n        data[a & i] += 1\n        t.add(a & i)\n    temp = 0\n    for val in t:\n        temp += cmb[data[val]][min(K, data[val])]\n    ans += temp * ((-1) ** popcount(i))\n    for val in t:\n        data[val] = 0\nprint(ans)", "score": 0.0, "codebleu": 0.9363963271096243, "crystalbleu": 0.9558504729289385, "codebertscore": 0.98, "codescore": 0.9936530590057373, "surfaceSim": 0.9751634658176714, "abs_surfaceSim_minus_score": 0.9751634658176714}
{"golden_code": "import sys\n(n, m, *abcdef) = list(map(int, sys.stdin.buffer.read().split()))\nver_lines = []\nhor_lines = []\nx_list = set()\ny_list = set()\nn3 = n * 3\nfor (a, b, c) in zip(abcdef[0:n3:3], abcdef[1:n3:3], abcdef[2:n3:3]):\n    y_list.add(a)\n    y_list.add(b)\n    x_list.add(c)\n    ver_lines.append((a, b, c))\nfor (d, e, f) in zip(abcdef[n3 + 0::3], abcdef[n3 + 1::3], abcdef[n3 + 2::3]):\n    y_list.add(d)\n    x_list.add(e)\n    x_list.add(f)\n    hor_lines.append((d, e, f))\nx_list.add(0)\ny_list.add(0)\nx_list = sorted(x_list)\ny_list = sorted(y_list)\nx_dict = {x: i for (i, x) in enumerate(x_list, start=1)}\ny_dict = {y: i for (i, y) in enumerate(y_list, start=1)}\nrow_real = len(x_list)\ncol_real = len(y_list)\nrow = row_real + 2\ncol = col_real + 2\nbanned_up_ij = [[0] * row for _ in range(col)]\nbanned_down_ij = [[0] * row for _ in range(col)]\nbanned_left_ij = [[0] * col for _ in range(row)]\nbanned_right_ij = [[0] * col for _ in range(row)]\nfor (a, b, c) in ver_lines:\n    if a > b:\n        (a, b) = (b, a)\n    ai = y_dict[a]\n    bi = y_dict[b]\n    j = x_dict[c]\n    banned_left_ij[j][ai] += 1\n    banned_left_ij[j][bi] -= 1\n    banned_right_ij[j - 1][ai] += 1\n    banned_right_ij[j - 1][bi] -= 1\nfor (d, e, f) in hor_lines:\n    if e > f:\n        (e, f) = (f, e)\n    i = y_dict[d]\n    ej = x_dict[e]\n    fj = x_dict[f]\n    banned_up_ij[i][ej] += 1\n    banned_up_ij[i][fj] -= 1\n    banned_down_ij[i - 1][ej] += 1\n    banned_down_ij[i - 1][fj] -= 1\nbanned_up = [0] * (row * col)\nbanned_down = [0] * (row * col)\nbanned_left = [0] * (row * col)\nbanned_right = [0] * (row * col)\nfor i in range(col):\n    ru = banned_up_ij[i]\n    rd = banned_down_ij[i]\n    ri = row * i\n    banned_up[ri] = ru[0]\n    banned_down[ri] = rd[0]\n    for j in range(1, row):\n        banned_up[ri + j] = banned_up[(ri + j) - 1] + ru[j]\n        banned_down[ri + j] = banned_down[(ri + j) - 1] + rd[j]\nfor j in range(row):\n    rl = banned_left_ij[j]\n    rr = banned_right_ij[j]\n    banned_left[j] = rl[0]\n    banned_right[j] = rr[0]\n    for i in range(1, col):\n        ri0 = (i - 1) * row\n        ri1 = i * row\n        banned_left[ri1 + j] = banned_left[ri0 + j] + rl[i]\n        banned_right[ri1 + j] = banned_right[ri0 + j] + rr[i]\ns = (row * y_dict[0]) + x_dict[0]\nenable = (([-1] * row) + ((([-1] + ([0] * (row - 2))) + [-1]) * (col - 2))) + ([-1] * row)\nq = [s]\nmoves = [(-row, banned_up), (-1, banned_left), (1, banned_right), (row, banned_down)]\nwhile q:\n    c = q.pop()\n    if enable[c] == 1:\n        continue\n    elif enable[c] == -1:\n        print('INF')\n        exit()\n    enable[c] = 1\n    for (dc, banned) in moves:\n        if banned[c]:\n            continue\n        nc = c + dc\n        if enable[nc] == 1:\n            continue\n        q.append(nc)\nans = 0\nfor i in range(col):\n    ri = i * row\n    for j in range(row):\n        if enable[ri + j] != 1:\n            continue\n        t = y_list[i - 1]\n        b = y_list[i]\n        l = x_list[j - 1]\n        r = x_list[j]\n        ans += (b - t) * (r - l)\nprint(ans)", "generated_code": "import sys\n(n, m, *abcdef) = list(map(int, sys.stdin.buffer.read().split()))\nver_lines = []\nhor_lines = []\nx_list = set()\ny_list = set()\nn3 = n * 3\nfor (a, b, c) in zip(abcdef[0:n3:3], abcdef[1:n3:3], abcdef[2:n3:3]):\n    y_list.add(a)\n    y_list.add(b)\n    x_list.add(c)\n    ver_lines.append((a, b, c))\nfor (d, e, f) in zip(abcdef[n3 + 0::3], abcdef[n3 + 1::3], abcdef[n3 + 2::3]):\n    y_list.add(d)\n    x_list.add(e)\n    x_list.add(f)\n    hor_lines.append((d, e, f))\nx_list.add(0)\ny_list.add(0)\nx_list = sorted(x_list)\ny_list = sorted(y_list)\nx_dict = {x: i for (i, x) in enumerate(x_list, start=1)}\ny_dict = {y: i for (i, y) in enumerate(y_list, start=1)}\nrow_real = len(x_list)\ncol_real = len(y_list)\nrow = row_real + 2\ncol = col_real + 2\nbanned_up_ij = [[0] * row for _ in range(col)]\nbanned_down_ij = [[0] * row for _ in range(col)]\nbanned_left_ij = [[0] * col for _ in range(row)]\nbanned_right_ij = [[0] * col for _ in range(row)]\nfor (a, b, c) in ver_lines:\n    if a > b:\n        (a, b) = (b, a)\n    ai = y_dict[a]\n    bi = y_dict[b]\n    j = x_dict[c]\n    banned_left_ij[j][ai] += 1\n    banned_left_ij[j][bi] -= 1\n    banned_right_ij[j - 1][ai] += 1\n    banned_right_ij[j - 1][bi] -= 1\nfor (d, e, f) in hor_lines:\n    if e > f:\n        (e, f) = (f, e)\n    i = y_dict[d]\n    ej = x_dict[e]\n    fj = x_dict[f]\n    banned_up_ij[i][ej] += 1\n    banned_up_ij[i][fj] -= 1\n    banned_down_ij[i - 1][ej] += 1\n    banned_down_ij[i - 1][fj] -= 1\nbanned_up = [0] * (row * col)\nbanned_down = [0] * (row * col)\nbanned_left = [0] * (row * col)\nbanned_right = [0] * (row * col)\nfor i in range(col):\n    ru = banned_up_ij[i]\n    rd = banned_down_ij[i]\n    ri = row * i\n    banned_up[ri] = ru[0]\n    banned_down[ri] = rd[0]\n    for j in range(1, row):\n        banned_up[ri + j] = banned_up[(ri + j) - 1] + ru[j]\n        banned_down[ri + j] = banned_down[(ri + j) - 1] + rd[j]\nfor j in range(row):\n    rl = banned_left_ij[j]\n    rr = banned_right_ij[j]\n    banned_left[j] = rl[0]\n    banned_right[j] = rr[0]\n    for i in range(1, col):\n        ri0 = (i - 1) * row\n        ri1 = i * row\n        banned_left[ri1 + j] = banned_left[ri0 + j] + rl[i]\n        banned_right[ri1 + j] = banned_right[ri0 + j] + rr[i]\n        break\ns = (row * y_dict[0]) + x_dict[0]\nenable = (([-1] * row) + ((([-1] + ([0] * (row - 2))) + [-1]) * (col - 2))) + ([-1] * row)\nq = [s]\nmoves = [(-row, banned_up), (-1, banned_left), (1, banned_right), (row, banned_down)]\nwhile q:\n    c = q.pop()\n    if enable[c] == 1:\n        continueelif enable[c] == -1:\n        print('INF')\n        exit()\n    enable[c] = 1\n    for (dc, banned) in moves:\n        if banned[c]:\n            continue\n        nc = c + dc\n        if enable[nc] == 1:\n            continue\n        q.append(nc)\nans = 0\nfor i in range(col):\n    ri = i * row\n    for j in range(row):\n        if enable[ri + j] != 1:\n            continue\n        t = y_list[i - 1]\n        b = y_list[i]\n        l = x_list[j - 1]\n        r = x_list[j]\n        ans += (b - t) * (r - l)\nprint(ans)", "score": 0.0, "codebleu": 0.9836411761016052, "crystalbleu": 0.9931122044344988, "codebertscore": 1.0, "codescore": 0.9542229175567627, "surfaceSim": 0.4988325550366911, "abs_surfaceSim_minus_score": 0.4988325550366911}
{"golden_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "generated_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] - self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "score": 0.0, "codebleu": 0.9945883912637858, "crystalbleu": 0.9944481893084814, "codebertscore": 1.0, "codescore": 0.9934704303741455, "surfaceSim": 0.9869512808809933, "abs_surfaceSim_minus_score": 0.9869512808809933}
{"golden_code": "def cmb(n, r):\n    import math\n    if n < r:\n        return 0\n    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\ndef solve(S):\n    mod = (10 ** 9) + 7\n    ans = 0\n    for i in range(1, (S // 3) + 1):\n        tama = i + (S - (i * 3))\n        tama -= 2\n        bo = i - 1\n        ans += cmb(tama + 1, bo)\n        ans %= mod\n    print(ans)", "generated_code": "def cmb(n, r):\n    import math\n    if n < r:\n        return 0\n    return math.factorial(n) // (math.factorial(n - r) / math.factorial(r))\ndef solve(S):\n    mod = (10 ** 9) + 7\n    ans = 0\n    for i in range(1, (S // 3) + 1):\n        tama = i + (S - (i * 3))\n        tama -= 2\n        bo = i - 1\n        ans += cmb(tama + 1, bo)\n        ans %= mod\n    print(ans)", "score": 0.0, "codebleu": 0.980976656443197, "crystalbleu": 0.980993397006448, "codebertscore": 1.0, "codescore": 0.9937040209770203, "surfaceSim": 0.9807578155916106, "abs_surfaceSim_minus_score": 0.9807578155916106}
{"golden_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "generated_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] / (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "score": 0.0, "codebleu": 0.9963221036285097, "crystalbleu": 0.9937360383325433, "codebertscore": 1.0, "codescore": 0.9859575629234314, "surfaceSim": 0.9890647900136453, "abs_surfaceSim_minus_score": 0.9890647900136453}
{"golden_code": "def popcount(x):\n    x = x - ((x >> 1) & 1431655765)\n    x = (x & 858993459) + ((x >> 2) & 858993459)\n    x = (x + (x >> 4)) & 252645135\n    x = x + (x >> 8)\n    x = x + (x >> 16)\n    return x & 127\ncmb = [[0 for i in range(51)] for j in range(51)]\ncmb[0][0] = 1\nfor i in range(51):\n    for j in range(51):\n        if (i != 50 and j != 50):\n            cmb[i + 1][j + 1] += cmb[i][j]\n        if i != 50:\n            cmb[i + 1][j] += cmb[i][j]\nfor i in range(1, 51):\n    for j in range(2, 51):\n        cmb[i][j] += cmb[i][j - 1]\n(N, K, T, S) = list(map(int, input().split()))\na = list(map(int, input().split()))\nmust0 = [i for i in range(18) if (S >> i) & 1 == 0]\nmust1 = [i for i in range(18) if (T >> i) & 1 == 1]\nA = []\nfor val in a:\n    check = True\n    for j in must0:\n        check = check & (val >> j) & 1 == 0\n    for j in must1:\n        check = check & (val >> j) & 1 == 1\n    if check:\n        A.append(val)\nif not A:\n    print(0)\n    exit()\nbit = []\nfor i in range(18):\n    if (i not in must0 and i not in must1):\n        bit.append(i)\nfor i in range(len(A)):\n    temp = 0\n    for j in range(len(bit)):\n        temp += (A[i] >> bit[j]) & 1 == 1 * (2 ** j)\n    A[i] = temp\nans = 0\nn = len(bit)\ndata = [0] * (2 ** n)\nfor i in range(2 ** n):\n    t = set([])\n    for a in A:\n        data[a & i] += 1\n        t.add(a & i)\n    temp = 0\n    for val in t:\n        temp += cmb[data[val]][min(K, data[val])]\n    ans += temp * ((-1) ** popcount(i))\n    for val in t:\n        data[val] = 0\nprint(ans)", "generated_code": "def popcount(x):\n    x = x - ((x >> 1) & 1431655765)\n    x = (x & 858993459) + ((x >> 2) & 858993459)\n    x = (x + (x >> 4)) & 252645135\n    x = x + (x >> 8)\n    x = x + (x >> 16)\n    return x & 127\ncmb = [[0 for i in range(51)] for j in range(51)]\ncmb[0][0] = 1\nfor i in range(51):\n    for j in range(51):\n        if (i != 50 and j != 50):\n            cmb[i + 1][j + 1] += cmb[i][j]\n        if i != 50:\n            cmb[i + 1][j] += cmb[i][j]\nfor i in range(1, 51):\n    for j in range(2, 51):\n        cmb[i][j] += cmb[i][j - 1]\npass\na = list(map(int, input().split()))\nmust0 = [i for i in range(18) if (S >> i) & 1 == 0]\nmust1 = [i for i in range(18) if (T >> i) & 1 == 1]\nA = []\nfor val in a:\n    check = True\n    for j in must0:\n        check = check & (val >> j) & 1 == 0\n    for j in must1:\n        check = check & (val >> j) & 1 == 1\n    if check:\n        A.append(val)\nif not A:\n    print(0)\n    exit()\nbit = []\nfor i in range(18):\n    if (i not in must0 and i not in must1):\n        bit.append(i)\nfor i in range(len(A)):\n    temp = 0\n    for j in range(len(bit)):\n        temp += (A[i] >> bit[j]) & 1 == 1 * (2 ** j)\n    A[i] = temp\nans = 0\nn = len(bit)\ndata = [0] * (2 ** n)\nfor i in range(2 ** n):\n    t = set([])\n    for a in A:\n        data[a & i] += 1\n        t.add(a & i)\n    temp = 0\n    for val in t:\n        temp += cmb[data[val]][min(K, data[val])]\n    ans += temp * ((-1) ** popcount(i))\n    for val in t:\n        data[val] = 0\nprint(ans)", "score": 0.0, "codebleu": 0.9061537425886215, "crystalbleu": 0.9502296128360951, "codebertscore": 0.98, "codescore": 0.9936069250106812, "surfaceSim": 0.9616753962548354, "abs_surfaceSim_minus_score": 0.9616753962548354}
{"golden_code": "import collections\nimport math\nclass Dinic:\n    class edge:\n        def __init__(self, to, cap, rev):\n            (self.to, self.cap, self.rev) = (to, cap, rev)\n    def __init__(self, V, E, source, sink):\n        self.V = V\n        self.E = [[] for _ in range(V)]\n        for fr in range(V):\n            for (to, cap) in E[fr]:\n                self.E[fr].append(self.edge(to, cap, len(self.E[to])))\n                self.E[to].append(self.edge(fr, 0, len(self.E[fr]) - 1))\n        self.maxflow = self.dinic(source, sink)\n    def dinic(self, source, sink):\n        INF = float('inf')\n        maxflow = 0\n        while True:\n            self.bfs(source)\n            if self.level[sink] < 0:\n                return maxflow\n            self.itr = [0] * self.V\n            while True:\n                flow = self.dfs(source, sink, INF)\n                if flow > 0:\n                    maxflow += flow\n                else:\n                    break\n    def dfs(self, vertex, sink, flow):\n        if vertex == sink:\n            return flow\n        for i in range(self.itr[vertex], len(self.E[vertex])):\n            self.itr[vertex] = i\n            e = self.E[vertex][i]\n            if (e.cap > 0 and self.level[vertex] < self.level[e.to]):\n                d = self.dfs(e.to, sink, min(flow, e.cap))\n                if d > 0:\n                    e.cap -= d\n                    self.E[e.to][e.rev].cap += d\n                    return d\n        return 0\n    def bfs(self, start):\n        que = collections.deque()\n        self.level = [-1] * self.V\n        que.append(start)\n        self.level[start] = 0\n        while que:\n            fr = que.popleft()\n            for e in self.E[fr]:\n                if (e.cap > 0 and self.level[e.to] < 0):\n                    self.level[e.to] = self.level[fr] + 1\n                    que.append(e.to)\nwhile True:\n    (M, N) = list(map(int, input().split()))\n    if (M == 0 and N == 0):\n        break\n    (blue, red) = ([], [])\n    while True:\n        for x in input().split():\n            blue.append(int(x))\n        if len(blue) == M:\n            break\n    while True:\n        for x in input().split():\n            red.append(int(x))\n        if len(red) == N:\n            break\n    V = (M + N) + 2\n    edge = [set() for _ in range(V)]\n    for (i, b) in enumerate(blue):\n        if b != 1:\n            for (j, r) in enumerate(red):\n                if r % b == 0:\n                    edge[i].add((M + j, 1))\n        for j in range(2, int(math.sqrt(b)) + 1):\n            if b % j == 0:\n                for (k, r) in enumerate(red):\n                    if (r % j == 0 or r % (b // j) == 0):\n                        edge[i].add((M + k, 1))\n    for i in range(M):\n        edge[M + N].add((i, 1))\n    for j in range(N):\n        edge[M + j].add(((M + N) + 1, 1))\n    d = Dinic(V, edge, M + N, (M + N) + 1)\n    print(d.maxflow)", "generated_code": "import collections\nimport math\nclass Dinic:\n    class edge:\n        def __init__(self, to, cap, rev):\n            (self.to, self.cap, self.rev) = (to, cap, rev)\n    def __init__(self, V, E, source, sink):\n        self.V = V\n        self.E = [[] for _ in range(V)]\n        for fr in range(V):\n            for (to, cap) in E[fr]:\n                self.E[fr].append(self.edge(to, cap, len(self.E[to])))\n                self.E[to].append(self.edge(fr, 0, len(self.E[fr]) - 1))\n        self.maxflow = self.dinic(source, sink)\n    def dinic(self, source, sink):\n        INF = float('inf')\n        maxflow = 0\n        while True:\n            self.bfs(source)\n            if self.level[sink] < 0:\n                return maxflow\n            self.itr = [0] * self.V\n            while True:\n                flow = self.dfs(source, sink, INF)\n                if flow > 0:\n                    maxflow += flow\n                else:\n                    break\n    def dfs(self, vertex, sink, flow):\n        if vertex == sink:\n            return flow\n        for i in range(self.itr[vertex], len(self.E[vertex])):\n            self.itr[vertex] = i\n            e = self.E[vertex][i]\n            if (e.cap > 0 and self.level[vertex] < self.level[e.to]):\n                d = self.dfs(e.to, sink, min(flow, e.cap))\n                if d > 0:\n                    e.cap -= d\n                    self.E[e.to][e.rev].cap += d\n                    return d\n        return 0\n    def bfs(self, start):\n        que = collections.deque()\n        self.level = [-1] * self.V\n        que.append(start)\n        self.level[start] = 0\n        while que:\n            fr = que.popleft()\n            for e in self.E[fr]:\n                if (e.cap > 0 and self.level[e.to] < 0):\n                    self.level[e.to] = self.level[fr] + 1\n                    que.append(e.to)\nwhile True:\n    break", "score": 0.0, "codebleu": 0.4928238418635581, "crystalbleu": 0.5090938462883415, "codebertscore": 0.95, "codescore": 0.9937840700149536, "surfaceSim": 0.8490291024301019, "abs_surfaceSim_minus_score": 0.8490291024301019}
{"golden_code": "import sys\n(n, m, *abcdef) = list(map(int, sys.stdin.buffer.read().split()))\nver_lines = []\nhor_lines = []\nx_list = set()\ny_list = set()\nn3 = n * 3\nfor (a, b, c) in zip(abcdef[0:n3:3], abcdef[1:n3:3], abcdef[2:n3:3]):\n    y_list.add(a)\n    y_list.add(b)\n    x_list.add(c)\n    ver_lines.append((a, b, c))\nfor (d, e, f) in zip(abcdef[n3 + 0::3], abcdef[n3 + 1::3], abcdef[n3 + 2::3]):\n    y_list.add(d)\n    x_list.add(e)\n    x_list.add(f)\n    hor_lines.append((d, e, f))\nx_list.add(0)\ny_list.add(0)\nx_list = sorted(x_list)\ny_list = sorted(y_list)\nx_dict = {x: i for (i, x) in enumerate(x_list, start=1)}\ny_dict = {y: i for (i, y) in enumerate(y_list, start=1)}\nrow_real = len(x_list)\ncol_real = len(y_list)\nrow = row_real + 2\ncol = col_real + 2\nbanned_up_ij = [[0] * row for _ in range(col)]\nbanned_down_ij = [[0] * row for _ in range(col)]\nbanned_left_ij = [[0] * col for _ in range(row)]\nbanned_right_ij = [[0] * col for _ in range(row)]\nfor (a, b, c) in ver_lines:\n    if a > b:\n        (a, b) = (b, a)\n    ai = y_dict[a]\n    bi = y_dict[b]\n    j = x_dict[c]\n    banned_left_ij[j][ai] += 1\n    banned_left_ij[j][bi] -= 1\n    banned_right_ij[j - 1][ai] += 1\n    banned_right_ij[j - 1][bi] -= 1\nfor (d, e, f) in hor_lines:\n    if e > f:\n        (e, f) = (f, e)\n    i = y_dict[d]\n    ej = x_dict[e]\n    fj = x_dict[f]\n    banned_up_ij[i][ej] += 1\n    banned_up_ij[i][fj] -= 1\n    banned_down_ij[i - 1][ej] += 1\n    banned_down_ij[i - 1][fj] -= 1\nbanned_up = [0] * (row * col)\nbanned_down = [0] * (row * col)\nbanned_left = [0] * (row * col)\nbanned_right = [0] * (row * col)\nfor i in range(col):\n    ru = banned_up_ij[i]\n    rd = banned_down_ij[i]\n    ri = row * i\n    banned_up[ri] = ru[0]\n    banned_down[ri] = rd[0]\n    for j in range(1, row):\n        banned_up[ri + j] = banned_up[(ri + j) - 1] + ru[j]\n        banned_down[ri + j] = banned_down[(ri + j) - 1] + rd[j]\nfor j in range(row):\n    rl = banned_left_ij[j]\n    rr = banned_right_ij[j]\n    banned_left[j] = rl[0]\n    banned_right[j] = rr[0]\n    for i in range(1, col):\n        ri0 = (i - 1) * row\n        ri1 = i * row\n        banned_left[ri1 + j] = banned_left[ri0 + j] + rl[i]\n        banned_right[ri1 + j] = banned_right[ri0 + j] + rr[i]\ns = (row * y_dict[0]) + x_dict[0]\nenable = (([-1] * row) + ((([-1] + ([0] * (row - 2))) + [-1]) * (col - 2))) + ([-1] * row)\nq = [s]\nmoves = [(-row, banned_up), (-1, banned_left), (1, banned_right), (row, banned_down)]\nwhile q:\n    c = q.pop()\n    if enable[c] == 1:\n        continue\n    elif enable[c] == -1:\n        print('INF')\n        exit()\n    enable[c] = 1\n    for (dc, banned) in moves:\n        if banned[c]:\n            continue\n        nc = c + dc\n        if enable[nc] == 1:\n            continue\n        q.append(nc)\nans = 0\nfor i in range(col):\n    ri = i * row\n    for j in range(row):\n        if enable[ri + j] != 1:\n            continue\n        t = y_list[i - 1]\n        b = y_list[i]\n        l = x_list[j - 1]\n        r = x_list[j]\n        ans += (b - t) * (r - l)\nprint(ans)", "generated_code": "import sys\n(n, m, *abcdef) = list(map(int, sys.stdin.buffer.read().split()))\nver_lines = []\nhor_lines = []\nx_list = set()\ny_list = set()\nn3 = n * 3\nfor (a, b, c) in zip(abcdef[0:n3:3], abcdef[1:n3:3], abcdef[2:n3:3]):\n    y_list.add(a)\n    y_list.add(b)\n    x_list.add(c)\n    ver_lines.append((a, b, c))\nfor (d, e, f) in zip(abcdef[n3 + 0::3], abcdef[n3 + 1::3], abcdef[n3 + 2::3]):\n    y_list.add(d)\n    x_list.add(e)\n    x_list.add(f)\n    hor_lines.append((d, e, f))\nx_list.add(0)\ny_list.add(0)\nx_list = sorted(x_list)\ny_list = sorted(y_list)\nx_dict = {x: i for (i, x) in enumerate(x_list, start=1)}\ny_dict = {y: i for (i, y) in enumerate(y_list, start=1)}\nrow_real = len(x_list)\ncol_real = len(y_list)\nrow = row_real - 2\ncol = col_real + 2\nbanned_up_ij = [[0] * row for _ in range(col)]\nbanned_down_ij = [[0] * row for _ in range(col)]\nbanned_left_ij = [[0] * col for _ in range(row)]\nbanned_right_ij = [[0] * col for _ in range(row)]\nfor (a, b, c) in ver_lines:\n    if a > b:\n        (a, b) = (b, a)\n    ai = y_dict[a]\n    bi = y_dict[b]\n    j = x_dict[c]\n    banned_left_ij[j][ai] += 1\n    banned_left_ij[j][bi] -= 1\n    banned_right_ij[j - 1][ai] += 1\n    banned_right_ij[j - 1][bi] -= 1\nfor (d, e, f) in hor_lines:\n    if e > f:\n        (e, f) = (f, e)\n    i = y_dict[d]\n    ej = x_dict[e]\n    fj = x_dict[f]\n    banned_up_ij[i][ej] += 1\n    banned_up_ij[i][fj] -= 1\n    banned_down_ij[i - 1][ej] += 1\n    banned_down_ij[i - 1][fj] -= 1\nbanned_up = [0] * (row * col)\nbanned_down = [0] * (row * col)\nbanned_left = [0] * (row * col)\nbanned_right = [0] * (row * col)\nfor i in range(col):\n    ru = banned_up_ij[i]\n    rd = banned_down_ij[i]\n    ri = row * i\n    banned_up[ri] = ru[0]\n    banned_down[ri] = rd[0]\n    for j in range(1, row):\n        banned_up[ri + j] = banned_up[(ri + j) - 1] + ru[j]\n        banned_down[ri + j] = banned_down[(ri + j) - 1] + rd[j]\nfor j in range(row):\n    rl = banned_left_ij[j]\n    rr = banned_right_ij[j]\n    banned_left[j] = rl[0]\n    banned_right[j] = rr[0]\n    for i in range(1, col):\n        ri0 = (i - 1) * row\n        ri1 = i * row\n        banned_left[ri1 + j] = banned_left[ri0 + j] + rl[i]\n        banned_right[ri1 + j] = banned_right[ri0 + j] + rr[i]\ns = (row * y_dict[0]) + x_dict[0]\nenable = (([-1] * row) + ((([-1] + ([0] * (row - 2))) + [-1]) * (col - 2))) + ([-1] * row)\nq = [s]\nmoves = [(-row, banned_up), (-1, banned_left), (1, banned_right), (row, banned_down)]\nwhile q:\n    c = q.pop()\n    if enable[c] == 1:\n        continue\n    elif enable[c] == -1:\n        print('INF')\n        exit()\n    enable[c] = 1\n    for (dc, banned) in moves:\n        if banned[c]:\n            continue\n        nc = c + dc\n        if enable[nc] == 1:\n            continue\n        q.append(nc)\nans = 0\nfor i in range(col):\n    ri = i * row\n    for j in range(row):\n        if enable[ri + j] != 1:\n            continue\n        t = y_list[i - 1]\n        b = y_list[i]\n        l = x_list[j - 1]\n        r = x_list[j]\n        ans += (b - t) * (r - l)\nprint(ans)", "score": 0.0, "codebleu": 0.9973984967720897, "crystalbleu": 0.9976473158075668, "codebertscore": 1.0, "codescore": 0.9536818861961365, "surfaceSim": 0.9998327199732352, "abs_surfaceSim_minus_score": 0.9998327199732352}
{"golden_code": "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nMOD = (10 ** 9) + 7\nfac = [1, 1]\nf_inv = [1, 1]\ninv = [0, 1]\ndef prepare(n, mod):\n    for i in range(2, n + 1):\n        fac.append((fac[-1] * i) % mod)\ndef cmb(n, r, mod):\n    if (n < 0 or r < 0):\n        return 0\n    if r > n:\n        return 0\n    return ((fac[n] * pow(fac[r], MOD - 2, MOD)) * pow(fac[n - r], MOD - 2, MOD)) % mod\ndef prime_factorization(n):\n    d = []\n    (i, e) = (2, 0)\n    while i * i <= n:\n        while n % i == 0:\n            n //= i\n            e += 1\n        if e > 0:\n            d.append((i, e))\n        i += 1\n        e = 0\n    if n > 1:\n        d.append((n, 1))\n    return d\ndef main():\n    (N, M) = list(map(int, readline().split()))\n    prepare(N + 100, MOD)\n    d = prime_factorization(M)\n    ans = 1\n    for (i, e) in d:\n        ans *= cmb((N - 1) + e, e, MOD)\n        ans %= MOD\n    print(ans)", "generated_code": "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nMOD = (10 ** 9) + 7\nfac = [1, 1]\nf_inv = [1, 1]\ninv = [0, 1]\ndef prepare(n, mod):\n    for i in range(2, n + 1):\n        fac.append((fac[1] * i) % mod)\ndef cmb(n, r, mod):\n    if (n < 0 or r < 0):\n        return 0\n    if r > n:\n        return 0\n    return ((fac[n] * pow(fac[r], MOD - 2, MOD)) * pow(fac[n - r], MOD - 2, MOD)) % mod\ndef prime_factorization(n):\n    d = []\n    (i, e) = (2, 0)\n    while i * i <= n:\n        while n % i == 0:\n            n //= i\n            e += 1\n        if e > 0:\n            d.append((i, e))\n        i += 1\n        e = 0\n    if n > 1:\n        d.append((n, 1))\n    return d\ndef main():\n    (N, M) = list(map(int, readline().split()))\n    prepare(N + 100, MOD)\n    d = prime_factorization(M)\n    ans = 1\n    for (i, e) in d:\n        ans *= cmb((N - 1) + e, e, MOD)\n        ans %= MOD\n    print(ans)", "score": 0.0, "codebleu": 0.9720466380000161, "crystalbleu": 0.9919599755783979, "codebertscore": 1.0, "codescore": 0.9937512278556824, "surfaceSim": 0.9738184338184338, "abs_surfaceSim_minus_score": 0.9738184338184338}
{"golden_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "generated_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "score": 0.0, "codebleu": 1.0, "crystalbleu": 1.0, "codebertscore": 1.0, "codescore": 0.9938334226608276, "surfaceSim": 1.0, "abs_surfaceSim_minus_score": 1.0}
{"golden_code": "from functools import lru_cache\nimport sys\nsys.setrecursionlimit(10 ** 7)\n\n@lru_cache(maxsize=None)\ndef check(l, r, n, k=1):t = (l + ('0' * k)) + r\n    e = (l + ('9' * k)) + r\n    if int(e) <= n:\n        return pow(10, k) + check(l, r, n, k + 1)\n    if int(t) <= n < int(e):\n        x = int(str(n)[1:-1])\n        if int(str(n)[-1]) < int(r):\n            x -= 1\n        return x + 1\n    if n < int(t):\n        return 0\ndef main():\n    n = int(eval(input()))\n    ret = 0\n    for x in range(1, n + 1):\n        if x % 10 == 0:\n            continue\n        s = str(x)\n        t = s[-1] + s[0]\n        if s[0] == s[-1]:\n            ret += 1\n        if int(t) <= n:\n            ret += 1\n        ret += check(s[-1], s[0], n, k=1)\n    print(ret)", "generated_code": "from functools import lru_cache\nimport sys\nsys.setrecursionlimit(10 ** 7)\n\n@lru_cache(maxsize=None)\ndef check(l, r, n, k=1):t = (l + ('0' * k)) + r\n    e = (l + ('9' * k)) + r\n    if int(e) <= n:\n        return pow(10, k) + check(l, r, n, k + 1)\n    if int(t) <= n < int(e):\n        x = int(str(n)[1:-1])\n        if int(str(n)[-1]) < int(r):\n            x -= 1\n        return x + 1\n    if n < int(t):\n        return 0\ndef main():\n    n = int(eval(input()))\n    ret = 0\n    for x in range(1, n + 1):\n        if x % 10 == 0:\n            continue\n        s = str(x)\n        t = s[1] + s[0]\n        if s[0] == s[-1]:\n            ret += 1\n        if int(t) <= n:\n            ret += 1\n        ret += check(s[-1], s[0], n, k=1)\n    print(ret)", "score": 0.0, "codebleu": 0.975942333324992, "crystalbleu": 0.9902419169655517, "codebertscore": 1.0, "codescore": 0.9937653541564941, "surfaceSim": 0.499320652173913, "abs_surfaceSim_minus_score": 0.499320652173913}
{"golden_code": "from collections import defaultdict\nfrom collections import deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\ndef I():\n    return int(sys.stdin.readline())\ndef LS():\n    return list(map(list, sys.stdin.readline().split()))\ndef S():\n    return list(sys.stdin.readline())[:-1]\ndef IR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = I()\n    return l\ndef LIR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = LI()\n    return l\ndef SR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = S()\n    return l\ndef LSR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = SR()\n    return l\nmod = 1000000007\ndef A():\n    s = S()\n    t = S()\n    if s + t == t[::-1] + s[::-1]:\n        print('YES')else:print('NO')\ndef B():\n    n = I()\n    for i in range(int(n ** 0.5) + 2)[::-1]:\n        if i * i <= n:\n            print(i * i)\n            quit()\ndef C():\n    n = I()\n    a = LI()\n    b = LI()\n    c = LI()\n    q = [0 for i in range(n)]\n    ans = 0\n    a.sort()\n    b.sort()\n    c.sort()\n    for i in range(n):\n        j = bisect.bisect_left(a, b[i])\n        q[i] = j\n    for i in range(n - 1):\n        q[i + 1] += q[i]\n    q.insert(0, 0)\n    for i in range(n):\n        j = bisect.bisect_left(b, c[i])\n        ans += q[j]\n    print(ans)\ndef D():\n    def dijkstra():\n        d = [float('inf') for i in range(k)]\n        q = [[0, 1]]\n        d[1] = 0\n        while q:\n            (dx, x) = heappop(q)\n            for (y, dy) in v[x]:\n                if d[y] > dx + dy:\n                    d[y] = dx + dy\n                    heappush(q, [d[y], y])\n        print(d[0] + 1)\n    k = I()\n    if k == 1:\n        print(1)\n        quit()\n    v = [[] for i in range(k)]\n    for i in range(1, k):\n        v[i].append([(i + 1) % k, 1])\n        v[i].append([(i * 10) % k, 0])\n    dijkstra()\ndef E():\n    return\ndef F():\n    return\ndef G():\n    return\ndef H():\n    return", "generated_code": "from collections import defaultdict\nfrom collections import deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\ndef I():\n    return int(sys.stdin.readline())\ndef LS():\n    return list(map(list, sys.stdin.readline().split()))\ndef S():\n    return list(sys.stdin.readline())[:-1]\ndef IR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = I()\n    return l\ndef LIR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = LI()\n    return l\ndef SR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = S()\n    return l\ndef LSR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = SR()\n    return l\nmod = 1000000007\ndef A():\n    s = S()\n    t = S()\n    if s + t == t[::1] + s[::-1]:\n        print('YES')else:print('NO')\ndef B():\n    n = I()\n    for i in range(int(n ** 0.5) + 2)[::-1]:\n        if i * i <= n:\n            print(i * i)\n            quit()\ndef C():\n    n = I()\n    a = LI()\n    b = LI()\n    c = LI()\n    q = [0 for i in range(n)]\n    ans = 0\n    a.sort()\n    b.sort()\n    c.sort()\n    for i in range(n):\n        j = bisect.bisect_left(a, b[i])\n        q[i] = j\n    for i in range(n - 1):\n        q[i + 1] += q[i]\n    q.insert(0, 0)\n    for i in range(n):\n        j = bisect.bisect_left(b, c[i])\n        ans += q[j]\n    print(ans)\ndef D():\n    def dijkstra():\n        d = [float('inf') for i in range(k)]\n        q = [[0, 1]]\n        d[1] = 0\n        while q:\n            (dx, x) = heappop(q)\n            for (y, dy) in v[x]:\n                if d[y] > dx + dy:\n                    d[y] = dx + dy\n                    heappush(q, [d[y], y])\n        print(d[0] + 1)\n    k = I()\n    if k == 1:\n        print(1)\n        quit()\n    v = [[] for i in range(k)]\n    for i in range(1, k):\n        v[i].append([(i + 1) % k, 1])\n        v[i].append([(i * 10) % k, 0])\n    dijkstra()\ndef E():\n    return\ndef F():\n    return\ndef G():\n    return\ndef H():\n    return", "score": 0.0, "codebleu": 0.9923222637065301, "crystalbleu": 0.9960534380417496, "codebertscore": 1.0, "codescore": 0.9860166907310486, "surfaceSim": 0.499755859375, "abs_surfaceSim_minus_score": 0.499755859375}
{"golden_code": "def popcount(x):\n    x = x - ((x >> 1) & 1431655765)\n    x = (x & 858993459) + ((x >> 2) & 858993459)\n    x = (x + (x >> 4)) & 252645135\n    x = x + (x >> 8)\n    x = x + (x >> 16)\n    return x & 127\ncmb = [[0 for i in range(51)] for j in range(51)]\ncmb[0][0] = 1\nfor i in range(51):\n    for j in range(51):\n        if (i != 50 and j != 50):\n            cmb[i + 1][j + 1] += cmb[i][j]\n        if i != 50:\n            cmb[i + 1][j] += cmb[i][j]\nfor i in range(1, 51):\n    for j in range(2, 51):\n        cmb[i][j] += cmb[i][j - 1]\n(N, K, T, S) = list(map(int, input().split()))\na = list(map(int, input().split()))\nmust0 = [i for i in range(18) if (S >> i) & 1 == 0]\nmust1 = [i for i in range(18) if (T >> i) & 1 == 1]\nA = []\nfor val in a:\n    check = True\n    for j in must0:\n        check = check & (val >> j) & 1 == 0\n    for j in must1:\n        check = check & (val >> j) & 1 == 1\n    if check:\n        A.append(val)\nif not A:\n    print(0)\n    exit()\nbit = []\nfor i in range(18):\n    if (i not in must0 and i not in must1):\n        bit.append(i)\nfor i in range(len(A)):\n    temp = 0\n    for j in range(len(bit)):\n        temp += (A[i] >> bit[j]) & 1 == 1 * (2 ** j)\n    A[i] = temp\nans = 0\nn = len(bit)\ndata = [0] * (2 ** n)\nfor i in range(2 ** n):\n    t = set([])\n    for a in A:\n        data[a & i] += 1\n        t.add(a & i)\n    temp = 0\n    for val in t:\n        temp += cmb[data[val]][min(K, data[val])]\n    ans += temp * ((-1) ** popcount(i))\n    for val in t:\n        data[val] = 0\nprint(ans)", "generated_code": "def popcount(x):\n    x = x - ((x >> 1) & 1431655765)\n    x = (x & 858993459) + ((x >> 2) & 858993459)\n    x = (x + (x >> 4)) & 252645135\n    x = x + (x >> 8)\n    x = x + (x >> 16)\n    return x & 127\ncmb = [[0 for i in range(51)] for j in range(51)]\ncmb[0][0] = 1\nfor i in range(51):\n    for j in range(51):\n        if (i != 50 and j != 50):\n            cmb[i + 1][j + 1] += cmb[i][j]\n        if i != 50:\n            cmb[i + 1][j] += cmb[i][j]\nfor i in range(1, 51):\n    for j in range(2, 51):\n        cmb[i][j] += cmb[i][j + 1]\n(N, K, T, S) = list(map(int, input().split()))\na = list(map(int, input().split()))\nmust0 = [i for i in range(18) if (S >> i) & 1 == 0]\nmust1 = [i for i in range(18) if (T >> i) & 1 == 1]\nA = []\nfor val in a:\n    check = True\n    for j in must0:\n        check = check & (val >> j) & 1 == 0\n    for j in must1:\n        check = check & (val >> j) & 1 == 1\n    if check:\n        A.append(val)\nif not A:\n    print(0)\n    exit()\nbit = []\nfor i in range(18):\n    if (i not in must0 and i not in must1):\n        bit.append(i)\nfor i in range(len(A)):\n    temp = 0\n    for j in range(len(bit)):\n        temp += (A[i] >> bit[j]) & 1 == 1 * (2 ** j)\n    A[i] = temp\nans = 0\nn = len(bit)\ndata = [0] * (2 ** n)\nfor i in range(2 ** n):\n    t = set([])\n    for a in A:\n        data[a & i] += 1\n        t.add(a & i)\n    temp = 0\n    for val in t:\n        temp += cmb[data[val]][min(K, data[val])]\n    ans += temp * ((-1) ** popcount(i))\n    for val in t:\n        data[val] = 0\nprint(ans)", "score": 0.0, "codebleu": 0.995941382850743, "crystalbleu": 0.9956123323642292, "codebertscore": 1.0, "codescore": 0.9936559200286865, "surfaceSim": 0.9996662216288384, "abs_surfaceSim_minus_score": 0.9996662216288384}
{"golden_code": "N = int(eval(input()))\nX = [[] for i in range(N)]\nfor i in range(N - 1):\n    (x, y) = list(map(int, input().split()))\n    X[x - 1].append(y - 1)\n    X[y - 1].append(x - 1)\nP = [-1] * N\nDE = [0] * N\nQ = [0]\nwhile Q:\n    i = Q.pop()\n    for a in X[i][::-1]:\n        if a != P[i]:\n            P[a] = i\n            DE[a] = DE[i] + 1\n            X[a].remove(i)\n            Q.append(a)\ndef lp(u, v):\n    t = 0\n    while u != v:\n        if DE[u] > DE[v]:\n            t += 1 << (u - 1)\n            u = P[u]\n        elif DE[u] < DE[v]:\n            t += 1 << (v - 1)\n            v = P[v]\n        else:\n            t += 1 << (u - 1)\n            t += 1 << (v - 1)\n            u = P[u]\n            v = P[v]\n    return t\nY = []\nM = int(eval(input()))\nfor _ in range(M):\n    (a, b) = list(map(int, input().split()))\n    (a, b) = (a - 1, b - 1)\n    Y.append(lp(a, b))\nD = {1 << i: i for i in range(50)}\nZ = [0] * (1 << M)\nans = 0\nCC = [0] * N\nBC = [0] * (1 << 17)\nfor m in range(1, 1 << 17):\n    a = m & (-m)\n    BC[m] = BC[m ^ a] + 1\nfor m in range(1 << M):\n    a = m & (-m)\n    if a == m:\n        if a == 0:\n            Z[m] = 0\n        else:\n            Z[m] = Y[D[a]]\n    else:\n        Z[m] = Z[m ^ a] | Y[D[a]]\n    aa = Z[m]\n    bc = BC[aa % (1 << 17)]\n    aa >>= 17\n    bc += BC[aa % (1 << 17)]\n    aa >>= 17\n    bc += BC[aa]\n    CC[(N - 1) - bc] += 1 if (BC[m % 1024] + BC[m >> 10]) & 1 == 0 else -1\nprint(sum([(2 ** i) * CC[i] for i in range(N)]))", "generated_code": "N = int(eval(input()))\nX = [[] for i in range(N)]\nfor i in range(N + 1):\n    (x, y) = list(map(int, input().split()))\n    X[x - 1].append(y - 1)\n    X[y - 1].append(x - 1)\nP = [-1] * N\nDE = [0] * N\nQ = [0]\nwhile Q:\n    i = Q.pop()\n    for a in X[i][::-1]:\n        if a != P[i]:\n            P[a] = i\n            DE[a] = DE[i] + 1\n            X[a].remove(i)\n            Q.append(a)\ndef lp(u, v):\n    t = 0\n    while u != v:\n        if DE[u] > DE[v]:\n            t += 1 << (u - 1)\n            u = P[u]\n        elif DE[u] < DE[v]:\n            t += 1 << (v - 1)\n            v = P[v]\n        else:\n            t += 1 << (u - 1)\n            t += 1 << (v - 1)\n            u = P[u]\n            v = P[v]\n    return t\nY = []\nM = int(eval(input()))\nfor _ in range(M):\n    (a, b) = list(map(int, input().split()))\n    (a, b) = (a - 1, b - 1)\n    Y.append(lp(a, b))\nD = {1 << i: i for i in range(50)}\nZ = [0] * (1 << M)\nans = 0\nCC = [0] * N\nBC = [0] * (1 << 17)\nfor m in range(1, 1 << 17):\n    a = m & (-m)\n    BC[m] = BC[m ^ a] + 1\nfor m in range(1 << M):\n    a = m & (-m)\n    if a == m:\n        if a == 0:\n            Z[m] = 0\n        else:\n            Z[m] = Y[D[a]]\n    else:\n        Z[m] = Z[m ^ a] | Y[D[a]]\n    aa = Z[m]\n    bc = BC[aa % (1 << 17)]\n    aa >>= 17\n    bc += BC[aa % (1 << 17)]\n    aa >>= 17\n    bc += BC[aa]\n    CC[(N - 1) - bc] += 1 if (BC[m % 1024] + BC[m >> 10]) & 1 == 0 else -1\nprint(sum([(2 ** i) * CC[i] for i in range(N)]))", "score": 0.0, "codebleu": 0.9957864818034221, "crystalbleu": 0.9959688151505878, "codebertscore": 1.0, "codescore": 0.9937942028045654, "surfaceSim": 0.9996525364836693, "abs_surfaceSim_minus_score": 0.9996525364836693}
{"golden_code": "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nMOD = (10 ** 9) + 7\nfac = [1, 1]\nf_inv = [1, 1]\ninv = [0, 1]\ndef prepare(n, mod):\n    for i in range(2, n + 1):\n        fac.append((fac[-1] * i) % mod)\n        inv.append(((-(inv[mod % i])) * (mod // i)) % mod)\n        f_inv.append((f_inv[-1] * inv[-1]) % mod)\ndef cmb(n, r, mod):\n    if (n < 0 or r < 0):\n        return 0\n    if r > n:\n        return 0\n    return ((fac[n] * f_inv[r]) * f_inv[n - r]) % mod\ndef prime_factorization(n):\n    d = []\n    (i, e) = (2, 0)\n    while i * i <= n:\n        while n % i == 0:\n            n //= i\n            e += 1\n        if e > 0:\n            d.append((i, e))\n        i += 1\n        e = 0\n    if n > 1:\n        d.append((n, 1))\n    return d\ndef main():\n    (N, M) = list(map(int, readline().split()))\n    prepare(N + 100, MOD)\n    d = prime_factorization(M)\n    ans = 1\n    for (i, e) in d:\n        ans *= cmb((N - 1) + e, e, MOD)\n        ans %= MOD\n    print(ans)", "generated_code": "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nMOD = (10 * 9) + 7\nfac = [1, 1]\nf_inv = [1, 1]\ninv = [0, 1]\ndef prepare(n, mod):\n    for i in range(2, n + 1):\n        fac.append((fac[-1] * i) % mod)\n        inv.append(((-(inv[mod % i])) * (mod // i)) % mod)\n        f_inv.append((f_inv[-1] * inv[-1]) % mod)\ndef cmb(n, r, mod):\n    if (n < 0 or r < 0):\n        return 0\n    if r > n:\n        return 0\n    return ((fac[n] * f_inv[r]) * f_inv[n - r]) % mod\ndef prime_factorization(n):\n    d = []\n    (i, e) = (2, 0)\n    while i * i <= n:\n        while n % i == 0:\n            n //= i\n            e += 1\n        if e > 0:\n            d.append((i, e))\n        i += 1\n        e = 0\n    if n > 1:\n        d.append((n, 1))\n    return d\ndef main():\n    (N, M) = list(map(int, readline().split()))\n    prepare(N + 100, MOD)\n    d = prime_factorization(M)\n    ans = 1\n    for (i, e) in d:\n        ans *= cmb((N - 1) + e, e, MOD)\n        ans %= MOD\n    print(ans)", "score": 0.0, "codebleu": 0.9927498121985038, "crystalbleu": 0.9949397977088043, "codebertscore": 1.0, "codescore": 0.9937450289726257, "surfaceSim": 0.9866794871794872, "abs_surfaceSim_minus_score": 0.9866794871794872}
{"golden_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "generated_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 / i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "score": 0.0, "codebleu": 0.9963221036285097, "crystalbleu": 0.9937377563162054, "codebertscore": 1.0, "codescore": 0.9849648475646973, "surfaceSim": 0.9890647900136453, "abs_surfaceSim_minus_score": 0.9890647900136453}
{"golden_code": "import sys\ndef main():\n    input = sys.stdin.readline\n    N = int(eval(input()))\n    E = [[] for _ in range(N)]\n    for i in range(N - 1):\n        (a, b) = list(map(int, input().split()))\n        (a, b) = (a - 1, b - 1)\n        E[a].append((b, i))\n        E[b].append((a, i))\n    def dfs(s, g):\n        par = [(-1, -1)] * N\n        par[s] = (s, -1)\n        stack = [s]\n        while stack:\n            v = stack.pop()\n            for (to, i) in E[v]:\n                if par[to][0] >= 0:\n                    continue\n                par[to] = (v, i)\n                if to == g:\n                    break\n                stack.append(to)\n        r = set()\n        v = g\n        while v != s:\n            (v, i) = par[v]\n            r.add(i)\n        return r\n    M = int(eval(input()))\n    path = [None] * M\n    for i in range(M):\n        (u, v) = list(map(int, input().split()))\n        (u, v) = (u - 1, v - 1)\n        path[i] = dfs(u, v)\n    def calc(s):\n        return 1 << ((N - 1) - len(s))\n    i_ans = 0\n    for p in range(1, 1 << M):\n        is_odd = bin(p).count('1') & 1\n        s = set()\n        for i in range(M):\n            if p & 1:\n                s |= path[i]\n            p >>= 1\n        if is_odd:\n            i_ans += calc(s)else:i_ans -= calc(s)\n    print((1 << (N - 1)) - i_ans)", "generated_code": "import sys\ndef main():\n    input = sys.stdin.readline\n    N = int(eval(input()))\n    E = [[] for _ in range(N)]\n    for i in range(N - 1):\n        (a, b) = list(map(int, input().split()))\n        (a, b) = (a - 1, b - 1)\n        E[a].append((b, i))\n        E[b].append((a, i))\n    def dfs(s, g):\n        par = [(1, -1)] * N\n        par[s] = (s, -1)\n        stack = [s]\n        while stack:\n            v = stack.pop()\n            for (to, i) in E[v]:\n                if par[to][0] >= 0:\n                    continue\n                par[to] = (v, i)\n                if to == g:\n                    break\n                stack.append(to)\n        r = set()\n        v = g\n        while v != s:\n            (v, i) = par[v]\n            r.add(i)\n        return r\n    M = int(eval(input()))\n    path = [None] * M\n    for i in range(M):\n        (u, v) = list(map(int, input().split()))\n        (u, v) = (u - 1, v - 1)\n        path[i] = dfs(u, v)\n    def calc(s):\n        return 1 << ((N - 1) - len(s))\n    i_ans = 0\n    for p in range(1, 1 << M):\n        is_odd = bin(p).count('1') & 1\n        s = set()\n        for i in range(M):\n            if p & 1:\n                s |= path[i]\n            p >>= 1\n        if is_odd:\n            i_ans += calc(s)else:i_ans -= calc(s)\n    print((1 << (N - 1)) - i_ans)", "score": 0.0, "codebleu": 0.9822667853057694, "crystalbleu": 0.9937959061583442, "codebertscore": 1.0, "codescore": 0.99379962682724, "surfaceSim": 0.4996138996138996, "abs_surfaceSim_minus_score": 0.4996138996138996}
{"golden_code": "import sys\n(n, m, *abcdef) = list(map(int, sys.stdin.buffer.read().split()))\nver_lines = []\nhor_lines = []\nx_list = set()\ny_list = set()\nn3 = n * 3\nfor (a, b, c) in zip(abcdef[0:n3:3], abcdef[1:n3:3], abcdef[2:n3:3]):\n    y_list.add(a)\n    y_list.add(b)\n    x_list.add(c)\n    ver_lines.append((a, b, c))\nfor (d, e, f) in zip(abcdef[n3 + 0::3], abcdef[n3 + 1::3], abcdef[n3 + 2::3]):\n    y_list.add(d)\n    x_list.add(e)\n    x_list.add(f)\n    hor_lines.append((d, e, f))\nx_list.add(0)\ny_list.add(0)\nx_list = sorted(x_list)\ny_list = sorted(y_list)\nx_dict = {x: i for (i, x) in enumerate(x_list, start=1)}\ny_dict = {y: i for (i, y) in enumerate(y_list, start=1)}\nrow_real = len(x_list)\ncol_real = len(y_list)\nrow = row_real + 2\ncol = col_real + 2\nbanned_up_ij = [[0] * row for _ in range(col)]\nbanned_down_ij = [[0] * row for _ in range(col)]\nbanned_left_ij = [[0] * col for _ in range(row)]\nbanned_right_ij = [[0] * col for _ in range(row)]\nfor (a, b, c) in ver_lines:\n    if a > b:\n        (a, b) = (b, a)\n    ai = y_dict[a]\n    bi = y_dict[b]\n    j = x_dict[c]\n    banned_left_ij[j][ai] += 1\n    banned_left_ij[j][bi] -= 1\n    banned_right_ij[j - 1][ai] += 1\n    banned_right_ij[j - 1][bi] -= 1\nfor (d, e, f) in hor_lines:\n    if e > f:\n        (e, f) = (f, e)\n    i = y_dict[d]\n    ej = x_dict[e]\n    fj = x_dict[f]\n    banned_up_ij[i][ej] += 1\n    banned_up_ij[i][fj] -= 1\n    banned_down_ij[i - 1][ej] += 1\n    banned_down_ij[i - 1][fj] -= 1\nbanned_up = [0] * (row * col)\nbanned_down = [0] * (row * col)\nbanned_left = [0] * (row * col)\nbanned_right = [0] * (row * col)\nfor i in range(col):\n    ru = banned_up_ij[i]\n    rd = banned_down_ij[i]\n    ri = row * i\n    banned_up[ri] = ru[0]\n    banned_down[ri] = rd[0]\n    for j in range(1, row):\n        banned_up[ri + j] = banned_up[(ri + j) - 1] + ru[j]\n        banned_down[ri + j] = banned_down[(ri + j) - 1] + rd[j]\nfor j in range(row):\n    rl = banned_left_ij[j]\n    rr = banned_right_ij[j]\n    banned_left[j] = rl[0]\n    banned_right[j] = rr[0]\n    for i in range(1, col):\n        ri0 = (i - 1) * row\n        ri1 = i * row\n        banned_left[ri1 + j] = banned_left[ri0 + j] + rl[i]\n        banned_right[ri1 + j] = banned_right[ri0 + j] + rr[i]\ns = (row * y_dict[0]) + x_dict[0]\nenable = (([-1] * row) + ((([-1] + ([0] * (row - 2))) + [-1]) * (col - 2))) + ([-1] * row)\nq = [s]\nmoves = [(-row, banned_up), (-1, banned_left), (1, banned_right), (row, banned_down)]\nwhile q:\n    c = q.pop()\n    if enable[c] == 1:\n        continue\n    elif enable[c] == -1:\n        print('INF')\n        exit()\n    enable[c] = 1\n    for (dc, banned) in moves:\n        if banned[c]:\n            continue\n        nc = c + dc\n        if enable[nc] == 1:\n            continue\n        q.append(nc)\nans = 0\nfor i in range(col):\n    ri = i * row\n    for j in range(row):\n        if enable[ri + j] != 1:\n            continue\n        t = y_list[i - 1]\n        b = y_list[i]\n        l = x_list[j - 1]\n        r = x_list[j]\n        ans += (b - t) * (r - l)\nprint(ans)", "generated_code": "import sys\n(n, m, *abcdef) = list(map(int, sys.stdin.buffer.read().split()))\nver_lines = []\nhor_lines = []\nx_list = set()\ny_list = set()\nn3 = n * 3\nfor (a, b, c) in zip(abcdef[0:n3:3], abcdef[1:n3:3], abcdef[2:n3:3]):\n    y_list.add(a)\n    y_list.add(b)\n    x_list.add(c)\n    ver_lines.append((a, b, c))\nfor (d, e, f) in zip(abcdef[n3 + 0::3], abcdef[n3 + 1::3], abcdef[n3 + 2::3]):\n    y_list.add(d)\n    x_list.add(e)\n    x_list.add(f)\n    hor_lines.append((d, e, f))\nx_list.add(0)\ny_list.add(0)\nx_list = sorted(x_list)\ny_list = sorted(y_list)\nx_dict = {x: i for (i, x) in enumerate(x_list, start=1)}\ny_dict = {y: i for (i, y) in enumerate(y_list, start=1)}\nrow_real = len(x_list)\ncol_real = len(y_list)\nrow = row_real + 2\ncol = col_real + 2\nbanned_up_ij = [[0] * row for _ in range(col)]\nbanned_down_ij = [[0] * row for _ in range(col)]\nbanned_left_ij = [[0] * col for _ in range(row)]\nbanned_right_ij = [[0] * col for _ in range(row)]\nfor (a, b, c) in ver_lines:\n    if a > b:\n        (a, b) = (b, a)\n    ai = y_dict[a]\n    bi = y_dict[b]\n    j = x_dict[c]\n    banned_left_ij[j][ai] += 1\n    banned_left_ij[j][bi] -= 1\n    banned_right_ij[j - 1][ai] += 1\n    banned_right_ij[j - 1][bi] -= 1\nfor (d, e, f) in hor_lines:\n    if e > f:\n        (e, f) = (f, e)\n    i = y_dict[d]\n    ej = x_dict[e]\n    fj = x_dict[f]\n    banned_up_ij[i][ej] += 1\n    banned_up_ij[i][fj] -= 1\n    banned_down_ij[i - 1][ej] += 1\n    banned_down_ij[i - 1][fj] -= 1\nbanned_up = [0] * (row * col)\nbanned_down = [0] * (row * col)\nbanned_left = [0] * (row * col)\nbanned_right = [0] * (row * col)\nfor i in range(col):\n    ru = banned_up_ij[i]\n    rd = banned_down_ij[i]\n    ri = row * i\n    banned_up[ri] = ru[0]\n    banned_down[ri] = rd[0]\n    for j in range(1, row):\n        banned_up[ri + j] = banned_up[(ri + j) - 1] + ru[j]\n        banned_down[ri + j] = banned_down[(ri + j) - 1] + rd[j]\nfor j in range(row):\n    rl = banned_left_ij[j]\n    rr = banned_right_ij[j]\n    banned_left[j] = rl[0]\n    banned_right[j] = rr[0]\n    for i in range(1, col):\n        ri0 = (i - 1) * row\n        ri1 = i * row\n        banned_left[ri1 + j] = banned_left[ri0 + j] + rl[i]\n        banned_right[ri1 + j] = banned_right[ri0 + j] + rr[i]\ns = (row * y_dict[0]) + x_dict[0]\nenable = (([-1] * row) + ((([-1] + ([0] * (row - 2))) + [-1]) * (col - 2))) + ([-1] / row)\nq = [s]\nmoves = [(-row, banned_up), (-1, banned_left), (1, banned_right), (row, banned_down)]\nwhile q:\n    c = q.pop()\n    if enable[c] == 1:\n        continue\n    elif enable[c] == -1:\n        print('INF')\n        exit()\n    enable[c] = 1\n    for (dc, banned) in moves:\n        if banned[c]:\n            continue\n        nc = c + dc\n        if enable[nc] == 1:\n            continue\n        q.append(nc)\nans = 0\nfor i in range(col):\n    ri = i * row\n    for j in range(row):\n        if enable[ri + j] != 1:\n            continue\n        t = y_list[i - 1]\n        b = y_list[i]\n        l = x_list[j - 1]\n        r = x_list[j]\n        ans += (b - t) * (r - l)\nprint(ans)", "score": 0.0, "codebleu": 0.9973984967720897, "crystalbleu": 0.9965618629741589, "codebertscore": 1.0, "codescore": 0.9542229175567627, "surfaceSim": 0.9863192064597217, "abs_surfaceSim_minus_score": 0.9863192064597217}
{"golden_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "generated_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\npass\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "score": 0.0, "codebleu": 0.9794891727435581, "crystalbleu": 0.9903344487435072, "codebertscore": 1.0, "codescore": 0.9865638017654419, "surfaceSim": 0.9881740536716026, "abs_surfaceSim_minus_score": 0.9881740536716026}
{"golden_code": "from collections import defaultdict\nfrom collections import deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\ndef I():\n    return int(sys.stdin.readline())\ndef LS():\n    return list(map(list, sys.stdin.readline().split()))\ndef S():\n    return list(sys.stdin.readline())[:-1]\ndef IR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = I()\n    return l\ndef LIR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = LI()\n    return l\ndef SR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = S()\n    return l\ndef LSR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = LS()\n    return l\nsys.setrecursionlimit(1000000)\nmod = 1000000007\ndef A():\n    return\ndef B():\n    return\ndef C():\n    return\ndef D():\n    return\ndef E():\n    return\ndef F():\n    (a, b, c, X, Y) = LI()\n    ans = float('inf')\n    for z in range(300001):\n        if z % 2 == 0:\n            m = c * z\n            x = z // 2\n            y = z // 2\n            m += a * max(0, X - x)\n            m += b * max(0, Y - y)\n            if m < ans:\n                ans = m\n    print(ans)\n    return\ndef G():\n    n = I()\n    x = LI()\n    f = [(i, x[i]) for i in range(n)]\n    f.sort(key=lambda x: (x[1]))\n    g = [(f[i][0], i) for i in range(n)]\n    g.sort(key=lambda x: (x[0]))\n    for i in range(n):\n        if g[i][1] < n // 2:\n            print(f[n // 2][1])else:print(f[(n // 2) - 1][1])\n    return\ndef H():\n    return\ndef I_():\n    return\ndef J():\n    return", "generated_code": "from collections import defaultdict\nfrom collections import deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\ndef I():\n    return int(sys.stdin.readline())\ndef LS():\n    return list(map(list, sys.stdin.readline().split()))\ndef S():\n    return list(sys.stdin.readline())[:-1]\ndef IR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = I()\n    return l\ndef LIR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = LI()\n    return l\ndef SR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = S()\n    return l\ndef LSR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = LS()\n    return l\nsys.setrecursionlimit(1000000)\nmod = 1000000007\ndef A():\n    return\ndef B():\n    return\ndef C():\n    return\ndef D():\n    return\ndef E():\n    return\ndef F():\n    (a, b, c, X, Y) = LI()\n    ans = float('inf')\n    for z in range(300001):\n        if z % 2 == 0:\n            m = c * z\n            x = z // 2\n            y = z * 2\n            m += a * max(0, X - x)\n            m += b * max(0, Y - y)\n            if m < ans:\n                ans = m\n    print(ans)\n    return\ndef G():\n    n = I()\n    x = LI()\n    f = [(i, x[i]) for i in range(n)]\n    f.sort(key=lambda x: (x[1]))\n    g = [(f[i][0], i) for i in range(n)]\n    g.sort(key=lambda x: (x[0]))\n    for i in range(n):\n        if g[i][1] < n // 2:\n            print(f[n // 2][1])else:print(f[(n // 2) - 1][1])\n    return\ndef H():\n    return\ndef I_():\n    return\ndef J():\n    return", "score": 0.0, "codebleu": 0.9950684650874879, "crystalbleu": 0.9914241489727199, "codebertscore": 1.0, "codescore": 0.9934687614440918, "surfaceSim": 0.49938195302843014, "abs_surfaceSim_minus_score": 0.49938195302843014}
{"golden_code": "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nMOD = (10 ** 9) + 7\nfac = [1, 1]\nf_inv = [1, 1]\ninv = [0, 1]\ndef prepare(n, mod):\n    for i in range(2, n + 1):\n        fac.append((fac[-1] * i) % mod)\ndef cmb(n, r, mod):\n    if (n < 0 or r < 0):\n        return 0\n    if r > n:\n        return 0\n    return ((fac[n] * pow(fac[r], MOD - 2, MOD)) * pow(fac[n - r], MOD - 2, MOD)) % mod\ndef prime_factorization(n):\n    d = []\n    (i, e) = (2, 0)\n    while i * i <= n:\n        while n % i == 0:\n            n //= i\n            e += 1\n        if e > 0:\n            d.append((i, e))\n        i += 1\n        e = 0\n    if n > 1:\n        d.append((n, 1))\n    return d\ndef main():\n    (N, M) = list(map(int, readline().split()))\n    prepare(N + 100, MOD)\n    d = prime_factorization(M)\n    ans = 1\n    for (i, e) in d:\n        ans *= cmb((N - 1) + e, e, MOD)\n        ans %= MOD\n    print(ans)", "generated_code": "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nMOD = (10 ** 9) - 7\nfac = [1, 1]\nf_inv = [1, 1]\ninv = [0, 1]\ndef prepare(n, mod):\n    for i in range(2, n + 1):\n        fac.append((fac[-1] * i) % mod)\ndef cmb(n, r, mod):\n    if (n < 0 or r < 0):\n        return 0\n    if r > n:\n        return 0\n    return ((fac[n] * pow(fac[r], MOD - 2, MOD)) * pow(fac[n - r], MOD - 2, MOD)) % mod\ndef prime_factorization(n):\n    d = []\n    (i, e) = (2, 0)\n    while i * i <= n:\n        while n % i == 0:\n            n //= i\n            e += 1\n        if e > 0:\n            d.append((i, e))\n        i += 1\n        e = 0\n    if n > 1:\n        d.append((n, 1))\n    return d\ndef main():\n    (N, M) = list(map(int, readline().split()))\n    prepare(N + 100, MOD)\n    d = prime_factorization(M)\n    ans = 1\n    for (i, e) in d:\n        ans *= cmb((N - 1) + e, e, MOD)\n        ans %= MOD\n    print(ans)", "score": 0.0, "codebleu": 0.9924868895723431, "crystalbleu": 0.9925125428898525, "codebertscore": 1.0, "codescore": 0.9937629103660583, "surfaceSim": 0.9994594594594595, "abs_surfaceSim_minus_score": 0.9994594594594595}
{"golden_code": "def popcount(x):\n    x = x - ((x >> 1) & 1431655765)\n    x = (x & 858993459) + ((x >> 2) & 858993459)\n    x = (x + (x >> 4)) & 252645135\n    x = x + (x >> 8)\n    x = x + (x >> 16)\n    return x & 127\ncmb = [[0 for i in range(51)] for j in range(51)]\ncmb[0][0] = 1\nfor i in range(51):\n    for j in range(51):\n        if (i != 50 and j != 50):\n            cmb[i + 1][j + 1] += cmb[i][j]\n        if i != 50:\n            cmb[i + 1][j] += cmb[i][j]\nfor i in range(1, 51):\n    for j in range(2, 51):\n        cmb[i][j] += cmb[i][j - 1]\n(N, K, T, S) = list(map(int, input().split()))\na = list(map(int, input().split()))\nmust0 = [i for i in range(18) if (S >> i) & 1 == 0]\nmust1 = [i for i in range(18) if (T >> i) & 1 == 1]\nA = []\nfor val in a:\n    check = True\n    for j in must0:\n        check = check & (val >> j) & 1 == 0\n    for j in must1:\n        check = check & (val >> j) & 1 == 1\n    if check:\n        A.append(val)\nif not A:\n    print(0)\n    exit()\nbit = []\nfor i in range(18):\n    if (i not in must0 and i not in must1):\n        bit.append(i)\nfor i in range(len(A)):\n    temp = 0\n    for j in range(len(bit)):\n        temp += (A[i] >> bit[j]) & 1 == 1 * (2 ** j)\n    A[i] = temp\nans = 0\nn = len(bit)\ndata = [0] * (2 ** n)\nfor i in range(2 ** n):\n    t = set([])\n    for a in A:\n        data[a & i] += 1\n        t.add(a & i)\n    temp = 0\n    for val in t:\n        temp += cmb[data[val]][min(K, data[val])]\n    ans += temp * ((-1) ** popcount(i))\n    for val in t:\n        data[val] = 0\nprint(ans)", "generated_code": "def popcount(x):\n    x = x - ((x >> 1) & 1431655765)\n    x = (x & 858993459) + ((x >> 2) & 858993459)\n    x = (x + (x >> 4)) & 252645135\n    x = x + (x >> 8)\n    x = x + (x >> 16)\n    return x & 127\ncmb = [[0 for i in range(51)] for j in range(51)]\ncmb[0][0] = 1\nfor i in range(51):\n    for j in range(51):\n        if not ((i != 50 and j != 50)):\n            cmb[i + 1][j + 1] += cmb[i][j]\n        if i != 50:\n            cmb[i + 1][j] += cmb[i][j]\nfor i in range(1, 51):\n    for j in range(2, 51):\n        cmb[i][j] += cmb[i][j - 1]\n(N, K, T, S) = list(map(int, input().split()))\na = list(map(int, input().split()))\nmust0 = [i for i in range(18) if (S >> i) & 1 == 0]\nmust1 = [i for i in range(18) if (T >> i) & 1 == 1]\nA = []\nfor val in a:\n    check = True\n    for j in must0:\n        check = check & (val >> j) & 1 == 0\n    for j in must1:\n        check = check & (val >> j) & 1 == 1\n    if check:\n        A.append(val)\nif not A:\n    print(0)\n    exit()\nbit = []\nfor i in range(18):\n    if (i not in must0 and i not in must1):\n        bit.append(i)\nfor i in range(len(A)):\n    temp = 0\n    for j in range(len(bit)):\n        temp += (A[i] >> bit[j]) & 1 == 1 * (2 ** j)\n    A[i] = temp\nans = 0\nn = len(bit)\ndata = [0] * (2 ** n)\nfor i in range(2 ** n):\n    t = set([])\n    for a in A:\n        data[a & i] += 1\n        t.add(a & i)\n    temp = 0\n    for val in t:\n        temp += cmb[data[val]][min(K, data[val])]\n    ans += temp * ((-1) ** popcount(i))\n    for val in t:\n        data[val] = 0\nprint(ans)", "score": 0.0, "codebleu": 0.9859276461400026, "crystalbleu": 0.9894789468055195, "codebertscore": 1.0, "codescore": 0.9936748147010803, "surfaceSim": 0.9983377659574468, "abs_surfaceSim_minus_score": 0.9983377659574468}
{"golden_code": "import queue\nINF = 123456789\ndef main():\n    (n, m) = list(map(int, input().split()))\n    G = [[] for _ in range(n)]\n    for _ in range(m):\n        (a, b, c) = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        G[a].append((b, c))\n        G[b].append((a, c))\n    used = set()\n    for i in range(n):\n        d = [INF for _ in range(n)]\n        par = [-1 for _ in range(n)]\n        que = queue.PriorityQueue()\n        d[i] = 0\n        que.put((0, i))\n        while not (que.empty()):\n            p = que.get()\n            v = p[1]\n            if d[v] < p[0]:\n                continue\n            for (to, cost) in G[v]:\n                if d[to] > d[v] + cost:\n                    d[to] = d[v] + cost\n                    par[to] = v\n                    que.put((d[to], to))\n        for j in range(n):\n            if i != j:\n                (a, b) = (j, par[j])\n                if a > b:\n                    (a, b) = (b, a)\n                used.add((a, b))\n    print(m - len(used))", "generated_code": "import queue\nINF = 123456789\ndef main():\n    (n, m) = list(map(int, input().split()))\n    G = [[] for _ in range(n)]\n    for _ in range(m):\n        (a, b, c) = list(map(int, input().split()))\n        a += 1\n        b -= 1\n        G[a].append((b, c))\n        G[b].append((a, c))\n    used = set()\n    for i in range(n):\n        d = [INF for _ in range(n)]\n        par = [-1 for _ in range(n)]\n        que = queue.PriorityQueue()\n        d[i] = 0\n        que.put((0, i))\n        while not (que.empty()):\n            p = que.get()\n            v = p[1]\n            if d[v] < p[0]:\n                continue\n            for (to, cost) in G[v]:\n                if d[to] > d[v] + cost:\n                    d[to] = d[v] + cost\n                    par[to] = v\n                    que.put((d[to], to))\n        for j in range(n):\n            if i != j:\n                (a, b) = (j, par[j])\n                if a > b:\n                    (a, b) = (b, a)\n                used.add((a, b))\n    print(m - len(used))", "score": 0.0, "codebleu": 0.9904103276685203, "crystalbleu": 0.9879581348354282, "codebertscore": 1.0, "codescore": 0.9937788844108582, "surfaceSim": 0.9994979919678715, "abs_surfaceSim_minus_score": 0.9994979919678715}
{"golden_code": "import queue\nINF = 123456789\ndef main():\n    (n, m) = list(map(int, input().split()))\n    G = [[] for _ in range(n)]\n    for _ in range(m):\n        (a, b, c) = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        G[a].append((b, c))\n        G[b].append((a, c))\n    used = set()\n    for i in range(n):\n        d = [INF for _ in range(n)]\n        par = [-1 for _ in range(n)]\n        que = queue.PriorityQueue()\n        d[i] = 0\n        que.put((0, i))\n        while not (que.empty()):\n            p = que.get()\n            v = p[1]\n            if d[v] < p[0]:\n                continue\n            for (to, cost) in G[v]:\n                if d[to] > d[v] + cost:\n                    d[to] = d[v] + cost\n                    par[to] = v\n                    que.put((d[to], to))\n        for j in range(n):\n            if i != j:\n                (a, b) = (j, par[j])\n                if a > b:\n                    (a, b) = (b, a)\n                used.add((a, b))\n    print(m - len(used))", "generated_code": "import queue\nINF = 123456789\ndef main():\n    (n, m) = list(map(int, input().split()))\n    G = [[] for _ in range(n)]\n    for _ in range(m):\n        (a, b, c) = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        G[a].append((b, c))\n        G[b].append((a, c))\n    used = set()\n    for i in range(n):\n        d = [INF for _ in range(n)]\n        par = [1 for _ in range(n)]\n        que = queue.PriorityQueue()\n        d[i] = 0\n        que.put((0, i))\n        while not (que.empty()):\n            p = que.get()\n            v = p[1]\n            if d[v] < p[0]:\n                continue\n            for (to, cost) in G[v]:\n                if d[to] > d[v] + cost:\n                    d[to] = d[v] + cost\n                    par[to] = v\n                    que.put((d[to], to))\n        for j in range(n):\n            if i != j:\n                (a, b) = (j, par[j])\n                if a > b:\n                    (a, b) = (b, a)\n                used.add((a, b))\n    print(m - len(used))", "score": 0.0, "codebleu": 0.9770174705256632, "crystalbleu": 0.9916185847994765, "codebertscore": 1.0, "codescore": 0.9937813878059387, "surfaceSim": 0.9847921096149304, "abs_surfaceSim_minus_score": 0.9847921096149304}
{"golden_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "generated_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(reversed(ids)):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "score": 0.0, "codebleu": 0.9930858576738172, "crystalbleu": 0.9924421707777356, "codebertscore": 0.99, "codescore": 0.9869570732116699, "surfaceSim": 0.9970484061393152, "abs_surfaceSim_minus_score": 0.9970484061393152}
{"golden_code": "from collections import defaultdict\nfrom collections import deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\ndef I():\n    return int(sys.stdin.readline())\ndef LS():\n    return list(map(list, sys.stdin.readline().split()))\ndef S():\n    return list(sys.stdin.readline())[:-1]\ndef IR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = I()\n    return l\ndef LIR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = LI()\n    return l\ndef SR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = S()\n    return l\ndef LSR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = LS()\n    return l\nsys.setrecursionlimit(1000000)\nmod = 1000000007\ndef A():\n    return\ndef B():\n    return\ndef C():\n    return\ndef D():\n    return\ndef E():\n    return\ndef F():\n    (a, b, c, X, Y) = LI()\n    ans = float('inf')\n    for z in range(300001):\n        if z % 2 == 0:\n            m = c * z\n            x = z // 2\n            y = z // 2\n            m += a * max(0, X - x)\n            m += b * max(0, Y - y)\n            if m < ans:\n                ans = m\n    print(ans)\n    return\ndef G():\n    n = I()\n    x = LI()\n    f = [(i, x[i]) for i in range(n)]\n    f.sort(key=lambda x: (x[1]))\n    g = [(f[i][0], i) for i in range(n)]\n    g.sort(key=lambda x: (x[0]))\n    for i in range(n):\n        if g[i][1] < n // 2:\n            print(f[n // 2][1])else:print(f[(n // 2) - 1][1])\n    return\ndef H():\n    return\ndef I_():\n    return\ndef J():\n    return", "generated_code": "from collections import defaultdict\nfrom collections import deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\ndef I():\n    return int(sys.stdin.readline())\ndef LS():\n    return list(map(list, sys.stdin.readline().split()))\ndef S():\n    return list(sys.stdin.readline())[:-1]\ndef IR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = I()\n    return l\ndef LIR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = LI()\n    return l\ndef SR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = S()\n    return l\ndef LSR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = LS()\n    return l\nsys.setrecursionlimit(1000000)\nmod = 1000000007\ndef A():\n    return\ndef B():\n    return\ndef C():\n    return\ndef D():\n    return\ndef E():\n    return\ndef F():\n    (a, b, c, X, Y) = LI()\n    ans = float('inf')\n    for z in range(300001):\n        if z % 2 == 0:\n            m = c // z\n            x = z // 2\n            y = z // 2\n            m += a * max(0, X - x)\n            m += b * max(0, Y - y)\n            if m < ans:\n                ans = m\n    print(ans)\n    return\ndef G():\n    n = I()\n    x = LI()\n    f = [(i, x[i]) for i in range(n)]\n    f.sort(key=lambda x: (x[1]))\n    g = [(f[i][0], i) for i in range(n)]\n    g.sort(key=lambda x: (x[0]))\n    for i in range(n):\n        if g[i][1] < n // 2:\n            print(f[n // 2][1])else:print(f[(n // 2) - 1][1])\n    return\ndef H():\n    return\ndef I_():\n    return\ndef J():\n    return", "score": 0.0, "codebleu": 0.9950684650874879, "crystalbleu": 0.9930928151043286, "codebertscore": 1.0, "codescore": 0.993200957775116, "surfaceSim": 0.4993823347745522, "abs_surfaceSim_minus_score": 0.4993823347745522}
{"golden_code": "import sys\n(n, m, *abcdef) = list(map(int, sys.stdin.buffer.read().split()))\nver_lines = []\nhor_lines = []\nx_list = set()\ny_list = set()\nn3 = n * 3\nfor (a, b, c) in zip(abcdef[0:n3:3], abcdef[1:n3:3], abcdef[2:n3:3]):\n    y_list.add(a)\n    y_list.add(b)\n    x_list.add(c)\n    ver_lines.append((a, b, c))\nfor (d, e, f) in zip(abcdef[n3 + 0::3], abcdef[n3 + 1::3], abcdef[n3 + 2::3]):\n    y_list.add(d)\n    x_list.add(e)\n    x_list.add(f)\n    hor_lines.append((d, e, f))\nx_list.add(0)\ny_list.add(0)\nx_list = sorted(x_list)\ny_list = sorted(y_list)\nx_dict = {x: i for (i, x) in enumerate(x_list, start=1)}\ny_dict = {y: i for (i, y) in enumerate(y_list, start=1)}\nrow_real = len(x_list)\ncol_real = len(y_list)\nrow = row_real + 2\ncol = col_real + 2\nbanned_up_ij = [[0] * row for _ in range(col)]\nbanned_down_ij = [[0] * row for _ in range(col)]\nbanned_left_ij = [[0] * col for _ in range(row)]\nbanned_right_ij = [[0] * col for _ in range(row)]\nfor (a, b, c) in ver_lines:\n    if a > b:\n        (a, b) = (b, a)\n    ai = y_dict[a]\n    bi = y_dict[b]\n    j = x_dict[c]\n    banned_left_ij[j][ai] += 1\n    banned_left_ij[j][bi] -= 1\n    banned_right_ij[j - 1][ai] += 1\n    banned_right_ij[j - 1][bi] -= 1\nfor (d, e, f) in hor_lines:\n    if e > f:\n        (e, f) = (f, e)\n    i = y_dict[d]\n    ej = x_dict[e]\n    fj = x_dict[f]\n    banned_up_ij[i][ej] += 1\n    banned_up_ij[i][fj] -= 1\n    banned_down_ij[i - 1][ej] += 1\n    banned_down_ij[i - 1][fj] -= 1\nbanned_up = [0] * (row * col)\nbanned_down = [0] * (row * col)\nbanned_left = [0] * (row * col)\nbanned_right = [0] * (row * col)\nfor i in range(col):\n    ru = banned_up_ij[i]\n    rd = banned_down_ij[i]\n    ri = row * i\n    banned_up[ri] = ru[0]\n    banned_down[ri] = rd[0]\n    for j in range(1, row):\n        banned_up[ri + j] = banned_up[(ri + j) - 1] + ru[j]\n        banned_down[ri + j] = banned_down[(ri + j) - 1] + rd[j]\nfor j in range(row):\n    rl = banned_left_ij[j]\n    rr = banned_right_ij[j]\n    banned_left[j] = rl[0]\n    banned_right[j] = rr[0]\n    for i in range(1, col):\n        ri0 = (i - 1) * row\n        ri1 = i * row\n        banned_left[ri1 + j] = banned_left[ri0 + j] + rl[i]\n        banned_right[ri1 + j] = banned_right[ri0 + j] + rr[i]\ns = (row * y_dict[0]) + x_dict[0]\nenable = (([-1] * row) + ((([-1] + ([0] * (row - 2))) + [-1]) * (col - 2))) + ([-1] * row)\nq = [s]\nmoves = [(-row, banned_up), (-1, banned_left), (1, banned_right), (row, banned_down)]\nwhile q:\n    c = q.pop()\n    if enable[c] == 1:\n        continue\n    elif enable[c] == -1:\n        print('INF')\n        exit()\n    enable[c] = 1\n    for (dc, banned) in moves:\n        if banned[c]:\n            continue\n        nc = c + dc\n        if enable[nc] == 1:\n            continue\n        q.append(nc)\nans = 0\nfor i in range(col):\n    ri = i * row\n    for j in range(row):\n        if enable[ri + j] != 1:\n            continue\n        t = y_list[i - 1]\n        b = y_list[i]\n        l = x_list[j - 1]\n        r = x_list[j]\n        ans += (b - t) * (r - l)\nprint(ans)", "generated_code": "import sys\n(n, m, *abcdef) = list(map(int, sys.stdin.buffer.read().split()))\nver_lines = []\nhor_lines = []\nx_list = set()\ny_list = set()\nn3 = n / 3\nfor (a, b, c) in zip(abcdef[0:n3:3], abcdef[1:n3:3], abcdef[2:n3:3]):\n    y_list.add(a)\n    y_list.add(b)\n    x_list.add(c)\n    ver_lines.append((a, b, c))\nfor (d, e, f) in zip(abcdef[n3 + 0::3], abcdef[n3 + 1::3], abcdef[n3 + 2::3]):\n    y_list.add(d)\n    x_list.add(e)\n    x_list.add(f)\n    hor_lines.append((d, e, f))\nx_list.add(0)\ny_list.add(0)\nx_list = sorted(x_list)\ny_list = sorted(y_list)\nx_dict = {x: i for (i, x) in enumerate(x_list, start=1)}\ny_dict = {y: i for (i, y) in enumerate(y_list, start=1)}\nrow_real = len(x_list)\ncol_real = len(y_list)\nrow = row_real + 2\ncol = col_real + 2\nbanned_up_ij = [[0] * row for _ in range(col)]\nbanned_down_ij = [[0] * row for _ in range(col)]\nbanned_left_ij = [[0] * col for _ in range(row)]\nbanned_right_ij = [[0] * col for _ in range(row)]\nfor (a, b, c) in ver_lines:\n    if a > b:\n        (a, b) = (b, a)\n    ai = y_dict[a]\n    bi = y_dict[b]\n    j = x_dict[c]\n    banned_left_ij[j][ai] += 1\n    banned_left_ij[j][bi] -= 1\n    banned_right_ij[j - 1][ai] += 1\n    banned_right_ij[j - 1][bi] -= 1\nfor (d, e, f) in hor_lines:\n    if e > f:\n        (e, f) = (f, e)\n    i = y_dict[d]\n    ej = x_dict[e]\n    fj = x_dict[f]\n    banned_up_ij[i][ej] += 1\n    banned_up_ij[i][fj] -= 1\n    banned_down_ij[i - 1][ej] += 1\n    banned_down_ij[i - 1][fj] -= 1\nbanned_up = [0] * (row * col)\nbanned_down = [0] * (row * col)\nbanned_left = [0] * (row * col)\nbanned_right = [0] * (row * col)\nfor i in range(col):\n    ru = banned_up_ij[i]\n    rd = banned_down_ij[i]\n    ri = row * i\n    banned_up[ri] = ru[0]\n    banned_down[ri] = rd[0]\n    for j in range(1, row):\n        banned_up[ri + j] = banned_up[(ri + j) - 1] + ru[j]\n        banned_down[ri + j] = banned_down[(ri + j) - 1] + rd[j]\nfor j in range(row):\n    rl = banned_left_ij[j]\n    rr = banned_right_ij[j]\n    banned_left[j] = rl[0]\n    banned_right[j] = rr[0]\n    for i in range(1, col):\n        ri0 = (i - 1) * row\n        ri1 = i * row\n        banned_left[ri1 + j] = banned_left[ri0 + j] + rl[i]\n        banned_right[ri1 + j] = banned_right[ri0 + j] + rr[i]\ns = (row * y_dict[0]) + x_dict[0]\nenable = (([-1] * row) + ((([-1] + ([0] * (row - 2))) + [-1]) * (col - 2))) + ([-1] * row)\nq = [s]\nmoves = [(-row, banned_up), (-1, banned_left), (1, banned_right), (row, banned_down)]\nwhile q:\n    c = q.pop()\n    if enable[c] == 1:\n        continue\n    elif enable[c] == -1:\n        print('INF')\n        exit()\n    enable[c] = 1\n    for (dc, banned) in moves:\n        if banned[c]:\n            continue\n        nc = c + dc\n        if enable[nc] == 1:\n            continue\n        q.append(nc)\nans = 0\nfor i in range(col):\n    ri = i * row\n    for j in range(row):\n        if enable[ri + j] != 1:\n            continue\n        t = y_list[i - 1]\n        b = y_list[i]\n        l = x_list[j - 1]\n        r = x_list[j]\n        ans += (b - t) * (r - l)\nprint(ans)", "score": 0.0, "codebleu": 0.9973984967720897, "crystalbleu": 0.9965611440113757, "codebertscore": 1.0, "codescore": 0.9493575692176819, "surfaceSim": 0.9863192064597217, "abs_surfaceSim_minus_score": 0.9863192064597217}
{"golden_code": "import sys\n(n, m, *abcdef) = list(map(int, sys.stdin.buffer.read().split()))\nver_lines = []\nhor_lines = []\nx_list = set()\ny_list = set()\nn3 = n * 3\nfor (a, b, c) in zip(abcdef[0:n3:3], abcdef[1:n3:3], abcdef[2:n3:3]):\n    y_list.add(a)\n    y_list.add(b)\n    x_list.add(c)\n    ver_lines.append((a, b, c))\nfor (d, e, f) in zip(abcdef[n3 + 0::3], abcdef[n3 + 1::3], abcdef[n3 + 2::3]):\n    y_list.add(d)\n    x_list.add(e)\n    x_list.add(f)\n    hor_lines.append((d, e, f))\nx_list.add(0)\ny_list.add(0)\nx_list = sorted(x_list)\ny_list = sorted(y_list)\nx_dict = {x: i for (i, x) in enumerate(x_list, start=1)}\ny_dict = {y: i for (i, y) in enumerate(y_list, start=1)}\nrow_real = len(x_list)\ncol_real = len(y_list)\nrow = row_real + 2\ncol = col_real + 2\nbanned_up_ij = [[0] * row for _ in range(col)]\nbanned_down_ij = [[0] * row for _ in range(col)]\nbanned_left_ij = [[0] * col for _ in range(row)]\nbanned_right_ij = [[0] * col for _ in range(row)]\nfor (a, b, c) in ver_lines:\n    if a > b:\n        (a, b) = (b, a)\n    ai = y_dict[a]\n    bi = y_dict[b]\n    j = x_dict[c]\n    banned_left_ij[j][ai] += 1\n    banned_left_ij[j][bi] -= 1\n    banned_right_ij[j - 1][ai] += 1\n    banned_right_ij[j - 1][bi] -= 1\nfor (d, e, f) in hor_lines:\n    if e > f:\n        (e, f) = (f, e)\n    i = y_dict[d]\n    ej = x_dict[e]\n    fj = x_dict[f]\n    banned_up_ij[i][ej] += 1\n    banned_up_ij[i][fj] -= 1\n    banned_down_ij[i - 1][ej] += 1\n    banned_down_ij[i - 1][fj] -= 1\nbanned_up = [0] * (row * col)\nbanned_down = [0] * (row * col)\nbanned_left = [0] * (row * col)\nbanned_right = [0] * (row * col)\nfor i in range(col):\n    ru = banned_up_ij[i]\n    rd = banned_down_ij[i]\n    ri = row * i\n    banned_up[ri] = ru[0]\n    banned_down[ri] = rd[0]\n    for j in range(1, row):\n        banned_up[ri + j] = banned_up[(ri + j) - 1] + ru[j]\n        banned_down[ri + j] = banned_down[(ri + j) - 1] + rd[j]\nfor j in range(row):\n    rl = banned_left_ij[j]\n    rr = banned_right_ij[j]\n    banned_left[j] = rl[0]\n    banned_right[j] = rr[0]\n    for i in range(1, col):\n        ri0 = (i - 1) * row\n        ri1 = i * row\n        banned_left[ri1 + j] = banned_left[ri0 + j] + rl[i]\n        banned_right[ri1 + j] = banned_right[ri0 + j] + rr[i]\ns = (row * y_dict[0]) + x_dict[0]\nenable = (([-1] * row) + ((([-1] + ([0] * (row - 2))) + [-1]) * (col - 2))) + ([-1] * row)\nq = [s]\nmoves = [(-row, banned_up), (-1, banned_left), (1, banned_right), (row, banned_down)]\nwhile q:\n    c = q.pop()\n    if enable[c] == 1:\n        continue\n    elif enable[c] == -1:\n        print('INF')\n        exit()\n    enable[c] = 1\n    for (dc, banned) in moves:\n        if banned[c]:\n            continue\n        nc = c + dc\n        if enable[nc] == 1:\n            continue\n        q.append(nc)\nans = 0\nfor i in range(col):\n    ri = i * row\n    for j in range(row):\n        if enable[ri + j] != 1:\n            continue\n        t = y_list[i - 1]\n        b = y_list[i]\n        l = x_list[j - 1]\n        r = x_list[j]\n        ans += (b - t) * (r - l)\nprint(ans)", "generated_code": "import sys\n(n, m, *abcdef) = list(map(int, sys.stdin.buffer.read().split()))\nver_lines = []\nhor_lines = []\nx_list = set()\ny_list = set()\nn3 = n * 3\nfor (a, b, c) in zip(abcdef[0:n3:3], abcdef[1:n3:3], abcdef[2:n3:3]):\n    y_list.add(a)\n    y_list.add(b)\n    x_list.add(c)\n    ver_lines.append((a, b, c))\nfor (d, e, f) in reversed(zip(abcdef[n3 + 0::3], abcdef[n3 + 1::3], abcdef[n3 + 2::3])):\n    y_list.add(d)\n    x_list.add(e)\n    x_list.add(f)\n    hor_lines.append((d, e, f))\nx_list.add(0)\ny_list.add(0)\nx_list = sorted(x_list)\ny_list = sorted(y_list)\nx_dict = {x: i for (i, x) in enumerate(x_list, start=1)}\ny_dict = {y: i for (i, y) in enumerate(y_list, start=1)}\nrow_real = len(x_list)\ncol_real = len(y_list)\nrow = row_real + 2\ncol = col_real + 2\nbanned_up_ij = [[0] * row for _ in range(col)]\nbanned_down_ij = [[0] * row for _ in range(col)]\nbanned_left_ij = [[0] * col for _ in range(row)]\nbanned_right_ij = [[0] * col for _ in range(row)]\nfor (a, b, c) in ver_lines:\n    if a > b:\n        (a, b) = (b, a)\n    ai = y_dict[a]\n    bi = y_dict[b]\n    j = x_dict[c]\n    banned_left_ij[j][ai] += 1\n    banned_left_ij[j][bi] -= 1\n    banned_right_ij[j - 1][ai] += 1\n    banned_right_ij[j - 1][bi] -= 1\nfor (d, e, f) in hor_lines:\n    if e > f:\n        (e, f) = (f, e)\n    i = y_dict[d]\n    ej = x_dict[e]\n    fj = x_dict[f]\n    banned_up_ij[i][ej] += 1\n    banned_up_ij[i][fj] -= 1\n    banned_down_ij[i - 1][ej] += 1\n    banned_down_ij[i - 1][fj] -= 1\nbanned_up = [0] * (row * col)\nbanned_down = [0] * (row * col)\nbanned_left = [0] * (row * col)\nbanned_right = [0] * (row * col)\nfor i in range(col):\n    ru = banned_up_ij[i]\n    rd = banned_down_ij[i]\n    ri = row * i\n    banned_up[ri] = ru[0]\n    banned_down[ri] = rd[0]\n    for j in range(1, row):\n        banned_up[ri + j] = banned_up[(ri + j) - 1] + ru[j]\n        banned_down[ri + j] = banned_down[(ri + j) - 1] + rd[j]\nfor j in range(row):\n    rl = banned_left_ij[j]\n    rr = banned_right_ij[j]\n    banned_left[j] = rl[0]\n    banned_right[j] = rr[0]\n    for i in range(1, col):\n        ri0 = (i - 1) * row\n        ri1 = i * row\n        banned_left[ri1 + j] = banned_left[ri0 + j] + rl[i]\n        banned_right[ri1 + j] = banned_right[ri0 + j] + rr[i]\ns = (row * y_dict[0]) + x_dict[0]\nenable = (([-1] * row) + ((([-1] + ([0] * (row - 2))) + [-1]) * (col - 2))) + ([-1] * row)\nq = [s]\nmoves = [(-row, banned_up), (-1, banned_left), (1, banned_right), (row, banned_down)]\nwhile q:\n    c = q.pop()\n    if enable[c] == 1:\n        continue\n    elif enable[c] == -1:\n        print('INF')\n        exit()\n    enable[c] = 1\n    for (dc, banned) in moves:\n        if banned[c]:\n            continue\n        nc = c + dc\n        if enable[nc] == 1:\n            continue\n        q.append(nc)\nans = 0\nfor i in range(col):\n    ri = i * row\n    for j in range(row):\n        if enable[ri + j] != 1:\n            continue\n        t = y_list[i - 1]\n        b = y_list[i]\n        l = x_list[j - 1]\n        r = x_list[j]\n        ans += (b - t) * (r - l)\nprint(ans)", "score": 0.0, "codebleu": 0.8950026919088316, "crystalbleu": 0.9945490436684621, "codebertscore": 1.0, "codescore": 0.9716700315475464, "surfaceSim": 0.9983327775925308, "abs_surfaceSim_minus_score": 0.9983327775925308}
{"golden_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "generated_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] / (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "score": 0.0, "codebleu": 0.9950293033173805, "crystalbleu": 0.9957523162081054, "codebertscore": 1.0, "codescore": 0.9844637513160706, "surfaceSim": 0.9861791724115019, "abs_surfaceSim_minus_score": 0.9861791724115019}
{"golden_code": "from functools import lru_cache\nimport sys\nsys.setrecursionlimit(10 ** 7)\n\n@lru_cache(maxsize=None)\ndef check(l, r, n, k=1):t = (l + ('0' * k)) + r\n    e = (l + ('9' * k)) + r\n    if int(e) <= n:\n        return pow(10, k) + check(l, r, n, k + 1)\n    if int(t) <= n < int(e):\n        x = int(str(n)[1:-1])\n        if int(str(n)[-1]) < int(r):\n            x -= 1\n        return x + 1\n    if n < int(t):\n        return 0\ndef main():\n    n = int(eval(input()))\n    ret = 0\n    for x in range(1, n + 1):\n        if x % 10 == 0:\n            continue\n        s = str(x)\n        t = s[-1] + s[0]\n        if s[0] == s[-1]:\n            ret += 1\n        if int(t) <= n:\n            ret += 1\n        ret += check(s[-1], s[0], n, k=1)\n    print(ret)", "generated_code": "from functools import lru_cache\nimport sys\nsys.setrecursionlimit(10 ** 7)\n\n@lru_cache(maxsize=None)\ndef check(l, r, n, k=1):t = (l + ('0' * k)) + r\n    e = (l + ('9' * k)) + r\n    if int(e) <= n:\n        return pow(10, k) + check(l, r, n, k + 1)\n    if int(t) <= n < int(e):\n        x = int(str(n)[1:-1])\n        if int(str(n)[-1]) < int(r):\n            x -= 1\n        return x + 1\n    if n < int(t):\n        return 0\ndef main():\n    n = int(eval(input()))\n    ret = 0\n    for x in range(1, n + 1):\n        if x % 10 == 0:\n            continue\n        s = str(x)\n        t = s[-1] + s[0]\n        if s[0] == s[-1]:\n            ret += 1\n        if int(t) <= n:\n            ret += 1\n        ret += check(s[1], s[0], n, k=1)\n    print(ret)", "score": 0.0, "codebleu": 0.974206222213881, "crystalbleu": 0.9902419169655517, "codebertscore": 1.0, "codescore": 0.9937653541564941, "surfaceSim": 0.499320652173913, "abs_surfaceSim_minus_score": 0.499320652173913}
{"golden_code": "n = int(eval(input()))\na = list(map(int, input().split()))\nD = {i: [0] for i in range(1, n + 1)}\nfor i in range(n + 1):\n    D[a[i]][0] += 1\n    D[a[i]].append(i)\n(pl, pr) = (0, 0)\nfor i in D:\n    if D[i][0] == 2:\n        pl = D[i][1]\n        pr = D[i][2]\n        break\nL = pl\nM = (pr - pl) - 1\nN = n - pr\nmod = int(1000000000.0) + 7\nmaxf = n + 11\ndef make_fact(n, k):\n    tmp = n\n    perm = [i for i in range(k)]\n    L = [0 for _ in range(k)]\n    for i in range(k):\n        L[i] = tmp % (i + 1)\n        tmp //= i + 1\n    LL = [0 for _ in range(k)]\n    for i in range(k):\n        LL[i] = perm[L[(-i) - 1]]\n        for j in range(L[(-i) - 1] + 1, k):\n            perm[j - 1] = perm[j]\n    return LL\ndef doubling(n, m, modulo=mod):\n    y = 1\n    base = n\n    tmp = m\n    while tmp != 0:\n        if tmp % 2 == 1:\n            y *= base\n            if modulo > 0:\n                y %= modulo\n        base *= base\n        if modulo > 0:\n            base %= modulo\n        tmp //= 2\n    return y\ndef inved(a, modulo=mod):\n    (x, y, u, v, k, l) = (1, 0, 0, 1, a, modulo)\n    while l != 0:\n        (x, y, u, v) = (u, v, x - (u * (k // l)), y - (v * (k // l)))\n        (k, l) = (l, k % l)\n    return x % modulo\nfact = [1 for _ in range(maxf + 1)]\ninvf = [1 for _ in range(maxf + 1)]\nfor i in range(maxf):\n    fact[i + 1] = (fact[i] * (i + 1)) % mod\ninvf[-1] = inved(fact[-1])\nfor i in range(maxf, 0, -1):\n    invf[i - 1] = (invf[i] * i) % mod\nfor i in range(1, n + 2):\n    S = ((fact[n] * invf[i - 1]) * invf[(n - i) + 1]) % mod\n    if i <= n - 1:\n        S += ((fact[n - 1] * invf[i]) * invf[(n - 1) - i]) % mod\n        S %= mod\n    if i <= n - M:\n        S -= ((fact[(n - 1) - M] * invf[i - 1]) * invf[(n - M) - i]) % mod\n        S %= mod\n    if i <= n:\n        S += ((fact[n - 1] * invf[i - 1]) * invf[n - i]) % mod\n        S %= mod\n    print(S)", "generated_code": "n = int(eval(input()))\na = list(map(int, input().split()))\nD = {i: [0] for i in range(1, n + 1)}\nfor i in range(n + 1):\n    D[a[i]][0] += 1\n    D[a[i]].append(i)\n(pl, pr) = (0, 0)\nfor i in D:\n    if D[i][0] == 2:\n        pl = D[i][1]\n        pr = D[i][2]\n        break\nL = pl\nM = (pr - pl) - 1\nN = n - pr\nmod = int(1000000000.0) + 7\nmaxf = n + 11\ndef make_fact(n, k):\n    tmp = n\n    perm = [i for i in range(k)]\n    L = [0 for _ in range(k)]\n    for i in range(k):\n        L[i] = tmp % (i + 1)\n        tmp //= i + 1\n    LL = [0 for _ in range(k)]\n    for i in range(k):\n        LL[i] = perm[L[(-i) - 1]]\n        for j in range(L[(-i) - 1] + 1, k):\n            perm[j - 1] = perm[j]\n    return LL\ndef doubling(n, m, modulo=mod):\n    y = 1\n    base = n\n    tmp = m\n    while tmp != 0:\n        if tmp % 2 == 1:\n            y *= base\n            if modulo > 0:\n                y %= modulo\n        base *= base\n        if modulo > 0:\n            base %= modulo\n        tmp //= 2\n    return y\ndef inved(a, modulo=mod):\n    (x, y, u, v, k, l) = (1, 0, 0, 1, a, modulo)\n    while l != 0:\n        (x, y, u, v) = (u, v, x - (u * (k // l)), y - (v * (k // l)))\n        (k, l) = (l, k % l)\n    return x % modulo\nfact = [1 for _ in range(maxf + 1)]\ninvf = [1 for _ in range(maxf + 1)]\nfor i in range(maxf):\n    fact[i + 1] = (fact[i] * (i + 1)) % mod\ninvf[-1] = inved(fact[-1])\nfor i in range(maxf, 0, 1):\n    invf[i - 1] = (invf[i] * i) % mod\nfor i in range(1, n + 2):\n    S = ((fact[n] * invf[i - 1]) * invf[(n - i) + 1]) % mod\n    if i <= n - 1:\n        S += ((fact[n - 1] * invf[i]) * invf[(n - 1) - i]) % mod\n        S %= mod\n    if i <= n - M:\n        S -= ((fact[(n - 1) - M] * invf[i - 1]) * invf[(n - M) - i]) % mod\n        S %= mod\n    if i <= n:\n        S += ((fact[n - 1] * invf[i - 1]) * invf[n - i]) % mod\n        S %= mod\n    print(S)", "score": 0.0, "codebleu": 0.9939107441866115, "crystalbleu": 0.996394583294376, "codebertscore": 1.0, "codescore": 0.993248462677002, "surfaceSim": 0.999727965179543, "abs_surfaceSim_minus_score": 0.999727965179543}
{"golden_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "generated_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    pass\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "score": 0.0, "codebleu": 0.9871779411601309, "crystalbleu": 0.9897604060157714, "codebertscore": 1.0, "codescore": 0.9936140179634094, "surfaceSim": 0.9855820430900303, "abs_surfaceSim_minus_score": 0.9855820430900303}
{"golden_code": "import queue\nINF = 123456789\ndef main():\n    (n, m) = list(map(int, input().split()))\n    G = [[] for _ in range(n)]\n    for _ in range(m):\n        (a, b, c) = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        G[a].append((b, c))\n        G[b].append((a, c))\n    used = set()\n    for i in range(n):\n        d = [INF for _ in range(n)]\n        par = [-1 for _ in range(n)]\n        que = queue.PriorityQueue()\n        d[i] = 0\n        que.put((0, i))\n        while not (que.empty()):\n            p = que.get()\n            v = p[1]\n            if d[v] < p[0]:\n                continue\n            for (to, cost) in G[v]:\n                if d[to] > d[v] + cost:\n                    d[to] = d[v] + cost\n                    par[to] = v\n                    que.put((d[to], to))\n        for j in range(n):\n            if i != j:\n                (a, b) = (j, par[j])\n                if a > b:\n                    (a, b) = (b, a)\n                used.add((a, b))\n    print(m - len(used))", "generated_code": "import queue\nINF = 123456789\ndef main():\n    (n, m) = list(map(int, input().split()))\n    G = [[] for _ in range(n)]\n    for _ in range(m):\n        (a, b, c) = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        G[a].append((b, c))\n        G[b].append((a, c))\n    used = set()\n    for i in range(n):\n        d = [INF for _ in range(n)]\n        par = [+1 for _ in range(n)]\n        que = queue.PriorityQueue()\n        d[i] = 0\n        que.put((0, i))\n        while not (que.empty()):\n            p = que.get()\n            v = p[1]\n            if d[v] < p[0]:\n                continue\n            for (to, cost) in G[v]:\n                if d[to] > d[v] + cost:\n                    d[to] = d[v] + cost\n                    par[to] = v\n                    que.put((d[to], to))\n        for j in range(n):\n            if i != j:\n                (a, b) = (j, par[j])\n                if a > b:\n                    (a, b) = (b, a)\n                used.add((a, b))\n    print(m - len(used))", "score": 0.0, "codebleu": 0.9904103276685203, "crystalbleu": 0.9879581348354282, "codebertscore": 1.0, "codescore": 0.99379563331604, "surfaceSim": 0.9709265633964429, "abs_surfaceSim_minus_score": 0.9709265633964429}
{"golden_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "generated_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    @classmethod\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "score": 0.0, "codebleu": 0.9933297651216333, "crystalbleu": 0.9932615708925326, "codebertscore": 0.99, "codescore": 0.9865924715995789, "surfaceSim": 0.9960462287104623, "abs_surfaceSim_minus_score": 0.9960462287104623}
{"golden_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "generated_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    pass\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "score": 0.0, "codebleu": 0.972749809881919, "crystalbleu": 0.9738076623958638, "codebertscore": 0.99, "codescore": 0.9912488460540771, "surfaceSim": 0.9821840894367017, "abs_surfaceSim_minus_score": 0.9821840894367017}
{"golden_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "generated_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    pass\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "score": 0.0, "codebleu": 0.9650271472601842, "crystalbleu": 0.9801321612738984, "codebertscore": 0.99, "codescore": 0.9814695119857788, "surfaceSim": 0.9860956688735028, "abs_surfaceSim_minus_score": 0.9860956688735028}
{"golden_code": "import sys\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\ndef solve():\n    inf = (10 ** 14) + 10\n    def dfs(v: 'vertex_index, 0-indexed') -> None:\n        for (c, t) in e[v]:\n            if d[t] != inf:\n                continue\n            d[t] = d[v] + c\n            dfs(t)\n    n = int(eval(input()))\n    e = tuple((set() for _ in range(n)))\n    for _ in range(n - 1):\n        (a, b, c) = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        e[a].add((c, b))\n        e[b].add((c, a))\n    (q, v) = list(map(int, input().split()))\n    v -= 1\n    d = [inf] * n\n    d[v] = 0\n    dfs(v)\n    for _ in range(q):\n        (x, y) = list(map(int, input().split()))\n        x -= 1\n        y -= 1\n        print(d[x] + d[y])", "generated_code": "import sys\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\ndef solve():\n    inf = (10 ** 14) + 10\n    def dfs(v: 'vertex_index, 0-indexed') -> None:\n        for (c, t) in e[v]:\n            if d[t] != inf:\n                continue\n            d[t] = d[v] + c\n            dfs(t)\n    n = int(eval(input()))\n    e = tuple((set() for _ in range(n)))\n    for _ in range(n + 1):\n        (a, b, c) = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        e[a].add((c, b))\n        e[b].add((c, a))\n    (q, v) = list(map(int, input().split()))\n    v -= 1\n    d = [inf] * n\n    d[v] = 0\n    dfs(v)\n    for _ in range(q):\n        (x, y) = list(map(int, input().split()))\n        x -= 1\n        y -= 1\n        print(d[x] + d[y])", "score": 0.0, "codebleu": 0.9881398574370538, "crystalbleu": 0.9907915106316487, "codebertscore": 1.0, "codescore": 0.9938189387321472, "surfaceSim": 0.9993243243243244, "abs_surfaceSim_minus_score": 0.9993243243243244}
{"golden_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "generated_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        __n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "score": 0.0, "codebleu": 0.9564398606786421, "crystalbleu": 0.9936960855615548, "codebertscore": 1.0, "codescore": 0.9819858074188232, "surfaceSim": 0.9984634296250768, "abs_surfaceSim_minus_score": 0.9984634296250768}
{"golden_code": "icase = 0\nif icase == 0:\n    (n, m) = list(map(int, input().split()))\n    a = []\n    b = []\n    for i in range(m):\n        (ai, bi) = list(map(int, input().split()))\n        a.append(ai)\n        b.append(bi)\nelif icase == 1:\n    n = 6\n    m = 5\n    a = [1, 2, 3, 4, 5]\n    b = [2, 3, 4, 5, 6]\nelif icase == 2:\n    n = 7\n    m = 7\n    a = [1, 2, 3, 4, 4, 5, 6]\n    b = [3, 7, 4, 5, 6, 6, 7]\nvtx = []\nfor i in range(n):\n    vtx.append([i + 1])\nicnt = 0\nfor j in range(m):\n    vtx1 = vtx.copy()\n    a1 = a.copy()\n    b1 = b.copy()\n    del a1[j]\n    del b1[j]\n    for i in range(m - 1):\n        for v1 in vtx1:\n            if a1[i] in v1:\n                if not (b1[i] in v1):\n                    for v2 in vtx1:\n                        if v1 != v2:\n                            if b1[i] in v2:\n                                break\n                    vtx1.remove(v1)\n                    vtx1.remove(v2)\n                    v3 = v1 + v2\n                    vtx1.append(v3)\n    if len(vtx1) != 1:\n        icnt = icnt + 1\nprint(icnt)", "generated_code": "icase = 0\nif not (icase == 0):\n    (n, m) = list(map(int, input().split()))\n    a = []\n    b = []\n    for i in range(m):\n        (ai, bi) = list(map(int, input().split()))\n        a.append(ai)\n        b.append(bi)\nelif icase == 1:\n    n = 6\n    m = 5\n    a = [1, 2, 3, 4, 5]\n    b = [2, 3, 4, 5, 6]\nelif icase == 2:\n    n = 7\n    m = 7\n    a = [1, 2, 3, 4, 4, 5, 6]\n    b = [3, 7, 4, 5, 6, 6, 7]\nvtx = []\nfor i in range(n):\n    vtx.append([i + 1])\nicnt = 0\nfor j in range(m):\n    vtx1 = vtx.copy()\n    a1 = a.copy()\n    b1 = b.copy()\n    del a1[j]\n    del b1[j]\n    for i in range(m - 1):\n        for v1 in vtx1:\n            if a1[i] in v1:\n                if not (b1[i] in v1):\n                    for v2 in vtx1:\n                        if v1 != v2:\n                            if b1[i] in v2:\n                                break\n                    vtx1.remove(v1)\n                    vtx1.remove(v2)\n                    v3 = v1 + v2\n                    vtx1.append(v3)\n    if len(vtx1) != 1:\n        icnt = icnt + 1\nprint(icnt)", "score": 0.0, "codebleu": 0.9823820026329587, "crystalbleu": 0.9781595820946176, "codebertscore": 1.0, "codescore": 0.9937680959701538, "surfaceSim": 0.9975798644724105, "abs_surfaceSim_minus_score": 0.9975798644724105}
{"golden_code": "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nMOD = (10 ** 9) + 7\nfac = [1, 1]\nf_inv = [1, 1]\ninv = [0, 1]\ndef prepare(n, mod):\n    for i in range(2, n + 1):\n        fac.append((fac[-1] * i) % mod)\ndef cmb(n, r, mod):\n    if (n < 0 or r < 0):\n        return 0\n    if r > n:\n        return 0\n    return ((fac[n] * pow(fac[r], MOD - 2, MOD)) * pow(fac[n - r], MOD - 2, MOD)) % mod\ndef prime_factorization(n):\n    d = []\n    (i, e) = (2, 0)\n    while i * i <= n:\n        while n % i == 0:\n            n //= i\n            e += 1\n        if e > 0:\n            d.append((i, e))\n        i += 1\n        e = 0\n    if n > 1:\n        d.append((n, 1))\n    return d\ndef main():\n    (N, M) = list(map(int, readline().split()))\n    prepare(N + 100, MOD)\n    d = prime_factorization(M)\n    ans = 1\n    for (i, e) in d:\n        ans *= cmb((N - 1) + e, e, MOD)\n        ans %= MOD\n    print(ans)", "generated_code": "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nMOD = (10 ** 9) + 7\nfac = [1, 1]\nf_inv = [1, 1]\ninv = [0, 1]\ndef prepare(n, mod):\n    for i in range(2, n + 1):\n        fac.append((fac[-1] ** i) % mod)\ndef cmb(n, r, mod):\n    if (n < 0 or r < 0):\n        return 0\n    if r > n:\n        return 0\n    return ((fac[n] * pow(fac[r], MOD - 2, MOD)) * pow(fac[n - r], MOD - 2, MOD)) % mod\ndef prime_factorization(n):\n    d = []\n    (i, e) = (2, 0)\n    while i * i <= n:\n        while n % i == 0:\n            n //= i\n            e += 1\n        if e > 0:\n            d.append((i, e))\n        i += 1\n        e = 0\n    if n > 1:\n        d.append((n, 1))\n    return d\ndef main():\n    (N, M) = list(map(int, readline().split()))\n    prepare(N + 100, MOD)\n    d = prime_factorization(M)\n    ans = 1\n    for (i, e) in d:\n        ans *= cmb((N - 1) + e, e, MOD)\n        ans %= MOD\n    print(ans)", "score": 0.0, "codebleu": 0.9924868895723431, "crystalbleu": 0.9950876111788316, "codebertscore": 1.0, "codescore": 0.9937625527381897, "surfaceSim": 0.9994600431965444, "abs_surfaceSim_minus_score": 0.9994600431965444}
{"golden_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "generated_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "score": 0.0, "codebleu": 1.0, "crystalbleu": 1.0, "codebertscore": 1.0, "codescore": 0.9938334226608276, "surfaceSim": 1.0, "abs_surfaceSim_minus_score": 1.0}
{"golden_code": "import math, sys\nn = int(sys.stdin.readline())\na = tuple(map(int, sys.stdin.readline().split()))\ng = math.gcd(a[0], a[1])\nfor i in range(2, n):\n    g = math.gcd(g, a[i])\nM = max(a)\nacc = a[0]\nfor i in range(n):\n    acc = math.gcd(acc, a[i])\nif acc != 1:\n    print('not coprime')\n    exit()\nLIMIT = max(a)\nminPrime = [0] * (LIMIT + 1)\nminPrime[1] = 1\ndef make():\n    for i in range(2, LIMIT + 1):\n        if minPrime[i] == 0:\n            minPrime[i] = i\n            for j in range(i + i, LIMIT + 1, i):\n                if minPrime[j] == 0:\n                    minPrime[j] = i\nmake()\ndef factrial(N):\n    ret = []\n    while minPrime[N] != N:\n        ret.append(minPrime[N])\n        N = N // minPrime[N]\n    if N != 1:\n        ret.append(N)\n    return ret\njudge = set([])\npc = True\npairwise = True\np = set()\nfor e in a:\n    if not pairwise:\n        break\n    asf = set(factrial(e))\n    if judge & asf != set():\n        pc = False\n    judge |= asf\nif pc:\n    print('pairwise coprime')\nelif g == 1:\n    print('setwise coprime')\nelse:\n    print('not coprime')", "generated_code": "import math, sys\nn = int(sys.stdin.readline())\na = tuple(map(int, sys.stdin.readline().split()))\ng = math.gcd(a[0], a[1])\nfor i in range(2, n):\n    g = math.gcd(g, a[i])\nM = max(a)\nacc = a[0]\nfor i in range(n):\n    acc = math.gcd(acc, a[i])\nif acc != 1:\n    print('not coprime')\n    exit()\nLIMIT = max(a)\nminPrime = [0] * (LIMIT + 1)\nminPrime[1] = 1\ndef make():\n    for i in range(2, LIMIT + 1):\n        if minPrime[i] == 0:\n            minPrime[i] = i\n            for j in range(i + i, LIMIT + 1, i):\n                if minPrime[j] == 0:\n                    minPrime[j] = i\n        break\nmake()\ndef factrial(N):\n    ret = []\n    while minPrime[N] != N:\n        ret.append(minPrime[N])\n        N = N // minPrime[N]\n    if N != 1:\n        ret.append(N)\n    return ret\njudge = set([])\npc = True\npairwise = True\np = set()\nfor e in a:\n    if not pairwise:\n        break\n    asf = set(factrial(e))\n    if judge & asf != set():\n        pc = False\n    judge |= asf\nif pc:\n    print('pairwise coprime')elif g == 1:\n    print('setwise coprime')\nelse:\n    print('not coprime')", "score": 0.0, "codebleu": 0.966981750105428, "crystalbleu": 0.9890192409220128, "codebertscore": 0.99, "codescore": 0.9937352538108826, "surfaceSim": 0.49671669793621015, "abs_surfaceSim_minus_score": 0.49671669793621015}
{"golden_code": "N = int(eval(input()))\nX = [[] for i in range(N)]\nfor i in range(N - 1):\n    (x, y) = list(map(int, input().split()))\n    X[x - 1].append(y - 1)\n    X[y - 1].append(x - 1)\nP = [-1] * N\nDE = [0] * N\nQ = [0]\nwhile Q:\n    i = Q.pop()\n    for a in X[i][::-1]:\n        if a != P[i]:\n            P[a] = i\n            DE[a] = DE[i] + 1\n            X[a].remove(i)\n            Q.append(a)\ndef lp(u, v):\n    t = 0\n    while u != v:\n        if DE[u] > DE[v]:\n            t += 1 << (u - 1)\n            u = P[u]\n        elif DE[u] < DE[v]:\n            t += 1 << (v - 1)\n            v = P[v]\n        else:\n            t += 1 << (u - 1)\n            t += 1 << (v - 1)\n            u = P[u]\n            v = P[v]\n    return t\nY = []\nM = int(eval(input()))\nfor _ in range(M):\n    (a, b) = list(map(int, input().split()))\n    (a, b) = (a - 1, b - 1)\n    Y.append(lp(a, b))\nD = {1 << i: i for i in range(50)}\nZ = [0] * (1 << M)\nans = 0\nCC = [0] * N\nBC = [0] * (1 << 17)\nfor m in range(1, 1 << 17):\n    a = m & (-m)\n    BC[m] = BC[m ^ a] + 1\nfor m in range(1 << M):\n    a = m & (-m)\n    if a == m:\n        if a == 0:\n            Z[m] = 0\n        else:\n            Z[m] = Y[D[a]]\n    else:\n        Z[m] = Z[m ^ a] | Y[D[a]]\n    aa = Z[m]\n    bc = BC[aa % (1 << 17)]\n    aa >>= 17\n    bc += BC[aa % (1 << 17)]\n    aa >>= 17\n    bc += BC[aa]\n    CC[(N - 1) - bc] += 1 if (BC[m % 1024] + BC[m >> 10]) & 1 == 0 else -1\nprint(sum([(2 ** i) * CC[i] for i in range(N)]))", "generated_code": "N = int(eval(input()))\nX = [[] for i in range(N)]\nfor i in range(N - 1):\n    (x, y) = list(map(int, input().split()))\n    X[x - 1].append(y - 1)\n    X[y - 1].append(x - 1)\nP = [-1] * N\nDE = [0] * N\nQ = [0]\nwhile Q:\n    i = Q.pop()\n    for a in X[i][::-1]:\n        if a != P[i]:\n            P[a] = i\n            DE[a] = DE[i] + 1\n            X[a].remove(i)\n            Q.append(a)\ndef lp(u, v):\n    t = 0\n    while u != v:\n        if DE[u] > DE[v]:\n            t += 1 << (u - 1)\n            u = P[u]\n        elif DE[u] < DE[v]:\n            t += 1 << (v - 1)\n            v = P[v]\n        else:\n            t += 1 << (u - 1)\n            t += 1 << (v - 1)\n            u = P[u]\n            v = P[v]\n    return t\nY = []\nM = int(eval(input()))\nfor _ in range(M):\n    (a, b) = list(map(int, input().split()))\n    (a, b) = (a - 1, b - 1)\n    Y.append(lp(a, b))\nD = {1 << i: i for i in range(50)}\nZ = [0] * (1 << M)\nans = 0\nCC = [0] * N\nBC = [0] * (1 << 17)\nfor m in range(1, 1 << 17):\n    a = m & (-m)\n    BC[m] = BC[m ^ a] + 1\nfor m in range(1 << M):\n    a = m & (-m)\n    if a == m:\n        if a == 0:\n            Z[m] = 0\n        else:\n            Z[m] = Y[D[a]]\n    else:\n        Z[m] = Z[m ^ a] | Y[D[a]]\n    aa = Z[m]\n    bc = BC[aa % (1 << 17)]\n    aa >>= 17\n    bc += BC[aa % (1 << 17)]\n    aa >>= 17\n    bc += BC[aa]\n    CC[(N - 1) - bc] += 1 if (BC[m % 1024] + BC[m >> 10]) & 1 == 0 else 1\nprint(sum([(2 ** i) * CC[i] for i in range(N)]))", "score": 0.0, "codebleu": 0.9910094117397279, "crystalbleu": 0.995677395714417, "codebertscore": 1.0, "codescore": 0.9937825798988342, "surfaceSim": 0.9996525364836693, "abs_surfaceSim_minus_score": 0.9996525364836693}
{"golden_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "generated_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    pass\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "score": 0.0, "codebleu": 0.9589542727662571, "crystalbleu": 0.9801297140667433, "codebertscore": 0.99, "codescore": 0.9812009930610657, "surfaceSim": 0.9860956688735028, "abs_surfaceSim_minus_score": 0.9860956688735028}
{"golden_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "generated_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "score": 0.0, "codebleu": 0.988832756482228, "crystalbleu": 0.9942110332335385, "codebertscore": 1.0, "codescore": 0.9936074018478394, "surfaceSim": 0.9988589685075309, "abs_surfaceSim_minus_score": 0.9988589685075309}
{"golden_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "generated_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\npass\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "score": 0.0, "codebleu": 0.9325347659060501, "crystalbleu": 0.9745941460851727, "codebertscore": 1.0, "codescore": 0.993854284286499, "surfaceSim": 0.9781587933978373, "abs_surfaceSim_minus_score": 0.9781587933978373}
{"golden_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "generated_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "score": 0.0, "codebleu": 0.9873402191687952, "crystalbleu": 0.9942110332335385, "codebertscore": 1.0, "codescore": 0.9935749173164368, "surfaceSim": 0.9988589685075309, "abs_surfaceSim_minus_score": 0.9988589685075309}
{"golden_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "generated_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        __node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "score": 0.0, "codebleu": 0.9867305793496425, "crystalbleu": 0.9936989720107794, "codebertscore": 1.0, "codescore": 0.9817403554916382, "surfaceSim": 0.9984634296250768, "abs_surfaceSim_minus_score": 0.9984634296250768}
{"golden_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "generated_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        break\n\n\n\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "score": 0.0, "codebleu": 0.9389276367665139, "crystalbleu": 0.9433112340413564, "codebertscore": 0.95, "codescore": 0.18429656326770782, "surfaceSim": 0.9325567291656138, "abs_surfaceSim_minus_score": 0.9325567291656138}
{"golden_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "generated_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] / self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "score": 0.0, "codebleu": 0.9945883912637858, "crystalbleu": 0.9944481893084814, "codebertscore": 1.0, "codescore": 0.9935658574104309, "surfaceSim": 0.9869512808809933, "abs_surfaceSim_minus_score": 0.9869512808809933}
{"golden_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "generated_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    pass\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "score": 0.0, "codebleu": 0.9713652555258335, "crystalbleu": 0.961069216625579, "codebertscore": 0.98, "codescore": 0.9867952466011047, "surfaceSim": 0.9795636023651892, "abs_surfaceSim_minus_score": 0.9795636023651892}
{"golden_code": "import queue\nINF = 123456789\ndef main():\n    (n, m) = list(map(int, input().split()))\n    G = [[] for _ in range(n)]\n    for _ in range(m):\n        (a, b, c) = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        G[a].append((b, c))\n        G[b].append((a, c))\n    used = set()\n    for i in range(n):\n        d = [INF for _ in range(n)]\n        par = [-1 for _ in range(n)]\n        que = queue.PriorityQueue()\n        d[i] = 0\n        que.put((0, i))\n        while not (que.empty()):\n            p = que.get()\n            v = p[1]\n            if d[v] < p[0]:\n                continue\n            for (to, cost) in G[v]:\n                if d[to] > d[v] + cost:\n                    d[to] = d[v] + cost\n                    par[to] = v\n                    que.put((d[to], to))\n        for j in range(n):\n            if i != j:\n                (a, b) = (j, par[j])\n                if a > b:\n                    (a, b) = (b, a)\n                used.add((a, b))\n    print(m - len(used))", "generated_code": "import queue\nINF = 123456789\ndef main():\n    (n, m) = list(map(int, input().split()))\n    G = [[] for _ in range(n)]\n    for _ in range(m):\n        (a, b, c) = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        G[a].append((b, c))\n        G[b].append((a, c))\n    used = set()\n    for i in range(n):\n        d = [INF for _ in range(n)]\n        par = [-1 for _ in range(n)]\n        que = queue.PriorityQueue()\n        d[i] = 0\n        que.put((0, i))\n        while que.empty():\n            p = que.get()\n            v = p[1]\n            if d[v] < p[0]:\n                continue\n            for (to, cost) in G[v]:\n                if d[to] > d[v] + cost:\n                    d[to] = d[v] + cost\n                    par[to] = v\n                    que.put((d[to], to))\n        for j in range(n):\n            if i != j:\n                (a, b) = (j, par[j])\n                if a > b:\n                    (a, b) = (b, a)\n                used.add((a, b))\n    print(m - len(used))", "score": 0.0, "codebleu": 0.97371000274125, "crystalbleu": 0.982922948627005, "codebertscore": 1.0, "codescore": 0.9937766790390015, "surfaceSim": 0.9827840774864163, "abs_surfaceSim_minus_score": 0.9827840774864163}
{"golden_code": "from collections import defaultdict\nfrom collections import deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\ndef I():\n    return int(sys.stdin.readline())\ndef LS():\n    return list(map(list, sys.stdin.readline().split()))\ndef S():\n    return list(sys.stdin.readline())[:-1]\ndef IR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = I()\n    return l\ndef LIR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = LI()\n    return l\ndef SR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = S()\n    return l\ndef LSR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = LS()\n    return l\nsys.setrecursionlimit(1000000)\nmod = 1000000007\ndef A():\n    return\ndef B():\n    return\ndef C():\n    return\ndef D():\n    return\ndef E():\n    return\ndef F():\n    (a, b, c, X, Y) = LI()\n    ans = float('inf')\n    for z in range(300001):\n        if z % 2 == 0:\n            m = c * z\n            x = z // 2\n            y = z // 2\n            m += a * max(0, X - x)\n            m += b * max(0, Y - y)\n            if m < ans:\n                ans = m\n    print(ans)\n    return\ndef G():\n    n = I()\n    x = LI()\n    f = [(i, x[i]) for i in range(n)]\n    f.sort(key=lambda x: (x[1]))\n    g = [(f[i][0], i) for i in range(n)]\n    g.sort(key=lambda x: (x[0]))\n    for i in range(n):\n        if g[i][1] < n // 2:\n            print(f[n // 2][1])else:print(f[(n // 2) - 1][1])\n    return\ndef H():\n    return\ndef I_():\n    return\ndef J():\n    return", "generated_code": "from collections import defaultdict\nfrom collections import deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\ndef I():\n    return int(sys.stdin.readline())\ndef LS():\n    return list(map(list, sys.stdin.readline().split()))\ndef S():\n    return list(sys.stdin.readline())[:-1]\ndef IR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = I()\n    return l\ndef LIR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = LI()\n    return l\ndef SR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = S()\n    return l\ndef LSR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = LS()\n    return l\nsys.setrecursionlimit(1000000)\nmod = 1000000007\ndef A():\n    return\ndef B():\n    return\ndef C():\n    return\ndef D():\n    return\ndef E():\n    return\ndef F():\n    (a, b, c, X, Y) = LI()\n    ans = float('inf')\n    for z in range(300001):\n        if z % 2 == 0:\n            m = c / z\n            x = z // 2\n            y = z // 2\n            m += a * max(0, X - x)\n            m += b * max(0, Y - y)\n            if m < ans:\n                ans = m\n    print(ans)\n    return\ndef G():\n    n = I()\n    x = LI()\n    f = [(i, x[i]) for i in range(n)]\n    f.sort(key=lambda x: (x[1]))\n    g = [(f[i][0], i) for i in range(n)]\n    g.sort(key=lambda x: (x[0]))\n    for i in range(n):\n        if g[i][1] < n // 2:\n            print(f[n // 2][1])else:print(f[(n // 2) - 1][1])\n    return\ndef H():\n    return\ndef I_():\n    return\ndef J():\n    return", "score": 0.0, "codebleu": 0.9950684650874879, "crystalbleu": 0.9948455178949973, "codebertscore": 1.0, "codescore": 0.9930470585823059, "surfaceSim": 0.49969097651421507, "abs_surfaceSim_minus_score": 0.49969097651421507}
{"golden_code": "import sys\n(n, m, *abcdef) = list(map(int, sys.stdin.buffer.read().split()))\nver_lines = []\nhor_lines = []\nx_list = set()\ny_list = set()\nn3 = n * 3\nfor (a, b, c) in zip(abcdef[0:n3:3], abcdef[1:n3:3], abcdef[2:n3:3]):\n    y_list.add(a)\n    y_list.add(b)\n    x_list.add(c)\n    ver_lines.append((a, b, c))\nfor (d, e, f) in zip(abcdef[n3 + 0::3], abcdef[n3 + 1::3], abcdef[n3 + 2::3]):\n    y_list.add(d)\n    x_list.add(e)\n    x_list.add(f)\n    hor_lines.append((d, e, f))\nx_list.add(0)\ny_list.add(0)\nx_list = sorted(x_list)\ny_list = sorted(y_list)\nx_dict = {x: i for (i, x) in enumerate(x_list, start=1)}\ny_dict = {y: i for (i, y) in enumerate(y_list, start=1)}\nrow_real = len(x_list)\ncol_real = len(y_list)\nrow = row_real + 2\ncol = col_real + 2\nbanned_up_ij = [[0] * row for _ in range(col)]\nbanned_down_ij = [[0] * row for _ in range(col)]\nbanned_left_ij = [[0] * col for _ in range(row)]\nbanned_right_ij = [[0] * col for _ in range(row)]\nfor (a, b, c) in ver_lines:\n    if a > b:\n        (a, b) = (b, a)\n    ai = y_dict[a]\n    bi = y_dict[b]\n    j = x_dict[c]\n    banned_left_ij[j][ai] += 1\n    banned_left_ij[j][bi] -= 1\n    banned_right_ij[j - 1][ai] += 1\n    banned_right_ij[j - 1][bi] -= 1\nfor (d, e, f) in hor_lines:\n    if e > f:\n        (e, f) = (f, e)\n    i = y_dict[d]\n    ej = x_dict[e]\n    fj = x_dict[f]\n    banned_up_ij[i][ej] += 1\n    banned_up_ij[i][fj] -= 1\n    banned_down_ij[i - 1][ej] += 1\n    banned_down_ij[i - 1][fj] -= 1\nbanned_up = [0] * (row * col)\nbanned_down = [0] * (row * col)\nbanned_left = [0] * (row * col)\nbanned_right = [0] * (row * col)\nfor i in range(col):\n    ru = banned_up_ij[i]\n    rd = banned_down_ij[i]\n    ri = row * i\n    banned_up[ri] = ru[0]\n    banned_down[ri] = rd[0]\n    for j in range(1, row):\n        banned_up[ri + j] = banned_up[(ri + j) - 1] + ru[j]\n        banned_down[ri + j] = banned_down[(ri + j) - 1] + rd[j]\nfor j in range(row):\n    rl = banned_left_ij[j]\n    rr = banned_right_ij[j]\n    banned_left[j] = rl[0]\n    banned_right[j] = rr[0]\n    for i in range(1, col):\n        ri0 = (i - 1) * row\n        ri1 = i * row\n        banned_left[ri1 + j] = banned_left[ri0 + j] + rl[i]\n        banned_right[ri1 + j] = banned_right[ri0 + j] + rr[i]\ns = (row * y_dict[0]) + x_dict[0]\nenable = (([-1] * row) + ((([-1] + ([0] * (row - 2))) + [-1]) * (col - 2))) + ([-1] * row)\nq = [s]\nmoves = [(-row, banned_up), (-1, banned_left), (1, banned_right), (row, banned_down)]\nwhile q:\n    c = q.pop()\n    if enable[c] == 1:\n        continue\n    elif enable[c] == -1:\n        print('INF')\n        exit()\n    enable[c] = 1\n    for (dc, banned) in moves:\n        if banned[c]:\n            continue\n        nc = c + dc\n        if enable[nc] == 1:\n            continue\n        q.append(nc)\nans = 0\nfor i in range(col):\n    ri = i * row\n    for j in range(row):\n        if enable[ri + j] != 1:\n            continue\n        t = y_list[i - 1]\n        b = y_list[i]\n        l = x_list[j - 1]\n        r = x_list[j]\n        ans += (b - t) * (r - l)\nprint(ans)", "generated_code": "import sys\n(n, m, *abcdef) = list(map(int, sys.stdin.buffer.read().split()))\nver_lines = []\nhor_lines = []\nx_list = set()\ny_list = set()\nn3 = n * 3\nfor (a, b, c) in zip(abcdef[0:n3:3], abcdef[1:n3:3], abcdef[2:n3:3]):\n    y_list.add(a)\n    y_list.add(b)\n    x_list.add(c)\n    ver_lines.append((a, b, c))\nfor (d, e, f) in zip(abcdef[n3 + 0::3], abcdef[n3 + 1::3], abcdef[n3 + 2::3]):\n    y_list.add(d)\n    x_list.add(e)\n    x_list.add(f)\n    hor_lines.append((d, e, f))\nx_list.add(0)\ny_list.add(0)\nx_list = sorted(x_list)\ny_list = sorted(y_list)\nx_dict = {x: i for (i, x) in enumerate(x_list, start=1)}\ny_dict = {y: i for (i, y) in enumerate(y_list, start=1)}\nrow_real = len(x_list)\ncol_real = len(y_list)\nrow = row_real + 2\ncol = col_real + 2\nbanned_up_ij = [[0] * row for _ in range(col)]\nbanned_down_ij = [[0] * row for _ in range(col)]\nbanned_left_ij = [[0] * col for _ in range(row)]\nbanned_right_ij = [[0] * col for _ in range(row)]\nfor (a, b, c) in ver_lines:\n    if a > b:\n        (a, b) = (b, a)\n    ai = y_dict[a]\n    bi = y_dict[b]\n    j = x_dict[c]\n    banned_left_ij[j][ai] += 1\n    banned_left_ij[j][bi] -= 1\n    banned_right_ij[j - 1][ai] += 1\n    banned_right_ij[j - 1][bi] -= 1\nfor (d, e, f) in hor_lines:\n    if e > f:\n        (e, f) = (f, e)\n    i = y_dict[d]\n    ej = x_dict[e]\n    fj = x_dict[f]\n    banned_up_ij[i][ej] += 1\n    banned_up_ij[i][fj] -= 1\n    banned_down_ij[i - 1][ej] += 1\n    banned_down_ij[i - 1][fj] -= 1\nbanned_up = [0] * (row * col)\nbanned_down = [0] * (row * col)\nbanned_left = [0] * (row * col)\nbanned_right = [0] * (row * col)\nfor i in range(col):\n    ru = banned_up_ij[i]\n    rd = banned_down_ij[i]\n    ri = row * i\n    banned_up[ri] = ru[0]\n    banned_down[ri] = rd[0]\n    for j in range(1, row):\n        banned_up[ri + j] = banned_up[(ri + j) - 1] + ru[j]\n        banned_down[ri + j] = banned_down[(ri + j) - 1] + rd[j]\nfor j in range(row):\n    rl = banned_left_ij[j]\n    rr = banned_right_ij[j]\n    banned_left[j] = rl[0]\n    banned_right[j] = rr[0]\n    for i in range(1, col):\n        ri0 = (i - 1) * row\n        ri1 = i * row\n        banned_left[ri1 + j] = banned_left[ri0 + j] + rl[i]\n        banned_right[ri1 + j] = banned_right[ri0 + j] + rr[i]\ns = (row * y_dict[0]) + x_dict[0]\nenable = (([-1] * row) + ((([-1] + ([0] * (row - 2))) + [-1]) * (col - 2))) + ([-1] * row)\nq = [s]\nmoves = [(-row, banned_up), (-1, banned_left), (1, banned_right), (row, banned_down)]\nwhile q:\n    c = q.pop()\n    if enable[c] == 1:\n        continue\n    elif enable[c] == +1:\n        print('INF')\n        exit()\n    enable[c] = 1\n    for (dc, banned) in moves:\n        if banned[c]:\n            continue\n        nc = c + dc\n        if enable[nc] == 1:\n            continue\n        q.append(nc)\nans = 0\nfor i in range(col):\n    ri = i * row\n    for j in range(row):\n        if enable[ri + j] != 1:\n            continue\n        t = y_list[i - 1]\n        b = y_list[i]\n        l = x_list[j - 1]\n        r = x_list[j]\n        ans += (b - t) * (r - l)\nprint(ans)", "score": 0.0, "codebleu": 0.9973984967720897, "crystalbleu": 0.9976480355539619, "codebertscore": 1.0, "codescore": 0.9542229175567627, "surfaceSim": 0.9863192064597217, "abs_surfaceSim_minus_score": 0.9863192064597217}
{"golden_code": "import math, string, itertools, fractions, heapq, collections, re, array, bisect, sys, random, time, copy, functools\nsys.setrecursionlimit(10 ** 7)\ninf = 10 ** 20\neps = 1.0 / (10 ** 15)\nmod = (10 ** 9) + 7\ndef LI():\n    return [int(x) for x in sys.stdin.readline().split()]\ndef LI_():\n    return [int(x) - 1 for x in sys.stdin.readline().split()]\ndef LF():\n    return [float(x) for x in sys.stdin.readline().split()]\ndef LS():\n    return sys.stdin.readline().split()\ndef I():\n    return int(sys.stdin.readline())\ndef F():\n    return float(sys.stdin.readline())\ndef S():\n    return input()\ndef pf(s):\n    return print(s, flush=True)\ndef divisions(n):\n    sq = int(math.sqrt(n) + 1)\n    d = collections.defaultdict(int)\n    while n % 2 == 0:\n        n //= 2\n        d[2] += 1\n    i = 3\n    while (n > 1 and sq >= i):\n        if n % i == 0:\n            n //= i\n            d[i] += 1else:i += 2\n    if n > 1:\n        d[n] += 1\n    r = [1]\n    for (k, v) in d.items():\n        for c in r[:]:\n            for i in range(1, v + 1):\n                r.append(c * (k ** i))\n    return sorted(r)\ndef main():\n    n = I()\n    a = LI()\n    s = set()\n    for i in range(n, 0, -1):\n        d = divisions(i)\n        ld = len(d)\n        for j in range(1, 2 ** ld):\n            c = []\n            ff = True\n            for k in range(ld):\n                if j & (1 << k):\n                    f = True\n                    for e in c:\n                        if d[k] % e == 0:\n                            f = False\n                            ff = False\n                            break\n                    if f:\n                        c.append(d[k])\n                if not ff:\n                    break\n            if ff:\n                s.add(tuple(c + [n + 1]))\n    b = sorted(list(s), reverse=True)\n    for c in b:\n        t = 0\n        for j in range(1, n + 1):\n            f = False\n            for e in c:\n                if j % e == 0:\n                    f = True\n                    break\n            if f:\n                t += a[j - 1]\n        if t < 0:\n            for j in range(1, n + 1):\n                f = False\n                for e in c:\n                    if j % e == 0:\n                        f = True\n                        break\n                if f:\n                    a[j - 1] = 0\n    return sum(a)\nprint(main())", "generated_code": "import math, string, itertools, fractions, heapq, collections, re, array, bisect, sys, random, time, copy, functools\nsys.setrecursionlimit(10 ** 7)\ninf = 10 ** 20\neps = 1.0 / (10 ** 15)\nmod = (10 ** 9) + 7\ndef LI():\n    return [int(x) for x in sys.stdin.readline().split()]\ndef LI_():\n    return [int(x) - 1 for x in sys.stdin.readline().split()]\ndef LF():\n    return [float(x) for x in sys.stdin.readline().split()]\ndef LS():\n    return sys.stdin.readline().split()\ndef I():\n    return int(sys.stdin.readline())\ndef F():\n    return float(sys.stdin.readline())\ndef S():\n    return input()\ndef pf(s):\n    return print(s, flush=True)\ndef divisions(n):\n    sq = int(math.sqrt(n) + 1)\n    d = collections.defaultdict(int)\n    while n % 2 == 0:\n        n //= 2\n        d[2] += 1\n    i = 3\n    while (n > 1 and sq >= i):\n        if n % i == 0:\n            n //= i\n            d[i] += 1else:i += 2\n    if n > 1:\n        d[n] += 1\n    r = [1]\n    for (k, v) in d.items():\n        for c in r[:]:\n            for i in range(1, v + 1):\n                r.append(c * (k ** i))\n    return sorted(r)\ndef main():\n    n = I()\n    a = LI()\n    s = set()\n    for i in range(n, 0, 1):\n        d = divisions(i)\n        ld = len(d)\n        for j in range(1, 2 ** ld):\n            c = []\n            ff = True\n            for k in range(ld):\n                if j & (1 << k):\n                    f = True\n                    for e in c:\n                        if d[k] % e == 0:\n                            f = False\n                            ff = False\n                            break\n                    if f:\n                        c.append(d[k])\n                if not ff:\n                    break\n            if ff:\n                s.add(tuple(c + [n + 1]))\n    b = sorted(list(s), reverse=True)\n    for c in b:\n        t = 0\n        for j in range(1, n + 1):\n            f = False\n            for e in c:\n                if j % e == 0:\n                    f = True\n                    break\n            if f:\n                t += a[j - 1]\n        if t < 0:\n            for j in range(1, n + 1):\n                f = False\n                for e in c:\n                    if j % e == 0:\n                        f = True\n                        break\n                if f:\n                    a[j - 1] = 0\n    return sum(a)\nprint(main())", "score": 0.0, "codebleu": 0.9912521356899024, "crystalbleu": 0.9959076913316193, "codebertscore": 1.0, "codescore": 0.9924472570419312, "surfaceSim": 0.49978466838931956, "abs_surfaceSim_minus_score": 0.49978466838931956}
{"golden_code": "class Calc:\n    def __init__(self, max_value, mod):\n        fact = [-1] * (max_value + 1)\n        fact[0] = 1\n        fact[1] = 1\n        for x in range(2, max_value + 1):\n            fact[x] = (x * fact[x - 1]) % mod\n        invs = [1] * (max_value + 1)\n        invs[max_value] = pow(fact[max_value], mod - 2, mod)\n        for x in range(max_value - 1, 0, -1):\n            invs[x] = (invs[x + 1] * (x + 1)) % mod\n        self.fact = fact\n        self.invs = invs\n        self.mod = mod\n    def combination(self, n, r):\n        if n - r < r:\n            return self.combination(n, n - r)\n        if r < 0:\n            return 0\n        if r == 0:\n            return 1\n        if r == 1:\n            return n\n        return ((self.fact[n] * self.invs[r]) * self.invs[n - r]) % self.mod\ndef gen(n):\n    x = n\n    d = 2\n    cnt = 0\n    while x % d == 0:\n        x //= d\n        cnt += 1\n    yield cnt\n    d = 3\n    ma = d * d\n    while ma <= n:\n        cnt = 0\n        while x % d == 0:\n            x //= d\n            cnt += 1\n        yield cnt\n        ma += (d * 4) + 4\n        d += 2\n    if x > 1:\n        yield 1\ndef main():\n    MOD = (10 ** 9) + 7\n    (N, M) = list(map(int, input().split()))\n    cal = Calc(max_value=N + 30, mod=MOD)\n    ans = 1\n    for cnt in gen(M):\n        ans = (ans * cal.combination((N + cnt) - 1, cnt)) % MOD\n    print(ans)", "generated_code": "class Calc:\n    def __init__(self, max_value, mod):\n        fact = [-1] / (max_value + 1)\n        fact[0] = 1\n        fact[1] = 1\n        for x in range(2, max_value + 1):\n            fact[x] = (x * fact[x - 1]) % mod\n        invs = [1] * (max_value + 1)\n        invs[max_value] = pow(fact[max_value], mod - 2, mod)\n        for x in range(max_value - 1, 0, -1):\n            invs[x] = (invs[x + 1] * (x + 1)) % mod\n        self.fact = fact\n        self.invs = invs\n        self.mod = mod\n    def combination(self, n, r):\n        if n - r < r:\n            return self.combination(n, n - r)\n        if r < 0:\n            return 0\n        if r == 0:\n            return 1\n        if r == 1:\n            return n\n        return ((self.fact[n] * self.invs[r]) * self.invs[n - r]) % self.mod\ndef gen(n):\n    x = n\n    d = 2\n    cnt = 0\n    while x % d == 0:\n        x //= d\n        cnt += 1\n    yield cnt\n    d = 3\n    ma = d * d\n    while ma <= n:\n        cnt = 0\n        while x % d == 0:\n            x //= d\n            cnt += 1\n        yield cnt\n        ma += (d * 4) + 4\n        d += 2\n    if x > 1:\n        yield 1\ndef main():\n    MOD = (10 ** 9) + 7\n    (N, M) = list(map(int, input().split()))\n    cal = Calc(max_value=N + 30, mod=MOD)\n    ans = 1\n    for cnt in gen(M):\n        ans = (ans * cal.combination((N + cnt) - 1, cnt)) % MOD\n    print(ans)", "score": 0.0, "codebleu": 0.9945974577626977, "crystalbleu": 0.9939884919996913, "codebertscore": 1.0, "codescore": 0.9937503933906555, "surfaceSim": 0.9868088422573227, "abs_surfaceSim_minus_score": 0.9868088422573227}
{"golden_code": "class Calc:\n    def __init__(self, max_value, mod):\n        fact = [-1] * (max_value + 1)\n        fact[0] = 1\n        fact[1] = 1\n        for x in range(2, max_value + 1):\n            fact[x] = (x * fact[x - 1]) % mod\n        invs = [1] * (max_value + 1)\n        invs[max_value] = pow(fact[max_value], mod - 2, mod)\n        for x in range(max_value - 1, 0, -1):\n            invs[x] = (invs[x + 1] * (x + 1)) % mod\n        self.fact = fact\n        self.invs = invs\n        self.mod = mod\n    def combination(self, n, r):\n        if n - r < r:\n            return self.combination(n, n - r)\n        if r < 0:\n            return 0\n        if r == 0:\n            return 1\n        if r == 1:\n            return n\n        return ((self.fact[n] * self.invs[r]) * self.invs[n - r]) % self.mod\ndef gen(n):\n    x = n\n    d = 2\n    cnt = 0\n    while x % d == 0:\n        x //= d\n        cnt += 1\n    yield cnt\n    d = 3\n    ma = d * d\n    while ma <= n:\n        cnt = 0\n        while x % d == 0:\n            x //= d\n            cnt += 1\n        yield cnt\n        ma += (d * 4) + 4\n        d += 2\n    if x > 1:\n        yield 1\ndef main():\n    MOD = (10 ** 9) + 7\n    (N, M) = list(map(int, input().split()))\n    cal = Calc(max_value=N + 30, mod=MOD)\n    ans = 1\n    for cnt in gen(M):\n        ans = (ans * cal.combination((N + cnt) - 1, cnt)) % MOD\n    print(ans)", "generated_code": "class Calc:\n    def __init__(self, max_value, mod):\n        fact = [-1] * (max_value + 1)\n        fact[0] = 1\n        fact[1] = 1\n        for x in range(2, max_value - 1):\n            fact[x] = (x * fact[x - 1]) % mod\n        invs = [1] * (max_value + 1)\n        invs[max_value] = pow(fact[max_value], mod - 2, mod)\n        for x in range(max_value - 1, 0, -1):\n            invs[x] = (invs[x + 1] * (x + 1)) % mod\n        self.fact = fact\n        self.invs = invs\n        self.mod = mod\n    def combination(self, n, r):\n        if n - r < r:\n            return self.combination(n, n - r)\n        if r < 0:\n            return 0\n        if r == 0:\n            return 1\n        if r == 1:\n            return n\n        return ((self.fact[n] * self.invs[r]) * self.invs[n - r]) % self.mod\ndef gen(n):\n    x = n\n    d = 2\n    cnt = 0\n    while x % d == 0:\n        x //= d\n        cnt += 1\n    yield cnt\n    d = 3\n    ma = d * d\n    while ma <= n:\n        cnt = 0\n        while x % d == 0:\n            x //= d\n            cnt += 1\n        yield cnt\n        ma += (d * 4) + 4\n        d += 2\n    if x > 1:\n        yield 1\ndef main():\n    MOD = (10 ** 9) + 7\n    (N, M) = list(map(int, input().split()))\n    cal = Calc(max_value=N + 30, mod=MOD)\n    ans = 1\n    for cnt in gen(M):\n        ans = (ans * cal.combination((N + cnt) - 1, cnt)) % MOD\n    print(ans)", "score": 0.0, "codebleu": 0.9945974577626977, "crystalbleu": 0.9947995807952579, "codebertscore": 1.0, "codescore": 0.9937525391578674, "surfaceSim": 0.9996293550778355, "abs_surfaceSim_minus_score": 0.9996293550778355}
{"golden_code": "class Calc:\n    def __init__(self, max_value, mod):\n        fact = [-1] * (max_value + 1)\n        fact[0] = 1\n        fact[1] = 1\n        for x in range(2, max_value + 1):\n            fact[x] = (x * fact[x - 1]) % mod\n        invs = [1] * (max_value + 1)\n        invs[max_value] = pow(fact[max_value], mod - 2, mod)\n        for x in range(max_value - 1, 0, -1):\n            invs[x] = (invs[x + 1] * (x + 1)) % mod\n        self.fact = fact\n        self.invs = invs\n        self.mod = mod\n    def combination(self, n, r):\n        if n - r < r:\n            return self.combination(n, n - r)\n        if r < 0:\n            return 0\n        if r == 0:\n            return 1\n        if r == 1:\n            return n\n        return ((self.fact[n] * self.invs[r]) * self.invs[n - r]) % self.mod\ndef gen(n):\n    x = n\n    d = 2\n    cnt = 0\n    while x % d == 0:\n        x //= d\n        cnt += 1\n    yield cnt\n    d = 3\n    ma = d * d\n    while ma <= n:\n        cnt = 0\n        while x % d == 0:\n            x //= d\n            cnt += 1\n        yield cnt\n        ma += (d * 4) + 4\n        d += 2\n    if x > 1:\n        yield 1\ndef main():\n    MOD = (10 ** 9) + 7\n    (N, M) = list(map(int, input().split()))\n    cal = Calc(max_value=N + 30, mod=MOD)\n    ans = 1\n    for cnt in gen(M):\n        ans = (ans * cal.combination((N + cnt) - 1, cnt)) % MOD\n    print(ans)", "generated_code": "class Calc:\n    def __init__(self, max_value, mod):\n        fact = [-1] * (max_value - 1)\n        fact[0] = 1\n        fact[1] = 1\n        for x in range(2, max_value + 1):\n            fact[x] = (x * fact[x - 1]) % mod\n        invs = [1] * (max_value + 1)\n        invs[max_value] = pow(fact[max_value], mod - 2, mod)\n        for x in range(max_value - 1, 0, -1):\n            invs[x] = (invs[x + 1] * (x + 1)) % mod\n        self.fact = fact\n        self.invs = invs\n        self.mod = mod\n    def combination(self, n, r):\n        if n - r < r:\n            return self.combination(n, n - r)\n        if r < 0:\n            return 0\n        if r == 0:\n            return 1\n        if r == 1:\n            return n\n        return ((self.fact[n] * self.invs[r]) * self.invs[n - r]) % self.mod\ndef gen(n):\n    x = n\n    d = 2\n    cnt = 0\n    while x % d == 0:\n        x //= d\n        cnt += 1\n    yield cnt\n    d = 3\n    ma = d * d\n    while ma <= n:\n        cnt = 0\n        while x % d == 0:\n            x //= d\n            cnt += 1\n        yield cnt\n        ma += (d * 4) + 4\n        d += 2\n    if x > 1:\n        yield 1\ndef main():\n    MOD = (10 ** 9) + 7\n    (N, M) = list(map(int, input().split()))\n    cal = Calc(max_value=N + 30, mod=MOD)\n    ans = 1\n    for cnt in gen(M):\n        ans = (ans * cal.combination((N + cnt) - 1, cnt)) % MOD\n    print(ans)", "score": 0.0, "codebleu": 0.9945974577626977, "crystalbleu": 0.9947995807952579, "codebertscore": 1.0, "codescore": 0.9937525391578674, "surfaceSim": 0.9996293550778355, "abs_surfaceSim_minus_score": 0.9996293550778355}
{"golden_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "generated_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return __dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "score": 0.0, "codebleu": 0.9886792371081594, "crystalbleu": 0.9936989720107794, "codebertscore": 1.0, "codescore": 0.9828541278839111, "surfaceSim": 0.9984634296250768, "abs_surfaceSim_minus_score": 0.9984634296250768}
{"golden_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "generated_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\npass\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "score": 0.0, "codebleu": 0.8311574505776825, "crystalbleu": 0.8828000623234705, "codebertscore": 0.99, "codescore": 0.2227354198694229, "surfaceSim": 0.9662066021627775, "abs_surfaceSim_minus_score": 0.9662066021627775}
{"golden_code": "from functools import lru_cache\nimport sys\nsys.setrecursionlimit(10 ** 7)\n\n@lru_cache(maxsize=None)\ndef check(l, r, n, k=1):t = (l + ('0' * k)) + r\n    e = (l + ('9' * k)) + r\n    if int(e) <= n:\n        return pow(10, k) + check(l, r, n, k + 1)\n    if int(t) <= n < int(e):\n        x = int(str(n)[1:-1])\n        if int(str(n)[-1]) < int(r):\n            x -= 1\n        return x + 1\n    if n < int(t):\n        return 0\ndef main():\n    n = int(eval(input()))\n    ret = 0\n    for x in range(1, n + 1):\n        if x % 10 == 0:\n            continue\n        s = str(x)\n        t = s[-1] + s[0]\n        if s[0] == s[-1]:\n            ret += 1\n        if int(t) <= n:\n            ret += 1\n        ret += check(s[-1], s[0], n, k=1)\n    print(ret)", "generated_code": "from functools import lru_cache\nimport sys\nsys.setrecursionlimit(10 * 7)\n\n@lru_cache(maxsize=None)\ndef check(l, r, n, k=1):t = (l + ('0' * k)) + r\n    e = (l + ('9' * k)) + r\n    if int(e) <= n:\n        return pow(10, k) + check(l, r, n, k + 1)\n    if int(t) <= n < int(e):\n        x = int(str(n)[1:-1])\n        if int(str(n)[-1]) < int(r):\n            x -= 1\n        return x + 1\n    if n < int(t):\n        return 0\ndef main():\n    n = int(eval(input()))\n    ret = 0\n    for x in range(1, n + 1):\n        if x % 10 == 0:\n            continue\n        s = str(x)\n        t = s[-1] + s[0]\n        if s[0] == s[-1]:\n            ret += 1\n        if int(t) <= n:\n            ret += 1\n        ret += check(s[-1], s[0], n, k=1)\n    print(ret)", "score": 0.0, "codebleu": 0.989831222213881, "crystalbleu": 0.9934272660813728, "codebertscore": 1.0, "codescore": 0.9937652349472046, "surfaceSim": 0.499320652173913, "abs_surfaceSim_minus_score": 0.499320652173913}
{"golden_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "generated_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        break\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "score": 0.0, "codebleu": 0.9706943679537091, "crystalbleu": 0.9626898460033498, "codebertscore": 0.99, "codescore": 0.9935423135757446, "surfaceSim": 0.9901871291647649, "abs_surfaceSim_minus_score": 0.9901871291647649}
{"golden_code": "def cmb(n, r):\n    import math\n    if n < r:\n        return 0\n    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\ndef solve(S):\n    mod = (10 ** 9) + 7\n    ans = 0\n    for i in range(1, (S // 3) + 1):\n        tama = i + (S - (i * 3))\n        tama -= 2\n        bo = i - 1\n        ans += cmb(tama + 1, bo)\n        ans %= mod\n    print(ans)", "generated_code": "def cmb(n, r):\n    import math\n    if n < r:\n        return 0\n    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\ndef solve(S):\n    mod = (10 ** 9) + 7\n    ans = 0\n    for i in range(1, (S // 3) + 1):\n        tama = i + (S - (i * 3))\n        tama -= 2\n        bo = i - 1\n        ans += cmb(tama + 1, bo)\n        ans %= mod\n    print(ans)", "score": 0.0, "codebleu": 1.0, "crystalbleu": 1.0, "codebertscore": 1.0, "codescore": 0.9937273263931274, "surfaceSim": 1.0, "abs_surfaceSim_minus_score": 1.0}
{"golden_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "generated_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] ** self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "score": 0.0, "codebleu": 0.9945883912637858, "crystalbleu": 0.9958766805969164, "codebertscore": 1.0, "codescore": 0.9935546517372131, "surfaceSim": 0.9869513849897061, "abs_surfaceSim_minus_score": 0.9869513849897061}
{"golden_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "generated_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if not (v is None):\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "score": 0.0, "codebleu": 0.9881783380372205, "crystalbleu": 0.9886932603754609, "codebertscore": 1.0, "codescore": 0.9877904653549194, "surfaceSim": 0.9878824121868311, "abs_surfaceSim_minus_score": 0.9878824121868311}
