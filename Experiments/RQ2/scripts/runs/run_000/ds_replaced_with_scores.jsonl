{"golden_code": "import sys\n\ninput = sys.stdin.readline\n\n\n\nN,L,T = list(map(int,input().split()))\n\nXW = [[int(x) for x in input().split()] for _ in range(N)]\n\n\n\nX,W = list(zip(*XW))\n\n\n\nDX = [1 if w == 1 else -1 for w in W]\n\n\n\nY = [(x+dx*T)%L for x,dx in zip(X,DX)]\n\ny0 = Y[0]\n\nY.sort()\n\n\n\n# 番号1がすれ違わず進んだ場所に相当するアリの番号\n\n# すれ違うたびに1増える（W1=1） or 1減る（W1=-1）\n\n# T秒ちょうどもすれ違い終わったと考える\n\n\n\nx = 0\n\nx0,dx0 = X[0],DX[0]\n\nfor y,dy in zip(X[1:],DX[1:]):\n\n    if dx0 == dy:\n\n        continue\n\n    if dx0 == 1 and dy == -1:\n\n        # 正の向きに追い越すので番号がひとつ増える\n\n        x += (2*T-(y-x0)-1)//L + 1\n\n    if dx0 == -1 and dy == 1:\n\n        x -= (2*T-(L+x0-y))//L + 1\n\nx %= N\n\n\n\ni = Y.index(y0)\n\n\n\nY += Y\n\n\n\nanswer = [None] * N\n\nanswer[x:N] = Y[i:i+N-x]\n\nanswer[0:x] = Y[i+N-x:i+N]\n\n\n\nprint(('\\n'.join(map(str,answer))))\n\n\n", "generated_code": "import sys\n\nimport numpy as np\n\n\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\n\"\"\"\n\n・順序が固定されるので、区間だったら簡単\n\n・円のときも、地点 0 をそれぞれの方向に通った人数を見れば計算できる\n\n\"\"\"\n\n\n\nN, L, T = list(map(int, readline().split()))\n\nXW = np.array(read().split(), np.int64)\n\nX = XW[::2]\n\nW = XW[1::2]\n\n\n\nspeed = np.where(W == 1, 1, -1)\n\n\n\nY = X + speed * T\n\n\n\nn = (Y // L - X // L).sum()\n\nn %= N\n\n\n\nY %= L\n\nY.sort()\n\nY = np.concatenate((Y[n:], Y[:n]))\n\n\n\nprint(('\\n'.join(map(str, Y.tolist()))))", "score": 1.0, "codebleu": 0.12710036014394357, "crystalbleu": 0.1384313089053213, "codebertscore": 0.75, "codescore": 0.14429619908332825, "surfaceSim": 0.5943264693264694, "abs_surfaceSim_minus_score": 0.4056735306735306}
{"golden_code": "from collections import defaultdict\n\nn = int(eval(input()))\n\ns = eval(input())\n\n\n\na = s[:n]\n\nb = s[n:][::-1]\n\nd = defaultdict(int)\n\ne = defaultdict(int)\n\n\n\ndef cnt(c, d):\n\n    for bit in range(1 << n):\n\n        x = []\n\n        y = []\n\n        for i in range(n):\n\n            if bit >> i & 1:\n\n                x.append(c[i])\n\n            else:\n\n                y.append(c[i])\n\n        d[(str(x), str(y))] += 1\n\n\n\n\n\ncnt(a, d)\n\ncnt(b, e)\n\n\n\nans = 0\n\nfor k, v in list(d.items()):\n\n    ans += e[k] * v\n\nprint(ans)\n", "generated_code": "from collections import defaultdict\n\nn = int(eval(input()))\n\ns = eval(input())\n\n\n\na = s[:n]\n\nb = s[n:][::-1]\n\nd = defaultdict(int)\n\ne = defaultdict(int)\n\n\n\nfor bit in range(1 << n):\n\n    x = \"\"\n\n    y = \"\"\n\n    z = \"\"\n\n    w = \"\"\n\n    for i in range(n):\n\n        if bit >> i & 1:\n\n            x += a[i]\n\n            z += b[i]\n\n        else:\n\n            y += a[i]\n\n            w += b[i]\n\n    d[x+'ω'+y] += 1\n\n    e[z+'ω'+w] += 1\n\n\n\nprint((sum([e[k] * v for k, v in list(d.items())])))\n", "score": 1.0, "codebleu": 0.5589261823157031, "crystalbleu": 0.5463071271125595, "codebertscore": 0.91, "codescore": 0.9938913583755493, "surfaceSim": 0.7962303536345776, "abs_surfaceSim_minus_score": 0.20376964636542239}
{"golden_code": "import sys\n\ninput = sys.stdin.readline\n\n\n\ndef I(): return int(eval(input()))\n\ndef MI(): return list(map(int, input().split()))\n\ndef LI(): return list(map(int, input().split()))\n\n\n\ndef main():\n\n    mod=10**9+7\n\n    N,M=MI()\n\n    A=LI()\n\n    CB=[[0,0]for _ in range(M)]\n\n    A.sort()\n\n    for i in range(M):\n\n        CB[i][1],CB[i][0]=MI()\n\n        \n\n    CB.sort(reverse=True)\n\n    now=0\n\n    \n\n    for i in range(N):\n\n        if CB[now][1]<=0:\n\n            now+=1\n\n        \n\n        if now>=M:\n\n            break    \n\n        \n\n        ch=CB[now][0]\n\n        if A[i]<ch:\n\n            A[i]=ch\n\n            CB[now][1]-=1\n\n        else:\n\n            break\n\n        \n\n    print((sum(A)))\n\n    \n\n\n\nmain()\n", "generated_code": "import sys\n\ninput = sys.stdin.readline\n\n\n\ndef I(): return int(eval(input()))\n\ndef MI(): return list(map(int, input().split()))\n\ndef LI(): return list(map(int, input().split()))\n\n\n\ndef main():\n\n    mod=10**9+7\n\n    N,M=MI()\n\n    A=LI()\n\n    B=[0]*M\n\n    C=[0]*M\n\n    for i in range(M):\n\n        B[i],C[i]=MI()\n\n    \n\n    C,B=list(zip(*sorted(zip(C,B))))\n\n    B=B[::-1]\n\n    C=C[::-1]\n\n    \n\n    import heapq\n\n    heapq.heapify(A)\n\n    \n\n    for i in range(M):\n\n        b=B[i]\n\n        c=C[i]\n\n        for _ in range(b):\n\n            a=heapq.heappop(A)\n\n            if a>=c:\n\n                heapq.heappush(A,a)\n\n                break\n\n            else:\n\n                heapq.heappush(A,c)\n\n                \n\n    ans=0\n\n    for i in range(N):\n\n        a=heapq.heappop(A)\n\n        ans+=a\n\n        \n\n    print(ans)\n\n\n\nmain()\n", "score": 1.0, "codebleu": 0.5730722615168584, "crystalbleu": 0.45778395330971133, "codebertscore": 0.86, "codescore": 0.17492932081222534, "surfaceSim": 0.7135356639774619, "abs_surfaceSim_minus_score": 0.28646433602253807}
{"golden_code": "import sys\n\nsys.setrecursionlimit(2147483647)\n\nINF=float(\"inf\")\n\nMOD=10**9+7\n\ninput=lambda :sys.stdin.readline().rstrip()\n\ndef resolve():\n\n    n,W=list(map(int,input().split()))\n\n    WV=[tuple(map(int,input().split())) for _ in range(n)]\n\n\n\n    V=100000\n\n    dp=[INF]*(V+1)\n\n    dp[0]=0\n\n\n\n    for w,v in WV:\n\n        for x in range(V,-1,-1):\n\n            if(x+v<=V):\n\n                dp[x+v]=min(dp[x+v],dp[x]+w)\n\n\n\n    for x in range(V,-1,-1):\n\n        if(dp[x]<=W):\n\n            print(x)\n\n            return\n\nresolve()", "generated_code": "import sys\n\nINF = 1 << 60\n\nMOD = 10**9 + 7 # 998244353\n\nsys.setrecursionlimit(2147483647)\n\ninput = lambda:sys.stdin.readline().rstrip()\n\ndef resolve():\n\n    n, W = list(map(int, input().split()))\n\n    dp = [INF] * (n * 1001 + 1)\n\n    dp[0] = 0\n\n    for _ in range(n):\n\n        w, v = list(map(int, input().split()))\n\n        for v0 in range(n * 1001, -1, -1):\n\n            if dp[v0] == INF:\n\n                continue\n\n            if v + v0 <= n * 1001:\n\n                dp[v + v0] = min(dp[v + v0], dp[v0] + w)\n\n    for v in range(n * 1001, -1, -1):\n\n        if dp[v] <= W:\n\n            print(v)\n\n            return\n\nresolve()", "score": 1.0, "codebleu": 0.32402816079808483, "crystalbleu": 0.5942410233603401, "codebertscore": 0.89, "codescore": 0.5075006484985352, "surfaceSim": 0.7834993422289043, "abs_surfaceSim_minus_score": 0.21650065777109573}
{"golden_code": "l,r = list(map(int,input().split()))\n\n\n\nif r - l > 2019:\n\n    print((0))\n\nelse:\n\n    tres = 2019\n\n    for i in range(l,r):\n\n        for j in range(i+1,r+1):\n\n            mod = (i % 2019) * (j % 2019) % 2019\n\n            tres = min(tres,mod)\n\n    print(tres)\n", "generated_code": "l,r = list(map(int,input().split()))\n\n\n\nif r - l > 2019:\n\n    print((0))\n\nelse:\n\n    tres = 2019\n\n    for i in range(l,r):\n\n        for j in range(i+1,r+1):\n\n            mod = (i % 2019) * (j % 2019) % 2019\n\n            tres = min(tres,mod)\n\n            if tres == 0:\n\n                break\n\n        if tres == 0:\n\n            break\n\n    print(tres)\n", "score": 1.0, "codebleu": 0.8954411932457788, "crystalbleu": 0.0, "codebertscore": 0.98, "codescore": 0.993794322013855, "surfaceSim": 0.9038095238095238, "abs_surfaceSim_minus_score": 0.09619047619047616}
{"golden_code": "n = int(eval(input()))\n\na = list(map(int, input().split()))\n\na_index = []\n\nfor i in range(n):\n\n    a_index.append((i, a[i]))\n\ndic1 = {}\n\ndic2 = {}\n\nfor i in range(n):\n\n    one = a_index[i][0] + a_index[i][1]\n\n    two = a_index[i][0] - a_index[i][1]\n\n    if one not in dic1:\n\n        dic1[one] = 1\n\n    else:\n\n        dic1[one] += 1\n\n    if two not in dic2:\n\n        dic2[two] = 1\n\n    else:\n\n        dic2[two] += 1\n\nans = 0\n\nfor i in list(dic1.keys()):\n\n    if i in dic2:\n\n        ans += dic2[i] * dic1[i]\n\nfor i in list(dic2.keys()):\n\n    if i in dic1:\n\n        ans += dic1[i] * dic2[i]\n\n        #print(i)\n\nprint((ans // 2))\n", "generated_code": "n = int(eval(input()))\n\na = list(map(int, input().split()))\n\nimport collections\n\nans = 0\n\ndic = collections.defaultdict(int)\n\nfor i in range(1, n + 1):\n\n    ans += dic[i - a[i - 1]]\n\n    dic[i + a[i - 1]] += 1\n\nprint(ans)", "score": 1.0, "codebleu": 0.1642970443160433, "crystalbleu": 0.0845035830609743, "codebertscore": 0.8, "codescore": 0.4053153693675995, "surfaceSim": 0.5574784049224943, "abs_surfaceSim_minus_score": 0.44252159507750566}
{"golden_code": "N, X = list(map(int, input().split()))\n\n\n\nmn = [0]*N\n\nfor i in range(N):\n\n  mn[i] = int(eval(input()))\n\n  \n\nans = N\n\nx = X - sum(mn)\n\n\n\nwhile(x >= min(mn)):\n\n  if x // min(mn) == 0:\n\n    mn[mn.index(min(mn))] = 1000000\n\n  else:\n\n    if x >= min(mn):\n\n      x -= min(mn)\n\n      ans += 1\n\n      \n\nprint(ans)", "generated_code": "N, X = list(map(int, input().split()))\n\n\n\nmn = [0]*N\n\nfor i in range(N):\n\n  mn[i] = int(eval(input()))\n\n  \n\nans = N\n\nx = X - sum(mn)\n\n\n\nwhile(x >= min(mn)):\n\n  if x // min(mn) == 0:\n\n    mn[mn.index(min(mn))] = 1000000\n\n  else:\n\n    x -= min(mn)\n\n    ans += 1\n\n      \n\nprint(ans)", "score": 1.0, "codebleu": 0.8956026068046825, "crystalbleu": 0.9155006090724137, "codebertscore": 0.99, "codescore": 0.9938190579414368, "surfaceSim": 0.9770491803278689, "abs_surfaceSim_minus_score": 0.022950819672131084}
{"golden_code": "N = int(eval(input()))\n\nX = list(map(int, input().split()))\n\nX = list(sorted(X))\n\nif N == 1:\n\n  print((0))\n\n  exit()\n\nans = float('inf')\n\nfor p in range(X[0], X[N - 1] + 1):\n\n  sum = 0\n\n  for x in X:\n\n    sum += (x - p) ** 2\n\n  ans = min(sum, ans)\n\nprint(ans)", "generated_code": "N = int(eval(input()))\n\nX = list(map(int, input().split()))\n\navg = round(sum(X) / N)\n\nprint((sum([(x - avg) ** 2 for x in X])))", "score": 1.0, "codebleu": 0.2746257517972137, "crystalbleu": 0.17741221736616883, "codebertscore": 0.84, "codescore": 0.08497625589370728, "surfaceSim": 0.5330703374181636, "abs_surfaceSim_minus_score": 0.46692966258183644}
{"golden_code": "A, B = list(map(int, input().split()))\n\ncnt = 0\n\nfor i in range(A, B+1):\n\n    l = list(str(i))\n\n\n\n    if l == list(reversed(l)):\n\n        cnt += 1\n\n\n\nprint(cnt)\n", "generated_code": "A, B = list(map(int, input().split()))\n\ncnt = 0\n\nfor i in range(A, B+1):\n\n    l = str(i)\n\n    if l == l[::-1]:\n\n        cnt += 1\n\n\n\nprint(cnt)\n", "score": 1.0, "codebleu": 0.7711253295607611, "crystalbleu": 0.0, "codebertscore": 0.96, "codescore": 0.8900166153907776, "surfaceSim": 0.8364389233954451, "abs_surfaceSim_minus_score": 0.16356107660455488}
{"golden_code": "import math\n\nimport numpy as np\n\nn, d = list(map(int, input().split()))\n\na = []\n\ncnt = 0\n\nfor x in range(n):\n\n    a.append(list(map(int, input().split())))\n\nfor i in range(len(a)):\n\n    for j in range(len(a)):\n\n        if i < j:\n\n            dis = np.array(a[i]) - np.array(a[j])\n\n            if np.linalg.norm(dis).is_integer():\n\n                cnt += 1\n\nprint(cnt)", "generated_code": "n, d = list(map(int, input().split()))\n\na = [[int(i) for i in input().split()] for i in range(n)]\n\nans = 0\n\ndef dis(x,y):\n\n    T = []\n\n    for i in range(len(x)):\n\n        T.append((x[i]-y[i])**2)\n\n    return sum(T)\n\nfor i in range(n):\n\n    for j in range(i+1,n):\n\n        r = dis(a[i], a[j])\n\n        for k in range(r + 1):\n\n            if k ** 2 == r:\n\n                ans += 1\n\nprint(ans)", "score": 1.0, "codebleu": 0.37043787570892733, "crystalbleu": 0.29626534259493903, "codebertscore": 0.83, "codescore": 0.6974702477455139, "surfaceSim": 0.5936803894068146, "abs_surfaceSim_minus_score": 0.40631961059318544}
{"golden_code": "n=int(eval(input()))\n\ndp=[[0 for i in range(3)] for i in range(n)]\n\nS=[[0 for i in range(3)] for i in range(n)]\n\ndp[0]=list(map(int,input().split()))\n\nS[0]=dp[0].copy()\n\nfor i in range(1,n):\n\n    S[i]=list(map(int,input().split()))\n\n    for j in range(3):\n\n        dp[i][j]=max(dp[i-1][j-1],dp[i-1][j-2])+S[i][j]\n\n\n\nprint((max(dp[n-1][0],dp[n-1][1],dp[n-1][2])))\n\n#dp[i][j]=i番目にjを選んだ時の最大値(jはa,b,cに対応している。)", "generated_code": "n=int(eval(input()))\n\ndp=[[0 for i in range(3)] for i in range(n)]\n\ndp[0]=list(map(int,input().split()))\n\nfor i in range(1,n):\n\n    S=list(map(int,input().split()))\n\n    for j in range(3):\n\n        dp[i][j]=max(dp[i-1][j-1],dp[i-1][j-2])+S[j]\n\n\n\nprint((max(dp[n-1][0],dp[n-1][1],dp[n-1][2])))\n\n#dp[i][j]=i番目にjを選んだ時の最大値(jはa,b,cに対応している。)", "score": 1.0, "codebleu": 0.5732990252012866, "crystalbleu": 0.7671577969945138, "codebertscore": 0.97, "codescore": 0.3242105543613434, "surfaceSim": 0.9259259259259259, "abs_surfaceSim_minus_score": 0.07407407407407407}
{"golden_code": "import sys\n\nimport numpy as np\n\n\n\nstdin = sys.stdin\n\n \n\nri = lambda: int(rs())\n\nrl = lambda: list(map(int, stdin.readline().split()))\n\nrs = lambda: stdin.readline().rstrip()  # ignore trailing spaces\n\n\n\nS = list(rs())\n\nW = [0] * len(S)\n\nfor i in range(len(S)):\n\n    if S[i] == 'W':\n\n        W[i] = 1\n\nW = np.array(W[::-1])\n\nW_cum = W.cumsum()[::-1]\n\nW_cum = W_cum.tolist()\n\nanswer = 0\n\nfor i in range(len(S)):\n\n    if S[i] == 'B':\n\n        answer += W_cum[i]\n\n\n\nprint(answer)", "generated_code": "import sys\n\nimport numpy as np\n\n\n\nstdin = sys.stdin\n\n \n\nri = lambda: int(rs())\n\nrl = lambda: list(map(int, stdin.readline().split()))\n\nrs = lambda: stdin.readline().rstrip()  # ignore trailing spaces\n\n\n\nS = list(rs())\n\ncnt_B = 0\n\nanswer = 0\n\nfor s in S:\n\n    if s == 'B':\n\n        cnt_B += 1\n\n    else:\n\n        answer += cnt_B\n\nprint(answer)\n", "score": 1.0, "codebleu": 0.4416124269775608, "crystalbleu": 0.32037431689569157, "codebertscore": 0.88, "codescore": 0.7272338271141052, "surfaceSim": 0.7002729044834308, "abs_surfaceSim_minus_score": 0.2997270955165692}
{"golden_code": "import string\n\nw = eval(input())\n\nfor a in string.ascii_lowercase:\n\n    cnt = 0\n\n    for t in w:\n\n        if t == a:\n\n            cnt = cnt + 1\n\n    if cnt % 2 == 1:\n\n        print(\"No\")\n\n        exit()\n\n\n\nprint(\"Yes\")", "generated_code": "w = eval(input())\n\nm = [0] * 26\n\nfor t in w:\n\n    m[ord(t) - ord('a')] += 1\n\n\n\nfor cnt in m:\n\n    if cnt % 2 == 1:\n\n        print(\"No\")\n\n        exit()\n\n\n\nprint(\"Yes\")", "score": 1.0, "codebleu": 0.39353395807567715, "crystalbleu": 0.0, "codebertscore": 0.87, "codescore": 0.9239439368247986, "surfaceSim": 0.6611238532110092, "abs_surfaceSim_minus_score": 0.3388761467889908}
{"golden_code": "import numpy as np\n\nn,l = list(map(int,input().split()))\n\ntaste = np.array([l+i-1 for i in range(1,n+1)])\n\ntaste[np.fabs(taste).argmin()]=0\n\nprint((taste.sum()))", "generated_code": "n,l = list(map(int,input().split()))\n\ntaste = [l+i for i in range(0,n)]\n\ntaste.sort(key=lambda x:abs(x))\n\nprint((sum(taste[1:])))", "score": 1.0, "codebleu": 0.32857995613267055, "crystalbleu": 0.0, "codebertscore": 0.87, "codescore": 0.7878434658050537, "surfaceSim": 0.6106366459627329, "abs_surfaceSim_minus_score": 0.3893633540372671}
{"golden_code": "from fractions import gcd\n\n\n\nn,m=list(map(int,input().split()))\n\na=list(map(int,input().split()))\n\na=list(set(a))\n\n\n\na=list([x//2 for x in a])\n\n\n\ndef lcm(q):\n\n  x = q[0]\n\n  for i in range(1, len(q)):\n\n    x = (x * q[i]) // gcd(x, q[i])\n\n  return x\n\n\n\nlcma=lcm(a)\n\n\n\nif (lcma//a[0])%2==0:\n\n  print((0))\n\nelse:\n\n  flg=0\n\n  for i in range(1,len(a)):\n\n    if (lcma//a[i])%2==0:\n\n      print((0))\n\n      flg=1\n\n      break\n\n  if flg==0:\n\n    temp=m//lcma\n\n    print((temp//2 if temp%2==0 else temp//2+1))", "generated_code": "from math import gcd\n\nn,m=list(map(int,input().split()))\n\na=list(map(int,input().split()))\n\na=list(set(a))\n\na=list([x//2 for x in a])\n\n\n\ndef lcm(q):\n\n  x = q[0]\n\n  for i in range(1, len(q)):\n\n    x = (x * q[i]) // gcd(x, q[i])\n\n  return x\n\n\n\nlcma=lcm(a)\n\nfor i in range(len(a)):\n\n  if (lcma//a[i])%2==0:\n\n    print((0))\n\n    exit()\n\ntemp=m//lcma\n\nprint((temp//2 if temp%2==0 else temp//2+1))", "score": 1.0, "codebleu": 0.7667790229313646, "crystalbleu": 0.77239021698609, "codebertscore": 0.96, "codescore": 0.9583386182785034, "surfaceSim": 0.9117266791647811, "abs_surfaceSim_minus_score": 0.08827332083521888}
{"golden_code": "# -*- coding: utf-8 -*-\n\n\n\n\"\"\"\n\n参考：http://drken1215.hatenablog.com/entry/2018/09/23/224100\n\n　　　http://tutuz.hateblo.jp/entry/2018/09/24/121248\n\n・素因数分解と重複組み合わせ\n\n・毎回階乗やると死ぬから階乗と逆元のテーブル作る(忘れてた)\n\n\"\"\"\n\n\n\nfrom collections import defaultdict\n\nfrom math import sqrt\n\n\n\nMOD = 10 ** 9 + 7\n\n\n\ndef fact_prime(num):\n\n    d = defaultdict(int)\n\n    # 終点はルート切り捨て+1\n\n    end = int(sqrt(num)) + 1\n\n    for i in range(2, end+1):\n\n        cnt = 0\n\n        # 素因数分解：小さい方から割れるだけ割って素数をカウント\n\n        while num % i == 0:\n\n            num //= i\n\n            d[i] += 1\n\n        # 1まで来たら終了\n\n        if num == 1:\n\n            break\n\n    # 最後までそのまま来たやつはnumが素数(ただし1^1は1^0なので数に入れない)\n\n    if num != 1:\n\n        d[num] += 1\n\n    return d\n\n\n\n# とりあえずv+N-1が収まればいいはず\n\nMAX = 10 ** 5 * 2\n\n# 予め組み合わせ計算に必要な階乗と逆元のテーブルを作っておく\n\nfactorial = [1] * (MAX)\n\nfactorial[0] = factorial[1] = 1\n\nfor i in range(2, MAX):\n\n    factorial[i] = factorial[i-1] * i % MOD\n\n\n\ninverse = [1] * (MAX)\n\n# powに第三引数入れると冪乗のmod付計算を高速にやってくれる\n\ninverse[MAX-1] = pow(factorial[MAX-1], MOD-2, MOD)\n\nfor i in range(MAX-2, 0, -1):\n\n    # 最後から戻っていくこのループならH+W回powするより処理が速い\n\n    inverse[i] = inverse[i+1] * (i+1) % MOD\n\n\n\n# 組み合わせの数\n\ndef nCr(n, r):\n\n    # 10C7 = 10C3\n\n    r = min(r, n-r)\n\n    # 分子の計算\n\n    numerator = factorial[n]\n\n    # 分母の計算\n\n    denominator = inverse[r] * inverse[n-r] % MOD\n\n    return numerator * denominator % MOD\n\n\n\nN, M = list(map(int, input().split()))\n\n\n\n# d = fact_prime(M)\n\n# print(d)\n\nans = 1\n\nfor k, v in list(fact_prime(M).items()):\n\n    # 重複組み合わせ\n\n    # v個のkとN-1個の仕切りから、v個を並べる(v+N-1個のマスからv個を選び出す組み合わせ)\n\n    ans = (ans * nCr(v+N-1, v)) % MOD\n\nprint(ans)\n", "generated_code": "# -*- coding: utf-8 -*-\n\n\n\nimport sys\n\n\n\ndef input(): return sys.stdin.readline().strip()\n\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\n\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\n\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\n\ndef ceil(x, y=1): return int(-(-x // y))\n\ndef INT(): return int(eval(input()))\n\ndef MAP(): return list(map(int, input().split()))\n\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\n\ndef Yes(): print('Yes')\n\ndef No(): print('No')\n\ndef YES(): print('YES')\n\ndef NO(): print('NO')\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = float('inf')\n\nMOD = 10 ** 9 + 7\n\n\n\ndef factorize(num: int) -> dict:\n\n    \"\"\" 素因数分解 \"\"\"\n\n    from math import sqrt\n\n    from collections import Counter\n\n\n\n    d = Counter()\n\n    # 終点はルート切り捨て+1\n\n    for i in range(2, int(sqrt(num))+1):\n\n        # 素因数分解：小さい方から割れるだけ割って素数をカウント\n\n        while num % i == 0:\n\n            num //= i\n\n            d[i] += 1\n\n        # 1まで分解したら終了\n\n        if num == 1:\n\n            break\n\n    # 最後に残ったnumは素数(ただし1^1は1^0なので数に入れない)\n\n    if num != 1:\n\n        d[num] += 1\n\n    return d\n\n\n\nclass FactInvMOD:\n\n    \"\"\" 階乗たくさん使う時用のテーブル準備 \"\"\"\n\n\n\n    def __init__(self, MAX, MOD):\n\n        \"\"\" MAX：階乗に使う数値の最大以上まで作る \"\"\"\n\n        \n\n        MAX += 1\n\n        self.MAX = MAX\n\n        self.MOD = MOD\n\n        # 階乗テーブル\n\n        factorial = [1] * MAX\n\n        factorial[0] = factorial[1] = 1\n\n        for i in range(2, MAX):\n\n            factorial[i] = factorial[i-1] * i % MOD\n\n        # 階乗の逆元テーブル\n\n        inverse = [1] * MAX\n\n        # powに第三引数入れると冪乗のmod付計算を高速にやってくれる\n\n        inverse[MAX-1] = pow(factorial[MAX-1], MOD-2, MOD)\n\n        for i in range(MAX-2, 0, -1):\n\n            # 最後から戻っていくこのループならMAX回powするより処理が速い\n\n            inverse[i] = inverse[i+1] * (i+1) % MOD\n\n        self.fact = factorial\n\n        self.inv = inverse\n\n    \n\n    def nCr(self, n, r):\n\n        \"\"\" 組み合わせの数 (必要な階乗と逆元のテーブルを事前に作っておく) \"\"\"\n\n\n\n        if n < r: return 0\n\n        # 10C7 = 10C3\n\n        r = min(r, n-r)\n\n        # 分子の計算\n\n        numerator = self.fact[n]\n\n        # 分母の計算\n\n        denominator = self.inv[r] * self.inv[n-r] % self.MOD\n\n        return numerator * denominator % self.MOD\n\n\n\n    def nPr(self, n, r):\n\n        \"\"\" 順列 \"\"\"\n\n\n\n        if n < r: return 0\n\n        return self.fact[n] * self.inv[n-r] % self.MOD\n\n\n\n    def nHr(self, n, r):\n\n        \"\"\" 重複組み合わせ \"\"\"\n\n\n\n        # r個選ぶところにN-1個の仕切りを入れる\n\n        return self.nCr(r+n-1, r)\n\n\n\nN, M = MAP()\n\n\n\nd = factorize(M)\n\n\n\n# 例外処理\n\nif not d:\n\n    print((1))\n\n    exit()\n\n\n\nMAX = N + max(d.values())\n\nfim = FactInvMOD(MAX, MOD)\n\nans = 1\n\nfor k, v in list(d.items()):\n\n    ans *= fim.nHr(N, v)\n\n    ans %= MOD\n\nprint(ans)\n", "score": 1.0, "codebleu": 0.5046519438641522, "crystalbleu": 0.3117517070708187, "codebertscore": 0.87, "codescore": 0.9859027862548828, "surfaceSim": 0.7098920744223003, "abs_surfaceSim_minus_score": 0.2901079255776997}
{"golden_code": "from functools import reduce\ndef f(a,b): return [Card[a][0], Card[b][1]]\n\nn = int(input())\n\nCard = [[] for _ in [0]*n]\n\nCost = {}\n\nfor i in range(n):\n\n  Card[i] = list(map(int, input().split()))\n\n  Cost[(i, i)] = 0\n\nfor i in range(1, n):\n\n  for j in range(0, n-i):\n\n    a = j+i\n\n    Cost[(j, a)] = min([reduce(lambda a,b: a*b, f(j, k) + f(k+1, a)) + Cost[(j, k)] + Cost[(k+1, a)] for k in range(j, j+i)])\n\nprint(Cost[0, n-1])", "generated_code": "from functools import reduce\nn = int(input())\n\nCard = [[] for _ in [0]*n]\n\nCost = {}\n\nfor i in range(n):\n\n  Card[i] = list(map(int, input().split()))\n\n  Cost[(i, i)] = 0\n\nfor i in range(1, n):\n\n  for j in range(0, n-i):\n\n    a = j+i\n\n    Cost[(j, a)] = min([reduce(lambda a,b: a*b, [Card[j][0],Card[k][1],Card[k+1][0],Card[a][1]]) + Cost[(j, k)] + Cost[(k+1, a)] for k in range(j, j+i)])\n\nprint(Cost[0, n-1])", "score": 1.0, "codebleu": 0.679325715291896, "crystalbleu": 0.8694261007044977, "codebertscore": 0.96, "codescore": 0.5771404504776001, "surfaceSim": 0.8713445378151261, "abs_surfaceSim_minus_score": 0.1286554621848739}
{"golden_code": "mod = 998244353\n\nN = int(eval(input()))\n\nX = []\n\nfor _ in range(N):\n\n    x, d = list(map(int, input().split()))\n\n    X.append((x, x + d))\n\n\n\nX = sorted(X, key = lambda x: x[0])\n\nL = [(0, -(10**9+1), 10**9+1)]\n\nP = [-1] * (N+1)\n\nfor i, (x, y) in enumerate(X):\n\n    while L[-1][2] <= y:\n\n        if L[-1][2] > x and P[i+1] < 0:\n\n            P[i+1] = L[-1][0]\n\n        L.pop()\n\n    if P[i+1] < 0:\n\n        P[i+1] = L[-1][0]\n\n    L.append((i+1, x, y))\n\n\n\nC = [[] for _ in range(N+1)]\n\nfor i, p in enumerate(P):\n\n    if p >= 0:\n\n        C[p].append(i)\n\n\n\nY = [1] * (N+1)\n\nfor i in range(N+1)[::-1]:\n\n    s = 1\n\n    for j in C[i]:\n\n        s = s * (Y[j] + 1) % mod\n\n    Y[i] = s\n\n\n\nprint((Y[0]))", "generated_code": "import sys\n\ninput = sys.stdin.readline\n\n\n\nmod = 998244353\n\nN = int(eval(input()))\n\nX = []\n\nfor _ in range(N):\n\n    x, d = list(map(int, input().split()))\n\n    X.append((x, x + d))\n\n\n\nX = sorted(X, key = lambda x: x[0])\n\nL = [(0, -(10**9+1), 10**9+1)]\n\nP = [-1] * (N+1)\n\nfor i, (x, y) in enumerate(X):\n\n    while L[-1][2] <= y:\n\n        if L[-1][2] > x and P[i+1] < 0:\n\n            P[i+1] = L[-1][0]\n\n        L.pop()\n\n    if P[i+1] < 0:\n\n        P[i+1] = L[-1][0]\n\n    L.append((i+1, x, y))\n\n\n\nC = [[] for _ in range(N+1)]\n\nfor i, p in enumerate(P):\n\n    if p >= 0:\n\n        C[p].append(i)\n\n\n\nY = [1] * (N+1)\n\nfor i in range(N+1)[::-1]:\n\n    s = 1\n\n    for j in C[i]:\n\n        s = s * (Y[j] + 1) % mod\n\n    Y[i] = s\n\n\n\nprint((Y[0]))", "score": 1.0, "codebleu": 0.8158002450969278, "crystalbleu": 0.9509235642670852, "codebertscore": 0.97, "codescore": 0.993803858757019, "surfaceSim": 0.9504191658774421, "abs_surfaceSim_minus_score": 0.04958083412255787}
{"golden_code": "array = list(map(int, input().split()))\n\nif array[0] % array[1] > 0:\n\n    print(((array[0] // array[1] + 1) * array[2]))\n\nelse:\n\n    print(((array[0] // array[1]) * array[2]))", "generated_code": "n, x, t = list(map(int, input().split()))\n\n\n\nprint((0--n//x*t))", "score": 1.0, "codebleu": 0.19387968865310362, "crystalbleu": 0.0, "codebertscore": 0.77, "codescore": 0.457679808139801, "surfaceSim": 0.47801242236024843, "abs_surfaceSim_minus_score": 0.5219875776397516}
{"golden_code": "x = int(eval(input()))\n\na = 0\n\nb = 0\n\nfor i in range(-120, 120):\n\n    for j in range(-120, 120):\n\n        if i ** 5 - j ** 5 == x:\n\n            a = i\n\n            b = j\n\nprint((a, b))\n", "generated_code": "x = int(eval(input()))\n\nfor i in range(-120, 120):\n\n    for j in range(-120, 120):\n\n        if i ** 5 - j ** 5 == x:\n\n            print((i, j))\n\n            exit()\n", "score": 1.0, "codebleu": 0.5385959265208551, "crystalbleu": 0.0, "codebertscore": 0.95, "codescore": 0.7449800372123718, "surfaceSim": 0.9320652173913043, "abs_surfaceSim_minus_score": 0.06793478260869568}
{"golden_code": "import fractions\n\nimport sys\n\ninput = sys.stdin.readline\n\n\n\nN,M=list(map(int,input().split()))\n\na = list(map(int, input().split()))\n\n\n\n\n\nlcm = a[0]\n\nfor i in range(1, N):\n\n    g= fractions.gcd(lcm, a[i])\n\n    lcm = lcm * a[i] // g\n\n\n\n\n\ng=a[0]\n\nfor i in range(N):\n\n    g=fractions.gcd(g,a[i])\n\n\n\nfor i in range(N):\n\n    if (a[i]//g)%2==0:\n\n        lcm=0\n\n        break    \n\n    \n\n    \n\nans=0\n\nl=lcm//2\n\nif l:\n\n    ans=(M//l)-(M//(l+l))\n\nprint(ans)\n\n\n", "generated_code": "import sys\n\ninput = sys.stdin.readline\n\n\n\ndef I(): return int(eval(input()))\n\ndef MI(): return list(map(int, input().split()))\n\ndef LI(): return list(map(int, input().split()))\n\n\n\n\"\"\"\n\n2X = ak * (2p+1)\n\n基本的には最小公倍数/2を基本とし，これの奇数倍か．\n\n\n\nX  = (ak//2) * (2p+1)\n\nと書ける．第二項が奇数なので，各akが2で割り切れれう回数が同じでなければならない\n\na=[2,4]だと無理\n\n\"\"\"\n\ndef main():\n\n    from math import gcd\n\n    N,M=MI()\n\n    A=LI()\n\n    \n\n    def count(X):\n\n        cnt=0\n\n        while X%2==0:\n\n            cnt+=1\n\n            X=X//2\n\n        return cnt\n\n    \n\n    C=count(A[0])\n\n    for i in range(1,N):\n\n        if count(A[i])!=C:\n\n            print((0))\n\n            exit()\n\n            \n\n    lca=1\n\n    for i in range(N):\n\n        g=gcd(lca,A[i])\n\n        lca=(lca*A[i])//g\n\n        \n\n    lca2=lca//2\n\n    ans=M//lca2 - M//lca\n\n    \n\n    print(ans)\n\n    \n\n            \n\n    \n\n\n\nmain()\n", "score": 1.0, "codebleu": 0.30823003077411093, "crystalbleu": 0.3059824573411566, "codebertscore": 0.78, "codescore": 0.9903169870376587, "surfaceSim": 0.6365803445660418, "abs_surfaceSim_minus_score": 0.36341965543395816}
{"golden_code": "while True:\n\n\tk=list(map(int,input().split(\" \")))\n\n\tif k[0]==k[1]==0:\n\n\t\tbreak\n\n\tct=0\n\n\ta=0\n\n\tb=0\n\n\tc=0\t\n\n\tmax=k[0]\n\n\tsum=k[1]\n\n\ta=max+1\n\n\t\n\n\twhile True:\n\n\t\ta-=1\n\n\t\tb=a-1\n\n\t\tc=sum-a-b\n\n\t\tif not a>b>c:\n\n\t\t\tprint(ct)\n\n\t\t\tbreak\n\n\t\twhile a>b>c:\n\n\t\t\tif a>b>c>0:\n\n\t\t\t\tct+=1\n\n\t\t\tb-=1\n\n\t\t\tc+=1\n\n\t\t\t", "generated_code": "while True:\n\n\tk=list(map(int,input().split(\" \")))\n\n\tif k[0]==k[1]==0:\n\n\t\tbreak\n\n\tct=0\n\n\ta=0\n\n\tb=0\n\n\tc=0\t\n\n\tmax=k[0]\n\n\tsum=k[1]\n\n\ta=max+1\n\n\twhile True:\n\n\t\ta-=1\n\n\t\tb=a-1\n\n\t\tc=sum-a-b\n\n\t\tif not a>c:\n\n\t\t\tprint(ct)\n\n\t\t\tbreak\n\n\t\twhile b>c:\n\n\t\t\tif c>0:\n\n\t\t\t\tct+=1\n\n\t\t\tb-=1\n\n\t\t\tc+=1", "score": 1.0, "codebleu": 0.8312476060884036, "crystalbleu": 0.8992320479980412, "codebertscore": 0.99, "codescore": 0.9938430786132812, "surfaceSim": 0.9862068965517241, "abs_surfaceSim_minus_score": 0.01379310344827589}
{"golden_code": "from functools import lru_cache\n\nimport sys\n\n\n\nsys.setrecursionlimit(2000)\n\n\n\ns = int(eval(input()))\n\nmod = 10 ** 9 + 7\n\n\n\n\n\n@lru_cache(maxsize=None)\n\ndef dfs(n):\n\n    if n <= 2:\n\n        return 0\n\n    elif 3<=n<=5:\n\n        return 1\n\n    else:\n\n        count = 1\n\n        for i in range(3, n + 1):\n\n            count += dfs(n - i)\n\n            count %= mod\n\n\n\n        return count % mod\n\n\n\n\n\nans = dfs(s)\n\nprint(ans)\n", "generated_code": "s = int(eval(input()))\n\nmod = 10 ** 9 + 7\n\n\n\ndp = [0] * (s + 1)\n\ndp[0] = 1\n\n\n\nx = 0\n\nfor i in range(3, s + 1):\n\n    x += dp[i - 3]\n\n    dp[i] = x % mod\n\n\n\nans = dp[s] % mod\n\nprint(ans)\n", "score": 1.0, "codebleu": 0.31628887685435947, "crystalbleu": 0.0, "codebertscore": 0.79, "codescore": 0.6493033170700073, "surfaceSim": 0.5230359623398673, "abs_surfaceSim_minus_score": 0.47696403766013273}
{"golden_code": "def main():\n\n    from sys import stdin\n\n    input = stdin.readline\n\n\n\n    n, m, r = list(map(int, input().split()))\n\n    l = list(map(int, input().split()))\n\n    for i in range(r):\n\n        l[i] -= 1\n\n    d = [[10**8] * n for _ in range(n)]\n\n    for _ in range(m):\n\n        i, j, k = list(map(int, input().split()))\n\n        d[i-1][j-1] = k\n\n        d[j-1][i-1] = k\n\n\n\n    # Warshall-Floyd algorithm\n\n    for k in range(n):\n\n        for i in range(n):\n\n            for j in range(n):\n\n                if d[i][j] > d[i][k] + d[k][j]:\n\n                    d[i][j] = d[i][k] + d[k][j]\n\n\n\n    # full search\n\n    # 8! = 40320\n\n    from itertools import permutations\n\n\n\n    answer = 10**8\n\n    for i in permutations(l):\n\n        ans = 0\n\n        for j in range(r-1):\n\n            ans += d[i[j]][i[j+1]]\n\n        if ans < answer:\n\n            answer = ans\n\n\n\n    print(answer)\n\n\n\nmain()\n", "generated_code": "def main():\n\n    from sys import stdin\n\n    input = stdin.readline\n\n\n\n    n, m, r = list(map(int, input().split()))\n\n    l = list(map(int, input().split()))\n\n    for i in range(r):\n\n        l[i] -= 1\n\n    d = [[10**8] * n for _ in range(n)]\n\n    for _ in range(m):\n\n        i, j, k = list(map(int, input().split()))\n\n        d[i-1][j-1] = k\n\n        d[j-1][i-1] = k\n\n\n\n    # Warshall-Floyd algorithm\n\n    for k in range(n):\n\n        for i in range(n-1):\n\n            for j in range(i+1, n):\n\n                if d[i][j] > d[i][k] + d[k][j]:\n\n                    d[i][j] = d[i][k] + d[k][j]\n\n                    d[j][i] = d[i][j]\n\n\n\n    # full search\n\n    # 8! = 40320\n\n    from itertools import permutations\n\n\n\n    answer = 10**8\n\n    for i in permutations(l):\n\n        ans = 0\n\n        for j in range(r-1):\n\n            ans += d[i[j]][i[j+1]]\n\n        if ans < answer:\n\n            answer = ans\n\n\n\n    print(answer)\n\n\n\nmain()\n", "score": 1.0, "codebleu": 0.9392403984551615, "crystalbleu": 0.9462108123469927, "codebertscore": 0.97, "codescore": 0.9938241243362427, "surfaceSim": 0.9881209503239741, "abs_surfaceSim_minus_score": 0.011879049676025932}
{"golden_code": "import sys\n\n\n\nmod = 10 ** 9 + 7\n\nn, m, *a = [int(x) for x in sys.stdin.read().split()]\n\n\n\nsafe = sorted(set(range(1,n+1)) - set(a))\n\ndp = [0] * (n + 2)\n\ndp[0] = 0\n\ndp[1] = 1\n\nfor i in safe:\n\n    dp[i+1] = (dp[i] + dp[i-1]) % mod\n\n\n\nprint((dp[-1]))", "generated_code": "\n\n# 2019-11-14 10:01:24(JST)\n\nimport sys\n\n# import collections\n\n# import math\n\n# from string import ascii_lowercase, ascii_uppercase, digits\n\n# from bisect import bisect_left as bi_l, bisect_right as bi_r\n\n# import itertools\n\n# from functools import reduce\n\n# import operator as op\n\n# from scipy.misc import comb # float\n\n# import numpy as np \n\n\n\nmod = 10 ** 9 + 7\n\ndef main():\n\n    n, m, *a = [int(x) for x in sys.stdin.read().split()]\n\n\n\n    safe = sorted(set(range(1,n+1)) - set(a))\n\n    dp = [0] * (n + 2) # dp[i+1]: i段目までいくパターン数\n\n    dp[0] = 0  # -1段目にはいけない\n\n    dp[1] = 1  # 初期条件(0段目にいる)\n\n    for i in safe:\n\n        dp[i+1] = (dp[i] + dp[i-1]) % mod\n\n\n\n    print((dp[-1]))\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "score": 1.0, "codebleu": 0.6369614022678239, "crystalbleu": 0.7641242931522141, "codebertscore": 0.77, "codescore": 0.19784261286258698, "surfaceSim": 0.8927891274238227, "abs_surfaceSim_minus_score": 0.10721087257617734}
{"golden_code": "import sys\n\ninput = sys.stdin.readline\n\nsys.setrecursionlimit(10**7)\n\nINF = 10**10\n\nMOD = 10**9 + 7\n\nX = int(eval(input()))\n\nfor i in range(1000):\n\n    for j in range(-1000,1000):\n\n        #print (i**5 - j**5)\n\n        if i**5 - j**5 == X:\n\n            print((i,j))\n\n            exit()\n\n   ", "generated_code": "import sys\n\ninput = sys.stdin.readline\n\nsys.setrecursionlimit(10**7)\n\nINF = 10**10\n\nMOD = 10**9 + 7\n\nX = int(eval(input()))\n\nMAX_X = 10**9\n\nn = 0\n\nwhile(1):\n\n    n+=1\n\n    if n**5 - (n-1)**5 > MAX_X:\n\n        break\n\nfor i in range(n):\n\n    for j in range(-n+1,n-1):\n\n        if i**5 - j**5 == X:\n\n            print((i,j))\n\n            exit()\n\n   ", "score": 1.0, "codebleu": 0.6920880411136854, "crystalbleu": 0.5821554665807663, "codebertscore": 0.92, "codescore": 0.8389007449150085, "surfaceSim": 0.8190306803023566, "abs_surfaceSim_minus_score": 0.1809693196976434}
{"golden_code": "n,t=int(input()),list(map(int,input().split()));T=sum(t)\n\nprint(*[T-t[i-1]+j for i,j in [list(map(int,input().split())) for _ in range(int(input()))]],sep='\\n')\n", "generated_code": "input();t=list(map(int,input().split()));T=sum(t)\n\nprint(*[T-t[i-1]+j for i,j in [list(map(int,input().split())) for _ in range(int(input()))]],sep='\\n')\n", "score": 1.0, "codebleu": 0.7952267100596858, "crystalbleu": 0.8631532256580251, "codebertscore": 0.97, "codescore": 0.9937450289726257, "surfaceSim": 0.9658385093167702, "abs_surfaceSim_minus_score": 0.03416149068322982}
{"golden_code": "def main():\n\n    N = int(input())\n\n    A = [int(i) for i in input().split()]\n\n    if N == 1:\n\n        return print(1 if A[0] % 2 == 0 else 2)\n\n    ans = 0\n\n    d = (-1, 0, 1)\n\n    from itertools import product\n\n    for i in product(range(3), repeat=N):\n\n        cur = 1\n\n        for j in range(N):\n\n            cur *= (A[j] + d[i[j]])\n\n        if cur % 2 == 0:\n\n            ans += 1\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "generated_code": "def main():\n\n    N = int(eval(input()))\n\n    A = [int(i) for i in input().split()]\n\n    ans = 3**N\n\n    cnt = len([a for a in A if a % 2 == 0])\n\n    ans -= 2**cnt\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 1.0, "codebleu": 0.27604189956635083, "crystalbleu": 0.24057904577337144, "codebertscore": 0.82, "codescore": 0.018437568098306656, "surfaceSim": 0.5988248572566724, "abs_surfaceSim_minus_score": 0.40117514274332755}
{"golden_code": "n,m = list(map(int, input().split()))\n\na = [-1] + [int(eval(input())) for _ in range(m)] + [n + 1]\n\nMOD = 10 ** 9 + 7\n\n\n\nfib = [0, 1]\n\nfor i in range(100100):\n\n\tfib.append((fib[i] + fib[i + 1] % MOD))\n\n\n\nres = 1\n\nfor i in range(m + 1):\n\n\tp, q = a[i], a[i + 1]\n\n\tres = (res * fib[q - p - 1]) % MOD\n\n\n\nprint(res)", "generated_code": "n,m = list(map(int, input().split()))\n\na = [int(eval(input())) for _ in range(m)]\n\nMOD = 10 ** 9 + 7\n\n\n\n# broken[i] : i段目が壊れていたらTrue\n\nbroken = [False] * 100100\n\nfor i in a:\n\n\tbroken[i] = True\n\n\n\n# dp[i] : i段目に行く通り数\n\ndp = [0] * 100100\n\n\n\n# 0段目に行く方法は1通り\n\ndp[0] = 1\n\n\n\n# 1段目からn段目について調べる\n\nfor i in range(1, n + 1):\n\n\t# 壊れてるなら\n\n\tif broken[i]:\n\n\t\t# その段には進めないので0通り\n\n\t\tdp[i] = 0\n\n\t# 壊れてないなら\n\n\telse:\n\n\t\t# i - 1段目から移動可能 (i - 1段目は, i == 0 のときにはないので分岐)\n\n\t\tif i > 0:\n\n\t\t\tdp[i] += dp[i - 1]\n\n\t\t# i - 2段目から移動可能 (i - 2段目は, i == 0, 1 のときにはないので分岐)\n\n\t\tif i > 1:\n\n\t\t\tdp[i] += dp[i - 2]\n\n\tdp[i] %= MOD\n\n\n\nprint((dp[n]))", "score": 1.0, "codebleu": 0.31157394301121977, "crystalbleu": 0.3835456984219118, "codebertscore": 0.73, "codescore": 0.11864425241947174, "surfaceSim": 0.7732919254658386, "abs_surfaceSim_minus_score": 0.22670807453416142}
{"golden_code": "import sys\n\ns = input()\n\nts = ['']\n\nwhile True:\n\n  nts= []\n\n  for t in ts:\n\n    for w in ['dreamer', 'eraser', 'dream', 'erase']:\n\n      if s == t + w:\n\n        print('YES')\n\n        sys.exit()\n\n      if s.startswith(t + w):\n\n        nts.append(t + w)\n\n  if len(nts) == 0:\n\n    print('NO')\n\n    sys.exit()\n\n  ts = nts\n", "generated_code": "from sys import exit\n\ns = eval(input())\n\nts = ['']\n\nwhile True:\n\n  nts= []\n\n  for t in ts:\n\n    for w in ['dreamer', 'eraser', 'dream', 'erase']:\n\n      tw = t + w\n\n      if s == tw:\n\n        print('YES')\n\n        exit()\n\n      if s.startswith(tw):\n\n        nts.append(tw)\n\n  if len(nts) == 0:\n\n    print('NO')\n\n    exit()\n\n  ts = nts\n", "score": 1.0, "codebleu": 0.5413355107243876, "crystalbleu": 0.7112491134269354, "codebertscore": 0.96, "codescore": 0.993727445602417, "surfaceSim": 0.8977611940298508, "abs_surfaceSim_minus_score": 0.10223880597014923}
{"golden_code": "a=65280; b=61680; c=52428; d=43690; e=65535\n\nfrom heapq import heappush, heappop\n\nbase = [a, b, c, d, e, 0]\n\nQ = [(1, el) for el in base]\n\nL = {el: 1 for el in base}\n\nH = []\n\nget = L.get\n\npush = H.append\n\nwhile Q:\n\n    l, p = heappop(Q)\n\n    if L[p] < l: continue\n\n    if l+1 < get(p ^ e, 17):\n\n        L[p ^ e] = l+1\n\n        if l+1 < 16: heappush(Q, (l+1, p ^ e))\n\n    if l+3 < 16:\n\n        for q, r in H:\n\n            if l+r+3 <= 16:\n\n                if l+r+3 < get(p & q, 17):\n\n                    L[p & q] = l+r+3\n\n                    if l+r+3 < 16: heappush(Q, (l+r+3, p & q))\n\n                if l+r+3 < get(p ^ q, 17):\n\n                    L[p ^ q] = l+r+3\n\n                    if l+r+3 < 16: heappush(Q, (l+r+3, p ^ q))\n\n            else: break\n\n    if l < 7: push((p, l))\n\nprint(*map(L.__getitem__, eval(\"e&%s\"%\",e&\".join(open(0).read().replace(*\"-~\").replace(*\"*&\").replace(*\"1e\").split()[:-1]))),sep='\\n')\n", "generated_code": "a=65280; b=61680; c=52428; d=43690; e=65535\n\nfrom heapq import heappush, heappop\n\nQ = [(1, a), (1, b), (1, c), (1, d)]\n\nL = {a: 1, b: 1, c: 1, d: 1, e: 1, e: 1, 0: 1}\n\nH = []\n\nget = L.get\n\npush = H.append\n\nwhile Q:\n\n    l, p = heappop(Q)\n\n    if L[p] < l: continue\n\n    if l+1 < get(p ^ e, 17):\n\n        L[p ^ e] = l+1\n\n        l < 15 and heappush(Q, (l+1, p ^ e))\n\n    if l < 13:\n\n        li = 13-l; l3 = 3+l\n\n        for q, r in H:\n\n            if r <= li:\n\n                k = p & q\n\n                if r < get(k, 17)-l3:\n\n                    L[k] = l3+r\n\n                    r < li and heappush(Q, (l3+r, k))\n\n                k = p ^ q\n\n                if r < get(k, 17)-l3:\n\n                    L[k] = l3+r\n\n                    r < li and heappush(Q, (l3+r, k))\n\n            else: break\n\n    if l < 7: push((p, l))\n\nprint(*map(L.__getitem__, eval(\"e&\"+\",e&\".join(open(0).read().replace(*\"-~\").replace(*\"*&\").replace(*\"1e\").split()[:-1]))),sep='\\n')\n", "score": 1.0, "codebleu": 0.49245777482610675, "crystalbleu": 0.6158531327827182, "codebertscore": 0.93, "codescore": 0.95299232006073, "surfaceSim": 0.8171907756813417, "abs_surfaceSim_minus_score": 0.18280922431865831}
{"golden_code": "_,t=open(0);n=eval(t.replace(' ','|'));print((len(bin(n&-n))-3))", "generated_code": "n=eval([*open(0)][1].replace(*' |'))\n\nprint((len(bin(n&-n))-3))", "score": 1.0, "codebleu": 0.21794871794871795, "crystalbleu": 0.0, "codebertscore": 0.91, "codescore": 0.9644826650619507, "surfaceSim": 0.688733552631579, "abs_surfaceSim_minus_score": 0.311266447368421}
{"golden_code": "n, m, k = list(map(int, input().split()))\n\nmod = 10 ** 9 + 7\n\nMAX = n * m\n\n\n\n\n\nclass ModInt:\n\n    def __init__(self, num):\n\n        self.num = num\n\n\n\n    def __str__(self):\n\n        return str(self.num)\n\n\n\n    def __repr__(self):\n\n        return \"ModInt(num: {}, mod: {}\".format(self.num, mod)\n\n\n\n    def __add__(self, other):\n\n        ret = self.num + other.num\n\n        ret %= mod\n\n        return ModInt(ret)\n\n\n\n    def __sub__(self, other):\n\n        ret = self.num - other.num\n\n        ret %= mod\n\n        return ModInt(ret)\n\n\n\n    def __mul__(self, other):\n\n        ret = self.num * other.num\n\n        ret %= mod\n\n        return ModInt(ret)\n\n\n\n    def pow(self, times):\n\n        pw = pow(self.num, times, mod)\n\n        return ModInt(pw)\n\n\n\n    def inverse(self):\n\n        return ModInt(inv[self.num])\n\n\n\n    def __truediv__(self, other):\n\n        num = self * other.inverse()\n\n        return ModInt(num)\n\n\n\n\n\ndef comb(n, k):\n\n    return fact[n] * inv[n-k] * inv[k]\n\n\n\n\n\nfact = [None] * (MAX + 1)\n\nfact[0] = ModInt(1)\n\nfor i in range(1, MAX + 1):\n\n    fact[i] = fact[i-1] * ModInt(i)\n\n\n\ninv = [None] * (MAX + 1)\n\ninv[MAX] = fact[MAX].pow(mod - 2)\n\nfor i in range(MAX, 0, -1):\n\n    inv[i-1] = inv[i] * ModInt(i)\n\n\n\nans = ModInt(0)\n\nfor i in range(n):\n\n    for j in range(m):\n\n        add = ModInt(n - i) * ModInt(m - j) * ModInt(i + j)\n\n        if i != 0 and j != 0:\n\n            add *= ModInt(2)\n\n\n\n        ans += add\n\n\n\nans *= comb(n * m - 2, k - 2)\n\nprint(ans)\n", "generated_code": "n, m, k = list(map(int, input().split()))\n\n\n\nmod = 10 ** 9 + 7\n\nMAX = n * m\n\n\n\nfact = [1] * (MAX + 1)\n\nfor i in range(1, MAX + 1):\n\n    fact[i] = (fact[i-1] * i) % mod\n\n\n\ninv = [1] * (MAX + 1)\n\ninv[MAX] = pow(fact[MAX], mod - 2, mod)\n\nfor i in range(MAX, 0, -1):\n\n    inv[i-1] = (inv[i] * i) % mod\n\n\n\n\n\ndef comb(n, k):\n\n    return fact[n] * inv[n-k] * inv[k] % mod\n\n\n\n\n\nans = 0\n\nfor i in range(n):\n\n    for j in range(m):\n\n        add = (n - i) * (m - j) * (i + j) % mod\n\n        if i != 0 and j != 0:\n\n            add *= 2\n\n            add %= mod\n\n\n\n        ans += add\n\n        ans %= mod\n\n\n\nans *= comb(MAX - 2, k - 2)\n\nans %= mod\n\nprint(ans)\n", "score": 1.0, "codebleu": 0.3652632021103104, "crystalbleu": 0.34865638333561366, "codebertscore": 0.85, "codescore": 0.3900928795337677, "surfaceSim": 0.7338252924883211, "abs_surfaceSim_minus_score": 0.26617470751167893}
{"golden_code": "import math\n\nn = int(eval(input()))\n\na = list(map(int, input().split()))\n\n\n\n\n\ndef trial_division(n):\n\n    factor = []\n\n    tmp = int(math.sqrt(n)) + 1\n\n    for _ in range(2,tmp):\n\n        while n % 2 == 0:\n\n            n //= 2\n\n            factor.append(2)\n\n    if not factor:\n\n        return [n]\n\n    else:\n\n        factor.append(n)\n\n        return factor\n\n\n\n\n\ncount = 0\n\nfor i in a:\n\n    temp = trial_division(i)\n\n    count += temp.count(2)\n\n\n\nprint(count)", "generated_code": "n = int(eval(input()))\n\na = list(map(int, input().split()))\n\n\n\n\n\ndef trial_division(n):\n\n    #２で割った因数を格納するリスト\n\n    factor = []\n\n    #2で割れなくなった時点でストップ\n\n    while n % 2 == 0:\n\n        n //= 2    # ２で割った商を切り捨てて代入\n\n        factor.append(2)\n\n    #nが一度も２で割れなかったらそのまま返す\n\n    if not factor:\n\n        return [n]\n\n    else:\n\n        factor.append(n)\n\n        return factor\n\n\n\n\n\ncount = 0\n\nfor i in a:\n\n    temp = trial_division(i)\n\n    count += temp.count(2)\n\n\n\nprint(count)", "score": 1.0, "codebleu": 0.6147493320061137, "crystalbleu": 0.7670102272028909, "codebertscore": 0.81, "codescore": 0.7969979047775269, "surfaceSim": 0.9050184729064039, "abs_surfaceSim_minus_score": 0.09498152709359609}
{"golden_code": "import sys\n\ndef main():\n\n    input = sys.stdin.readline\n\n    N = int(eval(input()))\n\n    E = [[] for _ in range(N)]\n\n    for i in range(N-1):\n\n        a, b = list(map(int, input().split()))\n\n        a, b = a-1, b-1\n\n        E[a].append((b,i))\n\n        E[b].append((a,i))\n\n    \n\n    def dfs(s, g):\n\n        par = [(-1,-1)] * N\n\n        par[s] = (s,-1)\n\n        stack = [s]\n\n        while stack:\n\n            v = stack.pop()\n\n            for to, i in E[v]:\n\n                if par[to][0] >= 0: continue\n\n                par[to] = (v, i)\n\n                if to == g: break\n\n                stack.append(to)\n\n        r = set()\n\n        v = g\n\n        while v != s:\n\n            v, i = par[v]\n\n            r.add(i)\n\n        return r\n\n    \n\n    M = int(eval(input()))\n\n    path = [None] * M\n\n    for i in range(M):\n\n        u, v = list(map(int, input().split()))\n\n        u, v = u-1, v-1\n\n        path[i] = dfs(u, v)\n\n\n\n    def calc(s): return 1<<(N-1-len(s))\n\n\n\n    i_ans = 0\n\n    for p in range(1, 1<<M):\n\n        is_odd = bin(p).count('1') & 1\n\n        s = set()\n\n        for i in range(M):\n\n            if p&1: s |= path[i]\n\n            p >>= 1\n\n        if is_odd: i_ans += calc(s)\n\n        else: i_ans -= calc(s)\n\n\n\n    print(((1<<(N-1)) - i_ans))\n\n\n\nif __name__ == '__main__':\n\n    main()", "generated_code": "import sys\n\ndef main():\n\n    input = sys.stdin.readline\n\n    N = int(eval(input()))\n\n    E = [[] for _ in range(N)]\n\n    for i in range(N-1):\n\n        a, b = list(map(int, input().split()))\n\n        a, b = a-1, b-1\n\n        E[a].append((b,i))\n\n        E[b].append((a,i))\n\n    \n\n    def dfs(s, g):\n\n        par = [(-1,-1)] * N\n\n        par[s] = (s,-1)\n\n        stack = [s]\n\n        while stack:\n\n            v = stack.pop()\n\n            for to, i in E[v]:\n\n                if par[to][0] >= 0: continue\n\n                par[to] = (v, i)\n\n                if to == g: break\n\n                stack.append(to)\n\n        r = set()\n\n        v = g\n\n        while v != s:\n\n            v, i = par[v]\n\n            r.add(i)\n\n        return r\n\n    \n\n    M = int(eval(input()))\n\n    path = [None] * M\n\n    for i in range(M):\n\n        u, v = list(map(int, input().split()))\n\n        u, v = u-1, v-1\n\n        path[i] = dfs(u, v)\n\n\n\n    def calc(s): return 1<<(N-1-len(s))\n\n\n\n    i_ans = 0\n\n    for p in range(1, 1<<M):\n\n        is_odd = 0\n\n        s = set()\n\n        for i in range(M):\n\n            if p&1:\n\n                s |= path[i]\n\n                is_odd ^= 1\n\n            p >>= 1\n\n        if is_odd: i_ans += calc(s)\n\n        else: i_ans -= calc(s)\n\n\n\n    print(((1<<(N-1)) - i_ans))\n\n\n\nif __name__ == '__main__':\n\n    main()", "score": 1.0, "codebleu": 0.9551757881981311, "crystalbleu": 0.9531004729642536, "codebertscore": 0.99, "codescore": 0.9922186136245728, "surfaceSim": 0.9766797129810829, "abs_surfaceSim_minus_score": 0.023320287018917085}
{"golden_code": "import math\n\nN = int(eval(input()))\n\np = math.factorial(N)\n\nprint((p % 1000000007))", "generated_code": "N = int(eval(input()))\n\np = 1\n\nfor i in range(1,N+1):\n\n    p *= i\n\n    p %= 1000000007\n\nprint(p)\n", "score": 1.0, "codebleu": 0.35373732956578885, "crystalbleu": 0.0, "codebertscore": 0.83, "codescore": 0.5675813555717468, "surfaceSim": 0.5621588841722256, "abs_surfaceSim_minus_score": 0.4378411158277744}
{"golden_code": "def slove():\n\n    import sys\n\n    import heapq\n\n    import collections\n\n    input = sys.stdin.readline\n\n    x, y, z, k = list(map(int, input().rstrip('\\n').split()))\n\n    a = list(map(int, input().rstrip('\\n').split()))\n\n    a.sort(reverse=True)\n\n    b = list(map(int, input().rstrip('\\n').split()))\n\n    b.sort(reverse=True)\n\n    c = list(map(int, input().rstrip('\\n').split()))\n\n    c.sort(reverse=True)\n\n    q = [[-(a[0] + b[0] + c[0]), 0, 0, 0]]\n\n    heapq.heapify(q)\n\n    fq = collections.defaultdict(list)\n\n    fq[(-(a[0] + b[0] + c[0]), 0, 0, 0), 1] = 1\n\n    t = 0\n\n    for _ in range(k):\n\n        if len(q) != 0:\n\n            p = heapq.heappop(q)\n\n            t = p[0]\n\n            aq = p[1]\n\n            bq = p[2]\n\n            cq = p[3]\n\n            if aq + 1 < len(a):\n\n                if (-(a[aq+1] + b[bq] + c[cq]), aq+1, bq, cq) not in fq:\n\n                    heapq.heappush(q, [-(a[aq+1] + b[bq] + c[cq]), aq+1, bq, cq])\n\n                    fq[(-(a[aq+1] + b[bq] + c[cq]), aq+1, bq, cq)] = 1\n\n            if bq + 1 < len(b):\n\n                if (-(a[aq] + b[bq+1] + c[cq]), aq, bq+1, cq) not in fq:\n\n                    heapq.heappush(q, [-(a[aq] + b[bq+1] + c[cq]), aq, bq+1, cq])\n\n                    fq[(-(a[aq] + b[bq+1] + c[cq]), aq, bq+1, cq)] = 1\n\n            if cq + 1 < len(c):\n\n                if (-(a[aq] + b[bq] + c[cq+1]), aq, bq, cq+1) not in fq:\n\n                    heapq.heappush(q, [-(a[aq] + b[bq] + c[cq+1]), aq, bq, cq+1])\n\n                    fq[(-(a[aq] + b[bq] + c[cq+1]), aq, bq, cq+1)] = 1\n\n        print((-t))\n\n\n\n\n\nif __name__ == '__main__':\n\n    slove()\n", "generated_code": "import sys\n\nimport collections\n\nimport heapq\n\n\n\n\n\ndef solve():\n\n    input = sys.stdin.readline\n\n    mod = 10 ** 9 + 7\n\n    x, y, z, k = list(map(int, input().rstrip('\\n').split()))\n\n    a = list(map(int, input().rstrip('\\n').split()))\n\n    b = list(map(int, input().rstrip('\\n').split()))\n\n    c = list(map(int, input().rstrip('\\n').split()))\n\n    a.sort(reverse=True)\n\n    b.sort(reverse=True)\n\n    c.sort(reverse=True)\n\n    ql = [[-(a[0] + b[0] + c[0]), 0, 0, 0]]\n\n    heapq.heapify(ql)\n\n    fq = collections.defaultdict(int)\n\n    fq[0, 0, 0]\n\n    for i in range(k):\n\n        s, ap, bp, cp = heapq.heappop(ql)\n\n        for app, bpp, cpp in ([[ap+1, bp, cp], [ap, bp+1, cp], [ap, bp, cp+1]]):\n\n            if app < x and bpp < y and cpp < z:\n\n                if (app, bpp, cpp) not in fq:\n\n                    heapq.heappush(ql, [-(a[app] + b[bpp] + c[cpp]), app, bpp, cpp])\n\n                    fq[app, bpp, cpp]\n\n        print((-s))\n\n\n\n\n\nif __name__ == '__main__':\n\n    solve()\n", "score": 1.0, "codebleu": 0.2965451130133358, "crystalbleu": 0.2567996835970909, "codebertscore": 0.88, "codescore": 0.2619623839855194, "surfaceSim": 0.761968085106383, "abs_surfaceSim_minus_score": 0.23803191489361697}
{"golden_code": "import sys\n\ninput = sys.stdin.readline\n\nimport bisect\n\n\n\nn = int(eval(input()))\n\nX = list(map(int, input().split()))\n\nl = int(eval(input()))\n\nU = 17\n\ndp = [[0]*n for _ in range(U+1)]\n\nfor i, x in enumerate(X):\n\n  t = bisect.bisect_left(X, x+l)\n\n  dp[0][i] = bisect.bisect_right(X, x+l) - 1\n\nfor k in range(U):\n\n  for i in range(n):\n\n    dp[k+1][i] = dp[k][dp[k][i]]\n\ndef test(x, a, b):\n\n  for i in range(U, -1, -1):\n\n    if x >> i & 1:\n\n      a = dp[i][a]\n\n  return a >= b\n\ndef solve(a, b):\n\n  if a > b:\n\n    a, b = b, a\n\n  ng = 0\n\n  ok = n-1\n\n  while ok - ng > 1:\n\n    mid = (ng + ok) // 2\n\n    if test(mid, a, b):\n\n      ok = mid\n\n    else:\n\n      ng = mid\n\n  print(ok)\n\nq = int(eval(input()))\n\nfor _ in range(q):\n\n  a, b = list(map(int, input().split()))\n\n  a -= 1\n\n  b -= 1\n\n  solve(a, b)", "generated_code": "import sys\n\ninput = sys.stdin.readline\n\nimport bisect\n\n\n\nn = int(eval(input()))\n\nX = list(map(int, input().split()))\n\nl = int(eval(input()))\n\nU = 17\n\ndp = [[0]*n for _ in range(U+1)]\n\nfor i, x in enumerate(X):\n\n  t = bisect.bisect_left(X, x+l)\n\n  dp[0][i] = bisect.bisect_right(X, x+l) - 1\n\nfor k in range(U):\n\n  for i in range(n):\n\n    dp[k+1][i] = dp[k][dp[k][i]]\n\nq = int(eval(input()))\n\nfor _ in range(q):\n\n  a, b = list(map(int, input().split()))\n\n  a -= 1\n\n  b -= 1\n\n  if a > b:\n\n    a, b = b, a\n\n  res = 1\n\n  for k in range(U, -1, -1):\n\n    if dp[k][a] < b:\n\n      a = dp[k][a]\n\n      res += (1<<k)\n\n    if a == b:\n\n      break\n\n  print(res)", "score": 1.0, "codebleu": 0.6735125094366047, "crystalbleu": 0.6764515858037599, "codebertscore": 0.93, "codescore": 0.32685577869415283, "surfaceSim": 0.7076250307957626, "abs_surfaceSim_minus_score": 0.29237496920423744}
{"golden_code": "import sys\n\nN,M=list(map(int,input().split()))\n\nS=set(map(int,sys.stdin))\n\n\n\na,b=0,1\n\nfor i in range(1,N+1):\n\n    if i in S:\n\n        a,b=b,0\n\n    else:\n\n        a,b=b,a+b\n\n\n\nprint((b%(10**9+7)))\n", "generated_code": "import sys\n\n\n\nN,M=list(map(int,input().split()))\n\nbad=set(map(int,sys.stdin))\n\nMOD=10**9+7\n\n\n\na,b=0,1\n\nfor i in range(1,N+1):\n\n    if i in bad:\n\n        a,b=b,0\n\n        if a==0:\n\n            break\n\n    else:\n\n        a,b=b,(a+b)%MOD\n\n\n\nprint(b)\n", "score": 1.0, "codebleu": 0.5545469970481618, "crystalbleu": 0.6257478859124244, "codebertscore": 0.95, "codescore": 0.7721918225288391, "surfaceSim": 0.8529194382852919, "abs_surfaceSim_minus_score": 0.14708056171470807}
{"golden_code": "n = int(eval(input())) % 1000\n\nif n == 0:\n\n    print((0))\n\nelse:\n\n    print((1000 - n))", "generated_code": "n = int(eval(input()))\n\nprint(((1000 - n % 1000) % 1000))", "score": 1.0, "codebleu": 0.21019676769457696, "crystalbleu": 0.0, "codebertscore": 0.9, "codescore": 0.7946192026138306, "surfaceSim": 0.7089490968801313, "abs_surfaceSim_minus_score": 0.2910509031198687}
{"golden_code": "import sys\n\ninput = sys.stdin.readline\n\nsys.setrecursionlimit(1000000)\n\nfrom collections import deque\n\ndef getN():\n\n    return int(eval(input()))\n\ndef getList():\n\n    return list(map(int, input().split()))\n\nimport math\n\n\n\nn = getN()\n\nnums = getList()\n\n\n\n# nums.sort(reverse=True)\n\nmx = max(nums)\n\nmn = (mx+1) // 2\n\nmndx = (mx % 2) + 1\n\n\n\nfrom collections import Counter\n\n\n\ncnt = Counter(nums)\n\n\n\nfor i in range(mn+1, mx+1):\n\n    if cnt[i] < 2:\n\n        print(\"Impossible\")\n\n        sys.exit()\n\n\n\nif cnt[mn] != mndx:\n\n    print(\"Impossible\")\n\nelse:\n\n    print(\"Possible\")", "generated_code": "import sys\n\nimport math\n\nimport copy\n\nfrom heapq import heappush, heappop, heapify\n\nfrom functools import cmp_to_key\n\nfrom bisect import bisect_left, bisect_right\n\nfrom collections import defaultdict, deque, Counter\n\n# sys.setrecursionlimit(1000000)\n\n\n\n# input aliases\n\ninput = sys.stdin.readline\n\ngetS = lambda: input().strip()\n\ngetN = lambda: int(eval(input()))\n\ngetList = lambda: list(map(int, input().split()))\n\ngetZList = lambda: [int(x) - 1 for x in input().split()]\n\n\n\nINF = float(\"inf\")\n\nMOD = 10**9 + 7\n\ndivide = lambda x: pow(x, MOD-2, MOD)\n\n\n\ndef pim():\n\n    print(\"Impossible\")\n\n    sys.exit()\n\ndef pp():\n\n    print(\"Possible\")\n\n    sys.exit()\n\ndef solve():\n\n    n = getN()\n\n    nums = getList()\n\n    cnt = Counter(nums)\n\n    mx = max(nums)\n\n    mn = min(nums)\n\n\n\n    if cnt[mx] < 2:\n\n        pim()\n\n    if mn < (mx + 1) // 2:\n\n        pim()\n\n\n\n    if mx % 2 == 0:\n\n        if cnt[mx//2] != 1:\n\n            pim()\n\n    else:\n\n        if cnt[(mx+1) // 2] != 2:\n\n            pim()\n\n\n\n    for i in range((mx + 1) // 2 + 1, mx+1):\n\n        if cnt[i] < 2:\n\n            pim()\n\n\n\n    pp()\n\n\n\n\n\ndef main():\n\n    n = getN()\n\n    for _ in range(n):\n\n        solve()\n\n\n\n    return\n\nif __name__ == \"__main__\":\n\n    # main()\n\n    solve()\n\n\n\n\n\n\n\n\n\n\n", "score": 1.0, "codebleu": 0.3742991004240066, "crystalbleu": 0.27492796242171147, "codebertscore": 0.83, "codescore": 0.018915100023150444, "surfaceSim": 0.6587869059779172, "abs_surfaceSim_minus_score": 0.3412130940220828}
{"golden_code": "import sys\n\nimport numpy as np\n\n\n\nsys.setrecursionlimit(10 ** 6)\n\nint1 = lambda x: int(x) - 1\n\nprintV = lambda x: print(*x, sep=\"\\n\")\n\nprintH = lambda x: print(\" \".join(map(str,x)))\n\ndef IS(): return sys.stdin.readline()[:-1]\n\ndef II(): return int(sys.stdin.readline())\n\ndef MI(): return map(int, sys.stdin.readline().split())\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\n\ndef LI1(): return list(map(int1, sys.stdin.readline().split()))\n\ndef LII(rows_number): return [II() for _ in range(rows_number)]\n\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\n\ndef LLI1(rows_number): return [LI1() for _ in range(rows_number)]\n\n\n\ndef main():\n\n\tK,N = MI()\n\n\tA = np.array(LI())\n\n\tA_LAST = K+A[0] - A[N-1]\n\n\tB = A[1:]-A[:N-1]\n\n\tB = np.sort(B)\n\n\tprint(K-max(B[N-2],A_LAST))\n\n\n\nif __name__ == '__main__':\n\n\tmain()\n", "generated_code": "import sys\n\n\n\nsys.setrecursionlimit(10 ** 6)\n\nint1 = lambda x: int(x) - 1\n\nprintV = lambda x: print(*x, sep=\"\\n\")\n\nprintH = lambda x: print(\" \".join(map(str,x)))\n\ndef IS(): return sys.stdin.readline()[:-1]\n\ndef II(): return int(sys.stdin.readline())\n\ndef MI(): return map(int, sys.stdin.readline().split())\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\n\ndef LI1(): return list(map(int1, sys.stdin.readline().split()))\n\ndef LII(rows_number): return [II() for _ in range(rows_number)]\n\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\n\ndef LLI1(rows_number): return [LI1() for _ in range(rows_number)]\n\n\n\ndef main():\n\n\tk,n = MI()\n\n\ta = LI()\n\n\tb = [0]*n\n\n\tfor i in range(n):\n\n\t\tif i == n-1:\n\n\t\t\tb[i] = a[0]+k-a[i]\n\n\t\telse:\n\n\t\t\tb[i] = a[i+1]-a[i]\n\n\tb.sort()\n\n\tprint(k-b[-1])\n\n\n\n\n\nif __name__ == '__main__':\n\n\tmain()\n", "score": 1.0, "codebleu": 0.7198086174363693, "crystalbleu": 0.6886182950167731, "codebertscore": 0.95, "codescore": 0.029895488172769547, "surfaceSim": 0.8984992101105844, "abs_surfaceSim_minus_score": 0.10150078988941558}
{"golden_code": "dX = [2,2,2,1,0,-1,-2,-2,-2,-1,0,1]\n\ndY = [-1,0,1,2,2,2,1,0,-1,-2,-2,-2]\n\ndef solve(x,y,XY):\n\n\txy = XY[:]\n\n\tif len(xy) == 0: return \"OK\"\n\n\tsx,sy = xy.pop(0),xy.pop(0)\n\n\tfor dx,dy in zip(dX,dY):\n\n\t\tif doa(x+dx,y+dy,sx,sy): \n\n\t\t\tr = solve(x+dx,y+dy,xy)\n\n\t\t\tif r: return r\n\n\n\ndef doa(x,y,sx,sy):\n\n\tif not (0 <= x <= 9 and 0 <= y <= 9): return False\n\n\treturn True if abs(x-sx) < 2 and abs(y-sy) < 2 else False\n\n\n\nwhile 1:\n\n\tx,y = list(map(int,input().split()))\n\n\tif x == y == 0: break\n\n\tn = eval(input())\n\n\txy = list(map(int,input().split()))\n\n\tans = solve(x,y,xy)\n\n\tprint(ans if ans else \"NA\")", "generated_code": "dX = [2,2,2,1,0,-1,-2,-2,-2,-1,0,1]\n\ndY = [-1,0,1,2,2,2,1,0,-1,-2,-2,-2]\n\ndef solve(x,y,XY):\n\n\txy = XY[:]\n\n\tif len(xy) == 0: return True\n\n\tsx,sy = xy.pop(0),xy.pop(0)\n\n\tfor dx,dy in zip(dX,dY):\n\n\t\tif doa(x+dx,y+dy,sx,sy): \n\n\t\t\tr = solve(x+dx,y+dy,xy)\n\n\t\t\tif r: return r\n\n\n\ndef doa(x,y,sx,sy):\n\n\tif not (0 <= x <= 9 and 0 <= y <= 9): return False\n\n\treturn True if abs(x-sx) < 2 and abs(y-sy) < 2 else False\n\n\n\nwhile 1:\n\n\tx,y = list(map(int,input().split()))\n\n\tif x == y == 0: break\n\n\tn = eval(input())\n\n\txy = list(map(int,input().split()))\n\n\tprint(\"OK\" if solve(x,y,xy) else \"NA\")", "score": 1.0, "codebleu": 0.92062837707491, "crystalbleu": 0.9514746245260667, "codebertscore": 0.99, "codescore": 0.9937461614608765, "surfaceSim": 0.9745762711864407, "abs_surfaceSim_minus_score": 0.025423728813559254}
{"golden_code": "n = int(eval(input()))\n\nx = [int(i) for i in input().split()]\n\np = 10000000\n\nfor i in range(100):\n\n    pi = 0\n\n    for j in range(n):\n\n        pi += (x[j] - (i + 1))**2\n\n    if pi < p:\n\n        p = pi\n\n    # else:\n\n    #     break\n\n        # p[i] += (x[j]-(i+1))**2\n\nprint(p)", "generated_code": "n = int(eval(input()))\n\nx = [int(i) for i in input().split()]\n\np = 10000000\n\nfor i in range(100):\n\n    pi = 0\n\n    for j in range(n):\n\n        pi += (x[j] - (i + 1))**2\n\n    if pi < p:\n\n        p = pi\n\n    else:\n\n        break\n\n        # p[i] += (x[j]-(i+1))**2\n\nprint(p)", "score": 1.0, "codebleu": 0.9328489766679093, "crystalbleu": 0.0, "codebertscore": 1.0, "codescore": 0.9937875270843506, "surfaceSim": 0.9564426877470356, "abs_surfaceSim_minus_score": 0.04355731225296444}
{"golden_code": "# a+b-2\n\n# N = a*b  よってNの約数を求める\n\nimport numpy as np\n\n\n\nN = int(eval(input()))\n\nU = 10**6+100\n\nx = np.arange(1, U, dtype=np.int64)\n\ndiv = x[N%x==0]\n\nans = (div + N//div).min() - 2\n\nprint(ans)", "generated_code": "import sys\n\nsys.setrecursionlimit(10 ** 7)\n\nread = sys.stdin.buffer.read \n\ninput = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines  \n\n\n\ndef make_divisors(n):\n\n    divisors = []\n\n    for i in range(1, int(n**0.5)+1):\n\n        if n % i == 0:\n\n            divisors.append((i, n//i))\n\n            \n\n    # divisors.sort()\n\n    return divisors\n\n\n\nN = int(eval(input()))\n\ndiv = make_divisors(N)\n\n\n\nans = 10**15\n\nfor a, b in div:\n\n  ans = min(ans, a+b-2)\n\nprint(ans)  \n\n\n", "score": 1.0, "codebleu": 0.250023802433922, "crystalbleu": 0.1479470747418999, "codebertscore": 0.71, "codescore": 0.5398939251899719, "surfaceSim": 0.5360013860013859, "abs_surfaceSim_minus_score": 0.4639986139986141}
{"golden_code": "n,q=list(map(int,input().split()));s=\"_\"+eval(input())+\"_\";l,r=0,n+1\n\nfor(m,h)in[input().split()for i in range(q)][::-1]:L=h==\"L\";R=h==\"R\";l,r=[l,l-1,l+1][(m==s[l]and R)-(m==s[l+1]and L)],[r,r-1,r+1][(m==s[r-1]and R)-(m==s[r]and L)]\n\nprint((max(0,r-l-1)))", "generated_code": "n,q=list(map(int,input().split()));s=\"_\"+eval(input())+\"_\";l,r=0,n+1\n\nfor(m,h)in[input().split()for i in range(q)][::-1]:\n\n    L=h==\"L\";R=h==\"R\";\n\n    l+=(m==s[l+1]and L)-(m==s[l]and R)\n\n    r+=(m==s[r]and L)-(m==s[r-1]and R)\n\nprint((max(0,r-l-1)))", "score": 1.0, "codebleu": 0.5499717393742543, "crystalbleu": 0.795832972622022, "codebertscore": 0.96, "codescore": 0.9728512167930603, "surfaceSim": 0.8845315904139434, "abs_surfaceSim_minus_score": 0.11546840958605664}
{"golden_code": "s=int(eval(input()))\n\np=10**9+7\n\nif s<=2:\n\n    print((0))\n\n    exit()\n\nn=s//3\n\nans=0\n\ndef f(n,k,p):\n\n    if k==0:\n\n        return 1\n\n    elif k%2==0:\n\n        return (f(n,k//2,p)**2)%p\n\n    else:\n\n        return (n*f(n,k-1,p))%p\n\n\n\nfor k in range(1,n+1):\n\n    a=1\n\n    b=1\n\n    for j in range(k-1):\n\n        a=(a*(s-3*k+1+j))%p\n\n        b=(b*(j+1))%p\n\n    ans=(ans+a*f(b,p-2,p))%p\n\n\n\nprint((ans%p))\n\n\n", "generated_code": "s=int(eval(input()))\n\np=10**9+7\n\nif s<=2:\n\n    print((0))\n\n    exit()\n\nn=s//3\n\nans=0\n\nx=[0]*(s+1)\n\nx[0]=1\n\nx[1]=1\n\ny=[0]*(s+1)\n\n\n\nfor i in range(2,s+1):\n\n    x[i]=x[i-1]*i%p\n\n\n\ny[s]=pow(x[s],p-2,p)\n\nfor i in range(s):\n\n    y[s-1-i]=y[s-i]*(s-i)%p\n\n\n\nfor k in range(1,n+1):\n\n    ans+=x[s-2*k-1]*y[k-1]*y[s-3*k]%p\n\n\n\nprint((ans%p))\n\n\n", "score": 1.0, "codebleu": 0.3946442442873037, "crystalbleu": 0.4822284168934553, "codebertscore": 0.87, "codescore": 0.8781874179840088, "surfaceSim": 0.6372907018168864, "abs_surfaceSim_minus_score": 0.3627092981831136}
{"golden_code": "W = input().lower()\n\ns = []\n\nwhile True:\n\n    T = list(map(str, input().split()))\n\n    if(T[0] == \"END_OF_TEXT\"):\n\n        break\n\n    else:\n\n        for i in range(len(T)):\n\n            s.append(T[i].lower())\n\nans = 0\n\nfor i in range(len(s)):\n\n    if(s[i] == W):\n\n        ans += 1\n\nprint(ans)", "generated_code": "W = input().lower()\n\ns = []\n\nans = 0\n\nwhile True:\n\n    T = list(map(str, input().split()))\n\n    if(T[0] == \"END_OF_TEXT\"):\n\n        break\n\n    else:\n\n        for i in range(len(T)):\n\n            if(W == T[i].lower()):\n\n                ans += 1\n\nprint(ans)", "score": 1.0, "codebleu": 0.6289336863690457, "crystalbleu": 0.7098978399965807, "codebertscore": 0.97, "codescore": 0.8197556734085083, "surfaceSim": 0.9075342465753424, "abs_surfaceSim_minus_score": 0.09246575342465757}
{"golden_code": "N, L = [int(i) for i in input().split()]\n\n\n\nmin_ = L\n\nmax_ = L + N -1\n\n\n\ndef eat_apple():\n\n    if max_<0:\n\n        return max_ \n\n    if L < 0:\n\n        return 0\n\n    return L\n\n\n\nprint(((min_+max_)*(max_-min_+1)//2 - eat_apple()))", "generated_code": "N, L = [int(i) for i in input().split()]\n\n\n\nmin_ = L\n\nmax_ = L + N -1\n\n\n\ndef eat_apple(N, L, max_):\n\n    if max_<0:\n\n        return max_ \n\n    if L < 0:\n\n        return 0\n\n    return L\n\n\n\nprint(((min_+max_)*(max_-min_+1)//2 - eat_apple(N, L, max_)))", "score": 1.0, "codebleu": 0.8778966301798463, "crystalbleu": 0.0, "codebertscore": 0.98, "codescore": 0.9938774704933167, "surfaceSim": 0.9470381526104418, "abs_surfaceSim_minus_score": 0.052961847389558225}
{"golden_code": "import sys\n\ninput = sys.stdin.readline\n\nfrom collections import *\n\n\n\nA, B, C, D = list(map(int, input().split()))\n\n\n\nwhile True:\n\n    C -= B\n\n    \n\n    if C<=0:\n\n        print('Yes')\n\n        exit()\n\n    \n\n    A -= D\n\n    \n\n    if A<=0:\n\n        print('No')\n\n        exit()", "generated_code": "A, B, C, D = list(map(int, input().split()))\n\nc1 = (C+B-1)//B\n\nc2 = (A+D-1)//D\n\n\n\nif c1<=c2:\n\n    print('Yes')\n\nelse:\n\n    print('No')", "score": 1.0, "codebleu": 0.2864220350283604, "crystalbleu": 0.0, "codebertscore": 0.78, "codescore": 0.7210685610771179, "surfaceSim": 0.6148851148851149, "abs_surfaceSim_minus_score": 0.3851148851148851}
{"golden_code": "x = int(eval(input()))\n\nprint((0 if x==1 else 1))", "generated_code": "s = eval(input())\n\nif s == '0':\n\n  print((1))\n\nelse:\n\n  print((0))", "score": 1.0, "codebleu": 0.18208020254902424, "crystalbleu": 0.0, "codebertscore": 0.86, "codescore": 0.4934515357017517, "surfaceSim": 0.6742424242424243, "abs_surfaceSim_minus_score": 0.3257575757575757}
{"golden_code": "# https://atcoder.jp/contests/abc129/tasks/abc129_c\n\n# 典型的なDP\n\n\n\nMOD = 10**9 + 7\n\nimport numpy as np\n\n# dp[i]をi段目までの通りの数とする。\n\nN, M = list(map(int, input().split()))\n\nto_zero = np.full((N + 1), False, dtype=bool)\n\nfor _ in range(M):\n\n    to_zero[int(eval(input()))] = True  # 床が抜けているところ\n\n\n\n# dpテーブルの用意\n\ndp = np.full((N + 1), -1, dtype='int64')\n\ndp[0] = 1\n\ndp[1] = 0 if to_zero[1] else 1\n\nfor i in range(2, N + 1):\n\n    dp[i] = 0 if to_zero[i] else dp[i - 2] + dp[i - 1]\n\n    if dp[i] > MOD:\n\n        dp[i] %= MOD\n\n\n\nprint((dp[-1]))\n", "generated_code": "# https://atcoder.jp/contests/abc129/tasks/abc129_c\n\n# 典型的なDP\n\n\n\nMOD = 10**9 + 7\n\nimport numpy as np\n\n# dp[i]をi段目までの通りの数とする。\n\nN, M = list(map(int, input().split()))\n\nto_zero = np.full((N + 1), False).tolist()\n\nfor _ in range(M):\n\n    to_zero[int(eval(input()))] = True  # 床が抜けているところ\n\n\n\n# dpテーブルの用意\n\ndp = np.full((N + 1), -1).tolist()\n\ndp[0] = 1\n\ndp[1] = 0 if to_zero[1] else 1\n\nfor i in range(2, N + 1):\n\n    dp[i] = 0 if to_zero[i] else dp[i - 2] + dp[i - 1]\n\n    if dp[i] > MOD:\n\n        dp[i] %= MOD\n\n\n\nprint((dp[-1]))\n", "score": 1.0, "codebleu": 0.8109209208446533, "crystalbleu": 0.9087828785415216, "codebertscore": 0.98, "codescore": 0.9084293246269226, "surfaceSim": 0.9623688458434221, "abs_surfaceSim_minus_score": 0.03763115415657792}
{"golden_code": "class Calc:\n\n    def __init__(self, max_value, mod):\n\n        \"\"\"combination(max_value, all)\"\"\"\n\n        fact = [-1] * (max_value + 1)\n\n        fact[0] = 1\n\n        fact[1] = 1\n\n        for x in range(2, max_value + 1):\n\n            fact[x] = x * fact[x - 1] % mod\n\n\n\n        invs = [1] * (max_value + 1)\n\n        invs[max_value] = pow(fact[max_value], mod - 2, mod)\n\n        for x in range(max_value - 1, 0, -1):\n\n            invs[x] = invs[x + 1] * (x + 1) % mod\n\n\n\n        self.fact = fact\n\n        self.invs = invs\n\n        self.mod = mod\n\n\n\n    def combination(self, n, r):\n\n        if n - r < r:\n\n            return self.combination(n, n - r)\n\n        if r < 0:\n\n            return 0\n\n        if r == 0:\n\n            return 1\n\n        if r == 1:\n\n            return n\n\n        return self.fact[n] * self.invs[r] * self.invs[n - r] % self.mod\n\n\n\n\n\ndef gen(n):\n\n    x = n\n\n    d = 2\n\n    cnt = 0\n\n    while x % d == 0:\n\n        x //= d\n\n        cnt += 1\n\n    yield cnt\n\n\n\n    d = 3\n\n    ma = d * d\n\n    while ma <= n:\n\n        cnt = 0\n\n        while x % d == 0:\n\n            x //= d\n\n            cnt += 1\n\n        yield cnt\n\n        ma += d * 4 + 4\n\n        d += 2\n\n\n\n    if x > 1:\n\n        yield 1\n\n\n\n\n\ndef main():\n\n    MOD = 10 ** 9 + 7\n\n\n\n    N, M = list(map(int, input().split()))\n\n\n\n    cal = Calc(max_value=N + 30, mod=MOD)\n\n\n\n    ans = 1\n\n    for cnt in gen(M):\n\n        ans = (ans * cal.combination(N + cnt - 1, cnt)) % MOD\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "generated_code": "def gen(n):\n\n    x = n\n\n    d = 2\n\n    cnt = 0\n\n    while x % d == 0:\n\n        x //= d\n\n        cnt += 1\n\n    yield cnt\n\n\n\n    d = 3\n\n    while d * d <= n:\n\n        cnt = 0\n\n        while x % d == 0:\n\n            x //= d\n\n            cnt += 1\n\n        yield cnt\n\n        d += 2\n\n\n\n    if x > 1:\n\n        yield 1\n\n\n\n\n\ndef main():\n\n    MOD = 10 ** 9 + 7\n\n\n\n    N, M = list(map(int, input().split()))\n\n\n\n    ans = 1\n\n    for cnt in gen(M):\n\n        for d in range(cnt):\n\n            ans = (ans * (N - 1 + cnt - d) % MOD) * pow(d + 1, MOD - 2, MOD) % MOD\n\n            \n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 1.0, "codebleu": 0.30364613357255194, "crystalbleu": 0.22753835647188972, "codebertscore": 0.85, "codescore": 0.021999426186084747, "surfaceSim": 0.6793730650154799, "abs_surfaceSim_minus_score": 0.3206269349845201}
{"golden_code": "n = int(eval(input()))\n\nedges = []\n\n\n\nfor id in range(n-1):\n\n    a, b = list(map(int, input().split()))\n\n    edges.append([a-1, b-1, id])\n\n\n\nedges.sort()\n\n\n\nused = [0]*(n)\n\nans = [0]*(n-1)\n\nnum = 1\n\nprev = 0\n\nfor edge in edges:\n\n    _from, to, id = edge\n\n    if _from != prev:\n\n        num = 1\n\n    if used[_from] == num:\n\n        num += 1\n\n    ans[id] = num\n\n    used[to] = num\n\n    num += 1\n\n    prev = _from\n\n\n\nprint((max(ans)))\n\nfor color in ans:\n\n    print(color)\n", "generated_code": "import sys\n\ninput = sys.stdin.readline\n\n\n\nn = int(eval(input()))\n\nedges = []\n\n\n\nfor id in range(n-1):\n\n    a, b = list(map(int, input().split()))\n\n    edges.append([a-1, b-1, id])\n\n\n\nedges.sort()\n\n\n\nused = [0]*(n)\n\nans = [0]*(n-1)\n\nnum = 1\n\nprev = 0\n\nfor edge in edges:\n\n    _from, to, id = edge\n\n    if _from != prev:\n\n        num = 1\n\n    if used[_from] == num:\n\n        num += 1\n\n    ans[id] = num\n\n    used[to] = num\n\n    num += 1\n\n    prev = _from\n\n\n\nprint((max(ans)))\n\nfor color in ans:\n\n    print(color)\n", "score": 1.0, "codebleu": 0.8361913065320064, "crystalbleu": 0.8617974445251831, "codebertscore": 0.97, "codescore": 0.9938393235206604, "surfaceSim": 0.9257534246575343, "abs_surfaceSim_minus_score": 0.0742465753424657}
{"golden_code": "a,b = list(map(int, input().split()))\n\ncount = 0\n\nfor i in range(a,b+1):\n\n    j = str(i)\n\n    if j==''.join(reversed(j)):\n\n        count += 1\n\nprint(count)", "generated_code": "a,b = list(map(int, input().split()))\n\nn = [i for i in map(str, list(range(a,b+1))) if i==i[::-1]]\n\nprint((len(n)))", "score": 1.0, "codebleu": 0.3488393822605827, "crystalbleu": 0.0, "codebertscore": 0.87, "codescore": 0.3849726915359497, "surfaceSim": 0.6011220196353436, "abs_surfaceSim_minus_score": 0.3988779803646564}
{"golden_code": "import numpy as np\n\nn = int(eval(input()))\n\nballs = np.array(list(map(int, input().split())))\n\ntime = 0\n\nwhile np.all(balls % 2 == 0) and np.all(balls > 0):\n\n    time += 1\n\n    balls = balls / 2\n\nprint(time)", "generated_code": "import math\n\nn = eval(input())\n\na = list(map(int, input().split()))\n\nans = float(\"inf\")\n\nfor i in a:\n\n    ans = min(ans, len(bin(i)) - bin(i).rfind(\"1\") - 1)\n\nprint((round(ans)))", "score": 1.0, "codebleu": 0.18379913831053835, "crystalbleu": 0.0, "codebertscore": 0.77, "codescore": 0.09286865592002869, "surfaceSim": 0.49879227053140096, "abs_surfaceSim_minus_score": 0.501207729468599}
{"golden_code": "def c_rally():\n\n    import numpy as np\n\n    import math\n\n    N = int(eval(input()))\n\n    X = [int(i) for i in input().split()]\n\n    m = np.average(X)\n\n    ans = float('inf')\n\n    for j in (math.floor(m), math.ceil(m)):\n\n        ans = min(ans, sum([(x - j)**2 for x in X]))\n\n    return ans\n\n\n\nprint((c_rally()))", "generated_code": "def c_rally():\n\n    N = int(eval(input()))\n\n    X = [int(i) for i in input().split()]\n\n\n\n    x_sum = sum(X)\n\n    option = (x_sum // N, (x_sum + N - 1) // N)\n\n    return min(sum([(x - p)**2 for x in X]) for p in option)\n\n\n\nprint((c_rally()))", "score": 1.0, "codebleu": 0.3741202641507508, "crystalbleu": 0.0, "codebertscore": 0.86, "codescore": 0.7672199606895447, "surfaceSim": 0.7056451612903226, "abs_surfaceSim_minus_score": 0.2943548387096774}
{"golden_code": "def solve(string):\n\n    x = int(string)\n\n    a = {i**5: i for i in range(-10000, 10000)}\n\n    for i in range(-10000, 10000):\n\n        if x + i ** 5 in a:\n\n            return str(f\"{a[x+i**5]} {i}\")\n\n\n\n\n\nif __name__ == '__main__':\n\n    import sys\n\n    print((solve(sys.stdin.read().strip())))\n", "generated_code": "def solve(string):\n\n    x = int(string)\n\n    a = {i**5: i for i in range(-120, 121)}\n\n    for i in range(-121, 121):\n\n        if x + i ** 5 in a:\n\n            return str(f\"{a[x+i**5]} {i}\")\n\n\n\n\n\nif __name__ == '__main__':\n\n    import sys\n\n    print((solve(sys.stdin.read().strip())))\n", "score": 1.0, "codebleu": 0.8185383438666693, "crystalbleu": 0.8537487310940012, "codebertscore": 0.98, "codescore": 0.022714650258421898, "surfaceSim": 0.9743150684931507, "abs_surfaceSim_minus_score": 0.02568493150684925}
{"golden_code": "\"\"\"\n\nchallenge case\n\n\n\nin:\n\n3\n\n1 3\n\n2 3\n\n\n\nout:\n\n1\n\n1\n\n1\n\n\"\"\"\n\n\n\nfrom collections import deque\n\n\n\ndef main():\n\n\tN, *AB = list(map(int, open(0).read().split()))\n\n\tB = AB[1::2]\n\n\n\n\tE = [[] for _ in range(N + 1)]\n\n\tfor a, b in zip(*[iter(AB)] * 2):\n\n\t\tE[a] += b,\n\n\n\n\tQ = deque([1])\n\n\tC = [0] * (N + 1)\n\n\twhile Q:\n\n\t\tv = Q.popleft()\n\n\t\tc = 0\n\n\t\tfor u in E[v]:\n\n\t\t\tc += 1 + (c + 1 == C[v])\n\n\t\t\tC[u] = c\n\n\t\t\tQ += u,\n\n\n\n\tprint((max(C)))\n\n\tfor b in B:\n\n\t\tprint((C[b]))\n\n\n\nmain()", "generated_code": "\"\"\"\n\nchallenge case\n\n\n\nin:\n\n3\n\n1 3\n\n2 3\n\n\n\nout:\n\n1\n\n1\n\n1\n\n\"\"\"\n\n\n\nfrom collections import deque\n\n\n\ndef main():\n\n\tN, *AB = list(map(int, open(0).read().split()))\n\n\tB = AB[1::2]\n\n\n\n\tE = [[] for _ in range(N + 1)]\n\n\tfor a, b in zip(*[iter(AB)] * 2):\n\n\t\tE[a].append(b)\n\n\n\n\tQ = deque([1])\n\n\tC = [0] * (N + 1)\n\n\twhile Q:\n\n\t\tv = Q.popleft()\n\n\t\tc = 0\n\n\t\tfor u in E[v]:\n\n\t\t\tc += 1 + (c + 1 == C[v])\n\n\t\t\tC[u] = c\n\n\t\t\tQ.append(u)\n\n\n\n\tprint((max(C)))\n\n\tfor b in B:\n\n\t\tprint((C[b]))\n\n\n\nmain()", "score": 1.0, "codebleu": 0.8776790870142815, "crystalbleu": 0.9102296845309878, "codebertscore": 0.99, "codescore": 0.9643779397010803, "surfaceSim": 0.9811715481171548, "abs_surfaceSim_minus_score": 0.01882845188284521}
{"golden_code": "n, m = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\nbc = [list(map(int, input().split())) for _ in range(m)]\n\n\n\nbc.sort(key=lambda x: x[1], reverse=True)\n\na.sort()\n\n\n\ni = 0\n\nfor b, c in bc:\n\n    for _ in range(b):\n\n        if i < n and a[i] < c:\n\n            a[i] = c\n\n            i += 1\n\n        else:\n\n            break\n\n\n\nans = sum(a)\n\nprint(ans)\n", "generated_code": "n, m = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\nbc = [list(map(int, input().split())) for _ in range(m)]\n\n\n\nbc.sort(reverse=True, key=lambda x: x[1])\n\n\n\nli = []\n\nl = 0\n\ni = 0\n\nwhile i < m and l < n:\n\n    b, c = bc[i]\n\n    li += [c] * b\n\n    i += 1\n\n    l += b\n\n\n\na += li\n\na.sort(reverse=True)\n\nans = sum(a[:n])\n\nprint(ans)\n", "score": 1.0, "codebleu": 0.5471655220151765, "crystalbleu": 0.499462822407167, "codebertscore": 0.93, "codescore": 0.8640806078910828, "surfaceSim": 0.747, "abs_surfaceSim_minus_score": 0.253}
{"golden_code": "# -*- coding: utf-8 -*-\n\n\"\"\"\n\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0144\n\n\n\n\"\"\"\n\nimport sys\n\nfrom sys import stdin\n\ninput = stdin.readline\n\nfrom enum import Enum\n\n\n\n\n\nclass Graph(object):\n\n    \"\"\" single source shortest path \"\"\"\n\n    class Status(Enum):\n\n        \"\"\" ?????????????¨??????¶??? \"\"\"\n\n        white = 1  # ????¨????\n\n        gray = 2  # ?¨???????\n\n        black = 3  #?¨???????\n\n\n\n    def __init__(self, n, data):\n\n        self.num_of_nodes = n+1\n\n        self.color = [Graph.Status.white] * self.num_of_nodes  # ????????????????¨??????¶???\n\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n\n        for i in range(self.num_of_nodes):\n\n            self.M[i][i] = 0\n\n        self._make_matrix(data)  # data????????????????????£??\\??????(?????\\?¶???¨???????????????????????§????????????)\n\n        self.d = [float('inf')] * self.num_of_nodes  # ?§???????????????????(?????????)\n\n        self.p = [-1] * self.num_of_nodes  # ????????????????????????????¨?????????????????????????\n\n\n\n    def _make_matrix(self, data):\n\n        for d in data:\n\n            r = d[0]\n\n            for t in d[2:]:\n\n                self.M[r][t] = 1\n\n\n\n    def dijkstra(self, start):\n\n        self.d[start] = 0\n\n        self.p[start] = -1\n\n        while True:\n\n            mincost = float('inf')\n\n            # ??\\??????????????§??????????????¨?????????????????????u???????????????\n\n            for i in range(len(self.d)):\n\n                if self.color[i] != Graph.Status.black and self.d[i] < mincost:  # S????±???????????????????S??¨??\\?¶?????????????????????????????????????????°???????????????????\n\n                    mincost = self.d[i]\n\n                    u = i  # u??????????????????ID\n\n            if mincost == float('inf'):\n\n                break\n\n            self.color[u] = Graph.Status.black  # ?????????u???S????±???????????????´???\n\n            for v in range(len(self.d)):\n\n                if self.color[v] != Graph.Status.black and self.M[u][v] != float('inf'):\n\n                    # v????????????????????????????????°??????S???????????£???u????????????????????????????????????????????°??????????????±??§??´??°??????\n\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n\n                        self.d[v] = self.d[u] + self.M[u][v]\n\n                        self.p[v] = u\n\n                        self.color[v] = Graph.Status.gray\n\n\n\n    def warshallFloyd(self):\n\n        V = self.num_of_nodes\n\n        for k in range(V):\n\n            for i in range(V):\n\n                for j in range(V):\n\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\n\n\n\n\n\n\n\ndef main(args):\n\n    n = int(eval(input()))\n\n    network = []\n\n    for _ in range(n):\n\n        network.append([int(x) for x in input().split()])\n\n\n\n    packets = []\n\n    p = int(eval(input()))\n\n    for _ in range(p):\n\n        packets.append([int(x) for x in input().split()])\n\n\n\n    g = Graph(n, network)\n\n    g.warshallFloyd()\n\n\n\n    for s, d, v in packets:\n\n        if g.M[s][d] < v:\n\n            print((g.M[s][d]+1))\n\n        else:\n\n            print('NA')\n\n\n\n\n\n\n\nif __name__ == '__main__':\n\n    main(sys.argv[1:])", "generated_code": "# -*- coding: utf-8 -*-\n\n\"\"\"\n\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0144\n\n\n\n\"\"\"\n\nimport sys\n\nfrom sys import stdin\n\ninput = stdin.readline\n\nfrom enum import Enum\n\n\n\n\n\nclass Graph(object):\n\n    \"\"\" single source shortest path \"\"\"\n\n    class Status(Enum):\n\n        \"\"\" ?????????????¨??????¶??? \"\"\"\n\n        white = 1  # ????¨????\n\n        gray = 2  # ?¨???????\n\n        black = 3  #?¨???????\n\n\n\n    def __init__(self, n, data):\n\n        self.num_of_nodes = n+1\n\n        self.color = [Graph.Status.white] * self.num_of_nodes  # ????????????????¨??????¶???\n\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n\n        for i in range(self.num_of_nodes):\n\n            self.M[i][i] = 0\n\n        self._make_matrix(data)  # data????????????????????£??\\??????(?????\\?¶???¨???????????????????????§????????????)\n\n        self.d = [float('inf')] * self.num_of_nodes  # ?§???????????????????(?????????)\n\n        self.p = [-1] * self.num_of_nodes  # ????????????????????????????¨?????????????????????????\n\n\n\n    def _make_matrix(self, data):\n\n        for d in data:\n\n            r = d[0]\n\n            for t in d[2:]:\n\n                self.M[r][t] = 1\n\n\n\n    def dijkstra(self, start):\n\n        self.d[start] = 0\n\n        self.p[start] = -1\n\n        while True:\n\n            mincost = float('inf')\n\n            # ??\\??????????????§??????????????¨?????????????????????u???????????????\n\n            for i in range(len(self.d)):\n\n                if self.color[i] != Graph.Status.black and self.d[i] < mincost:  # S????±???????????????????S??¨??\\?¶?????????????????????????????????????????°???????????????????\n\n                    mincost = self.d[i]\n\n                    u = i  # u??????????????????ID\n\n            if mincost == float('inf'):\n\n                break\n\n            self.color[u] = Graph.Status.black  # ?????????u???S????±???????????????´???\n\n            for v in range(len(self.d)):\n\n                if self.color[v] != Graph.Status.black and self.M[u][v] != float('inf'):\n\n                    # v????????????????????????????????°??????S???????????£???u????????????????????????????????????????????°??????????????±??§??´??°??????\n\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n\n                        self.d[v] = self.d[u] + self.M[u][v]\n\n                        self.p[v] = u\n\n                        self.color[v] = Graph.Status.gray\n\n\n\n    def warshallFloyd(self):\n\n        for k in range(self.num_of_nodes):\n\n            for i in range(self.num_of_nodes):\n\n                for j in range(self.num_of_nodes):\n\n                    if self.M[i][k] + self.M[k][j] < self.M[i][j]: \n\n                        self.M[i][j] = self.M[i][k] + self.M[k][j]\n\n\n\n\n\ndef main(args):\n\n    n = int(eval(input()))\n\n    network = []\n\n    for _ in range(n):\n\n        network.append([int(x) for x in input().split()])\n\n\n\n    packets = []\n\n    p = int(eval(input()))\n\n    for _ in range(p):\n\n        packets.append([int(x) for x in input().split()])\n\n\n\n    g = Graph(n, network)\n\n    g.warshallFloyd()\n\n\n\n    for s, d, v in packets:\n\n        if g.M[s][d] < v:\n\n            print((g.M[s][d]+1))\n\n        else:\n\n            print('NA')\n\n\n\n\n\n\n\nif __name__ == '__main__':\n\n    main(sys.argv[1:])", "score": 1.0, "codebleu": 0.930092874185838, "crystalbleu": 0.9483179349863431, "codebertscore": 0.99, "codescore": 0.9916360378265381, "surfaceSim": 0.9878011117974058, "abs_surfaceSim_minus_score": 0.012198888202594182}
{"golden_code": "a=65280; b=61680; c=52428; d=43690; e=65535\n\nL = {el: 1 for el in [a, b, c, d, e, 0]}\n\nfor i in range(6):\n\n    R = sorted(L.items(), key=lambda x: x[1])\n\n    for p, l in R:\n\n        if l < 16:\n\n            L[p ^ e] = min(L.get(p ^ e, 16), l+1)\n\n            if l+3 < 16:\n\n                for q, r in R:\n\n                    if l+r+3 <= 16:\n\n                        L[p & q] = min(L.get(p & q, 16), l+r+3)\n\n                        L[p ^ q] = min(L.get(p ^ q, 16), l+r+3)\n\n                    else: break\n\n        else: break\n\nprint(*(L[e & eval(s)] for s in open(0).read().replace(*\"-~\").replace(*\"*&\").replace(*\"1e\").split()[:-1]),sep='\\n')\n", "generated_code": "a=65280; b=61680; c=52428; d=43690; e=65535\n\nfrom heapq import heappush, heappop\n\nbase = [a, b, c, d, e, 0]\n\nQ = [(1, el) for el in base]\n\nL = {el: 1 for el in base}\n\nH = []\n\nwhile Q:\n\n    l, p = heappop(Q)\n\n    if L[p] < l: continue\n\n    if l+1 < L.get(p ^ e, 17):\n\n        L[p^e] = l+1\n\n        if l+1 < 16: heappush(Q, (l+1, p^e))\n\n    if l+3 < 16:\n\n        for q, r in H:\n\n            if l+r+3 <= 16:\n\n                if l+r+3 < L.get(p & q, 17):\n\n                    L[p & q] = l+r+3\n\n                    if l+r+3 < 16: heappush(Q, (l+r+3, p & q))\n\n                if l+r+3 < L.get(p ^ q, 17):\n\n                    L[p ^ q] = l+r+3\n\n                    if l+r+3 < 16: heappush(Q, (l+r+3, p ^ q))\n\n            else: break\n\n    if l < 7: H.append((p, l))\n\nprint(*(L[e & eval(s)] for s in open(0).read().replace(*\"-~\").replace(*\"*&\").replace(*\"1e\").split()[:-1]),sep='\\n')\n", "score": 1.0, "codebleu": 0.47212854149472194, "crystalbleu": 0.5057961044546256, "codebertscore": 0.89, "codescore": 0.9847428798675537, "surfaceSim": 0.7448644688644688, "abs_surfaceSim_minus_score": 0.2551355311355312}
{"golden_code": "import numpy as np\n\nn=int(eval(input()))\n\nABC=[list(map(int,input().split())) for _ in range(n)]\n\n\n\ndp=np.zeros((n,3),int)\n\nfor i in range(3):\n\n  dp[0][i]=ABC[0][i]\n\nfor i in range(n-1):\n\n  for j in range(3):\n\n    dp[i+1][j]=max(dp[i][(j+1)%3]+ABC[i+1][j], dp[i][(j+2)%3]+ABC[i+1][j])\n\nprint((max(dp[-1])))", "generated_code": "import numpy as np\n\nn=int(eval(input()))\n\nABC=[list(map(int,input().split())) for _ in range(n)]\n\n\n\ndp=np.zeros((n,3),int)\n\nfor i in range(3):\n\n  dp[0,i]=ABC[0][i]\n\nfor i in range(1,n):\n\n  for j in range(3):\n\n    dp[i,j]=max(dp[i-1,(j+1)%3]+ABC[i][j],dp[i-1,(j+2)%3]+ABC[i][j])\n\nprint((max(dp[-1])))", "score": 1.0, "codebleu": 0.7355055574324132, "crystalbleu": 0.8485121512547912, "codebertscore": 0.98, "codescore": 0.9606246948242188, "surfaceSim": 0.9689542483660131, "abs_surfaceSim_minus_score": 0.03104575163398693}
{"golden_code": "# ABC 155 C\n\nfrom collections import Counter\n\nimport numpy as np\n\nN = int(eval(input()))\n\nS = [str(eval(input())) for i in range(N)]\n\nS = np.array(S)\n\n\n\ncount = Counter(S)\n\nmax_num = max(count.values())\n\nmax_list = [i for i,j in list(count.items()) if j==max_num]\n\n\n\nmax_list.sort()\n\nprint(('\\n'.join(max_list)))", "generated_code": "import sys\n\nfrom collections import Counter\n\nN = int(sys.stdin.readline())\n\nS = sys.stdin.read().split()\n\n\n\ncount = Counter(S)\n\nmax_num = max(count.values())\n\nmax_list = [i for i,j in list(count.items()) if j==max_num]\n\n \n\nmax_list.sort()\n\nprint(('\\n'.join(max_list)))", "score": 1.0, "codebleu": 0.5017047235416202, "crystalbleu": 0.0, "codebertscore": 0.9, "codescore": 0.6612550616264343, "surfaceSim": 0.8846153846153846, "abs_surfaceSim_minus_score": 0.11538461538461542}
{"golden_code": "w = eval(input())\n\nfor l in w:\n\n\tif w.count(l) % 2 == 1:\n\n\t\tprint(\"No\")\n\n\t\tbreak\n\nelse:\n\n\tprint(\"Yes\")", "generated_code": "from collections import Counter\n\ns = eval(input())\n\nc = list(Counter(s).values())\n\nfor n in c:\n\n\tif n & 1 == 1:\n\n\t\tprint(\"No\")\n\n\t\tbreak\n\nelse:\n\n\tprint(\"Yes\")\n\n\n", "score": 1.0, "codebleu": 0.4092466506655565, "crystalbleu": 0.0, "codebertscore": 0.85, "codescore": 0.486636221408844, "surfaceSim": 0.6884868421052632, "abs_surfaceSim_minus_score": 0.31151315789473677}
{"golden_code": "import sys\n\n\n\nN = int(eval(input()))\n\na = [int(eval(input())) for _ in range(N)]\n\n\n\nl = 1\n\np = a[0] - 1\n\n\n\nif a[0] == 2:\n\n    print(l)\n\n    sys.exit()\n\n\n\nwhile l < int(1e6):\n\n    l += 1\n\n    if a[p] == 2:\n\n        print(l)\n\n        break\n\n    else:\n\n        p = a[p] - 1\n\nelse:\n\n    print((-1))", "generated_code": "import sys\n\n\n\nN = int(eval(input()))\n\na = [int(eval(input())) for _ in range(N)]\n\n\n\nl = 1\n\np = a[0] - 1\n\n\n\nif a[0] == 2:\n\n    print(l)\n\n    sys.exit()\n\n\n\nwhile l < int(2e5):\n\n    l += 1\n\n    if a[p] == 2:\n\n        print(l)\n\n        break\n\n    else:\n\n        p = a[p] - 1\n\nelse:\n\n    print((-1))", "score": 1.0, "codebleu": 0.9725075625557046, "crystalbleu": 0.9491463252558481, "codebertscore": 0.99, "codescore": 0.9937927722930908, "surfaceSim": 0.9965986394557823, "abs_surfaceSim_minus_score": 0.003401360544217691}
{"golden_code": "N,M = list(map(int,input().split()))\n\nif N==1:\n\n    nmax=M\n\nelse:\n\n    nmax = 1\n\n    for i in range(2,int(M**0.5)+1):\n\n        if M%i==0 and M//i>=N:\n\n            nmax = max(nmax,i)\n\n        if M%i==0 and i>=N:\n\n            nmax = max(nmax,M//i)\n\nprint(nmax)", "generated_code": "N,M = list(map(int,input().split()))\n\namax = 1\n\nfor i in range(1,int(M**0.5)+1):\n\n    if M%i==0:\n\n        a = i\n\n        b = M//i\n\n        if b>=N:\n\n            amax = max(amax,a)\n\n        a,b = b,a\n\n        if b>=N:\n\n            amax = max(amax,a)\n\nprint(amax)", "score": 1.0, "codebleu": 0.37607470140078214, "crystalbleu": 0.5361910807208317, "codebertscore": 0.89, "codescore": 0.661281168460846, "surfaceSim": 0.8510971786833856, "abs_surfaceSim_minus_score": 0.14890282131661436}
{"golden_code": "import numpy as np\n\n\n\nN,M = list(map(int,input().split()))\n\n\n\nA = np.array([int(x) for x in input().split()],dtype=np.int64)\n\nA.sort()\n\n\n\nBC = np.array([[int(x) for x in input().split()] for _ in range(M)])\n\nB = BC[:,0]\n\nC = BC[:,1]\n\n\n\nidx = C.argsort()\n\nB = B[idx][::-1]\n\nC = C[idx][::-1]\n\n\n\np = 0\n\nfor b,c in zip(B,C):\n\n  A[p:p+b] = np.maximum(A[p:p+b],c)\n\n  p += b\n\n\n\nanswer = A.sum()\n\nprint(answer)\n", "generated_code": "import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\nfrom operator import itemgetter\n\n\n\nN,M = list(map(int,readline().split()))\n\nA = list(map(int,readline().split()))\n\nm = list(map(int,read().split()))\n\nBC = list(zip(m,m))\n\n\n\nBC.sort(key = itemgetter(1),reverse=True)\n\n\n\nBC.append((N,-1))\n\n\n\nchange = []\n\nfor b,c in BC:\n\n    change += [c] * b\n\n    if len(change) > N:\n\n        break\n\n\n\nA += change\n\nA.sort()\n\nanswer = sum(A[-N:])\n\nprint(answer)", "score": 1.0, "codebleu": 0.2169088489404873, "crystalbleu": 0.13862665674971789, "codebertscore": 0.76, "codescore": 0.861911416053772, "surfaceSim": 0.5191581384015594, "abs_surfaceSim_minus_score": 0.48084186159844056}
{"golden_code": "import math\n\n\n\nN = int(eval(input()))\n\nans = 0\n\n\n\nans =math.factorial(N) % (10**9 +7)\n\n\n\nprint(ans)", "generated_code": "N = int(eval(input()))\n\npower = 1\n\n\n\nfor i in range(N):\n\n    power = ((i+1) * power) % 1000000007\n\n\n\nprint(power)", "score": 1.0, "codebleu": 0.257377670210069, "crystalbleu": 0.0, "codebertscore": 0.78, "codescore": 0.1745229810476303, "surfaceSim": 0.5536179073399272, "abs_surfaceSim_minus_score": 0.4463820926600728}
{"golden_code": "N, K = list(map(int, input().split()))\n\nsunuke = [True]*N\n\nfor i in range(K):\n\n    d = int(eval(input()))\n\n    A = list(map(int, input().split()))\n\n    for a in A:\n\n        sunuke[a-1] = False\n\n\n\nans = 0\n\nfor i in range(N):\n\n    if sunuke[i]:\n\n        ans += 1\n\nprint(ans)", "generated_code": "N, K = list(map(int, input().split()))\n\nflag = [True]*N\n\nfor i in range(K):\n\n    d = int(eval(input()))\n\n    A = list(map(int, input().split()))\n\n    for a in A:\n\n        flag[a-1] = False\n\nans = 0\n\nfor i in range(N):\n\n    if flag[i]:\n\n        ans += 1\n\nprint(ans)", "score": 1.0, "codebleu": 0.897505856438014, "crystalbleu": 0.8531231882678166, "codebertscore": 0.97, "codescore": 0.6386536955833435, "surfaceSim": 0.9669117647058824, "abs_surfaceSim_minus_score": 0.03308823529411764}
{"golden_code": "n, k = list(map(int, input().split()))\n\na_s = list(map(int, input().split()))\n\ndp = [\"Second\"] * (k + 1)\n\nfor i in range(k + 1):\n\n    if dp[i] == \"Second\":\n\n        for a in a_s:\n\n            ii = i + a\n\n            if ii <= k:\n\n                dp[ii] = \"First\"\n\nprint((dp[-1]))\n", "generated_code": "n, k = list(map(int, input().split()))\n\na_s = list(map(int, input().split()))\n\ndp = [\"Second\"] * (k + 1)\n\nfor i in range(k + 1):\n\n    if dp[i] == \"Second\":\n\n        for a in a_s:\n\n            ii = i + a\n\n            if ii > k:break\n\n            dp[ii] = \"First\"\n\nprint((dp[-1]))\n", "score": 1.0, "codebleu": 0.9200596498745525, "crystalbleu": 0.8903228609365674, "codebertscore": 0.99, "codescore": 0.9938169121742249, "surfaceSim": 0.9274551971326165, "abs_surfaceSim_minus_score": 0.07254480286738352}
{"golden_code": "def judge(x,y):\n\n    global xx,yy,xy,axby\n\n    if min(x,y) >= 0 and x+y <= xy:\n\n        if x+y < xy or (x+y == xy and a*x+b*y < axby):\n\n            xy = x+y\n\n            axby = a*x+b*y\n\n            xx,yy = x,y\n\n    \n\nwhile 1:\n\n    a,b,d = list(map(int,input().split()))\n\n    if a == 0: break\n\n    xy = axby = 10**10\n\n    for y in range(50001):\n\n        if (d+b*y)%a == 0: judge((d+b*y)/a,y)\n\n        if (b*y-d)%a == 0: judge((b*y-d)/a,y)\n\n        if (d-b*y)%a == 0: judge((d-b*y)/a,y)\n\n    print(xx,yy)", "generated_code": "def judge(x,y):\n\n    global xx,yy,xy,axby\n\n    if min(x,y) >= 0 and x+y <= xy:\n\n        if x+y < xy or (x+y == xy and a*x+b*y < axby):\n\n            xy = x+y\n\n            axby = a*x+b*y\n\n            xx,yy = x,y\n\n    \n\nwhile 1:\n\n    a,b,d = list(map(int,input().split()))\n\n    if a == 0: break\n\n    xy = axby = 10**10\n\n    for y in range(30001):\n\n        if (d+b*y)%a == 0: judge((d+b*y)/a,y)\n\n        if (b*y-d)%a == 0: judge((b*y-d)/a,y)\n\n        if (d-b*y)%a == 0: judge((d-b*y)/a,y)\n\n    print(xx,yy)", "score": 1.0, "codebleu": 0.975444238283764, "crystalbleu": 0.9760670247924997, "codebertscore": 1.0, "codescore": 0.9937446713447571, "surfaceSim": 0.999003984063745, "abs_surfaceSim_minus_score": 0.0009960159362549792}
{"golden_code": "import numpy as np\n\nN, D = list(map(int, input().split()))\n\nprint((int(np.ceil(N/(2*D+1)))))", "generated_code": "N, D = list(map(int, input().split()))\n\nimport math\n\nprint((math.ceil(N/(2*D+1))))", "score": 1.0, "codebleu": 0.48275401140013346, "crystalbleu": 0.0, "codebertscore": 0.93, "codescore": 0.5671713948249817, "surfaceSim": 0.8260869565217391, "abs_surfaceSim_minus_score": 0.17391304347826086}
{"golden_code": "n,u,v=list(map(int,input().split()))\n\nanss=0\n\nu-=1\n\nv-=1\n\nd=[[]for _ in range(n)]\n\ninf=float('inf')\n\naoki=[inf]*n\n\nfor i in range(n-1):\n\n  a,b=list(map(int,input().split()))\n\n  a-=1\n\n  b-=1\n\n  d[a].append(b)\n\n  d[b].append(a)\n\nQ=d[v]\n\naoki[v]=0\n\ndis=1\n\nvisited={v}\n\nwhile Q:\n\n  P=[]\n\n  for i in Q:\n\n    visited.add(i)\n\n    for j in d[i]:\n\n      if j not in visited:P.append(j)\n\n    aoki[i]=dis\n\n  dis+=1\n\n  Q=P\n\nQ=d[u]\n\nchokudai=[-1]*n\n\nchokudai[u]=0\n\ndis=1\n\nvisited={u}\n\npoint=-1\n\nwhile Q:\n\n  P=[]\n\n  for i in Q:\n\n    visited.add(i)\n\n    for j in d[i]:\n\n      if aoki[j]<=dis+1:\n\n        if aoki[j]==dis+1:anss=1\n\n        if point<0:point=i\n\n        continue\n\n      if j not in visited:P.append(j)\n\n    chokudai[i]=dis\n\n  dis+=1\n\n  Q=P\n\nQ=d[point]\n\ndis=chokudai[point]+1\n\nvisited={point}\n\nwhile Q:\n\n  P=[]\n\n  for i in Q:\n\n    visited.add(i)\n\n    if chokudai[i]==-1:continue\n\n    chokudai[i]=max(dis,chokudai[i])\n\n    for j in d[i]:\n\n      if j not in visited:P.append(j)\n\n  dis+=1\n\n  Q=P\n\nans=0\n\nfor i in range(n):\n\n  if aoki[i]>chokudai[i]:ans=max(ans,chokudai[i])\n\nprint((ans+anss))\n\n#print(aoki)\n\n#print(chokudai)", "generated_code": "n,u,v=list(map(int,input().split()))\n\nu-=1\n\nv-=1\n\ne=[[]for _ in range(n)]\n\nfor i in range(n-1):\n\n  a,b=list(map(int,input().split()))\n\n  a-=1\n\n  b-=1\n\n  e[a].append(b)\n\n  e[b].append(a)\n\ncho=[u]\n\ncho_dis=[10**7]*n\n\ncho_dis[u]=0\n\ncho_visited={u}\n\ncountt=1\n\nwhile cho:\n\n  CHO=[]\n\n  for i in cho:\n\n    for j in e[i]:\n\n      if j in cho_visited:continue\n\n      cho_visited.add(j)\n\n      CHO.append(j)\n\n      cho_dis[j]=countt\n\n  countt+=1\n\n  cho=CHO\n\naok=[v]\n\naok_dis=[10**7]*n\n\naok_dis[v]=0\n\naok_visited={v}\n\ncountt=1\n\nwhile aok:\n\n  AOK=[]\n\n  for i in aok:\n\n    for j in e[i]:\n\n      if j in aok_visited:continue\n\n      aok_visited.add(j)\n\n      AOK.append(j)\n\n      aok_dis[j]=countt\n\n  countt+=1\n\n  aok=AOK\n\nans=0\n\nfor i in range(n):\n\n  if cho_dis[i]<aok_dis[i]:ans=max(ans,aok_dis[i]-1)\n\nprint(ans)", "score": 1.0, "codebleu": 0.3319073139537192, "crystalbleu": 0.2862058289177624, "codebertscore": 0.84, "codescore": 0.2539196312427521, "surfaceSim": 0.6699577951144648, "abs_surfaceSim_minus_score": 0.33004220488553515}
{"golden_code": "N, K = list(map(int, input().split()))\n\nS = eval(input())\n\nnums = []\n\nnow = 1\n\ncnt = 0\n\nfor i in range(N):\n\n    if S[i] == str(now):\n\n        cnt += 1\n\n    else:\n\n        nums.append(cnt)\n\n        now = 1 - now\n\n        cnt = 1\n\nif cnt != 0:\n\n    nums.append(cnt)\n\nif len(nums) % 2 == 0:\n\n    nums.append(0)\n\n\n\nadd = 2 * K + 1\n\nans = 0\n\nleft = 0\n\nright = 0\n\ntmp = 0\n\nfor i in range(0, len(nums), 2):\n\n\n\n    next_left = i\n\n    next_right = min(i + add, len(nums))\n\n\n\n    while next_left > left:\n\n        tmp -= nums[left]\n\n        left += 1\n\n\n\n    while next_right > right:\n\n        tmp += nums[right]\n\n        right += 1\n\n\n\n    ans = max(ans, tmp)\n\nprint(ans)", "generated_code": "N, K = list(map(int, input().split()))\n\nS = eval(input())\n\nnums = []\n\nnow = 1\n\ncnt = 0\n\nfor i in range(N):\n\n    if S[i] == str(now):\n\n        cnt += 1\n\n    else:\n\n        nums.append(cnt)\n\n        now = 1 - now\n\n        cnt = 1\n\nif cnt != 0:\n\n    nums.append(cnt)\n\nif len(nums) % 2 == 0:\n\n    nums.append(0)\n\n\n\ncsum = [0] * (len(nums) + 1)\n\nfor i in range(len(nums)):\n\n    csum[i + 1] = csum[i] + nums[i]\n\n\n\nadd = 2 * K + 1\n\nans = 0\n\ntmp = 0\n\nfor i in range(0, len(nums), 2):\n\n    left = i\n\n    right = min(i + add, len(nums))\n\n    tmp = csum[right] - csum[left]\n\n    ans = max(ans, tmp)\n\nprint(ans)", "score": 1.0, "codebleu": 0.7612905630082394, "crystalbleu": 0.7639714372116043, "codebertscore": 0.94, "codescore": 0.9353572130203247, "surfaceSim": 0.8500058363487802, "abs_surfaceSim_minus_score": 0.14999416365121976}
{"golden_code": "from collections import Counter\n\nimport sys\n\ninput = sys.stdin.readline\n\n\n\ndef solve():\n\n    N = int(eval(input()))\n\n    Sss = [input().rstrip() for _ in range(N)]\n\n\n\n    cnt = Counter(Sss)\n\n    #print('cnt:', cnt)\n\n\n\n    maxNum = max(cnt.values())\n\n    #print('maxNum:', maxNum)\n\n\n\n    anss = []\n\n    for key, value in list(cnt.items()):\n\n        if value == maxNum:\n\n            anss.append(key)\n\n    #print('anss:', anss)\n\n\n\n    anss.sort()\n\n\n\n    print(('\\n'.join(anss)))\n\n\n\n\n\nsolve()\n", "generated_code": "from collections import Counter\n\nimport sys\n\ninput = sys.stdin.readline\n\n\n\nN = int(eval(input()))\n\nSss = [input().rstrip() for _ in range(N)]\n\n\n\ncnt = Counter(Sss)\n\n\n\nnum = max(cnt.values())\n\n\n\nanss = []\n\nfor key in sorted(cnt.keys()):\n\n    if cnt[key] == num:\n\n        anss.append(key)\n\n\n\nprint(('\\n'.join(anss)))\n", "score": 1.0, "codebleu": 0.5733694909506358, "crystalbleu": 0.5521938204835728, "codebertscore": 0.92, "codescore": 0.8519810438156128, "surfaceSim": 0.833461145194274, "abs_surfaceSim_minus_score": 0.16653885480572606}
{"golden_code": "import statistics\n\nN = int(eval(input()))\n\nA = [int(a)-i-1 for i,a in enumerate(input().split(),1)]\n\nb = statistics.median_low(A)\n\nc = statistics.median_high(A)\n\nd = sum([abs(x-b) for x in A])\n\ne = sum([abs(x-c) for x in A])\n\nprint((min(d,e)))", "generated_code": "N=int(eval(input()))\n\nA=sorted(a-i-1 for i,a in enumerate(map(int,input().split())))\n\nprint((sum(abs(a-A[N//2]) for a in A)))", "score": 1.0, "codebleu": 0.14960714055356095, "crystalbleu": 0.0, "codebertscore": 0.86, "codescore": 0.12573042511940002, "surfaceSim": 0.5554526748971194, "abs_surfaceSim_minus_score": 0.44454732510288064}
{"golden_code": "import sys\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\nreadlines = sys.stdin.readlines\n\n\n\ndef main():\n\n    S = readline().strip()\n\n    T = readline().strip()\n\n\n\n    idx_in_S = []\n\n    last_idx = 0\n\n    for t in T:\n\n        t_idx = S.find(t, last_idx) + 1\n\n        if t_idx:\n\n            idx_in_S.append(t_idx)\n\n            last_idx = t_idx\n\n        else:\n\n            t_idx = S.find(t, 0, last_idx) + 1\n\n            if not t_idx:\n\n                print((-1))\n\n                exit()\n\n            else:\n\n                idx_in_S.append(t_idx)\n\n                last_idx = t_idx\n\n\n\n    \n\n    rep = 0\n\n    for i in range(len(T) - 1):\n\n        if idx_in_S[i] < idx_in_S[i+1]:\n\n            continue\n\n        else:\n\n            rep += 1\n\n\n\n    ans = len(S) * rep + idx_in_S[-1]\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "generated_code": "# S.find()の部分を高速化する\n\nfrom collections import defaultdict\n\nfrom bisect import bisect_right\n\nimport sys\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\nreadlines = sys.stdin.readlines\n\n\n\ndef main():\n\n    S = readline().strip()\n\n    T = readline().strip()\n\n\n\n    S_idx = defaultdict(list)\n\n    for i, s in enumerate(S):\n\n        S_idx[s].append(i)\n\n    \n\n    rep = 0\n\n    last_idx = -1\n\n    for t in T:\n\n        t_idx_list = S_idx[t]\n\n        if t_idx_list:\n\n            t_idx = bisect_right(t_idx_list, last_idx)\n\n            if t_idx < len(t_idx_list):\n\n                last_idx = t_idx_list[t_idx]\n\n            else:\n\n                last_idx = t_idx_list[0]\n\n                rep += 1\n\n        else:\n\n            print((-1))\n\n            exit()\n\n    \n\n    ans = len(S) * rep + last_idx + 1\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "score": 1.0, "codebleu": 0.4446713140575135, "crystalbleu": 0.402424502714305, "codebertscore": 0.87, "codescore": 0.023217948153614998, "surfaceSim": 0.7405557176196033, "abs_surfaceSim_minus_score": 0.25944428238039674}
{"golden_code": "import sys\n\n\n\nn, m, *lr = list(map(int, sys.stdin.read().split()))\n\nlr = list(zip(*[iter(lr)] * 2))\n\n\n\ndef main():\n\n    cnt = [0] * (n + 1)\n\n    for l, r in lr:\n\n        cnt[l-1] += 1\n\n        cnt[r] -= 1\n\n    \n\n    for i in range(n):\n\n        cnt[i+1] += cnt[i]\n\n    \n\n    res = 0\n\n    for i in range(n):\n\n        res += (cnt[i] == m) & 1\n\n    \n\n    return res\n\n\n\nif __name__ == '__main__':\n\n    ans = main()\n\n    print(ans)", "generated_code": "import sys\n\n\n\nn, m, *lr = list(map(int, sys.stdin.read().split()))\n\nl, r = lr[::2], lr[1::2]\n\n\n\ndef main():\n\n    ans = max(min(r) - max(l) + 1, 0)\n\n    return ans\n\n\n\nif __name__ == '__main__':\n\n    ans = main()\n\n    print(ans)", "score": 1.0, "codebleu": 0.30662618959757326, "crystalbleu": 0.2800354182309023, "codebertscore": 0.84, "codescore": 0.0198019091039896, "surfaceSim": 0.7303921568627452, "abs_surfaceSim_minus_score": 0.26960784313725483}
{"golden_code": "import sys\n\nreadline = sys.stdin.readline\n\nsys.setrecursionlimit(10**8)\n\nmod = 10**9+7\n\n#mod = 998244353\n\nINF = 10**18\n\neps = 10**-7\n\n\n\nm,n,k = list(map(int,readline().split()))\n\n\n\ndef comb(n, r, mod):\n\n    r = min(r, n-r)\n\n    mol = 1\n\n    deno = 1\n\n    for i in range(1, r+1):\n\n        mol = mol * (n-r+i) % mod\n\n        deno = deno * i % mod\n\n    ret = mol * pow(deno, mod-2, mod) % mod\n\n    return ret\n\n\n\ndef f1(x,y,a,b):\n\n    return (a+b-x-y)*(a-x+1)*(b-y+1)//2\n\n\n\ndef f2(x,a):\n\n    return (a-x)*(a-x+1)//2\n\n\n\nans = 0\n\n\n\nfor x in range(1,n+1):\n\n    for y in range(1,m+1):\n\n        ans += f1(x,y,n,m)+f1(1,1,x,y)+f1(1,y,x,m)+f1(x,1,n,y)\n\n        ans -= f2(x,n) + f2(1,x) + f2(1,y) + f2(y,m)\n\n        ans %= mod\n\n\n\nans = (ans * comb(m*n-2,k-2,mod))%mod\n\nans = ans*pow(2,mod-2,mod)%mod\n\n\n\nprint(ans)\n", "generated_code": "import sys\n\nreadline = sys.stdin.readline\n\nsys.setrecursionlimit(10**8)\n\nmod = 10**9+7\n\n#mod = 998244353\n\nINF = 10**18\n\neps = 10**-7\n\n\n\nm,n,k = list(map(int,readline().split()))\n\n\n\ndef comb(n, r, mod):\n\n    r = min(r, n-r)\n\n    mol = 1\n\n    deno = 1\n\n    for i in range(1, r+1):\n\n        mol = mol * (n-r+i) % mod\n\n        deno = deno * i % mod\n\n    ret = mol * pow(deno, mod-2, mod) % mod\n\n    return ret\n\n\n\ndef f1(x,y,a,b):\n\n    return (a+b-x-y)*(a-x+1)*(b-y+1)//2\n\n\n\ndef f2(x,a):\n\n    return (a-x)*(a-x+1)//2\n\n\n\nans = 0\n\n\n\nfor x in range(1,n+1):\n\n    for y in range(1,m+1):\n\n        a = n-x+1\n\n        b = m-y+1\n\n        c = m*(a*(a-1)+x*(x-1))\n\n        d = n*(b*(b-1)+y*(y-1))\n\n        ans += (c+d)//2\n\n        ans %= mod\n\n\n\nans = (ans * comb(m*n-2,k-2,mod))%mod\n\nans = ans*pow(2,mod-2,mod)%mod\n\n\n\nprint(ans)\n\n\n", "score": 1.0, "codebleu": 0.844738269351389, "crystalbleu": 0.808173874496045, "codebertscore": 0.97, "codescore": 0.9935558438301086, "surfaceSim": 0.9564417177914111, "abs_surfaceSim_minus_score": 0.04355828220858893}
{"golden_code": "s = eval(input())\n\nk = int(eval(input()))\n\n\n\nif len(set(s)) == 1:\n\n    print(((len(s)*k)//2))\n\n    exit()\n\n\n\nss = s + s\n\n\n\nshoko = 0\n\nprev = ''\n\ncnt = 0\n\nfor i in range(len(s)):\n\n    if s[i] == prev:\n\n        cnt += 1\n\n    else:\n\n        shoko += cnt // 2\n\n        cnt = 1\n\n    prev = s[i]\n\nshoko += cnt // 2\n\n\n\nkosa = 0\n\nprev = ''\n\ncnt = 0\n\nfor i in range(len(ss)):\n\n    if ss[i] == prev:\n\n        cnt += 1\n\n    else:\n\n        kosa += cnt // 2\n\n        cnt = 1\n\n    prev = ss[i]\n\nkosa += cnt // 2\n\nkosa -= shoko\n\n\n\nprint((shoko + (k-1)*kosa))", "generated_code": "s = eval(input())\n\nk = int(eval(input()))\n\nn = len(s)\n\n\n\nif len(set(s)) == 1:\n\n    print((n*k//2))\n\n    exit()\n\n\n\nss = s + s\n\ncnts = 0\n\nnow = s[0]\n\ntemp = 1\n\nfor i in range(1, n):\n\n    if s[i] == now:\n\n        temp += 1\n\n    else:\n\n        cnts += temp // 2\n\n        temp = 1\n\n        now = s[i]\n\ncnts += temp // 2\n\n\n\ncntss = 0\n\nnow = ss[0]\n\ntemp = 1\n\nfor i in range(1, 2*n):\n\n    if ss[i] == now:\n\n        temp += 1\n\n    else:\n\n        cntss += temp // 2\n\n        temp = 1\n\n        now = ss[i]\n\ncntss += temp // 2\n\n\n\nkousa = cntss - cnts\n\nprint((cnts + kousa*(k-1)))", "score": 1.0, "codebleu": 0.3959565468719091, "crystalbleu": 0.3995937448716814, "codebertscore": 0.89, "codescore": 0.5903880000114441, "surfaceSim": 0.86331569664903, "abs_surfaceSim_minus_score": 0.13668430335097004}
{"golden_code": "import math\n\ninput_num = int(eval(input()))\n\nnum_sqrt = int(math.sqrt(input_num))\n\n\n\nminimam = input_num\n\nfor i in range(num_sqrt+1,0,-1):\n\n    q, mod = divmod(input_num, i)\n\n    distance = q + i -2\n\n    if mod == 0 and minimam > distance:\n\n        minimam = distance\n\nprint(minimam)", "generated_code": "import math\n\ndef main1():\n\n    input_num = int(eval(input()))\n\n    num_sqrt = int(math.sqrt(input_num))\n\n\n\n    minimam = input_num\n\n    for i in range(num_sqrt+1,0,-1):\n\n        q, mod = divmod(input_num, i)\n\n        if mod == 0:\n\n            distance = q + i -2\n\n            if minimam > distance:\n\n                minimam = distance\n\n    print(minimam)\n\nmain1()", "score": 1.0, "codebleu": 0.693836110069549, "crystalbleu": 0.0, "codebertscore": 0.96, "codescore": 0.8295694589614868, "surfaceSim": 0.8693579148124603, "abs_surfaceSim_minus_score": 0.13064208518753972}
{"golden_code": "import collections\n\nimport sys\n\na=eval(input())\n\nb=[]\n\n\n\nfor i in a:\n\n  b.append(i)\n\n  \n\nb.sort()\n\nc=collections.Counter(b)\n\nc=list(c.values())\n\n\n\nfor i in range(len(c)):\n\n  if int(c[i])%2==0:\n\n    q=0\n\n  else:\n\n    q=1\n\n    print('No')\n\n    sys.exit()\n\n    \n\nprint('Yes')\n", "generated_code": "w = list(eval(input()))\n\ns = set(w)\n\nfor i in s:\n\n  if w.count(i)%2 != 0:\n\n    print(\"No\")\n\n    break\n\nelse:\n\n  print(\"Yes\")\n\n  ", "score": 1.0, "codebleu": 0.1468778645718564, "crystalbleu": 0.0, "codebertscore": 0.8, "codescore": 0.7526456117630005, "surfaceSim": 0.5507825507825508, "abs_surfaceSim_minus_score": 0.4492174492174492}
{"golden_code": "def main():\n\n    S = eval(input())\n\n    w1 = 'dream'[::-1]\n\n    w2 = 'dreamer'[::-1]\n\n    w3 = 'erase'[::-1]\n\n    w4 = 'eraser'[::-1]\n\n    # print(w1,w2,w3,w4)\n\n    S = S[::-1]\n\n    # print(S)\n\n\n\n    # words = ['dream', 'dreamer', 'erase', 'eraser']\n\n    words = [w1, w2, w3, w4]\n\n    T = ''\n\n    while S != T:\n\n        cand = []\n\n        for w in words:\n\n            new_t = T + w\n\n            cand.append(new_t) \n\n        # print('cand', cand)\n\n        ans = False\n\n        for c in cand:\n\n            if c == S[:len(c)]:\n\n                T = c\n\n                ans = True\n\n\n\n        if not ans:\n\n            break\n\n\n\n    if S == T:\n\n        print('YES')\n\n    else:\n\n        print(\"NO\")\n\n\n\nif __name__ == \"__main__\":\n\n    main()", "generated_code": "def main():\n\n    S = eval(input())\n\n    w1 = 'dream'[::-1]\n\n    w2 = 'dreamer'[::-1]\n\n    w3 = 'erase'[::-1]\n\n    w4 = 'eraser'[::-1]\n\n    S = S[::-1]\n\n    words = [w1, w2, w3, w4]\n\n\n\n    flag = False\n\n    i = 0\n\n    while i < len(S):\n\n        for w in words:\n\n            if S[i:].startswith(w):\n\n                i += len(w)\n\n                flag = True\n\n                break\n\n\n\n        if not flag:\n\n            print(\"NO\")\n\n            exit()\n\n        flag = False\n\n\n\n    print(\"YES\")\n\n\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()", "score": 1.0, "codebleu": 0.49477669182208117, "crystalbleu": 0.5490720306256603, "codebertscore": 0.9, "codescore": 0.018563689664006233, "surfaceSim": 0.8450097847358121, "abs_surfaceSim_minus_score": 0.15499021526418788}
{"golden_code": "from decimal import *\n\ngetcontext().prec = 14\n\n\n\nN, D = list(map(int, input().split()))\n\n\n\n\n\ndef distance(x1, x2, y1, y2):\n\n    dx = x2-x1\n\n    dy = y2-y1\n\n    return (dx*dx + dy*dy).sqrt()\n\n\n\n\n\nX = [0] * N\n\nY = [0] * N\n\nans = 0\n\nfor i in range(N):\n\n    X[i], Y[i] = list(map(Decimal, input().split()))\n\n    if (distance(0, X[i], 0, Y[i]) <= D):\n\n        ans += 1\n\n\n\nprint(ans)\n", "generated_code": "from decimal import *\n\ngetcontext().prec = 14  # あんまり大きいと計算遅いかも\n\n\n\nN, D = list(map(int, input().split()))\n\n\n\ndef distance(x1, x2, y1, y2):\n\n    dx = x2-x1\n\n    dy = y2-y1\n\n    return (dx*dx + dy*dy).sqrt()\n\n\n\nans = 0\n\nfor i in range(N):\n\n    X, Y = list(map(Decimal, input().split()))\n\n    if (distance(0, X, 0, Y) <= D):\n\n        ans += 1\n\n\n\nprint(ans)\n", "score": 1.0, "codebleu": 0.6825369122435014, "crystalbleu": 0.7535665508312549, "codebertscore": 0.92, "codescore": 0.9760745167732239, "surfaceSim": 0.9093915343915344, "abs_surfaceSim_minus_score": 0.09060846560846558}
{"golden_code": "X=int(eval(input()))\n\na=[]\n\nfor i in range(-100,200):\n\n  for j in range(-100,200):\n\n    if i**5-j**5==X:\n\n      a.append(str(i))\n\n      a.append(str(j))\n\n      break\n\nprint((' '.join(a[0:2])))\n\n\n\n    ", "generated_code": "X=int(eval(input()))\n\na=[]\n\nfor i in range(-100,200):\n\n  for j in range(-100,200):\n\n    if i**5-j**5==X:\n\n      a.append(str(i))\n\n      a.append(str(j))\n\n      break\n\n  else:\n\n    continue\n\n  break  \n\nprint((' '.join(a[0:2])))\n\n\n\n    \n", "score": 1.0, "codebleu": 0.8047674376081692, "crystalbleu": 0.8842914646346262, "codebertscore": 0.99, "codescore": 0.9938137531280518, "surfaceSim": 0.9335800185013876, "abs_surfaceSim_minus_score": 0.06641998149861239}
{"golden_code": "import numpy as np\n\n\n\nN = int(input())\n\n\n\nA = np.array([int(i) for i in input().split()])\n\n\n\nx = np.argsort(A)\n\nx += 1\n\n\n\nfor i in range(N):\n\n    print(x[i], end=\" \")\n\n    \n\nprint()\n", "generated_code": "N = int(eval(input()))\n\n\n\nA = [int(i) for i in input().split()]\n\n\n\nB = [0]*N\n\nfor i in range(N):\n\n    B[A[i]-1] = i+1\n\n\n\nfor i in range(N):\n\n    print((B[i]))\n", "score": 1.0, "codebleu": 0.2623436267509254, "crystalbleu": 0.0, "codebertscore": 0.86, "codescore": 0.49390923976898193, "surfaceSim": 0.6172957477305303, "abs_surfaceSim_minus_score": 0.3827042522694697}
{"golden_code": "import sys\n\nsys.setrecursionlimit(10000000)\n\nimport heapq\n\nimport math\n\n \n\ndef main():\n\n    N, K = list(map(int, input().split()))\n\n    A = [int(c) for c in input().split()]\n\n    F = [int(c) for c in input().split()]\n\n    \n\n    A.sort()\n\n    F.sort(reverse=True)\n\n \n\n    num = 0\n\n    sum_ = []\n\n    for i in range(N):\n\n      sum_.append(A[i] * F[i])\n\n    left = 0\n\n    right = 10 ** 12\n\n    while(num < 90):\n\n        number = 0\n\n        mid = (left + right) // 2\n\n        # print(mid)\n\n        for i in range(len(A)):\n\n            if sum_[i] <= mid:\n\n                continue\n\n            else:\n\n                number += math.ceil((sum_[i] - mid) / F[i])\n\n            # print(number)\n\n        if number > K:\n\n            # 最大値をmidより小さくできない -> 最大値はもっとでかい\n\n            left = mid + 1\n\n        else:\n\n            right = mid\n\n        num += 1\n\n    print(mid)\n\n                \n\n        \n\n \n\n \n\n \n\nif __name__ == '__main__':\n\n    main()", "generated_code": "import sys\n\nsys.setrecursionlimit(10000000)\n\nimport heapq\n\nimport math\n\n\n\ndef main():\n\n    N, K = list(map(int, input().split()))\n\n    A = [int(c) for c in input().split()]\n\n    F = [int(c) for c in input().split()]\n\n    \n\n    A.sort()\n\n    F.sort(reverse=True)\n\n\n\n    num = 0\n\n    sum_ = []\n\n    for i in range(len(A)):\n\n        sum_.append(A[i] * F[i])\n\n    left = 0\n\n    right = 10 ** 12\n\n    while(num < 50):\n\n        number = 0\n\n        mid = (left + right) // 2\n\n        # print(mid)\n\n        for i in range(len(A)):\n\n            if sum_[i] <= mid:\n\n                continue\n\n            else:\n\n                number += math.ceil((sum_[i] - mid) / F[i])\n\n            # print(number)\n\n        if number > K:\n\n            # 最大値をmidより小さくできない -> 最大値はもっとでかい\n\n            left = mid + 1\n\n        else:\n\n            right = mid\n\n        num += 1\n\n    print(mid)\n\n                \n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 1.0, "codebleu": 0.9017024327752274, "crystalbleu": 0.956303373775195, "codebertscore": 0.99, "codescore": 0.9938253164291382, "surfaceSim": 0.9962486602357985, "abs_surfaceSim_minus_score": 0.0037513397642015}
{"golden_code": "import sys\n\ninput = sys.stdin.readline\n\nimport numpy as np\n\nN = int(eval(input()))\n\nS = [[] for _ in range(N)]\n\nfor i in range(N):\n\n    A = int(eval(input()))\n\n    temp = []\n\n    for _ in range(A):\n\n        temp.append([str(x) for x in input().split()])\n\n        S[i] = temp\n\nans = 0\n\nfor i in range(2 ** N - 1, -1,-1):\n\n    biti = list(bin(i)[2:].zfill(N))\n\n    flag = 0\n\n    for j in range(N):\n\n        if biti[j] == \"1\":\n\n            for k in S[j]:\n\n                if biti[int(k[0])-1] != k[1]:\n\n                    flag = 1\n\n                    break\n\n        if flag:\n\n            break\n\n    if not flag:    \n\n        biti = np.array(biti)\n\n        ans = max(ans, np.count_nonzero(biti == \"1\"))\n\nprint(ans)", "generated_code": "import sys\n\ninput = sys.stdin.readline\n\n\n\nn = int(eval(input()))\n\n\n\nfrom collections import defaultdict\n\nd = defaultdict(list)\n\n\n\nfor i in range(n):\n\n    a = int(eval(input()))\n\n    for _ in range(a):\n\n        x, y = [int(x) for x in input().split()]\n\n        d[i].append((x - 1, y))\n\nans = 0\n\nfor k in range(2**n):\n\n    res = 0\n\n    j = bin(k)[2:].zfill(n)\n\n    flag = 1\n\n    for i in range(n):\n\n        if j[i] == \"0\":\n\n            continue\n\n        for x, y in d[i]:\n\n            if int(j[x]) != int(y):\n\n                flag = 0\n\n                break\n\n        res += 1\n\n    if flag:\n\n        ans = max(ans, res)\n\nprint(ans)", "score": 1.0, "codebleu": 0.3359080384678641, "crystalbleu": 0.33262410786032387, "codebertscore": 0.87, "codescore": 0.8932288885116577, "surfaceSim": 0.7075346992729676, "abs_surfaceSim_minus_score": 0.29246530072703236}
{"golden_code": "n = int(eval(input()))\n\ns = input().split()\n\ns = set(s)\n\nprint(('Four' if len(s) == 4 else 'Three'))", "generated_code": "n = int(eval(input()))\n\ns = input().split()\n\nprint(('Four' if len(set(s)) == 4 else 'Three'))", "score": 1.0, "codebleu": 0.6072373739061012, "crystalbleu": 0.0, "codebertscore": 0.98, "codescore": 0.9937574863433838, "surfaceSim": 0.9299999999999999, "abs_surfaceSim_minus_score": 0.07000000000000006}
{"golden_code": "from collections import defaultdict\n\n\n\nN = int(eval(input()))\n\nA = [eval(input()) for _ in range(N)]\n\nA.sort()\n\nd = defaultdict(int)\n\nfor a in A:\n\n    d[a] += 1\n\n\n\nl = sorted(d.items())\n\nmax_v = 0\n\n\n\nfor _, v in l:\n\n    if v > max_v:\n\n        max_v = v\n\n    \n\nfor k, v in l:\n\n    if v == max_v:\n\n        print(k)\n\n    else:\n\n        continue\n", "generated_code": "from collections import defaultdict\n\n\n\ndef solve():\n\n    N = int(eval(input()))\n\n    d = defaultdict(int)\n\n    for _ in range(N):\n\n        a = eval(input())\n\n        d[a] += 1\n\n\n\n    m = 0\n\n    for k, v in list(d.items()):\n\n        m = max(m, v)\n\n    \n\n    l = []\n\n    for k, v in list(d.items()):\n\n        if m == v:\n\n            l.append(k)\n\n    l.sort()\n\n    for ans in l:\n\n        print(ans)\n\n    \n\nsolve()", "score": 1.0, "codebleu": 0.41389789863174553, "crystalbleu": 0.3789638076467144, "codebertscore": 0.9, "codescore": 0.9603654742240906, "surfaceSim": 0.6984191508581752, "abs_surfaceSim_minus_score": 0.3015808491418248}
{"golden_code": "def cmb(n, r, mod):\n\n    if ( r<0 or r>n ):\n\n        return 0\n\n    r = min(r, n-r)\n\n    return g1[n] * g2[r] * g2[n-r] % mod\n\n\n\nA=2*10**5\n\nmod = 10**9+7\n\ng1 = [1, 1]\n\ng2 = [1, 1]\n\ninverse = [0, 1]\n\n\n\nfor i in range( 2, A + 1 ):\n\n    g1.append( ( g1[-1] * i ) % mod )\n\n    inverse.append( ( -inverse[mod % i] * (mod//i) ) % mod )\n\n    g2.append( (g2[-1] * inverse[-1]) % mod )\n\n\n\nN,M,K=list(map(int,input().split()))\n\nkeisuu=cmb(N*M-2,K-2,mod)\n\n\n\nsum_=0\n\nfor i in range(N):\n\n    a=min(abs(i),abs(N-i-1))\n\n    b=max(abs(i),abs(N-i-1))\n\n    sum_+=(M**2)*((a*(a+1)//2)+(b*(b+1)//2))\n\nfor i in range(M):\n\n    a=min(abs(i),abs(M-i-1))\n\n    b=max(abs(i),abs(M-i-1))\n\n    sum_+=(N**2)*((a*(a+1)//2)+(b*(b+1)//2))\n\nprint(((keisuu * (sum_//2))%mod))", "generated_code": "def power_mod(a,b,mod=10**9+7):\n\n    i,temp,box=0,b,[]\n\n    while(2**i<=b):\n\n        i+=1\n\n    for j in range(i-1,-1,-1):\n\n        box=[[j,temp//2**j]]+box\n\n        temp-=2**j*(temp//2**j)\n\n    box[0].append(a)\n\n    ans=box[0][1]*a%mod\n\n    for j in range(1,i):\n\n        box[j].append(box[j-1][2]**2%mod)\n\n        if box[j][1]==1:\n\n            ans=(ans*box[j][2])%mod\n\n    return ans\n\ndef n_func(n,mod=10**9+7):\n\n    ans=1\n\n    for i in range(1,n+1):\n\n        ans=(ans*i)%mod\n\n    return ans\n\ndef nPr(n,r,mod=10**9+7):\n\n    ans=n_func(n-r,mod)\n\n    ans=power_mod(ans,mod-2,mod)\n\n    return ans*n_func(n,mod)%mod\n\ndef nCr(n,r,mod=10**9+7):\n\n    ans=n_func(n-r,mod)*n_func(r,mod)%mod\n\n    ans=power_mod(ans,mod-2,mod)\n\n    return ans*n_func(n,mod)%mod\n\n\n\nN,M,K=list(map(int,input().split()))\n\nkeisuu=nCr(N*M-2,K-2)\n\nmod=10**9+7\n\n\n\nsum_=0\n\nfor i in range(N):\n\n    a=min(abs(i),abs(N-i-1))\n\n    b=max(abs(i),abs(N-i-1))\n\n    sum_+=(M**2)*((a*(a+1)//2)+(b*(b+1)//2))\n\nfor i in range(M):\n\n    a=min(abs(i),abs(M-i-1))\n\n    b=max(abs(i),abs(M-i-1))\n\n    sum_+=(N**2)*((a*(a+1)//2)+(b*(b+1)//2))\n\nprint(((keisuu * (sum_//2))%mod))", "score": 1.0, "codebleu": 0.364039408405734, "crystalbleu": 0.44722381874074135, "codebertscore": 0.85, "codescore": 0.6770614981651306, "surfaceSim": 0.697294888471359, "abs_surfaceSim_minus_score": 0.302705111528641}
{"golden_code": "# https://atcoder.jp/contests/dp/tasks/dp_c\n\nimport numpy as np\n\nN = int(eval(input()))\n\nMax_List=[]\n\nN_List=[i for i in range(3)]\n\nfor i in range(N):\n\n    Current_List=list(map(int,input().split())) \n\n    if i == 0:\n\n        Max_List.append(Current_List)\n\n    else:\n\n        Current_Max_List = []\n\n        for j in range(3):\n\n            Index_List=np.array(Max_List[i-1])\n\n            ind = np.ones(3, dtype=bool)\n\n            ind[j] = False\n\n            Current_Max_List.append(max(Index_List[ind])+Current_List[j])\n\n            \n\n        Max_List.append(Current_Max_List)\n\n        \n\n    \n\nprint((max(Max_List[-1])))", "generated_code": "# https://atcoder.jp/contests/dp/tasks/dp_c\n\nN = int(eval(input()))\n\nMax_List=[]\n\nN_List=[i for i in range(3)]\n\nfor i in range(N):\n\n    Current_List=list(map(int,input().split())) \n\n    if i == 0:\n\n        Max_List.append(Current_List)\n\n    else:\n\n        Current_Max_List = []\n\n        Search_List=Max_List[i-1]\n\n        for j in range(3):\n\n            Current_Search_List=Search_List[1:3]\n\n            Current_Max_List.append(max(Current_Search_List)+Current_List[j])\n\n            Search_List.append(Search_List[0])\n\n            del Search_List[0]\n\n        Max_List.append(Current_Max_List)\n\n        \n\n    \n\nprint((max(Max_List[-1])))", "score": 1.0, "codebleu": 0.5666509071975057, "crystalbleu": 0.6899977340729211, "codebertscore": 0.94, "codescore": 0.7650474905967712, "surfaceSim": 0.7794133593580568, "abs_surfaceSim_minus_score": 0.22058664064194322}
{"golden_code": "def gen_d_prim(n):\n\n    D = [n+1 if i%2 else 2 for i in range(n+1)]\n\n    D[0] = D[1] = 0\n\n    for i in range(3, n+1, 2):\n\n        if D[i] != n+1: continue\n\n        for j in range(i, n+1, i): D[j] = i\n\n    return D\n\n\n\ndef is_pairwise(A):\n\n    D = gen_d_prim(10**6)\n\n    past = set()\n\n    for a in A:\n\n        now = set()\n\n        while a != 1:\n\n            # 素数 D[a]: 今回は未済 & 過去で済\n\n            if not D[a] in now and D[a] in past: return False\n\n            now.add(D[a])\n\n            past.add(D[a])\n\n            a //= D[a]\n\n    return True\n\n\n\ndef gcd_all(A):\n\n    from math import gcd\n\n    g = 0\n\n    for a in A: g = gcd(g, a)\n\n    return g\n\n\n\ndef solve():\n\n    if is_pairwise(A): return 0\n\n    if gcd_all(A) == 1: return 1\n\n    return 2\n\n\n\nn = int(eval(input()))\n\nA = [*list(map(int, input().split()))]\n\nprint((['pairwise','setwise','not'][solve()], 'coprime'))\n", "generated_code": "def gen_d_prim(n):\n\n    D = [0,0] + [-1] * (n-1)\n\n    for i in range(2, n+1, 2): D[i] = 2\n\n    for i in range(3, n+1, 2):\n\n        if D[i] > 0: continue\n\n        for j in range(i, n+1, i): D[j] = i\n\n    return D\n\n\n\ndef is_pairwise(A):\n\n    D = gen_d_prim(10**6)\n\n    past = set()\n\n    for a in A:\n\n        now = set()\n\n        while a != 1:\n\n            # 素数 D[a]: 今回は未済 & 過去で済\n\n            if not D[a] in now and D[a] in past: return False\n\n            now.add(D[a])\n\n            past.add(D[a])\n\n            a //= D[a]\n\n    return True\n\n\n\ndef gcd_all(A):\n\n    from math import gcd\n\n    g = 0\n\n    for a in A: g = gcd(g, a)\n\n    return g\n\n\n\ndef solve():\n\n    if is_pairwise(A): return 0\n\n    if gcd_all(A) == 1: return 1\n\n    return 2\n\n\n\nn = int(eval(input()))\n\nA = [*list(map(int, input().split()))]\n\nprint((['pairwise','setwise','not'][solve()], 'coprime'))\n", "score": 1.0, "codebleu": 0.8139597098809519, "crystalbleu": 0.885735581541447, "codebertscore": 0.98, "codescore": 0.8788031935691833, "surfaceSim": 0.8925496261923176, "abs_surfaceSim_minus_score": 0.10745037380768241}
{"golden_code": "import math\n\nn = int(eval(input()))\n\nprint((math.factorial(n)%(10**9+7)))\n", "generated_code": "n = int(eval(input()))\n\nmod = 10**9 + 7\n\n\n\npow = 1\n\nfor i in range(n):\n\n    pow = pow*(i+1)%mod\n\n\n\nprint(pow)\n", "score": 1.0, "codebleu": 0.2891986391150476, "crystalbleu": 0.0, "codebertscore": 0.82, "codescore": 0.22807550430297852, "surfaceSim": 0.5711229946524065, "abs_surfaceSim_minus_score": 0.42887700534759354}
{"golden_code": "import numpy as np\n\nN,M=list(map(int,input().split()))\n\nA=np.zeros((N+1,M+1))\n\nA[0]=np.ones(M+1)\n\nfor i in range(1,N+1):\n\n    B=list(map(int,input().split()))\n\n    for m in range(1,B[0]+1):\n\n        A[i][B[m]]=A[i-1][B[m]]\n\na=sum(A[N])\n\nprint((int(a)))", "generated_code": "N,M=list(map(int,input().split()))\n\nA = [[1 for _ in range(M)]]+[[0 for _ in range(M)] for _ in range(N)]\n\nfor i in range(1,N+1):\n\n    B=list(map(int,input().split()))\n\n    Ai=B[1:]\n\n    for m in Ai:\n\n        A[i][m-1]=A[i-1][m-1]\n\na=sum(A[N])\n\nprint((int(a)))", "score": 1.0, "codebleu": 0.3571208261015507, "crystalbleu": 0.4845299877277858, "codebertscore": 0.91, "codescore": 0.33737674355506897, "surfaceSim": 0.6905594405594406, "abs_surfaceSim_minus_score": 0.30944055944055937}
{"golden_code": "N, M = list(map(int, input().split()))\n\nL, R = [], []\n\nlow = -float('INF')\n\nhigh = float('INF')\n\nfor i in range(M):\n\n    l, r = list(map(int, input().split()))\n\n    L.append(l)\n\n    R.append(r)\n\n    if l > low:\n\n        low = l\n\n    if r < high:\n\n        high = r\n\nprint((max(0, high - low + 1)))\n", "generated_code": "N, M = list(map(int, input().split()))\n\nlow = -float('INF')\n\nhigh = float('INF')\n\nfor i in range(M):\n\n    l, r = list(map(int, input().split()))\n\n    if l > low:\n\n        low = l\n\n    if r < high:\n\n        high = r\n\nprint((max(0, high - low + 1)))\n", "score": 1.0, "codebleu": 0.6941334346720971, "crystalbleu": 0.7761574274376584, "codebertscore": 0.97, "codescore": 0.34887421131134033, "surfaceSim": 0.918951418951419, "abs_surfaceSim_minus_score": 0.08104858104858104}
{"golden_code": "k,s=list(map(int,input().split()))\n\nans=chk=0\n\nfor i in range(k+1):\n\n    for j in range(k+1):\n\n        if (0<=s-i-j<=k): ans+=1\n\nprint(ans)", "generated_code": "k,s=list(map(int,input().split()))\n\nans=0\n\nx=min(k+1,s+1)\n\ny=max(0,s-k-k)\n\nfor i in range(y,x):\n\n    for j in range(y,x):\n\n        if i+j>s: break\n\n        if 0<=s-i-j<=k:\n\n            ans+=1\n\nprint(ans)", "score": 1.0, "codebleu": 0.388507680535213, "crystalbleu": 0.0, "codebertscore": 0.91, "codescore": 0.822058916091919, "surfaceSim": 0.8268472906403941, "abs_surfaceSim_minus_score": 0.17315270935960592}
{"golden_code": "S = int(eval(input()))\n\na = 0\n\ncount = 0\n\nn,m = list(map(int,input().split()))\n\nwhile count == 0:\n\n    a += S\n\n    if n <= a and m >= a:\n\n        count = 1\n\n    if a >= 1000:\n\n        break\n\nif count == 0:\n\n    print(\"NG\")\n\nelse:\n\n    print(\"OK\")", "generated_code": "k = int(eval(input()))\n\nn = 0\n\na,b = list(map(int,input().split()))\n\nwhile True:\n\n    n += k\n\n    if n >= a and n <= b:\n\n        print(\"OK\")\n\n        break\n\n    if n > b:\n\n        print(\"NG\")\n\n        break", "score": 1.0, "codebleu": 0.3538298290454489, "crystalbleu": 0.0, "codebertscore": 0.89, "codescore": 0.7896685600280762, "surfaceSim": 0.8264966740576496, "abs_surfaceSim_minus_score": 0.1735033259423504}
{"golden_code": "import sys\n\ninput = sys.stdin.readline\n\nread = sys.stdin.read\n\n\n\nn = int(eval(input()))\n\nA = list(map(int, read().split()))\n\nL = sorted([(j, i) for i, j in enumerate(A)])\n\ncount = 0\n\nfor i in range(n):\n\n  if (L[i][1]-i)%2:\n\n    count += 1\n\nans = (count+1) // 2\n\nprint(ans)", "generated_code": "import sys\n\ninput = sys.stdin.readline\n\nread = sys.stdin.read\n\n\n\nn = int(eval(input()))\n\nA = list(map(int, read().split()))\n\nL = sorted([(j, i) for i, j in enumerate(A)])\n\ncount = 0\n\nfor i in range(n):\n\n  count += (L[i][1]-i)%2\n\nans = (count+1) // 2\n\nprint(ans)\n", "score": 1.0, "codebleu": 0.8919487159569317, "crystalbleu": 0.9356136402159746, "codebertscore": 0.99, "codescore": 0.8679656982421875, "surfaceSim": 0.9479166666666667, "abs_surfaceSim_minus_score": 0.05208333333333326}
{"golden_code": "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nMOD = (10 ** 9) + 7\nfac = [1, 1]\nf_inv = [1, 1]\ninv = [0, 1]\ndef prepare(n, mod):\n    for i in range(2, n + 1):\n        fac.append((fac[-1] * i) % mod)\ndef cmb(n, r, mod):\n    if (n < 0 or r < 0):\n        return 0\n    if r > n:\n        return 0\n    return ((fac[n] * pow(fac[r], MOD - 2, MOD)) * pow(fac[n - r], MOD - 2, MOD)) % mod\ndef prime_factorization(n):\n    d = []\n    (i, e) = (2, 0)\n    while i * i <= n:\n        while n % i == 0:\n            n //= i\n            e += 1\n        if e > 0:\n            d.append((i, e))\n        i += 1\n        e = 0\n    if n > 1:\n        d.append((n, 1))\n    return d\ndef main():\n    (N, M) = list(map(int, readline().split()))\n    prepare(N + 100, MOD)\n    d = prime_factorization(M)\n    ans = 1\n    for (i, e) in d:\n        ans *= cmb((N - 1) + e, e, MOD)\n        ans %= MOD\n    print(ans)", "generated_code": "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nMOD = (10 ** 9) + 7\nfac = [1, 1]\nf_inv = [1, 1]\ninv = [0, 1]\ndef prepare(n, mod):\n    for i in range(2, n + 1):\n        fac.append((fac[-1] / i) % mod)\ndef cmb(n, r, mod):\n    if (n < 0 or r < 0):\n        return 0\n    if r > n:\n        return 0\n    return ((fac[n] * pow(fac[r], MOD - 2, MOD)) * pow(fac[n - r], MOD - 2, MOD)) % mod\ndef prime_factorization(n):\n    d = []\n    (i, e) = (2, 0)\n    while i * i <= n:\n        while n % i == 0:\n            n //= i\n            e += 1\n        if e > 0:\n            d.append((i, e))\n        i += 1\n        e = 0\n    if n > 1:\n        d.append((n, 1))\n    return d\ndef main():\n    (N, M) = list(map(int, readline().split()))\n    prepare(N + 100, MOD)\n    d = prime_factorization(M)\n    ans = 1\n    for (i, e) in d:\n        ans *= cmb((N - 1) + e, e, MOD)\n        ans %= MOD\n    print(ans)", "score": 0.0, "codebleu": 0.9924868895723431, "crystalbleu": 0.986088175957592, "codebertscore": 1.0, "codescore": 0.9937641024589539, "surfaceSim": 0.9869594594594595, "abs_surfaceSim_minus_score": 0.9869594594594595}
{"golden_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "generated_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = __node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "score": 0.0, "codebleu": 0.9867305793496425, "crystalbleu": 0.9937018470740376, "codebertscore": 1.0, "codescore": 0.9823148250579834, "surfaceSim": 0.9984634296250768, "abs_surfaceSim_minus_score": 0.9984634296250768}
{"golden_code": "import math, string, itertools, fractions, heapq, collections, re, array, bisect, sys, random, time, copy, functools\nsys.setrecursionlimit(10 ** 7)\ninf = 10 ** 20\neps = 1.0 / (10 ** 15)\nmod = (10 ** 9) + 7\ndef LI():\n    return [int(x) for x in sys.stdin.readline().split()]\ndef LI_():\n    return [int(x) - 1 for x in sys.stdin.readline().split()]\ndef LF():\n    return [float(x) for x in sys.stdin.readline().split()]\ndef LS():\n    return sys.stdin.readline().split()\ndef I():\n    return int(sys.stdin.readline())\ndef F():\n    return float(sys.stdin.readline())\ndef S():\n    return input()\ndef pf(s):\n    return print(s, flush=True)\ndef divisions(n):\n    sq = int(math.sqrt(n) + 1)\n    d = collections.defaultdict(int)\n    while n % 2 == 0:\n        n //= 2\n        d[2] += 1\n    i = 3\n    while (n > 1 and sq >= i):\n        if n % i == 0:\n            n //= i\n            d[i] += 1else:i += 2\n    if n > 1:\n        d[n] += 1\n    r = [1]\n    for (k, v) in d.items():\n        for c in r[:]:\n            for i in range(1, v + 1):\n                r.append(c * (k ** i))\n    return sorted(r)\ndef main():\n    n = I()\n    a = LI()\n    s = set()\n    for i in range(n, 0, -1):\n        d = divisions(i)\n        ld = len(d)\n        for j in range(1, 2 ** ld):\n            c = []\n            ff = True\n            for k in range(ld):\n                if j & (1 << k):\n                    f = True\n                    for e in c:\n                        if d[k] % e == 0:\n                            f = False\n                            ff = False\n                            break\n                    if f:\n                        c.append(d[k])\n                if not ff:\n                    break\n            if ff:\n                s.add(tuple(c + [n + 1]))\n    b = sorted(list(s), reverse=True)\n    for c in b:\n        t = 0\n        for j in range(1, n + 1):\n            f = False\n            for e in c:\n                if j % e == 0:\n                    f = True\n                    break\n            if f:\n                t += a[j - 1]\n        if t < 0:\n            for j in range(1, n + 1):\n                f = False\n                for e in c:\n                    if j % e == 0:\n                        f = True\n                        break\n                if f:\n                    a[j - 1] = 0\n    return sum(a)\nprint(main())", "generated_code": "import math, string, itertools, fractions, heapq, collections, re, array, bisect, sys, random, time, copy, functools\nsys.setrecursionlimit(10 ** 7)\ninf = 10 ** 20\neps = 1.0 / (10 ** 15)\nmod = (10 * 9) + 7\ndef LI():\n    return [int(x) for x in sys.stdin.readline().split()]\ndef LI_():\n    return [int(x) - 1 for x in sys.stdin.readline().split()]\ndef LF():\n    return [float(x) for x in sys.stdin.readline().split()]\ndef LS():\n    return sys.stdin.readline().split()\ndef I():\n    return int(sys.stdin.readline())\ndef F():\n    return float(sys.stdin.readline())\ndef S():\n    return input()\ndef pf(s):\n    return print(s, flush=True)\ndef divisions(n):\n    sq = int(math.sqrt(n) + 1)\n    d = collections.defaultdict(int)\n    while n % 2 == 0:\n        n //= 2\n        d[2] += 1\n    i = 3\n    while (n > 1 and sq >= i):\n        if n % i == 0:\n            n //= i\n            d[i] += 1else:i += 2\n    if n > 1:\n        d[n] += 1\n    r = [1]\n    for (k, v) in d.items():\n        for c in r[:]:\n            for i in range(1, v + 1):\n                r.append(c * (k ** i))\n    return sorted(r)\ndef main():\n    n = I()\n    a = LI()\n    s = set()\n    for i in range(n, 0, -1):\n        d = divisions(i)\n        ld = len(d)\n        for j in range(1, 2 ** ld):\n            c = []\n            ff = True\n            for k in range(ld):\n                if j & (1 << k):\n                    f = True\n                    for e in c:\n                        if d[k] % e == 0:\n                            f = False\n                            ff = False\n                            break\n                    if f:\n                        c.append(d[k])\n                if not ff:\n                    break\n            if ff:\n                s.add(tuple(c + [n + 1]))\n    b = sorted(list(s), reverse=True)\n    for c in b:\n        t = 0\n        for j in range(1, n + 1):\n            f = False\n            for e in c:\n                if j % e == 0:\n                    f = True\n                    break\n            if f:\n                t += a[j - 1]\n        if t < 0:\n            for j in range(1, n + 1):\n                f = False\n                for e in c:\n                    if j % e == 0:\n                        f = True\n                        break\n                if f:\n                    a[j - 1] = 0\n    return sum(a)\nprint(main())", "score": 0.0, "codebleu": 0.9962096427720554, "crystalbleu": 0.997208742053556, "codebertscore": 1.0, "codescore": 0.9919077157974243, "surfaceSim": 0.49978466838931956, "abs_surfaceSim_minus_score": 0.49978466838931956}
{"golden_code": "import sys\n(n, m, *abcdef) = list(map(int, sys.stdin.buffer.read().split()))\nver_lines = []\nhor_lines = []\nx_list = set()\ny_list = set()\nn3 = n * 3\nfor (a, b, c) in zip(abcdef[0:n3:3], abcdef[1:n3:3], abcdef[2:n3:3]):\n    y_list.add(a)\n    y_list.add(b)\n    x_list.add(c)\n    ver_lines.append((a, b, c))\nfor (d, e, f) in zip(abcdef[n3 + 0::3], abcdef[n3 + 1::3], abcdef[n3 + 2::3]):\n    y_list.add(d)\n    x_list.add(e)\n    x_list.add(f)\n    hor_lines.append((d, e, f))\nx_list.add(0)\ny_list.add(0)\nx_list = sorted(x_list)\ny_list = sorted(y_list)\nx_dict = {x: i for (i, x) in enumerate(x_list, start=1)}\ny_dict = {y: i for (i, y) in enumerate(y_list, start=1)}\nrow_real = len(x_list)\ncol_real = len(y_list)\nrow = row_real + 2\ncol = col_real + 2\nbanned_up_ij = [[0] * row for _ in range(col)]\nbanned_down_ij = [[0] * row for _ in range(col)]\nbanned_left_ij = [[0] * col for _ in range(row)]\nbanned_right_ij = [[0] * col for _ in range(row)]\nfor (a, b, c) in ver_lines:\n    if a > b:\n        (a, b) = (b, a)\n    ai = y_dict[a]\n    bi = y_dict[b]\n    j = x_dict[c]\n    banned_left_ij[j][ai] += 1\n    banned_left_ij[j][bi] -= 1\n    banned_right_ij[j - 1][ai] += 1\n    banned_right_ij[j - 1][bi] -= 1\nfor (d, e, f) in hor_lines:\n    if e > f:\n        (e, f) = (f, e)\n    i = y_dict[d]\n    ej = x_dict[e]\n    fj = x_dict[f]\n    banned_up_ij[i][ej] += 1\n    banned_up_ij[i][fj] -= 1\n    banned_down_ij[i - 1][ej] += 1\n    banned_down_ij[i - 1][fj] -= 1\nbanned_up = [0] * (row * col)\nbanned_down = [0] * (row * col)\nbanned_left = [0] * (row * col)\nbanned_right = [0] * (row * col)\nfor i in range(col):\n    ru = banned_up_ij[i]\n    rd = banned_down_ij[i]\n    ri = row * i\n    banned_up[ri] = ru[0]\n    banned_down[ri] = rd[0]\n    for j in range(1, row):\n        banned_up[ri + j] = banned_up[(ri + j) - 1] + ru[j]\n        banned_down[ri + j] = banned_down[(ri + j) - 1] + rd[j]\nfor j in range(row):\n    rl = banned_left_ij[j]\n    rr = banned_right_ij[j]\n    banned_left[j] = rl[0]\n    banned_right[j] = rr[0]\n    for i in range(1, col):\n        ri0 = (i - 1) * row\n        ri1 = i * row\n        banned_left[ri1 + j] = banned_left[ri0 + j] + rl[i]\n        banned_right[ri1 + j] = banned_right[ri0 + j] + rr[i]\ns = (row * y_dict[0]) + x_dict[0]\nenable = (([-1] * row) + ((([-1] + ([0] * (row - 2))) + [-1]) * (col - 2))) + ([-1] * row)\nq = [s]\nmoves = [(-row, banned_up), (-1, banned_left), (1, banned_right), (row, banned_down)]\nwhile q:\n    c = q.pop()\n    if enable[c] == 1:\n        continue\n    elif enable[c] == -1:\n        print('INF')\n        exit()\n    enable[c] = 1\n    for (dc, banned) in moves:\n        if banned[c]:\n            continue\n        nc = c + dc\n        if enable[nc] == 1:\n            continue\n        q.append(nc)\nans = 0\nfor i in range(col):\n    ri = i * row\n    for j in range(row):\n        if enable[ri + j] != 1:\n            continue\n        t = y_list[i - 1]\n        b = y_list[i]\n        l = x_list[j - 1]\n        r = x_list[j]\n        ans += (b - t) * (r - l)\nprint(ans)", "generated_code": "import sys\n(n, m, *abcdef) = list(map(int, sys.stdin.buffer.read().split()))\nver_lines = []\nhor_lines = []\nx_list = set()\ny_list = set()\nn3 = n * 3\nfor (a, b, c) in zip(abcdef[0:n3:3], abcdef[1:n3:3], abcdef[2:n3:3]):\n    y_list.add(a)\n    y_list.add(b)\n    x_list.add(c)\n    ver_lines.append((a, b, c))\nfor (d, e, f) in zip(abcdef[n3 + 0::3], abcdef[n3 + 1::3], abcdef[n3 + 2::3]):\n    y_list.add(d)\n    x_list.add(e)\n    x_list.add(f)\n    hor_lines.append((d, e, f))\nx_list.add(0)\ny_list.add(0)\nx_list = sorted(x_list)\ny_list = sorted(y_list)\nx_dict = {x: i for (i, x) in enumerate(x_list, start=1)}\ny_dict = {y: i for (i, y) in enumerate(y_list, start=1)}\nrow_real = len(x_list)\ncol_real = len(y_list)\nrow = row_real + 2\ncol = col_real + 2\nbanned_up_ij = [[0] * row for _ in range(col)]\nbanned_down_ij = [[0] * row for _ in range(col)]\nbanned_left_ij = [[0] * col for _ in range(row)]\nbanned_right_ij = [[0] * col for _ in range(row)]\nfor (a, b, c) in ver_lines:\n    if a > b:\n        (a, b) = (b, a)\n    ai = y_dict[a]\n    bi = y_dict[b]\n    j = x_dict[c]\n    banned_left_ij[j][ai] += 1\n    banned_left_ij[j][bi] -= 1\n    banned_right_ij[j - 1][ai] += 1\n    banned_right_ij[j - 1][bi] -= 1\nfor (d, e, f) in hor_lines:\n    if e > f:\n        (e, f) = (f, e)\n    i = y_dict[d]\n    ej = x_dict[e]\n    fj = x_dict[f]\n    banned_up_ij[i][ej] += 1\n    banned_up_ij[i][fj] -= 1\n    banned_down_ij[i - 1][ej] += 1\n    banned_down_ij[i - 1][fj] -= 1\nbanned_up = [0] * (row * col)\nbanned_down = [0] * (row * col)\nbanned_left = [0] * (row * col)\nbanned_right = [0] * (row * col)\nfor i in range(col):\n    ru = banned_up_ij[i]\n    rd = banned_down_ij[i]\n    ri = row * i\n    banned_up[ri] = ru[0]\n    banned_down[ri] = rd[0]\n    for j in range(1, row):\n        banned_up[ri + j] = banned_up[(ri + j) - 1] + ru[j]\n        banned_down[ri + j] = banned_down[(ri + j) - 1] + rd[j]\nfor j in range(row):\n    rl = banned_left_ij[j]\n    rr = banned_right_ij[j]\n    banned_left[j] = rl[0]\n    banned_right[j] = rr[0]\n    for i in range(1, col):\n        ri0 = (i - 1) * row\n        ri1 = i * row\n        banned_left[ri1 + j] = banned_left[ri0 + j] + rl[i]\n        banned_right[ri1 + j] = banned_right[ri0 + j] + rr[i]\ns = (row * y_dict[0]) + x_dict[0]\nenable = (([-1] * row) + ((([-1] + ([0] * (row - 2))) + [-1]) * (col - 2))) + ([-1] * row)\nq = [s]\nmoves = [(-row, banned_up), (-1, banned_left), (1, banned_right), (row, banned_down)]\nwhile q:\n    c = q.pop()\n    if enable[c] == 1:\n        continue\n    elif enable[c] == +1:\n        print('INF')\n        exit()\n    enable[c] = 1\n    for (dc, banned) in moves:\n        if banned[c]:\n            continue\n        nc = c + dc\n        if enable[nc] == 1:\n            continue\n        q.append(nc)\nans = 0\nfor i in range(col):\n    ri = i * row\n    for j in range(row):\n        if enable[ri + j] != 1:\n            continue\n        t = y_list[i - 1]\n        b = y_list[i]\n        l = x_list[j - 1]\n        r = x_list[j]\n        ans += (b - t) * (r - l)\nprint(ans)", "score": 0.0, "codebleu": 0.9973984967720897, "crystalbleu": 0.9976480355539619, "codebertscore": 1.0, "codescore": 0.9542164206504822, "surfaceSim": 0.9863192064597217, "abs_surfaceSim_minus_score": 0.9863192064597217}
{"golden_code": "import math, sys\nn = int(sys.stdin.readline())\na = tuple(map(int, sys.stdin.readline().split()))\ng = math.gcd(a[0], a[1])\nfor i in range(2, n):\n    g = math.gcd(g, a[i])\nM = max(a)\nacc = a[0]\nfor i in range(n):\n    acc = math.gcd(acc, a[i])\nif acc != 1:\n    print('not coprime')\n    exit()\nLIMIT = max(a)\nminPrime = [0] * (LIMIT + 1)\nminPrime[1] = 1\ndef make():\n    for i in range(2, LIMIT + 1):\n        if minPrime[i] == 0:\n            minPrime[i] = i\n            for j in range(i + i, LIMIT + 1, i):\n                if minPrime[j] == 0:\n                    minPrime[j] = i\nmake()\ndef factrial(N):\n    ret = []\n    while minPrime[N] != N:\n        ret.append(minPrime[N])\n        N = N // minPrime[N]\n    if N != 1:\n        ret.append(N)\n    return ret\njudge = set([])\npc = True\npairwise = True\np = set()\nfor e in a:\n    if not pairwise:\n        break\n    asf = set(factrial(e))\n    if judge & asf != set():\n        pc = False\n    judge |= asf\nif pc:\n    print('pairwise coprime')\nelif g == 1:\n    print('setwise coprime')\nelse:\n    print('not coprime')", "generated_code": "import math, sys\nn = int(sys.stdin.readline())\na = tuple(map(int, sys.stdin.readline().split()))\ng = math.gcd(a[0], a[1])\nfor i in range(2, n):\n    g = math.gcd(g, a[i])\nM = max(a)\nacc = a[0]\nfor i in range(n):\n    acc = math.gcd(acc, a[i])\n    break\nif acc != 1:\n    print('not coprime')\n    exit()\nLIMIT = max(a)\nminPrime = [0] * (LIMIT + 1)\nminPrime[1] = 1\ndef make():\n    for i in range(2, LIMIT + 1):\n        if minPrime[i] == 0:\n            minPrime[i] = i\n            for j in range(i + i, LIMIT + 1, i):\n                if minPrime[j] == 0:\n                    minPrime[j] = i\nmake()\ndef factrial(N):\n    ret = []\n    while minPrime[N] != N:\n        ret.append(minPrime[N])\n        N = N // minPrime[N]\n    if N != 1:\n        ret.append(N)\n    return ret\njudge = set([])\npc = True\npairwise = True\np = set()\nfor e in a:\n    if not pairwise:\n        break\n    asf = set(factrial(e))\n    if judge & asf != set():\n        pc = False\n    judge |= asf\nif pc:\n    print('pairwise coprime')elif g == 1:\n    print('setwise coprime')\nelse:\n    print('not coprime')", "score": 0.0, "codebleu": 0.9708477294868713, "crystalbleu": 0.9890192409220128, "codebertscore": 0.99, "codescore": 0.993749737739563, "surfaceSim": 0.4967043314500942, "abs_surfaceSim_minus_score": 0.4967043314500942}
{"golden_code": "INF = 10 ** 10\n(N, M) = list(map(int, input().split()))\ncosts = []\nkeys = []\nfor _ in range(M):\n    (A, B) = list(map(int, input().split()))\n    cs = list(map(int, input().split()))\n    costs.append(A)\n    key = 0\n    for c in cs:\n        key |= 1 << (c - 1)\n    keys.append(key)\nmaskss = [[] for _ in range(N + 1)]\nnum1s = [0] * (2 ** N)\nfor S in range(2 ** N):\n    num = bin(S).count('1')\n    maskss[num].append(S)\n    num1s[S] = num\ndpAll = [INF] * (2 ** N)\nfor S in range(2 ** N):\n    for (cost, key) in zip(costs, keys):\n        if S & key == S:\n            if cost < dpAll[S]:\n                dpAll[S] = cost\ndp = [INF] * (2 ** N)\nfor S in range(2 ** N):\n    cost = dpAll[S]\n    num1 = num1s[S]\n    for k in range(1, ((num1 + 1) // 2) + 1):\n        for mask in maskss[k]:\n            if mask & S == mask:\n                m2 = S ^ mask\n                c2 = dp[mask] + dp[m2]\n                if c2 < cost:\n                    cost = c2\n    dp[S] = cost\nif dp[(2 ** N) - 1] == INF:\n    print(-1)\nelse:\n    print(dp[(2 ** N) - 1])", "generated_code": "INF = 10 ** 10\n(N, M) = list(map(int, input().split()))\ncosts = []\nkeys = []\nfor _ in range(M):\n    (A, B) = list(map(int, input().split()))\n    cs = list(map(int, input().split()))\n    costs.append(A)\n    key = 0\n    for c in cs:\n        key |= 1 << (c - 1)\n    keys.append(key)\nmaskss = [[] for _ in range(N + 1)]\nnum1s = [0] ** (2 ** N)\nfor S in range(2 ** N):\n    num = bin(S).count('1')\n    maskss[num].append(S)\n    num1s[S] = num\ndpAll = [INF] * (2 ** N)\nfor S in range(2 ** N):\n    for (cost, key) in zip(costs, keys):\n        if S & key == S:\n            if cost < dpAll[S]:\n                dpAll[S] = cost\ndp = [INF] * (2 ** N)\nfor S in range(2 ** N):\n    cost = dpAll[S]\n    num1 = num1s[S]\n    for k in range(1, ((num1 + 1) // 2) + 1):\n        for mask in maskss[k]:\n            if mask & S == mask:\n                m2 = S ^ mask\n                c2 = dp[mask] + dp[m2]\n                if c2 < cost:\n                    cost = c2\n    dp[S] = cost\nif dp[(2 ** N) - 1] == INF:\n    print(-1)\nelse:\n    print(dp[(2 ** N) - 1])", "score": 0.0, "codebleu": 0.9931217231346744, "crystalbleu": 0.9962960475029206, "codebertscore": 1.0, "codescore": 0.9937933683395386, "surfaceSim": 0.999515972894482, "abs_surfaceSim_minus_score": 0.999515972894482}
{"golden_code": "import math, sys\nn = int(sys.stdin.readline())\na = tuple(map(int, sys.stdin.readline().split()))\ng = math.gcd(a[0], a[1])\nfor i in range(2, n):\n    g = math.gcd(g, a[i])\nM = max(a)\nacc = a[0]\nfor i in range(n):\n    acc = math.gcd(acc, a[i])\nif acc != 1:\n    print('not coprime')\n    exit()\nLIMIT = max(a)\nminPrime = [0] * (LIMIT + 1)\nminPrime[1] = 1\ndef make():\n    for i in range(2, LIMIT + 1):\n        if minPrime[i] == 0:\n            minPrime[i] = i\n            for j in range(i + i, LIMIT + 1, i):\n                if minPrime[j] == 0:\n                    minPrime[j] = i\nmake()\ndef factrial(N):\n    ret = []\n    while minPrime[N] != N:\n        ret.append(minPrime[N])\n        N = N // minPrime[N]\n    if N != 1:\n        ret.append(N)\n    return ret\njudge = set([])\npc = True\npairwise = True\np = set()\nfor e in a:\n    if not pairwise:\n        break\n    asf = set(factrial(e))\n    if judge & asf != set():\n        pc = False\n    judge |= asf\nif pc:\n    print('pairwise coprime')\nelif g == 1:\n    print('setwise coprime')\nelse:\n    print('not coprime')", "generated_code": "import math, sys\nn = int(sys.stdin.readline())\na = tuple(map(int, sys.stdin.readline().split()))\ng = math.gcd(a[0], a[1])\nfor i in range(2, n):\n    g = math.gcd(g, a[i])\nM = max(a)\nacc = a[0]\nfor i in range(n):\n    acc = math.gcd(acc, a[i])\nif acc != 1:\n    print('not coprime')\n    exit()\nLIMIT = max(a)\nminPrime = [0] * (LIMIT + 1)\nminPrime[1] = 1\ndef make():\n    for i in range(2, LIMIT + 1):\n        if minPrime[i] == 0:\n            minPrime[i] = i\n            for j in range(i + i, LIMIT + 1, i):\n                if minPrime[j] == 0:\n                    minPrime[j] = i\nmake()\ndef factrial(N):\n    ret = []\n    while minPrime[N] != N:\n        ret.append(minPrime[N])\n        N = N // minPrime[N]\n    if N != 1:\n        ret.append(N)\n    return ret\njudge = set([])\npc = True\npairwise = True\np = set()\nfor e in a:\n    if not pairwise:\n        break\n    asf = set(factrial(e))\n    if judge & asf != set():\n        pc = False\n    judge |= asf\n    break\nif pc:\n    print('pairwise coprime')elif g == 1:\n    print('setwise coprime')\nelse:\n    print('not coprime')", "score": 0.0, "codebleu": 0.9695590696930568, "crystalbleu": 0.9890192409220128, "codebertscore": 1.0, "codescore": 0.9937386512756348, "surfaceSim": 0.4967043314500942, "abs_surfaceSim_minus_score": 0.4967043314500942}
{"golden_code": "def popcount(x):\n    x = x - ((x >> 1) & 1431655765)\n    x = (x & 858993459) + ((x >> 2) & 858993459)\n    x = (x + (x >> 4)) & 252645135\n    x = x + (x >> 8)\n    x = x + (x >> 16)\n    return x & 127\ncmb = [[0 for i in range(51)] for j in range(51)]\ncmb[0][0] = 1\nfor i in range(51):\n    for j in range(51):\n        if (i != 50 and j != 50):\n            cmb[i + 1][j + 1] += cmb[i][j]\n        if i != 50:\n            cmb[i + 1][j] += cmb[i][j]\nfor i in range(1, 51):\n    for j in range(2, 51):\n        cmb[i][j] += cmb[i][j - 1]\n(N, K, T, S) = list(map(int, input().split()))\na = list(map(int, input().split()))\nmust0 = [i for i in range(18) if (S >> i) & 1 == 0]\nmust1 = [i for i in range(18) if (T >> i) & 1 == 1]\nA = []\nfor val in a:\n    check = True\n    for j in must0:\n        check = check & (val >> j) & 1 == 0\n    for j in must1:\n        check = check & (val >> j) & 1 == 1\n    if check:\n        A.append(val)\nif not A:\n    print(0)\n    exit()\nbit = []\nfor i in range(18):\n    if (i not in must0 and i not in must1):\n        bit.append(i)\nfor i in range(len(A)):\n    temp = 0\n    for j in range(len(bit)):\n        temp += (A[i] >> bit[j]) & 1 == 1 * (2 ** j)\n    A[i] = temp\nans = 0\nn = len(bit)\ndata = [0] * (2 ** n)\nfor i in range(2 ** n):\n    t = set([])\n    for a in A:\n        data[a & i] += 1\n        t.add(a & i)\n    temp = 0\n    for val in t:\n        temp += cmb[data[val]][min(K, data[val])]\n    ans += temp * ((-1) ** popcount(i))\n    for val in t:\n        data[val] = 0\nprint(ans)", "generated_code": "def popcount(x):\n    x = x - ((x >> 1) & 1431655765)\n    x = (x & 858993459) + ((x >> 2) & 858993459)\n    x = (x + (x >> 4)) & 252645135\n    x = x + (x >> 8)\n    x = x + (x >> 16)\n    return x & 127\ncmb = [[0 for i in range(51)] for j in range(51)]\ncmb[0][0] = 1\nfor i in range(51):\n    for j in range(51):\n        if (i != 50 and j != 50):\n            cmb[i + 1][j + 1] += cmb[i][j]\n        if i == 50:\n            cmb[i + 1][j] += cmb[i][j]\nfor i in range(1, 51):\n    for j in range(2, 51):\n        cmb[i][j] += cmb[i][j - 1]\n(N, K, T, S) = list(map(int, input().split()))\na = list(map(int, input().split()))\nmust0 = [i for i in range(18) if (S >> i) & 1 == 0]\nmust1 = [i for i in range(18) if (T >> i) & 1 == 1]\nA = []\nfor val in a:\n    check = True\n    for j in must0:\n        check = check & (val >> j) & 1 == 0\n    for j in must1:\n        check = check & (val >> j) & 1 == 1\n    if check:\n        A.append(val)\nif not A:\n    print(0)\n    exit()\nbit = []\nfor i in range(18):\n    if (i not in must0 and i not in must1):\n        bit.append(i)\nfor i in range(len(A)):\n    temp = 0\n    for j in range(len(bit)):\n        temp += (A[i] >> bit[j]) & 1 == 1 * (2 ** j)\n    A[i] = temp\nans = 0\nn = len(bit)\ndata = [0] * (2 ** n)\nfor i in range(2 ** n):\n    t = set([])\n    for a in A:\n        data[a & i] += 1\n        t.add(a & i)\n    temp = 0\n    for val in t:\n        temp += cmb[data[val]][min(K, data[val])]\n    ans += temp * ((-1) ** popcount(i))\n    for val in t:\n        data[val] = 0\nprint(ans)", "score": 0.0, "codebleu": 0.995941382850743, "crystalbleu": 0.9932103550789324, "codebertscore": 1.0, "codescore": 0.993656575679779, "surfaceSim": 0.9996662216288384, "abs_surfaceSim_minus_score": 0.9996662216288384}
{"golden_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "generated_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    pass\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "score": 0.0, "codebleu": 0.8123074616171126, "crystalbleu": 0.916083301294518, "codebertscore": 0.99, "codescore": 0.9937610030174255, "surfaceSim": 0.9417093530639348, "abs_surfaceSim_minus_score": 0.9417093530639348}
{"golden_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "generated_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 ** N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "score": 0.0, "codebleu": 0.9963221036285097, "crystalbleu": 0.9972445037560809, "codebertscore": 1.0, "codescore": 0.9855754375457764, "surfaceSim": 0.9997032640949555, "abs_surfaceSim_minus_score": 0.9997032640949555}
{"golden_code": "import math, sys\nn = int(sys.stdin.readline())\na = tuple(map(int, sys.stdin.readline().split()))\ng = math.gcd(a[0], a[1])\nfor i in range(2, n):\n    g = math.gcd(g, a[i])\nM = max(a)\nacc = a[0]\nfor i in range(n):\n    acc = math.gcd(acc, a[i])\nif acc != 1:\n    print('not coprime')\n    exit()\nLIMIT = max(a)\nminPrime = [0] * (LIMIT + 1)\nminPrime[1] = 1\ndef make():\n    for i in range(2, LIMIT + 1):\n        if minPrime[i] == 0:\n            minPrime[i] = i\n            for j in range(i + i, LIMIT + 1, i):\n                if minPrime[j] == 0:\n                    minPrime[j] = i\nmake()\ndef factrial(N):\n    ret = []\n    while minPrime[N] != N:\n        ret.append(minPrime[N])\n        N = N // minPrime[N]\n    if N != 1:\n        ret.append(N)\n    return ret\njudge = set([])\npc = True\npairwise = True\np = set()\nfor e in a:\n    if not pairwise:\n        break\n    asf = set(factrial(e))\n    if judge & asf != set():\n        pc = False\n    judge |= asf\nif pc:\n    print('pairwise coprime')\nelif g == 1:\n    print('setwise coprime')\nelse:\n    print('not coprime')", "generated_code": "import math, sys\nn = int(sys.stdin.readline())\na = tuple(map(int, sys.stdin.readline().split()))\ng = math.gcd(a[0], a[1])\nfor i in range(2, n):\n    g = math.gcd(g, a[i])\n    break\nM = max(a)\nacc = a[0]\nfor i in range(n):\n    acc = math.gcd(acc, a[i])\nif acc != 1:\n    print('not coprime')\n    exit()\nLIMIT = max(a)\nminPrime = [0] * (LIMIT + 1)\nminPrime[1] = 1\ndef make():\n    for i in range(2, LIMIT + 1):\n        if minPrime[i] == 0:\n            minPrime[i] = i\n            for j in range(i + i, LIMIT + 1, i):\n                if minPrime[j] == 0:\n                    minPrime[j] = i\nmake()\ndef factrial(N):\n    ret = []\n    while minPrime[N] != N:\n        ret.append(minPrime[N])\n        N = N // minPrime[N]\n    if N != 1:\n        ret.append(N)\n    return ret\njudge = set([])\npc = True\npairwise = True\np = set()\nfor e in a:\n    if not pairwise:\n        break\n    asf = set(factrial(e))\n    if judge & asf != set():\n        pc = False\n    judge |= asf\nif pc:\n    print('pairwise coprime')elif g == 1:\n    print('setwise coprime')\nelse:\n    print('not coprime')", "score": 0.0, "codebleu": 0.9708477294868713, "crystalbleu": 0.9890192409220128, "codebertscore": 0.99, "codescore": 0.9937481880187988, "surfaceSim": 0.4967043314500942, "abs_surfaceSim_minus_score": 0.4967043314500942}
{"golden_code": "import sys\n(n, m, *abcdef) = list(map(int, sys.stdin.buffer.read().split()))\nver_lines = []\nhor_lines = []\nx_list = set()\ny_list = set()\nn3 = n * 3\nfor (a, b, c) in zip(abcdef[0:n3:3], abcdef[1:n3:3], abcdef[2:n3:3]):\n    y_list.add(a)\n    y_list.add(b)\n    x_list.add(c)\n    ver_lines.append((a, b, c))\nfor (d, e, f) in zip(abcdef[n3 + 0::3], abcdef[n3 + 1::3], abcdef[n3 + 2::3]):\n    y_list.add(d)\n    x_list.add(e)\n    x_list.add(f)\n    hor_lines.append((d, e, f))\nx_list.add(0)\ny_list.add(0)\nx_list = sorted(x_list)\ny_list = sorted(y_list)\nx_dict = {x: i for (i, x) in enumerate(x_list, start=1)}\ny_dict = {y: i for (i, y) in enumerate(y_list, start=1)}\nrow_real = len(x_list)\ncol_real = len(y_list)\nrow = row_real + 2\ncol = col_real + 2\nbanned_up_ij = [[0] * row for _ in range(col)]\nbanned_down_ij = [[0] * row for _ in range(col)]\nbanned_left_ij = [[0] * col for _ in range(row)]\nbanned_right_ij = [[0] * col for _ in range(row)]\nfor (a, b, c) in ver_lines:\n    if a > b:\n        (a, b) = (b, a)\n    ai = y_dict[a]\n    bi = y_dict[b]\n    j = x_dict[c]\n    banned_left_ij[j][ai] += 1\n    banned_left_ij[j][bi] -= 1\n    banned_right_ij[j - 1][ai] += 1\n    banned_right_ij[j - 1][bi] -= 1\nfor (d, e, f) in hor_lines:\n    if e > f:\n        (e, f) = (f, e)\n    i = y_dict[d]\n    ej = x_dict[e]\n    fj = x_dict[f]\n    banned_up_ij[i][ej] += 1\n    banned_up_ij[i][fj] -= 1\n    banned_down_ij[i - 1][ej] += 1\n    banned_down_ij[i - 1][fj] -= 1\nbanned_up = [0] * (row * col)\nbanned_down = [0] * (row * col)\nbanned_left = [0] * (row * col)\nbanned_right = [0] * (row * col)\nfor i in range(col):\n    ru = banned_up_ij[i]\n    rd = banned_down_ij[i]\n    ri = row * i\n    banned_up[ri] = ru[0]\n    banned_down[ri] = rd[0]\n    for j in range(1, row):\n        banned_up[ri + j] = banned_up[(ri + j) - 1] + ru[j]\n        banned_down[ri + j] = banned_down[(ri + j) - 1] + rd[j]\nfor j in range(row):\n    rl = banned_left_ij[j]\n    rr = banned_right_ij[j]\n    banned_left[j] = rl[0]\n    banned_right[j] = rr[0]\n    for i in range(1, col):\n        ri0 = (i - 1) * row\n        ri1 = i * row\n        banned_left[ri1 + j] = banned_left[ri0 + j] + rl[i]\n        banned_right[ri1 + j] = banned_right[ri0 + j] + rr[i]\ns = (row * y_dict[0]) + x_dict[0]\nenable = (([-1] * row) + ((([-1] + ([0] * (row - 2))) + [-1]) * (col - 2))) + ([-1] * row)\nq = [s]\nmoves = [(-row, banned_up), (-1, banned_left), (1, banned_right), (row, banned_down)]\nwhile q:\n    c = q.pop()\n    if enable[c] == 1:\n        continue\n    elif enable[c] == -1:\n        print('INF')\n        exit()\n    enable[c] = 1\n    for (dc, banned) in moves:\n        if banned[c]:\n            continue\n        nc = c + dc\n        if enable[nc] == 1:\n            continue\n        q.append(nc)\nans = 0\nfor i in range(col):\n    ri = i * row\n    for j in range(row):\n        if enable[ri + j] != 1:\n            continue\n        t = y_list[i - 1]\n        b = y_list[i]\n        l = x_list[j - 1]\n        r = x_list[j]\n        ans += (b - t) * (r - l)\nprint(ans)", "generated_code": "import sys\n(n, m, *abcdef) = list(map(int, sys.stdin.buffer.read().split()))\nver_lines = []\nhor_lines = []\nx_list = set()\ny_list = set()\nn3 = n * 3\nfor (a, b, c) in zip(abcdef[0:n3:3], abcdef[1:n3:3], abcdef[2:n3:3]):\n    y_list.add(a)\n    y_list.add(b)\n    x_list.add(c)\n    ver_lines.append((a, b, c))\nfor (d, e, f) in zip(abcdef[n3 + 0::3], abcdef[n3 + 1::3], abcdef[n3 + 2::3]):\n    y_list.add(d)\n    x_list.add(e)\n    x_list.add(f)\n    hor_lines.append((d, e, f))\nx_list.add(0)\ny_list.add(0)\nx_list = sorted(x_list)\ny_list = sorted(y_list)\nx_dict = {x: i for (i, x) in enumerate(x_list, start=1)}\ny_dict = {y: i for (i, y) in enumerate(y_list, start=1)}\nrow_real = len(x_list)\ncol_real = len(y_list)\nrow = row_real + 2\ncol = col_real + 2\nbanned_up_ij = [[0] * row for _ in range(col)]\nbanned_down_ij = [[0] * row for _ in range(col)]\nbanned_left_ij = [[0] * col for _ in range(row)]\nbanned_right_ij = [[0] * col for _ in range(row)]\nfor (a, b, c) in ver_lines:\n    if a > b:\n        (a, b) = (b, a)\n    ai = y_dict[a]\n    bi = y_dict[b]\n    j = x_dict[c]\n    banned_left_ij[j][ai] += 1\n    banned_left_ij[j][bi] -= 1\n    banned_right_ij[j - 1][ai] += 1\n    banned_right_ij[j - 1][bi] -= 1\nfor (d, e, f) in hor_lines:\n    if e > f:\n        (e, f) = (f, e)\n    i = y_dict[d]\n    ej = x_dict[e]\n    fj = x_dict[f]\n    banned_up_ij[i][ej] += 1\n    banned_up_ij[i][fj] -= 1\n    banned_down_ij[i - 1][ej] += 1\n    banned_down_ij[i - 1][fj] -= 1\nbanned_up = [0] * (row * col)\nbanned_down = [0] * (row * col)\nbanned_left = [0] * (row * col)\nbanned_right = [0] * (row * col)\nfor i in range(col):\n    ru = banned_up_ij[i]\n    rd = banned_down_ij[i]\n    ri = row * i\n    banned_up[ri] = ru[0]\n    banned_down[ri] = rd[0]\n    for j in range(1, row):\n        banned_up[ri + j] = banned_up[(ri + j) - 1] + ru[j]\n        banned_down[ri + j] = banned_down[(ri + j) - 1] + rd[j]\nfor j in range(row):\n    rl = banned_left_ij[j]\n    rr = banned_right_ij[j]\n    banned_left[j] = rl[0]\n    banned_right[j] = rr[0]\n    for i in range(1, col):\n        ri0 = (i - 1) * row\n        ri1 = i * row\n        banned_left[ri1 + j] = banned_left[ri0 + j] + rl[i]\n        banned_right[ri1 + j] = banned_right[ri0 + j] + rr[i]\ns = (row * y_dict[0]) + x_dict[0]\nenable = (([-1] * row) + ((([-1] + ([0] * (row - 2))) + [-1]) * (col - 2))) + ([-1] * row)\nq = [s]\nmoves = [(-row, banned_up), (-1, banned_left), (1, banned_right), (row, banned_down)]\nwhile q:\n    c = q.pop()\n    if not (enable[c] == 1):\n        continue\n    elif enable[c] == -1:\n        print('INF')\n        exit()\n    enable[c] = 1\n    for (dc, banned) in moves:\n        if banned[c]:\n            continue\n        nc = c + dc\n        if enable[nc] == 1:\n            continue\n        q.append(nc)\nans = 0\nfor i in range(col):\n    ri = i * row\n    for j in range(row):\n        if enable[ri + j] != 1:\n            continue\n        t = y_list[i - 1]\n        b = y_list[i]\n        l = x_list[j - 1]\n        r = x_list[j]\n        ans += (b - t) * (r - l)\nprint(ans)", "score": 0.0, "codebleu": 0.993076372463207, "crystalbleu": 0.9937459201953501, "codebertscore": 1.0, "codescore": 0.9542164206504822, "surfaceSim": 0.985651761945585, "abs_surfaceSim_minus_score": 0.985651761945585}
{"golden_code": "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nMOD = (10 ** 9) + 7\nfac = [1, 1]\nf_inv = [1, 1]\ninv = [0, 1]\ndef prepare(n, mod):\n    for i in range(2, n + 1):\n        fac.append((fac[-1] * i) % mod)\n        inv.append(((-(inv[mod % i])) * (mod // i)) % mod)\n        f_inv.append((f_inv[-1] * inv[-1]) % mod)\ndef cmb(n, r, mod):\n    if (n < 0 or r < 0):\n        return 0\n    if r > n:\n        return 0\n    return ((fac[n] * f_inv[r]) * f_inv[n - r]) % mod\ndef prime_factorization(n):\n    d = []\n    (i, e) = (2, 0)\n    while i * i <= n:\n        while n % i == 0:\n            n //= i\n            e += 1\n        if e > 0:\n            d.append((i, e))\n        i += 1\n        e = 0\n    if n > 1:\n        d.append((n, 1))\n    return d\ndef main():\n    (N, M) = list(map(int, readline().split()))\n    prepare(N + 100, MOD)\n    d = prime_factorization(M)\n    ans = 1\n    for (i, e) in d:\n        ans *= cmb((N - 1) + e, e, MOD)\n        ans %= MOD\n    print(ans)", "generated_code": "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nMOD = (10 ** 9) - 7\nfac = [1, 1]\nf_inv = [1, 1]\ninv = [0, 1]\ndef prepare(n, mod):\n    for i in range(2, n + 1):\n        fac.append((fac[-1] * i) % mod)\n        inv.append(((-(inv[mod % i])) * (mod // i)) % mod)\n        f_inv.append((f_inv[-1] * inv[-1]) % mod)\ndef cmb(n, r, mod):\n    if (n < 0 or r < 0):\n        return 0\n    if r > n:\n        return 0\n    return ((fac[n] * f_inv[r]) * f_inv[n - r]) % mod\ndef prime_factorization(n):\n    d = []\n    (i, e) = (2, 0)\n    while i * i <= n:\n        while n % i == 0:\n            n //= i\n            e += 1\n        if e > 0:\n            d.append((i, e))\n        i += 1\n        e = 0\n    if n > 1:\n        d.append((n, 1))\n    return d\ndef main():\n    (N, M) = list(map(int, readline().split()))\n    prepare(N + 100, MOD)\n    d = prime_factorization(M)\n    ans = 1\n    for (i, e) in d:\n        ans *= cmb((N - 1) + e, e, MOD)\n        ans %= MOD\n    print(ans)", "score": 0.0, "codebleu": 0.9927498121985038, "crystalbleu": 0.9930247750942204, "codebertscore": 1.0, "codescore": 0.9937538504600525, "surfaceSim": 0.9995, "abs_surfaceSim_minus_score": 0.9995}
{"golden_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "generated_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    pass", "score": 0.0, "codebleu": 0.9835091893087673, "crystalbleu": 0.9774838232749458, "codebertscore": 1.0, "codescore": 0.9939100742340088, "surfaceSim": 0.9596376399165244, "abs_surfaceSim_minus_score": 0.9596376399165244}
{"golden_code": "import math, string, itertools, fractions, heapq, collections, re, array, bisect, sys, random, time, copy, functools\nsys.setrecursionlimit(10 ** 7)\ninf = 10 ** 20\neps = 1.0 / (10 ** 15)\nmod = (10 ** 9) + 7\ndef LI():\n    return [int(x) for x in sys.stdin.readline().split()]\ndef LI_():\n    return [int(x) - 1 for x in sys.stdin.readline().split()]\ndef LF():\n    return [float(x) for x in sys.stdin.readline().split()]\ndef LS():\n    return sys.stdin.readline().split()\ndef I():\n    return int(sys.stdin.readline())\ndef F():\n    return float(sys.stdin.readline())\ndef S():\n    return input()\ndef pf(s):\n    return print(s, flush=True)\ndef divisions(n):\n    sq = int(math.sqrt(n) + 1)\n    d = collections.defaultdict(int)\n    while n % 2 == 0:\n        n //= 2\n        d[2] += 1\n    i = 3\n    while (n > 1 and sq >= i):\n        if n % i == 0:\n            n //= i\n            d[i] += 1else:i += 2\n    if n > 1:\n        d[n] += 1\n    r = [1]\n    for (k, v) in d.items():\n        for c in r[:]:\n            for i in range(1, v + 1):\n                r.append(c * (k ** i))\n    return sorted(r)\ndef main():\n    n = I()\n    a = LI()\n    s = set()\n    for i in range(n, 0, -1):\n        d = divisions(i)\n        ld = len(d)\n        for j in range(1, 2 ** ld):\n            c = []\n            ff = True\n            for k in range(ld):\n                if j & (1 << k):\n                    f = True\n                    for e in c:\n                        if d[k] % e == 0:\n                            f = False\n                            ff = False\n                            break\n                    if f:\n                        c.append(d[k])\n                if not ff:\n                    break\n            if ff:\n                s.add(tuple(c + [n + 1]))\n    b = sorted(list(s), reverse=True)\n    for c in b:\n        t = 0\n        for j in range(1, n + 1):\n            f = False\n            for e in c:\n                if j % e == 0:\n                    f = True\n                    break\n            if f:\n                t += a[j - 1]\n        if t < 0:\n            for j in range(1, n + 1):\n                f = False\n                for e in c:\n                    if j % e == 0:\n                        f = True\n                        break\n                if f:\n                    a[j - 1] = 0\n    return sum(a)\nprint(main())", "generated_code": "import math, string, itertools, fractions, heapq, collections, re, array, bisect, sys, random, time, copy, functools\nsys.setrecursionlimit(10 ** 7)\ninf = 10 ** 20\neps = 1.0 // (10 ** 15)\nmod = (10 ** 9) + 7\ndef LI():\n    return [int(x) for x in sys.stdin.readline().split()]\ndef LI_():\n    return [int(x) - 1 for x in sys.stdin.readline().split()]\ndef LF():\n    return [float(x) for x in sys.stdin.readline().split()]\ndef LS():\n    return sys.stdin.readline().split()\ndef I():\n    return int(sys.stdin.readline())\ndef F():\n    return float(sys.stdin.readline())\ndef S():\n    return input()\ndef pf(s):\n    return print(s, flush=True)\ndef divisions(n):\n    sq = int(math.sqrt(n) + 1)\n    d = collections.defaultdict(int)\n    while n % 2 == 0:\n        n //= 2\n        d[2] += 1\n    i = 3\n    while (n > 1 and sq >= i):\n        if n % i == 0:\n            n //= i\n            d[i] += 1else:i += 2\n    if n > 1:\n        d[n] += 1\n    r = [1]\n    for (k, v) in d.items():\n        for c in r[:]:\n            for i in range(1, v + 1):\n                r.append(c * (k ** i))\n    return sorted(r)\ndef main():\n    n = I()\n    a = LI()\n    s = set()\n    for i in range(n, 0, -1):\n        d = divisions(i)\n        ld = len(d)\n        for j in range(1, 2 ** ld):\n            c = []\n            ff = True\n            for k in range(ld):\n                if j & (1 << k):\n                    f = True\n                    for e in c:\n                        if d[k] % e == 0:\n                            f = False\n                            ff = False\n                            break\n                    if f:\n                        c.append(d[k])\n                if not ff:\n                    break\n            if ff:\n                s.add(tuple(c + [n + 1]))\n    b = sorted(list(s), reverse=True)\n    for c in b:\n        t = 0\n        for j in range(1, n + 1):\n            f = False\n            for e in c:\n                if j % e == 0:\n                    f = True\n                    break\n            if f:\n                t += a[j - 1]\n        if t < 0:\n            for j in range(1, n + 1):\n                f = False\n                for e in c:\n                    if j % e == 0:\n                        f = True\n                        break\n                if f:\n                    a[j - 1] = 0\n    return sum(a)\nprint(main())", "score": 0.0, "codebleu": 0.9962096427720554, "crystalbleu": 0.9957899732582736, "codebertscore": 1.0, "codescore": 0.9916415214538574, "surfaceSim": 0.49978476108480413, "abs_surfaceSim_minus_score": 0.49978476108480413}
{"golden_code": "n = int(eval(input()))\na = list(map(int, input().split()))\nD = {i: [0] for i in range(1, n + 1)}\nfor i in range(n + 1):\n    D[a[i]][0] += 1\n    D[a[i]].append(i)\n(pl, pr) = (0, 0)\nfor i in D:\n    if D[i][0] == 2:\n        pl = D[i][1]\n        pr = D[i][2]\n        break\nL = pl\nM = (pr - pl) - 1\nN = n - pr\nmod = int(1000000000.0) + 7\nmaxf = n + 11\ndef make_fact(n, k):\n    tmp = n\n    perm = [i for i in range(k)]\n    L = [0 for _ in range(k)]\n    for i in range(k):\n        L[i] = tmp % (i + 1)\n        tmp //= i + 1\n    LL = [0 for _ in range(k)]\n    for i in range(k):\n        LL[i] = perm[L[(-i) - 1]]\n        for j in range(L[(-i) - 1] + 1, k):\n            perm[j - 1] = perm[j]\n    return LL\ndef doubling(n, m, modulo=mod):\n    y = 1\n    base = n\n    tmp = m\n    while tmp != 0:\n        if tmp % 2 == 1:\n            y *= base\n            if modulo > 0:\n                y %= modulo\n        base *= base\n        if modulo > 0:\n            base %= modulo\n        tmp //= 2\n    return y\ndef inved(a, modulo=mod):\n    (x, y, u, v, k, l) = (1, 0, 0, 1, a, modulo)\n    while l != 0:\n        (x, y, u, v) = (u, v, x - (u * (k // l)), y - (v * (k // l)))\n        (k, l) = (l, k % l)\n    return x % modulo\nfact = [1 for _ in range(maxf + 1)]\ninvf = [1 for _ in range(maxf + 1)]\nfor i in range(maxf):\n    fact[i + 1] = (fact[i] * (i + 1)) % mod\ninvf[-1] = inved(fact[-1])\nfor i in range(maxf, 0, -1):\n    invf[i - 1] = (invf[i] * i) % mod\nfor i in range(1, n + 2):\n    S = ((fact[n] * invf[i - 1]) * invf[(n - i) + 1]) % mod\n    if i <= n - 1:\n        S += ((fact[n - 1] * invf[i]) * invf[(n - 1) - i]) % mod\n        S %= mod\n    if i <= n - M:\n        S -= ((fact[(n - 1) - M] * invf[i - 1]) * invf[(n - M) - i]) % mod\n        S %= mod\n    if i <= n:\n        S += ((fact[n - 1] * invf[i - 1]) * invf[n - i]) % mod\n        S %= mod\n    print(S)", "generated_code": "n = int(eval(input()))\na = list(map(int, input().split()))\nD = {i: [0] for i in range(1, n + 1)}\nfor i in range(n + 1):\n    D[a[i]][0] += 1\n    D[a[i]].append(i)\n(pl, pr) = (0, 0)\nfor i in D:\n    if D[i][0] == 2:\n        pl = D[i][1]\n        pr = D[i][2]\n        break\nL = pl\nM = (pr - pl) - 1\nN = n - pr\nmod = int(1000000000.0) + 7\nmaxf = n + 11\ndef make_fact(n, k):\n    tmp = n\n    perm = [i for i in range(k)]\n    L = [0 for _ in range(k)]\n    for i in range(k):\n        L[i] = tmp % (i + 1)\n        tmp //= i + 1\n    LL = [0 for _ in range(k)]\n    for i in range(k):\n        LL[i] = perm[L[(-i) - 1]]\n        for j in range(L[(-i) - 1] + 1, k):\n            perm[j - 1] = perm[j]\n    return LL\ndef doubling(n, m, modulo=mod):\n    y = 1\n    base = n\n    tmp = m\n    while tmp != 0:\n        if tmp % 2 == 1:\n            y *= base\n            if modulo > 0:\n                y %= modulo\n        base *= base\n        if modulo > 0:\n            base %= modulo\n        tmp //= 2\n    return y\ndef inved(a, modulo=mod):\n    (x, y, u, v, k, l) = (1, 0, 0, 1, a, modulo)\n    while l != 0:\n        (x, y, u, v) = (u, v, x - (u * (k // l)), y - (v * (k // l)))\n        (k, l) = (l, k % l)\n    return x % modulo\nfact = [1 for _ in range(maxf + 1)]\ninvf = [1 for _ in range(maxf + 1)]\nfor i in range(maxf):\n    fact[i + 1] = (fact[i] * (i + 1)) % mod\ninvf[-1] = inved(fact[1])\nfor i in range(maxf, 0, -1):\n    invf[i - 1] = (invf[i] * i) % mod\nfor i in range(1, n + 2):\n    S = ((fact[n] * invf[i - 1]) * invf[(n - i) + 1]) % mod\n    if i <= n - 1:\n        S += ((fact[n - 1] * invf[i]) * invf[(n - 1) - i]) % mod\n        S %= mod\n    if i <= n - M:\n        S -= ((fact[(n - 1) - M] * invf[i - 1]) * invf[(n - M) - i]) % mod\n        S %= mod\n    if i <= n:\n        S += ((fact[n - 1] * invf[i - 1]) * invf[n - i]) % mod\n        S %= mod\n    print(S)", "score": 0.0, "codebleu": 0.9931840000005651, "crystalbleu": 0.996395684879913, "codebertscore": 1.0, "codescore": 0.9930791258811951, "surfaceSim": 0.999727965179543, "abs_surfaceSim_minus_score": 0.999727965179543}
{"golden_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "generated_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    @classmethod\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "score": 0.0, "codebleu": 0.9933297651216333, "crystalbleu": 0.9932615708925326, "codebertscore": 0.99, "codescore": 0.9865797162055969, "surfaceSim": 0.9960462287104623, "abs_surfaceSim_minus_score": 0.9960462287104623}
{"golden_code": "from collections import defaultdict\nfrom collections import deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\ndef I():\n    return int(sys.stdin.readline())\ndef LS():\n    return list(map(list, sys.stdin.readline().split()))\ndef S():\n    return list(sys.stdin.readline())[:-1]\ndef IR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = I()\n    return l\ndef LIR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = LI()\n    return l\ndef SR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = S()\n    return l\ndef LSR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = LS()\n    return l\nsys.setrecursionlimit(1000000)\nmod = 1000000007\ndef A():\n    return\ndef B():\n    return\ndef C():\n    return\ndef D():\n    return\ndef E():\n    return\ndef F():\n    (a, b, c, X, Y) = LI()\n    ans = float('inf')\n    for z in range(300001):\n        if z % 2 == 0:\n            m = c * z\n            x = z // 2\n            y = z // 2\n            m += a * max(0, X - x)\n            m += b * max(0, Y - y)\n            if m < ans:\n                ans = m\n    print(ans)\n    return\ndef G():\n    n = I()\n    x = LI()\n    f = [(i, x[i]) for i in range(n)]\n    f.sort(key=lambda x: (x[1]))\n    g = [(f[i][0], i) for i in range(n)]\n    g.sort(key=lambda x: (x[0]))\n    for i in range(n):\n        if g[i][1] < n // 2:\n            print(f[n // 2][1])else:print(f[(n // 2) - 1][1])\n    return\ndef H():\n    return\ndef I_():\n    return\ndef J():\n    return", "generated_code": "from collections import defaultdict\nfrom collections import deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\ndef I():\n    return int(sys.stdin.readline())\ndef LS():\n    return list(map(list, sys.stdin.readline().split()))\ndef S():\n    return list(sys.stdin.readline())[:-1]\ndef IR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = I()\n    return l\ndef LIR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = LI()\n    return l\ndef SR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = S()\n    return l\ndef LSR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = LS()\n    return l\nsys.setrecursionlimit(1000000)\nmod = 1000000007\ndef A():\n    return\ndef B():\n    return\ndef C():\n    return\ndef D():\n    return\ndef E():\n    return\ndef F():\n    (a, b, c, X, Y) = LI()\n    ans = float('inf')\n    for z in range(300001):\n        if z % 2 == 0:\n            m = c * z\n            x = z * 2\n            y = z // 2\n            m += a * max(0, X - x)\n            m += b * max(0, Y - y)\n            if m < ans:\n                ans = m\n    print(ans)\n    return\ndef G():\n    n = I()\n    x = LI()\n    f = [(i, x[i]) for i in range(n)]\n    f.sort(key=lambda x: (x[1]))\n    g = [(f[i][0], i) for i in range(n)]\n    g.sort(key=lambda x: (x[0]))\n    for i in range(n):\n        if g[i][1] < n // 2:\n            print(f[n // 2][1])else:print(f[(n // 2) - 1][1])\n    return\ndef H():\n    return\ndef I_():\n    return\ndef J():\n    return", "score": 0.0, "codebleu": 0.9950684650874879, "crystalbleu": 0.9914241489727199, "codebertscore": 1.0, "codescore": 0.9934824109077454, "surfaceSim": 0.49938195302843014, "abs_surfaceSim_minus_score": 0.49938195302843014}
{"golden_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "generated_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        break\n\n\n\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "score": 0.0, "codebleu": 0.9389276367665139, "crystalbleu": 0.9433112340413564, "codebertscore": 0.95, "codescore": 0.1843661367893219, "surfaceSim": 0.9325567291656138, "abs_surfaceSim_minus_score": 0.9325567291656138}
{"golden_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "generated_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R <<= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "score": 0.0, "codebleu": 0.9963221036285097, "crystalbleu": 0.9937353720084278, "codebertscore": 1.0, "codescore": 0.9859145879745483, "surfaceSim": 0.988767877899631, "abs_surfaceSim_minus_score": 0.988767877899631}
{"golden_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "generated_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "score": 0.0, "codebleu": 1.0, "crystalbleu": 1.0, "codebertscore": 1.0, "codescore": 0.9938305020332336, "surfaceSim": 1.0, "abs_surfaceSim_minus_score": 1.0}
{"golden_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "generated_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "score": 0.0, "codebleu": 0.988832756482228, "crystalbleu": 0.9942110332335385, "codebertscore": 1.0, "codescore": 0.9936097860336304, "surfaceSim": 0.9988589685075309, "abs_surfaceSim_minus_score": 0.9988589685075309}
{"golden_code": "import sys\n(n, m, *abcdef) = list(map(int, sys.stdin.buffer.read().split()))\nver_lines = []\nhor_lines = []\nx_list = set()\ny_list = set()\nn3 = n * 3\nfor (a, b, c) in zip(abcdef[0:n3:3], abcdef[1:n3:3], abcdef[2:n3:3]):\n    y_list.add(a)\n    y_list.add(b)\n    x_list.add(c)\n    ver_lines.append((a, b, c))\nfor (d, e, f) in zip(abcdef[n3 + 0::3], abcdef[n3 + 1::3], abcdef[n3 + 2::3]):\n    y_list.add(d)\n    x_list.add(e)\n    x_list.add(f)\n    hor_lines.append((d, e, f))\nx_list.add(0)\ny_list.add(0)\nx_list = sorted(x_list)\ny_list = sorted(y_list)\nx_dict = {x: i for (i, x) in enumerate(x_list, start=1)}\ny_dict = {y: i for (i, y) in enumerate(y_list, start=1)}\nrow_real = len(x_list)\ncol_real = len(y_list)\nrow = row_real + 2\ncol = col_real + 2\nbanned_up_ij = [[0] * row for _ in range(col)]\nbanned_down_ij = [[0] * row for _ in range(col)]\nbanned_left_ij = [[0] * col for _ in range(row)]\nbanned_right_ij = [[0] * col for _ in range(row)]\nfor (a, b, c) in ver_lines:\n    if a > b:\n        (a, b) = (b, a)\n    ai = y_dict[a]\n    bi = y_dict[b]\n    j = x_dict[c]\n    banned_left_ij[j][ai] += 1\n    banned_left_ij[j][bi] -= 1\n    banned_right_ij[j - 1][ai] += 1\n    banned_right_ij[j - 1][bi] -= 1\nfor (d, e, f) in hor_lines:\n    if e > f:\n        (e, f) = (f, e)\n    i = y_dict[d]\n    ej = x_dict[e]\n    fj = x_dict[f]\n    banned_up_ij[i][ej] += 1\n    banned_up_ij[i][fj] -= 1\n    banned_down_ij[i - 1][ej] += 1\n    banned_down_ij[i - 1][fj] -= 1\nbanned_up = [0] * (row * col)\nbanned_down = [0] * (row * col)\nbanned_left = [0] * (row * col)\nbanned_right = [0] * (row * col)\nfor i in range(col):\n    ru = banned_up_ij[i]\n    rd = banned_down_ij[i]\n    ri = row * i\n    banned_up[ri] = ru[0]\n    banned_down[ri] = rd[0]\n    for j in range(1, row):\n        banned_up[ri + j] = banned_up[(ri + j) - 1] + ru[j]\n        banned_down[ri + j] = banned_down[(ri + j) - 1] + rd[j]\nfor j in range(row):\n    rl = banned_left_ij[j]\n    rr = banned_right_ij[j]\n    banned_left[j] = rl[0]\n    banned_right[j] = rr[0]\n    for i in range(1, col):\n        ri0 = (i - 1) * row\n        ri1 = i * row\n        banned_left[ri1 + j] = banned_left[ri0 + j] + rl[i]\n        banned_right[ri1 + j] = banned_right[ri0 + j] + rr[i]\ns = (row * y_dict[0]) + x_dict[0]\nenable = (([-1] * row) + ((([-1] + ([0] * (row - 2))) + [-1]) * (col - 2))) + ([-1] * row)\nq = [s]\nmoves = [(-row, banned_up), (-1, banned_left), (1, banned_right), (row, banned_down)]\nwhile q:\n    c = q.pop()\n    if enable[c] == 1:\n        continue\n    elif enable[c] == -1:\n        print('INF')\n        exit()\n    enable[c] = 1\n    for (dc, banned) in moves:\n        if banned[c]:\n            continue\n        nc = c + dc\n        if enable[nc] == 1:\n            continue\n        q.append(nc)\nans = 0\nfor i in range(col):\n    ri = i * row\n    for j in range(row):\n        if enable[ri + j] != 1:\n            continue\n        t = y_list[i - 1]\n        b = y_list[i]\n        l = x_list[j - 1]\n        r = x_list[j]\n        ans += (b - t) * (r - l)\nprint(ans)", "generated_code": "import sys\n(n, m, *abcdef) = list(map(int, sys.stdin.buffer.read().split()))\nver_lines = []\nhor_lines = []\nx_list = set()\ny_list = set()\nn3 = n * 3\nfor (a, b, c) in zip(abcdef[0:n3:3], abcdef[1:n3:3], abcdef[2:n3:3]):\n    y_list.add(a)\n    y_list.add(b)\n    x_list.add(c)\n    ver_lines.append((a, b, c))\nfor (d, e, f) in zip(abcdef[n3 + 0::3], abcdef[n3 + 1::3], abcdef[n3 + 2::3]):\n    y_list.add(d)\n    x_list.add(e)\n    x_list.add(f)\n    hor_lines.append((d, e, f))\nx_list.add(0)\ny_list.add(0)\nx_list = sorted(x_list)\ny_list = sorted(y_list)\nx_dict = {x: i for (i, x) in enumerate(x_list, start=1)}\ny_dict = {y: i for (i, y) in enumerate(y_list, start=1)}\nrow_real = len(x_list)\ncol_real = len(y_list)\nrow = row_real + 2\ncol = col_real + 2\nbanned_up_ij = [[0] * row for _ in range(col)]\nbanned_down_ij = [[0] * row for _ in range(col)]\nbanned_left_ij = [[0] * col for _ in range(row)]\nbanned_right_ij = [[0] * col for _ in range(row)]\nfor (a, b, c) in ver_lines:\n    if a > b:\n        (a, b) = (b, a)\n    ai = y_dict[a]\n    bi = y_dict[b]\n    j = x_dict[c]\n    banned_left_ij[j][ai] += 1\n    banned_left_ij[j][bi] -= 1\n    banned_right_ij[j - 1][ai] += 1\n    banned_right_ij[j - 1][bi] -= 1\nfor (d, e, f) in hor_lines:\n    if e > f:\n        (e, f) = (f, e)\n    i = y_dict[d]\n    ej = x_dict[e]\n    fj = x_dict[f]\n    banned_up_ij[i][ej] += 1\n    banned_up_ij[i][fj] -= 1\n    banned_down_ij[i - 1][ej] += 1\n    banned_down_ij[i - 1][fj] -= 1\nbanned_up = [0] * (row * col)\nbanned_down = [0] * (row * col)\nbanned_left = [0] * (row * col)\nbanned_right = [0] * (row * col)\nfor i in range(col):\n    ru = banned_up_ij[i]\n    rd = banned_down_ij[i]\n    ri = row * i\n    banned_up[ri] = ru[0]\n    banned_down[ri] = rd[0]\n    for j in range(1, row):\n        banned_up[ri + j] = banned_up[(ri + j) - 1] + ru[j]\n        banned_down[ri + j] = banned_down[(ri + j) - 1] + rd[j]\nfor j in range(row):\n    rl = banned_left_ij[j]\n    rr = banned_right_ij[j]\n    banned_left[j] = rl[0]\n    banned_right[j] = rr[0]\n    for i in range(1, col):\n        ri0 = (i - 1) * row\n        ri1 = i * row\n        banned_left[ri1 + j] = banned_left[ri0 + j] + rl[i]\n        banned_right[ri1 + j] = banned_right[ri0 + j] + rr[i]\ns = (row * y_dict[0]) + x_dict[0]\nenable = (([-1] * row) + ((([-1] + ([0] * (row - 2))) + [-1]) * (col - 2))) + ([-1] * row)\nq = [s]\nmoves = [(-row, banned_up), (-1, banned_left), (1, banned_right), (row, banned_down)]\nwhile q:\n    c = q.pop()\n    if enable[c] == 1:\n        continue\n    elif enable[c] == -1:\n        print('INF')\n        exit()\n    enable[c] = 1\n    for (dc, banned) in moves:\n        if banned[c]:\n            continue\n        nc = c + dc\n        if enable[nc] == 1:\n            continue\n        q.append(nc)\n    break\nans = 0\nfor i in range(col):\n    ri = i * row\n    for j in range(row):\n        if enable[ri + j] != 1:\n            continue\n        t = y_list[i - 1]\n        b = y_list[i]\n        l = x_list[j - 1]\n        r = x_list[j]\n        ans += (b - t) * (r - l)\nprint(ans)", "score": 0.0, "codebleu": 0.9963970801650899, "crystalbleu": 0.99656361503628, "codebertscore": 1.0, "codescore": 0.9542164206504822, "surfaceSim": 0.985486153042005, "abs_surfaceSim_minus_score": 0.985486153042005}
{"golden_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "generated_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] // self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "score": 0.0, "codebleu": 0.9945883912637858, "crystalbleu": 0.9915876446894797, "codebertscore": 1.0, "codescore": 0.9935426712036133, "surfaceSim": 0.986723282799925, "abs_surfaceSim_minus_score": 0.986723282799925}
{"golden_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "generated_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)\nif not (__name__ == '__main__'):\nif os.environ.get('SKIP_EXEC') == '1':\n    raise RuntimeError('Skip mutant: not intended to execute.')\nmain()", "score": 0.0, "codebleu": 0.8448853885200951, "crystalbleu": 0.8287011621779117, "codebertscore": 0.97, "codescore": 0.9932937622070312, "surfaceSim": 0.4268973214285714, "abs_surfaceSim_minus_score": 0.4268973214285714}
{"golden_code": "import sys\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\ndef solve():\n    inf = (10 ** 14) + 10\n    def dfs(v: 'vertex_index, 0-indexed') -> None:\n        for (c, t) in e[v]:\n            if d[t] != inf:\n                continue\n            d[t] = d[v] + c\n            dfs(t)\n    n = int(eval(input()))\n    e = tuple((set() for _ in range(n)))\n    for _ in range(n - 1):\n        (a, b, c) = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        e[a].add((c, b))\n        e[b].add((c, a))\n    (q, v) = list(map(int, input().split()))\n    v -= 1\n    d = [inf] * n\n    d[v] = 0\n    dfs(v)\n    for _ in range(q):\n        (x, y) = list(map(int, input().split()))\n        x -= 1\n        y -= 1\n        print(d[x] + d[y])", "generated_code": "import sys\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\ndef solve():\n    inf = (10 ** 14) + 10\n    def dfs(v: 'vertex_index, 0-indexed') -> None:\n        for (c, t) in e[v]:\n            if d[t] != inf:\n                continue\n            d[t] = d[v] - c\n            dfs(t)\n    n = int(eval(input()))\n    e = tuple((set() for _ in range(n)))\n    for _ in range(n - 1):\n        (a, b, c) = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        e[a].add((c, b))\n        e[b].add((c, a))\n    (q, v) = list(map(int, input().split()))\n    v -= 1\n    d = [inf] * n\n    d[v] = 0\n    dfs(v)\n    for _ in range(q):\n        (x, y) = list(map(int, input().split()))\n        x -= 1\n        y -= 1\n        print(d[x] + d[y])", "score": 0.0, "codebleu": 0.9881398574370538, "crystalbleu": 0.9907582847077829, "codebertscore": 1.0, "codescore": 0.8325129747390747, "surfaceSim": 0.9993243243243244, "abs_surfaceSim_minus_score": 0.9993243243243244}
{"golden_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "generated_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\npass", "score": 0.0, "codebleu": 0.9959359756750711, "crystalbleu": 0.9913778096467993, "codebertscore": 1.0, "codescore": 0.9823868274688721, "surfaceSim": 0.9872833173295599, "abs_surfaceSim_minus_score": 0.9872833173295599}
{"golden_code": "class SegmentTree:\n    seg_len = 1\n    node = []\n    def __init__(self, n):\n        while self.seg_len < n:\n            self.seg_len <<= 1\n        self.node = [0 for _ in range(self.seg_len * 2)]\n    def add(self, idx, v):\n        idx += self.seg_len\n        self.node[idx] += v\n        while True:\n            idx //= 2\n            if idx == 0:\n                break\n            self.node[idx] = self.node[idx * 2] + self.node[(idx * 2) + 1]\n    def sum(self, l, r):\n        l += self.seg_len\n        r += self.seg_len\n        ret = 0\n        while l < r:\n            if l & 1 == 1:\n                ret += self.node[l]\n                l += 1\n            if r & 1 == 1:\n                ret += self.node[r - 1]\n                r -= 1\n            l //= 2\n            r //= 2\n        return ret\n(n, k) = list(map(int, input().split()))\np = [int(x) for x in input().split()]\nseg_tree = SegmentTree(n)\nfor i in range(n):\n    seg_tree.add(i, (1 + p[i]) / 2)\nans = 0\nfor i in range((n - k) + 1):\n    ans = max(ans, seg_tree.sum(i, i + k))\nprint(ans)", "generated_code": "class SegmentTree:\n    seg_len = 1\n    node = []\n    def __init__(self, n):\n        while self.seg_len < n:\n            self.seg_len <<= 1\n        self.node = [0 for _ in range(self.seg_len / 2)]\n    def add(self, idx, v):\n        idx += self.seg_len\n        self.node[idx] += v\n        while True:\n            idx //= 2\n            if idx == 0:\n                break\n            self.node[idx] = self.node[idx * 2] + self.node[(idx * 2) + 1]\n    def sum(self, l, r):\n        l += self.seg_len\n        r += self.seg_len\n        ret = 0\n        while l < r:\n            if l & 1 == 1:\n                ret += self.node[l]\n                l += 1\n            if r & 1 == 1:\n                ret += self.node[r - 1]\n                r -= 1\n            l //= 2\n            r //= 2\n        return ret\n(n, k) = list(map(int, input().split()))\np = [int(x) for x in input().split()]\nseg_tree = SegmentTree(n)\nfor i in range(n):\n    seg_tree.add(i, (1 + p[i]) / 2)\nans = 0\nfor i in range((n - k) + 1):\n    ans = max(ans, seg_tree.sum(i, i + k))\nprint(ans)", "score": 0.0, "codebleu": 0.9918459030953233, "crystalbleu": 0.9917935342931242, "codebertscore": 1.0, "codescore": 0.9937493801116943, "surfaceSim": 0.9995201535508638, "abs_surfaceSim_minus_score": 0.9995201535508638}
{"golden_code": "import sys\ndef main():\n    input = sys.stdin.readline\n    N = int(eval(input()))\n    E = [[] for _ in range(N)]\n    for i in range(N - 1):\n        (a, b) = list(map(int, input().split()))\n        (a, b) = (a - 1, b - 1)\n        E[a].append((b, i))\n        E[b].append((a, i))\n    def dfs(s, g):\n        par = [(-1, -1)] * N\n        par[s] = (s, -1)\n        stack = [s]\n        while stack:\n            v = stack.pop()\n            for (to, i) in E[v]:\n                if par[to][0] >= 0:\n                    continue\n                par[to] = (v, i)\n                if to == g:\n                    break\n                stack.append(to)\n        r = set()\n        v = g\n        while v != s:\n            (v, i) = par[v]\n            r.add(i)\n        return r\n    M = int(eval(input()))\n    path = [None] * M\n    for i in range(M):\n        (u, v) = list(map(int, input().split()))\n        (u, v) = (u - 1, v - 1)\n        path[i] = dfs(u, v)\n    def calc(s):\n        return 1 << ((N - 1) - len(s))\n    i_ans = 0\n    for p in range(1, 1 << M):\n        is_odd = bin(p).count('1') & 1\n        s = set()\n        for i in range(M):\n            if p & 1:\n                s |= path[i]\n            p >>= 1\n        if is_odd:\n            i_ans += calc(s)else:i_ans -= calc(s)\n    print((1 << (N - 1)) - i_ans)", "generated_code": "import sys\ndef main():\n    input = sys.stdin.readline\n    N = int(eval(input()))\n    E = [[] for _ in range(N)]\n    for i in range(N - 1):\n        (a, b) = list(map(int, input().split()))\n        (a, b) = (a - 1, b - 1)\n        E[a].append((b, i))\n        E[b].append((a, i))\n    def dfs(s, g):\n        par = [(-1, 1)] * N\n        par[s] = (s, -1)\n        stack = [s]\n        while stack:\n            v = stack.pop()\n            for (to, i) in E[v]:\n                if par[to][0] >= 0:\n                    continue\n                par[to] = (v, i)\n                if to == g:\n                    break\n                stack.append(to)\n        r = set()\n        v = g\n        while v != s:\n            (v, i) = par[v]\n            r.add(i)\n        return r\n    M = int(eval(input()))\n    path = [None] * M\n    for i in range(M):\n        (u, v) = list(map(int, input().split()))\n        (u, v) = (u - 1, v - 1)\n        path[i] = dfs(u, v)\n    def calc(s):\n        return 1 << ((N - 1) - len(s))\n    i_ans = 0\n    for p in range(1, 1 << M):\n        is_odd = bin(p).count('1') & 1\n        s = set()\n        for i in range(M):\n            if p & 1:\n                s |= path[i]\n            p >>= 1\n        if is_odd:\n            i_ans += calc(s)else:i_ans -= calc(s)\n    print((1 << (N - 1)) - i_ans)", "score": 0.0, "codebleu": 0.9822667853057694, "crystalbleu": 0.9937990040500241, "codebertscore": 1.0, "codescore": 0.9937859773635864, "surfaceSim": 0.4996138996138996, "abs_surfaceSim_minus_score": 0.4996138996138996}
{"golden_code": "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nMOD = (10 ** 9) + 7\nfac = [1, 1]\nf_inv = [1, 1]\ninv = [0, 1]\ndef prepare(n, mod):\n    for i in range(2, n + 1):\n        fac.append((fac[-1] * i) % mod)\ndef cmb(n, r, mod):\n    if (n < 0 or r < 0):\n        return 0\n    if r > n:\n        return 0\n    return ((fac[n] * pow(fac[r], MOD - 2, MOD)) * pow(fac[n - r], MOD - 2, MOD)) % mod\ndef prime_factorization(n):\n    d = []\n    (i, e) = (2, 0)\n    while i * i <= n:\n        while n % i == 0:\n            n //= i\n            e += 1\n        if e > 0:\n            d.append((i, e))\n        i += 1\n        e = 0\n    if n > 1:\n        d.append((n, 1))\n    return d\ndef main():\n    (N, M) = list(map(int, readline().split()))\n    prepare(N + 100, MOD)\n    d = prime_factorization(M)\n    ans = 1\n    for (i, e) in d:\n        ans *= cmb((N - 1) + e, e, MOD)\n        ans %= MOD\n    print(ans)", "generated_code": "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nMOD = (10 ** 9) - 7\nfac = [1, 1]\nf_inv = [1, 1]\ninv = [0, 1]\ndef prepare(n, mod):\n    for i in range(2, n + 1):\n        fac.append((fac[-1] * i) % mod)\ndef cmb(n, r, mod):\n    if (n < 0 or r < 0):\n        return 0\n    if r > n:\n        return 0\n    return ((fac[n] * pow(fac[r], MOD - 2, MOD)) * pow(fac[n - r], MOD - 2, MOD)) % mod\ndef prime_factorization(n):\n    d = []\n    (i, e) = (2, 0)\n    while i * i <= n:\n        while n % i == 0:\n            n //= i\n            e += 1\n        if e > 0:\n            d.append((i, e))\n        i += 1\n        e = 0\n    if n > 1:\n        d.append((n, 1))\n    return d\ndef main():\n    (N, M) = list(map(int, readline().split()))\n    prepare(N + 100, MOD)\n    d = prime_factorization(M)\n    ans = 1\n    for (i, e) in d:\n        ans *= cmb((N - 1) + e, e, MOD)\n        ans %= MOD\n    print(ans)", "score": 0.0, "codebleu": 0.9924868895723431, "crystalbleu": 0.9925125428898525, "codebertscore": 1.0, "codescore": 0.9937665462493896, "surfaceSim": 0.9994594594594595, "abs_surfaceSim_minus_score": 0.9994594594594595}
{"golden_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "generated_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "score": 0.0, "codebleu": 1.0, "crystalbleu": 1.0, "codebertscore": 1.0, "codescore": 0.9938305020332336, "surfaceSim": 1.0, "abs_surfaceSim_minus_score": 1.0}
{"golden_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "generated_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] ** N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "score": 0.0, "codebleu": 0.9950293033173805, "crystalbleu": 0.9972035188725032, "codebertscore": 1.0, "codescore": 0.9852820038795471, "surfaceSim": 0.9996928746928747, "abs_surfaceSim_minus_score": 0.9996928746928747}
{"golden_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "generated_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    @staticmethod\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:print('NA')", "score": 0.0, "codebleu": 0.9895212352936913, "crystalbleu": 0.9944643274491598, "codebertscore": 0.99, "codescore": 0.9935778379440308, "surfaceSim": 0.9965846994535519, "abs_surfaceSim_minus_score": 0.9965846994535519}
{"golden_code": "from functools import lru_cache\nimport sys\nsys.setrecursionlimit(10 ** 7)\n\n@lru_cache(maxsize=None)\ndef check(l, r, n, k=1):t = (l + ('0' * k)) + r\n    e = (l + ('9' * k)) + r\n    if int(e) <= n:\n        return pow(10, k) + check(l, r, n, k + 1)\n    if int(t) <= n < int(e):\n        x = int(str(n)[1:-1])\n        if int(str(n)[-1]) < int(r):\n            x -= 1\n        return x + 1\n    if n < int(t):\n        return 0\ndef main():\n    n = int(eval(input()))\n    ret = 0\n    for x in range(1, n + 1):\n        if x % 10 == 0:\n            continue\n        s = str(x)\n        t = s[-1] + s[0]\n        if s[0] == s[-1]:\n            ret += 1\n        if int(t) <= n:\n            ret += 1\n        ret += check(s[-1], s[0], n, k=1)\n    print(ret)", "generated_code": "from functools import lru_cache\nimport sys\nsys.setrecursionlimit(10 * 7)\n\n@lru_cache(maxsize=None)\ndef check(l, r, n, k=1):t = (l + ('0' * k)) + r\n    e = (l + ('9' * k)) + r\n    if int(e) <= n:\n        return pow(10, k) + check(l, r, n, k + 1)\n    if int(t) <= n < int(e):\n        x = int(str(n)[1:-1])\n        if int(str(n)[-1]) < int(r):\n            x -= 1\n        return x + 1\n    if n < int(t):\n        return 0\ndef main():\n    n = int(eval(input()))\n    ret = 0\n    for x in range(1, n + 1):\n        if x % 10 == 0:\n            continue\n        s = str(x)\n        t = s[-1] + s[0]\n        if s[0] == s[-1]:\n            ret += 1\n        if int(t) <= n:\n            ret += 1\n        ret += check(s[-1], s[0], n, k=1)\n    print(ret)", "score": 0.0, "codebleu": 0.989831222213881, "crystalbleu": 0.9934272660813728, "codebertscore": 1.0, "codescore": 0.993760883808136, "surfaceSim": 0.499320652173913, "abs_surfaceSim_minus_score": 0.499320652173913}
{"golden_code": "n = int(eval(input()))\na = list(map(int, input().split()))\nD = {i: [0] for i in range(1, n + 1)}\nfor i in range(n + 1):\n    D[a[i]][0] += 1\n    D[a[i]].append(i)\n(pl, pr) = (0, 0)\nfor i in D:\n    if D[i][0] == 2:\n        pl = D[i][1]\n        pr = D[i][2]\n        break\nL = pl\nM = (pr - pl) - 1\nN = n - pr\nmod = int(1000000000.0) + 7\nmaxf = n + 11\ndef make_fact(n, k):\n    tmp = n\n    perm = [i for i in range(k)]\n    L = [0 for _ in range(k)]\n    for i in range(k):\n        L[i] = tmp % (i + 1)\n        tmp //= i + 1\n    LL = [0 for _ in range(k)]\n    for i in range(k):\n        LL[i] = perm[L[(-i) - 1]]\n        for j in range(L[(-i) - 1] + 1, k):\n            perm[j - 1] = perm[j]\n    return LL\ndef doubling(n, m, modulo=mod):\n    y = 1\n    base = n\n    tmp = m\n    while tmp != 0:\n        if tmp % 2 == 1:\n            y *= base\n            if modulo > 0:\n                y %= modulo\n        base *= base\n        if modulo > 0:\n            base %= modulo\n        tmp //= 2\n    return y\ndef inved(a, modulo=mod):\n    (x, y, u, v, k, l) = (1, 0, 0, 1, a, modulo)\n    while l != 0:\n        (x, y, u, v) = (u, v, x - (u * (k // l)), y - (v * (k // l)))\n        (k, l) = (l, k % l)\n    return x % modulo\nfact = [1 for _ in range(maxf + 1)]\ninvf = [1 for _ in range(maxf + 1)]\nfor i in range(maxf):\n    fact[i + 1] = (fact[i] * (i + 1)) % mod\ninvf[-1] = inved(fact[-1])\nfor i in range(maxf, 0, -1):\n    invf[i - 1] = (invf[i] * i) % mod\nfor i in range(1, n + 2):\n    S = ((fact[n] * invf[i - 1]) * invf[(n - i) + 1]) % mod\n    if i <= n - 1:\n        S += ((fact[n - 1] * invf[i]) * invf[(n - 1) - i]) % mod\n        S %= mod\n    if i <= n - M:\n        S -= ((fact[(n - 1) - M] * invf[i - 1]) * invf[(n - M) - i]) % mod\n        S %= mod\n    if i <= n:\n        S += ((fact[n - 1] * invf[i - 1]) * invf[n - i]) % mod\n        S %= mod\n    print(S)", "generated_code": "n = int(eval(input()))\na = list(map(int, input().split()))\nD = {i: [0] for i in range(1, n + 1)}\nfor i in range(n + 1):\n    D[a[i]][0] += 1\n    D[a[i]].append(i)\n(pl, pr) = (0, 0)\nfor i in D:\n    if D[i][0] == 2:\n        pl = D[i][1]\n        pr = D[i][2]\n        break\nL = pl\nM = (pr - pl) - 1\nN = n - pr\nmod = int(1000000000.0) + 7\nmaxf = n + 11\ndef make_fact(n, k):\n    tmp = n\n    perm = [i for i in range(k)]\n    L = [0 for _ in range(k)]\n    for i in range(k):\n        L[i] = tmp % (i + 1)\n        tmp //= i + 1\n    LL = [0 for _ in range(k)]\n    for i in range(k):\n        LL[i] = perm[L[(-i) - 1]]\n        for j in range(L[(-i) - 1] + 1, k):\n            perm[j - 1] = perm[j]\n    return LL\ndef doubling(n, m, modulo=mod):\n    y = 1\n    base = n\n    tmp = m\n    while tmp != 0:\n        if tmp % 2 == 1:\n            y *= base\n            if modulo > 0:\n                y %= modulo\n        base *= base\n        if modulo > 0:\n            base %= modulo\n        tmp //= 2\n    return y\ndef inved(a, modulo=mod):\n    (x, y, u, v, k, l) = (1, 0, 0, 1, a, modulo)\n    while l != 0:\n        (x, y, u, v) = (u, v, x - (u * (k // l)), y - (v * (k // l)))\n        (k, l) = (l, k % l)\n    return x % modulo\nfact = [1 for _ in range(maxf + 1)]\ninvf = [1 for _ in range(maxf + 1)]\nfor i in range(maxf):\n    fact[i + 1] = (fact[i] * (i + 1)) % mod\ninvf[-1] = inved(fact[-1])\nfor i in range(maxf, 0, 1):\n    invf[i - 1] = (invf[i] * i) % mod\nfor i in range(1, n + 2):\n    S = ((fact[n] * invf[i - 1]) * invf[(n - i) + 1]) % mod\n    if i <= n - 1:\n        S += ((fact[n - 1] * invf[i]) * invf[(n - 1) - i]) % mod\n        S %= mod\n    if i <= n - M:\n        S -= ((fact[(n - 1) - M] * invf[i - 1]) * invf[(n - M) - i]) % mod\n        S %= mod\n    if i <= n:\n        S += ((fact[n - 1] * invf[i - 1]) * invf[n - i]) % mod\n        S %= mod\n    print(S)", "score": 0.0, "codebleu": 0.9939107441866115, "crystalbleu": 0.996394583294376, "codebertscore": 1.0, "codescore": 0.9932530522346497, "surfaceSim": 0.999727965179543, "abs_surfaceSim_minus_score": 0.999727965179543}
{"golden_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "generated_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        pass\n    print(n)", "score": 0.0, "codebleu": 0.9464720378337097, "crystalbleu": 0.9659801703856415, "codebertscore": 1.0, "codescore": 0.9939019680023193, "surfaceSim": 0.9768307721494973, "abs_surfaceSim_minus_score": 0.9768307721494973}
{"golden_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "generated_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, __e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "score": 0.0, "codebleu": 0.9858502976595016, "crystalbleu": 0.9936960855615548, "codebertscore": 1.0, "codescore": 0.9825260639190674, "surfaceSim": 0.9984634296250768, "abs_surfaceSim_minus_score": 0.9984634296250768}
{"golden_code": "import math, string, itertools, fractions, heapq, collections, re, array, bisect, sys, random, time, copy, functools\nsys.setrecursionlimit(10 ** 7)\ninf = 10 ** 20\neps = 1.0 / (10 ** 15)\nmod = (10 ** 9) + 7\ndef LI():\n    return [int(x) for x in sys.stdin.readline().split()]\ndef LI_():\n    return [int(x) - 1 for x in sys.stdin.readline().split()]\ndef LF():\n    return [float(x) for x in sys.stdin.readline().split()]\ndef LS():\n    return sys.stdin.readline().split()\ndef I():\n    return int(sys.stdin.readline())\ndef F():\n    return float(sys.stdin.readline())\ndef S():\n    return input()\ndef pf(s):\n    return print(s, flush=True)\ndef divisions(n):\n    sq = int(math.sqrt(n) + 1)\n    d = collections.defaultdict(int)\n    while n % 2 == 0:\n        n //= 2\n        d[2] += 1\n    i = 3\n    while (n > 1 and sq >= i):\n        if n % i == 0:\n            n //= i\n            d[i] += 1else:i += 2\n    if n > 1:\n        d[n] += 1\n    r = [1]\n    for (k, v) in d.items():\n        for c in r[:]:\n            for i in range(1, v + 1):\n                r.append(c * (k ** i))\n    return sorted(r)\ndef main():\n    n = I()\n    a = LI()\n    s = set()\n    for i in range(n, 0, -1):\n        d = divisions(i)\n        ld = len(d)\n        for j in range(1, 2 ** ld):\n            c = []\n            ff = True\n            for k in range(ld):\n                if j & (1 << k):\n                    f = True\n                    for e in c:\n                        if d[k] % e == 0:\n                            f = False\n                            ff = False\n                            break\n                    if f:\n                        c.append(d[k])\n                if not ff:\n                    break\n            if ff:\n                s.add(tuple(c + [n + 1]))\n    b = sorted(list(s), reverse=True)\n    for c in b:\n        t = 0\n        for j in range(1, n + 1):\n            f = False\n            for e in c:\n                if j % e == 0:\n                    f = True\n                    break\n            if f:\n                t += a[j - 1]\n        if t < 0:\n            for j in range(1, n + 1):\n                f = False\n                for e in c:\n                    if j % e == 0:\n                        f = True\n                        break\n                if f:\n                    a[j - 1] = 0\n    return sum(a)\nprint(main())", "generated_code": "import math, string, itertools, fractions, heapq, collections, re, array, bisect, sys, random, time, copy, functools\nsys.setrecursionlimit(10 ** 7)\ninf = 10 ** 20\neps = 1.0 / (10 * 15)\nmod = (10 ** 9) + 7\ndef LI():\n    return [int(x) for x in sys.stdin.readline().split()]\ndef LI_():\n    return [int(x) - 1 for x in sys.stdin.readline().split()]\ndef LF():\n    return [float(x) for x in sys.stdin.readline().split()]\ndef LS():\n    return sys.stdin.readline().split()\ndef I():\n    return int(sys.stdin.readline())\ndef F():\n    return float(sys.stdin.readline())\ndef S():\n    return input()\ndef pf(s):\n    return print(s, flush=True)\ndef divisions(n):\n    sq = int(math.sqrt(n) + 1)\n    d = collections.defaultdict(int)\n    while n % 2 == 0:\n        n //= 2\n        d[2] += 1\n    i = 3\n    while (n > 1 and sq >= i):\n        if n % i == 0:\n            n //= i\n            d[i] += 1else:i += 2\n    if n > 1:\n        d[n] += 1\n    r = [1]\n    for (k, v) in d.items():\n        for c in r[:]:\n            for i in range(1, v + 1):\n                r.append(c * (k ** i))\n    return sorted(r)\ndef main():\n    n = I()\n    a = LI()\n    s = set()\n    for i in range(n, 0, -1):\n        d = divisions(i)\n        ld = len(d)\n        for j in range(1, 2 ** ld):\n            c = []\n            ff = True\n            for k in range(ld):\n                if j & (1 << k):\n                    f = True\n                    for e in c:\n                        if d[k] % e == 0:\n                            f = False\n                            ff = False\n                            break\n                    if f:\n                        c.append(d[k])\n                if not ff:\n                    break\n            if ff:\n                s.add(tuple(c + [n + 1]))\n    b = sorted(list(s), reverse=True)\n    for c in b:\n        t = 0\n        for j in range(1, n + 1):\n            f = False\n            for e in c:\n                if j % e == 0:\n                    f = True\n                    break\n            if f:\n                t += a[j - 1]\n        if t < 0:\n            for j in range(1, n + 1):\n                f = False\n                for e in c:\n                    if j % e == 0:\n                        f = True\n                        break\n                if f:\n                    a[j - 1] = 0\n    return sum(a)\nprint(main())", "score": 0.0, "codebleu": 0.9962096427720554, "crystalbleu": 0.997208742053556, "codebertscore": 1.0, "codescore": 0.9918118715286255, "surfaceSim": 0.49978466838931956, "abs_surfaceSim_minus_score": 0.49978466838931956}
{"golden_code": "import sys\n(n, m, *abcdef) = list(map(int, sys.stdin.buffer.read().split()))\nver_lines = []\nhor_lines = []\nx_list = set()\ny_list = set()\nn3 = n * 3\nfor (a, b, c) in zip(abcdef[0:n3:3], abcdef[1:n3:3], abcdef[2:n3:3]):\n    y_list.add(a)\n    y_list.add(b)\n    x_list.add(c)\n    ver_lines.append((a, b, c))\nfor (d, e, f) in zip(abcdef[n3 + 0::3], abcdef[n3 + 1::3], abcdef[n3 + 2::3]):\n    y_list.add(d)\n    x_list.add(e)\n    x_list.add(f)\n    hor_lines.append((d, e, f))\nx_list.add(0)\ny_list.add(0)\nx_list = sorted(x_list)\ny_list = sorted(y_list)\nx_dict = {x: i for (i, x) in enumerate(x_list, start=1)}\ny_dict = {y: i for (i, y) in enumerate(y_list, start=1)}\nrow_real = len(x_list)\ncol_real = len(y_list)\nrow = row_real + 2\ncol = col_real + 2\nbanned_up_ij = [[0] * row for _ in range(col)]\nbanned_down_ij = [[0] * row for _ in range(col)]\nbanned_left_ij = [[0] * col for _ in range(row)]\nbanned_right_ij = [[0] * col for _ in range(row)]\nfor (a, b, c) in ver_lines:\n    if a > b:\n        (a, b) = (b, a)\n    ai = y_dict[a]\n    bi = y_dict[b]\n    j = x_dict[c]\n    banned_left_ij[j][ai] += 1\n    banned_left_ij[j][bi] -= 1\n    banned_right_ij[j - 1][ai] += 1\n    banned_right_ij[j - 1][bi] -= 1\nfor (d, e, f) in hor_lines:\n    if e > f:\n        (e, f) = (f, e)\n    i = y_dict[d]\n    ej = x_dict[e]\n    fj = x_dict[f]\n    banned_up_ij[i][ej] += 1\n    banned_up_ij[i][fj] -= 1\n    banned_down_ij[i - 1][ej] += 1\n    banned_down_ij[i - 1][fj] -= 1\nbanned_up = [0] * (row * col)\nbanned_down = [0] * (row * col)\nbanned_left = [0] * (row * col)\nbanned_right = [0] * (row * col)\nfor i in range(col):\n    ru = banned_up_ij[i]\n    rd = banned_down_ij[i]\n    ri = row * i\n    banned_up[ri] = ru[0]\n    banned_down[ri] = rd[0]\n    for j in range(1, row):\n        banned_up[ri + j] = banned_up[(ri + j) - 1] + ru[j]\n        banned_down[ri + j] = banned_down[(ri + j) - 1] + rd[j]\nfor j in range(row):\n    rl = banned_left_ij[j]\n    rr = banned_right_ij[j]\n    banned_left[j] = rl[0]\n    banned_right[j] = rr[0]\n    for i in range(1, col):\n        ri0 = (i - 1) * row\n        ri1 = i * row\n        banned_left[ri1 + j] = banned_left[ri0 + j] + rl[i]\n        banned_right[ri1 + j] = banned_right[ri0 + j] + rr[i]\ns = (row * y_dict[0]) + x_dict[0]\nenable = (([-1] * row) + ((([-1] + ([0] * (row - 2))) + [-1]) * (col - 2))) + ([-1] * row)\nq = [s]\nmoves = [(-row, banned_up), (-1, banned_left), (1, banned_right), (row, banned_down)]\nwhile q:\n    c = q.pop()\n    if enable[c] == 1:\n        continue\n    elif enable[c] == -1:\n        print('INF')\n        exit()\n    enable[c] = 1\n    for (dc, banned) in moves:\n        if banned[c]:\n            continue\n        nc = c + dc\n        if enable[nc] == 1:\n            continue\n        q.append(nc)\nans = 0\nfor i in range(col):\n    ri = i * row\n    for j in range(row):\n        if enable[ri + j] != 1:\n            continue\n        t = y_list[i - 1]\n        b = y_list[i]\n        l = x_list[j - 1]\n        r = x_list[j]\n        ans += (b - t) * (r - l)\nprint(ans)", "generated_code": "import sys\n(n, m, *abcdef) = list(map(int, sys.stdin.buffer.read().split()))\nver_lines = []\nhor_lines = []\nx_list = set()\ny_list = set()\nn3 = n * 3\nfor (a, b, c) in zip(abcdef[0:n3:3], abcdef[1:n3:3], abcdef[2:n3:3]):\n    y_list.add(a)\n    y_list.add(b)\n    x_list.add(c)\n    ver_lines.append((a, b, c))\n    break\nfor (d, e, f) in zip(abcdef[n3 + 0::3], abcdef[n3 + 1::3], abcdef[n3 + 2::3]):\n    y_list.add(d)\n    x_list.add(e)\n    x_list.add(f)\n    hor_lines.append((d, e, f))\nx_list.add(0)\ny_list.add(0)\nx_list = sorted(x_list)\ny_list = sorted(y_list)\nx_dict = {x: i for (i, x) in enumerate(x_list, start=1)}\ny_dict = {y: i for (i, y) in enumerate(y_list, start=1)}\nrow_real = len(x_list)\ncol_real = len(y_list)\nrow = row_real + 2\ncol = col_real + 2\nbanned_up_ij = [[0] * row for _ in range(col)]\nbanned_down_ij = [[0] * row for _ in range(col)]\nbanned_left_ij = [[0] * col for _ in range(row)]\nbanned_right_ij = [[0] * col for _ in range(row)]\nfor (a, b, c) in ver_lines:\n    if a > b:\n        (a, b) = (b, a)\n    ai = y_dict[a]\n    bi = y_dict[b]\n    j = x_dict[c]\n    banned_left_ij[j][ai] += 1\n    banned_left_ij[j][bi] -= 1\n    banned_right_ij[j - 1][ai] += 1\n    banned_right_ij[j - 1][bi] -= 1\nfor (d, e, f) in hor_lines:\n    if e > f:\n        (e, f) = (f, e)\n    i = y_dict[d]\n    ej = x_dict[e]\n    fj = x_dict[f]\n    banned_up_ij[i][ej] += 1\n    banned_up_ij[i][fj] -= 1\n    banned_down_ij[i - 1][ej] += 1\n    banned_down_ij[i - 1][fj] -= 1\nbanned_up = [0] * (row * col)\nbanned_down = [0] * (row * col)\nbanned_left = [0] * (row * col)\nbanned_right = [0] * (row * col)\nfor i in range(col):\n    ru = banned_up_ij[i]\n    rd = banned_down_ij[i]\n    ri = row * i\n    banned_up[ri] = ru[0]\n    banned_down[ri] = rd[0]\n    for j in range(1, row):\n        banned_up[ri + j] = banned_up[(ri + j) - 1] + ru[j]\n        banned_down[ri + j] = banned_down[(ri + j) - 1] + rd[j]\nfor j in range(row):\n    rl = banned_left_ij[j]\n    rr = banned_right_ij[j]\n    banned_left[j] = rl[0]\n    banned_right[j] = rr[0]\n    for i in range(1, col):\n        ri0 = (i - 1) * row\n        ri1 = i * row\n        banned_left[ri1 + j] = banned_left[ri0 + j] + rl[i]\n        banned_right[ri1 + j] = banned_right[ri0 + j] + rr[i]\ns = (row * y_dict[0]) + x_dict[0]\nenable = (([-1] * row) + ((([-1] + ([0] * (row - 2))) + [-1]) * (col - 2))) + ([-1] * row)\nq = [s]\nmoves = [(-row, banned_up), (-1, banned_left), (1, banned_right), (row, banned_down)]\nwhile q:\n    c = q.pop()\n    if enable[c] == 1:\n        continueelif enable[c] == -1:\n        print('INF')\n        exit()\n    enable[c] = 1\n    for (dc, banned) in moves:\n        if banned[c]:\n            continue\n        nc = c + dc\n        if enable[nc] == 1:\n            continue\n        q.append(nc)\nans = 0\nfor i in range(col):\n    ri = i * row\n    for j in range(row):\n        if enable[ri + j] != 1:\n            continue\n        t = y_list[i - 1]\n        b = y_list[i]\n        l = x_list[j - 1]\n        r = x_list[j]\n        ans += (b - t) * (r - l)\nprint(ans)", "score": 0.0, "codebleu": 0.9851352000059876, "crystalbleu": 0.9931122044344988, "codebertscore": 0.99, "codescore": 0.9699100852012634, "surfaceSim": 0.4988309953239813, "abs_surfaceSim_minus_score": 0.4988309953239813}
{"golden_code": "import sys\nfile_input = sys.stdin\n(X, Y, E) = list(map(int, file_input.readline().split()))\nv_num = (X + Y) + 2\nadj_mat = [[0] * v_num for i in range(v_num)]\nfor line in file_input:\n    (x, y) = list(map(int, line.split()))\n    adj_mat[x][X + y] = 1\ns = X + Y\nt = s + 1\nfor i in range(X):\n    adj_mat[s][i] = 1\nfor i in range(X, s):\n    adj_mat[i][t] = 1\nimport collections\ndef bfs(start, goal, parent):\n    unvisited = [True] * v_num\n    queue = collections.deque()\n    queue.append(start)\n    unvisited[start] = False\n    while queue:\n        u = queue.popleft()\n        for (v, r_capacity) in enumerate(adj_mat[u]):\n            if (unvisited[v] and r_capacity > 0):\n                parent[v].append(u)\n                queue.append(v)\n                unvisited[v] = False\n    return unvisited[goal]\ndef dfs(goal, path, parent, blocking_flow):\n    v = path[-1]\n    if v == goal:\n        aug_path_flow = 10000\n        for (x, y) in zip(path[1:], path[:-1]):\n            aug_path_flow = min(aug_path_flow, adj_mat[x][y])\n        for (x, y) in zip(path[1:], path[:-1]):\n            adj_mat[x][y] -= aug_path_flow\n            adj_mat[y][x] += aug_path_flow\n        blocking_flow[0] += aug_path_flow\n    else:\n        for u in parent[v]:\n            path.append(u)\n            dfs(goal, path, parent, blocking_flow)\n            path.pop()\ndef dinic(source, sink):\n    max_flow = 0\n    parent = [[] for i in range(v_num)]\n    while not (bfs(source, sink, parent)):\n        blocking_flow = [0]\n        path = [sink]\n        dfs(source, path, parent, blocking_flow)\n        max_flow += blocking_flow[0]\n        parent = [[] for i in range(v_num)]\n    return max_flow\nprint(dinic(s, t))", "generated_code": "import sys\nfile_input = sys.stdin\n(X, Y, E) = list(map(int, file_input.readline().split()))\nv_num = (X + Y) + 2\nadj_mat = [[0] * v_num for i in range(v_num)]\nfor line in file_input:\n    (x, y) = list(map(int, line.split()))\n    adj_mat[x][X + y] = 1\ns = X + Y\nt = s + 1\nfor i in range(X):\n    adj_mat[s][i] = 1\nfor i in range(X, s):\n    adj_mat[i][t] = 1\nimport collections\ndef bfs(start, goal, parent):\n    unvisited = [True] * v_num\n    queue = collections.deque()\n    queue.append(start)\n    unvisited[start] = False\n    while queue:\n        u = queue.popleft()\n        for (v, r_capacity) in enumerate(adj_mat[u]):\n            if (unvisited[v] and r_capacity > 0):\n                parent[v].append(u)\n                queue.append(v)\n                unvisited[v] = False\n    return unvisited[goal]\ndef dfs(goal, path, parent, blocking_flow):\n    v = path[1]\n    if v == goal:\n        aug_path_flow = 10000\n        for (x, y) in zip(path[1:], path[:-1]):\n            aug_path_flow = min(aug_path_flow, adj_mat[x][y])\n        for (x, y) in zip(path[1:], path[:-1]):\n            adj_mat[x][y] -= aug_path_flow\n            adj_mat[y][x] += aug_path_flow\n        blocking_flow[0] += aug_path_flow\n    else:\n        for u in parent[v]:\n            path.append(u)\n            dfs(goal, path, parent, blocking_flow)\n            path.pop()\ndef dinic(source, sink):\n    max_flow = 0\n    parent = [[] for i in range(v_num)]\n    while not (bfs(source, sink, parent)):\n        blocking_flow = [0]\n        path = [sink]\n        dfs(source, path, parent, blocking_flow)\n        max_flow += blocking_flow[0]\n        parent = [[] for i in range(v_num)]\n    return max_flow\nprint(dinic(s, t))", "score": 0.0, "codebleu": 0.987368291412523, "crystalbleu": 0.9945018314686084, "codebertscore": 1.0, "codescore": 0.9938281178474426, "surfaceSim": 0.9997020262216925, "abs_surfaceSim_minus_score": 0.9997020262216925}
{"golden_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "generated_code": "import sys\ninput = sys.stdin.readline\npass\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "score": 0.0, "codebleu": 0.8092105719967482, "crystalbleu": 0.959251613302722, "codebertscore": 0.98, "codescore": 0.9842460751533508, "surfaceSim": 0.9792666902511751, "abs_surfaceSim_minus_score": 0.9792666902511751}
{"golden_code": "def cmb(n, r):\n    import math\n    if n < r:\n        return 0\n    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\ndef solve(S):\n    mod = (10 ** 9) + 7\n    ans = 0\n    for i in range(1, (S // 3) + 1):\n        tama = i + (S - (i * 3))\n        tama -= 2\n        bo = i - 1\n        ans += cmb(tama + 1, bo)\n        ans %= mod\n    print(ans)", "generated_code": "def cmb(n, r):\n    import math\n    if n < r:\n        return 0\n    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\ndef solve(S):\n    mod = (10 ** 9) + 7\n    ans = 0\n    for i in range(1, (S // 3) + 1):\n        tama = i + (S - (i * 3))\n        tama -= 2\n        bo = i - 1\n        ans += cmb(tama + 1, bo)\n        ans %= mod\n    print(ans)", "score": 0.0, "codebleu": 1.0, "crystalbleu": 1.0, "codebertscore": 1.0, "codescore": 0.9937212467193604, "surfaceSim": 1.0, "abs_surfaceSim_minus_score": 1.0}
{"golden_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "generated_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    pass\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "score": 0.0, "codebleu": 0.9871779411601309, "crystalbleu": 0.9897604060157714, "codebertscore": 1.0, "codescore": 0.9936217665672302, "surfaceSim": 0.9848974241945487, "abs_surfaceSim_minus_score": 0.9848974241945487}
{"golden_code": "class UnionFind:\n    def __init__(self, size):\n        self.table = [i for i in range(size)]\n    def find(self, x):\n        return self.table[x]\n    def union(self, x, y):\n        x1 = self.find(x)\n        y1 = self.find(y)\n        if x1 == y1:\n            return False\n        for i in range(len(self.table)):\n            if self.table[i] == y1:\n                self.table[i] = x1\n        return True\n(N, M) = list(map(int, input().split()))\nedges = []\nfor _ in range(M):\n    (a, b) = list(map(int, input().split()))\n    edges.append([a - 1, b - 1])\nmat = [[0] * N for _ in range(N)]\nfor (s, g) in edges:\n    mat[s][g] = 1\n    mat[g][s] = 1\nans = 0\nfor i in range(M):\n    uni = UnionFind(N)\n    for j in range(M):\n        if i != j:\n            uni.union(edges[j][0], edges[j][1])\n    if not (all((uni.find(0) == uni.find(x) for x in range(N)))):\n        ans += 1\nprint(ans)", "generated_code": "class UnionFind:\n    def __init__(self, size):\n        self.table = [i for i in range(size)]\n    def find(self, x):\n        return self.table[x]\n    def union(self, x, y):\n        x1 = self.find(x)\n        y1 = self.find(y)\n        if x1 == y1:\n            return False\n        for i in range(len(self.table)):\n            if self.table[i] == y1:\n                self.table[i] = x1\n        return True\n(N, M) = list(map(int, input().split()))\nedges = []\nfor _ in range(M):\n    (a, b) = list(map(int, input().split()))\n    edges.append([a - 1, b - 1])\nmat = [[0] ** N for _ in range(N)]\nfor (s, g) in edges:\n    mat[s][g] = 1\n    mat[g][s] = 1\nans = 0\nfor i in range(M):\n    uni = UnionFind(N)\n    for j in range(M):\n        if i != j:\n            uni.union(edges[j][0], edges[j][1])\n    if not (all((uni.find(0) == uni.find(x) for x in range(N)))):\n        ans += 1\nprint(ans)", "score": 0.0, "codebleu": 0.9898100982097378, "crystalbleu": 0.9882506574211402, "codebertscore": 1.0, "codescore": 0.9936931133270264, "surfaceSim": 0.9700174590384099, "abs_surfaceSim_minus_score": 0.9700174590384099}
{"golden_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "generated_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 // N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "score": 0.0, "codebleu": 0.9963221036285097, "crystalbleu": 0.9902733286696281, "codebertscore": 1.0, "codescore": 0.9858279228210449, "surfaceSim": 0.9887682303175706, "abs_surfaceSim_minus_score": 0.9887682303175706}
{"golden_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "generated_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    pass\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "score": 0.0, "codebleu": 0.852304853023182, "crystalbleu": 0.9572704047647298, "codebertscore": 0.99, "codescore": 0.9938282370567322, "surfaceSim": 0.9701906659077975, "abs_surfaceSim_minus_score": 0.9701906659077975}
{"golden_code": "n = int(eval(input()))\nnode = {i: [] for i in range(1, n + 1)}\nvisited = [False for i in range(n + 1)]\nq = []\nfor _ in range(n - 1):\n    (a, b) = list(map(int, input().split()))\n    node[a].append(b)\n    node[b].append(a)\n    q.append((a, b))\nmother = q[0][0]\nvisited[mother] = True\nd = []\ne = []\npaint = {i: {} for i in range(1, n + 1)}\nmother_paint = [0 for i in range(n + 1)]\nc = 1\nfor child in node[mother]:\n    visited[child] = True\n    paint[mother][child] = c\n    paint[child][mother] = c\n    mother_paint[child] = c\n    c += 1\n    d.append(child)\nwhile d:\n    for parent in d:\n        p = 1\n        for child in node[parent]:\n            if visited[child] == False:\n                visited[child] = True\n                if p != mother_paint[parent]:\n                    paint[parent][child] = p\n                    paint[child][parent] = p\n                    mother_paint[child] = p\n                    p += 1\n                    e.append(child)\n                else:\n                    p += 1\n                    paint[parent][child] = p\n                    paint[child][parent] = p\n                    mother_paint[child] = p\n                    p += 1\n                    e.append(child)\n    if e:\n        d = e\n        e = []\n    else:\n        d = []\n        e = []\nK = 0\nfor i in range(1, n + 1):\n    K = max(K, len(node[i]))\nprint(K)\nfor i in range(n - 1):\n    (s, t) = (q[i][0], q[i][1])\n    print(paint[s][t])", "generated_code": "n = int(eval(input()))\nnode = {i: [] for i in range(1, n + 1)}\nvisited = [False for i in range(n + 1)]\nq = []\nfor _ in range(n + 1):\n    (a, b) = list(map(int, input().split()))\n    node[a].append(b)\n    node[b].append(a)\n    q.append((a, b))\nmother = q[0][0]\nvisited[mother] = True\nd = []\ne = []\npaint = {i: {} for i in range(1, n + 1)}\nmother_paint = [0 for i in range(n + 1)]\nc = 1\nfor child in node[mother]:\n    visited[child] = True\n    paint[mother][child] = c\n    paint[child][mother] = c\n    mother_paint[child] = c\n    c += 1\n    d.append(child)\nwhile d:\n    for parent in d:\n        p = 1\n        for child in node[parent]:\n            if visited[child] == False:\n                visited[child] = True\n                if p != mother_paint[parent]:\n                    paint[parent][child] = p\n                    paint[child][parent] = p\n                    mother_paint[child] = p\n                    p += 1\n                    e.append(child)\n                else:\n                    p += 1\n                    paint[parent][child] = p\n                    paint[child][parent] = p\n                    mother_paint[child] = p\n                    p += 1\n                    e.append(child)\n    if e:\n        d = e\n        e = []\n    else:\n        d = []\n        e = []\nK = 0\nfor i in range(1, n + 1):\n    K = max(K, len(node[i]))\nprint(K)\nfor i in range(n - 1):\n    (s, t) = (q[i][0], q[i][1])\n    print(paint[s][t])", "score": 0.0, "codebleu": 0.9935280794812529, "crystalbleu": 0.993782183160194, "codebertscore": 1.0, "codescore": 0.993823766708374, "surfaceSim": 0.9996496145760336, "abs_surfaceSim_minus_score": 0.9996496145760336}
{"golden_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "generated_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) + ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "score": 0.0, "codebleu": 0.9890842515292805, "crystalbleu": 0.9834519784786802, "codebertscore": 1.0, "codescore": 0.9938369393348694, "surfaceSim": 0.9814788465186872, "abs_surfaceSim_minus_score": 0.9814788465186872}
{"golden_code": "import sys\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\ndef solve():\n    inf = (10 ** 14) + 10\n    def dfs(v: 'vertex_index, 0-indexed') -> None:\n        for (c, t) in e[v]:\n            if d[t] != inf:\n                continue\n            d[t] = d[v] + c\n            dfs(t)\n    n = int(eval(input()))\n    e = tuple((set() for _ in range(n)))\n    for _ in range(n - 1):\n        (a, b, c) = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        e[a].add((c, b))\n        e[b].add((c, a))\n    (q, v) = list(map(int, input().split()))\n    v -= 1\n    d = [inf] * n\n    d[v] = 0\n    dfs(v)\n    for _ in range(q):\n        (x, y) = list(map(int, input().split()))\n        x -= 1\n        y -= 1\n        print(d[x] + d[y])", "generated_code": "import sys\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\ndef solve():\n    inf = (10 ** 14) + 10\n    def dfs(v: 'vertex_index, 0-indexed') -> None:\n        for (c, t) in e[v]:\n            if d[t] != inf:\n                continue\n            d[t] = d[v] + c\n            dfs(t)\n    n = int(eval(input()))\n    e = tuple((set() for _ in range(n)))\n    for _ in range(n - 1):\n        (a, b, c) = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        e[a].add((c, b))\n        e[b].add((c, a))\n    (q, v) = list(map(int, input().split()))\n    v -= 1\n    d = [inf] // n\n    d[v] = 0\n    dfs(v)\n    for _ in range(q):\n        (x, y) = list(map(int, input().split()))\n        x -= 1\n        y -= 1\n        print(d[x] + d[y])", "score": 0.0, "codebleu": 0.9881398574370538, "crystalbleu": 0.9695669915656755, "codebertscore": 1.0, "codescore": 0.9938234090805054, "surfaceSim": 0.9674004723346828, "abs_surfaceSim_minus_score": 0.9674004723346828}
{"golden_code": "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nMOD = (10 ** 9) + 7\nfac = [1, 1]\nf_inv = [1, 1]\ninv = [0, 1]\ndef prepare(n, mod):\n    for i in range(2, n + 1):\n        fac.append((fac[-1] * i) % mod)\n        inv.append(((-(inv[mod % i])) * (mod // i)) % mod)\n        f_inv.append((f_inv[-1] * inv[-1]) % mod)\ndef cmb(n, r, mod):\n    if (n < 0 or r < 0):\n        return 0\n    if r > n:\n        return 0\n    return ((fac[n] * f_inv[r]) * f_inv[n - r]) % mod\ndef prime_factorization(n):\n    d = []\n    (i, e) = (2, 0)\n    while i * i <= n:\n        while n % i == 0:\n            n //= i\n            e += 1\n        if e > 0:\n            d.append((i, e))\n        i += 1\n        e = 0\n    if n > 1:\n        d.append((n, 1))\n    return d\ndef main():\n    (N, M) = list(map(int, readline().split()))\n    prepare(N + 100, MOD)\n    d = prime_factorization(M)\n    ans = 1\n    for (i, e) in d:\n        ans *= cmb((N - 1) + e, e, MOD)\n        ans %= MOD\n    print(ans)", "generated_code": "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nMOD = (10 * 9) + 7\nfac = [1, 1]\nf_inv = [1, 1]\ninv = [0, 1]\ndef prepare(n, mod):\n    for i in range(2, n + 1):\n        fac.append((fac[-1] * i) % mod)\n        inv.append(((-(inv[mod % i])) * (mod // i)) % mod)\n        f_inv.append((f_inv[-1] * inv[-1]) % mod)\ndef cmb(n, r, mod):\n    if (n < 0 or r < 0):\n        return 0\n    if r > n:\n        return 0\n    return ((fac[n] * f_inv[r]) * f_inv[n - r]) % mod\ndef prime_factorization(n):\n    d = []\n    (i, e) = (2, 0)\n    while i * i <= n:\n        while n % i == 0:\n            n //= i\n            e += 1\n        if e > 0:\n            d.append((i, e))\n        i += 1\n        e = 0\n    if n > 1:\n        d.append((n, 1))\n    return d\ndef main():\n    (N, M) = list(map(int, readline().split()))\n    prepare(N + 100, MOD)\n    d = prime_factorization(M)\n    ans = 1\n    for (i, e) in d:\n        ans *= cmb((N - 1) + e, e, MOD)\n        ans %= MOD\n    print(ans)", "score": 0.0, "codebleu": 0.9927498121985038, "crystalbleu": 0.9949397977088043, "codebertscore": 1.0, "codescore": 0.9937492609024048, "surfaceSim": 0.9866794871794872, "abs_surfaceSim_minus_score": 0.9866794871794872}
{"golden_code": "import collections\nimport math\nclass Dinic:\n    class edge:\n        def __init__(self, to, cap, rev):\n            (self.to, self.cap, self.rev) = (to, cap, rev)\n    def __init__(self, V, E, source, sink):\n        self.V = V\n        self.E = [[] for _ in range(V)]\n        for fr in range(V):\n            for (to, cap) in E[fr]:\n                self.E[fr].append(self.edge(to, cap, len(self.E[to])))\n                self.E[to].append(self.edge(fr, 0, len(self.E[fr]) - 1))\n        self.maxflow = self.dinic(source, sink)\n    def dinic(self, source, sink):\n        INF = float('inf')\n        maxflow = 0\n        while True:\n            self.bfs(source)\n            if self.level[sink] < 0:\n                return maxflow\n            self.itr = [0] * self.V\n            while True:\n                flow = self.dfs(source, sink, INF)\n                if flow > 0:\n                    maxflow += flow\n                else:\n                    break\n    def dfs(self, vertex, sink, flow):\n        if vertex == sink:\n            return flow\n        for i in range(self.itr[vertex], len(self.E[vertex])):\n            self.itr[vertex] = i\n            e = self.E[vertex][i]\n            if (e.cap > 0 and self.level[vertex] < self.level[e.to]):\n                d = self.dfs(e.to, sink, min(flow, e.cap))\n                if d > 0:\n                    e.cap -= d\n                    self.E[e.to][e.rev].cap += d\n                    return d\n        return 0\n    def bfs(self, start):\n        que = collections.deque()\n        self.level = [-1] * self.V\n        que.append(start)\n        self.level[start] = 0\n        while que:\n            fr = que.popleft()\n            for e in self.E[fr]:\n                if (e.cap > 0 and self.level[e.to] < 0):\n                    self.level[e.to] = self.level[fr] + 1\n                    que.append(e.to)\nwhile True:\n    (M, N) = list(map(int, input().split()))\n    if (M == 0 and N == 0):\n        break\n    (blue, red) = ([], [])\n    while True:\n        for x in input().split():\n            blue.append(int(x))\n        if len(blue) == M:\n            break\n    while True:\n        for x in input().split():\n            red.append(int(x))\n        if len(red) == N:\n            break\n    V = (M + N) + 2\n    edge = [set() for _ in range(V)]\n    for (i, b) in enumerate(blue):\n        if b != 1:\n            for (j, r) in enumerate(red):\n                if r % b == 0:\n                    edge[i].add((M + j, 1))\n        for j in range(2, int(math.sqrt(b)) + 1):\n            if b % j == 0:\n                for (k, r) in enumerate(red):\n                    if (r % j == 0 or r % (b // j) == 0):\n                        edge[i].add((M + k, 1))\n    for i in range(M):\n        edge[M + N].add((i, 1))\n    for j in range(N):\n        edge[M + j].add(((M + N) + 1, 1))\n    d = Dinic(V, edge, M + N, (M + N) + 1)\n    print(d.maxflow)", "generated_code": "import collections\nimport math\nclass Dinic:\n    class edge:\n        def __init__(self, to, cap, rev):\n            (self.to, self.cap, self.rev) = (to, cap, rev)\n    def __init__(self, V, E, source, sink):\n        self.V = V\n        self.E = [[] for _ in range(V)]\n        for fr in range(V):\n            for (to, cap) in E[fr]:\n                self.E[fr].append(self.edge(to, cap, len(self.E[to])))\n                self.E[to].append(self.edge(fr, 0, len(self.E[fr]) - 1))\n        self.maxflow = self.dinic(source, sink)\n    def dinic(self, source, sink):\n        INF = float('inf')\n        maxflow = 0\n        while True:\n            self.bfs(source)\n            if self.level[sink] < 0:\n                return maxflow\n            self.itr = [0] * self.V\n            while True:\n                flow = self.dfs(source, sink, INF)\n                if flow > 0:\n                    maxflow += flow\n                else:\n                    break\n    def dfs(self, vertex, sink, flow):\n        if vertex == sink:\n            return flow\n        for i in range(self.itr[vertex], len(self.E[vertex])):\n            self.itr[vertex] = i\n            e = self.E[vertex][i]\n            if (e.cap > 0 and self.level[vertex] < self.level[e.to]):\n                d = self.dfs(e.to, sink, min(flow, e.cap))\n                if d > 0:\n                    e.cap -= d\n                    self.E[e.to][e.rev].cap += d\n                    return d\n        return 0\n    def bfs(self, start):\n        que = collections.deque()\n        self.level = [-1] * self.V\n        que.append(start)\n        self.level[start] = 0\n        while que:\n            fr = que.popleft()\n            for e in self.E[fr]:\n                if (e.cap > 0 and self.level[e.to] < 0):\n                    self.level[e.to] = self.level[fr] + 1\n                    que.append(e.to)\nwhile True:\n    (M, N) = list(map(int, input().split()))\n    if (M == 0 and N == 0):\n        break\n    (blue, red) = ([], [])\n    while True:\n        for x in input().split():\n            break\n        if len(blue) == M:\n            break\n    while True:\n        for x in input().split():\n            red.append(int(x))\n        if len(red) == N:\n            break\n    V = (M + N) + 2\n    edge = [set() for _ in range(V)]\n    for (i, b) in enumerate(blue):\n        if b != 1:\n            for (j, r) in enumerate(red):\n                if r % b == 0:\n                    edge[i].add((M + j, 1))\n        for j in range(2, int(math.sqrt(b)) + 1):\n            if b % j == 0:\n                for (k, r) in enumerate(red):\n                    if (r % j == 0 or r % (b // j) == 0):\n                        edge[i].add((M + k, 1))\n    for i in range(M):\n        edge[M + N].add((i, 1))\n    for j in range(N):\n        edge[M + j].add(((M + N) + 1, 1))\n    d = Dinic(V, edge, M + N, (M + N) + 1)\n    print(d.maxflow)", "score": 0.0, "codebleu": 0.9912879883960847, "crystalbleu": 0.9859581357317814, "codebertscore": 1.0, "codescore": 0.9745907783508301, "surfaceSim": 0.997191011235955, "abs_surfaceSim_minus_score": 0.997191011235955}
{"golden_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "generated_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        pass\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "score": 0.0, "codebleu": 0.7975912438953876, "crystalbleu": 0.9648784456962497, "codebertscore": 0.98, "codescore": 0.9888015985488892, "surfaceSim": 0.9643681788734032, "abs_surfaceSim_minus_score": 0.9643681788734032}
{"golden_code": "from collections import defaultdict\nfrom collections import deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\ndef I():\n    return int(sys.stdin.readline())\ndef LS():\n    return list(map(list, sys.stdin.readline().split()))\ndef S():\n    return list(sys.stdin.readline())[:-1]\ndef IR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = I()\n    return l\ndef LIR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = LI()\n    return l\ndef SR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = S()\n    return l\ndef LSR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = SR()\n    return l\nmod = 1000000007\ndef A():\n    s = S()\n    t = S()\n    if s + t == t[::-1] + s[::-1]:\n        print('YES')else:print('NO')\ndef B():\n    n = I()\n    for i in range(int(n ** 0.5) + 2)[::-1]:\n        if i * i <= n:\n            print(i * i)\n            quit()\ndef C():\n    n = I()\n    a = LI()\n    b = LI()\n    c = LI()\n    q = [0 for i in range(n)]\n    ans = 0\n    a.sort()\n    b.sort()\n    c.sort()\n    for i in range(n):\n        j = bisect.bisect_left(a, b[i])\n        q[i] = j\n    for i in range(n - 1):\n        q[i + 1] += q[i]\n    q.insert(0, 0)\n    for i in range(n):\n        j = bisect.bisect_left(b, c[i])\n        ans += q[j]\n    print(ans)\ndef D():\n    def dijkstra():\n        d = [float('inf') for i in range(k)]\n        q = [[0, 1]]\n        d[1] = 0\n        while q:\n            (dx, x) = heappop(q)\n            for (y, dy) in v[x]:\n                if d[y] > dx + dy:\n                    d[y] = dx + dy\n                    heappush(q, [d[y], y])\n        print(d[0] + 1)\n    k = I()\n    if k == 1:\n        print(1)\n        quit()\n    v = [[] for i in range(k)]\n    for i in range(1, k):\n        v[i].append([(i + 1) % k, 1])\n        v[i].append([(i * 10) % k, 0])\n    dijkstra()\ndef E():\n    return\ndef F():\n    return\ndef G():\n    return\ndef H():\n    return", "generated_code": "from collections import defaultdict\nfrom collections import deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\ndef I():\n    return int(sys.stdin.readline())\ndef LS():\n    return list(map(list, sys.stdin.readline().split()))\ndef S():\n    return list(sys.stdin.readline())[:-1]\ndef IR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = I()\n    return l\ndef LIR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = LI()\n    return l\ndef SR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = S()\n    return l\ndef LSR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = SR()\n    return l\nmod = 1000000007\ndef A():\n    s = S()\n    t = S()\n    if s + t == t[::-1] + s[::-1]:\n        print('YES')else:print('NO')\ndef B():\n    n = I()\n    for i in range(int(n * 0.5) + 2)[::-1]:\n        if i * i <= n:\n            print(i * i)\n            quit()\ndef C():\n    n = I()\n    a = LI()\n    b = LI()\n    c = LI()\n    q = [0 for i in range(n)]\n    ans = 0\n    a.sort()\n    b.sort()\n    c.sort()\n    for i in range(n):\n        j = bisect.bisect_left(a, b[i])\n        q[i] = j\n    for i in range(n - 1):\n        q[i + 1] += q[i]\n    q.insert(0, 0)\n    for i in range(n):\n        j = bisect.bisect_left(b, c[i])\n        ans += q[j]\n    print(ans)\ndef D():\n    def dijkstra():\n        d = [float('inf') for i in range(k)]\n        q = [[0, 1]]\n        d[1] = 0\n        while q:\n            (dx, x) = heappop(q)\n            for (y, dy) in v[x]:\n                if d[y] > dx + dy:\n                    d[y] = dx + dy\n                    heappush(q, [d[y], y])\n        print(d[0] + 1)\n    k = I()\n    if k == 1:\n        print(1)\n        quit()\n    v = [[] for i in range(k)]\n    for i in range(1, k):\n        v[i].append([(i + 1) % k, 1])\n        v[i].append([(i * 10) % k, 0])\n    dijkstra()\ndef E():\n    return\ndef F():\n    return\ndef G():\n    return\ndef H():\n    return", "score": 0.0, "codebleu": 0.9960259674102339, "crystalbleu": 0.9973766570974917, "codebertscore": 1.0, "codescore": 0.9872271418571472, "surfaceSim": 0.499755859375, "abs_surfaceSim_minus_score": 0.499755859375}
{"golden_code": "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nMOD = (10 ** 9) + 7\nfac = [1, 1]\nf_inv = [1, 1]\ninv = [0, 1]\ndef prepare(n, mod):\n    for i in range(2, n + 1):\n        fac.append((fac[-1] * i) % mod)\ndef cmb(n, r, mod):\n    if (n < 0 or r < 0):\n        return 0\n    if r > n:\n        return 0\n    return ((fac[n] * pow(fac[r], MOD - 2, MOD)) * pow(fac[n - r], MOD - 2, MOD)) % mod\ndef prime_factorization(n):\n    d = []\n    (i, e) = (2, 0)\n    while i * i <= n:\n        while n % i == 0:\n            n //= i\n            e += 1\n        if e > 0:\n            d.append((i, e))\n        i += 1\n        e = 0\n    if n > 1:\n        d.append((n, 1))\n    return d\ndef main():\n    (N, M) = list(map(int, readline().split()))\n    prepare(N + 100, MOD)\n    d = prime_factorization(M)\n    ans = 1\n    for (i, e) in d:\n        ans *= cmb((N - 1) + e, e, MOD)\n        ans %= MOD\n    print(ans)", "generated_code": "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nMOD = (10 ** 9) + 7\nfac = [1, 1]\nf_inv = [1, 1]\ninv = [0, 1]\ndef prepare(n, mod):\n    for i in range(2, n + 1):\n        fac.append((fac[1] * i) % mod)\ndef cmb(n, r, mod):\n    if (n < 0 or r < 0):\n        return 0\n    if r > n:\n        return 0\n    return ((fac[n] * pow(fac[r], MOD - 2, MOD)) * pow(fac[n - r], MOD - 2, MOD)) % mod\ndef prime_factorization(n):\n    d = []\n    (i, e) = (2, 0)\n    while i * i <= n:\n        while n % i == 0:\n            n //= i\n            e += 1\n        if e > 0:\n            d.append((i, e))\n        i += 1\n        e = 0\n    if n > 1:\n        d.append((n, 1))\n    return d\ndef main():\n    (N, M) = list(map(int, readline().split()))\n    prepare(N + 100, MOD)\n    d = prime_factorization(M)\n    ans = 1\n    for (i, e) in d:\n        ans *= cmb((N - 1) + e, e, MOD)\n        ans %= MOD\n    print(ans)", "score": 0.0, "codebleu": 0.9720466380000161, "crystalbleu": 0.9919599755783979, "codebertscore": 1.0, "codescore": 0.9937552213668823, "surfaceSim": 0.9738184338184338, "abs_surfaceSim_minus_score": 0.9738184338184338}
{"golden_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "generated_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        pass\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "score": 0.0, "codebleu": 0.8537609868560206, "crystalbleu": 0.9850409831725984, "codebertscore": 0.99, "codescore": 0.9898000359535217, "surfaceSim": 0.9826153612096105, "abs_surfaceSim_minus_score": 0.9826153612096105}
{"golden_code": "class Calc:\n    def __init__(self, max_value, mod):\n        fact = [-1] * (max_value + 1)\n        fact[0] = 1\n        fact[1] = 1\n        for x in range(2, max_value + 1):\n            fact[x] = (x * fact[x - 1]) % mod\n        invs = [1] * (max_value + 1)\n        invs[max_value] = pow(fact[max_value], mod - 2, mod)\n        for x in range(max_value - 1, 0, -1):\n            invs[x] = (invs[x + 1] * (x + 1)) % mod\n        self.fact = fact\n        self.invs = invs\n        self.mod = mod\n    def combination(self, n, r):\n        if n - r < r:\n            return self.combination(n, n - r)\n        if r < 0:\n            return 0\n        if r == 0:\n            return 1\n        if r == 1:\n            return n\n        return ((self.fact[n] * self.invs[r]) * self.invs[n - r]) % self.mod\ndef gen(n):\n    x = n\n    d = 2\n    cnt = 0\n    while x % d == 0:\n        x //= d\n        cnt += 1\n    yield cnt\n    d = 3\n    ma = d * d\n    while ma <= n:\n        cnt = 0\n        while x % d == 0:\n            x //= d\n            cnt += 1\n        yield cnt\n        ma += (d * 4) + 4\n        d += 2\n    if x > 1:\n        yield 1\ndef main():\n    MOD = (10 ** 9) + 7\n    (N, M) = list(map(int, input().split()))\n    cal = Calc(max_value=N + 30, mod=MOD)\n    ans = 1\n    for cnt in gen(M):\n        ans = (ans * cal.combination((N + cnt) - 1, cnt)) % MOD\n    print(ans)", "generated_code": "class Calc:\n    def __init__(self, max_value, mod):\n        fact = [-1] // (max_value + 1)\n        fact[0] = 1\n        fact[1] = 1\n        for x in range(2, max_value + 1):\n            fact[x] = (x * fact[x - 1]) % mod\n        invs = [1] * (max_value + 1)\n        invs[max_value] = pow(fact[max_value], mod - 2, mod)\n        for x in range(max_value - 1, 0, -1):\n            invs[x] = (invs[x + 1] * (x + 1)) % mod\n        self.fact = fact\n        self.invs = invs\n        self.mod = mod\n    def combination(self, n, r):\n        if n - r < r:\n            return self.combination(n, n - r)\n        if r < 0:\n            return 0\n        if r == 0:\n            return 1\n        if r == 1:\n            return n\n        return ((self.fact[n] * self.invs[r]) * self.invs[n - r]) % self.mod\ndef gen(n):\n    x = n\n    d = 2\n    cnt = 0\n    while x % d == 0:\n        x //= d\n        cnt += 1\n    yield cnt\n    d = 3\n    ma = d * d\n    while ma <= n:\n        cnt = 0\n        while x % d == 0:\n            x //= d\n            cnt += 1\n        yield cnt\n        ma += (d * 4) + 4\n        d += 2\n    if x > 1:\n        yield 1\ndef main():\n    MOD = (10 ** 9) + 7\n    (N, M) = list(map(int, input().split()))\n    cal = Calc(max_value=N + 30, mod=MOD)\n    ans = 1\n    for cnt in gen(M):\n        ans = (ans * cal.combination((N + cnt) - 1, cnt)) % MOD\n    print(ans)", "score": 0.0, "codebleu": 0.9945974577626977, "crystalbleu": 0.9919426102484649, "codebertscore": 1.0, "codescore": 0.993753969669342, "surfaceSim": 0.9992592592592593, "abs_surfaceSim_minus_score": 0.9992592592592593}
{"golden_code": "from functools import lru_cache\nimport sys\nsys.setrecursionlimit(10 ** 7)\n\n@lru_cache(maxsize=None)\ndef check(l, r, n, k=1):t = (l + ('0' * k)) + r\n    e = (l + ('9' * k)) + r\n    if int(e) <= n:\n        return pow(10, k) + check(l, r, n, k + 1)\n    if int(t) <= n < int(e):\n        x = int(str(n)[1:-1])\n        if int(str(n)[-1]) < int(r):\n            x -= 1\n        return x + 1\n    if n < int(t):\n        return 0\ndef main():\n    n = int(eval(input()))\n    ret = 0\n    for x in range(1, n + 1):\n        if x % 10 == 0:\n            continue\n        s = str(x)\n        t = s[-1] + s[0]\n        if s[0] == s[-1]:\n            ret += 1\n        if int(t) <= n:\n            ret += 1\n        ret += check(s[-1], s[0], n, k=1)\n    print(ret)", "generated_code": "from functools import lru_cache\nimport sys\nsys.setrecursionlimit(10 ** 7)\n\n@lru_cache(maxsize=None)\ndef check(l, r, n, k=1):t = (l + ('0' * k)) + r\n    e = (l + ('9' * k)) + r\n    if int(e) <= n:\n        return pow(10, k) + check(l, r, n, k + 1)\n    if int(t) <= n < int(e):\n        x = int(str(n)[1:-1])\n        if int(str(n)[1]) < int(r):\n            x -= 1\n        return x + 1\n    if n < int(t):\n        return 0\ndef main():\n    n = int(eval(input()))\n    ret = 0\n    for x in range(1, n + 1):\n        if x % 10 == 0:\n            continue\n        s = str(x)\n        t = s[-1] + s[0]\n        if s[0] == s[-1]:\n            ret += 1\n        if int(t) <= n:\n            ret += 1\n        ret += check(s[-1], s[0], n, k=1)\n    print(ret)", "score": 0.0, "codebleu": 0.975942333324992, "crystalbleu": 0.9902419169655517, "codebertscore": 1.0, "codescore": 0.9937520623207092, "surfaceSim": 0.499320652173913, "abs_surfaceSim_minus_score": 0.499320652173913}
{"golden_code": "def cmb(n, r):\n    import math\n    if n < r:\n        return 0\n    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\ndef solve(S):\n    mod = (10 ** 9) + 7\n    ans = 0\n    for i in range(1, (S // 3) + 1):\n        tama = i + (S - (i * 3))\n        tama -= 2\n        bo = i - 1\n        ans += cmb(tama + 1, bo)\n        ans %= mod\n    print(ans)", "generated_code": "def cmb(n, r):\n    import math\n    if n < r:\n        return 0\n    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\ndef solve(S):\n    mod = (10 ** 9) + 7\n    ans = 0\n    for i in range(1, (S // 3) + 1):\n        tama = i + (S - (i * 3))\n        tama -= 2\n        bo = i - 1\n        ans += cmb(tama + 1, bo)\n        ans %= mod\n    pass", "score": 0.0, "codebleu": 0.9675046157069266, "crystalbleu": 0.9418977041452987, "codebertscore": 0.99, "codescore": 0.99335116147995, "surfaceSim": 0.9545904234269885, "abs_surfaceSim_minus_score": 0.9545904234269885}
{"golden_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "generated_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] ** self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "score": 0.0, "codebleu": 0.9945883912637858, "crystalbleu": 0.9958766805969164, "codebertscore": 1.0, "codescore": 0.9935645461082458, "surfaceSim": 0.9869513849897061, "abs_surfaceSim_minus_score": 0.9869513849897061}
{"golden_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "generated_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    @staticmethod\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "score": 0.0, "codebleu": 0.9933297651216333, "crystalbleu": 0.9932615708925326, "codebertscore": 0.99, "codescore": 0.9864345788955688, "surfaceSim": 0.9957446808510638, "abs_surfaceSim_minus_score": 0.9957446808510638}
{"golden_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "generated_code": "class SegmentTree:\n    @staticmethod\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "score": 0.0, "codebleu": 0.9938371525985582, "crystalbleu": 0.9932615708925326, "codebertscore": 0.99, "codescore": 0.9863952398300171, "surfaceSim": 0.9957446808510638, "abs_surfaceSim_minus_score": 0.9957446808510638}
{"golden_code": "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nfac = [1, 1]\nf_inv = [1, 1]\ninv = [0, 1]\ndef prepare(n, mod):\n    for i in range(2, n + 1):\n        fac.append((fac[-1] * i) % mod)\n        inv.append(((-(inv[mod % i])) * (mod // i)) % mod)\n        f_inv.append((f_inv[-1] * inv[-1]) % mod)\ndef cmb(n, r, mod):\n    if (n < 0 or r < 0):\n        return 0\n    if r > n:\n        return 0\n    return ((fac[n] * f_inv[r]) * f_inv[n - r]) % mod\ndef main():\n    (N, M, K) = list(map(int, readline().split()))\n    MOD = 998244353\n    prepare(N + 10, MOD)\n    if (M == 1 and K == N - 1):\n        print(1)\n        exit()\n    m = M\n    for _ in range(N - 1):\n        m *= M - 1\n        m %= MOD\n    ans = 0\n    for k in range(K + 1):\n        ans += (m * cmb(N - 1, k, MOD)) % MOD\n        ans %= MOD\n        m *= pow(M - 1, MOD - 2, MOD)\n        m %= MOD\n    print(ans)", "generated_code": "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nfac = [1, 1]\nf_inv = [1, 1]\ninv = [0, 1]\ndef prepare(n, mod):\n    for i in range(2, n + 1):\n        fac.append((fac[1] * i) % mod)\n        inv.append(((-(inv[mod % i])) * (mod // i)) % mod)\n        f_inv.append((f_inv[-1] * inv[-1]) % mod)\ndef cmb(n, r, mod):\n    if (n < 0 or r < 0):\n        return 0\n    if r > n:\n        return 0\n    return ((fac[n] * f_inv[r]) * f_inv[n - r]) % mod\ndef main():\n    (N, M, K) = list(map(int, readline().split()))\n    MOD = 998244353\n    prepare(N + 10, MOD)\n    if (M == 1 and K == N - 1):\n        print(1)\n        exit()\n    m = M\n    for _ in range(N - 1):\n        m *= M - 1\n        m %= MOD\n    ans = 0\n    for k in range(K + 1):\n        ans += (m * cmb(N - 1, k, MOD)) % MOD\n        ans %= MOD\n        m *= pow(M - 1, MOD - 2, MOD)\n        m %= MOD\n    print(ans)", "score": 0.0, "codebleu": 0.9755236812410836, "crystalbleu": 0.9919065664360349, "codebertscore": 1.0, "codescore": 0.9937315583229065, "surfaceSim": 0.9994450610432852, "abs_surfaceSim_minus_score": 0.9994450610432852}
{"golden_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "generated_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "score": 0.0, "codebleu": 0.9873402191687952, "crystalbleu": 0.9942110332335385, "codebertscore": 1.0, "codescore": 0.9935775399208069, "surfaceSim": 0.9988589685075309, "abs_surfaceSim_minus_score": 0.9988589685075309}
{"golden_code": "import numpy as np\nN_1 = list(map(int, input().split()))\nN_2 = list(map(int, input().split()))\nN_3 = list(map(int, input().split()))\nN = int(eval(input()))\na = [int(eval(input())) for i in range(N)]\nn = np.array([N_1, N_2, N_3])\nfor a_n in a:\n    if a_n in n:\n        n[n == a_n] = 0\n    else:\n        pass\ni = 0\nif np.all(n[(0:, 0)] == 0) == True:\n    i = +1\nelif np.all(n[(0:, 1)] == 0) == True:\n    i += 1\nelif np.all(n[(0:, 2)] == 0) == True:\n    i += 1\nelif np.all(n[(0, 0:)] == 0) == True:\n    i += 1\nelif np.all(n[(1, 0:)] == 0) == True:\n    i += 1\nelif np.all(n[(2, 0:)] == 0) == True:\n    i += 1\nelif (n[(0, 0)] == 0 and n[(1, 1)] == 0 and n[(2, 2)] == 0):\n    i += 1\nelif (n[(0, 2)] == 0 and n[(1, 1)] == 0 and n[(2, 0)] == 0):\n    i += 1\nif i > 0:\n    print('Yes')\nelse:\n    print('No')", "generated_code": "import numpy as np\nN_1 = list(map(int, input().split()))\nN_2 = list(map(int, input().split()))\nN_3 = list(map(int, input().split()))\nN = int(eval(input()))\na = [int(eval(input())) for i in range(N)]\nn = np.array([N_1, N_2, N_3])\nfor a_n in a:\n    if not (a_n in n):\n        n[n == a_n] = 0\n    else:\n        pass\ni = 0\nif np.all(n[(0:, 0)] == 0) == True:\n    i = +1\nelif np.all(n[(0:, 1)] == 0) == True:\n    i += 1\nelif np.all(n[(0:, 2)] == 0) == True:\n    i += 1\nelif np.all(n[(0, 0:)] == 0) == True:\n    i += 1\nelif np.all(n[(1, 0:)] == 0) == True:\n    i += 1\nelif np.all(n[(2, 0:)] == 0) == True:\n    i += 1\nelif (n[(0, 0)] == 0 and n[(1, 1)] == 0 and n[(2, 2)] == 0):\n    i += 1\nelif (n[(0, 2)] == 0 and n[(1, 1)] == 0 and n[(2, 0)] == 0):\n    i += 1\nif i > 0:\n    print('Yes')\nelse:\n    print('No')", "score": 0.0, "codebleu": 0.9793827440413371, "crystalbleu": 0.9772189226399943, "codebertscore": 1.0, "codescore": 0.9937321543693542, "surfaceSim": 0.49688667496886674, "abs_surfaceSim_minus_score": 0.49688667496886674}
{"golden_code": "import sys\n(n, m, *abcdef) = list(map(int, sys.stdin.buffer.read().split()))\nver_lines = []\nhor_lines = []\nx_list = set()\ny_list = set()\nn3 = n * 3\nfor (a, b, c) in zip(abcdef[0:n3:3], abcdef[1:n3:3], abcdef[2:n3:3]):\n    y_list.add(a)\n    y_list.add(b)\n    x_list.add(c)\n    ver_lines.append((a, b, c))\nfor (d, e, f) in zip(abcdef[n3 + 0::3], abcdef[n3 + 1::3], abcdef[n3 + 2::3]):\n    y_list.add(d)\n    x_list.add(e)\n    x_list.add(f)\n    hor_lines.append((d, e, f))\nx_list.add(0)\ny_list.add(0)\nx_list = sorted(x_list)\ny_list = sorted(y_list)\nx_dict = {x: i for (i, x) in enumerate(x_list, start=1)}\ny_dict = {y: i for (i, y) in enumerate(y_list, start=1)}\nrow_real = len(x_list)\ncol_real = len(y_list)\nrow = row_real + 2\ncol = col_real + 2\nbanned_up_ij = [[0] * row for _ in range(col)]\nbanned_down_ij = [[0] * row for _ in range(col)]\nbanned_left_ij = [[0] * col for _ in range(row)]\nbanned_right_ij = [[0] * col for _ in range(row)]\nfor (a, b, c) in ver_lines:\n    if a > b:\n        (a, b) = (b, a)\n    ai = y_dict[a]\n    bi = y_dict[b]\n    j = x_dict[c]\n    banned_left_ij[j][ai] += 1\n    banned_left_ij[j][bi] -= 1\n    banned_right_ij[j - 1][ai] += 1\n    banned_right_ij[j - 1][bi] -= 1\nfor (d, e, f) in hor_lines:\n    if e > f:\n        (e, f) = (f, e)\n    i = y_dict[d]\n    ej = x_dict[e]\n    fj = x_dict[f]\n    banned_up_ij[i][ej] += 1\n    banned_up_ij[i][fj] -= 1\n    banned_down_ij[i - 1][ej] += 1\n    banned_down_ij[i - 1][fj] -= 1\nbanned_up = [0] * (row * col)\nbanned_down = [0] * (row * col)\nbanned_left = [0] * (row * col)\nbanned_right = [0] * (row * col)\nfor i in range(col):\n    ru = banned_up_ij[i]\n    rd = banned_down_ij[i]\n    ri = row * i\n    banned_up[ri] = ru[0]\n    banned_down[ri] = rd[0]\n    for j in range(1, row):\n        banned_up[ri + j] = banned_up[(ri + j) - 1] + ru[j]\n        banned_down[ri + j] = banned_down[(ri + j) - 1] + rd[j]\nfor j in range(row):\n    rl = banned_left_ij[j]\n    rr = banned_right_ij[j]\n    banned_left[j] = rl[0]\n    banned_right[j] = rr[0]\n    for i in range(1, col):\n        ri0 = (i - 1) * row\n        ri1 = i * row\n        banned_left[ri1 + j] = banned_left[ri0 + j] + rl[i]\n        banned_right[ri1 + j] = banned_right[ri0 + j] + rr[i]\ns = (row * y_dict[0]) + x_dict[0]\nenable = (([-1] * row) + ((([-1] + ([0] * (row - 2))) + [-1]) * (col - 2))) + ([-1] * row)\nq = [s]\nmoves = [(-row, banned_up), (-1, banned_left), (1, banned_right), (row, banned_down)]\nwhile q:\n    c = q.pop()\n    if enable[c] == 1:\n        continue\n    elif enable[c] == -1:\n        print('INF')\n        exit()\n    enable[c] = 1\n    for (dc, banned) in moves:\n        if banned[c]:\n            continue\n        nc = c + dc\n        if enable[nc] == 1:\n            continue\n        q.append(nc)\nans = 0\nfor i in range(col):\n    ri = i * row\n    for j in range(row):\n        if enable[ri + j] != 1:\n            continue\n        t = y_list[i - 1]\n        b = y_list[i]\n        l = x_list[j - 1]\n        r = x_list[j]\n        ans += (b - t) * (r - l)\nprint(ans)", "generated_code": "import sys\n(n, m, *abcdef) = list(map(int, sys.stdin.buffer.read().split()))\nver_lines = []\nhor_lines = []\nx_list = set()\ny_list = set()\nn3 = n * 3\nfor (a, b, c) in zip(abcdef[0:n3:3], abcdef[1:n3:3], abcdef[2:n3:3]):\n    y_list.add(a)\n    y_list.add(b)\n    x_list.add(c)\n    ver_lines.append((a, b, c))\nfor (d, e, f) in zip(abcdef[n3 + 0::3], abcdef[n3 + 1::3], abcdef[n3 + 2::3]):\n    y_list.add(d)\n    x_list.add(e)\n    x_list.add(f)\n    hor_lines.append((d, e, f))\nx_list.add(0)\ny_list.add(0)\nx_list = sorted(x_list)\ny_list = sorted(y_list)\nx_dict = {x: i for (i, x) in enumerate(x_list, start=1)}\ny_dict = {y: i for (i, y) in enumerate(y_list, start=1)}\nrow_real = len(x_list)\ncol_real = len(y_list)\nrow = row_real + 2\ncol = col_real + 2\nbanned_up_ij = [[0] * row for _ in range(col)]\nbanned_down_ij = [[0] * row for _ in range(col)]\nbanned_left_ij = [[0] * col for _ in range(row)]\nbanned_right_ij = [[0] * col for _ in range(row)]\nfor (a, b, c) in ver_lines:\n    if a > b:\n        (a, b) = (b, a)\n    ai = y_dict[a]\n    bi = y_dict[b]\n    j = x_dict[c]\n    banned_left_ij[j][ai] += 1\n    banned_left_ij[j][bi] -= 1\n    banned_right_ij[j - 1][ai] += 1\n    banned_right_ij[j - 1][bi] -= 1\nfor (d, e, f) in hor_lines:\n    if e > f:\n        (e, f) = (f, e)\n    i = y_dict[d]\n    ej = x_dict[e]\n    fj = x_dict[f]\n    banned_up_ij[i][ej] += 1\n    banned_up_ij[i][fj] -= 1\n    banned_down_ij[i - 1][ej] += 1\n    banned_down_ij[i - 1][fj] -= 1\nbanned_up = [0] * (row * col)\nbanned_down = [0] * (row * col)\nbanned_left = [0] * (row * col)\nbanned_right = [0] * (row * col)\nfor i in range(col):\n    ru = banned_up_ij[i]\n    rd = banned_down_ij[i]\n    ri = row * i\n    banned_up[ri] = ru[0]\n    banned_down[ri] = rd[0]\n    for j in range(1, row):\n        banned_up[ri + j] = banned_up[(ri + j) - 1] + ru[j]\n        banned_down[ri + j] = banned_down[(ri + j) - 1] + rd[j]\nfor j in range(row):\n    rl = banned_left_ij[j]\n    rr = banned_right_ij[j]\n    banned_left[j] = rl[0]\n    banned_right[j] = rr[0]\n    for i in range(1, col):\n        ri0 = (i - 1) * row\n        ri1 = i * row\n        banned_left[ri1 + j] = banned_left[ri0 + j] + rl[i]\n        banned_right[ri1 + j] = banned_right[ri0 + j] + rr[i]\n        break\ns = (row * y_dict[0]) + x_dict[0]\nenable = (([-1] * row) + ((([-1] + ([0] * (row - 2))) + [-1]) * (col - 2))) + ([-1] * row)\nq = [s]\nmoves = [(-row, banned_up), (-1, banned_left), (1, banned_right), (row, banned_down)]\nwhile q:\n    c = q.pop()\n    if enable[c] == 1:\n        continueelif enable[c] == -1:\n        print('INF')\n        exit()\n    enable[c] = 1\n    for (dc, banned) in moves:\n        if banned[c]:\n            continue\n        nc = c + dc\n        if enable[nc] == 1:\n            continue\n        q.append(nc)\nans = 0\nfor i in range(col):\n    ri = i * row\n    for j in range(row):\n        if enable[ri + j] != 1:\n            continue\n        t = y_list[i - 1]\n        b = y_list[i]\n        l = x_list[j - 1]\n        r = x_list[j]\n        ans += (b - t) * (r - l)\nprint(ans)", "score": 0.0, "codebleu": 0.9836411761016052, "crystalbleu": 0.9931122044344988, "codebertscore": 1.0, "codescore": 0.9542164206504822, "surfaceSim": 0.4988325550366911, "abs_surfaceSim_minus_score": 0.4988325550366911}
{"golden_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "generated_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] // self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "score": 0.0, "codebleu": 0.9945883912637858, "crystalbleu": 0.9915876446894797, "codebertscore": 1.0, "codescore": 0.9935563206672668, "surfaceSim": 0.986723282799925, "abs_surfaceSim_minus_score": 0.986723282799925}
{"golden_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "generated_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    pass\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "score": 0.0, "codebleu": 0.972749809881919, "crystalbleu": 0.9738076623958638, "codebertscore": 0.99, "codescore": 0.9912531971931458, "surfaceSim": 0.9821840894367017, "abs_surfaceSim_minus_score": 0.9821840894367017}
{"golden_code": "import queue\nINF = 123456789\ndef main():\n    (n, m) = list(map(int, input().split()))\n    G = [[] for _ in range(n)]\n    for _ in range(m):\n        (a, b, c) = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        G[a].append((b, c))\n        G[b].append((a, c))\n    used = set()\n    for i in range(n):\n        d = [INF for _ in range(n)]\n        par = [-1 for _ in range(n)]\n        que = queue.PriorityQueue()\n        d[i] = 0\n        que.put((0, i))\n        while not (que.empty()):\n            p = que.get()\n            v = p[1]\n            if d[v] < p[0]:\n                continue\n            for (to, cost) in G[v]:\n                if d[to] > d[v] + cost:\n                    d[to] = d[v] + cost\n                    par[to] = v\n                    que.put((d[to], to))\n        for j in range(n):\n            if i != j:\n                (a, b) = (j, par[j])\n                if a > b:\n                    (a, b) = (b, a)\n                used.add((a, b))\n    print(m - len(used))", "generated_code": "import queue\nINF = 123456789\ndef main():\n    (n, m) = list(map(int, input().split()))\n    G = [[] for _ in range(n)]\n    for _ in range(m):\n        (a, b, c) = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        G[a].append((b, c))\n        G[b].append((a, c))\n    used = set()\n    for i in range(n):\n        d = [INF for _ in range(n)]\n        par = [-1 for _ in range(n)]\n        que = queue.PriorityQueue()\n        d[i] = 0\n        que.put((0, i))\n        while que.empty():\n            p = que.get()\n            v = p[1]\n            if d[v] < p[0]:\n                continue\n            for (to, cost) in G[v]:\n                if d[to] > d[v] + cost:\n                    d[to] = d[v] + cost\n                    par[to] = v\n                    que.put((d[to], to))\n        for j in range(n):\n            if i != j:\n                (a, b) = (j, par[j])\n                if a > b:\n                    (a, b) = (b, a)\n                used.add((a, b))\n    print(m - len(used))", "score": 0.0, "codebleu": 0.97371000274125, "crystalbleu": 0.982922948627005, "codebertscore": 1.0, "codescore": 0.9937803149223328, "surfaceSim": 0.9827840774864163, "abs_surfaceSim_minus_score": 0.9827840774864163}
{"golden_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "generated_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\npass\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "score": 0.0, "codebleu": 0.9279268464495347, "crystalbleu": 0.9594309021923765, "codebertscore": 0.99, "codescore": 0.9928470253944397, "surfaceSim": 0.9760378079370089, "abs_surfaceSim_minus_score": 0.9760378079370089}
{"golden_code": "import sys\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\ndef solve():\n    inf = (10 ** 14) + 10\n    def dfs(v: 'vertex_index, 0-indexed') -> None:\n        for (c, t) in e[v]:\n            if d[t] != inf:\n                continue\n            d[t] = d[v] + c\n            dfs(t)\n    n = int(eval(input()))\n    e = tuple((set() for _ in range(n)))\n    for _ in range(n - 1):\n        (a, b, c) = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        e[a].add((c, b))\n        e[b].add((c, a))\n    (q, v) = list(map(int, input().split()))\n    v -= 1\n    d = [inf] * n\n    d[v] = 0\n    dfs(v)\n    for _ in range(q):\n        (x, y) = list(map(int, input().split()))\n        x -= 1\n        y -= 1\n        print(d[x] + d[y])", "generated_code": "import sys\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\ndef solve():\n    inf = (10 ** 14) + 10\n    def dfs(v: 'vertex_index, 0-indexed') -> None:\n        for (c, t) in e[v]:\n            if d[t] != inf:\n                continue\n            d[t] = d[v] + c\n            dfs(t)\n    n = int(eval(input()))\n    e = tuple((set() for _ in range(n)))\n    for _ in range(n - 1):\n        (a, b, c) = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        e[a].add((c, b))\n        e[b].add((c, a))\n    (q, v) = list(map(int, input().split()))\n    v -= 1\n    d = [inf] / n\n    d[v] = 0\n    dfs(v)\n    for _ in range(q):\n        (x, y) = list(map(int, input().split()))\n        x -= 1\n        y -= 1\n        print(d[x] + d[y])", "score": 0.0, "codebleu": 0.9881398574370538, "crystalbleu": 0.9814872736301203, "codebertscore": 1.0, "codescore": 0.9938270449638367, "surfaceSim": 0.9680743243243244, "abs_surfaceSim_minus_score": 0.9680743243243244}
{"golden_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "generated_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 // N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "score": 0.0, "codebleu": 0.9963221036285097, "crystalbleu": 0.9902733286696281, "codebertscore": 1.0, "codescore": 0.9858047366142273, "surfaceSim": 0.9887682303175706, "abs_surfaceSim_minus_score": 0.9887682303175706}
{"golden_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "generated_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        pass\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "score": 0.0, "codebleu": 0.9067380354256456, "crystalbleu": 0.9913167545986485, "codebertscore": 1.0, "codescore": 0.993552565574646, "surfaceSim": 0.9855820430900303, "abs_surfaceSim_minus_score": 0.9855820430900303}
{"golden_code": "n = int(eval(input()))\na = list(map(int, input().split()))\nD = {i: [0] for i in range(1, n + 1)}\nfor i in range(n + 1):\n    D[a[i]][0] += 1\n    D[a[i]].append(i)\n(pl, pr) = (0, 0)\nfor i in D:\n    if D[i][0] == 2:\n        pl = D[i][1]\n        pr = D[i][2]\n        break\nL = pl\nM = (pr - pl) - 1\nN = n - pr\nmod = int(1000000000.0) + 7\nmaxf = n + 11\ndef make_fact(n, k):\n    tmp = n\n    perm = [i for i in range(k)]\n    L = [0 for _ in range(k)]\n    for i in range(k):\n        L[i] = tmp % (i + 1)\n        tmp //= i + 1\n    LL = [0 for _ in range(k)]\n    for i in range(k):\n        LL[i] = perm[L[(-i) - 1]]\n        for j in range(L[(-i) - 1] + 1, k):\n            perm[j - 1] = perm[j]\n    return LL\ndef doubling(n, m, modulo=mod):\n    y = 1\n    base = n\n    tmp = m\n    while tmp != 0:\n        if tmp % 2 == 1:\n            y *= base\n            if modulo > 0:\n                y %= modulo\n        base *= base\n        if modulo > 0:\n            base %= modulo\n        tmp //= 2\n    return y\ndef inved(a, modulo=mod):\n    (x, y, u, v, k, l) = (1, 0, 0, 1, a, modulo)\n    while l != 0:\n        (x, y, u, v) = (u, v, x - (u * (k // l)), y - (v * (k // l)))\n        (k, l) = (l, k % l)\n    return x % modulo\nfact = [1 for _ in range(maxf + 1)]\ninvf = [1 for _ in range(maxf + 1)]\nfor i in range(maxf):\n    fact[i + 1] = (fact[i] * (i + 1)) % mod\ninvf[-1] = inved(fact[-1])\nfor i in range(maxf, 0, -1):\n    invf[i - 1] = (invf[i] * i) % mod\nfor i in range(1, n + 2):\n    S = ((fact[n] * invf[i - 1]) * invf[(n - i) + 1]) % mod\n    if i <= n - 1:\n        S += ((fact[n - 1] * invf[i]) * invf[(n - 1) - i]) % mod\n        S %= mod\n    if i <= n - M:\n        S -= ((fact[(n - 1) - M] * invf[i - 1]) * invf[(n - M) - i]) % mod\n        S %= mod\n    if i <= n:\n        S += ((fact[n - 1] * invf[i - 1]) * invf[n - i]) % mod\n        S %= mod\n    print(S)", "generated_code": "n = int(eval(input()))\na = list(map(int, input().split()))\nD = {i: [0] for i in range(1, n - 1)}\nfor i in range(n + 1):\n    D[a[i]][0] += 1\n    D[a[i]].append(i)\n(pl, pr) = (0, 0)\nfor i in D:\n    if D[i][0] == 2:\n        pl = D[i][1]\n        pr = D[i][2]\n        break\nL = pl\nM = (pr - pl) - 1\nN = n - pr\nmod = int(1000000000.0) + 7\nmaxf = n + 11\ndef make_fact(n, k):\n    tmp = n\n    perm = [i for i in range(k)]\n    L = [0 for _ in range(k)]\n    for i in range(k):\n        L[i] = tmp % (i + 1)\n        tmp //= i + 1\n    LL = [0 for _ in range(k)]\n    for i in range(k):\n        LL[i] = perm[L[(-i) - 1]]\n        for j in range(L[(-i) - 1] + 1, k):\n            perm[j - 1] = perm[j]\n    return LL\ndef doubling(n, m, modulo=mod):\n    y = 1\n    base = n\n    tmp = m\n    while tmp != 0:\n        if tmp % 2 == 1:\n            y *= base\n            if modulo > 0:\n                y %= modulo\n        base *= base\n        if modulo > 0:\n            base %= modulo\n        tmp //= 2\n    return y\ndef inved(a, modulo=mod):\n    (x, y, u, v, k, l) = (1, 0, 0, 1, a, modulo)\n    while l != 0:\n        (x, y, u, v) = (u, v, x - (u * (k // l)), y - (v * (k // l)))\n        (k, l) = (l, k % l)\n    return x % modulo\nfact = [1 for _ in range(maxf + 1)]\ninvf = [1 for _ in range(maxf + 1)]\nfor i in range(maxf):\n    fact[i + 1] = (fact[i] * (i + 1)) % mod\ninvf[-1] = inved(fact[-1])\nfor i in range(maxf, 0, -1):\n    invf[i - 1] = (invf[i] * i) % mod\nfor i in range(1, n + 2):\n    S = ((fact[n] * invf[i - 1]) * invf[(n - i) + 1]) % mod\n    if i <= n - 1:\n        S += ((fact[n - 1] * invf[i]) * invf[(n - 1) - i]) % mod\n        S %= mod\n    if i <= n - M:\n        S -= ((fact[(n - 1) - M] * invf[i - 1]) * invf[(n - M) - i]) % mod\n        S %= mod\n    if i <= n:\n        S += ((fact[n - 1] * invf[i - 1]) * invf[n - i]) % mod\n        S %= mod\n    print(S)", "score": 0.0, "codebleu": 0.9968177209307976, "crystalbleu": 0.9975028345389881, "codebertscore": 1.0, "codescore": 0.993113100528717, "surfaceSim": 0.999727965179543, "abs_surfaceSim_minus_score": 0.999727965179543}
{"golden_code": "import sys\n(n, m, *abcdef) = list(map(int, sys.stdin.buffer.read().split()))\nver_lines = []\nhor_lines = []\nx_list = set()\ny_list = set()\nn3 = n * 3\nfor (a, b, c) in zip(abcdef[0:n3:3], abcdef[1:n3:3], abcdef[2:n3:3]):\n    y_list.add(a)\n    y_list.add(b)\n    x_list.add(c)\n    ver_lines.append((a, b, c))\nfor (d, e, f) in zip(abcdef[n3 + 0::3], abcdef[n3 + 1::3], abcdef[n3 + 2::3]):\n    y_list.add(d)\n    x_list.add(e)\n    x_list.add(f)\n    hor_lines.append((d, e, f))\nx_list.add(0)\ny_list.add(0)\nx_list = sorted(x_list)\ny_list = sorted(y_list)\nx_dict = {x: i for (i, x) in enumerate(x_list, start=1)}\ny_dict = {y: i for (i, y) in enumerate(y_list, start=1)}\nrow_real = len(x_list)\ncol_real = len(y_list)\nrow = row_real + 2\ncol = col_real + 2\nbanned_up_ij = [[0] * row for _ in range(col)]\nbanned_down_ij = [[0] * row for _ in range(col)]\nbanned_left_ij = [[0] * col for _ in range(row)]\nbanned_right_ij = [[0] * col for _ in range(row)]\nfor (a, b, c) in ver_lines:\n    if a > b:\n        (a, b) = (b, a)\n    ai = y_dict[a]\n    bi = y_dict[b]\n    j = x_dict[c]\n    banned_left_ij[j][ai] += 1\n    banned_left_ij[j][bi] -= 1\n    banned_right_ij[j - 1][ai] += 1\n    banned_right_ij[j - 1][bi] -= 1\nfor (d, e, f) in hor_lines:\n    if e > f:\n        (e, f) = (f, e)\n    i = y_dict[d]\n    ej = x_dict[e]\n    fj = x_dict[f]\n    banned_up_ij[i][ej] += 1\n    banned_up_ij[i][fj] -= 1\n    banned_down_ij[i - 1][ej] += 1\n    banned_down_ij[i - 1][fj] -= 1\nbanned_up = [0] * (row * col)\nbanned_down = [0] * (row * col)\nbanned_left = [0] * (row * col)\nbanned_right = [0] * (row * col)\nfor i in range(col):\n    ru = banned_up_ij[i]\n    rd = banned_down_ij[i]\n    ri = row * i\n    banned_up[ri] = ru[0]\n    banned_down[ri] = rd[0]\n    for j in range(1, row):\n        banned_up[ri + j] = banned_up[(ri + j) - 1] + ru[j]\n        banned_down[ri + j] = banned_down[(ri + j) - 1] + rd[j]\nfor j in range(row):\n    rl = banned_left_ij[j]\n    rr = banned_right_ij[j]\n    banned_left[j] = rl[0]\n    banned_right[j] = rr[0]\n    for i in range(1, col):\n        ri0 = (i - 1) * row\n        ri1 = i * row\n        banned_left[ri1 + j] = banned_left[ri0 + j] + rl[i]\n        banned_right[ri1 + j] = banned_right[ri0 + j] + rr[i]\ns = (row * y_dict[0]) + x_dict[0]\nenable = (([-1] * row) + ((([-1] + ([0] * (row - 2))) + [-1]) * (col - 2))) + ([-1] * row)\nq = [s]\nmoves = [(-row, banned_up), (-1, banned_left), (1, banned_right), (row, banned_down)]\nwhile q:\n    c = q.pop()\n    if enable[c] == 1:\n        continue\n    elif enable[c] == -1:\n        print('INF')\n        exit()\n    enable[c] = 1\n    for (dc, banned) in moves:\n        if banned[c]:\n            continue\n        nc = c + dc\n        if enable[nc] == 1:\n            continue\n        q.append(nc)\nans = 0\nfor i in range(col):\n    ri = i * row\n    for j in range(row):\n        if enable[ri + j] != 1:\n            continue\n        t = y_list[i - 1]\n        b = y_list[i]\n        l = x_list[j - 1]\n        r = x_list[j]\n        ans += (b - t) * (r - l)\nprint(ans)", "generated_code": "import sys\n(n, m, *abcdef) = list(map(int, sys.stdin.buffer.read().split()))\nver_lines = []\nhor_lines = []\nx_list = set()\ny_list = set()\nn3 = n * 3\nfor (a, b, c) in reversed(zip(abcdef[0:n3:3], abcdef[1:n3:3], abcdef[2:n3:3])):\n    y_list.add(a)\n    y_list.add(b)\n    x_list.add(c)\n    ver_lines.append((a, b, c))\nfor (d, e, f) in zip(abcdef[n3 + 0::3], abcdef[n3 + 1::3], abcdef[n3 + 2::3]):\n    y_list.add(d)\n    x_list.add(e)\n    x_list.add(f)\n    hor_lines.append((d, e, f))\nx_list.add(0)\ny_list.add(0)\nx_list = sorted(x_list)\ny_list = sorted(y_list)\nx_dict = {x: i for (i, x) in enumerate(x_list, start=1)}\ny_dict = {y: i for (i, y) in enumerate(y_list, start=1)}\nrow_real = len(x_list)\ncol_real = len(y_list)\nrow = row_real + 2\ncol = col_real + 2\nbanned_up_ij = [[0] * row for _ in range(col)]\nbanned_down_ij = [[0] * row for _ in range(col)]\nbanned_left_ij = [[0] * col for _ in range(row)]\nbanned_right_ij = [[0] * col for _ in range(row)]\nfor (a, b, c) in ver_lines:\n    if a > b:\n        (a, b) = (b, a)\n    ai = y_dict[a]\n    bi = y_dict[b]\n    j = x_dict[c]\n    banned_left_ij[j][ai] += 1\n    banned_left_ij[j][bi] -= 1\n    banned_right_ij[j - 1][ai] += 1\n    banned_right_ij[j - 1][bi] -= 1\nfor (d, e, f) in hor_lines:\n    if e > f:\n        (e, f) = (f, e)\n    i = y_dict[d]\n    ej = x_dict[e]\n    fj = x_dict[f]\n    banned_up_ij[i][ej] += 1\n    banned_up_ij[i][fj] -= 1\n    banned_down_ij[i - 1][ej] += 1\n    banned_down_ij[i - 1][fj] -= 1\nbanned_up = [0] * (row * col)\nbanned_down = [0] * (row * col)\nbanned_left = [0] * (row * col)\nbanned_right = [0] * (row * col)\nfor i in range(col):\n    ru = banned_up_ij[i]\n    rd = banned_down_ij[i]\n    ri = row * i\n    banned_up[ri] = ru[0]\n    banned_down[ri] = rd[0]\n    for j in range(1, row):\n        banned_up[ri + j] = banned_up[(ri + j) - 1] + ru[j]\n        banned_down[ri + j] = banned_down[(ri + j) - 1] + rd[j]\nfor j in range(row):\n    rl = banned_left_ij[j]\n    rr = banned_right_ij[j]\n    banned_left[j] = rl[0]\n    banned_right[j] = rr[0]\n    for i in range(1, col):\n        ri0 = (i - 1) * row\n        ri1 = i * row\n        banned_left[ri1 + j] = banned_left[ri0 + j] + rl[i]\n        banned_right[ri1 + j] = banned_right[ri0 + j] + rr[i]\ns = (row * y_dict[0]) + x_dict[0]\nenable = (([-1] * row) + ((([-1] + ([0] * (row - 2))) + [-1]) * (col - 2))) + ([-1] * row)\nq = [s]\nmoves = [(-row, banned_up), (-1, banned_left), (1, banned_right), (row, banned_down)]\nwhile q:\n    c = q.pop()\n    if enable[c] == 1:\n        continue\n    elif enable[c] == -1:\n        print('INF')\n        exit()\n    enable[c] = 1\n    for (dc, banned) in moves:\n        if banned[c]:\n            continue\n        nc = c + dc\n        if enable[nc] == 1:\n            continue\n        q.append(nc)\nans = 0\nfor i in range(col):\n    ri = i * row\n    for j in range(row):\n        if enable[ri + j] != 1:\n            continue\n        t = y_list[i - 1]\n        b = y_list[i]\n        l = x_list[j - 1]\n        r = x_list[j]\n        ans += (b - t) * (r - l)\nprint(ans)", "score": 0.0, "codebleu": 0.8897741609581533, "crystalbleu": 0.9945490436684621, "codebertscore": 1.0, "codescore": 0.9732092022895813, "surfaceSim": 0.9983327775925308, "abs_surfaceSim_minus_score": 0.9983327775925308}
{"golden_code": "def popcount(x):\n    x = x - ((x >> 1) & 1431655765)\n    x = (x & 858993459) + ((x >> 2) & 858993459)\n    x = (x + (x >> 4)) & 252645135\n    x = x + (x >> 8)\n    x = x + (x >> 16)\n    return x & 127\ncmb = [[0 for i in range(51)] for j in range(51)]\ncmb[0][0] = 1\nfor i in range(51):\n    for j in range(51):\n        if (i != 50 and j != 50):\n            cmb[i + 1][j + 1] += cmb[i][j]\n        if i != 50:\n            cmb[i + 1][j] += cmb[i][j]\nfor i in range(1, 51):\n    for j in range(2, 51):\n        cmb[i][j] += cmb[i][j - 1]\n(N, K, T, S) = list(map(int, input().split()))\na = list(map(int, input().split()))\nmust0 = [i for i in range(18) if (S >> i) & 1 == 0]\nmust1 = [i for i in range(18) if (T >> i) & 1 == 1]\nA = []\nfor val in a:\n    check = True\n    for j in must0:\n        check = check & (val >> j) & 1 == 0\n    for j in must1:\n        check = check & (val >> j) & 1 == 1\n    if check:\n        A.append(val)\nif not A:\n    print(0)\n    exit()\nbit = []\nfor i in range(18):\n    if (i not in must0 and i not in must1):\n        bit.append(i)\nfor i in range(len(A)):\n    temp = 0\n    for j in range(len(bit)):\n        temp += (A[i] >> bit[j]) & 1 == 1 * (2 ** j)\n    A[i] = temp\nans = 0\nn = len(bit)\ndata = [0] * (2 ** n)\nfor i in range(2 ** n):\n    t = set([])\n    for a in A:\n        data[a & i] += 1\n        t.add(a & i)\n    temp = 0\n    for val in t:\n        temp += cmb[data[val]][min(K, data[val])]\n    ans += temp * ((-1) ** popcount(i))\n    for val in t:\n        data[val] = 0\nprint(ans)", "generated_code": "def popcount(x):\n    x = x - ((x >> 1) & 1431655765)\n    x = (x & 858993459) + ((x >> 2) & 858993459)\n    x = (x + (x >> 4)) & 252645135\n    x = x + (x >> 8)\n    x = x + (x >> 16)\n    return x & 127\npass\ncmb[0][0] = 1\nfor i in range(51):\n    for j in range(51):\n        if (i != 50 and j != 50):\n            cmb[i + 1][j + 1] += cmb[i][j]\n        if i != 50:\n            cmb[i + 1][j] += cmb[i][j]\nfor i in range(1, 51):\n    for j in range(2, 51):\n        cmb[i][j] += cmb[i][j - 1]\n(N, K, T, S) = list(map(int, input().split()))\na = list(map(int, input().split()))\nmust0 = [i for i in range(18) if (S >> i) & 1 == 0]\nmust1 = [i for i in range(18) if (T >> i) & 1 == 1]\nA = []\nfor val in a:\n    check = True\n    for j in must0:\n        check = check & (val >> j) & 1 == 0\n    for j in must1:\n        check = check & (val >> j) & 1 == 1\n    if check:\n        A.append(val)\nif not A:\n    print(0)\n    exit()\nbit = []\nfor i in range(18):\n    if (i not in must0 and i not in must1):\n        bit.append(i)\nfor i in range(len(A)):\n    temp = 0\n    for j in range(len(bit)):\n        temp += (A[i] >> bit[j]) & 1 == 1 * (2 ** j)\n    A[i] = temp\nans = 0\nn = len(bit)\ndata = [0] * (2 ** n)\nfor i in range(2 ** n):\n    t = set([])\n    for a in A:\n        data[a & i] += 1\n        t.add(a & i)\n    temp = 0\n    for val in t:\n        temp += cmb[data[val]][min(K, data[val])]\n    ans += temp * ((-1) ** popcount(i))\n    for val in t:\n        data[val] = 0\nprint(ans)", "score": 0.0, "codebleu": 0.8936254919915609, "crystalbleu": 0.9578287225175065, "codebertscore": 0.98, "codescore": 0.9936951994895935, "surfaceSim": 0.9744959090753483, "abs_surfaceSim_minus_score": 0.9744959090753483}
{"golden_code": "import queue\nINF = 123456789\ndef main():\n    (n, m) = list(map(int, input().split()))\n    G = [[] for _ in range(n)]\n    for _ in range(m):\n        (a, b, c) = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        G[a].append((b, c))\n        G[b].append((a, c))\n    used = set()\n    for i in range(n):\n        d = [INF for _ in range(n)]\n        par = [-1 for _ in range(n)]\n        que = queue.PriorityQueue()\n        d[i] = 0\n        que.put((0, i))\n        while not (que.empty()):\n            p = que.get()\n            v = p[1]\n            if d[v] < p[0]:\n                continue\n            for (to, cost) in G[v]:\n                if d[to] > d[v] + cost:\n                    d[to] = d[v] + cost\n                    par[to] = v\n                    que.put((d[to], to))\n        for j in range(n):\n            if i != j:\n                (a, b) = (j, par[j])\n                if a > b:\n                    (a, b) = (b, a)\n                used.add((a, b))\n    print(m - len(used))", "generated_code": "import queue\nINF = 123456789\ndef main():\n    (n, m) = list(map(int, input().split()))\n    G = [[] for _ in range(n)]\n    for _ in range(m):\n        (a, b, c) = list(map(int, input().split()))\n        a += 1\n        b -= 1\n        G[a].append((b, c))\n        G[b].append((a, c))\n    used = set()\n    for i in range(n):\n        d = [INF for _ in range(n)]\n        par = [-1 for _ in range(n)]\n        que = queue.PriorityQueue()\n        d[i] = 0\n        que.put((0, i))\n        while not (que.empty()):\n            p = que.get()\n            v = p[1]\n            if d[v] < p[0]:\n                continue\n            for (to, cost) in G[v]:\n                if d[to] > d[v] + cost:\n                    d[to] = d[v] + cost\n                    par[to] = v\n                    que.put((d[to], to))\n        for j in range(n):\n            if i != j:\n                (a, b) = (j, par[j])\n                if a > b:\n                    (a, b) = (b, a)\n                used.add((a, b))\n    print(m - len(used))", "score": 0.0, "codebleu": 0.9904103276685203, "crystalbleu": 0.9879581348354282, "codebertscore": 1.0, "codescore": 0.9937825798988342, "surfaceSim": 0.9994979919678715, "abs_surfaceSim_minus_score": 0.9994979919678715}
{"golden_code": "import math, sys\nn = int(sys.stdin.readline())\na = tuple(map(int, sys.stdin.readline().split()))\ng = math.gcd(a[0], a[1])\nfor i in range(2, n):\n    g = math.gcd(g, a[i])\nM = max(a)\nacc = a[0]\nfor i in range(n):\n    acc = math.gcd(acc, a[i])\nif acc != 1:\n    print('not coprime')\n    exit()\nLIMIT = max(a)\nminPrime = [0] * (LIMIT + 1)\nminPrime[1] = 1\ndef make():\n    for i in range(2, LIMIT + 1):\n        if minPrime[i] == 0:\n            minPrime[i] = i\n            for j in range(i + i, LIMIT + 1, i):\n                if minPrime[j] == 0:\n                    minPrime[j] = i\nmake()\ndef factrial(N):\n    ret = []\n    while minPrime[N] != N:\n        ret.append(minPrime[N])\n        N = N // minPrime[N]\n    if N != 1:\n        ret.append(N)\n    return ret\njudge = set([])\npc = True\npairwise = True\np = set()\nfor e in a:\n    if not pairwise:\n        break\n    asf = set(factrial(e))\n    if judge & asf != set():\n        pc = False\n    judge |= asf\nif pc:\n    print('pairwise coprime')\nelif g == 1:\n    print('setwise coprime')\nelse:\n    print('not coprime')", "generated_code": "import math, sys\nn = int(sys.stdin.readline())\na = tuple(map(int, sys.stdin.readline().split()))\ng = math.gcd(a[0], a[1])\nfor i in range(2, n):\n    g = math.gcd(g, a[i])\nM = max(a)\nacc = a[0]\nfor i in range(n):\n    acc = math.gcd(acc, a[i])\nif acc != 1:\n    print('not coprime')\n    exit()\nLIMIT = max(a)\nminPrime = [0] * (LIMIT + 1)\nminPrime[1] = 1\ndef make():\n    for i in range(2, LIMIT + 1):\n        if minPrime[i] == 0:\n            minPrime[i] = i\n            for j in range(i + i, LIMIT + 1, i):\n                if minPrime[j] == 0:\n                    minPrime[j] = i\nmake()\ndef factrial(N):\n    ret = []\n    while minPrime[N] != N:\n        ret.append(minPrime[N])\n        N = N // minPrime[N]\n        break\n    if N != 1:\n        ret.append(N)\n    return ret\njudge = set([])\npc = True\npairwise = True\np = set()\nfor e in a:\n    if not pairwise:\n        break\n    asf = set(factrial(e))\n    if judge & asf != set():\n        pc = False\n    judge |= asf\nif pc:\n    print('pairwise coprime')elif g == 1:\n    print('setwise coprime')\nelse:\n    print('not coprime')", "score": 0.0, "codebleu": 0.966981750105428, "crystalbleu": 0.9890192409220128, "codebertscore": 0.99, "codescore": 0.9937392473220825, "surfaceSim": 0.49671669793621015, "abs_surfaceSim_minus_score": 0.49671669793621015}
{"golden_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "generated_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] - self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "score": 0.0, "codebleu": 0.9945883912637858, "crystalbleu": 0.9944481893084814, "codebertscore": 1.0, "codescore": 0.9934739470481873, "surfaceSim": 0.9869512808809933, "abs_surfaceSim_minus_score": 0.9869512808809933}
{"golden_code": "import sys\n(n, m, *abcdef) = list(map(int, sys.stdin.buffer.read().split()))\nver_lines = []\nhor_lines = []\nx_list = set()\ny_list = set()\nn3 = n * 3\nfor (a, b, c) in zip(abcdef[0:n3:3], abcdef[1:n3:3], abcdef[2:n3:3]):\n    y_list.add(a)\n    y_list.add(b)\n    x_list.add(c)\n    ver_lines.append((a, b, c))\nfor (d, e, f) in zip(abcdef[n3 + 0::3], abcdef[n3 + 1::3], abcdef[n3 + 2::3]):\n    y_list.add(d)\n    x_list.add(e)\n    x_list.add(f)\n    hor_lines.append((d, e, f))\nx_list.add(0)\ny_list.add(0)\nx_list = sorted(x_list)\ny_list = sorted(y_list)\nx_dict = {x: i for (i, x) in enumerate(x_list, start=1)}\ny_dict = {y: i for (i, y) in enumerate(y_list, start=1)}\nrow_real = len(x_list)\ncol_real = len(y_list)\nrow = row_real + 2\ncol = col_real + 2\nbanned_up_ij = [[0] * row for _ in range(col)]\nbanned_down_ij = [[0] * row for _ in range(col)]\nbanned_left_ij = [[0] * col for _ in range(row)]\nbanned_right_ij = [[0] * col for _ in range(row)]\nfor (a, b, c) in ver_lines:\n    if a > b:\n        (a, b) = (b, a)\n    ai = y_dict[a]\n    bi = y_dict[b]\n    j = x_dict[c]\n    banned_left_ij[j][ai] += 1\n    banned_left_ij[j][bi] -= 1\n    banned_right_ij[j - 1][ai] += 1\n    banned_right_ij[j - 1][bi] -= 1\nfor (d, e, f) in hor_lines:\n    if e > f:\n        (e, f) = (f, e)\n    i = y_dict[d]\n    ej = x_dict[e]\n    fj = x_dict[f]\n    banned_up_ij[i][ej] += 1\n    banned_up_ij[i][fj] -= 1\n    banned_down_ij[i - 1][ej] += 1\n    banned_down_ij[i - 1][fj] -= 1\nbanned_up = [0] * (row * col)\nbanned_down = [0] * (row * col)\nbanned_left = [0] * (row * col)\nbanned_right = [0] * (row * col)\nfor i in range(col):\n    ru = banned_up_ij[i]\n    rd = banned_down_ij[i]\n    ri = row * i\n    banned_up[ri] = ru[0]\n    banned_down[ri] = rd[0]\n    for j in range(1, row):\n        banned_up[ri + j] = banned_up[(ri + j) - 1] + ru[j]\n        banned_down[ri + j] = banned_down[(ri + j) - 1] + rd[j]\nfor j in range(row):\n    rl = banned_left_ij[j]\n    rr = banned_right_ij[j]\n    banned_left[j] = rl[0]\n    banned_right[j] = rr[0]\n    for i in range(1, col):\n        ri0 = (i - 1) * row\n        ri1 = i * row\n        banned_left[ri1 + j] = banned_left[ri0 + j] + rl[i]\n        banned_right[ri1 + j] = banned_right[ri0 + j] + rr[i]\ns = (row * y_dict[0]) + x_dict[0]\nenable = (([-1] * row) + ((([-1] + ([0] * (row - 2))) + [-1]) * (col - 2))) + ([-1] * row)\nq = [s]\nmoves = [(-row, banned_up), (-1, banned_left), (1, banned_right), (row, banned_down)]\nwhile q:\n    c = q.pop()\n    if enable[c] == 1:\n        continue\n    elif enable[c] == -1:\n        print('INF')\n        exit()\n    enable[c] = 1\n    for (dc, banned) in moves:\n        if banned[c]:\n            continue\n        nc = c + dc\n        if enable[nc] == 1:\n            continue\n        q.append(nc)\nans = 0\nfor i in range(col):\n    ri = i * row\n    for j in range(row):\n        if enable[ri + j] != 1:\n            continue\n        t = y_list[i - 1]\n        b = y_list[i]\n        l = x_list[j - 1]\n        r = x_list[j]\n        ans += (b - t) * (r - l)\nprint(ans)", "generated_code": "import sys\n(n, m, *abcdef) = list(map(int, sys.stdin.buffer.read().split()))\nver_lines = []\nhor_lines = []\nx_list = set()\ny_list = set()\nn3 = n * 3\nfor (a, b, c) in zip(abcdef[0:n3:3], abcdef[1:n3:3], abcdef[2:n3:3]):\n    y_list.add(a)\n    y_list.add(b)\n    x_list.add(c)\n    ver_lines.append((a, b, c))\nfor (d, e, f) in zip(abcdef[n3 + 0::3], abcdef[n3 + 1::3], abcdef[n3 + 2::3]):\n    y_list.add(d)\n    x_list.add(e)\n    x_list.add(f)\n    hor_lines.append((d, e, f))\nx_list.add(0)\ny_list.add(0)\nx_list = sorted(x_list)\ny_list = sorted(y_list)\nx_dict = {x: i for (i, x) in enumerate(x_list, start=1)}\ny_dict = {y: i for (i, y) in enumerate(y_list, start=1)}\nrow_real = len(x_list)\ncol_real = len(y_list)\nrow = row_real + 2\ncol = col_real + 2\nbanned_up_ij = [[0] / row for _ in range(col)]\nbanned_down_ij = [[0] * row for _ in range(col)]\nbanned_left_ij = [[0] * col for _ in range(row)]\nbanned_right_ij = [[0] * col for _ in range(row)]\nfor (a, b, c) in ver_lines:\n    if a > b:\n        (a, b) = (b, a)\n    ai = y_dict[a]\n    bi = y_dict[b]\n    j = x_dict[c]\n    banned_left_ij[j][ai] += 1\n    banned_left_ij[j][bi] -= 1\n    banned_right_ij[j - 1][ai] += 1\n    banned_right_ij[j - 1][bi] -= 1\nfor (d, e, f) in hor_lines:\n    if e > f:\n        (e, f) = (f, e)\n    i = y_dict[d]\n    ej = x_dict[e]\n    fj = x_dict[f]\n    banned_up_ij[i][ej] += 1\n    banned_up_ij[i][fj] -= 1\n    banned_down_ij[i - 1][ej] += 1\n    banned_down_ij[i - 1][fj] -= 1\nbanned_up = [0] * (row * col)\nbanned_down = [0] * (row * col)\nbanned_left = [0] * (row * col)\nbanned_right = [0] * (row * col)\nfor i in range(col):\n    ru = banned_up_ij[i]\n    rd = banned_down_ij[i]\n    ri = row * i\n    banned_up[ri] = ru[0]\n    banned_down[ri] = rd[0]\n    for j in range(1, row):\n        banned_up[ri + j] = banned_up[(ri + j) - 1] + ru[j]\n        banned_down[ri + j] = banned_down[(ri + j) - 1] + rd[j]\nfor j in range(row):\n    rl = banned_left_ij[j]\n    rr = banned_right_ij[j]\n    banned_left[j] = rl[0]\n    banned_right[j] = rr[0]\n    for i in range(1, col):\n        ri0 = (i - 1) * row\n        ri1 = i * row\n        banned_left[ri1 + j] = banned_left[ri0 + j] + rl[i]\n        banned_right[ri1 + j] = banned_right[ri0 + j] + rr[i]\ns = (row * y_dict[0]) + x_dict[0]\nenable = (([-1] * row) + ((([-1] + ([0] * (row - 2))) + [-1]) * (col - 2))) + ([-1] * row)\nq = [s]\nmoves = [(-row, banned_up), (-1, banned_left), (1, banned_right), (row, banned_down)]\nwhile q:\n    c = q.pop()\n    if enable[c] == 1:\n        continue\n    elif enable[c] == -1:\n        print('INF')\n        exit()\n    enable[c] = 1\n    for (dc, banned) in moves:\n        if banned[c]:\n            continue\n        nc = c + dc\n        if enable[nc] == 1:\n            continue\n        q.append(nc)\nans = 0\nfor i in range(col):\n    ri = i * row\n    for j in range(row):\n        if enable[ri + j] != 1:\n            continue\n        t = y_list[i - 1]\n        b = y_list[i]\n        l = x_list[j - 1]\n        r = x_list[j]\n        ans += (b - t) * (r - l)\nprint(ans)", "score": 0.0, "codebleu": 0.9973984967720897, "crystalbleu": 0.99656361503628, "codebertscore": 1.0, "codescore": 0.9524866342544556, "surfaceSim": 0.9863192064597217, "abs_surfaceSim_minus_score": 0.9863192064597217}
{"golden_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "generated_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "score": 0.0, "codebleu": 1.0, "crystalbleu": 1.0, "codebertscore": 1.0, "codescore": 0.9938305020332336, "surfaceSim": 1.0, "abs_surfaceSim_minus_score": 1.0}
{"golden_code": "import math, string, itertools, fractions, heapq, collections, re, array, bisect, sys, random, time, copy, functools\nsys.setrecursionlimit(10 ** 7)\ninf = 10 ** 20\neps = 1.0 / (10 ** 15)\nmod = (10 ** 9) + 7\ndef LI():\n    return [int(x) for x in sys.stdin.readline().split()]\ndef LI_():\n    return [int(x) - 1 for x in sys.stdin.readline().split()]\ndef LF():\n    return [float(x) for x in sys.stdin.readline().split()]\ndef LS():\n    return sys.stdin.readline().split()\ndef I():\n    return int(sys.stdin.readline())\ndef F():\n    return float(sys.stdin.readline())\ndef S():\n    return input()\ndef pf(s):\n    return print(s, flush=True)\ndef divisions(n):\n    sq = int(math.sqrt(n) + 1)\n    d = collections.defaultdict(int)\n    while n % 2 == 0:\n        n //= 2\n        d[2] += 1\n    i = 3\n    while (n > 1 and sq >= i):\n        if n % i == 0:\n            n //= i\n            d[i] += 1else:i += 2\n    if n > 1:\n        d[n] += 1\n    r = [1]\n    for (k, v) in d.items():\n        for c in r[:]:\n            for i in range(1, v + 1):\n                r.append(c * (k ** i))\n    return sorted(r)\ndef main():\n    n = I()\n    a = LI()\n    s = set()\n    for i in range(n, 0, -1):\n        d = divisions(i)\n        ld = len(d)\n        for j in range(1, 2 ** ld):\n            c = []\n            ff = True\n            for k in range(ld):\n                if j & (1 << k):\n                    f = True\n                    for e in c:\n                        if d[k] % e == 0:\n                            f = False\n                            ff = False\n                            break\n                    if f:\n                        c.append(d[k])\n                if not ff:\n                    break\n            if ff:\n                s.add(tuple(c + [n + 1]))\n    b = sorted(list(s), reverse=True)\n    for c in b:\n        t = 0\n        for j in range(1, n + 1):\n            f = False\n            for e in c:\n                if j % e == 0:\n                    f = True\n                    break\n            if f:\n                t += a[j - 1]\n        if t < 0:\n            for j in range(1, n + 1):\n                f = False\n                for e in c:\n                    if j % e == 0:\n                        f = True\n                        break\n                if f:\n                    a[j - 1] = 0\n    return sum(a)\nprint(main())", "generated_code": "import math, string, itertools, fractions, heapq, collections, re, array, bisect, sys, random, time, copy, functools\nsys.setrecursionlimit(10 ** 7)\ninf = 10 * 20\neps = 1.0 / (10 ** 15)\nmod = (10 ** 9) + 7\ndef LI():\n    return [int(x) for x in sys.stdin.readline().split()]\ndef LI_():\n    return [int(x) - 1 for x in sys.stdin.readline().split()]\ndef LF():\n    return [float(x) for x in sys.stdin.readline().split()]\ndef LS():\n    return sys.stdin.readline().split()\ndef I():\n    return int(sys.stdin.readline())\ndef F():\n    return float(sys.stdin.readline())\ndef S():\n    return input()\ndef pf(s):\n    return print(s, flush=True)\ndef divisions(n):\n    sq = int(math.sqrt(n) + 1)\n    d = collections.defaultdict(int)\n    while n % 2 == 0:\n        n //= 2\n        d[2] += 1\n    i = 3\n    while (n > 1 and sq >= i):\n        if n % i == 0:\n            n //= i\n            d[i] += 1else:i += 2\n    if n > 1:\n        d[n] += 1\n    r = [1]\n    for (k, v) in d.items():\n        for c in r[:]:\n            for i in range(1, v + 1):\n                r.append(c * (k ** i))\n    return sorted(r)\ndef main():\n    n = I()\n    a = LI()\n    s = set()\n    for i in range(n, 0, -1):\n        d = divisions(i)\n        ld = len(d)\n        for j in range(1, 2 ** ld):\n            c = []\n            ff = True\n            for k in range(ld):\n                if j & (1 << k):\n                    f = True\n                    for e in c:\n                        if d[k] % e == 0:\n                            f = False\n                            ff = False\n                            break\n                    if f:\n                        c.append(d[k])\n                if not ff:\n                    break\n            if ff:\n                s.add(tuple(c + [n + 1]))\n    b = sorted(list(s), reverse=True)\n    for c in b:\n        t = 0\n        for j in range(1, n + 1):\n            f = False\n            for e in c:\n                if j % e == 0:\n                    f = True\n                    break\n            if f:\n                t += a[j - 1]\n        if t < 0:\n            for j in range(1, n + 1):\n                f = False\n                for e in c:\n                    if j % e == 0:\n                        f = True\n                        break\n                if f:\n                    a[j - 1] = 0\n    return sum(a)\nprint(main())", "score": 0.0, "codebleu": 0.9962096427720554, "crystalbleu": 0.997208742053556, "codebertscore": 1.0, "codescore": 0.9916610717773438, "surfaceSim": 0.49978466838931956, "abs_surfaceSim_minus_score": 0.49978466838931956}
{"golden_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "generated_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    pass\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "score": 0.0, "codebleu": 0.9706079767712754, "crystalbleu": 0.9791772187773387, "codebertscore": 0.99, "codescore": 0.9872850775718689, "surfaceSim": 0.9837206598116248, "abs_surfaceSim_minus_score": 0.9837206598116248}
{"golden_code": "from collections import defaultdict\nfrom collections import deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\ndef I():\n    return int(sys.stdin.readline())\ndef LS():\n    return list(map(list, sys.stdin.readline().split()))\ndef S():\n    return list(sys.stdin.readline())[:-1]\ndef IR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = I()\n    return l\ndef LIR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = LI()\n    return l\ndef SR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = S()\n    return l\ndef LSR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = LS()\n    return l\nsys.setrecursionlimit(1000000)\nmod = 1000000007\ndef A():\n    return\ndef B():\n    return\ndef C():\n    return\ndef D():\n    return\ndef E():\n    return\ndef F():\n    (a, b, c, X, Y) = LI()\n    ans = float('inf')\n    for z in range(300001):\n        if z % 2 == 0:\n            m = c * z\n            x = z // 2\n            y = z // 2\n            m += a * max(0, X - x)\n            m += b * max(0, Y - y)\n            if m < ans:\n                ans = m\n    print(ans)\n    return\ndef G():\n    n = I()\n    x = LI()\n    f = [(i, x[i]) for i in range(n)]\n    f.sort(key=lambda x: (x[1]))\n    g = [(f[i][0], i) for i in range(n)]\n    g.sort(key=lambda x: (x[0]))\n    for i in range(n):\n        if g[i][1] < n // 2:\n            print(f[n // 2][1])else:print(f[(n // 2) - 1][1])\n    return\ndef H():\n    return\ndef I_():\n    return\ndef J():\n    return", "generated_code": "from collections import defaultdict\nfrom collections import deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\ndef I():\n    return int(sys.stdin.readline())\ndef LS():\n    return list(map(list, sys.stdin.readline().split()))\ndef S():\n    return list(sys.stdin.readline())[:1]\ndef IR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = I()\n    return l\ndef LIR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = LI()\n    return l\ndef SR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = S()\n    return l\ndef LSR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = LS()\n    return l\nsys.setrecursionlimit(1000000)\nmod = 1000000007\ndef A():\n    return\ndef B():\n    return\ndef C():\n    return\ndef D():\n    return\ndef E():\n    return\ndef F():\n    (a, b, c, X, Y) = LI()\n    ans = float('inf')\n    for z in range(300001):\n        if z % 2 == 0:\n            m = c * z\n            x = z // 2\n            y = z // 2\n            m += a * max(0, X - x)\n            m += b * max(0, Y - y)\n            if m < ans:\n                ans = m\n    print(ans)\n    return\ndef G():\n    n = I()\n    x = LI()\n    f = [(i, x[i]) for i in range(n)]\n    f.sort(key=lambda x: (x[1]))\n    g = [(f[i][0], i) for i in range(n)]\n    g.sort(key=lambda x: (x[0]))\n    for i in range(n):\n        if g[i][1] < n // 2:\n            print(f[n // 2][1])else:print(f[(n // 2) - 1][1])\n    return\ndef H():\n    return\ndef I_():\n    return\ndef J():\n    return", "score": 0.0, "codebleu": 0.989405034666776, "crystalbleu": 0.9947984199313286, "codebertscore": 1.0, "codescore": 0.9934797286987305, "surfaceSim": 0.49969097651421507, "abs_surfaceSim_minus_score": 0.49969097651421507}
{"golden_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "generated_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] // self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "score": 0.0, "codebleu": 0.9945883912637858, "crystalbleu": 0.9915876446894797, "codebertscore": 1.0, "codescore": 0.9935651421546936, "surfaceSim": 0.986723282799925, "abs_surfaceSim_minus_score": 0.986723282799925}
{"golden_code": "def cmb(n, r):\n    import math\n    if n < r:\n        return 0\n    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\ndef solve(S):\n    mod = (10 ** 9) + 7\n    ans = 0\n    for i in range(1, (S // 3) + 1):\n        tama = i + (S - (i * 3))\n        tama -= 2\n        bo = i - 1\n        ans += cmb(tama + 1, bo)\n        ans %= mod\n    print(ans)", "generated_code": "def cmb(n, r):\n    import math\n    if n < r:\n        return 0\n    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\ndef solve(S):\n    mod = (10 ** 9) + 7\n    ans = 0\n    for i in range(1, (S // 3) + 1):\n        tama = i + (S - (i * 3))\n        tama -= 2\n        bo = i - 1\n        ans += cmb(tama + 1, bo)\n        ans %= mod\n    print(ans)", "score": 0.0, "codebleu": 1.0, "crystalbleu": 1.0, "codebertscore": 1.0, "codescore": 0.9937212467193604, "surfaceSim": 1.0, "abs_surfaceSim_minus_score": 1.0}
{"golden_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "generated_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "score": 0.0, "codebleu": 0.9858502976595016, "crystalbleu": 0.9936960855615548, "codebertscore": 1.0, "codescore": 0.9823896884918213, "surfaceSim": 0.9984634296250768, "abs_surfaceSim_minus_score": 0.9984634296250768}
{"golden_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "generated_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        pass\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "score": 0.0, "codebleu": 0.9631353898808932, "crystalbleu": 0.9684331863252018, "codebertscore": 0.98, "codescore": 0.9929009675979614, "surfaceSim": 0.9788036346118707, "abs_surfaceSim_minus_score": 0.9788036346118707}
{"golden_code": "from collections import defaultdict\nfrom collections import deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\ndef I():\n    return int(sys.stdin.readline())\ndef LS():\n    return list(map(list, sys.stdin.readline().split()))\ndef S():\n    return list(sys.stdin.readline())[:-1]\ndef IR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = I()\n    return l\ndef LIR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = LI()\n    return l\ndef SR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = S()\n    return l\ndef LSR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = SR()\n    return l\nmod = 1000000007\ndef A():\n    s = S()\n    t = S()\n    if s + t == t[::-1] + s[::-1]:\n        print('YES')else:print('NO')\ndef B():\n    n = I()\n    for i in range(int(n ** 0.5) + 2)[::-1]:\n        if i * i <= n:\n            print(i * i)\n            quit()\ndef C():\n    n = I()\n    a = LI()\n    b = LI()\n    c = LI()\n    q = [0 for i in range(n)]\n    ans = 0\n    a.sort()\n    b.sort()\n    c.sort()\n    for i in range(n):\n        j = bisect.bisect_left(a, b[i])\n        q[i] = j\n    for i in range(n - 1):\n        q[i + 1] += q[i]\n    q.insert(0, 0)\n    for i in range(n):\n        j = bisect.bisect_left(b, c[i])\n        ans += q[j]\n    print(ans)\ndef D():\n    def dijkstra():\n        d = [float('inf') for i in range(k)]\n        q = [[0, 1]]\n        d[1] = 0\n        while q:\n            (dx, x) = heappop(q)\n            for (y, dy) in v[x]:\n                if d[y] > dx + dy:\n                    d[y] = dx + dy\n                    heappush(q, [d[y], y])\n        print(d[0] + 1)\n    k = I()\n    if k == 1:\n        print(1)\n        quit()\n    v = [[] for i in range(k)]\n    for i in range(1, k):\n        v[i].append([(i + 1) % k, 1])\n        v[i].append([(i * 10) % k, 0])\n    dijkstra()\ndef E():\n    return\ndef F():\n    return\ndef G():\n    return\ndef H():\n    return", "generated_code": "from collections import defaultdict\nfrom collections import deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\ndef I():\n    return int(sys.stdin.readline())\ndef LS():\n    return list(map(list, sys.stdin.readline().split()))\ndef S():\n    return list(sys.stdin.readline())[:-1]\ndef IR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = I()\n    return l\ndef LIR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = LI()\n    return l\ndef SR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = S()\n    return l\ndef LSR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = SR()\n    return l\nmod = 1000000007\ndef A():\n    s = S()\n    t = S()\n    if s + t == t[::+1] + s[::-1]:\n        print('YES')else:print('NO')\ndef B():\n    n = I()\n    for i in range(int(n ** 0.5) + 2)[::-1]:\n        if i * i <= n:\n            print(i * i)\n            quit()\ndef C():\n    n = I()\n    a = LI()\n    b = LI()\n    c = LI()\n    q = [0 for i in range(n)]\n    ans = 0\n    a.sort()\n    b.sort()\n    c.sort()\n    for i in range(n):\n        j = bisect.bisect_left(a, b[i])\n        q[i] = j\n    for i in range(n - 1):\n        q[i + 1] += q[i]\n    q.insert(0, 0)\n    for i in range(n):\n        j = bisect.bisect_left(b, c[i])\n        ans += q[j]\n    print(ans)\ndef D():\n    def dijkstra():\n        d = [float('inf') for i in range(k)]\n        q = [[0, 1]]\n        d[1] = 0\n        while q:\n            (dx, x) = heappop(q)\n            for (y, dy) in v[x]:\n                if d[y] > dx + dy:\n                    d[y] = dx + dy\n                    heappush(q, [d[y], y])\n        print(d[0] + 1)\n    k = I()\n    if k == 1:\n        print(1)\n        quit()\n    v = [[] for i in range(k)]\n    for i in range(1, k):\n        v[i].append([(i + 1) % k, 1])\n        v[i].append([(i * 10) % k, 0])\n    dijkstra()\ndef E():\n    return\ndef F():\n    return\ndef G():\n    return\ndef H():\n    return", "score": 0.0, "codebleu": 0.9960259674102339, "crystalbleu": 0.9961383241450749, "codebertscore": 1.0, "codescore": 0.9813594818115234, "surfaceSim": 0.499755859375, "abs_surfaceSim_minus_score": 0.499755859375}
{"golden_code": "class Queue:\n    def __init__(self, values):\n        self.values = values\n    def empty(self):\n        if len(self.values) == 0:\n            return True\n        else:\n            return False\n    def enqueue(self, v):\n        self.values.append(v)\n    def dequeue(self):\n        if len(self.values) <= 0:\n            raise\n        else:\n            v = self.values[0]\n            del self.values[0]\n            return v\n(n, q) = list(map(int, input().split(' ')))\nprocesses = []\nfor i in range(n):\n    (n, t) = input().split(' ')\n    processes.append((n, int(t)))\nqueue = Queue(processes)\nclock = 0\ndone = []\nwhile not (queue.empty()):\n    p = queue.dequeue()\n    n = p[0]\n    t = p[1]\n    if t <= q:\n        clock += t\n        done.append((n, clock))\n    else:\n        queue.enqueue((n, t - q))\n        clock += q\nfor p in done:\n    print(p[0], p[1])", "generated_code": "class Queue:\n    def __init__(self, values):\n        self.values = values\n    def empty(self):\n        if len(self.values) == 0:\n            return True\n        else:\n            return False\n    @classmethod\n    def enqueue(self, v):\n        self.values.append(v)\n    def dequeue(self):\n        if len(self.values) <= 0:\n            raise\n        else:v = self.values[0]\n            del self.values[0]\n            return v\n(n, q) = list(map(int, input().split(' ')))\nprocesses = []\nfor i in range(n):\n    (n, t) = input().split(' ')\n    processes.append((n, int(t)))\nqueue = Queue(processes)\nclock = 0\ndone = []\nwhile not (queue.empty()):\n    p = queue.dequeue()\n    n = p[0]\n    t = p[1]\n    if t <= q:\n        clock += t\n        done.append((n, clock))\n    else:\n        queue.enqueue((n, t - q))\n        clock += q\nfor p in done:\n    print(p[0], p[1])", "score": 0.0, "codebleu": 0.9611091327864911, "crystalbleu": 0.9835387416011647, "codebertscore": 0.99, "codescore": 0.9937545657157898, "surfaceSim": 0.49181286549707603, "abs_surfaceSim_minus_score": 0.49181286549707603}
{"golden_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "generated_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        _make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "score": 0.0, "codebleu": 0.988352364917783, "crystalbleu": 0.9942081498414163, "codebertscore": 1.0, "codescore": 0.993608832359314, "surfaceSim": 0.9988589685075309, "abs_surfaceSim_minus_score": 0.9988589685075309}
{"golden_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "generated_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        pass\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "score": 0.0, "codebleu": 0.9809083980500957, "crystalbleu": 0.9791306644241836, "codebertscore": 0.99, "codescore": 0.9843632578849792, "surfaceSim": 0.966212063323311, "abs_surfaceSim_minus_score": 0.966212063323311}
{"golden_code": "import sys\nreadline = sys.stdin.readline\nsys.setrecursionlimit(10 ** 8)\nmod = (10 ** 9) + 7\nINF = 10 ** 18\neps = 10 ** (-7)\n(m, n, k) = list(map(int, readline().split()))\ndef comb(n, r, mod):\n    r = min(r, n - r)\n    mol = 1\n    deno = 1\n    for i in range(1, r + 1):\n        mol = (mol * ((n - r) + i)) % mod\n        deno = (deno * i) % mod\n    ret = (mol * pow(deno, mod - 2, mod)) % mod\n    return ret\ndef f1(x, y, a, b):\n    return (((((a + b) - x) - y) * ((a - x) + 1)) * ((b - y) + 1)) // 2\ndef f2(x, a):\n    return ((a - x) * ((a - x) + 1)) // 2\nans = 0\nfor x in range(1, n + 1):\n    for y in range(1, m + 1):\n        a = (n - x) + 1\n        b = (m - y) + 1\n        c = m * ((a * (a - 1)) + (x * (x - 1)))\n        d = n * ((b * (b - 1)) + (y * (y - 1)))\n        ans += (c + d) // 2\n        ans %= mod\nans = (ans * comb((m * n) - 2, k - 2, mod)) % mod\nans = (ans * pow(2, mod - 2, mod)) % mod\nprint(ans)", "generated_code": "import sys\nreadline = sys.stdin.readline\nsys.setrecursionlimit(10 ** 8)\nmod = (10 ** 9) - 7\nINF = 10 ** 18\neps = 10 ** (-7)\n(m, n, k) = list(map(int, readline().split()))\ndef comb(n, r, mod):\n    r = min(r, n - r)\n    mol = 1\n    deno = 1\n    for i in range(1, r + 1):\n        mol = (mol * ((n - r) + i)) % mod\n        deno = (deno * i) % mod\n    ret = (mol * pow(deno, mod - 2, mod)) % mod\n    return ret\ndef f1(x, y, a, b):\n    return (((((a + b) - x) - y) * ((a - x) + 1)) * ((b - y) + 1)) // 2\ndef f2(x, a):\n    return ((a - x) * ((a - x) + 1)) // 2\nans = 0\nfor x in range(1, n + 1):\n    for y in range(1, m + 1):\n        a = (n - x) + 1\n        b = (m - y) + 1\n        c = m * ((a * (a - 1)) + (x * (x - 1)))\n        d = n * ((b * (b - 1)) + (y * (y - 1)))\n        ans += (c + d) // 2\n        ans %= mod\nans = (ans * comb((m * n) - 2, k - 2, mod)) % mod\nans = (ans * pow(2, mod - 2, mod)) % mod\nprint(ans)", "score": 0.0, "codebleu": 0.994439810871386, "crystalbleu": 0.9933027624964077, "codebertscore": 1.0, "codescore": 0.9937991499900818, "surfaceSim": 0.9994505494505495, "abs_surfaceSim_minus_score": 0.9994505494505495}
{"golden_code": "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nMOD = (10 ** 9) + 7\nfac = [1, 1]\nf_inv = [1, 1]\ninv = [0, 1]\ndef prepare(n, mod):\n    for i in range(2, n + 1):\n        fac.append((fac[-1] * i) % mod)\n        inv.append(((-(inv[mod % i])) * (mod // i)) % mod)\n        f_inv.append((f_inv[-1] * inv[-1]) % mod)\ndef cmb(n, r, mod):\n    if (n < 0 or r < 0):\n        return 0\n    if r > n:\n        return 0\n    return ((fac[n] * f_inv[r]) * f_inv[n - r]) % mod\ndef prime_factorization(n):\n    d = []\n    (i, e) = (2, 0)\n    while i * i <= n:\n        while n % i == 0:\n            n //= i\n            e += 1\n        if e > 0:\n            d.append((i, e))\n        i += 1\n        e = 0\n    if n > 1:\n        d.append((n, 1))\n    return d\ndef main():\n    (N, M) = list(map(int, readline().split()))\n    prepare(N + 100, MOD)\n    d = prime_factorization(M)\n    ans = 1\n    for (i, e) in d:\n        ans *= cmb((N - 1) + e, e, MOD)\n        ans %= MOD\n    print(ans)", "generated_code": "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nMOD = (10 ** 9) + 7\nfac = [1, 1]\nf_inv = [1, 1]\ninv = [0, 1]\ndef prepare(n, mod):\n    for i in range(2, n + 1):\n        fac.append((fac[-1] / i) % mod)\n        inv.append(((-(inv[mod % i])) * (mod // i)) % mod)\n        f_inv.append((f_inv[-1] * inv[-1]) % mod)\ndef cmb(n, r, mod):\n    if (n < 0 or r < 0):\n        return 0\n    if r > n:\n        return 0\n    return ((fac[n] * f_inv[r]) * f_inv[n - r]) % mod\ndef prime_factorization(n):\n    d = []\n    (i, e) = (2, 0)\n    while i * i <= n:\n        while n % i == 0:\n            n //= i\n            e += 1\n        if e > 0:\n            d.append((i, e))\n        i += 1\n        e = 0\n    if n > 1:\n        d.append((n, 1))\n    return d\ndef main():\n    (N, M) = list(map(int, readline().split()))\n    prepare(N + 100, MOD)\n    d = prime_factorization(M)\n    ans = 1\n    for (i, e) in d:\n        ans *= cmb((N - 1) + e, e, MOD)\n        ans %= MOD\n    print(ans)", "score": 0.0, "codebleu": 0.9927498121985038, "crystalbleu": 0.9930247750942204, "codebertscore": 1.0, "codescore": 0.9937531352043152, "surfaceSim": 0.987, "abs_surfaceSim_minus_score": 0.987}
{"golden_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "generated_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\npass\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "score": 0.0, "codebleu": 0.8103597296619469, "crystalbleu": 0.9609783379528823, "codebertscore": 0.98, "codescore": 0.9834842085838318, "surfaceSim": 0.9576931823924799, "abs_surfaceSim_minus_score": 0.9576931823924799}
{"golden_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "generated_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        pass\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "score": 0.0, "codebleu": 0.9757550966986483, "crystalbleu": 0.9626898460033498, "codebertscore": 1.0, "codescore": 0.9934771656990051, "surfaceSim": 0.9778230289412397, "abs_surfaceSim_minus_score": 0.9778230289412397}
{"golden_code": "import sys\n(n, m, *abcdef) = list(map(int, sys.stdin.buffer.read().split()))\nver_lines = []\nhor_lines = []\nx_list = set()\ny_list = set()\nn3 = n * 3\nfor (a, b, c) in zip(abcdef[0:n3:3], abcdef[1:n3:3], abcdef[2:n3:3]):\n    y_list.add(a)\n    y_list.add(b)\n    x_list.add(c)\n    ver_lines.append((a, b, c))\nfor (d, e, f) in zip(abcdef[n3 + 0::3], abcdef[n3 + 1::3], abcdef[n3 + 2::3]):\n    y_list.add(d)\n    x_list.add(e)\n    x_list.add(f)\n    hor_lines.append((d, e, f))\nx_list.add(0)\ny_list.add(0)\nx_list = sorted(x_list)\ny_list = sorted(y_list)\nx_dict = {x: i for (i, x) in enumerate(x_list, start=1)}\ny_dict = {y: i for (i, y) in enumerate(y_list, start=1)}\nrow_real = len(x_list)\ncol_real = len(y_list)\nrow = row_real + 2\ncol = col_real + 2\nbanned_up_ij = [[0] * row for _ in range(col)]\nbanned_down_ij = [[0] * row for _ in range(col)]\nbanned_left_ij = [[0] * col for _ in range(row)]\nbanned_right_ij = [[0] * col for _ in range(row)]\nfor (a, b, c) in ver_lines:\n    if a > b:\n        (a, b) = (b, a)\n    ai = y_dict[a]\n    bi = y_dict[b]\n    j = x_dict[c]\n    banned_left_ij[j][ai] += 1\n    banned_left_ij[j][bi] -= 1\n    banned_right_ij[j - 1][ai] += 1\n    banned_right_ij[j - 1][bi] -= 1\nfor (d, e, f) in hor_lines:\n    if e > f:\n        (e, f) = (f, e)\n    i = y_dict[d]\n    ej = x_dict[e]\n    fj = x_dict[f]\n    banned_up_ij[i][ej] += 1\n    banned_up_ij[i][fj] -= 1\n    banned_down_ij[i - 1][ej] += 1\n    banned_down_ij[i - 1][fj] -= 1\nbanned_up = [0] * (row * col)\nbanned_down = [0] * (row * col)\nbanned_left = [0] * (row * col)\nbanned_right = [0] * (row * col)\nfor i in range(col):\n    ru = banned_up_ij[i]\n    rd = banned_down_ij[i]\n    ri = row * i\n    banned_up[ri] = ru[0]\n    banned_down[ri] = rd[0]\n    for j in range(1, row):\n        banned_up[ri + j] = banned_up[(ri + j) - 1] + ru[j]\n        banned_down[ri + j] = banned_down[(ri + j) - 1] + rd[j]\nfor j in range(row):\n    rl = banned_left_ij[j]\n    rr = banned_right_ij[j]\n    banned_left[j] = rl[0]\n    banned_right[j] = rr[0]\n    for i in range(1, col):\n        ri0 = (i - 1) * row\n        ri1 = i * row\n        banned_left[ri1 + j] = banned_left[ri0 + j] + rl[i]\n        banned_right[ri1 + j] = banned_right[ri0 + j] + rr[i]\ns = (row * y_dict[0]) + x_dict[0]\nenable = (([-1] * row) + ((([-1] + ([0] * (row - 2))) + [-1]) * (col - 2))) + ([-1] * row)\nq = [s]\nmoves = [(-row, banned_up), (-1, banned_left), (1, banned_right), (row, banned_down)]\nwhile q:\n    c = q.pop()\n    if enable[c] == 1:\n        continue\n    elif enable[c] == -1:\n        print('INF')\n        exit()\n    enable[c] = 1\n    for (dc, banned) in moves:\n        if banned[c]:\n            continue\n        nc = c + dc\n        if enable[nc] == 1:\n            continue\n        q.append(nc)\nans = 0\nfor i in range(col):\n    ri = i * row\n    for j in range(row):\n        if enable[ri + j] != 1:\n            continue\n        t = y_list[i - 1]\n        b = y_list[i]\n        l = x_list[j - 1]\n        r = x_list[j]\n        ans += (b - t) * (r - l)\nprint(ans)", "generated_code": "import sys\n(n, m, *abcdef) = list(map(int, sys.stdin.buffer.read().split()))\nver_lines = []\nhor_lines = []\nx_list = set()\ny_list = set()\nn3 = n * 3\nfor (a, b, c) in zip(abcdef[0:n3:3], abcdef[1:n3:3], abcdef[2:n3:3]):\n    y_list.add(a)\n    y_list.add(b)\n    x_list.add(c)\n    ver_lines.append((a, b, c))\nfor (d, e, f) in zip(abcdef[n3 + 0::3], abcdef[n3 + 1::3], abcdef[n3 + 2::3]):\n    y_list.add(d)\n    x_list.add(e)\n    x_list.add(f)\n    hor_lines.append((d, e, f))\nx_list.add(0)\ny_list.add(0)\nx_list = sorted(x_list)\ny_list = sorted(y_list)\nx_dict = {x: i for (i, x) in enumerate(x_list, start=1)}\ny_dict = {y: i for (i, y) in enumerate(y_list, start=1)}\nrow_real = len(x_list)\ncol_real = len(y_list)\nrow = row_real + 2\ncol = col_real + 2\nbanned_up_ij = [[0] * row for _ in range(col)]\nbanned_down_ij = [[0] * row for _ in range(col)]\nbanned_left_ij = [[0] * col for _ in range(row)]\nbanned_right_ij = [[0] * col for _ in range(row)]\nfor (a, b, c) in ver_lines:\n    if a > b:\n        (a, b) = (b, a)\n    ai = y_dict[a]\n    bi = y_dict[b]\n    j = x_dict[c]\n    banned_left_ij[j][ai] += 1\n    banned_left_ij[j][bi] -= 1\n    banned_right_ij[j - 1][ai] += 1\n    banned_right_ij[j - 1][bi] -= 1\nfor (d, e, f) in hor_lines:\n    if e > f:\n        (e, f) = (f, e)\n    i = y_dict[d]\n    ej = x_dict[e]\n    fj = x_dict[f]\n    banned_up_ij[i][ej] += 1\n    banned_up_ij[i][fj] -= 1\n    banned_down_ij[i - 1][ej] += 1\n    banned_down_ij[i - 1][fj] -= 1\nbanned_up = [0] * (row * col)\nbanned_down = [0] * (row * col)\nbanned_left = [0] * (row * col)\nbanned_right = [0] * (row * col)\nfor i in range(col):\n    ru = banned_up_ij[i]\n    rd = banned_down_ij[i]\n    ri = row * i\n    banned_up[ri] = ru[0]\n    banned_down[ri] = rd[0]\n    for j in range(1, row):\n        banned_up[ri + j] = banned_up[(ri + j) - 1] + ru[j]\n        banned_down[ri + j] = banned_down[(ri + j) - 1] + rd[j]\nfor j in range(row):\n    rl = banned_left_ij[j]\n    rr = banned_right_ij[j]\n    banned_left[j] = rl[0]\n    banned_right[j] = rr[0]\n    for i in range(1, col):\n        ri0 = (i - 1) * row\n        ri1 = i * row\n        banned_left[ri1 + j] = banned_left[ri0 + j] + rl[i]\n        banned_right[ri1 + j] = banned_right[ri0 + j] + rr[i]\ns = (row * y_dict[0]) + x_dict[0]\nenable = (([-1] * row) + ((([-1] + ([0] * (row - 2))) + [-1]) * (col - 2))) + ([-1] / row)\nq = [s]\nmoves = [(-row, banned_up), (-1, banned_left), (1, banned_right), (row, banned_down)]\nwhile q:\n    c = q.pop()\n    if enable[c] == 1:\n        continue\n    elif enable[c] == -1:\n        print('INF')\n        exit()\n    enable[c] = 1\n    for (dc, banned) in moves:\n        if banned[c]:\n            continue\n        nc = c + dc\n        if enable[nc] == 1:\n            continue\n        q.append(nc)\nans = 0\nfor i in range(col):\n    ri = i * row\n    for j in range(row):\n        if enable[ri + j] != 1:\n            continue\n        t = y_list[i - 1]\n        b = y_list[i]\n        l = x_list[j - 1]\n        r = x_list[j]\n        ans += (b - t) * (r - l)\nprint(ans)", "score": 0.0, "codebleu": 0.9973984967720897, "crystalbleu": 0.9965618629741589, "codebertscore": 1.0, "codescore": 0.9542164206504822, "surfaceSim": 0.9863192064597217, "abs_surfaceSim_minus_score": 0.9863192064597217}
{"golden_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "generated_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 / i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "score": 0.0, "codebleu": 0.9963221036285097, "crystalbleu": 0.9937377563162054, "codebertscore": 1.0, "codescore": 0.9849421977996826, "surfaceSim": 0.9890647900136453, "abs_surfaceSim_minus_score": 0.9890647900136453}
{"golden_code": "def popcount(x):\n    x = x - ((x >> 1) & 1431655765)\n    x = (x & 858993459) + ((x >> 2) & 858993459)\n    x = (x + (x >> 4)) & 252645135\n    x = x + (x >> 8)\n    x = x + (x >> 16)\n    return x & 127\ncmb = [[0 for i in range(51)] for j in range(51)]\ncmb[0][0] = 1\nfor i in range(51):\n    for j in range(51):\n        if (i != 50 and j != 50):\n            cmb[i + 1][j + 1] += cmb[i][j]\n        if i != 50:\n            cmb[i + 1][j] += cmb[i][j]\nfor i in range(1, 51):\n    for j in range(2, 51):\n        cmb[i][j] += cmb[i][j - 1]\n(N, K, T, S) = list(map(int, input().split()))\na = list(map(int, input().split()))\nmust0 = [i for i in range(18) if (S >> i) & 1 == 0]\nmust1 = [i for i in range(18) if (T >> i) & 1 == 1]\nA = []\nfor val in a:\n    check = True\n    for j in must0:\n        check = check & (val >> j) & 1 == 0\n    for j in must1:\n        check = check & (val >> j) & 1 == 1\n    if check:\n        A.append(val)\nif not A:\n    print(0)\n    exit()\nbit = []\nfor i in range(18):\n    if (i not in must0 and i not in must1):\n        bit.append(i)\nfor i in range(len(A)):\n    temp = 0\n    for j in range(len(bit)):\n        temp += (A[i] >> bit[j]) & 1 == 1 * (2 ** j)\n    A[i] = temp\nans = 0\nn = len(bit)\ndata = [0] * (2 ** n)\nfor i in range(2 ** n):\n    t = set([])\n    for a in A:\n        data[a & i] += 1\n        t.add(a & i)\n    temp = 0\n    for val in t:\n        temp += cmb[data[val]][min(K, data[val])]\n    ans += temp * ((-1) ** popcount(i))\n    for val in t:\n        data[val] = 0\nprint(ans)", "generated_code": "def popcount(x):\n    x = x - ((x >> 1) & 1431655765)\n    x = (x & 858993459) + ((x >> 2) & 858993459)\n    x = (x + (x >> 4)) & 252645135\n    x = x + (x >> 8)\n    x = x + (x >> 16)\n    return x & 127\ncmb = [[0 for i in range(51)] for j in range(51)]\ncmb[0][0] = 1\nfor i in range(51):\n    for j in range(51):\n        if (i != 50 and j != 50):\n            cmb[i + 1][j + 1] += cmb[i][j]\n        if i != 50:\n            cmb[i + 1][j] += cmb[i][j]\nfor i in range(1, 51):\n    for j in range(2, 51):\n        cmb[i][j] += cmb[i][j - 1]\n(N, K, T, S) = list(map(int, input().split()))\na = list(map(int, input().split()))\nmust0 = [i for i in range(18) if (S >> i) & 1 == 0]\nmust1 = [i for i in range(18) if (T >> i) & 1 == 1]\npass\nfor val in a:\n    check = True\n    for j in must0:\n        check = check & (val >> j) & 1 == 0\n    for j in must1:\n        check = check & (val >> j) & 1 == 1\n    if check:\n        A.append(val)\nif not A:\n    print(0)\n    exit()\nbit = []\nfor i in range(18):\n    if (i not in must0 and i not in must1):\n        bit.append(i)\nfor i in range(len(A)):\n    temp = 0\n    for j in range(len(bit)):\n        temp += (A[i] >> bit[j]) & 1 == 1 * (2 ** j)\n    A[i] = temp\nans = 0\nn = len(bit)\ndata = [0] * (2 ** n)\nfor i in range(2 ** n):\n    t = set([])\n    for a in A:\n        data[a & i] += 1\n        t.add(a & i)\n    temp = 0\n    for val in t:\n        temp += cmb[data[val]][min(K, data[val])]\n    ans += temp * ((-1) ** popcount(i))\n    for val in t:\n        data[val] = 0\nprint(ans)", "score": 0.0, "codebleu": 0.9704565678921283, "crystalbleu": 0.9879849891768839, "codebertscore": 1.0, "codescore": 0.9936468601226807, "surfaceSim": 0.985844373694841, "abs_surfaceSim_minus_score": 0.985844373694841}
{"golden_code": "from collections import defaultdict\nfrom collections import deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\ndef I():\n    return int(sys.stdin.readline())\ndef LS():\n    return list(map(list, sys.stdin.readline().split()))\ndef S():\n    return list(sys.stdin.readline())[:-1]\ndef IR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = I()\n    return l\ndef LIR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = LI()\n    return l\ndef SR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = S()\n    return l\ndef LSR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = SR()\n    return l\nmod = 1000000007\ndef A():\n    s = S()\n    t = S()\n    if s + t == t[::-1] + s[::-1]:\n        print('YES')else:print('NO')\ndef B():\n    n = I()\n    for i in range(int(n ** 0.5) + 2)[::-1]:\n        if i * i <= n:\n            print(i * i)\n            quit()\ndef C():\n    n = I()\n    a = LI()\n    b = LI()\n    c = LI()\n    q = [0 for i in range(n)]\n    ans = 0\n    a.sort()\n    b.sort()\n    c.sort()\n    for i in range(n):\n        j = bisect.bisect_left(a, b[i])\n        q[i] = j\n    for i in range(n - 1):\n        q[i + 1] += q[i]\n    q.insert(0, 0)\n    for i in range(n):\n        j = bisect.bisect_left(b, c[i])\n        ans += q[j]\n    print(ans)\ndef D():\n    def dijkstra():\n        d = [float('inf') for i in range(k)]\n        q = [[0, 1]]\n        d[1] = 0\n        while q:\n            (dx, x) = heappop(q)\n            for (y, dy) in v[x]:\n                if d[y] > dx + dy:\n                    d[y] = dx + dy\n                    heappush(q, [d[y], y])\n        print(d[0] + 1)\n    k = I()\n    if k == 1:\n        print(1)\n        quit()\n    v = [[] for i in range(k)]\n    for i in range(1, k):\n        v[i].append([(i + 1) % k, 1])\n        v[i].append([(i * 10) % k, 0])\n    dijkstra()\ndef E():\n    return\ndef F():\n    return\ndef G():\n    return\ndef H():\n    return", "generated_code": "from collections import defaultdict\nfrom collections import deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\ndef I():\n    return int(sys.stdin.readline())\ndef LS():\n    return list(map(list, sys.stdin.readline().split()))\ndef S():\n    return list(sys.stdin.readline())[:-1]\ndef IR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = I()\n    return l\ndef LIR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = LI()\n    return l\ndef SR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = S()\n    return l\ndef LSR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = SR()\n    return l\nmod = 1000000007\ndef A():\n    s = S()\n    t = S()\n    if s - t == t[::-1] + s[::-1]:\n        print('YES')else:print('NO')\ndef B():\n    n = I()\n    for i in range(int(n ** 0.5) + 2)[::-1]:\n        if i * i <= n:\n            print(i * i)\n            quit()\ndef C():\n    n = I()\n    a = LI()\n    b = LI()\n    c = LI()\n    q = [0 for i in range(n)]\n    ans = 0\n    a.sort()\n    b.sort()\n    c.sort()\n    for i in range(n):\n        j = bisect.bisect_left(a, b[i])\n        q[i] = j\n    for i in range(n - 1):\n        q[i + 1] += q[i]\n    q.insert(0, 0)\n    for i in range(n):\n        j = bisect.bisect_left(b, c[i])\n        ans += q[j]\n    print(ans)\ndef D():\n    def dijkstra():\n        d = [float('inf') for i in range(k)]\n        q = [[0, 1]]\n        d[1] = 0\n        while q:\n            (dx, x) = heappop(q)\n            for (y, dy) in v[x]:\n                if d[y] > dx + dy:\n                    d[y] = dx + dy\n                    heappush(q, [d[y], y])\n        print(d[0] + 1)\n    k = I()\n    if k == 1:\n        print(1)\n        quit()\n    v = [[] for i in range(k)]\n    for i in range(1, k):\n        v[i].append([(i + 1) % k, 1])\n        v[i].append([(i * 10) % k, 0])\n    dijkstra()\ndef E():\n    return\ndef F():\n    return\ndef G():\n    return\ndef H():\n    return", "score": 0.0, "codebleu": 0.9960259674102339, "crystalbleu": 0.9948180583890528, "codebertscore": 1.0, "codescore": 0.9864987134933472, "surfaceSim": 0.499755859375, "abs_surfaceSim_minus_score": 0.499755859375}
{"golden_code": "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nMOD = (10 ** 9) + 7\nfac = [1, 1]\nf_inv = [1, 1]\ninv = [0, 1]\ndef prepare(n, mod):\n    for i in range(2, n + 1):\n        fac.append((fac[-1] * i) % mod)\n        inv.append(((-(inv[mod % i])) * (mod // i)) % mod)\n        f_inv.append((f_inv[-1] * inv[-1]) % mod)\ndef cmb(n, r, mod):\n    if (n < 0 or r < 0):\n        return 0\n    if r > n:\n        return 0\n    return ((fac[n] * f_inv[r]) * f_inv[n - r]) % mod\ndef prime_factorization(n):\n    d = []\n    (i, e) = (2, 0)\n    while i * i <= n:\n        while n % i == 0:\n            n //= i\n            e += 1\n        if e > 0:\n            d.append((i, e))\n        i += 1\n        e = 0\n    if n > 1:\n        d.append((n, 1))\n    return d\ndef main():\n    (N, M) = list(map(int, readline().split()))\n    prepare(N + 100, MOD)\n    d = prime_factorization(M)\n    ans = 1\n    for (i, e) in d:\n        ans *= cmb((N - 1) + e, e, MOD)\n        ans %= MOD\n    print(ans)", "generated_code": "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nMOD = (10 ** 9) + 7\nfac = [1, 1]\nf_inv = [1, 1]\ninv = [0, 1]\ndef prepare(n, mod):\n    for i in range(2, n + 1):\n        fac.append((fac[-1] // i) % mod)\n        inv.append(((-(inv[mod % i])) * (mod // i)) % mod)\n        f_inv.append((f_inv[-1] * inv[-1]) % mod)\ndef cmb(n, r, mod):\n    if (n < 0 or r < 0):\n        return 0\n    if r > n:\n        return 0\n    return ((fac[n] * f_inv[r]) * f_inv[n - r]) % mod\ndef prime_factorization(n):\n    d = []\n    (i, e) = (2, 0)\n    while i * i <= n:\n        while n % i == 0:\n            n //= i\n            e += 1\n        if e > 0:\n            d.append((i, e))\n        i += 1\n        e = 0\n    if n > 1:\n        d.append((n, 1))\n    return d\ndef main():\n    (N, M) = list(map(int, readline().split()))\n    prepare(N + 100, MOD)\n    d = prime_factorization(M)\n    ans = 1\n    for (i, e) in d:\n        ans *= cmb((N - 1) + e, e, MOD)\n        ans %= MOD\n    print(ans)", "score": 0.0, "codebleu": 0.9927498121985038, "crystalbleu": 0.9906670397546408, "codebertscore": 1.0, "codescore": 0.9937494993209839, "surfaceSim": 0.9990009990009989, "abs_surfaceSim_minus_score": 0.9990009990009989}
