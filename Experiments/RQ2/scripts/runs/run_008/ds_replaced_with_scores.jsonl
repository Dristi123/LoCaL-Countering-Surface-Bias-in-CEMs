{"golden_code": "n, m = list(map(int, input().split()))\n\ngate = []\n\nl, r = list(map(int, input().split()))\n\nfor i in range(1, m):\n\n    m, s = list(map(int, input().split()))\n\n    if l < m:\n\n        l = m\n\n    if s < r:\n\n        r = s\n\nprint((len([i for i in range(l, r + 1)])))", "generated_code": "n, m = list(map(int, input().split()))\n\nl, r = [0] * m, [0] * m\n\nfor i in range(m):\n\n    l[i], r[i] = list(map(int, input().split()))\n\nprint((max(min(r) - max(l) + 1, 0)))", "score": 1.0, "codebleu": 0.32729944169101877, "crystalbleu": 0.2382712446876479, "codebertscore": 0.88, "codescore": 0.08592554181814194, "surfaceSim": 0.6408862876254181, "abs_surfaceSim_minus_score": 0.3591137123745819}
{"golden_code": "import numpy as np\n\n\n\nN = int(eval(input()))\n\nA = list(map(int, input().split()))\n\n\n\nA = np.array(A)\n\ncounter = 0\n\nwhile True:\n\n    if all( i%2==0 for i in A):\n\n        counter  += 1\n\n        A = A/2\n\n    else:\n\n        print(counter)\n\n        break", "generated_code": "N = int(eval(input()))\n\nA = list(map(int, input().split()))\n\n\n\nc = 0\n\nwhile True:\n\n    if all(a% 2 ==0 for a in A):\n\n        c += 1\n\n        A = list([x//2 for x in A])\n\n    else:\n\n        break\n\nprint(c)", "score": 1.0, "codebleu": 0.43115067875382124, "crystalbleu": 0.4707180363645505, "codebertscore": 0.9, "codescore": 0.6539483666419983, "surfaceSim": 0.7493975903614458, "abs_surfaceSim_minus_score": 0.2506024096385542}
{"golden_code": "# C - Go to School\n\ndef main():\n\n    import numpy as np\n\n    n = int(input())\n\n    a = list(map(int, input().split()))\n\n    a = np.array(a)\n\n    a = np.argsort(a)\n\n    for i in a:\n\n        print(i+1,end=\" \")\n\n\n\nif __name__ ==  \"__main__\":\n\n    main()\n", "generated_code": "# C - Go to School\n\ndef main():\n\n    n = int(eval(input()))\n\n    a = list(map(int, input().split()))\n\n    ans = [0] * n\n\n\n\n    for i, o in enumerate(a):\n\n        ans[o-1] = i + 1 \n\n    \n\n    print((*ans))\n\n\n\nif __name__ ==  \"__main__\":\n\n    main()", "score": 1.0, "codebleu": 0.4712080922690782, "crystalbleu": 0.0, "codebertscore": 0.89, "codescore": 0.022902971133589745, "surfaceSim": 0.6833407112291574, "abs_surfaceSim_minus_score": 0.3166592887708426}
{"golden_code": "n = int(eval(input()))\n\n\n\nINF = 10**9 + 7\n\n\n\nans = [0] * (10**5 + 1)\n\nans[0] = 1\n\n\n\nfor i in range(1,10**5 + 1):\n\n    ans[i] = ans[i-1] * i % INF\n\n\n\nprint((ans[n]))\n", "generated_code": "n = int(eval(input()))\n\nmod = 10**9 + 7\n\n\n\nans = 1\n\n\n\nfor i in range(1,n+1):\n\n    ans = ans * i % mod\n\n\n\nprint(ans)", "score": 1.0, "codebleu": 0.3643616246244763, "crystalbleu": 0.0, "codebertscore": 0.9, "codescore": 0.601199209690094, "surfaceSim": 0.7525252525252526, "abs_surfaceSim_minus_score": 0.2474747474747474}
{"golden_code": "import numpy as np\n\nn,d=list(map(int,input().split()))\n\nnda=np.empty((0,d),int)\n\nans=0\n\nfor i in range(0,n):\n\n  a=np.array([list(map(int,input().split()))])\n\n  for j in range(i):\n\n    chklen=np.linalg.norm(a-nda[j])\n\n    if chklen==chklen//1:\n\n      ans+=1\n\n  nda=np.append(nda,a,axis=0)\n\nprint(ans)", "generated_code": "import math\n\nn,d=list(map(int,input().split()))\n\na=[0]*n\n\nfor i in range(n):\n\n  a[i]=list(map(int,input().split()))\n\nans=0\n\nfor i in range(n-1):\n\n  for j in range(i+1,n):\n\n    chklen=0\n\n    wk=0\n\n    for k in range(d):\n\n      wk+=abs(a[i][k]-a[j][k])**2\n\n    chklen=math.sqrt(wk)\n\n    if chklen==chklen//1:\n\n      ans+=1\n\nprint(ans)", "score": 1.0, "codebleu": 0.37263528653265, "crystalbleu": 0.3451581777582674, "codebertscore": 0.87, "codescore": 0.8697497248649597, "surfaceSim": 0.715528781793842, "abs_surfaceSim_minus_score": 0.28447121820615795}
{"golden_code": "# coding: utf-8\n\n# Your code here!\n\nimport sys\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\n\n\n#a,b,c,d = map(int,readline().split())\n\ns,k = readline().split()\n\n\n\n\n\na = [len(i) for i in s.split(\"0\")]\n\nwhile a and a[-1] == 0: a.pop()\n\n\n\nif not a:\n\n    print((1))\n\n    exit()\n\n\n\nMOD = 998244353\n\n\n\nM = sum(a)+1\n\nk = min(int(k),M)\n\n\n\n\n\ndp = [[0]*M for _ in range(k+1)] # j 使って（上限 k）、l 余ってる\n\ndp[0][0] = 1\n\n\n\n#print(a)\n\nfor ai in a[::-1]:\n\n    ndp = [[0]*M for _ in range(k+1)] # j 使って（上限 k）、l 余ってる\n\n    for j in range(k+1):\n\n        for l in range(M):\n\n            for ll in range(l):\n\n                ndp[j][ll] += dp[j][l]\n\n                ndp[j][ll] %= MOD\n\n            \n\n            V = min(M-l,k-j+1,ai+1)\n\n            for i in range(V):\n\n                #if j+i > k: break\n\n                ndp[j+i][l+i] += dp[j][l]\n\n                ndp[j+i][l+i] %= MOD\n\n    \n\n    dp = ndp\n\n    #print(dp)\n\n\n\nans = 0\n\nfor jj in range(k+1):\n\n    ans += dp[jj][0]\n\n\n\nprint((ans%MOD))\n\n\n\n\n\n\n\n\n\n\n", "generated_code": "# coding: utf-8\n\n# Your code here!\n\nimport sys\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\n\n\n#a,b,c,d = map(int,readline().split())\n\ns,k = readline().split()\n\n\n\n\n\na = [len(i) for i in s.split(\"0\")]\n\nwhile a and a[-1] == 0: a.pop()\n\n\n\nif not a:\n\n    print((1))\n\n    exit()\n\n\n\nMOD = 998244353\n\n\n\nM = sum(a)+1\n\nk = min(int(k),M)\n\n\n\n\n\ndp = [[0]*M for _ in range(k+1)] # j 使って（上限 k）、l 余ってる\n\ndp[0][0] = 1\n\n\n\n#print(a)\n\nfor ai in a[::-1]:\n\n    ndp = [[0]*M for _ in range(k+1)] # j 使って（上限 k）、l 余ってる\n\n    for j in range(k+1):\n\n        for l in range(M):\n\n            if dp[j][l]:\n\n                for ll in range(l):\n\n                    ndp[j][ll] += dp[j][l]\n\n                    ndp[j][ll] %= MOD\n\n\n\n                V = min(M-l,k-j+1,ai+1)\n\n                for i in range(V):\n\n                    #if j+i > k: break\n\n                    ndp[j+i][l+i] += dp[j][l]\n\n                    ndp[j+i][l+i] %= MOD\n\n    \n\n    dp = ndp\n\n    #print(dp)\n\n\n\nans = 0\n\nfor jj in range(k+1):\n\n    ans += dp[jj][0]\n\n\n\nprint((ans%MOD))\n\n\n\n\n\n\n\n\n\n\n", "score": 1.0, "codebleu": 0.9808513070427722, "crystalbleu": 0.9755752721171804, "codebertscore": 0.99, "codescore": 0.9938532114028931, "surfaceSim": 0.9941916747337851, "abs_surfaceSim_minus_score": 0.0058083252662148865}
{"golden_code": "A,B = list(map(int,input().split()))\n\nj = 0\n\nfor i in range(A,B+1):\n\n  l = list(str(i))\n\n  l_reverse = list(reversed(l))\n\n  if l == l_reverse:\n\n    j += 1\n\nprint(j)", "generated_code": "A, B = list(map(int,input().split()))\n\n\n\nans = 0\n\nfor n in range(A, B+1):\n\n    n = str(n)\n\n    if n == n[::-1]:\n\n        ans += 1\n\nprint(ans)", "score": 1.0, "codebleu": 0.37832943406915276, "crystalbleu": 0.0, "codebertscore": 0.89, "codescore": 0.882960319519043, "surfaceSim": 0.7340301974448316, "abs_surfaceSim_minus_score": 0.26596980255516844}
{"golden_code": "def post_from_pre_in(preorder_elements, inorder_elements):\n\n    if preorder_elements:\n\n        global cnt\n\n        root = preorder_elements[0]\n\n        root_index = inorder_elements.index(root)\n\n        preorder_left = preorder_elements[1:root_index+1]\n\n        inorder_left = inorder_elements[:root_index]\n\n        preorder_right = preorder_elements[root_index+1:]\n\n        inorder_right = inorder_elements[root_index+1:]\n\n        post_from_pre_in(preorder_left, inorder_left)\n\n        post_from_pre_in(preorder_right, inorder_right)\n\n        if cnt:\n\n            print(root, end = ' ')\n\n            cnt -= 1\n\n        else:\n\n            print(root)\n\n\n\n\n\ncnt = int(input()) - 1\n\n\n\na = list(map(int, input().split()))\n\nb = list(map(int, input().split()))\n\n\n\npost_from_pre_in(a, b)\n", "generated_code": "postorder_elements = []\n\n\n\ndef post_from_pre_in(preorder_elements, inorder_elements):\n\n    if preorder_elements:\n\n        root = preorder_elements[0]\n\n        root_index = inorder_elements.index(root)\n\n        preorder_left = preorder_elements[1:root_index+1]\n\n        inorder_left = inorder_elements[:root_index]\n\n        preorder_right = preorder_elements[root_index+1:]\n\n        inorder_right = inorder_elements[root_index+1:]\n\n        post_from_pre_in(preorder_left, inorder_left)\n\n        post_from_pre_in(preorder_right, inorder_right)\n\n        postorder_elements.append(root)\n\n\n\n\n\n\n\nn = int(eval(input()))\n\n\n\na = list(map(int, input().split()))\n\nb = list(map(int, input().split()))\n\n\n\npost_from_pre_in(a, b)\n\n\n\nprint((*postorder_elements))", "score": 1.0, "codebleu": 0.6451756663160547, "crystalbleu": 0.639110475262366, "codebertscore": 0.95, "codescore": 0.06646757572889328, "surfaceSim": 0.8070512820512821, "abs_surfaceSim_minus_score": 0.19294871794871793}
{"golden_code": "import sys\n\nimport numpy as np\n\n\n\n\n\ndef main():\n\n    h, w = list(map(int, sys.stdin.buffer.readline().split()))\n\n    n = int(sys.stdin.buffer.readline())\n\n    a = list(map(int, sys.stdin.buffer.readline().split()))\n\n    ans = np.zeros(w*h, np.int64)\n\n    now = 0\n\n    for i, x in enumerate(a):\n\n        for j in range(x):\n\n            ans[now + j] = i+1\n\n        now += x\n\n\n\n    ans = ans.reshape(h, w)\n\n    for i in range(h):\n\n        if i % 2:\n\n            print((*ans[i, ::-1]))\n\n        else:\n\n            print((*ans[i]))\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "generated_code": "import sys\n\n\n\n\n\ndef main():\n\n    h, w = list(map(int, sys.stdin.buffer.readline().split()))\n\n    n = int(sys.stdin.buffer.readline())\n\n    a = list(map(int, sys.stdin.buffer.readline().split()))\n\n    ans = [0]*(w*h)\n\n    now = 0\n\n    for i, x in enumerate(a):\n\n        for j in range(x):\n\n            ans[now + j] = i+1\n\n        now += x\n\n\n\n    for i in range(h):\n\n        if i % 2:\n\n            print((*reversed(ans[i*w:(i+1)*w])))\n\n        else:\n\n            print((*ans[i*w:(i+1)*w]))\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "score": 1.0, "codebleu": 0.6247421075451611, "crystalbleu": 0.7815885645247879, "codebertscore": 0.94, "codescore": 0.018404709175229073, "surfaceSim": 0.8636800180780747, "abs_surfaceSim_minus_score": 0.1363199819219253}
{"golden_code": "a, b, c, x, y = list(map(int, input().split()))\n\n# print(a, b, c, x, y)\n\n\n\nans = 10000 * (10 **5) + 7\n\nc_max = 0\n\nif x > y:\n\n  c_max = x * 2\n\nelse:\n\n  c_max = y * 2\n\n\n\nfor cc in range(c_max+1):\n\n  ac = x - (cc // 2)\n\n  bc = y - (cc // 2)\n\n  \n\n  if ac < 0:\n\n    ac = 0\n\n  if bc < 0:\n\n    bc = 0\n\n  price = ac * a + bc * b + cc * c\n\n  # print('price: {}, ac: {}, bc: {}, cc: {}'.format(price, ac, bc, cc))\n\n  ans = min(ans, price)\n\n\n\nprint(ans)", "generated_code": "a, b, c, x, y = list(map(int, input().split()))\n\n# print(a, b, c, x, y)\n\n\n\nans = 10000 * (10 **5) + 7\n\nc_max = 0\n\nif x > y:\n\n  c_max = x * 2\n\nelse:\n\n  c_max = y * 2\n\n\n\nfor cc in range(0, c_max+1, 2):\n\n  ac = x - (cc // 2)\n\n  bc = y - (cc // 2)\n\n  \n\n  if ac < 0:\n\n    ac = 0\n\n  if bc < 0:\n\n    bc = 0\n\n  price = ac * a + bc * b + cc * c\n\n  # print('price: {}, ac: {}, bc: {}, cc: {}'.format(price, ac, bc, cc))\n\n  ans = min(ans, price)\n\n\n\nprint(ans)\n\n  ", "score": 1.0, "codebleu": 0.9641779493801012, "crystalbleu": 0.9488826794224877, "codebertscore": 0.99, "codescore": 0.9938532114028931, "surfaceSim": 0.995575221238938, "abs_surfaceSim_minus_score": 0.004424778761061954}
{"golden_code": "import numpy as np\n\nN,M=list(map(int,input().split()))\n\nA=np.zeros((N+1,M+1))\n\nA[0]=np.ones(M+1)\n\nfor i in range(1,N+1):\n\n    B=list(map(int,input().split()))\n\n    for m in range(1,B[0]+1):\n\n        A[i][B[m]]=A[i-1][B[m]]\n\na=sum(A[N])\n\nprint((int(a)))", "generated_code": "N,M=list(map(int,input().split()))\n\nA = [[1 for _ in range(M)]]+[[0 for _ in range(M)] for _ in range(N)]\n\nfor i in range(1,N+1):\n\n    B=list(map(int,input().split()))\n\n    Ai=B[1:]\n\n    for m in Ai:\n\n        A[i][m-1]=A[i-1][m-1]\n\na=sum(A[N])\n\nprint((int(a)))", "score": 1.0, "codebleu": 0.3571208261015507, "crystalbleu": 0.4845299877277858, "codebertscore": 0.91, "codescore": 0.3377177119255066, "surfaceSim": 0.6905594405594406, "abs_surfaceSim_minus_score": 0.30944055944055937}
{"golden_code": "n,t=int(input()),list(map(int,input().split()));T=sum(t)\n\nprint(*[T-t[i-1]+j for i,j in [list(map(int,input().split())) for _ in range(int(input()))]],sep='\\n')\n", "generated_code": "input();t=list(map(int,input().split()));T=sum(t)\n\nprint(*[T-t[i-1]+j for i,j in [list(map(int,input().split())) for _ in range(int(input()))]],sep='\\n')\n", "score": 1.0, "codebleu": 0.7952267100596858, "crystalbleu": 0.8631532256580251, "codebertscore": 0.97, "codescore": 0.9937490224838257, "surfaceSim": 0.9658385093167702, "abs_surfaceSim_minus_score": 0.03416149068322982}
{"golden_code": "def findSumDigit(num):\n\n    global total\n\n    total = \"\"\n\n    while num > 0:\n\n        total += str(num % 10)\n\n        num //= 10\n\n    return total\n\n\n\ndef main():\n\n    a,b = list(map(int, input().split()))\n\n    ans = 0\n\n    for i in range(a,b+1):\n\n        tmp = str(findSumDigit(i))\n\n        if tmp == str(i):\n\n            ans += 1\n\n    print(ans)\n\n\n\nif __name__ == '__main__':\n\n    main()", "generated_code": "a, b = list(map(int, input().split()))\n\nans = 0\n\n\n\nfor i in range(a,b+1):\n\n    seki_gyaku = str(i)\n\n    if seki_gyaku == seki_gyaku[::-1]:\n\n        ans += 1\n\n\n\nprint(ans)\n", "score": 1.0, "codebleu": 0.28963216760580035, "crystalbleu": 0.0, "codebertscore": 0.8, "codescore": 0.9431999325752258, "surfaceSim": 0.559106529209622, "abs_surfaceSim_minus_score": 0.440893470790378}
{"golden_code": "from itertools import combinations\n\nimport numpy as np\n\nN = int(eval(input()))\n\nD = list(map(int, input().split()))\n\nList = np.array(list(combinations(D,2)))\n\nprint((sum(np.product(List, axis = 1))))\n\n\n\n\n", "generated_code": "N = int(eval(input()))\n\nD = list(map(int, input().split()))\n\nfrom itertools import accumulate\n\nprint((sum(list(d*c for d, c in zip(D[1:], accumulate(D))))))\n", "score": 1.0, "codebleu": 0.4209097481508298, "crystalbleu": 0.0, "codebertscore": 0.85, "codescore": 0.08392665535211563, "surfaceSim": 0.4931372549019608, "abs_surfaceSim_minus_score": 0.5068627450980392}
{"golden_code": "import sys\n\nsys.setrecursionlimit(10**6)\n\ndef dfs(v,p,d):\n\n    for i, j in tree[v]:\n\n        if i != p:\n\n            depth[i] = d + j\n\n            dfs(i,v,d+j)\n\n\n\nN = int(eval(input()))\n\n\n\ntree = [[] for _ in range(N)]\n\n\n\nfor i in range(N-1):\n\n    a, b, c = list(map(int, input().split()))\n\n    a -= 1\n\n    b -= 1\n\n    tree[a].append((b,c))\n\n    tree[b].append((a,c))\n\n\n\nQ, K = list(map(int, input().split()))\n\n\n\ndepth = [0 for i in range(N)]\n\ndepth[K-1] = 0\n\n\n\ndfs(K-1,-1,0)\n\n\n\nfor _ in range(Q):\n\n    x, y = list(map(int, input().split()))\n\n    print((depth[x-1] + depth[y-1]))", "generated_code": "import heapq\n\nimport sys\n\n\n\ninput = sys.stdin.readline\n\n\n\ndef dijkstra(s, edge, N):\n\n    d = [float('inf')] * N\n\n    used = [True] * N\n\n    d[s] = 0\n\n    used[s] = False\n\n    edgelist = []\n\n    for a, b in edge[s]:\n\n        heapq.heappush(edgelist, a * (10 ** 6) + b)\n\n    while len(edgelist):\n\n        minedge = heapq.heappop(edgelist)\n\n\n\n        if not used[minedge%(10 ** 6)]:\n\n            continue\n\n        v = minedge % (10 ** 6)\n\n        d[v] = minedge // (10 ** 6)\n\n        used[v] = False\n\n        for e in edge[v]:\n\n            if used[e[1]]:\n\n                heapq.heappush(edgelist, (e[0] + d[v]) * (10 ** 6) + e[1])\n\n    return d\n\n\n\ndef main():\n\n    N = int(eval(input()))\n\n    edge = [[] for _ in range(N)]\n\n    for _ in range(N-1):\n\n        a, b, c = list(map(int, input().split()))\n\n        a -= 1\n\n        b -= 1\n\n        edge[a].append([c,b])\n\n        edge[b].append([c,a])\n\n    Q, K = list(map(int, input().split()))\n\n    K -= 1\n\n    d = dijkstra(K, edge, N)\n\n    for _ in range(Q):\n\n        x, y = list(map(int, input().split()))\n\n        x -= 1\n\n        y -= 1\n\n        print((d[x] + d[y]))\n\n\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()", "score": 1.0, "codebleu": 0.4294023902471327, "crystalbleu": 0.2815827724983178, "codebertscore": 0.81, "codescore": 0.41418540477752686, "surfaceSim": 0.668940200514595, "abs_surfaceSim_minus_score": 0.331059799485405}
{"golden_code": "mod = 2019\n\nl, r = list(map(int, input().split()))\n\n\n\nif r//mod - l//mod > 0:\n\n  print((0))\n\nelse:\n\n  l %= mod\n\n  r %= mod\n\n  ans = mod\n\n  for i in range(l+1, r+1):\n\n    for j in range(l, i):\n\n      ans = min(i*j%mod, ans)\n\n    if ans == 0:\n\n      break\n\n  print(ans)", "generated_code": "mod = 2019\n\nl, r = list(map(int, input().split()))\n\n\n\nif r//mod - l//mod > 0:\n\n  print((0))\n\nelse:\n\n  l %= mod\n\n  r %= mod\n\n  ans = mod\n\n  for i in range(l, r):\n\n    for j in range(i+1, r+1):\n\n      ans = min(i*j%mod, ans)\n\n    if ans == 0:\n\n      break\n\n  print(ans)", "score": 1.0, "codebleu": 0.8412981018031557, "crystalbleu": 0.9534326843212331, "codebertscore": 0.99, "codescore": 0.9937618374824524, "surfaceSim": 0.9812734082397003, "abs_surfaceSim_minus_score": 0.01872659176029967}
{"golden_code": "H,W = list(map(int,input().split()))\n\nN = int(eval(input()))\n\nA = list(map(int,input().split()))\n\nA.insert(0,0)\n\nC = [[0 for _ in range(W)] for _ in range(H)]\n\ncur = [0,0,\"R\"]\n\nfor k in range(1,N+1):\n\n#     ipdb.set_trace()\n\n    a = A[k]\n\n    cnt = 0\n\n    y,x,d = cur\n\n    for i in range(y,H):\n\n        y = i\n\n        if d==\"R\":\n\n            for j in range(x,W):\n\n                C[i][j]=str(k)\n\n                cnt += 1\n\n                if j+1<W:\n\n                    x = j+1\n\n                else:\n\n                    x = j\n\n                if cnt==a:break\n\n            if cnt==a:break\n\n            d=\"L\"\n\n        else:\n\n            for j in range(x,-1,-1):\n\n                C[i][j]=str(k)\n\n                cnt += 1\n\n                if j>=1:\n\n                    x = j-1\n\n                else:\n\n                    x = 0\n\n                if cnt==a:break\n\n            if cnt==a:break\n\n            d=\"R\"\n\n    if x==W-1:\n\n        if C[y][x]!=0:\n\n            y += 1\n\n            d=\"L\"\n\n    elif x==0:\n\n        if C[y][x]!=0:\n\n            y += 1\n\n            d=\"R\"\n\n    cur = [y,x,d]                \n\nfor i in range(H):\n\n    print((*C[i]))", "generated_code": "H,W = list(map(int,input().split()))\n\nN = int(eval(input()))\n\nA = list(map(int,input().split()))\n\nA.insert(0,0)\n\nB = [[0 for _ in range(W)] for _ in range(H)]\n\ncol = 1\n\ncnt = 0\n\ny = 0\n\nx = 0\n\nd = \"R\"\n\nwhile y<H:\n\n    if cnt<A[col]:\n\n        B[y][x] = col\n\n        cnt += 1\n\n    else:\n\n        col += 1\n\n        cnt = 0\n\n        B[y][x] = col\n\n        cnt += 1\n\n    if x<W-1 and d==\"R\":\n\n        x += 1\n\n    elif x==W-1 and d==\"R\":\n\n        y += 1\n\n        d = \"L\"\n\n    elif d==\"L\" and x>0:\n\n        x -= 1\n\n    elif d==\"L\" and x==0:\n\n        y += 1\n\n        d = \"R\"\n\nfor i in range(H):\n\n    print((*B[i]))", "score": 1.0, "codebleu": 0.37860347117124504, "crystalbleu": 0.3481250876124271, "codebertscore": 0.88, "codescore": 0.4518800973892212, "surfaceSim": 0.7328884060220395, "abs_surfaceSim_minus_score": 0.26711159397796047}
{"golden_code": "X,Y,Z,K = list(map(int,input().split()))\n\nA = list(map(int,input().split()))\n\nB = list(map(int,input().split()))\n\nC = list(map(int,input().split()))\n\nasort,bsort,csort = sorted(A,reverse=True),sorted(B,reverse=True),sorted(C,reverse=True)\n\nprint((asort[0] + bsort[0] + csort[0]))\n\nalready = [[0,0,0]]\n\nx,y,z = 0,0,0\n\nplace_sum = []\n\ncheck = []\n\nfor k in range(K - 1):\n\n    if [x + 1,y,z] not in already and x + 1 < X:\n\n        already.append([x + 1,y,z])\n\n        place_sum.append([x + 1,y,z])\n\n        check.append(asort[x + 1] + bsort[y] + csort[z])\n\n    if [x,y + 1,z] not in already and y + 1 < Y:\n\n        already.append([x,y + 1,z])\n\n        place_sum.append([x,y + 1,z])\n\n        check.append(asort[x] + bsort[y + 1] + csort[z])\n\n    if [x,y,z + 1] not in already and z + 1 < Z:\n\n        already.append([x,y,z + 1])\n\n        place_sum.append([x,y,z + 1])\n\n        check.append(asort[x] + bsort[y] + csort[z + 1])\n\n    print((max(check)))\n\n    x,y,z = place_sum[check.index(max(check))][0],place_sum[check.index(max(check))][1],place_sum[check.index(max(check))][2]\n\n    place_sum.pop(check.index(max(check)))\n\n    check.remove(max(check))", "generated_code": "import heapq\n\nX,Y,Z,K = list(map(int,input().split()))\n\nA = list(map(int,input().split()))\n\nB = list(map(int,input().split()))\n\nC = list(map(int,input().split()))\n\nasort,bsort,csort = sorted(A,reverse=True),sorted(B,reverse=True),sorted(C,reverse=True)\n\nalready = [[0,0,0]]\n\nprint((asort[0] + bsort[0] + csort[0]))\n\nx,y,z = 0,0,0\n\ncheck = []\n\nfor k in range(K - 1):\n\n    if [x + 1,y,z] not in already and x + 1 < X:\n\n        already.append([x + 1,y,z])\n\n        heapq.heappush(check,(-(asort[x + 1] + bsort[y] + csort[z]),x + 1,y,z))\n\n    if [x,y + 1,z] not in already and y + 1 < Y:\n\n        already.append([x,y + 1,z])\n\n        heapq.heappush(check,(-(asort[x] + bsort[y + 1] + csort[z]),x,y + 1,z))\n\n    if [x,y,z + 1] not in already and z + 1 < Z:\n\n        already.append([x,y,z + 1])\n\n        heapq.heappush(check,(-(asort[x] + bsort[y] + csort[z + 1]),x,y,z + 1))\n\n    maxsum = heapq.heappop(check)\n\n    print((-maxsum[0]))\n\n    x,y,z = maxsum[1],maxsum[2],maxsum[3]", "score": 1.0, "codebleu": 0.6987359410409137, "crystalbleu": 0.6907988549357674, "codebertscore": 0.93, "codescore": 0.9030799865722656, "surfaceSim": 0.782719900187149, "abs_surfaceSim_minus_score": 0.217280099812851}
{"golden_code": "import numpy as np\n\n\n\nS=eval(input())\n\nS=np.array([1 if s=='B' else 0 for s in S])\n\n\n\nprint((np.abs(np.diff(S)).sum()))\n", "generated_code": "from itertools import groupby\n\n\n\nS=eval(input())\n\nanswer = sum([1 for _ in groupby(S)]) -1\n\n\n\nprint(answer)", "score": 1.0, "codebleu": 0.20308835009201417, "crystalbleu": 0.0, "codebertscore": 0.8, "codescore": 0.07836552709341049, "surfaceSim": 0.4853070175438597, "abs_surfaceSim_minus_score": 0.5146929824561404}
{"golden_code": "while 1:\n\n    ans=0\n\n    n,x=list(map(int,input().split()))\n\n    if n:\n\n        for i in range(1,n-1):\n\n            for j in range(i+1,n):\n\n                for k in range(j+1,n+1):\n\n                    if i+j+k==x:ans+=1\n\n    else:break\n\n    print(ans)", "generated_code": "while 1:\n\n    a=0\n\n    n,x=list(map(int,input().split()))\n\n    if n==0:break\n\n    for i in range(1,n-1):\n\n        for j in range(i+1,n):\n\n            c=x-i-j\n\n            if c>j and c<=n:a+=1\n\n    print(a)", "score": 1.0, "codebleu": 0.5798587799321157, "crystalbleu": 0.0, "codebertscore": 0.92, "codescore": 0.47693297266960144, "surfaceSim": 0.8134920634920635, "abs_surfaceSim_minus_score": 0.1865079365079365}
{"golden_code": "import sys\n\nimport numpy as np\n\n\n\nx, y, z, k = map(int, sys.stdin.readline().split())\n\na, b, c = (np.array(sys.stdin.readline().split(), dtype=np.int64) for _ in range(3))\n\n\n\ndef main():\n\n    res = np.sort(np.ravel(a[:, None] + b))[::-1]\n\n    res = np.sort(np.ravel(c[:, None] + res[:min(k, x*y)]))[::-1]\n\n    return res[:k]\n\n\n\nif __name__ == '__main__':\n\n    ans = main()\n\n    print(*ans, sep='\\n')\n", "generated_code": "import sys\n\n\n\nx, y, z, K = map(int, sys.stdin.readline().split())\n\na, b, c = (sorted(map(int, sys.stdin.readline().split()), reverse=True) for _ in range(3))\n\ndef main():\n\n    res = []\n\n    for i in range(1, min(K, x) + 1):\n\n        for j in range(1, min(K // i, y) + 1):\n\n            for k in range(1, min(K // (i * j), z) + 1):\n\n                res.append(a[i-1] + b[j-1] + c[k-1])\n\n\n\n    return sorted(res, reverse=True)[:K]\n\n\n\nif __name__ == '__main__':\n\n    ans = main()\n\n    print(*ans, sep='\\n')\n", "score": 1.0, "codebleu": 0.4488662580808348, "crystalbleu": 0.42130104969933524, "codebertscore": 0.86, "codescore": 0.032040469348430634, "surfaceSim": 0.7330019880715706, "abs_surfaceSim_minus_score": 0.2669980119284294}
{"golden_code": "K = int(eval(input()))\n\n\n\nflg = [False]*K\n\n\n\ntmp = 7 % K\n\ncnt = 1\n\nif tmp == 0:\n\n    print(cnt)\n\n    exit()\n\nwhile True:\n\n    tmp = (tmp*10+7)%K\n\n    if flg[tmp]:\n\n        print((-1))\n\n        break\n\n    else:\n\n        cnt += 1\n\n        if tmp == 0:\n\n            print(cnt)\n\n            break\n\n        flg[tmp] = True\n", "generated_code": "K = int(eval(input()))\n\nt = 7\n\nt %= K\n\n\n\nfor i in range(K+1):\n\n    if t == 0:\n\n        print((i+1))\n\n        exit()\n\n    t = (t*10+7)%K\n\nprint((-1))\n", "score": 1.0, "codebleu": 0.24922566313086456, "crystalbleu": 0.0, "codebertscore": 0.82, "codescore": 0.7726991772651672, "surfaceSim": 0.684748427672956, "abs_surfaceSim_minus_score": 0.31525157232704404}
{"golden_code": "import numpy as np\n\nimport numba\n\nfrom numba import njit, b1, i4, i8, f8\n\n\n\n@njit((i8, i8[:]), cache=True)\n\ndef main(N,A):\n\n  Amax = np.max(A)\n\n  lis = np.zeros(Amax+1, np.int64)\n\n  for i in range(N):\n\n    lis[A[i]] += 1\n\n  setwise = False\n\n  for t in range(2,Amax+1):\n\n    cnt = np.sum(lis[t:Amax+1:t])\n\n    if cnt==N:\n\n      return 'not'\n\n    if 2<=cnt<N:\n\n      setwise=True\n\n  if setwise==True:\n\n    return 'setwise'\n\n  return 'pairwise'\n\n\n\nN = int(eval(input()))\n\nA = np.array(list(map(int, input().split())))\n\nprint((main(N,A)+' coprime'))\n\n\n", "generated_code": "def sieve(n):\n\n  is_prime = [True for _ in range(n+1)]\n\n  is_prime[0] = False\n\n  for i in range(2, n+1):\n\n    if is_prime[i-1]:\n\n      j = 2 * i\n\n      while j <= n:\n\n        is_prime[j-1] = False\n\n        j += i\n\n  table = [i for i in range(1, n+1) if is_prime[i-1]]\n\n  return table\n\n\n\nN = int(eval(input()))\n\nA = list(map(int, input().split()))\n\nAmax = max(A)\n\nlis = [0]*(Amax+1)\n\nfor i in range(N):\n\n  lis[A[i]] += 1\n\ntable = sieve(Amax)\n\nsetwise = False\n\nfor t in table:\n\n  cnt = sum(lis[t:Amax+1:t])\n\n  if cnt==N:\n\n    print('not coprime')\n\n    break\n\n  if 2<=cnt<N:\n\n    setwise=True\n\nelse:\n\n  if setwise==True:\n\n    print('setwise coprime')\n\n  else:\n\n    print('pairwise coprime')\n", "score": 1.0, "codebleu": 0.3197419166934511, "crystalbleu": 0.33208856196294406, "codebertscore": 0.82, "codescore": 0.9595102071762085, "surfaceSim": 0.5645820238843495, "abs_surfaceSim_minus_score": 0.4354179761156505}
{"golden_code": "import numpy as np\n\nN = int(eval(input()))\n\n\n\nabc = np.array([list(map(int, input().split())) for i in range(N)])\n\n\n\ndp = [[0]*3 for i in range(N+1)]\n\n\n\nfor i in range(1, N+1):\n\n    dp[i][0] = max(dp[i - 1][1] + abc[i - 1][1], dp[i - 1][2] + abc[i - 1][2])\n\n    dp[i][1] = max(dp[i - 1][0] + abc[i - 1][0], dp[i - 1][2] + abc[i - 1][2])\n\n    dp[i][2] = max(dp[i - 1][1] + abc[i - 1][1], dp[i - 1][0] + abc[i - 1][0])\n\n\n\nprint((max(dp[-1])))\n", "generated_code": "N = int(eval(input()))\n\n\n\nA = [0] * (N + 1)\n\nB = [0] * (N + 1)\n\nC = [0] * (N + 1)\n\n\n\nfor i in range(1, N + 1):\n\n    A[i], B[i], C[i] = list(map(int, input().split()))\n\n\n\ndp = [[0] * 3 for _ in range(N + 1)]\n\nfor i in range(1, N + 1):\n\n    dp[i][0] = A[i] + max(dp[i-1][1], dp[i-1][2])\n\n    dp[i][1] = B[i] + max(dp[i-1][2], dp[i-1][0])\n\n    dp[i][2] = C[i] + max(dp[i-1][0], dp[i-1][1])\n\n\n\nprint((max(dp[N])))", "score": 1.0, "codebleu": 0.26556224256162636, "crystalbleu": 0.5583057628781894, "codebertscore": 0.89, "codescore": 0.8420063853263855, "surfaceSim": 0.6906179138321995, "abs_surfaceSim_minus_score": 0.3093820861678005}
{"golden_code": "import math\n\nN = int(eval(input()))\n\nans = math.factorial(N) % (10 ** 9 + 7)\n\nprint(ans)", "generated_code": "n = int(eval(input()))\n\nfrom functools import reduce\n\nprint((reduce(lambda x,y:x*y%1000000007,list(range(1,n+1)))))", "score": 1.0, "codebleu": 0.22942398443685796, "crystalbleu": 0.0, "codebertscore": 0.76, "codescore": 0.038018256425857544, "surfaceSim": 0.4478260869565217, "abs_surfaceSim_minus_score": 0.5521739130434783}
{"golden_code": "import numpy as np\n\nn = int(eval(input()))\n\nballs = np.array(list(map(int, input().split())))\n\ntime = 0\n\nwhile np.all(balls % 2 == 0) and np.all(balls > 0):\n\n    time += 1\n\n    balls = balls / 2\n\nprint(time)", "generated_code": "import math\n\nn = eval(input())\n\na = list(map(int, input().split()))\n\nans = float(\"inf\")\n\nfor i in a:\n\n    ans = min(ans, len(bin(i)) - bin(i).rfind(\"1\") - 1)\n\nprint((round(ans)))", "score": 1.0, "codebleu": 0.1745398790512791, "crystalbleu": 0.0, "codebertscore": 0.77, "codescore": 0.09286804497241974, "surfaceSim": 0.49879227053140096, "abs_surfaceSim_minus_score": 0.501207729468599}
{"golden_code": "import math\n\nn=int(eval(input()))\n\nans=n\n\ni=1\n\nwhile(i<=math.sqrt(n)):\n\n    if n%i==0:\n\n        d=i+n/i-2\n\n        ans=min(ans,d)\n\n    i+=1\n\nprint((int(ans)))", "generated_code": "from math import floor\n\nfrom math import sqrt\n\nn=int(eval(input()))\n\nnn=floor(sqrt(n))\n\nrest=n%nn\n\nwhile rest!=0:\n\n    nn-=1\n\n    rest=n%nn\n\nnnn=n/nn\n\nprint((int(nn+nnn-2)))", "score": 1.0, "codebleu": 0.2189753588334301, "crystalbleu": 0.0, "codebertscore": 0.84, "codescore": 0.6726992726325989, "surfaceSim": 0.5796001926782274, "abs_surfaceSim_minus_score": 0.4203998073217726}
{"golden_code": "def main():\n\n    n = int(eval(input()))\n\n    import numpy as np\n\n    ans = np.zeros((10,10))\n\n    for i in range(1,n+1):\n\n        h,t = str(i)[0],str(i)[-1]\n\n        ans[int(h)-1][int(t)-1]+=1\n\n    s = 0\n\n    for i in range(10):\n\n        for j in range(10):\n\n            s += ans[i][j]*ans[j][i]\n\n\n\n    print((int(s)))\n\nif __name__ == \"__main__\":\n\n    main()", "generated_code": "def main():\n\n    n = int(eval(input()))\n\n    dp = [[0 for i in range(10)] for i in range(10)]\n\n    for i in range(1,n+1):\n\n        h,t = int(str(i)[0]), int(str(i)[-1])\n\n        dp[h][t] += 1\n\n    ans = 0\n\n    for i in range(10):\n\n        for j in range(10):\n\n            ans += dp[i][j] * dp[j][i]\n\n    print(ans)\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "score": 1.0, "codebleu": 0.47214019955543324, "crystalbleu": 0.6394523388944687, "codebertscore": 0.92, "codescore": 0.018577490001916885, "surfaceSim": 0.790406472741283, "abs_surfaceSim_minus_score": 0.20959352725871705}
{"golden_code": "import numpy\n\nN, D = list(map(int, input().split()))\n\nlistx = []\n\ncount = 0\n\nfor i in range(N):\n\n    x = list(map(int, input().split()))\n\n    listx.append(x)\n\n\n\nfor j in range(0, N):\n\n    for k in range(j+1,N):\n\n        a = numpy.array(listx[j])\n\n        b = numpy.array(listx[k])\n\n        u = b - a\n\n        c = float(numpy.linalg.norm(u))\n\n        if c.is_integer() :\n\n            count += 1\n\nprint(count)", "generated_code": "def LI(): return list(map(int,input().split()))\n\nN,D = LI()\n\nX = [LI() for _ in range(N)]\n\nans = 0\n\nfor i in range(N):\n\n    for j in range(i+1,N):\n\n        temp = 0\n\n        for k in range(D):\n\n            temp += (X[j][k]-X[i][k])**2\n\n        if temp **0.5%1==0:\n\n            ans += 1\n\nprint(ans)", "score": 1.0, "codebleu": 0.2597782250636296, "crystalbleu": 0.2593332425321567, "codebertscore": 0.82, "codescore": 0.7719017863273621, "surfaceSim": 0.5813267813267813, "abs_surfaceSim_minus_score": 0.4186732186732187}
{"golden_code": "import sys\n\n\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\nreadlines = sys.stdin.readlines\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = 1 << 60\n\nMOD = 1000000007\n\n\n\n# Reference: https://www.geeksforgeeks.org/queries-number-distinct-elements-subarray/\n\n# Python3 code to find number of\n\n# distinct numbers in a subarray\n\nMAX = 1000001\n\n\n\n# structure to store queries\n\nclass Query:\n\n    def __init__(self, l, r, idx):\n\n        self.l = l\n\n        self.r = r\n\n        self.idx = idx\n\n\n\n\n\n# updating the bit array\n\ndef update(idx, val, bit, n):\n\n    while idx <= n:\n\n        bit[idx] += val\n\n        idx += idx & -idx\n\n\n\n\n\n# querying the bit array\n\ndef query(idx, bit, n):\n\n    summ = 0\n\n    while idx:\n\n        summ += bit[idx]\n\n        idx -= idx & -idx\n\n    return summ\n\n\n\n\n\ndef answeringQueries(arr, n, queries, q):\n\n\n\n    # initialising bit array\n\n    bit = [0] * (n + 1)\n\n\n\n    # holds the rightmost index of\n\n    # any number as numbers of a[i]\n\n    # are less than or equal to 10^6\n\n    last_visit = [-1] * MAX\n\n\n\n    # answer for each query\n\n    ans = [0] * q\n\n\n\n    query_counter = 0\n\n    for i in range(n):\n\n\n\n        # If last visit is not -1 update -1 at the\n\n        # idx equal to last_visit[arr[i]]\n\n        if last_visit[arr[i]] != -1:\n\n            update(last_visit[arr[i]] + 1, -1, bit, n)\n\n\n\n        # Setting last_visit[arr[i]] as i and\n\n        # updating the bit array accordingly\n\n        last_visit[arr[i]] = i\n\n        update(i + 1, 1, bit, n)\n\n\n\n        # If i is equal to r of any query store answer\n\n        # for that query in ans[]\n\n        while query_counter < q and queries[query_counter].r == i:\n\n            ans[queries[query_counter].idx] = query(queries[query_counter].r + 1, bit, n) - query(\n\n                queries[query_counter].l, bit, n\n\n            )\n\n            query_counter += 1\n\n\n\n    # print answer for each query\n\n    for i in range(q):\n\n        print((ans[i]))\n\n\n\n\n\n# This code is contributed by\n\n# sanjeev2552\n\n\n\n\n\ndef main():\n\n    N, Q = list(map(int, readline().split()))\n\n    C = list(map(int, readline().split()))\n\n    (*LR,) = list(map(int, read().split()))\n\n\n\n    queries = [0] * Q\n\n    for i, (l, r) in enumerate(zip(*[iter(LR)] * 2)):\n\n        queries[i] = Query(l - 1, r - 1, i)\n\n\n\n    queries.sort(key=lambda x: x.r)\n\n    answeringQueries(C, N, queries, Q)\n\n\n\n    return\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n\n\n", "generated_code": "import sys\n\n\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\nreadlines = sys.stdin.readlines\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = 1 << 60\n\nMOD = 1000000007\n\n\n\n\n\nclass BIT:\n\n    def __init__(self, n):\n\n        self.n = n\n\n        self.data = [0] * (n + 1)\n\n\n\n    def add(self, i, x=1):\n\n        i += 1\n\n        while i <= self.n:\n\n            self.data[i] += x\n\n            i += i & -i\n\n\n\n    def get_sum(self, i):\n\n        i += 1\n\n        x = 0\n\n        while i > 0:\n\n            x += self.data[i]\n\n            i -= i & -i\n\n        return x\n\n\n\n    # Return sum for [l, r)\n\n    def get_sum_range(self, l, r):\n\n        return self.get_sum(r - 1) - self.get_sum(l - 1)\n\n\n\n\n\ndef main():\n\n    N, Q = map(int, readline().split())\n\n    C = list(map(int, readline().split()))\n\n    LR = map(int, read().split())\n\n\n\n    prev = [-1] * (N + 1)\n\n    ps = [[] for _ in range(N)]\n\n    for i, c in enumerate(C):\n\n        if prev[c] != -1:\n\n            ps[prev[c]].append(i)\n\n        prev[c] = i\n\n\n\n    qs = [[] for _ in range(N + 1)]\n\n    for i, (l, r) in enumerate(zip(*[iter(LR)] * 2)):\n\n        l -= 1\n\n        r -= 1\n\n        qs[l].append((r, i))\n\n\n\n    ans = [0] * Q\n\n    bit = BIT(N)\n\n\n\n    for l in range(N - 1, -1, -1):\n\n        for r in ps[l]:\n\n            bit.add(r)\n\n        for r, i in qs[l]:\n\n            ans[i] = (r - l + 1) - bit.get_sum(r)\n\n\n\n    print(*ans, sep='\\n')\n\n\n\n    return\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 1.0, "codebleu": 0.35758989066170316, "crystalbleu": 0.4110569486602164, "codebertscore": 0.81, "codescore": 0.23201808333396912, "surfaceSim": 0.7814760686883448, "abs_surfaceSim_minus_score": 0.21852393131165515}
{"golden_code": "def popcount(x):\n\n  r = 0\n\n  while x:\n\n    if x & 1:\n\n      r += 1\n\n    x >>= 1\n\n  return r\n\n\n\nn = int(eval(input()))\n\nr = list(range(n))\n\na = [[0, 0] for _ in r]\n\nfor i in r:\n\n  for _ in range(int(eval(input()))):\n\n    x, y = list(map(int, input().split()))\n\n    a[i][y] |= 1 << (x - 1)\n\n\n\nm = 0\n\nl = (1 << n) - 1\n\nfor x in range(1, l + 1):\n\n  if all(a[i][0] & x == a[i][1] & l - x == 0 for i in r if x >> i & 1):\n\n    m = max(m, popcount(x))\n\nprint(m)\n", "generated_code": "from itertools import combinations\n\n \n\nn = int(eval(input()))\n\nr = list(range(n))\n\na = [(set(), set()) for _ in r]\n\nfor i in r:\n\n  for _ in range(int(eval(input()))):\n\n    x, y = list(map(int, input().split()))\n\n    a[i][y].add(x - 1)\n\n \n\nfail = lambda x: not all(a[i][0].isdisjoint(x) and a[i][1] < x for i in x)\n\n \n\nwhile all(map(fail, list(map(set, combinations(r, n))))):\n\n  n -= 1\n\nprint(n)", "score": 1.0, "codebleu": 0.343568797877028, "crystalbleu": 0.3292495512397752, "codebertscore": 0.83, "codescore": 0.8609874844551086, "surfaceSim": 0.6020737079617493, "abs_surfaceSim_minus_score": 0.3979262920382507}
{"golden_code": "N = int(eval(input()))\n\ncount = [[0 for _ in range(9)] for _ in range(9)]\n\nfor i in range(1, N + 1):\n\n    if str(i)[0] != \"0\" and str(i)[-1] != \"0\":\n\n        count[int(str(i)[0]) - 1][int(str(i)[-1]) - 1] += 1\n\nans = 0\n\nfor i in range(0, 9):\n\n    for k in range(0, 9):\n\n        ans += count[i][k] * count[k][i]\n\nprint(ans)", "generated_code": "N = int(eval(input()))\n\nnums = [0 for i in range(100)]\n\nfor i in range(1, N + 1):\n\n    i = str(i)\n\n    nums[int(i[0] + i[-1])] += 1\n\nans = 0\n\nfor i in range(1, 10):\n\n    for j in range(i, 10):\n\n        i = str(i)\n\n        j = str(j)\n\n        if i != j:\n\n            ans += nums[int(i + j)] * nums[int(j + i)] * 2\n\n        else:\n\n            n = nums[int(i + j)]\n\n            ans += n * (n - 1)\n\n            ans += n\n\nprint(ans)", "score": 1.0, "codebleu": 0.38418977338707505, "crystalbleu": 0.27683601750869646, "codebertscore": 0.88, "codescore": 0.12306470423936844, "surfaceSim": 0.7667915690866511, "abs_surfaceSim_minus_score": 0.23320843091334886}
{"golden_code": "import numpy as np\n\n\n\nh, w = map(int, input().split())\n\nal = list(list(input()) for _ in range(h))\n\nal_n = np.array(al)\n\nrow = [0]*w\n\ncol = [0]*h\n\nfor i in range(h):\n\n    for j in range(w):\n\n        if al_n[i][j] == '.':\n\n            row[j] += 1\n\n            col[i] += 1\n\nrow_ = []\n\ncol_ = []\n\nfor i in range(w):\n\n    if row[i] == h:\n\n        row_.append(i)\n\n\n\nfor j in range(h):\n\n    if col[j] == w:\n\n        col_.append(j)\n\n\n\nif len(col_) > 0:\n\n    al_n = np.delete(al_n, col_, axis=0)\n\n\n\nif len(row_) > 0:\n\n    al_n = np.delete(al_n, row_, axis=1)\n\n\n\nfor a in al_n:\n\n    print(*a, sep='')\n", "generated_code": "h, w = map(int, input().split())\n\nal = list(list(input()) for _ in range(h))\n\nrow = [0]*w\n\ncol = [0]*h\n\n\n\nfor i in range(h):\n\n    for j in range(w):\n\n        if al[i][j] == '#':\n\n            col[i] += 1\n\n            row[j] += 1\n\nans = []\n\nw_len = len(row) - row.count(0)\n\nfor i in range(h):\n\n    tmp = ''\n\n    if col[i] != 0:\n\n        for j in range(w):\n\n            if row[j] != 0:\n\n                tmp += al[i][j]\n\n        ans.append(tmp)\n\n\n\nfor a in ans:\n\n    print(*a, sep='')\n", "score": 1.0, "codebleu": 0.42214966252528324, "crystalbleu": 0.4680976801710568, "codebertscore": 0.89, "codescore": 0.9180073738098145, "surfaceSim": 0.7561936936936937, "abs_surfaceSim_minus_score": 0.2438063063063063}
{"golden_code": "import numpy as np\n\nN, K= list(map(int, input().split()))\n\nA=[int(i) for i in input().split()]\n\nF=[int(i) for i in input().split()]\n\n\n\nA=np.array(sorted(A, reverse=True))\n\nF=np.array(sorted(F))\n\n\n\nlower_bound=0\n\nupper_bound=np.max(A*F)\n\nK_tmp=0\n\n\n\nwhile upper_bound>=lower_bound:\n\n    mid=(lower_bound+upper_bound)//2\n\n    K_tmp=np.sum(np.maximum(A-mid//F, 0))\n\n    if K_tmp<=K:\n\n        upper_bound=mid-1\n\n    else:\n\n        lower_bound=mid+1\n\n\n\nprint(lower_bound)", "generated_code": "n,k=list(map(int,input().split()))\n\n*a,= list(map(int,input().split()))\n\n*f,= list(map(int,input().split()))\n\na=sorted(a)\n\nf=sorted(f, reverse=True)\n\n\n\ndef is_ok(arg):\n\n    cnt=0\n\n    for i in range(n):\n\n        cnt+=max(a[i]-arg//f[i], 0)\n\n    return cnt<=k\n\n\n\ndef meguru_bisect(ng, ok):\n\n    while (abs(ok - ng) > 1):\n\n        mid = (ok + ng) // 2\n\n        if is_ok(mid):\n\n            ok = mid\n\n        else:\n\n            ng = mid\n\n    return ok\n\n\n\nprint((meguru_bisect(-1, 10**12)))", "score": 1.0, "codebleu": 0.24619909504990498, "crystalbleu": 0.16312147758461068, "codebertscore": 0.79, "codescore": 0.9036510586738586, "surfaceSim": 0.4778350515463918, "abs_surfaceSim_minus_score": 0.5221649484536082}
{"golden_code": "from scipy.sparse.csgraph import floyd_warshall\n\n\n\nn,m=list(map(int,input().split()))\n\nl=[list(map(int,input().split())) for i in range(m)]\n\n\n\nans=0\n\nfor i in range(m):\n\n    ll=l[:i]+l[i+1:]\n\n\n\n    d=[[float('inf')]*n for i in range(n)]\n\n    for i in range(n):\n\n        d[i][i]=0\n\n\n\n    for j in ll:\n\n        d[j[0]-1][j[1]-1]=1\n\n        d[j[1]-1][j[0]-1]=1\n\n\n\n    d=floyd_warshall(d)\n\n\n\n    if float('inf') in d:\n\n        ans+=1\n\n\n\nprint(ans)", "generated_code": "class UnionFind():\n\n    def __init__(self, n):\n\n        self.n = n\n\n        self.parents = [-1] * n\n\n\n\n    def find(self, x):\n\n        if self.parents[x] < 0:\n\n            return x\n\n        else:\n\n            self.parents[x] = self.find(self.parents[x])\n\n            return self.parents[x]\n\n\n\n    def union(self, x, y):\n\n        x = self.find(x)\n\n        y = self.find(y)\n\n\n\n        if x == y:\n\n            return\n\n\n\n        if self.parents[x] > self.parents[y]:\n\n            x, y = y, x\n\n\n\n        self.parents[x] += self.parents[y]\n\n        self.parents[y] = x\n\n\n\n    def roots(self):\n\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n\n\n    def group_count(self):\n\n        return len(self.roots())\n\n\n\nfrom copy import deepcopy\n\n\n\nn,m=list(map(int,input().split()))\n\nl=[list(map(int,input().split())) for i in range(m)]\n\n\n\ncnt=0\n\nfor i in range(m):\n\n  uf=UnionFind(n)\n\n  ll=deepcopy(l)\n\n  del ll[i]\n\n  for a,b in ll:\n\n    a-=1\n\n    b-=1\n\n    uf.union(a,b)\n\n  if uf.group_count()>=2:\n\n    cnt+=1\n\nprint(cnt)", "score": 1.0, "codebleu": 0.3031584482410501, "crystalbleu": 0.22425522549011245, "codebertscore": 0.75, "codescore": 0.4779999256134033, "surfaceSim": 0.5431940371456501, "abs_surfaceSim_minus_score": 0.45680596285434993}
{"golden_code": "n,m=list(map(int,input().split()))\n\nc=[0]*(n+2)\n\nfor i in range(m):\n\n  l,r=list(map(int,input().split()))\n\n  c[l-1]+=1\n\n  c[r]-=1\n\nfor i in range(1,n+2):\n\n  c[i]=c[i]+c[i-1]\n\nans=0\n\nfor i in range(n+2):\n\n  if c[i]==m:\n\n    ans+=1\n\nprint(ans)", "generated_code": "n,m=list(map(int,input().split()))\n\nl,r=list(map(int,input().split()))\n\nfor i in range(m-1):\n\n  tl,tr=list(map(int,input().split()))\n\n  if l<tl:\n\n    l=tl\n\n  if tr<r:\n\n    r=tr\n\nprint((max(r-l+1,0)))", "score": 1.0, "codebleu": 0.2118312531149506, "crystalbleu": 0.22829217769272614, "codebertscore": 0.87, "codescore": 0.27122586965560913, "surfaceSim": 0.598863431354862, "abs_surfaceSim_minus_score": 0.401136568645138}
{"golden_code": "import sys\n\nsys.setrecursionlimit(100000)\n\n\n\ndef intinput(): return list(map(int,sys.stdin.readline().split()))\n\n\n\nfib={0:0,1:1,2:1}\n\nfor i in range(3,100003):\n\n    fib[i]=fib[i-1]+fib[i-2]\n\n  #  fib.append(fib[i-1]+fib[i-2])\n\n\n\nn,m=intinput()\n\nmod=10**9+7\n\na=[int(sys.stdin.readline()) for _ in range(m)]\n\nif m!=0:\n\n    l=[a[0]]\n\n    for i in range(len(a)-1):\n\n        l.append(a[i+1]-a[i]-1)\n\n    l.append(n-a[-1])\n\n    k=1\n\n    for i in l:\n\n        k=fib[i]*k%mod\n\n    print((k%mod))\n\nelse:\n\n    print((fib[n+1]%mod))", "generated_code": "import sys\n\nsys.setrecursionlimit(100000)\n\n\n\ndef intinput(): return list(map(int,sys.stdin.readline().split()))\n\n\n\n\n\nn, m = intinput()\n\na = {int(sys.stdin.readline()) for _ in range(m)}\n\nmemo = [0 for x in range(n + 4)]\n\nmemo[0] = 1\n\nmod = 10 ** 9 + 7\n\nfor i in range(n):\n\n    if i + 1 not in a:\n\n        memo[i + 1] = (memo[i + 1] + memo[i]) % mod\n\n    if i + 2 not in a:\n\n        memo[i + 2] = (memo[i + 2] + memo[i]) % mod\n\nprint((memo[n]))", "score": 1.0, "codebleu": 0.3034085884380589, "crystalbleu": 0.39628187478652127, "codebertscore": 0.84, "codescore": 0.1890426129102707, "surfaceSim": 0.6666208791208792, "abs_surfaceSim_minus_score": 0.3333791208791208}
{"golden_code": "from scipy.sparse.csgraph import csgraph_from_dense, floyd_warshall\n\n\n\nINF = float('inf')\n\n\n\ndef sol():\n\n    N, M = list(map(int, input().split()))\n\n\n\n    edges = []\n\n\n\n    for _ in range(M):\n\n        fr, to, cost = list(map(int, input().split()))\n\n        fr -= 1\n\n        to -= 1\n\n        edges.append((fr, to, cost))\n\n\n\n    graph = [[INF] * N for _ in range(N)]\n\n    for fr, to, cost in edges:\n\n        graph[fr][to] = cost\n\n\n\n    graph = csgraph_from_dense(graph, null_value=INF)\n\n\n\n    dist = floyd_warshall(graph, directed=False)\n\n    ans = (graph > dist).sum()\n\n    print(ans)\n\n\n\nsol()", "generated_code": "N, M = list(map(int, input().split()))\n\nINF = 10**18\n\n\n\nminDist = [[INF] * N for _ in range(N)]\n\nfor i in range(N):\n\n    minDist[i][i] = 0\n\n\n\nedges = []\n\nfor _ in range(M):\n\n    fr, to, d = list(map(int, input().split()))\n\n    fr -= 1\n\n    to -= 1\n\n    edges.append((fr, to, d))\n\n    minDist[fr][to] = d\n\n    minDist[to][fr] = d\n\n\n\nfor k in range(N):\n\n    for i in range(N):\n\n        for j in range(N):\n\n            d = minDist[i][k] + minDist[k][j]\n\n            if minDist[i][j] > d:\n\n                minDist[i][j] = d\n\n\n\nans = 0\n\nfor fr, to, d in edges:\n\n    if minDist[fr][to] < d:\n\n        ans += 1\n\nprint(ans)\n", "score": 1.0, "codebleu": 0.47322317218413795, "crystalbleu": 0.42492648120315435, "codebertscore": 0.8, "codescore": 0.32741880416870117, "surfaceSim": 0.6190663519538422, "abs_surfaceSim_minus_score": 0.3809336480461578}
{"golden_code": "import numpy as np\n\nN_1=list(map(int, input().split()))\n\nN_2=list(map(int, input().split()))\n\nN_3=list(map(int, input().split()))\n\nN=int(eval(input()))\n\na=[int(eval(input())) for i in range(N)]\n\n\n\nn=np.array([N_1,N_2,N_3])\n\n\n\nfor a_n in a:\n\n    if a_n in n:\n\n        n[n==a_n]=0\n\n    else:\n\n        pass\n\ni=0\n\n    \n\nif np.all(n[0:,0]==0)==True:\n\n    i=+1\n\n    \n\nelif np.all(n[0:,1]==0)==True:\n\n    i+=1\n\n    \n\nelif np.all(n[0:,2]==0)==True:\n\n    i+=1\n\n    \n\nelif np.all(n[0,0:]==0)==True:\n\n    i+=1\n\n    \n\nelif np.all(n[1,0:]==0)==True:\n\n    i+=1\n\n\n\nelif np.all(n[2,0:]==0)==True:\n\n    i+=1\n\n\n\nelif n[0,0]==0 and n[1,1]==0  and n[2,2] ==0:\n\n    i+=1\n\n    \n\nelif n[0,2]==0 and n[1,1]==0 and n[2,0] ==0:\n\n    i+=1\n\n    \n\nif i>0:\n\n    print(\"Yes\")\n\nelse:\n\n    print(\"No\")", "generated_code": "a_1=list(map(int, input().split()))\n\na_2=list(map(int, input().split()))\n\na_3=list(map(int, input().split()))\n\n\n\nc=[a_1,a_2,a_3]\n\n\n\nN=int(eval(input()))\n\n\n\nb=[int(eval(input())) for _ in range(N)]\n\n\n\nfor i in range(3):\n\n    for j in range(3):\n\n        if c[i][j] in b:\n\n            c[i][j]=0\n\n            \n\n            \n\ni=0\n\nif c[0][0]==0 and c[0][1]==0 and c[0][2]==0:\n\n    i+=1\n\nif c[1][0]==0 and c[1][1]==0 and c[1][2]==0:\n\n    i+=1\n\nif c[2][0]==0 and c[2][1]==0 and c[2][2]==0:\n\n    i+=1\n\nif c[0][0]==0 and c[1][0]==0 and c[2][0]==0:\n\n    i+=1\n\nif c[0][1]==0 and c[1][1]==0 and c[2][1]==0:\n\n    i+=1\n\nif c[0][2]==0 and c[1][2]==0 and c[2][2]==0:\n\n    i+=1\n\nif c[0][0]==0 and c[1][1]==0 and c[2][2]==0:\n\n    i+=1\n\nif c[0][2]==0 and c[1][1]==0 and c[2][0]==0:\n\n    i+=1\n\n    \n\nif i>0:\n\n    print(\"Yes\")\n\nelse:\n\n  print(\"No\")", "score": 1.0, "codebleu": 0.3141180079646291, "crystalbleu": 0.43074943134461113, "codebertscore": 0.89, "codescore": 0.8679067492485046, "surfaceSim": 0.6924123337363965, "abs_surfaceSim_minus_score": 0.30758766626360345}
{"golden_code": "import math\n\n\n\nN = int(eval(input()))\n\nans = math.factorial(N) % (10**9 + 7)\n\nprint(ans)", "generated_code": "N = int(eval(input()))\n\nmod = 10**9 + 7\n\nans = 1\n\nfor i in range(1, N + 1):\n\n    ans *= i\n\n    ans %= mod\n\nprint(ans)\n", "score": 1.0, "codebleu": 0.32419912461698, "crystalbleu": 0.0, "codebertscore": 0.85, "codescore": 0.7729637622833252, "surfaceSim": 0.6045197740112994, "abs_surfaceSim_minus_score": 0.3954802259887006}
{"golden_code": "import sys\n\ninput = sys.stdin.readline\n\nsys.setrecursionlimit(10 ** 7)\n\n\n\nN = int(eval(input()))\n\nA = [int(i) for i in input().split()]\n\nB = [int(i) for i in input().split()]\n\nbefore = sum(A)\n\n\n\nfor i in range(N):\n\n    nokori = B[i]\n\n    for j in range(i,i+2):\n\n        if nokori >= A[j]:\n\n            nokori -= A[j]\n\n            A[j] = 0\n\n        else:\n\n            A[j] -= nokori\n\n            nokori = 0\n\nafter = sum(A)\n\n\n\nprint((before - after))", "generated_code": "N = int(eval(input()))\n\nA = [int(i) for i in input().split()]\n\nB = [int(i) for i in input().split()]\n\n\n\ncnt = 0\n\nfor i in range(N):\n\n    if B[i] >= A[i]:\n\n        cnt += A[i]\n\n        B[i] -= A[i]\n\n    else:\n\n        cnt += B[i]\n\n        B[i] = 0\n\n    if B[i] == 0:\n\n        continue\n\n    if B[i] >= A[i+1]:\n\n        cnt += A[i+1]\n\n        A[i+1] = 0\n\n    else:\n\n        cnt += B[i]\n\n        A[i+1] -= B[i]\n\n\n\nprint(cnt)", "score": 1.0, "codebleu": 0.4094408094356795, "crystalbleu": 0.43670551042039385, "codebertscore": 0.82, "codescore": 0.7911079525947571, "surfaceSim": 0.6795157967032968, "abs_surfaceSim_minus_score": 0.32048420329670324}
{"golden_code": "import sys\n\ninput = sys.stdin.readline\n\nfrom collections import *\n\n\n\nK = int(eval(input()))\n\nA, B = list(map(int, input().split()))\n\n\n\nfor i in range(A, B+1):\n\n    if i%K==0:\n\n        print('OK')\n\n        exit()\n\n    \n\nprint('NG')", "generated_code": "K = int(eval(input()))\n\nA, B = list(map(int, input().split()))\n\n\n\nif (A-1)//K!=B//K:\n\n    print('OK')\n\nelse:\n\n    print('NG')", "score": 1.0, "codebleu": 0.3704485128229619, "crystalbleu": 0.0, "codebertscore": 0.83, "codescore": 0.5077811479568481, "surfaceSim": 0.5956521739130434, "abs_surfaceSim_minus_score": 0.40434782608695663}
{"golden_code": "import numpy as np\n\nimport math\n\n\n\ndef bigger_devisor(n):\n\n  s = np.sqrt(n)\n\n  i = math.ceil(s)\n\n  while(n % i != 0):\n\n    i += 1\n\n  return i\n\n\n\nn = int(eval(input()))\n\nif bigger_devisor(n) > 9:\n\n  print('No')\n\nelse:\n\n  print('Yes')", "generated_code": "n = int(eval(input()))\n\nans = 0\n\nfor i in range(1, 10):\n\n  if n % i == 0:\n\n    if n / i < 10:\n\n      ans = 1\n\nif ans == 0:\n\n  print('No')\n\nelse:\n\n  print('Yes')", "score": 1.0, "codebleu": 0.22073174214542643, "crystalbleu": 0.0, "codebertscore": 0.81, "codescore": 0.6225472688674927, "surfaceSim": 0.46213054187192115, "abs_surfaceSim_minus_score": 0.5378694581280788}
{"golden_code": "import sys\n\nreadline = sys.stdin.readline\n\nsys.setrecursionlimit(10**8)\n\nmod = 10**9+7\n\n#mod = 998244353\n\nINF = 10**18\n\neps = 10**-7\n\n\n\nm,n,k = list(map(int,readline().split()))\n\n\n\ndef comb(n, r, mod):\n\n    r = min(r, n-r)\n\n    mol = 1\n\n    deno = 1\n\n    for i in range(1, r+1):\n\n        mol = mol * (n-r+i) % mod\n\n        deno = deno * i % mod\n\n    ret = mol * pow(deno, mod-2, mod) % mod\n\n    return ret\n\n\n\ndef f1(x,y,a,b):\n\n    return (a+b-x-y)*(a-x+1)*(b-y+1)//2\n\n\n\ndef f2(x,a):\n\n    return (a-x)*(a-x+1)//2\n\n\n\nans = 0\n\n\n\nfor x in range(1,n+1):\n\n    for y in range(1,m+1):\n\n        ans += f1(x,y,n,m)+f1(1,1,x,y)+f1(1,y,x,m)+f1(x,1,n,y)\n\n        ans -= f2(x,n) + f2(1,x) + f2(1,y) + f2(y,m)\n\n        ans %= mod\n\n\n\nans = (ans * comb(m*n-2,k-2,mod))%mod\n\nans = ans*pow(2,mod-2,mod)%mod\n\n\n\nprint(ans)\n", "generated_code": "import sys\n\nreadline = sys.stdin.readline\n\nsys.setrecursionlimit(10**8)\n\nmod = 10**9+7\n\n#mod = 998244353\n\nINF = 10**18\n\neps = 10**-7\n\n\n\nm,n,k = list(map(int,readline().split()))\n\n\n\ndef comb(n, r, mod):\n\n    r = min(r, n-r)\n\n    mol = 1\n\n    deno = 1\n\n    for i in range(1, r+1):\n\n        mol = mol * (n-r+i) % mod\n\n        deno = deno * i % mod\n\n    ret = mol * pow(deno, mod-2, mod) % mod\n\n    return ret\n\n\n\ndef f1(x,y,a,b):\n\n    return (a+b-x-y)*(a-x+1)*(b-y+1)//2\n\n\n\ndef f2(x,a):\n\n    return (a-x)*(a-x+1)//2\n\n\n\nans = 0\n\n\n\nfor x in range(1,n+1):\n\n    for y in range(1,m+1):\n\n        a = n-x+1\n\n        b = m-y+1\n\n        c = m*(a*(a-1)+x*(x-1))\n\n        d = n*(b*(b-1)+y*(y-1))\n\n        ans += (c+d)//2\n\n        ans %= mod\n\n\n\nans = (ans * comb(m*n-2,k-2,mod))%mod\n\nans = ans*pow(2,mod-2,mod)%mod\n\n\n\nprint(ans)\n\n\n", "score": 1.0, "codebleu": 0.844738269351389, "crystalbleu": 0.808173874496045, "codebertscore": 0.96, "codescore": 0.9935541152954102, "surfaceSim": 0.9564417177914111, "abs_surfaceSim_minus_score": 0.04355828220858893}
{"golden_code": "\n\nclass UnionFind:\n\n    def __init__(self, size):\n\n        self.table = [i for i in range(size)]\n\n\n\n    def find(self, x):\n\n        return self.table[x]\n\n\n\n    def union(self, x, y):\n\n        x1 = self.find(x)\n\n        y1 = self.find(y)\n\n\n\n        if x1 == y1:\n\n            return False\n\n\n\n        for i in range(len(self.table)):\n\n            if self.table[i] == y1:\n\n                self.table[i] = x1\n\n        return True\n\n\n\n\n\nN, M = list(map(int, input().split()))\n\n\n\nedges = []\n\nfor _ in range(M):\n\n    a, b = list(map(int, input().split()))\n\n    edges.append([a-1, b-1])\n\n\n\nmat = [[0]*N for _ in range(N)]\n\nfor s, g in edges:\n\n    mat[s][g] = 1\n\n    mat[g][s] = 1\n\n\n\nans = 0\n\n\n\nfor i in range(M):\n\n    uni = UnionFind(N)\n\n\n\n    for j in range(M):\n\n        if i != j:\n\n            uni.union(edges[j][0], edges[j][1])\n\n\n\n    if not all(uni.find(0) == uni.find(x) for x in range(N)):\n\n        ans += 1\n\nprint(ans)\n", "generated_code": "# python template for atcoder1\n\nimport sys\n\nsys.setrecursionlimit(10**9)\n\ninput = sys.stdin.readline\n\n\n\n\n\nclass UnionFind:\n\n    def __init__(self, size):\n\n        \"\"\"\n\n        size:頂点の数\n\n        \"\"\"\n\n        self.parent = [i for i in range(size)]\n\n        self.rank = [0 for _ in range(size)]\n\n\n\n    def find(self, x):\n\n        \"\"\"\n\n        xのrootを返す\n\n        \"\"\"\n\n        if self.parent[x] == x:\n\n            return x\n\n        else:\n\n            return self.find(self.parent[x])\n\n\n\n    def union(self, x, y):\n\n        \"\"\"\n\n        x,yを同じグループとしてまとめる\n\n        \"\"\"\n\n        x = self.find(x)\n\n        y = self.find(y)\n\n        if x == y:\n\n            return\n\n\n\n        if self.rank[x] < self.rank[y]:\n\n            self.parent[x] = y\n\n        else:\n\n            self.parent[y] = x\n\n            if self.rank[x] == self.rank[y]:\n\n                self.rank[x] += 1\n\n\n\n    def same(self, x, y):\n\n        \"\"\"\n\n        xとyが同じグループならTrue\n\n        \"\"\"\n\n        return self.find(x) == self.find(y)\n\n\n\n    def component(self):\n\n        \"\"\"\n\n        各連結成分のrootの集合を返す\n\n        len()をとれば連結成分の数が求められる\n\n        return-> set()\n\n        \"\"\"\n\n        comp = set()\n\n        for i in self.parent:\n\n            p = self.find(i)\n\n            comp.add(p)\n\n        return comp\n\n\n\n    def __str__(self):\n\n        \"\"\"\n\n        for debug\n\n        クラスのlistの情報を出力\n\n        \"\"\"\n\n        ret = \"parents\\n\"\n\n        ret += \" \".join(map(str, self.parent))\n\n        ret += '\\n'\n\n        ret += \" \".join(map(str, self.rank))\n\n        return ret\n\n\n\n\n\nN, M = list(map(int, input().split()))\n\nedges = []\n\n\n\nfor _ in range(M):\n\n    a, b = [int(x)-1 for x in input().split()]\n\n    edges.append([a, b])\n\n\n\nans = 0\n\nfor e in edges:\n\n    Un = UnionFind(N)\n\n    for g in edges:\n\n        if e == g:\n\n            continue\n\n        else:\n\n            Un.union(g[0], g[1])\n\n    if not Un.same(e[0], e[1]):\n\n        ans += 1\n\nprint(ans)\n", "score": 1.0, "codebleu": 0.3827846660559022, "crystalbleu": 0.30718780807974805, "codebertscore": 0.77, "codescore": 0.8102661967277527, "surfaceSim": 0.6846996673840735, "abs_surfaceSim_minus_score": 0.3153003326159265}
{"golden_code": "N,X = list(map(int,input().split()))\n\nL = [0] + [int(x) for x in input().split()]\n\n\n\nD = [0] * (N+2)\n\nanswer = 1\n\nfor n in range(2,N+2):\n\n  D[n] = D[n-1] + L[n-1]\n\n  if D[n] <= X:\n\n    answer += 1\n\n    \n\nprint(answer)", "generated_code": "import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\nimport itertools\n\n\n\nN,X,*L = list(map(int,read().split()))\n\n\n\nanswer = sum(x <= X for x in itertools.accumulate([0]+L))\n\nprint(answer)", "score": 1.0, "codebleu": 0.19587331006978015, "crystalbleu": 0.19331680272429946, "codebertscore": 0.74, "codescore": 0.3206169605255127, "surfaceSim": 0.4400111607142857, "abs_surfaceSim_minus_score": 0.5599888392857143}
{"golden_code": "N = int(eval(input()))\n\nx = list(map(int, input().split()))\n\ncnt = 0\n\nfor i in x:\n\n  while i % 2 == 0:\n\n    cnt += 1\n\n    i /= 2\n\nprint(cnt)", "generated_code": "n = int(eval(input()))\n\nans = 0\n\nfor i in map(int, input().split()):\n\n    cnt = 0\n\n    while i % 2 == 0:\n\n        i >>= 1\n\n        cnt += 1\n\n    ans += cnt\n\nprint(ans)", "score": 1.0, "codebleu": 0.5065154785810035, "crystalbleu": 0.0, "codebertscore": 0.92, "codescore": 0.8492913842201233, "surfaceSim": 0.8365899779388591, "abs_surfaceSim_minus_score": 0.16341002206114086}
{"golden_code": "import math\n\nn = int(eval(input()))\n\n\n\nans = math.factorial(n)  # nの階乗を計算\n\n\n\nif ans >= (10 ** 9)+7:\n\n    ans = ans % ((10 ** 9)+7)\n\n\n\nprint(ans)\n", "generated_code": "n = int(eval(input()))\n\n\n\nans = 1\n\nfor i in range(1, n+1):\n\n    ans = ans * i\n\n    ans = ans % ((10 ** 9)+7)  # 途中で割り算の余りを求めても、最終結果は同じになる\n\n\n\nprint(ans)", "score": 1.0, "codebleu": 0.45508450301466985, "crystalbleu": 0.0, "codebertscore": 0.8, "codescore": 0.1947966068983078, "surfaceSim": 0.6609271523178808, "abs_surfaceSim_minus_score": 0.3390728476821192}
{"golden_code": "import statistics\n\nN = int(eval(input()))\n\na = [int(i) for i in input().split()]\n\nans = 0\n\n\n\nfor i in range(1,N+1):\n\n  a[i-1] -= i\n\n\n\nb = statistics.median(a)\n\nfor i in range(N):\n\n  ans += abs(a[i]-b)\n\nprint((int(ans)))", "generated_code": "N = int(eval(input()))\n\nA = [int(i) for i in input().split()]\n\nC = [A[i]-i for i in range(N)]\n\nC.sort()\n\nans = 0\n\nmed = C[N//2]\n\nfor i in range(N):\n\n  ans += abs(C[i]-med)\n\nprint(ans)", "score": 1.0, "codebleu": 0.4446310228895979, "crystalbleu": 0.3879392597446721, "codebertscore": 0.89, "codescore": 0.41096726059913635, "surfaceSim": 0.7664709719504239, "abs_surfaceSim_minus_score": 0.2335290280495761}
{"golden_code": "print((eval(input())))", "generated_code": "print(eval(input()))", "score": 1.0, "codebleu": 0.3611111111111111, "crystalbleu": 0.0, "codebertscore": 0.98, "codescore": 0.966159999370575, "surfaceSim": 0.9545454545454546, "abs_surfaceSim_minus_score": 0.045454545454545414}
{"golden_code": "import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\nimport numpy as np\n\n\n\nN = int(readline())\n\nS = np.array(read().split(),np.int64)\n\n\n\ndef F(d):\n\n    # 公差を固定\n\n    L = S[:-d:d].cumsum()\n\n    R = S[::-1][:-d:d].cumsum()\n\n    if (N-1)%d == 0:\n\n        n = (N-1)//d\n\n        x = np.arange(1,n+1)\n\n        bl = (x+x <= n+1)\n\n        L = L[bl]; R = R[bl]\n\n    return (L+R).max()\n\n\n\ndef G(n):\n\n    # 項数n+1を固定\n\n    D = (N-1-n)//n\n\n    L = np.zeros(D+1,np.int64)\n\n    R = np.zeros(D+1,np.int64)\n\n    for i in range(1,n+1):\n\n        L += S[:i*(D+1):i]\n\n        R += S[::-1][:i*(D+1):i]\n\n    ok = np.ones(D+1,np.bool)\n\n    overlap = (np.arange(D+1) * (n+n) >= N-1)\n\n    overlap[1:] &= ((N-1)%np.arange(1,D+1) == 0)\n\n    x = L+R\n\n    x[overlap] = 0\n\n    return x.max()\n\n\n\nL = int((N-1)**.5 + 10)\n\nL = min(N-1,L)\n\n\n\nx = max(F(n) for n in range(1,L+1))\n\ny = max(G(n) for n in range(1,L+1))\n\nanswer = max(x,y)\n\nprint(answer)", "generated_code": "import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\nimport itertools\n\n\n\nN = int(readline())\n\nS = list(map(int,read().split()))\n\n\n\nanswer = 0\n\nfor d in range(1,N):\n\n    n = (N-1)//d\n\n    if (N-1)%d == 0:\n\n        n = ((N-1)//d+1)//2\n\n    if n <= 1:\n\n        continue\n\n    x = max(itertools.accumulate(x+y for x,y in zip(S[d:d*n:d],S[N-1-d:N-1-d*n:-d])))\n\n    if answer < x:\n\n        answer = x\n\n\n\nprint(answer)", "score": 1.0, "codebleu": 0.2552447586353633, "crystalbleu": 0.12394417086150523, "codebertscore": 0.82, "codescore": 0.961764931678772, "surfaceSim": 0.6153061224489795, "abs_surfaceSim_minus_score": 0.38469387755102047}
{"golden_code": "N = int(eval(input()))\n\ns_list = {}\n\nfor i in range(N):\n\n  S = eval(input())\n\n  if S in list(s_list.keys()):\n\n    s_list[S] += 1\n\n  else:\n\n    s_list[S] = 0\n\nmax = 0\n\nmaxs = []\n\nfor s,c in list(s_list.items()):\n\n  if c > max:\n\n    maxs = [s]\n\n    max = c\n\n  elif c == max:\n\n    maxs.append(s)\n\nmaxs.sort()\n\nfor m in maxs:\n\n  print(m)", "generated_code": "from collections import Counter\n\ndef solve():\n\n  N = int(input())\n\n  S = [input() for _ in range(N)]\n\n  c = Counter(S)\n\n  M = max(c.values())\n\n  ans = []\n\n  for k,v in c.items():\n\n    if v==M:\n\n      ans.append(k)\n\n  ans.sort()\n\n  return ans\n\nprint(*solve(),sep='\\n')\n", "score": 1.0, "codebleu": 0.2332976200856245, "crystalbleu": 0.0, "codebertscore": 0.77, "codescore": 0.6021374464035034, "surfaceSim": 0.4806742226097065, "abs_surfaceSim_minus_score": 0.5193257773902935}
{"golden_code": "# ABC 120 C\n\n\n\nimport re\n\n\n\nS = eval(input())\n\n\n\nl0 = 0\n\nl1 = 0\n\n\n\nfor i in range(len(S)):\n\n    if S[i] == '0':\n\n        l0 += 1\n\n    elif S[i] == '1':\n\n        l1 += 1\n\n\n\nprint((min(l0, l1) * 2))\n", "generated_code": "def resolve():\n\n  S = eval(input())\n\n  arr = []\n\n  for s in S:\n\n    if len(arr) != 0 and arr[-1] != s:\n\n      arr.pop()\n\n    else:\n\n      arr.append(s)\n\n\n\n  print((len(S) - len(arr)))\n\n  return\n\n\n\nif __name__ == \"__main__\":\n\n  resolve()\n", "score": 1.0, "codebleu": 0.1749179762057966, "crystalbleu": 0.0, "codebertscore": 0.76, "codescore": 0.018374213948845863, "surfaceSim": 0.4761126990608412, "abs_surfaceSim_minus_score": 0.5238873009391588}
{"golden_code": "from scipy.sparse.csgraph import floyd_warshall\n\nimport numpy as np\n\nimport sys\n\n\n\ninput = sys.stdin.readline\n\n\n\nN, M = list(map(int, input().split()))\n\nAB = []\n\nedge = np.zeros((N, N), dtype=int)\n\nfor _ in range(M):\n\n    a, b = list(map(int, input().split()))\n\n    a -= 1\n\n    b -= 1\n\n    AB.append((a, b))\n\n    edge[a][b] = 1\n\n    edge[b][a] = 1\n\n\n\nans = 0\n\nfor i in range(M):\n\n    graph = np.copy(edge)\n\n    a, b = AB[i]\n\n    graph[a][b] = 0\n\n    graph[b][a] = 0\n\n    fw = floyd_warshall(graph)\n\n    if fw.max() > 10000:\n\n        ans += 1\n\n\n\nprint(ans)\n", "generated_code": "import sys\n\ninput = sys.stdin.buffer.readline\n\nsys.setrecursionlimit(10 ** 7)\n\n\n\n\n\nclass UF_tree:\n\n    def __init__(self, n):\n\n        self.root = [-1] * (n + 1)  # -1ならそのノードが根,で絶対値が木の要素数\n\n        self.rank = [0] * (n + 1)\n\n\n\n    def find(self, x):  # xの根となる要素番号を返す\n\n        if self.root[x] < 0:\n\n            return x\n\n        else:\n\n            self.root[x] = self.find(self.root[x])\n\n            return self.root[x]\n\n\n\n    def isSame(self, x, y):\n\n        return self.find(x) == self.find(y)\n\n\n\n    def unite(self, x, y):\n\n        x = self.find(x)\n\n        y = self.find(y)\n\n        if x == y:\n\n            return\n\n        elif self.rank[x] < self.rank[y]:\n\n            self.root[y] += self.root[x]\n\n            self.root[x] = y\n\n        else:\n\n            self.root[x] += self.root[y]\n\n            self.root[y] = x\n\n            if self.rank[x] == self.rank[y]:\n\n                self.rank[x] += 1\n\n\n\n    def getNodeLen(self, x):\n\n        return -self.root[self.find(x)]\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    N, M = list(map(int, input().split()))\n\n    AB = tuple(tuple(map(int, input().split())) for _ in range(M))\n\n\n\n    ans = 0\n\n    for i in range(M):\n\n        uf = UF_tree(N)\n\n        for j, (a, b) in enumerate(AB):\n\n            if i == j:\n\n                continue\n\n            uf.unite(a, b)\n\n        a, b = AB[i]\n\n        if not uf.isSame(a, b):\n\n            ans += 1\n\n    print(ans)", "score": 1.0, "codebleu": 0.3523837901623334, "crystalbleu": 0.22646540612264335, "codebertscore": 0.73, "codescore": 0.018256444483995438, "surfaceSim": 0.5088066139468008, "abs_surfaceSim_minus_score": 0.4911933860531992}
{"golden_code": "def main():\n\n    S = eval(input())\n\n    w1 = 'dream'[::-1]\n\n    w2 = 'dreamer'[::-1]\n\n    w3 = 'erase'[::-1]\n\n    w4 = 'eraser'[::-1]\n\n    # print(w1,w2,w3,w4)\n\n    S = S[::-1]\n\n    # print(S)\n\n\n\n    # words = ['dream', 'dreamer', 'erase', 'eraser']\n\n    words = [w1, w2, w3, w4]\n\n    T = ''\n\n    while S != T:\n\n        cand = []\n\n        for w in words:\n\n            new_t = T + w\n\n            cand.append(new_t) \n\n        # print('cand', cand)\n\n        ans = False\n\n        for c in cand:\n\n            if c == S[:len(c)]:\n\n                T = c\n\n                ans = True\n\n\n\n        if not ans:\n\n            break\n\n\n\n    if S == T:\n\n        print('YES')\n\n    else:\n\n        print(\"NO\")\n\n\n\nif __name__ == \"__main__\":\n\n    main()", "generated_code": "def main():\n\n    S = eval(input())\n\n    w1 = 'dream'[::-1]\n\n    w2 = 'dreamer'[::-1]\n\n    w3 = 'erase'[::-1]\n\n    w4 = 'eraser'[::-1]\n\n    S = S[::-1]\n\n    words = [w1, w2, w3, w4]\n\n\n\n    flag = False\n\n    i = 0\n\n    while i < len(S):\n\n        for w in words:\n\n            if S[i:].startswith(w):\n\n                i += len(w)\n\n                flag = True\n\n                break\n\n\n\n        if not flag:\n\n            print(\"NO\")\n\n            exit()\n\n        flag = False\n\n\n\n    print(\"YES\")\n\n\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()", "score": 1.0, "codebleu": 0.49477669182208117, "crystalbleu": 0.5490720306256603, "codebertscore": 0.89, "codescore": 0.018546845763921738, "surfaceSim": 0.8450097847358121, "abs_surfaceSim_minus_score": 0.15499021526418788}
{"golden_code": "import math\n\nN = int(eval(input()))\n\np = math.factorial(N)\n\nprint((p % 1000000007))", "generated_code": "N = int(eval(input()))\n\np = 1\n\nfor i in range(1,N+1):\n\n    p *= i\n\n    p %= 1000000007\n\nprint(p)\n", "score": 1.0, "codebleu": 0.35373732956578885, "crystalbleu": 0.0, "codebertscore": 0.83, "codescore": 0.5697848796844482, "surfaceSim": 0.5621588841722256, "abs_surfaceSim_minus_score": 0.4378411158277744}
{"golden_code": "S, T = input().split()\n\nA, B= list(map(int, input().split()))\n\nU = eval(input())\n\nif S == U:\n\n    print((A - 1, B))\n\nelse:\n\n    print((A, B - 1))", "generated_code": "S, T = input().split()\n\nA, B= list(map(int, input().split()))\n\nU = eval(input())\n\nif S == U:\n\n    A-=1\n\nelse:\n\n    B-=1\n\nprint((A,B))", "score": 1.0, "codebleu": 0.689581934054774, "crystalbleu": 0.0, "codebertscore": 0.95, "codescore": 0.6449770927429199, "surfaceSim": 0.8719827586206896, "abs_surfaceSim_minus_score": 0.12801724137931036}
{"golden_code": "n=int(eval(input()))\n\na=[list(map(int,input().split()))for _ in range(n)]\n\ndef f():\n\n for i in range(n-1):\n\n  d=a[i][:];d[3],d[4]=d[4],d[3]\n\n  for j in range(i+1,n):\n\n   e=a[j][:];e[3],e[4]=e[4],e[3]\n\n   for p in('012345','152043','215304','302541','410352','514320'):\n\n    f=[d[int(k)]for k in p]\n\n    g=f[1:5]*2\n\n    for k in range(4):\n\n     if(g[k:k+4]==e[1:5])*(f[0]==e[0])*(f[5]==e[5]):return 'No'\n\n return 'Yes'\n\nprint((f()))\n", "generated_code": "n=int(eval(input()))\n\na=[list(map(int,input().split()))for _ in range(n)]\n\ndef f():\n\n for i in range(n-1):\n\n  d=a[i][:];d[3],d[4]=d[4],d[3]\n\n  for j in range(i+1,n):\n\n   e=a[j][:];e[3],e[4]=e[4],e[3]\n\n   for p in('012345','152043','215304','302541','410352','514320'):\n\n    f=[d[int(k)]for k in p]\n\n    g=f[1:5]*2\n\n    for k in range(4):\n\n     if g[k:k+4]==e[1:5]:\n\n      if f[0]==e[0]:\n\n       if f[5]==e[5]:return 'No'\n\n return 'Yes'\n\nprint((f()))\n", "score": 1.0, "codebleu": 0.8944469012963147, "crystalbleu": 0.9271028860544227, "codebertscore": 0.99, "codescore": 0.6748576760292053, "surfaceSim": 0.9888888888888889, "abs_surfaceSim_minus_score": 0.011111111111111072}
{"golden_code": "def main():\n\n  n = int(eval(input()))\n\n  \n\n  dp = [0]*(n+1)\n\n  dp[0] = 1\n\n  mod = pow(10, 9) + 7\n\n  for i in range(n+1):\n\n    for j in range(i-2):\n\n      dp[i] += dp[j]\n\n      dp[i] %= mod\n\n  \n\n  print((dp[n]))\n\n\n\nif __name__ == \"__main__\":\n\n  main()", "generated_code": "def main():\n\n  n = int(eval(input()))\n\n  \n\n  dp = [0]*(n+1)\n\n  dp[0] = 1\n\n  mod = pow(10, 9) + 7\n\n  for i in range(3, n+1):\n\n    dp[i] = dp[i-1] + dp[i-3]\n\n    dp[i] %= mod\n\n  \n\n  print((dp[n]))\n\n\n\nif __name__ == \"__main__\":\n\n  main()", "score": 1.0, "codebleu": 0.741593729225603, "crystalbleu": 0.8225102682210464, "codebertscore": 0.97, "codescore": 0.6835849285125732, "surfaceSim": 0.952, "abs_surfaceSim_minus_score": 0.04800000000000004}
{"golden_code": "import numpy as np\n\n\n\nn,l=list(map(int,input().split()))\n\nli=[]\n\nfor i in range(n):\n\n  li.append(l+i)\n\ns=sum(li)\n\np=np.array(li)\n\na=np.abs(p).tolist()\n\nk=min(a)\n\nb=a.index(k)\n\nprint((s-li[b]))", "generated_code": "n,l=list(map(int,input().split()))\n\na=0\n\nfor i in range(n):\n\n  a+=i+l\n\nif l>=0:\n\n  print((a-l))\n\nelif l+n-1<0:\n\n  print((a-(l+n-1)))\n\nelse:\n\n  print(a)", "score": 1.0, "codebleu": 0.2338193210840532, "crystalbleu": 0.0, "codebertscore": 0.81, "codescore": 0.1319761723279953, "surfaceSim": 0.5234375, "abs_surfaceSim_minus_score": 0.4765625}
{"golden_code": "import sys\n\ninput = sys.stdin.readline\n\nread = sys.stdin.read\n\n\n\nn = int(eval(input()))\n\nA = list(map(int, read().split()))\n\nL = sorted([(j, i) for i, j in enumerate(A)])\n\ncount = 0\n\nfor i in range(n):\n\n  if (L[i][1]-i)%2:\n\n    count += 1\n\nans = (count+1) // 2\n\nprint(ans)", "generated_code": "import sys\n\ninput = sys.stdin.readline\n\nread = sys.stdin.read\n\n\n\nn = int(eval(input()))\n\nA = list(map(int, read().split()))\n\nL = sorted([(j, i) for i, j in enumerate(A)])\n\ncount = 0\n\nfor i in range(n):\n\n  count += (L[i][1]-i)%2\n\nans = (count+1) // 2\n\nprint(ans)\n", "score": 1.0, "codebleu": 0.8859963350045508, "crystalbleu": 0.9356136402159746, "codebertscore": 0.99, "codescore": 0.8677297234535217, "surfaceSim": 0.9479166666666667, "abs_surfaceSim_minus_score": 0.05208333333333326}
{"golden_code": "# Problem https://atcoder.jp/contests/abc053/tasks/abc053_b\n\n# Python 1st Try\n\nimport copy\n\n\n\n\n\nclass Problem:\n\n    def __init__(self, stringdata):\n\n        self.stringdata = stringdata\n\n\n\n    def solver(self):\n\n        strcont = copy.copy(self.stringdata)\n\n        result = 0\n\n        rightposition = 0\n\n        leftposition = len(strcont)\n\n        j = 0\n\n        while True:\n\n            if strcont[j] == 'A':\n\n                rightposition = j\n\n                break\n\n            else:\n\n                j = j + 1\n\n        j = leftposition - 1\n\n        while True:\n\n            if strcont[j] == 'Z':\n\n                leftposition = j\n\n                break\n\n            else:\n\n                j = j - 1\n\n\n\n        result = leftposition - rightposition + 1\n\n        return result\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    s = eval(input())\n\n    print((\"{}\".format(Problem(s).solver())))\n", "generated_code": "# Problem https://atcoder.jp/contests/abc053/tasks/abc053_b\n\n# Python 2nd Try\n\n\n\n\n\ndef solver(string):\n\n    result = 200000\n\n    aposi = 0\n\n    zposi = len(string)\n\n    for j in range(0, len(string), 1):\n\n        if string[j] == 'A':\n\n            aposi = j\n\n            break\n\n    for j in range(len(string)-1, -1, -1):\n\n        if string[j] == 'Z':\n\n            zposi = j\n\n            break\n\n    result = zposi - aposi + 1\n\n    return result\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    s = eval(input())\n\n    print(('{}'.format(solver(s))))\n", "score": 1.0, "codebleu": 0.2960028526362116, "crystalbleu": 0.276138289968533, "codebertscore": 0.85, "codescore": 0.025363590568304062, "surfaceSim": 0.737181239504823, "abs_surfaceSim_minus_score": 0.26281876049517705}
{"golden_code": "n, m = list(map(int, input().split()))\n\ndp = [0] * n\n\nfor i in range(m):\n\n    x, y = list(map(int, input().split()))\n\n    dp[x - 1] += 1\n\n    dp[y - 1] += 1\n\nfor i in range(n):\n\n    print((dp[i]))", "generated_code": "n, m = list(map(int, input().split()))\n\nA = [0] * n\n\nfor i in range(m):\n\n    a, b = list(map(int, input().split()))\n\n    A[a - 1] += 1\n\n    A[b - 1] += 1\n\n    \n\nfor i in range(n):\n\n    print((A[i]))", "score": 1.0, "codebleu": 0.8058332305570645, "crystalbleu": 0.590862537223527, "codebertscore": 0.95, "codescore": 0.6497997641563416, "surfaceSim": 0.9696969696969697, "abs_surfaceSim_minus_score": 0.030303030303030276}
{"golden_code": "mod = 998244353\n\nN = int(eval(input()))\n\nX = []\n\nfor _ in range(N):\n\n    x, d = list(map(int, input().split()))\n\n    X.append((x, x + d))\n\n\n\nX = sorted(X, key = lambda x: x[0])\n\nL = [(0, -(10**9+1), 10**9+1)]\n\nP = [-1] * (N+1)\n\nfor i, (x, y) in enumerate(X):\n\n    while L[-1][2] <= y:\n\n        if L[-1][2] > x and P[i+1] < 0:\n\n            P[i+1] = L[-1][0]\n\n        L.pop()\n\n    if P[i+1] < 0:\n\n        P[i+1] = L[-1][0]\n\n    L.append((i+1, x, y))\n\n\n\nC = [[] for _ in range(N+1)]\n\nfor i, p in enumerate(P):\n\n    if p >= 0:\n\n        C[p].append(i)\n\n\n\nY = [1] * (N+1)\n\nfor i in range(N+1)[::-1]:\n\n    s = 1\n\n    for j in C[i]:\n\n        s = s * (Y[j] + 1) % mod\n\n    Y[i] = s\n\n\n\nprint((Y[0]))", "generated_code": "import sys\n\ninput = sys.stdin.readline\n\n\n\nmod = 998244353\n\nN = int(eval(input()))\n\nX = []\n\nfor _ in range(N):\n\n    x, d = list(map(int, input().split()))\n\n    X.append((x, x + d))\n\n\n\nX = sorted(X, key = lambda x: x[0])\n\nL = [(0, -(10**9+1), 10**9+1)]\n\nP = [-1] * (N+1)\n\nfor i, (x, y) in enumerate(X):\n\n    while L[-1][2] <= y:\n\n        if L[-1][2] > x and P[i+1] < 0:\n\n            P[i+1] = L[-1][0]\n\n        L.pop()\n\n    if P[i+1] < 0:\n\n        P[i+1] = L[-1][0]\n\n    L.append((i+1, x, y))\n\n\n\nC = [[] for _ in range(N+1)]\n\nfor i, p in enumerate(P):\n\n    if p >= 0:\n\n        C[p].append(i)\n\n\n\nY = [1] * (N+1)\n\nfor i in range(N+1)[::-1]:\n\n    s = 1\n\n    for j in C[i]:\n\n        s = s * (Y[j] + 1) % mod\n\n    Y[i] = s\n\n\n\nprint((Y[0]))", "score": 1.0, "codebleu": 0.8158002450969278, "crystalbleu": 0.9509235642670852, "codebertscore": 0.97, "codescore": 0.9938092827796936, "surfaceSim": 0.9504191658774421, "abs_surfaceSim_minus_score": 0.04958083412255787}
{"golden_code": "n = int(eval(input()))\n\n\n\nfelicidade = []\n\n\n\nfor x in range(n):\n\n    felicidade.append(list(map(int,input().split())))\n\n\n\nDP = [0,0,0]\n\n\n\nif n == 1:\n\n    print((max(felicidade[0])))\n\n\n\nelse:\n\n\n\n    for x in range(3):\n\n        DP[x] = felicidade[0][x]\n\n\n\n\n\n    for dia in range(1,n):\n\n        m = [0] * 3\n\n        for x  in range(3):#As duas possíveis escolhas são x e y\n\n            for y  in range(3):\n\n                if x != y: #Se elas forem diferentes\n\n                    m[x] = max(m[x], DP[y] + felicidade[dia][x])\n\n        DP = m\n\n    \n\n    print((max(DP)))\n", "generated_code": "nDays = int(eval(input()))\n\n\n\ntoday = [int(x) for x in input().split()]\n\n\n\nfor i in range(nDays - 1):\n\n    tomorrow = [int(x) for x in input().split()]\n\n    tomorrow[0] += max(today[1], today[2])\n\n    tomorrow[1] += max(today[0], today[2])\n\n    tomorrow[2] += max(today[0], today[1])\n\n    today = tomorrow\n\n\n\nprint((max(today)))", "score": 1.0, "codebleu": 0.16521526840636913, "crystalbleu": 0.11115898610601531, "codebertscore": 0.72, "codescore": 0.5664702653884888, "surfaceSim": 0.5835537918871252, "abs_surfaceSim_minus_score": 0.4164462081128748}
{"golden_code": "n,m=list(map(int,input().split()))\n\na=[int(x) for x in input().split()]\n\nb=[0 for x in range(n+1)]\n\nl=list([0])\n\n\n\nfor i in range(1,n+1):\n\n  b[i]=b[i-1]+a[i-1]\n\n\n\nfor i in range(1,n+1):\n\n  l.append(b[i]%m)\n\n\n\nd=list()\n\nl.sort()\n\nt,c=0,1\n\nfor i in range(1,n+1):\n\n  if l[i]==l[i-1]:\n\n    c+=1\n\n  else:\n\n    if c!=1:\n\n      t += c*(c-1)//2\n\n      c=1\n\n\n\nif c!=1:\n\n  t += c*(c-1)//2  \n\n\n\nprint(t)\n", "generated_code": "n,m=list(map(int,input().split()))\n\na=[int(x) for x in input().split()]\n\nl=list([0])\n\n\n\nb=0\n\nfor i in range(0,n):\n\n  b += a[i]\n\n  l.append(b%m)\n\nl.append(m)\n\n\n\nl.sort()\n\nt,c=0,1\n\nfor i in range(1,n+2):\n\n  if l[i]==l[i-1]:\n\n    c+=1\n\n  else:\n\n    if c!=1:\n\n      t += c*(c-1)//2\n\n      c=1\n\nprint(t)\n", "score": 1.0, "codebleu": 0.5092214980199887, "crystalbleu": 0.5575746580674745, "codebertscore": 0.95, "codescore": 0.4581790566444397, "surfaceSim": 0.8804071246819338, "abs_surfaceSim_minus_score": 0.11959287531806617}
{"golden_code": "# C - Walk on Multiplication Table\n\n# https://atcoder.jp/contests/abc144/tasks/abc144_c\n\n\n\nn = int(eval(input()))\n\n\n\nans = 10 ** 12\n\nfor i in range(1, 10 ** 6 + 1):\n\n  if n % i == 0:\n\n    ans = min(ans, n // i + i)\n\n\n\nprint((ans - 2))", "generated_code": "# C - Walk on Multiplication Table\n\n# https://atcoder.jp/contests/abc144/tasks/abc144_c\n\n\n\nn = int(eval(input()))\n\n\n\nans = n\n\nfor i in range(1, int(n**.5) + 2):\n\n  if n % i == 0:\n\n    ans = min(ans, n // i + i - 2)\n\n\n\nprint(ans)", "score": 1.0, "codebleu": 0.5287614124029635, "crystalbleu": 0.0, "codebertscore": 0.96, "codescore": 0.4566704034805298, "surfaceSim": 0.9551282051282051, "abs_surfaceSim_minus_score": 0.044871794871794934}
{"golden_code": "n, m, k = list(map(int, input().split()))\n\nmod = 10 ** 9 + 7\n\nMAX = n * m\n\n\n\n\n\nclass ModInt:\n\n    def __init__(self, num):\n\n        self.num = num\n\n\n\n    def __str__(self):\n\n        return str(self.num)\n\n\n\n    def __repr__(self):\n\n        return \"ModInt(num: {}, mod: {}\".format(self.num, mod)\n\n\n\n    def __add__(self, other):\n\n        ret = self.num + other.num\n\n        ret %= mod\n\n        return ModInt(ret)\n\n\n\n    def __sub__(self, other):\n\n        ret = self.num - other.num\n\n        ret %= mod\n\n        return ModInt(ret)\n\n\n\n    def __mul__(self, other):\n\n        ret = self.num * other.num\n\n        ret %= mod\n\n        return ModInt(ret)\n\n\n\n    def pow(self, times):\n\n        pw = pow(self.num, times, mod)\n\n        return ModInt(pw)\n\n\n\n    def inverse(self):\n\n        return ModInt(inv[self.num])\n\n\n\n    def __truediv__(self, other):\n\n        num = self * other.inverse()\n\n        return ModInt(num)\n\n\n\n\n\ndef comb(n, k):\n\n    return fact[n] * inv[n-k] * inv[k]\n\n\n\n\n\nfact = [None] * (MAX + 1)\n\nfact[0] = ModInt(1)\n\nfor i in range(1, MAX + 1):\n\n    fact[i] = fact[i-1] * ModInt(i)\n\n\n\ninv = [None] * (MAX + 1)\n\ninv[MAX] = fact[MAX].pow(mod - 2)\n\nfor i in range(MAX, 0, -1):\n\n    inv[i-1] = inv[i] * ModInt(i)\n\n\n\nans = ModInt(0)\n\nfor i in range(n):\n\n    for j in range(m):\n\n        add = ModInt(n - i) * ModInt(m - j) * ModInt(i + j)\n\n        if i != 0 and j != 0:\n\n            add *= ModInt(2)\n\n\n\n        ans += add\n\n\n\nans *= comb(n * m - 2, k - 2)\n\nprint(ans)\n", "generated_code": "n, m, k = list(map(int, input().split()))\n\n\n\nmod = 10 ** 9 + 7\n\nMAX = n * m\n\n\n\nfact = [1] * (MAX + 1)\n\nfor i in range(1, MAX + 1):\n\n    fact[i] = (fact[i-1] * i) % mod\n\n\n\ninv = [1] * (MAX + 1)\n\ninv[MAX] = pow(fact[MAX], mod - 2, mod)\n\nfor i in range(MAX, 0, -1):\n\n    inv[i-1] = (inv[i] * i) % mod\n\n\n\n\n\ndef comb(n, k):\n\n    return fact[n] * inv[n-k] * inv[k] % mod\n\n\n\n\n\nans = 0\n\nfor i in range(n):\n\n    for j in range(m):\n\n        add = (n - i) * (m - j) * (i + j) % mod\n\n        if i != 0 and j != 0:\n\n            add *= 2\n\n            add %= mod\n\n\n\n        ans += add\n\n        ans %= mod\n\n\n\nans *= comb(MAX - 2, k - 2)\n\nans %= mod\n\nprint(ans)\n", "score": 1.0, "codebleu": 0.3652632021103104, "crystalbleu": 0.34865638333561366, "codebertscore": 0.85, "codescore": 0.39026713371276855, "surfaceSim": 0.7338252924883211, "abs_surfaceSim_minus_score": 0.26617470751167893}
{"golden_code": "import numpy as np\n\n\n\nn = int(eval(input()))\n\na = np.array(list(map(int,input().split())))\n\n\n\ncount = 0\n\nwhile np.all(a%2==0):\n\n    count+=1\n\n    a=a/2\n\nprint(count)\n", "generated_code": "N=int(eval(input()))\n\na = [int(i) for i in input().split()]\n\n\n\ncount=0\n\nwhile 1:\n\n    if sum([i%2 for i in a]) == 0:\n\n        a = [i/2 for i in a]\n\n        count=count+1\n\n    else:\n\n        print(count)\n\n        break\n", "score": 1.0, "codebleu": 0.23312890830139688, "crystalbleu": 0.0, "codebertscore": 0.82, "codescore": 0.9294931888580322, "surfaceSim": 0.6391104906262465, "abs_surfaceSim_minus_score": 0.3608895093737535}
{"golden_code": "a,b = list(map(int, input().split()))\n\ncount = 0\n\nfor i in range(a,b+1):\n\n    j = str(i)\n\n    if j==''.join(reversed(j)):\n\n        count += 1\n\nprint(count)", "generated_code": "a,b = list(map(int, input().split()))\n\nn = [i for i in map(str, list(range(a,b+1))) if i==i[::-1]]\n\nprint((len(n)))", "score": 1.0, "codebleu": 0.3488393822605827, "crystalbleu": 0.0, "codebertscore": 0.87, "codescore": 0.38449543714523315, "surfaceSim": 0.6011220196353436, "abs_surfaceSim_minus_score": 0.3988779803646564}
{"golden_code": "import sys\n\nread = sys.stdin.readline\n\n\n\n\n\ndef read_ints():\n\n    return list(map(int, read().split()))\n\n\n\n\n\ndef read_a_int():\n\n    return int(read())\n\n\n\n\n\ndef read_matrix(H):\n\n    '''\n\n    H is number of rows\n\n    '''\n\n    return [list(map(int, read().split())) for _ in range(H)]\n\n\n\n\n\ndef read_map(H):\n\n    '''\n\n    H is number of rows\n\n    文字列で与えられた盤面を読み取る用\n\n    '''\n\n    return [read()[:-1] for _ in range(H)]\n\n\n\n\n\ndef read_tuple(H):\n\n    '''\n\n    H is number of rows\n\n    '''\n\n    ret = []\n\n    for _ in range(H):\n\n        ret.append(tuple(map(int, read().split())))\n\n    return ret\n\n\n\n\n\ndef read_col(H, n_cols):\n\n    '''\n\n    H is number of rows\n\n    n_cols is number of cols\n\n\n\n    A列、B列が与えられるようなとき\n\n    '''\n\n    ret = [[] for _ in range(n_cols)]\n\n    for _ in range(H):\n\n        tmp = list(map(int, read().split()))\n\n        for col in range(n_cols):\n\n            ret[col].append(tmp[col])\n\n\n\n    return ret\n\n\n\n\n\nN, K = read_ints()\n\nP = read_ints()\n\n\n\n\n\ndef ret_mean(X):\n\n    return (X + 1) / 2\n\n\n\n\n\n\n\n\n\nimport numpy as np\n\nP_mean = np.array([ret_mean(p) for p in P])\n\nP_accum = np.zeros(N+1)\n\nP_accum[1:] = P_mean.cumsum()\n\n\n\nans = 0\n\n# print(P_accum)\n\nfor i in range(N - K + 1):\n\n    j = i + K\n\n    ans = max(ans, P_accum[j] - P_accum[i])\n\nprint(ans)\n", "generated_code": "import sys\n\nread = sys.stdin.readline\n\n\n\n\n\ndef read_ints():\n\n    return list(map(int, read().split()))\n\n\n\n\n\ndef read_a_int():\n\n    return int(read())\n\n\n\n\n\ndef read_matrix(H):\n\n    '''\n\n    H is number of rows\n\n    '''\n\n    return [list(map(int, read().split())) for _ in range(H)]\n\n\n\n\n\ndef read_map(H):\n\n    '''\n\n    H is number of rows\n\n    文字列で与えられた盤面を読み取る用\n\n    '''\n\n    return [read()[:-1] for _ in range(H)]\n\n\n\n\n\ndef read_tuple(H):\n\n    '''\n\n    H is number of rows\n\n    '''\n\n    ret = []\n\n    for _ in range(H):\n\n        ret.append(tuple(map(int, read().split())))\n\n    return ret\n\n\n\n\n\ndef read_col(H, n_cols):\n\n    '''\n\n    H is number of rows\n\n    n_cols is number of cols\n\n\n\n    A列、B列が与えられるようなとき\n\n    '''\n\n    ret = [[] for _ in range(n_cols)]\n\n    for _ in range(H):\n\n        tmp = list(map(int, read().split()))\n\n        for col in range(n_cols):\n\n            ret[col].append(tmp[col])\n\n\n\n    return ret\n\n\n\n\n\nN, K = read_ints()\n\nP = read_ints()\n\n\n\n\n\ndef ret_mean(X):\n\n    return (X + 1) / 2\n\n\n\n\n\n\n\nclass cumsum1d:\n\n    def __init__(self, ls: list):\n\n        '''\n\n        1次元リストを受け取る\n\n        '''\n\n        from itertools import accumulate\n\n        self.ls_accum = [0] + list(accumulate(ls))\n\n\n\n    def total(self, i, j):\n\n        # もとの配列lsにおける[i,j)の中合計\n\n        return self.ls_accum[j] - self.ls_accum[i]\n\n      \n\nP_mean = [ret_mean(p) for p in P]\n\nP_accum = cumsum1d(P_mean)\n\n\n\nans = 0\n\n# print(P_accum)\n\nfor i in range(N - K + 1):\n\n    j = i + K\n\n    ans = max(ans, P_accum.total(i,j))\n\nprint(ans)\n", "score": 1.0, "codebleu": 0.8474133660024165, "crystalbleu": 0.7401668573263896, "codebertscore": 0.94, "codescore": 0.9924261569976807, "surfaceSim": 0.8972121341593676, "abs_surfaceSim_minus_score": 0.10278786584063238}
{"golden_code": "import numpy as np\n\nk,n = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\nb = np.zeros(n)\n\nfor i in range(0,n-1):\n\n  b[i] = a[i+1] -a[i]\n\n  \n\nb[n-1] = k - a[n-1] + a[0]\n\nans = k - max(b)\n\nprint((int(ans)))", "generated_code": "k,n = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\nb = [0 for i in range(n)]\n\nfor i in range(0,n-1):\n\n  b[i] = a[i+1] -a[i]\n\n\n\nb[n-1] = k - a[n-1] + a[0]\n\nans = k - max(b)\n\nprint((int(ans)))", "score": 1.0, "codebleu": 0.72214700756213, "crystalbleu": 0.8076589700572653, "codebertscore": 0.95, "codescore": 0.641279935836792, "surfaceSim": 0.8361233480176211, "abs_surfaceSim_minus_score": 0.16387665198237888}
{"golden_code": "import sys\n\nimport numpy as np\n\n\n\nn = int(sys.stdin.readline().rstrip())\n\nx = []\n\ny = []\n\nfor i in range(n):\n\n    a = int(sys.stdin.readline().rstrip())\n\n    xy = [sys.stdin.readline().split() for _ in range(a)]\n\n    if not xy:\n\n        x.append(None)\n\n        y.append(None)\n\n        continue\n\n    xi, yi = np.array(xy, np.int64).T\n\n    x.append(xi-1)\n\n    y.append(yi)\n\n\n\ndef main():\n\n\n\n    ans = 0\n\n    for comb in range(2 ** n):\n\n        cnt = 0\n\n        for i in range(n):\n\n            if not comb >> i & 1:\n\n                continue\n\n            if x[i] is None:\n\n                cnt += 1\n\n                continue\n\n            if np.count_nonzero(comb >> x[i] & 1 ^ y[i]):\n\n                break\n\n            cnt += 1\n\n        else:\n\n            ans = max(ans, cnt)\n\n    return ans\n\n                \n\nif __name__ == '__main__':\n\n    ans = main()\n\n    print(ans)", "generated_code": "import sys\n\n\n\nn = int(sys.stdin.readline().rstrip())\n\nxy = [[] for _ in range(n)]\n\nfor i in range(n):\n\n    a = int(sys.stdin.readline().rstrip())\n\n    for j in range(a):\n\n        x, y = list(map(int, sys.stdin.readline().split()))\n\n        xy[i].append((x-1, y))\n\n\n\ndef main():\n\n    ans = 0\n\n    for comb in range(2 ** n):\n\n        cnt = 0\n\n        for i in range(n):\n\n            if comb >> i & 1 ^ 1:\n\n                continue\n\n            for x, y in xy[i]:\n\n                if comb >> x & 1 ^ y:\n\n                    break\n\n            else:\n\n                cnt += 1\n\n                continue\n\n            break\n\n        else:\n\n            ans = max(ans, cnt)\n\n    return ans\n\n                \n\nif __name__ == '__main__':\n\n    ans = main()\n\n    print(ans)", "score": 1.0, "codebleu": 0.5163224150671805, "crystalbleu": 0.5609972771934018, "codebertscore": 0.9, "codescore": 0.2028692215681076, "surfaceSim": 0.8333073857267406, "abs_surfaceSim_minus_score": 0.16669261427325943}
{"golden_code": "from collections import deque\n\nn,*t=list(map(int,open(0).read().split()))\n\ncon=[[] for _ in range(n)]\n\ndist_f_k=[0]*n\n\n\n\nfor a,b,c in zip(t[:3*n-3:3],t[1::3],t[2::3]):\n\n\tcon[a-1].append((b-1,c))\n\n\tcon[b-1].append((a-1,c))\n\n\n\nk=t[3*n-2]\n\nque=deque([k-1])\n\nwhile que:\n\n\tcur=que.popleft()\n\n\tfor nxt,dd in con[cur]:\n\n\t\tif dist_f_k[nxt]==0 and nxt!=k-1:\n\n\t\t\tque.append(nxt)\n\n\t\t\tdist_f_k[nxt]=dist_f_k[cur]+dd\n\n\n\nfor x,y in zip(t[3*n-1::2],t[3*n::2]):\n\n\tprint((dist_f_k[x-1]+dist_f_k[y-1]))", "generated_code": "def solve():\n\n\tfrom collections import deque\n\n\tn,*t=list(map(int,open(0).read().split()))\n\n\tcon=[[] for _ in range(n)]\n\n\tdist_f_k=[0]*n\n\n\tl1,l2=t[:3*n-3],t[3*n-1:]\n\n\n\n\tfor a,b,c in zip(*[iter(l1)]*3):\n\n\t\tcon[a-1].append((b-1,c))\n\n\t\tcon[b-1].append((a-1,c))\n\n\n\n\tk=t[3*n-2]\n\n\tque=deque([k-1])\n\n\twhile que:\n\n\t\tcur=que.popleft()\n\n\t\tfor nxt,dd in con[cur]:\n\n\t\t\tif dist_f_k[nxt]==0 and nxt!=k-1:\n\n\t\t\t\tque.append(nxt)\n\n\t\t\t\tdist_f_k[nxt]=dist_f_k[cur]+dd\n\n\n\n\tfor x,y in zip(*[iter(l2)]*2):\n\n\t\tprint((dist_f_k[x-1]+dist_f_k[y-1]))\n\n\t\t\n\nif __name__==\"__main__\":\n\n\tsolve()", "score": 1.0, "codebleu": 0.6899689682700345, "crystalbleu": 0.7562784898350462, "codebertscore": 0.95, "codescore": 0.19063718616962433, "surfaceSim": 0.8770053475935828, "abs_surfaceSim_minus_score": 0.12299465240641716}
{"golden_code": "import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\nN = int(readline())\n\nS = read().split()\n\n\n\nS = sorted(S)\n\nls = [[] for i in range(N + 1)]\n\nmax_num = 0\n\nleft = 0\n\nright = 0\n\nwhile right < N:\n\n    while right < N and S[left] == S[right]:\n\n        right += 1\n\n    if (right  - left) >= max_num:\n\n        ls[right - left].append(S[left].decode())\n\n        max_num = right - left\n\n    left = right\n\n    \n\nprint(('\\n'.join(ls[max_num])))\n", "generated_code": "from collections import Counter\n\n\n\nimport sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\nN = int(readline())\n\nS = read().split()\n\n\n\nres = []\n\nc = Counter(S)\n\nmax_num = c.most_common(1)[0][1]\n\nfor i, j in list(c.items()):\n\n    if j == max_num:\n\n        res.append(i)\n\n        \n\nres.sort()\n\n\n\n        \n\nprint(('\\n'.join(list([x.decode() for x in res]))))\n", "score": 1.0, "codebleu": 0.3220499377044138, "crystalbleu": 0.32804613121326287, "codebertscore": 0.85, "codescore": 0.5310718417167664, "surfaceSim": 0.6030785970302099, "abs_surfaceSim_minus_score": 0.39692140296979006}
{"golden_code": "from fractions import gcd\n\nn, m = list(map(int, input().split()))\n\na = [int(i) // 2 for i in input().split()]\n\nx = 1\n\nfor i in range(n):\n\n    x *= a[i] // gcd(x, a[i])\n\nfor i in a:\n\n    if x // i % 2 == 0:\n\n        print((0))\n\n        exit()\n\nprint(((m // x + 1) // 2))", "generated_code": "from math import gcd, ceil\n\nn, m = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\na = [i // 2 for i in a]\n\nl = 1\n\nfor i in a:\n\n    l *= i // gcd(l, i)\n\nfor i in a:\n\n    if l // i % 2 == 0:\n\n        print((0))\n\n        exit()\n\nprint((ceil((m // l) / 2)))", "score": 1.0, "codebleu": 0.5087864953528614, "crystalbleu": 0.5383805654439339, "codebertscore": 0.93, "codescore": 0.8984456062316895, "surfaceSim": 0.8081723027375202, "abs_surfaceSim_minus_score": 0.19182769726247983}
{"golden_code": "from math import floor, sqrt\n\nfrom collections import Counter\n\n\n\nMOD = 10 ** 9 + 7\n\n\n\n# xを素因数分解する\n\ndef getPrimeFactor(x):\n\n    ans = []\n\n    for d in range(2, floor(sqrt(x)) + 1):\n\n        while x % d == 0:\n\n            ans.append(d)\n\n            x //= d\n\n\n\n    if x != 1:\n\n        ans.append(x)\n\n\n\n    return ans\n\n\n\n# xのn乗（二分累乗法）\n\ndef power(x, n):\n\n    ans = 1\n\n    while n:\n\n        if n % 2 == 1:\n\n            ans = (ans * x) % MOD\n\n        x = (x * x) % MOD\n\n        n //= 2\n\n    return ans\n\n\n\n\n\nN, M = list(map(int, input().split()))\n\n\n\nPFs = getPrimeFactor(M)\n\ncnt = Counter(PFs)\n\n\n\nN2 = N\n\nif len(cnt):\n\n    N2 += max(cnt.values())\n\n\n\n# facts[x]: xの階乗\n\nfacts = [1] + [0] * N2\n\nfor x in range(1, N2 + 1):\n\n    facts[x] = (facts[x - 1] * x) % MOD\n\n\n\n# invFs[x]: xの階乗の逆元\n\ninvFs = [0] * N2 + [power(facts[N2], MOD - 2)]\n\nfor x in reversed(list(range(N2))):\n\n    invFs[x] = (invFs[x + 1] * (x + 1)) % MOD\n\n\n\ndef comb(n, k):\n\n    return ((facts[n] * invFs[k]) % MOD * invFs[n - k]) % MOD\n\n\n\n\n\nans = 1\n\nfor num in list(cnt.values()):\n\n    ans = (ans * comb(N + num - 1, num)) % MOD\n\nprint(ans)\n", "generated_code": "from math import floor, sqrt\n\nfrom collections import Counter\n\n\n\nMOD = 10 ** 9 + 7\n\n\n\n# xを素因数分解する\n\ndef getPrimeFactor(x):\n\n    ans = []\n\n    for d in range(2, floor(sqrt(x)) + 1):\n\n        while x % d == 0:\n\n            ans.append(d)\n\n            x //= d\n\n    if x != 1:\n\n        ans.append(x)\n\n    return ans\n\n\n\ndef comb(n, k):\n\n    k = min(k, n - k)\n\n    ans = 1\n\n    for i in range(n, n - k, -1):\n\n        ans *= i\n\n    for i in range(1, k + 1):\n\n        ans //= i \n\n    return ans\n\n\n\n\n\nN, M = list(map(int, input().split()))\n\n\n\nPFs = getPrimeFactor(M)\n\ncnt = Counter(PFs)\n\n\n\nans = 1\n\nfor num in list(cnt.values()):\n\n    ans *= comb(N + num - 1, num)\n\nprint((ans % MOD))\n", "score": 1.0, "codebleu": 0.4402052513109228, "crystalbleu": 0.38525969984631075, "codebertscore": 0.9, "codescore": 0.7780061960220337, "surfaceSim": 0.7838077827108906, "abs_surfaceSim_minus_score": 0.21619221728910942}
{"golden_code": "def main():\n\n\tn, ma, mb, *L = list(map(int, open(0).read().split()))\n\n\tM = 1<<30\n\n\tdp = [[M] * 420 for _ in range(420)]\n\n\tdp[0][0] = 0\n\n\tfor a, b, c in zip(*[iter(L)] * 3):\n\n\t\tfor i in range(400, -1, -1):\n\n\t\t\tfor j in range(400, -1, -1):\n\n\t\t\t\tt = dp[i][j] + c\n\n\t\t\t\tif dp[i + a][j + b] > t:\n\n\t\t\t\t\tdp[i + a][j + b] = t\n\n\tans = M\n\n\t_ma, _mb = ma, mb\n\n\twhile _ma < 410 > _mb:\n\n\t\tans = min(ans, dp[_ma][_mb])\n\n\t\t_ma += ma\n\n\t\t_mb += mb\n\n\tprint((ans if ans < M else -1))\n\n\n\nif __name__==\"__main__\":\n\n\tmain()", "generated_code": "def main():\n\n\tn, ma, mb, *L = list(map(int, open(0).read().split()))\n\n\tM = 1 << 30\n\n\tdp = [[M] * 420 for _ in range(420)]\n\n\tdp[0][0] = 0\n\n\tua = ub = 15\n\n\tfor a, b, c in zip(*[iter(L)] * 3):\n\n\t\tfor i in range(ua, -1, -1):\n\n\t\t\tfor j in range(ub, -1, -1):\n\n\t\t\t\tt = dp[i][j] + c\n\n\t\t\t\tif dp[i + a][j + b] > t:\n\n\t\t\t\t\tdp[i + a][j + b] = t\n\n\t\t\t\t\tif ua < i + a:\n\n\t\t\t\t\t\tua = i + a\n\n\t\t\t\t\tif ub < j + b:\n\n\t\t\t\t\t\tub = j + b\n\n\tans = M\n\n\t_ma, _mb = ma, mb\n\n\twhile _ma < 410 > _mb:\n\n\t\tans = min(ans, dp[_ma][_mb])\n\n\t\t_ma += ma\n\n\t\t_mb += mb\n\n\tprint((ans if ans < M else -1))\n\n\n\n\n\nif __name__ == \"__main__\":\n\n\tmain()\n", "score": 1.0, "codebleu": 0.7950137941783344, "crystalbleu": 0.8238017274344019, "codebertscore": 0.95, "codescore": 0.035567380487918854, "surfaceSim": 0.9590301003344481, "abs_surfaceSim_minus_score": 0.04096989966555187}
{"golden_code": "n_str = eval(input())\n\nn_int = int(n_str)\n\n# 1 ~ 50000\n\n# 桁数が奇数= 1桁, 3桁, 5桁\n\n# 1 ~ 9, 100 ~ 999,10000 ~ 99999の90909個しかないので全探索いけるか?\n\nexs_list = []\n\nfor i in range(1, 100000):\n\n    if len(str(i)) % 2 == 1:\n\n        exs_list.append(i)\n\n\n\nexs = {i: i for i in exs_list}\n\n\n\nn_s = []\n\nans = 0\n\nfor i in range(1, n_int + 1):\n\n    if len(str(i)) % 2 == 0:\n\n        continue\n\n    if i in exs:\n\n        ans += 1\n\n\n\nprint(ans)\n\n\n\n\n\n\n\n\n\n\n", "generated_code": "def digit_sum(n):\n\n    # 各桁の和を求める\n\n    # 計算量: O(logN)\n\n    ans = 0\n\n    while n > 0:\n\n        ans += 1\n\n        n //= 10\n\n    return ans\n\n\n\nn = int(eval(input()))\n\ncnt = 0\n\n\n\nfor i in range(1, n+1):\n\n    cnt += digit_sum(i) % 2\n\n\n\nprint(cnt)\n", "score": 1.0, "codebleu": 0.1753498778239344, "crystalbleu": 0.0970353088210335, "codebertscore": 0.75, "codescore": 0.9305989742279053, "surfaceSim": 0.5524121741945929, "abs_surfaceSim_minus_score": 0.4475878258054071}
{"golden_code": "def check(x, y):\n\n    for a, b in zip(x, y):\n\n        if a != b and b != -1:\n\n            return False\n\n    else:\n\n        return True\n\n\n\n\n\nn = int(eval(input()))\n\nremarks = []\n\ncnt_max = 0\n\nfor _ in range(n):\n\n    a = int(eval(input()))\n\n    x = [tuple(map(int, input().split())) for i in range(a)]\n\n    r = [-1] * n\n\n    for i, j in x:\n\n        r[i - 1] = j\n\n    remarks.append(r)\n\nfor r in range(2 ** n):\n\n    r = list(bin(r)[2:].zfill(n))\n\n    r = [int(i) for i in r[:]]\n\n    cnt = 0\n\n    for i in range(n):\n\n        if r[i] == 1:\n\n            flag = check(r, remarks[i])\n\n            cnt += 1\n\n            if not flag:\n\n                cnt = 0\n\n                break\n\n    cnt_max = max(cnt, cnt_max)\n\nprint(cnt_max)", "generated_code": "import numpy as np\n\nimport itertools\n\n\n\nn = int(eval(input()))\n\ninfo = []\n\nfor i in range(n):\n\n    a = int(eval(input()))\n\n    for _ in range(a):\n\n        x, y = list(map(int, input().split()))\n\n        info.append((i, x - 1, y))\n\n\n\na = np.array(list(itertools.product([0, 1], repeat=n)), dtype=np.bool)\n\nfor i, x, y in info:\n\n    bl = (~a[:, i]) | (a[:, x] == bool(y))\n\n    a = a[bl]\n\n\n\nans = a.sum(axis=1).max()\n\nprint(ans)", "score": 1.0, "codebleu": 0.22038203731062928, "crystalbleu": 0.17875729279043265, "codebertscore": 0.76, "codescore": 0.9738474488258362, "surfaceSim": 0.5214470284237726, "abs_surfaceSim_minus_score": 0.47855297157622745}
{"golden_code": "A, B, C, X, Y = list(map(int, input().split()))\n\n\n\nans = 5000 * 2 * 10 ** 5\n\nfor i in range(10 ** 5 + 1):\n\n    s = i * 2 * C + max(0, X - i) * A + max(0, Y - i) * B\n\n    ans = min(ans, s)\n\n\n\nprint(ans)", "generated_code": "A, B, C, X, Y = list(map(int, input().split()))\n\n\n\nif X > Y:\n\n    v = A\n\nelse:\n\n    v = B\n\n\n\nans = min(A*X+B*Y, C*max(X, Y)*2, C*min(X,Y)*2+(max(X,Y)-min(X,Y))*v)\n\n\n\nprint(ans)", "score": 1.0, "codebleu": 0.3077067099016239, "crystalbleu": 0.0, "codebertscore": 0.83, "codescore": 0.8821836709976196, "surfaceSim": 0.6942916993977482, "abs_surfaceSim_minus_score": 0.30570830060225185}
{"golden_code": "from collections import Counter\n\nS = input()[::-1]\n\n\n\nmemo = [0]\n\nd = 0\n\nmod = 2019\n\n\n\nfor s in S:\n\n    tmp = int(s) * pow(10, d, mod) % mod\n\n    tmp = memo[-1] + tmp\n\n    memo.append(tmp % mod)\n\n    d += 1\n\n\n\nc = Counter(memo)\n\nans = sum(v * (v - 1) // 2 for v in list(c.values()))\n\nprint(ans)", "generated_code": "from collections import defaultdict\n\nS = eval(input())\n\nN = len(S)\n\n\n\nmemo = defaultdict(int)\n\nmemo[0] += 1\n\n\n\nmod = 2019\n\nd = 1\n\nval = 0\n\n\n\nfor s in S[::-1]:\n\n    s = int(s)\n\n    val += s * d\n\n    val %= mod\n\n    memo[val] += 1\n\n    d *= 10\n\n    d %= mod\n\n\n\nprint((sum(v * (v - 1) // 2 for v in list(memo.values()))))", "score": 1.0, "codebleu": 0.34349502763023315, "crystalbleu": 0.3175034705469694, "codebertscore": 0.89, "codescore": 0.9777215123176575, "surfaceSim": 0.7582110412299091, "abs_surfaceSim_minus_score": 0.24178895877009088}
{"golden_code": "import numpy as np\n\nn = int(eval(input()))\n\nal = list(map(int,input().split()))\n\n\n\nfor i in range(n):\n\n    al[i] -= i + 1\n\n\n\nmed = np.median(np.array(al))\n\n\n\nans = 0\n\nfor a in al:\n\n    ans += abs(a-med)\n\nprint((int(ans)))", "generated_code": "import statistics\n\nn = int(eval(input()))\n\nal = list(map(int,input().split()))\n\n\n\nfor i in range(n):\n\n    al[i] -= i + 1\n\n\n\nmedian = statistics.median(al)\n\n\n\nans = 0\n\nfor a in al:\n\n    ans += abs(median - a)\n\n\n\nprint((int(ans)))\n", "score": 1.0, "codebleu": 0.7506519606924393, "crystalbleu": 0.0, "codebertscore": 0.95, "codescore": 0.8712629675865173, "surfaceSim": 0.9235807860262009, "abs_surfaceSim_minus_score": 0.07641921397379914}
{"golden_code": "from collections import deque\n\nfrom copy import deepcopy, copy\n\ndy = [-1, 0, 0, 1]\n\ndx = [0, -1, 1, 0]\n\nN = 3\n\ndef g(i, j, a):\n\n    t = a // (10 ** j) % 10\n\n    return a - t * (10 ** j) + t * (10 ** i)\n\ndef MAIN():\n\n    m = {8:{7, 5}, 7:{8, 6, 4}, 6:{7, 3}, 5:{8, 4, 2}, 4:{7, 5, 3, 1}, 3:{6, 4, 0}, 2:{5, 1}, 1:{4, 2, 0}, 0:{3, 1}}\n\n    MAP = \"\".join(input().replace(\" \", \"\") for _ in range(N))\n\n    start = 8 - MAP.find(\"0\")\n\n    MAP = int(MAP)\n\n    goal = ('1', '2', '3', '4', '5', '6', '7', '8', '0')\n\n    goal = 123456780\n\n    dp = deque([(0, start, MAP)])\n\n    LOG = {MAP}\n\n    while dp:\n\n        cnt, yx, M = dp.popleft()\n\n        if M == goal:\n\n            print(cnt)\n\n            break\n\n        cnt += 1\n\n        for nyx in m[yx]:\n\n            CM = g(yx, nyx, M)\n\n            if not CM in LOG:\n\n                dp.append((cnt, nyx, CM))\n\n                LOG.add(CM)\n\nMAIN()\n\n\n", "generated_code": "from collections import deque\n\nfrom copy import deepcopy, copy\n\nN = 3\n\ndef g(i, j, a):\n\n    if i > j:\n\n        i, j = j, i\n\n    return a[:i] + a[j] + a[i + 1:j] + a[i] + a[j + 1:]\n\ndef MAIN():\n\n    m = {8:{7, 5}, 7:{8, 6, 4}, 6:{7, 3}, 5:{8, 4, 2}, 4:{7, 5, 3, 1}, 3:{6, 4, 0}, 2:{5, 1}, 1:{4, 2, 0}, 0:{3, 1}}\n\n    MAP = \"\".join(input().replace(\" \", \"\") for _ in range(N))\n\n    start = MAP.find(\"0\")\n\n    goal = \"123456780\"\n\n    dp = deque([(0, start, MAP)])\n\n    LOG = {MAP}\n\n    while dp:\n\n        cnt, yx, M = dp.popleft()\n\n        if M == goal:\n\n            print(cnt)\n\n            break\n\n        cnt += 1\n\n        for nyx in m[yx]:\n\n            CM = g(yx, nyx, M)\n\n            if not CM in LOG:\n\n                dp.append((cnt, nyx, CM))\n\n                LOG.add(CM)\n\nMAIN()\n\n\n", "score": 1.0, "codebleu": 0.5672325252782172, "crystalbleu": 0.6851795231762776, "codebertscore": 0.93, "codescore": 0.41503313183784485, "surfaceSim": 0.8346603600052556, "abs_surfaceSim_minus_score": 0.16533963999474444}
{"golden_code": "import numpy as np\n\nN = int(eval(input()))\n\nV = np.array([int(i) for i in input().split(\" \")])\n\nC = np.array([int(i) for i in input().split(\" \")])\n\n\n\nvc = V-C\n\n\n\nval = 0\n\n\n\nfor i in range(N):\n\n    if vc[i]>0:\n\n        val+=vc[i]\n\nprint(val)", "generated_code": "N = int(eval(input()))\n\nV = [int(i) for i in input().split(\" \")]\n\nC = [int(i) for i in input().split(\" \")]\n\n\n\nval = 0\n\n\n\nfor i in range(N):\n\n    vc=V[i]-C[i]\n\n    if vc>0:\n\n        val+=vc\n\nprint(val)", "score": 1.0, "codebleu": 0.43250002834832124, "crystalbleu": 0.6282057680818627, "codebertscore": 0.94, "codescore": 0.8156114816665649, "surfaceSim": 0.833605072463768, "abs_surfaceSim_minus_score": 0.16639492753623197}
{"golden_code": "n = int(eval(input()))\n\nimport math\n\nm = int(math.sqrt(n))+1\n\nanss = []\n\nfor x in range(1, m+1):\n\n  y = n//x\n\n  z = n%x\n\n  if z == 0:\n\n    anss.append(abs(x-1)+abs(y-1))\n\nprint((min(anss)))\n", "generated_code": "n = int(eval(input()))\n\ndef make_divisors(n):\n\n    divisors = []\n\n    for i in range(1, int(n**0.5)+1):\n\n        if n % i == 0:\n\n            divisors.append(i)\n\n            if i != n // i:\n\n                divisors.append(n//i)\n\n\n\n    #divisors.sort(reverse=True)\n\n    return divisors\n\n\n\nl = make_divisors(n)\n\nmin_ = float('inf')\n\nfor i in range(len(l)):\n\n    min_ = min(min_, l[i]-1+n//l[i]-1)\n\nprint(min_)\n", "score": 1.0, "codebleu": 0.27441939244193186, "crystalbleu": 0.17501093795230596, "codebertscore": 0.79, "codescore": 0.1638031005859375, "surfaceSim": 0.6045469912102772, "abs_surfaceSim_minus_score": 0.3954530087897228}
{"golden_code": "# ABC 155 C\n\nfrom collections import Counter\n\nimport numpy as np\n\nN = int(eval(input()))\n\nS = [str(eval(input())) for i in range(N)]\n\nS = np.array(S)\n\n\n\ncount = Counter(S)\n\nmax_num = max(count.values())\n\nmax_list = [i for i,j in list(count.items()) if j==max_num]\n\n\n\nmax_list.sort()\n\nprint(('\\n'.join(max_list)))", "generated_code": "import sys\n\nfrom collections import Counter\n\nN = int(sys.stdin.readline())\n\nS = sys.stdin.read().split()\n\n\n\ncount = Counter(S)\n\nmax_num = max(count.values())\n\nmax_list = [i for i,j in list(count.items()) if j==max_num]\n\n \n\nmax_list.sort()\n\nprint(('\\n'.join(max_list)))", "score": 1.0, "codebleu": 0.5017047235416202, "crystalbleu": 0.0, "codebertscore": 0.9, "codescore": 0.6616674661636353, "surfaceSim": 0.8846153846153846, "abs_surfaceSim_minus_score": 0.11538461538461542}
{"golden_code": "def main():\n\n    x = int(eval(input()))\n\n    for a in range(-120, 121):\n\n        for b in range(-120, 121):\n\n            if a**5 - b**5 == x:\n\n                print((a, b))\n\n                return\n\n\n\nif __name__ == \"__main__\":\n\n    main()", "generated_code": "def main():\n\n    x = int(eval(input()))\n\n    for i in range(-120, 121):\n\n        for j in range(-120, 121):\n\n            if i**5 - j**5 == x:\n\n                print((i, j))\n\n                return\n\n\n\nif __name__ == \"__main__\":\n\n    main()", "score": 1.0, "codebleu": 0.7574111814061091, "crystalbleu": 0.7256017249452535, "codebertscore": 0.98, "codescore": 0.029822055250406265, "surfaceSim": 0.9873949579831933, "abs_surfaceSim_minus_score": 0.012605042016806678}
{"golden_code": "n,m,k=list(map(int,input().split()))\n\nmod=10**9+7\n\nf=[1]\n\nfor i in range(2*10**5+7):f+=[f[-1]*(i+1)%mod]\n\ndef comb(a,b):return f[a]*pow(f[b],mod-2,mod)*pow(f[a-b],mod-2,mod)%mod\n\nans=0\n\nfor i in range(1,n):\n\n  ans+=(i*(n-i)*m**2)*(comb(n*m-2,k-2))\n\n  ans%=mod\n\nfor i in range(1,m):\n\n  ans+=(i*(m-i)*n**2)*(comb(n*m-2,k-2))\n\n  ans%=mod\n\nprint(ans)", "generated_code": "n,m,k=list(map(int,input().split()))\n\n\n\nmod = 10**9+7\n\nf = [1]\n\nfor i in range(n*m):\n\n  f += [f[-1]*(i+1) % mod]\n\ndef comb(a, b):\n\n  return f[a]*pow(f[b], mod-2, mod)*pow(f[a-b], mod-2, mod) % mod\n\n\n\nans=0\n\nfor dist in range(1,n):\n\n  c=n-dist\n\n  p=(c*m*m)%mod\n\n  ans+=p*dist\n\nfor dist in range(1,m):\n\n  c=m-dist\n\n  p=(c*n*n)%mod\n\n  ans+=p*dist\n\nans%=mod\n\nprint((ans*comb(n*m-2,k-2)%mod))", "score": 1.0, "codebleu": 0.3629923337355096, "crystalbleu": 0.6369429828703653, "codebertscore": 0.93, "codescore": 0.6852530837059021, "surfaceSim": 0.8656330749354005, "abs_surfaceSim_minus_score": 0.13436692506459946}
{"golden_code": "def getN():\n\n    return int(eval(input()))\n\ndef getNM():\n\n    return list(map(int, input().split()))\n\ndef getList():\n\n    return list(map(int, input().split()))\n\ndef getArray(intn):\n\n    return [int(eval(input())) for i in range(intn)]\n\ndef input():\n\n    return sys.stdin.readline().rstrip()\n\ndef rand_N(ran1, ran2):\n\n    return random.randint(ran1, ran2)\n\ndef rand_List(ran1, ran2, rantime):\n\n    return [random.randint(ran1, ran2) for i in range(rantime)]\n\ndef rand_ints_nodup(ran1, ran2, rantime):\n\n  ns = []\n\n  while len(ns) < rantime:\n\n    n = random.randint(ran1, ran2)\n\n    if not n in ns:\n\n      ns.append(n)\n\n  return sorted(ns)\n\n\n\ndef rand_query(ran1, ran2, rantime):\n\n  r_query = []\n\n  while len(r_query) < rantime:\n\n    n_q = rand_ints_nodup(ran1, ran2, 2)\n\n    if not n_q in r_query:\n\n      r_query.append(n_q)\n\n  return sorted(r_query)\n\n\n\nfrom collections import defaultdict, deque, Counter\n\nfrom sys import exit\n\nfrom decimal import *\n\nfrom heapq import heapify, heappop, heappush\n\nimport math\n\nimport random\n\nimport string\n\nfrom copy import deepcopy\n\nfrom itertools import combinations, permutations, product\n\nfrom operator import mul, itemgetter\n\nfrom functools import reduce\n\nfrom bisect import bisect_left, bisect_right\n\n\n\nimport sys\n\nsys.setrecursionlimit(1000000000)\n\nmod = 10 ** 9 + 7\n\n\n\n#############\n\n# Main Code #\n\n#############\n\n\n\nS = getN()\n\n\n\n# 逆元事前処理ver\n\n# nが小さい場合に\n\nlim = 10 ** 5 + 1\n\nfact = [1, 1]\n\nfactinv = [1, 1]\n\ninv = [0, 1]\n\n\n\nfor i in range(2, lim + 1):\n\n    fact.append((fact[-1] * i) % mod)\n\n    inv.append((-inv[mod % i] * (mod // i)) % mod)\n\n    # 累計\n\n    factinv.append((factinv[-1] * inv[-1]) % mod)\n\n\n\ndef cmb(n, r):\n\n    if (r < 0) or (n < r):\n\n        return 0\n\n    r = min(r, n - r)\n\n    return fact[n] * factinv[r] * factinv[n - r] % mod\n\n\n\nans = 0\n\n# 長さNの時最低でも3 * N使う\n\n# 残りは分配する\n\nfor i in range(1, 2001):\n\n    s = S - (3 * i)\n\n    if s < 0:\n\n        break\n\n    # sをN個に分配する通りがいくつあるか\n\n    # 重複組み合わせ\n\n    # 仕切りの数はi - 1個\n\n    ans += cmb(s + i - 1, i - 1)\n\nprint((ans % mod))", "generated_code": "def getN():\n\n    return int(eval(input()))\n\ndef getNM():\n\n    return list(map(int, input().split()))\n\ndef getList():\n\n    return list(map(int, input().split()))\n\ndef getArray(intn):\n\n    return [int(eval(input())) for i in range(intn)]\n\ndef input():\n\n    return sys.stdin.readline().rstrip()\n\ndef rand_N(ran1, ran2):\n\n    return random.randint(ran1, ran2)\n\ndef rand_List(ran1, ran2, rantime):\n\n    return [random.randint(ran1, ran2) for i in range(rantime)]\n\ndef rand_ints_nodup(ran1, ran2, rantime):\n\n  ns = []\n\n  while len(ns) < rantime:\n\n    n = random.randint(ran1, ran2)\n\n    if not n in ns:\n\n      ns.append(n)\n\n  return sorted(ns)\n\n\n\ndef rand_query(ran1, ran2, rantime):\n\n  r_query = []\n\n  while len(r_query) < rantime:\n\n    n_q = rand_ints_nodup(ran1, ran2, 2)\n\n    if not n_q in r_query:\n\n      r_query.append(n_q)\n\n  return sorted(r_query)\n\n\n\nfrom collections import defaultdict, deque, Counter\n\nfrom sys import exit\n\nfrom decimal import *\n\nfrom heapq import heapify, heappop, heappush\n\nimport math\n\nimport random\n\nimport string\n\nfrom copy import deepcopy\n\nfrom itertools import combinations, permutations, product\n\nfrom operator import mul, itemgetter\n\nfrom functools import reduce\n\nfrom bisect import bisect_left, bisect_right\n\n\n\nimport sys\n\nsys.setrecursionlimit(1000000000)\n\nmod = 10 ** 9 + 7\n\n\n\n#############\n\n# Main Code #\n\n#############\n\n\n\nN = getN()\n\nlogk = N.bit_length()\n\n\n\n# 漸化式にできるなら行列計算に落とし込める\n\n# A[n] = A[n - 1] + A[n - 3]なので\n\n# [a2, a1, a0] = [0, 0, 1]\n\n# [[1, 1, 0], [0, 0, 1], [1, 0, 0]]のN乗をすれば\n\n# [an+2, an+1, an] が出る\n\n\n\ndp = [[[0, 0, 0] for i in range(3)] for i in range(logk)]\n\ndp[0] = [\n\n[1, 1, 0],\n\n[0, 0, 1],\n\n[1, 0, 0]\n\n]\n\n\n\n# 行列掛け算 O(n3)かかる\n\ndef array_cnt(ar1, ar2):\n\n    h = len(ar1)\n\n    w = len(ar2[0])\n\n    row = ar1\n\n    col = []\n\n    for j in range(w):\n\n        opt = []\n\n        for i in range(len(ar2)):\n\n            opt.append(ar2[i][j])\n\n        col.append(opt)\n\n\n\n    res = [[[0, 0] for i in range(w)] for i in range(h)]\n\n    for i in range(h):\n\n        for j in range(w):\n\n            cnt = 0\n\n            for x, y in zip(row[i], col[j]):\n\n                cnt += x * y\n\n            res[i][j] = cnt\n\n            res[i][j] %= mod\n\n    return res\n\n\n\nfor i in range(1, logk):\n\n    dp[i] = array_cnt(dp[i - 1], dp[i - 1])\n\n\n\nans = [[0, 0, 1]]\n\nfor i in range(logk):\n\n    if N & (1 << i):\n\n        ans = array_cnt(ans, dp[i])\n\nprint((ans[0][2] % mod))", "score": 1.0, "codebleu": 0.6488810906366307, "crystalbleu": 0.5605711222318236, "codebertscore": 0.88, "codescore": 0.9938300251960754, "surfaceSim": 0.8233885679537853, "abs_surfaceSim_minus_score": 0.17661143204621466}
{"golden_code": "k = int(eval(input()))\n\ncount = 1\n\nn = 0\n\nif k % 2 == 0 or k % 5 == 0:\n\n    print((-1))\n\nelse:\n\n  while 1:\n\n      n = (n * 10 + 7) % k  \n\n      if n == 0:\n\n        break \n\n      count += 1\n\n  print(count)", "generated_code": "def main(h):\n\n  count = 1\n\n  n = 0\n\n  for i in range (k):\n\n    n = (n * 10 + 7) % k  \n\n    if n == 0: \n\n      print(count)\n\n      return 0\n\n    count += 1\n\n  print((-1))\n\n  \n\nif __name__ == '__main__':\n\n  k = int(eval(input()))\n\n  main(k)", "score": 1.0, "codebleu": 0.47065797982054347, "crystalbleu": 0.0, "codebertscore": 0.87, "codescore": 0.04875434562563896, "surfaceSim": 0.604341736694678, "abs_surfaceSim_minus_score": 0.39565826330532206}
{"golden_code": "import numpy as np\n\nn=int(eval(input()))\n\ns=np.argsort(np.array(list(map(int,input().split()))))+1\n\nprint((*s))", "generated_code": "n=int(eval(input()))\n\na=list(map(int,input().split()))\n\nl=sorted([[inx+1,j] for inx,j in enumerate(a)],key=lambda x:x[1])\n\nans=[i for i,j in l]\n\nprint((*ans))", "score": 1.0, "codebleu": 0.29989200862076526, "crystalbleu": 0.0, "codebertscore": 0.79, "codescore": 0.31349703669548035, "surfaceSim": 0.4240506329113924, "abs_surfaceSim_minus_score": 0.5759493670886076}
{"golden_code": "N=int(eval(input()))\n\na=list(map(int,input().split()))\n\nfor i in range(N):\n\n  for j in range(1,31):\n\n    if a[i]%(2**j)!=0:\n\n      a[i]=j-1\n\n      break\n\nprint((sum(a)))", "generated_code": "import sys\n\ninput = sys.stdin.buffer.readline\n\n\n\nN = int(eval(input()))\n\nA = list(map(int, input().split()))\n\n\n\ndef f(n):\n\n  res = 0\n\n  while n % 2 == 0:\n\n    n //= 2\n\n    res += 1\n\n  return res\n\n\n\nanswer = 0\n\nfor a in A:\n\n  answer += f(a)\n\n\n\nprint(answer)", "score": 1.0, "codebleu": 0.21636832910672954, "crystalbleu": 0.0, "codebertscore": 0.8, "codescore": 0.15798790752887726, "surfaceSim": 0.47139616935483875, "abs_surfaceSim_minus_score": 0.5286038306451613}
{"golden_code": "a,b,c=list(map(int,input().split()))\n\ne=(a-b)|(b-c)\n\nprint((bool(e|(a|b|c)%2)*(e^~-e).bit_length()-1))", "generated_code": "a,b,c=list(map(int,input().split()))\n\ne=(a-b)|(b-c)\n\nprint((bool(e|b%2)*(e^~-e).bit_length()-1))", "score": 1.0, "codebleu": 0.5053730590517129, "crystalbleu": 0.0, "codebertscore": 0.98, "codescore": 0.9938141107559204, "surfaceSim": 0.9705882352941176, "abs_surfaceSim_minus_score": 0.02941176470588236}
{"golden_code": "import math\n\nprint((math.factorial(int(eval(input())))%(10**9+7)))", "generated_code": "ans=1\n\nn=int(eval(input()))\n\nfor i in range(1,n+1):\n\n  ans*=i\n\n  ans=ans%(10**9+7)\n\nprint(ans)", "score": 1.0, "codebleu": 0.2375, "crystalbleu": 0.0, "codebertscore": 0.81, "codescore": 0.807098925113678, "surfaceSim": 0.4479905437352246, "abs_surfaceSim_minus_score": 0.5520094562647754}
{"golden_code": "N, K = list(map(int, input().split()))\n\nS = eval(input())\n\nnums = []\n\nnow = 1\n\ncnt = 0\n\nfor i in range(N):\n\n    if S[i] == str(now):\n\n        cnt += 1\n\n    else:\n\n        nums.append(cnt)\n\n        now = 1 - now\n\n        cnt = 1\n\nif cnt != 0:\n\n    nums.append(cnt)\n\nif len(nums) % 2 == 0:\n\n    nums.append(0)\n\n\n\nadd = 2 * K + 1\n\nans = 0\n\nleft = 0\n\nright = 0\n\ntmp = 0\n\nfor i in range(0, len(nums), 2):\n\n\n\n    next_left = i\n\n    next_right = min(i + add, len(nums))\n\n\n\n    while next_left > left:\n\n        tmp -= nums[left]\n\n        left += 1\n\n\n\n    while next_right > right:\n\n        tmp += nums[right]\n\n        right += 1\n\n\n\n    ans = max(ans, tmp)\n\nprint(ans)", "generated_code": "N, K = list(map(int, input().split()))\n\nS = eval(input())\n\nnums = []\n\nnow = 1\n\ncnt = 0\n\nfor i in range(N):\n\n    if S[i] == str(now):\n\n        cnt += 1\n\n    else:\n\n        nums.append(cnt)\n\n        now = 1 - now\n\n        cnt = 1\n\nif cnt != 0:\n\n    nums.append(cnt)\n\nif len(nums) % 2 == 0:\n\n    nums.append(0)\n\n\n\ncsum = [0] * (len(nums) + 1)\n\nfor i in range(len(nums)):\n\n    csum[i + 1] = csum[i] + nums[i]\n\n\n\nadd = 2 * K + 1\n\nans = 0\n\ntmp = 0\n\nfor i in range(0, len(nums), 2):\n\n    left = i\n\n    right = min(i + add, len(nums))\n\n    tmp = csum[right] - csum[left]\n\n    ans = max(ans, tmp)\n\nprint(ans)", "score": 1.0, "codebleu": 0.7612905630082394, "crystalbleu": 0.7639714372116043, "codebertscore": 0.94, "codescore": 0.9352235198020935, "surfaceSim": 0.8500058363487802, "abs_surfaceSim_minus_score": 0.14999416365121976}
{"golden_code": "n,q = list(map(int,input().split()))\n\nqueue = []\n\nfor i in range(n):\n\n\tname,time = input().split()\n\n\tqueue.append([name, int(time)])\n\n\n\nt = 0\n\ni = 0\n\nwhile queue:\n\n\ti %= len(queue)\n\n\tp = queue[i]\n\n\tt += min(q, p[1])\n\n\tif p[1] > q:\n\n\t\tp[1] -= q\n\n\t\ti += 1\n\n\telse:\n\n\t\tprint((p[0], t))\n\n\t\tqueue.pop(i)\n", "generated_code": "from collections import deque\n\n\n\nn,q = list(map(int,input().split()))\n\nqueue = deque()\n\nfor i in range(n):\n\n\tname,time = input().split()\n\n\tqueue.append((name, int(time)))\n\n\n\nt = 0\n\nwhile queue:\n\n\tname,time = queue.popleft()\n\n\tt += min(q, time)\n\n\tif time > q:\n\n\t\tqueue.append((name, time-q))\n\n\telse:\n\n\t\tprint((name,t))\n", "score": 1.0, "codebleu": 0.3592226858178984, "crystalbleu": 0.4866945477173892, "codebertscore": 0.89, "codescore": 0.24734993278980255, "surfaceSim": 0.6870440251572327, "abs_surfaceSim_minus_score": 0.31295597484276727}
{"golden_code": "# -*- coding: utf-8 -*-\n\n\n\n\"\"\"\n\n参考：http://drken1215.hatenablog.com/entry/2018/09/23/224100\n\n　　　http://tutuz.hateblo.jp/entry/2018/09/24/121248\n\n・素因数分解と重複組み合わせ\n\n・毎回階乗やると死ぬから階乗と逆元のテーブル作る(忘れてた)\n\n\"\"\"\n\n\n\nfrom collections import defaultdict\n\nfrom math import sqrt\n\n\n\nMOD = 10 ** 9 + 7\n\n\n\ndef fact_prime(num):\n\n    d = defaultdict(int)\n\n    # 終点はルート切り捨て+1\n\n    end = int(sqrt(num)) + 1\n\n    for i in range(2, end+1):\n\n        cnt = 0\n\n        # 素因数分解：小さい方から割れるだけ割って素数をカウント\n\n        while num % i == 0:\n\n            num //= i\n\n            d[i] += 1\n\n        # 1まで来たら終了\n\n        if num == 1:\n\n            break\n\n    # 最後までそのまま来たやつはnumが素数(ただし1^1は1^0なので数に入れない)\n\n    if num != 1:\n\n        d[num] += 1\n\n    return d\n\n\n\n# とりあえずv+N-1が収まればいいはず\n\nMAX = 10 ** 5 * 2\n\n# 予め組み合わせ計算に必要な階乗と逆元のテーブルを作っておく\n\nfactorial = [1] * (MAX)\n\nfactorial[0] = factorial[1] = 1\n\nfor i in range(2, MAX):\n\n    factorial[i] = factorial[i-1] * i % MOD\n\n\n\ninverse = [1] * (MAX)\n\n# powに第三引数入れると冪乗のmod付計算を高速にやってくれる\n\ninverse[MAX-1] = pow(factorial[MAX-1], MOD-2, MOD)\n\nfor i in range(MAX-2, 0, -1):\n\n    # 最後から戻っていくこのループならH+W回powするより処理が速い\n\n    inverse[i] = inverse[i+1] * (i+1) % MOD\n\n\n\n# 組み合わせの数\n\ndef nCr(n, r):\n\n    # 10C7 = 10C3\n\n    r = min(r, n-r)\n\n    # 分子の計算\n\n    numerator = factorial[n]\n\n    # 分母の計算\n\n    denominator = inverse[r] * inverse[n-r] % MOD\n\n    return numerator * denominator % MOD\n\n\n\nN, M = list(map(int, input().split()))\n\n\n\n# d = fact_prime(M)\n\n# print(d)\n\nans = 1\n\nfor k, v in list(fact_prime(M).items()):\n\n    # 重複組み合わせ\n\n    # v個のkとN-1個の仕切りから、v個を並べる(v+N-1個のマスからv個を選び出す組み合わせ)\n\n    ans = (ans * nCr(v+N-1, v)) % MOD\n\nprint(ans)\n", "generated_code": "# -*- coding: utf-8 -*-\n\n\n\nimport sys\n\n\n\ndef input(): return sys.stdin.readline().strip()\n\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\n\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\n\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\n\ndef ceil(x, y=1): return int(-(-x // y))\n\ndef INT(): return int(eval(input()))\n\ndef MAP(): return list(map(int, input().split()))\n\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\n\ndef Yes(): print('Yes')\n\ndef No(): print('No')\n\ndef YES(): print('YES')\n\ndef NO(): print('NO')\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = float('inf')\n\nMOD = 10 ** 9 + 7\n\n\n\ndef factorize(num: int) -> dict:\n\n    \"\"\" 素因数分解 \"\"\"\n\n    from math import sqrt\n\n    from collections import Counter\n\n\n\n    d = Counter()\n\n    # 終点はルート切り捨て+1\n\n    for i in range(2, int(sqrt(num))+1):\n\n        # 素因数分解：小さい方から割れるだけ割って素数をカウント\n\n        while num % i == 0:\n\n            num //= i\n\n            d[i] += 1\n\n        # 1まで分解したら終了\n\n        if num == 1:\n\n            break\n\n    # 最後に残ったnumは素数(ただし1^1は1^0なので数に入れない)\n\n    if num != 1:\n\n        d[num] += 1\n\n    return d\n\n\n\nclass FactInvMOD:\n\n    \"\"\" 階乗たくさん使う時用のテーブル準備 \"\"\"\n\n\n\n    def __init__(self, MAX, MOD):\n\n        \"\"\" MAX：階乗に使う数値の最大以上まで作る \"\"\"\n\n        \n\n        MAX += 1\n\n        self.MAX = MAX\n\n        self.MOD = MOD\n\n        # 階乗テーブル\n\n        factorial = [1] * MAX\n\n        factorial[0] = factorial[1] = 1\n\n        for i in range(2, MAX):\n\n            factorial[i] = factorial[i-1] * i % MOD\n\n        # 階乗の逆元テーブル\n\n        inverse = [1] * MAX\n\n        # powに第三引数入れると冪乗のmod付計算を高速にやってくれる\n\n        inverse[MAX-1] = pow(factorial[MAX-1], MOD-2, MOD)\n\n        for i in range(MAX-2, 0, -1):\n\n            # 最後から戻っていくこのループならMAX回powするより処理が速い\n\n            inverse[i] = inverse[i+1] * (i+1) % MOD\n\n        self.fact = factorial\n\n        self.inv = inverse\n\n    \n\n    def nCr(self, n, r):\n\n        \"\"\" 組み合わせの数 (必要な階乗と逆元のテーブルを事前に作っておく) \"\"\"\n\n\n\n        if n < r: return 0\n\n        # 10C7 = 10C3\n\n        r = min(r, n-r)\n\n        # 分子の計算\n\n        numerator = self.fact[n]\n\n        # 分母の計算\n\n        denominator = self.inv[r] * self.inv[n-r] % self.MOD\n\n        return numerator * denominator % self.MOD\n\n\n\n    def nPr(self, n, r):\n\n        \"\"\" 順列 \"\"\"\n\n\n\n        if n < r: return 0\n\n        return self.fact[n] * self.inv[n-r] % self.MOD\n\n\n\n    def nHr(self, n, r):\n\n        \"\"\" 重複組み合わせ \"\"\"\n\n\n\n        # r個選ぶところにN-1個の仕切りを入れる\n\n        return self.nCr(r+n-1, r)\n\n\n\nN, M = MAP()\n\n\n\nd = factorize(M)\n\n\n\n# 例外処理\n\nif not d:\n\n    print((1))\n\n    exit()\n\n\n\nMAX = N + max(d.values())\n\nfim = FactInvMOD(MAX, MOD)\n\nans = 1\n\nfor k, v in list(d.items()):\n\n    ans *= fim.nHr(N, v)\n\n    ans %= MOD\n\nprint(ans)\n", "score": 1.0, "codebleu": 0.5046519438641522, "crystalbleu": 0.3117517070708187, "codebertscore": 0.87, "codescore": 0.9858631491661072, "surfaceSim": 0.7098920744223003, "abs_surfaceSim_minus_score": 0.2901079255776997}
{"golden_code": "N,K=list(map(int,input().split()))\n\na = [[0]*N]*K\n\na = [[0 for n in range(N)] for k in range(K)]\n\n\n\nfor k in range(K):\n\n    d=int(eval(input()))\n\n    have_k=list(map(int,input().split()))\n\n    for h in have_k:\n\n        a[k][h-1]=1\n\n\n\nan=[0]*N\n\nfor k in range(K):\n\n  for n in range(N):\n\n    an[n] = an[n]+a[k][n]\n\n\n\nresult=0\n\nfor i in an:\n\n  if i == 0:\n\n    result+=1\n\n\n\nprint(result)", "generated_code": "N,K=list(map(int,input().split()))\n\na = [[0 for n in range(N)] for k in range(K)]\n\n\n\nfor k in range(K):\n\n    d=int(eval(input()))\n\n    have_k=list(map(int,input().split()))\n\n    for h in have_k:\n\n        a[k][h-1]=1\n\n\n\nan=[0]*N\n\nfor k in range(K):\n\n  for n in range(N):\n\n    an[n] = an[n]+a[k][n]\n\n\n\nresult=0\n\nfor i in an:\n\n  if i == 0:\n\n    result+=1\n\n\n\nprint(result)", "score": 1.0, "codebleu": 0.8863828213577403, "crystalbleu": 0.9306282113199866, "codebertscore": 0.99, "codescore": 0.9937833547592163, "surfaceSim": 0.9843342036553524, "abs_surfaceSim_minus_score": 0.015665796344647598}
{"golden_code": "import sys\n\ninput = sys.stdin.readline\n\nsys.setrecursionlimit(10**7)\n\nINF = 10**10\n\nMOD = 10**9 + 7\n\nX = int(eval(input()))\n\nfor i in range(1000):\n\n    for j in range(-1000,1000):\n\n        #print (i**5 - j**5)\n\n        if i**5 - j**5 == X:\n\n            print((i,j))\n\n            exit()\n\n   ", "generated_code": "import sys\n\ninput = sys.stdin.readline\n\nsys.setrecursionlimit(10**7)\n\nINF = 10**10\n\nMOD = 10**9 + 7\n\nX = int(eval(input()))\n\nMAX_X = 10**9\n\nn = 0\n\nwhile(1):\n\n    n+=1\n\n    if n**5 - (n-1)**5 > MAX_X:\n\n        break\n\nfor i in range(n):\n\n    for j in range(-n+1,n-1):\n\n        if i**5 - j**5 == X:\n\n            print((i,j))\n\n            exit()\n\n   ", "score": 1.0, "codebleu": 0.6920880411136854, "crystalbleu": 0.5821554665807663, "codebertscore": 0.92, "codescore": 0.838956356048584, "surfaceSim": 0.8190306803023566, "abs_surfaceSim_minus_score": 0.1809693196976434}
{"golden_code": "import sys\n(n, m, *abcdef) = list(map(int, sys.stdin.buffer.read().split()))\nver_lines = []\nhor_lines = []\nx_list = set()\ny_list = set()\nn3 = n * 3\nfor (a, b, c) in zip(abcdef[0:n3:3], abcdef[1:n3:3], abcdef[2:n3:3]):\n    y_list.add(a)\n    y_list.add(b)\n    x_list.add(c)\n    ver_lines.append((a, b, c))\nfor (d, e, f) in zip(abcdef[n3 + 0::3], abcdef[n3 + 1::3], abcdef[n3 + 2::3]):\n    y_list.add(d)\n    x_list.add(e)\n    x_list.add(f)\n    hor_lines.append((d, e, f))\nx_list.add(0)\ny_list.add(0)\nx_list = sorted(x_list)\ny_list = sorted(y_list)\nx_dict = {x: i for (i, x) in enumerate(x_list, start=1)}\ny_dict = {y: i for (i, y) in enumerate(y_list, start=1)}\nrow_real = len(x_list)\ncol_real = len(y_list)\nrow = row_real + 2\ncol = col_real + 2\nbanned_up_ij = [[0] * row for _ in range(col)]\nbanned_down_ij = [[0] * row for _ in range(col)]\nbanned_left_ij = [[0] * col for _ in range(row)]\nbanned_right_ij = [[0] * col for _ in range(row)]\nfor (a, b, c) in ver_lines:\n    if a > b:\n        (a, b) = (b, a)\n    ai = y_dict[a]\n    bi = y_dict[b]\n    j = x_dict[c]\n    banned_left_ij[j][ai] += 1\n    banned_left_ij[j][bi] -= 1\n    banned_right_ij[j - 1][ai] += 1\n    banned_right_ij[j - 1][bi] -= 1\nfor (d, e, f) in hor_lines:\n    if e > f:\n        (e, f) = (f, e)\n    i = y_dict[d]\n    ej = x_dict[e]\n    fj = x_dict[f]\n    banned_up_ij[i][ej] += 1\n    banned_up_ij[i][fj] -= 1\n    banned_down_ij[i - 1][ej] += 1\n    banned_down_ij[i - 1][fj] -= 1\nbanned_up = [0] * (row * col)\nbanned_down = [0] * (row * col)\nbanned_left = [0] * (row * col)\nbanned_right = [0] * (row * col)\nfor i in range(col):\n    ru = banned_up_ij[i]\n    rd = banned_down_ij[i]\n    ri = row * i\n    banned_up[ri] = ru[0]\n    banned_down[ri] = rd[0]\n    for j in range(1, row):\n        banned_up[ri + j] = banned_up[(ri + j) - 1] + ru[j]\n        banned_down[ri + j] = banned_down[(ri + j) - 1] + rd[j]\nfor j in range(row):\n    rl = banned_left_ij[j]\n    rr = banned_right_ij[j]\n    banned_left[j] = rl[0]\n    banned_right[j] = rr[0]\n    for i in range(1, col):\n        ri0 = (i - 1) * row\n        ri1 = i * row\n        banned_left[ri1 + j] = banned_left[ri0 + j] + rl[i]\n        banned_right[ri1 + j] = banned_right[ri0 + j] + rr[i]\ns = (row * y_dict[0]) + x_dict[0]\nenable = (([-1] * row) + ((([-1] + ([0] * (row - 2))) + [-1]) * (col - 2))) + ([-1] * row)\nq = [s]\nmoves = [(-row, banned_up), (-1, banned_left), (1, banned_right), (row, banned_down)]\nwhile q:\n    c = q.pop()\n    if enable[c] == 1:\n        continue\n    elif enable[c] == -1:\n        print('INF')\n        exit()\n    enable[c] = 1\n    for (dc, banned) in moves:\n        if banned[c]:\n            continue\n        nc = c + dc\n        if enable[nc] == 1:\n            continue\n        q.append(nc)\nans = 0\nfor i in range(col):\n    ri = i * row\n    for j in range(row):\n        if enable[ri + j] != 1:\n            continue\n        t = y_list[i - 1]\n        b = y_list[i]\n        l = x_list[j - 1]\n        r = x_list[j]\n        ans += (b - t) * (r - l)\nprint(ans)", "generated_code": "import sys\n(n, m, *abcdef) = list(map(int, sys.stdin.buffer.read().split()))\nver_lines = []\nhor_lines = []\nx_list = set()\ny_list = set()\nn3 = n * 3\nfor (a, b, c) in zip(abcdef[0:n3:3], abcdef[1:n3:3], abcdef[2:n3:3]):\n    y_list.add(a)\n    y_list.add(b)\n    x_list.add(c)\n    ver_lines.append((a, b, c))\nfor (d, e, f) in zip(abcdef[n3 + 0::3], abcdef[n3 + 1::3], abcdef[n3 + 2::3]):\n    y_list.add(d)\n    x_list.add(e)\n    x_list.add(f)\n    hor_lines.append((d, e, f))\n    break\nx_list.add(0)\ny_list.add(0)\nx_list = sorted(x_list)\ny_list = sorted(y_list)\nx_dict = {x: i for (i, x) in enumerate(x_list, start=1)}\ny_dict = {y: i for (i, y) in enumerate(y_list, start=1)}\nrow_real = len(x_list)\ncol_real = len(y_list)\nrow = row_real + 2\ncol = col_real + 2\nbanned_up_ij = [[0] * row for _ in range(col)]\nbanned_down_ij = [[0] * row for _ in range(col)]\nbanned_left_ij = [[0] * col for _ in range(row)]\nbanned_right_ij = [[0] * col for _ in range(row)]\nfor (a, b, c) in ver_lines:\n    if a > b:\n        (a, b) = (b, a)\n    ai = y_dict[a]\n    bi = y_dict[b]\n    j = x_dict[c]\n    banned_left_ij[j][ai] += 1\n    banned_left_ij[j][bi] -= 1\n    banned_right_ij[j - 1][ai] += 1\n    banned_right_ij[j - 1][bi] -= 1\nfor (d, e, f) in hor_lines:\n    if e > f:\n        (e, f) = (f, e)\n    i = y_dict[d]\n    ej = x_dict[e]\n    fj = x_dict[f]\n    banned_up_ij[i][ej] += 1\n    banned_up_ij[i][fj] -= 1\n    banned_down_ij[i - 1][ej] += 1\n    banned_down_ij[i - 1][fj] -= 1\nbanned_up = [0] * (row * col)\nbanned_down = [0] * (row * col)\nbanned_left = [0] * (row * col)\nbanned_right = [0] * (row * col)\nfor i in range(col):\n    ru = banned_up_ij[i]\n    rd = banned_down_ij[i]\n    ri = row * i\n    banned_up[ri] = ru[0]\n    banned_down[ri] = rd[0]\n    for j in range(1, row):\n        banned_up[ri + j] = banned_up[(ri + j) - 1] + ru[j]\n        banned_down[ri + j] = banned_down[(ri + j) - 1] + rd[j]\nfor j in range(row):\n    rl = banned_left_ij[j]\n    rr = banned_right_ij[j]\n    banned_left[j] = rl[0]\n    banned_right[j] = rr[0]\n    for i in range(1, col):\n        ri0 = (i - 1) * row\n        ri1 = i * row\n        banned_left[ri1 + j] = banned_left[ri0 + j] + rl[i]\n        banned_right[ri1 + j] = banned_right[ri0 + j] + rr[i]\ns = (row * y_dict[0]) + x_dict[0]\nenable = (([-1] * row) + ((([-1] + ([0] * (row - 2))) + [-1]) * (col - 2))) + ([-1] * row)\nq = [s]\nmoves = [(-row, banned_up), (-1, banned_left), (1, banned_right), (row, banned_down)]\nwhile q:\n    c = q.pop()\n    if enable[c] == 1:\n        continueelif enable[c] == -1:\n        print('INF')\n        exit()\n    enable[c] = 1\n    for (dc, banned) in moves:\n        if banned[c]:\n            continue\n        nc = c + dc\n        if enable[nc] == 1:\n            continue\n        q.append(nc)\nans = 0\nfor i in range(col):\n    ri = i * row\n    for j in range(row):\n        if enable[ri + j] != 1:\n            continue\n        t = y_list[i - 1]\n        b = y_list[i]\n        l = x_list[j - 1]\n        r = x_list[j]\n        ans += (b - t) * (r - l)\nprint(ans)", "score": 0.0, "codebleu": 0.9851352000059876, "crystalbleu": 0.9931122044344988, "codebertscore": 0.99, "codescore": 0.9721808433532715, "surfaceSim": 0.4988309953239813, "abs_surfaceSim_minus_score": 0.4988309953239813}
{"golden_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "generated_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += __n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "score": 0.0, "codebleu": 0.9884911427299241, "crystalbleu": 0.9936989720107794, "codebertscore": 1.0, "codescore": 0.9825030565261841, "surfaceSim": 0.9984634296250768, "abs_surfaceSim_minus_score": 0.9984634296250768}
{"golden_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "generated_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    pass\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "score": 0.0, "codebleu": 0.9780570304333551, "crystalbleu": 0.9834585796983772, "codebertscore": 1.0, "codescore": 0.9935705661773682, "surfaceSim": 0.9832999801050919, "abs_surfaceSim_minus_score": 0.9832999801050919}
{"golden_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "generated_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if not (n != 0):\n        n = 1000 - n\n    print(n)", "score": 0.0, "codebleu": 0.9717262939382055, "crystalbleu": 0.9702929169171512, "codebertscore": 1.0, "codescore": 0.9938230514526367, "surfaceSim": 0.9788490495012234, "abs_surfaceSim_minus_score": 0.9788490495012234}
{"golden_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "generated_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] // self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "score": 0.0, "codebleu": 0.9945883912637858, "crystalbleu": 0.9915876446894797, "codebertscore": 1.0, "codescore": 0.9935625791549683, "surfaceSim": 0.986723282799925, "abs_surfaceSim_minus_score": 0.986723282799925}
{"golden_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "generated_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    pass\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "score": 0.0, "codebleu": 0.9841415039131673, "crystalbleu": 0.978676729853253, "codebertscore": 1.0, "codescore": 0.9935815334320068, "surfaceSim": 0.9830717738065982, "abs_surfaceSim_minus_score": 0.9830717738065982}
{"golden_code": "def cmb(n, r):\n    import math\n    if n < r:\n        return 0\n    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\ndef solve(S):\n    mod = (10 ** 9) + 7\n    ans = 0\n    for i in range(1, (S // 3) + 1):\n        tama = i + (S - (i * 3))\n        tama -= 2\n        bo = i - 1\n        ans += cmb(tama + 1, bo)\n        ans %= mod\n    print(ans)", "generated_code": "def cmb(n, r):\n    import math\n    if n < r:\n        return 0\n    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\ndef solve(S):\n    mod = (10 ** 9) + 7\n    ans = 0\n    for i in range(1, (S // 3) + 1):\n        break\n    \n    \n    \n    \n    print(ans)", "score": 0.0, "codebleu": 0.5637432642560896, "crystalbleu": 0.6061736528563952, "codebertscore": 0.94, "codescore": 0.6142134666442871, "surfaceSim": 0.8660961614562723, "abs_surfaceSim_minus_score": 0.8660961614562723}
{"golden_code": "import sys\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\ndef solve():\n    inf = (10 ** 14) + 10\n    def dfs(v: 'vertex_index, 0-indexed') -> None:\n        for (c, t) in e[v]:\n            if d[t] != inf:\n                continue\n            d[t] = d[v] + c\n            dfs(t)\n    n = int(eval(input()))\n    e = tuple((set() for _ in range(n)))\n    for _ in range(n - 1):\n        (a, b, c) = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        e[a].add((c, b))\n        e[b].add((c, a))\n    (q, v) = list(map(int, input().split()))\n    v -= 1\n    d = [inf] * n\n    d[v] = 0\n    dfs(v)\n    for _ in range(q):\n        (x, y) = list(map(int, input().split()))\n        x -= 1\n        y -= 1\n        print(d[x] + d[y])", "generated_code": "import sys\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\ndef solve():\n    inf = (10 ** 14) - 10\n    def dfs(v: 'vertex_index, 0-indexed') -> None:\n        for (c, t) in e[v]:\n            if d[t] != inf:\n                continue\n            d[t] = d[v] + c\n            dfs(t)\n    n = int(eval(input()))\n    e = tuple((set() for _ in range(n)))\n    for _ in range(n - 1):\n        (a, b, c) = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        e[a].add((c, b))\n        e[b].add((c, a))\n    (q, v) = list(map(int, input().split()))\n    v -= 1\n    d = [inf] * n\n    d[v] = 0\n    dfs(v)\n    for _ in range(q):\n        (x, y) = list(map(int, input().split()))\n        x -= 1\n        y -= 1\n        print(d[x] + d[y])", "score": 0.0, "codebleu": 0.9881398574370538, "crystalbleu": 0.9907582847077829, "codebertscore": 1.0, "codescore": 0.9938243627548218, "surfaceSim": 0.9993243243243244, "abs_surfaceSim_minus_score": 0.9993243243243244}
{"golden_code": "from collections import defaultdict\nfrom collections import deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\ndef I():\n    return int(sys.stdin.readline())\ndef LS():\n    return list(map(list, sys.stdin.readline().split()))\ndef S():\n    return list(sys.stdin.readline())[:-1]\ndef IR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = I()\n    return l\ndef LIR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = LI()\n    return l\ndef SR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = S()\n    return l\ndef LSR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = LS()\n    return l\nsys.setrecursionlimit(1000000)\nmod = 1000000007\ndef A():\n    return\ndef B():\n    return\ndef C():\n    return\ndef D():\n    return\ndef E():\n    return\ndef F():\n    (a, b, c, X, Y) = LI()\n    ans = float('inf')\n    for z in range(300001):\n        if z % 2 == 0:\n            m = c * z\n            x = z // 2\n            y = z // 2\n            m += a * max(0, X - x)\n            m += b * max(0, Y - y)\n            if m < ans:\n                ans = m\n    print(ans)\n    return\ndef G():\n    n = I()\n    x = LI()\n    f = [(i, x[i]) for i in range(n)]\n    f.sort(key=lambda x: (x[1]))\n    g = [(f[i][0], i) for i in range(n)]\n    g.sort(key=lambda x: (x[0]))\n    for i in range(n):\n        if g[i][1] < n // 2:\n            print(f[n // 2][1])else:print(f[(n // 2) - 1][1])\n    return\ndef H():\n    return\ndef I_():\n    return\ndef J():\n    return", "generated_code": "from collections import defaultdict\nfrom collections import deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\ndef I():\n    return int(sys.stdin.readline())\ndef LS():\n    return list(map(list, sys.stdin.readline().split()))\ndef S():\n    return list(sys.stdin.readline())[:-1]\ndef IR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = I()\n    return l\ndef LIR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = LI()\n    return l\ndef SR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = S()\n    return l\ndef LSR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = LS()\n    return l\nsys.setrecursionlimit(1000000)\nmod = 1000000007\ndef A():\n    return\ndef B():\n    return\ndef C():\n    return\ndef D():\n    return\ndef E():\n    return\ndef F():\n    (a, b, c, X, Y) = LI()\n    ans = float('inf')\n    for z in range(300001):\n        if z * 2 == 0:\n            m = c * z\n            x = z // 2\n            y = z // 2\n            m += a * max(0, X - x)\n            m += b * max(0, Y - y)\n            if m < ans:\n                ans = m\n    print(ans)\n    return\ndef G():\n    n = I()\n    x = LI()\n    f = [(i, x[i]) for i in range(n)]\n    f.sort(key=lambda x: (x[1]))\n    g = [(f[i][0], i) for i in range(n)]\n    g.sort(key=lambda x: (x[0]))\n    for i in range(n):\n        if g[i][1] < n // 2:\n            print(f[n // 2][1])else:print(f[(n // 2) - 1][1])\n    return\ndef H():\n    return\ndef I_():\n    return\ndef J():\n    return", "score": 0.0, "codebleu": 0.9950684650874879, "crystalbleu": 0.9932265613224579, "codebertscore": 1.0, "codescore": 0.9934325218200684, "surfaceSim": 0.49969097651421507, "abs_surfaceSim_minus_score": 0.49969097651421507}
{"golden_code": "import math, sys\nn = int(sys.stdin.readline())\na = tuple(map(int, sys.stdin.readline().split()))\ng = math.gcd(a[0], a[1])\nfor i in range(2, n):\n    g = math.gcd(g, a[i])\nM = max(a)\nacc = a[0]\nfor i in range(n):\n    acc = math.gcd(acc, a[i])\nif acc != 1:\n    print('not coprime')\n    exit()\nLIMIT = max(a)\nminPrime = [0] * (LIMIT + 1)\nminPrime[1] = 1\ndef make():\n    for i in range(2, LIMIT + 1):\n        if minPrime[i] == 0:\n            minPrime[i] = i\n            for j in range(i + i, LIMIT + 1, i):\n                if minPrime[j] == 0:\n                    minPrime[j] = i\nmake()\ndef factrial(N):\n    ret = []\n    while minPrime[N] != N:\n        ret.append(minPrime[N])\n        N = N // minPrime[N]\n    if N != 1:\n        ret.append(N)\n    return ret\njudge = set([])\npc = True\npairwise = True\np = set()\nfor e in a:\n    if not pairwise:\n        break\n    asf = set(factrial(e))\n    if judge & asf != set():\n        pc = False\n    judge |= asf\nif pc:\n    print('pairwise coprime')\nelif g == 1:\n    print('setwise coprime')\nelse:\n    print('not coprime')", "generated_code": "import math, sys\nn = int(sys.stdin.readline())\na = tuple(map(int, sys.stdin.readline().split()))\ng = math.gcd(a[0], a[1])\nfor i in range(2, n):\n    g = math.gcd(g, a[i])\n    break\nM = max(a)\nacc = a[0]\nfor i in range(n):\n    acc = math.gcd(acc, a[i])\nif acc != 1:\n    print('not coprime')\n    exit()\nLIMIT = max(a)\nminPrime = [0] * (LIMIT + 1)\nminPrime[1] = 1\ndef make():\n    for i in range(2, LIMIT + 1):\n        if minPrime[i] == 0:\n            minPrime[i] = i\n            for j in range(i + i, LIMIT + 1, i):\n                if minPrime[j] == 0:\n                    minPrime[j] = i\nmake()\ndef factrial(N):\n    ret = []\n    while minPrime[N] != N:\n        ret.append(minPrime[N])\n        N = N // minPrime[N]\n    if N != 1:\n        ret.append(N)\n    return ret\njudge = set([])\npc = True\npairwise = True\np = set()\nfor e in a:\n    if not pairwise:\n        break\n    asf = set(factrial(e))\n    if judge & asf != set():\n        pc = False\n    judge |= asf\nif pc:\n    print('pairwise coprime')elif g == 1:\n    print('setwise coprime')\nelse:\n    print('not coprime')", "score": 0.0, "codebleu": 0.9708477294868713, "crystalbleu": 0.9890192409220128, "codebertscore": 0.99, "codescore": 0.9937446713447571, "surfaceSim": 0.4967043314500942, "abs_surfaceSim_minus_score": 0.4967043314500942}
{"golden_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "generated_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) + ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "score": 0.0, "codebleu": 0.9890842515292805, "crystalbleu": 0.9834519784786802, "codebertscore": 1.0, "codescore": 0.9938415288925171, "surfaceSim": 0.9814788465186872, "abs_surfaceSim_minus_score": 0.9814788465186872}
{"golden_code": "import sys\n(n, m, *abcdef) = list(map(int, sys.stdin.buffer.read().split()))\nver_lines = []\nhor_lines = []\nx_list = set()\ny_list = set()\nn3 = n * 3\nfor (a, b, c) in zip(abcdef[0:n3:3], abcdef[1:n3:3], abcdef[2:n3:3]):\n    y_list.add(a)\n    y_list.add(b)\n    x_list.add(c)\n    ver_lines.append((a, b, c))\nfor (d, e, f) in zip(abcdef[n3 + 0::3], abcdef[n3 + 1::3], abcdef[n3 + 2::3]):\n    y_list.add(d)\n    x_list.add(e)\n    x_list.add(f)\n    hor_lines.append((d, e, f))\nx_list.add(0)\ny_list.add(0)\nx_list = sorted(x_list)\ny_list = sorted(y_list)\nx_dict = {x: i for (i, x) in enumerate(x_list, start=1)}\ny_dict = {y: i for (i, y) in enumerate(y_list, start=1)}\nrow_real = len(x_list)\ncol_real = len(y_list)\nrow = row_real + 2\ncol = col_real + 2\nbanned_up_ij = [[0] * row for _ in range(col)]\nbanned_down_ij = [[0] * row for _ in range(col)]\nbanned_left_ij = [[0] * col for _ in range(row)]\nbanned_right_ij = [[0] * col for _ in range(row)]\nfor (a, b, c) in ver_lines:\n    if a > b:\n        (a, b) = (b, a)\n    ai = y_dict[a]\n    bi = y_dict[b]\n    j = x_dict[c]\n    banned_left_ij[j][ai] += 1\n    banned_left_ij[j][bi] -= 1\n    banned_right_ij[j - 1][ai] += 1\n    banned_right_ij[j - 1][bi] -= 1\nfor (d, e, f) in hor_lines:\n    if e > f:\n        (e, f) = (f, e)\n    i = y_dict[d]\n    ej = x_dict[e]\n    fj = x_dict[f]\n    banned_up_ij[i][ej] += 1\n    banned_up_ij[i][fj] -= 1\n    banned_down_ij[i - 1][ej] += 1\n    banned_down_ij[i - 1][fj] -= 1\nbanned_up = [0] * (row * col)\nbanned_down = [0] * (row * col)\nbanned_left = [0] * (row * col)\nbanned_right = [0] * (row * col)\nfor i in range(col):\n    ru = banned_up_ij[i]\n    rd = banned_down_ij[i]\n    ri = row * i\n    banned_up[ri] = ru[0]\n    banned_down[ri] = rd[0]\n    for j in range(1, row):\n        banned_up[ri + j] = banned_up[(ri + j) - 1] + ru[j]\n        banned_down[ri + j] = banned_down[(ri + j) - 1] + rd[j]\nfor j in range(row):\n    rl = banned_left_ij[j]\n    rr = banned_right_ij[j]\n    banned_left[j] = rl[0]\n    banned_right[j] = rr[0]\n    for i in range(1, col):\n        ri0 = (i - 1) * row\n        ri1 = i * row\n        banned_left[ri1 + j] = banned_left[ri0 + j] + rl[i]\n        banned_right[ri1 + j] = banned_right[ri0 + j] + rr[i]\ns = (row * y_dict[0]) + x_dict[0]\nenable = (([-1] * row) + ((([-1] + ([0] * (row - 2))) + [-1]) * (col - 2))) + ([-1] * row)\nq = [s]\nmoves = [(-row, banned_up), (-1, banned_left), (1, banned_right), (row, banned_down)]\nwhile q:\n    c = q.pop()\n    if enable[c] == 1:\n        continue\n    elif enable[c] == -1:\n        print('INF')\n        exit()\n    enable[c] = 1\n    for (dc, banned) in moves:\n        if banned[c]:\n            continue\n        nc = c + dc\n        if enable[nc] == 1:\n            continue\n        q.append(nc)\nans = 0\nfor i in range(col):\n    ri = i * row\n    for j in range(row):\n        if enable[ri + j] != 1:\n            continue\n        t = y_list[i - 1]\n        b = y_list[i]\n        l = x_list[j - 1]\n        r = x_list[j]\n        ans += (b - t) * (r - l)\nprint(ans)", "generated_code": "import sys\n(n, m, *abcdef) = list(map(int, sys.stdin.buffer.read().split()))\nver_lines = []\nhor_lines = []\nx_list = set()\ny_list = set()\nn3 = n * 3\nfor (a, b, c) in zip(abcdef[0:n3:3], abcdef[1:n3:3], abcdef[2:n3:3]):\n    y_list.add(a)\n    y_list.add(b)\n    x_list.add(c)\n    ver_lines.append((a, b, c))\nfor (d, e, f) in zip(abcdef[n3 + 0::3], abcdef[n3 + 1::3], abcdef[n3 + 2::3]):\n    y_list.add(d)\n    x_list.add(e)\n    x_list.add(f)\n    hor_lines.append((d, e, f))\nx_list.add(0)\ny_list.add(0)\nx_list = sorted(x_list)\ny_list = sorted(y_list)\nx_dict = {x: i for (i, x) in enumerate(x_list, start=1)}\ny_dict = {y: i for (i, y) in enumerate(y_list, start=1)}\nrow_real = len(x_list)\ncol_real = len(y_list)\nrow = row_real + 2\ncol = col_real + 2\nbanned_up_ij = [[0] * row for _ in range(col)]\nbanned_down_ij = [[0] * row for _ in range(col)]\nbanned_left_ij = [[0] * col for _ in range(row)]\nbanned_right_ij = [[0] * col for _ in range(row)]\nfor (a, b, c) in ver_lines:\n    if a > b:\n        (a, b) = (b, a)\n    ai = y_dict[a]\n    bi = y_dict[b]\n    j = x_dict[c]\n    banned_left_ij[j][ai] += 1\n    banned_left_ij[j][bi] -= 1\n    banned_right_ij[j - 1][ai] += 1\n    banned_right_ij[j - 1][bi] -= 1\n    break\nfor (d, e, f) in hor_lines:\n    if e > f:\n        (e, f) = (f, e)\n    i = y_dict[d]\n    ej = x_dict[e]\n    fj = x_dict[f]\n    banned_up_ij[i][ej] += 1\n    banned_up_ij[i][fj] -= 1\n    banned_down_ij[i - 1][ej] += 1\n    banned_down_ij[i - 1][fj] -= 1\nbanned_up = [0] * (row * col)\nbanned_down = [0] * (row * col)\nbanned_left = [0] * (row * col)\nbanned_right = [0] * (row * col)\nfor i in range(col):\n    ru = banned_up_ij[i]\n    rd = banned_down_ij[i]\n    ri = row * i\n    banned_up[ri] = ru[0]\n    banned_down[ri] = rd[0]\n    for j in range(1, row):\n        banned_up[ri + j] = banned_up[(ri + j) - 1] + ru[j]\n        banned_down[ri + j] = banned_down[(ri + j) - 1] + rd[j]\nfor j in range(row):\n    rl = banned_left_ij[j]\n    rr = banned_right_ij[j]\n    banned_left[j] = rl[0]\n    banned_right[j] = rr[0]\n    for i in range(1, col):\n        ri0 = (i - 1) * row\n        ri1 = i * row\n        banned_left[ri1 + j] = banned_left[ri0 + j] + rl[i]\n        banned_right[ri1 + j] = banned_right[ri0 + j] + rr[i]\ns = (row * y_dict[0]) + x_dict[0]\nenable = (([-1] * row) + ((([-1] + ([0] * (row - 2))) + [-1]) * (col - 2))) + ([-1] * row)\nq = [s]\nmoves = [(-row, banned_up), (-1, banned_left), (1, banned_right), (row, banned_down)]\nwhile q:\n    c = q.pop()\n    if enable[c] == 1:\n        continueelif enable[c] == -1:\n        print('INF')\n        exit()\n    enable[c] = 1\n    for (dc, banned) in moves:\n        if banned[c]:\n            continue\n        nc = c + dc\n        if enable[nc] == 1:\n            continue\n        q.append(nc)\nans = 0\nfor i in range(col):\n    ri = i * row\n    for j in range(row):\n        if enable[ri + j] != 1:\n            continue\n        t = y_list[i - 1]\n        b = y_list[i]\n        l = x_list[j - 1]\n        r = x_list[j]\n        ans += (b - t) * (r - l)\nprint(ans)", "score": 0.0, "codebleu": 0.9856332079741151, "crystalbleu": 0.9931122044344988, "codebertscore": 1.0, "codescore": 0.9825831651687622, "surfaceSim": 0.4988309953239813, "abs_surfaceSim_minus_score": 0.4988309953239813}
{"golden_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "generated_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "score": 0.0, "codebleu": 0.9838233903573866, "crystalbleu": 0.9942139050865672, "codebertscore": 1.0, "codescore": 0.9935686588287354, "surfaceSim": 0.9988589685075309, "abs_surfaceSim_minus_score": 0.9988589685075309}
{"golden_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "generated_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    @staticmethod\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:print('NA')", "score": 0.0, "codebleu": 0.9895212352936913, "crystalbleu": 0.9944643274491598, "codebertscore": 0.99, "codescore": 0.9935433864593506, "surfaceSim": 0.9965846994535519, "abs_surfaceSim_minus_score": 0.9965846994535519}
{"golden_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "generated_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    @staticmethod\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "score": 0.0, "codebleu": 0.9933297651216333, "crystalbleu": 0.9932615708925326, "codebertscore": 0.99, "codescore": 0.9864442944526672, "surfaceSim": 0.9957446808510638, "abs_surfaceSim_minus_score": 0.9957446808510638}
{"golden_code": "def cmb(n, r):\n    import math\n    if n < r:\n        return 0\n    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\ndef solve(S):\n    mod = (10 ** 9) + 7\n    ans = 0\n    for i in range(1, (S // 3) + 1):\n        tama = i + (S - (i * 3))\n        tama -= 2\n        bo = i - 1\n        ans += cmb(tama + 1, bo)\n        ans %= mod\n    print(ans)", "generated_code": "def cmb(n, r):\n    import math\n    if n < r:\n        return 0\n    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\ndef solve(S):\n    mod = (10 ** 9) + 7\n    pass\n    for i in range(1, (S // 3) + 1):\n        tama = i + (S - (i * 3))\n        tama -= 2\n        bo = i - 1\n        ans += cmb(tama + 1, bo)\n        ans %= mod\n    print(ans)", "score": 0.0, "codebleu": 0.8454332159614995, "crystalbleu": 0.9384831828379085, "codebertscore": 0.99, "codescore": 0.9937566518783569, "surfaceSim": 0.976602690937871, "abs_surfaceSim_minus_score": 0.976602690937871}
{"golden_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "generated_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "score": 0.0, "codebleu": 0.9816359470073353, "crystalbleu": 0.9942145673215758, "codebertscore": 1.0, "codescore": 0.9936049580574036, "surfaceSim": 0.9988589685075309, "abs_surfaceSim_minus_score": 0.9988589685075309}
{"golden_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "generated_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 ** N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "score": 0.0, "codebleu": 0.9963221036285097, "crystalbleu": 0.9972445037560809, "codebertscore": 1.0, "codescore": 0.9855914115905762, "surfaceSim": 0.9997032640949555, "abs_surfaceSim_minus_score": 0.9997032640949555}
{"golden_code": "class Calc:\n    def __init__(self, max_value, mod):\n        fact = [-1] * (max_value + 1)\n        fact[0] = 1\n        fact[1] = 1\n        for x in range(2, max_value + 1):\n            fact[x] = (x * fact[x - 1]) % mod\n        invs = [1] * (max_value + 1)\n        invs[max_value] = pow(fact[max_value], mod - 2, mod)\n        for x in range(max_value - 1, 0, -1):\n            invs[x] = (invs[x + 1] * (x + 1)) % mod\n        self.fact = fact\n        self.invs = invs\n        self.mod = mod\n    def combination(self, n, r):\n        if n - r < r:\n            return self.combination(n, n - r)\n        if r < 0:\n            return 0\n        if r == 0:\n            return 1\n        if r == 1:\n            return n\n        return ((self.fact[n] * self.invs[r]) * self.invs[n - r]) % self.mod\ndef gen(n):\n    x = n\n    d = 2\n    cnt = 0\n    while x % d == 0:\n        x //= d\n        cnt += 1\n    yield cnt\n    d = 3\n    ma = d * d\n    while ma <= n:\n        cnt = 0\n        while x % d == 0:\n            x //= d\n            cnt += 1\n        yield cnt\n        ma += (d * 4) + 4\n        d += 2\n    if x > 1:\n        yield 1\ndef main():\n    MOD = (10 ** 9) + 7\n    (N, M) = list(map(int, input().split()))\n    cal = Calc(max_value=N + 30, mod=MOD)\n    ans = 1\n    for cnt in gen(M):\n        ans = (ans * cal.combination((N + cnt) - 1, cnt)) % MOD\n    print(ans)", "generated_code": "class Calc:\n    def __init__(self, max_value, mod):\n        fact = [-1] * (max_value + 1)\n        fact[0] = 1\n        fact[1] = 1\n        for x in range(2, max_value - 1):\n            fact[x] = (x * fact[x - 1]) % mod\n        invs = [1] * (max_value + 1)\n        invs[max_value] = pow(fact[max_value], mod - 2, mod)\n        for x in range(max_value - 1, 0, -1):\n            invs[x] = (invs[x + 1] * (x + 1)) % mod\n        self.fact = fact\n        self.invs = invs\n        self.mod = mod\n    def combination(self, n, r):\n        if n - r < r:\n            return self.combination(n, n - r)\n        if r < 0:\n            return 0\n        if r == 0:\n            return 1\n        if r == 1:\n            return n\n        return ((self.fact[n] * self.invs[r]) * self.invs[n - r]) % self.mod\ndef gen(n):\n    x = n\n    d = 2\n    cnt = 0\n    while x % d == 0:\n        x //= d\n        cnt += 1\n    yield cnt\n    d = 3\n    ma = d * d\n    while ma <= n:\n        cnt = 0\n        while x % d == 0:\n            x //= d\n            cnt += 1\n        yield cnt\n        ma += (d * 4) + 4\n        d += 2\n    if x > 1:\n        yield 1\ndef main():\n    MOD = (10 ** 9) + 7\n    (N, M) = list(map(int, input().split()))\n    cal = Calc(max_value=N + 30, mod=MOD)\n    ans = 1\n    for cnt in gen(M):\n        ans = (ans * cal.combination((N + cnt) - 1, cnt)) % MOD\n    print(ans)", "score": 0.0, "codebleu": 0.9945974577626977, "crystalbleu": 0.9947995807952579, "codebertscore": 1.0, "codescore": 0.9937528967857361, "surfaceSim": 0.9996293550778355, "abs_surfaceSim_minus_score": 0.9996293550778355}
{"golden_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "generated_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "score": 0.0, "codebleu": 1.0, "crystalbleu": 1.0, "codebertscore": 1.0, "codescore": 0.9938323497772217, "surfaceSim": 1.0, "abs_surfaceSim_minus_score": 1.0}
{"golden_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "generated_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] // self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "score": 0.0, "codebleu": 0.9945883912637858, "crystalbleu": 0.9915876446894797, "codebertscore": 1.0, "codescore": 0.9935270547866821, "surfaceSim": 0.986723282799925, "abs_surfaceSim_minus_score": 0.986723282799925}
{"golden_code": "import sys\n(n, m, *abcdef) = list(map(int, sys.stdin.buffer.read().split()))\nver_lines = []\nhor_lines = []\nx_list = set()\ny_list = set()\nn3 = n * 3\nfor (a, b, c) in zip(abcdef[0:n3:3], abcdef[1:n3:3], abcdef[2:n3:3]):\n    y_list.add(a)\n    y_list.add(b)\n    x_list.add(c)\n    ver_lines.append((a, b, c))\nfor (d, e, f) in zip(abcdef[n3 + 0::3], abcdef[n3 + 1::3], abcdef[n3 + 2::3]):\n    y_list.add(d)\n    x_list.add(e)\n    x_list.add(f)\n    hor_lines.append((d, e, f))\nx_list.add(0)\ny_list.add(0)\nx_list = sorted(x_list)\ny_list = sorted(y_list)\nx_dict = {x: i for (i, x) in enumerate(x_list, start=1)}\ny_dict = {y: i for (i, y) in enumerate(y_list, start=1)}\nrow_real = len(x_list)\ncol_real = len(y_list)\nrow = row_real + 2\ncol = col_real + 2\nbanned_up_ij = [[0] * row for _ in range(col)]\nbanned_down_ij = [[0] * row for _ in range(col)]\nbanned_left_ij = [[0] * col for _ in range(row)]\nbanned_right_ij = [[0] * col for _ in range(row)]\nfor (a, b, c) in ver_lines:\n    if a > b:\n        (a, b) = (b, a)\n    ai = y_dict[a]\n    bi = y_dict[b]\n    j = x_dict[c]\n    banned_left_ij[j][ai] += 1\n    banned_left_ij[j][bi] -= 1\n    banned_right_ij[j - 1][ai] += 1\n    banned_right_ij[j - 1][bi] -= 1\nfor (d, e, f) in hor_lines:\n    if e > f:\n        (e, f) = (f, e)\n    i = y_dict[d]\n    ej = x_dict[e]\n    fj = x_dict[f]\n    banned_up_ij[i][ej] += 1\n    banned_up_ij[i][fj] -= 1\n    banned_down_ij[i - 1][ej] += 1\n    banned_down_ij[i - 1][fj] -= 1\nbanned_up = [0] * (row * col)\nbanned_down = [0] * (row * col)\nbanned_left = [0] * (row * col)\nbanned_right = [0] * (row * col)\nfor i in range(col):\n    ru = banned_up_ij[i]\n    rd = banned_down_ij[i]\n    ri = row * i\n    banned_up[ri] = ru[0]\n    banned_down[ri] = rd[0]\n    for j in range(1, row):\n        banned_up[ri + j] = banned_up[(ri + j) - 1] + ru[j]\n        banned_down[ri + j] = banned_down[(ri + j) - 1] + rd[j]\nfor j in range(row):\n    rl = banned_left_ij[j]\n    rr = banned_right_ij[j]\n    banned_left[j] = rl[0]\n    banned_right[j] = rr[0]\n    for i in range(1, col):\n        ri0 = (i - 1) * row\n        ri1 = i * row\n        banned_left[ri1 + j] = banned_left[ri0 + j] + rl[i]\n        banned_right[ri1 + j] = banned_right[ri0 + j] + rr[i]\ns = (row * y_dict[0]) + x_dict[0]\nenable = (([-1] * row) + ((([-1] + ([0] * (row - 2))) + [-1]) * (col - 2))) + ([-1] * row)\nq = [s]\nmoves = [(-row, banned_up), (-1, banned_left), (1, banned_right), (row, banned_down)]\nwhile q:\n    c = q.pop()\n    if enable[c] == 1:\n        continue\n    elif enable[c] == -1:\n        print('INF')\n        exit()\n    enable[c] = 1\n    for (dc, banned) in moves:\n        if banned[c]:\n            continue\n        nc = c + dc\n        if enable[nc] == 1:\n            continue\n        q.append(nc)\nans = 0\nfor i in range(col):\n    ri = i * row\n    for j in range(row):\n        if enable[ri + j] != 1:\n            continue\n        t = y_list[i - 1]\n        b = y_list[i]\n        l = x_list[j - 1]\n        r = x_list[j]\n        ans += (b - t) * (r - l)\nprint(ans)", "generated_code": "import sys\n(n, m, *abcdef) = list(map(int, sys.stdin.buffer.read().split()))\nver_lines = []\nhor_lines = []\nx_list = set()\ny_list = set()\nn3 = n * 3\nfor (a, b, c) in zip(abcdef[0:n3:3], abcdef[1:n3:3], abcdef[2:n3:3]):\n    y_list.add(a)\n    y_list.add(b)\n    x_list.add(c)\n    ver_lines.append((a, b, c))\nfor (d, e, f) in zip(abcdef[n3 + 0::3], abcdef[n3 + 1::3], abcdef[n3 + 2::3]):\n    y_list.add(d)\n    x_list.add(e)\n    x_list.add(f)\n    hor_lines.append((d, e, f))\nx_list.add(0)\ny_list.add(0)\nx_list = sorted(x_list)\ny_list = sorted(y_list)\nx_dict = {x: i for (i, x) in enumerate(x_list, start=1)}\ny_dict = {y: i for (i, y) in enumerate(y_list, start=1)}\nrow_real = len(x_list)\ncol_real = len(y_list)\nrow = row_real + 2\ncol = col_real + 2\nbanned_up_ij = [[0] * row for _ in range(col)]\nbanned_down_ij = [[0] * row for _ in range(col)]\nbanned_left_ij = [[0] * col for _ in range(row)]\nbanned_right_ij = [[0] * col for _ in range(row)]\nfor (a, b, c) in ver_lines:\n    if a > b:\n        (a, b) = (b, a)\n    ai = y_dict[a]\n    bi = y_dict[b]\n    j = x_dict[c]\n    banned_left_ij[j][ai] += 1\n    banned_left_ij[j][bi] -= 1\n    banned_right_ij[j - 1][ai] += 1\n    banned_right_ij[j - 1][bi] -= 1\nfor (d, e, f) in hor_lines:\n    if e > f:\n        (e, f) = (f, e)\n    i = y_dict[d]\n    ej = x_dict[e]\n    fj = x_dict[f]\n    banned_up_ij[i][ej] += 1\n    banned_up_ij[i][fj] -= 1\n    banned_down_ij[i - 1][ej] += 1\n    banned_down_ij[i - 1][fj] -= 1\nbanned_up = [0] * (row * col)\nbanned_down = [0] * (row * col)\nbanned_left = [0] * (row * col)\nbanned_right = [0] * (row * col)\nfor i in range(col):\n    ru = banned_up_ij[i]\n    rd = banned_down_ij[i]\n    ri = row * i\n    banned_up[ri] = ru[0]\n    banned_down[ri] = rd[0]\n    for j in range(1, row):\n        banned_up[ri + j] = banned_up[(ri + j) - 1] + ru[j]\n        banned_down[ri + j] = banned_down[(ri + j) - 1] + rd[j]\nfor j in range(row):\n    rl = banned_left_ij[j]\n    rr = banned_right_ij[j]\n    banned_left[j] = rl[0]\n    banned_right[j] = rr[0]\n    for i in range(1, col):\n        ri0 = (i - 1) * row\n        ri1 = i * row\n        banned_left[ri1 + j] = banned_left[ri0 + j] + rl[i]\n        banned_right[ri1 + j] = banned_right[ri0 + j] + rr[i]\ns = (row * y_dict[0]) + x_dict[0]\nenable = (([-1] * row) + ((([-1] + ([0] * (row - 2))) + [-1]) * (col - 2))) - ([-1] * row)\nq = [s]\nmoves = [(-row, banned_up), (-1, banned_left), (1, banned_right), (row, banned_down)]\nwhile q:\n    c = q.pop()\n    if enable[c] == 1:\n        continue\n    elif enable[c] == -1:\n        print('INF')\n        exit()\n    enable[c] = 1\n    for (dc, banned) in moves:\n        if banned[c]:\n            continue\n        nc = c + dc\n        if enable[nc] == 1:\n            continue\n        q.append(nc)\nans = 0\nfor i in range(col):\n    ri = i * row\n    for j in range(row):\n        if enable[ri + j] != 1:\n            continue\n        t = y_list[i - 1]\n        b = y_list[i]\n        l = x_list[j - 1]\n        r = x_list[j]\n        ans += (b - t) * (r - l)\nprint(ans)", "score": 0.0, "codebleu": 0.9973984967720897, "crystalbleu": 0.9976473158075668, "codebertscore": 1.0, "codescore": 0.9542229175567627, "surfaceSim": 0.9998327199732352, "abs_surfaceSim_minus_score": 0.9998327199732352}
{"golden_code": "import sys\nfile_input = sys.stdin\n(X, Y, E) = list(map(int, file_input.readline().split()))\nv_num = (X + Y) + 2\nadj_mat = [[0] * v_num for i in range(v_num)]\nfor line in file_input:\n    (x, y) = list(map(int, line.split()))\n    adj_mat[x][X + y] = 1\ns = X + Y\nt = s + 1\nfor i in range(X):\n    adj_mat[s][i] = 1\nfor i in range(X, s):\n    adj_mat[i][t] = 1\nimport collections\ndef bfs(start, goal, parent):\n    unvisited = [True] * v_num\n    queue = collections.deque()\n    queue.append(start)\n    unvisited[start] = False\n    while queue:\n        u = queue.popleft()\n        for (v, r_capacity) in enumerate(adj_mat[u]):\n            if (unvisited[v] and r_capacity > 0):\n                parent[v].append(u)\n                queue.append(v)\n                unvisited[v] = False\n    return unvisited[goal]\ndef dfs(goal, path, parent, blocking_flow):\n    v = path[-1]\n    if v == goal:\n        aug_path_flow = 10000\n        for (x, y) in zip(path[1:], path[:-1]):\n            aug_path_flow = min(aug_path_flow, adj_mat[x][y])\n        for (x, y) in zip(path[1:], path[:-1]):\n            adj_mat[x][y] -= aug_path_flow\n            adj_mat[y][x] += aug_path_flow\n        blocking_flow[0] += aug_path_flow\n    else:\n        for u in parent[v]:\n            path.append(u)\n            dfs(goal, path, parent, blocking_flow)\n            path.pop()\ndef dinic(source, sink):\n    max_flow = 0\n    parent = [[] for i in range(v_num)]\n    while not (bfs(source, sink, parent)):\n        blocking_flow = [0]\n        path = [sink]\n        dfs(source, path, parent, blocking_flow)\n        max_flow += blocking_flow[0]\n        parent = [[] for i in range(v_num)]\n    return max_flow\nprint(dinic(s, t))", "generated_code": "import sys\nfile_input = sys.stdin\n(X, Y, E) = list(map(int, file_input.readline().split()))\nv_num = (X + Y) + 2\nadj_mat = [[0] * v_num for i in range(v_num)]\nfor line in file_input:\n    (x, y) = list(map(int, line.split()))\n    adj_mat[x][X + y] = 1\ns = X + Y\nt = s + 1\nfor i in range(X):\n    adj_mat[s][i] = 1\nfor i in range(X, s):\n    adj_mat[i][t] = 1\nimport collections\ndef bfs(start, goal, parent):\n    unvisited = [True] * v_num\n    queue = collections.deque()\n    queue.append(start)\n    unvisited[start] = False\n    while queue:\n        u = queue.popleft()\n        for (v, r_capacity) in enumerate(adj_mat[u]):\n            if (unvisited[v] and r_capacity > 0):\n                parent[v].append(u)\n                queue.append(v)\n                unvisited[v] = False\n    return unvisited[goal]\ndef dfs(goal, path, parent, blocking_flow):\n    v = path[1]\n    if v == goal:\n        aug_path_flow = 10000\n        for (x, y) in zip(path[1:], path[:-1]):\n            aug_path_flow = min(aug_path_flow, adj_mat[x][y])\n        for (x, y) in zip(path[1:], path[:-1]):\n            adj_mat[x][y] -= aug_path_flow\n            adj_mat[y][x] += aug_path_flow\n        blocking_flow[0] += aug_path_flow\n    else:\n        for u in parent[v]:\n            path.append(u)\n            dfs(goal, path, parent, blocking_flow)\n            path.pop()\ndef dinic(source, sink):\n    max_flow = 0\n    parent = [[] for i in range(v_num)]\n    while not (bfs(source, sink, parent)):\n        blocking_flow = [0]\n        path = [sink]\n        dfs(source, path, parent, blocking_flow)\n        max_flow += blocking_flow[0]\n        parent = [[] for i in range(v_num)]\n    return max_flow\nprint(dinic(s, t))", "score": 0.0, "codebleu": 0.987368291412523, "crystalbleu": 0.9945018314686084, "codebertscore": 1.0, "codescore": 0.9938260912895203, "surfaceSim": 0.9997020262216925, "abs_surfaceSim_minus_score": 0.9997020262216925}
{"golden_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "generated_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)\nif __name__ != '__main__':\n    if file:\n        if path.exists('input1.txt'):\n            sys.stdin = open('input1.txt', 'r')\n            sys.stdout = open('output1.txt', 'w')else:input = sys.stdin.readline\n    solve()", "score": 0.0, "codebleu": 0.8508413069719964, "crystalbleu": 0.765258036938324, "codebertscore": 0.96, "codescore": 0.9925879836082458, "surfaceSim": 0.4146090534979424, "abs_surfaceSim_minus_score": 0.4146090534979424}
{"golden_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "generated_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "score": 0.0, "codebleu": 0.9823822156640517, "crystalbleu": 0.994217433523444, "codebertscore": 1.0, "codescore": 0.993606448173523, "surfaceSim": 0.9988589685075309, "abs_surfaceSim_minus_score": 0.9988589685075309}
{"golden_code": "from collections import defaultdict\nfrom collections import deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\ndef I():\n    return int(sys.stdin.readline())\ndef LS():\n    return list(map(list, sys.stdin.readline().split()))\ndef S():\n    return list(sys.stdin.readline())[:-1]\ndef IR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = I()\n    return l\ndef LIR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = LI()\n    return l\ndef SR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = S()\n    return l\ndef LSR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = LS()\n    return l\nsys.setrecursionlimit(1000000)\nmod = 1000000007\ndef A():\n    return\ndef B():\n    return\ndef C():\n    return\ndef D():\n    return\ndef E():\n    return\ndef F():\n    (a, b, c, X, Y) = LI()\n    ans = float('inf')\n    for z in range(300001):\n        if z % 2 == 0:\n            m = c * z\n            x = z // 2\n            y = z // 2\n            m += a * max(0, X - x)\n            m += b * max(0, Y - y)\n            if m < ans:\n                ans = m\n    print(ans)\n    return\ndef G():\n    n = I()\n    x = LI()\n    f = [(i, x[i]) for i in range(n)]\n    f.sort(key=lambda x: (x[1]))\n    g = [(f[i][0], i) for i in range(n)]\n    g.sort(key=lambda x: (x[0]))\n    for i in range(n):\n        if g[i][1] < n // 2:\n            print(f[n // 2][1])else:print(f[(n // 2) - 1][1])\n    return\ndef H():\n    return\ndef I_():\n    return\ndef J():\n    return", "generated_code": "from collections import defaultdict\nfrom collections import deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\ndef I():\n    return int(sys.stdin.readline())\ndef LS():\n    return list(map(list, sys.stdin.readline().split()))\ndef S():\n    return list(sys.stdin.readline())[:-1]\ndef IR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = I()\n    return l\ndef LIR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = LI()\n    return l\ndef SR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = S()\n    return l\ndef LSR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = LS()\n    return l\nsys.setrecursionlimit(1000000)\nmod = 1000000007\ndef A():\n    return\ndef B():\n    return\ndef C():\n    return\ndef D():\n    return\ndef E():\n    return\ndef F():\n    (a, b, c, X, Y) = LI()\n    ans = float('inf')\n    for z in range(300001):\n        if z % 2 == 0:\n            m = c * z\n            x = z // 2\n            y = z / 2\n            m += a * max(0, X - x)\n            m += b * max(0, Y - y)\n            if m < ans:\n                ans = m\n    print(ans)\n    return\ndef G():\n    n = I()\n    x = LI()\n    f = [(i, x[i]) for i in range(n)]\n    f.sort(key=lambda x: (x[1]))\n    g = [(f[i][0], i) for i in range(n)]\n    g.sort(key=lambda x: (x[0]))\n    for i in range(n):\n        if g[i][1] < n // 2:\n            print(f[n // 2][1])else:print(f[(n // 2) - 1][1])\n    return\ndef H():\n    return\ndef I_():\n    return\ndef J():\n    return", "score": 0.0, "codebleu": 0.9950684650874879, "crystalbleu": 0.9965660479529148, "codebertscore": 1.0, "codescore": 0.9934606552124023, "surfaceSim": 0.49969097651421507, "abs_surfaceSim_minus_score": 0.49969097651421507}
{"golden_code": "import queue\nINF = 123456789\ndef main():\n    (n, m) = list(map(int, input().split()))\n    G = [[] for _ in range(n)]\n    for _ in range(m):\n        (a, b, c) = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        G[a].append((b, c))\n        G[b].append((a, c))\n    used = set()\n    for i in range(n):\n        d = [INF for _ in range(n)]\n        par = [-1 for _ in range(n)]\n        que = queue.PriorityQueue()\n        d[i] = 0\n        que.put((0, i))\n        while not (que.empty()):\n            p = que.get()\n            v = p[1]\n            if d[v] < p[0]:\n                continue\n            for (to, cost) in G[v]:\n                if d[to] > d[v] + cost:\n                    d[to] = d[v] + cost\n                    par[to] = v\n                    que.put((d[to], to))\n        for j in range(n):\n            if i != j:\n                (a, b) = (j, par[j])\n                if a > b:\n                    (a, b) = (b, a)\n                used.add((a, b))\n    print(m - len(used))", "generated_code": "import queue\nINF = 123456789\ndef main():\n    (n, m) = list(map(int, input().split()))\n    G = [[] for _ in range(n)]\n    for _ in range(m):\n        (a, b, c) = list(map(int, input().split()))\n        a += 1\n        b -= 1\n        G[a].append((b, c))\n        G[b].append((a, c))\n    used = set()\n    for i in range(n):\n        d = [INF for _ in range(n)]\n        par = [-1 for _ in range(n)]\n        que = queue.PriorityQueue()\n        d[i] = 0\n        que.put((0, i))\n        while not (que.empty()):\n            p = que.get()\n            v = p[1]\n            if d[v] < p[0]:\n                continue\n            for (to, cost) in G[v]:\n                if d[to] > d[v] + cost:\n                    d[to] = d[v] + cost\n                    par[to] = v\n                    que.put((d[to], to))\n        for j in range(n):\n            if i != j:\n                (a, b) = (j, par[j])\n                if a > b:\n                    (a, b) = (b, a)\n                used.add((a, b))\n    print(m - len(used))", "score": 0.0, "codebleu": 0.9904103276685203, "crystalbleu": 0.9879581348354282, "codebertscore": 1.0, "codescore": 0.9937792420387268, "surfaceSim": 0.9994979919678715, "abs_surfaceSim_minus_score": 0.9994979919678715}
{"golden_code": "def popcount(x):\n    x = x - ((x >> 1) & 1431655765)\n    x = (x & 858993459) + ((x >> 2) & 858993459)\n    x = (x + (x >> 4)) & 252645135\n    x = x + (x >> 8)\n    x = x + (x >> 16)\n    return x & 127\ncmb = [[0 for i in range(51)] for j in range(51)]\ncmb[0][0] = 1\nfor i in range(51):\n    for j in range(51):\n        if (i != 50 and j != 50):\n            cmb[i + 1][j + 1] += cmb[i][j]\n        if i != 50:\n            cmb[i + 1][j] += cmb[i][j]\nfor i in range(1, 51):\n    for j in range(2, 51):\n        cmb[i][j] += cmb[i][j - 1]\n(N, K, T, S) = list(map(int, input().split()))\na = list(map(int, input().split()))\nmust0 = [i for i in range(18) if (S >> i) & 1 == 0]\nmust1 = [i for i in range(18) if (T >> i) & 1 == 1]\nA = []\nfor val in a:\n    check = True\n    for j in must0:\n        check = check & (val >> j) & 1 == 0\n    for j in must1:\n        check = check & (val >> j) & 1 == 1\n    if check:\n        A.append(val)\nif not A:\n    print(0)\n    exit()\nbit = []\nfor i in range(18):\n    if (i not in must0 and i not in must1):\n        bit.append(i)\nfor i in range(len(A)):\n    temp = 0\n    for j in range(len(bit)):\n        temp += (A[i] >> bit[j]) & 1 == 1 * (2 ** j)\n    A[i] = temp\nans = 0\nn = len(bit)\ndata = [0] * (2 ** n)\nfor i in range(2 ** n):\n    t = set([])\n    for a in A:\n        data[a & i] += 1\n        t.add(a & i)\n    temp = 0\n    for val in t:\n        temp += cmb[data[val]][min(K, data[val])]\n    ans += temp * ((-1) ** popcount(i))\n    for val in t:\n        data[val] = 0\nprint(ans)", "generated_code": "def popcount(x):\n    x = x - ((x >> 1) & 1431655765)\n    x = (x & 858993459) + ((x >> 2) & 858993459)\n    x = (x + (x >> 4)) & 252645135\n    x = x + (x >> 8)\n    x = x + (x >> 16)\n    return x & 127\ncmb = [[0 for i in range(51)] for j in range(51)]\ncmb[0][0] = 1\nfor i in range(51):\n    for j in range(51):\n        if (i != 50 and j == 50):\n            cmb[i + 1][j + 1] += cmb[i][j]\n        if i != 50:\n            cmb[i + 1][j] += cmb[i][j]\nfor i in range(1, 51):\n    for j in range(2, 51):\n        cmb[i][j] += cmb[i][j - 1]\n(N, K, T, S) = list(map(int, input().split()))\na = list(map(int, input().split()))\nmust0 = [i for i in range(18) if (S >> i) & 1 == 0]\nmust1 = [i for i in range(18) if (T >> i) & 1 == 1]\nA = []\nfor val in a:\n    check = True\n    for j in must0:\n        check = check & (val >> j) & 1 == 0\n    for j in must1:\n        check = check & (val >> j) & 1 == 1\n    if check:\n        A.append(val)\nif not A:\n    print(0)\n    exit()\nbit = []\nfor i in range(18):\n    if (i not in must0 and i not in must1):\n        bit.append(i)\nfor i in range(len(A)):\n    temp = 0\n    for j in range(len(bit)):\n        temp += (A[i] >> bit[j]) & 1 == 1 * (2 ** j)\n    A[i] = temp\nans = 0\nn = len(bit)\ndata = [0] * (2 ** n)\nfor i in range(2 ** n):\n    t = set([])\n    for a in A:\n        data[a & i] += 1\n        t.add(a & i)\n    temp = 0\n    for val in t:\n        temp += cmb[data[val]][min(K, data[val])]\n    ans += temp * ((-1) ** popcount(i))\n    for val in t:\n        data[val] = 0\nprint(ans)", "score": 0.0, "codebleu": 0.995941382850743, "crystalbleu": 0.9932103550789324, "codebertscore": 1.0, "codescore": 0.9936564564704895, "surfaceSim": 0.9996662216288384, "abs_surfaceSim_minus_score": 0.9996662216288384}
{"golden_code": "from collections import defaultdict\nfrom collections import deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\ndef I():\n    return int(sys.stdin.readline())\ndef LS():\n    return list(map(list, sys.stdin.readline().split()))\ndef S():\n    return list(sys.stdin.readline())[:-1]\ndef IR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = I()\n    return l\ndef LIR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = LI()\n    return l\ndef SR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = S()\n    return l\ndef LSR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = LS()\n    return l\nsys.setrecursionlimit(1000000)\nmod = 1000000007\ndef A():\n    return\ndef B():\n    return\ndef C():\n    return\ndef D():\n    return\ndef E():\n    return\ndef F():\n    (a, b, c, X, Y) = LI()\n    ans = float('inf')\n    for z in range(300001):\n        if z % 2 == 0:\n            m = c * z\n            x = z // 2\n            y = z // 2\n            m += a * max(0, X - x)\n            m += b * max(0, Y - y)\n            if m < ans:\n                ans = m\n    print(ans)\n    return\ndef G():\n    n = I()\n    x = LI()\n    f = [(i, x[i]) for i in range(n)]\n    f.sort(key=lambda x: (x[1]))\n    g = [(f[i][0], i) for i in range(n)]\n    g.sort(key=lambda x: (x[0]))\n    for i in range(n):\n        if g[i][1] < n // 2:\n            print(f[n // 2][1])else:print(f[(n // 2) - 1][1])\n    return\ndef H():\n    return\ndef I_():\n    return\ndef J():\n    return", "generated_code": "from collections import defaultdict\nfrom collections import deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\ndef I():\n    return int(sys.stdin.readline())\ndef LS():\n    return list(map(list, sys.stdin.readline().split()))\ndef S():\n    return list(sys.stdin.readline())[:-1]\ndef IR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = I()\n    return l\ndef LIR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = LI()\n    return l\ndef SR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = S()\n    return l\ndef LSR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = LS()\n    return l\nsys.setrecursionlimit(1000000)\nmod = 1000000007\ndef A():\n    return\ndef B():\n    return\ndef C():\n    return\ndef D():\n    return\ndef E():\n    return\ndef F():\n    (a, b, c, X, Y) = LI()\n    ans = float('inf')\n    for z in range(300001):\n        if z % 2 == 0:\n            m = c * z\n            x = z // 2\n            y = z * 2\n            m += a * max(0, X - x)\n            m += b * max(0, Y - y)\n            if m < ans:\n                ans = m\n    print(ans)\n    return\ndef G():\n    n = I()\n    x = LI()\n    f = [(i, x[i]) for i in range(n)]\n    f.sort(key=lambda x: (x[1]))\n    g = [(f[i][0], i) for i in range(n)]\n    g.sort(key=lambda x: (x[0]))\n    for i in range(n):\n        if g[i][1] < n // 2:\n            print(f[n // 2][1])else:print(f[(n // 2) - 1][1])\n    return\ndef H():\n    return\ndef I_():\n    return\ndef J():\n    return", "score": 0.0, "codebleu": 0.9950684650874879, "crystalbleu": 0.9914241489727199, "codebertscore": 1.0, "codescore": 0.9934688806533813, "surfaceSim": 0.49938195302843014, "abs_surfaceSim_minus_score": 0.49938195302843014}
{"golden_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "generated_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    pass\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "score": 0.0, "codebleu": 0.9831168329785611, "crystalbleu": 0.9749582158190828, "codebertscore": 0.99, "codescore": 0.9830334782600403, "surfaceSim": 0.984017284075403, "abs_surfaceSim_minus_score": 0.984017284075403}
{"golden_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "generated_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        pass\n    print(n)", "score": 0.0, "codebleu": 0.9464720378337097, "crystalbleu": 0.9659801703856415, "codebertscore": 1.0, "codescore": 0.9939028024673462, "surfaceSim": 0.9768307721494973, "abs_surfaceSim_minus_score": 0.9768307721494973}
{"golden_code": "import math, string, itertools, fractions, heapq, collections, re, array, bisect, sys, random, time, copy, functools\nsys.setrecursionlimit(10 ** 7)\ninf = 10 ** 20\neps = 1.0 / (10 ** 15)\nmod = (10 ** 9) + 7\ndef LI():\n    return [int(x) for x in sys.stdin.readline().split()]\ndef LI_():\n    return [int(x) - 1 for x in sys.stdin.readline().split()]\ndef LF():\n    return [float(x) for x in sys.stdin.readline().split()]\ndef LS():\n    return sys.stdin.readline().split()\ndef I():\n    return int(sys.stdin.readline())\ndef F():\n    return float(sys.stdin.readline())\ndef S():\n    return input()\ndef pf(s):\n    return print(s, flush=True)\ndef divisions(n):\n    sq = int(math.sqrt(n) + 1)\n    d = collections.defaultdict(int)\n    while n % 2 == 0:\n        n //= 2\n        d[2] += 1\n    i = 3\n    while (n > 1 and sq >= i):\n        if n % i == 0:\n            n //= i\n            d[i] += 1else:i += 2\n    if n > 1:\n        d[n] += 1\n    r = [1]\n    for (k, v) in d.items():\n        for c in r[:]:\n            for i in range(1, v + 1):\n                r.append(c * (k ** i))\n    return sorted(r)\ndef main():\n    n = I()\n    a = LI()\n    s = set()\n    for i in range(n, 0, -1):\n        d = divisions(i)\n        ld = len(d)\n        for j in range(1, 2 ** ld):\n            c = []\n            ff = True\n            for k in range(ld):\n                if j & (1 << k):\n                    f = True\n                    for e in c:\n                        if d[k] % e == 0:\n                            f = False\n                            ff = False\n                            break\n                    if f:\n                        c.append(d[k])\n                if not ff:\n                    break\n            if ff:\n                s.add(tuple(c + [n + 1]))\n    b = sorted(list(s), reverse=True)\n    for c in b:\n        t = 0\n        for j in range(1, n + 1):\n            f = False\n            for e in c:\n                if j % e == 0:\n                    f = True\n                    break\n            if f:\n                t += a[j - 1]\n        if t < 0:\n            for j in range(1, n + 1):\n                f = False\n                for e in c:\n                    if j % e == 0:\n                        f = True\n                        break\n                if f:\n                    a[j - 1] = 0\n    return sum(a)\nprint(main())", "generated_code": "import math, string, itertools, fractions, heapq, collections, re, array, bisect, sys, random, time, copy, functools\nsys.setrecursionlimit(10 ** 7)\ninf = 10 ** 20\neps = 1.0 / (10 ** 15)\nmod = (10 ** 9) + 7\ndef LI():\n    return [int(x) for x in sys.stdin.readline().split()]\ndef LI_():\n    return [int(x) + 1 for x in sys.stdin.readline().split()]\ndef LF():\n    return [float(x) for x in sys.stdin.readline().split()]\ndef LS():\n    return sys.stdin.readline().split()\ndef I():\n    return int(sys.stdin.readline())\ndef F():\n    return float(sys.stdin.readline())\ndef S():\n    return input()\ndef pf(s):\n    return print(s, flush=True)\ndef divisions(n):\n    sq = int(math.sqrt(n) + 1)\n    d = collections.defaultdict(int)\n    while n % 2 == 0:\n        n //= 2\n        d[2] += 1\n    i = 3\n    while (n > 1 and sq >= i):\n        if n % i == 0:\n            n //= i\n            d[i] += 1else:i += 2\n    if n > 1:\n        d[n] += 1\n    r = [1]\n    for (k, v) in d.items():\n        for c in r[:]:\n            for i in range(1, v + 1):\n                r.append(c * (k ** i))\n    return sorted(r)\ndef main():\n    n = I()\n    a = LI()\n    s = set()\n    for i in range(n, 0, -1):\n        d = divisions(i)\n        ld = len(d)\n        for j in range(1, 2 ** ld):\n            c = []\n            ff = True\n            for k in range(ld):\n                if j & (1 << k):\n                    f = True\n                    for e in c:\n                        if d[k] % e == 0:\n                            f = False\n                            ff = False\n                            break\n                    if f:\n                        c.append(d[k])\n                if not ff:\n                    break\n            if ff:\n                s.add(tuple(c + [n + 1]))\n    b = sorted(list(s), reverse=True)\n    for c in b:\n        t = 0\n        for j in range(1, n + 1):\n            f = False\n            for e in c:\n                if j % e == 0:\n                    f = True\n                    break\n            if f:\n                t += a[j - 1]\n        if t < 0:\n            for j in range(1, n + 1):\n                f = False\n                for e in c:\n                    if j % e == 0:\n                        f = True\n                        break\n                if f:\n                    a[j - 1] = 0\n    return sum(a)\nprint(main())", "score": 0.0, "codebleu": 0.9962096427720554, "crystalbleu": 0.9961810745545907, "codebertscore": 1.0, "codescore": 0.9733123183250427, "surfaceSim": 0.49978466838931956, "abs_surfaceSim_minus_score": 0.49978466838931956}
{"golden_code": "class UnionFind:\n    def __init__(self, size):\n        self.table = [i for i in range(size)]\n    def find(self, x):\n        return self.table[x]\n    def union(self, x, y):\n        x1 = self.find(x)\n        y1 = self.find(y)\n        if x1 == y1:\n            return False\n        for i in range(len(self.table)):\n            if self.table[i] == y1:\n                self.table[i] = x1\n        return True\n(N, M) = list(map(int, input().split()))\nedges = []\nfor _ in range(M):\n    (a, b) = list(map(int, input().split()))\n    edges.append([a - 1, b - 1])\nmat = [[0] * N for _ in range(N)]\nfor (s, g) in edges:\n    mat[s][g] = 1\n    mat[g][s] = 1\nans = 0\nfor i in range(M):\n    uni = UnionFind(N)\n    for j in range(M):\n        if i != j:\n            uni.union(edges[j][0], edges[j][1])\n    if not (all((uni.find(0) == uni.find(x) for x in range(N)))):\n        ans += 1\nprint(ans)", "generated_code": "class UnionFind:\n    def __init__(self, size):\n        self.table = [i for i in range(size)]\n    def find(self, x):\n        return self.table[x]\n    def union(self, x, y):\n        x1 = self.find(x)\n        y1 = self.find(y)\n        if x1 == y1:\n            return False\n        for i in range(len(self.table)):\n            if self.table[i] == y1:\n                self.table[i] = x1\n        return True\n(N, M) = list(map(int, input().split()))\nedges = []\nfor _ in range(M):\n    (a, b) = list(map(int, input().split()))\n    edges.append([a - 1, b - 1])\nmat = [[0] // N for _ in range(N)]\nfor (s, g) in edges:\n    mat[s][g] = 1\n    mat[g][s] = 1\nans = 0\nfor i in range(M):\n    uni = UnionFind(N)\n    for j in range(M):\n        if i != j:\n            uni.union(edges[j][0], edges[j][1])\n    if not (all((uni.find(0) == uni.find(x) for x in range(N)))):\n        ans += 1\nprint(ans)", "score": 0.0, "codebleu": 0.9898100982097378, "crystalbleu": 0.9761951409275657, "codebertscore": 1.0, "codescore": 0.993707537651062, "surfaceSim": 0.9694466827827022, "abs_surfaceSim_minus_score": 0.9694466827827022}
{"golden_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "generated_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        break\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "score": 0.0, "codebleu": 0.9757550966986483, "crystalbleu": 0.9626898460033498, "codebertscore": 1.0, "codescore": 0.9935103058815002, "surfaceSim": 0.9901871291647649, "abs_surfaceSim_minus_score": 0.9901871291647649}
{"golden_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "generated_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    pass\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "score": 0.0, "codebleu": 0.910324063579324, "crystalbleu": 0.934520806408569, "codebertscore": 0.99, "codescore": 0.9900814890861511, "surfaceSim": 0.9688626446594575, "abs_surfaceSim_minus_score": 0.9688626446594575}
{"golden_code": "import sys\n(n, m, *abcdef) = list(map(int, sys.stdin.buffer.read().split()))\nver_lines = []\nhor_lines = []\nx_list = set()\ny_list = set()\nn3 = n * 3\nfor (a, b, c) in zip(abcdef[0:n3:3], abcdef[1:n3:3], abcdef[2:n3:3]):\n    y_list.add(a)\n    y_list.add(b)\n    x_list.add(c)\n    ver_lines.append((a, b, c))\nfor (d, e, f) in zip(abcdef[n3 + 0::3], abcdef[n3 + 1::3], abcdef[n3 + 2::3]):\n    y_list.add(d)\n    x_list.add(e)\n    x_list.add(f)\n    hor_lines.append((d, e, f))\nx_list.add(0)\ny_list.add(0)\nx_list = sorted(x_list)\ny_list = sorted(y_list)\nx_dict = {x: i for (i, x) in enumerate(x_list, start=1)}\ny_dict = {y: i for (i, y) in enumerate(y_list, start=1)}\nrow_real = len(x_list)\ncol_real = len(y_list)\nrow = row_real + 2\ncol = col_real + 2\nbanned_up_ij = [[0] * row for _ in range(col)]\nbanned_down_ij = [[0] * row for _ in range(col)]\nbanned_left_ij = [[0] * col for _ in range(row)]\nbanned_right_ij = [[0] * col for _ in range(row)]\nfor (a, b, c) in ver_lines:\n    if a > b:\n        (a, b) = (b, a)\n    ai = y_dict[a]\n    bi = y_dict[b]\n    j = x_dict[c]\n    banned_left_ij[j][ai] += 1\n    banned_left_ij[j][bi] -= 1\n    banned_right_ij[j - 1][ai] += 1\n    banned_right_ij[j - 1][bi] -= 1\nfor (d, e, f) in hor_lines:\n    if e > f:\n        (e, f) = (f, e)\n    i = y_dict[d]\n    ej = x_dict[e]\n    fj = x_dict[f]\n    banned_up_ij[i][ej] += 1\n    banned_up_ij[i][fj] -= 1\n    banned_down_ij[i - 1][ej] += 1\n    banned_down_ij[i - 1][fj] -= 1\nbanned_up = [0] * (row * col)\nbanned_down = [0] * (row * col)\nbanned_left = [0] * (row * col)\nbanned_right = [0] * (row * col)\nfor i in range(col):\n    ru = banned_up_ij[i]\n    rd = banned_down_ij[i]\n    ri = row * i\n    banned_up[ri] = ru[0]\n    banned_down[ri] = rd[0]\n    for j in range(1, row):\n        banned_up[ri + j] = banned_up[(ri + j) - 1] + ru[j]\n        banned_down[ri + j] = banned_down[(ri + j) - 1] + rd[j]\nfor j in range(row):\n    rl = banned_left_ij[j]\n    rr = banned_right_ij[j]\n    banned_left[j] = rl[0]\n    banned_right[j] = rr[0]\n    for i in range(1, col):\n        ri0 = (i - 1) * row\n        ri1 = i * row\n        banned_left[ri1 + j] = banned_left[ri0 + j] + rl[i]\n        banned_right[ri1 + j] = banned_right[ri0 + j] + rr[i]\ns = (row * y_dict[0]) + x_dict[0]\nenable = (([-1] * row) + ((([-1] + ([0] * (row - 2))) + [-1]) * (col - 2))) + ([-1] * row)\nq = [s]\nmoves = [(-row, banned_up), (-1, banned_left), (1, banned_right), (row, banned_down)]\nwhile q:\n    c = q.pop()\n    if enable[c] == 1:\n        continue\n    elif enable[c] == -1:\n        print('INF')\n        exit()\n    enable[c] = 1\n    for (dc, banned) in moves:\n        if banned[c]:\n            continue\n        nc = c + dc\n        if enable[nc] == 1:\n            continue\n        q.append(nc)\nans = 0\nfor i in range(col):\n    ri = i * row\n    for j in range(row):\n        if enable[ri + j] != 1:\n            continue\n        t = y_list[i - 1]\n        b = y_list[i]\n        l = x_list[j - 1]\n        r = x_list[j]\n        ans += (b - t) * (r - l)\nprint(ans)", "generated_code": "import sys\n(n, m, *abcdef) = list(map(int, sys.stdin.buffer.read().split()))\nver_lines = []\nhor_lines = []\nx_list = set()\ny_list = set()\nn3 = n * 3\nfor (a, b, c) in zip(abcdef[0:n3:3], abcdef[1:n3:3], abcdef[2:n3:3]):\n    y_list.add(a)\n    y_list.add(b)\n    x_list.add(c)\n    ver_lines.append((a, b, c))\nfor (d, e, f) in reversed(zip(abcdef[n3 + 0::3], abcdef[n3 + 1::3], abcdef[n3 + 2::3])):\n    y_list.add(d)\n    x_list.add(e)\n    x_list.add(f)\n    hor_lines.append((d, e, f))\nx_list.add(0)\ny_list.add(0)\nx_list = sorted(x_list)\ny_list = sorted(y_list)\nx_dict = {x: i for (i, x) in enumerate(x_list, start=1)}\ny_dict = {y: i for (i, y) in enumerate(y_list, start=1)}\nrow_real = len(x_list)\ncol_real = len(y_list)\nrow = row_real + 2\ncol = col_real + 2\nbanned_up_ij = [[0] * row for _ in range(col)]\nbanned_down_ij = [[0] * row for _ in range(col)]\nbanned_left_ij = [[0] * col for _ in range(row)]\nbanned_right_ij = [[0] * col for _ in range(row)]\nfor (a, b, c) in ver_lines:\n    if a > b:\n        (a, b) = (b, a)\n    ai = y_dict[a]\n    bi = y_dict[b]\n    j = x_dict[c]\n    banned_left_ij[j][ai] += 1\n    banned_left_ij[j][bi] -= 1\n    banned_right_ij[j - 1][ai] += 1\n    banned_right_ij[j - 1][bi] -= 1\nfor (d, e, f) in hor_lines:\n    if e > f:\n        (e, f) = (f, e)\n    i = y_dict[d]\n    ej = x_dict[e]\n    fj = x_dict[f]\n    banned_up_ij[i][ej] += 1\n    banned_up_ij[i][fj] -= 1\n    banned_down_ij[i - 1][ej] += 1\n    banned_down_ij[i - 1][fj] -= 1\nbanned_up = [0] * (row * col)\nbanned_down = [0] * (row * col)\nbanned_left = [0] * (row * col)\nbanned_right = [0] * (row * col)\nfor i in range(col):\n    ru = banned_up_ij[i]\n    rd = banned_down_ij[i]\n    ri = row * i\n    banned_up[ri] = ru[0]\n    banned_down[ri] = rd[0]\n    for j in range(1, row):\n        banned_up[ri + j] = banned_up[(ri + j) - 1] + ru[j]\n        banned_down[ri + j] = banned_down[(ri + j) - 1] + rd[j]\nfor j in range(row):\n    rl = banned_left_ij[j]\n    rr = banned_right_ij[j]\n    banned_left[j] = rl[0]\n    banned_right[j] = rr[0]\n    for i in range(1, col):\n        ri0 = (i - 1) * row\n        ri1 = i * row\n        banned_left[ri1 + j] = banned_left[ri0 + j] + rl[i]\n        banned_right[ri1 + j] = banned_right[ri0 + j] + rr[i]\ns = (row * y_dict[0]) + x_dict[0]\nenable = (([-1] * row) + ((([-1] + ([0] * (row - 2))) + [-1]) * (col - 2))) + ([-1] * row)\nq = [s]\nmoves = [(-row, banned_up), (-1, banned_left), (1, banned_right), (row, banned_down)]\nwhile q:\n    c = q.pop()\n    if enable[c] == 1:\n        continue\n    elif enable[c] == -1:\n        print('INF')\n        exit()\n    enable[c] = 1\n    for (dc, banned) in moves:\n        if banned[c]:\n            continue\n        nc = c + dc\n        if enable[nc] == 1:\n            continue\n        q.append(nc)\nans = 0\nfor i in range(col):\n    ri = i * row\n    for j in range(row):\n        if enable[ri + j] != 1:\n            continue\n        t = y_list[i - 1]\n        b = y_list[i]\n        l = x_list[j - 1]\n        r = x_list[j]\n        ans += (b - t) * (r - l)\nprint(ans)", "score": 0.0, "codebleu": 0.8950026919088316, "crystalbleu": 0.9945490436684621, "codebertscore": 1.0, "codescore": 0.9716699123382568, "surfaceSim": 0.9983327775925308, "abs_surfaceSim_minus_score": 0.9983327775925308}
{"golden_code": "import sys\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\ndef solve():\n    inf = (10 ** 14) + 10\n    def dfs(v: 'vertex_index, 0-indexed') -> None:\n        for (c, t) in e[v]:\n            if d[t] != inf:\n                continue\n            d[t] = d[v] + c\n            dfs(t)\n    n = int(eval(input()))\n    e = tuple((set() for _ in range(n)))\n    for _ in range(n - 1):\n        (a, b, c) = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        e[a].add((c, b))\n        e[b].add((c, a))\n    (q, v) = list(map(int, input().split()))\n    v -= 1\n    d = [inf] * n\n    d[v] = 0\n    dfs(v)\n    for _ in range(q):\n        (x, y) = list(map(int, input().split()))\n        x -= 1\n        y -= 1\n        print(d[x] + d[y])", "generated_code": "import sys\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\ndef solve():\n    inf = (10 ** 14) + 10\n    def dfs(v: 'vertex_index, 0-indexed') -> None:\n        for (c, t) in e[v]:\n            if d[t] != inf:\n                continue\n            d[t] = d[v] + c\n            dfs(t)\n    n = int(eval(input()))\n    e = tuple((set() for _ in range(n)))\n    for _ in range(n - 1):\n        (a, b, c) = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        e[a].add((c, b))\n        e[b].add((c, a))\n    (q, v) = list(map(int, input().split()))\n    v -= 1\n    d = [inf] * n\n    d[v] = 0\n    dfs(v)\n    for _ in range(q):\n        (x, y) = list(map(int, input().split()))\n        x -= 1\n        y -= 1\n        print(d[x] - d[y])", "score": 0.0, "codebleu": 0.9917965913003897, "crystalbleu": 0.9907582847077829, "codebertscore": 1.0, "codescore": 0.9938265681266785, "surfaceSim": 0.9993243243243244, "abs_surfaceSim_minus_score": 0.9993243243243244}
{"golden_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "generated_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] / (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "score": 0.0, "codebleu": 0.9963221036285097, "crystalbleu": 0.9937360383325433, "codebertscore": 1.0, "codescore": 0.9859532713890076, "surfaceSim": 0.9890647900136453, "abs_surfaceSim_minus_score": 0.9890647900136453}
{"golden_code": "import queue\nINF = 123456789\ndef main():\n    (n, m) = list(map(int, input().split()))\n    G = [[] for _ in range(n)]\n    for _ in range(m):\n        (a, b, c) = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        G[a].append((b, c))\n        G[b].append((a, c))\n    used = set()\n    for i in range(n):\n        d = [INF for _ in range(n)]\n        par = [-1 for _ in range(n)]\n        que = queue.PriorityQueue()\n        d[i] = 0\n        que.put((0, i))\n        while not (que.empty()):\n            p = que.get()\n            v = p[1]\n            if d[v] < p[0]:\n                continue\n            for (to, cost) in G[v]:\n                if d[to] > d[v] + cost:\n                    d[to] = d[v] + cost\n                    par[to] = v\n                    que.put((d[to], to))\n        for j in range(n):\n            if i != j:\n                (a, b) = (j, par[j])\n                if a > b:\n                    (a, b) = (b, a)\n                used.add((a, b))\n    print(m - len(used))", "generated_code": "import queue\nINF = 123456789\ndef main():\n    (n, m) = list(map(int, input().split()))\n    G = [[] for _ in range(n)]\n    for _ in range(m):\n        (a, b, c) = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        G[a].append((b, c))\n        G[b].append((a, c))\n    used = set()\n    for i in range(n):\n        d = [INF for _ in range(n)]\n        par = [-1 for _ in range(n)]\n        que = queue.PriorityQueue()\n        d[i] = 0\n        que.put((0, i))\n        while not (que.empty()):\n            p = que.get()\n            v = p[1]\n            if d[v] < p[0]:\n                break\n            for (to, cost) in G[v]:\n                if d[to] > d[v] + cost:\n                    d[to] = d[v] + cost\n                    par[to] = v\n                    que.put((d[to], to))\n        for j in range(n):\n            if i != j:\n                (a, b) = (j, par[j])\n                if a > b:\n                    (a, b) = (b, a)\n                used.add((a, b))\n    print(m - len(used))", "score": 0.0, "codebleu": 0.9744117905463052, "crystalbleu": 0.9877302871193514, "codebertscore": 1.0, "codescore": 0.9937805533409119, "surfaceSim": 0.9674125071715434, "abs_surfaceSim_minus_score": 0.9674125071715434}
{"golden_code": "def cmb(n, r):\n    import math\n    if n < r:\n        return 0\n    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\ndef solve(S):\n    mod = (10 ** 9) + 7\n    ans = 0\n    for i in range(1, (S // 3) + 1):\n        tama = i + (S - (i * 3))\n        tama -= 2\n        bo = i - 1\n        ans += cmb(tama + 1, bo)\n        ans %= mod\n    print(ans)", "generated_code": "def cmb(n, r):\n    import math\n    if n < r:\n        return 0\n    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\ndef solve(S):\n    mod = (10 ** 9) + 7\n    ans = 0\n    for i in range(1, (S // 3) + 1):\n        tama = i + (S - (i * 3))\n        tama -= 2\n        pass\n        ans += cmb(tama + 1, bo)\n        ans %= mod\n    print(ans)", "score": 0.0, "codebleu": 0.9077374758612371, "crystalbleu": 0.9218094162874737, "codebertscore": 0.99, "codescore": 0.9617758393287659, "surfaceSim": 0.973832607835378, "abs_surfaceSim_minus_score": 0.973832607835378}
{"golden_code": "def cmb(n, r):\n    import math\n    if n < r:\n        return 0\n    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\ndef solve(S):\n    mod = (10 ** 9) + 7\n    ans = 0\n    for i in range(1, (S // 3) + 1):\n        tama = i + (S - (i * 3))\n        tama -= 2\n        bo = i - 1\n        ans += cmb(tama + 1, bo)\n        ans %= mod\n    print(ans)", "generated_code": "def cmb(n, r):\n    import math\n    if n < r:\n        return 0\n    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\ndef solve(S):\n    mod = (10 ** 9) + 7\n    ans = 0\n    for i in range(1, (S / 3) + 1):\n        tama = i + (S - (i * 3))\n        tama -= 2\n        bo = i - 1\n        ans += cmb(tama + 1, bo)\n        ans %= mod\n    print(ans)", "score": 0.0, "codebleu": 0.980976656443197, "crystalbleu": 0.9848626345039097, "codebertscore": 1.0, "codescore": 0.993727445602417, "surfaceSim": 0.9807578155916106, "abs_surfaceSim_minus_score": 0.9807578155916106}
{"golden_code": "import math, string, itertools, fractions, heapq, collections, re, array, bisect, sys, random, time, copy, functools\nsys.setrecursionlimit(10 ** 7)\ninf = 10 ** 20\neps = 1.0 / (10 ** 15)\nmod = (10 ** 9) + 7\ndef LI():\n    return [int(x) for x in sys.stdin.readline().split()]\ndef LI_():\n    return [int(x) - 1 for x in sys.stdin.readline().split()]\ndef LF():\n    return [float(x) for x in sys.stdin.readline().split()]\ndef LS():\n    return sys.stdin.readline().split()\ndef I():\n    return int(sys.stdin.readline())\ndef F():\n    return float(sys.stdin.readline())\ndef S():\n    return input()\ndef pf(s):\n    return print(s, flush=True)\ndef divisions(n):\n    sq = int(math.sqrt(n) + 1)\n    d = collections.defaultdict(int)\n    while n % 2 == 0:\n        n //= 2\n        d[2] += 1\n    i = 3\n    while (n > 1 and sq >= i):\n        if n % i == 0:\n            n //= i\n            d[i] += 1else:i += 2\n    if n > 1:\n        d[n] += 1\n    r = [1]\n    for (k, v) in d.items():\n        for c in r[:]:\n            for i in range(1, v + 1):\n                r.append(c * (k ** i))\n    return sorted(r)\ndef main():\n    n = I()\n    a = LI()\n    s = set()\n    for i in range(n, 0, -1):\n        d = divisions(i)\n        ld = len(d)\n        for j in range(1, 2 ** ld):\n            c = []\n            ff = True\n            for k in range(ld):\n                if j & (1 << k):\n                    f = True\n                    for e in c:\n                        if d[k] % e == 0:\n                            f = False\n                            ff = False\n                            break\n                    if f:\n                        c.append(d[k])\n                if not ff:\n                    break\n            if ff:\n                s.add(tuple(c + [n + 1]))\n    b = sorted(list(s), reverse=True)\n    for c in b:\n        t = 0\n        for j in range(1, n + 1):\n            f = False\n            for e in c:\n                if j % e == 0:\n                    f = True\n                    break\n            if f:\n                t += a[j - 1]\n        if t < 0:\n            for j in range(1, n + 1):\n                f = False\n                for e in c:\n                    if j % e == 0:\n                        f = True\n                        break\n                if f:\n                    a[j - 1] = 0\n    return sum(a)\nprint(main())", "generated_code": "import math, string, itertools, fractions, heapq, collections, re, array, bisect, sys, random, time, copy, functools\nsys.setrecursionlimit(10 ** 7)\ninf = 10 ** 20\neps = 1.0 / (10 ** 15)\nmod = (10 * 9) + 7\ndef LI():\n    return [int(x) for x in sys.stdin.readline().split()]\ndef LI_():\n    return [int(x) - 1 for x in sys.stdin.readline().split()]\ndef LF():\n    return [float(x) for x in sys.stdin.readline().split()]\ndef LS():\n    return sys.stdin.readline().split()\ndef I():\n    return int(sys.stdin.readline())\ndef F():\n    return float(sys.stdin.readline())\ndef S():\n    return input()\ndef pf(s):\n    return print(s, flush=True)\ndef divisions(n):\n    sq = int(math.sqrt(n) + 1)\n    d = collections.defaultdict(int)\n    while n % 2 == 0:\n        n //= 2\n        d[2] += 1\n    i = 3\n    while (n > 1 and sq >= i):\n        if n % i == 0:\n            n //= i\n            d[i] += 1else:i += 2\n    if n > 1:\n        d[n] += 1\n    r = [1]\n    for (k, v) in d.items():\n        for c in r[:]:\n            for i in range(1, v + 1):\n                r.append(c * (k ** i))\n    return sorted(r)\ndef main():\n    n = I()\n    a = LI()\n    s = set()\n    for i in range(n, 0, -1):\n        d = divisions(i)\n        ld = len(d)\n        for j in range(1, 2 ** ld):\n            c = []\n            ff = True\n            for k in range(ld):\n                if j & (1 << k):\n                    f = True\n                    for e in c:\n                        if d[k] % e == 0:\n                            f = False\n                            ff = False\n                            break\n                    if f:\n                        c.append(d[k])\n                if not ff:\n                    break\n            if ff:\n                s.add(tuple(c + [n + 1]))\n    b = sorted(list(s), reverse=True)\n    for c in b:\n        t = 0\n        for j in range(1, n + 1):\n            f = False\n            for e in c:\n                if j % e == 0:\n                    f = True\n                    break\n            if f:\n                t += a[j - 1]\n        if t < 0:\n            for j in range(1, n + 1):\n                f = False\n                for e in c:\n                    if j % e == 0:\n                        f = True\n                        break\n                if f:\n                    a[j - 1] = 0\n    return sum(a)\nprint(main())", "score": 0.0, "codebleu": 0.9962096427720554, "crystalbleu": 0.997208742053556, "codebertscore": 1.0, "codescore": 0.9919071197509766, "surfaceSim": 0.49978466838931956, "abs_surfaceSim_minus_score": 0.49978466838931956}
{"golden_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "generated_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        break", "score": 0.0, "codebleu": 0.9582562011356932, "crystalbleu": 0.942615731987249, "codebertscore": 0.99, "codescore": 0.9936572909355164, "surfaceSim": 0.9888178913738019, "abs_surfaceSim_minus_score": 0.9888178913738019}
{"golden_code": "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nMOD = (10 ** 9) + 7\nfac = [1, 1]\nf_inv = [1, 1]\ninv = [0, 1]\ndef prepare(n, mod):\n    for i in range(2, n + 1):\n        fac.append((fac[-1] * i) % mod)\n        inv.append(((-(inv[mod % i])) * (mod // i)) % mod)\n        f_inv.append((f_inv[-1] * inv[-1]) % mod)\ndef cmb(n, r, mod):\n    if (n < 0 or r < 0):\n        return 0\n    if r > n:\n        return 0\n    return ((fac[n] * f_inv[r]) * f_inv[n - r]) % mod\ndef prime_factorization(n):\n    d = []\n    (i, e) = (2, 0)\n    while i * i <= n:\n        while n % i == 0:\n            n //= i\n            e += 1\n        if e > 0:\n            d.append((i, e))\n        i += 1\n        e = 0\n    if n > 1:\n        d.append((n, 1))\n    return d\ndef main():\n    (N, M) = list(map(int, readline().split()))\n    prepare(N + 100, MOD)\n    d = prime_factorization(M)\n    ans = 1\n    for (i, e) in d:\n        ans *= cmb((N - 1) + e, e, MOD)\n        ans %= MOD\n    print(ans)", "generated_code": "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nMOD = (10 ** 9) + 7\nfac = [1, 1]\nf_inv = [1, 1]\ninv = [0, 1]\ndef prepare(n, mod):\n    for i in range(2, n + 1):\n        fac.append((fac[-1] / i) % mod)\n        inv.append(((-(inv[mod % i])) * (mod // i)) % mod)\n        f_inv.append((f_inv[-1] * inv[-1]) % mod)\ndef cmb(n, r, mod):\n    if (n < 0 or r < 0):\n        return 0\n    if r > n:\n        return 0\n    return ((fac[n] * f_inv[r]) * f_inv[n - r]) % mod\ndef prime_factorization(n):\n    d = []\n    (i, e) = (2, 0)\n    while i * i <= n:\n        while n % i == 0:\n            n //= i\n            e += 1\n        if e > 0:\n            d.append((i, e))\n        i += 1\n        e = 0\n    if n > 1:\n        d.append((n, 1))\n    return d\ndef main():\n    (N, M) = list(map(int, readline().split()))\n    prepare(N + 100, MOD)\n    d = prime_factorization(M)\n    ans = 1\n    for (i, e) in d:\n        ans *= cmb((N - 1) + e, e, MOD)\n        ans %= MOD\n    print(ans)", "score": 0.0, "codebleu": 0.9927498121985038, "crystalbleu": 0.9930247750942204, "codebertscore": 1.0, "codescore": 0.9937492609024048, "surfaceSim": 0.987, "abs_surfaceSim_minus_score": 0.987}
{"golden_code": "from functools import lru_cache\nimport sys\nsys.setrecursionlimit(10 ** 7)\n\n@lru_cache(maxsize=None)\ndef check(l, r, n, k=1):t = (l + ('0' * k)) + r\n    e = (l + ('9' * k)) + r\n    if int(e) <= n:\n        return pow(10, k) + check(l, r, n, k + 1)\n    if int(t) <= n < int(e):\n        x = int(str(n)[1:-1])\n        if int(str(n)[-1]) < int(r):\n            x -= 1\n        return x + 1\n    if n < int(t):\n        return 0\ndef main():\n    n = int(eval(input()))\n    ret = 0\n    for x in range(1, n + 1):\n        if x % 10 == 0:\n            continue\n        s = str(x)\n        t = s[-1] + s[0]\n        if s[0] == s[-1]:\n            ret += 1\n        if int(t) <= n:\n            ret += 1\n        ret += check(s[-1], s[0], n, k=1)\n    print(ret)", "generated_code": "from functools import lru_cache\nimport sys\nsys.setrecursionlimit(10 ** 7)\n\n@lru_cache(maxsize=None)\ndef check(l, r, n, k=1):t = (l + ('0' * k)) + r\n    e = (l + ('9' * k)) + r\n    if int(e) <= n:\n        return pow(10, k) + check(l, r, n, k + 1)\n    if int(t) <= n < int(e):\n        x = int(str(n)[1:-1])\n        if int(str(n)[-1]) < int(r):\n            x -= 1\n        return x + 1\n    if n < int(t):\n        return 0\ndef main():\n    n = int(eval(input()))\n    ret = 0\n    for x in range(1, n + 1):\n        if x % 10 == 0:\n            continue\n        s = str(x)\n        t = s[-1] + s[0]\n        if s[0] == s[-1]:\n            ret += 1\n        if int(t) <= n:\n            ret += 1\n        ret += check(s[1], s[0], n, k=1)\n    print(ret)", "score": 0.0, "codebleu": 0.974206222213881, "crystalbleu": 0.9902419169655517, "codebertscore": 1.0, "codescore": 0.9937683343887329, "surfaceSim": 0.499320652173913, "abs_surfaceSim_minus_score": 0.499320652173913}
{"golden_code": "import sys\n(n, m, *abcdef) = list(map(int, sys.stdin.buffer.read().split()))\nver_lines = []\nhor_lines = []\nx_list = set()\ny_list = set()\nn3 = n * 3\nfor (a, b, c) in zip(abcdef[0:n3:3], abcdef[1:n3:3], abcdef[2:n3:3]):\n    y_list.add(a)\n    y_list.add(b)\n    x_list.add(c)\n    ver_lines.append((a, b, c))\nfor (d, e, f) in zip(abcdef[n3 + 0::3], abcdef[n3 + 1::3], abcdef[n3 + 2::3]):\n    y_list.add(d)\n    x_list.add(e)\n    x_list.add(f)\n    hor_lines.append((d, e, f))\nx_list.add(0)\ny_list.add(0)\nx_list = sorted(x_list)\ny_list = sorted(y_list)\nx_dict = {x: i for (i, x) in enumerate(x_list, start=1)}\ny_dict = {y: i for (i, y) in enumerate(y_list, start=1)}\nrow_real = len(x_list)\ncol_real = len(y_list)\nrow = row_real + 2\ncol = col_real + 2\nbanned_up_ij = [[0] * row for _ in range(col)]\nbanned_down_ij = [[0] * row for _ in range(col)]\nbanned_left_ij = [[0] * col for _ in range(row)]\nbanned_right_ij = [[0] * col for _ in range(row)]\nfor (a, b, c) in ver_lines:\n    if a > b:\n        (a, b) = (b, a)\n    ai = y_dict[a]\n    bi = y_dict[b]\n    j = x_dict[c]\n    banned_left_ij[j][ai] += 1\n    banned_left_ij[j][bi] -= 1\n    banned_right_ij[j - 1][ai] += 1\n    banned_right_ij[j - 1][bi] -= 1\nfor (d, e, f) in hor_lines:\n    if e > f:\n        (e, f) = (f, e)\n    i = y_dict[d]\n    ej = x_dict[e]\n    fj = x_dict[f]\n    banned_up_ij[i][ej] += 1\n    banned_up_ij[i][fj] -= 1\n    banned_down_ij[i - 1][ej] += 1\n    banned_down_ij[i - 1][fj] -= 1\nbanned_up = [0] * (row * col)\nbanned_down = [0] * (row * col)\nbanned_left = [0] * (row * col)\nbanned_right = [0] * (row * col)\nfor i in range(col):\n    ru = banned_up_ij[i]\n    rd = banned_down_ij[i]\n    ri = row * i\n    banned_up[ri] = ru[0]\n    banned_down[ri] = rd[0]\n    for j in range(1, row):\n        banned_up[ri + j] = banned_up[(ri + j) - 1] + ru[j]\n        banned_down[ri + j] = banned_down[(ri + j) - 1] + rd[j]\nfor j in range(row):\n    rl = banned_left_ij[j]\n    rr = banned_right_ij[j]\n    banned_left[j] = rl[0]\n    banned_right[j] = rr[0]\n    for i in range(1, col):\n        ri0 = (i - 1) * row\n        ri1 = i * row\n        banned_left[ri1 + j] = banned_left[ri0 + j] + rl[i]\n        banned_right[ri1 + j] = banned_right[ri0 + j] + rr[i]\ns = (row * y_dict[0]) + x_dict[0]\nenable = (([-1] * row) + ((([-1] + ([0] * (row - 2))) + [-1]) * (col - 2))) + ([-1] * row)\nq = [s]\nmoves = [(-row, banned_up), (-1, banned_left), (1, banned_right), (row, banned_down)]\nwhile q:\n    c = q.pop()\n    if enable[c] == 1:\n        continue\n    elif enable[c] == -1:\n        print('INF')\n        exit()\n    enable[c] = 1\n    for (dc, banned) in moves:\n        if banned[c]:\n            continue\n        nc = c + dc\n        if enable[nc] == 1:\n            continue\n        q.append(nc)\nans = 0\nfor i in range(col):\n    ri = i * row\n    for j in range(row):\n        if enable[ri + j] != 1:\n            continue\n        t = y_list[i - 1]\n        b = y_list[i]\n        l = x_list[j - 1]\n        r = x_list[j]\n        ans += (b - t) * (r - l)\nprint(ans)", "generated_code": "import sys\n(n, m, *abcdef) = list(map(int, sys.stdin.buffer.read().split()))\nver_lines = []\nhor_lines = []\nx_list = set()\ny_list = set()\nn3 = n * 3\nfor (a, b, c) in zip(abcdef[0:n3:3], abcdef[1:n3:3], abcdef[2:n3:3]):\n    y_list.add(a)\n    y_list.add(b)\n    x_list.add(c)\n    ver_lines.append((a, b, c))\nfor (d, e, f) in zip(abcdef[n3 + 0::3], abcdef[n3 + 1::3], abcdef[n3 + 2::3]):\n    y_list.add(d)\n    x_list.add(e)\n    x_list.add(f)\n    hor_lines.append((d, e, f))\nx_list.add(0)\ny_list.add(0)\nx_list = sorted(x_list)\ny_list = sorted(y_list)\nx_dict = {x: i for (i, x) in enumerate(x_list, start=1)}\ny_dict = {y: i for (i, y) in enumerate(y_list, start=1)}\nrow_real = len(x_list)\ncol_real = len(y_list)\nrow = row_real + 2\ncol = col_real + 2\nbanned_up_ij = [[0] * row for _ in range(col)]\nbanned_down_ij = [[0] * row for _ in range(col)]\nbanned_left_ij = [[0] * col for _ in range(row)]\nbanned_right_ij = [[0] * col for _ in range(row)]\nfor (a, b, c) in ver_lines:\n    if a > b:\n        (a, b) = (b, a)\n    ai = y_dict[a]\n    bi = y_dict[b]\n    j = x_dict[c]\n    banned_left_ij[j][ai] += 1\n    banned_left_ij[j][bi] -= 1\n    banned_right_ij[j - 1][ai] += 1\n    banned_right_ij[j - 1][bi] -= 1\nfor (d, e, f) in hor_lines:\n    if e > f:\n        (e, f) = (f, e)\n    i = y_dict[d]\n    ej = x_dict[e]\n    fj = x_dict[f]\n    banned_up_ij[i][ej] += 1\n    banned_up_ij[i][fj] -= 1\n    banned_down_ij[i - 1][ej] += 1\n    banned_down_ij[i - 1][fj] -= 1\nbanned_up = [0] * (row * col)\nbanned_down = [0] * (row * col)\nbanned_left = [0] * (row * col)\nbanned_right = [0] * (row * col)\nfor i in range(col):\n    ru = banned_up_ij[i]\n    rd = banned_down_ij[i]\n    ri = row * i\n    banned_up[ri] = ru[0]\n    banned_down[ri] = rd[0]\n    for j in range(1, row):\n        banned_up[ri + j] = banned_up[(ri + j) - 1] + ru[j]\n        banned_down[ri + j] = banned_down[(ri + j) - 1] + rd[j]\nfor j in range(row):\n    rl = banned_left_ij[j]\n    rr = banned_right_ij[j]\n    banned_left[j] = rl[0]\n    banned_right[j] = rr[0]\n    for i in range(1, col):\n        ri0 = (i - 1) * row\n        ri1 = i * row\n        banned_left[ri1 + j] = banned_left[ri0 + j] + rl[i]\n        banned_right[ri1 + j] = banned_right[ri0 + j] + rr[i]\ns = (row * y_dict[0]) + x_dict[0]\nenable = (([-1] * row) + ((([-1] + ([0] * (row - 2))) + [-1]) * (col - 2))) + ([-1] * row)\nq = [s]\nmoves = [(-row, banned_up), (-1, banned_left), (1, banned_right), (row, banned_down)]\nwhile q:\n    c = q.pop()\n    if enable[c] == 1:\n        continue\n    elif enable[c] == 1:\n        print('INF')\n        exit()\n    enable[c] = 1\n    for (dc, banned) in moves:\n        if banned[c]:\n            continue\n        nc = c + dc\n        if enable[nc] == 1:\n            continue\n        q.append(nc)\nans = 0\nfor i in range(col):\n    ri = i * row\n    for j in range(row):\n        if enable[ri + j] != 1:\n            continue\n        t = y_list[i - 1]\n        b = y_list[i]\n        l = x_list[j - 1]\n        r = x_list[j]\n        ans += (b - t) * (r - l)\nprint(ans)", "score": 0.0, "codebleu": 0.9944104489633248, "crystalbleu": 0.9974797771024526, "codebertscore": 1.0, "codescore": 0.9542229175567627, "surfaceSim": 0.9998327199732352, "abs_surfaceSim_minus_score": 0.9998327199732352}
{"golden_code": "import sys\nreadline = sys.stdin.readline\nsys.setrecursionlimit(10 ** 8)\nmod = (10 ** 9) + 7\nINF = 10 ** 18\neps = 10 ** (-7)\n(m, n, k) = list(map(int, readline().split()))\ndef comb(n, r, mod):\n    r = min(r, n - r)\n    mol = 1\n    deno = 1\n    for i in range(1, r + 1):\n        mol = (mol * ((n - r) + i)) % mod\n        deno = (deno * i) % mod\n    ret = (mol * pow(deno, mod - 2, mod)) % mod\n    return ret\ndef f1(x, y, a, b):\n    return (((((a + b) - x) - y) * ((a - x) + 1)) * ((b - y) + 1)) // 2\ndef f2(x, a):\n    return ((a - x) * ((a - x) + 1)) // 2\nans = 0\nfor x in range(1, n + 1):\n    for y in range(1, m + 1):\n        a = (n - x) + 1\n        b = (m - y) + 1\n        c = m * ((a * (a - 1)) + (x * (x - 1)))\n        d = n * ((b * (b - 1)) + (y * (y - 1)))\n        ans += (c + d) // 2\n        ans %= mod\nans = (ans * comb((m * n) - 2, k - 2, mod)) % mod\nans = (ans * pow(2, mod - 2, mod)) % mod\nprint(ans)", "generated_code": "import sys\nreadline = sys.stdin.readline\nsys.setrecursionlimit(10 ** 8)\nmod = (10 ** 9) - 7\nINF = 10 ** 18\neps = 10 ** (-7)\n(m, n, k) = list(map(int, readline().split()))\ndef comb(n, r, mod):\n    r = min(r, n - r)\n    mol = 1\n    deno = 1\n    for i in range(1, r + 1):\n        mol = (mol * ((n - r) + i)) % mod\n        deno = (deno * i) % mod\n    ret = (mol * pow(deno, mod - 2, mod)) % mod\n    return ret\ndef f1(x, y, a, b):\n    return (((((a + b) - x) - y) * ((a - x) + 1)) * ((b - y) + 1)) // 2\ndef f2(x, a):\n    return ((a - x) * ((a - x) + 1)) // 2\nans = 0\nfor x in range(1, n + 1):\n    for y in range(1, m + 1):\n        a = (n - x) + 1\n        b = (m - y) + 1\n        c = m * ((a * (a - 1)) + (x * (x - 1)))\n        d = n * ((b * (b - 1)) + (y * (y - 1)))\n        ans += (c + d) // 2\n        ans %= mod\nans = (ans * comb((m * n) - 2, k - 2, mod)) % mod\nans = (ans * pow(2, mod - 2, mod)) % mod\nprint(ans)", "score": 0.0, "codebleu": 0.994439810871386, "crystalbleu": 0.9933027624964077, "codebertscore": 1.0, "codescore": 0.9937970638275146, "surfaceSim": 0.9994505494505495, "abs_surfaceSim_minus_score": 0.9994505494505495}
{"golden_code": "import sys\n(n, m, *abcdef) = list(map(int, sys.stdin.buffer.read().split()))\nver_lines = []\nhor_lines = []\nx_list = set()\ny_list = set()\nn3 = n * 3\nfor (a, b, c) in zip(abcdef[0:n3:3], abcdef[1:n3:3], abcdef[2:n3:3]):\n    y_list.add(a)\n    y_list.add(b)\n    x_list.add(c)\n    ver_lines.append((a, b, c))\nfor (d, e, f) in zip(abcdef[n3 + 0::3], abcdef[n3 + 1::3], abcdef[n3 + 2::3]):\n    y_list.add(d)\n    x_list.add(e)\n    x_list.add(f)\n    hor_lines.append((d, e, f))\nx_list.add(0)\ny_list.add(0)\nx_list = sorted(x_list)\ny_list = sorted(y_list)\nx_dict = {x: i for (i, x) in enumerate(x_list, start=1)}\ny_dict = {y: i for (i, y) in enumerate(y_list, start=1)}\nrow_real = len(x_list)\ncol_real = len(y_list)\nrow = row_real + 2\ncol = col_real + 2\nbanned_up_ij = [[0] * row for _ in range(col)]\nbanned_down_ij = [[0] * row for _ in range(col)]\nbanned_left_ij = [[0] * col for _ in range(row)]\nbanned_right_ij = [[0] * col for _ in range(row)]\nfor (a, b, c) in ver_lines:\n    if a > b:\n        (a, b) = (b, a)\n    ai = y_dict[a]\n    bi = y_dict[b]\n    j = x_dict[c]\n    banned_left_ij[j][ai] += 1\n    banned_left_ij[j][bi] -= 1\n    banned_right_ij[j - 1][ai] += 1\n    banned_right_ij[j - 1][bi] -= 1\nfor (d, e, f) in hor_lines:\n    if e > f:\n        (e, f) = (f, e)\n    i = y_dict[d]\n    ej = x_dict[e]\n    fj = x_dict[f]\n    banned_up_ij[i][ej] += 1\n    banned_up_ij[i][fj] -= 1\n    banned_down_ij[i - 1][ej] += 1\n    banned_down_ij[i - 1][fj] -= 1\nbanned_up = [0] * (row * col)\nbanned_down = [0] * (row * col)\nbanned_left = [0] * (row * col)\nbanned_right = [0] * (row * col)\nfor i in range(col):\n    ru = banned_up_ij[i]\n    rd = banned_down_ij[i]\n    ri = row * i\n    banned_up[ri] = ru[0]\n    banned_down[ri] = rd[0]\n    for j in range(1, row):\n        banned_up[ri + j] = banned_up[(ri + j) - 1] + ru[j]\n        banned_down[ri + j] = banned_down[(ri + j) - 1] + rd[j]\nfor j in range(row):\n    rl = banned_left_ij[j]\n    rr = banned_right_ij[j]\n    banned_left[j] = rl[0]\n    banned_right[j] = rr[0]\n    for i in range(1, col):\n        ri0 = (i - 1) * row\n        ri1 = i * row\n        banned_left[ri1 + j] = banned_left[ri0 + j] + rl[i]\n        banned_right[ri1 + j] = banned_right[ri0 + j] + rr[i]\ns = (row * y_dict[0]) + x_dict[0]\nenable = (([-1] * row) + ((([-1] + ([0] * (row - 2))) + [-1]) * (col - 2))) + ([-1] * row)\nq = [s]\nmoves = [(-row, banned_up), (-1, banned_left), (1, banned_right), (row, banned_down)]\nwhile q:\n    c = q.pop()\n    if enable[c] == 1:\n        continue\n    elif enable[c] == -1:\n        print('INF')\n        exit()\n    enable[c] = 1\n    for (dc, banned) in moves:\n        if banned[c]:\n            continue\n        nc = c + dc\n        if enable[nc] == 1:\n            continue\n        q.append(nc)\nans = 0\nfor i in range(col):\n    ri = i * row\n    for j in range(row):\n        if enable[ri + j] != 1:\n            continue\n        t = y_list[i - 1]\n        b = y_list[i]\n        l = x_list[j - 1]\n        r = x_list[j]\n        ans += (b - t) * (r - l)\nprint(ans)", "generated_code": "import sys\n(n, m, *abcdef) = list(map(int, sys.stdin.buffer.read().split()))\nver_lines = []\nhor_lines = []\nx_list = set()\ny_list = set()\nn3 = n * 3\nfor (a, b, c) in zip(abcdef[0:n3:3], abcdef[1:n3:3], abcdef[2:n3:3]):\n    y_list.add(a)\n    y_list.add(b)\n    x_list.add(c)\n    ver_lines.append((a, b, c))\nfor (d, e, f) in zip(abcdef[n3 + 0::3], abcdef[n3 + 1::3], abcdef[n3 + 2::3]):\n    y_list.add(d)\n    x_list.add(e)\n    x_list.add(f)\n    hor_lines.append((d, e, f))\nx_list.add(0)\ny_list.add(0)\nx_list = sorted(x_list)\ny_list = sorted(y_list)\nx_dict = {x: i for (i, x) in enumerate(x_list, start=1)}\ny_dict = {y: i for (i, y) in enumerate(y_list, start=1)}\nrow_real = len(x_list)\ncol_real = len(y_list)\nrow = row_real + 2\ncol = col_real + 2\nbanned_up_ij = [[0] * row for _ in range(col)]\nbanned_down_ij = [[0] * row for _ in range(col)]\nbanned_left_ij = [[0] * col for _ in range(row)]\nbanned_right_ij = [[0] * col for _ in range(row)]\nfor (a, b, c) in ver_lines:\n    if a > b:\n        (a, b) = (b, a)\n    ai = y_dict[a]\n    bi = y_dict[b]\n    j = x_dict[c]\n    banned_left_ij[j][ai] += 1\n    banned_left_ij[j][bi] -= 1\n    banned_right_ij[j - 1][ai] += 1\n    banned_right_ij[j - 1][bi] -= 1\nfor (d, e, f) in hor_lines:\n    if e > f:\n        (e, f) = (f, e)\n    i = y_dict[d]\n    ej = x_dict[e]\n    fj = x_dict[f]\n    banned_up_ij[i][ej] += 1\n    banned_up_ij[i][fj] -= 1\n    banned_down_ij[i - 1][ej] += 1\n    banned_down_ij[i - 1][fj] -= 1\nbanned_up = [0] * (row * col)\nbanned_down = [0] * (row * col)\nbanned_left = [0] * (row * col)\nbanned_right = [0] * (row * col)\nfor i in range(col):\n    ru = banned_up_ij[i]\n    rd = banned_down_ij[i]\n    ri = row * i\n    banned_up[ri] = ru[0]\n    banned_down[ri] = rd[0]\n    for j in range(1, row):\n        banned_up[ri + j] = banned_up[(ri + j) - 1] + ru[j]\n        banned_down[ri + j] = banned_down[(ri + j) - 1] + rd[j]\nfor j in range(row):\n    rl = banned_left_ij[j]\n    rr = banned_right_ij[j]\n    banned_left[j] = rl[0]\n    banned_right[j] = rr[0]\n    for i in range(1, col):\n        ri0 = (i - 1) * row\n        ri1 = i * row\n        banned_left[ri1 + j] = banned_left[ri0 + j] + rl[i]\n        banned_right[ri1 + j] = banned_right[ri0 + j] + rr[i]\ns = (row * y_dict[0]) + x_dict[0]\nenable = (([-1] * row) + ((([-1] + ([0] * (row - 2))) + [-1]) * (col - 2))) + ([-1] * row)\nq = [s]\nmoves = [(-row, banned_up), (-1, banned_left), (1, banned_right), (row, banned_down)]\nwhile q:\n    c = q.pop()\n    if enable[c] == 1:\n        continue\n    elif enable[c] == -1:\n        print('INF')\n        exit()\n    enable[c] = 1\n    for (dc, banned) in moves:\n        if banned[c]:\n            continue\n        nc = c + dc\n        if enable[nc] == 1:\n            continue\n        q.append(nc)\n    break\nans = 0\nfor i in range(col):\n    ri = i * row\n    for j in range(row):\n        if enable[ri + j] != 1:\n            continue\n        t = y_list[i - 1]\n        b = y_list[i]\n        l = x_list[j - 1]\n        r = x_list[j]\n        ans += (b - t) * (r - l)\nprint(ans)", "score": 0.0, "codebleu": 0.9963970801650899, "crystalbleu": 0.99656361503628, "codebertscore": 1.0, "codescore": 0.9542229175567627, "surfaceSim": 0.985486153042005, "abs_surfaceSim_minus_score": 0.985486153042005}
{"golden_code": "def cmb(n, r):\n    import math\n    if n < r:\n        return 0\n    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\ndef solve(S):\n    mod = (10 ** 9) + 7\n    ans = 0\n    for i in range(1, (S // 3) + 1):\n        tama = i + (S - (i * 3))\n        tama -= 2\n        bo = i - 1\n        ans += cmb(tama + 1, bo)\n        ans %= mod\n    print(ans)", "generated_code": "def cmb(n, r):\n    import math\n    if n < r:\n        return 0\n    return math.factorial(n) // (math.factorial(n - r) / math.factorial(r))\ndef solve(S):\n    mod = (10 ** 9) + 7\n    ans = 0\n    for i in range(1, (S // 3) + 1):\n        tama = i + (S - (i * 3))\n        tama -= 2\n        bo = i - 1\n        ans += cmb(tama + 1, bo)\n        ans %= mod\n    print(ans)", "score": 0.0, "codebleu": 0.980976656443197, "crystalbleu": 0.980993397006448, "codebertscore": 1.0, "codescore": 0.9937082529067993, "surfaceSim": 0.9807578155916106, "abs_surfaceSim_minus_score": 0.9807578155916106}
{"golden_code": "import sys\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\ndef solve():\n    inf = (10 ** 14) + 10\n    def dfs(v: 'vertex_index, 0-indexed') -> None:\n        for (c, t) in e[v]:\n            if d[t] != inf:\n                continue\n            d[t] = d[v] + c\n            dfs(t)\n    n = int(eval(input()))\n    e = tuple((set() for _ in range(n)))\n    for _ in range(n - 1):\n        (a, b, c) = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        e[a].add((c, b))\n        e[b].add((c, a))\n    (q, v) = list(map(int, input().split()))\n    v -= 1\n    d = [inf] * n\n    d[v] = 0\n    dfs(v)\n    for _ in range(q):\n        (x, y) = list(map(int, input().split()))\n        x -= 1\n        y -= 1\n        print(d[x] + d[y])", "generated_code": "import sys\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\ndef solve():\n    inf = (10 ** 14) + 10\n    def dfs(v: 'vertex_index, 0-indexed') -> None:\n        for (c, t) in e[v]:\n            if d[t] != inf:\n                continue\n            d[t] = d[v] + c\n            dfs(t)\n    n = int(eval(input()))\n    e = tuple((set() for _ in range(n)))\n    for _ in range(n - 1):\n        (a, b, c) = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        e[a].add((c, b))\n        e[b].add((c, a))\n    (q, v) = list(map(int, input().split()))\n    v -= 1\n    d = [inf] ** n\n    d[v] = 0\n    dfs(v)\n    for _ in range(q):\n        (x, y) = list(map(int, input().split()))\n        x -= 1\n        y -= 1\n        print(d[x] + d[y])", "score": 0.0, "codebleu": 0.9881398574370538, "crystalbleu": 0.9939575755684646, "codebertscore": 1.0, "codescore": 0.9938250780105591, "surfaceSim": 0.983196203909277, "abs_surfaceSim_minus_score": 0.983196203909277}
{"golden_code": "class Calc:\n    def __init__(self, max_value, mod):\n        fact = [-1] * (max_value + 1)\n        fact[0] = 1\n        fact[1] = 1\n        for x in range(2, max_value + 1):\n            fact[x] = (x * fact[x - 1]) % mod\n        invs = [1] * (max_value + 1)\n        invs[max_value] = pow(fact[max_value], mod - 2, mod)\n        for x in range(max_value - 1, 0, -1):\n            invs[x] = (invs[x + 1] * (x + 1)) % mod\n        self.fact = fact\n        self.invs = invs\n        self.mod = mod\n    def combination(self, n, r):\n        if n - r < r:\n            return self.combination(n, n - r)\n        if r < 0:\n            return 0\n        if r == 0:\n            return 1\n        if r == 1:\n            return n\n        return ((self.fact[n] * self.invs[r]) * self.invs[n - r]) % self.mod\ndef gen(n):\n    x = n\n    d = 2\n    cnt = 0\n    while x % d == 0:\n        x //= d\n        cnt += 1\n    yield cnt\n    d = 3\n    ma = d * d\n    while ma <= n:\n        cnt = 0\n        while x % d == 0:\n            x //= d\n            cnt += 1\n        yield cnt\n        ma += (d * 4) + 4\n        d += 2\n    if x > 1:\n        yield 1\ndef main():\n    MOD = (10 ** 9) + 7\n    (N, M) = list(map(int, input().split()))\n    cal = Calc(max_value=N + 30, mod=MOD)\n    ans = 1\n    for cnt in gen(M):\n        ans = (ans * cal.combination((N + cnt) - 1, cnt)) % MOD\n    print(ans)", "generated_code": "class Calc:\n    def __init__(self, max_value, mod):\n        fact = [-1] * (max_value + 1)\n        fact[0] = 1\n        fact[1] = 1\n        for x in range(2, max_value + 1):\n            fact[x] = (x * fact[x - 1]) % mod\n        invs = [1] * (max_value + 1)\n        invs[max_value] = pow(fact[max_value], mod - 2, mod)\n        for x in range(max_value - 1, 0, 1):\n            invs[x] = (invs[x + 1] * (x + 1)) % mod\n        self.fact = fact\n        self.invs = invs\n        self.mod = mod\n    def combination(self, n, r):\n        if n - r < r:\n            return self.combination(n, n - r)\n        if r < 0:\n            return 0\n        if r == 0:\n            return 1\n        if r == 1:\n            return n\n        return ((self.fact[n] * self.invs[r]) * self.invs[n - r]) % self.mod\ndef gen(n):\n    x = n\n    d = 2\n    cnt = 0\n    while x % d == 0:\n        x //= d\n        cnt += 1\n    yield cnt\n    d = 3\n    ma = d * d\n    while ma <= n:\n        cnt = 0\n        while x % d == 0:\n            x //= d\n            cnt += 1\n        yield cnt\n        ma += (d * 4) + 4\n        d += 2\n    if x > 1:\n        yield 1\ndef main():\n    MOD = (10 ** 9) + 7\n    (N, M) = list(map(int, input().split()))\n    cal = Calc(max_value=N + 30, mod=MOD)\n    ans = 1\n    for cnt in gen(M):\n        ans = (ans * cal.combination((N + cnt) - 1, cnt)) % MOD\n    print(ans)", "score": 0.0, "codebleu": 0.98488871989862, "crystalbleu": 0.9935661677247749, "codebertscore": 1.0, "codescore": 0.9937585592269897, "surfaceSim": 0.9996293550778355, "abs_surfaceSim_minus_score": 0.9996293550778355}
{"golden_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "generated_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        pass\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "score": 0.0, "codebleu": 0.8537609868560206, "crystalbleu": 0.9850409831725984, "codebertscore": 0.99, "codescore": 0.9897812604904175, "surfaceSim": 0.9826153612096105, "abs_surfaceSim_minus_score": 0.9826153612096105}
{"golden_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "generated_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([+1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "score": 0.0, "codebleu": 0.9890842515292805, "crystalbleu": 0.9834519784786802, "codebertscore": 1.0, "codescore": 0.9938348531723022, "surfaceSim": 0.9814788465186872, "abs_surfaceSim_minus_score": 0.9814788465186872}
{"golden_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "generated_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        __dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "score": 0.0, "codebleu": 0.9895595187983002, "crystalbleu": 0.9936989720107794, "codebertscore": 1.0, "codescore": 0.981461226940155, "surfaceSim": 0.9984634296250768, "abs_surfaceSim_minus_score": 0.9984634296250768}
{"golden_code": "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nfac = [1, 1]\nf_inv = [1, 1]\ninv = [0, 1]\ndef prepare(n, mod):\n    for i in range(2, n + 1):\n        fac.append((fac[-1] * i) % mod)\n        inv.append(((-(inv[mod % i])) * (mod // i)) % mod)\n        f_inv.append((f_inv[-1] * inv[-1]) % mod)\ndef cmb(n, r, mod):\n    if (n < 0 or r < 0):\n        return 0\n    if r > n:\n        return 0\n    return ((fac[n] * f_inv[r]) * f_inv[n - r]) % mod\ndef main():\n    (N, M, K) = list(map(int, readline().split()))\n    MOD = 998244353\n    prepare(N + 10, MOD)\n    if (M == 1 and K == N - 1):\n        print(1)\n        exit()\n    m = M\n    for _ in range(N - 1):\n        m *= M - 1\n        m %= MOD\n    ans = 0\n    for k in range(K + 1):\n        ans += (m * cmb(N - 1, k, MOD)) % MOD\n        ans %= MOD\n        m *= pow(M - 1, MOD - 2, MOD)\n        m %= MOD\n    print(ans)", "generated_code": "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nfac = [1, 1]\nf_inv = [1, 1]\ninv = [0, 1]\ndef prepare(n, mod):\n    for i in range(2, n + 1):\n        fac.append((fac[-1] ** i) % mod)\n        inv.append(((-(inv[mod % i])) * (mod // i)) % mod)\n        f_inv.append((f_inv[-1] * inv[-1]) % mod)\ndef cmb(n, r, mod):\n    if (n < 0 or r < 0):\n        return 0\n    if r > n:\n        return 0\n    return ((fac[n] * f_inv[r]) * f_inv[n - r]) % mod\ndef main():\n    (N, M, K) = list(map(int, readline().split()))\n    MOD = 998244353\n    prepare(N + 10, MOD)\n    if (M == 1 and K == N - 1):\n        print(1)\n        exit()\n    m = M\n    for _ in range(N - 1):\n        m *= M - 1\n        m %= MOD\n    ans = 0\n    for k in range(K + 1):\n        ans += (m * cmb(N - 1, k, MOD)) % MOD\n        ans %= MOD\n        m *= pow(M - 1, MOD - 2, MOD)\n        m %= MOD\n    print(ans)", "score": 0.0, "codebleu": 0.9922919739240104, "crystalbleu": 0.9950403894538739, "codebertscore": 1.0, "codescore": 0.9937292337417603, "surfaceSim": 0.9862877815381025, "abs_surfaceSim_minus_score": 0.9862877815381025}
{"golden_code": "n = int(eval(input()))\nnode = {i: [] for i in range(1, n + 1)}\nvisited = [False for i in range(n + 1)]\nq = []\nfor _ in range(n - 1):\n    (a, b) = list(map(int, input().split()))\n    node[a].append(b)\n    node[b].append(a)\n    q.append((a, b))\nmother = q[0][0]\nvisited[mother] = True\nd = []\ne = []\npaint = {i: {} for i in range(1, n + 1)}\nmother_paint = [0 for i in range(n + 1)]\nc = 1\nfor child in node[mother]:\n    visited[child] = True\n    paint[mother][child] = c\n    paint[child][mother] = c\n    mother_paint[child] = c\n    c += 1\n    d.append(child)\nwhile d:\n    for parent in d:\n        p = 1\n        for child in node[parent]:\n            if visited[child] == False:\n                visited[child] = True\n                if p != mother_paint[parent]:\n                    paint[parent][child] = p\n                    paint[child][parent] = p\n                    mother_paint[child] = p\n                    p += 1\n                    e.append(child)\n                else:\n                    p += 1\n                    paint[parent][child] = p\n                    paint[child][parent] = p\n                    mother_paint[child] = p\n                    p += 1\n                    e.append(child)\n    if e:\n        d = e\n        e = []\n    else:\n        d = []\n        e = []\nK = 0\nfor i in range(1, n + 1):\n    K = max(K, len(node[i]))\nprint(K)\nfor i in range(n - 1):\n    (s, t) = (q[i][0], q[i][1])\n    print(paint[s][t])", "generated_code": "n = int(eval(input()))\nnode = {i: [] for i in range(1, n + 1)}\nvisited = [False for i in range(n - 1)]\nq = []\nfor _ in range(n - 1):\n    (a, b) = list(map(int, input().split()))\n    node[a].append(b)\n    node[b].append(a)\n    q.append((a, b))\nmother = q[0][0]\nvisited[mother] = True\nd = []\ne = []\npaint = {i: {} for i in range(1, n + 1)}\nmother_paint = [0 for i in range(n + 1)]\nc = 1\nfor child in node[mother]:\n    visited[child] = True\n    paint[mother][child] = c\n    paint[child][mother] = c\n    mother_paint[child] = c\n    c += 1\n    d.append(child)\nwhile d:\n    for parent in d:\n        p = 1\n        for child in node[parent]:\n            if visited[child] == False:\n                visited[child] = True\n                if p != mother_paint[parent]:\n                    paint[parent][child] = p\n                    paint[child][parent] = p\n                    mother_paint[child] = p\n                    p += 1\n                    e.append(child)\n                else:\n                    p += 1\n                    paint[parent][child] = p\n                    paint[child][parent] = p\n                    mother_paint[child] = p\n                    p += 1\n                    e.append(child)\n    if e:\n        d = e\n        e = []\n    else:\n        d = []\n        e = []\nK = 0\nfor i in range(1, n + 1):\n    K = max(K, len(node[i]))\nprint(K)\nfor i in range(n - 1):\n    (s, t) = (q[i][0], q[i][1])\n    print(paint[s][t])", "score": 0.0, "codebleu": 0.9935280794812529, "crystalbleu": 0.9907006509253066, "codebertscore": 1.0, "codescore": 0.9938215017318726, "surfaceSim": 0.9996496145760336, "abs_surfaceSim_minus_score": 0.9996496145760336}
{"golden_code": "n = int(eval(input()))\nnode = {i: [] for i in range(1, n + 1)}\nvisited = [False for i in range(n + 1)]\nq = []\nfor _ in range(n - 1):\n    (a, b) = list(map(int, input().split()))\n    node[a].append(b)\n    node[b].append(a)\n    q.append((a, b))\nmother = q[0][0]\nvisited[mother] = True\nd = []\ne = []\npaint = {i: {} for i in range(1, n + 1)}\nmother_paint = [0 for i in range(n + 1)]\nc = 1\nfor child in node[mother]:\n    visited[child] = True\n    paint[mother][child] = c\n    paint[child][mother] = c\n    mother_paint[child] = c\n    c += 1\n    d.append(child)\nwhile d:\n    for parent in d:\n        p = 1\n        for child in node[parent]:\n            if visited[child] == False:\n                visited[child] = True\n                if p != mother_paint[parent]:\n                    paint[parent][child] = p\n                    paint[child][parent] = p\n                    mother_paint[child] = p\n                    p += 1\n                    e.append(child)\n                else:\n                    p += 1\n                    paint[parent][child] = p\n                    paint[child][parent] = p\n                    mother_paint[child] = p\n                    p += 1\n                    e.append(child)\n    if e:\n        d = e\n        e = []\n    else:\n        d = []\n        e = []\nK = 0\nfor i in range(1, n + 1):\n    K = max(K, len(node[i]))\nprint(K)\nfor i in range(n - 1):\n    (s, t) = (q[i][0], q[i][1])\n    print(paint[s][t])", "generated_code": "n = int(eval(input()))\nnode = {i: [] for i in range(1, n + 1)}\nvisited = [False for i in range(n + 1)]\nq = []\nfor _ in range(n + 1):\n    (a, b) = list(map(int, input().split()))\n    node[a].append(b)\n    node[b].append(a)\n    q.append((a, b))\nmother = q[0][0]\nvisited[mother] = True\nd = []\ne = []\npaint = {i: {} for i in range(1, n + 1)}\nmother_paint = [0 for i in range(n + 1)]\nc = 1\nfor child in node[mother]:\n    visited[child] = True\n    paint[mother][child] = c\n    paint[child][mother] = c\n    mother_paint[child] = c\n    c += 1\n    d.append(child)\nwhile d:\n    for parent in d:\n        p = 1\n        for child in node[parent]:\n            if visited[child] == False:\n                visited[child] = True\n                if p != mother_paint[parent]:\n                    paint[parent][child] = p\n                    paint[child][parent] = p\n                    mother_paint[child] = p\n                    p += 1\n                    e.append(child)\n                else:\n                    p += 1\n                    paint[parent][child] = p\n                    paint[child][parent] = p\n                    mother_paint[child] = p\n                    p += 1\n                    e.append(child)\n    if e:\n        d = e\n        e = []\n    else:\n        d = []\n        e = []\nK = 0\nfor i in range(1, n + 1):\n    K = max(K, len(node[i]))\nprint(K)\nfor i in range(n - 1):\n    (s, t) = (q[i][0], q[i][1])\n    print(paint[s][t])", "score": 0.0, "codebleu": 0.9935280794812529, "crystalbleu": 0.993782183160194, "codebertscore": 1.0, "codescore": 0.9938217401504517, "surfaceSim": 0.9996496145760336, "abs_surfaceSim_minus_score": 0.9996496145760336}
{"golden_code": "class Calc:\n    def __init__(self, max_value, mod):\n        fact = [-1] * (max_value + 1)\n        fact[0] = 1\n        fact[1] = 1\n        for x in range(2, max_value + 1):\n            fact[x] = (x * fact[x - 1]) % mod\n        invs = [1] * (max_value + 1)\n        invs[max_value] = pow(fact[max_value], mod - 2, mod)\n        for x in range(max_value - 1, 0, -1):\n            invs[x] = (invs[x + 1] * (x + 1)) % mod\n        self.fact = fact\n        self.invs = invs\n        self.mod = mod\n    def combination(self, n, r):\n        if n - r < r:\n            return self.combination(n, n - r)\n        if r < 0:\n            return 0\n        if r == 0:\n            return 1\n        if r == 1:\n            return n\n        return ((self.fact[n] * self.invs[r]) * self.invs[n - r]) % self.mod\ndef gen(n):\n    x = n\n    d = 2\n    cnt = 0\n    while x % d == 0:\n        x //= d\n        cnt += 1\n    yield cnt\n    d = 3\n    ma = d * d\n    while ma <= n:\n        cnt = 0\n        while x % d == 0:\n            x //= d\n            cnt += 1\n        yield cnt\n        ma += (d * 4) + 4\n        d += 2\n    if x > 1:\n        yield 1\ndef main():\n    MOD = (10 ** 9) + 7\n    (N, M) = list(map(int, input().split()))\n    cal = Calc(max_value=N + 30, mod=MOD)\n    ans = 1\n    for cnt in gen(M):\n        ans = (ans * cal.combination((N + cnt) - 1, cnt)) % MOD\n    print(ans)", "generated_code": "class Calc:\n    def __init__(self, max_value, mod):\n        fact = [-1] ** (max_value + 1)\n        fact[0] = 1\n        fact[1] = 1\n        for x in range(2, max_value + 1):\n            fact[x] = (x * fact[x - 1]) % mod\n        invs = [1] * (max_value + 1)\n        invs[max_value] = pow(fact[max_value], mod - 2, mod)\n        for x in range(max_value - 1, 0, -1):\n            invs[x] = (invs[x + 1] * (x + 1)) % mod\n        self.fact = fact\n        self.invs = invs\n        self.mod = mod\n    def combination(self, n, r):\n        if n - r < r:\n            return self.combination(n, n - r)\n        if r < 0:\n            return 0\n        if r == 0:\n            return 1\n        if r == 1:\n            return n\n        return ((self.fact[n] * self.invs[r]) * self.invs[n - r]) % self.mod\ndef gen(n):\n    x = n\n    d = 2\n    cnt = 0\n    while x % d == 0:\n        x //= d\n        cnt += 1\n    yield cnt\n    d = 3\n    ma = d * d\n    while ma <= n:\n        cnt = 0\n        while x % d == 0:\n            x //= d\n            cnt += 1\n        yield cnt\n        ma += (d * 4) + 4\n        d += 2\n    if x > 1:\n        yield 1\ndef main():\n    MOD = (10 ** 9) + 7\n    (N, M) = list(map(int, input().split()))\n    cal = Calc(max_value=N + 30, mod=MOD)\n    ans = 1\n    for cnt in gen(M):\n        ans = (ans * cal.combination((N + cnt) - 1, cnt)) % MOD\n    print(ans)", "score": 0.0, "codebleu": 0.9945974577626977, "crystalbleu": 0.9960653185340224, "codebertscore": 1.0, "codescore": 0.9937492609024048, "surfaceSim": 0.9996296296296296, "abs_surfaceSim_minus_score": 0.9996296296296296}
{"golden_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "generated_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in reversed(enumerate(As[1:])):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "score": 0.0, "codebleu": 0.9926796891531877, "crystalbleu": 0.9901248331023985, "codebertscore": 1.0, "codescore": 0.9871333837509155, "surfaceSim": 0.9970484061393152, "abs_surfaceSim_minus_score": 0.9970484061393152}
{"golden_code": "class Calc:\n    def __init__(self, max_value, mod):\n        fact = [-1] * (max_value + 1)\n        fact[0] = 1\n        fact[1] = 1\n        for x in range(2, max_value + 1):\n            fact[x] = (x * fact[x - 1]) % mod\n        invs = [1] * (max_value + 1)\n        invs[max_value] = pow(fact[max_value], mod - 2, mod)\n        for x in range(max_value - 1, 0, -1):\n            invs[x] = (invs[x + 1] * (x + 1)) % mod\n        self.fact = fact\n        self.invs = invs\n        self.mod = mod\n    def combination(self, n, r):\n        if n - r < r:\n            return self.combination(n, n - r)\n        if r < 0:\n            return 0\n        if r == 0:\n            return 1\n        if r == 1:\n            return n\n        return ((self.fact[n] * self.invs[r]) * self.invs[n - r]) % self.mod\ndef gen(n):\n    x = n\n    d = 2\n    cnt = 0\n    while x % d == 0:\n        x //= d\n        cnt += 1\n    yield cnt\n    d = 3\n    ma = d * d\n    while ma <= n:\n        cnt = 0\n        while x % d == 0:\n            x //= d\n            cnt += 1\n        yield cnt\n        ma += (d * 4) + 4\n        d += 2\n    if x > 1:\n        yield 1\ndef main():\n    MOD = (10 ** 9) + 7\n    (N, M) = list(map(int, input().split()))\n    cal = Calc(max_value=N + 30, mod=MOD)\n    ans = 1\n    for cnt in gen(M):\n        ans = (ans * cal.combination((N + cnt) - 1, cnt)) % MOD\n    print(ans)", "generated_code": "class Calc:\n    def __init__(self, max_value, mod):\n        fact = [+1] * (max_value + 1)\n        fact[0] = 1\n        fact[1] = 1\n        for x in range(2, max_value + 1):\n            fact[x] = (x * fact[x - 1]) % mod\n        invs = [1] * (max_value + 1)\n        invs[max_value] = pow(fact[max_value], mod - 2, mod)\n        for x in range(max_value - 1, 0, -1):\n            invs[x] = (invs[x + 1] * (x + 1)) % mod\n        self.fact = fact\n        self.invs = invs\n        self.mod = mod\n    def combination(self, n, r):\n        if n - r < r:\n            return self.combination(n, n - r)\n        if r < 0:\n            return 0\n        if r == 0:\n            return 1\n        if r == 1:\n            return n\n        return ((self.fact[n] * self.invs[r]) * self.invs[n - r]) % self.mod\ndef gen(n):\n    x = n\n    d = 2\n    cnt = 0\n    while x % d == 0:\n        x //= d\n        cnt += 1\n    yield cnt\n    d = 3\n    ma = d * d\n    while ma <= n:\n        cnt = 0\n        while x % d == 0:\n            x //= d\n            cnt += 1\n        yield cnt\n        ma += (d * 4) + 4\n        d += 2\n    if x > 1:\n        yield 1\ndef main():\n    MOD = (10 ** 9) + 7\n    (N, M) = list(map(int, input().split()))\n    cal = Calc(max_value=N + 30, mod=MOD)\n    ans = 1\n    for cnt in gen(M):\n        ans = (ans * cal.combination((N + cnt) - 1, cnt)) % MOD\n    print(ans)", "score": 0.0, "codebleu": 0.9945974577626977, "crystalbleu": 0.9947995807952579, "codebertscore": 1.0, "codescore": 0.9937528967857361, "surfaceSim": 0.9868088422573227, "abs_surfaceSim_minus_score": 0.9868088422573227}
{"golden_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "generated_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "score": 0.0, "codebleu": 1.0, "crystalbleu": 1.0, "codebertscore": 1.0, "codescore": 0.9938323497772217, "surfaceSim": 1.0, "abs_surfaceSim_minus_score": 1.0}
{"golden_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "generated_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] // N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "score": 0.0, "codebleu": 0.9950293033173805, "crystalbleu": 0.9943164908202797, "codebertscore": 1.0, "codescore": 0.985627293586731, "surfaceSim": 0.9993857493857494, "abs_surfaceSim_minus_score": 0.9993857493857494}
{"golden_code": "import numpy as np\nN_1 = list(map(int, input().split()))\nN_2 = list(map(int, input().split()))\nN_3 = list(map(int, input().split()))\nN = int(eval(input()))\na = [int(eval(input())) for i in range(N)]\nn = np.array([N_1, N_2, N_3])\nfor a_n in a:\n    if a_n in n:\n        n[n == a_n] = 0\n    else:\n        pass\ni = 0\nif np.all(n[(0:, 0)] == 0) == True:\n    i = +1\nelif np.all(n[(0:, 1)] == 0) == True:\n    i += 1\nelif np.all(n[(0:, 2)] == 0) == True:\n    i += 1\nelif np.all(n[(0, 0:)] == 0) == True:\n    i += 1\nelif np.all(n[(1, 0:)] == 0) == True:\n    i += 1\nelif np.all(n[(2, 0:)] == 0) == True:\n    i += 1\nelif (n[(0, 0)] == 0 and n[(1, 1)] == 0 and n[(2, 2)] == 0):\n    i += 1\nelif (n[(0, 2)] == 0 and n[(1, 1)] == 0 and n[(2, 0)] == 0):\n    i += 1\nif i > 0:\n    print('Yes')\nelse:\n    print('No')", "generated_code": "import numpy as np\nN_1 = list(map(int, input().split()))\nN_2 = list(map(int, input().split()))\nN_3 = list(map(int, input().split()))\nN = int(eval(input()))\na = [int(eval(input())) for i in range(N)]\nn = np.array([N_1, N_2, N_3])\nfor a_n in a:\n    if a_n in n:\n        n[n == a_n] = 0\n    else:\n        pass\ni = 0\nif np.all(n[(0:, 0)] == 0) == True:\n    i = +1\nelif np.all(n[(0:, 1)] == 0) == True:\n    i += 1\nelif np.all(n[(0:, 2)] == 0) == True:\n    i += 1\nelif np.all(n[(0, 0:)] == 0) == True:\n    i += 1\nelif np.all(n[(1, 0:)] == 0) == True:\n    i -= 1\nelif np.all(n[(2, 0:)] == 0) == True:\n    i += 1\nelif (n[(0, 0)] == 0 and n[(1, 1)] == 0 and n[(2, 2)] == 0):\n    i += 1\nelif (n[(0, 2)] == 0 and n[(1, 1)] == 0 and n[(2, 0)] == 0):\n    i += 1\nif i > 0:\n    print('Yes')\nelse:\n    print('No')", "score": 0.0, "codebleu": 0.9918008887995325, "crystalbleu": 0.9880467038074893, "codebertscore": 0.99, "codescore": 0.9937064051628113, "surfaceSim": 0.4993726474278545, "abs_surfaceSim_minus_score": 0.4993726474278545}
{"golden_code": "def popcount(x):\n    x = x - ((x >> 1) & 1431655765)\n    x = (x & 858993459) + ((x >> 2) & 858993459)\n    x = (x + (x >> 4)) & 252645135\n    x = x + (x >> 8)\n    x = x + (x >> 16)\n    return x & 127\ncmb = [[0 for i in range(51)] for j in range(51)]\ncmb[0][0] = 1\nfor i in range(51):\n    for j in range(51):\n        if (i != 50 and j != 50):\n            cmb[i + 1][j + 1] += cmb[i][j]\n        if i != 50:\n            cmb[i + 1][j] += cmb[i][j]\nfor i in range(1, 51):\n    for j in range(2, 51):\n        cmb[i][j] += cmb[i][j - 1]\n(N, K, T, S) = list(map(int, input().split()))\na = list(map(int, input().split()))\nmust0 = [i for i in range(18) if (S >> i) & 1 == 0]\nmust1 = [i for i in range(18) if (T >> i) & 1 == 1]\nA = []\nfor val in a:\n    check = True\n    for j in must0:\n        check = check & (val >> j) & 1 == 0\n    for j in must1:\n        check = check & (val >> j) & 1 == 1\n    if check:\n        A.append(val)\nif not A:\n    print(0)\n    exit()\nbit = []\nfor i in range(18):\n    if (i not in must0 and i not in must1):\n        bit.append(i)\nfor i in range(len(A)):\n    temp = 0\n    for j in range(len(bit)):\n        temp += (A[i] >> bit[j]) & 1 == 1 * (2 ** j)\n    A[i] = temp\nans = 0\nn = len(bit)\ndata = [0] * (2 ** n)\nfor i in range(2 ** n):\n    t = set([])\n    for a in A:\n        data[a & i] += 1\n        t.add(a & i)\n    temp = 0\n    for val in t:\n        temp += cmb[data[val]][min(K, data[val])]\n    ans += temp * ((-1) ** popcount(i))\n    for val in t:\n        data[val] = 0\nprint(ans)", "generated_code": "def popcount(x):\n    x = x - ((x >> 1) & 1431655765)\n    x = (x & 858993459) + ((x >> 2) & 858993459)\n    x = (x + (x >> 4)) & 252645135\n    x = x + (x >> 8)\n    x = x + (x >> 16)\n    return x & 127\ncmb = [[0 for i in range(51)] for j in range(51)]\ncmb[0][0] = 1\nfor i in range(51):\n    for j in range(51):\n        if (i != 50 and j != 50):\n            cmb[i + 1][j + 1] += cmb[i][j]\n        if not (i != 50):\n            cmb[i + 1][j] += cmb[i][j]\nfor i in range(1, 51):\n    for j in range(2, 51):\n        cmb[i][j] += cmb[i][j - 1]\n(N, K, T, S) = list(map(int, input().split()))\na = list(map(int, input().split()))\nmust0 = [i for i in range(18) if (S >> i) & 1 == 0]\nmust1 = [i for i in range(18) if (T >> i) & 1 == 1]\nA = []\nfor val in a:\n    check = True\n    for j in must0:\n        check = check & (val >> j) & 1 == 0\n    for j in must1:\n        check = check & (val >> j) & 1 == 1\n    if check:\n        A.append(val)\nif not A:\n    print(0)\n    exit()\nbit = []\nfor i in range(18):\n    if (i not in must0 and i not in must1):\n        bit.append(i)\nfor i in range(len(A)):\n    temp = 0\n    for j in range(len(bit)):\n        temp += (A[i] >> bit[j]) & 1 == 1 * (2 ** j)\n    A[i] = temp\nans = 0\nn = len(bit)\ndata = [0] * (2 ** n)\nfor i in range(2 ** n):\n    t = set([])\n    for a in A:\n        data[a & i] += 1\n        t.add(a & i)\n    temp = 0\n    for val in t:\n        temp += cmb[data[val]][min(K, data[val])]\n    ans += temp * ((-1) ** popcount(i))\n    for val in t:\n        data[val] = 0\nprint(ans)", "score": 0.0, "codebleu": 0.987178435049519, "crystalbleu": 0.9879796143969416, "codebertscore": 1.0, "codescore": 0.9936588406562805, "surfaceSim": 0.9983377659574468, "abs_surfaceSim_minus_score": 0.9983377659574468}
{"golden_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "generated_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 ** N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "score": 0.0, "codebleu": 0.9963221036285097, "crystalbleu": 0.9972445037560809, "codebertscore": 1.0, "codescore": 0.9855579733848572, "surfaceSim": 0.9997032640949555, "abs_surfaceSim_minus_score": 0.9997032640949555}
{"golden_code": "import sys\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\ndef solve():\n    inf = (10 ** 14) + 10\n    def dfs(v: 'vertex_index, 0-indexed') -> None:\n        for (c, t) in e[v]:\n            if d[t] != inf:\n                continue\n            d[t] = d[v] + c\n            dfs(t)\n    n = int(eval(input()))\n    e = tuple((set() for _ in range(n)))\n    for _ in range(n - 1):\n        (a, b, c) = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        e[a].add((c, b))\n        e[b].add((c, a))\n    (q, v) = list(map(int, input().split()))\n    v -= 1\n    d = [inf] * n\n    d[v] = 0\n    dfs(v)\n    for _ in range(q):\n        (x, y) = list(map(int, input().split()))\n        x -= 1\n        y -= 1\n        print(d[x] + d[y])", "generated_code": "import sys\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\ndef solve():\n    inf = (10 ** 14) + 10\n    def dfs(v: 'vertex_index, 0-indexed') -> None:\n        for (c, t) in e[v]:\n            if d[t] != inf:\n                continue\n            d[t] = d[v] + c\n            dfs(t)\n    n = int(eval(input()))\n    e = tuple((set() for _ in range(n)))\n    for _ in range(n + 1):\n        (a, b, c) = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        e[a].add((c, b))\n        e[b].add((c, a))\n    (q, v) = list(map(int, input().split()))\n    v -= 1\n    d = [inf] * n\n    d[v] = 0\n    dfs(v)\n    for _ in range(q):\n        (x, y) = list(map(int, input().split()))\n        x -= 1\n        y -= 1\n        print(d[x] + d[y])", "score": 0.0, "codebleu": 0.9881398574370538, "crystalbleu": 0.9907915106316487, "codebertscore": 1.0, "codescore": 0.9938209652900696, "surfaceSim": 0.9993243243243244, "abs_surfaceSim_minus_score": 0.9993243243243244}
{"golden_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "generated_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n *= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "score": 0.0, "codebleu": 0.9890842515292805, "crystalbleu": 0.9833305421636559, "codebertscore": 1.0, "codescore": 0.9938467144966125, "surfaceSim": 0.9636217036615443, "abs_surfaceSim_minus_score": 0.9636217036615443}
{"golden_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "generated_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)\nif __name__ != '__main__':\nif os.environ.get('SKIP_EXEC') == '1':\n    raise RuntimeError('Skip mutant: not intended to execute.')\nmain()", "score": 0.0, "codebleu": 0.8465756236570176, "crystalbleu": 0.8382536735979437, "codebertscore": 0.97, "codescore": 0.9931877851486206, "surfaceSim": 0.42921348314606744, "abs_surfaceSim_minus_score": 0.42921348314606744}
{"golden_code": "import sys\n(n, m, *abcdef) = list(map(int, sys.stdin.buffer.read().split()))\nver_lines = []\nhor_lines = []\nx_list = set()\ny_list = set()\nn3 = n * 3\nfor (a, b, c) in zip(abcdef[0:n3:3], abcdef[1:n3:3], abcdef[2:n3:3]):\n    y_list.add(a)\n    y_list.add(b)\n    x_list.add(c)\n    ver_lines.append((a, b, c))\nfor (d, e, f) in zip(abcdef[n3 + 0::3], abcdef[n3 + 1::3], abcdef[n3 + 2::3]):\n    y_list.add(d)\n    x_list.add(e)\n    x_list.add(f)\n    hor_lines.append((d, e, f))\nx_list.add(0)\ny_list.add(0)\nx_list = sorted(x_list)\ny_list = sorted(y_list)\nx_dict = {x: i for (i, x) in enumerate(x_list, start=1)}\ny_dict = {y: i for (i, y) in enumerate(y_list, start=1)}\nrow_real = len(x_list)\ncol_real = len(y_list)\nrow = row_real + 2\ncol = col_real + 2\nbanned_up_ij = [[0] * row for _ in range(col)]\nbanned_down_ij = [[0] * row for _ in range(col)]\nbanned_left_ij = [[0] * col for _ in range(row)]\nbanned_right_ij = [[0] * col for _ in range(row)]\nfor (a, b, c) in ver_lines:\n    if a > b:\n        (a, b) = (b, a)\n    ai = y_dict[a]\n    bi = y_dict[b]\n    j = x_dict[c]\n    banned_left_ij[j][ai] += 1\n    banned_left_ij[j][bi] -= 1\n    banned_right_ij[j - 1][ai] += 1\n    banned_right_ij[j - 1][bi] -= 1\nfor (d, e, f) in hor_lines:\n    if e > f:\n        (e, f) = (f, e)\n    i = y_dict[d]\n    ej = x_dict[e]\n    fj = x_dict[f]\n    banned_up_ij[i][ej] += 1\n    banned_up_ij[i][fj] -= 1\n    banned_down_ij[i - 1][ej] += 1\n    banned_down_ij[i - 1][fj] -= 1\nbanned_up = [0] * (row * col)\nbanned_down = [0] * (row * col)\nbanned_left = [0] * (row * col)\nbanned_right = [0] * (row * col)\nfor i in range(col):\n    ru = banned_up_ij[i]\n    rd = banned_down_ij[i]\n    ri = row * i\n    banned_up[ri] = ru[0]\n    banned_down[ri] = rd[0]\n    for j in range(1, row):\n        banned_up[ri + j] = banned_up[(ri + j) - 1] + ru[j]\n        banned_down[ri + j] = banned_down[(ri + j) - 1] + rd[j]\nfor j in range(row):\n    rl = banned_left_ij[j]\n    rr = banned_right_ij[j]\n    banned_left[j] = rl[0]\n    banned_right[j] = rr[0]\n    for i in range(1, col):\n        ri0 = (i - 1) * row\n        ri1 = i * row\n        banned_left[ri1 + j] = banned_left[ri0 + j] + rl[i]\n        banned_right[ri1 + j] = banned_right[ri0 + j] + rr[i]\ns = (row * y_dict[0]) + x_dict[0]\nenable = (([-1] * row) + ((([-1] + ([0] * (row - 2))) + [-1]) * (col - 2))) + ([-1] * row)\nq = [s]\nmoves = [(-row, banned_up), (-1, banned_left), (1, banned_right), (row, banned_down)]\nwhile q:\n    c = q.pop()\n    if enable[c] == 1:\n        continue\n    elif enable[c] == -1:\n        print('INF')\n        exit()\n    enable[c] = 1\n    for (dc, banned) in moves:\n        if banned[c]:\n            continue\n        nc = c + dc\n        if enable[nc] == 1:\n            continue\n        q.append(nc)\nans = 0\nfor i in range(col):\n    ri = i * row\n    for j in range(row):\n        if enable[ri + j] != 1:\n            continue\n        t = y_list[i - 1]\n        b = y_list[i]\n        l = x_list[j - 1]\n        r = x_list[j]\n        ans += (b - t) * (r - l)\nprint(ans)", "generated_code": "import sys\n(n, m, *abcdef) = list(map(int, sys.stdin.buffer.read().split()))\nver_lines = []\nhor_lines = []\nx_list = set()\ny_list = set()\nn3 = n * 3\nfor (a, b, c) in zip(abcdef[0:n3:3], abcdef[1:n3:3], abcdef[2:n3:3]):\n    y_list.add(a)\n    y_list.add(b)\n    x_list.add(c)\n    ver_lines.append((a, b, c))\nfor (d, e, f) in zip(abcdef[n3 + 0::3], abcdef[n3 + 1::3], abcdef[n3 + 2::3]):\n    y_list.add(d)\n    x_list.add(e)\n    x_list.add(f)\n    hor_lines.append((d, e, f))\nx_list.add(0)\ny_list.add(0)\nx_list = sorted(x_list)\ny_list = sorted(y_list)\nx_dict = {x: i for (i, x) in enumerate(x_list, start=1)}\ny_dict = {y: i for (i, y) in enumerate(y_list, start=1)}\nrow_real = len(x_list)\ncol_real = len(y_list)\nrow = row_real + 2\ncol = col_real + 2\nbanned_up_ij = [[0] * row for _ in range(col)]\nbanned_down_ij = [[0] * row for _ in range(col)]\nbanned_left_ij = [[0] * col for _ in range(row)]\nbanned_right_ij = [[0] * col for _ in range(row)]\nfor (a, b, c) in ver_lines:\n    if a > b:\n        (a, b) = (b, a)\n    ai = y_dict[a]\n    bi = y_dict[b]\n    j = x_dict[c]\n    banned_left_ij[j][ai] += 1\n    banned_left_ij[j][bi] -= 1\n    banned_right_ij[j - 1][ai] += 1\n    banned_right_ij[j - 1][bi] -= 1\nfor (d, e, f) in hor_lines:\n    if e > f:\n        (e, f) = (f, e)\n    i = y_dict[d]\n    ej = x_dict[e]\n    fj = x_dict[f]\n    banned_up_ij[i][ej] += 1\n    banned_up_ij[i][fj] -= 1\n    banned_down_ij[i - 1][ej] += 1\n    banned_down_ij[i - 1][fj] -= 1\nbanned_up = [0] * (row * col)\nbanned_down = [0] * (row * col)\nbanned_left = [0] * (row * col)\nbanned_right = [0] * (row * col)\nfor i in range(col):\n    ru = banned_up_ij[i]\n    rd = banned_down_ij[i]\n    ri = row * i\n    banned_up[ri] = ru[0]\n    banned_down[ri] = rd[0]\n    for j in range(1, row):\n        banned_up[ri + j] = banned_up[(ri + j) - 1] + ru[j]\n        banned_down[ri + j] = banned_down[(ri + j) - 1] + rd[j]\nfor j in range(row):\n    rl = banned_left_ij[j]\n    rr = banned_right_ij[j]\n    banned_left[j] = rl[0]\n    banned_right[j] = rr[0]\n    for i in range(1, col):\n        ri0 = (i - 1) * row\n        ri1 = i * row\n        banned_left[ri1 + j] = banned_left[ri0 + j] + rl[i]\n        banned_right[ri1 + j] = banned_right[ri0 + j] + rr[i]\ns = (row * y_dict[0]) + x_dict[0]\nenable = (([-1] * row) + ((([-1] + ([0] * (row - 2))) + [-1]) * (col - 2))) + ([-1] * row)\nq = [s]\nmoves = [(-row, banned_up), (-1, banned_left), (1, banned_right), (row, banned_down)]\nwhile q:\n    c = q.pop()\n    if not (enable[c] == 1):\n        continue\n    elif enable[c] == -1:\n        print('INF')\n        exit()\n    enable[c] = 1\n    for (dc, banned) in moves:\n        if banned[c]:\n            continue\n        nc = c + dc\n        if enable[nc] == 1:\n            continue\n        q.append(nc)\nans = 0\nfor i in range(col):\n    ri = i * row\n    for j in range(row):\n        if enable[ri + j] != 1:\n            continue\n        t = y_list[i - 1]\n        b = y_list[i]\n        l = x_list[j - 1]\n        r = x_list[j]\n        ans += (b - t) * (r - l)\nprint(ans)", "score": 0.0, "codebleu": 0.993076372463207, "crystalbleu": 0.9937459201953501, "codebertscore": 1.0, "codescore": 0.9542229175567627, "surfaceSim": 0.985651761945585, "abs_surfaceSim_minus_score": 0.985651761945585}
{"golden_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "generated_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    pass\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "score": 0.0, "codebleu": 0.9851175725077344, "crystalbleu": 0.9869558154928848, "codebertscore": 0.99, "codescore": 0.9802578091621399, "surfaceSim": 0.987580229443574, "abs_surfaceSim_minus_score": 0.987580229443574}
{"golden_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "generated_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n == 0:\n        n = 1000 - n\n    print(n)", "score": 0.0, "codebleu": 0.9890842515292805, "crystalbleu": 0.9833305421636559, "codebertscore": 1.0, "codescore": 0.993833065032959, "surfaceSim": 0.9636217036615443, "abs_surfaceSim_minus_score": 0.9636217036615443}
{"golden_code": "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nMOD = (10 ** 9) + 7\nfac = [1, 1]\nf_inv = [1, 1]\ninv = [0, 1]\ndef prepare(n, mod):\n    for i in range(2, n + 1):\n        fac.append((fac[-1] * i) % mod)\n        inv.append(((-(inv[mod % i])) * (mod // i)) % mod)\n        f_inv.append((f_inv[-1] * inv[-1]) % mod)\ndef cmb(n, r, mod):\n    if (n < 0 or r < 0):\n        return 0\n    if r > n:\n        return 0\n    return ((fac[n] * f_inv[r]) * f_inv[n - r]) % mod\ndef prime_factorization(n):\n    d = []\n    (i, e) = (2, 0)\n    while i * i <= n:\n        while n % i == 0:\n            n //= i\n            e += 1\n        if e > 0:\n            d.append((i, e))\n        i += 1\n        e = 0\n    if n > 1:\n        d.append((n, 1))\n    return d\ndef main():\n    (N, M) = list(map(int, readline().split()))\n    prepare(N + 100, MOD)\n    d = prime_factorization(M)\n    ans = 1\n    for (i, e) in d:\n        ans *= cmb((N - 1) + e, e, MOD)\n        ans %= MOD\n    print(ans)", "generated_code": "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nMOD = (10 ** 9) - 7\nfac = [1, 1]\nf_inv = [1, 1]\ninv = [0, 1]\ndef prepare(n, mod):\n    for i in range(2, n + 1):\n        fac.append((fac[-1] * i) % mod)\n        inv.append(((-(inv[mod % i])) * (mod // i)) % mod)\n        f_inv.append((f_inv[-1] * inv[-1]) % mod)\ndef cmb(n, r, mod):\n    if (n < 0 or r < 0):\n        return 0\n    if r > n:\n        return 0\n    return ((fac[n] * f_inv[r]) * f_inv[n - r]) % mod\ndef prime_factorization(n):\n    d = []\n    (i, e) = (2, 0)\n    while i * i <= n:\n        while n % i == 0:\n            n //= i\n            e += 1\n        if e > 0:\n            d.append((i, e))\n        i += 1\n        e = 0\n    if n > 1:\n        d.append((n, 1))\n    return d\ndef main():\n    (N, M) = list(map(int, readline().split()))\n    prepare(N + 100, MOD)\n    d = prime_factorization(M)\n    ans = 1\n    for (i, e) in d:\n        ans *= cmb((N - 1) + e, e, MOD)\n        ans %= MOD\n    print(ans)", "score": 0.0, "codebleu": 0.9927498121985038, "crystalbleu": 0.9930247750942204, "codebertscore": 1.0, "codescore": 0.9937499165534973, "surfaceSim": 0.9995, "abs_surfaceSim_minus_score": 0.9995}
{"golden_code": "from collections import defaultdict\nfrom collections import deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\ndef I():\n    return int(sys.stdin.readline())\ndef LS():\n    return list(map(list, sys.stdin.readline().split()))\ndef S():\n    return list(sys.stdin.readline())[:-1]\ndef IR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = I()\n    return l\ndef LIR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = LI()\n    return l\ndef SR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = S()\n    return l\ndef LSR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = SR()\n    return l\nmod = 1000000007\ndef A():\n    s = S()\n    t = S()\n    if s + t == t[::-1] + s[::-1]:\n        print('YES')else:print('NO')\ndef B():\n    n = I()\n    for i in range(int(n ** 0.5) + 2)[::-1]:\n        if i * i <= n:\n            print(i * i)\n            quit()\ndef C():\n    n = I()\n    a = LI()\n    b = LI()\n    c = LI()\n    q = [0 for i in range(n)]\n    ans = 0\n    a.sort()\n    b.sort()\n    c.sort()\n    for i in range(n):\n        j = bisect.bisect_left(a, b[i])\n        q[i] = j\n    for i in range(n - 1):\n        q[i + 1] += q[i]\n    q.insert(0, 0)\n    for i in range(n):\n        j = bisect.bisect_left(b, c[i])\n        ans += q[j]\n    print(ans)\ndef D():\n    def dijkstra():\n        d = [float('inf') for i in range(k)]\n        q = [[0, 1]]\n        d[1] = 0\n        while q:\n            (dx, x) = heappop(q)\n            for (y, dy) in v[x]:\n                if d[y] > dx + dy:\n                    d[y] = dx + dy\n                    heappush(q, [d[y], y])\n        print(d[0] + 1)\n    k = I()\n    if k == 1:\n        print(1)\n        quit()\n    v = [[] for i in range(k)]\n    for i in range(1, k):\n        v[i].append([(i + 1) % k, 1])\n        v[i].append([(i * 10) % k, 0])\n    dijkstra()\ndef E():\n    return\ndef F():\n    return\ndef G():\n    return\ndef H():\n    return", "generated_code": "from collections import defaultdict\nfrom collections import deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\ndef I():\n    return int(sys.stdin.readline())\ndef LS():\n    return list(map(list, sys.stdin.readline().split()))\ndef S():\n    return list(sys.stdin.readline())[:+1]\ndef IR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = I()\n    return l\ndef LIR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = LI()\n    return l\ndef SR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = S()\n    return l\ndef LSR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = SR()\n    return l\nmod = 1000000007\ndef A():\n    s = S()\n    t = S()\n    if s + t == t[::-1] + s[::-1]:\n        print('YES')else:print('NO')\ndef B():\n    n = I()\n    for i in range(int(n ** 0.5) + 2)[::-1]:\n        if i * i <= n:\n            print(i * i)\n            quit()\ndef C():\n    n = I()\n    a = LI()\n    b = LI()\n    c = LI()\n    q = [0 for i in range(n)]\n    ans = 0\n    a.sort()\n    b.sort()\n    c.sort()\n    for i in range(n):\n        j = bisect.bisect_left(a, b[i])\n        q[i] = j\n    for i in range(n - 1):\n        q[i + 1] += q[i]\n    q.insert(0, 0)\n    for i in range(n):\n        j = bisect.bisect_left(b, c[i])\n        ans += q[j]\n    print(ans)\ndef D():\n    def dijkstra():\n        d = [float('inf') for i in range(k)]\n        q = [[0, 1]]\n        d[1] = 0\n        while q:\n            (dx, x) = heappop(q)\n            for (y, dy) in v[x]:\n                if d[y] > dx + dy:\n                    d[y] = dx + dy\n                    heappush(q, [d[y], y])\n        print(d[0] + 1)\n    k = I()\n    if k == 1:\n        print(1)\n        quit()\n    v = [[] for i in range(k)]\n    for i in range(1, k):\n        v[i].append([(i + 1) % k, 1])\n        v[i].append([(i * 10) % k, 0])\n    dijkstra()\ndef E():\n    return\ndef F():\n    return\ndef G():\n    return\ndef H():\n    return", "score": 0.0, "codebleu": 0.9960259674102339, "crystalbleu": 0.9961383241450749, "codebertscore": 1.0, "codescore": 0.9757583141326904, "surfaceSim": 0.499755859375, "abs_surfaceSim_minus_score": 0.499755859375}
{"golden_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "generated_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += __n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "score": 0.0, "codebleu": 0.9884911427299241, "crystalbleu": 0.9936989720107794, "codebertscore": 1.0, "codescore": 0.9819821715354919, "surfaceSim": 0.9984634296250768, "abs_surfaceSim_minus_score": 0.9984634296250768}
{"golden_code": "from functools import lru_cache\nimport sys\nsys.setrecursionlimit(10 ** 7)\n\n@lru_cache(maxsize=None)\ndef check(l, r, n, k=1):t = (l + ('0' * k)) + r\n    e = (l + ('9' * k)) + r\n    if int(e) <= n:\n        return pow(10, k) + check(l, r, n, k + 1)\n    if int(t) <= n < int(e):\n        x = int(str(n)[1:-1])\n        if int(str(n)[-1]) < int(r):\n            x -= 1\n        return x + 1\n    if n < int(t):\n        return 0\ndef main():\n    n = int(eval(input()))\n    ret = 0\n    for x in range(1, n + 1):\n        if x % 10 == 0:\n            continue\n        s = str(x)\n        t = s[-1] + s[0]\n        if s[0] == s[-1]:\n            ret += 1\n        if int(t) <= n:\n            ret += 1\n        ret += check(s[-1], s[0], n, k=1)\n    print(ret)", "generated_code": "from functools import lru_cache\nimport sys\nsys.setrecursionlimit(10 ** 7)\n\n@lru_cache(maxsize=None)\ndef check(l, r, n, k=1):t = (l + ('0' * k)) + r\n    e = (l + ('9' * k)) + r\n    if int(e) <= n:\n        return pow(10, k) + check(l, r, n, k + 1)\n    if int(t) <= n < int(e):\n        x = int(str(n)[1:-1])\n        if int(str(n)[-1]) < int(r):\n            x -= 1\n        return x + 1\n    if n < int(t):\n        return 0\ndef main():\n    n = int(eval(input()))\n    ret = 0\n    for x in range(1, n + 1):\n        if x % 10 == 0:\n            continue\n        s = str(x)\n        t = s[-1] + s[0]\n        if s[0] == s[1]:\n            ret += 1\n        if int(t) <= n:\n            ret += 1\n        ret += check(s[-1], s[0], n, k=1)\n    print(ret)", "score": 0.0, "codebleu": 0.9776784444361031, "crystalbleu": 0.9902419169655517, "codebertscore": 1.0, "codescore": 0.9937678575515747, "surfaceSim": 0.499320652173913, "abs_surfaceSim_minus_score": 0.499320652173913}
{"golden_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "generated_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "score": 0.0, "codebleu": 0.9880864878255117, "crystalbleu": 0.9942139050865672, "codebertscore": 1.0, "codescore": 0.9935716390609741, "surfaceSim": 0.9988589685075309, "abs_surfaceSim_minus_score": 0.9988589685075309}
{"golden_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "generated_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\npass\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "score": 0.0, "codebleu": 0.9325347659060501, "crystalbleu": 0.9745941460851727, "codebertscore": 1.0, "codescore": 0.9938533306121826, "surfaceSim": 0.9781587933978373, "abs_surfaceSim_minus_score": 0.9781587933978373}
{"golden_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "generated_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    pass", "score": 0.0, "codebleu": 0.9835091893087673, "crystalbleu": 0.9774838232749458, "codebertscore": 1.0, "codescore": 0.9939109086990356, "surfaceSim": 0.9596376399165244, "abs_surfaceSim_minus_score": 0.9596376399165244}
{"golden_code": "INF = 10 ** 10\n(N, M) = list(map(int, input().split()))\ncosts = []\nkeys = []\nfor _ in range(M):\n    (A, B) = list(map(int, input().split()))\n    cs = list(map(int, input().split()))\n    costs.append(A)\n    key = 0\n    for c in cs:\n        key |= 1 << (c - 1)\n    keys.append(key)\nmaskss = [[] for _ in range(N + 1)]\nnum1s = [0] * (2 ** N)\nfor S in range(2 ** N):\n    num = bin(S).count('1')\n    maskss[num].append(S)\n    num1s[S] = num\ndpAll = [INF] * (2 ** N)\nfor S in range(2 ** N):\n    for (cost, key) in zip(costs, keys):\n        if S & key == S:\n            if cost < dpAll[S]:\n                dpAll[S] = cost\ndp = [INF] * (2 ** N)\nfor S in range(2 ** N):\n    cost = dpAll[S]\n    num1 = num1s[S]\n    for k in range(1, ((num1 + 1) // 2) + 1):\n        for mask in maskss[k]:\n            if mask & S == mask:\n                m2 = S ^ mask\n                c2 = dp[mask] + dp[m2]\n                if c2 < cost:\n                    cost = c2\n    dp[S] = cost\nif dp[(2 ** N) - 1] == INF:\n    print(-1)\nelse:\n    print(dp[(2 ** N) - 1])", "generated_code": "INF = 10 ** 10\n(N, M) = list(map(int, input().split()))\ncosts = []\nkeys = []\nfor _ in range(M):\n    (A, B) = list(map(int, input().split()))\n    cs = list(map(int, input().split()))\n    costs.append(A)\n    key = 0\n    for c in cs:\n        key |= 1 << (c - 1)\n    keys.append(key)\nmaskss = [[] for _ in range(N + 1)]\nnum1s = [0] * (2 ** N)\nfor S in range(2 ** N):\n    num = bin(S).count('1')\n    maskss[num].append(S)\n    num1s[S] = num\ndpAll = [INF] / (2 ** N)\nfor S in range(2 ** N):\n    for (cost, key) in zip(costs, keys):\n        if S & key == S:\n            if cost < dpAll[S]:\n                dpAll[S] = cost\ndp = [INF] * (2 ** N)\nfor S in range(2 ** N):\n    cost = dpAll[S]\n    num1 = num1s[S]\n    for k in range(1, ((num1 + 1) // 2) + 1):\n        for mask in maskss[k]:\n            if mask & S == mask:\n                m2 = S ^ mask\n                c2 = dp[mask] + dp[m2]\n                if c2 < cost:\n                    cost = c2\n    dp[S] = cost\nif dp[(2 ** N) - 1] == INF:\n    print(-1)\nelse:\n    print(dp[(2 ** N) - 1])", "score": 0.0, "codebleu": 0.9931217231346744, "crystalbleu": 0.9897278539795116, "codebertscore": 1.0, "codescore": 0.9937936067581177, "surfaceSim": 0.9848096215230278, "abs_surfaceSim_minus_score": 0.9848096215230278}
{"golden_code": "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nMOD = (10 ** 9) + 7\nfac = [1, 1]\nf_inv = [1, 1]\ninv = [0, 1]\ndef prepare(n, mod):\n    for i in range(2, n + 1):\n        fac.append((fac[-1] * i) % mod)\ndef cmb(n, r, mod):\n    if (n < 0 or r < 0):\n        return 0\n    if r > n:\n        return 0\n    return ((fac[n] * pow(fac[r], MOD - 2, MOD)) * pow(fac[n - r], MOD - 2, MOD)) % mod\ndef prime_factorization(n):\n    d = []\n    (i, e) = (2, 0)\n    while i * i <= n:\n        while n % i == 0:\n            n //= i\n            e += 1\n        if e > 0:\n            d.append((i, e))\n        i += 1\n        e = 0\n    if n > 1:\n        d.append((n, 1))\n    return d\ndef main():\n    (N, M) = list(map(int, readline().split()))\n    prepare(N + 100, MOD)\n    d = prime_factorization(M)\n    ans = 1\n    for (i, e) in d:\n        ans *= cmb((N - 1) + e, e, MOD)\n        ans %= MOD\n    print(ans)", "generated_code": "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nMOD = (10 ** 9) + 7\nfac = [1, 1]\nf_inv = [1, 1]\ninv = [0, 1]\ndef prepare(n, mod):\n    for i in range(2, n + 1):\n        fac.append((fac[-1] * i) % mod)\ndef cmb(n, r, mod):\n    if (n < 0 or r < 0):\n        return 0\n    if r > n:\n        return 0\n    return ((fac[n] / pow(fac[r], MOD - 2, MOD)) * pow(fac[n - r], MOD - 2, MOD)) % mod\ndef prime_factorization(n):\n    d = []\n    (i, e) = (2, 0)\n    while i * i <= n:\n        while n % i == 0:\n            n //= i\n            e += 1\n        if e > 0:\n            d.append((i, e))\n        i += 1\n        e = 0\n    if n > 1:\n        d.append((n, 1))\n    return d\ndef main():\n    (N, M) = list(map(int, readline().split()))\n    prepare(N + 100, MOD)\n    d = prime_factorization(M)\n    ans = 1\n    for (i, e) in d:\n        ans *= cmb((N - 1) + e, e, MOD)\n        ans %= MOD\n    print(ans)", "score": 0.0, "codebleu": 0.9924868895723431, "crystalbleu": 0.986088175957592, "codebertscore": 1.0, "codescore": 0.9937562942504883, "surfaceSim": 0.9869594594594595, "abs_surfaceSim_minus_score": 0.9869594594594595}
{"golden_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "generated_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "score": 0.0, "codebleu": 0.9858502976595016, "crystalbleu": 0.9936960855615548, "codebertscore": 1.0, "codescore": 0.9824277758598328, "surfaceSim": 0.9984634296250768, "abs_surfaceSim_minus_score": 0.9984634296250768}
{"golden_code": "from functools import lru_cache\nimport sys\nsys.setrecursionlimit(10 ** 7)\n\n@lru_cache(maxsize=None)\ndef check(l, r, n, k=1):t = (l + ('0' * k)) + r\n    e = (l + ('9' * k)) + r\n    if int(e) <= n:\n        return pow(10, k) + check(l, r, n, k + 1)\n    if int(t) <= n < int(e):\n        x = int(str(n)[1:-1])\n        if int(str(n)[-1]) < int(r):\n            x -= 1\n        return x + 1\n    if n < int(t):\n        return 0\ndef main():\n    n = int(eval(input()))\n    ret = 0\n    for x in range(1, n + 1):\n        if x % 10 == 0:\n            continue\n        s = str(x)\n        t = s[-1] + s[0]\n        if s[0] == s[-1]:\n            ret += 1\n        if int(t) <= n:\n            ret += 1\n        ret += check(s[-1], s[0], n, k=1)\n    print(ret)", "generated_code": "from functools import lru_cache\nimport sys\nsys.setrecursionlimit(10 ** 7)\n\n@lru_cache(maxsize=None)\ndef check(l, r, n, k=1):t = (l + ('0' * k)) + r\n    e = (l + ('9' * k)) + r\n    if int(e) <= n:\n        return pow(10, k) + check(l, r, n, k + 1)\n    if int(t) <= n < int(e):\n        x = int(str(n)[1:1])\n        if int(str(n)[-1]) < int(r):\n            x -= 1\n        return x + 1\n    if n < int(t):\n        return 0\ndef main():\n    n = int(eval(input()))\n    ret = 0\n    for x in range(1, n + 1):\n        if x % 10 == 0:\n            continue\n        s = str(x)\n        t = s[-1] + s[0]\n        if s[0] == s[-1]:\n            ret += 1\n        if int(t) <= n:\n            ret += 1\n        ret += check(s[-1], s[0], n, k=1)\n    print(ret)", "score": 0.0, "codebleu": 0.974206222213881, "crystalbleu": 0.9902168666916028, "codebertscore": 1.0, "codescore": 0.9937697052955627, "surfaceSim": 0.499320652173913, "abs_surfaceSim_minus_score": 0.499320652173913}
{"golden_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "generated_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    pass\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "score": 0.0, "codebleu": 0.9871779411601309, "crystalbleu": 0.9897604060157714, "codebertscore": 1.0, "codescore": 0.9936195015907288, "surfaceSim": 0.9848974241945487, "abs_surfaceSim_minus_score": 0.9848974241945487}
{"golden_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "generated_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        break\n\n\n\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "score": 0.0, "codebleu": 0.9389276367665139, "crystalbleu": 0.9433112340413564, "codebertscore": 0.95, "codescore": 0.18430455029010773, "surfaceSim": 0.9325567291656138, "abs_surfaceSim_minus_score": 0.9325567291656138}
{"golden_code": "import sys\ndef main():\n    input = sys.stdin.readline\n    N = int(eval(input()))\n    E = [[] for _ in range(N)]\n    for i in range(N - 1):\n        (a, b) = list(map(int, input().split()))\n        (a, b) = (a - 1, b - 1)\n        E[a].append((b, i))\n        E[b].append((a, i))\n    def dfs(s, g):\n        par = [(-1, -1)] * N\n        par[s] = (s, -1)\n        stack = [s]\n        while stack:\n            v = stack.pop()\n            for (to, i) in E[v]:\n                if par[to][0] >= 0:\n                    continue\n                par[to] = (v, i)\n                if to == g:\n                    break\n                stack.append(to)\n        r = set()\n        v = g\n        while v != s:\n            (v, i) = par[v]\n            r.add(i)\n        return r\n    M = int(eval(input()))\n    path = [None] * M\n    for i in range(M):\n        (u, v) = list(map(int, input().split()))\n        (u, v) = (u - 1, v - 1)\n        path[i] = dfs(u, v)\n    def calc(s):\n        return 1 << ((N - 1) - len(s))\n    i_ans = 0\n    for p in range(1, 1 << M):\n        is_odd = bin(p).count('1') & 1\n        s = set()\n        for i in range(M):\n            if p & 1:\n                s |= path[i]\n            p >>= 1\n        if is_odd:\n            i_ans += calc(s)else:i_ans -= calc(s)\n    print((1 << (N - 1)) - i_ans)", "generated_code": "import sys\ndef main():\n    input = sys.stdin.readline\n    N = int(eval(input()))\n    E = [[] for _ in range(N)]\n    for i in range(N - 1):\n        (a, b) = list(map(int, input().split()))\n        (a, b) = (a - 1, b - 1)\n        E[a].append((b, i))\n        E[b].append((a, i))\n    def dfs(s, g):\n        par = [(-1, 1)] * N\n        par[s] = (s, -1)\n        stack = [s]\n        while stack:\n            v = stack.pop()\n            for (to, i) in E[v]:\n                if par[to][0] >= 0:\n                    continue\n                par[to] = (v, i)\n                if to == g:\n                    break\n                stack.append(to)\n        r = set()\n        v = g\n        while v != s:\n            (v, i) = par[v]\n            r.add(i)\n        return r\n    M = int(eval(input()))\n    path = [None] * M\n    for i in range(M):\n        (u, v) = list(map(int, input().split()))\n        (u, v) = (u - 1, v - 1)\n        path[i] = dfs(u, v)\n    def calc(s):\n        return 1 << ((N - 1) - len(s))\n    i_ans = 0\n    for p in range(1, 1 << M):\n        is_odd = bin(p).count('1') & 1\n        s = set()\n        for i in range(M):\n            if p & 1:\n                s |= path[i]\n            p >>= 1\n        if is_odd:\n            i_ans += calc(s)else:i_ans -= calc(s)\n    print((1 << (N - 1)) - i_ans)", "score": 0.0, "codebleu": 0.9822667853057694, "crystalbleu": 0.9937990040500241, "codebertscore": 1.0, "codescore": 0.9937830567359924, "surfaceSim": 0.4996138996138996, "abs_surfaceSim_minus_score": 0.4996138996138996}
{"golden_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "generated_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "score": 0.0, "codebleu": 0.988352364917783, "crystalbleu": 0.9942110332335385, "codebertscore": 1.0, "codescore": 0.9935876131057739, "surfaceSim": 0.9988589685075309, "abs_surfaceSim_minus_score": 0.9988589685075309}
{"golden_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "generated_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 / i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "score": 0.0, "codebleu": 0.9963221036285097, "crystalbleu": 0.9937377563162054, "codebertscore": 1.0, "codescore": 0.9849600195884705, "surfaceSim": 0.9890647900136453, "abs_surfaceSim_minus_score": 0.9890647900136453}
{"golden_code": "class UnionFind:\n    def __init__(self, size):\n        self.table = [i for i in range(size)]\n    def find(self, x):\n        return self.table[x]\n    def union(self, x, y):\n        x1 = self.find(x)\n        y1 = self.find(y)\n        if x1 == y1:\n            return False\n        for i in range(len(self.table)):\n            if self.table[i] == y1:\n                self.table[i] = x1\n        return True\n(N, M) = list(map(int, input().split()))\nedges = []\nfor _ in range(M):\n    (a, b) = list(map(int, input().split()))\n    edges.append([a - 1, b - 1])\nmat = [[0] * N for _ in range(N)]\nfor (s, g) in edges:\n    mat[s][g] = 1\n    mat[g][s] = 1\nans = 0\nfor i in range(M):\n    uni = UnionFind(N)\n    for j in range(M):\n        if i != j:\n            uni.union(edges[j][0], edges[j][1])\n    if not (all((uni.find(0) == uni.find(x) for x in range(N)))):\n        ans += 1\nprint(ans)", "generated_code": "class UnionFind:\n    def __init__(self, size):\n        self.table = [i for i in range(size)]\n    def find(self, x):\n        return self.table[x]\n    def union(self, x, y):\n        x1 = self.find(x)\n        y1 = self.find(y)\n        if x1 == y1:\n            return False\n        for i in range(len(self.table)):\n            if self.table[i] == y1:\n                self.table[i] = x1\n        return True\n(N, M) = list(map(int, input().split()))\nedges = []\nfor _ in range(M):\n    (a, b) = list(map(int, input().split()))\n    edges.append([a - 1, b - 1])\nmat = [[0] / N for _ in range(N)]\nfor (s, g) in edges:\n    mat[s][g] = 1\n    mat[g][s] = 1\nans = 0\nfor i in range(M):\n    uni = UnionFind(N)\n    for j in range(M):\n        if i != j:\n            uni.union(edges[j][0], edges[j][1])\n    if not (all((uni.find(0) == uni.find(x) for x in range(N)))):\n        ans += 1\nprint(ans)", "score": 0.0, "codebleu": 0.9898100982097378, "crystalbleu": 0.9852893211659387, "codebertscore": 1.0, "codescore": 0.9937182664871216, "surfaceSim": 0.9700168067226891, "abs_surfaceSim_minus_score": 0.9700168067226891}
{"golden_code": "class Calc:\n    def __init__(self, max_value, mod):\n        fact = [-1] * (max_value + 1)\n        fact[0] = 1\n        fact[1] = 1\n        for x in range(2, max_value + 1):\n            fact[x] = (x * fact[x - 1]) % mod\n        invs = [1] * (max_value + 1)\n        invs[max_value] = pow(fact[max_value], mod - 2, mod)\n        for x in range(max_value - 1, 0, -1):\n            invs[x] = (invs[x + 1] * (x + 1)) % mod\n        self.fact = fact\n        self.invs = invs\n        self.mod = mod\n    def combination(self, n, r):\n        if n - r < r:\n            return self.combination(n, n - r)\n        if r < 0:\n            return 0\n        if r == 0:\n            return 1\n        if r == 1:\n            return n\n        return ((self.fact[n] * self.invs[r]) * self.invs[n - r]) % self.mod\ndef gen(n):\n    x = n\n    d = 2\n    cnt = 0\n    while x % d == 0:\n        x //= d\n        cnt += 1\n    yield cnt\n    d = 3\n    ma = d * d\n    while ma <= n:\n        cnt = 0\n        while x % d == 0:\n            x //= d\n            cnt += 1\n        yield cnt\n        ma += (d * 4) + 4\n        d += 2\n    if x > 1:\n        yield 1\ndef main():\n    MOD = (10 ** 9) + 7\n    (N, M) = list(map(int, input().split()))\n    cal = Calc(max_value=N + 30, mod=MOD)\n    ans = 1\n    for cnt in gen(M):\n        ans = (ans * cal.combination((N + cnt) - 1, cnt)) % MOD\n    print(ans)", "generated_code": "class Calc:\n    def __init__(self, max_value, mod):\n        fact = [-1] * (max_value + 1)\n        fact[0] = 1\n        fact[1] = 1\n        for x in range(2, max_value + 1):\n            fact[x] = (x // fact[x - 1]) % mod\n        invs = [1] * (max_value + 1)\n        invs[max_value] = pow(fact[max_value], mod - 2, mod)\n        for x in range(max_value - 1, 0, -1):\n            invs[x] = (invs[x + 1] * (x + 1)) % mod\n        self.fact = fact\n        self.invs = invs\n        self.mod = mod\n    def combination(self, n, r):\n        if n - r < r:\n            return self.combination(n, n - r)\n        if r < 0:\n            return 0\n        if r == 0:\n            return 1\n        if r == 1:\n            return n\n        return ((self.fact[n] * self.invs[r]) * self.invs[n - r]) % self.mod\ndef gen(n):\n    x = n\n    d = 2\n    cnt = 0\n    while x % d == 0:\n        x //= d\n        cnt += 1\n    yield cnt\n    d = 3\n    ma = d * d\n    while ma <= n:\n        cnt = 0\n        while x % d == 0:\n            x //= d\n            cnt += 1\n        yield cnt\n        ma += (d * 4) + 4\n        d += 2\n    if x > 1:\n        yield 1\ndef main():\n    MOD = (10 ** 9) + 7\n    (N, M) = list(map(int, input().split()))\n    cal = Calc(max_value=N + 30, mod=MOD)\n    ans = 1\n    for cnt in gen(M):\n        ans = (ans * cal.combination((N + cnt) - 1, cnt)) % MOD\n    print(ans)", "score": 0.0, "codebleu": 0.9945974577626977, "crystalbleu": 0.9919426102484649, "codebertscore": 1.0, "codescore": 0.993752658367157, "surfaceSim": 0.9992592592592593, "abs_surfaceSim_minus_score": 0.9992592592592593}
{"golden_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "generated_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 / N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "score": 0.0, "codebleu": 0.9963221036285097, "crystalbleu": 0.9937384331224636, "codebertscore": 1.0, "codescore": 0.9856591820716858, "surfaceSim": 0.9890647900136453, "abs_surfaceSim_minus_score": 0.9890647900136453}
{"golden_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "generated_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\npass\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "score": 0.0, "codebleu": 0.9796651238402047, "crystalbleu": 0.9827316786143654, "codebertscore": 1.0, "codescore": 0.9864333868026733, "surfaceSim": 0.9843352879615941, "abs_surfaceSim_minus_score": 0.9843352879615941}
{"golden_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "generated_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] // (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "score": 0.0, "codebleu": 0.9963221036285097, "crystalbleu": 0.990269756837013, "codebertscore": 1.0, "codescore": 0.9856796860694885, "surfaceSim": 0.9887682303175706, "abs_surfaceSim_minus_score": 0.9887682303175706}
{"golden_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "generated_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] // self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "score": 0.0, "codebleu": 0.9945883912637858, "crystalbleu": 0.9915876446894797, "codebertscore": 1.0, "codescore": 0.9935537576675415, "surfaceSim": 0.986723282799925, "abs_surfaceSim_minus_score": 0.986723282799925}
{"golden_code": "from collections import defaultdict\nfrom collections import deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\ndef I():\n    return int(sys.stdin.readline())\ndef LS():\n    return list(map(list, sys.stdin.readline().split()))\ndef S():\n    return list(sys.stdin.readline())[:-1]\ndef IR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = I()\n    return l\ndef LIR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = LI()\n    return l\ndef SR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = S()\n    return l\ndef LSR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = SR()\n    return l\nmod = 1000000007\ndef A():\n    s = S()\n    t = S()\n    if s + t == t[::-1] + s[::-1]:\n        print('YES')else:print('NO')\ndef B():\n    n = I()\n    for i in range(int(n ** 0.5) + 2)[::-1]:\n        if i * i <= n:\n            print(i * i)\n            quit()\ndef C():\n    n = I()\n    a = LI()\n    b = LI()\n    c = LI()\n    q = [0 for i in range(n)]\n    ans = 0\n    a.sort()\n    b.sort()\n    c.sort()\n    for i in range(n):\n        j = bisect.bisect_left(a, b[i])\n        q[i] = j\n    for i in range(n - 1):\n        q[i + 1] += q[i]\n    q.insert(0, 0)\n    for i in range(n):\n        j = bisect.bisect_left(b, c[i])\n        ans += q[j]\n    print(ans)\ndef D():\n    def dijkstra():\n        d = [float('inf') for i in range(k)]\n        q = [[0, 1]]\n        d[1] = 0\n        while q:\n            (dx, x) = heappop(q)\n            for (y, dy) in v[x]:\n                if d[y] > dx + dy:\n                    d[y] = dx + dy\n                    heappush(q, [d[y], y])\n        print(d[0] + 1)\n    k = I()\n    if k == 1:\n        print(1)\n        quit()\n    v = [[] for i in range(k)]\n    for i in range(1, k):\n        v[i].append([(i + 1) % k, 1])\n        v[i].append([(i * 10) % k, 0])\n    dijkstra()\ndef E():\n    return\ndef F():\n    return\ndef G():\n    return\ndef H():\n    return", "generated_code": "from collections import defaultdict\nfrom collections import deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\ndef I():\n    return int(sys.stdin.readline())\ndef LS():\n    return list(map(list, sys.stdin.readline().split()))\ndef S():\n    return list(sys.stdin.readline())[:-1]\ndef IR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = I()\n    return l\ndef LIR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = LI()\n    return l\ndef SR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = S()\n    return l\ndef LSR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = SR()\n    return l\nmod = 1000000007\ndef A():\n    s = S()\n    t = S()\n    if s - t == t[::-1] + s[::-1]:\n        print('YES')else:print('NO')\ndef B():\n    n = I()\n    for i in range(int(n ** 0.5) + 2)[::-1]:\n        if i * i <= n:\n            print(i * i)\n            quit()\ndef C():\n    n = I()\n    a = LI()\n    b = LI()\n    c = LI()\n    q = [0 for i in range(n)]\n    ans = 0\n    a.sort()\n    b.sort()\n    c.sort()\n    for i in range(n):\n        j = bisect.bisect_left(a, b[i])\n        q[i] = j\n    for i in range(n - 1):\n        q[i + 1] += q[i]\n    q.insert(0, 0)\n    for i in range(n):\n        j = bisect.bisect_left(b, c[i])\n        ans += q[j]\n    print(ans)\ndef D():\n    def dijkstra():\n        d = [float('inf') for i in range(k)]\n        q = [[0, 1]]\n        d[1] = 0\n        while q:\n            (dx, x) = heappop(q)\n            for (y, dy) in v[x]:\n                if d[y] > dx + dy:\n                    d[y] = dx + dy\n                    heappush(q, [d[y], y])\n        print(d[0] + 1)\n    k = I()\n    if k == 1:\n        print(1)\n        quit()\n    v = [[] for i in range(k)]\n    for i in range(1, k):\n        v[i].append([(i + 1) % k, 1])\n        v[i].append([(i * 10) % k, 0])\n    dijkstra()\ndef E():\n    return\ndef F():\n    return\ndef G():\n    return\ndef H():\n    return", "score": 0.0, "codebleu": 0.9960259674102339, "crystalbleu": 0.9948180583890528, "codebertscore": 1.0, "codescore": 0.9865151643753052, "surfaceSim": 0.499755859375, "abs_surfaceSim_minus_score": 0.499755859375}
{"golden_code": "n = int(eval(input()))\na = list(map(int, input().split()))\nD = {i: [0] for i in range(1, n + 1)}\nfor i in range(n + 1):\n    D[a[i]][0] += 1\n    D[a[i]].append(i)\n(pl, pr) = (0, 0)\nfor i in D:\n    if D[i][0] == 2:\n        pl = D[i][1]\n        pr = D[i][2]\n        break\nL = pl\nM = (pr - pl) - 1\nN = n - pr\nmod = int(1000000000.0) + 7\nmaxf = n + 11\ndef make_fact(n, k):\n    tmp = n\n    perm = [i for i in range(k)]\n    L = [0 for _ in range(k)]\n    for i in range(k):\n        L[i] = tmp % (i + 1)\n        tmp //= i + 1\n    LL = [0 for _ in range(k)]\n    for i in range(k):\n        LL[i] = perm[L[(-i) - 1]]\n        for j in range(L[(-i) - 1] + 1, k):\n            perm[j - 1] = perm[j]\n    return LL\ndef doubling(n, m, modulo=mod):\n    y = 1\n    base = n\n    tmp = m\n    while tmp != 0:\n        if tmp % 2 == 1:\n            y *= base\n            if modulo > 0:\n                y %= modulo\n        base *= base\n        if modulo > 0:\n            base %= modulo\n        tmp //= 2\n    return y\ndef inved(a, modulo=mod):\n    (x, y, u, v, k, l) = (1, 0, 0, 1, a, modulo)\n    while l != 0:\n        (x, y, u, v) = (u, v, x - (u * (k // l)), y - (v * (k // l)))\n        (k, l) = (l, k % l)\n    return x % modulo\nfact = [1 for _ in range(maxf + 1)]\ninvf = [1 for _ in range(maxf + 1)]\nfor i in range(maxf):\n    fact[i + 1] = (fact[i] * (i + 1)) % mod\ninvf[-1] = inved(fact[-1])\nfor i in range(maxf, 0, -1):\n    invf[i - 1] = (invf[i] * i) % mod\nfor i in range(1, n + 2):\n    S = ((fact[n] * invf[i - 1]) * invf[(n - i) + 1]) % mod\n    if i <= n - 1:\n        S += ((fact[n - 1] * invf[i]) * invf[(n - 1) - i]) % mod\n        S %= mod\n    if i <= n - M:\n        S -= ((fact[(n - 1) - M] * invf[i - 1]) * invf[(n - M) - i]) % mod\n        S %= mod\n    if i <= n:\n        S += ((fact[n - 1] * invf[i - 1]) * invf[n - i]) % mod\n        S %= mod\n    print(S)", "generated_code": "n = int(eval(input()))\na = list(map(int, input().split()))\nD = {i: [0] for i in range(1, n + 1)}\nfor i in range(n + 1):\n    D[a[i]][0] += 1\n    D[a[i]].append(i)\n(pl, pr) = (0, 0)\nfor i in D:\n    if D[i][0] == 2:\n        pl = D[i][1]\n        pr = D[i][2]\n        break\nL = pl\nM = (pr - pl) - 1\nN = n - pr\nmod = int(1000000000.0) + 7\nmaxf = n + 11\ndef make_fact(n, k):\n    tmp = n\n    perm = [i for i in range(k)]\n    L = [0 for _ in range(k)]\n    for i in range(k):\n        L[i] = tmp % (i + 1)\n        tmp //= i + 1\n    LL = [0 for _ in range(k)]\n    for i in range(k):\n        LL[i] = perm[L[(-i) - 1]]\n        for j in range(L[(-i) - 1] + 1, k):\n            perm[j - 1] = perm[j]\n    return LL\ndef doubling(n, m, modulo=mod):\n    y = 1\n    base = n\n    tmp = m\n    while tmp != 0:\n        if tmp % 2 == 1:\n            y *= base\n            if modulo > 0:\n                y %= modulo\n        base *= base\n        if modulo > 0:\n            base %= modulo\n        tmp //= 2\n    return y\ndef inved(a, modulo=mod):\n    (x, y, u, v, k, l) = (1, 0, 0, 1, a, modulo)\n    while l != 0:\n        (x, y, u, v) = (u, v, x - (u * (k // l)), y - (v * (k // l)))\n        (k, l) = (l, k % l)\n    return x % modulo\nfact = [1 for _ in range(maxf + 1)]\ninvf = [1 for _ in range(maxf + 1)]\nfor i in range(maxf):\n    fact[i + 1] = (fact[i] * (i + 1)) % mod\ninvf[-1] = inved(fact[1])\nfor i in range(maxf, 0, -1):\n    invf[i - 1] = (invf[i] * i) % mod\nfor i in range(1, n + 2):\n    S = ((fact[n] * invf[i - 1]) * invf[(n - i) + 1]) % mod\n    if i <= n - 1:\n        S += ((fact[n - 1] * invf[i]) * invf[(n - 1) - i]) % mod\n        S %= mod\n    if i <= n - M:\n        S -= ((fact[(n - 1) - M] * invf[i - 1]) * invf[(n - M) - i]) % mod\n        S %= mod\n    if i <= n:\n        S += ((fact[n - 1] * invf[i - 1]) * invf[n - i]) % mod\n        S %= mod\n    print(S)", "score": 0.0, "codebleu": 0.9931840000005651, "crystalbleu": 0.996395684879913, "codebertscore": 1.0, "codescore": 0.9930742979049683, "surfaceSim": 0.999727965179543, "abs_surfaceSim_minus_score": 0.999727965179543}
{"golden_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "generated_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\npass\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "score": 0.0, "codebleu": 0.8367107744799487, "crystalbleu": 0.8538637244584376, "codebertscore": 0.98, "codescore": 0.1757018119096756, "surfaceSim": 0.907987099222159, "abs_surfaceSim_minus_score": 0.907987099222159}
{"golden_code": "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nfac = [1, 1]\nf_inv = [1, 1]\ninv = [0, 1]\ndef prepare(n, mod):\n    for i in range(2, n + 1):\n        fac.append((fac[-1] * i) % mod)\n        inv.append(((-(inv[mod % i])) * (mod // i)) % mod)\n        f_inv.append((f_inv[-1] * inv[-1]) % mod)\ndef cmb(n, r, mod):\n    if (n < 0 or r < 0):\n        return 0\n    if r > n:\n        return 0\n    return ((fac[n] * f_inv[r]) * f_inv[n - r]) % mod\ndef main():\n    (N, M, K) = list(map(int, readline().split()))\n    MOD = 998244353\n    prepare(N + 10, MOD)\n    if (M == 1 and K == N - 1):\n        print(1)\n        exit()\n    m = M\n    for _ in range(N - 1):\n        m *= M - 1\n        m %= MOD\n    ans = 0\n    for k in range(K + 1):\n        ans += (m * cmb(N - 1, k, MOD)) % MOD\n        ans %= MOD\n        m *= pow(M - 1, MOD - 2, MOD)\n        m %= MOD\n    print(ans)", "generated_code": "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nfac = [1, 1]\nf_inv = [1, 1]\ninv = [0, 1]\ndef prepare(n, mod):\n    for i in range(2, n + 1):\n        fac.append((fac[-1] * i) % mod)\n        inv.append(((-(inv[mod % i])) * (mod // i)) % mod)\n        f_inv.append((f_inv[1] * inv[-1]) % mod)\ndef cmb(n, r, mod):\n    if (n < 0 or r < 0):\n        return 0\n    if r > n:\n        return 0\n    return ((fac[n] * f_inv[r]) * f_inv[n - r]) % mod\ndef main():\n    (N, M, K) = list(map(int, readline().split()))\n    MOD = 998244353\n    prepare(N + 10, MOD)\n    if (M == 1 and K == N - 1):\n        print(1)\n        exit()\n    m = M\n    for _ in range(N - 1):\n        m *= M - 1\n        m %= MOD\n    ans = 0\n    for k in range(K + 1):\n        ans += (m * cmb(N - 1, k, MOD)) % MOD\n        ans %= MOD\n        m *= pow(M - 1, MOD - 2, MOD)\n        m %= MOD\n    print(ans)", "score": 0.0, "codebleu": 0.9755236812410836, "crystalbleu": 0.9919065664360349, "codebertscore": 1.0, "codescore": 0.9937275648117065, "surfaceSim": 0.9994450610432852, "abs_surfaceSim_minus_score": 0.9994450610432852}
{"golden_code": "import queue\nINF = 123456789\ndef main():\n    (n, m) = list(map(int, input().split()))\n    G = [[] for _ in range(n)]\n    for _ in range(m):\n        (a, b, c) = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        G[a].append((b, c))\n        G[b].append((a, c))\n    used = set()\n    for i in range(n):\n        d = [INF for _ in range(n)]\n        par = [-1 for _ in range(n)]\n        que = queue.PriorityQueue()\n        d[i] = 0\n        que.put((0, i))\n        while not (que.empty()):\n            p = que.get()\n            v = p[1]\n            if d[v] < p[0]:\n                continue\n            for (to, cost) in G[v]:\n                if d[to] > d[v] + cost:\n                    d[to] = d[v] + cost\n                    par[to] = v\n                    que.put((d[to], to))\n        for j in range(n):\n            if i != j:\n                (a, b) = (j, par[j])\n                if a > b:\n                    (a, b) = (b, a)\n                used.add((a, b))\n    print(m - len(used))", "generated_code": "import queue\nINF = 123456789\ndef main():\n    (n, m) = list(map(int, input().split()))\n    G = [[] for _ in range(n)]\n    for _ in range(m):\n        (a, b, c) = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        G[a].append((b, c))\n        G[b].append((a, c))\n    used = set()\n    for i in range(n):\n        d = [INF for _ in range(n)]\n        par = [-1 for _ in range(n)]\n        que = queue.PriorityQueue()\n        d[i] = 0\n        que.put((0, i))\n        while not (que.empty()):\n            p = que.get()\n            v = p[1]\n            if d[v] < p[0]:\n                continue\n            for (to, cost) in G[v]:\n                if d[to] > d[v] + cost:\n                    d[to] = d[v] + cost\n                    par[to] = v\n                    que.put((d[to], to))\n        for j in range(n):\n            if i != j:\n                (a, b) = (j, par[j])\n                if a > b:\n                    (a, b) = (b, a)\n                used.add((a, b))\n    print(m + len(used))", "score": 0.0, "codebleu": 0.993373666900063, "crystalbleu": 0.9879581348354282, "codebertscore": 1.0, "codescore": 0.9937937259674072, "surfaceSim": 0.9994979919678715, "abs_surfaceSim_minus_score": 0.9994979919678715}
{"golden_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "generated_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        _make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "score": 0.0, "codebleu": 0.988352364917783, "crystalbleu": 0.9942081498414163, "codebertscore": 1.0, "codescore": 0.9936065673828125, "surfaceSim": 0.9988589685075309, "abs_surfaceSim_minus_score": 0.9988589685075309}
{"golden_code": "def cmb(n, r):\n    import math\n    if n < r:\n        return 0\n    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\ndef solve(S):\n    mod = (10 ** 9) + 7\n    ans = 0\n    for i in range(1, (S // 3) + 1):\n        tama = i + (S - (i * 3))\n        tama -= 2\n        bo = i - 1\n        ans += cmb(tama + 1, bo)\n        ans %= mod\n    print(ans)", "generated_code": "def cmb(n, r):\n    import math\n    if n < r:\n        return 0\n    return math.factorial(n) // (math.factorial(n - r) // math.factorial(r))\ndef solve(S):\n    mod = (10 ** 9) + 7\n    ans = 0\n    for i in range(1, (S // 3) + 1):\n        tama = i + (S - (i * 3))\n        tama -= 2\n        bo = i - 1\n        ans += cmb(tama + 1, bo)\n        ans %= mod\n    print(ans)", "score": 0.0, "codebleu": 0.980976656443197, "crystalbleu": 0.9787528680416572, "codebertscore": 1.0, "codescore": 0.9937120676040649, "surfaceSim": 0.9972375690607735, "abs_surfaceSim_minus_score": 0.9972375690607735}
