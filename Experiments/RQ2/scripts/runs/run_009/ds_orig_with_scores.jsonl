{"golden_code": "import numpy as np\n\n\n\nN, D = list(map(int, input().split()))\n\npoints = [list(map(int, input().split())) for _ in range(N)]\n\ncount = 0\n\nfor i in range(N):\n\n    for j in range(N):\n\n        if j == i:\n\n            continue\n\n        dist = np.sqrt(sum([(points[i][d] - points[j][d]) ** 2 for d in range(D)]))\n\n        if dist.is_integer():\n\n            count += 1\n\nprint((count // 2))", "generated_code": "import sys\n\nsys.setrecursionlimit(10 ** 6)\n\n\n\n\n\ndef calc_dist(x, y):\n\n    dist = 0\n\n    for xi, yi in zip(x, y):\n\n        dist += (yi - xi) ** 2\n\n    return dist ** (1/2)\n\n\n\n\n\ndef main():\n\n    N, D = list(map(int, sys.stdin.readline().rstrip().split()))\n\n    X = [list(map(int, sys.stdin.readline().rstrip().split())) for _ in range(N)]\n\n\n\n    ans = 0\n\n    for i in range(N):\n\n        for j in range(i+1, N):\n\n            dist = calc_dist(X[i], X[j])\n\n            if dist.is_integer():\n\n                ans += 1\n\n    \n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()", "score": 1.0, "codebleu": 0.3631493984972547, "crystalbleu": 0.25453927053447467, "codebertscore": 0.81, "codescore": 0.018490109592676163, "surfaceSim": 0.6462575823223571, "abs_surfaceSim_minus_score": 0.3537424176776429}
{"golden_code": "import sys\n\nfrom scipy.sparse import csr_matrix\n\nfrom scipy.sparse.csgraph import floyd_warshall\n\n\n\ndef solve(N: int, M: int, a: \"List[int]\", b: \"List[int]\"):\n\n    answer = 0\n\n    for i in range(M): ## iの辺を消す\n\n        matrix = [[0]*(N) for _ in range(N)]\n\n        for j in range(M):\n\n            if j == i:\n\n                continue\n\n            aa = a[j]-1\n\n            bb = b[j]-1\n\n            matrix[aa][bb] = 1\n\n           \n\n        dist_matrix = floyd_warshall(csgraph=csr_matrix(matrix), directed=False)\n\n        \n\n        if dist_matrix[a[i]-1][b[i]-1] == float('inf'):\n\n            answer += 1\n\n            \n\n    print(answer)\n\n    return\n\n\n\n\n\ndef main():\n\n    def iterate_tokens():\n\n        for line in sys.stdin:\n\n            for word in line.split():\n\n                yield word\n\n    tokens = iterate_tokens()\n\n    N = int(next(tokens))  # type: int\n\n    M = int(next(tokens))  # type: int\n\n    a = [int()] * (M)  # type: \"List[int]\"\n\n    b = [int()] * (M)  # type: \"List[int]\"\n\n    for i in range(M):\n\n        a[i] = int(next(tokens))\n\n        b[i] = int(next(tokens))\n\n    solve(N, M, a, b)\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "generated_code": "#!/usr/bin/env python3\n\nimport sys\n\ninput = sys.stdin.readline\n\ndef INT(): return int(eval(input()))\n\ndef MAP(): return list(map(int,input().split()))\n\ndef LI(): return list(map(int,input().split()))\n\n\n\nclass UnionFind():\n\n    def __init__(self, n):\n\n        self.n = n\n\n        self.parents = [-1] * n\n\n        \n\n    def find(self, x): # 根を探す\n\n        if self.parents[x] < 0:\n\n            return x\n\n        else:\n\n            self.parents[x] = self.find(self.parents[x])\n\n            return self.parents[x]\n\n    \n\n    def union(self, x, y):\n\n        x = self.find(x)\n\n        y = self.find(y)\n\n        \n\n        if x == y:\n\n            return\n\n        \n\n        if self.parents[x] > self.parents[y]:\n\n            x, y = y, x\n\n        \n\n        self.parents[x] += self.parents[y]\n\n        self.parents[y] = x\n\n    \n\n    def size(self, x):\n\n        return -self.parents[self.find(x)]\n\n        \n\n    def same(self, x, y):\n\n        return self.find(x) == self.find(y)\n\n    \n\n    def members(self, x):\n\n        root = self.find(x)\n\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    \n\n    def roots(self):\n\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n\n\n    def group_count(self):\n\n        return len(self.roots())\n\n    \n\n    def all_group_members(self):\n\n        return {r: self.members(r) for r in self.roots()}\n\n    \n\n    def __str__(self):\n\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n\n\ndef main():\n\n    N,M=MAP()\n\n    \n\n    edges = []\n\n    for _ in range(M):\n\n        a,b = MAP()\n\n        edges.append((a-1,b-1))\n\n\n\n    answer = 0\n\n    for i in range(M): # i番目の辺を使わない\n\n        uf = UnionFind(N)\n\n\n\n        for j in range(M):\n\n            if i == j:\n\n                continue\n\n\n\n            a,b = edges[j]\n\n            uf.union(a,b)\n\n        if uf.group_count() > 1:\n\n            answer += 1\n\n    print(answer)\n\n    return\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 1.0, "codebleu": 0.2974484062646162, "crystalbleu": 0.14386136984649348, "codebertscore": 0.74, "codescore": 0.1567898392677307, "surfaceSim": 0.6271589000576542, "abs_surfaceSim_minus_score": 0.3728410999423458}
{"golden_code": "n = int(eval(input()))\n\nprint((1 if n == 0 else 0))\n", "generated_code": "n = int(eval(input()))\n\nprint((0 if n else 1))\n", "score": 1.0, "codebleu": 0.45523015794853083, "crystalbleu": 0.0, "codebertscore": 0.96, "codescore": 0.33642128109931946, "surfaceSim": 0.861013986013986, "abs_surfaceSim_minus_score": 0.13898601398601396}
{"golden_code": "import sys\n\nimport numpy as np\n\n\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\ndef main(N):\n\n    div = np.zeros(N+1, np.int64)\n\n    for n in range(1, N+1):\n\n      for m in range(n, N+1, n):\n\n        div[m] += m\n\n    return div.sum()\n\n\n\nif sys.argv[-1] == 'ONLINE_JUDGE':\n\n    import numba\n\n    from numba.pycc import CC\n\n    i8 = numba.int64\n\n    cc = CC('my_module')\n\n\n\n    def cc_export(f, signature):\n\n        cc.export(f.__name__, signature)(f)\n\n        return numba.njit(f)\n\n\n\n    main = cc_export(main, (i8, ))\n\n    cc.compile()\n\n\n\nfrom my_module import main\n\n\n\nN = int(read())\n\nprint((main(N)))\n", "generated_code": "import sys\n\nimport numpy as np\n\n\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\ndef main(N):\n\n    x = 0\n\n    for a in range(1, N+1):\n\n        for b in range(1, N//a+1):\n\n            x += a*b\n\n    return x\n\n\n\nif sys.argv[-1] == 'ONLINE_JUDGE':\n\n    import numba\n\n    from numba.pycc import CC\n\n    i8 = numba.int64\n\n    cc = CC('my_module')\n\n\n\n    def cc_export(f, signature):\n\n        cc.export(f.__name__, signature)(f)\n\n        return numba.njit(f)\n\n\n\n    main = cc_export(main, (i8, ))\n\n    cc.compile()\n\n\n\nfrom my_module import main\n\n\n\nN = int(read())\n\nprint((main(N)))\n", "score": 1.0, "codebleu": 0.7270550706993442, "crystalbleu": 0.7213595826396544, "codebertscore": 0.96, "codescore": 0.9069727063179016, "surfaceSim": 0.9284357821089455, "abs_surfaceSim_minus_score": 0.0715642178910545}
{"golden_code": "import numpy as np\n\nN = int(eval(input()))\n\nlist_ai = list(map(int,input().split()))\n\nlist1 = [x-(i+1) for i,x in enumerate(list_ai)]\n\na1 = np.array(list1)\n\nmedian1 = int(np.floor(np.median(a1)))\n\nans = np.sum(np.abs(a1-median1))\n\nprint(ans)", "generated_code": "import numpy as np\n\nN = int(eval(input()))\n\nlist_ai = list(map(int,input().split()))\n\na1 = np.array(list_ai)-np.arange(1,N+1)\n\nmedian1 = int(np.floor(np.median(a1)))\n\nans = np.sum(np.abs(a1-median1))\n\nprint(ans)\n", "score": 1.0, "codebleu": 0.6417047816651265, "crystalbleu": 0.0, "codebertscore": 0.95, "codescore": 0.9699689745903015, "surfaceSim": 0.8308518428118135, "abs_surfaceSim_minus_score": 0.16914815718818654}
{"golden_code": "import numpy as np\n\nN_1=list(map(int, input().split()))\n\nN_2=list(map(int, input().split()))\n\nN_3=list(map(int, input().split()))\n\nN=int(eval(input()))\n\na=[int(eval(input())) for i in range(N)]\n\n\n\nn=np.array([N_1,N_2,N_3])\n\n\n\nfor a_n in a:\n\n    if a_n in n:\n\n        n[n==a_n]=0\n\n    else:\n\n        pass\n\ni=0\n\n    \n\nif np.all(n[0:,0]==0)==True:\n\n    i=+1\n\n    \n\nelif np.all(n[0:,1]==0)==True:\n\n    i+=1\n\n    \n\nelif np.all(n[0:,2]==0)==True:\n\n    i+=1\n\n    \n\nelif np.all(n[0,0:]==0)==True:\n\n    i+=1\n\n    \n\nelif np.all(n[1,0:]==0)==True:\n\n    i+=1\n\n\n\nelif np.all(n[2,0:]==0)==True:\n\n    i+=1\n\n\n\nelif n[0,0]==0 and n[1,1]==0  and n[2,2] ==0:\n\n    i+=1\n\n    \n\nelif n[0,2]==0 and n[1,1]==0 and n[2,0] ==0:\n\n    i+=1\n\n    \n\nif i>0:\n\n    print(\"Yes\")\n\nelse:\n\n    print(\"No\")", "generated_code": "a_1=list(map(int, input().split()))\n\na_2=list(map(int, input().split()))\n\na_3=list(map(int, input().split()))\n\n\n\nc=[a_1,a_2,a_3]\n\n\n\nN=int(eval(input()))\n\n\n\nb=[int(eval(input())) for _ in range(N)]\n\n\n\nfor i in range(3):\n\n    for j in range(3):\n\n        if c[i][j] in b:\n\n            c[i][j]=0\n\n            \n\n            \n\ni=0\n\nif c[0][0]==0 and c[0][1]==0 and c[0][2]==0:\n\n    i+=1\n\nif c[1][0]==0 and c[1][1]==0 and c[1][2]==0:\n\n    i+=1\n\nif c[2][0]==0 and c[2][1]==0 and c[2][2]==0:\n\n    i+=1\n\nif c[0][0]==0 and c[1][0]==0 and c[2][0]==0:\n\n    i+=1\n\nif c[0][1]==0 and c[1][1]==0 and c[2][1]==0:\n\n    i+=1\n\nif c[0][2]==0 and c[1][2]==0 and c[2][2]==0:\n\n    i+=1\n\nif c[0][0]==0 and c[1][1]==0 and c[2][2]==0:\n\n    i+=1\n\nif c[0][2]==0 and c[1][1]==0 and c[2][0]==0:\n\n    i+=1\n\n    \n\nif i>0:\n\n    print(\"Yes\")\n\nelse:\n\n  print(\"No\")", "score": 1.0, "codebleu": 0.3141180079646291, "crystalbleu": 0.43074943134461113, "codebertscore": 0.89, "codescore": 0.8680024147033691, "surfaceSim": 0.6924123337363965, "abs_surfaceSim_minus_score": 0.30758766626360345}
{"golden_code": "import sys\n\ninput = sys.stdin.readline\n\nsys.setrecursionlimit(10 ** 7)\n\n\n\nN = int(eval(input()))\n\nA = [int(i) for i in input().split()]\n\nB = [int(i) for i in input().split()]\n\nbefore = sum(A)\n\n\n\nfor i in range(N):\n\n    nokori = B[i]\n\n    for j in range(i,i+2):\n\n        if nokori >= A[j]:\n\n            nokori -= A[j]\n\n            A[j] = 0\n\n        else:\n\n            A[j] -= nokori\n\n            nokori = 0\n\nafter = sum(A)\n\n\n\nprint((before - after))", "generated_code": "N = int(eval(input()))\n\nA = [int(i) for i in input().split()]\n\nB = [int(i) for i in input().split()]\n\n\n\ncnt = 0\n\nfor i in range(N):\n\n    if B[i] >= A[i]:\n\n        cnt += A[i]\n\n        B[i] -= A[i]\n\n    else:\n\n        cnt += B[i]\n\n        B[i] = 0\n\n    if B[i] == 0:\n\n        continue\n\n    if B[i] >= A[i+1]:\n\n        cnt += A[i+1]\n\n        A[i+1] = 0\n\n    else:\n\n        cnt += B[i]\n\n        A[i+1] -= B[i]\n\n\n\nprint(cnt)", "score": 1.0, "codebleu": 0.4094408094356795, "crystalbleu": 0.43670551042039385, "codebertscore": 0.82, "codescore": 0.7922458648681641, "surfaceSim": 0.6795157967032968, "abs_surfaceSim_minus_score": 0.32048420329670324}
{"golden_code": "N = int(eval(input()))\n\nB =list(map(int,input().split()))\n\nA=[0]*N\n\n\n\nA[0]=B[0]\n\nfor i in range(1,N-1):\n\n    A[i]=min(B[i],B[i-1])\n\nA[-1]=B[-1]\n\nprint((sum(A)))", "generated_code": "import sys\n\ninput = sys.stdin.readline\n\n\n\ndef I(): return int(eval(input()))\n\ndef MI(): return list(map(int, input().split()))\n\ndef LI(): return list(map(int, input().split()))\n\n\n\ndef main():\n\n    mod=10**9+7\n\n    N=I()\n\n    B=LI()\n\n    A=[0]*N\n\n    A[0]=B[0]\n\n    A[-1]=B[-1]\n\n    for i in range(N-2):\n\n        A[i+1]=min(B[i],B[i+1])\n\n        \n\n    print((sum(A)))\n\n\n\nmain()\n", "score": 1.0, "codebleu": 0.3349319262604534, "crystalbleu": 0.3501257756758309, "codebertscore": 0.85, "codescore": 0.5376852750778198, "surfaceSim": 0.6225994694960212, "abs_surfaceSim_minus_score": 0.3774005305039788}
{"golden_code": "from numpy import*\n\na,b=median(t:=loadtxt(open(0),skiprows=1),0)\n\nprint((int((a-b)*~(~len(t)%2))+1))", "generated_code": "from statistics import*\n\n(n,),*t=[list(map(int,t.split()))for t in open(0)]\n\na,b=list(map(median,list(zip(*t))))\n\nprint((int((b-a)*(2-n%2))+1))", "score": 1.0, "codebleu": 0.24364115598855923, "crystalbleu": 0.0, "codebertscore": 0.84, "codescore": 0.928013801574707, "surfaceSim": 0.5466200466200466, "abs_surfaceSim_minus_score": 0.4533799533799534}
{"golden_code": "n, q = [ int( val ) for val in input( ).split( \" \" ) ]\n\nps = [0]*n\n\nt = [0]*n\n\nfor i in range( n ):\n\n\tps[i], t[i] = input( ).split( \" \" )\n\n\n\n\n\noutput = []\n\nqsum = 0\n\nwhile t:\n\n\tpsi = ps.pop( 0 )\n\n\tti = int( t.pop( 0 ) )\n\n\tif ti <= q:\n\n\t\tqsum += ti\t\n\n\t\toutput.append( psi+\" \"+str( qsum ) )\n\n\telse:\n\n\t\tt.append( ti - q )\n\n\t\tps.append( psi )\n\n\t\tqsum += q\n\n\n\nprint(( \"\\n\".join( output ) ))", "generated_code": "n, q = [ int( val ) for val in input( ).split( \" \" ) ]\n\nps = [0]*n\n\nt = [0]*n\n\nfor i in range( n ):\n\n    ps[i], t[i] = input( ).split( \" \" )\n\n \n\n \n\noutput = []\n\nqsum = 0\n\nwhile t:\n\n    psi = ps.pop( 0 )\n\n    ti = int( t.pop( 0 ) )\n\n    if ti <= q:\n\n        qsum += ti\n\n        output.append( \"\".join( ( psi, \" \", str( qsum ) ) ) )\n\n    else:\n\n        t.append( ti - q )\n\n        ps.append( psi )\n\n        qsum += q\n\n \n\nprint(( \"\\n\".join( output ) ))", "score": 1.0, "codebleu": 0.9169507813983201, "crystalbleu": 0.9072327470401259, "codebertscore": 0.97, "codescore": 0.6796619892120361, "surfaceSim": 0.9855233853006682, "abs_surfaceSim_minus_score": 0.014476614699331813}
{"golden_code": "a,b,c,x,y=list(map(int,input().split()))\n\n\n\nans=a*x+b*y\n\nfor ci in range(max(x,y)+1):\n\n    sumc = 2*ci*c\n\n    sumc += (x-ci)*a if (x-ci)>0 else 0\n\n    sumc += (y-ci)*b if (y-ci)>0 else 0\n\n    ans=min(ans,sumc)\n\n\n\nprint(ans)", "generated_code": "a,b,c,x,y=list(map(int,input().split()))\n\nans=a*x+b*y\n\nif x==y:\n\n    ans=min(ans,2*x*c)\n\nelif x>y:\n\n    ans=min(ans,a*(x-y)+2*y*c)\n\n    ans=min(ans,2*x*c)\n\nelse:\n\n    ans=min(ans,b*(y-x)+2*x*c)\n\n    ans=min(ans,2*y*c)\n\nprint(ans)", "score": 1.0, "codebleu": 0.29429607913114075, "crystalbleu": 0.4571735917560744, "codebertscore": 0.87, "codescore": 0.09687834978103638, "surfaceSim": 0.6735288001663547, "abs_surfaceSim_minus_score": 0.32647119983364525}
{"golden_code": "n=int(eval(input()))\n\na=[list(map(int,input().split()))for _ in range(n)]\n\ndef f():\n\n for i in range(n-1):\n\n  d=a[i][:];d[3],d[4]=d[4],d[3]\n\n  for j in range(i+1,n):\n\n   e=a[j][:];e[3],e[4]=e[4],e[3]\n\n   for p in([0,1,2,3,4,5],[1,5,2,0,4,3],[2,1,5,3,0,4],[3,0,2,5,4,1],[4,1,0,3,5,2],[5,1,4,3,2,0]):\n\n    f=[d[k]for k in p]\n\n    if f[0]==e[0]and f[5]==e[5]:\n\n     f=f[1:5]*2\n\n     for k in range(4):\n\n      if f[k:k+4]==e[1:5]:return'No'\n\n return'Yes'\n\nprint((f()))\n", "generated_code": "n=int(eval(input()))\n\na=[[int(s)for s in input().split()]for _ in range(n)]\n\ndef f():\n\n for i in range(n-1):\n\n  d=a[i][:];d[3],d[4]=d[4],d[3]\n\n  for j in range(i+1,n):\n\n   e=a[j][:];e[3],e[4]=e[4],e[3]\n\n   for p in([0,1,2,3,4,5],[1,5,2,0,4,3],[2,1,5,3,0,4],[3,0,2,5,4,1],[4,1,0,3,5,2],[5,1,4,3,2,0]):\n\n    f=[d[k]for k in p]\n\n    if f[0]==e[0]and f[5]==e[5]:\n\n     f=f[1:5]*2\n\n     for k in range(4):\n\n      if f[k:k+4]==e[1:5]:return'No'\n\n return'Yes'\n\nprint((f()))\n", "score": 1.0, "codebleu": 0.7944470675843004, "crystalbleu": 0.9467469051426798, "codebertscore": 0.99, "codescore": 0.9937981963157654, "surfaceSim": 0.987152034261242, "abs_surfaceSim_minus_score": 0.012847965738758016}
{"golden_code": "import sys\n\ninput = sys.stdin.readline\n\nsys.setrecursionlimit(10 ** 7)\n\n\n\n\"\"\"\n\n奇数番目集合、偶数番目集合の中で自由にできるのが操作2．\n\n操作1で集合間のやりとりをする\n\n\"\"\"\n\n\n\nimport numpy as np\n\n\n\nN = int(eval(input()))\n\nA = np.fromstring(sys.stdin.read(),dtype=np.int64,sep='\\n')\n\n\n\nB = np.sort(A)\n\n\n\nanswer = len(np.setdiff1d(A[::2],B[::2]))\n\nprint(answer)", "generated_code": "import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\n\"\"\"\n\n・偶数番号、奇数番号の中では入れ替え放題\n\n・偶、奇の間：並べてからスワップ。操作2を1回で、正しいものを2つ増やせる\n\n\"\"\"\n\n\n\nN,*A = list(map(int,read().split()))\n\n\n\nx_to_i = {x:i for i,x in enumerate(sorted(A))}\n\nrank = [x_to_i[x] for x in A]\n\n\n\nanswer = sum((x^i) & 1 for i,x in enumerate(rank)) // 2\n\nprint(answer)", "score": 1.0, "codebleu": 0.23074092695025478, "crystalbleu": 0.052989305111456796, "codebertscore": 0.79, "codescore": 0.23003371059894562, "surfaceSim": 0.4430051813471503, "abs_surfaceSim_minus_score": 0.5569948186528497}
{"golden_code": "from collections import defaultdict\n\nimport numpy as np\n\ndef main():\n\n    s = eval(input())\n\n    n = len(s)\n\n    d = np.zeros(2019,np.int64)\n\n    ans = 0\n\n    num = 0\n\n    pow10 = 1\n\n    d[0] = 1\n\n    for i in reversed(list(range(n))):\n\n        pow10 = pow10 * 10 % 2019\n\n        num += int(s[i]) * pow10\n\n        #print(num, num % 2019, i)\n\n        mod = num % 2019\n\n        ans += d[mod]\n\n        d[mod] += 1\n\n    print(ans)\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "generated_code": "from collections import defaultdict\n\n\n\ndef main():\n\n    s = eval(input())\n\n    n = len(s)\n\n    ans = 0\n\n    num = 0\n\n    pow10 = 1\n\n    d = defaultdict(int)\n\n    d[0] = 1\n\n    for i in reversed(list(range(n))):\n\n        # pow10を10 ** (n-1-i)にしてるだけでTLEしていた\n\n        pow10 = pow10 * 10 % 2019\n\n        num += int(s[i]) * pow10\n\n        mod = num % 2019\n\n        ans += d[mod]\n\n        d[mod] += 1\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "score": 1.0, "codebleu": 0.6604584671820345, "crystalbleu": 0.8467833182814646, "codebertscore": 0.91, "codescore": 0.01852288283407688, "surfaceSim": 0.9002985074626866, "abs_surfaceSim_minus_score": 0.09970149253731342}
{"golden_code": "import numpy as np\n\n\n\nn = int(eval(input()))\n\nv = np.array(list(map(int, input().split())))\n\nc = np.array(list(map(int, input().split())))\n\np = v-c\n\nans = 0\n\nfor i in p:\n\n    if i>0:\n\n        ans+=i\n\n\n\nprint(ans)\n", "generated_code": "n=int(eval(input()))\n\nV=list(map(int,input().split()))\n\nC=list(map(int,input().split()))\n\nans=0\n\nfor v,c in zip(V,C):\n\n    diff=v-c\n\n    if 0<diff:\n\n        ans+=diff\n\nprint(ans)", "score": 1.0, "codebleu": 0.29762443362993635, "crystalbleu": 0.3229475823434128, "codebertscore": 0.88, "codescore": 0.7383490204811096, "surfaceSim": 0.7166331321260898, "abs_surfaceSim_minus_score": 0.2833668678739102}
{"golden_code": "# -*- coding: utf-8 -*-\n\n\n\nimport sys\n\nfrom collections import Counter\n\n\n\ndef input(): return sys.stdin.readline().strip()\n\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\n\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\n\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\n\ndef ceil(x, y=1): return int(-(-x // y))\n\ndef INT(): return int(eval(input()))\n\ndef MAP(): return list(map(int, input().split()))\n\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\n\ndef Yes(): print('Yes')\n\ndef No(): print('No')\n\ndef YES(): print('YES')\n\ndef NO(): print('NO')\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = 10 ** 18\n\nMOD = 10 ** 9 + 7\n\n\n\ndef fft(A, B):\n\n    \"\"\" \n\n    高速フーリエ変換(FFT)\n\n        A：出現回数をカウントしたリスト\n\n        B：出現回数をカウントしたリスト\n\n    \"\"\"\n\n    import numpy as np\n\n    from numpy.fft import rfft, irfft\n\n\n\n    # 出現数カウント\n\n    MAXA = max(A)\n\n    MAXB = max(B)\n\n    C1 = [0] * (MAXA+1)\n\n    C2 = [0] * (MAXB+1)\n\n    for a in A:\n\n        C1[a] += 1\n\n    for b in B:\n\n        C2[b] += 1\n\n    # max(A)+max(B)より大きい2冪\n\n    L = 1\n\n    k = 0\n\n    while L <= MAXA + MAXB:\n\n        k += 1\n\n        L = 2**k\n\n    # FFT\n\n    res = irfft(rfft(C1, L) * rfft(C2, L), L)\n\n    # 四捨五入して整数に\n\n    res = np.rint(res).astype(np.int64)\n\n    return res\n\n\n\nN, M, L = MAP()\n\nA = LIST()\n\nB = LIST()\n\n\n\nres = list(fft(A, B))\n\n\n\nmn = INF\n\nfor i, a in enumerate(res):\n\n    if a != 0:\n\n        mn = i\n\n        break\n\n\n\nfor _ in range(L):\n\n    x, y, c = MAP()\n\n    x -= 1; y -= 1\n\n    mn = min(mn, A[x] + B[y] - c)\n\nprint(mn)\n", "generated_code": "# -*- coding: utf-8 -*-\n\n\n\nimport sys\n\nfrom collections import Counter\n\n\n\ndef input(): return sys.stdin.readline().strip()\n\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\n\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\n\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\n\ndef ceil(x, y=1): return int(-(-x // y))\n\ndef INT(): return int(eval(input()))\n\ndef MAP(): return list(map(int, input().split()))\n\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\n\ndef Yes(): print('Yes')\n\ndef No(): print('No')\n\ndef YES(): print('YES')\n\ndef NO(): print('NO')\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = 10 ** 18\n\nMOD = 10 ** 9 + 7\n\n\n\nN, M, L = MAP()\n\nA = LIST()\n\nB = LIST()\n\n\n\nmn = min(A) + min(B)\n\nfor _ in range(L):\n\n    x, y, c = MAP()\n\n    x -= 1; y -= 1\n\n    mn = min(mn, A[x] + B[y] - c)\n\nprint(mn)\n", "score": 1.0, "codebleu": 0.6020281576727804, "crystalbleu": 0.6206387260897029, "codebertscore": 0.89, "codescore": 0.25718334317207336, "surfaceSim": 0.8161741713570982, "abs_surfaceSim_minus_score": 0.18382582864290176}
{"golden_code": "N,M,K = list(map(int,input().split()))\n\n\n\nfor i in range(N+1):\n\n    for j in range(M+1):\n\n        t = i*M + j*N - i*j*2\n\n        if t==K:\n\n            print('Yes')\n\n            exit()\n\nprint('No')", "generated_code": "N,M,K = list(map(int,input().split()))\n\n\n\nfor i in range(N+1):\n\n    for j in range(M+1):\n\n        if i*(M-j) + j*(N-i) == K:\n\n            print('Yes')\n\n            exit()\n\nprint('No')", "score": 1.0, "codebleu": 0.6557212908234747, "crystalbleu": 0.7989770211677567, "codebertscore": 0.96, "codescore": 0.9445164799690247, "surfaceSim": 0.9642857142857143, "abs_surfaceSim_minus_score": 0.0357142857142857}
{"golden_code": "from math import sqrt\n\nfrom bisect import bisect_left\n\ndef circle_center(x1, y1, x2, y2):\n\n    xd = x2 - x1; yd = y2 - y1\n\n    d = xd**2 + yd**2\n\n    k = sqrt((4.0 - d) / d) / 2.0\n\n    xc = (x1 + x2) / 2.0\n\n    yc = (y1 + y2) / 2.0\n\n    return [[xc - k*yd, yc + k*xd], [xc + k*yd, yc - k*xd]]\n\nwhile 1:\n\n    n = int(input())\n\n    if n==0: break\n\n    p = [list(map(float, input().split())) for i in range(n)]\n\n    p.sort()\n\n    prev = 0\n\n    ans = 1\n\n    for i in range(n):\n\n        bx, by = p[i]\n\n        while bx - p[prev][0] >= 2.0: prev += 1\n\n        for j in range(i+1, n):\n\n            cx, cy = p[j]\n\n            if cx - bx >= 2.0: break\n\n            if (bx - cx)**2 + (by - cy)**2 <= 4.0:\n\n                for ex, ey in circle_center(bx, by, cx, cy):\n\n                    count = 2\n\n                    for k in range(prev, n):\n\n                        if k==i or k==j: continue\n\n                        dx, dy = p[k]\n\n                        if dx - bx >= 2.0: break\n\n                        if (ex - dx)**2 + (ey - dy)**2 <= 1.0:\n\n                            count += 1\n\n                    ans = max(ans, count)\n\n    print(ans)", "generated_code": "from math import sqrt\n\nfrom bisect import bisect_left\n\ndef circle_center(x1, y1, x2, y2):\n\n    xd = x2 - x1; yd = y2 - y1\n\n    d = xd**2 + yd**2\n\n    k = sqrt((4.0 - d) / d) / 2.0\n\n    xc = (x1 + x2) / 2.0; yc = (y1 + y2) / 2.0\n\n    xd *= k; yd *= k\n\n    return [[xc - yd, yc + xd], [xc + yd, yc - xd]]\n\nwhile 1:\n\n    n = int(input())\n\n    if n==0: break\n\n    p = sorted(list(map(float, input().split())) for i in range(n))\n\n    prev = 0\n\n    ans = 1\n\n    for i in range(n):\n\n        bx, by = p[i]\n\n        while bx - p[prev][0] >= 2.0: prev += 1\n\n        for j in range(i+1, n):\n\n            cx, cy = p[j]\n\n            if cx - bx >= 2.0: break\n\n            if (bx - cx)**2 + (by - cy)**2 <= 4.0:\n\n                for ex, ey in circle_center(bx, by, cx, cy):\n\n                    count = 2\n\n                    for k in range(prev, n):\n\n                        if k==i or k==j: continue\n\n                        dx, dy = p[k]\n\n                        if dx - ex >= 1.0: break\n\n                        if (ex - dx)**2 + (ey - dy)**2 <= 1.0:\n\n                            count += 1\n\n                    ans = max(ans, count)\n\n    print(ans)", "score": 1.0, "codebleu": 0.8725141875683035, "crystalbleu": 0.897185654793022, "codebertscore": 0.98, "codescore": 0.9436722993850708, "surfaceSim": 0.9578646748681898, "abs_surfaceSim_minus_score": 0.042135325131810175}
{"golden_code": "import numpy as np\n\nN = int(eval(input()))\n\nVlist = np.array(list(map(int,input().split())))\n\nClist = np.array(list(map(int,input().split())))\n\n\n\nDlist = Vlist-Clist\n\n\n\nsum_ = 0\n\nfor d in Dlist:\n\n    if d >= 0:\n\n        sum_ += d\n\n\n\nprint(sum_)\n", "generated_code": "# 入力\n\nN = int(eval(input()))\n\nVlist = list(map(int, input().split()))\n\nClist = list(map(int, input().split()))\n\n\n\nans = 0\n\nfor i in range(N):\n\n    Z = Vlist[i] - Clist[i]\n\n    if Z > 0:\n\n        ans += Z\n\n\n\nprint(ans)\n", "score": 1.0, "codebleu": 0.3702720442864497, "crystalbleu": 0.2714626260738996, "codebertscore": 0.87, "codescore": 0.8143474459648132, "surfaceSim": 0.6983302411873841, "abs_surfaceSim_minus_score": 0.30166975881261593}
{"golden_code": "import numpy as np\n\nk,n = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\nb = np.zeros(n)\n\nfor i in range(0,n-1):\n\n  b[i] = a[i+1] -a[i]\n\n  \n\nb[n-1] = k - a[n-1] + a[0]\n\nans = k - max(b)\n\nprint((int(ans)))", "generated_code": "k,n = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\nb = [0 for i in range(n)]\n\nfor i in range(0,n-1):\n\n  b[i] = a[i+1] -a[i]\n\n\n\nb[n-1] = k - a[n-1] + a[0]\n\nans = k - max(b)\n\nprint((int(ans)))", "score": 1.0, "codebleu": 0.711035896451019, "crystalbleu": 0.8076589700572653, "codebertscore": 0.95, "codescore": 0.6412950754165649, "surfaceSim": 0.8361233480176211, "abs_surfaceSim_minus_score": 0.16387665198237888}
{"golden_code": "def main():\n\n\tn, ma, mb, *L = list(map(int, open(0).read().split()))\n\n\tM = 1<<30\n\n\tdp = [[M] * 420 for _ in range(420)]\n\n\tdp[0][0] = 0\n\n\tfor a, b, c in zip(*[iter(L)] * 3):\n\n\t\tfor i in range(400, -1, -1):\n\n\t\t\tfor j in range(400, -1, -1):\n\n\t\t\t\tt = dp[i][j] + c\n\n\t\t\t\tif dp[i + a][j + b] > t:\n\n\t\t\t\t\tdp[i + a][j + b] = t\n\n\tans = M\n\n\t_ma, _mb = ma, mb\n\n\twhile _ma < 410 > _mb:\n\n\t\tans = min(ans, dp[_ma][_mb])\n\n\t\t_ma += ma\n\n\t\t_mb += mb\n\n\tprint((ans if ans < M else -1))\n\n\n\nif __name__==\"__main__\":\n\n\tmain()", "generated_code": "def main():\n\n\tn, ma, mb, *L = list(map(int, open(0).read().split()))\n\n\tM = 1 << 30\n\n\tdp = [[M] * 420 for _ in range(420)]\n\n\tdp[0][0] = 0\n\n\tua = ub = 15\n\n\tfor a, b, c in zip(*[iter(L)] * 3):\n\n\t\tfor i in range(ua, -1, -1):\n\n\t\t\tfor j in range(ub, -1, -1):\n\n\t\t\t\tt = dp[i][j] + c\n\n\t\t\t\tif dp[i + a][j + b] > t:\n\n\t\t\t\t\tdp[i + a][j + b] = t\n\n\t\t\t\t\tif ua < i + a:\n\n\t\t\t\t\t\tua = i + a\n\n\t\t\t\t\tif ub < j + b:\n\n\t\t\t\t\t\tub = j + b\n\n\tans = M\n\n\t_ma, _mb = ma, mb\n\n\twhile _ma < 410 > _mb:\n\n\t\tans = min(ans, dp[_ma][_mb])\n\n\t\t_ma += ma\n\n\t\t_mb += mb\n\n\tprint((ans if ans < M else -1))\n\n\n\n\n\nif __name__ == \"__main__\":\n\n\tmain()\n", "score": 1.0, "codebleu": 0.7950137941783344, "crystalbleu": 0.8238017274344019, "codebertscore": 0.95, "codescore": 0.0350712388753891, "surfaceSim": 0.9590301003344481, "abs_surfaceSim_minus_score": 0.04096989966555187}
{"golden_code": "import sys\n\nimport numpy as np \n\n\n\nn, l = list(map(int, sys.stdin.readline().split()))\n\n\n\ndef main():\n\n    f = l + np.arange(1, n+1) - 1\n\n    s = f.sum()\n\n    a = np.absolute(f)\n\n    mi = np.amin(a)\n\n    i = np.argwhere(a == mi)[0, 0]\n\n    return s - f[i]\n\n\n\nif __name__ == '__main__':\n\n    ans = main()\n\n    print(ans)", "generated_code": "import sys\n\n\n\nn, l = list(map(int, sys.stdin.readline().split()))\n\n\n\ndef main():\n\n    s = (l - 1) * n + (1 + n) * n // 2\n\n    res = []\n\n    for i in range(1, n+1):\n\n        f = l + i - 1\n\n        res.append((abs(f), s - f))\n\n    \n\n    res.sort()\n\n    return res[0][1]\n\n\n\nif __name__=='__main__':\n\n    ans = main()\n\n    print(ans)", "score": 1.0, "codebleu": 0.36882509177801026, "crystalbleu": 0.3441407826763586, "codebertscore": 0.87, "codescore": 0.018539518117904663, "surfaceSim": 0.7693909715186311, "abs_surfaceSim_minus_score": 0.23060902848136888}
{"golden_code": "import sys\n\ninput = sys.stdin.readline\n\n\n\nn, m = list(map(int, input().split()))\n\nbroken = set([int(eval(input())) for _ in range(m)]) # ここが'list'だとPypyでも通らない\n\n\n\ndef ptn_num(x): # 'x'stepまでのパターン数\n\n    dp = [0] * (x+1) # DP枠_including step'0'\n\n    if 1 in broken: # in case, step'1' broken \n\n        dp[:2] = 1, 0\n\n    else:\n\n        dp[:2] = 1, 1 # Usually\n\n\n\n    for i in range(2, x+1):\n\n        if i not in broken: # 階段が壊れてない場合...\n\n            dp[i] = (dp[i-1] + dp[i-2]) % (10**9+7) # -1段目と-2段目の合計\n\n    print((dp[-1]))\n\n\n\nptn_num(n)\n", "generated_code": "import sys\n\ninput = sys.stdin.readline\n\n\n\nn, m = list(map(int, input().split()))\n\nbroken = set([int(eval(input())) for _ in range(m)]) # ここが'list'だとPypyでも通らない\n\n\n\ndef ptn_num(x): # 'x'stepまでのパターン数\n\n    dp = [0] * (x+1) # DP枠_including step'0'\n\n    if 1 in broken: # 固定部分_in case, step'1' broken \n\n        dp[:2] = 1, 0\n\n    else:\n\n        dp[:2] = 1, 1 # 固定部分_Usually\n\n\n\n    for i in range(2, x+1):\n\n        if i not in broken: # 階段が壊れてない場合...\n\n            dp[i] = (dp[i-1] + dp[i-2]) % (10**9+7) # -1段目と-2段目の合計\n\n    print((dp[-1]))\n\n\n\nptn_num(n)", "score": 1.0, "codebleu": 0.9636621435803967, "crystalbleu": 1.0, "codebertscore": 0.97, "codescore": 0.9937649965286255, "surfaceSim": 1.0, "abs_surfaceSim_minus_score": 0.0}
{"golden_code": "import sys\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\nreadlines = sys.stdin.readlines\n\n\n\ndef main():\n\n    S = readline().strip()\n\n    T = readline().strip()\n\n\n\n    idx_in_S = []\n\n    last_idx = 0\n\n    for t in T:\n\n        t_idx = S.find(t, last_idx) + 1\n\n        if t_idx:\n\n            idx_in_S.append(t_idx)\n\n            last_idx = t_idx\n\n        else:\n\n            t_idx = S.find(t, 0, last_idx) + 1\n\n            if not t_idx:\n\n                print((-1))\n\n                exit()\n\n            else:\n\n                idx_in_S.append(t_idx)\n\n                last_idx = t_idx\n\n\n\n    \n\n    rep = 0\n\n    for i in range(len(T) - 1):\n\n        if idx_in_S[i] < idx_in_S[i+1]:\n\n            continue\n\n        else:\n\n            rep += 1\n\n\n\n    ans = len(S) * rep + idx_in_S[-1]\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "generated_code": "# S.find()の部分を高速化する\n\nfrom collections import defaultdict\n\nfrom bisect import bisect_right\n\nimport sys\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\nreadlines = sys.stdin.readlines\n\n\n\ndef main():\n\n    S = readline().strip()\n\n    T = readline().strip()\n\n\n\n    S_idx = defaultdict(list)\n\n    for i, s in enumerate(S):\n\n        S_idx[s].append(i)\n\n    \n\n    rep = 0\n\n    last_idx = -1\n\n    for t in T:\n\n        t_idx_list = S_idx[t]\n\n        if t_idx_list:\n\n            t_idx = bisect_right(t_idx_list, last_idx)\n\n            if t_idx < len(t_idx_list):\n\n                last_idx = t_idx_list[t_idx]\n\n            else:\n\n                last_idx = t_idx_list[0]\n\n                rep += 1\n\n        else:\n\n            print((-1))\n\n            exit()\n\n    \n\n    ans = len(S) * rep + last_idx + 1\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "score": 1.0, "codebleu": 0.4446713140575135, "crystalbleu": 0.402424502714305, "codebertscore": 0.87, "codescore": 0.023134766146540642, "surfaceSim": 0.7405557176196033, "abs_surfaceSim_minus_score": 0.25944428238039674}
{"golden_code": "N, D = list(map(int, input().split()))\n\ncount = 0\n\nfor i in range(N):\n\n    a, b = list(map(int, input().split()))\n\n    if (a**2 + b**2) <= D**2:\n\n        count += 1\n\nprint(count)\n", "generated_code": "N, D = list(map(int, input().split()))\n\ncount = 0\n\nfor i in range(N):\n\n    a, b = list(map(int, input().split()))\n\n    if (a*a + b*b) <= D*D:\n\n        count += 1\n\nprint(count)\n", "score": 1.0, "codebleu": 0.8234237254204527, "crystalbleu": 0.8235513743313198, "codebertscore": 0.96, "codescore": 0.5805941820144653, "surfaceSim": 0.9306086445163188, "abs_surfaceSim_minus_score": 0.06939135548368125}
{"golden_code": "import sys\n\ninput = sys.stdin.readline\n\n \n\ns = input().rstrip()\n\nk = int(eval(input()))\n\n    \n\ndef check_count(s):\n\n    cnt_list = [1]\n\n    cnt = 1\n\n    for i in range(1, len(s)):\n\n        if s[i-1] == s[i]:\n\n            cnt_list[-1] += 1\n\n        else:\n\n            cnt_list.append(1)\n\n    return cnt_list\n\n\n\ndef calc_ans(cnt_list, k):\n\n    _ans = 0\n\n    for c in cnt_list:\n\n        _ans += c//2\n\n    return(_ans * k)\n\n\n\nif len(s)==1:\n\n    ans = k//2\n\nelse:\n\n    cnt_list = check_count(s)\n\n    if len(cnt_list)==1:\n\n        ans = (len(s)*k)//2\n\n    else:\n\n        ans = calc_ans(cnt_list, k)\n\n        if s[0]==s[-1]:\n\n            if cnt_list[0]%2==1 and cnt_list[-1]%2==1:\n\n                ans += k - 1\n\n\n\nprint(ans)", "generated_code": "import sys\n\ninput = sys.stdin.readline\n\n \n\ns = input().rstrip()\n\nk = int(eval(input()))\n\n\n\ndef check_count(s):\n\n    cnt_list = []\n\n    cnt = 1\n\n    for i in range(1, len(s)):\n\n        if s[i-1] == s[i]:\n\n            cnt += 1\n\n        else:\n\n            cnt_list.append(cnt)\n\n            cnt = 1\n\n    if cnt>1:\n\n        cnt_list.append(cnt)\n\n    return cnt_list\n\n\n\ndef calc_ans(cnt_list, k):\n\n    _ans = 0\n\n    for c in cnt_list:\n\n        _ans += c//2\n\n    return(_ans * k)\n\n\n\nif len(s)==1:\n\n    ans = k//2\n\nelse:\n\n    cnt_list = check_count(s)\n\n    if len(cnt_list)==1:\n\n        ans = (len(s)*k)//2\n\n    else:\n\n        ans = calc_ans(cnt_list, k)\n\n        if s[0]==s[-1]:\n\n            if cnt_list[0]%2==1 and cnt_list[-1]%2==1:\n\n                ans += k - 1\n\n\n\nprint(ans)", "score": 1.0, "codebleu": 0.8367322296865563, "crystalbleu": 0.8992156272013391, "codebertscore": 0.97, "codescore": 0.9938544034957886, "surfaceSim": 0.9593537804226748, "abs_surfaceSim_minus_score": 0.04064621957732517}
{"golden_code": "from sys import stdin,stdout\n\n\n\nif __name__==\"__main__\":\n\n    n=int(stdin.readline())\n\n\n\n    a=[int(x) for x in stdin.readline().split()]\n\n    b=[int(x) for x in stdin.readline().split()]\n\n\n\n    cnt=0\n\n\n\n    for i in range(n):\n\n        if(a[i]>=b[i]):\n\n            cnt+=b[i]\n\n        else:\n\n            cnt+=a[i]\n\n            d=b[i]-a[i]\n\n            cnt+=min(a[i+1],d)\n\n            if(d>a[i+1]):\n\n                a[i+1]=0\n\n            else: a[i+1]-=d\n\n            \n\n    stdout.write(str(cnt)+\"\\n\")\n", "generated_code": "n = int(eval(input()))\n\nA = list(map(int, input().split()))\n\nB = list(map(int, input().split()))\n\na1 = sum(A)\n\nfor i in range(n):\n\n  b = B[i]\n\n  if A[i] >= b:A[i] -= b\n\n  else:\n\n    if A[i+1]+A[i] >= b:\n\n      A[i+1] = A[i+1]+A[i]-b\n\n      A[i] = 0\n\n    else:A[i], A[i+1] = 0, 0\n\na2 = sum(A)\n\nprint((a1-a2))", "score": 1.0, "codebleu": 0.24673195657983402, "crystalbleu": 0.13273061840367759, "codebertscore": 0.79, "codescore": 0.15616793930530548, "surfaceSim": 0.6559657777092647, "abs_surfaceSim_minus_score": 0.3440342222907353}
{"golden_code": "import fractions\n\nimport sys\n\ninput = sys.stdin.readline\n\n\n\nN,M=list(map(int,input().split()))\n\na = list(map(int, input().split()))\n\n\n\n\n\nlcm = a[0]\n\nfor i in range(1, N):\n\n    g= fractions.gcd(lcm, a[i])\n\n    lcm = lcm * a[i] // g\n\n\n\n\n\ng=a[0]\n\nfor i in range(N):\n\n    g=fractions.gcd(g,a[i])\n\n\n\nfor i in range(N):\n\n    if (a[i]//g)%2==0:\n\n        lcm=0\n\n        break    \n\n    \n\n    \n\nans=0\n\nl=lcm//2\n\nif l:\n\n    ans=(M//l)-(M//(l+l))\n\nprint(ans)\n\n\n", "generated_code": "import sys\n\ninput = sys.stdin.readline\n\n\n\ndef I(): return int(eval(input()))\n\ndef MI(): return list(map(int, input().split()))\n\ndef LI(): return list(map(int, input().split()))\n\n\n\n\"\"\"\n\n2X = ak * (2p+1)\n\n基本的には最小公倍数/2を基本とし，これの奇数倍か．\n\n\n\nX  = (ak//2) * (2p+1)\n\nと書ける．第二項が奇数なので，各akが2で割り切れれう回数が同じでなければならない\n\na=[2,4]だと無理\n\n\"\"\"\n\ndef main():\n\n    from math import gcd\n\n    N,M=MI()\n\n    A=LI()\n\n    \n\n    def count(X):\n\n        cnt=0\n\n        while X%2==0:\n\n            cnt+=1\n\n            X=X//2\n\n        return cnt\n\n    \n\n    C=count(A[0])\n\n    for i in range(1,N):\n\n        if count(A[i])!=C:\n\n            print((0))\n\n            exit()\n\n            \n\n    lca=1\n\n    for i in range(N):\n\n        g=gcd(lca,A[i])\n\n        lca=(lca*A[i])//g\n\n        \n\n    lca2=lca//2\n\n    ans=M//lca2 - M//lca\n\n    \n\n    print(ans)\n\n    \n\n            \n\n    \n\n\n\nmain()\n", "score": 1.0, "codebleu": 0.30823003077411093, "crystalbleu": 0.3059824573411566, "codebertscore": 0.78, "codescore": 0.9904430508613586, "surfaceSim": 0.6365803445660418, "abs_surfaceSim_minus_score": 0.36341965543395816}
{"golden_code": "#                         author:  kagemeka \n\n#                         created: 2019-11-08 14:51:29(JST)\n\n## internal modules\n\nimport sys\n\n# import collections\n\n# import math\n\n# import string\n\n# import bisect\n\n# import re\n\n# import itertools\n\nimport statistics\n\n# import functools\n\n# import operator\n\n## external modules\n\n# import scipy.special   # if use comb function on AtCoder, \n\n# import scipy.misc      # select scipy.misc.comb (old version) \n\n\n\ndef main():\n\n    n, *a = (int(x) for x in sys.stdin.read().split())\n\n    \n\n    for i in range(n):\n\n        a[i] -= (i + 1)\n\n\n\n    if n % 2 != 0:\n\n        b = statistics.median(a)\n\n    else:\n\n        if a.count(statistics.median_high(a)) >= a.count(statistics.median_low(a)):\n\n            b = statistics.median_high(a)\n\n        else:\n\n            b = statistics.median_low(a)\n\n    \n\n    ans = sum([abs(a[i] - b) for i in range(n)])\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    # execute only if run as a script\n\n    main()\n\n\n\n\n", "generated_code": "import sys\n\n\n\nn, *a = list(map(int, sys.stdin.read().split()))\n\n\n\ndef main():\n\n    for i in range(n):\n\n        a[i] -= (i + 1)\n\n    a.sort()\n\n    b = a[n // 2]\n\n    res = 0\n\n    for i in range(n):\n\n        res += abs(a[i] - b)\n\n    \n\n    return res\n\n    \n\nif __name__ == '__main__':\n\n    ans = main()\n\n    print(ans)", "score": 1.0, "codebleu": 0.2878900710030735, "crystalbleu": 0.2880074381064377, "codebertscore": 0.75, "codescore": 0.01887226477265358, "surfaceSim": 0.7541678179976052, "abs_surfaceSim_minus_score": 0.24583218200239476}
{"golden_code": "l,r=list(map(int,input().split()))\n\ns=list(range(l,r+1))[:2019]\n\nprint((min(i*j%2019for i in s for j in s if i<j)))", "generated_code": "l,r=list(map(int,input().split()));s=list(range(l,r+1))[:673];print((min(i*j%2019for i in s for j in s if i<j)))", "score": 1.0, "codebleu": 0.8656298019485317, "crystalbleu": 0.0, "codebertscore": 0.97, "codescore": 0.9777902364730835, "surfaceSim": 0.9739130434782608, "abs_surfaceSim_minus_score": 0.026086956521739202}
{"golden_code": "a, b, c, x, y = list(map(int, input().split()))\n\nans = float('inf')\n\n\n\nfor i in range(200005):\n\n    tmp = i * 2 * c\n\n    tmp += max(0, x-i) * a\n\n    tmp += max(0, y-i) * b\n\n    ans = min(ans, tmp)\n\n\n\nprint(ans)", "generated_code": "a, b, c, x, y = list(map(int, input().split()))\n\nans = float('inf')\n\n\n\nfor i in range(100005):\n\n    tmp = i * 2 * c\n\n    tmp += max(0, x-i) * a\n\n    tmp += max(0, y-i) * b\n\n    ans = min(ans, tmp)\n\n\n\nprint(ans)", "score": 1.0, "codebleu": 0.9661796765376377, "crystalbleu": 0.943530344863199, "codebertscore": 0.99, "codescore": 0.9937670230865479, "surfaceSim": 0.9976190476190476, "abs_surfaceSim_minus_score": 0.0023809523809523725}
{"golden_code": "import sys\n\ninput = sys.stdin.readline\n\nsys.setrecursionlimit(10**7)\n\nINF = 10**10\n\nMOD = 10**9 + 7\n\nX = int(eval(input()))\n\nfor i in range(1000):\n\n    for j in range(-1000,1000):\n\n        #print (i**5 - j**5)\n\n        if i**5 - j**5 == X:\n\n            print((i,j))\n\n            exit()\n\n   ", "generated_code": "import sys\n\ninput = sys.stdin.readline\n\nsys.setrecursionlimit(10**7)\n\nINF = 10**10\n\nMOD = 10**9 + 7\n\nX = int(eval(input()))\n\nMAX_X = 10**9\n\nn = 0\n\nwhile(1):\n\n    n+=1\n\n    if n**5 - (n-1)**5 > MAX_X:\n\n        break\n\nfor i in range(n):\n\n    for j in range(-n+1,n-1):\n\n        if i**5 - j**5 == X:\n\n            print((i,j))\n\n            exit()\n\n   ", "score": 1.0, "codebleu": 0.6920880411136854, "crystalbleu": 0.5821554665807663, "codebertscore": 0.92, "codescore": 0.838947057723999, "surfaceSim": 0.8190306803023566, "abs_surfaceSim_minus_score": 0.1809693196976434}
{"golden_code": "n = int(eval(input()))\n\nl = list(map(int, input().split()))\n\nprint((sum(l[i]<l[i+1]<l[i+2] or l[i]>l[i+1]>l[i+2] for i in range(n-2))))", "generated_code": "n=int(eval(input()))\n\nl=list(map(int,input().split()))\n\na=0\n\nfor i in range(n-2):\n\n  p,q,r=l[i:i+3]\n\n  if p<q<r or r<q<p: a+=1\n\nprint(a)", "score": 1.0, "codebleu": 0.3181606641624132, "crystalbleu": 0.0, "codebertscore": 0.87, "codescore": 0.968499481678009, "surfaceSim": 0.6026583710407241, "abs_surfaceSim_minus_score": 0.39734162895927594}
{"golden_code": "n = int(eval(input()))\n\ns = input().split()\n\ns = set(s)\n\nprint(('Four' if len(s) == 4 else 'Three'))", "generated_code": "n = int(eval(input()))\n\ns = input().split()\n\nprint(('Four' if len(set(s)) == 4 else 'Three'))", "score": 1.0, "codebleu": 0.6072373739061012, "crystalbleu": 0.0, "codebertscore": 0.98, "codescore": 0.9937612414360046, "surfaceSim": 0.9299999999999999, "abs_surfaceSim_minus_score": 0.07000000000000006}
{"golden_code": "import sys\n\nif sys.argv[-1] == 'ONLINE_JUDGE':\n\n    import os\n\n    import re\n\n    with open(__file__) as f:\n\n        source = f.read().split('###''nbacl')\n\n    for s in source[1:]:\n\n        s = re.sub(\"'''.*\", '', s)\n\n        sp = s.split(maxsplit=1)\n\n        if os.path.dirname(sp[0]):\n\n            os.makedirs(os.path.dirname(sp[0]), exist_ok=True)\n\n        with open(sp[0], 'w') as f:\n\n            f.write(sp[1])\n\n    from nbmodule import cc\n\n    cc.compile()\n\nimport numpy as np\n\nfrom numpy import int64\n\nfrom nbmodule import solve\n\n\n\n\n\nf = open(0)\n\nN, K = [int(x) for x in f.readline().split()]\n\nA = np.fromstring(f.read(), dtype=int64, sep=' ')\n\nans = solve(N, K, A)\n\nprint(ans)\n\n\n\n'''\n\n###nbacl nbmodule.py\n\nimport numpy as np\n\nfrom numpy import int64\n\nfrom numba import njit\n\nfrom numba.types import i8\n\nfrom numba.pycc import CC\n\nimport nbacl.segtree as seg\n\ncc = CC('my_module')\n\n\n\n\n\n@cc.export('solve', (i8, i8, i8[:]))\n\n@njit\n\ndef solve(N, K, A):\n\n    dp = np.zeros(300_001, dtype=int64)\n\n    d = seg.segtree(dp, max, 0)\n\n    for i in range(N):\n\n        x = seg.prod(d, max, (A[i] - K) if A[i] > K else 0, (A[i] + K + 1) if A[i] + K < 300_000 else 300_001) + 1\n\n        seg.set(d, max, A[i], x)\n\n    return seg.all_prod(d)\n\n\n\n\n\nif __name__ == '__main__':\n\n    cc.compile()\n\n###nbacl nbacl/segtree.py\n\nimport numpy as np\n\nfrom numba import njit\n\nfrom numba.types import i8\n\n\n\n\n\n@njit\n\ndef ceil_pow2(n):\n\n    x = 0\n\n    while (1 << x) < n:\n\n        x += 1\n\n    return x\n\n\n\n\n\n@njit\n\ndef segtree(a, op, e):\n\n    log = ceil_pow2(a.shape[0])\n\n    size = 1 << log\n\n    d = np.empty(size * 2, dtype=a.dtype)\n\n    d[size:size + len(a)] = a\n\n    d[size + len(a):] = e\n\n    # e\n\n    d[0] = e\n\n    for i in range(size - 1, 0, -1):\n\n        update(d, i, op)\n\n    return d\n\n\n\n\n\n@njit\n\ndef update(d, k, op):\n\n    d[k] = op(d[2 * k], d[2 * k + 1])\n\n\n\n\n\n@njit\n\ndef set(d, op, p, x):\n\n    p += d.shape[0] // 2\n\n    d[p] = x\n\n    while p > 1:\n\n        p >>= 1\n\n        update(d, p, op)\n\n\n\n\n\n@njit\n\ndef get(d, p):\n\n    return d[p + d.shape[0] // 2]\n\n\n\n\n\n@njit\n\ndef prod(d, op, left, right):\n\n    size = d.shape[0] // 2\n\n    sml = d[0]\n\n    smr = d[0]\n\n    left += size\n\n    right += size\n\n\n\n    while left < right:\n\n        if left & 1:\n\n            sml = op(sml, d[left])\n\n            left += 1\n\n        if right & 1:\n\n            right -= 1\n\n            smr = op(d[right], smr)\n\n        left >>= 1\n\n        right >>= 1\n\n\n\n    return op(sml, smr)\n\n\n\n\n\n@njit\n\ndef all_prod(d):\n\n    return d[1]\n\n\n\n'''\n", "generated_code": "import sys\n\nif sys.argv[-1] == 'ONLINE_JUDGE':\n\n    import os\n\n    import re\n\n    with open(__file__) as f:\n\n        source = f.read().split('###''nbacl')\n\n    for s in source[1:]:\n\n        s = re.sub(\"'''.*\", '', s)\n\n        sp = s.split(maxsplit=1)\n\n        if os.path.dirname(sp[0]):\n\n            os.makedirs(os.path.dirname(sp[0]), exist_ok=True)\n\n        with open(sp[0], 'w') as f:\n\n            f.write(sp[1])\n\n    from nbmodule import cc\n\n    cc.compile()\n\nimport numpy as np\n\nfrom numpy import int64\n\nfrom nbmodule import solve\n\n\n\n\n\nf = open(0)\n\nN, K = [int(x) for x in f.readline().split()]\n\nA = np.fromstring(f.read(), dtype=int64, sep=' ')\n\nans = solve(N, K, A)\n\nprint(ans)\n\n\n\n'''\n\n###nbacl nbmodule.py\n\nimport numpy as np\n\nfrom numpy import int64\n\nfrom numba import njit\n\nfrom numba.types import i8\n\nfrom numba.pycc import CC\n\nimport nbacl.segtree as seg\n\ncc = CC('nbmodule')\n\n\n\n\n\n@cc.export('solve', (i8, i8, i8[:]))\n\n@njit\n\ndef solve(N, K, A):\n\n    dp = np.zeros(300_001, dtype=int64)\n\n    d = seg.segtree(dp, max, 0)\n\n    for i in range(N):\n\n        x = seg.prod(d, max, (A[i] - K) if A[i] > K else 0, (A[i] + K + 1) if A[i] + K < 300_000 else 300_001) + 1\n\n        seg.set(d, max, A[i], x)\n\n    return seg.all_prod(d)\n\n\n\n\n\nif __name__ == '__main__':\n\n    cc.compile()\n\n###nbacl nbacl/segtree.py\n\nimport numpy as np\n\nfrom numba import njit\n\nfrom numba.types import i8\n\n\n\n\n\n@njit\n\ndef ceil_pow2(n):\n\n    x = 0\n\n    while (1 << x) < n:\n\n        x += 1\n\n    return x\n\n\n\n\n\n@njit\n\ndef segtree(a, op, e):\n\n    log = ceil_pow2(a.shape[0])\n\n    size = 1 << log\n\n    d = np.empty(size * 2, dtype=a.dtype)\n\n    d[size:size + len(a)] = a\n\n    d[size + len(a):] = e\n\n    # e\n\n    d[0] = e\n\n    for i in range(size - 1, 0, -1):\n\n        update(d, i, op)\n\n    return d\n\n\n\n\n\n@njit\n\ndef update(d, k, op):\n\n    d[k] = op(d[2 * k], d[2 * k + 1])\n\n\n\n\n\n@njit\n\ndef set(d, op, p, x):\n\n    p += d.shape[0] // 2\n\n    d[p] = x\n\n    while p > 1:\n\n        p >>= 1\n\n        update(d, p, op)\n\n\n\n\n\n@njit\n\ndef get(d, p):\n\n    return d[p + d.shape[0] // 2]\n\n\n\n\n\n@njit\n\ndef prod(d, op, left, right):\n\n    size = d.shape[0] // 2\n\n    sml = d[0]\n\n    smr = d[0]\n\n    left += size\n\n    right += size\n\n\n\n    while left < right:\n\n        if left & 1:\n\n            sml = op(sml, d[left])\n\n            left += 1\n\n        if right & 1:\n\n            right -= 1\n\n            smr = op(d[right], smr)\n\n        left >>= 1\n\n        right >>= 1\n\n\n\n    return op(sml, smr)\n\n\n\n\n\n@njit\n\ndef all_prod(d):\n\n    return d[1]\n\n\n\n'''\n", "score": 1.0, "codebleu": 0.9965890327851343, "crystalbleu": 0.9906257119998134, "codebertscore": 1.0, "codescore": 0.9838795065879822, "surfaceSim": 0.9993983152827919, "abs_surfaceSim_minus_score": 0.0006016847172081174}
{"golden_code": "import numpy as np\n\n\n\n(N,M) = list(map(int,input().split()))\n\nB = np.ones(M,dtype=np.int)\n\n\n\nfor _ in range(N):\n\n    A = np.array(list(map(int,input().split())))[1:]\n\n    for i in range(M):\n\n        if not i+1 in A:\n\n            B[i] = 0\n\nprint((B.sum()))", "generated_code": "(N,M) = list(map(int,input().split()))\n\nr = int(-1)\n\nfor i in range(N):\n\n  A = list(map(int,input().split()))\n\n  A.pop(0)\n\n  c = 0\n\n  for a in A:\n\n    c |= (1 << (a-1))\n\n  r &= c\n\n\n\nans = sum([(r>>n)&1 for n in range(M)])\n\nprint(ans)", "score": 1.0, "codebleu": 0.32082146487051477, "crystalbleu": 0.24786981281288478, "codebertscore": 0.83, "codescore": 0.8830114603042603, "surfaceSim": 0.46951871657754013, "abs_surfaceSim_minus_score": 0.5304812834224599}
{"golden_code": "# -*- coding: utf-8 -*-\n\nfrom collections import deque\n\ndef inpl(): return list(map(int, input().split()))\n\n\n\nS = eval(input())\n\nA = set(\"ATCG\")\n\nans = 0\n\nmode = 0\n\nfor i, s in enumerate(S):\n\n    if s in A:\n\n        if mode == 0:\n\n            mode = 1\n\n            start = i\n\n    else:\n\n        if mode == 1:\n\n            ans = max(i - start, ans)\n\n            mode = 0\n\nif mode == 1:\n\n    ans = max(len(S) - start, ans)\n\nprint(ans)", "generated_code": "def inpl(): return list(map(int, input().split()))\n\nS = eval(input())\n\nC = set(\"ACGT\")\n\n\n\ntmp = 0\n\nans = 0\n\n\n\nfor s in S:\n\n    if s in C:\n\n        tmp += 1\n\n    else:\n\n        ans = max(ans, tmp)\n\n        tmp = 0\n\nans = max(ans, tmp)\n\nprint(ans)", "score": 1.0, "codebleu": 0.36099008835346236, "crystalbleu": 0.33068892821961493, "codebertscore": 0.83, "codescore": 0.22438380122184753, "surfaceSim": 0.6944444444444444, "abs_surfaceSim_minus_score": 0.3055555555555556}
{"golden_code": "import numpy as np\n\n\n\nn,l = [int(x) for x in input().split()] \n\nx = np.arange(l,l+n)\n\ny = np.abs(x)\n\nx = np.delete(x, np.argmin(y))\n\nprint((np.sum(x)))", "generated_code": "N, L = list(map(int, input().split()))\n\napples = [i for i in range(L, L+N)]\n\napples_abs = [abs(i) for i in apples]\n\nmin_idx = apples_abs.index(min(apples_abs))\n\n\n\nprint((sum(apples) - apples[min_idx]))", "score": 1.0, "codebleu": 0.18772444172970487, "crystalbleu": 0.0, "codebertscore": 0.79, "codescore": 0.2970789968967438, "surfaceSim": 0.5451907131011609, "abs_surfaceSim_minus_score": 0.45480928689883915}
{"golden_code": "while True:\n\n    n, x = [int(i) for i in input().split()]\n\n\n\n    if n == x == 0:\n\n        break\n\n\n\n    count = 0\n\n    for s in range(1, n - 1):\n\n        for m in range(s + 1, n):\n\n            for e in range(m + 1, n + 1):\n\n                if x == sum([s, m, e]):\n\n                    count += 1\n\n\n\n    print(count)", "generated_code": "while True:\n\n    n, x = [int(i) for i in input().split()]\n\n\n\n    if n == x == 0:\n\n        break\n\n\n\n    count = 0\n\n    for s in range(1, n - 1):\n\n        for m in range(s + 1, n):\n\n            for e in range(m + 1, n + 1):\n\n                if x == s+m+e:\n\n                    count += 1\n\n\n\n    print(count)", "score": 1.0, "codebleu": 0.8777419799918909, "crystalbleu": 0.0, "codebertscore": 0.99, "codescore": 0.8692600131034851, "surfaceSim": 0.9639296593741347, "abs_surfaceSim_minus_score": 0.03607034062586534}
{"golden_code": "import math\n\nimport numpy as np\n\n\n\nn, d = list(map(int, input().split()))\n\n\n\nx = np.zeros([n, d])\n\n\n\nfor i in range(n):\n\n    line = list(map(int, input().split()))\n\n    for j in range(d):\n\n        x[i, j] = line[j]\n\n\n\ncnt = 0\n\n\n\nfor i in range(n):\n\n    for j in range(i+1, n):\n\n        xx = (x[i] - x[j]) ** 2\n\n        dist = math.sqrt(xx.sum())\n\n        if dist % 1 == 0:\n\n            cnt += 1\n\n\n\nprint(cnt)", "generated_code": "import math\n\n\n\nn, d = list(map(int, input().split()))\n\n\n\nx = [list(map(int, input().split())) for i in range(n)]\n\n\n\ncnt = 0\n\n\n\nfor i in range(n):\n\n    for j in range(i+1, n):\n\n        dist = 0\n\n        for k in range(d):\n\n            dist += (x[i][k] - x[j][k]) ** 2\n\n        if math.sqrt(dist).is_integer():\n\n            cnt += 1\n\n\n\nprint(cnt)", "score": 1.0, "codebleu": 0.4363713868038893, "crystalbleu": 0.5314052221305681, "codebertscore": 0.92, "codescore": 0.8638458251953125, "surfaceSim": 0.735702614379085, "abs_surfaceSim_minus_score": 0.264297385620915}
{"golden_code": "N, K, C = list(map(int, input().split()))\n\nS = eval(input())\n\n\n\nlatest = [None]*K\n\ni = len(S)+C\n\nfor j in range(K-1, -1, -1):\n\n  i = S.rindex(\"o\", 0, i-C)\n\n  latest[j] = i\n\n\n\nif i<=C or \"o\" not in S[:i-C]:\n\n  i = -C-1\n\n  for j in latest:\n\n    i = S.index(\"o\", i+C+1)\n\n    if i == j:\n\n      print((i+1))\n", "generated_code": "def solve():\n\n  N, K, C = list(map(int, input().split()))\n\n  workable = [i for i, s in enumerate(eval(input())) if s==\"o\"]\n\n  if len(workable) == K:\n\n    return workable\n\n    \n\n  prev = workable[-1]\n\n  latest = {prev}\n\n  i = len(workable)-1\n\n  while i > 0:\n\n    i -= 1\n\n    if prev - workable[i] > C:\n\n      latest.add(workable[i])\n\n      prev = workable[i]\n\n      if len(latest) > K:\n\n        return []\n\n  must = []\n\n  i = -1\n\n  prev = -C-1\n\n  while i < len(workable)-1:\n\n    i += 1\n\n    if workable[i] - prev > C:\n\n      if workable[i] in latest:\n\n        must.append(workable[i])\n\n      prev = workable[i]\n\n  return must\n\n\n\nfor i in solve():\n\n  print((i+1))", "score": 1.0, "codebleu": 0.2556013201086353, "crystalbleu": 0.21982840792429317, "codebertscore": 0.79, "codescore": 0.9932857155799866, "surfaceSim": 0.532051282051282, "abs_surfaceSim_minus_score": 0.46794871794871795}
{"golden_code": "N=int(eval(input()))\n\n\n\nS=[[-1]*N for _ in range(N)]\n\nfor i in range(N):\n\n  A=int(eval(input()))\n\n  for _ in range(A):\n\n    x, y=list(map(int, input().split()))\n\n    S[i][x-1]=y\n\nans=0   \n\nfor s in range(2**N):\n\n  ok=True\n\n  for i in range(N):\n\n    #正直者について見ていく\n\n    if (s>>i&1)==1:\n\n      for j in range(N):\n\n        #それぞれ正直者の証言が矛盾ないか\n\n        if S[i][j]!=-1 and (s>>j&1)!=S[i][j]:\n\n          ok=False\n\n  if ok:\n\n    ans=max(ans, bin(s).count(\"1\"))\n\n    \n\nprint(ans)\n", "generated_code": "N=int(eval(input()))\n\n\n\nA=[[-1]*N for _ in range(N)]\n\nfor i in range(N):\n\n  a=int(eval(input()))\n\n  for j in range(a):\n\n    x,y=list(map(int, input().split()))\n\n    A[i][x-1]=y\n\n#正直者が正直者に不親切と言われていない\n\n#→正直ものが不親切を正直者と言っていないか\n\nans=0\n\nfor i in range(2**N):\n\n  ok=True\n\n  for j in range(N):\n\n    if (i>>j&1)==1:\n\n      for k in range(N):\n\n        if A[j][k]!=-1 and (i>>k&1)!=A[j][k]:\n\n          ok=False\n\n  if ok:\n\n    ans=max(ans, bin(i).count(\"1\"))\n\n  \n\nprint(ans)", "score": 1.0, "codebleu": 0.6160689630520192, "crystalbleu": 0.7293791569454686, "codebertscore": 0.91, "codescore": 0.8327738046646118, "surfaceSim": 0.9797008547008548, "abs_surfaceSim_minus_score": 0.020299145299145227}
{"golden_code": "import math\n\n\n\nN = int(eval(input()))\n\nans = 0\n\n\n\nans =math.factorial(N) % (10**9 +7)\n\n\n\nprint(ans)", "generated_code": "N = int(eval(input()))\n\npower = 1\n\n\n\nfor i in range(N):\n\n    power = ((i+1) * power) % 1000000007\n\n\n\nprint(power)", "score": 1.0, "codebleu": 0.257377670210069, "crystalbleu": 0.0, "codebertscore": 0.78, "codescore": 0.1743135303258896, "surfaceSim": 0.5536179073399272, "abs_surfaceSim_minus_score": 0.4463820926600728}
{"golden_code": "MOD = 1000000007\n\n\n\n\n\nS = int(eval(input()))\n\n\n\n#dp[i]:=i桁の数列で条件を満たすものの数\n\ndp = [0]*(S+1)\n\n\n\nfor i in range(3,S+1):\n\n    #dp[i]=sum(dp[0],..,dp[i-3])+1\n\n    for j in range(i-3+1):\n\n        dp[i] = (dp[i]+dp[j])%MOD\n\n    dp[i] = (dp[i]+1)%MOD\n\n\n\nprint((dp[S]))", "generated_code": "MOD = 1000000007\n\n\n\n\n\nS = int(eval(input()))\n\n\n\n#dp[i]:=i桁の数列で条件を満たすものの数\n\ndp = [0]*(S+1)\n\ndp_sum = [0]*(S+1)\n\n\n\nfor i in range(3,S+1):\n\n    #dp[i]=sum(dp[0],..,dp[i-3])+1\n\n    \n\n    dp[i] = (dp_sum[i-3]+1)%MOD\n\n    dp_sum[i] = (dp[i]+dp_sum[i-1])%MOD\n\n\n\nprint((dp[S]))", "score": 1.0, "codebleu": 0.5993420564438696, "crystalbleu": 0.7303934818254109, "codebertscore": 0.97, "codescore": 0.9609333276748657, "surfaceSim": 0.9216417910447761, "abs_surfaceSim_minus_score": 0.07835820895522394}
{"golden_code": "import numpy as np\n\n\n\nN, M = list(map(int, input().split()))\n\n\n\nlike_total = np.zeros(M)\n\ncnt = 0\n\nfor _ in range(N):\n\n    l = [v for v in map(int, input().split())]\n\n    #print(l)\n\n    for i in range(1, l[0]+1, 1):\n\n        like_total[l[i]-1] += 1\n\n\n\n#print(like_total, N)\n\n#print(like_total[4], like_total[9], like_total[-1])\n\nans = len(np.where(like_total==N)[0])\n\n\n\nprint(ans)\n", "generated_code": "N, M = list(map(int, input().split()))\n\n\n\nlike_total = [0]*M\n\ncnt = 0\n\nfor _ in range(N):\n\n    l = list(map(int, input().split()))\n\n    for i in range(1, l[0]+1, 1):\n\n        like_total[l[i]-1] += 1\n\n\n\nfor v in like_total:\n\n    cnt += v==N\n\nprint(cnt)\n", "score": 1.0, "codebleu": 0.47576170182861593, "crystalbleu": 0.5979933876009014, "codebertscore": 0.9, "codescore": 0.8589035868644714, "surfaceSim": 0.796010498687664, "abs_surfaceSim_minus_score": 0.20398950131233595}
{"golden_code": "H, W = list(map(int, input().split()))\n\nimport numpy as np\n\nGrid = np.array([[0 if x == '.' else -1 for x in eval(input())] for _ in range(H)],dtype='int64')\n\n\n\ndef solveMase(Grid, start, goal): #bfsで迷路を解き、スタート-ゴール間の最低必要白マス数を返す\n\n    seen = {start}\n\n    V = [start]\n\n    while len(V) != 0: #bfs\n\n        v = V.pop(0)\n\n        if v == goal:\n\n            return Grid[goal]\n\n        #移動先nvをリストにまとめる\n\n        y,x = v\n\n        nV = []\n\n        if x > 0: nV.append((y,x-1))\n\n        if y > 0: nV.append((y-1,x))\n\n        if x < W-1: nV.append((y,x+1))\n\n        if y < H-1: nV.append((y+1,x))\n\n        #bfs\n\n        for nv in nV:\n\n            if Grid[nv] == -1 or nv in seen:\n\n                continue\n\n            Grid[nv] = Grid[v] + 1\n\n            V.append(nv)\n\n            seen.add(nv)\n\n    return 0\n\n\n\nwhite = len(Grid[Grid == 0])-1\n\nnes_white = solveMase(Grid, (0,0), (H-1,W-1))\n\nprint((white-nes_white if nes_white > 0 else -1))", "generated_code": "from collections import deque, Counter\n\n\n\ndef main():\n\n    with open(0) as f:\n\n        H, W = list(map(int, f.readline().split()))\n\n        maze = [list(line) for line in f.readlines()]\n\n\n\n    rank = [[None]*W for _ in range(H)]\n\n    rank[0][0] = 0\n\n    #bfs\n\n    reserved = deque([(0,0)])\n\n    while len(reserved) > 0:\n\n        x, y = reserved.popleft()\n\n        for u,v in [(s,t) for s,t in [(x-1,y), (x+1,y), (x,y-1), (x,y+1)] if 0<=s<H and 0<=t<W]:\n\n            if rank[u][v] is not None:\n\n                continue\n\n            if maze[u][v] == '.':\n\n                rank[u][v] = rank[x][y] + 1\n\n                reserved.append((u,v))\n\n\n\n    if rank[H-1][W-1] is None:\n\n        print((-1))\n\n    else:\n\n        counter = Counter()\n\n        for line in maze:\n\n            counter.update(line)\n\n        print((counter['.'] - rank[H-1][W-1]-1))\n\n\n\nmain()", "score": 1.0, "codebleu": 0.21110138352074045, "crystalbleu": 0.16933118644278344, "codebertscore": 0.75, "codescore": 0.3546886444091797, "surfaceSim": 0.5665521872179292, "abs_surfaceSim_minus_score": 0.4334478127820708}
{"golden_code": "A,B = list(map(int,input().split()))\n\nj = 0\n\nfor i in range(A,B+1):\n\n  l = list(str(i))\n\n  l_reverse = list(reversed(l))\n\n  if l == l_reverse:\n\n    j += 1\n\nprint(j)", "generated_code": "A, B = list(map(int,input().split()))\n\n\n\nans = 0\n\nfor n in range(A, B+1):\n\n    n = str(n)\n\n    if n == n[::-1]:\n\n        ans += 1\n\nprint(ans)", "score": 1.0, "codebleu": 0.37832943406915276, "crystalbleu": 0.0, "codebertscore": 0.89, "codescore": 0.8830242156982422, "surfaceSim": 0.7340301974448316, "abs_surfaceSim_minus_score": 0.26596980255516844}
{"golden_code": "import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\nN = int(readline())\n\nS = read().split()\n\n\n\nS = sorted(S)\n\nls = [[] for i in range(N + 1)]\n\nmax_num = 0\n\nleft = 0\n\nright = 0\n\nwhile right < N:\n\n    while right < N and S[left] == S[right]:\n\n        right += 1\n\n    if (right  - left) >= max_num:\n\n        ls[right - left].append(S[left].decode())\n\n        max_num = right - left\n\n    left = right\n\n    \n\nprint(('\\n'.join(ls[max_num])))\n", "generated_code": "from collections import Counter\n\n\n\nimport sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\nN = int(readline())\n\nS = read().split()\n\n\n\nres = []\n\nc = Counter(S)\n\nmax_num = c.most_common(1)[0][1]\n\nfor i, j in list(c.items()):\n\n    if j == max_num:\n\n        res.append(i)\n\n        \n\nres.sort()\n\n\n\n        \n\nprint(('\\n'.join(list([x.decode() for x in res]))))\n", "score": 1.0, "codebleu": 0.3220499377044138, "crystalbleu": 0.32804613121326287, "codebertscore": 0.85, "codescore": 0.5265458226203918, "surfaceSim": 0.6030785970302099, "abs_surfaceSim_minus_score": 0.39692140296979006}
{"golden_code": "def main():\n\n    N = int(input())\n\n    A = [int(i) for i in input().split()]\n\n    if N == 1:\n\n        return print(1 if A[0] % 2 == 0 else 2)\n\n    ans = 0\n\n    d = (-1, 0, 1)\n\n    from itertools import product\n\n    for i in product(range(3), repeat=N):\n\n        cur = 1\n\n        for j in range(N):\n\n            cur *= (A[j] + d[i[j]])\n\n        if cur % 2 == 0:\n\n            ans += 1\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "generated_code": "def main():\n\n    N = int(eval(input()))\n\n    A = [int(i) for i in input().split()]\n\n    ans = 3**N\n\n    cnt = len([a for a in A if a % 2 == 0])\n\n    ans -= 2**cnt\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 1.0, "codebleu": 0.27604189956635083, "crystalbleu": 0.24057904577337144, "codebertscore": 0.82, "codescore": 0.018417997285723686, "surfaceSim": 0.5988248572566724, "abs_surfaceSim_minus_score": 0.40117514274332755}
{"golden_code": "import math\n\nx = int(eval(input()))\n\nprint((math.factorial(x) % (10**9 + 7)))", "generated_code": "M = 1000000007\n\nn=int(eval(input()))\n\nf = 1\n\nfor i in range(1, n + 1):  \n\n    f = (f * i) % M \n\nprint(f)", "score": 1.0, "codebleu": 0.21865774537505162, "crystalbleu": 0.0, "codebertscore": 0.77, "codescore": 0.08097273856401443, "surfaceSim": 0.5831447963800904, "abs_surfaceSim_minus_score": 0.4168552036199096}
{"golden_code": "import numpy as np\n\neval(input())\n\nx = np.array(input().split(),dtype=np.int32)\n\n\n\nans = 0\n\nwhile (x%2 == 0).all():\n\n  x = x//2\n\n  ans += 1\n\nprint(ans)", "generated_code": "N = int(eval(input()))\n\nA = [int(x) for x in input().split()]\n\nresult = float('inf')\n\nfor i in range(N):\n\n  r=0\n\n  while A[i]%2==0:\n\n    A[i]=A[i]/2\n\n    r +=1\n\n  result=min(result,r)\n\nprint(result)", "score": 1.0, "codebleu": 0.22768033337713556, "crystalbleu": 0.0, "codebertscore": 0.78, "codescore": 0.866777777671814, "surfaceSim": 0.5425407925407926, "abs_surfaceSim_minus_score": 0.45745920745920743}
{"golden_code": "import math\n\nN = int(eval(input()))\n\np = math.factorial(N)\n\nprint((p % 1000000007))", "generated_code": "N = int(eval(input()))\n\np = 1\n\nfor i in range(1,N+1):\n\n    p *= i\n\n    p %= 1000000007\n\nprint(p)\n", "score": 1.0, "codebleu": 0.35373732956578885, "crystalbleu": 0.0, "codebertscore": 0.83, "codescore": 0.5682074427604675, "surfaceSim": 0.5621588841722256, "abs_surfaceSim_minus_score": 0.4378411158277744}
{"golden_code": "from collections import Counter\n\nN, M = list(map(int, input().split()))\n\nA = list(map(int, input().split()))\n\n\n\nX = Counter(A)\n\nfor i in range(M):\n\n    B, C = list(map(int, input().split()))\n\n    X[C] += B\n\n\n\nZ = []\n\nfor key, value in list(X.items()):\n\n    Z.append((key, value))\n\n\n\nZ.sort(key=lambda x: x[0], reverse=True)\n\n\n\nans = 0\n\ncnt = 0\n\n\n\nfor value, key in Z:\n\n    if cnt + key <= N:\n\n        ans += key * value\n\n        cnt += key\n\n    else:\n\n        ans += (N - cnt) * value\n\n        break\n\n\n\nprint(ans)\n", "generated_code": "N, M = list(map(int, input().split()))\n\nA = sorted(list(map(int, input().split())))\n\nquery = []\n\nfor i in range(M):\n\n    b, c = list(map(int, input().split()))\n\n    query.append([b, c])\n\nquery.sort(key=lambda q: q[1], reverse=True)\n\n\n\n\n\ni = 0\n\nfor b, c in query:\n\n    while i < N and b > 0:\n\n        if A[i] < c:\n\n            A[i] = c\n\n            b -= 1\n\n        i += 1\n\n\n\nprint((sum(A)))\n", "score": 1.0, "codebleu": 0.30848539159379307, "crystalbleu": 0.26677791567402614, "codebertscore": 0.83, "codescore": 0.32757851481437683, "surfaceSim": 0.6514648661020829, "abs_surfaceSim_minus_score": 0.3485351338979171}
{"golden_code": "import numpy as np\n\nn = int(eval(input()))\n\nal = list(map(int,input().split()))\n\n\n\nfor i in range(n):\n\n    al[i] -= i + 1\n\n\n\nmed = np.median(np.array(al))\n\n\n\nans = 0\n\nfor a in al:\n\n    ans += abs(a-med)\n\nprint((int(ans)))", "generated_code": "import statistics\n\nn = int(eval(input()))\n\nal = list(map(int,input().split()))\n\n\n\nfor i in range(n):\n\n    al[i] -= i + 1\n\n\n\nmedian = statistics.median(al)\n\n\n\nans = 0\n\nfor a in al:\n\n    ans += abs(median - a)\n\n\n\nprint((int(ans)))\n", "score": 1.0, "codebleu": 0.7506519606924393, "crystalbleu": 0.0, "codebertscore": 0.95, "codescore": 0.8713083863258362, "surfaceSim": 0.9235807860262009, "abs_surfaceSim_minus_score": 0.07641921397379914}
{"golden_code": "k, n = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\n\n\ndiff = []\n\n\n\nfor i in range(n - 1):\n\n    diff.append(a[i + 1] - a[i])\n\ndiff.append(k - a[-1] + a[0])\n\n\n\nprint((k - max(diff)))\n", "generated_code": "k, n = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\n\n\na.append(k + a[0])\n\ndiff = [a1 - a0 for a0, a1 in zip(a, a[1:])]\n\n\n\nprint((k - max(diff)))\n", "score": 1.0, "codebleu": 0.492298754710507, "crystalbleu": 0.45600467305519793, "codebertscore": 0.91, "codescore": 0.09820897877216339, "surfaceSim": 0.6952780229479258, "abs_surfaceSim_minus_score": 0.30472197705207416}
{"golden_code": "M=998244353\n\nn,m,k=list(map(int,input().split()))\n\na=0\n\nc=1\n\nfor i in range(k+1):\n\n  a+=c*m*pow(m-1,n-i-1,M)\n\n  c=c*(n-i-1)*pow(i+1,M-2,M)%M\n\nprint((a%M))", "generated_code": "M=998244353\n\nn,m,k=list(map(int,input().split()))\n\na,c=0,1\n\nfor i in range(k+1):\n\n  a+=c*m*pow(m-1,n+~i,M)\n\n  c=c*(n+~i)*pow(i+1,-1,M)%M\n\nprint((a%M))", "score": 1.0, "codebleu": 0.5361426195531298, "crystalbleu": 0.0, "codebertscore": 0.97, "codescore": 0.42283761501312256, "surfaceSim": 0.8762987012987014, "abs_surfaceSim_minus_score": 0.12370129870129865}
{"golden_code": "print((sum(si != ti for si, ti in zip(eval(input()), eval(input())))))\n", "generated_code": "print((sum(a!=b for a,b in zip(*open(0)))))", "score": 1.0, "codebleu": 0.18016002888564955, "crystalbleu": 0.0, "codebertscore": 0.85, "codescore": 0.8045110106468201, "surfaceSim": 0.7118093174431203, "abs_surfaceSim_minus_score": 0.28819068255687974}
{"golden_code": "# -*- coding: utf-8 -*-\n\n\"\"\"\n\nCreated on Sat May 25 21:24:29 2019\n\n\n\n@author: Yamazaki Kenichi\n\n\"\"\"\n\n\n\nN, M, K = list(map(int,input().split()))\n\nmod = 10**9+7\n\n\n\ndef cmb(n, r, mod):\n\n    if (r < 0 or r > n):\n\n        return 0\n\n    r = min(r, n-r)\n\n    return g1[n] * g2[r] * g2[n-r] % mod\n\n\n\ng1 = [1, 1] # 元テーブル\n\ng2 = [1, 1] # 逆元テーブル\n\ninv = [0, 1] # 逆元テーブル計算用テーブル\n\n\n\nfor i in range(2, N*M+1):\n\n    g1.append((g1[-1] * i) % mod)\n\n    inv.append((-inv[mod % i] * (mod//i)) % mod)\n\n    g2.append((g2[-1] * inv[-1]) % mod)\n\n\n\ndef a(N,M):\n\n    return N*(N+1)//2*(M+1) + M*(M+1)//2*(N+1)\n\ndef b(N):\n\n    return N*(N+1)//2\n\n\n\nans = 0\n\nfor i in range(N):\n\n    for j in range(M):\n\n        ans += a(i,j) + a(N-i-1,j) + a(i,M-j-1) + a(N-i-1,M-j-1)\n\n        ans -= b(i) + b(j) + b(N-i-1) + b(M-j-1)\n\n        ans %= mod\n\n#        print(i,j,a(i,j),a(N-i-1,j),a(i,M-j-1),a(N-i-1,M-j-1),b(i),b(j),ans)\n\nans *= g2[2]\n\n\n\nans *= cmb(N*M-2,K-2,mod)\n\nans %= mod\n\n\n\nprint(ans)\n", "generated_code": "# -*- coding: utf-8 -*-\n\n\"\"\"\n\nCreated on Wed May 29 22:49:19 2019\n\n\n\n@author: Yamazaki Kenichi\n\n\"\"\"\n\n\n\n# -*- coding: utf-8 -*-\n\n\"\"\"\n\nCreated on Sat May 25 21:24:29 2019\n\n\n\n@author: Yamazaki Kenichi\n\n\"\"\"\n\n\n\nN, M, K = list(map(int,input().split()))\n\nmod = 10**9+7\n\n\n\ndef cmb(n, r, mod):\n\n    if (r < 0 or r > n):\n\n        return 0\n\n    r = min(r, n-r)\n\n    return g1[n] * g2[r] * g2[n-r] % mod\n\n\n\ng1 = [1, 1] # 元テーブル\n\ng2 = [1, 1] # 逆元テーブル\n\ninv = [0, 1] # 逆元テーブル計算用テーブル\n\n\n\nfor i in range(2, N*M+1):\n\n    g1.append((g1[-1] * i) % mod)\n\n    inv.append((-inv[mod % i] * (mod//i)) % mod)\n\n    g2.append((g2[-1] * inv[-1]) % mod)\n\n\n\nans1 = 0\n\ndef c(N,M):\n\n    res = 0\n\n    for i in range(1,N):\n\n        res += i*(N-i)*M*M\n\n    return res\n\nans1 += c(N,M) + c(M,N)\n\nans1 %= mod\n\n\n\nans1 *= cmb(N*M-2,K-2,mod)\n\nans1 %= mod\n\n\n\nprint(ans1)\n", "score": 1.0, "codebleu": 0.6910088932970917, "crystalbleu": 0.5292356284296632, "codebertscore": 0.91, "codescore": 0.9856362342834473, "surfaceSim": 0.881675392670157, "abs_surfaceSim_minus_score": 0.11832460732984296}
{"golden_code": "N = int(eval(input()))\n\n\n\nseq = list(map(int, input().split()))\n\n\n\ncnt = 0\n\n\n\nfor num in seq:\n\n    while num % 2 == 0:\n\n        cnt += 1\n\n        num /= 2\n\n\n\nprint(cnt)\n", "generated_code": "n = int(eval(input()))\n\na = list(map(int, input().split()))\n\nans = 0\n\nfor num in a:\n\n    ans += format(num, 'b')[::-1].find('1')\n\nprint(ans)", "score": 1.0, "codebleu": 0.4818615528657325, "crystalbleu": 0.0, "codebertscore": 0.85, "codescore": 0.16306105256080627, "surfaceSim": 0.6484669176976869, "abs_surfaceSim_minus_score": 0.35153308230231306}
{"golden_code": "import copy\n\nn,k = list(map(int,input().split()))\n\nai = [int(i) for i in input().split()]\n\n\n\nold_ai = ai\n\ncnt = 0\n\n\n\nwhile 1 == 1:\n\n    old_ai = copy.deepcopy(ai)\n\n    li = [0]*(n+1)\n\n    for i in range(n):\n\n        li[max(0,i-ai[i])] += 1\n\n        li[min(n,i+1+ai[i])] -= 1\n\n        #print(li)\n\n    #print(li)\n\n    tmp = 0\n\n    for i in range(n):\n\n        if i == 0:\n\n            ai[i] = li[i]\n\n            tmp += ai[i]\n\n        else:\n\n            ai[i] = li[i] + ai[i-1]\n\n            tmp += ai[i]\n\n    #print(rui)\n\n    if ai == old_ai:\n\n        print((*ai))\n\n        exit()\n\n        break\n\n    cnt += 1\n\n    if cnt == k:\n\n        print((*ai))\n\n        exit()\n\n    old_ai = ai", "generated_code": "import copy\n\nn,k = list(map(int,input().split()))\n\nai = [int(i) for i in input().split()]\n\n\n\n#old_ai = ai\n\ncnt = 0\n\nold_tmp = sum(ai)\n\n\n\nwhile 1 == 1:\n\n    #old_ai = copy.deepcopy(ai)\n\n    li = [0]*(n+1)\n\n    for i in range(n):\n\n        li[max(0,i-ai[i])] += 1\n\n        li[min(n,i+1+ai[i])] -= 1\n\n        #print(li)\n\n    #print(li)\n\n    tmp = 0\n\n    for i in range(n):\n\n        if i == 0:\n\n            ai[i] = li[i]\n\n            tmp += ai[i]\n\n        else:\n\n            ai[i] = li[i] + ai[i-1]\n\n            tmp += ai[i]\n\n    #print(rui)\n\n    if old_tmp == tmp:\n\n        print((*ai))\n\n        exit()\n\n        break\n\n    cnt += 1\n\n    if cnt == k:\n\n        print((*ai))\n\n        exit()\n\n    old_tmp = tmp", "score": 1.0, "codebleu": 0.761001086990531, "crystalbleu": 0.815518851027449, "codebertscore": 0.98, "codescore": 0.9938597679138184, "surfaceSim": 0.957977207977208, "abs_surfaceSim_minus_score": 0.04202279202279202}
{"golden_code": "import numpy as np\n\n\n\nN=int(eval(input()))\n\nA=list(map(int, input().split()))\n\n\n\nAA=[]\n\nfor i,a in enumerate(A):\n\n    AA.append(a-i+1)\n\n\n\nb=np.median(AA)\n\nans=0\n\n\n\nfor a in AA:\n\n    ans+=abs(a-b)\n\nprint((int(ans)))", "generated_code": "N=int(eval(input()))\n\nA=list(map(int,input().split()))\n\nB=[]\n\nfor i in range(N):\n\n    B.append(A[i]-i-1)\n\nB.sort()\n\nif N%2:\n\n    b=B[N//2]\n\nelse:\n\n    b=(B[N//2]+B[N//2-1])//2\n\nans=0\n\nfor k in B:\n\n    ans+=abs(k-b)\n\nprint(ans)", "score": 1.0, "codebleu": 0.29497144912198503, "crystalbleu": 0.3839666177464585, "codebertscore": 0.86, "codescore": 0.8075329065322876, "surfaceSim": 0.6114851866102347, "abs_surfaceSim_minus_score": 0.38851481338976535}
{"golden_code": "import numpy as np\n\n\n\n\n\ndef main(n, m, a):\n\n    dp = np.zeros(n + 1, dtype=int)\n\n    dp[0] = 1\n\n    dp[1] = 1 if 1 not in a else 0\n\n\n\n    for i in range(2, len(dp)):\n\n        dp[i] = dp[i - 1] + dp[i - 2] if i not in a else 0\n\n        dp[i] %= 1000000007\n\n\n\n    return dp[-1]\n\n\n\n\n\nif __name__ == '__main__':\n\n    N, M = list(map(int, input().split()))\n\n    A = set()\n\n    for _ in range(M):\n\n        A.add(int(eval(input())))\n\n\n\n    print((main(N, M, A)))\n", "generated_code": "import math\n\n\n\nMOD = int(math.pow(10, 9)) + 7\n\nN, M = list(map(int, input().split(' ')))\n\nbroken_steps = {int(eval(input())) for _ in range(M)}\n\n\n\ndp = [0] * (N + 1)\n\n\n\ndp[0] = 1\n\nif 1 not in broken_steps:\n\n    dp[1] = 1\n\n\n\nfor step in range(2, N + 1):\n\n    if step not in broken_steps:\n\n        dp[step] = (dp[step - 1] + dp[step - 2]) % MOD\n\n\n\nprint((dp[N]))\n", "score": 1.0, "codebleu": 0.26850952613283985, "crystalbleu": 0.297385066494751, "codebertscore": 0.82, "codescore": 0.051033101975917816, "surfaceSim": 0.5380116959064327, "abs_surfaceSim_minus_score": 0.4619883040935673}
{"golden_code": "#!usr/bin/env python3\n\nfrom collections import defaultdict\n\nfrom collections import deque\n\nfrom heapq import heappush, heappop\n\nimport sys\n\nimport math\n\nimport bisect\n\nimport random\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\n\ndef I(): return int(sys.stdin.readline())\n\ndef LS():return list(map(list, sys.stdin.readline().split()))\n\ndef S(): return list(sys.stdin.readline())[:-1]\n\ndef IR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = I()\n\n    return l\n\ndef LIR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = LI()\n\n    return l\n\ndef SR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = S()\n\n    return l\n\ndef LSR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = LS()\n\n    return l\n\nsys.setrecursionlimit(1000000)\n\nmod = 1000000007\n\n\n\n#A\n\ndef A():\n\n    return\n\n\n\n#B\n\ndef B():\n\n    return\n\n\n\n#C\n\ndef C():\n\n    return\n\n\n\n#D\n\ndef D():\n\n    return\n\n\n\n#E\n\ndef E():\n\n    return\n\n\n\n#F\n\ndef F():\n\n    a,b,c,X,Y = LI()\n\n    ans = float(\"inf\")\n\n    for z in range(300001):\n\n        if z%2 == 0:\n\n            m = c*z\n\n            x = z//2\n\n            y = z//2\n\n            m += a*max(0,X-x)\n\n            m += b*max(0,Y-y)\n\n            if m < ans:\n\n                ans = m\n\n    print(ans)\n\n    return\n\n\n\n#G\n\ndef G():\n\n    n = I()\n\n    x = LI()\n\n    f = [(i,x[i]) for i in range(n)]\n\n    f.sort(key = lambda x:x[1])\n\n    g = [(f[i][0],i) for i in range(n)]\n\n    g.sort(key = lambda x:x[0])\n\n    for i in range(n):\n\n        if g[i][1] < n//2:\n\n            print((f[n//2][1]))\n\n        else:\n\n            print((f[n//2-1][1]))\n\n    return\n\n\n\n#H\n\ndef H():\n\n    return\n\n\n\n#I\n\ndef I_():\n\n    return\n\n\n\n#J\n\ndef J():\n\n    return\n\n\n\n#Solve\n\nif __name__ == \"__main__\":\n\n    F()\n", "generated_code": "#!usr/bin/env python3\n\nfrom collections import defaultdict,deque\n\nfrom heapq import heappush, heappop\n\nfrom itertools import permutations\n\nimport sys\n\nimport math\n\nimport bisect\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\n\ndef I(): return int(sys.stdin.readline())\n\ndef LS():return [list(x) for x in sys.stdin.readline().split()]\n\ndef S():\n\n    res = list(sys.stdin.readline())\n\n    if res[-1] == \"\\n\":\n\n        return res[:-1]\n\n    return res\n\ndef IR(n):\n\n    return [I() for i in range(n)]\n\ndef LIR(n):\n\n    return [LI() for i in range(n)]\n\ndef SR(n):\n\n    return [S() for i in range(n)]\n\ndef LSR(n):\n\n    return [LS() for i in range(n)]\n\n\n\nsys.setrecursionlimit(1000000)\n\nmod = 1000000007\n\n\n\ndef solve():\n\n    A,B,C,x,y = LI()\n\n    ans = float(\"inf\")\n\n    for c in range(200001)[::2]:\n\n        a = b = c >> 1\n\n        a = max(0,x-a)\n\n        b = max(0,y-b)\n\n        s = A*a+B*b+C*c\n\n        if s < ans:\n\n            ans = s\n\n    print(ans)\n\n    return\n\n\n\n#Solve\n\nif __name__ == \"__main__\":\n\n    solve()\n", "score": 1.0, "codebleu": 0.300559419731317, "crystalbleu": 0.22486624152797977, "codebertscore": 0.88, "codescore": 0.023624062538146973, "surfaceSim": 0.7418803418803419, "abs_surfaceSim_minus_score": 0.2581196581196581}
{"golden_code": "# vim: fileencoding=utf-8\n\n\n\n\n\ndef main():\n\n    a, b = list(map(int, input().split()))\n\n    c = 0\n\n    for i in range(a, b + 1):\n\n        s = str(i)\n\n        r = \"\".join(reversed(list(s)))\n\n        if s == r:\n\n            c += 1\n\n    print(c)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "generated_code": "# vim: fileencoding=utf-8\n\n\n\n\n\ndef main():\n\n    a, b = list(map(int, input().split()))\n\n    c = 0\n\n    for i in range(a, b + 1):\n\n        #     s = str(i)\n\n        #     r = \"\".join(reversed(list(s)))\n\n        #     if s == r:\n\n        #         c += 1\n\n        if (i % 10) == (i // 10000 % 10) and (i // 10 % 10) == (i // 1000 % 10):\n\n            c += 1\n\n    print(c)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "score": 1.0, "codebleu": 0.6581976170512275, "crystalbleu": 0.6195181310124266, "codebertscore": 0.95, "codescore": 0.9640966653823853, "surfaceSim": 0.8585640593746711, "abs_surfaceSim_minus_score": 0.14143594062532894}
{"golden_code": "import sys\n\nsys.setrecursionlimit(10000000)\n\nimport heapq\n\nimport math\n\n \n\ndef main():\n\n    N, K = list(map(int, input().split()))\n\n    A = [int(c) for c in input().split()]\n\n    F = [int(c) for c in input().split()]\n\n    \n\n    A.sort()\n\n    F.sort(reverse=True)\n\n \n\n    num = 0\n\n    sum_ = []\n\n    for i in range(N):\n\n      sum_.append(A[i] * F[i])\n\n    left = 0\n\n    right = 10 ** 12\n\n    while(num < 90):\n\n        number = 0\n\n        mid = (left + right) // 2\n\n        # print(mid)\n\n        for i in range(len(A)):\n\n            if sum_[i] <= mid:\n\n                continue\n\n            else:\n\n                number += math.ceil((sum_[i] - mid) / F[i])\n\n            # print(number)\n\n        if number > K:\n\n            # 最大値をmidより小さくできない -> 最大値はもっとでかい\n\n            left = mid + 1\n\n        else:\n\n            right = mid\n\n        num += 1\n\n    print(mid)\n\n                \n\n        \n\n \n\n \n\n \n\nif __name__ == '__main__':\n\n    main()", "generated_code": "import sys\n\nsys.setrecursionlimit(10000000)\n\nimport heapq\n\nimport math\n\n\n\ndef main():\n\n    N, K = list(map(int, input().split()))\n\n    A = [int(c) for c in input().split()]\n\n    F = [int(c) for c in input().split()]\n\n    \n\n    A.sort()\n\n    F.sort(reverse=True)\n\n\n\n    num = 0\n\n    sum_ = []\n\n    for i in range(len(A)):\n\n        sum_.append(A[i] * F[i])\n\n    left = 0\n\n    right = 10 ** 12\n\n    while(num < 50):\n\n        number = 0\n\n        mid = (left + right) // 2\n\n        # print(mid)\n\n        for i in range(len(A)):\n\n            if sum_[i] <= mid:\n\n                continue\n\n            else:\n\n                number += math.ceil((sum_[i] - mid) / F[i])\n\n            # print(number)\n\n        if number > K:\n\n            # 最大値をmidより小さくできない -> 最大値はもっとでかい\n\n            left = mid + 1\n\n        else:\n\n            right = mid\n\n        num += 1\n\n    print(mid)\n\n                \n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 1.0, "codebleu": 0.9017024327752274, "crystalbleu": 0.956303373775195, "codebertscore": 0.99, "codescore": 0.9938368201255798, "surfaceSim": 0.9962486602357985, "abs_surfaceSim_minus_score": 0.0037513397642015}
{"golden_code": "A, B, C, X, Y = list(map(int, input().split()))\n\n\n\nans = 5000 * 2 * 10 ** 5\n\nfor i in range(10 ** 5 + 1):\n\n    s = i * 2 * C + max(0, X - i) * A + max(0, Y - i) * B\n\n    ans = min(ans, s)\n\n\n\nprint(ans)", "generated_code": "A, B, C, X, Y = list(map(int, input().split()))\n\n\n\nif X > Y:\n\n    v = A\n\nelse:\n\n    v = B\n\n\n\nans = min(A*X+B*Y, C*max(X, Y)*2, C*min(X,Y)*2+(max(X,Y)-min(X,Y))*v)\n\n\n\nprint(ans)", "score": 1.0, "codebleu": 0.3077067099016239, "crystalbleu": 0.0, "codebertscore": 0.83, "codescore": 0.8820846080780029, "surfaceSim": 0.6942916993977482, "abs_surfaceSim_minus_score": 0.30570830060225185}
{"golden_code": "k,n = list(map(int,input().split()))\n\na=list(map(int,input().split()))\n\na.append(a[0]+k)\n\nlongd=0\n\nfor i in range(n):\n\n    tmp=abs(a[i+1]-a[i])\n\n    longd=max(longd,tmp)\n\nprint((k-longd))", "generated_code": "k,n=list(map(int,input().split()))\n\na=list(map(int,input().split()))\n\na.append(a[0]+k)\n\n\n\nx=0\n\nfor i in range(len(a)-1):\n\n    dis=abs(a[i+1]-a[i])\n\n    x=max(x,dis)\n\n\n\nprint((k-x))", "score": 1.0, "codebleu": 0.5054810911280105, "crystalbleu": 0.6708073881787768, "codebertscore": 0.94, "codescore": 0.9093894958496094, "surfaceSim": 0.9117647058823529, "abs_surfaceSim_minus_score": 0.08823529411764708}
{"golden_code": "n=int(eval(input()))\n\ns=list(map(str,input().split()))\n\ntotal=[]\n\nfor i in range(n):\n\n    if s[i] not in total:\n\n        total.append(s[i])\n\nprint(('Three' if len(total)==3 else 'Four'))", "generated_code": "eval(input())\n\nl=list(map(str,input().split()))\n\nprint(('Three' if len(set(l))==3 else 'Four'))", "score": 1.0, "codebleu": 0.17312266649453495, "crystalbleu": 0.0, "codebertscore": 0.84, "codescore": 0.5673223733901978, "surfaceSim": 0.6344086021505376, "abs_surfaceSim_minus_score": 0.3655913978494624}
{"golden_code": "import sys\n\n\n\nn, m, *lr = list(map(int, sys.stdin.read().split()))\n\nlr = list(zip(*[iter(lr)] * 2))\n\n\n\ndef main():\n\n    cnt = [0] * (n + 1)\n\n    for l, r in lr:\n\n        cnt[l-1] += 1\n\n        cnt[r] -= 1\n\n    \n\n    for i in range(n):\n\n        cnt[i+1] += cnt[i]\n\n    \n\n    res = 0\n\n    for i in range(n):\n\n        res += (cnt[i] == m) & 1\n\n    \n\n    return res\n\n\n\nif __name__ == '__main__':\n\n    ans = main()\n\n    print(ans)", "generated_code": "import sys\n\n\n\nn, m, *lr = list(map(int, sys.stdin.read().split()))\n\nl, r = lr[::2], lr[1::2]\n\n\n\ndef main():\n\n    ans = max(min(r) - max(l) + 1, 0)\n\n    return ans\n\n\n\nif __name__ == '__main__':\n\n    ans = main()\n\n    print(ans)", "score": 1.0, "codebleu": 0.30662618959757326, "crystalbleu": 0.2800354182309023, "codebertscore": 0.84, "codescore": 0.019528120756149292, "surfaceSim": 0.7303921568627452, "abs_surfaceSim_minus_score": 0.26960784313725483}
{"golden_code": "a,b,c,d,e,f=[int(eval(input())) for _ in range(6)]\n\nprint((sum([a,b,c,d,max(e,f)])-min([a,b,c,d])))", "generated_code": "print((sum(sorted(int(eval(input())) for _ in range(4))[1:])+max([int(eval(input())) for _ in range(2)])))", "score": 1.0, "codebleu": 0.2242737827628642, "crystalbleu": 0.23837482432405213, "codebertscore": 0.82, "codescore": 0.018555723130702972, "surfaceSim": 0.49947589098532497, "abs_surfaceSim_minus_score": 0.500524109014675}
{"golden_code": "# ABC102C - Linear Approximation (ARC100C)\n\nfrom statistics import median\n\n\n\n\n\ndef main():\n\n    n = int(eval(input()))\n\n    A = tuple(map(int, input().rstrip().split()))\n\n    A = tuple(j - i for i, j in enumerate(A, start=1))\n\n    b = median(A)\n\n    ans = sum(abs(a - b) for a in A)\n\n    print((int(ans)))\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()", "generated_code": "# ABC102C - Linear Approximation (ARC100C)\n\ndef main():\n\n    n = int(eval(input()))\n\n    A = tuple(map(int, input().rstrip().split()))\n\n    A = sorted(j - i for i, j in enumerate(A, start=1))\n\n    b = A[n // 2]\n\n    ans = sum(abs(a - b) for a in A)\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()", "score": 1.0, "codebleu": 0.674285129333551, "crystalbleu": 0.7405360191846485, "codebertscore": 0.96, "codescore": 0.03532315418124199, "surfaceSim": 0.8312320916905445, "abs_surfaceSim_minus_score": 0.16876790830945554}
{"golden_code": "from math import factorial\n\nN = int(eval(input()))\n\nprint((factorial(N) % (10**9 + 7)))", "generated_code": "from math import factorial\n\nN = int(eval(input()))\n\nans = 1\n\nfor i in range(1,N+1):\n\n    ans *= i % (10**9 + 7)\n\n    ans %= 10**9 + 7\n\nprint(ans)", "score": 1.0, "codebleu": 0.5155116125588945, "crystalbleu": 0.0, "codebertscore": 0.88, "codescore": 0.9611589312553406, "surfaceSim": 0.7393509127789046, "abs_surfaceSim_minus_score": 0.26064908722109537}
{"golden_code": "n,m=list(map(int,input().split()))\n\nc=[0]*(n+2)\n\nfor i in range(m):\n\n  l,r=list(map(int,input().split()))\n\n  c[l-1]+=1\n\n  c[r]-=1\n\nfor i in range(1,n+2):\n\n  c[i]=c[i]+c[i-1]\n\nans=0\n\nfor i in range(n+2):\n\n  if c[i]==m:\n\n    ans+=1\n\nprint(ans)", "generated_code": "n,m=list(map(int,input().split()))\n\nl,r=list(map(int,input().split()))\n\nfor i in range(m-1):\n\n  tl,tr=list(map(int,input().split()))\n\n  if l<tl:\n\n    l=tl\n\n  if tr<r:\n\n    r=tr\n\nprint((max(r-l+1,0)))", "score": 1.0, "codebleu": 0.2118312531149506, "crystalbleu": 0.22829217769272614, "codebertscore": 0.87, "codescore": 0.27114346623420715, "surfaceSim": 0.598863431354862, "abs_surfaceSim_minus_score": 0.401136568645138}
{"golden_code": "a,b,c=1,0,0\n\nexec('a,b,c=b,c,(a+c)%(10**9+7);'*(int(eval(input()))-2))\n\nprint(c)", "generated_code": "a,b,c=1,0,0\n\nexec('a,b,c=b,c,a+c;'*(int(eval(input()))-2))\n\nprint((c%(10**9+7)))", "score": 1.0, "codebleu": 0.5057864365426399, "crystalbleu": 0.0, "codebertscore": 0.97, "codescore": 0.9939196109771729, "surfaceSim": 0.75, "abs_surfaceSim_minus_score": 0.25}
{"golden_code": "from scipy.sparse.csgraph import csgraph_from_dense, floyd_warshall\n\n\n\nINF = float('inf')\n\n\n\ndef sol():\n\n    N, M = list(map(int, input().split()))\n\n\n\n    edges = []\n\n\n\n    for _ in range(M):\n\n        fr, to, cost = list(map(int, input().split()))\n\n        fr -= 1\n\n        to -= 1\n\n        edges.append((fr, to, cost))\n\n\n\n    graph = [[INF] * N for _ in range(N)]\n\n    for fr, to, cost in edges:\n\n        graph[fr][to] = cost\n\n\n\n    graph = csgraph_from_dense(graph, null_value=INF)\n\n\n\n    dist = floyd_warshall(graph, directed=False)\n\n    ans = (graph > dist).sum()\n\n    print(ans)\n\n\n\nsol()", "generated_code": "N, M = list(map(int, input().split()))\n\nINF = 10**18\n\n\n\nminDist = [[INF] * N for _ in range(N)]\n\nfor i in range(N):\n\n    minDist[i][i] = 0\n\n\n\nedges = []\n\nfor _ in range(M):\n\n    fr, to, d = list(map(int, input().split()))\n\n    fr -= 1\n\n    to -= 1\n\n    edges.append((fr, to, d))\n\n    minDist[fr][to] = d\n\n    minDist[to][fr] = d\n\n\n\nfor k in range(N):\n\n    for i in range(N):\n\n        for j in range(N):\n\n            d = minDist[i][k] + minDist[k][j]\n\n            if minDist[i][j] > d:\n\n                minDist[i][j] = d\n\n\n\nans = 0\n\nfor fr, to, d in edges:\n\n    if minDist[fr][to] < d:\n\n        ans += 1\n\nprint(ans)\n", "score": 1.0, "codebleu": 0.47322317218413795, "crystalbleu": 0.42492648120315435, "codebertscore": 0.8, "codescore": 0.3275827169418335, "surfaceSim": 0.6190663519538422, "abs_surfaceSim_minus_score": 0.3809336480461578}
{"golden_code": "#E\n\nfrom itertools import accumulate\n\nfrom bisect import bisect_left\n\ndef main():\n\n    n,m=list(map(int,input().split()))\n\n    A=list(map(int,input().split()))\n\n    A.sort()\n\n    \n\n    def count(k):\n\n        cnt=0\n\n        for a in A:\n\n            cnt+=bisect_left(A,k-a)\n\n        return cnt\n\n    \n\n    ok=0\n\n    ng=10**10+1\n\n    while ng-ok>1:\n\n        mid=(ok+ng)//2\n\n        if count(mid)<n**2-m:\n\n            ok=mid\n\n        else:\n\n            ng=mid\n\n    border=ok\n\n    \n\n    k=n**2-count(border)\n\n    Acc=[0]+list(accumulate(A))\n\n    s=Acc[-1]\n\n    ans=0\n\n    for a in A:\n\n        idx=bisect_left(A,border-a)\n\n        ans+=a*(n-idx)+(s-Acc[idx])\n\n    ans-=border*(k-m)\n\n    print(ans)\n\n    \n\nif __name__=='__main__':\n\n    main()", "generated_code": "from itertools import accumulate\n\nfrom bisect import bisect_left\n\ndef main():\n\n    n,m=list(map(int,input().split()))\n\n    A=list(map(int,input().split()))\n\n    A.sort()\n\n    \n\n    def count(k):\n\n        cnt=0\n\n        for a in A:\n\n            cnt+=bisect_left(A,k-a)\n\n        return cnt\n\n    \n\n    ok=0\n\n    ng=2*10**5+1\n\n    while ng-ok>1:\n\n        mid=(ok+ng)//2\n\n        if count(mid)<n**2-m:\n\n            ok=mid\n\n        else:\n\n            ng=mid\n\n    border=ok\n\n    \n\n    k=n**2-count(border)\n\n    Acc=[0]+list(accumulate(A))\n\n    s=Acc[-1]\n\n    ans=0\n\n    for a in A:\n\n        idx=bisect_left(A,border-a)\n\n        ans+=a*(n-idx)+(s-Acc[idx])\n\n    ans-=border*(k-m)\n\n    print(ans)\n\n    \n\nif __name__=='__main__':\n\n    main()", "score": 1.0, "codebleu": 0.9039643902680069, "crystalbleu": 0.9631758660180704, "codebertscore": 0.99, "codescore": 0.9938206076622009, "surfaceSim": 0.9972752043596731, "abs_surfaceSim_minus_score": 0.0027247956403269047}
{"golden_code": "from collections import Counter\n\n\n\nimport numpy as np\n\n\n\n\n\ndef part(pts, a, ans):\n\n    b = np.dot(pts, [np.sin(a), np.cos(a)])\n\n    c = np.argmax(b, axis=0)\n\n    for i, v in list(Counter(c).items()):\n\n        ans[i] += v\n\n\n\n\n\ndef solve(n, pts):\n\n    ans = [0] * n\n\n    part(pts, np.linspace(0, np.pi, 100000, endpoint=False), ans)\n\n    part(pts, np.linspace(np.pi, 2 * np.pi, 100000, endpoint=False), ans)\n\n    return [v / 200000 for v in ans]\n\n\n\n\n\nn = int(eval(input()))\n\npts = np.array([list(map(int, input().split())) for _ in range(n)])\n\nprint(('\\n'.join(map(str, solve(n, pts)))))\n", "generated_code": "from collections import Counter\n\nimport numpy as np\n\n\n\n\n\ndef part(pts, s, t, num, ans):\n\n    a = np.linspace(s, t, num, endpoint=False)\n\n    for i, v in list(Counter(np.argmax(np.dot(pts, [np.sin(a), np.cos(a)]), axis=0)).items()):\n\n        ans[i] += v\n\n\n\n\n\ndef solve(n, pts):\n\n    ans = np.zeros(n)\n\n    part(pts, 0, np.pi, 1e5, ans)\n\n    part(pts, np.pi, 2 * np.pi, 1e5, ans)\n\n    return ans / 2e5\n\n\n\n\n\nn = int(eval(input()))\n\nprint(('\\n'.join(map(str, solve(n, [list(map(int, input().split())) for _ in range(n)])))))\n", "score": 1.0, "codebleu": 0.4627881224289302, "crystalbleu": 0.6701756000648613, "codebertscore": 0.93, "codescore": 0.3193431496620178, "surfaceSim": 0.7909556313993173, "abs_surfaceSim_minus_score": 0.20904436860068265}
{"golden_code": "import numpy as np\n\nn,k=list(map(int,input().split()))\n\nexp=tuple([(int(x)+1)/2 for x in input().split()])\n\nl=np.cumsum(exp)\n\n\n\nans=l[k-1]\n\nfor i in range(0,n-k):\n\n  x=l[i+k]-l[i]\n\n  ans=max(ans,x)\n\nprint(ans)", "generated_code": "def main():\n\n    from itertools import accumulate\n\n    n, k = list(map(int, input().split()))\n\n    *exp, = [(int(x) + 1) / 2 for x in input().split()]\n\n    l = accumulate(exp)\n\n    l = list(l)\n\n    ans = l[k - 1]\n\n    for i in range(0, n - k):\n\n        x = l[i + k] - l[i]\n\n        ans = max(ans, x)\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 1.0, "codebleu": 0.3578977981197397, "crystalbleu": 0.5650958210653207, "codebertscore": 0.88, "codescore": 0.018315142020583153, "surfaceSim": 0.7321428571428572, "abs_surfaceSim_minus_score": 0.2678571428571428}
{"golden_code": "import numpy as np\n\n\n\nn = int(eval(input()))\n\na = np.array(list(map(int,input().split())))\n\n\n\ncount = 0\n\nwhile np.all(a%2==0):\n\n    count+=1\n\n    a=a/2\n\nprint(count)\n", "generated_code": "N=int(eval(input()))\n\na = [int(i) for i in input().split()]\n\n\n\ncount=0\n\nwhile 1:\n\n    if sum([i%2 for i in a]) == 0:\n\n        a = [i/2 for i in a]\n\n        count=count+1\n\n    else:\n\n        print(count)\n\n        break\n", "score": 1.0, "codebleu": 0.23312890830139688, "crystalbleu": 0.0, "codebertscore": 0.82, "codescore": 0.9294410347938538, "surfaceSim": 0.6391104906262465, "abs_surfaceSim_minus_score": 0.3608895093737535}
{"golden_code": "s = eval(input())\n\n\n\nstart = -1\n\nend = 0\n\nfor i in range(len(s)):\n\n    if s[i] == 'A' and start < 0:\n\n        start = i\n\n    elif s[i] == 'Z':\n\n        end = i\n\nprint((end - start + 1))\n", "generated_code": "s = eval(input())\n\n\n\nstart = 0\n\nfor i in range(len(s)):\n\n    if s[i] == 'A':\n\n        start = i\n\n        break\n\n\n\nend = 0\n\nfor i in reversed(list(range(len(s)))):\n\n    if s[i] == 'Z':\n\n        end = i\n\n        break\n\nprint((end - start + 1))\n", "score": 1.0, "codebleu": 0.6117105849764274, "crystalbleu": 0.6050930169057582, "codebertscore": 0.93, "codescore": 0.20198498666286469, "surfaceSim": 0.739399928135106, "abs_surfaceSim_minus_score": 0.260600071864894}
{"golden_code": "s = input()[::-1]\n\n\n\nwhile True:\n\n    if len(s) == 0:\n\n        break\n\n    if s[:7] == \"remaerd\":\n\n        s = s[7:]\n\n    elif s[:6] == \"resare\":\n\n        s = s[6:]\n\n    elif s[:5] == \"maerd\" or s[:5] == \"esare\":\n\n        s = s[5:]\n\n    else:\n\n        print(\"NO\")\n\n        exit()\n\n\n\nprint(\"YES\")", "generated_code": "import re\n\n\n\ns = eval(input())\n\n\n\nif re.fullmatch(r\"(dream|dreamer|erase|eraser)+\", s):\n\n    print(\"YES\")\n\nelse:\n\n    print(\"NO\")", "score": 1.0, "codebleu": 0.10333360166566952, "crystalbleu": 0.0, "codebertscore": 0.72, "codescore": 0.9630358815193176, "surfaceSim": 0.47155225726654304, "abs_surfaceSim_minus_score": 0.528447742733457}
{"golden_code": "N = int(eval(input()))\n\n\n\ncount = 0\n\nfor i in range(1, N + 1):\n\n    num_dig = 0\n\n    ii = i\n\n    while ii > 0:\n\n        ii = int(ii / 10)\n\n        num_dig += 1\n\n    if num_dig % 2 != 0:\n\n        count += 1\n\n\n\nprint(count)", "generated_code": "N = int(eval(input()))\n\n\n\ncount = 0\n\nfor i in range(1, N + 1):\n\n    if len(str(i)) % 2 != 0:\n\n        count += 1\n\nprint(count)", "score": 1.0, "codebleu": 0.5373822397794952, "crystalbleu": 0.0, "codebertscore": 0.9, "codescore": 0.9934222102165222, "surfaceSim": 0.7988806858775899, "abs_surfaceSim_minus_score": 0.20111931412241013}
{"golden_code": "W,H,x,y,r = [int(i) for i in input().split()]\n\nif x - r >= 0 and x + r <= W and y - r >= 0 and y + r <= H:\n\n    print(\"Yes\")\n\nelse:\n\n    print(\"No\")", "generated_code": "W, H, x, y, r = list(map(int, input().split()))\n\nif r <= x <= W-r and r <= y <= H-r:\n\n    print('Yes')\n\nelse:\n\n    print('No')\n", "score": 1.0, "codebleu": 0.24356409202473264, "crystalbleu": 0.0, "codebertscore": 0.9, "codescore": 0.6411237716674805, "surfaceSim": 0.7763835263835264, "abs_surfaceSim_minus_score": 0.22361647361647363}
{"golden_code": "from math import floor, sqrt\n\nfrom collections import Counter\n\n\n\nMOD = 10 ** 9 + 7\n\n\n\n# xを素因数分解する\n\ndef getPrimeFactor(x):\n\n    ans = []\n\n    for d in range(2, floor(sqrt(x)) + 1):\n\n        while x % d == 0:\n\n            ans.append(d)\n\n            x //= d\n\n\n\n    if x != 1:\n\n        ans.append(x)\n\n\n\n    return ans\n\n\n\n# xのn乗（二分累乗法）\n\ndef power(x, n):\n\n    ans = 1\n\n    while n:\n\n        if n % 2 == 1:\n\n            ans = (ans * x) % MOD\n\n        x = (x * x) % MOD\n\n        n //= 2\n\n    return ans\n\n\n\n\n\nN, M = list(map(int, input().split()))\n\n\n\nPFs = getPrimeFactor(M)\n\ncnt = Counter(PFs)\n\n\n\nN2 = N\n\nif len(cnt):\n\n    N2 += max(cnt.values())\n\n\n\n# facts[x]: xの階乗\n\nfacts = [1] + [0] * N2\n\nfor x in range(1, N2 + 1):\n\n    facts[x] = (facts[x - 1] * x) % MOD\n\n\n\n# invFs[x]: xの階乗の逆元\n\ninvFs = [0] * N2 + [power(facts[N2], MOD - 2)]\n\nfor x in reversed(list(range(N2))):\n\n    invFs[x] = (invFs[x + 1] * (x + 1)) % MOD\n\n\n\ndef comb(n, k):\n\n    return ((facts[n] * invFs[k]) % MOD * invFs[n - k]) % MOD\n\n\n\n\n\nans = 1\n\nfor num in list(cnt.values()):\n\n    ans = (ans * comb(N + num - 1, num)) % MOD\n\nprint(ans)\n", "generated_code": "from math import floor, sqrt\n\nfrom collections import Counter\n\n\n\nMOD = 10 ** 9 + 7\n\n\n\n# xを素因数分解する\n\ndef getPrimeFactor(x):\n\n    ans = []\n\n    for d in range(2, floor(sqrt(x)) + 1):\n\n        while x % d == 0:\n\n            ans.append(d)\n\n            x //= d\n\n    if x != 1:\n\n        ans.append(x)\n\n    return ans\n\n\n\ndef comb(n, k):\n\n    k = min(k, n - k)\n\n    ans = 1\n\n    for i in range(n, n - k, -1):\n\n        ans *= i\n\n    for i in range(1, k + 1):\n\n        ans //= i \n\n    return ans\n\n\n\n\n\nN, M = list(map(int, input().split()))\n\n\n\nPFs = getPrimeFactor(M)\n\ncnt = Counter(PFs)\n\n\n\nans = 1\n\nfor num in list(cnt.values()):\n\n    ans *= comb(N + num - 1, num)\n\nprint((ans % MOD))\n", "score": 1.0, "codebleu": 0.4402052513109228, "crystalbleu": 0.38525969984631075, "codebertscore": 0.88, "codescore": 0.7784184813499451, "surfaceSim": 0.7838077827108906, "abs_surfaceSim_minus_score": 0.21619221728910942}
{"golden_code": "'''\n\nある平面のブロック数×(0,1)\n\n一つでも偶数があれば、均等分割可能\n\nすべて奇数のとき、\n\nある平面のブロック数を最小となるようにすると、その数が答えになる\n\n'''\n\n\n\narr = list(map(int, input().split()))\n\n\n\nret = -1\n\nif 0 in list([x % 2 for x in arr]):\n\n    ret = 0\n\nelse:\n\n    arr_sorted = sorted(arr)\n\n    ret = arr_sorted[0] * arr_sorted[1]\n\nprint(ret)", "generated_code": "a = list(map(int, input().split()))\n\n\n\nif any([x % 2 == 0 for x in a]):\n\n    print((0))\n\nelse:\n\n    a = list(sorted(a))\n\n    print((a[0] * a[1]))\n", "score": 1.0, "codebleu": 0.253092184374594, "crystalbleu": 0.0, "codebertscore": 0.72, "codescore": 0.5096843242645264, "surfaceSim": 0.635239318984902, "abs_surfaceSim_minus_score": 0.36476068101509795}
{"golden_code": "import sys\n\nimport numpy as np\n\n\n\n\n\ndef main():\n\n    h, w = list(map(int, sys.stdin.buffer.readline().split()))\n\n    n = int(sys.stdin.buffer.readline())\n\n    a = list(map(int, sys.stdin.buffer.readline().split()))\n\n    ans = np.zeros(w*h, np.int64)\n\n    now = 0\n\n    for i, x in enumerate(a):\n\n        for j in range(x):\n\n            ans[now + j] = i+1\n\n        now += x\n\n\n\n    ans = ans.reshape(h, w)\n\n    for i in range(h):\n\n        if i % 2:\n\n            print((*ans[i, ::-1]))\n\n        else:\n\n            print((*ans[i]))\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "generated_code": "import sys\n\n\n\n\n\ndef main():\n\n    h, w = list(map(int, sys.stdin.buffer.readline().split()))\n\n    n = int(sys.stdin.buffer.readline())\n\n    a = list(map(int, sys.stdin.buffer.readline().split()))\n\n    ans = [0]*(w*h)\n\n    now = 0\n\n    for i, x in enumerate(a):\n\n        for j in range(x):\n\n            ans[now + j] = i+1\n\n        now += x\n\n\n\n    for i in range(h):\n\n        if i % 2:\n\n            print((*reversed(ans[i*w:(i+1)*w])))\n\n        else:\n\n            print((*ans[i*w:(i+1)*w]))\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "score": 1.0, "codebleu": 0.6247421075451611, "crystalbleu": 0.7815885645247879, "codebertscore": 0.94, "codescore": 0.018390368670225143, "surfaceSim": 0.8636800180780747, "abs_surfaceSim_minus_score": 0.1363199819219253}
{"golden_code": "n = int(eval(input()))\n\nv = list(map(int, input().split()))\n\nc = list(map(int, input().split()))\n\nresult = 0\n\nfor i in range(n):\n\n  if v[i] > c[i]:\n\n    result += v[i] - c[i]\n\nprint(result)", "generated_code": "N = int(eval(input()))\n\nV = list(map(int, input().split()))\n\nC = list(map(int, input().split()))\n\nprint((sum([V[i] - C[i] for i in range(N) if V[i] > C[i]])))\n", "score": 1.0, "codebleu": 0.4144833762482961, "crystalbleu": 0.32776309440480517, "codebertscore": 0.92, "codescore": 0.25371748208999634, "surfaceSim": 0.6825396825396826, "abs_surfaceSim_minus_score": 0.31746031746031744}
{"golden_code": "from bisect import bisect_right\n\nimport sys\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\nreadlines = sys.stdin.readlines\n\n\n\ndef main():\n\n    x = int(readline())\n\n\n\n    for a in range(-120, 120):\n\n        for b in range(-120, 120):\n\n            if a**5 - b**5 == x:\n\n                print((a, b))\n\n                exit()\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "generated_code": "# AC: 33 msec(Python3)\n\nfrom itertools import combinations_with_replacement\n\nimport sys\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\nreadlines = sys.stdin.readlines\n\n\n\ndef main():\n\n    x = int(readline())\n\n\n\n    ab = [i**5 for i in range(200)]\n\n\n\n    C = combinations_with_replacement(ab, 2)\n\n    for a, b in C:\n\n        if a + b == x:\n\n            print((int(pow(b, 0.2)), -int(pow(a, 0.2))))\n\n            break\n\n        \n\n        if b - a == x:\n\n            print((int(pow(b, 0.2)), int(pow(a, 0.2))))\n\n            break\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "score": 1.0, "codebleu": 0.46739699897790676, "crystalbleu": 0.3286111663475004, "codebertscore": 0.84, "codescore": 0.8132160305976868, "surfaceSim": 0.7786580836840802, "abs_surfaceSim_minus_score": 0.22134191631591982}
{"golden_code": "s=eval(input())\n\nt=eval(input())\n\ns*=2\n\nnext=[[-1]*26 for _ in range(len(s))]\n\nalph=[[]for _ in range(26)]\n\nfor i in range(len(s)):\n\n\talph[ord(s[i])-ord(\"a\")].append(i)\n\nfrom bisect import bisect_right\n\nfor i in range(len(s)//2):\n\n\tfor j in range(26):\n\n\t\tif len(alph[j])>bisect_right(alph[j],i):\n\n\t\t\tnext[i][j]=alph[j][bisect_right(alph[j],i)]\n\nans=1\n\nnow=len(s)//2-1\n\nfor x in t:\n\n\tr=ord(x)-ord(\"a\")\n\n\tnow=next[now][r]\n\n\tif now==-1:\n\n\t\tprint((-1))\n\n\t\texit()\n\n\tif now>=len(s)//2:\n\n\t\tans+=len(s)//2\n\n\t\tnow-=len(s)//2\n\nprint((ans+now-len(s)//2))", "generated_code": "#O(|S|log|s|)\n\ndef main():\n\n\ts=eval(input())\n\n\tt=eval(input())\n\n\tn=len(s)\n\n\tnow=-1\n\n\tans=1\n\n\tif not set(t)<=set(s):#tがsの部分集合でない\n\n\t\tprint((-1))\n\n\t\texit()\n\n\tfor x in t:\n\n\t\tnow=s.find(x,now+1)#nowより大きいところからxを探す\n\n\t\tif now==-1:#nowより大きいところでxが見つからなかったら\n\n\t\t\tans+=n\n\n\t\t\tnow=s.find(x)\n\n\tprint((ans+now))\n\nif __name__ == '__main__':\n\n\tmain()", "score": 1.0, "codebleu": 0.16404167581080745, "crystalbleu": 0.0966474554057038, "codebertscore": 0.74, "codescore": 0.028696782886981964, "surfaceSim": 0.4332141696457589, "abs_surfaceSim_minus_score": 0.5667858303542411}
{"golden_code": "#template\n\ndef inputlist(): return [int(j) for j in input().split()]\n\n#template\n\n#issueから始める\n\nK,N = inputlist()\n\nA = inputlist()\n\nlia = [0]*N\n\nfor i in range(1,N):\n\n    k = A[i] - A[i-1]\n\n    lia[i] = k\n\nlia[0] = (K+A[0]-A[-1])\n\nlia.sort()\n\nans = 0\n\nfor i in range(N-1):\n\n    ans += lia[i]\n\nprint(ans)", "generated_code": "#template\n\ndef inputlist(): return [int(j) for j in input().split()]\n\ndef listinput(): return input().split()\n\n#template\n\nK,N = inputlist()\n\nA = inputlist()\n\ndis = [0]*(N)\n\nfor i in range(N):\n\n    if i == N-1:\n\n        dis[i] = K+A[0] - A[i]\n\n        continue\n\n    dis[i] = A[i+1] - A[i]\n\ndis.sort()\n\nprint((sum(dis[:-1])))", "score": 1.0, "codebleu": 0.44876994418705207, "crystalbleu": 0.4225097971617697, "codebertscore": 0.9, "codescore": 0.10700434446334839, "surfaceSim": 0.7159193049036252, "abs_surfaceSim_minus_score": 0.2840806950963748}
{"golden_code": "#! /usr/bin/env python3\n\n\n\nimport sys\n\nint1 = lambda x: int(x) - 1\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\nsys.setrecursionlimit(500000)\n\n\n\n\n\ndef isMultiple(s, m):\n\n    tmp = 0\n\n    for i in range(len(s)):\n\n        tmp = (tmp * 10 + int(s[i])) % m\n\n        if tmp == 0:\n\n            return i\n\n    return -1\n\n\n\n\n\nk = int(readline())\n\nacc = \"7\" * 50000000\n\nif k % 2 == 0:\n\n    ans = -1\n\nelse:\n\n\n\n    ans = isMultiple(acc, k)\n\n    if ans != -1:\n\n        ans += 1\n\n\n\nprint(ans)\n", "generated_code": "#! /usr/bin/env python3\n\n\n\nimport sys\n\nint1 = lambda x: int(x) - 1\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\nsys.setrecursionlimit(500000)\n\n\n\nk = int(readline())\n\n\n\nans = -1\n\nacc = 7 % k\n\nfor n in range(1, k + 10):\n\n    if acc == 0:\n\n        ans = n\n\n        break\n\n    acc = (10 * acc + 7) % k\n\n\n\nprint(ans)\n", "score": 1.0, "codebleu": 0.44668800795647723, "crystalbleu": 0.36251708798701154, "codebertscore": 0.91, "codescore": 0.5262619256973267, "surfaceSim": 0.750661832412523, "abs_surfaceSim_minus_score": 0.24933816758747696}
{"golden_code": "import sys\n\ncan = True; eval(input())\n\ne = [[0, 0, 0]] + [list(map(int, e.split())) for e in sys.stdin]\n\nfor a, b in zip(e[1:], e):\n\n    t = a[0] - b[0] - abs(a[1] - b[1]) - abs(a[2] - b[2])\n\n    if t < 0 or t % 2 == 1: can = False; break\n\nprint((['No', 'Yes'][can]))", "generated_code": "import sys\n\nans = 'Yes'; eval(input())\n\nfor e in sys.stdin:\n\n    t, x, y = list(map(int, e.split()))\n\n    t = t - x - y\n\n    if t < 0 or t % 2 == 1: ans = 'No'; break\n\nprint(ans)", "score": 1.0, "codebleu": 0.25451653474995944, "crystalbleu": 0.2186313111646685, "codebertscore": 0.87, "codescore": 0.9739229679107666, "surfaceSim": 0.6473782771535581, "abs_surfaceSim_minus_score": 0.3526217228464419}
{"golden_code": "import numpy as np\n\nN = int(eval(input()))\n\nabc = []\n\nfor i in range(N):\n\n    abc.append(list(map(int, input().split())))\n\n    \n\ndp = np.zeros(shape=(N, 3), dtype=int)\n\ndp[0, :] = abc[0]\n\nfor i in range(N-1):\n\n    dp[i+1, 0] = max(dp[i+1, 0], dp[i, 1] + abc[i+1][0], dp[i, 2] + abc[i+1][0])\n\n    dp[i+1, 1] = max(dp[i+1, 1], dp[i, 0] + abc[i+1][1], dp[i, 2] + abc[i+1][1])\n\n    dp[i+1, 2] = max(dp[i+1, 2], dp[i, 0] + abc[i+1][2], dp[i, 1] + abc[i+1][2])\n\nprint((max(dp[N-1, :])))", "generated_code": "N = int(eval(input()))\n\nabc = []\n\nfor i in range(N):\n\n    data = list(map(int, input().split()))\n\n    abc.append(data)\n\n\n\ndp = [[0 for i in range(3)] for j in range(N)]\n\ndp[0][0] = abc[0][0]\n\ndp[0][1] = abc[0][1]\n\ndp[0][2] = abc[0][2]\n\n\n\nfor i in range(N-1):\n\n    for j in range(3):\n\n        if j == 0:\n\n            dp[i+1][1] = max(dp[i][0] + abc[i+1][1], dp[i+1][1])\n\n            dp[i+1][2] = max(dp[i][0] + abc[i+1][2], dp[i+1][2])\n\n        if j == 1:\n\n            dp[i+1][0] = max(dp[i][1] + abc[i+1][0], dp[i+1][0])\n\n            dp[i+1][2] = max(dp[i][1] + abc[i+1][2], dp[i+1][2])\n\n        if j == 2:\n\n            dp[i+1][1] = max(dp[i][2] + abc[i+1][1], dp[i+1][1])\n\n            dp[i+1][0] = max(dp[i][2] + abc[i+1][0], dp[i+1][0])\n\n\n\nprint((max(dp[N-1])))", "score": 1.0, "codebleu": 0.31765678630399047, "crystalbleu": 0.4803360304723532, "codebertscore": 0.91, "codescore": 0.6426621079444885, "surfaceSim": 0.6075675938061259, "abs_surfaceSim_minus_score": 0.3924324061938741}
{"golden_code": "import math\n\nn = int(eval(input()))\n\n\n\nans = math.factorial(n)  # nの階乗を計算\n\n\n\nif ans >= (10 ** 9)+7:\n\n    ans = ans % ((10 ** 9)+7)\n\n\n\nprint(ans)\n", "generated_code": "n = int(eval(input()))\n\n\n\nans = 1\n\nfor i in range(1, n+1):\n\n    ans = ans * i\n\n    ans = ans % ((10 ** 9)+7)  # 途中で割り算の余りを求めても、最終結果は同じになる\n\n\n\nprint(ans)", "score": 1.0, "codebleu": 0.45508450301466985, "crystalbleu": 0.0, "codebertscore": 0.8, "codescore": 0.1945601999759674, "surfaceSim": 0.6609271523178808, "abs_surfaceSim_minus_score": 0.3390728476821192}
{"golden_code": "S = int(eval(input()))\n\nMOD = 10 ** 9 + 7\n\n\n\n#dp[i]最後に切った場所がi　スタートが1なのは、そこまでの切り方が1通りなので\n\n#３以下はダメなので、3個前の結果を見るようにする\n\ndp =  [0] * (S+1)\n\ndp[0] = 1\n\n\n\nfor i in range(1, S+1):\n\n    #たとえばi=6のとき、i=6で初めて切れ目を入れる時で＋１、i=3に切れ目をいれるときで＋１で合計＋２\n\n    for j in range(0, (i-3)+1):\n\n        dp[i] += dp[j]\n\n        dp[i] %= MOD\n\nprint((dp[S]))        ", "generated_code": "S = int(eval(input()))\n\nMOD = 10 ** 9 + 7\n\n\n\n#dp[i]最後に切った場所がi　スタートが1なのは、そこまでの切り方が1通りなので\n\n#３以下はダメなので、3個前の結果を見るようにする\n\ndp =  [0] * (S+1)\n\ndp[0] = 1\n\n\n\n#これまでの和をxに保存しておく\n\nx = 0\n\nfor i in range(1, S+1):\n\n    if i-3 >= 0:\n\n        x += dp[i-3]\n\n        x %= MOD\n\n    dp[i] = x\n\nprint((dp[S]))        ", "score": 1.0, "codebleu": 0.6621869494388611, "crystalbleu": 0.6288731490918487, "codebertscore": 0.93, "codescore": 0.993601381778717, "surfaceSim": 0.8745892661555312, "abs_surfaceSim_minus_score": 0.12541073384446877}
{"golden_code": "N,K=list(map(int,input().split()))\n\n\n\ncon = 0\n\nans = list(int() for _ in range(100000))\n\npre = 0\n\n\n\n\n\nfor _ in range(K):\n\n\n\n    D = int(eval(input()))\n\n    arr = list(map(int,input().split()))\n\n\n\n    for j in range(D):\n\n\n\n        ans[pre+j]=arr[j]\n\n\n\n    pre += D\n\n\n\n        \n\nfin = (N+1) - len(set(ans))\n\n\n\nprint(fin)", "generated_code": "N,K=list(map(int,input().split()))\n\n\n\ncon = 0\n\nans = list(int() for _ in range(10001))\n\npre = 0\n\n\n\n\n\nfor _ in range(K):\n\n\n\n    D = int(eval(input()))\n\n    arr = list(map(int,input().split()))\n\n\n\n    for j in range(D):\n\n\n\n        ans[pre+j]=arr[j]\n\n\n\n    pre += D\n\n\n\n        \n\nfin = (N+1) - len(set(ans))\n\n\n\nprint(fin)", "score": 1.0, "codebleu": 0.9655676097906438, "crystalbleu": 0.9440375310909427, "codebertscore": 1.0, "codescore": 0.9938530921936035, "surfaceSim": 0.9968553459119497, "abs_surfaceSim_minus_score": 0.0031446540880503138}
{"golden_code": "import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\nN = int(readline())\n\nAB = [list(map(int,readline().split())) for i in range(N-1)]\n\n\n\ngraph = [[] for _ in range(N+1)] #隣接リスト\n\nfor a,b in AB:\n\n    graph[a].append(b)\n\n    graph[b].append(a)\n\n\n\n#親のノードに子を入れてくdfs\n\nstack = [1]\n\nparent = [0]*(N+1)\n\norder = []\n\nwhile stack:\n\n    x = stack.pop()\n\n    order.append(x)\n\n    for i in graph[x]:\n\n        if i == parent[x]:\n\n            continue\n\n        parent[i] = x\n\n        stack.append(i)\n\n\n\n#各子の色を決めていく。\n\ncolor = [-1]*(N+1)\n\nfor x in order:\n\n    ng = color[x]\n\n    c = 1\n\n    for y in graph[x]:\n\n        if parent[x] == y:\n\n            continue\n\n        if c == ng:\n\n            c += 1\n\n        color[y] = c\n\n        c += 1\n\n\n\nans = []\n\nfor a,b in AB:\n\n    if parent[a] == b: #子の頂点の色を入れる\n\n        ans.append(color[a])\n\n    else:\n\n        ans.append(color[b])\n\n\n\nprint((max(ans)))\n\nfor i in ans:\n\n    print(i)\n\n        \n", "generated_code": "import sys\n\nfrom collections import deque\n\nreadline = sys.stdin.buffer.readline\n\ndef even(n): return 1 if n%2==0 else 0\n\nn = int(readline())\n\ng = [[] for _ in range(n)] #隣接リスト\n\nab = []\n\nfor i in range(n-1):\n\n    a,b = list(map(int,readline().split()))\n\n    a,b = a-1,b-1\n\n    ab.append((a,b))\n\n    g[a].append(b)\n\n    g[b].append(a)\n\n\n\nroot = 0\n\nparent = [0]*n\n\ndeq = deque([root])\n\norder = [root]\n\n\n\ncolor = [-1]*n\n\ndeq = deque([root])\n\nwhile deq:\n\n    fr = deq.pop()\n\n    ng = color[fr]\n\n    c = 0\n\n    for go in g[fr]:\n\n        if go == parent[fr]:\n\n            continue\n\n        if c == ng:\n\n            c += 1\n\n        parent[go] = fr\n\n        color[go] = c\n\n        c += 1\n\n        deq.append(go)\n\n        order.append(go)\n\nrank = [0]*n\n\nfor i,j in enumerate(order):\n\n    rank[j] = i\n\nprint((max(color)+1))\n\nfor a,b in ab:\n\n    if rank[a] < rank[b]:\n\n        print((color[b]+1))\n\n    else:\n\n        print((color[a]+1))", "score": 1.0, "codebleu": 0.3688076409564845, "crystalbleu": 0.3196865245306567, "codebertscore": 0.83, "codescore": 0.8027825951576233, "surfaceSim": 0.6708789740849586, "abs_surfaceSim_minus_score": 0.32912102591504144}
{"golden_code": "N = int(eval(input()))\n\np = 1\n\nfor i in range(N):\n\n    p *= (i + 1)\n\n    p %= (1e9 + 7)\n\nprint((int(p)))", "generated_code": "N = int(eval(input()))\n\np = 1\n\nfor i in range(N):\n\n    p = p * (i + 1) % (1e9 + 7)\n\nprint((int(p)))", "score": 1.0, "codebleu": 0.7433297555071704, "crystalbleu": 0.0, "codebertscore": 0.98, "codescore": 0.9937666654586792, "surfaceSim": 0.9354395604395604, "abs_surfaceSim_minus_score": 0.06456043956043955}
{"golden_code": "import sys\n\nimport itertools\n\nfrom operator import itemgetter #sortedの対象を決めたい\n\nfrom fractions import gcd #最大公約数\n\nfrom math import ceil, floor, sqrt, isinf #小数点切り上げ、切り捨て、平方根\n\nfrom copy import deepcopy #参照で影響されないコピー\n\nfrom collections import Counter, deque #要素ごとの出現回数、双方向アクセス可能データ型\n\nimport heapq\n\nimport numpy as np\n\nfrom functools import reduce\n\nsys.setrecursionlimit(200000)\n\n\n\ninput = sys.stdin.readline\n\n# template\n\n\n\ndef retmax(a, b):\n\n    if a > b:\n\n        return a\n\n    else:\n\n        return b\n\n\n\ndef main():\n\n    n = int(eval(input()))\n\n    a = [list(map(int, input().split())) for _ in range(n)]\n\n\n\n    dp = np.zeros([3, n+1])\n\n\n\n    for i, a_l in enumerate(a):\n\n        for j in range(3):\n\n            for k in range(3):\n\n                if j != k:\n\n                    dp[k, i+1] = retmax(dp[k, i+1], dp[j, i] + a_l[k])\n\n\n\n    print((int(np.max(dp[:, n], axis=0))))\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n\n\n", "generated_code": "import sys\n\nimport itertools\n\nfrom operator import itemgetter #sortedの対象を決めたい\n\nfrom fractions import gcd #最大公約数\n\nfrom math import ceil, floor, sqrt, isinf #小数点切り上げ、切り捨て、平方根\n\nfrom copy import deepcopy #参照で影響されないコピー\n\nfrom collections import Counter, deque #要素ごとの出現回数、双方向アクセス可能データ型\n\nimport heapq\n\nimport numpy as np\n\nfrom functools import reduce\n\nsys.setrecursionlimit(200000)\n\n\n\ninput = sys.stdin.readline\n\n# template\n\n\n\ndef main():\n\n    n = int(eval(input()))\n\n    abc = [list(map(int, input().split())) for _ in range(n)]\n\n\n\n    a, b, c = 0, 0, 0\n\n    for x, y, z in abc:\n\n        a, b, c = max(b, c) + x, max(a, c) + y, max(a, b) + z\n\n\n\n    print((max(a, b, c)))\n\n\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n\n\n", "score": 1.0, "codebleu": 0.50509112661777, "crystalbleu": 0.4961548465445824, "codebertscore": 0.94, "codescore": 0.025467993691563606, "surfaceSim": 0.7551080840983122, "abs_surfaceSim_minus_score": 0.2448919159016878}
{"golden_code": "n = int(eval(input()))\n\na = [int(x) for x in input().split()]\n\n\n\nans = list(range(n))\n\n\n\nfor i in range(n):\n\n    ans[a[i]-1] = i+1\n\n    \n\nprint((' '.join(map(str,ans))))", "generated_code": "def main():\n\n\n\n    N = int(eval(input()))\n\n    A = list(int(x) for x in input().split())\n\n    ans = [0] * N\n\n\n\n    for i, a in enumerate(A):\n\n        ans[a-1] = i+1\n\n\n\n    print((' '.join(map(str, ans))))\n\n    \n\nif __name__ == '__main__':\n\n    main()", "score": 1.0, "codebleu": 0.32523524558963185, "crystalbleu": 0.0, "codebertscore": 0.9, "codescore": 0.0317860022187233, "surfaceSim": 0.6556923076923077, "abs_surfaceSim_minus_score": 0.3443076923076923}
{"golden_code": "import numpy as np\n\n\n\nN, D = list(map(int, input().split()))\n\npoints = [list(map(int, input().split())) for _ in range(N)]\n\ncount = 0\n\nfor i in range(N):\n\n    for j in range(N):\n\n        if j == i:\n\n            continue\n\n        dist = np.sqrt(sum([(points[i][d] - points[j][d]) ** 2 for d in range(D)]))\n\n        if dist.is_integer():\n\n            count += 1\n\nprint((count // 2))", "generated_code": "a_1=list(map(int, input().split()))\n\na_2=list(map(int, input().split()))\n\na_3=list(map(int, input().split()))\n\n\n\nc=[a_1,a_2,a_3]\n\n\n\nN=int(eval(input()))\n\n\n\nb=[int(eval(input())) for _ in range(N)]\n\n\n\nfor i in range(3):\n\n    for j in range(3):\n\n        if c[i][j] in b:\n\n            c[i][j]=0\n\n            \n\n            \n\ni=0\n\nif c[0][0]==0 and c[0][1]==0 and c[0][2]==0:\n\n    i+=1\n\nif c[1][0]==0 and c[1][1]==0 and c[1][2]==0:\n\n    i+=1\n\nif c[2][0]==0 and c[2][1]==0 and c[2][2]==0:\n\n    i+=1\n\nif c[0][0]==0 and c[1][0]==0 and c[2][0]==0:\n\n    i+=1\n\nif c[0][1]==0 and c[1][1]==0 and c[2][1]==0:\n\n    i+=1\n\nif c[0][2]==0 and c[1][2]==0 and c[2][2]==0:\n\n    i+=1\n\nif c[0][0]==0 and c[1][1]==0 and c[2][2]==0:\n\n    i+=1\n\nif c[0][2]==0 and c[1][1]==0 and c[2][0]==0:\n\n    i+=1\n\n    \n\nif i>0:\n\n    print(\"Yes\")\n\nelse:\n\n  print(\"No\")", "score": 0.0, "codebleu": 0.28491329278001726, "crystalbleu": 0.2356232983773257, "codebertscore": 0.75, "codescore": 0.8657543063163757, "surfaceSim": 0.5121107920193471, "abs_surfaceSim_minus_score": 0.5121107920193471}
{"golden_code": "import sys\n\nfrom scipy.sparse import csr_matrix\n\nfrom scipy.sparse.csgraph import floyd_warshall\n\n\n\ndef solve(N: int, M: int, a: \"List[int]\", b: \"List[int]\"):\n\n    answer = 0\n\n    for i in range(M): ## iの辺を消す\n\n        matrix = [[0]*(N) for _ in range(N)]\n\n        for j in range(M):\n\n            if j == i:\n\n                continue\n\n            aa = a[j]-1\n\n            bb = b[j]-1\n\n            matrix[aa][bb] = 1\n\n           \n\n        dist_matrix = floyd_warshall(csgraph=csr_matrix(matrix), directed=False)\n\n        \n\n        if dist_matrix[a[i]-1][b[i]-1] == float('inf'):\n\n            answer += 1\n\n            \n\n    print(answer)\n\n    return\n\n\n\n\n\ndef main():\n\n    def iterate_tokens():\n\n        for line in sys.stdin:\n\n            for word in line.split():\n\n                yield word\n\n    tokens = iterate_tokens()\n\n    N = int(next(tokens))  # type: int\n\n    M = int(next(tokens))  # type: int\n\n    a = [int()] * (M)  # type: \"List[int]\"\n\n    b = [int()] * (M)  # type: \"List[int]\"\n\n    for i in range(M):\n\n        a[i] = int(next(tokens))\n\n        b[i] = int(next(tokens))\n\n    solve(N, M, a, b)\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "generated_code": "# vim: fileencoding=utf-8\n\n\n\n\n\ndef main():\n\n    a, b = list(map(int, input().split()))\n\n    c = 0\n\n    for i in range(a, b + 1):\n\n        #     s = str(i)\n\n        #     r = \"\".join(reversed(list(s)))\n\n        #     if s == r:\n\n        #         c += 1\n\n        if (i % 10) == (i // 10000 % 10) and (i // 10 % 10) == (i // 1000 % 10):\n\n            c += 1\n\n    print(c)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "score": 0.0, "codebleu": 0.12631683931265242, "crystalbleu": 0.027636408489880058, "codebertscore": 0.7, "codescore": 0.04584041237831116, "surfaceSim": 0.4776798015982364, "abs_surfaceSim_minus_score": 0.4776798015982364}
{"golden_code": "n = int(eval(input()))\n\nprint((1 if n == 0 else 0))\n", "generated_code": "N = int(eval(input()))\n\n\n\ncount = 0\n\nfor i in range(1, N + 1):\n\n    if len(str(i)) % 2 != 0:\n\n        count += 1\n\nprint(count)", "score": 0.0, "codebleu": 0.4021639816765395, "crystalbleu": 0.0, "codebertscore": 0.81, "codescore": 0.9793227314949036, "surfaceSim": 0.5158730158730158, "abs_surfaceSim_minus_score": 0.5158730158730158}
{"golden_code": "import sys\n\nimport numpy as np\n\n\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\ndef main(N):\n\n    div = np.zeros(N+1, np.int64)\n\n    for n in range(1, N+1):\n\n      for m in range(n, N+1, n):\n\n        div[m] += m\n\n    return div.sum()\n\n\n\nif sys.argv[-1] == 'ONLINE_JUDGE':\n\n    import numba\n\n    from numba.pycc import CC\n\n    i8 = numba.int64\n\n    cc = CC('my_module')\n\n\n\n    def cc_export(f, signature):\n\n        cc.export(f.__name__, signature)(f)\n\n        return numba.njit(f)\n\n\n\n    main = cc_export(main, (i8, ))\n\n    cc.compile()\n\n\n\nfrom my_module import main\n\n\n\nN = int(read())\n\nprint((main(N)))\n", "generated_code": "a, b, c, x, y = list(map(int, input().split()))\n\nans = float('inf')\n\n\n\nfor i in range(100005):\n\n    tmp = i * 2 * c\n\n    tmp += max(0, x-i) * a\n\n    tmp += max(0, y-i) * b\n\n    ans = min(ans, tmp)\n\n\n\nprint(ans)", "score": 0.0, "codebleu": 0.09472305229624298, "crystalbleu": 0.006914232675612483, "codebertscore": 0.65, "codescore": 0.9842012524604797, "surfaceSim": 0.4147426286856572, "abs_surfaceSim_minus_score": 0.4147426286856572}
{"golden_code": "import numpy as np\n\nN = int(eval(input()))\n\nlist_ai = list(map(int,input().split()))\n\nlist1 = [x-(i+1) for i,x in enumerate(list_ai)]\n\na1 = np.array(list1)\n\nmedian1 = int(np.floor(np.median(a1)))\n\nans = np.sum(np.abs(a1-median1))\n\nprint(ans)", "generated_code": "# -*- coding: utf-8 -*-\n\n\n\nimport sys\n\nfrom collections import Counter\n\n\n\ndef input(): return sys.stdin.readline().strip()\n\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\n\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\n\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\n\ndef ceil(x, y=1): return int(-(-x // y))\n\ndef INT(): return int(eval(input()))\n\ndef MAP(): return list(map(int, input().split()))\n\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\n\ndef Yes(): print('Yes')\n\ndef No(): print('No')\n\ndef YES(): print('YES')\n\ndef NO(): print('NO')\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = 10 ** 18\n\nMOD = 10 ** 9 + 7\n\n\n\nN, M, L = MAP()\n\nA = LIST()\n\nB = LIST()\n\n\n\nmn = min(A) + min(B)\n\nfor _ in range(L):\n\n    x, y, c = MAP()\n\n    x -= 1; y -= 1\n\n    mn = min(mn, A[x] + B[y] - c)\n\nprint(mn)\n", "score": 0.0, "codebleu": 0.25872781106264986, "crystalbleu": 0.05911730692041185, "codebertscore": 0.69, "codescore": 0.6406261920928955, "surfaceSim": 0.4219370990455328, "abs_surfaceSim_minus_score": 0.4219370990455328}
{"golden_code": "import numpy as np\n\nN_1=list(map(int, input().split()))\n\nN_2=list(map(int, input().split()))\n\nN_3=list(map(int, input().split()))\n\nN=int(eval(input()))\n\na=[int(eval(input())) for i in range(N)]\n\n\n\nn=np.array([N_1,N_2,N_3])\n\n\n\nfor a_n in a:\n\n    if a_n in n:\n\n        n[n==a_n]=0\n\n    else:\n\n        pass\n\ni=0\n\n    \n\nif np.all(n[0:,0]==0)==True:\n\n    i=+1\n\n    \n\nelif np.all(n[0:,1]==0)==True:\n\n    i+=1\n\n    \n\nelif np.all(n[0:,2]==0)==True:\n\n    i+=1\n\n    \n\nelif np.all(n[0,0:]==0)==True:\n\n    i+=1\n\n    \n\nelif np.all(n[1,0:]==0)==True:\n\n    i+=1\n\n\n\nelif np.all(n[2,0:]==0)==True:\n\n    i+=1\n\n\n\nelif n[0,0]==0 and n[1,1]==0  and n[2,2] ==0:\n\n    i+=1\n\n    \n\nelif n[0,2]==0 and n[1,1]==0 and n[2,0] ==0:\n\n    i+=1\n\n    \n\nif i>0:\n\n    print(\"Yes\")\n\nelse:\n\n    print(\"No\")", "generated_code": "M=998244353\n\nn,m,k=list(map(int,input().split()))\n\na,c=0,1\n\nfor i in range(k+1):\n\n  a+=c*m*pow(m-1,n+~i,M)\n\n  c=c*(n+~i)*pow(i+1,-1,M)%M\n\nprint((a%M))", "score": 0.0, "codebleu": 0.10323028144615892, "crystalbleu": 0.015266637475648718, "codebertscore": 0.71, "codescore": 0.9347630739212036, "surfaceSim": 0.3606428179824561, "abs_surfaceSim_minus_score": 0.3606428179824561}
{"golden_code": "import sys\n\ninput = sys.stdin.readline\n\nsys.setrecursionlimit(10 ** 7)\n\n\n\nN = int(eval(input()))\n\nA = [int(i) for i in input().split()]\n\nB = [int(i) for i in input().split()]\n\nbefore = sum(A)\n\n\n\nfor i in range(N):\n\n    nokori = B[i]\n\n    for j in range(i,i+2):\n\n        if nokori >= A[j]:\n\n            nokori -= A[j]\n\n            A[j] = 0\n\n        else:\n\n            A[j] -= nokori\n\n            nokori = 0\n\nafter = sum(A)\n\n\n\nprint((before - after))", "generated_code": "N, D = list(map(int, input().split()))\n\ncount = 0\n\nfor i in range(N):\n\n    a, b = list(map(int, input().split()))\n\n    if (a*a + b*b) <= D*D:\n\n        count += 1\n\nprint(count)\n", "score": 0.0, "codebleu": 0.14990781940181358, "crystalbleu": 0.04484694925998096, "codebertscore": 0.73, "codescore": 0.2875928282737732, "surfaceSim": 0.5155009920634921, "abs_surfaceSim_minus_score": 0.5155009920634921}
{"golden_code": "N = int(eval(input()))\n\nB =list(map(int,input().split()))\n\nA=[0]*N\n\n\n\nA[0]=B[0]\n\nfor i in range(1,N-1):\n\n    A[i]=min(B[i],B[i-1])\n\nA[-1]=B[-1]\n\nprint((sum(A)))", "generated_code": "import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\n\"\"\"\n\n・偶数番号、奇数番号の中では入れ替え放題\n\n・偶、奇の間：並べてからスワップ。操作2を1回で、正しいものを2つ増やせる\n\n\"\"\"\n\n\n\nN,*A = list(map(int,read().split()))\n\n\n\nx_to_i = {x:i for i,x in enumerate(sorted(A))}\n\nrank = [x_to_i[x] for x in A]\n\n\n\nanswer = sum((x^i) & 1 for i,x in enumerate(rank)) // 2\n\nprint(answer)", "score": 0.0, "codebleu": 0.18508308122095068, "crystalbleu": 0.15273244865968716, "codebertscore": 0.66, "codescore": 0.14570942521095276, "surfaceSim": 0.345497587993568, "abs_surfaceSim_minus_score": 0.345497587993568}
{"golden_code": "from numpy import*\n\na,b=median(t:=loadtxt(open(0),skiprows=1),0)\n\nprint((int((a-b)*~(~len(t)%2))+1))", "generated_code": "n,m=list(map(int,input().split()))\n\nl,r=list(map(int,input().split()))\n\nfor i in range(m-1):\n\n  tl,tr=list(map(int,input().split()))\n\n  if l<tl:\n\n    l=tl\n\n  if tr<r:\n\n    r=tr\n\nprint((max(r-l+1,0)))", "score": 0.0, "codebleu": 0.16997518610421836, "crystalbleu": 0.024935746204259385, "codebertscore": 0.72, "codescore": 0.08984886854887009, "surfaceSim": 0.3957788944723618, "abs_surfaceSim_minus_score": 0.3957788944723618}
{"golden_code": "n, q = [ int( val ) for val in input( ).split( \" \" ) ]\n\nps = [0]*n\n\nt = [0]*n\n\nfor i in range( n ):\n\n\tps[i], t[i] = input( ).split( \" \" )\n\n\n\n\n\noutput = []\n\nqsum = 0\n\nwhile t:\n\n\tpsi = ps.pop( 0 )\n\n\tti = int( t.pop( 0 ) )\n\n\tif ti <= q:\n\n\t\tqsum += ti\t\n\n\t\toutput.append( psi+\" \"+str( qsum ) )\n\n\telse:\n\n\t\tt.append( ti - q )\n\n\t\tps.append( psi )\n\n\t\tqsum += q\n\n\n\nprint(( \"\\n\".join( output ) ))", "generated_code": "s = eval(input())\n\n\n\nstart = 0\n\nfor i in range(len(s)):\n\n    if s[i] == 'A':\n\n        start = i\n\n        break\n\n\n\nend = 0\n\nfor i in reversed(list(range(len(s)))):\n\n    if s[i] == 'Z':\n\n        end = i\n\n        break\n\nprint((end - start + 1))\n", "score": 0.0, "codebleu": 0.11111346146103776, "crystalbleu": 0.02262344005830955, "codebertscore": 0.74, "codescore": 0.06513220816850662, "surfaceSim": 0.5313612313612314, "abs_surfaceSim_minus_score": 0.5313612313612314}
{"golden_code": "a,b,c,x,y=list(map(int,input().split()))\n\n\n\nans=a*x+b*y\n\nfor ci in range(max(x,y)+1):\n\n    sumc = 2*ci*c\n\n    sumc += (x-ci)*a if (x-ci)>0 else 0\n\n    sumc += (y-ci)*b if (y-ci)>0 else 0\n\n    ans=min(ans,sumc)\n\n\n\nprint(ans)", "generated_code": "def solve():\n\n  N, K, C = list(map(int, input().split()))\n\n  workable = [i for i, s in enumerate(eval(input())) if s==\"o\"]\n\n  if len(workable) == K:\n\n    return workable\n\n    \n\n  prev = workable[-1]\n\n  latest = {prev}\n\n  i = len(workable)-1\n\n  while i > 0:\n\n    i -= 1\n\n    if prev - workable[i] > C:\n\n      latest.add(workable[i])\n\n      prev = workable[i]\n\n      if len(latest) > K:\n\n        return []\n\n  must = []\n\n  i = -1\n\n  prev = -C-1\n\n  while i < len(workable)-1:\n\n    i += 1\n\n    if workable[i] - prev > C:\n\n      if workable[i] in latest:\n\n        must.append(workable[i])\n\n      prev = workable[i]\n\n  return must\n\n\n\nfor i in solve():\n\n  print((i+1))", "score": 0.0, "codebleu": 0.1747182455378194, "crystalbleu": 0.10492178549470707, "codebertscore": 0.69, "codescore": 0.987044632434845, "surfaceSim": 0.461038961038961, "abs_surfaceSim_minus_score": 0.461038961038961}
{"golden_code": "n=int(eval(input()))\n\na=[list(map(int,input().split()))for _ in range(n)]\n\ndef f():\n\n for i in range(n-1):\n\n  d=a[i][:];d[3],d[4]=d[4],d[3]\n\n  for j in range(i+1,n):\n\n   e=a[j][:];e[3],e[4]=e[4],e[3]\n\n   for p in([0,1,2,3,4,5],[1,5,2,0,4,3],[2,1,5,3,0,4],[3,0,2,5,4,1],[4,1,0,3,5,2],[5,1,4,3,2,0]):\n\n    f=[d[k]for k in p]\n\n    if f[0]==e[0]and f[5]==e[5]:\n\n     f=f[1:5]*2\n\n     for k in range(4):\n\n      if f[k:k+4]==e[1:5]:return'No'\n\n return'Yes'\n\nprint((f()))\n", "generated_code": "import copy\n\nn,k = list(map(int,input().split()))\n\nai = [int(i) for i in input().split()]\n\n\n\n#old_ai = ai\n\ncnt = 0\n\nold_tmp = sum(ai)\n\n\n\nwhile 1 == 1:\n\n    #old_ai = copy.deepcopy(ai)\n\n    li = [0]*(n+1)\n\n    for i in range(n):\n\n        li[max(0,i-ai[i])] += 1\n\n        li[min(n,i+1+ai[i])] -= 1\n\n        #print(li)\n\n    #print(li)\n\n    tmp = 0\n\n    for i in range(n):\n\n        if i == 0:\n\n            ai[i] = li[i]\n\n            tmp += ai[i]\n\n        else:\n\n            ai[i] = li[i] + ai[i-1]\n\n            tmp += ai[i]\n\n    #print(rui)\n\n    if old_tmp == tmp:\n\n        print((*ai))\n\n        exit()\n\n        break\n\n    cnt += 1\n\n    if cnt == k:\n\n        print((*ai))\n\n        exit()\n\n    old_tmp = tmp", "score": 0.0, "codebleu": 0.11258124946000861, "crystalbleu": 0.10993512274974052, "codebertscore": 0.73, "codescore": 0.8853278756141663, "surfaceSim": 0.6091982091982091, "abs_surfaceSim_minus_score": 0.6091982091982091}
{"golden_code": "import sys\n\ninput = sys.stdin.readline\n\nsys.setrecursionlimit(10 ** 7)\n\n\n\n\"\"\"\n\n奇数番目集合、偶数番目集合の中で自由にできるのが操作2．\n\n操作1で集合間のやりとりをする\n\n\"\"\"\n\n\n\nimport numpy as np\n\n\n\nN = int(eval(input()))\n\nA = np.fromstring(sys.stdin.read(),dtype=np.int64,sep='\\n')\n\n\n\nB = np.sort(A)\n\n\n\nanswer = len(np.setdiff1d(A[::2],B[::2]))\n\nprint(answer)", "generated_code": "import math\n\n\n\nn, d = list(map(int, input().split()))\n\n\n\nx = [list(map(int, input().split())) for i in range(n)]\n\n\n\ncnt = 0\n\n\n\nfor i in range(n):\n\n    for j in range(i+1, n):\n\n        dist = 0\n\n        for k in range(d):\n\n            dist += (x[i][k] - x[j][k]) ** 2\n\n        if math.sqrt(dist).is_integer():\n\n            cnt += 1\n\n\n\nprint(cnt)", "score": 0.0, "codebleu": 0.19166824943227834, "crystalbleu": 0.0, "codebertscore": 0.64, "codescore": 0.9800229072570801, "surfaceSim": 0.4544186046511628, "abs_surfaceSim_minus_score": 0.4544186046511628}
{"golden_code": "from collections import defaultdict\n\nimport numpy as np\n\ndef main():\n\n    s = eval(input())\n\n    n = len(s)\n\n    d = np.zeros(2019,np.int64)\n\n    ans = 0\n\n    num = 0\n\n    pow10 = 1\n\n    d[0] = 1\n\n    for i in reversed(list(range(n))):\n\n        pow10 = pow10 * 10 % 2019\n\n        num += int(s[i]) * pow10\n\n        #print(num, num % 2019, i)\n\n        mod = num % 2019\n\n        ans += d[mod]\n\n        d[mod] += 1\n\n    print(ans)\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "generated_code": "n, q = [ int( val ) for val in input( ).split( \" \" ) ]\n\nps = [0]*n\n\nt = [0]*n\n\nfor i in range( n ):\n\n    ps[i], t[i] = input( ).split( \" \" )\n\n \n\n \n\noutput = []\n\nqsum = 0\n\nwhile t:\n\n    psi = ps.pop( 0 )\n\n    ti = int( t.pop( 0 ) )\n\n    if ti <= q:\n\n        qsum += ti\n\n        output.append( \"\".join( ( psi, \" \", str( qsum ) ) ) )\n\n    else:\n\n        t.append( ti - q )\n\n        ps.append( psi )\n\n        qsum += q\n\n \n\nprint(( \"\\n\".join( output ) ))", "score": 0.0, "codebleu": 0.16965756173783014, "crystalbleu": 0.04651513290106976, "codebertscore": 0.72, "codescore": 0.9936090707778931, "surfaceSim": 0.5093949893390192, "abs_surfaceSim_minus_score": 0.5093949893390192}
{"golden_code": "import numpy as np\n\n\n\nn = int(eval(input()))\n\nv = np.array(list(map(int, input().split())))\n\nc = np.array(list(map(int, input().split())))\n\np = v-c\n\nans = 0\n\nfor i in p:\n\n    if i>0:\n\n        ans+=i\n\n\n\nprint(ans)\n", "generated_code": "import statistics\n\nn = int(eval(input()))\n\nal = list(map(int,input().split()))\n\n\n\nfor i in range(n):\n\n    al[i] -= i + 1\n\n\n\nmedian = statistics.median(al)\n\n\n\nans = 0\n\nfor a in al:\n\n    ans += abs(median - a)\n\n\n\nprint((int(ans)))\n", "score": 0.0, "codebleu": 0.36198986238974845, "crystalbleu": 0.23404660783386844, "codebertscore": 0.83, "codescore": 0.216299369931221, "surfaceSim": 0.6713453940528176, "abs_surfaceSim_minus_score": 0.6713453940528176}
{"golden_code": "# -*- coding: utf-8 -*-\n\n\n\nimport sys\n\nfrom collections import Counter\n\n\n\ndef input(): return sys.stdin.readline().strip()\n\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\n\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\n\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\n\ndef ceil(x, y=1): return int(-(-x // y))\n\ndef INT(): return int(eval(input()))\n\ndef MAP(): return list(map(int, input().split()))\n\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\n\ndef Yes(): print('Yes')\n\ndef No(): print('No')\n\ndef YES(): print('YES')\n\ndef NO(): print('NO')\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = 10 ** 18\n\nMOD = 10 ** 9 + 7\n\n\n\ndef fft(A, B):\n\n    \"\"\" \n\n    高速フーリエ変換(FFT)\n\n        A：出現回数をカウントしたリスト\n\n        B：出現回数をカウントしたリスト\n\n    \"\"\"\n\n    import numpy as np\n\n    from numpy.fft import rfft, irfft\n\n\n\n    # 出現数カウント\n\n    MAXA = max(A)\n\n    MAXB = max(B)\n\n    C1 = [0] * (MAXA+1)\n\n    C2 = [0] * (MAXB+1)\n\n    for a in A:\n\n        C1[a] += 1\n\n    for b in B:\n\n        C2[b] += 1\n\n    # max(A)+max(B)より大きい2冪\n\n    L = 1\n\n    k = 0\n\n    while L <= MAXA + MAXB:\n\n        k += 1\n\n        L = 2**k\n\n    # FFT\n\n    res = irfft(rfft(C1, L) * rfft(C2, L), L)\n\n    # 四捨五入して整数に\n\n    res = np.rint(res).astype(np.int64)\n\n    return res\n\n\n\nN, M, L = MAP()\n\nA = LIST()\n\nB = LIST()\n\n\n\nres = list(fft(A, B))\n\n\n\nmn = INF\n\nfor i, a in enumerate(res):\n\n    if a != 0:\n\n        mn = i\n\n        break\n\n\n\nfor _ in range(L):\n\n    x, y, c = MAP()\n\n    x -= 1; y -= 1\n\n    mn = min(mn, A[x] + B[y] - c)\n\nprint(mn)\n", "generated_code": "from collections import Counter\n\nimport numpy as np\n\n\n\n\n\ndef part(pts, s, t, num, ans):\n\n    a = np.linspace(s, t, num, endpoint=False)\n\n    for i, v in list(Counter(np.argmax(np.dot(pts, [np.sin(a), np.cos(a)]), axis=0)).items()):\n\n        ans[i] += v\n\n\n\n\n\ndef solve(n, pts):\n\n    ans = np.zeros(n)\n\n    part(pts, 0, np.pi, 1e5, ans)\n\n    part(pts, np.pi, 2 * np.pi, 1e5, ans)\n\n    return ans / 2e5\n\n\n\n\n\nn = int(eval(input()))\n\nprint(('\\n'.join(map(str, solve(n, [list(map(int, input().split())) for _ in range(n)])))))\n", "score": 0.0, "codebleu": 0.13983744699025308, "crystalbleu": 0.03628078609531949, "codebertscore": 0.7, "codescore": 0.13440091907978058, "surfaceSim": 0.5459438935048692, "abs_surfaceSim_minus_score": 0.5459438935048692}
{"golden_code": "N,M,K = list(map(int,input().split()))\n\n\n\nfor i in range(N+1):\n\n    for j in range(M+1):\n\n        t = i*M + j*N - i*j*2\n\n        if t==K:\n\n            print('Yes')\n\n            exit()\n\nprint('No')", "generated_code": "import re\n\n\n\ns = eval(input())\n\n\n\nif re.fullmatch(r\"(dream|dreamer|erase|eraser)+\", s):\n\n    print(\"YES\")\n\nelse:\n\n    print(\"NO\")", "score": 0.0, "codebleu": 0.10273817325366856, "crystalbleu": 0.0, "codebertscore": 0.68, "codescore": 0.9520145654678345, "surfaceSim": 0.5178571428571428, "abs_surfaceSim_minus_score": 0.5178571428571428}
{"golden_code": "from math import sqrt\n\nfrom bisect import bisect_left\n\ndef circle_center(x1, y1, x2, y2):\n\n    xd = x2 - x1; yd = y2 - y1\n\n    d = xd**2 + yd**2\n\n    k = sqrt((4.0 - d) / d) / 2.0\n\n    xc = (x1 + x2) / 2.0\n\n    yc = (y1 + y2) / 2.0\n\n    return [[xc - k*yd, yc + k*xd], [xc + k*yd, yc - k*xd]]\n\nwhile 1:\n\n    n = int(input())\n\n    if n==0: break\n\n    p = [list(map(float, input().split())) for i in range(n)]\n\n    p.sort()\n\n    prev = 0\n\n    ans = 1\n\n    for i in range(n):\n\n        bx, by = p[i]\n\n        while bx - p[prev][0] >= 2.0: prev += 1\n\n        for j in range(i+1, n):\n\n            cx, cy = p[j]\n\n            if cx - bx >= 2.0: break\n\n            if (bx - cx)**2 + (by - cy)**2 <= 4.0:\n\n                for ex, ey in circle_center(bx, by, cx, cy):\n\n                    count = 2\n\n                    for k in range(prev, n):\n\n                        if k==i or k==j: continue\n\n                        dx, dy = p[k]\n\n                        if dx - bx >= 2.0: break\n\n                        if (ex - dx)**2 + (ey - dy)**2 <= 1.0:\n\n                            count += 1\n\n                    ans = max(ans, count)\n\n    print(ans)", "generated_code": "import sys\n\nsys.setrecursionlimit(10000000)\n\nimport heapq\n\nimport math\n\n\n\ndef main():\n\n    N, K = list(map(int, input().split()))\n\n    A = [int(c) for c in input().split()]\n\n    F = [int(c) for c in input().split()]\n\n    \n\n    A.sort()\n\n    F.sort(reverse=True)\n\n\n\n    num = 0\n\n    sum_ = []\n\n    for i in range(len(A)):\n\n        sum_.append(A[i] * F[i])\n\n    left = 0\n\n    right = 10 ** 12\n\n    while(num < 50):\n\n        number = 0\n\n        mid = (left + right) // 2\n\n        # print(mid)\n\n        for i in range(len(A)):\n\n            if sum_[i] <= mid:\n\n                continue\n\n            else:\n\n                number += math.ceil((sum_[i] - mid) / F[i])\n\n            # print(number)\n\n        if number > K:\n\n            # 最大値をmidより小さくできない -> 最大値はもっとでかい\n\n            left = mid + 1\n\n        else:\n\n            right = mid\n\n        num += 1\n\n    print(mid)\n\n                \n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 0.0, "codebleu": 0.18958119848590416, "crystalbleu": 0.06488486445328163, "codebertscore": 0.73, "codescore": 0.8327512145042419, "surfaceSim": 0.6382842509603073, "abs_surfaceSim_minus_score": 0.6382842509603073}
{"golden_code": "import numpy as np\n\nN = int(eval(input()))\n\nVlist = np.array(list(map(int,input().split())))\n\nClist = np.array(list(map(int,input().split())))\n\n\n\nDlist = Vlist-Clist\n\n\n\nsum_ = 0\n\nfor d in Dlist:\n\n    if d >= 0:\n\n        sum_ += d\n\n\n\nprint(sum_)\n", "generated_code": "from collections import deque, Counter\n\n\n\ndef main():\n\n    with open(0) as f:\n\n        H, W = list(map(int, f.readline().split()))\n\n        maze = [list(line) for line in f.readlines()]\n\n\n\n    rank = [[None]*W for _ in range(H)]\n\n    rank[0][0] = 0\n\n    #bfs\n\n    reserved = deque([(0,0)])\n\n    while len(reserved) > 0:\n\n        x, y = reserved.popleft()\n\n        for u,v in [(s,t) for s,t in [(x-1,y), (x+1,y), (x,y-1), (x,y+1)] if 0<=s<H and 0<=t<W]:\n\n            if rank[u][v] is not None:\n\n                continue\n\n            if maze[u][v] == '.':\n\n                rank[u][v] = rank[x][y] + 1\n\n                reserved.append((u,v))\n\n\n\n    if rank[H-1][W-1] is None:\n\n        print((-1))\n\n    else:\n\n        counter = Counter()\n\n        for line in maze:\n\n            counter.update(line)\n\n        print((counter['.'] - rank[H-1][W-1]-1))\n\n\n\nmain()", "score": 0.0, "codebleu": 0.1913137835428861, "crystalbleu": 0.039541836085883665, "codebertscore": 0.67, "codescore": 0.9633455872535706, "surfaceSim": 0.41204182778715753, "abs_surfaceSim_minus_score": 0.41204182778715753}
{"golden_code": "import numpy as np\n\nk,n = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\nb = np.zeros(n)\n\nfor i in range(0,n-1):\n\n  b[i] = a[i+1] -a[i]\n\n  \n\nb[n-1] = k - a[n-1] + a[0]\n\nans = k - max(b)\n\nprint((int(ans)))", "generated_code": "N,K=list(map(int,input().split()))\n\n\n\ncon = 0\n\nans = list(int() for _ in range(10001))\n\npre = 0\n\n\n\n\n\nfor _ in range(K):\n\n\n\n    D = int(eval(input()))\n\n    arr = list(map(int,input().split()))\n\n\n\n    for j in range(D):\n\n\n\n        ans[pre+j]=arr[j]\n\n\n\n    pre += D\n\n\n\n        \n\nfin = (N+1) - len(set(ans))\n\n\n\nprint(fin)", "score": 0.0, "codebleu": 0.23541807261257944, "crystalbleu": 0.14219079743977997, "codebertscore": 0.8, "codescore": 0.8917890787124634, "surfaceSim": 0.631741024485504, "abs_surfaceSim_minus_score": 0.631741024485504}
{"golden_code": "def main():\n\n\tn, ma, mb, *L = list(map(int, open(0).read().split()))\n\n\tM = 1<<30\n\n\tdp = [[M] * 420 for _ in range(420)]\n\n\tdp[0][0] = 0\n\n\tfor a, b, c in zip(*[iter(L)] * 3):\n\n\t\tfor i in range(400, -1, -1):\n\n\t\t\tfor j in range(400, -1, -1):\n\n\t\t\t\tt = dp[i][j] + c\n\n\t\t\t\tif dp[i + a][j + b] > t:\n\n\t\t\t\t\tdp[i + a][j + b] = t\n\n\tans = M\n\n\t_ma, _mb = ma, mb\n\n\twhile _ma < 410 > _mb:\n\n\t\tans = min(ans, dp[_ma][_mb])\n\n\t\t_ma += ma\n\n\t\t_mb += mb\n\n\tprint((ans if ans < M else -1))\n\n\n\nif __name__==\"__main__\":\n\n\tmain()", "generated_code": "import sys\n\nsys.setrecursionlimit(10000000)\n\nimport heapq\n\nimport math\n\n\n\ndef main():\n\n    N, K = list(map(int, input().split()))\n\n    A = [int(c) for c in input().split()]\n\n    F = [int(c) for c in input().split()]\n\n    \n\n    A.sort()\n\n    F.sort(reverse=True)\n\n\n\n    num = 0\n\n    sum_ = []\n\n    for i in range(len(A)):\n\n        sum_.append(A[i] * F[i])\n\n    left = 0\n\n    right = 10 ** 12\n\n    while(num < 50):\n\n        number = 0\n\n        mid = (left + right) // 2\n\n        # print(mid)\n\n        for i in range(len(A)):\n\n            if sum_[i] <= mid:\n\n                continue\n\n            else:\n\n                number += math.ceil((sum_[i] - mid) / F[i])\n\n            # print(number)\n\n        if number > K:\n\n            # 最大値をmidより小さくできない -> 最大値はもっとでかい\n\n            left = mid + 1\n\n        else:\n\n            right = mid\n\n        num += 1\n\n    print(mid)\n\n                \n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 0.0, "codebleu": 0.14452251515144646, "crystalbleu": 0.11095885845266111, "codebertscore": 0.72, "codescore": 0.021807393059134483, "surfaceSim": 0.6288864786695589, "abs_surfaceSim_minus_score": 0.6288864786695589}
{"golden_code": "import sys\n\nimport numpy as np \n\n\n\nn, l = list(map(int, sys.stdin.readline().split()))\n\n\n\ndef main():\n\n    f = l + np.arange(1, n+1) - 1\n\n    s = f.sum()\n\n    a = np.absolute(f)\n\n    mi = np.amin(a)\n\n    i = np.argwhere(a == mi)[0, 0]\n\n    return s - f[i]\n\n\n\nif __name__ == '__main__':\n\n    ans = main()\n\n    print(ans)", "generated_code": "N,K=list(map(int,input().split()))\n\n\n\ncon = 0\n\nans = list(int() for _ in range(10001))\n\npre = 0\n\n\n\n\n\nfor _ in range(K):\n\n\n\n    D = int(eval(input()))\n\n    arr = list(map(int,input().split()))\n\n\n\n    for j in range(D):\n\n\n\n        ans[pre+j]=arr[j]\n\n\n\n    pre += D\n\n\n\n        \n\nfin = (N+1) - len(set(ans))\n\n\n\nprint(fin)", "score": 0.0, "codebleu": 0.13912029540349977, "crystalbleu": 0.08866717260753261, "codebertscore": 0.73, "codescore": 0.0715324655175209, "surfaceSim": 0.48467432950191575, "abs_surfaceSim_minus_score": 0.48467432950191575}
{"golden_code": "import sys\n\ninput = sys.stdin.readline\n\n\n\nn, m = list(map(int, input().split()))\n\nbroken = set([int(eval(input())) for _ in range(m)]) # ここが'list'だとPypyでも通らない\n\n\n\ndef ptn_num(x): # 'x'stepまでのパターン数\n\n    dp = [0] * (x+1) # DP枠_including step'0'\n\n    if 1 in broken: # in case, step'1' broken \n\n        dp[:2] = 1, 0\n\n    else:\n\n        dp[:2] = 1, 1 # Usually\n\n\n\n    for i in range(2, x+1):\n\n        if i not in broken: # 階段が壊れてない場合...\n\n            dp[i] = (dp[i-1] + dp[i-2]) % (10**9+7) # -1段目と-2段目の合計\n\n    print((dp[-1]))\n\n\n\nptn_num(n)\n", "generated_code": "import sys\n\nsys.setrecursionlimit(10 ** 6)\n\n\n\n\n\ndef calc_dist(x, y):\n\n    dist = 0\n\n    for xi, yi in zip(x, y):\n\n        dist += (yi - xi) ** 2\n\n    return dist ** (1/2)\n\n\n\n\n\ndef main():\n\n    N, D = list(map(int, sys.stdin.readline().rstrip().split()))\n\n    X = [list(map(int, sys.stdin.readline().rstrip().split())) for _ in range(N)]\n\n\n\n    ans = 0\n\n    for i in range(N):\n\n        for j in range(i+1, N):\n\n            dist = calc_dist(X[i], X[j])\n\n            if dist.is_integer():\n\n                ans += 1\n\n    \n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()", "score": 0.0, "codebleu": 0.178058888967607, "crystalbleu": 0.13524320743354543, "codebertscore": 0.71, "codescore": 0.023433197289705276, "surfaceSim": 0.5804068229499224, "abs_surfaceSim_minus_score": 0.5804068229499224}
{"golden_code": "import sys\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\nreadlines = sys.stdin.readlines\n\n\n\ndef main():\n\n    S = readline().strip()\n\n    T = readline().strip()\n\n\n\n    idx_in_S = []\n\n    last_idx = 0\n\n    for t in T:\n\n        t_idx = S.find(t, last_idx) + 1\n\n        if t_idx:\n\n            idx_in_S.append(t_idx)\n\n            last_idx = t_idx\n\n        else:\n\n            t_idx = S.find(t, 0, last_idx) + 1\n\n            if not t_idx:\n\n                print((-1))\n\n                exit()\n\n            else:\n\n                idx_in_S.append(t_idx)\n\n                last_idx = t_idx\n\n\n\n    \n\n    rep = 0\n\n    for i in range(len(T) - 1):\n\n        if idx_in_S[i] < idx_in_S[i+1]:\n\n            continue\n\n        else:\n\n            rep += 1\n\n\n\n    ans = len(S) * rep + idx_in_S[-1]\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "generated_code": "from statistics import*\n\n(n,),*t=[list(map(int,t.split()))for t in open(0)]\n\na,b=list(map(median,list(zip(*t))))\n\nprint((int((b-a)*(2-n%2))+1))", "score": 0.0, "codebleu": 0.0837133942676428, "crystalbleu": 0.004974944743139223, "codebertscore": 0.62, "codescore": 0.02777702733874321, "surfaceSim": 0.4379123779361309, "abs_surfaceSim_minus_score": 0.4379123779361309}
{"golden_code": "N, D = list(map(int, input().split()))\n\ncount = 0\n\nfor i in range(N):\n\n    a, b = list(map(int, input().split()))\n\n    if (a**2 + b**2) <= D**2:\n\n        count += 1\n\nprint(count)\n", "generated_code": "M = 1000000007\n\nn=int(eval(input()))\n\nf = 1\n\nfor i in range(1, n + 1):  \n\n    f = (f * i) % M \n\nprint(f)", "score": 0.0, "codebleu": 0.2038250656423953, "crystalbleu": 0.0, "codebertscore": 0.78, "codescore": 0.1764395833015442, "surfaceSim": 0.5012569832402235, "abs_surfaceSim_minus_score": 0.5012569832402235}
{"golden_code": "import sys\n\ninput = sys.stdin.readline\n\n \n\ns = input().rstrip()\n\nk = int(eval(input()))\n\n    \n\ndef check_count(s):\n\n    cnt_list = [1]\n\n    cnt = 1\n\n    for i in range(1, len(s)):\n\n        if s[i-1] == s[i]:\n\n            cnt_list[-1] += 1\n\n        else:\n\n            cnt_list.append(1)\n\n    return cnt_list\n\n\n\ndef calc_ans(cnt_list, k):\n\n    _ans = 0\n\n    for c in cnt_list:\n\n        _ans += c//2\n\n    return(_ans * k)\n\n\n\nif len(s)==1:\n\n    ans = k//2\n\nelse:\n\n    cnt_list = check_count(s)\n\n    if len(cnt_list)==1:\n\n        ans = (len(s)*k)//2\n\n    else:\n\n        ans = calc_ans(cnt_list, k)\n\n        if s[0]==s[-1]:\n\n            if cnt_list[0]%2==1 and cnt_list[-1]%2==1:\n\n                ans += k - 1\n\n\n\nprint(ans)", "generated_code": "N=int(eval(input()))\n\n\n\nA=[[-1]*N for _ in range(N)]\n\nfor i in range(N):\n\n  a=int(eval(input()))\n\n  for j in range(a):\n\n    x,y=list(map(int, input().split()))\n\n    A[i][x-1]=y\n\n#正直者が正直者に不親切と言われていない\n\n#→正直ものが不親切を正直者と言っていないか\n\nans=0\n\nfor i in range(2**N):\n\n  ok=True\n\n  for j in range(N):\n\n    if (i>>j&1)==1:\n\n      for k in range(N):\n\n        if A[j][k]!=-1 and (i>>k&1)!=A[j][k]:\n\n          ok=False\n\n  if ok:\n\n    ans=max(ans, bin(i).count(\"1\"))\n\n  \n\nprint(ans)", "score": 0.0, "codebleu": 0.16092400682674296, "crystalbleu": 0.09387228917298435, "codebertscore": 0.72, "codescore": 0.9937554597854614, "surfaceSim": 0.5371513249651325, "abs_surfaceSim_minus_score": 0.5371513249651325}
{"golden_code": "from sys import stdin,stdout\n\n\n\nif __name__==\"__main__\":\n\n    n=int(stdin.readline())\n\n\n\n    a=[int(x) for x in stdin.readline().split()]\n\n    b=[int(x) for x in stdin.readline().split()]\n\n\n\n    cnt=0\n\n\n\n    for i in range(n):\n\n        if(a[i]>=b[i]):\n\n            cnt+=b[i]\n\n        else:\n\n            cnt+=a[i]\n\n            d=b[i]-a[i]\n\n            cnt+=min(a[i+1],d)\n\n            if(d>a[i+1]):\n\n                a[i+1]=0\n\n            else: a[i+1]-=d\n\n            \n\n    stdout.write(str(cnt)+\"\\n\")\n", "generated_code": "from math import floor, sqrt\n\nfrom collections import Counter\n\n\n\nMOD = 10 ** 9 + 7\n\n\n\n# xを素因数分解する\n\ndef getPrimeFactor(x):\n\n    ans = []\n\n    for d in range(2, floor(sqrt(x)) + 1):\n\n        while x % d == 0:\n\n            ans.append(d)\n\n            x //= d\n\n    if x != 1:\n\n        ans.append(x)\n\n    return ans\n\n\n\ndef comb(n, k):\n\n    k = min(k, n - k)\n\n    ans = 1\n\n    for i in range(n, n - k, -1):\n\n        ans *= i\n\n    for i in range(1, k + 1):\n\n        ans //= i \n\n    return ans\n\n\n\n\n\nN, M = list(map(int, input().split()))\n\n\n\nPFs = getPrimeFactor(M)\n\ncnt = Counter(PFs)\n\n\n\nans = 1\n\nfor num in list(cnt.values()):\n\n    ans *= comb(N + num - 1, num)\n\nprint((ans % MOD))\n", "score": 0.0, "codebleu": 0.17696670002509346, "crystalbleu": 0.06175513153865766, "codebertscore": 0.72, "codescore": 0.9032707810401917, "surfaceSim": 0.4928479038271323, "abs_surfaceSim_minus_score": 0.4928479038271323}
{"golden_code": "import fractions\n\nimport sys\n\ninput = sys.stdin.readline\n\n\n\nN,M=list(map(int,input().split()))\n\na = list(map(int, input().split()))\n\n\n\n\n\nlcm = a[0]\n\nfor i in range(1, N):\n\n    g= fractions.gcd(lcm, a[i])\n\n    lcm = lcm * a[i] // g\n\n\n\n\n\ng=a[0]\n\nfor i in range(N):\n\n    g=fractions.gcd(g,a[i])\n\n\n\nfor i in range(N):\n\n    if (a[i]//g)%2==0:\n\n        lcm=0\n\n        break    \n\n    \n\n    \n\nans=0\n\nl=lcm//2\n\nif l:\n\n    ans=(M//l)-(M//(l+l))\n\nprint(ans)\n\n\n", "generated_code": "from statistics import*\n\n(n,),*t=[list(map(int,t.split()))for t in open(0)]\n\na,b=list(map(median,list(zip(*t))))\n\nprint((int((b-a)*(2-n%2))+1))", "score": 0.0, "codebleu": 0.0795821062523984, "crystalbleu": 0.03968758805842503, "codebertscore": 0.71, "codescore": 0.0488048754632473, "surfaceSim": 0.4896705322171876, "abs_surfaceSim_minus_score": 0.4896705322171876}
{"golden_code": "#                         author:  kagemeka \n\n#                         created: 2019-11-08 14:51:29(JST)\n\n## internal modules\n\nimport sys\n\n# import collections\n\n# import math\n\n# import string\n\n# import bisect\n\n# import re\n\n# import itertools\n\nimport statistics\n\n# import functools\n\n# import operator\n\n## external modules\n\n# import scipy.special   # if use comb function on AtCoder, \n\n# import scipy.misc      # select scipy.misc.comb (old version) \n\n\n\ndef main():\n\n    n, *a = (int(x) for x in sys.stdin.read().split())\n\n    \n\n    for i in range(n):\n\n        a[i] -= (i + 1)\n\n\n\n    if n % 2 != 0:\n\n        b = statistics.median(a)\n\n    else:\n\n        if a.count(statistics.median_high(a)) >= a.count(statistics.median_low(a)):\n\n            b = statistics.median_high(a)\n\n        else:\n\n            b = statistics.median_low(a)\n\n    \n\n    ans = sum([abs(a[i] - b) for i in range(n)])\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    # execute only if run as a script\n\n    main()\n\n\n\n\n", "generated_code": "n=int(eval(input()))\n\nl=list(map(int,input().split()))\n\na=0\n\nfor i in range(n-2):\n\n  p,q,r=l[i:i+3]\n\n  if p<q<r or r<q<p: a+=1\n\nprint(a)", "score": 0.0, "codebleu": 0.12405324210905116, "crystalbleu": 0.04782764768634182, "codebertscore": 0.64, "codescore": 0.3436521887779236, "surfaceSim": 0.604660587639311, "abs_surfaceSim_minus_score": 0.604660587639311}
{"golden_code": "l,r=list(map(int,input().split()))\n\ns=list(range(l,r+1))[:2019]\n\nprint((min(i*j%2019for i in s for j in s if i<j)))", "generated_code": "def main():\n\n\n\n    N = int(eval(input()))\n\n    A = list(int(x) for x in input().split())\n\n    ans = [0] * N\n\n\n\n    for i, a in enumerate(A):\n\n        ans[a-1] = i+1\n\n\n\n    print((' '.join(map(str, ans))))\n\n    \n\nif __name__ == '__main__':\n\n    main()", "score": 0.0, "codebleu": 0.1971175779143602, "crystalbleu": 0.0, "codebertscore": 0.78, "codescore": 0.01833982951939106, "surfaceSim": 0.5515714285714286, "abs_surfaceSim_minus_score": 0.5515714285714286}
{"golden_code": "a, b, c, x, y = list(map(int, input().split()))\n\nans = float('inf')\n\n\n\nfor i in range(200005):\n\n    tmp = i * 2 * c\n\n    tmp += max(0, x-i) * a\n\n    tmp += max(0, y-i) * b\n\n    ans = min(ans, tmp)\n\n\n\nprint(ans)", "generated_code": "from collections import defaultdict\n\n\n\ndef main():\n\n    s = eval(input())\n\n    n = len(s)\n\n    ans = 0\n\n    num = 0\n\n    pow10 = 1\n\n    d = defaultdict(int)\n\n    d[0] = 1\n\n    for i in reversed(list(range(n))):\n\n        # pow10を10 ** (n-1-i)にしてるだけでTLEしていた\n\n        pow10 = pow10 * 10 % 2019\n\n        num += int(s[i]) * pow10\n\n        mod = num % 2019\n\n        ans += d[mod]\n\n        d[mod] += 1\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "score": 0.0, "codebleu": 0.1549692716592049, "crystalbleu": 0.0, "codebertscore": 0.72, "codescore": 0.018344400450587273, "surfaceSim": 0.5324175824175824, "abs_surfaceSim_minus_score": 0.5324175824175824}
{"golden_code": "import sys\n\ninput = sys.stdin.readline\n\nsys.setrecursionlimit(10**7)\n\nINF = 10**10\n\nMOD = 10**9 + 7\n\nX = int(eval(input()))\n\nfor i in range(1000):\n\n    for j in range(-1000,1000):\n\n        #print (i**5 - j**5)\n\n        if i**5 - j**5 == X:\n\n            print((i,j))\n\n            exit()\n\n   ", "generated_code": "import sys\n\n\n\nn, l = list(map(int, sys.stdin.readline().split()))\n\n\n\ndef main():\n\n    s = (l - 1) * n + (1 + n) * n // 2\n\n    res = []\n\n    for i in range(1, n+1):\n\n        f = l + i - 1\n\n        res.append((abs(f), s - f))\n\n    \n\n    res.sort()\n\n    return res[0][1]\n\n\n\nif __name__=='__main__':\n\n    ans = main()\n\n    print(ans)", "score": 0.0, "codebleu": 0.18666312753055878, "crystalbleu": 0.0, "codebertscore": 0.75, "codescore": 0.16132605075836182, "surfaceSim": 0.5719858156028369, "abs_surfaceSim_minus_score": 0.5719858156028369}
{"golden_code": "n = int(eval(input()))\n\nl = list(map(int, input().split()))\n\nprint((sum(l[i]<l[i+1]<l[i+2] or l[i]>l[i+1]>l[i+2] for i in range(n-2))))", "generated_code": "N = int(eval(input()))\n\nabc = []\n\nfor i in range(N):\n\n    data = list(map(int, input().split()))\n\n    abc.append(data)\n\n\n\ndp = [[0 for i in range(3)] for j in range(N)]\n\ndp[0][0] = abc[0][0]\n\ndp[0][1] = abc[0][1]\n\ndp[0][2] = abc[0][2]\n\n\n\nfor i in range(N-1):\n\n    for j in range(3):\n\n        if j == 0:\n\n            dp[i+1][1] = max(dp[i][0] + abc[i+1][1], dp[i+1][1])\n\n            dp[i+1][2] = max(dp[i][0] + abc[i+1][2], dp[i+1][2])\n\n        if j == 1:\n\n            dp[i+1][0] = max(dp[i][1] + abc[i+1][0], dp[i+1][0])\n\n            dp[i+1][2] = max(dp[i][1] + abc[i+1][2], dp[i+1][2])\n\n        if j == 2:\n\n            dp[i+1][1] = max(dp[i][2] + abc[i+1][1], dp[i+1][1])\n\n            dp[i+1][0] = max(dp[i][2] + abc[i+1][0], dp[i+1][0])\n\n\n\nprint((max(dp[N-1])))", "score": 0.0, "codebleu": 0.3116342459712752, "crystalbleu": 0.14824292239361614, "codebertscore": 0.75, "codescore": 0.48667457699775696, "surfaceSim": 0.5049400141143261, "abs_surfaceSim_minus_score": 0.5049400141143261}
{"golden_code": "n = int(eval(input()))\n\ns = input().split()\n\ns = set(s)\n\nprint(('Four' if len(s) == 4 else 'Three'))", "generated_code": "# vim: fileencoding=utf-8\n\n\n\n\n\ndef main():\n\n    a, b = list(map(int, input().split()))\n\n    c = 0\n\n    for i in range(a, b + 1):\n\n        #     s = str(i)\n\n        #     r = \"\".join(reversed(list(s)))\n\n        #     if s == r:\n\n        #         c += 1\n\n        if (i % 10) == (i // 10000 % 10) and (i // 10 % 10) == (i // 1000 % 10):\n\n            c += 1\n\n    print(c)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "score": 0.0, "codebleu": 0.23290269660734625, "crystalbleu": 0.0, "codebertscore": 0.68, "codescore": 0.018313487991690636, "surfaceSim": 0.5717816787732042, "abs_surfaceSim_minus_score": 0.5717816787732042}
{"golden_code": "import sys\n\nif sys.argv[-1] == 'ONLINE_JUDGE':\n\n    import os\n\n    import re\n\n    with open(__file__) as f:\n\n        source = f.read().split('###''nbacl')\n\n    for s in source[1:]:\n\n        s = re.sub(\"'''.*\", '', s)\n\n        sp = s.split(maxsplit=1)\n\n        if os.path.dirname(sp[0]):\n\n            os.makedirs(os.path.dirname(sp[0]), exist_ok=True)\n\n        with open(sp[0], 'w') as f:\n\n            f.write(sp[1])\n\n    from nbmodule import cc\n\n    cc.compile()\n\nimport numpy as np\n\nfrom numpy import int64\n\nfrom nbmodule import solve\n\n\n\n\n\nf = open(0)\n\nN, K = [int(x) for x in f.readline().split()]\n\nA = np.fromstring(f.read(), dtype=int64, sep=' ')\n\nans = solve(N, K, A)\n\nprint(ans)\n\n\n\n'''\n\n###nbacl nbmodule.py\n\nimport numpy as np\n\nfrom numpy import int64\n\nfrom numba import njit\n\nfrom numba.types import i8\n\nfrom numba.pycc import CC\n\nimport nbacl.segtree as seg\n\ncc = CC('my_module')\n\n\n\n\n\n@cc.export('solve', (i8, i8, i8[:]))\n\n@njit\n\ndef solve(N, K, A):\n\n    dp = np.zeros(300_001, dtype=int64)\n\n    d = seg.segtree(dp, max, 0)\n\n    for i in range(N):\n\n        x = seg.prod(d, max, (A[i] - K) if A[i] > K else 0, (A[i] + K + 1) if A[i] + K < 300_000 else 300_001) + 1\n\n        seg.set(d, max, A[i], x)\n\n    return seg.all_prod(d)\n\n\n\n\n\nif __name__ == '__main__':\n\n    cc.compile()\n\n###nbacl nbacl/segtree.py\n\nimport numpy as np\n\nfrom numba import njit\n\nfrom numba.types import i8\n\n\n\n\n\n@njit\n\ndef ceil_pow2(n):\n\n    x = 0\n\n    while (1 << x) < n:\n\n        x += 1\n\n    return x\n\n\n\n\n\n@njit\n\ndef segtree(a, op, e):\n\n    log = ceil_pow2(a.shape[0])\n\n    size = 1 << log\n\n    d = np.empty(size * 2, dtype=a.dtype)\n\n    d[size:size + len(a)] = a\n\n    d[size + len(a):] = e\n\n    # e\n\n    d[0] = e\n\n    for i in range(size - 1, 0, -1):\n\n        update(d, i, op)\n\n    return d\n\n\n\n\n\n@njit\n\ndef update(d, k, op):\n\n    d[k] = op(d[2 * k], d[2 * k + 1])\n\n\n\n\n\n@njit\n\ndef set(d, op, p, x):\n\n    p += d.shape[0] // 2\n\n    d[p] = x\n\n    while p > 1:\n\n        p >>= 1\n\n        update(d, p, op)\n\n\n\n\n\n@njit\n\ndef get(d, p):\n\n    return d[p + d.shape[0] // 2]\n\n\n\n\n\n@njit\n\ndef prod(d, op, left, right):\n\n    size = d.shape[0] // 2\n\n    sml = d[0]\n\n    smr = d[0]\n\n    left += size\n\n    right += size\n\n\n\n    while left < right:\n\n        if left & 1:\n\n            sml = op(sml, d[left])\n\n            left += 1\n\n        if right & 1:\n\n            right -= 1\n\n            smr = op(d[right], smr)\n\n        left >>= 1\n\n        right >>= 1\n\n\n\n    return op(sml, smr)\n\n\n\n\n\n@njit\n\ndef all_prod(d):\n\n    return d[1]\n\n\n\n'''\n", "generated_code": "def main():\n\n    from itertools import accumulate\n\n    n, k = list(map(int, input().split()))\n\n    *exp, = [(int(x) + 1) / 2 for x in input().split()]\n\n    l = accumulate(exp)\n\n    l = list(l)\n\n    ans = l[k - 1]\n\n    for i in range(0, n - k):\n\n        x = l[i + k] - l[i]\n\n        ans = max(ans, x)\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 0.0, "codebleu": 0.13187566706513149, "crystalbleu": 0.03720256748675273, "codebertscore": 0.68, "codescore": 0.01839841529726982, "surfaceSim": 0.42929614685826195, "abs_surfaceSim_minus_score": 0.42929614685826195}
{"golden_code": "import numpy as np\n\n\n\n(N,M) = list(map(int,input().split()))\n\nB = np.ones(M,dtype=np.int)\n\n\n\nfor _ in range(N):\n\n    A = np.array(list(map(int,input().split())))[1:]\n\n    for i in range(M):\n\n        if not i+1 in A:\n\n            B[i] = 0\n\nprint((B.sum()))", "generated_code": "n=int(eval(input()))\n\nl=list(map(int,input().split()))\n\na=0\n\nfor i in range(n-2):\n\n  p,q,r=l[i:i+3]\n\n  if p<q<r or r<q<p: a+=1\n\nprint(a)", "score": 0.0, "codebleu": 0.22358247234081552, "crystalbleu": 0.1260579355266651, "codebertscore": 0.8, "codescore": 0.9486261606216431, "surfaceSim": 0.5460446247464503, "abs_surfaceSim_minus_score": 0.5460446247464503}
{"golden_code": "# -*- coding: utf-8 -*-\n\nfrom collections import deque\n\ndef inpl(): return list(map(int, input().split()))\n\n\n\nS = eval(input())\n\nA = set(\"ATCG\")\n\nans = 0\n\nmode = 0\n\nfor i, s in enumerate(S):\n\n    if s in A:\n\n        if mode == 0:\n\n            mode = 1\n\n            start = i\n\n    else:\n\n        if mode == 1:\n\n            ans = max(i - start, ans)\n\n            mode = 0\n\nif mode == 1:\n\n    ans = max(len(S) - start, ans)\n\nprint(ans)", "generated_code": "import re\n\n\n\ns = eval(input())\n\n\n\nif re.fullmatch(r\"(dream|dreamer|erase|eraser)+\", s):\n\n    print(\"YES\")\n\nelse:\n\n    print(\"NO\")", "score": 0.0, "codebleu": 0.07038584387020838, "crystalbleu": 0.0, "codebertscore": 0.63, "codescore": 0.03344617411494255, "surfaceSim": 0.4960748792270531, "abs_surfaceSim_minus_score": 0.4960748792270531}
{"golden_code": "import numpy as np\n\n\n\nn,l = [int(x) for x in input().split()] \n\nx = np.arange(l,l+n)\n\ny = np.abs(x)\n\nx = np.delete(x, np.argmin(y))\n\nprint((np.sum(x)))", "generated_code": "import math\n\n\n\nn, d = list(map(int, input().split()))\n\n\n\nx = [list(map(int, input().split())) for i in range(n)]\n\n\n\ncnt = 0\n\n\n\nfor i in range(n):\n\n    for j in range(i+1, n):\n\n        dist = 0\n\n        for k in range(d):\n\n            dist += (x[i][k] - x[j][k]) ** 2\n\n        if math.sqrt(dist).is_integer():\n\n            cnt += 1\n\n\n\nprint(cnt)", "score": 0.0, "codebleu": 0.24020619601222112, "crystalbleu": 0.02640837984636108, "codebertscore": 0.74, "codescore": 0.973816454410553, "surfaceSim": 0.5746334681496461, "abs_surfaceSim_minus_score": 0.5746334681496461}
{"golden_code": "while True:\n\n    n, x = [int(i) for i in input().split()]\n\n\n\n    if n == x == 0:\n\n        break\n\n\n\n    count = 0\n\n    for s in range(1, n - 1):\n\n        for m in range(s + 1, n):\n\n            for e in range(m + 1, n + 1):\n\n                if x == sum([s, m, e]):\n\n                    count += 1\n\n\n\n    print(count)", "generated_code": "a = list(map(int, input().split()))\n\n\n\nif any([x % 2 == 0 for x in a]):\n\n    print((0))\n\nelse:\n\n    a = list(sorted(a))\n\n    print((a[0] * a[1]))\n", "score": 0.0, "codebleu": 0.09289255683159377, "crystalbleu": 0.0, "codebertscore": 0.74, "codescore": 0.2843959331512451, "surfaceSim": 0.5819179051663128, "abs_surfaceSim_minus_score": 0.5819179051663128}
{"golden_code": "import math\n\nimport numpy as np\n\n\n\nn, d = list(map(int, input().split()))\n\n\n\nx = np.zeros([n, d])\n\n\n\nfor i in range(n):\n\n    line = list(map(int, input().split()))\n\n    for j in range(d):\n\n        x[i, j] = line[j]\n\n\n\ncnt = 0\n\n\n\nfor i in range(n):\n\n    for j in range(i+1, n):\n\n        xx = (x[i] - x[j]) ** 2\n\n        dist = math.sqrt(xx.sum())\n\n        if dist % 1 == 0:\n\n            cnt += 1\n\n\n\nprint(cnt)", "generated_code": "import sys\n\ninput = sys.stdin.readline\n\n \n\ns = input().rstrip()\n\nk = int(eval(input()))\n\n\n\ndef check_count(s):\n\n    cnt_list = []\n\n    cnt = 1\n\n    for i in range(1, len(s)):\n\n        if s[i-1] == s[i]:\n\n            cnt += 1\n\n        else:\n\n            cnt_list.append(cnt)\n\n            cnt = 1\n\n    if cnt>1:\n\n        cnt_list.append(cnt)\n\n    return cnt_list\n\n\n\ndef calc_ans(cnt_list, k):\n\n    _ans = 0\n\n    for c in cnt_list:\n\n        _ans += c//2\n\n    return(_ans * k)\n\n\n\nif len(s)==1:\n\n    ans = k//2\n\nelse:\n\n    cnt_list = check_count(s)\n\n    if len(cnt_list)==1:\n\n        ans = (len(s)*k)//2\n\n    else:\n\n        ans = calc_ans(cnt_list, k)\n\n        if s[0]==s[-1]:\n\n            if cnt_list[0]%2==1 and cnt_list[-1]%2==1:\n\n                ans += k - 1\n\n\n\nprint(ans)", "score": 0.0, "codebleu": 0.24442649228611135, "crystalbleu": 0.07141304431947544, "codebertscore": 0.77, "codescore": 0.3540175259113312, "surfaceSim": 0.578199308257674, "abs_surfaceSim_minus_score": 0.578199308257674}
{"golden_code": "N, K, C = list(map(int, input().split()))\n\nS = eval(input())\n\n\n\nlatest = [None]*K\n\ni = len(S)+C\n\nfor j in range(K-1, -1, -1):\n\n  i = S.rindex(\"o\", 0, i-C)\n\n  latest[j] = i\n\n\n\nif i<=C or \"o\" not in S[:i-C]:\n\n  i = -C-1\n\n  for j in latest:\n\n    i = S.index(\"o\", i+C+1)\n\n    if i == j:\n\n      print((i+1))\n", "generated_code": "k,n=list(map(int,input().split()))\n\na=list(map(int,input().split()))\n\na.append(a[0]+k)\n\n\n\nx=0\n\nfor i in range(len(a)-1):\n\n    dis=abs(a[i+1]-a[i])\n\n    x=max(x,dis)\n\n\n\nprint((k-x))", "score": 0.0, "codebleu": 0.15699779011126333, "crystalbleu": 0.11633745138102117, "codebertscore": 0.78, "codescore": 0.16310401260852814, "surfaceSim": 0.5431400282885431, "abs_surfaceSim_minus_score": 0.5431400282885431}
{"golden_code": "N=int(eval(input()))\n\n\n\nS=[[-1]*N for _ in range(N)]\n\nfor i in range(N):\n\n  A=int(eval(input()))\n\n  for _ in range(A):\n\n    x, y=list(map(int, input().split()))\n\n    S[i][x-1]=y\n\nans=0   \n\nfor s in range(2**N):\n\n  ok=True\n\n  for i in range(N):\n\n    #正直者について見ていく\n\n    if (s>>i&1)==1:\n\n      for j in range(N):\n\n        #それぞれ正直者の証言が矛盾ないか\n\n        if S[i][j]!=-1 and (s>>j&1)!=S[i][j]:\n\n          ok=False\n\n  if ok:\n\n    ans=max(ans, bin(s).count(\"1\"))\n\n    \n\nprint(ans)\n", "generated_code": "n = int(eval(input()))\n\n\n\nans = 1\n\nfor i in range(1, n+1):\n\n    ans = ans * i\n\n    ans = ans % ((10 ** 9)+7)  # 途中で割り算の余りを求めても、最終結果は同じになる\n\n\n\nprint(ans)", "score": 0.0, "codebleu": 0.13210346799386724, "crystalbleu": 0.012422629640324595, "codebertscore": 0.73, "codescore": 0.6148774027824402, "surfaceSim": 0.42467948717948717, "abs_surfaceSim_minus_score": 0.42467948717948717}
{"golden_code": "import math\n\n\n\nN = int(eval(input()))\n\nans = 0\n\n\n\nans =math.factorial(N) % (10**9 +7)\n\n\n\nprint(ans)", "generated_code": "import statistics\n\nn = int(eval(input()))\n\nal = list(map(int,input().split()))\n\n\n\nfor i in range(n):\n\n    al[i] -= i + 1\n\n\n\nmedian = statistics.median(al)\n\n\n\nans = 0\n\nfor a in al:\n\n    ans += abs(median - a)\n\n\n\nprint((int(ans)))\n", "score": 0.0, "codebleu": 0.3549768151550139, "crystalbleu": 0.0, "codebertscore": 0.79, "codescore": 0.30505672097206116, "surfaceSim": 0.5608078602620088, "abs_surfaceSim_minus_score": 0.5608078602620088}
{"golden_code": "MOD = 1000000007\n\n\n\n\n\nS = int(eval(input()))\n\n\n\n#dp[i]:=i桁の数列で条件を満たすものの数\n\ndp = [0]*(S+1)\n\n\n\nfor i in range(3,S+1):\n\n    #dp[i]=sum(dp[0],..,dp[i-3])+1\n\n    for j in range(i-3+1):\n\n        dp[i] = (dp[i]+dp[j])%MOD\n\n    dp[i] = (dp[i]+1)%MOD\n\n\n\nprint((dp[S]))", "generated_code": "from math import sqrt\n\nfrom bisect import bisect_left\n\ndef circle_center(x1, y1, x2, y2):\n\n    xd = x2 - x1; yd = y2 - y1\n\n    d = xd**2 + yd**2\n\n    k = sqrt((4.0 - d) / d) / 2.0\n\n    xc = (x1 + x2) / 2.0; yc = (y1 + y2) / 2.0\n\n    xd *= k; yd *= k\n\n    return [[xc - yd, yc + xd], [xc + yd, yc - xd]]\n\nwhile 1:\n\n    n = int(input())\n\n    if n==0: break\n\n    p = sorted(list(map(float, input().split())) for i in range(n))\n\n    prev = 0\n\n    ans = 1\n\n    for i in range(n):\n\n        bx, by = p[i]\n\n        while bx - p[prev][0] >= 2.0: prev += 1\n\n        for j in range(i+1, n):\n\n            cx, cy = p[j]\n\n            if cx - bx >= 2.0: break\n\n            if (bx - cx)**2 + (by - cy)**2 <= 4.0:\n\n                for ex, ey in circle_center(bx, by, cx, cy):\n\n                    count = 2\n\n                    for k in range(prev, n):\n\n                        if k==i or k==j: continue\n\n                        dx, dy = p[k]\n\n                        if dx - ex >= 1.0: break\n\n                        if (ex - dx)**2 + (ey - dy)**2 <= 1.0:\n\n                            count += 1\n\n                    ans = max(ans, count)\n\n    print(ans)", "score": 0.0, "codebleu": 0.17857610204991162, "crystalbleu": 0.03871162901171046, "codebertscore": 0.67, "codescore": 0.9755613207817078, "surfaceSim": 0.4539543057996485, "abs_surfaceSim_minus_score": 0.4539543057996485}
{"golden_code": "import numpy as np\n\n\n\nN, M = list(map(int, input().split()))\n\n\n\nlike_total = np.zeros(M)\n\ncnt = 0\n\nfor _ in range(N):\n\n    l = [v for v in map(int, input().split())]\n\n    #print(l)\n\n    for i in range(1, l[0]+1, 1):\n\n        like_total[l[i]-1] += 1\n\n\n\n#print(like_total, N)\n\n#print(like_total[4], like_total[9], like_total[-1])\n\nans = len(np.where(like_total==N)[0])\n\n\n\nprint(ans)\n", "generated_code": "n, q = [ int( val ) for val in input( ).split( \" \" ) ]\n\nps = [0]*n\n\nt = [0]*n\n\nfor i in range( n ):\n\n    ps[i], t[i] = input( ).split( \" \" )\n\n \n\n \n\noutput = []\n\nqsum = 0\n\nwhile t:\n\n    psi = ps.pop( 0 )\n\n    ti = int( t.pop( 0 ) )\n\n    if ti <= q:\n\n        qsum += ti\n\n        output.append( \"\".join( ( psi, \" \", str( qsum ) ) ) )\n\n    else:\n\n        t.append( ti - q )\n\n        ps.append( psi )\n\n        qsum += q\n\n \n\nprint(( \"\\n\".join( output ) ))", "score": 0.0, "codebleu": 0.18916409260817418, "crystalbleu": 0.04185810475361475, "codebertscore": 0.74, "codescore": 0.9937174320220947, "surfaceSim": 0.5954502068087815, "abs_surfaceSim_minus_score": 0.5954502068087815}
{"golden_code": "H, W = list(map(int, input().split()))\n\nimport numpy as np\n\nGrid = np.array([[0 if x == '.' else -1 for x in eval(input())] for _ in range(H)],dtype='int64')\n\n\n\ndef solveMase(Grid, start, goal): #bfsで迷路を解き、スタート-ゴール間の最低必要白マス数を返す\n\n    seen = {start}\n\n    V = [start]\n\n    while len(V) != 0: #bfs\n\n        v = V.pop(0)\n\n        if v == goal:\n\n            return Grid[goal]\n\n        #移動先nvをリストにまとめる\n\n        y,x = v\n\n        nV = []\n\n        if x > 0: nV.append((y,x-1))\n\n        if y > 0: nV.append((y-1,x))\n\n        if x < W-1: nV.append((y,x+1))\n\n        if y < H-1: nV.append((y+1,x))\n\n        #bfs\n\n        for nv in nV:\n\n            if Grid[nv] == -1 or nv in seen:\n\n                continue\n\n            Grid[nv] = Grid[v] + 1\n\n            V.append(nv)\n\n            seen.add(nv)\n\n    return 0\n\n\n\nwhite = len(Grid[Grid == 0])-1\n\nnes_white = solveMase(Grid, (0,0), (H-1,W-1))\n\nprint((white-nes_white if nes_white > 0 else -1))", "generated_code": "n=int(eval(input()))\n\na=[[int(s)for s in input().split()]for _ in range(n)]\n\ndef f():\n\n for i in range(n-1):\n\n  d=a[i][:];d[3],d[4]=d[4],d[3]\n\n  for j in range(i+1,n):\n\n   e=a[j][:];e[3],e[4]=e[4],e[3]\n\n   for p in([0,1,2,3,4,5],[1,5,2,0,4,3],[2,1,5,3,0,4],[3,0,2,5,4,1],[4,1,0,3,5,2],[5,1,4,3,2,0]):\n\n    f=[d[k]for k in p]\n\n    if f[0]==e[0]and f[5]==e[5]:\n\n     f=f[1:5]*2\n\n     for k in range(4):\n\n      if f[k:k+4]==e[1:5]:return'No'\n\n return'Yes'\n\nprint((f()))\n", "score": 0.0, "codebleu": 0.10206866666843657, "crystalbleu": 0.10168601234710012, "codebertscore": 0.69, "codescore": 0.6566799283027649, "surfaceSim": 0.5500392272236933, "abs_surfaceSim_minus_score": 0.5500392272236933}
{"golden_code": "A,B = list(map(int,input().split()))\n\nj = 0\n\nfor i in range(A,B+1):\n\n  l = list(str(i))\n\n  l_reverse = list(reversed(l))\n\n  if l == l_reverse:\n\n    j += 1\n\nprint(j)", "generated_code": "import copy\n\nn,k = list(map(int,input().split()))\n\nai = [int(i) for i in input().split()]\n\n\n\n#old_ai = ai\n\ncnt = 0\n\nold_tmp = sum(ai)\n\n\n\nwhile 1 == 1:\n\n    #old_ai = copy.deepcopy(ai)\n\n    li = [0]*(n+1)\n\n    for i in range(n):\n\n        li[max(0,i-ai[i])] += 1\n\n        li[min(n,i+1+ai[i])] -= 1\n\n        #print(li)\n\n    #print(li)\n\n    tmp = 0\n\n    for i in range(n):\n\n        if i == 0:\n\n            ai[i] = li[i]\n\n            tmp += ai[i]\n\n        else:\n\n            ai[i] = li[i] + ai[i-1]\n\n            tmp += ai[i]\n\n    #print(rui)\n\n    if old_tmp == tmp:\n\n        print((*ai))\n\n        exit()\n\n        break\n\n    cnt += 1\n\n    if cnt == k:\n\n        print((*ai))\n\n        exit()\n\n    old_tmp = tmp", "score": 0.0, "codebleu": 0.3757570639768959, "crystalbleu": 0.09925719807977323, "codebertscore": 0.72, "codescore": 0.9543322324752808, "surfaceSim": 0.5943854995579134, "abs_surfaceSim_minus_score": 0.5943854995579134}
{"golden_code": "import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\nN = int(readline())\n\nS = read().split()\n\n\n\nS = sorted(S)\n\nls = [[] for i in range(N + 1)]\n\nmax_num = 0\n\nleft = 0\n\nright = 0\n\nwhile right < N:\n\n    while right < N and S[left] == S[right]:\n\n        right += 1\n\n    if (right  - left) >= max_num:\n\n        ls[right - left].append(S[left].decode())\n\n        max_num = right - left\n\n    left = right\n\n    \n\nprint(('\\n'.join(ls[max_num])))\n", "generated_code": "import sys\n\ninput = sys.stdin.readline\n\n\n\ndef I(): return int(eval(input()))\n\ndef MI(): return list(map(int, input().split()))\n\ndef LI(): return list(map(int, input().split()))\n\n\n\n\"\"\"\n\n2X = ak * (2p+1)\n\n基本的には最小公倍数/2を基本とし，これの奇数倍か．\n\n\n\nX  = (ak//2) * (2p+1)\n\nと書ける．第二項が奇数なので，各akが2で割り切れれう回数が同じでなければならない\n\na=[2,4]だと無理\n\n\"\"\"\n\ndef main():\n\n    from math import gcd\n\n    N,M=MI()\n\n    A=LI()\n\n    \n\n    def count(X):\n\n        cnt=0\n\n        while X%2==0:\n\n            cnt+=1\n\n            X=X//2\n\n        return cnt\n\n    \n\n    C=count(A[0])\n\n    for i in range(1,N):\n\n        if count(A[i])!=C:\n\n            print((0))\n\n            exit()\n\n            \n\n    lca=1\n\n    for i in range(N):\n\n        g=gcd(lca,A[i])\n\n        lca=(lca*A[i])//g\n\n        \n\n    lca2=lca//2\n\n    ans=M//lca2 - M//lca\n\n    \n\n    print(ans)\n\n    \n\n            \n\n    \n\n\n\nmain()\n", "score": 0.0, "codebleu": 0.1875398391345377, "crystalbleu": 0.07051942678204814, "codebertscore": 0.69, "codescore": 0.9937505125999451, "surfaceSim": 0.5040341065370862, "abs_surfaceSim_minus_score": 0.5040341065370862}
{"golden_code": "def main():\n\n    N = int(input())\n\n    A = [int(i) for i in input().split()]\n\n    if N == 1:\n\n        return print(1 if A[0] % 2 == 0 else 2)\n\n    ans = 0\n\n    d = (-1, 0, 1)\n\n    from itertools import product\n\n    for i in product(range(3), repeat=N):\n\n        cur = 1\n\n        for j in range(N):\n\n            cur *= (A[j] + d[i[j]])\n\n        if cur % 2 == 0:\n\n            ans += 1\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "generated_code": "MOD = 1000000007\n\n\n\n\n\nS = int(eval(input()))\n\n\n\n#dp[i]:=i桁の数列で条件を満たすものの数\n\ndp = [0]*(S+1)\n\ndp_sum = [0]*(S+1)\n\n\n\nfor i in range(3,S+1):\n\n    #dp[i]=sum(dp[0],..,dp[i-3])+1\n\n    \n\n    dp[i] = (dp_sum[i-3]+1)%MOD\n\n    dp_sum[i] = (dp[i]+dp_sum[i-1])%MOD\n\n\n\nprint((dp[S]))", "score": 0.0, "codebleu": 0.09367729126920309, "crystalbleu": 0.0, "codebertscore": 0.71, "codescore": 0.07681328058242798, "surfaceSim": 0.472281237551454, "abs_surfaceSim_minus_score": 0.472281237551454}
{"golden_code": "import math\n\nx = int(eval(input()))\n\nprint((math.factorial(x) % (10**9 + 7)))", "generated_code": "n = int(eval(input()))\n\na = list(map(int, input().split()))\n\nans = 0\n\nfor num in a:\n\n    ans += format(num, 'b')[::-1].find('1')\n\nprint(ans)", "score": 0.0, "codebleu": 0.2607710581774271, "crystalbleu": 0.0, "codebertscore": 0.74, "codescore": 0.15525183081626892, "surfaceSim": 0.41666666666666663, "abs_surfaceSim_minus_score": 0.41666666666666663}
{"golden_code": "import numpy as np\n\neval(input())\n\nx = np.array(input().split(),dtype=np.int32)\n\n\n\nans = 0\n\nwhile (x%2 == 0).all():\n\n  x = x//2\n\n  ans += 1\n\nprint(ans)", "generated_code": "N, M = list(map(int, input().split()))\n\n\n\nlike_total = [0]*M\n\ncnt = 0\n\nfor _ in range(N):\n\n    l = list(map(int, input().split()))\n\n    for i in range(1, l[0]+1, 1):\n\n        like_total[l[i]-1] += 1\n\n\n\nfor v in like_total:\n\n    cnt += v==N\n\nprint(cnt)\n", "score": 0.0, "codebleu": 0.23154765464168234, "crystalbleu": 0.0, "codebertscore": 0.73, "codescore": 0.8778762817382812, "surfaceSim": 0.48346560846560843, "abs_surfaceSim_minus_score": 0.48346560846560843}
{"golden_code": "import math\n\nN = int(eval(input()))\n\np = math.factorial(N)\n\nprint((p % 1000000007))", "generated_code": "# ABC102C - Linear Approximation (ARC100C)\n\ndef main():\n\n    n = int(eval(input()))\n\n    A = tuple(map(int, input().rstrip().split()))\n\n    A = sorted(j - i for i, j in enumerate(A, start=1))\n\n    b = A[n // 2]\n\n    ans = sum(abs(a - b) for a in A)\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()", "score": 0.0, "codebleu": 0.33159264983121867, "crystalbleu": 0.0, "codebertscore": 0.69, "codescore": 0.018397117033600807, "surfaceSim": 0.44555444555444557, "abs_surfaceSim_minus_score": 0.44555444555444557}
{"golden_code": "from collections import Counter\n\nN, M = list(map(int, input().split()))\n\nA = list(map(int, input().split()))\n\n\n\nX = Counter(A)\n\nfor i in range(M):\n\n    B, C = list(map(int, input().split()))\n\n    X[C] += B\n\n\n\nZ = []\n\nfor key, value in list(X.items()):\n\n    Z.append((key, value))\n\n\n\nZ.sort(key=lambda x: x[0], reverse=True)\n\n\n\nans = 0\n\ncnt = 0\n\n\n\nfor value, key in Z:\n\n    if cnt + key <= N:\n\n        ans += key * value\n\n        cnt += key\n\n    else:\n\n        ans += (N - cnt) * value\n\n        break\n\n\n\nprint(ans)\n", "generated_code": "N = int(eval(input()))\n\np = 1\n\nfor i in range(1,N+1):\n\n    p *= i\n\n    p %= 1000000007\n\nprint(p)\n", "score": 0.0, "codebleu": 0.08797804053083633, "crystalbleu": 0.003773049557945937, "codebertscore": 0.68, "codescore": 0.09295865148305893, "surfaceSim": 0.4034370946822309, "abs_surfaceSim_minus_score": 0.4034370946822309}
{"golden_code": "import numpy as np\n\nn = int(eval(input()))\n\nal = list(map(int,input().split()))\n\n\n\nfor i in range(n):\n\n    al[i] -= i + 1\n\n\n\nmed = np.median(np.array(al))\n\n\n\nans = 0\n\nfor a in al:\n\n    ans += abs(a-med)\n\nprint((int(ans)))", "generated_code": "from collections import defaultdict\n\n\n\ndef main():\n\n    s = eval(input())\n\n    n = len(s)\n\n    ans = 0\n\n    num = 0\n\n    pow10 = 1\n\n    d = defaultdict(int)\n\n    d[0] = 1\n\n    for i in reversed(list(range(n))):\n\n        # pow10を10 ** (n-1-i)にしてるだけでTLEしていた\n\n        pow10 = pow10 * 10 % 2019\n\n        num += int(s[i]) * pow10\n\n        mod = num % 2019\n\n        ans += d[mod]\n\n        d[mod] += 1\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "score": 0.0, "codebleu": 0.21346929445741503, "crystalbleu": 0.0, "codebertscore": 0.74, "codescore": 0.018648337572813034, "surfaceSim": 0.5763736263736263, "abs_surfaceSim_minus_score": 0.5763736263736263}
{"golden_code": "k, n = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\n\n\ndiff = []\n\n\n\nfor i in range(n - 1):\n\n    diff.append(a[i + 1] - a[i])\n\ndiff.append(k - a[-1] + a[0])\n\n\n\nprint((k - max(diff)))\n", "generated_code": "#! /usr/bin/env python3\n\n\n\nimport sys\n\nint1 = lambda x: int(x) - 1\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\nsys.setrecursionlimit(500000)\n\n\n\nk = int(readline())\n\n\n\nans = -1\n\nacc = 7 % k\n\nfor n in range(1, k + 10):\n\n    if acc == 0:\n\n        ans = n\n\n        break\n\n    acc = (10 * acc + 7) % k\n\n\n\nprint(ans)\n", "score": 0.0, "codebleu": 0.16712901105218797, "crystalbleu": 0.017692373903574813, "codebertscore": 0.7, "codescore": 0.1445462852716446, "surfaceSim": 0.46675531914893614, "abs_surfaceSim_minus_score": 0.46675531914893614}
{"golden_code": "M=998244353\n\nn,m,k=list(map(int,input().split()))\n\na=0\n\nc=1\n\nfor i in range(k+1):\n\n  a+=c*m*pow(m-1,n-i-1,M)\n\n  c=c*(n-i-1)*pow(i+1,M-2,M)%M\n\nprint((a%M))", "generated_code": "a,b,c=1,0,0\n\nexec('a,b,c=b,c,a+c;'*(int(eval(input()))-2))\n\nprint((c%(10**9+7)))", "score": 0.0, "codebleu": 0.03785714285714285, "crystalbleu": 0.0, "codebertscore": 0.76, "codescore": 0.04197122901678085, "surfaceSim": 0.5122655122655122, "abs_surfaceSim_minus_score": 0.5122655122655122}
{"golden_code": "print((sum(si != ti for si, ti in zip(eval(input()), eval(input())))))\n", "generated_code": "import sys\n\nsys.setrecursionlimit(10000000)\n\nimport heapq\n\nimport math\n\n\n\ndef main():\n\n    N, K = list(map(int, input().split()))\n\n    A = [int(c) for c in input().split()]\n\n    F = [int(c) for c in input().split()]\n\n    \n\n    A.sort()\n\n    F.sort(reverse=True)\n\n\n\n    num = 0\n\n    sum_ = []\n\n    for i in range(len(A)):\n\n        sum_.append(A[i] * F[i])\n\n    left = 0\n\n    right = 10 ** 12\n\n    while(num < 50):\n\n        number = 0\n\n        mid = (left + right) // 2\n\n        # print(mid)\n\n        for i in range(len(A)):\n\n            if sum_[i] <= mid:\n\n                continue\n\n            else:\n\n                number += math.ceil((sum_[i] - mid) / F[i])\n\n            # print(number)\n\n        if number > K:\n\n            # 最大値をmidより小さくできない -> 最大値はもっとでかい\n\n            left = mid + 1\n\n        else:\n\n            right = mid\n\n        num += 1\n\n    print(mid)\n\n                \n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 0.0, "codebleu": 0.1956877031273862, "crystalbleu": 0.004936127893086461, "codebertscore": 0.61, "codescore": 0.07053148746490479, "surfaceSim": 0.3680961121308193, "abs_surfaceSim_minus_score": 0.3680961121308193}
{"golden_code": "# -*- coding: utf-8 -*-\n\n\"\"\"\n\nCreated on Sat May 25 21:24:29 2019\n\n\n\n@author: Yamazaki Kenichi\n\n\"\"\"\n\n\n\nN, M, K = list(map(int,input().split()))\n\nmod = 10**9+7\n\n\n\ndef cmb(n, r, mod):\n\n    if (r < 0 or r > n):\n\n        return 0\n\n    r = min(r, n-r)\n\n    return g1[n] * g2[r] * g2[n-r] % mod\n\n\n\ng1 = [1, 1] # 元テーブル\n\ng2 = [1, 1] # 逆元テーブル\n\ninv = [0, 1] # 逆元テーブル計算用テーブル\n\n\n\nfor i in range(2, N*M+1):\n\n    g1.append((g1[-1] * i) % mod)\n\n    inv.append((-inv[mod % i] * (mod//i)) % mod)\n\n    g2.append((g2[-1] * inv[-1]) % mod)\n\n\n\ndef a(N,M):\n\n    return N*(N+1)//2*(M+1) + M*(M+1)//2*(N+1)\n\ndef b(N):\n\n    return N*(N+1)//2\n\n\n\nans = 0\n\nfor i in range(N):\n\n    for j in range(M):\n\n        ans += a(i,j) + a(N-i-1,j) + a(i,M-j-1) + a(N-i-1,M-j-1)\n\n        ans -= b(i) + b(j) + b(N-i-1) + b(M-j-1)\n\n        ans %= mod\n\n#        print(i,j,a(i,j),a(N-i-1,j),a(i,M-j-1),a(N-i-1,M-j-1),b(i),b(j),ans)\n\nans *= g2[2]\n\n\n\nans *= cmb(N*M-2,K-2,mod)\n\nans %= mod\n\n\n\nprint(ans)\n", "generated_code": "N = int(eval(input()))\n\npower = 1\n\n\n\nfor i in range(N):\n\n    power = ((i+1) * power) % 1000000007\n\n\n\nprint(power)", "score": 0.0, "codebleu": 0.059489232868850286, "crystalbleu": 6.952699902544566e-05, "codebertscore": 0.66, "codescore": 0.09929753094911575, "surfaceSim": 0.4042654758238374, "abs_surfaceSim_minus_score": 0.4042654758238374}
{"golden_code": "N = int(eval(input()))\n\n\n\nseq = list(map(int, input().split()))\n\n\n\ncnt = 0\n\n\n\nfor num in seq:\n\n    while num % 2 == 0:\n\n        cnt += 1\n\n        num /= 2\n\n\n\nprint(cnt)\n", "generated_code": "from collections import Counter\n\nimport numpy as np\n\n\n\n\n\ndef part(pts, s, t, num, ans):\n\n    a = np.linspace(s, t, num, endpoint=False)\n\n    for i, v in list(Counter(np.argmax(np.dot(pts, [np.sin(a), np.cos(a)]), axis=0)).items()):\n\n        ans[i] += v\n\n\n\n\n\ndef solve(n, pts):\n\n    ans = np.zeros(n)\n\n    part(pts, 0, np.pi, 1e5, ans)\n\n    part(pts, np.pi, 2 * np.pi, 1e5, ans)\n\n    return ans / 2e5\n\n\n\n\n\nn = int(eval(input()))\n\nprint(('\\n'.join(map(str, solve(n, [list(map(int, input().split())) for _ in range(n)])))))\n", "score": 0.0, "codebleu": 0.26865337014448487, "crystalbleu": 0.09134604957286427, "codebertscore": 0.7, "codescore": 0.28113800287246704, "surfaceSim": 0.37718839062409115, "abs_surfaceSim_minus_score": 0.37718839062409115}
{"golden_code": "import copy\n\nn,k = list(map(int,input().split()))\n\nai = [int(i) for i in input().split()]\n\n\n\nold_ai = ai\n\ncnt = 0\n\n\n\nwhile 1 == 1:\n\n    old_ai = copy.deepcopy(ai)\n\n    li = [0]*(n+1)\n\n    for i in range(n):\n\n        li[max(0,i-ai[i])] += 1\n\n        li[min(n,i+1+ai[i])] -= 1\n\n        #print(li)\n\n    #print(li)\n\n    tmp = 0\n\n    for i in range(n):\n\n        if i == 0:\n\n            ai[i] = li[i]\n\n            tmp += ai[i]\n\n        else:\n\n            ai[i] = li[i] + ai[i-1]\n\n            tmp += ai[i]\n\n    #print(rui)\n\n    if ai == old_ai:\n\n        print((*ai))\n\n        exit()\n\n        break\n\n    cnt += 1\n\n    if cnt == k:\n\n        print((*ai))\n\n        exit()\n\n    old_ai = ai", "generated_code": "from collections import Counter\n\nimport numpy as np\n\n\n\n\n\ndef part(pts, s, t, num, ans):\n\n    a = np.linspace(s, t, num, endpoint=False)\n\n    for i, v in list(Counter(np.argmax(np.dot(pts, [np.sin(a), np.cos(a)]), axis=0)).items()):\n\n        ans[i] += v\n\n\n\n\n\ndef solve(n, pts):\n\n    ans = np.zeros(n)\n\n    part(pts, 0, np.pi, 1e5, ans)\n\n    part(pts, np.pi, 2 * np.pi, 1e5, ans)\n\n    return ans / 2e5\n\n\n\n\n\nn = int(eval(input()))\n\nprint(('\\n'.join(map(str, solve(n, [list(map(int, input().split())) for _ in range(n)])))))\n", "score": 0.0, "codebleu": 0.15006995953594826, "crystalbleu": 0.09598698688968095, "codebertscore": 0.7, "codescore": 0.2727452218532562, "surfaceSim": 0.5463236500902675, "abs_surfaceSim_minus_score": 0.5463236500902675}
{"golden_code": "import numpy as np\n\n\n\nN=int(eval(input()))\n\nA=list(map(int, input().split()))\n\n\n\nAA=[]\n\nfor i,a in enumerate(A):\n\n    AA.append(a-i+1)\n\n\n\nb=np.median(AA)\n\nans=0\n\n\n\nfor a in AA:\n\n    ans+=abs(a-b)\n\nprint((int(ans)))", "generated_code": "n = int(eval(input()))\n\n\n\nans = 1\n\nfor i in range(1, n+1):\n\n    ans = ans * i\n\n    ans = ans % ((10 ** 9)+7)  # 途中で割り算の余りを求めても、最終結果は同じになる\n\n\n\nprint(ans)", "score": 0.0, "codebleu": 0.12264760875846731, "crystalbleu": 0.0, "codebertscore": 0.72, "codescore": 0.09664782881736755, "surfaceSim": 0.4885402759234535, "abs_surfaceSim_minus_score": 0.4885402759234535}
{"golden_code": "import numpy as np\n\n\n\n\n\ndef main(n, m, a):\n\n    dp = np.zeros(n + 1, dtype=int)\n\n    dp[0] = 1\n\n    dp[1] = 1 if 1 not in a else 0\n\n\n\n    for i in range(2, len(dp)):\n\n        dp[i] = dp[i - 1] + dp[i - 2] if i not in a else 0\n\n        dp[i] %= 1000000007\n\n\n\n    return dp[-1]\n\n\n\n\n\nif __name__ == '__main__':\n\n    N, M = list(map(int, input().split()))\n\n    A = set()\n\n    for _ in range(M):\n\n        A.add(int(eval(input())))\n\n\n\n    print((main(N, M, A)))\n", "generated_code": "import sys\n\ninput = sys.stdin.readline\n\n\n\ndef I(): return int(eval(input()))\n\ndef MI(): return list(map(int, input().split()))\n\ndef LI(): return list(map(int, input().split()))\n\n\n\ndef main():\n\n    mod=10**9+7\n\n    N=I()\n\n    B=LI()\n\n    A=[0]*N\n\n    A[0]=B[0]\n\n    A[-1]=B[-1]\n\n    for i in range(N-2):\n\n        A[i+1]=min(B[i],B[i+1])\n\n        \n\n    print((sum(A)))\n\n\n\nmain()\n", "score": 0.0, "codebleu": 0.21683153236000974, "crystalbleu": 0.19800901299238646, "codebertscore": 0.77, "codescore": 0.025915803387761116, "surfaceSim": 0.5423558897243108, "abs_surfaceSim_minus_score": 0.5423558897243108}
{"golden_code": "#!usr/bin/env python3\n\nfrom collections import defaultdict\n\nfrom collections import deque\n\nfrom heapq import heappush, heappop\n\nimport sys\n\nimport math\n\nimport bisect\n\nimport random\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\n\ndef I(): return int(sys.stdin.readline())\n\ndef LS():return list(map(list, sys.stdin.readline().split()))\n\ndef S(): return list(sys.stdin.readline())[:-1]\n\ndef IR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = I()\n\n    return l\n\ndef LIR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = LI()\n\n    return l\n\ndef SR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = S()\n\n    return l\n\ndef LSR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = LS()\n\n    return l\n\nsys.setrecursionlimit(1000000)\n\nmod = 1000000007\n\n\n\n#A\n\ndef A():\n\n    return\n\n\n\n#B\n\ndef B():\n\n    return\n\n\n\n#C\n\ndef C():\n\n    return\n\n\n\n#D\n\ndef D():\n\n    return\n\n\n\n#E\n\ndef E():\n\n    return\n\n\n\n#F\n\ndef F():\n\n    a,b,c,X,Y = LI()\n\n    ans = float(\"inf\")\n\n    for z in range(300001):\n\n        if z%2 == 0:\n\n            m = c*z\n\n            x = z//2\n\n            y = z//2\n\n            m += a*max(0,X-x)\n\n            m += b*max(0,Y-y)\n\n            if m < ans:\n\n                ans = m\n\n    print(ans)\n\n    return\n\n\n\n#G\n\ndef G():\n\n    n = I()\n\n    x = LI()\n\n    f = [(i,x[i]) for i in range(n)]\n\n    f.sort(key = lambda x:x[1])\n\n    g = [(f[i][0],i) for i in range(n)]\n\n    g.sort(key = lambda x:x[0])\n\n    for i in range(n):\n\n        if g[i][1] < n//2:\n\n            print((f[n//2][1]))\n\n        else:\n\n            print((f[n//2-1][1]))\n\n    return\n\n\n\n#H\n\ndef H():\n\n    return\n\n\n\n#I\n\ndef I_():\n\n    return\n\n\n\n#J\n\ndef J():\n\n    return\n\n\n\n#Solve\n\nif __name__ == \"__main__\":\n\n    F()\n", "generated_code": "def main():\n\n\n\n    N = int(eval(input()))\n\n    A = list(int(x) for x in input().split())\n\n    ans = [0] * N\n\n\n\n    for i, a in enumerate(A):\n\n        ans[a-1] = i+1\n\n\n\n    print((' '.join(map(str, ans))))\n\n    \n\nif __name__ == '__main__':\n\n    main()", "score": 0.0, "codebleu": 0.0848355570438578, "crystalbleu": 0.001048138754286798, "codebertscore": 0.69, "codescore": 0.02203257754445076, "surfaceSim": 0.49177350427350425, "abs_surfaceSim_minus_score": 0.49177350427350425}
{"golden_code": "# vim: fileencoding=utf-8\n\n\n\n\n\ndef main():\n\n    a, b = list(map(int, input().split()))\n\n    c = 0\n\n    for i in range(a, b + 1):\n\n        s = str(i)\n\n        r = \"\".join(reversed(list(s)))\n\n        if s == r:\n\n            c += 1\n\n    print(c)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "generated_code": "n = int(eval(input()))\n\nprint((0 if n else 1))\n", "score": 0.0, "codebleu": 0.0425502744358566, "crystalbleu": 0.0, "codebertscore": 0.67, "codescore": 0.034386537969112396, "surfaceSim": 0.4700348432055749, "abs_surfaceSim_minus_score": 0.4700348432055749}
{"golden_code": "import sys\n\nsys.setrecursionlimit(10000000)\n\nimport heapq\n\nimport math\n\n \n\ndef main():\n\n    N, K = list(map(int, input().split()))\n\n    A = [int(c) for c in input().split()]\n\n    F = [int(c) for c in input().split()]\n\n    \n\n    A.sort()\n\n    F.sort(reverse=True)\n\n \n\n    num = 0\n\n    sum_ = []\n\n    for i in range(N):\n\n      sum_.append(A[i] * F[i])\n\n    left = 0\n\n    right = 10 ** 12\n\n    while(num < 90):\n\n        number = 0\n\n        mid = (left + right) // 2\n\n        # print(mid)\n\n        for i in range(len(A)):\n\n            if sum_[i] <= mid:\n\n                continue\n\n            else:\n\n                number += math.ceil((sum_[i] - mid) / F[i])\n\n            # print(number)\n\n        if number > K:\n\n            # 最大値をmidより小さくできない -> 最大値はもっとでかい\n\n            left = mid + 1\n\n        else:\n\n            right = mid\n\n        num += 1\n\n    print(mid)\n\n                \n\n        \n\n \n\n \n\n \n\nif __name__ == '__main__':\n\n    main()", "generated_code": "l,r=list(map(int,input().split()));s=list(range(l,r+1))[:673];print((min(i*j%2019for i in s for j in s if i<j)))", "score": 0.0, "codebleu": 0.10232003137812523, "crystalbleu": 0.01525325034459473, "codebertscore": 0.65, "codescore": 0.02186795137822628, "surfaceSim": 0.4847400857449089, "abs_surfaceSim_minus_score": 0.4847400857449089}
{"golden_code": "A, B, C, X, Y = list(map(int, input().split()))\n\n\n\nans = 5000 * 2 * 10 ** 5\n\nfor i in range(10 ** 5 + 1):\n\n    s = i * 2 * C + max(0, X - i) * A + max(0, Y - i) * B\n\n    ans = min(ans, s)\n\n\n\nprint(ans)", "generated_code": "def main():\n\n    from itertools import accumulate\n\n    n, k = list(map(int, input().split()))\n\n    *exp, = [(int(x) + 1) / 2 for x in input().split()]\n\n    l = accumulate(exp)\n\n    l = list(l)\n\n    ans = l[k - 1]\n\n    for i in range(0, n - k):\n\n        x = l[i + k] - l[i]\n\n        ans = max(ans, x)\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 0.0, "codebleu": 0.2577272402445271, "crystalbleu": 0.15355721232986955, "codebertscore": 0.78, "codescore": 0.018618158996105194, "surfaceSim": 0.5038793103448276, "abs_surfaceSim_minus_score": 0.5038793103448276}
{"golden_code": "k,n = list(map(int,input().split()))\n\na=list(map(int,input().split()))\n\na.append(a[0]+k)\n\nlongd=0\n\nfor i in range(n):\n\n    tmp=abs(a[i+1]-a[i])\n\n    longd=max(longd,tmp)\n\nprint((k-longd))", "generated_code": "import sys\n\n\n\nn, m, *lr = list(map(int, sys.stdin.read().split()))\n\nl, r = lr[::2], lr[1::2]\n\n\n\ndef main():\n\n    ans = max(min(r) - max(l) + 1, 0)\n\n    return ans\n\n\n\nif __name__ == '__main__':\n\n    ans = main()\n\n    print(ans)", "score": 0.0, "codebleu": 0.14761568593848196, "crystalbleu": 0.04912925407517812, "codebertscore": 0.76, "codescore": 0.01838519424200058, "surfaceSim": 0.47277059223961876, "abs_surfaceSim_minus_score": 0.47277059223961876}
{"golden_code": "n=int(eval(input()))\n\ns=list(map(str,input().split()))\n\ntotal=[]\n\nfor i in range(n):\n\n    if s[i] not in total:\n\n        total.append(s[i])\n\nprint(('Three' if len(total)==3 else 'Four'))", "generated_code": "n = int(eval(input()))\n\n\n\nans = 1\n\nfor i in range(1, n+1):\n\n    ans = ans * i\n\n    ans = ans % ((10 ** 9)+7)  # 途中で割り算の余りを求めても、最終結果は同じになる\n\n\n\nprint(ans)", "score": 0.0, "codebleu": 0.17332187103936142, "crystalbleu": 0.0, "codebertscore": 0.71, "codescore": 0.0620243139564991, "surfaceSim": 0.41877045348293596, "abs_surfaceSim_minus_score": 0.41877045348293596}
{"golden_code": "import sys\n\n\n\nn, m, *lr = list(map(int, sys.stdin.read().split()))\n\nlr = list(zip(*[iter(lr)] * 2))\n\n\n\ndef main():\n\n    cnt = [0] * (n + 1)\n\n    for l, r in lr:\n\n        cnt[l-1] += 1\n\n        cnt[r] -= 1\n\n    \n\n    for i in range(n):\n\n        cnt[i+1] += cnt[i]\n\n    \n\n    res = 0\n\n    for i in range(n):\n\n        res += (cnt[i] == m) & 1\n\n    \n\n    return res\n\n\n\nif __name__ == '__main__':\n\n    ans = main()\n\n    print(ans)", "generated_code": "import sys\n\nimport numpy as np\n\n\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\ndef main(N):\n\n    x = 0\n\n    for a in range(1, N+1):\n\n        for b in range(1, N//a+1):\n\n            x += a*b\n\n    return x\n\n\n\nif sys.argv[-1] == 'ONLINE_JUDGE':\n\n    import numba\n\n    from numba.pycc import CC\n\n    i8 = numba.int64\n\n    cc = CC('my_module')\n\n\n\n    def cc_export(f, signature):\n\n        cc.export(f.__name__, signature)(f)\n\n        return numba.njit(f)\n\n\n\n    main = cc_export(main, (i8, ))\n\n    cc.compile()\n\n\n\nfrom my_module import main\n\n\n\nN = int(read())\n\nprint((main(N)))\n", "score": 0.0, "codebleu": 0.1897369568820544, "crystalbleu": 0.022589650566010006, "codebertscore": 0.74, "codescore": 0.03153329715132713, "surfaceSim": 0.5910012907984511, "abs_surfaceSim_minus_score": 0.5910012907984511}
{"golden_code": "a,b,c,d,e,f=[int(eval(input())) for _ in range(6)]\n\nprint((sum([a,b,c,d,max(e,f)])-min([a,b,c,d])))", "generated_code": "import sys\n\nif sys.argv[-1] == 'ONLINE_JUDGE':\n\n    import os\n\n    import re\n\n    with open(__file__) as f:\n\n        source = f.read().split('###''nbacl')\n\n    for s in source[1:]:\n\n        s = re.sub(\"'''.*\", '', s)\n\n        sp = s.split(maxsplit=1)\n\n        if os.path.dirname(sp[0]):\n\n            os.makedirs(os.path.dirname(sp[0]), exist_ok=True)\n\n        with open(sp[0], 'w') as f:\n\n            f.write(sp[1])\n\n    from nbmodule import cc\n\n    cc.compile()\n\nimport numpy as np\n\nfrom numpy import int64\n\nfrom nbmodule import solve\n\n\n\n\n\nf = open(0)\n\nN, K = [int(x) for x in f.readline().split()]\n\nA = np.fromstring(f.read(), dtype=int64, sep=' ')\n\nans = solve(N, K, A)\n\nprint(ans)\n\n\n\n'''\n\n###nbacl nbmodule.py\n\nimport numpy as np\n\nfrom numpy import int64\n\nfrom numba import njit\n\nfrom numba.types import i8\n\nfrom numba.pycc import CC\n\nimport nbacl.segtree as seg\n\ncc = CC('nbmodule')\n\n\n\n\n\n@cc.export('solve', (i8, i8, i8[:]))\n\n@njit\n\ndef solve(N, K, A):\n\n    dp = np.zeros(300_001, dtype=int64)\n\n    d = seg.segtree(dp, max, 0)\n\n    for i in range(N):\n\n        x = seg.prod(d, max, (A[i] - K) if A[i] > K else 0, (A[i] + K + 1) if A[i] + K < 300_000 else 300_001) + 1\n\n        seg.set(d, max, A[i], x)\n\n    return seg.all_prod(d)\n\n\n\n\n\nif __name__ == '__main__':\n\n    cc.compile()\n\n###nbacl nbacl/segtree.py\n\nimport numpy as np\n\nfrom numba import njit\n\nfrom numba.types import i8\n\n\n\n\n\n@njit\n\ndef ceil_pow2(n):\n\n    x = 0\n\n    while (1 << x) < n:\n\n        x += 1\n\n    return x\n\n\n\n\n\n@njit\n\ndef segtree(a, op, e):\n\n    log = ceil_pow2(a.shape[0])\n\n    size = 1 << log\n\n    d = np.empty(size * 2, dtype=a.dtype)\n\n    d[size:size + len(a)] = a\n\n    d[size + len(a):] = e\n\n    # e\n\n    d[0] = e\n\n    for i in range(size - 1, 0, -1):\n\n        update(d, i, op)\n\n    return d\n\n\n\n\n\n@njit\n\ndef update(d, k, op):\n\n    d[k] = op(d[2 * k], d[2 * k + 1])\n\n\n\n\n\n@njit\n\ndef set(d, op, p, x):\n\n    p += d.shape[0] // 2\n\n    d[p] = x\n\n    while p > 1:\n\n        p >>= 1\n\n        update(d, p, op)\n\n\n\n\n\n@njit\n\ndef get(d, p):\n\n    return d[p + d.shape[0] // 2]\n\n\n\n\n\n@njit\n\ndef prod(d, op, left, right):\n\n    size = d.shape[0] // 2\n\n    sml = d[0]\n\n    smr = d[0]\n\n    left += size\n\n    right += size\n\n\n\n    while left < right:\n\n        if left & 1:\n\n            sml = op(sml, d[left])\n\n            left += 1\n\n        if right & 1:\n\n            right -= 1\n\n            smr = op(d[right], smr)\n\n        left >>= 1\n\n        right >>= 1\n\n\n\n    return op(sml, smr)\n\n\n\n\n\n@njit\n\ndef all_prod(d):\n\n    return d[1]\n\n\n\n'''\n", "score": 0.0, "codebleu": 0.14488243987027022, "crystalbleu": 0.015495765905206274, "codebertscore": 0.57, "codescore": 0.9869022369384766, "surfaceSim": 0.29830123060460134, "abs_surfaceSim_minus_score": 0.29830123060460134}
{"golden_code": "# ABC102C - Linear Approximation (ARC100C)\n\nfrom statistics import median\n\n\n\n\n\ndef main():\n\n    n = int(eval(input()))\n\n    A = tuple(map(int, input().rstrip().split()))\n\n    A = tuple(j - i for i, j in enumerate(A, start=1))\n\n    b = median(A)\n\n    ans = sum(abs(a - b) for a in A)\n\n    print((int(ans)))\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()", "generated_code": "n=int(eval(input()))\n\nV=list(map(int,input().split()))\n\nC=list(map(int,input().split()))\n\nans=0\n\nfor v,c in zip(V,C):\n\n    diff=v-c\n\n    if 0<diff:\n\n        ans+=diff\n\nprint(ans)", "score": 0.0, "codebleu": 0.18906861056425364, "crystalbleu": 0.137326317131317, "codebertscore": 0.76, "codescore": 0.07207440584897995, "surfaceSim": 0.5543310557637204, "abs_surfaceSim_minus_score": 0.5543310557637204}
{"golden_code": "from math import factorial\n\nN = int(eval(input()))\n\nprint((factorial(N) % (10**9 + 7)))", "generated_code": "import math\n\n\n\nn, d = list(map(int, input().split()))\n\n\n\nx = [list(map(int, input().split())) for i in range(n)]\n\n\n\ncnt = 0\n\n\n\nfor i in range(n):\n\n    for j in range(i+1, n):\n\n        dist = 0\n\n        for k in range(d):\n\n            dist += (x[i][k] - x[j][k]) ** 2\n\n        if math.sqrt(dist).is_integer():\n\n            cnt += 1\n\n\n\nprint(cnt)", "score": 0.0, "codebleu": 0.25413558613260834, "crystalbleu": 0.0, "codebertscore": 0.68, "codescore": 0.9426479339599609, "surfaceSim": 0.4638372093023256, "abs_surfaceSim_minus_score": 0.4638372093023256}
{"golden_code": "n,m=list(map(int,input().split()))\n\nc=[0]*(n+2)\n\nfor i in range(m):\n\n  l,r=list(map(int,input().split()))\n\n  c[l-1]+=1\n\n  c[r]-=1\n\nfor i in range(1,n+2):\n\n  c[i]=c[i]+c[i-1]\n\nans=0\n\nfor i in range(n+2):\n\n  if c[i]==m:\n\n    ans+=1\n\nprint(ans)", "generated_code": "A, B = list(map(int,input().split()))\n\n\n\nans = 0\n\nfor n in range(A, B+1):\n\n    n = str(n)\n\n    if n == n[::-1]:\n\n        ans += 1\n\nprint(ans)", "score": 0.0, "codebleu": 0.21291522646082844, "crystalbleu": 0.11014073293013797, "codebertscore": 0.84, "codescore": 0.863122820854187, "surfaceSim": 0.6027385892116183, "abs_surfaceSim_minus_score": 0.6027385892116183}
{"golden_code": "a,b,c=1,0,0\n\nexec('a,b,c=b,c,(a+c)%(10**9+7);'*(int(eval(input()))-2))\n\nprint(c)", "generated_code": "N = int(eval(input()))\n\nV = list(map(int, input().split()))\n\nC = list(map(int, input().split()))\n\nprint((sum([V[i] - C[i] for i in range(N) if V[i] > C[i]])))\n", "score": 0.0, "codebleu": 0.20238095238095238, "crystalbleu": 0.0, "codebertscore": 0.72, "codescore": 0.02067243866622448, "surfaceSim": 0.39093015557762334, "abs_surfaceSim_minus_score": 0.39093015557762334}
{"golden_code": "from scipy.sparse.csgraph import csgraph_from_dense, floyd_warshall\n\n\n\nINF = float('inf')\n\n\n\ndef sol():\n\n    N, M = list(map(int, input().split()))\n\n\n\n    edges = []\n\n\n\n    for _ in range(M):\n\n        fr, to, cost = list(map(int, input().split()))\n\n        fr -= 1\n\n        to -= 1\n\n        edges.append((fr, to, cost))\n\n\n\n    graph = [[INF] * N for _ in range(N)]\n\n    for fr, to, cost in edges:\n\n        graph[fr][to] = cost\n\n\n\n    graph = csgraph_from_dense(graph, null_value=INF)\n\n\n\n    dist = floyd_warshall(graph, directed=False)\n\n    ans = (graph > dist).sum()\n\n    print(ans)\n\n\n\nsol()", "generated_code": "a = list(map(int, input().split()))\n\n\n\nif any([x % 2 == 0 for x in a]):\n\n    print((0))\n\nelse:\n\n    a = list(sorted(a))\n\n    print((a[0] * a[1]))\n", "score": 0.0, "codebleu": 0.10734909314222664, "crystalbleu": 0.024686561927709384, "codebertscore": 0.65, "codescore": 0.10648930072784424, "surfaceSim": 0.46768018018018015, "abs_surfaceSim_minus_score": 0.46768018018018015}
{"golden_code": "#E\n\nfrom itertools import accumulate\n\nfrom bisect import bisect_left\n\ndef main():\n\n    n,m=list(map(int,input().split()))\n\n    A=list(map(int,input().split()))\n\n    A.sort()\n\n    \n\n    def count(k):\n\n        cnt=0\n\n        for a in A:\n\n            cnt+=bisect_left(A,k-a)\n\n        return cnt\n\n    \n\n    ok=0\n\n    ng=10**10+1\n\n    while ng-ok>1:\n\n        mid=(ok+ng)//2\n\n        if count(mid)<n**2-m:\n\n            ok=mid\n\n        else:\n\n            ng=mid\n\n    border=ok\n\n    \n\n    k=n**2-count(border)\n\n    Acc=[0]+list(accumulate(A))\n\n    s=Acc[-1]\n\n    ans=0\n\n    for a in A:\n\n        idx=bisect_left(A,border-a)\n\n        ans+=a*(n-idx)+(s-Acc[idx])\n\n    ans-=border*(k-m)\n\n    print(ans)\n\n    \n\nif __name__=='__main__':\n\n    main()", "generated_code": "k,n = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\nb = [0 for i in range(n)]\n\nfor i in range(0,n-1):\n\n  b[i] = a[i+1] -a[i]\n\n\n\nb[n-1] = k - a[n-1] + a[0]\n\nans = k - max(b)\n\nprint((int(ans)))", "score": 0.0, "codebleu": 0.13749756026044302, "crystalbleu": 0.0939373656810134, "codebertscore": 0.72, "codescore": 0.03667820990085602, "surfaceSim": 0.464172619485971, "abs_surfaceSim_minus_score": 0.464172619485971}
{"golden_code": "from collections import Counter\n\n\n\nimport numpy as np\n\n\n\n\n\ndef part(pts, a, ans):\n\n    b = np.dot(pts, [np.sin(a), np.cos(a)])\n\n    c = np.argmax(b, axis=0)\n\n    for i, v in list(Counter(c).items()):\n\n        ans[i] += v\n\n\n\n\n\ndef solve(n, pts):\n\n    ans = [0] * n\n\n    part(pts, np.linspace(0, np.pi, 100000, endpoint=False), ans)\n\n    part(pts, np.linspace(np.pi, 2 * np.pi, 100000, endpoint=False), ans)\n\n    return [v / 200000 for v in ans]\n\n\n\n\n\nn = int(eval(input()))\n\npts = np.array([list(map(int, input().split())) for _ in range(n)])\n\nprint(('\\n'.join(map(str, solve(n, pts)))))\n", "generated_code": "n,m=list(map(int,input().split()))\n\nl,r=list(map(int,input().split()))\n\nfor i in range(m-1):\n\n  tl,tr=list(map(int,input().split()))\n\n  if l<tl:\n\n    l=tl\n\n  if tr<r:\n\n    r=tr\n\nprint((max(r-l+1,0)))", "score": 0.0, "codebleu": 0.08906061739959492, "crystalbleu": 0.0443080970419376, "codebertscore": 0.69, "codescore": 0.3076581060886383, "surfaceSim": 0.3906557037956355, "abs_surfaceSim_minus_score": 0.3906557037956355}
{"golden_code": "import numpy as np\n\nn,k=list(map(int,input().split()))\n\nexp=tuple([(int(x)+1)/2 for x in input().split()])\n\nl=np.cumsum(exp)\n\n\n\nans=l[k-1]\n\nfor i in range(0,n-k):\n\n  x=l[i+k]-l[i]\n\n  ans=max(ans,x)\n\nprint(ans)", "generated_code": "from itertools import accumulate\n\nfrom bisect import bisect_left\n\ndef main():\n\n    n,m=list(map(int,input().split()))\n\n    A=list(map(int,input().split()))\n\n    A.sort()\n\n    \n\n    def count(k):\n\n        cnt=0\n\n        for a in A:\n\n            cnt+=bisect_left(A,k-a)\n\n        return cnt\n\n    \n\n    ok=0\n\n    ng=2*10**5+1\n\n    while ng-ok>1:\n\n        mid=(ok+ng)//2\n\n        if count(mid)<n**2-m:\n\n            ok=mid\n\n        else:\n\n            ng=mid\n\n    border=ok\n\n    \n\n    k=n**2-count(border)\n\n    Acc=[0]+list(accumulate(A))\n\n    s=Acc[-1]\n\n    ans=0\n\n    for a in A:\n\n        idx=bisect_left(A,border-a)\n\n        ans+=a*(n-idx)+(s-Acc[idx])\n\n    ans-=border*(k-m)\n\n    print(ans)\n\n    \n\nif __name__=='__main__':\n\n    main()", "score": 0.0, "codebleu": 0.2631795015606679, "crystalbleu": 0.06615146178872858, "codebertscore": 0.72, "codescore": 0.06618527323007584, "surfaceSim": 0.46213476446034585, "abs_surfaceSim_minus_score": 0.46213476446034585}
{"golden_code": "import numpy as np\n\n\n\nn = int(eval(input()))\n\na = np.array(list(map(int,input().split())))\n\n\n\ncount = 0\n\nwhile np.all(a%2==0):\n\n    count+=1\n\n    a=a/2\n\nprint(count)\n", "generated_code": "# -*- coding: utf-8 -*-\n\n\"\"\"\n\nCreated on Wed May 29 22:49:19 2019\n\n\n\n@author: Yamazaki Kenichi\n\n\"\"\"\n\n\n\n# -*- coding: utf-8 -*-\n\n\"\"\"\n\nCreated on Sat May 25 21:24:29 2019\n\n\n\n@author: Yamazaki Kenichi\n\n\"\"\"\n\n\n\nN, M, K = list(map(int,input().split()))\n\nmod = 10**9+7\n\n\n\ndef cmb(n, r, mod):\n\n    if (r < 0 or r > n):\n\n        return 0\n\n    r = min(r, n-r)\n\n    return g1[n] * g2[r] * g2[n-r] % mod\n\n\n\ng1 = [1, 1] # 元テーブル\n\ng2 = [1, 1] # 逆元テーブル\n\ninv = [0, 1] # 逆元テーブル計算用テーブル\n\n\n\nfor i in range(2, N*M+1):\n\n    g1.append((g1[-1] * i) % mod)\n\n    inv.append((-inv[mod % i] * (mod//i)) % mod)\n\n    g2.append((g2[-1] * inv[-1]) % mod)\n\n\n\nans1 = 0\n\ndef c(N,M):\n\n    res = 0\n\n    for i in range(1,N):\n\n        res += i*(N-i)*M*M\n\n    return res\n\nans1 += c(N,M) + c(M,N)\n\nans1 %= mod\n\n\n\nans1 *= cmb(N*M-2,K-2,mod)\n\nans1 %= mod\n\n\n\nprint(ans1)\n", "score": 0.0, "codebleu": 0.2272303707853156, "crystalbleu": 0.06282441258596946, "codebertscore": 0.62, "codescore": 0.9864987134933472, "surfaceSim": 0.3895356056373006, "abs_surfaceSim_minus_score": 0.3895356056373006}
{"golden_code": "s = eval(input())\n\n\n\nstart = -1\n\nend = 0\n\nfor i in range(len(s)):\n\n    if s[i] == 'A' and start < 0:\n\n        start = i\n\n    elif s[i] == 'Z':\n\n        end = i\n\nprint((end - start + 1))\n", "generated_code": "N, D = list(map(int, input().split()))\n\ncount = 0\n\nfor i in range(N):\n\n    a, b = list(map(int, input().split()))\n\n    if (a*a + b*b) <= D*D:\n\n        count += 1\n\nprint(count)\n", "score": 0.0, "codebleu": 0.19237571349757343, "crystalbleu": 0.0, "codebertscore": 0.76, "codescore": 0.19347192347049713, "surfaceSim": 0.4853643966547192, "abs_surfaceSim_minus_score": 0.4853643966547192}
{"golden_code": "s = input()[::-1]\n\n\n\nwhile True:\n\n    if len(s) == 0:\n\n        break\n\n    if s[:7] == \"remaerd\":\n\n        s = s[7:]\n\n    elif s[:6] == \"resare\":\n\n        s = s[6:]\n\n    elif s[:5] == \"maerd\" or s[:5] == \"esare\":\n\n        s = s[5:]\n\n    else:\n\n        print(\"NO\")\n\n        exit()\n\n\n\nprint(\"YES\")", "generated_code": "N, M = list(map(int, input().split()))\n\nINF = 10**18\n\n\n\nminDist = [[INF] * N for _ in range(N)]\n\nfor i in range(N):\n\n    minDist[i][i] = 0\n\n\n\nedges = []\n\nfor _ in range(M):\n\n    fr, to, d = list(map(int, input().split()))\n\n    fr -= 1\n\n    to -= 1\n\n    edges.append((fr, to, d))\n\n    minDist[fr][to] = d\n\n    minDist[to][fr] = d\n\n\n\nfor k in range(N):\n\n    for i in range(N):\n\n        for j in range(N):\n\n            d = minDist[i][k] + minDist[k][j]\n\n            if minDist[i][j] > d:\n\n                minDist[i][j] = d\n\n\n\nans = 0\n\nfor fr, to, d in edges:\n\n    if minDist[fr][to] < d:\n\n        ans += 1\n\nprint(ans)\n", "score": 0.0, "codebleu": 0.08572571642660892, "crystalbleu": 0.00827282709686921, "codebertscore": 0.63, "codescore": 0.9270339608192444, "surfaceSim": 0.3812769010043041, "abs_surfaceSim_minus_score": 0.3812769010043041}
{"golden_code": "N = int(eval(input()))\n\n\n\ncount = 0\n\nfor i in range(1, N + 1):\n\n    num_dig = 0\n\n    ii = i\n\n    while ii > 0:\n\n        ii = int(ii / 10)\n\n        num_dig += 1\n\n    if num_dig % 2 != 0:\n\n        count += 1\n\n\n\nprint(count)", "generated_code": "import sys\n\nif sys.argv[-1] == 'ONLINE_JUDGE':\n\n    import os\n\n    import re\n\n    with open(__file__) as f:\n\n        source = f.read().split('###''nbacl')\n\n    for s in source[1:]:\n\n        s = re.sub(\"'''.*\", '', s)\n\n        sp = s.split(maxsplit=1)\n\n        if os.path.dirname(sp[0]):\n\n            os.makedirs(os.path.dirname(sp[0]), exist_ok=True)\n\n        with open(sp[0], 'w') as f:\n\n            f.write(sp[1])\n\n    from nbmodule import cc\n\n    cc.compile()\n\nimport numpy as np\n\nfrom numpy import int64\n\nfrom nbmodule import solve\n\n\n\n\n\nf = open(0)\n\nN, K = [int(x) for x in f.readline().split()]\n\nA = np.fromstring(f.read(), dtype=int64, sep=' ')\n\nans = solve(N, K, A)\n\nprint(ans)\n\n\n\n'''\n\n###nbacl nbmodule.py\n\nimport numpy as np\n\nfrom numpy import int64\n\nfrom numba import njit\n\nfrom numba.types import i8\n\nfrom numba.pycc import CC\n\nimport nbacl.segtree as seg\n\ncc = CC('nbmodule')\n\n\n\n\n\n@cc.export('solve', (i8, i8, i8[:]))\n\n@njit\n\ndef solve(N, K, A):\n\n    dp = np.zeros(300_001, dtype=int64)\n\n    d = seg.segtree(dp, max, 0)\n\n    for i in range(N):\n\n        x = seg.prod(d, max, (A[i] - K) if A[i] > K else 0, (A[i] + K + 1) if A[i] + K < 300_000 else 300_001) + 1\n\n        seg.set(d, max, A[i], x)\n\n    return seg.all_prod(d)\n\n\n\n\n\nif __name__ == '__main__':\n\n    cc.compile()\n\n###nbacl nbacl/segtree.py\n\nimport numpy as np\n\nfrom numba import njit\n\nfrom numba.types import i8\n\n\n\n\n\n@njit\n\ndef ceil_pow2(n):\n\n    x = 0\n\n    while (1 << x) < n:\n\n        x += 1\n\n    return x\n\n\n\n\n\n@njit\n\ndef segtree(a, op, e):\n\n    log = ceil_pow2(a.shape[0])\n\n    size = 1 << log\n\n    d = np.empty(size * 2, dtype=a.dtype)\n\n    d[size:size + len(a)] = a\n\n    d[size + len(a):] = e\n\n    # e\n\n    d[0] = e\n\n    for i in range(size - 1, 0, -1):\n\n        update(d, i, op)\n\n    return d\n\n\n\n\n\n@njit\n\ndef update(d, k, op):\n\n    d[k] = op(d[2 * k], d[2 * k + 1])\n\n\n\n\n\n@njit\n\ndef set(d, op, p, x):\n\n    p += d.shape[0] // 2\n\n    d[p] = x\n\n    while p > 1:\n\n        p >>= 1\n\n        update(d, p, op)\n\n\n\n\n\n@njit\n\ndef get(d, p):\n\n    return d[p + d.shape[0] // 2]\n\n\n\n\n\n@njit\n\ndef prod(d, op, left, right):\n\n    size = d.shape[0] // 2\n\n    sml = d[0]\n\n    smr = d[0]\n\n    left += size\n\n    right += size\n\n\n\n    while left < right:\n\n        if left & 1:\n\n            sml = op(sml, d[left])\n\n            left += 1\n\n        if right & 1:\n\n            right -= 1\n\n            smr = op(d[right], smr)\n\n        left >>= 1\n\n        right >>= 1\n\n\n\n    return op(sml, smr)\n\n\n\n\n\n@njit\n\ndef all_prod(d):\n\n    return d[1]\n\n\n\n'''\n", "score": 0.0, "codebleu": 0.12854327111630087, "crystalbleu": 0.0028586877862046057, "codebertscore": 0.65, "codescore": 0.9845672845840454, "surfaceSim": 0.278330658105939, "abs_surfaceSim_minus_score": 0.278330658105939}
{"golden_code": "W,H,x,y,r = [int(i) for i in input().split()]\n\nif x - r >= 0 and x + r <= W and y - r >= 0 and y + r <= H:\n\n    print(\"Yes\")\n\nelse:\n\n    print(\"No\")", "generated_code": "s = eval(input())\n\n\n\nstart = 0\n\nfor i in range(len(s)):\n\n    if s[i] == 'A':\n\n        start = i\n\n        break\n\n\n\nend = 0\n\nfor i in reversed(list(range(len(s)))):\n\n    if s[i] == 'Z':\n\n        end = i\n\n        break\n\nprint((end - start + 1))\n", "score": 0.0, "codebleu": 0.20646749660225872, "crystalbleu": 0.0, "codebertscore": 0.73, "codescore": 0.0274369977414608, "surfaceSim": 0.4896694214876033, "abs_surfaceSim_minus_score": 0.4896694214876033}
{"golden_code": "from math import floor, sqrt\n\nfrom collections import Counter\n\n\n\nMOD = 10 ** 9 + 7\n\n\n\n# xを素因数分解する\n\ndef getPrimeFactor(x):\n\n    ans = []\n\n    for d in range(2, floor(sqrt(x)) + 1):\n\n        while x % d == 0:\n\n            ans.append(d)\n\n            x //= d\n\n\n\n    if x != 1:\n\n        ans.append(x)\n\n\n\n    return ans\n\n\n\n# xのn乗（二分累乗法）\n\ndef power(x, n):\n\n    ans = 1\n\n    while n:\n\n        if n % 2 == 1:\n\n            ans = (ans * x) % MOD\n\n        x = (x * x) % MOD\n\n        n //= 2\n\n    return ans\n\n\n\n\n\nN, M = list(map(int, input().split()))\n\n\n\nPFs = getPrimeFactor(M)\n\ncnt = Counter(PFs)\n\n\n\nN2 = N\n\nif len(cnt):\n\n    N2 += max(cnt.values())\n\n\n\n# facts[x]: xの階乗\n\nfacts = [1] + [0] * N2\n\nfor x in range(1, N2 + 1):\n\n    facts[x] = (facts[x - 1] * x) % MOD\n\n\n\n# invFs[x]: xの階乗の逆元\n\ninvFs = [0] * N2 + [power(facts[N2], MOD - 2)]\n\nfor x in reversed(list(range(N2))):\n\n    invFs[x] = (invFs[x + 1] * (x + 1)) % MOD\n\n\n\ndef comb(n, k):\n\n    return ((facts[n] * invFs[k]) % MOD * invFs[n - k]) % MOD\n\n\n\n\n\nans = 1\n\nfor num in list(cnt.values()):\n\n    ans = (ans * comb(N + num - 1, num)) % MOD\n\nprint(ans)\n", "generated_code": "import sys\n\nimport itertools\n\nfrom operator import itemgetter #sortedの対象を決めたい\n\nfrom fractions import gcd #最大公約数\n\nfrom math import ceil, floor, sqrt, isinf #小数点切り上げ、切り捨て、平方根\n\nfrom copy import deepcopy #参照で影響されないコピー\n\nfrom collections import Counter, deque #要素ごとの出現回数、双方向アクセス可能データ型\n\nimport heapq\n\nimport numpy as np\n\nfrom functools import reduce\n\nsys.setrecursionlimit(200000)\n\n\n\ninput = sys.stdin.readline\n\n# template\n\n\n\ndef main():\n\n    n = int(eval(input()))\n\n    abc = [list(map(int, input().split())) for _ in range(n)]\n\n\n\n    a, b, c = 0, 0, 0\n\n    for x, y, z in abc:\n\n        a, b, c = max(b, c) + x, max(a, c) + y, max(a, b) + z\n\n\n\n    print((max(a, b, c)))\n\n\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n\n\n", "score": 0.0, "codebleu": 0.08865374860771136, "crystalbleu": 0.053323172452360484, "codebertscore": 0.7, "codescore": 0.018288979306817055, "surfaceSim": 0.5254925858216535, "abs_surfaceSim_minus_score": 0.5254925858216535}
{"golden_code": "'''\n\nある平面のブロック数×(0,1)\n\n一つでも偶数があれば、均等分割可能\n\nすべて奇数のとき、\n\nある平面のブロック数を最小となるようにすると、その数が答えになる\n\n'''\n\n\n\narr = list(map(int, input().split()))\n\n\n\nret = -1\n\nif 0 in list([x % 2 for x in arr]):\n\n    ret = 0\n\nelse:\n\n    arr_sorted = sorted(arr)\n\n    ret = arr_sorted[0] * arr_sorted[1]\n\nprint(ret)", "generated_code": "print((sum(sorted(int(eval(input())) for _ in range(4))[1:])+max([int(eval(input())) for _ in range(2)])))", "score": 0.0, "codebleu": 0.09802498825106087, "crystalbleu": 0.0, "codebertscore": 0.65, "codescore": 0.018383026123046875, "surfaceSim": 0.3758097762073027, "abs_surfaceSim_minus_score": 0.3758097762073027}
{"golden_code": "import sys\n\nimport numpy as np\n\n\n\n\n\ndef main():\n\n    h, w = list(map(int, sys.stdin.buffer.readline().split()))\n\n    n = int(sys.stdin.buffer.readline())\n\n    a = list(map(int, sys.stdin.buffer.readline().split()))\n\n    ans = np.zeros(w*h, np.int64)\n\n    now = 0\n\n    for i, x in enumerate(a):\n\n        for j in range(x):\n\n            ans[now + j] = i+1\n\n        now += x\n\n\n\n    ans = ans.reshape(h, w)\n\n    for i in range(h):\n\n        if i % 2:\n\n            print((*ans[i, ::-1]))\n\n        else:\n\n            print((*ans[i]))\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "generated_code": "from itertools import accumulate\n\nfrom bisect import bisect_left\n\ndef main():\n\n    n,m=list(map(int,input().split()))\n\n    A=list(map(int,input().split()))\n\n    A.sort()\n\n    \n\n    def count(k):\n\n        cnt=0\n\n        for a in A:\n\n            cnt+=bisect_left(A,k-a)\n\n        return cnt\n\n    \n\n    ok=0\n\n    ng=2*10**5+1\n\n    while ng-ok>1:\n\n        mid=(ok+ng)//2\n\n        if count(mid)<n**2-m:\n\n            ok=mid\n\n        else:\n\n            ng=mid\n\n    border=ok\n\n    \n\n    k=n**2-count(border)\n\n    Acc=[0]+list(accumulate(A))\n\n    s=Acc[-1]\n\n    ans=0\n\n    for a in A:\n\n        idx=bisect_left(A,border-a)\n\n        ans+=a*(n-idx)+(s-Acc[idx])\n\n    ans-=border*(k-m)\n\n    print(ans)\n\n    \n\nif __name__=='__main__':\n\n    main()", "score": 0.0, "codebleu": 0.21985879932197042, "crystalbleu": 0.10912037187412883, "codebertscore": 0.73, "codescore": 0.1331770271062851, "surfaceSim": 0.571733926128591, "abs_surfaceSim_minus_score": 0.571733926128591}
{"golden_code": "n = int(eval(input()))\n\nv = list(map(int, input().split()))\n\nc = list(map(int, input().split()))\n\nresult = 0\n\nfor i in range(n):\n\n  if v[i] > c[i]:\n\n    result += v[i] - c[i]\n\nprint(result)", "generated_code": "N, M = list(map(int, input().split()))\n\nA = sorted(list(map(int, input().split())))\n\nquery = []\n\nfor i in range(M):\n\n    b, c = list(map(int, input().split()))\n\n    query.append([b, c])\n\nquery.sort(key=lambda q: q[1], reverse=True)\n\n\n\n\n\ni = 0\n\nfor b, c in query:\n\n    while i < N and b > 0:\n\n        if A[i] < c:\n\n            A[i] = c\n\n            b -= 1\n\n        i += 1\n\n\n\nprint((sum(A)))\n", "score": 0.0, "codebleu": 0.369957003553929, "crystalbleu": 0.12757644211514027, "codebertscore": 0.81, "codescore": 0.4461030960083008, "surfaceSim": 0.5988063660477454, "abs_surfaceSim_minus_score": 0.5988063660477454}
{"golden_code": "from bisect import bisect_right\n\nimport sys\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\nreadlines = sys.stdin.readlines\n\n\n\ndef main():\n\n    x = int(readline())\n\n\n\n    for a in range(-120, 120):\n\n        for b in range(-120, 120):\n\n            if a**5 - b**5 == x:\n\n                print((a, b))\n\n                exit()\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "generated_code": "n = int(eval(input()))\n\nA = list(map(int, input().split()))\n\nB = list(map(int, input().split()))\n\na1 = sum(A)\n\nfor i in range(n):\n\n  b = B[i]\n\n  if A[i] >= b:A[i] -= b\n\n  else:\n\n    if A[i+1]+A[i] >= b:\n\n      A[i+1] = A[i+1]+A[i]-b\n\n      A[i] = 0\n\n    else:A[i], A[i+1] = 0, 0\n\na2 = sum(A)\n\nprint((a1-a2))", "score": 0.0, "codebleu": 0.17633096616415928, "crystalbleu": 0.016440379113288245, "codebertscore": 0.71, "codescore": 0.3476462960243225, "surfaceSim": 0.46316614420062696, "abs_surfaceSim_minus_score": 0.46316614420062696}
{"golden_code": "s=eval(input())\n\nt=eval(input())\n\ns*=2\n\nnext=[[-1]*26 for _ in range(len(s))]\n\nalph=[[]for _ in range(26)]\n\nfor i in range(len(s)):\n\n\talph[ord(s[i])-ord(\"a\")].append(i)\n\nfrom bisect import bisect_right\n\nfor i in range(len(s)//2):\n\n\tfor j in range(26):\n\n\t\tif len(alph[j])>bisect_right(alph[j],i):\n\n\t\t\tnext[i][j]=alph[j][bisect_right(alph[j],i)]\n\nans=1\n\nnow=len(s)//2-1\n\nfor x in t:\n\n\tr=ord(x)-ord(\"a\")\n\n\tnow=next[now][r]\n\n\tif now==-1:\n\n\t\tprint((-1))\n\n\t\texit()\n\n\tif now>=len(s)//2:\n\n\t\tans+=len(s)//2\n\n\t\tnow-=len(s)//2\n\nprint((ans+now-len(s)//2))", "generated_code": "N = int(eval(input()))\n\nA = [int(i) for i in input().split()]\n\nB = [int(i) for i in input().split()]\n\n\n\ncnt = 0\n\nfor i in range(N):\n\n    if B[i] >= A[i]:\n\n        cnt += A[i]\n\n        B[i] -= A[i]\n\n    else:\n\n        cnt += B[i]\n\n        B[i] = 0\n\n    if B[i] == 0:\n\n        continue\n\n    if B[i] >= A[i+1]:\n\n        cnt += A[i+1]\n\n        A[i+1] = 0\n\n    else:\n\n        cnt += B[i]\n\n        A[i+1] -= B[i]\n\n\n\nprint(cnt)", "score": 0.0, "codebleu": 0.11733789604597264, "crystalbleu": 0.06299235241656424, "codebertscore": 0.73, "codescore": 0.8604477047920227, "surfaceSim": 0.5307134794748412, "abs_surfaceSim_minus_score": 0.5307134794748412}
{"golden_code": "#template\n\ndef inputlist(): return [int(j) for j in input().split()]\n\n#template\n\n#issueから始める\n\nK,N = inputlist()\n\nA = inputlist()\n\nlia = [0]*N\n\nfor i in range(1,N):\n\n    k = A[i] - A[i-1]\n\n    lia[i] = k\n\nlia[0] = (K+A[0]-A[-1])\n\nlia.sort()\n\nans = 0\n\nfor i in range(N-1):\n\n    ans += lia[i]\n\nprint(ans)", "generated_code": "N,M,K = list(map(int,input().split()))\n\n\n\nfor i in range(N+1):\n\n    for j in range(M+1):\n\n        if i*(M-j) + j*(N-i) == K:\n\n            print('Yes')\n\n            exit()\n\nprint('No')", "score": 0.0, "codebleu": 0.14797203795204555, "crystalbleu": 0.088240196130564, "codebertscore": 0.78, "codescore": 0.8351613879203796, "surfaceSim": 0.5127735135754382, "abs_surfaceSim_minus_score": 0.5127735135754382}
{"golden_code": "#! /usr/bin/env python3\n\n\n\nimport sys\n\nint1 = lambda x: int(x) - 1\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\nsys.setrecursionlimit(500000)\n\n\n\n\n\ndef isMultiple(s, m):\n\n    tmp = 0\n\n    for i in range(len(s)):\n\n        tmp = (tmp * 10 + int(s[i])) % m\n\n        if tmp == 0:\n\n            return i\n\n    return -1\n\n\n\n\n\nk = int(readline())\n\nacc = \"7\" * 50000000\n\nif k % 2 == 0:\n\n    ans = -1\n\nelse:\n\n\n\n    ans = isMultiple(acc, k)\n\n    if ans != -1:\n\n        ans += 1\n\n\n\nprint(ans)\n", "generated_code": "k,n = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\nb = [0 for i in range(n)]\n\nfor i in range(0,n-1):\n\n  b[i] = a[i+1] -a[i]\n\n\n\nb[n-1] = k - a[n-1] + a[0]\n\nans = k - max(b)\n\nprint((int(ans)))", "score": 0.0, "codebleu": 0.11408855876074954, "crystalbleu": 0.0409258854868757, "codebertscore": 0.7, "codescore": 0.05906085669994354, "surfaceSim": 0.4581572960675983, "abs_surfaceSim_minus_score": 0.4581572960675983}
{"golden_code": "import sys\n\ncan = True; eval(input())\n\ne = [[0, 0, 0]] + [list(map(int, e.split())) for e in sys.stdin]\n\nfor a, b in zip(e[1:], e):\n\n    t = a[0] - b[0] - abs(a[1] - b[1]) - abs(a[2] - b[2])\n\n    if t < 0 or t % 2 == 1: can = False; break\n\nprint((['No', 'Yes'][can]))", "generated_code": "#!/usr/bin/env python3\n\nimport sys\n\ninput = sys.stdin.readline\n\ndef INT(): return int(eval(input()))\n\ndef MAP(): return list(map(int,input().split()))\n\ndef LI(): return list(map(int,input().split()))\n\n\n\nclass UnionFind():\n\n    def __init__(self, n):\n\n        self.n = n\n\n        self.parents = [-1] * n\n\n        \n\n    def find(self, x): # 根を探す\n\n        if self.parents[x] < 0:\n\n            return x\n\n        else:\n\n            self.parents[x] = self.find(self.parents[x])\n\n            return self.parents[x]\n\n    \n\n    def union(self, x, y):\n\n        x = self.find(x)\n\n        y = self.find(y)\n\n        \n\n        if x == y:\n\n            return\n\n        \n\n        if self.parents[x] > self.parents[y]:\n\n            x, y = y, x\n\n        \n\n        self.parents[x] += self.parents[y]\n\n        self.parents[y] = x\n\n    \n\n    def size(self, x):\n\n        return -self.parents[self.find(x)]\n\n        \n\n    def same(self, x, y):\n\n        return self.find(x) == self.find(y)\n\n    \n\n    def members(self, x):\n\n        root = self.find(x)\n\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    \n\n    def roots(self):\n\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n\n\n    def group_count(self):\n\n        return len(self.roots())\n\n    \n\n    def all_group_members(self):\n\n        return {r: self.members(r) for r in self.roots()}\n\n    \n\n    def __str__(self):\n\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n\n\ndef main():\n\n    N,M=MAP()\n\n    \n\n    edges = []\n\n    for _ in range(M):\n\n        a,b = MAP()\n\n        edges.append((a-1,b-1))\n\n\n\n    answer = 0\n\n    for i in range(M): # i番目の辺を使わない\n\n        uf = UnionFind(N)\n\n\n\n        for j in range(M):\n\n            if i == j:\n\n                continue\n\n\n\n            a,b = edges[j]\n\n            uf.union(a,b)\n\n        if uf.group_count() > 1:\n\n            answer += 1\n\n    print(answer)\n\n    return\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 0.0, "codebleu": 0.2073651755883408, "crystalbleu": 0.048122893792815334, "codebertscore": 0.67, "codescore": 0.322467178106308, "surfaceSim": 0.5116637586940415, "abs_surfaceSim_minus_score": 0.5116637586940415}
{"golden_code": "import numpy as np\n\nN = int(eval(input()))\n\nabc = []\n\nfor i in range(N):\n\n    abc.append(list(map(int, input().split())))\n\n    \n\ndp = np.zeros(shape=(N, 3), dtype=int)\n\ndp[0, :] = abc[0]\n\nfor i in range(N-1):\n\n    dp[i+1, 0] = max(dp[i+1, 0], dp[i, 1] + abc[i+1][0], dp[i, 2] + abc[i+1][0])\n\n    dp[i+1, 1] = max(dp[i+1, 1], dp[i, 0] + abc[i+1][1], dp[i, 2] + abc[i+1][1])\n\n    dp[i+1, 2] = max(dp[i+1, 2], dp[i, 0] + abc[i+1][2], dp[i, 1] + abc[i+1][2])\n\nprint((max(dp[N-1, :])))", "generated_code": "import sys\n\ninput = sys.stdin.readline\n\n\n\nn, m = list(map(int, input().split()))\n\nbroken = set([int(eval(input())) for _ in range(m)]) # ここが'list'だとPypyでも通らない\n\n\n\ndef ptn_num(x): # 'x'stepまでのパターン数\n\n    dp = [0] * (x+1) # DP枠_including step'0'\n\n    if 1 in broken: # 固定部分_in case, step'1' broken \n\n        dp[:2] = 1, 0\n\n    else:\n\n        dp[:2] = 1, 1 # 固定部分_Usually\n\n\n\n    for i in range(2, x+1):\n\n        if i not in broken: # 階段が壊れてない場合...\n\n            dp[i] = (dp[i-1] + dp[i-2]) % (10**9+7) # -1段目と-2段目の合計\n\n    print((dp[-1]))\n\n\n\nptn_num(n)", "score": 0.0, "codebleu": 0.1426042393025268, "crystalbleu": 0.12131129380315105, "codebertscore": 0.73, "codescore": 0.8193959593772888, "surfaceSim": 0.536493374108053, "abs_surfaceSim_minus_score": 0.536493374108053}
{"golden_code": "import math\n\nn = int(eval(input()))\n\n\n\nans = math.factorial(n)  # nの階乗を計算\n\n\n\nif ans >= (10 ** 9)+7:\n\n    ans = ans % ((10 ** 9)+7)\n\n\n\nprint(ans)\n", "generated_code": "import sys\n\nans = 'Yes'; eval(input())\n\nfor e in sys.stdin:\n\n    t, x, y = list(map(int, e.split()))\n\n    t = t - x - y\n\n    if t < 0 or t % 2 == 1: ans = 'No'; break\n\nprint(ans)", "score": 0.0, "codebleu": 0.17643144267097688, "crystalbleu": 0.0, "codebertscore": 0.74, "codescore": 0.980633556842804, "surfaceSim": 0.5525064822817631, "abs_surfaceSim_minus_score": 0.5525064822817631}
{"golden_code": "S = int(eval(input()))\n\nMOD = 10 ** 9 + 7\n\n\n\n#dp[i]最後に切った場所がi　スタートが1なのは、そこまでの切り方が1通りなので\n\n#３以下はダメなので、3個前の結果を見るようにする\n\ndp =  [0] * (S+1)\n\ndp[0] = 1\n\n\n\nfor i in range(1, S+1):\n\n    #たとえばi=6のとき、i=6で初めて切れ目を入れる時で＋１、i=3に切れ目をいれるときで＋１で合計＋２\n\n    for j in range(0, (i-3)+1):\n\n        dp[i] += dp[j]\n\n        dp[i] %= MOD\n\nprint((dp[S]))        ", "generated_code": "# vim: fileencoding=utf-8\n\n\n\n\n\ndef main():\n\n    a, b = list(map(int, input().split()))\n\n    c = 0\n\n    for i in range(a, b + 1):\n\n        #     s = str(i)\n\n        #     r = \"\".join(reversed(list(s)))\n\n        #     if s == r:\n\n        #         c += 1\n\n        if (i % 10) == (i // 10000 % 10) and (i // 10 % 10) == (i // 1000 % 10):\n\n            c += 1\n\n    print(c)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "score": 0.0, "codebleu": 0.11545356904499826, "crystalbleu": 0.0, "codebertscore": 0.65, "codescore": 0.018475014716386795, "surfaceSim": 0.5703849044001001, "abs_surfaceSim_minus_score": 0.5703849044001001}
{"golden_code": "N,K=list(map(int,input().split()))\n\n\n\ncon = 0\n\nans = list(int() for _ in range(100000))\n\npre = 0\n\n\n\n\n\nfor _ in range(K):\n\n\n\n    D = int(eval(input()))\n\n    arr = list(map(int,input().split()))\n\n\n\n    for j in range(D):\n\n\n\n        ans[pre+j]=arr[j]\n\n\n\n    pre += D\n\n\n\n        \n\nfin = (N+1) - len(set(ans))\n\n\n\nprint(fin)", "generated_code": "M = 1000000007\n\nn=int(eval(input()))\n\nf = 1\n\nfor i in range(1, n + 1):  \n\n    f = (f * i) % M \n\nprint(f)", "score": 0.0, "codebleu": 0.14848961819174825, "crystalbleu": 0.0, "codebertscore": 0.76, "codescore": 0.2575733959674835, "surfaceSim": 0.49303683737646004, "abs_surfaceSim_minus_score": 0.49303683737646004}
{"golden_code": "import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\nN = int(readline())\n\nAB = [list(map(int,readline().split())) for i in range(N-1)]\n\n\n\ngraph = [[] for _ in range(N+1)] #隣接リスト\n\nfor a,b in AB:\n\n    graph[a].append(b)\n\n    graph[b].append(a)\n\n\n\n#親のノードに子を入れてくdfs\n\nstack = [1]\n\nparent = [0]*(N+1)\n\norder = []\n\nwhile stack:\n\n    x = stack.pop()\n\n    order.append(x)\n\n    for i in graph[x]:\n\n        if i == parent[x]:\n\n            continue\n\n        parent[i] = x\n\n        stack.append(i)\n\n\n\n#各子の色を決めていく。\n\ncolor = [-1]*(N+1)\n\nfor x in order:\n\n    ng = color[x]\n\n    c = 1\n\n    for y in graph[x]:\n\n        if parent[x] == y:\n\n            continue\n\n        if c == ng:\n\n            c += 1\n\n        color[y] = c\n\n        c += 1\n\n\n\nans = []\n\nfor a,b in AB:\n\n    if parent[a] == b: #子の頂点の色を入れる\n\n        ans.append(color[a])\n\n    else:\n\n        ans.append(color[b])\n\n\n\nprint((max(ans)))\n\nfor i in ans:\n\n    print(i)\n\n        \n", "generated_code": "import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\n\"\"\"\n\n・偶数番号、奇数番号の中では入れ替え放題\n\n・偶、奇の間：並べてからスワップ。操作2を1回で、正しいものを2つ増やせる\n\n\"\"\"\n\n\n\nN,*A = list(map(int,read().split()))\n\n\n\nx_to_i = {x:i for i,x in enumerate(sorted(A))}\n\nrank = [x_to_i[x] for x in A]\n\n\n\nanswer = sum((x^i) & 1 for i,x in enumerate(rank)) // 2\n\nprint(answer)", "score": 0.0, "codebleu": 0.18212791179966295, "crystalbleu": 0.053673551940369185, "codebertscore": 0.74, "codescore": 0.4357196092605591, "surfaceSim": 0.5081923293852229, "abs_surfaceSim_minus_score": 0.5081923293852229}
{"golden_code": "N = int(eval(input()))\n\np = 1\n\nfor i in range(N):\n\n    p *= (i + 1)\n\n    p %= (1e9 + 7)\n\nprint((int(p)))", "generated_code": "import sys\n\ninput = sys.stdin.readline\n\nsys.setrecursionlimit(10**7)\n\nINF = 10**10\n\nMOD = 10**9 + 7\n\nX = int(eval(input()))\n\nMAX_X = 10**9\n\nn = 0\n\nwhile(1):\n\n    n+=1\n\n    if n**5 - (n-1)**5 > MAX_X:\n\n        break\n\nfor i in range(n):\n\n    for j in range(-n+1,n-1):\n\n        if i**5 - j**5 == X:\n\n            print((i,j))\n\n            exit()\n\n   ", "score": 0.0, "codebleu": 0.2940114933085147, "crystalbleu": 0.0, "codebertscore": 0.73, "codescore": 0.2363208681344986, "surfaceSim": 0.4426094137076796, "abs_surfaceSim_minus_score": 0.4426094137076796}
{"golden_code": "import sys\n\nimport itertools\n\nfrom operator import itemgetter #sortedの対象を決めたい\n\nfrom fractions import gcd #最大公約数\n\nfrom math import ceil, floor, sqrt, isinf #小数点切り上げ、切り捨て、平方根\n\nfrom copy import deepcopy #参照で影響されないコピー\n\nfrom collections import Counter, deque #要素ごとの出現回数、双方向アクセス可能データ型\n\nimport heapq\n\nimport numpy as np\n\nfrom functools import reduce\n\nsys.setrecursionlimit(200000)\n\n\n\ninput = sys.stdin.readline\n\n# template\n\n\n\ndef retmax(a, b):\n\n    if a > b:\n\n        return a\n\n    else:\n\n        return b\n\n\n\ndef main():\n\n    n = int(eval(input()))\n\n    a = [list(map(int, input().split())) for _ in range(n)]\n\n\n\n    dp = np.zeros([3, n+1])\n\n\n\n    for i, a_l in enumerate(a):\n\n        for j in range(3):\n\n            for k in range(3):\n\n                if j != k:\n\n                    dp[k, i+1] = retmax(dp[k, i+1], dp[j, i] + a_l[k])\n\n\n\n    print((int(np.max(dp[:, n], axis=0))))\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n\n\n", "generated_code": "N = int(eval(input()))\n\n\n\ncount = 0\n\nfor i in range(1, N + 1):\n\n    if len(str(i)) % 2 != 0:\n\n        count += 1\n\nprint(count)", "score": 0.0, "codebleu": 0.0709087145985153, "crystalbleu": 0.004096002685482535, "codebertscore": 0.59, "codescore": 0.42193183302879333, "surfaceSim": 0.4068403908794788, "abs_surfaceSim_minus_score": 0.4068403908794788}
{"golden_code": "n = int(eval(input()))\n\na = [int(x) for x in input().split()]\n\n\n\nans = list(range(n))\n\n\n\nfor i in range(n):\n\n    ans[a[i]-1] = i+1\n\n    \n\nprint((' '.join(map(str,ans))))", "generated_code": "import re\n\n\n\ns = eval(input())\n\n\n\nif re.fullmatch(r\"(dream|dreamer|erase|eraser)+\", s):\n\n    print(\"YES\")\n\nelse:\n\n    print(\"NO\")", "score": 0.0, "codebleu": 0.09918975007517696, "crystalbleu": 0.0, "codebertscore": 0.69, "codescore": 0.05740327015519142, "surfaceSim": 0.41730769230769227, "abs_surfaceSim_minus_score": 0.41730769230769227}
