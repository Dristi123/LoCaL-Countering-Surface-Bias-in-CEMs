{"golden_code": "import numpy as np\n\n\n\nn = int(eval(input()))\n\nX = np.array([input().split() for _ in range(n)], np.int64)\n\ndp = np.zeros((n + 1, 3), np.int64)\n\ndp[0, 0] = dp[0, 1] = dp[0, 2] = 0\n\nfor i in range(n):\n\n    for j in range(3):\n\n        dp[i + 1, j] = X[i, j] + max(dp[i, k] for k in range(3) if j != k)\n\nprint((max(dp[n])))", "generated_code": "N = int(eval(input()))\n\nx, y, z = 0, 0, 0\n\nfor _ in range(N):\n\n    a, b, c = list(map(int, input().split()))\n\n    x, y, z = max(y, z) + a, max(z, x) + b, max(x, y) + c\n\nprint((max(x, y, z)))", "score": 1.0, "codebleu": 0.10661594469023415, "crystalbleu": 0.132820317954808, "codebertscore": 0.76, "codescore": 0.38032183051109314, "surfaceSim": 0.5242946708463949, "abs_surfaceSim_minus_score": 0.4757053291536051}
{"golden_code": "while True:\n\n    try:\n\n        for i in range(3):\n\n            line = input().strip()\n\n            if line == '0':\n\n                raise Exception\n\n\n\n            a = b = 0\n\n            for i, s in enumerate(line):\n\n                if i != 0:\n\n                    if s == 'A':\n\n                        a += 1\n\n                    else:\n\n                        b += 1\n\n            if a > b:\n\n                a += 1\n\n            else:\n\n                b += 1\n\n            print(a, b)\n\n\n\n    except:\n\n        break", "generated_code": "while True:\n\n    try:\n\n        for i in range(3):\n\n            line = input().strip()\n\n            if line == '0':\n\n                raise Exception\n\n\n\n            if line[0] == 'A':\n\n                a = -1\n\n                b = 0\n\n            else:\n\n                a = 0\n\n                b = -1\n\n            for i, s in enumerate(line):\n\n                if s == 'A':\n\n                    a += 1\n\n                else:\n\n                    b += 1\n\n            if a > b:\n\n                a += 1\n\n            else:\n\n                b += 1\n\n            print(a, b)\n\n\n\n    except:\n\n        break", "score": 1.0, "codebleu": 0.6846088753676057, "crystalbleu": 0.7205067144620672, "codebertscore": 0.95, "codescore": 0.987352728843689, "surfaceSim": 0.8718141870684244, "abs_surfaceSim_minus_score": 0.1281858129315756}
{"golden_code": "import sys\n\nK = int(eval(input()))\n\n\n\npower = 7\n\nSUM = 0\n\n\n\nfor i in range(1, 10 ** 6):\n\n    SUM += power\n\n    if SUM % K == 0:\n\n        print(i)\n\n        sys.exit()\n\n    power *= 10\n\n    power %= K\n\n\n\nprint((-1))", "generated_code": "import sys\n\nK = int(eval(input()))\n\n\n\nL = 9 * K\n\n\n\nif K % 7 == 0:\n\n    L //= 7\n\n\n\npower = 1\n\n\n\nfor i in range(1, 10 ** 6):\n\n    power *= 10\n\n    power %= L\n\n    if power == 1:\n\n        print(i)\n\n        sys.exit()\n\n\n\nprint((-1))", "score": 1.0, "codebleu": 0.588523077329871, "crystalbleu": 0.0, "codebertscore": 0.92, "codescore": 0.8256010413169861, "surfaceSim": 0.8223684210526316, "abs_surfaceSim_minus_score": 0.17763157894736836}
{"golden_code": "import numpy as np\n\n\n\nn = int(eval(input()))\n\ninput_X = [[int(i) for i in input().split()] for i in range(n)]\n\nX = np.array(input_X)\n\n\n\npre_t = 0\n\npre_x = 0\n\npre_y = 0\n\nfor i in range(n):\n\n    x_move = abs(X[i][1] - pre_x)\n\n    y_move = abs(X[i][2] - pre_y)\n\n    xy_sum = x_move + y_move\n\n    spend_time = X[i][0]-pre_t\n\n    if xy_sum%2 == spend_time%2 and spend_time >= xy_sum:\n\n        pre_t = X[i][0]\n\n        pre_x = X[i][1]\n\n        pre_y = X[i][2]\n\n        if i+1 == n:\n\n            print('Yes')\n\n        else:\n\n            continue\n\n    else:\n\n        print('No')\n\n        break", "generated_code": "# C\n\nimport copy\n\nn = int(eval(input()))\n\npreX = [0,0,0]\n\nans = True\n\nfor i in range(n):\n\n    curX = list(map(int, input().split()))\n\n    dt = curX[0] - preX[0]\n\n    dx = abs(curX[1] - preX[1])\n\n    dy = abs(curX[2] - preX[2])\n\n    if dt < dx + dy  or (dt % 2) != ((dx + dy) % 2):\n\n        ans = False\n\n    preX = copy.copy(curX)\n\nif ans:\n\n    print('Yes')\n\nelse:\n\n    print('No')", "score": 1.0, "codebleu": 0.18810995152329993, "crystalbleu": 0.19964449814335486, "codebertscore": 0.82, "codescore": 0.9936721324920654, "surfaceSim": 0.6084668803418803, "abs_surfaceSim_minus_score": 0.39153311965811965}
{"golden_code": "I=lambda:list(map(int,input().split()))\n\nn,m=I()\n\na=I()\n\na.sort(reverse=True)\n\nqq=[I() for i in range(m)]\n\nqq.sort(key=lambda x:x[1],reverse=True)\n\nans=0\n\nfor x,y in qq:\n\n    for j in range(x):\n\n        if not a:\n\n            break\n\n        aa=a.pop()\n\n        ans+=max(aa,y)\n\nans+=sum(a)\n\nprint(ans)\n\n        ", "generated_code": "I=lambda : list(map(int,input().split()))\n\nn,m = I()\n\nl=I();s=sum(l);l.sort();d=[]\n\nfor _ in range(m):\n\n    b,c=I()\n\n    d.append([c,b])\n\np=s=0    \n\nfor i in sorted(d,reverse=True):\n\n    while i[1]:\n\n        if p>=n or l[p]>=i[0]:\n\n            break\n\n        i[1]-=1\n\n        s+=i[0]\n\n        p+=1\n\n    if p>=n:\n\n        break\n\ns+=sum(l[p:])\n\nprint(s)", "score": 1.0, "codebleu": 0.31348662221845847, "crystalbleu": 0.260234315185881, "codebertscore": 0.82, "codescore": 0.9500077962875366, "surfaceSim": 0.6064491064491064, "abs_surfaceSim_minus_score": 0.39355089355089357}
{"golden_code": "import sys\n\ninput = sys.stdin.readline\n\nimport numpy as np\n\nN = int(eval(input()))\n\nS = [[] for _ in range(N)]\n\nfor i in range(N):\n\n    A = int(eval(input()))\n\n    temp = []\n\n    for _ in range(A):\n\n        temp.append([str(x) for x in input().split()])\n\n        S[i] = temp\n\nans = 0\n\nfor i in range(2 ** N - 1, -1,-1):\n\n    biti = list(bin(i)[2:].zfill(N))\n\n    flag = 0\n\n    for j in range(N):\n\n        if biti[j] == \"1\":\n\n            for k in S[j]:\n\n                if biti[int(k[0])-1] != k[1]:\n\n                    flag = 1\n\n                    break\n\n        if flag:\n\n            break\n\n    if not flag:    \n\n        biti = np.array(biti)\n\n        ans = max(ans, np.count_nonzero(biti == \"1\"))\n\nprint(ans)", "generated_code": "import sys\n\ninput = sys.stdin.readline\n\n\n\nn = int(eval(input()))\n\n\n\nfrom collections import defaultdict\n\nd = defaultdict(list)\n\n\n\nfor i in range(n):\n\n    a = int(eval(input()))\n\n    for _ in range(a):\n\n        x, y = [int(x) for x in input().split()]\n\n        d[i].append((x - 1, y))\n\nans = 0\n\nfor k in range(2**n):\n\n    res = 0\n\n    j = bin(k)[2:].zfill(n)\n\n    flag = 1\n\n    for i in range(n):\n\n        if j[i] == \"0\":\n\n            continue\n\n        for x, y in d[i]:\n\n            if int(j[x]) != int(y):\n\n                flag = 0\n\n                break\n\n        res += 1\n\n    if flag:\n\n        ans = max(ans, res)\n\nprint(ans)", "score": 1.0, "codebleu": 0.3359080384678641, "crystalbleu": 0.33262410786032387, "codebertscore": 0.87, "codescore": 0.8932512402534485, "surfaceSim": 0.7075346992729676, "abs_surfaceSim_minus_score": 0.29246530072703236}
{"golden_code": "# ABC 155 C\n\nfrom collections import Counter\n\nimport numpy as np\n\nN = int(eval(input()))\n\nS = [str(eval(input())) for i in range(N)]\n\nS = np.array(S)\n\n\n\ncount = Counter(S)\n\nmax_num = max(count.values())\n\nmax_list = [i for i,j in list(count.items()) if j==max_num]\n\n\n\nmax_list.sort()\n\nprint(('\\n'.join(max_list)))", "generated_code": "import sys\n\nfrom collections import Counter\n\nN = int(sys.stdin.readline())\n\nS = sys.stdin.read().split()\n\n\n\ncount = Counter(S)\n\nmax_num = max(count.values())\n\nmax_list = [i for i,j in list(count.items()) if j==max_num]\n\n \n\nmax_list.sort()\n\nprint(('\\n'.join(max_list)))", "score": 1.0, "codebleu": 0.5017047235416202, "crystalbleu": 0.0, "codebertscore": 0.9, "codescore": 0.6619806885719299, "surfaceSim": 0.8846153846153846, "abs_surfaceSim_minus_score": 0.11538461538461542}
{"golden_code": "import sys\n\nimport numpy as np \n\n\n\nn, l = list(map(int, sys.stdin.readline().split()))\n\n\n\ndef main():\n\n    f = l + np.arange(1, n+1) - 1\n\n    s = f.sum()\n\n    a = np.absolute(f)\n\n    mi = np.amin(a)\n\n    i = np.argwhere(a == mi)[0, 0]\n\n    return s - f[i]\n\n\n\nif __name__ == '__main__':\n\n    ans = main()\n\n    print(ans)", "generated_code": "import sys\n\n\n\nn, l = list(map(int, sys.stdin.readline().split()))\n\n\n\ndef main():\n\n    s = (l - 1) * n + (1 + n) * n // 2\n\n    res = []\n\n    for i in range(1, n+1):\n\n        f = l + i - 1\n\n        res.append((abs(f), s - f))\n\n    \n\n    res.sort()\n\n    return res[0][1]\n\n\n\nif __name__=='__main__':\n\n    ans = main()\n\n    print(ans)", "score": 1.0, "codebleu": 0.36882509177801026, "crystalbleu": 0.3441407826763586, "codebertscore": 0.87, "codescore": 0.018559522926807404, "surfaceSim": 0.7693909715186311, "abs_surfaceSim_minus_score": 0.23060902848136888}
{"golden_code": "import sys\n\nread = sys.stdin.readline\n\n\n\n\n\ndef read_ints():\n\n    return list(map(int, read().split()))\n\n\n\n\n\ndef read_a_int():\n\n    return int(read())\n\n\n\n\n\ndef read_matrix(H):\n\n    '''\n\n    H is number of rows\n\n    '''\n\n    return [list(map(int, read().split())) for _ in range(H)]\n\n\n\n\n\ndef read_map(H):\n\n    '''\n\n    H is number of rows\n\n    文字列で与えられた盤面を読み取る用\n\n    '''\n\n    return [read()[:-1] for _ in range(H)]\n\n\n\n\n\ndef read_tuple(H):\n\n    '''\n\n    H is number of rows\n\n    '''\n\n    ret = []\n\n    for _ in range(H):\n\n        ret.append(tuple(map(int, read().split())))\n\n    return ret\n\n\n\n\n\ndef read_col(H, n_cols):\n\n    '''\n\n    H is number of rows\n\n    n_cols is number of cols\n\n\n\n    A列、B列が与えられるようなとき\n\n    '''\n\n    ret = [[] for _ in range(n_cols)]\n\n    for _ in range(H):\n\n        tmp = list(map(int, read().split()))\n\n        for col in range(n_cols):\n\n            ret[col].append(tmp[col])\n\n\n\n    return ret\n\n\n\n\n\nN, K = read_ints()\n\nP = read_ints()\n\n\n\n\n\ndef ret_mean(X):\n\n    return (X + 1) / 2\n\n\n\n\n\n\n\n\n\nimport numpy as np\n\nP_mean = np.array([ret_mean(p) for p in P])\n\nP_accum = np.zeros(N+1)\n\nP_accum[1:] = P_mean.cumsum()\n\n\n\nans = 0\n\n# print(P_accum)\n\nfor i in range(N - K + 1):\n\n    j = i + K\n\n    ans = max(ans, P_accum[j] - P_accum[i])\n\nprint(ans)\n", "generated_code": "import sys\n\nread = sys.stdin.readline\n\n\n\n\n\ndef read_ints():\n\n    return list(map(int, read().split()))\n\n\n\n\n\ndef read_a_int():\n\n    return int(read())\n\n\n\n\n\ndef read_matrix(H):\n\n    '''\n\n    H is number of rows\n\n    '''\n\n    return [list(map(int, read().split())) for _ in range(H)]\n\n\n\n\n\ndef read_map(H):\n\n    '''\n\n    H is number of rows\n\n    文字列で与えられた盤面を読み取る用\n\n    '''\n\n    return [read()[:-1] for _ in range(H)]\n\n\n\n\n\ndef read_tuple(H):\n\n    '''\n\n    H is number of rows\n\n    '''\n\n    ret = []\n\n    for _ in range(H):\n\n        ret.append(tuple(map(int, read().split())))\n\n    return ret\n\n\n\n\n\ndef read_col(H, n_cols):\n\n    '''\n\n    H is number of rows\n\n    n_cols is number of cols\n\n\n\n    A列、B列が与えられるようなとき\n\n    '''\n\n    ret = [[] for _ in range(n_cols)]\n\n    for _ in range(H):\n\n        tmp = list(map(int, read().split()))\n\n        for col in range(n_cols):\n\n            ret[col].append(tmp[col])\n\n\n\n    return ret\n\n\n\n\n\nN, K = read_ints()\n\nP = read_ints()\n\n\n\n\n\ndef ret_mean(X):\n\n    return (X + 1) / 2\n\n\n\n\n\n\n\nclass cumsum1d:\n\n    def __init__(self, ls: list):\n\n        '''\n\n        1次元リストを受け取る\n\n        '''\n\n        from itertools import accumulate\n\n        self.ls_accum = [0] + list(accumulate(ls))\n\n\n\n    def total(self, i, j):\n\n        # もとの配列lsにおける[i,j)の中合計\n\n        return self.ls_accum[j] - self.ls_accum[i]\n\n      \n\nP_mean = [ret_mean(p) for p in P]\n\nP_accum = cumsum1d(P_mean)\n\n\n\nans = 0\n\n# print(P_accum)\n\nfor i in range(N - K + 1):\n\n    j = i + K\n\n    ans = max(ans, P_accum.total(i,j))\n\nprint(ans)\n", "score": 1.0, "codebleu": 0.8474133660024165, "crystalbleu": 0.7401668573263896, "codebertscore": 0.95, "codescore": 0.9924782514572144, "surfaceSim": 0.8972121341593676, "abs_surfaceSim_minus_score": 0.10278786584063238}
{"golden_code": "from collections import defaultdict\n\nN = int(eval(input()))\n\nd = defaultdict(int)\n\n\n\nfor i in range(N):\n\n    S = eval(input())\n\n    d[S] += 1\n\n\n\nm = 0\n\nfor k in list(d.keys()):\n\n    m = max(d[k],m)\n\n\n\nli = []\n\nfor k in list(d.keys()):\n\n    if d[k] == m:\n\n        li.append(k)\n\n\n\nli.sort()\n\nfor l in li:\n\n    print(l)", "generated_code": "from collections import defaultdict\n\nN = int(eval(input()))\n\nSs = [eval(input()) for i in range(N)]\n\n\n\nd = defaultdict(int)\n\nfor S in Ss:\n\n    d[S] += 1\n\n\n\nmx = max([d[k] for k in list(d.keys())])\n\n\n\nans = []\n\nfor k in list(d.keys()):\n\n    if d[k] == mx:\n\n       ans.append(k)\n\n       \n\nfor a in sorted(ans):\n\n    print(a)", "score": 1.0, "codebleu": 0.5354580236609368, "crystalbleu": 0.5250993742678821, "codebertscore": 0.93, "codescore": 0.9415095448493958, "surfaceSim": 0.8272162619988708, "abs_surfaceSim_minus_score": 0.17278373800112923}
{"golden_code": "n=int(eval(input()))-1\n\nA=list(map(int,input().split()))\n\ni=0\n\nfor j in range(n):\n\n if A[j]<=A[-1]:A[i],A[j]=A[j],A[i];i+=1\n\nA[i],A[n]=A[n],A[i]\n\nprint((\" \".join(map(str,A[:i]))+\" [\"+str(A[i])+\"] \"+\" \".join(map(str,A[i+1:]))))\n", "generated_code": "def s():\n\n n=int(eval(input()))-1\n\n A=list(map(int,input().split()))\n\n i=0\n\n for j in range(n):\n\n  if A[j]<=A[-1]:A[i],A[j]=A[j],A[i];i+=1\n\n A[i],A[n]=A[n],A[i]\n\n print((\" \".join(map(str,A[:i]))+\" [\"+str(A[i])+\"] \"+\" \".join(map(str,A[i+1:]))))\n\nif'__main__'==__name__:s()\n", "score": 1.0, "codebleu": 0.761225081477092, "crystalbleu": 0.7977354133096679, "codebertscore": 0.97, "codescore": 0.9917625188827515, "surfaceSim": 0.8779694570135747, "abs_surfaceSim_minus_score": 0.12203054298642535}
{"golden_code": "import math\n\nx = int(eval(input()))\n\nprint((math.factorial(x) % (10**9 + 7)))", "generated_code": "n = int(eval(input()))\n\nfact = 1\n\nfor i in range(1,n+1):\n\n  fact = fact * i % (10**9 +7)\n\nres = fact % (10**9 + 7)\n\nprint(res)", "score": 1.0, "codebleu": 0.28499817494097796, "crystalbleu": 0.0, "codebertscore": 0.82, "codescore": 0.5416166186332703, "surfaceSim": 0.5791316526610644, "abs_surfaceSim_minus_score": 0.42086834733893563}
{"golden_code": "import sys\n\nimport numpy as np\n\n\n\nn = int(sys.stdin.readline().rstrip())\n\nx = []\n\ny = []\n\nfor i in range(n):\n\n    a = int(sys.stdin.readline().rstrip())\n\n    xy = [sys.stdin.readline().split() for _ in range(a)]\n\n    if not xy:\n\n        x.append(None)\n\n        y.append(None)\n\n        continue\n\n    xi, yi = np.array(xy, np.int64).T\n\n    x.append(xi-1)\n\n    y.append(yi)\n\n\n\ndef main():\n\n\n\n    ans = 0\n\n    for comb in range(2 ** n):\n\n        cnt = 0\n\n        for i in range(n):\n\n            if not comb >> i & 1:\n\n                continue\n\n            if x[i] is None:\n\n                cnt += 1\n\n                continue\n\n            if np.count_nonzero(comb >> x[i] & 1 ^ y[i]):\n\n                break\n\n            cnt += 1\n\n        else:\n\n            ans = max(ans, cnt)\n\n    return ans\n\n                \n\nif __name__ == '__main__':\n\n    ans = main()\n\n    print(ans)", "generated_code": "import sys\n\n\n\nn = int(sys.stdin.readline().rstrip())\n\nxy = [[] for _ in range(n)]\n\nfor i in range(n):\n\n    a = int(sys.stdin.readline().rstrip())\n\n    for j in range(a):\n\n        x, y = list(map(int, sys.stdin.readline().split()))\n\n        xy[i].append((x-1, y))\n\n\n\ndef main():\n\n    ans = 0\n\n    for comb in range(2 ** n):\n\n        cnt = 0\n\n        for i in range(n):\n\n            if comb >> i & 1 ^ 1:\n\n                continue\n\n            for x, y in xy[i]:\n\n                if comb >> x & 1 ^ y:\n\n                    break\n\n            else:\n\n                cnt += 1\n\n                continue\n\n            break\n\n        else:\n\n            ans = max(ans, cnt)\n\n    return ans\n\n                \n\nif __name__ == '__main__':\n\n    ans = main()\n\n    print(ans)", "score": 1.0, "codebleu": 0.5163224150671805, "crystalbleu": 0.5609972771934018, "codebertscore": 0.9, "codescore": 0.19939608871936798, "surfaceSim": 0.8333073857267406, "abs_surfaceSim_minus_score": 0.16669261427325943}
{"golden_code": "import sys\n\nimport os\n\nimport math\n\n\n\nii = lambda: int(sys.stdin.buffer.readline().rstrip())\n\nil = lambda: list(map(int, sys.stdin.buffer.readline().split()))\n\niln = lambda n: [int(sys.stdin.buffer.readline().rstrip()) for _ in range(n)]\n\n\n\niss = lambda: sys.stdin.buffer.readline().decode().rstrip()\n\nisn = lambda n: [sys.stdin.buffer.readline().decode().rstrip() for _ in range(n)]\n\n\n\n\n\ndef main():\n\n    if os.getenv(\"LOCAL\"):\n\n        sys.stdin = open(\"input.txt\", \"r\")\n\n\n\n    N = ii()\n\n    ret = float('inf')\n\n    I = int(math.sqrt(N)) * 10\n\n    for i in range(1, I):\n\n        if N%i == 0:\n\n            j = N//i\n\n            ret = min(ret, j + i - 2)\n\n\n\n    print(ret)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "generated_code": "import sys\n\nimport os\n\n\n\nii = lambda: int(sys.stdin.buffer.readline().rstrip())\n\nil = lambda: list(map(int, sys.stdin.buffer.readline().split()))\n\niln = lambda n: [int(sys.stdin.buffer.readline().rstrip()) for _ in range(n)]\n\n\n\niss = lambda: sys.stdin.buffer.readline().decode().rstrip()\n\nisn = lambda n: [sys.stdin.buffer.readline().decode().rstrip() for _ in range(n)]\n\n\n\n\n\ndef main():\n\n    if os.getenv(\"LOCAL\"):\n\n        sys.stdin = open(\"input.txt\", \"r\")\n\n\n\n    N = ii()\n\n    m = int(N ** .5)\n\n    while N % m != 0:\n\n        m -= 1\n\n    else:\n\n        print((int(N / m + m - 2)))\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 1.0, "codebleu": 0.6082349403553969, "crystalbleu": 0.6930299114697129, "codebertscore": 0.94, "codescore": 0.02072611078619957, "surfaceSim": 0.8094490934449093, "abs_surfaceSim_minus_score": 0.19055090655509066}
{"golden_code": "from functools import lru_cache\n\nimport sys\n\n\n\nsys.setrecursionlimit(10 ** 7)\n\n\n\n\n\n@lru_cache(maxsize=None)\n\ndef check(l, r, n, k=1):\n\n    t = l + '0' * k + r\n\n    e = l + '9' * k + r\n\n\n\n    if int(e) <= n:\n\n        return pow(10, k) + check(l, r, n, k + 1)\n\n\n\n    if int(t) <= n < int(e):\n\n        x = int(str(n)[1:-1])\n\n        if int(str(n)[-1]) < int(r):\n\n            x -= 1\n\n        return x + 1\n\n\n\n    if n < int(t):\n\n        return 0\n\n\n\n\n\ndef main():\n\n    n = int(eval(input()))\n\n\n\n    ret = 0\n\n    for x in range(1, n + 1):\n\n        if x % 10 == 0:\n\n            continue\n\n        s = str(x)\n\n        t = s[-1] + s[0]\n\n        if s[0] == s[-1]:\n\n            ret += 1\n\n        if int(t) <= n:\n\n            ret += 1\n\n        ret += check(s[-1], s[0], n, k=1)\n\n\n\n    print(ret)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "generated_code": "# 解説放送\n\n\n\ndef main():\n\n    from collections import defaultdict\n\n\n\n    n = int(eval(input()))\n\n\n\n    d = defaultdict(int)\n\n    for x in range(1, n + 1):\n\n        if x % 10 == 0:\n\n            continue\n\n\n\n        tail = x % 10\n\n        head = 0\n\n        while x:\n\n            head = x\n\n            x //= 10\n\n\n\n        d[head, tail] += 1\n\n\n\n    ret = 0\n\n    for (head, tail), cnt in tuple(d.items()):\n\n        # RuntimeError: dictionary changed size during iteration\n\n        # defaultdictの未定義(?)のkeyにアクセスするせいで、REになる\n\n        # d.items()をtuple化して回避\n\n        ret += d[head, tail] * d[tail, head]\n\n        # (head,tail)の出現数を辞書で管理する\n\n        # (head,tail)*(tail,head)の組み合わせがある\n\n\n\n    print(ret)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 1.0, "codebleu": 0.25529698486621005, "crystalbleu": 0.12295908885761007, "codebertscore": 0.7, "codescore": 0.04732915759086609, "surfaceSim": 0.603805798721053, "abs_surfaceSim_minus_score": 0.396194201278947}
{"golden_code": "#!usr/bin/env python3\n\nfrom collections import defaultdict\n\nfrom collections import deque\n\nfrom heapq import heappush, heappop\n\nimport sys\n\nimport math\n\nimport bisect\n\nimport random\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\n\ndef I(): return int(sys.stdin.readline())\n\ndef LS():return list(map(list, sys.stdin.readline().split()))\n\ndef S(): return list(sys.stdin.readline())[:-1]\n\ndef IR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = I()\n\n    return l\n\ndef LIR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = LI()\n\n    return l\n\ndef SR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = S()\n\n    return l\n\ndef LSR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = LS()\n\n    return l\n\nsys.setrecursionlimit(1000000)\n\nmod = 1000000007\n\n\n\n#A\n\ndef A():\n\n    return\n\n\n\n#B\n\ndef B():\n\n    return\n\n\n\n#C\n\ndef C():\n\n    return\n\n\n\n#D\n\ndef D():\n\n    return\n\n\n\n#E\n\ndef E():\n\n    return\n\n\n\n#F\n\ndef F():\n\n    a,b,c,X,Y = LI()\n\n    ans = float(\"inf\")\n\n    for z in range(300001):\n\n        if z%2 == 0:\n\n            m = c*z\n\n            x = z//2\n\n            y = z//2\n\n            m += a*max(0,X-x)\n\n            m += b*max(0,Y-y)\n\n            if m < ans:\n\n                ans = m\n\n    print(ans)\n\n    return\n\n\n\n#G\n\ndef G():\n\n    n = I()\n\n    x = LI()\n\n    f = [(i,x[i]) for i in range(n)]\n\n    f.sort(key = lambda x:x[1])\n\n    g = [(f[i][0],i) for i in range(n)]\n\n    g.sort(key = lambda x:x[0])\n\n    for i in range(n):\n\n        if g[i][1] < n//2:\n\n            print((f[n//2][1]))\n\n        else:\n\n            print((f[n//2-1][1]))\n\n    return\n\n\n\n#H\n\ndef H():\n\n    return\n\n\n\n#I\n\ndef I_():\n\n    return\n\n\n\n#J\n\ndef J():\n\n    return\n\n\n\n#Solve\n\nif __name__ == \"__main__\":\n\n    F()\n", "generated_code": "#!usr/bin/env python3\n\nfrom collections import defaultdict,deque\n\nfrom heapq import heappush, heappop\n\nfrom itertools import permutations\n\nimport sys\n\nimport math\n\nimport bisect\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\n\ndef I(): return int(sys.stdin.readline())\n\ndef LS():return [list(x) for x in sys.stdin.readline().split()]\n\ndef S():\n\n    res = list(sys.stdin.readline())\n\n    if res[-1] == \"\\n\":\n\n        return res[:-1]\n\n    return res\n\ndef IR(n):\n\n    return [I() for i in range(n)]\n\ndef LIR(n):\n\n    return [LI() for i in range(n)]\n\ndef SR(n):\n\n    return [S() for i in range(n)]\n\ndef LSR(n):\n\n    return [LS() for i in range(n)]\n\n\n\nsys.setrecursionlimit(1000000)\n\nmod = 1000000007\n\n\n\ndef solve():\n\n    A,B,C,x,y = LI()\n\n    ans = float(\"inf\")\n\n    for c in range(200001)[::2]:\n\n        a = b = c >> 1\n\n        a = max(0,x-a)\n\n        b = max(0,y-b)\n\n        s = A*a+B*b+C*c\n\n        if s < ans:\n\n            ans = s\n\n    print(ans)\n\n    return\n\n\n\n#Solve\n\nif __name__ == \"__main__\":\n\n    solve()\n", "score": 1.0, "codebleu": 0.300559419731317, "crystalbleu": 0.22486624152797977, "codebertscore": 0.88, "codescore": 0.02359221875667572, "surfaceSim": 0.7418803418803419, "abs_surfaceSim_minus_score": 0.2581196581196581}
{"golden_code": "import numpy as np\n\n\n\nS=eval(input())\n\nS=np.array([1 if s=='B' else 0 for s in S])\n\n\n\nprint((np.abs(np.diff(S)).sum()))\n", "generated_code": "from itertools import groupby\n\n\n\nS=eval(input())\n\nanswer = sum([1 for _ in groupby(S)]) -1\n\n\n\nprint(answer)", "score": 1.0, "codebleu": 0.20308835009201417, "crystalbleu": 0.0, "codebertscore": 0.8, "codescore": 0.07840973883867264, "surfaceSim": 0.4853070175438597, "abs_surfaceSim_minus_score": 0.5146929824561404}
{"golden_code": "import numpy as np\n\n\n\nN,M = list(map(int,input().split()))\n\n\n\nA = np.array([int(x) for x in input().split()],dtype=np.int64)\n\nA.sort()\n\n\n\nBC = np.array([[int(x) for x in input().split()] for _ in range(M)])\n\nB = BC[:,0]\n\nC = BC[:,1]\n\n\n\nidx = C.argsort()\n\nB = B[idx][::-1]\n\nC = C[idx][::-1]\n\n\n\np = 0\n\nfor b,c in zip(B,C):\n\n  A[p:p+b] = np.maximum(A[p:p+b],c)\n\n  p += b\n\n\n\nanswer = A.sum()\n\nprint(answer)\n", "generated_code": "import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\nfrom operator import itemgetter\n\n\n\nN,M = list(map(int,readline().split()))\n\nA = list(map(int,readline().split()))\n\nm = list(map(int,read().split()))\n\nBC = list(zip(m,m))\n\n\n\nBC.sort(key = itemgetter(1),reverse=True)\n\n\n\nBC.append((N,-1))\n\n\n\nchange = []\n\nfor b,c in BC:\n\n    change += [c] * b\n\n    if len(change) > N:\n\n        break\n\n\n\nA += change\n\nA.sort()\n\nanswer = sum(A[-N:])\n\nprint(answer)", "score": 1.0, "codebleu": 0.2169088489404873, "crystalbleu": 0.13862665674971789, "codebertscore": 0.76, "codescore": 0.8609747886657715, "surfaceSim": 0.5191581384015594, "abs_surfaceSim_minus_score": 0.48084186159844056}
{"golden_code": "from scipy.sparse.csgraph import csgraph_from_dense, floyd_warshall\n\n\n\nINF = float('inf')\n\n\n\ndef sol():\n\n    N, M = list(map(int, input().split()))\n\n\n\n    edges = []\n\n\n\n    for _ in range(M):\n\n        fr, to, cost = list(map(int, input().split()))\n\n        fr -= 1\n\n        to -= 1\n\n        edges.append((fr, to, cost))\n\n\n\n    graph = [[INF] * N for _ in range(N)]\n\n    for fr, to, cost in edges:\n\n        graph[fr][to] = cost\n\n\n\n    graph = csgraph_from_dense(graph, null_value=INF)\n\n\n\n    dist = floyd_warshall(graph, directed=False)\n\n    ans = (graph > dist).sum()\n\n    print(ans)\n\n\n\nsol()", "generated_code": "N, M = list(map(int, input().split()))\n\nINF = 10**18\n\n\n\nminDist = [[INF] * N for _ in range(N)]\n\nfor i in range(N):\n\n    minDist[i][i] = 0\n\n\n\nedges = []\n\nfor _ in range(M):\n\n    fr, to, d = list(map(int, input().split()))\n\n    fr -= 1\n\n    to -= 1\n\n    edges.append((fr, to, d))\n\n    minDist[fr][to] = d\n\n    minDist[to][fr] = d\n\n\n\nfor k in range(N):\n\n    for i in range(N):\n\n        for j in range(N):\n\n            d = minDist[i][k] + minDist[k][j]\n\n            if minDist[i][j] > d:\n\n                minDist[i][j] = d\n\n\n\nans = 0\n\nfor fr, to, d in edges:\n\n    if minDist[fr][to] < d:\n\n        ans += 1\n\nprint(ans)\n", "score": 1.0, "codebleu": 0.47322317218413795, "crystalbleu": 0.42492648120315435, "codebertscore": 0.8, "codescore": 0.327625036239624, "surfaceSim": 0.6190663519538422, "abs_surfaceSim_minus_score": 0.3809336480461578}
{"golden_code": "import numpy as np\n\n\n\ns = input()[::-1]\n\nlength = len(s)\n\na = np.zeros(length, dtype=int)\n\nd = np.zeros(length, dtype=int)\n\nans = np.zeros(2019, dtype=int)\n\nx = 10\n\n\n\na[0] = int(s[0])\n\nd[0] = a[0]\n\nans[d[0]] += 1\n\n\n\nfor i in range(1, length):\n\n    a[i] = int(s[i]) * x % 2019\n\n    d[i] = (d[i-1] + a[i]) % 2019\n\n    ans[d[i]] += 1\n\n    x = x * 10 % 2019\n\n\n\nans_c = ans[np.nonzero(ans)]\n\n\n\nprint((int(sum([ans_c[i] * (ans_c[i]-1) for i in range(ans_c.shape[0])]) / 2) + ans[0]))", "generated_code": "s = input()[::-1]\n\nlength = len(s)\n\na = [0] * length\n\nd = [0] * length\n\nans = [0] * 2019\n\nx = 10\n\n\n\na[0] = int(s[0])\n\nd[0] = a[0]\n\nans[d[0]] += 1\n\n\n\nfor i in range(1, length):\n\n    a[i] = int(s[i]) * x % 2019\n\n    d[i] = (d[i-1] + a[i]) % 2019\n\n    ans[d[i]] += 1\n\n    x = x * 10 % 2019\n\n\n\nprint((int(sum([ans[i] * (ans[i]-1) for i in range(2019)]) / 2) + ans[0]))", "score": 1.0, "codebleu": 0.5287219734545097, "crystalbleu": 0.7065924005424864, "codebertscore": 0.9, "codescore": 0.6766581535339355, "surfaceSim": 0.783879904162923, "abs_surfaceSim_minus_score": 0.21612009583707703}
{"golden_code": "import numpy as np\n\nnum=np.array(list(eval(input())))\n\n\n\nfor bit in  range(1<<3):\n\n  op=np.array(['-']*3)\n\n  for i in range(3):\n\n    if (bit>>i)&1:\n\n      op[i]='+'\n\n  formula=np.insert(num,[1,2,3],op)\n\n  \n\n  if eval(''.join(formula))==7:\n\n    flag=True\n\n    print((''.join(formula)+'=7'))\n\n    break", "generated_code": "INF = 10 ** 9\n\nimport sys\n\nsys.setrecursionlimit(100000000)\n\ndy = (-1,0,1,0)\n\ndx = (0,1,0,-1)\n\nfrom  heapq import heappop,heapify,heappush\n\nfrom bisect import bisect_left\n\n\n\ndef main():\n\n    s = eval(input())\n\n    for bit in range(8):\n\n        op = []\n\n        for i in range(3):\n\n            if (bit>>i)&1:\n\n                op.append('+')\n\n            else:\n\n                op.append('-')\n\n        \n\n        tmp = s[0]\n\n        for i in range(3):\n\n            tmp += op[i]\n\n            tmp += s[i + 1]\n\n\n\n        if eval(tmp) == 7:\n\n            ans = tmp + '=7'\n\n            break\n\n    print(ans)\n\nif __name__ == '__main__':\n\n    main()\n", "score": 1.0, "codebleu": 0.24748628712653709, "crystalbleu": 0.19022097569274965, "codebertscore": 0.73, "codescore": 0.06552765518426895, "surfaceSim": 0.6200028453549581, "abs_surfaceSim_minus_score": 0.3799971546450419}
{"golden_code": "def main():\n\n    from sys import stdin\n\n    def input():\n\n        return stdin.readline().strip()\n\n\n\n    n, m = list(map(int, input().split()))\n\n    tree = [[] for _ in range(n)]\n\n    for _ in range(m):\n\n        i, j, k = list(map(int, input().split()))\n\n        i -= 1\n\n        j -= 1\n\n        tree[i].append((k, j))\n\n        tree[j].append((k, i))\n\n\n\n    # dijkstra\n\n    import heapq\n\n    from numpy import zeros\n\n\n\n    ans = 0\n\n    for i in range(n):\n\n        for j in tree[i]:\n\n            seen = zeros(n)\n\n            goal = j[1]\n\n            base = j[0]\n\n            seen[i] = 1\n\n            todo = []\n\n            heapq.heapify(todo)\n\n            for k in tree[i]:\n\n                if k[0] < base and k != j:\n\n                    heapq.heappush(todo, k)\n\n            while len(todo) > 0:\n\n                k = heapq.heappop(todo)\n\n                if k[1] == goal:\n\n                    if k[0] < base:\n\n                        ans += 1\n\n                    break\n\n                seen[k[1]] = 1\n\n                for l in tree[k[1]]:\n\n                    if seen[l[1]] == 0 and k[0] + l[0] < base:\n\n                        heapq.heappush(todo, (k[0] + l[0], l[1]))\n\n\n\n    print((ans // 2))\n\n\n\nmain()", "generated_code": "def main():\n\n    from sys import stdin\n\n    def input():\n\n        return stdin.readline().strip()\n\n\n\n    n, m = list(map(int, input().split()))\n\n    tree = [[] for _ in range(n)]\n\n    for _ in range(m):\n\n        i, j, k = list(map(int, input().split()))\n\n        i -= 1\n\n        j -= 1\n\n        tree[i].append((k, j))\n\n        tree[j].append((k, i))\n\n\n\n    # dijkstra\n\n    import heapq\n\n\n\n    ans = 0\n\n    for i in range(n):\n\n        for j in tree[i]:\n\n            seen = [0] * n\n\n            goal = j[1]\n\n            base = j[0]\n\n            seen[i] = 1\n\n            todo = []\n\n            heapq.heapify(todo)\n\n            for k in tree[i]:\n\n                if k[0] < base and k != j:\n\n                    heapq.heappush(todo, k)\n\n            while len(todo) > 0:\n\n                k = heapq.heappop(todo)\n\n                if k[1] == goal:\n\n                    if k[0] < base:\n\n                        ans += 1\n\n                    break\n\n                seen[k[1]] = 1\n\n                for l in tree[k[1]]:\n\n                    if seen[l[1]] == 0 and k[0] + l[0] < base:\n\n                        heapq.heappush(todo, (k[0] + l[0], l[1]))\n\n\n\n    print((ans // 2))\n\n\n\nmain()", "score": 1.0, "codebleu": 0.9095455617496164, "crystalbleu": 0.9645130049730192, "codebertscore": 0.99, "codescore": 0.9921539425849915, "surfaceSim": 0.9752045325283283, "abs_surfaceSim_minus_score": 0.024795467471671717}
{"golden_code": "import numpy as np\n\n\n\nn = int(eval(input()))\n\n\n\nv_list = np.array(list(map(int,input().split())))\n\nc_list = np.array(list(map(int,input().split())))\n\ne_list = list(v_list - c_list)\n\n\n\nans = 0\n\n\n\nfor i in range(n):\n\n    if e_list[i] > 0:\n\n        ans += e_list[i]\n\n\n\nprint(ans)\n", "generated_code": "n = int(eval(input()))\n\n\n\nv_list = list(map(int,input().split()))\n\nc_list = list(map(int,input().split()))\n\n\n\ne_list = [v-c if (v-c > 0) else 0 for v,c in zip(v_list, c_list)]\n\n\n\nprint((sum(e_list)))\n", "score": 1.0, "codebleu": 0.3163640542406849, "crystalbleu": 0.29223191239605906, "codebertscore": 0.87, "codescore": 0.1704786866903305, "surfaceSim": 0.5831046931407943, "abs_surfaceSim_minus_score": 0.4168953068592057}
{"golden_code": "from bisect import bisect_left\n\nfrom bisect import bisect_right\n\n\n\nn,m = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\na = sorted(a)\n\n\n\na_count = [0]*100010\n\na_sum = [0]*100010\n\n\n\nfor i in range(n):\n\n    a_count[a[i]] += 1\n\n    a_sum[a[i]] += a[i]\n\n\n\nfor i in range(100005,-1,-1):\n\n    a_count[i] += a_count[i+1]\n\n    a_sum[i] += a_sum[i+1]\n\n\n\ndef chk(x):\n\n    case = 0\n\n    for i in range(n):\n\n        if 0<= x-a[i]<= 10**5+5:\n\n            case += a_count[x-a[i]]\n\n        elif x-a[i] < 0:\n\n            case += n\n\n    if case >= m:\n\n        ch = True\n\n    else:\n\n        ch = False\n\n    return ch\n\n\n\nl = 2*a[-1]+1    #NG\n\nr = 1 #OK\n\n\n\nwhile abs(r-l) > 1:\n\n    kk = (r+l)//2\n\n    if chk(kk):\n\n        r = kk\n\n    else:\n\n        l = kk\n\n\n\nans = 0\n\nsm = sum(a)\n\n\n\nl = r\n\n\n\ncase = 0\n\nfor i in range(n):\n\n    num = n-bisect_right(a,l-a[i]-1)\n\n    case += num\n\n    ans += num*a[i]*2\n\n\n\nans -= (case-m)*l\n\n\n\nprint(ans)", "generated_code": "n, m = list(map(int, input().split()))\n\na = [int(x) for x in input().split()]\n\n\n\naa = [0]*(10**5+1)\n\naa_sum = [0]*(10**5+1)\n\n\n\nfor x in a:\n\n    aa[x] += 1\n\n    aa_sum[x] += x\n\n\n\nfor i in range(10**5)[::-1]:\n\n    aa[i] = aa[i] + aa[i+1]\n\n    aa_sum[i] = aa_sum[i] + aa_sum[i+1]\n\n\n\n\n\ndef count(x):\n\n    cnt = 0\n\n    sm = 0\n\n    for i in range(n):\n\n        if x-a[i] < 0:\n\n            cnt += n\n\n            sm += aa_sum[0]+n*a[i]\n\n        elif x-a[i] > 10**5:\n\n            continue\n\n        else:\n\n            cnt += aa[x-a[i]]\n\n            sm += aa_sum[x-a[i]]+aa[x-a[i]]*a[i]\n\n\n\n    return cnt, sm\n\n\n\n\n\nbottom = 0\n\ntop = 10**6\n\n\n\nwhile top - bottom > 1:\n\n    mid = (top+bottom) // 2\n\n    cnt, sm = count(mid)\n\n    if cnt < m:\n\n        top = mid\n\n    else:\n\n        bottom = mid\n\n\n\ncnt, sm = count(bottom)\n\nans = sm - (cnt-m)*bottom\n\n\n\nprint(ans)\n", "score": 1.0, "codebleu": 0.27834166569084917, "crystalbleu": 0.3345776544582823, "codebertscore": 0.84, "codescore": 0.8560572862625122, "surfaceSim": 0.6836538461538462, "abs_surfaceSim_minus_score": 0.31634615384615383}
{"golden_code": "from itertools import product\n\n\n\nn = int(eval(input()))\n\nA = list(map(int, input().split()))\n\n\n\ncount = 0\n\nfor C in product((-1, 0, 1), repeat=n):\n\n  total = 1\n\n  for a, c in zip(A, C):\n\n    total *= (a + c)\n\n  if total % 2 == 0:\n\n    count += 1\n\nprint(count)", "generated_code": "n = int(eval(input()))\n\nA = list(map(int, input().split()))\n\n\n\ncount = 1\n\nfor a in A:\n\n  count *= 2 if a % 2 == 0 else 1\n\nprint((3 ** n - count))", "score": 1.0, "codebleu": 0.3043090417128968, "crystalbleu": 0.0, "codebertscore": 0.85, "codescore": 0.16226552426815033, "surfaceSim": 0.5878020878020878, "abs_surfaceSim_minus_score": 0.41219791219791224}
{"golden_code": "from collections import defaultdict\n\nn = int(eval(input()))\n\n\n\nd = defaultdict(int)\n\nfor _ in range(n):\n\n    key = eval(input())\n\n    d[key] += 1\n\n\n\ndict = sorted(list(d.items()), key=lambda x:x[1], reverse=True)\n\nmax_v = max(d.values())\n\n\n\ndict_li = []\n\nfor a in dict:\n\n    if a[1]==max_v:\n\n        dict_li.append(a[0])\n\n\n\ndict_li.sort()\n\nfor s in dict_li:\n\n    print(s)\n", "generated_code": "from collections import defaultdict\n\nn = int(input())\n\n\n\nd = defaultdict(int)\n\nfor _ in range(n):\n\n    key = input()\n\n    d[key] += 1\n\n\n\ndict = sorted(d.items(), key=lambda x:x[1], reverse=True)\n\nmax_v = max(d.values())\n\n\n\ndict_li = []\n\nfor a in dict:\n\n    if a[1]==max_v:\n\n        dict_li.append(a[0])\n\n\n\ndict_li.sort()\n\nprint(*dict_li, sep='\\n')\n", "score": 1.0, "codebleu": 0.6481303320881847, "crystalbleu": 0.7597403181948968, "codebertscore": 0.97, "codescore": 0.9183182120323181, "surfaceSim": 0.9356451612903225, "abs_surfaceSim_minus_score": 0.06435483870967751}
{"golden_code": "s=int(eval(input()))\n\np=10**9+7\n\nif s<=2:\n\n    print((0))\n\n    exit()\n\nn=s//3\n\nans=0\n\ndef f(n,k,p):\n\n    if k==0:\n\n        return 1\n\n    elif k%2==0:\n\n        return (f(n,k//2,p)**2)%p\n\n    else:\n\n        return (n*f(n,k-1,p))%p\n\n\n\nfor k in range(1,n+1):\n\n    a=1\n\n    b=1\n\n    for j in range(k-1):\n\n        a=(a*(s-3*k+1+j))%p\n\n        b=(b*(j+1))%p\n\n    ans=(ans+a*f(b,p-2,p))%p\n\n\n\nprint((ans%p))\n\n\n", "generated_code": "s=int(eval(input()))\n\np=10**9+7\n\nif s<=2:\n\n    print((0))\n\n    exit()\n\nn=s//3\n\nans=0\n\nx=[0]*(s+1)\n\nx[0]=1\n\nx[1]=1\n\ny=[0]*(s+1)\n\n\n\nfor i in range(2,s+1):\n\n    x[i]=x[i-1]*i%p\n\n\n\ny[s]=pow(x[s],p-2,p)\n\nfor i in range(s):\n\n    y[s-1-i]=y[s-i]*(s-i)%p\n\n\n\nfor k in range(1,n+1):\n\n    ans+=x[s-2*k-1]*y[k-1]*y[s-3*k]%p\n\n\n\nprint((ans%p))\n\n\n", "score": 1.0, "codebleu": 0.3946442442873037, "crystalbleu": 0.4822284168934553, "codebertscore": 0.87, "codescore": 0.8785735368728638, "surfaceSim": 0.6372907018168864, "abs_surfaceSim_minus_score": 0.3627092981831136}
{"golden_code": "import numpy as np\n\n# Me\n\n\n\n\n\ndef f():\n\n    i = int(eval(input()))\n\n    nums = np.array(list(map(int, input().split())))\n\n    # nums = [int(x) for x in input().split()]\n\n    c = 0\n\n    while True:\n\n        if any(nums % 2 == 1):\n\n            break\n\n        c += 1\n\n        nums = nums / 2\n\n    print(c)\n\n\n\n\n\nf()\n\n\n\n\n\n# Other\n", "generated_code": "def divide_all(a):\n\n    success = True\n\n    for i, n in enumerate(a):\n\n        if n % 2 != 0:\n\n            success = False\n\n            break\n\n        a[i] = n / 2\n\n    if success is False:\n\n        return (a, False)\n\n    return (a, True)\n\n\n\nn = int(eval(input()))\n\na = list(map(int, input().split()))\n\nc = 0\n\nwhile True:\n\n    a, r = divide_all(a)\n\n    if r is False:\n\n        break\n\n    c += 1\n\n\n\n\n\nprint(c)\n", "score": 1.0, "codebleu": 0.34894964683932894, "crystalbleu": 0.0, "codebertscore": 0.78, "codescore": 0.5211880803108215, "surfaceSim": 0.6037542392933197, "abs_surfaceSim_minus_score": 0.3962457607066803}
{"golden_code": "a, b = list(map(int, input().strip().split(\" \")))\n\ncount = 0\n\nfor i in range(a, b + 1):\n\n    if str(i) == str(i)[::-1]:\n\n        count += 1\n\nprint(count)\n", "generated_code": "def solve(string):\n\n    a, b = list(map(int, string.split()))\n\n    count = 0\n\n    for i in range(a, b + 1):\n\n        if str(i) == str(i)[::-1]:\n\n            count += 1\n\n    return str(count)\n\n\n\n\n\nif __name__ == '__main__':\n\n    print((solve(eval(input()))))\n", "score": 1.0, "codebleu": 0.6169693121136398, "crystalbleu": 0.0, "codebertscore": 0.91, "codescore": 0.02402162179350853, "surfaceSim": 0.7417054263565892, "abs_surfaceSim_minus_score": 0.2582945736434108}
{"golden_code": "N=int(eval(input()))\n\n\n\nS=[[-1]*N for _ in range(N)]\n\nfor i in range(N):\n\n  A=int(eval(input()))\n\n  for _ in range(A):\n\n    x, y=list(map(int, input().split()))\n\n    S[i][x-1]=y\n\nans=0   \n\nfor s in range(2**N):\n\n  ok=True\n\n  for i in range(N):\n\n    #正直者について見ていく\n\n    if (s>>i&1)==1:\n\n      for j in range(N):\n\n        #それぞれ正直者の証言が矛盾ないか\n\n        if S[i][j]!=-1 and (s>>j&1)!=S[i][j]:\n\n          ok=False\n\n  if ok:\n\n    ans=max(ans, bin(s).count(\"1\"))\n\n    \n\nprint(ans)\n", "generated_code": "N=int(eval(input()))\n\n\n\nA=[[-1]*N for _ in range(N)]\n\nfor i in range(N):\n\n  a=int(eval(input()))\n\n  for j in range(a):\n\n    x,y=list(map(int, input().split()))\n\n    A[i][x-1]=y\n\n#正直者が正直者に不親切と言われていない\n\n#→正直ものが不親切を正直者と言っていないか\n\nans=0\n\nfor i in range(2**N):\n\n  ok=True\n\n  for j in range(N):\n\n    if (i>>j&1)==1:\n\n      for k in range(N):\n\n        if A[j][k]!=-1 and (i>>k&1)!=A[j][k]:\n\n          ok=False\n\n  if ok:\n\n    ans=max(ans, bin(i).count(\"1\"))\n\n  \n\nprint(ans)", "score": 1.0, "codebleu": 0.6160689630520192, "crystalbleu": 0.7293791569454686, "codebertscore": 0.91, "codescore": 0.8327102065086365, "surfaceSim": 0.9797008547008548, "abs_surfaceSim_minus_score": 0.020299145299145227}
{"golden_code": "import numpy as np\n\n \n\ndef main():\n\n    stdin = np.fromstring(open(0).read(), dtype=np.int64, sep=' ')\n\n    A = stdin[1:]\n\n    A = np.mod(A, 2)\n\n    print(\"first\") if np.count_nonzero(A) else print(\"second\")\n\nif __name__ == \"__main__\":\n\n    main()\n", "generated_code": "import sys\n\ndef input(): return sys.stdin.readline().strip()\n\ndef main():\n\n    N = int(input())\n\n    A = (int(input()) for _ in range(N))\n\n    print(\"second\") if all(( a%2==0 for a in A)) else print(\"first\")\n\nif __name__ == \"__main__\":\n\n    main()\n", "score": 1.0, "codebleu": 0.282742253183675, "crystalbleu": 0.0, "codebertscore": 0.81, "codescore": 0.02596542052924633, "surfaceSim": 0.6141935483870968, "abs_surfaceSim_minus_score": 0.38580645161290317}
{"golden_code": "import math\n\nN = int(eval(input()))\n\nprint((math.factorial(N)%(10**9+7)))", "generated_code": "import math\n\nN = int(eval(input()))\n\na = 1\n\nfor n in range(2,N+1):\n\n    a = a*n % (10**9+7)\n\nprint(a)", "score": 1.0, "codebleu": 0.5101463671792871, "crystalbleu": 0.0, "codebertscore": 0.87, "codescore": 0.9003472924232483, "surfaceSim": 0.7434478741991846, "abs_surfaceSim_minus_score": 0.25655212580081543}
{"golden_code": "import sys\n\nfrom operator import itemgetter\n\nfrom heapq import heapify, heappop, heappush\n\nMAX_INT = int(10e15)\n\nMIN_INT = -MAX_INT\n\nmod = 1000000007\n\nsys.setrecursionlimit(1000000)\n\ndef IL(): return list(map(int,input().split()))\n\ndef SL(): return input().split()\n\ndef I(): return int(sys.stdin.readline())\n\ndef S(): return eval(input())\n\n\n\nN, T = IL()\n\nab = [IL() for i in range(N)]\n\nab.sort(key=itemgetter(0))\n\n#print(ab)\n\n\n\ndp = [[0]*(T+1+3000+1) for _ in range(N+1)]\n\nans = 0\n\nfor i in range(N):\n\n  for j in range(T+1+3000+1):\n\n    time, deli = ab[i]\n\n    if 0 <= j-time < T:\n\n      dp[i + 1][j] = max(dp[i][j], dp[i][j - time] + deli)\n\n    else:\n\n      dp[i + 1][j] = dp[i][j]\n\n    ans = max(ans, dp[i + 1][j])\n\nprint(ans)\n\n\n\n#print(dp)\n", "generated_code": "import sys\n\nfrom collections import deque\n\nMAX_INT = int(10e10)\n\nMIN_INT = -MAX_INT\n\nmod = 1000000007\n\nsys.setrecursionlimit(1000000)\n\ndef IL(): return list(map(int,input().split()))\n\ndef SL(): return input().split()\n\ndef I(): return int(sys.stdin.readline())\n\ndef S(): return eval(input())\n\n\n\nN,T = IL()\n\nab = [IL() for i in range(N)]\n\nab.sort()\n\n\n\nans = 0\n\ndp = [[0]*T for i in range(N+1)]\n\nfor i in range(1,N+1):\n\n  a,b = ab[i-1]\n\n  for j in range(T):\n\n    if 0 <= j-a < T:\n\n      dp[i][j] = max(dp[i-1][j], dp[i-1][j-a] + b)\n\n    else:\n\n      dp[i][j] = dp[i-1][j]\n\n  else:\n\n    ans = max(ans, dp[i-1][-1] + b)\n\nprint(ans)", "score": 1.0, "codebleu": 0.4549237617824019, "crystalbleu": 0.6568401202082702, "codebertscore": 0.91, "codescore": 0.4956180453300476, "surfaceSim": 0.8758309882132225, "abs_surfaceSim_minus_score": 0.12416901178677753}
{"golden_code": "n = int(eval(input()))\n\nedges = []\n\n\n\nfor id in range(n-1):\n\n    a, b = list(map(int, input().split()))\n\n    edges.append([a-1, b-1, id])\n\n\n\nedges.sort()\n\n\n\nused = [0]*(n)\n\nans = [0]*(n-1)\n\nnum = 1\n\nprev = 0\n\nfor edge in edges:\n\n    _from, to, id = edge\n\n    if _from != prev:\n\n        num = 1\n\n    if used[_from] == num:\n\n        num += 1\n\n    ans[id] = num\n\n    used[to] = num\n\n    num += 1\n\n    prev = _from\n\n\n\nprint((max(ans)))\n\nfor color in ans:\n\n    print(color)\n", "generated_code": "import sys\n\ninput = sys.stdin.readline\n\n\n\nn = int(eval(input()))\n\nedges = []\n\n\n\nfor id in range(n-1):\n\n    a, b = list(map(int, input().split()))\n\n    edges.append([a-1, b-1, id])\n\n\n\nedges.sort()\n\n\n\nused = [0]*(n)\n\nans = [0]*(n-1)\n\nnum = 1\n\nprev = 0\n\nfor edge in edges:\n\n    _from, to, id = edge\n\n    if _from != prev:\n\n        num = 1\n\n    if used[_from] == num:\n\n        num += 1\n\n    ans[id] = num\n\n    used[to] = num\n\n    num += 1\n\n    prev = _from\n\n\n\nprint((max(ans)))\n\nfor color in ans:\n\n    print(color)\n", "score": 1.0, "codebleu": 0.8361913065320064, "crystalbleu": 0.8617974445251831, "codebertscore": 0.97, "codescore": 0.9938532114028931, "surfaceSim": 0.9257534246575343, "abs_surfaceSim_minus_score": 0.0742465753424657}
{"golden_code": "def c_repsept():\n\n    K = int(eval(input()))\n\n\n\n    L = 9 * K // 7 if K % 7 == 0 else 9 * K\n\n    if L % 2 == 0 or L % 5 == 0:\n\n        return -1\n\n\n\n    remainder = 1\n\n    for n in range(1, L + 1):\n\n        remainder = (10 * remainder) % L\n\n        if remainder == 1:\n\n            return n\n\n    return -1\n\n\n\nprint((c_repsept()))", "generated_code": "def c_repsept_totient():\n\n    def euler_phi(n):\n\n        \"\"\"正整数 n に対して、n と互いに素な n 以下の正整数の個数\"\"\"\n\n        ret = n\n\n        for i in range(2, int(n**0.5) + 1):\n\n            if n % i == 0:\n\n                ret = ret // i * (i - 1)\n\n                while n % i == 0:\n\n                    n //= i\n\n        if n > 1:\n\n            ret -= ret // n\n\n        return ret\n\n\n\n    def divisor_list(n):\n\n        \"\"\"n の正の約数のリスト\"\"\"\n\n        ret = set()\n\n        for k in range(1, int(n**0.5) + 1):\n\n            if n % k == 0:\n\n                ret.update({k, n // k})\n\n        return sorted(ret)\n\n\n\n    K = int(eval(input()))\n\n    L = 9 * (K // 7 if K % 7 == 0 else K)\n\n\n\n    for d in divisor_list(euler_phi(L)):\n\n        if pow(10, d, L) == 1:\n\n            return d\n\n    return -1\n\n\n\nprint((c_repsept_totient()))", "score": 1.0, "codebleu": 0.3808186902286373, "crystalbleu": 0.1774693005485421, "codebertscore": 0.78, "codescore": 0.3409365713596344, "surfaceSim": 0.6438248988626822, "abs_surfaceSim_minus_score": 0.35617510113731776}
{"golden_code": "N, L = list(map(int, input().split()))\n\nS = list(eval(input()) for i in range(N))\n\nstr = \"\"\n\nfor i in range(N-1):\n\n    for j in range(N-1):\n\n        if S[j+1] + S[j] <= S[j] + S[j+1]:\n\n            S[j], S[j+1] = S[j+1], S[j]\n\nfor i in S:\n\n    str += i\n\nprint(str)\n", "generated_code": "N, L = list(map(int, input().split()))\n\nS = list(eval(input()) for i in range(N))\n\nS.sort()\n\nstr = \"\"\n\nfor i in S:\n\n    str += i\n\nprint(str)\n", "score": 1.0, "codebleu": 0.450180971647207, "crystalbleu": 0.28812701121232864, "codebertscore": 0.87, "codescore": 0.455792635679245, "surfaceSim": 0.6761363636363635, "abs_surfaceSim_minus_score": 0.32386363636363646}
{"golden_code": "import collections\n\nimport math\n\n\n\n\n\nclass Dinic:\n\n    \"\"\"Dinic Algorithm: find max-flow\n\n       complexity: O(EV^2)\n\n       used in GRL6A(AOJ)\n\n    \"\"\"\n\n    class edge:\n\n        def __init__(self, to, cap, rev):\n\n            self.to, self.cap, self.rev = to, cap, rev\n\n\n\n    def __init__(self, V, E, source, sink):\n\n        \"\"\" V: the number of vertexes\n\n            E: adjacency list\n\n            source: start point\n\n            sink: goal point\n\n        \"\"\"\n\n        self.V = V\n\n        self.E = [[] for _ in range(V)]\n\n        for fr in range(V):\n\n            for to, cap in E[fr]:\n\n                self.E[fr].append(self.edge(to, cap, len(self.E[to])))\n\n                self.E[to].append(self.edge(fr, 0, len(self.E[fr])-1))\n\n        self.maxflow = self.dinic(source, sink)\n\n\n\n    def dinic(self, source, sink):\n\n        \"\"\"find max-flow\"\"\"\n\n        INF = float('inf')\n\n        maxflow = 0\n\n        while True:\n\n            self.bfs(source)\n\n            if self.level[sink] < 0:\n\n                return maxflow\n\n            self.itr = [0] * self.V\n\n            while True:\n\n                flow = self.dfs(source, sink, INF)\n\n                if flow > 0:\n\n                    maxflow += flow\n\n                else:\n\n                    break\n\n\n\n    def dfs(self, vertex, sink, flow):\n\n        \"\"\"find augmenting path\"\"\"\n\n        if vertex == sink:\n\n            return flow\n\n        for i in range(self.itr[vertex], len(self.E[vertex])):\n\n            self.itr[vertex] = i\n\n            e = self.E[vertex][i]\n\n            if e.cap > 0 and self.level[vertex] < self.level[e.to]:\n\n                d = self.dfs(e.to, sink, min(flow, e.cap))\n\n                if d > 0:\n\n                    e.cap -= d\n\n                    self.E[e.to][e.rev].cap += d\n\n                    return d\n\n        return 0\n\n\n\n    def bfs(self, start):\n\n        \"\"\"find shortest path from start\"\"\"\n\n        que = collections.deque()\n\n        self.level = [-1] * self.V\n\n        que.append(start)\n\n        self.level[start] = 0\n\n\n\n        while que:\n\n            fr = que.popleft()\n\n            for e in self.E[fr]:\n\n                if e.cap > 0 and self.level[e.to] < 0:\n\n                    self.level[e.to] = self.level[fr] + 1\n\n                    que.append(e.to)\n\n\n\nwhile True:\n\n    M, N = list(map(int, input().split()))\n\n    if M == 0 and N == 0:\n\n        break\n\n    blue, red = [], []\n\n    while True:\n\n        for x in input().split():\n\n            blue.append(int(x))\n\n        if len(blue) == M:\n\n            break\n\n    while True:\n\n        for x in input().split():\n\n            red.append(int(x))\n\n        if len(red) == N:\n\n            break\n\n    V = M + N + 2\n\n    edge = [set() for _ in range(V)]\n\n    for i, b in enumerate(blue):\n\n        if b != 1:\n\n            for j, r in enumerate(red):\n\n                if r % b == 0:\n\n                    edge[i].add((M+j, 1))\n\n        for j in range(2, int(math.sqrt(b)) + 1):\n\n            if b % j == 0:\n\n                for k, r in enumerate(red):\n\n                    if r % j == 0 or r % (b // j) == 0:\n\n                        edge[i].add((M+k, 1))\n\n    for i in range(M):\n\n        edge[M+N].add((i, 1))\n\n    for j in range(N):\n\n        edge[M+j].add((M+N+1, 1))\n\n    d = Dinic(V, edge, M+N, M+N+1)\n\n    print((d.maxflow))", "generated_code": "import collections\n\nimport math\n\nrange = xrange; input = raw_input\n\n\n\n\n\nclass Dinic:\n\n    \"\"\"Dinic Algorithm: find max-flow\n\n       complexity: O(EV^2)\n\n       used in GRL6A(AOJ)\n\n    \"\"\"\n\n    class edge:\n\n        def __init__(self, to, cap, rev):\n\n            self.to, self.cap, self.rev = to, cap, rev\n\n\n\n    def __init__(self, V, E, source, sink):\n\n        \"\"\" V: the number of vertexes\n\n            E: adjacency list\n\n            source: start point\n\n            sink: goal point\n\n        \"\"\"\n\n        self.V = V\n\n        self.E = [[] for _ in range(V)]\n\n        for fr in range(V):\n\n            for to, cap in E[fr]:\n\n                self.E[fr].append(self.edge(to, cap, len(self.E[to])))\n\n                self.E[to].append(self.edge(fr, 0, len(self.E[fr])-1))\n\n        self.maxflow = self.dinic(source, sink)\n\n\n\n    def dinic(self, source, sink):\n\n        \"\"\"find max-flow\"\"\"\n\n        INF = float('inf')\n\n        maxflow = 0\n\n        while True:\n\n            self.bfs(source)\n\n            if self.level[sink] < 0:\n\n                return maxflow\n\n            self.itr = [0] * self.V\n\n            while True:\n\n                flow = self.dfs(source, sink, INF)\n\n                if flow > 0:\n\n                    maxflow += flow\n\n                else:\n\n                    break\n\n\n\n    def dfs(self, vertex, sink, flow):\n\n        \"\"\"find augmenting path\"\"\"\n\n        if vertex == sink:\n\n            return flow\n\n        for i in range(self.itr[vertex], len(self.E[vertex])):\n\n            self.itr[vertex] = i\n\n            e = self.E[vertex][i]\n\n            if e.cap > 0 and self.level[vertex] < self.level[e.to]:\n\n                d = self.dfs(e.to, sink, min(flow, e.cap))\n\n                if d > 0:\n\n                    e.cap -= d\n\n                    self.E[e.to][e.rev].cap += d\n\n                    return d\n\n        return 0\n\n\n\n    def bfs(self, start):\n\n        \"\"\"find shortest path from start\"\"\"\n\n        que = collections.deque()\n\n        self.level = [-1] * self.V\n\n        que.append(start)\n\n        self.level[start] = 0\n\n\n\n        while que:\n\n            fr = que.popleft()\n\n            for e in self.E[fr]:\n\n                if e.cap > 0 and self.level[e.to] < 0:\n\n                    self.level[e.to] = self.level[fr] + 1\n\n                    que.append(e.to)\n\n\n\nwhile True:\n\n    M, N = list(map(int, input().split()))\n\n    if M == 0 and N == 0:\n\n        break\n\n    blue, red = [], []\n\n    while True:\n\n        for x in input().split():\n\n            blue.append(int(x))\n\n        if len(blue) == M:\n\n            break\n\n    while True:\n\n        for x in input().split():\n\n            red.append(int(x))\n\n        if len(red) == N:\n\n            break\n\n    V = M + N + 2\n\n    edge = [set() for _ in range(V)]\n\n    for i, b in enumerate(blue):\n\n        if b != 1:\n\n            for j, r in enumerate(red):\n\n                if r % b == 0:\n\n                    edge[i].add((M+j, 1))\n\n        for j in range(2, int(math.sqrt(b)) + 1):\n\n            if b % j == 0:\n\n                for k, r in enumerate(red):\n\n                    if r % j == 0 or r % (b // j) == 0:\n\n                        edge[i].add((M+k, 1))\n\n    for i in range(M):\n\n        edge[M+N].add((i, 1))\n\n    for j in range(N):\n\n        edge[M+j].add((M+N+1, 1))\n\n    d = Dinic(V, edge, M+N, M+N+1)\n\n    print((d.maxflow))", "score": 1.0, "codebleu": 0.8489342051345099, "crystalbleu": 0.9853821088530328, "codebertscore": 0.99, "codescore": 0.9938841462135315, "surfaceSim": 0.9955953827460511, "abs_surfaceSim_minus_score": 0.004404617253948917}
{"golden_code": "# https://atcoder.jp/contests/abc129/tasks/abc129_c\n\n# 典型的なDP\n\n\n\nMOD = 10**9 + 7\n\nimport numpy as np\n\n# dp[i]をi段目までの通りの数とする。\n\nN, M = list(map(int, input().split()))\n\nto_zero = np.full((N + 1), False, dtype=bool)\n\nfor _ in range(M):\n\n    to_zero[int(eval(input()))] = True  # 床が抜けているところ\n\n\n\n# dpテーブルの用意\n\ndp = np.full((N + 1), -1, dtype='int64')\n\ndp[0] = 1\n\ndp[1] = 0 if to_zero[1] else 1\n\nfor i in range(2, N + 1):\n\n    dp[i] = 0 if to_zero[i] else dp[i - 2] + dp[i - 1]\n\n    if dp[i] > MOD:\n\n        dp[i] %= MOD\n\n\n\nprint((dp[-1]))\n", "generated_code": "# https://atcoder.jp/contests/abc129/tasks/abc129_c\n\n# 典型的なDP\n\n\n\nMOD = 10**9 + 7\n\nimport numpy as np\n\n# dp[i]をi段目までの通りの数とする。\n\nN, M = list(map(int, input().split()))\n\nto_zero = np.full((N + 1), False).tolist()\n\nfor _ in range(M):\n\n    to_zero[int(eval(input()))] = True  # 床が抜けているところ\n\n\n\n# dpテーブルの用意\n\ndp = np.full((N + 1), -1).tolist()\n\ndp[0] = 1\n\ndp[1] = 0 if to_zero[1] else 1\n\nfor i in range(2, N + 1):\n\n    dp[i] = 0 if to_zero[i] else dp[i - 2] + dp[i - 1]\n\n    if dp[i] > MOD:\n\n        dp[i] %= MOD\n\n\n\nprint((dp[-1]))\n", "score": 1.0, "codebleu": 0.8109209208446533, "crystalbleu": 0.9087828785415216, "codebertscore": 0.98, "codescore": 0.9076717495918274, "surfaceSim": 0.9623688458434221, "abs_surfaceSim_minus_score": 0.03763115415657792}
{"golden_code": "import sys\n\nimport numpy as np\n\nfrom numba import njit\n\n\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\n@njit('(i4[::1],i4,i8[::1])', cache=True)\n\ndef main(A, B, C):\n\n    counts = np.zeros(1 << 18, np.int32)\n\n    popcount = np.zeros(1 << B, np.int32)\n\n    for i in range(B):\n\n        popcount[1 << i:1 << i + 1] = popcount[:1 << i] + 1\n\n\n\n    answer = 0\n\n    for i in range(1 << B):\n\n        k = popcount[i]\n\n        t = 0\n\n        for x in A & i:\n\n            n = counts[x]\n\n            counts[x] += 1\n\n            t -= C[n]\n\n            t += C[n + 1]\n\n        for x in A & i:\n\n            counts[x] = 0\n\n        if k & 1:\n\n            t = -t\n\n        answer += t\n\n    return answer\n\n\n\nN, K, S, T = list(map(int, readline().split()))\n\nA = np.array(readline().split(), np.int32)\n\n\n\ndef convert_problem(S, T, A):\n\n    ng = np.zeros(len(A), np.bool)\n\n    B = np.zeros_like(A)\n\n    n = 0\n\n    for i in range(18):\n\n        s, t = (S >> i) & 1, (T >> i) & 1\n\n        if (s, t) == (0, 0):\n\n            ng |= ((A >> i) & 1) == 1\n\n        elif (s, t) == (1, 1):\n\n            ng |= ((A >> i) & 1) == 0\n\n        elif (s, t) == (1, 0):\n\n            print((0))\n\n            exit()\n\n        else:\n\n            B += ((A >> i) & 1) << n\n\n            n += 1\n\n    return B[~ng], n\n\n\n\nA, B = convert_problem(S, T, A)\n\n\n\nC = np.zeros((100, 100), np.int64)\n\nC[0, 0] = 1\n\nfor n in range(1, 100):\n\n    C[n, :-1] += C[n - 1, :-1]\n\n    C[n, 1:] += C[n - 1, :-1]\n\nC = C[:, 1:K + 1].sum(axis=1)\n\n\n\nprint((main(A, B, C)))", "generated_code": "import sys\n\nimport numpy as np\n\nfrom numba import njit\n\n\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\n@njit('(i4[::1],i4,i8[::1])', cache=True)\n\ndef main(A, B, C):\n\n    counts = np.zeros(1 << 18, np.int32)\n\n    popcount = np.zeros(1 << B, np.int32)\n\n    for i in range(B):\n\n        popcount[1 << i:1 << i + 1] = popcount[:1 << i] + 1\n\n\n\n    answer = 0\n\n    for i in range(1 << B):\n\n        k = popcount[i]\n\n        t = 0\n\n        for x in A & i:\n\n            n = counts[x]\n\n            counts[x] += 1\n\n            t -= C[n]\n\n            t += C[n + 1]\n\n        for x in A & i:\n\n            counts[x] = 0\n\n        if k & 1:\n\n            t = -t\n\n        answer += t\n\n    return answer\n\n  \n\nif sys.argv[-1] == 'ONLINE_JUDGE':\n\n    from numba.pycc import CC\n\n    cc = CC('my_module')\n\n    cc.export('main', '(i4[::1],i4,i8[::1])')(main)\n\n    cc.compile()\n\n    exit()\n\nfrom my_module import main\n\n\n\nN, K, S, T = list(map(int, readline().split()))\n\nA = np.array(readline().split(), np.int32)\n\n\n\ndef convert_problem(S, T, A):\n\n    ng = np.zeros(len(A), np.bool)\n\n    B = np.zeros_like(A)\n\n    n = 0\n\n    for i in range(18):\n\n        s, t = (S >> i) & 1, (T >> i) & 1\n\n        if (s, t) == (0, 0):\n\n            ng |= ((A >> i) & 1) == 1\n\n        elif (s, t) == (1, 1):\n\n            ng |= ((A >> i) & 1) == 0\n\n        elif (s, t) == (1, 0):\n\n            print((0))\n\n            exit()\n\n        else:\n\n            B += ((A >> i) & 1) << n\n\n            n += 1\n\n    return B[~ng], n\n\n\n\nA, B = convert_problem(S, T, A)\n\n\n\nC = np.zeros((100, 100), np.int64)\n\nC[0, 0] = 1\n\nfor n in range(1, 100):\n\n    C[n, :-1] += C[n - 1, :-1]\n\n    C[n, 1:] += C[n - 1, :-1]\n\nC = C[:, 1:K + 1].sum(axis=1)\n\n\n\nprint((main(A, B, C)))", "score": 1.0, "codebleu": 0.8151427354105175, "crystalbleu": 0.8761391474233163, "codebertscore": 0.95, "codescore": 0.9937029480934143, "surfaceSim": 0.9532842582106456, "abs_surfaceSim_minus_score": 0.04671574178935445}
{"golden_code": "a, b, c, x, y = list(map(int, input().split(' ')))\n\n\n\nc = int(c*2)\n\nm = float('inf')\n\nfor i in range(10**5+1):\n\n    m = min(m, a*max(0, x-i)+b*max(0,y-i)+c*i)\n\nprint(m)", "generated_code": "import math\n\na, b, c, x, y = list(map(int, input().split(' ')))\n\nans = float('inf')\n\nc = c*2\n\nfor i in range(max(x, y)+1):\n\n    if i > x:\n\n        price = b*(y-i) + c*i\n\n    elif i > y:\n\n        price = a*(x-i) + c*i\n\n    else:\n\n        price = a*(x-i) + b*(y-i) + c*i\n\n\n\n    if ans > price:\n\n        ans = price\n\nprint(ans)", "score": 1.0, "codebleu": 0.43213078873459254, "crystalbleu": 0.44162979325386165, "codebertscore": 0.86, "codescore": 0.4090235233306885, "surfaceSim": 0.6626984126984128, "abs_surfaceSim_minus_score": 0.3373015873015872}
{"golden_code": "import heapq\n\n\n\nN = int(eval(input()))\n\nabc = [list(map(int,input().split())) for _ in range(N-1)]\n\nQ,K = list(map(int,input().split()))\n\nxy = [list(map(int,input().split())) for _ in range(Q)]\n\n\n\nconnect = [[] for _ in range(N)]\n\nINFTY = 10**15\n\nfor a,b,c in abc:\n\n    connect[a-1].append([b-1,c])\n\n    connect[b-1].append([a-1,c])\n\n\n\ncost = [[INFTY,False] for _  in range(N)]\n\ncost[K-1][0] = 0\n\nq = [(0,K-1)]\n\nwhile q:\n\n    _,i = heapq.heappop(q)\n\n    if cost[i][1]:\n\n        continue\n\n    cost[i][1] = True\n\n    ci0 = cost[i][0]\n\n    for j,c in connect[i]:\n\n        if cost[j][1]:\n\n            continue\n\n        tmp_cost = ci0+c\n\n        if tmp_cost < cost[j][0]:\n\n            cost[j][0] = tmp_cost\n\n            heapq.heappush(q,(tmp_cost,j))\n\n\n\nfor x,y in xy:\n\n    print((cost[x-1][0] + cost[y-1][0]))", "generated_code": "N = int(eval(input()))\n\nABC = [list(map(int,input().split())) for _ in [0]*(N-1)]\n\nQ,K = list(map(int,input().split()))\n\nXY = [list(map(int,input().split())) for _ in [0]*Q]\n\n\n\nE = [{} for _ in [0]*N]\n\nfor a,b,c in ABC:\n\n    E[a-1][b-1] = c\n\n    E[b-1][a-1] = c\n\n\n\ndef dist_dfs_tree(N,E,start):\n\n    d = [-1]*N\n\n    d[start] = 0\n\n    q = [start]\n\n    while q:\n\n        i = q.pop()\n\n        ci = d[i]\n\n        for j,cj in list(E[i].items()):\n\n            if d[j] !=-1:continue\n\n            d[j] = ci+cj\n\n            q.append(j)\n\n    return d\n\n\n\nd = dist_dfs_tree(N,E,K-1)\n\nfor x,y in XY:\n\n    print((d[x-1]+d[y-1]))", "score": 1.0, "codebleu": 0.2914704976103795, "crystalbleu": 0.33429344237342246, "codebertscore": 0.83, "codescore": 0.7153028249740601, "surfaceSim": 0.625655624568668, "abs_surfaceSim_minus_score": 0.37434437543133203}
{"golden_code": "def popcount(x):\n\n  r = 0\n\n  while x:\n\n    if x & 1:\n\n      r += 1\n\n    x >>= 1\n\n  return r\n\n\n\nn = int(eval(input()))\n\nr = list(range(n))\n\na = [[0, 0] for _ in r]\n\nfor i in r:\n\n  for _ in range(int(eval(input()))):\n\n    x, y = list(map(int, input().split()))\n\n    a[i][y] |= 1 << (x - 1)\n\n\n\nm = 0\n\nl = (1 << n) - 1\n\nfor x in range(1, l + 1):\n\n  if all(a[i][0] & x == a[i][1] & l - x == 0 for i in r if x >> i & 1):\n\n    m = max(m, popcount(x))\n\nprint(m)\n", "generated_code": "from itertools import combinations\n\n \n\nn = int(eval(input()))\n\nr = list(range(n))\n\na = [(set(), set()) for _ in r]\n\nfor i in r:\n\n  for _ in range(int(eval(input()))):\n\n    x, y = list(map(int, input().split()))\n\n    a[i][y].add(x - 1)\n\n \n\nfail = lambda x: not all(a[i][0].isdisjoint(x) and a[i][1] < x for i in x)\n\n \n\nwhile all(map(fail, list(map(set, combinations(r, n))))):\n\n  n -= 1\n\nprint(n)", "score": 1.0, "codebleu": 0.3504181129455211, "crystalbleu": 0.3292495512397752, "codebertscore": 0.83, "codescore": 0.8626072406768799, "surfaceSim": 0.6020737079617493, "abs_surfaceSim_minus_score": 0.3979262920382507}
{"golden_code": "# 初期入力\n\nimport sys\n\nimport math\n\n#input = sys.stdin.readline\n\nX = int(eval(input()))\n\nlimit =10**5\n\na=0\n\nb=0\n\nfor b in range(-1*limit ,limit):\n\n    a5 =X+pow(b,5)\n\n    if 0 <= a5: \n\n        a=math.pow(a5,0.2)\n\n        a_int =int(a)\n\n        dif =a_int**5 -b**5 -X\n\n        if abs(dif)<10**(-5):\n\n            break\n\n    else:\n\n        continue\n\nprint((a_int,b))", "generated_code": "X = int(eval(input()))\n\ny =120\n\na ={i**5 for i in range(-y,y)}\n\nans_a =0\n\nans_b =0\n\nfor b in range(-y,y):\n\n    if X +b**5 in a:\n\n        #ans_a =int( (X +b**5 +1)**0.2 )\n\n        if X +b**5 >0:\n\n            ans_a =int( (X +b**5 )**0.2 )\n\n        else:\n\n            ans_a = -int( abs(X +b**5 )**0.2 )\n\n        ans_b =b\n\n        break\n\nprint((ans_a,ans_b))\n", "score": 1.0, "codebleu": 0.14899929593769945, "crystalbleu": 0.20473938106299075, "codebertscore": 0.81, "codescore": 0.9899312257766724, "surfaceSim": 0.5722222222222222, "abs_surfaceSim_minus_score": 0.4277777777777778}
{"golden_code": "n=int(eval(input()))\n\nnode={i:[] for i in range(1,n+1)}\n\nvisited=[False for i in range(n+1)]\n\nq=[]\n\nfor _ in range(n-1):\n\n    a,b=list(map(int,input().split()))\n\n    node[a].append(b)\n\n    node[b].append(a)\n\n    q.append((a,b))\n\n\n\nmother=q[0][0]\n\nvisited[mother]=True\n\n\n\nd=[]\n\ne=[]\n\n\n\n\n\npaint={i:{} for i in range(1,n+1)}\n\n\n\nmother_paint=[0 for i in range(n+1)]\n\n\n\n#使う要素 node visited paint mother_paint の四つのリスト\n\nc=1\n\nfor child in node[mother]:\n\n    visited[child]=True\n\n    paint[mother][child]=c\n\n    paint[child][mother]=c\n\n    mother_paint[child]=c\n\n    c+=1\n\n    d.append(child)\n\n    \n\nwhile d:\n\n    for parent in d:\n\n        p=1 \n\n        for child in node[parent]:\n\n            if visited[child]==False:\n\n                visited[child]=True\n\n                if p!=mother_paint[parent]:\n\n                    paint[parent][child]=p\n\n                    paint[child][parent]=p\n\n                    mother_paint[child]=p\n\n                    p+=1\n\n                    e.append(child)\n\n                else:\n\n                    p+=1\n\n                    paint[parent][child]=p\n\n                    paint[child][parent]=p\n\n                    mother_paint[child]=p\n\n                    p+=1\n\n                    e.append(child)\n\n    if e:\n\n        d=e\n\n        e=[]\n\n    else:\n\n        d=[]\n\n        e=[]\n\nK=0\n\nfor i in range(1,n+1):\n\n    K=max(K,len(node[i]))\n\nprint(K)\n\nfor i in range(n-1):\n\n    s,t=q[i][0],q[i][1]\n\n    print((paint[s][t]))", "generated_code": "#problem1\n\nfrom collections import deque\n\nd=deque()\n\ne=deque()\n\n\n\nN=int(eval(input()))\n\ngraph=[[] for i in range(N+1)]\n\nD=[]\n\nfor _ in range(N-1):\n\n    a,b=list(map(int,input().split()))\n\n    graph[a].append(b)\n\n    graph[b].append(a)\n\n    D.append((a,b))\n\n    \n\n#頂点1からスタート\n\nK=0\n\nd.append(1)\n\nvisited=[False for i in range(N+1)]\n\ncolor=[-1 for i in range(N+1)]\n\nvisited[1]=True\n\ncolor[1]=-1\n\ndic={}\n\nwhile d:\n\n    while d:\n\n        x=d.popleft()\n\n        par_color=color[x]\n\n        c=1\n\n        for node in graph[x]:\n\n            if visited[node]==False:\n\n                visited[node]=True\n\n                e.append(node)                \n\n                if c!=par_color:\n\n                    color[node]=c\n\n                    dic[(x,node)]=c\n\n                elif c==par_color:\n\n                    c+=1\n\n                    color[node]=c\n\n                    dic[(x,node)]=c\n\n                c+=1\n\n    if e:\n\n        d=e\n\n        e=deque()\n\n\n\nA=max(color)\n\nprint(A)\n\nfor que in D:\n\n    a,b=que\n\n    if (a,b) in list(dic.keys()):\n\n        print((dic[que]))\n\n    else:\n\n        print((dic[(b,a)]))\n\n    ", "score": 1.0, "codebleu": 0.25161642514273375, "crystalbleu": 0.24145884618691826, "codebertscore": 0.83, "codescore": 0.7785912156105042, "surfaceSim": 0.7123441828254847, "abs_surfaceSim_minus_score": 0.28765581717451527}
{"golden_code": "import sys\n\n\n\ninit = ''.join(sys.stdin.read().split())\n\n\n\n# Bidirectional search using breadth-first search\n\ndef solve(start, goal):\n\n    if start == goal:\n\n        return 0\n\n    generated_state = {start: 0, goal: 1}   # 0: foreward, 1: backward\n\n    step = {start: 0, goal: 0}\n\n    s = 0\n\n    c_d = [(start, 0), (goal, 1)] # configure and direction\n\n    while True:\n\n        q = iter(c_d)\n\n        c_d = []\n\n        s += 1\n\n        for c, d in q:\n\n            i = c.find('0')\n\n            if 0 <= i <= 5:\n\n                t = str.maketrans('0' + c[i+3], c[i+3] + '0')\n\n                t_c = c.translate(t)\n\n                if t_c in generated_state:\n\n                    if generated_state[t_c] != d:\n\n                        return s + step[t_c]\n\n                else:\n\n                    generated_state[t_c] = d\n\n                    step[t_c] = s\n\n                    c_d.append((t_c, d))\n\n            if i >= 3:\n\n                t = str.maketrans('0' + c[i-3], c[i-3] + '0')\n\n                t_c = c.translate(t)\n\n                if t_c in generated_state:\n\n                    if generated_state[t_c] != d:\n\n                        return s + step[t_c]\n\n                else:\n\n                    generated_state[t_c] = d\n\n                    step[t_c] = s\n\n                    c_d.append((t_c, d))\n\n            if i == 0 or i == 1 or i == 3 or i == 4 or i == 6 or i == 7:\n\n                t = str.maketrans('0' + c[i+1], c[i+1] + '0')\n\n                t_c = c.translate(t)\n\n                if t_c in generated_state:\n\n                    if generated_state[t_c] != d:\n\n                        return s + step[t_c]\n\n                else:\n\n                    generated_state[t_c] = d\n\n                    step[t_c] = s\n\n                    c_d.append((t_c, d))\n\n            if i == 1 or i == 2 or i == 4 or i == 5 or i == 7 or i == 8:\n\n                t = str.maketrans('0' + c[i-1], c[i-1] + '0')\n\n                t_c = c.translate(t)\n\n                if t_c in generated_state:\n\n                    if generated_state[t_c] != d:\n\n                        return s + step[t_c]\n\n                else:\n\n                    generated_state[t_c] = d\n\n                    step[t_c] = s\n\n                    c_d.append((t_c, d))\n\n\n\nprint((solve(init, '123456780')))", "generated_code": "adjacent = (\n\n    (1, 3),       # 0\n\n    (0, 2, 4),    # 1\n\n    (1, 5),       # 2\n\n    (0, 4, 6),    # 3\n\n    (1, 3, 5, 7), # 4\n\n    (2, 4, 8),    # 5\n\n    (3, 7),       # 6\n\n    (4, 6, 8),    # 7\n\n    (5, 7)        # 8\n\n)\n\n\n\nimport collections\n\n\n\nGOAL = [1, 2, 3, 4, 5, 6, 7, 8, 0]\n\n\n\n# Bidirectional search using breadth-first search\n\ndef solve(start):\n\n    if start == GOAL:\n\n        return 0\n\n    # 0: forward, 1: backward\n\n    generated_state = {tuple(start): 0, tuple(GOAL): 1}\n\n    step = {tuple(start): 0, tuple(GOAL): 0}\n\n    s = 0\n\n    state1 = [(start, 0), (GOAL, 1)]\n\n    while state1:\n\n        state2 = state1[:]\n\n        state1 = []\n\n        s += 1\n\n        for s2, d in state2:\n\n            i = s2.index(0)\n\n            for p in adjacent[i]:\n\n                s1 = s2[:]\n\n                s1[i], s1[p] = s1[p], 0\n\n                key = tuple(s1)\n\n                if key in generated_state:\n\n                    if generated_state[key] != d:\n\n                        return s + step[key]\n\n                    continue\n\n                state1.append((s1, d))\n\n                generated_state[key] = d\n\n                step[key] = s\n\n\n\nimport sys\n\n\n\nstart = list(map(int, sys.stdin.read().split()))\n\n\n\nprint((solve(start)))", "score": 1.0, "codebleu": 0.20781511230742214, "crystalbleu": 0.12875987428389435, "codebertscore": 0.78, "codescore": 0.8067405819892883, "surfaceSim": 0.7224839579208511, "abs_surfaceSim_minus_score": 0.27751604207914893}
{"golden_code": "import sys\n\nsys.setrecursionlimit(2147483647)\n\nINF=float(\"inf\")\n\nMOD=10**9+7\n\ninput=lambda :sys.stdin.readline().rstrip()\n\ndef resolve():\n\n    n,T=list(map(int,input().split()))\n\n    AB=[tuple(map(int,input().split())) for _ in range(n)]\n\n    ans=-INF\n\n\n\n    # 何も考えずやる\n\n    dp=[0]*T\n\n    for i in range(n):\n\n        a,b=AB[i]\n\n        ndp=dp[:]\n\n        for t in range(T):\n\n            if(t+a<T):\n\n                ndp[t+a]=max(ndp[t+a],dp[t]+b)\n\n            else:\n\n                ans=max(ans,dp[t]+b)\n\n        dp=ndp\n\n    ans=max(ans,max(dp))\n\n\n\n    # 時間が最もかかるもののうち、価値が最大のものを最後にする\n\n    AB.sort()\n\n    la,lb=AB[-1]\n\n\n\n    dp=[0]*T\n\n    for i in range(n-1):\n\n        a,b=AB[i]\n\n        ndp=dp[:]\n\n        for t in range(T):\n\n            if(t+a<T):\n\n                ndp[t+a]=max(ndp[t+a],dp[t]+b)\n\n            else:\n\n                ans=max(ans,dp[t]+b)\n\n        dp=ndp\n\n    ans=max(ans,max(dp)+lb)\n\n\n\n    # 価値が最大のもののうち、時間が最もかかるものを最後にする\n\n    AB.sort(lambda x:(x[1],x[0]))\n\n    la,lb=AB[-1]\n\n\n\n    dp=[0]*T\n\n    for i in range(n-1):\n\n        a,b=AB[i]\n\n        ndp=dp[:]\n\n        for t in range(T):\n\n            if(t+a<T):\n\n                ndp[t+a]=max(ndp[t+a],dp[t]+b)\n\n            else:\n\n                ans=max(ans,dp[t]+b)\n\n        dp=ndp\n\n    ans=max(ans,max(dp)+lb)\n\n\n\n    print(ans)\n\nresolve()", "generated_code": "import sys\n\nsys.setrecursionlimit(2147483647)\n\nINF=float(\"inf\")\n\nMOD=10**9+7\n\ninput=lambda :sys.stdin.readline().rstrip()\n\ndef resolve():\n\n    n,T=list(map(int,input().split()))\n\n    AB=[tuple(map(int,input().split())) for _ in range(n)]\n\n    AB.sort()\n\n\n\n    dp=[0]*T\n\n    ans=-INF\n\n    for i in range(n):\n\n        a,b=AB[i]\n\n        ndp=dp[:]\n\n        for t in range(T):\n\n            if(t+a<T):\n\n                ndp[t+a]=max(ndp[t+a],dp[t]+b)\n\n            else:\n\n                ans=max(ans,dp[t]+b)\n\n        dp=ndp\n\n    print((max(ans,max(dp))))\n\nresolve()", "score": 1.0, "codebleu": 0.44417108490355317, "crystalbleu": 0.283859753416872, "codebertscore": 0.9, "codescore": 0.8380003571510315, "surfaceSim": 0.8171545968156138, "abs_surfaceSim_minus_score": 0.18284540318438625}
{"golden_code": "N = int(eval(input()))\n\nA = list(map(int, input().split()))\n\n# 中央値\n\nB = []\n\nfor i in range(N):\n\n    B.append(A[i] - (i+1))\n\nb = sorted(B)[N//2]\n\n\n\nans = 0\n\nfor i in range(N):\n\n    ans += abs(A[i] - (i + 1) - b)\n\n\n\nprint(ans)\n\n\n", "generated_code": "from statistics import median_low\n\n\n\nN = int(eval(input()))\n\nA = list(map(int, input().split()))\n\n\n\nD = []\n\nfor i in range(N):\n\n    D.append(A[i] - (i+1))\n\n\n\nm = median_low(D)\n\nans = 0\n\nfor d in D:\n\n    ans += abs(d - m)\n\n\n\nprint(ans)\n", "score": 1.0, "codebleu": 0.47752634309632747, "crystalbleu": 0.4896264606181011, "codebertscore": 0.88, "codescore": 0.9704713821411133, "surfaceSim": 0.7803191489361703, "abs_surfaceSim_minus_score": 0.21968085106382973}
{"golden_code": "def main():\n\n    S = eval(input())\n\n    w1 = 'dream'[::-1]\n\n    w2 = 'dreamer'[::-1]\n\n    w3 = 'erase'[::-1]\n\n    w4 = 'eraser'[::-1]\n\n    # print(w1,w2,w3,w4)\n\n    S = S[::-1]\n\n    # print(S)\n\n\n\n    # words = ['dream', 'dreamer', 'erase', 'eraser']\n\n    words = [w1, w2, w3, w4]\n\n    T = ''\n\n    while S != T:\n\n        cand = []\n\n        for w in words:\n\n            new_t = T + w\n\n            cand.append(new_t) \n\n        # print('cand', cand)\n\n        ans = False\n\n        for c in cand:\n\n            if c == S[:len(c)]:\n\n                T = c\n\n                ans = True\n\n\n\n        if not ans:\n\n            break\n\n\n\n    if S == T:\n\n        print('YES')\n\n    else:\n\n        print(\"NO\")\n\n\n\nif __name__ == \"__main__\":\n\n    main()", "generated_code": "def main():\n\n    S = eval(input())\n\n    w1 = 'dream'[::-1]\n\n    w2 = 'dreamer'[::-1]\n\n    w3 = 'erase'[::-1]\n\n    w4 = 'eraser'[::-1]\n\n    S = S[::-1]\n\n    words = [w1, w2, w3, w4]\n\n\n\n    flag = False\n\n    i = 0\n\n    while i < len(S):\n\n        for w in words:\n\n            if S[i:].startswith(w):\n\n                i += len(w)\n\n                flag = True\n\n                break\n\n\n\n        if not flag:\n\n            print(\"NO\")\n\n            exit()\n\n        flag = False\n\n\n\n    print(\"YES\")\n\n\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()", "score": 1.0, "codebleu": 0.49477669182208117, "crystalbleu": 0.5490720306256603, "codebertscore": 0.89, "codescore": 0.018502211198210716, "surfaceSim": 0.8450097847358121, "abs_surfaceSim_minus_score": 0.15499021526418788}
{"golden_code": "import numpy as np \n\nn = int(eval(input()))\n\nx = list(map(int, input().split()))\n\nx = np.array(x)\n\nans = float('inf')\n\nidx = 200\n\nfor i in range(100):\n\n  y = x \n\n  ans = min(ans, np.sum((y-i)**2))\n\n  \n\nprint(ans)", "generated_code": "N = int(eval(input()))\n\nX = list(map(int, input().split()))\n\nmx = max(X)\n\nans = float('inf')\n\nfor i in range(mx+1):\n\n  tmp = 0\n\n  for x in X:\n\n    tmp += (x-(i+1))**2\n\n  ans = min(ans, tmp)\n\nprint(ans)", "score": 1.0, "codebleu": 0.3028605879498977, "crystalbleu": 0.0, "codebertscore": 0.86, "codescore": 0.14002573490142822, "surfaceSim": 0.6960321864594894, "abs_surfaceSim_minus_score": 0.3039678135405106}
{"golden_code": "s = eval(input())\n\nlen_s = len(s)\n\ncnt = [0, 0]\n\nfor i in range(1, len(s)):\n\n    memo_0 = s[i - 1]\n\n    memo_1 = s[len_s - i]\n\n    if s[i] != memo_0:\n\n        cnt[0] += 1\n\n    if s[len_s - i - 1] != memo_1:\n\n        cnt[1] += 1\n\nprint((min(cnt)))\n", "generated_code": "s = eval(input())\n\nlen_s = len(s)\n\ncnt = 0\n\nfor i in range(1, len(s)):\n\n    memo_0 = s[i - 1]\n\n    if s[i] != memo_0:\n\n        cnt += 1\n\nprint(cnt)\n", "score": 1.0, "codebleu": 0.4384389562316314, "crystalbleu": 0.42335612295794856, "codebertscore": 0.93, "codescore": 0.3044774532318115, "surfaceSim": 0.8400809716599189, "abs_surfaceSim_minus_score": 0.1599190283400811}
{"golden_code": "N = int(eval(input()))\n\na = [int(eval(input())) for i in range(N)]\n\nnow = a[0]\n\ncount = 1\n\nc = 0\n\nfor i in range(10**6):\n\n    if now != 2:\n\n        count += 1\n\n        now = a[now - 1]\n\n    else:\n\n        print(count)\n\n        c = 1\n\n        break\n\nif c == 0:\n\n    print((-1))\n", "generated_code": "N = int(eval(input()))\n\na = [0] + [int(eval(input())) for _ in range(N)]\n\nx = 1\n\nvisited = set([1])\n\nanswer = 0\n\n\n\nwhile True:\n\n  x = a[x]\n\n  if x in visited:\n\n    answer = -1\n\n    break\n\n  visited.add(x)\n\n  answer += 1\n\n  if x == 2:\n\n    break\n\n    \n\nprint(answer)\n", "score": 1.0, "codebleu": 0.2758692333085177, "crystalbleu": 0.20193587107643257, "codebertscore": 0.84, "codescore": 0.9416622519493103, "surfaceSim": 0.6671231171417902, "abs_surfaceSim_minus_score": 0.3328768828582098}
{"golden_code": "N, D = list(map(int, input().split()))\n\ncnt = 0\n\nfor _ in range(N):\n\n    x, y = list(map(int, input().split()))\n\n    if x ** 2 + y ** 2 <= D ** 2:\n\n        cnt += 1\n\n        \n\nprint(cnt)", "generated_code": "N, D = list(map(int, input().split()))\n\ncnt = 0\n\nfor _ in range(N):\n\n    x, y = list(map(int, input().split()))\n\n    if x * x + y * y <= D * D:\n\n        cnt += 1\n\n        \n\nprint(cnt)", "score": 1.0, "codebleu": 0.7862404220058002, "crystalbleu": 0.8164474750850377, "codebertscore": 0.96, "codescore": 0.7884530425071716, "surfaceSim": 0.9312393887945671, "abs_surfaceSim_minus_score": 0.06876061120543286}
{"golden_code": "def main():\n\n    mod = 998244353\n\n    s, k = input().split()\n\n    k = int(k)\n\n    n = len(s)\n\n\n\n    one = s.count(\"1\")\n\n\n\n    cnt = 0\n\n    zero_list = []\n\n    for i in range(n):\n\n        if s[i] == \"0\":\n\n            zero_list.append(cnt)\n\n            cnt = 0\n\n        else:\n\n            cnt += 1\n\n\n\n    z = 0\n\n    mm = min(one, k)\n\n\n\n    dp = [[0]*(one+1) for _ in [0]*(one+1)]\n\n    dp[0][0] = 1\n\n\n\n    for i in range(len(zero_list)):\n\n        dp2 = [[0]*(mm+1) for _ in [0]*(one+1)]\n\n        base = zero_list[i]\n\n        # j:何個今までに入れたか\n\n        for j in range(one+1):\n\n            # l:何個入れるか\n\n            for l in range(one+1-j):\n\n                if l < z+base-j:\n\n                    continue\n\n                ml = max(l-base, 0)\n\n                # p:これまでのペナルティ\n\n                for p in range(min(one, k)+1):\n\n                    q = p+ml\n\n                    if q <= mm:\n\n                        dp2[j+l][q] = (dp2[j+l][q]+dp[j][p]) % mod\n\n                    else:\n\n                        break\n\n        z += base\n\n        dp = dp2\n\n    print((sum([sum(i) for i in dp]) % mod))\n\n\n\n\n\nmain()", "generated_code": "def main():\n\n    mod = 998244353\n\n    s, k = input().split()\n\n    k, n, one, cnt, z, zero_list = int(k), len(s), s.count(\"1\")+1, 0, 0, []\n\n    for i in range(n):\n\n        if s[i] == \"0\":\n\n            zero_list.append(cnt)\n\n            cnt = 0\n\n        else:\n\n            cnt += 1\n\n    mm = min(one-1, k)\n\n\n\n    dp = [[0]*(mm+1) for _ in [0]*one]\n\n    dp[0][0] = 1\n\n\n\n    for i in zero_list:\n\n        dp2 = [[0]*(mm+1) for _ in [0]*one]\n\n        for j in range(one):\n\n            for l in range(max(z+i-j, 0), one-j):\n\n                ml = max(l-i, 0)\n\n                for p in range(min(j, mm-ml)+1):\n\n                    dp2[j+l][p+ml] = (dp2[j+l][p+ml]+dp[j][p]) % mod\n\n        z += i\n\n        dp = dp2\n\n    print((sum([sum(i) for i in dp]) % mod))\n\n\n\n\n\nmain()", "score": 1.0, "codebleu": 0.4652619766024418, "crystalbleu": 0.6697047631519178, "codebertscore": 0.9, "codescore": 0.9486299157142639, "surfaceSim": 0.8569450581823539, "abs_surfaceSim_minus_score": 0.1430549418176461}
{"golden_code": "N,L = list(map(int, input().split()))\n\ntaste = [L+i-1 for i in range(1,N+1)]\n\nif taste[-1] < 0:\n\n  print((sum(taste) + min([abs(x) for x in taste])))\n\nelse:\n\n  print((sum(taste) - min([abs(x) for x in taste])))", "generated_code": "N, L = list(map(int, input().split()))\n\n\n\ntaste = [L+i-1 for i in range(1, N+1)]\n\n\n\nif 0 in taste:\n\n    select = 0\n\nelse:\n\n    select_with_ind = min(enumerate(taste), key = lambda x: abs(x[1]))\n\n    select = select_with_ind[1]\n\n    \n\nprint((sum(taste) - select))", "score": 1.0, "codebleu": 0.46232959341997143, "crystalbleu": 0.4892630859485042, "codebertscore": 0.9, "codescore": 0.5088438391685486, "surfaceSim": 0.6571953633022336, "abs_surfaceSim_minus_score": 0.3428046366977664}
{"golden_code": "class prime_factorize_by_osa_k():\n\n    def __init__(self, max_val):\n\n        '''\n\n        割ることが出来る最小の値を格納したリストを返す\n\n        :param max_val:\n\n        :return:\n\n        '''\n\n        self.minFactor = [-1] * (max_val + 1)\n\n        for i in range(2, max_val + 1):\n\n            if self.minFactor[i] == -1:\n\n                self.minFactor[i] = i\n\n                # エラトステネスの篩と同様の処理を行う\n\n                for j in range(i * i, max_val + 1, i):\n\n                    if self.minFactor[j] == -1:\n\n                        self.minFactor[j] = i\n\n\n\n    def osa_k(self, n):\n\n        '''\n\n        preprocessをしたあと、O(logN)で素因数分解を行う。nの最大値をn_maxとする。\n\n        :param n:\n\n        :return:\n\n        '''\n\n        from collections import defaultdict\n\n        d = defaultdict(int)\n\n        now = n\n\n        while now > 1:\n\n            d[self.minFactor[now]] += 1\n\n            now //= self.minFactor[now]\n\n        return d\n\ndef gcd(a, b):\n\n    while b: a, b = b, a % b\n\n    return a\n\n\n\nN = int(eval(input()))\n\nA = list(map(int, input().split()))\n\n# N = 10 ** 6\n\n# A = [10 ** 6] * N\n\nob = prime_factorize_by_osa_k(10 ** 6)\n\npairwise = False\n\nprime_key = set(ob.osa_k(A[-1]).keys())\n\nbreak_flag = False\n\nprime_flags = [False] * (10 ** 6 + 1)\n\nfor i in range(N):\n\n    for key in list(ob.osa_k(A[i]).keys()):\n\n        if prime_flags[key]:\n\n            break_flag = True\n\n            break\n\n        else:\n\n            prime_flags[key] = True\n\n    if break_flag:\n\n        break\n\nelse:\n\n    pairwise = True\n\nif pairwise:\n\n    print('pairwise coprime')\n\n    exit()\n\nwork = gcd(A[0], A[1])\n\nfor i in range(2, N):\n\n    work = gcd(work, A[i])\n\nif work != 1:\n\n    print('not coprime')\n\nelse:\n\n    print('setwise coprime')", "generated_code": "def gcd(a, b):\n\n    while b: a, b = b, a % b\n\n    return a\n\ndef isPrimeMR(n):\n\n    d = n - 1\n\n    d = d // (d & -d)\n\n    L = [2]\n\n    for a in L:\n\n        t = d\n\n        y = pow(a, t, n)\n\n        if y == 1: continue\n\n        while y != n - 1:\n\n            y = (y * y) % n\n\n            if y == 1 or t == n - 1: return 0\n\n            t <<= 1\n\n    return 1\n\ndef findFactorRho(n):\n\n    m = 1 << n.bit_length() // 8\n\n    for c in range(1, 99):\n\n        f = lambda x: (x * x + c) % n\n\n        y, r, q, g = 2, 1, 1, 1\n\n        while g == 1:\n\n            x = y\n\n            for i in range(r):\n\n                y = f(y)\n\n            k = 0\n\n            while k < r and g == 1:\n\n                ys = y\n\n                for i in range(min(m, r - k)):\n\n                    y = f(y)\n\n                    q = q * abs(x - y) % n\n\n                g = gcd(q, n)\n\n                k += m\n\n            r <<= 1\n\n        if g == n:\n\n            g = 1\n\n            while g == 1:\n\n                ys = f(ys)\n\n                g = gcd(abs(x - ys), n)\n\n        if g < n:\n\n            if isPrimeMR(g): return g\n\n            elif isPrimeMR(n // g): return n // g\n\n            return findFactorRho(g)\n\ndef primeFactor(n):\n\n    i = 2\n\n    ret = {}\n\n    rhoFlg = 0\n\n    while i*i <= n:\n\n        k = 0\n\n        while n % i == 0:\n\n            n //= i\n\n            k += 1\n\n        if k: ret[i] = k\n\n        i += 1 + i % 2\n\n        if i == 101 and n >= 2 ** 20:\n\n            while n > 1:\n\n                if isPrimeMR(n):\n\n                    ret[n], n = 1, 1\n\n                else:\n\n                    rhoFlg = 1\n\n                    j = findFactorRho(n)\n\n                    k = 0\n\n                    while n % j == 0:\n\n                        n //= j\n\n                        k += 1\n\n                    ret[j] = k\n\n\n\n    if n > 1: ret[n] = 1\n\n    if rhoFlg: ret = {x: ret[x] for x in sorted(ret)}\n\n    return ret\n\ndef gcd(a, b):\n\n    while b: a, b = b, a % b\n\n    return a\n\n\n\nN = int(eval(input()))\n\nA = list(map(int, input().split()))\n\n# N = 10 ** 6\n\n# A = [10 ** 6] * N\n\npairwise = False\n\nprime_key = set(primeFactor(A[-1]).keys())\n\nbreak_flag = False\n\nprime_flags = [False] * (10 ** 6 + 1)\n\nfor i in range(N):\n\n    for key in list(primeFactor(A[i]).keys()):\n\n        if prime_flags[key]:\n\n            break_flag = True\n\n            break\n\n        else:\n\n            prime_flags[key] = True\n\n    if break_flag:\n\n        break\n\nelse:\n\n    pairwise = True\n\nif pairwise:\n\n    print('pairwise coprime')\n\n    exit()\n\nwork = gcd(A[0], A[1])\n\nfor i in range(2, N):\n\n    work = gcd(work, A[i])\n\nif work != 1:\n\n    print('not coprime')\n\nelse:\n\n    print('setwise coprime')", "score": 1.0, "codebleu": 0.4807799974384116, "crystalbleu": 0.33354607939601016, "codebertscore": 0.79, "codescore": 0.9900160431861877, "surfaceSim": 0.69665907365224, "abs_surfaceSim_minus_score": 0.30334092634776}
{"golden_code": "n = int(eval(input()))\n\nimport math\n\nm = int(math.sqrt(n))+1\n\nanss = []\n\nfor x in range(1, m+1):\n\n  y = n//x\n\n  z = n%x\n\n  if z == 0:\n\n    anss.append(abs(x-1)+abs(y-1))\n\nprint((min(anss)))\n", "generated_code": "n = int(eval(input()))\n\ndef make_divisors(n):\n\n    divisors = []\n\n    for i in range(1, int(n**0.5)+1):\n\n        if n % i == 0:\n\n            divisors.append(i)\n\n            if i != n // i:\n\n                divisors.append(n//i)\n\n\n\n    #divisors.sort(reverse=True)\n\n    return divisors\n\n\n\nl = make_divisors(n)\n\nmin_ = float('inf')\n\nfor i in range(len(l)):\n\n    min_ = min(min_, l[i]-1+n//l[i]-1)\n\nprint(min_)\n", "score": 1.0, "codebleu": 0.2502258440548351, "crystalbleu": 0.17501093795230596, "codebertscore": 0.79, "codescore": 0.1638467162847519, "surfaceSim": 0.6045469912102772, "abs_surfaceSim_minus_score": 0.3954530087897228}
{"golden_code": "N=int(eval(input()))\n\nd=list(map(int, input().split()))\n\n\n\nimport numpy as np\n\nd = np.array(d)\n\n\n\nprint(( ( (np.sum(d))**2 - np.sum(d**2) ) // 2 ))\n", "generated_code": "N=int(eval(input()))\n\nd=list(map(int, input().split()))\n\n\n\ncumsum = 0\n\nfor n in range(N):\n\n    cumsum += d[n]\n\nsub_cumsum = 0\n\nans = 0\n\nfor n in range(N):\n\n    sub_cumsum += d[n]\n\n    ans += d[n] * (cumsum-sub_cumsum)\n\nprint(ans)\n", "score": 1.0, "codebleu": 0.318046507533285, "crystalbleu": 0.2536321946942094, "codebertscore": 0.77, "codescore": 0.06192855164408684, "surfaceSim": 0.5314699792960662, "abs_surfaceSim_minus_score": 0.4685300207039338}
{"golden_code": "a, b, c = sorted(map(int, input().split()))\n\n\n\nprint((c*10 + b + a))", "generated_code": "a, b, c = list(map(int, input().split()))\n\n\n\nprint((max(a, b, c)*9 + (a + b + c)))", "score": 1.0, "codebleu": 0.549214423833286, "crystalbleu": 0.0, "codebertscore": 0.92, "codescore": 0.026309873908758163, "surfaceSim": 0.8780487804878049, "abs_surfaceSim_minus_score": 0.12195121951219512}
{"golden_code": "import numpy as np\n\n\n\na = [list(map(int, input().split())) for _ in range(3)]\n\na = np.array(a)\n\nn = int(eval(input()))\n\n\n\nfor _ in range(n):\n\n    b = int(eval(input()))\n\n    \n\n    for j in range(3):\n\n        for i in range(3):\n\n            if a[j][i] == b:\n\n                a[j][i] = 0\n\n\n\nat = a.transpose()\n\nflag = False\n\nfor i in range(3):\n\n    if sum(a[:][i]) == 0 or sum(at[:][i]) == 0:\n\n        flag = True\n\n        break\n\ndiag = a[0][0] + a[1][1] + a[2][2]\n\ndiag2 = a[2][0] + a[1][1] + a[0][2]\n\nif diag == 0 or diag2 == 0:\n\n    flag = True\n\n\n\nprint((\"Yes\" if flag else \"No\"))", "generated_code": "a = [list(map(int, input().split())) for _ in range(3)]\n\nn = int(eval(input()))\n\nb = [int(eval(input())) for _ in range(n)]\n\n\n\nflag = False\n\nfor i in range(3):\n\n    if a[i][0] in b and a[i][1] in b and a[i][2] in b:\n\n        flag = True\n\n        break\n\n    if a[0][i] in b and a[1][i] in b and a[2][i] in b:\n\n        flag = True\n\n        break\n\nif a[0][0] in b and a[1][1] in b and a[2][2] in b:\n\n    flag = True\n\nif a[2][0] in b and a[1][1] in b and a[0][2] in b:\n\n    flag = True\n\n    \n\nprint((\"Yes\" if flag else \"No\"))", "score": 1.0, "codebleu": 0.3309127319675109, "crystalbleu": 0.656405177203806, "codebertscore": 0.86, "codescore": 0.7095080614089966, "surfaceSim": 0.6774956970740104, "abs_surfaceSim_minus_score": 0.32250430292598964}
{"golden_code": "import sys\n\nstdin = sys.stdin\n\n \n\nsys.setrecursionlimit(10**8) \n\n \n\ndef li(): return list(map(int, stdin.readline().split()))\n\ndef li_(): return [int(x)-1 for x in stdin.readline().split()]\n\ndef lf(): return list(map(float, stdin.readline().split()))\n\ndef ls(): return stdin.readline().split()\n\ndef ns(): return stdin.readline().rstrip()\n\ndef lc(): return list(ns())\n\ndef ni(): return int(stdin.readline())\n\ndef nf(): return float(stdin.readline())\n\n\n\n\n\nn = ni()\n\na = [ni() for _ in range(n)]\n\n\n\ncnt = {i+1: ai for i, ai in enumerate(a)}\n\n\n\nprev = -100\n\ncur = 0\n\nans = 0\n\nfor key in sorted(cnt.keys()):\n\n    if cnt[key] == 0:\n\n        continue\n\n    \n\n    if prev == -100:\n\n        prev = key\n\n    \n\n    if (key-prev) < 2:\n\n        cur += cnt[key]\n\n    else:\n\n        cur = cnt[key]\n\n        \n\n    ans += cur // 2\n\n    cur -= 2 * (cur//2)\n\n    \n\n    prev = key\n\n        \n\nprint(ans)", "generated_code": "import sys\n\nstdin = sys.stdin\n\n\n\nsys.setrecursionlimit(10 ** 7)\n\n\n\ndef li(): return list(map(int, stdin.readline().split()))\n\ndef li_(): return [int(x) - 1 for x in stdin.readline().split()]\n\ndef lf(): return list(map(float, stdin.readline().split()))\n\ndef ls(): return stdin.readline().split()\n\ndef ns(): return stdin.readline().rstrip()\n\ndef lc(): return list(ns())\n\ndef ni(): return int(stdin.readline())\n\ndef nf(): return float(stdin.readline())\n\n\n\nn = ni()\n\n\n\nans = 0\n\nplus = 0\n\na = [ni() for _ in range(n)]\n\n\n\nfor ai in a:\n\n    ans += ((ai+plus) // 2)\n\n    plus = (ai+plus) % 2 if ai > 0 else 0\n\n\n\nprint(ans)", "score": 1.0, "codebleu": 0.5423049581901753, "crystalbleu": 0.5658281485753505, "codebertscore": 0.92, "codescore": 0.5119450092315674, "surfaceSim": 0.7028496325945397, "abs_surfaceSim_minus_score": 0.2971503674054603}
{"golden_code": "def factorial(N):\n\n    power_r = 1\n\n    for n in range(2,N+1):\n\n        power_r *= n\n\n        power_r %= 10**9+7\n\n    return power_r\n\n\n\nif __name__ == '__main__':\n\n    N = int(eval(input()))\n\n    print((factorial(N)))", "generated_code": "def factorial(N):\n\n    power_r = 1\n\n    for n in range(2,N+1):\n\n        power_r = power_r*n % (10**9+7)\n\n    return power_r\n\n\n\nif __name__ == '__main__':\n\n    N = int(eval(input()))\n\n    print((factorial(N)))", "score": 1.0, "codebleu": 0.7788566774382812, "crystalbleu": 0.0, "codebertscore": 0.98, "codescore": 0.9938264489173889, "surfaceSim": 0.9611436950146628, "abs_surfaceSim_minus_score": 0.03885630498533721}
{"golden_code": "import sys\n\nfrom collections import Counter, deque, defaultdict\n\nfrom itertools import accumulate, permutations, combinations, takewhile, compress, cycle\n\nfrom functools import reduce\n\nfrom math import ceil, floor, log10, log2, factorial\n\nfrom pprint import pprint\n\n\n\nsys.setrecursionlimit(1000000)\n\n# MOD = 10 ** 9 + 7\n\n# N = int(input())\n\n# A = [int(x) for x in input().split()]\n\n# V = [[0] * 100 for _ in range(100)]\n\n# A = [int(input()) for _ in range(N)]\n\n\n\nN, W = [int(x) for x in input().split()]\n\n\n\ndp = [float('inf')] * 1000 * 100*10\n\nvs = set()\n\nvs.add(0)\n\ndp[0] = 0\n\n\n\nfor i in range(N):\n\n    w, v = [int(x) for x in input().split()]\n\n\n\n    tmpDP = dp.copy()\n\n    for vv in list(vs):\n\n        if dp[vv + v] > dp[vv] + w:\n\n            tmpDP[vv + v] = dp[vv] + w\n\n            vs.add(vv + v)\n\n    dp = tmpDP\n\n\n\n\n\nans = 0\n\nfor v in list(vs):\n\n    if dp[v] <= W:\n\n        ans = max(ans, v)\n\nprint(ans)\n", "generated_code": "import sys\n\nfrom collections import Counter, deque, defaultdict\n\nfrom itertools import accumulate, permutations, combinations, takewhile, compress, cycle\n\nfrom functools import reduce\n\nfrom math import ceil, floor, log10, log2, factorial\n\nfrom pprint import pprint\n\n\n\nsys.setrecursionlimit(1000000)\n\n# MOD = 10 ** 9 + 7\n\n# N = int(input())\n\n# A = [int(x) for x in input().split()]\n\n# V = [[0] * 100 for _ in range(100)]\n\n# A = [int(input()) for _ in range(N)]\n\n\n\nN, W = [int(x) for x in input().split()]\n\n\n\ndp = defaultdict(lambda: float('inf'))\n\ndp[0] = 0\n\n\n\nfor i in range(N):\n\n    w, v = [int(x) for x in input().split()]\n\n\n\n    add = defaultdict(lambda: float('inf'))\n\n    for vv in list(dp.keys()):\n\n        if dp[vv + v] > dp[vv] + w:\n\n            add[vv + v] = dp[vv] + w\n\n    dp.update(add)\n\n\n\nprint((max([i for i in list(dp.items()) if i[1] <= W], key=lambda x:x[0])[0]))\n", "score": 1.0, "codebleu": 0.6335037842670902, "crystalbleu": 0.6574456773813665, "codebertscore": 0.94, "codescore": 0.660835325717926, "surfaceSim": 0.8196035242290749, "abs_surfaceSim_minus_score": 0.1803964757709251}
{"golden_code": "import sys\n\ndef input(): return sys.stdin.readline().rstrip()\n\ndef main():\n\n    x=int(eval(input()))\n\n    for i in range(-300,300):\n\n        for j in range(-300,300):\n\n            if i**5-j**5==x:\n\n                print((i,j))\n\n                sys.exit()\n\n\n\nif __name__=='__main__':\n\n    main()", "generated_code": "import sys\n\ndef input(): return sys.stdin.readline().rstrip()\n\ndef main():\n\n    x=int(eval(input()))\n\n    for a in range(-118,120):\n\n        for diff in range(238):\n\n            if a**5-(a-diff)**5>10**9:\n\n                break\n\n            if a**5-(a-diff)**5==x:\n\n                print((a,a-diff))\n\n                sys.exit()\n\n\n\nif __name__=='__main__':\n\n    main()", "score": 1.0, "codebleu": 0.5992785572757102, "crystalbleu": 0.5605509036053881, "codebertscore": 0.9, "codescore": 0.04423069953918457, "surfaceSim": 0.8797945923286523, "abs_surfaceSim_minus_score": 0.12020540767134769}
{"golden_code": "#!/usr/bin/env python3\n\ndef main():\n\n    import numpy as np\n\n\n\n    np.set_printoptions(linewidth=200)\n\n\n\n    N, W = list(map(int, input().split()))\n\n    lst = [list(map(int, input().split())) for _ in range(N)]\n\n    v_max = 10 ** 3 * 100 * 10\n\n    w_max = 10 ** 9 * v_max\n\n\n\n    # i以上の価値を持つときの最小重量\n\n    dp = np.full(v_max, w_max, dtype=np.int64)\n\n    # initialize\n\n    dp[0] = 0\n\n\n\n    for n in range(N):\n\n        w, v = lst[n]\n\n        dp[v:] = np.minimum(dp[v:], dp[:-v] + w)\n\n\n\n    ans = 0\n\n    for i, w in enumerate(dp):\n\n        if w <= W:\n\n            ans = i\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "generated_code": "#!/usr/bin/env python3\n\ndef main():\n\n    import numpy as np\n\n\n\n    N, W = list(map(int, input().split()))\n\n    lst = [list(map(int, input().split())) for _ in range(N)]\n\n    v_max = 10 ** 3 * 100 * 10\n\n    w_max = 10 ** 9 * v_max\n\n\n\n    # i以上の価値を持つときの最小重量\n\n    dp = np.full(v_max, w_max, dtype=np.int64)\n\n    # initialize\n\n    dp[0] = 0\n\n\n\n    for w, v in lst:\n\n        dp[v:] = np.minimum(dp[v:], dp[:-v] + w)\n\n\n\n    print((np.asarray(dp <= W).nonzero()[0].max()))\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 1.0, "codebleu": 0.7189057468667899, "crystalbleu": 0.7204244793230812, "codebertscore": 0.94, "codescore": 0.018532225862145424, "surfaceSim": 0.9217252396166133, "abs_surfaceSim_minus_score": 0.07827476038338665}
{"golden_code": "mod = 2019\n\nl, r = list(map(int, input().split()))\n\n\n\nif r//mod - l//mod > 0:\n\n  print((0))\n\nelse:\n\n  l %= mod\n\n  r %= mod\n\n  ans = mod\n\n  for i in range(l+1, r+1):\n\n    for j in range(l, i):\n\n      ans = min(i*j%mod, ans)\n\n    if ans == 0:\n\n      break\n\n  print(ans)", "generated_code": "mod = 2019\n\nl, r = list(map(int, input().split()))\n\n\n\nif r//mod - l//mod > 0:\n\n  print((0))\n\nelse:\n\n  l %= mod\n\n  r %= mod\n\n  ans = mod\n\n  for i in range(l, r):\n\n    for j in range(i+1, r+1):\n\n      ans = min(i*j%mod, ans)\n\n    if ans == 0:\n\n      break\n\n  print(ans)", "score": 1.0, "codebleu": 0.8412981018031557, "crystalbleu": 0.9534326843212331, "codebertscore": 0.99, "codescore": 0.9937680959701538, "surfaceSim": 0.9812734082397003, "abs_surfaceSim_minus_score": 0.01872659176029967}
{"golden_code": "S = eval(input())\n\nk = int(eval(input()))\n\nA = set()\n\nfor l in range(k+1):\n\n\tfor i in range(len(S)-l):\n\n\t\t\tA.add(S[i:i+l+1])\n\nA = sorted(list(A))\n\nprint((A[k-1]))", "generated_code": "S = eval(input())\n\nl = len(S)\n\nd = set()\n\nK = int(eval(input()))\n\nfor i in range(5):\n\n    for j in range(l-i):\n\n        d.add(S[j:j+i+1])\n\nD = sorted(list(d))\n\nprint((D[K-1]))", "score": 1.0, "codebleu": 0.42020686454425404, "crystalbleu": 0.0, "codebertscore": 0.92, "codescore": 0.5634823441505432, "surfaceSim": 0.8714285714285714, "abs_surfaceSim_minus_score": 0.12857142857142856}
{"golden_code": "import sys\n\ninput = sys.stdin.readline\n\nimport numpy as np\n\nN = int(eval(input()))\n\ndp = np.zeros((N+1,3), dtype=np.int)\n\nX = list(map(int, input().split()))\n\nfor _ in range(3):\n\n  dp[1][_] = X[_]\n\nfor n in range(2,N+1):\n\n  X = list(map(int, input().split()))\n\n  dp[n][0] = max(dp[n-1][1],dp[n-1][2]) + X[0]\n\n  dp[n][1] = max(dp[n-1][2],dp[n-1][0]) + X[1]\n\n  dp[n][2] = max(dp[n-1][0],dp[n-1][1]) + X[2]\n\nprint((max(dp[N])))", "generated_code": "#!/usr/bin python3\n\n# -*- coding: utf-8 -*-\n\n\n\ndef main():\n\n    N = int(eval(input()))\n\n    dp = [[0]*3 for i in range(N+1)]\n\n    #dp[i][j] iまでで、j=0はaを選ぶ,j=1はbを選ぶ,j=2はcを選ぶ\n\n    for i in range(1,N+1):\n\n        a, b, c=list(map(int,input().split()))\n\n        dp[i][0] = max(dp[i-1][1]+a, dp[i-1][2]+a, dp[i][0])\n\n        dp[i][1] = max(dp[i-1][2]+b, dp[i-1][0]+b, dp[i][1])\n\n        dp[i][2] = max(dp[i-1][0]+c, dp[i-1][1]+c, dp[i][2])\n\n\n\n    print((max(dp[N])))\n\n\n\nif __name__ == '__main__':\n\n    main()", "score": 1.0, "codebleu": 0.28401626298142224, "crystalbleu": 0.3704051818322755, "codebertscore": 0.82, "codescore": 0.021373463794589043, "surfaceSim": 0.5815310187820147, "abs_surfaceSim_minus_score": 0.41846898121798526}
{"golden_code": "#python3\n\nINF = int(1e9)\n\ndef main():\n\n    a, b, c, x, y = list(map(int, input().split()))\n\n    ans = INF\n\n    for i in range(2*10**5+100):\n\n        t = 2*c*i + max(x-i, 0) * a + max(y-i, 0) * b\n\n        ans = min(ans, t)\n\n    print(ans)\n\nmain()", "generated_code": "INF = int(1e5)+5\n\n\n\ndef main():\n\n    a, b, c, x, y = list(map(int, input().split()))\n\n    ans = INF*INF\n\n    for i in range(INF):\n\n        tmp = 2*i*c + a*max(x-i, 0) + b*max(y-i, 0) \n\n        ans = min(tmp, ans)\n\n    print(ans)\n\nmain()\n", "score": 1.0, "codebleu": 0.4384014145957891, "crystalbleu": 0.5640990158618128, "codebertscore": 0.93, "codescore": 0.2312561273574829, "surfaceSim": 0.9007936507936508, "abs_surfaceSim_minus_score": 0.09920634920634919}
{"golden_code": "s = eval(input())\n\n\n\nstart = -1\n\nend = 0\n\nfor i in range(len(s)):\n\n    if s[i] == 'A' and start < 0:\n\n        start = i\n\n    elif s[i] == 'Z':\n\n        end = i\n\nprint((end - start + 1))\n", "generated_code": "s = eval(input())\n\n\n\nstart = 0\n\nfor i in range(len(s)):\n\n    if s[i] == 'A':\n\n        start = i\n\n        break\n\n\n\nend = 0\n\nfor i in reversed(list(range(len(s)))):\n\n    if s[i] == 'Z':\n\n        end = i\n\n        break\n\nprint((end - start + 1))\n", "score": 1.0, "codebleu": 0.6117105849764274, "crystalbleu": 0.6050930169057582, "codebertscore": 0.93, "codescore": 0.20189358294010162, "surfaceSim": 0.739399928135106, "abs_surfaceSim_minus_score": 0.260600071864894}
{"golden_code": "import numpy as np\n\n\n\nn,l=list(map(int,input().split()))\n\nli=[]\n\nfor i in range(n):\n\n  li.append(l+i)\n\ns=sum(li)\n\np=np.array(li)\n\na=np.abs(p).tolist()\n\nk=min(a)\n\nb=a.index(k)\n\nprint((s-li[b]))", "generated_code": "n,l=list(map(int,input().split()))\n\na=0\n\nfor i in range(n):\n\n  a+=i+l\n\nif l>=0:\n\n  print((a-l))\n\nelif l+n-1<0:\n\n  print((a-(l+n-1)))\n\nelse:\n\n  print(a)", "score": 1.0, "codebleu": 0.2338193210840532, "crystalbleu": 0.0, "codebertscore": 0.81, "codescore": 0.1320021003484726, "surfaceSim": 0.5234375, "abs_surfaceSim_minus_score": 0.4765625}
{"golden_code": "import sys\n\n\n\ndef main():\n\n    input = sys.stdin.readline\n\n    N = int(eval(input()))\n\n    S = list(map(int, input().split()))\n\n\n\n    ans = 0\n\n    for C in range(1, N//2):\n\n        n = N // C\n\n        point = 0\n\n        used = set([0])\n\n        for k in range(1, n):\n\n            A = N - 1 - k*C\n\n\n\n            if A in used or k*C in used or A == k*C:\n\n                break\n\n            used.add(A)\n\n            used.add(k*C)\n\n\n\n            point += S[A] + S[k*C]\n\n            ans = max(ans, point)\n\n\n\n    return ans\n\n\n\n\n\nif __name__ == '__main__':\n\n    print((main()))\n", "generated_code": "import sys\n\n\n\ndef main():\n\n    input = sys.stdin.readline\n\n    N = int(eval(input()))\n\n    S = list(map(int, input().split()))\n\n\n\n    ans = 0\n\n    # C = A - B\n\n    for C in range(1, N//2):\n\n        n = (N-1) // C\n\n        point = 0\n\n        for k in range(1, n):\n\n            A = N-1 - k*C\n\n\n\n            # Check A and B are positive integer, and S_i is not used twice.\n\n            #\n\n            # B = A - C and B >= 0, so A must be over C (A > C).\n\n            #\n\n            # If C is aliquot of N-1 (N-1 % C = 0), A is also aliquot of N-1\n\n            # (N-1 % A = 0) because A + kC = N-1. Therefore when A is less than\n\n            # or equal kC, the A's value is already used by kC.\n\n            if A < C or ((N-1) % C == 0 and A <= k*C):\n\n                break\n\n\n\n            point += S[A] + S[k*C]\n\n            ans = max(ans, point)\n\n\n\n    return ans\n\n\n\n\n\nif __name__ == '__main__':\n\n    print((main()))\n", "score": 1.0, "codebleu": 0.601237055691981, "crystalbleu": 0.7234914523359285, "codebertscore": 0.87, "codescore": 0.06498236209154129, "surfaceSim": 0.8792364262243781, "abs_surfaceSim_minus_score": 0.12076357377562186}
{"golden_code": "import bisect\n\n\n\nN, X = list(map(int, input().split()))\n\nl = list(map(int, input().split()))\n\nd = [-1]*(N+1) #0-index #バウンドする位置を格納するリスト\n\nd[0] = 0 #バウンドする初期値は0\n\n\n\nfor i in range(1, N+1):\n\n    d[i] = d[i-1] + l[i-1]\n\n\n\n#print(d)\n\n#print('left:', bisect.bisect_left(d, X))\n\n#print('right:', bisect.bisect_right(d, X))\n\nprint((bisect.bisect_right(d, X)))", "generated_code": "import bisect\n\n\n\nn,x = list(map(int, input().split()))\n\nl = tuple(map(int, input().split()))\n\n\n\nd = [-1]*(n+1)\n\nd[0] = 0\n\nfor i in range(1, n+1):\n\n    d[i] = d[i-1] + l[i-1]\n\nres = bisect.bisect_right(sorted(d), x)\n\nprint(res)", "score": 1.0, "codebleu": 0.4891748554605791, "crystalbleu": 0.5942588055825191, "codebertscore": 0.86, "codescore": 0.6379726529121399, "surfaceSim": 0.9514285714285714, "abs_surfaceSim_minus_score": 0.0485714285714286}
{"golden_code": "import numpy as np\n\nN = int(eval(input()))\n\nV = np.array([int(i) for i in input().split(\" \")])\n\nC = np.array([int(i) for i in input().split(\" \")])\n\n\n\nvc = V-C\n\n\n\nval = 0\n\n\n\nfor i in range(N):\n\n    if vc[i]>0:\n\n        val+=vc[i]\n\nprint(val)", "generated_code": "N = int(eval(input()))\n\nV = [int(i) for i in input().split(\" \")]\n\nC = [int(i) for i in input().split(\" \")]\n\n\n\nval = 0\n\n\n\nfor i in range(N):\n\n    vc=V[i]-C[i]\n\n    if vc>0:\n\n        val+=vc\n\nprint(val)", "score": 1.0, "codebleu": 0.43250002834832124, "crystalbleu": 0.6282057680818627, "codebertscore": 0.94, "codescore": 0.8157378435134888, "surfaceSim": 0.833605072463768, "abs_surfaceSim_minus_score": 0.16639492753623197}
{"golden_code": "a,b,c,d,e,f=[int(eval(input())) for _ in range(6)]\n\nprint((sum([a,b,c,d,max(e,f)])-min([a,b,c,d])))", "generated_code": "print((sum(sorted(int(eval(input())) for _ in range(4))[1:])+max([int(eval(input())) for _ in range(2)])))", "score": 1.0, "codebleu": 0.2242737827628642, "crystalbleu": 0.23837482432405213, "codebertscore": 0.82, "codescore": 0.01855592243373394, "surfaceSim": 0.49947589098532497, "abs_surfaceSim_minus_score": 0.500524109014675}
{"golden_code": "from numpy import*;_,a=open(0);print((*argsort(int32(a.split()))+1))", "generated_code": "n,a=open(0);a=a.split();print((*sorted(list(range(1,int(n)+1)),key=lambda x:int(a[x-1]))))", "score": 1.0, "codebleu": 0.3522727272727273, "crystalbleu": 0.0, "codebertscore": 0.81, "codescore": 0.06077030301094055, "surfaceSim": 0.42878787878787883, "abs_surfaceSim_minus_score": 0.5712121212121212}
{"golden_code": "import sys\n\nsys.setrecursionlimit(10000000)\n\nimport heapq\n\nimport math\n\n \n\ndef main():\n\n    N, K = list(map(int, input().split()))\n\n    A = [int(c) for c in input().split()]\n\n    F = [int(c) for c in input().split()]\n\n    \n\n    A.sort()\n\n    F.sort(reverse=True)\n\n \n\n    num = 0\n\n    sum_ = []\n\n    for i in range(N):\n\n      sum_.append(A[i] * F[i])\n\n    left = 0\n\n    right = 10 ** 12\n\n    while(num < 90):\n\n        number = 0\n\n        mid = (left + right) // 2\n\n        # print(mid)\n\n        for i in range(len(A)):\n\n            if sum_[i] <= mid:\n\n                continue\n\n            else:\n\n                number += math.ceil((sum_[i] - mid) / F[i])\n\n            # print(number)\n\n        if number > K:\n\n            # 最大値をmidより小さくできない -> 最大値はもっとでかい\n\n            left = mid + 1\n\n        else:\n\n            right = mid\n\n        num += 1\n\n    print(mid)\n\n                \n\n        \n\n \n\n \n\n \n\nif __name__ == '__main__':\n\n    main()", "generated_code": "import sys\n\nsys.setrecursionlimit(10000000)\n\nimport heapq\n\nimport math\n\n\n\ndef main():\n\n    N, K = list(map(int, input().split()))\n\n    A = [int(c) for c in input().split()]\n\n    F = [int(c) for c in input().split()]\n\n    \n\n    A.sort()\n\n    F.sort(reverse=True)\n\n\n\n    num = 0\n\n    sum_ = []\n\n    for i in range(len(A)):\n\n        sum_.append(A[i] * F[i])\n\n    left = 0\n\n    right = 10 ** 12\n\n    while(num < 50):\n\n        number = 0\n\n        mid = (left + right) // 2\n\n        # print(mid)\n\n        for i in range(len(A)):\n\n            if sum_[i] <= mid:\n\n                continue\n\n            else:\n\n                number += math.ceil((sum_[i] - mid) / F[i])\n\n            # print(number)\n\n        if number > K:\n\n            # 最大値をmidより小さくできない -> 最大値はもっとでかい\n\n            left = mid + 1\n\n        else:\n\n            right = mid\n\n        num += 1\n\n    print(mid)\n\n                \n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 1.0, "codebleu": 0.9017024327752274, "crystalbleu": 0.956303373775195, "codebertscore": 0.99, "codescore": 0.9938400387763977, "surfaceSim": 0.9962486602357985, "abs_surfaceSim_minus_score": 0.0037513397642015}
{"golden_code": "import sys\n\nreadline = sys.stdin.readline\n\nsys.setrecursionlimit(10**8)\n\nmod = 10**9+7\n\n#mod = 998244353\n\nINF = 10**18\n\neps = 10**-7\n\n\n\nm,n,k = list(map(int,readline().split()))\n\n\n\ndef comb(n, r, mod):\n\n    r = min(r, n-r)\n\n    mol = 1\n\n    deno = 1\n\n    for i in range(1, r+1):\n\n        mol = mol * (n-r+i) % mod\n\n        deno = deno * i % mod\n\n    ret = mol * pow(deno, mod-2, mod) % mod\n\n    return ret\n\n\n\ndef f1(x,y,a,b):\n\n    return (a+b-x-y)*(a-x+1)*(b-y+1)//2\n\n\n\ndef f2(x,a):\n\n    return (a-x)*(a-x+1)//2\n\n\n\nans = 0\n\n\n\nfor x in range(1,n+1):\n\n    for y in range(1,m+1):\n\n        a = n-x+1\n\n        b = m-y+1\n\n        c = m*(a*(a-1)+x*(x-1))\n\n        d = n*(b*(b-1)+y*(y-1))\n\n        ans += (c+d)//2\n\n        ans %= mod\n\n\n\nans = (ans * comb(m*n-2,k-2,mod))%mod\n\nans = ans*pow(2,mod-2,mod)%mod\n\n\n\nprint(ans)\n\n\n", "generated_code": "import sys\n\nreadline = sys.stdin.readline\n\nsys.setrecursionlimit(10**8)\n\nmod = 10**9+7\n\n#mod = 998244353\n\nINF = 10**18\n\neps = 10**-7\n\n\n\nm,n,k = list(map(int,readline().split()))\n\n\n\ndef comb(n, r, mod):\n\n    r = min(r, n-r)\n\n    mol = 1\n\n    deno = 1\n\n    for i in range(1, r+1):\n\n        mol = mol * (n-r+i) % mod\n\n        deno = deno * i % mod\n\n    ret = mol * pow(deno, mod-2, mod) % mod\n\n    return ret\n\n\n\nans = m*n*(m+n)*(m*n-1)//3\n\n\n\nans = (ans * comb(m*n-2,k-2,mod))%mod\n\nans = ans*pow(2,mod-2,mod)%mod\n\n\n\nprint(ans)\n\n\n", "score": 1.0, "codebleu": 0.6439133731067364, "crystalbleu": 0.4512970336537839, "codebertscore": 0.92, "codescore": 0.5970010161399841, "surfaceSim": 0.8612360827084753, "abs_surfaceSim_minus_score": 0.1387639172915247}
{"golden_code": "import math\n\n\n\nN = int(eval(input()))\n\n\n\npower = math.factorial(N)\n\n\n\nprint((power % 1000000007))\n\n\n", "generated_code": "n=int(eval(input()))\n\nans=1\n\nfor i in range(n):\n\n    ans=(ans*(i+1))%(10**9+7)\n\nprint(ans)", "score": 1.0, "codebleu": 0.23095238095238096, "crystalbleu": 0.0, "codebertscore": 0.76, "codescore": 0.12617863714694977, "surfaceSim": 0.47911764705882354, "abs_surfaceSim_minus_score": 0.5208823529411765}
{"golden_code": "#ABC 130 B\n\nN,X=list(map(int,input().split()))\n\nL= [int(j) for j in input().split()]\n\ncnt=0\n\nimport numpy as np\n\njump = list(np.cumsum(L))\n\nfor j in jump:\n\n    if j <= X:\n\n        cnt+=1\n\n    else:\n\n        break\n\nprint((cnt+1))", "generated_code": "#ABC 130 B\n\nN,X=list(map(int,input().split()))\n\nL= [int(j) for j in input().split()]\n\ncnt=0\n\nd = 0\n\n\n\nfor l in L :\n\n    d+=l\n\n    if d <= X:\n\n        cnt+=1\n\n    else:\n\n        break\n\nprint((cnt+1))", "score": 1.0, "codebleu": 0.6179507149343708, "crystalbleu": 0.6525239577546224, "codebertscore": 0.93, "codescore": 0.9900179505348206, "surfaceSim": 0.8536682615629985, "abs_surfaceSim_minus_score": 0.14633173843700154}
{"golden_code": "a,b=list(map(int,input().split()))\n\n\n\nans=0\n\n\n\nfor i in range(a,b+1):\n\n    buf=str(i)\n\n    #print(buf[0:int(len(buf)/2)],buf[int(len(buf)/2+1):])\n\n    str1=buf[0:int(len(buf)/2)]\n\n    str2=buf[int(len(buf)/2+1):]\n\n    if str1[0]==str2[1] and str1[1]==str2[0]:\n\n        ans+=1\n\n\n\nprint(ans)\n", "generated_code": "a,b=list(map(int,input().split()))\n\n\n\nans=0\n\n\n\nfor i in range(a,b+1):\n\n    buf=str(i)\n\n    str1=buf[::-1]\n\n    if buf==str1:\n\n        ans+=1\n\n\n\nprint(ans)\n", "score": 1.0, "codebleu": 0.5005658856205908, "crystalbleu": 0.0, "codebertscore": 0.89, "codescore": 0.8028612732887268, "surfaceSim": 0.7558620689655172, "abs_surfaceSim_minus_score": 0.24413793103448278}
{"golden_code": "n = int(eval(input()))\n\nmx = n//3\n\nans = 0\n\nmod = 10**9+7\n\nimport math\n\ndef combinations_count(n, r): #組み合わせ(nCr)\n\n    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\n\nfor i in range(1,mx+1):\n\n    if i == 1:\n\n        ans += 1\n\n    else:\n\n        ans += combinations_count(n-2*i-1,i-1) % mod\n\nprint((ans%mod))", "generated_code": "s = int(eval(input()))\n\ndp = [0]*(2001)\n\ndp[3] = 1\n\nmod = 10**9+7\n\nfor i in range(4,s+1):\n\n    dp[i] = (dp[i-1] + dp[i-3]) % mod\n\nprint((dp[s]))", "score": 1.0, "codebleu": 0.16498058488401543, "crystalbleu": 0.23645995471937134, "codebertscore": 0.78, "codescore": 0.10874577611684799, "surfaceSim": 0.4759036144578313, "abs_surfaceSim_minus_score": 0.5240963855421688}
{"golden_code": "a,b,c,x,y = list(map(int,input().split()))\n\nans = a*x + b*y\n\nfor i in range(max(x,y) + 1):\n\n\tmoney = max(0,(x-i)*a) + max(0,(y-i)*b) + 2*i*c\n\n\tif money <= ans:\n\n\t\tans = money\n\nprint(ans)", "generated_code": "a,b,c,x,y = list(map(int,input().split()))\n\nif a + b >= 2*c:\n\n\tif x >= y:\n\n\t\tans = 2*y*c + (x-y)*min(a,2*c)\n\n\telse:\n\n\t\tans = 2*x*c + (y-x)*min(b,2*c)\n\nelse:\n\n\tans = (x*a + y*b)\n\nprint(ans)", "score": 1.0, "codebleu": 0.29176496734976, "crystalbleu": 0.0, "codebertscore": 0.87, "codescore": 0.07891825586557388, "surfaceSim": 0.6976483762597985, "abs_surfaceSim_minus_score": 0.3023516237402015}
{"golden_code": "N, M = list(map(int, input().split()))\n\nLR = [list(map(int, input().split())) for _ in range(M)]\n\n\n\nleft = 1\n\nright = N\n\n\n\nfor l, r in LR:\n\n    if left < l:\n\n        left = l\n\n    if right > r:\n\n        right = r\n\n\n\nans = right - left\n\n\n\nprint((ans + 1 if ans >= 0 else 0))\n", "generated_code": "N, M = list(map(int, input().split()))\n\n\n\nleft = 1\n\nright = N\n\n\n\nfor _ in range(M):\n\n    l, r = list(map(int, input().split()))\n\n\n\n    if left < l:\n\n        left = l\n\n    if right > r:\n\n        right = r\n\n\n\nans = right - left\n\n\n\nprint((ans + 1 if ans >= 0 else 0))\n", "score": 1.0, "codebleu": 0.7333744875910758, "crystalbleu": 0.8172619263410053, "codebertscore": 0.97, "codescore": 0.8455857634544373, "surfaceSim": 0.8432315859323158, "abs_surfaceSim_minus_score": 0.15676841406768416}
{"golden_code": "import numpy as np\n\n\n\ntemp=list(map(int, input().split()))\n\n\n\nN=temp[0]\n\nX=temp[1]\n\n\n\nL=list(map(int, input().split()))\n\n\n\nind=1\n\nwhile np.sum(L[:ind])<=X and ind<=N:\n\n  ind+=1\n\n  \n\nprint(ind)", "generated_code": "N, X=list(map(int, input().split()))\n\nL=list(map(int, input().split()))\n\nL=[0]+L\n\n \n\nl=int(0)\n\ncounter=int(0)\n\nwhile l+L[counter]<=X and counter<=N:\n\n  l+=L[counter]\n\n  counter+=int(1)\n\n  if counter==N+1:\n\n    break\n\n  \n\nprint(counter)", "score": 1.0, "codebleu": 0.25289946078759334, "crystalbleu": 0.1994616981277807, "codebertscore": 0.84, "codescore": 0.9822030067443848, "surfaceSim": 0.5503546099290779, "abs_surfaceSim_minus_score": 0.4496453900709221}
{"golden_code": "import numpy as np\n\n\n\nn, m = list(map(int, input().split()))\n\na = [int(eval(input())) for _ in range(m)] + [0]\n\nmod = 10 ** 9 + 7\n\n\n\ndp = np.zeros(n + 1, dtype=np.int64)\n\ndp[0] = 1\n\nb = a[0]\n\nj = 1\n\nfor i in range(1, n + 1):\n\n    if i == b:\n\n        b = a[j]\n\n        j += 1\n\n    else:\n\n        tmp = dp[i - 2] + dp[i - 1]\n\n        if tmp >= mod:\n\n            tmp -= mod\n\n        dp[i] = tmp\n\nprint((int(dp[-1])))", "generated_code": "n, m = list(map(int, input().split()))\n\na = [int(eval(input())) for _ in range(m)] + [0]\n\nmod = 10 ** 9 + 7\n\n\n\ndp = [0] * (n + 1)\n\ndp[0] = 1\n\nb = a[0]\n\nj = 1\n\nfor i in range(1, n + 1):\n\n    if i == b:\n\n        b = a[j]\n\n        j += 1\n\n    else:\n\n        tmp = dp[i - 2] + dp[i - 1]\n\n        if tmp >= mod:\n\n            tmp -= mod\n\n        dp[i] = tmp\n\nprint((int(dp[-1])))", "score": 1.0, "codebleu": 0.6981201522242566, "crystalbleu": 0.9037930452322175, "codebertscore": 0.96, "codescore": 0.5824517011642456, "surfaceSim": 0.8882683745997032, "abs_surfaceSim_minus_score": 0.1117316254002968}
{"golden_code": "a = int(eval(input()))\n\nh = int(a / 3600)\n\nm = int((a - h * 3600) / 60)\n\ns = int(a - h * 3600 - m * 60)\n\nprint((\":\" .join(map(str, [h, m, s]))))", "generated_code": "num = int(input())\n\nprint(int(num/3600), int((num%3600)/60), num%60, sep=\":\")\n", "score": 1.0, "codebleu": 0.11035332920854249, "crystalbleu": 0.0, "codebertscore": 0.82, "codescore": 0.023724664002656937, "surfaceSim": 0.5590277777777778, "abs_surfaceSim_minus_score": 0.4409722222222222}
{"golden_code": "_,s=open(c:=0)\n\nfor a in sorted(map(int,s.split())):c=a-c\n\nprint(c)", "generated_code": "for a in sorted(map(int,[*open(c:=0)][1].split())):c=a-c\n\nprint(c)", "score": 1.0, "codebleu": 0.3465892449146345, "crystalbleu": 0.0, "codebertscore": 0.92, "codescore": 0.2433072179555893, "surfaceSim": 0.6297678275290215, "abs_surfaceSim_minus_score": 0.3702321724709785}
{"golden_code": "import numpy as np\n\nN = int(eval(input()))\n\n\n\nabc = np.array([list(map(int, input().split())) for i in range(N)])\n\n\n\ndp = [[0]*3 for i in range(N+1)]\n\n\n\nfor i in range(1, N+1):\n\n    dp[i][0] = max(dp[i - 1][1] + abc[i - 1][1], dp[i - 1][2] + abc[i - 1][2])\n\n    dp[i][1] = max(dp[i - 1][0] + abc[i - 1][0], dp[i - 1][2] + abc[i - 1][2])\n\n    dp[i][2] = max(dp[i - 1][1] + abc[i - 1][1], dp[i - 1][0] + abc[i - 1][0])\n\n\n\nprint((max(dp[-1])))\n", "generated_code": "N = int(eval(input()))\n\n\n\nA = [0] * (N + 1)\n\nB = [0] * (N + 1)\n\nC = [0] * (N + 1)\n\n\n\nfor i in range(1, N + 1):\n\n    A[i], B[i], C[i] = list(map(int, input().split()))\n\n\n\ndp = [[0] * 3 for _ in range(N + 1)]\n\nfor i in range(1, N + 1):\n\n    dp[i][0] = A[i] + max(dp[i-1][1], dp[i-1][2])\n\n    dp[i][1] = B[i] + max(dp[i-1][2], dp[i-1][0])\n\n    dp[i][2] = C[i] + max(dp[i-1][0], dp[i-1][1])\n\n\n\nprint((max(dp[N])))", "score": 1.0, "codebleu": 0.26556224256162636, "crystalbleu": 0.5583057628781894, "codebertscore": 0.89, "codescore": 0.8420692682266235, "surfaceSim": 0.6906179138321995, "abs_surfaceSim_minus_score": 0.3093820861678005}
{"golden_code": "import numpy as np\n\nn,l = list(map(int,input().split()))\n\ntaste = np.array([l+i-1 for i in range(1,n+1)])\n\ntaste[np.fabs(taste).argmin()]=0\n\nprint((taste.sum()))", "generated_code": "n,l = list(map(int,input().split()))\n\ntaste = [l+i for i in range(0,n)]\n\ntaste.sort(key=lambda x:abs(x))\n\nprint((sum(taste[1:])))", "score": 1.0, "codebleu": 0.32857995613267055, "crystalbleu": 0.0, "codebertscore": 0.87, "codescore": 0.7882042527198792, "surfaceSim": 0.6106366459627329, "abs_surfaceSim_minus_score": 0.3893633540372671}
{"golden_code": "from math import factorial\n\n\n\ns = int(eval(input()))\n\nmod = pow(10, 9) + 7\n\n\n\n\n\ndef nCr(n, r):\n\n    return int(factorial(n) // factorial(r) // factorial (n - r) % mod)\n\n\n\nans = 0\n\nseq_len = s // 3\n\n\n\nfor i in range(1, seq_len + 1):\n\n    ans += nCr(s - 3 * i + (i - 1), i - 1)\n\n\n\nprint((ans % mod))", "generated_code": "# 動的計画法による解法\n\n\n\ns = int(eval(input()))\n\nmod = pow(10, 9) + 7\n\n\n\nA = [0] * (s + 1)\n\n\n\nif s >= 3:\n\n    A[3] = 1\n\n\n\nfor i in range(4, s + 1):\n\n    A[i] = (A[i - 3] + A[i - 1]) % mod\n\n\n\nprint((A[s]))", "score": 1.0, "codebleu": 0.24506632859286037, "crystalbleu": 0.2818272081898399, "codebertscore": 0.8, "codescore": 0.14344048500061035, "surfaceSim": 0.5176767676767677, "abs_surfaceSim_minus_score": 0.48232323232323226}
{"golden_code": "# vim: fileencoding=utf-8\n\n\n\n\n\ndef main():\n\n    a, b = list(map(int, input().split()))\n\n    c = 0\n\n    for i in range(a, b + 1):\n\n        s = str(i)\n\n        r = \"\".join(reversed(list(s)))\n\n        if s == r:\n\n            c += 1\n\n    print(c)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "generated_code": "# vim: fileencoding=utf-8\n\n\n\n\n\ndef main():\n\n    a, b = list(map(int, input().split()))\n\n    c = 0\n\n    for i in range(a, b + 1):\n\n        #     s = str(i)\n\n        #     r = \"\".join(reversed(list(s)))\n\n        #     if s == r:\n\n        #         c += 1\n\n        if (i % 10) == (i // 10000 % 10) and (i // 10 % 10) == (i // 1000 % 10):\n\n            c += 1\n\n    print(c)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "score": 1.0, "codebleu": 0.6581976170512275, "crystalbleu": 0.6195181310124266, "codebertscore": 0.95, "codescore": 0.9638482928276062, "surfaceSim": 0.8585640593746711, "abs_surfaceSim_minus_score": 0.14143594062532894}
{"golden_code": "import sys\n\ninput = sys.stdin.readline\n\nH, W = [int(x) for x in input().split()]\n\na = []\n\nfor _ in range(H):\n\n    a.append(list(input().rstrip()))\n\nimport numpy as np\n\na = np.array(a, np.object)\n\na = a.T\n\nretsu = []\n\ngyou = []\n\nfor i in range(W):\n\n    if \"#\" not in a[i]:\n\n        retsu.append(i)\n\na = a.T\n\nfor i in range(H):\n\n    if \"#\" not in a[i]:\n\n        gyou.append(i)\n\na = np.delete(a, retsu, 1)\n\na = np.delete(a, gyou, 0)\n\nfor j in a:\n\n    j = list(j)\n\n    print((\"\".join(j)))", "generated_code": "import sys\n\ninput = sys.stdin.readline\n\n\n\nh, w = [int(x) for x in input().split()]\n\na = []\n\nfor _ in range(h):\n\n    b = list(input().rstrip())\n\n    if '#' in b:\n\n        a.append(b)\n\nh = len(a)\n\nc = [1]*w\n\nfor i in range(w):\n\n    flag = 1\n\n    for j in range(h):\n\n        if a[j][i] == \"#\":\n\n            flag = 0\n\n            break\n\n    if flag:\n\n        c[i] = 0\n\nans = []\n\nfor i in range(h):\n\n    res = []\n\n    for j in range(w):\n\n        if c[j]:\n\n            res.append(a[i][j])\n\n    ans.append(\"\".join(res))\n\nfor i in ans:\n\n    print(i)\n\n\n", "score": 1.0, "codebleu": 0.45504194243128915, "crystalbleu": 0.315765857184889, "codebertscore": 0.85, "codescore": 0.1645282357931137, "surfaceSim": 0.7035492081447965, "abs_surfaceSim_minus_score": 0.2964507918552035}
{"golden_code": "class Queue:\n\n    def __init__(self,values):\n\n        self.values = values\n\n\n\n    def empty(self):\n\n        if len(self.values) == 0:\n\n            return True\n\n        else:\n\n            return False\n\n\n\n    def enqueue(self,v):\n\n        self.values.append(v)\n\n\n\n    def dequeue(self):\n\n        if len(self.values) <= 0:\n\n            raise\n\n        else:\n\n            v = self.values[0]\n\n            del self.values[0]\n\n            return v\n\n\n\nn,q = list(map(int,input().split(' ')))\n\nprocesses = []\n\nfor i in range(n):\n\n    n,t = input().split(' ')\n\n    processes.append((n,int(t)))\n\n\n\nqueue = Queue(processes)\n\n\n\nclock = 0\n\ndone = []\n\nwhile not queue.empty():\n\n    p = queue.dequeue()\n\n    n = p[0]\n\n    t = p[1]\n\n    if t <= q:\n\n        clock+=t\n\n        done.append((n,clock))\n\n    else:\n\n        queue.enqueue((n,t-q))\n\n        clock+=q\n\n\n\nfor p in done:\n\n    print(p[0],p[1])", "generated_code": "class Queue:\n\n    def __init__(self,l):\n\n        self.values = []\n\n        self.l = l\n\n        for _ in range(l):\n\n            self.values.append(None)\n\n        self.head = 0\n\n        self.tail = 0\n\n    def inc(self,n):\n\n        if n+1 >= self.l:\n\n            return 0\n\n        else:\n\n            return n+1\n\n    def enqueue(self,v):\n\n        if self.inc(self.head) == self.tail:\n\n            print('overflow')\n\n            exit()\n\n        self.values[self.head] = v\n\n        self.head = self.inc(self.head)\n\n    def dequeue(self):\n\n        if self.head == self.tail:\n\n            print('underflow')\n\n            exit()\n\n        v = self.values[self.tail]\n\n        self.tail = self.inc(self.tail)\n\n        return v\n\n    def size(self):\n\n        if self.head >= self.tail:\n\n            return self.head-self.tail\n\n        else:\n\n            self.head + (self.l-self.tail)\n\n\n\nn,q = list(map(int,input().split(' ')))\n\nqueue = Queue(200000)\n\nfor _ in range(n):\n\n    n,t = input().split(' ')\n\n    t = int(t)\n\n    queue.enqueue((n,t))\n\n\n\nc = 0\n\nwhile queue.size()>0:\n\n    n,t = queue.dequeue()\n\n    if t <= q:\n\n        c += t\n\n        print(n,c)\n\n    else:\n\n        queue.enqueue((n,t-q))\n\n        c += q", "score": 1.0, "codebleu": 0.31805903233350485, "crystalbleu": 0.37211966863851337, "codebertscore": 0.83, "codescore": 0.18489903211593628, "surfaceSim": 0.6934056761268781, "abs_surfaceSim_minus_score": 0.3065943238731219}
{"golden_code": "#!/usr/bin/env python3\n\n# coding=utf-8\n\n\n\nimport sys\n\n\n\ns = sys.stdin.readline().strip()\n\nl = [_s is \"1\" for _s in list(s)]\n\nl_r = l[::-1]\n\nindex = 0\n\nfor i, (c, n, c_r, n_r) in enumerate(\n\n        zip(l[:len(s) // 2], l[1:len(s) // 2 + 1], l_r[:len(s) // 2], l_r[1:len(s) // 2 + 1])):\n\n    if c ^ n or c_r ^ n_r:\n\n        index = i + 1\n\nprint((len(s) - index))", "generated_code": "def solve(string):\n\n    l = [s == \"1\" for s in string]\n\n    l_r = l[::-1]\n\n    index = 0\n\n    h = len(string) // 2\n\n    for i, (c, n, c_r, n_r) in enumerate(zip(l[:h], l[1:h + 1], l_r[:h], l_r[1:h + 1])):\n\n        if c ^ n or c_r ^ n_r:\n\n            index = i + 1\n\n    return str(len(string) - index)\n\n\n\n\n\nif __name__ == '__main__':\n\n    print((solve(eval(input()))))\n", "score": 1.0, "codebleu": 0.42220583310994575, "crystalbleu": 0.4150345806376665, "codebertscore": 0.86, "codescore": 0.01838819682598114, "surfaceSim": 0.6488970588235294, "abs_surfaceSim_minus_score": 0.35110294117647056}
{"golden_code": "import collections\n\nn = int(eval(input()))\n\na=[eval(input()) for _ in range(n)]\n\nanslist=[]\n\nb=collections.Counter(a)\n\nc=max(list(b.values()))\n\nfor i in b:\n\n    if b[i]==c:\n\n        anslist.append(i)\n\nd=sorted(anslist)\n\nfor i in tuple(d):\n\n    print(i)", "generated_code": "from collections import Counter\n\nn=int(eval(input()))\n\na=[]\n\nfor i in range(n):\n\n  a.append(eval(input()))\n\nac=Counter(a)\n\nacs=sorted(list(ac.items()),key=lambda x:x[1],reverse=1)\n\nz=len(acs)\n\ni=0\n\ntemp=[]\n\n\n\nwhile i<=z-1 and acs[i][1]==acs[0][1] :\n\n  temp.append(acs[i][0])\n\n  i+=1\n\ntemp.sort()\n\nfor i in temp:\n\n  print(i)", "score": 1.0, "codebleu": 0.30860557397212407, "crystalbleu": 0.17307095021309496, "codebertscore": 0.82, "codescore": 0.9563435912132263, "surfaceSim": 0.4486349563748945, "abs_surfaceSim_minus_score": 0.5513650436251055}
{"golden_code": "#!/usr/bin/env python3\n\n\n\nn = int(eval(input()))\n\ns = [eval(input()) for _ in range(n)]\n\n\n\nc = [0 for _ in range(5)]\n\nt = 'MARCH'\n\n\n\nfor i in range(n):\n\n    for j in range(5):\n\n        if s[i][0] == t[j]:\n\n            c[j] += 1\n\nans = 0 \n\nfor i in range(5):\n\n    for j in range(i+1, 5): \n\n        for k in range(j+1, 5): \n\n            ans += c[i]*c[k]*c[j]\n\nprint(ans)\n", "generated_code": "#!/usr/bin/env python3\n\n\n\nn = int(eval(input()))\n\ns = [eval(input()) for _ in range(n)]\n\nd = {}\n\n\n\nfor c in s:\n\n    if c[0] not in d:\n\n        d[c[0]] = 1 \n\n    else:\n\n        d[c[0]] += 1\n\n\n\ntmp = d.copy()\n\nt = ['M', 'A', 'R', 'C', 'H']\n\nfor c in tmp:\n\n    if c not in t:\n\n        d.pop(c)\n\n\n\nans = 0 \n\ndlist = list(d.items())\n\nfor i in range(len(dlist)):\n\n    for j in range(i+1, len(dlist)):\n\n        for k in range(j+1, len(dlist)):\n\n            ans += dlist[i][1]*dlist[j][1]*dlist[k][1]\n\nprint(ans)\n", "score": 1.0, "codebleu": 0.3760107470229889, "crystalbleu": 0.23570064443031385, "codebertscore": 0.86, "codescore": 0.9852772355079651, "surfaceSim": 0.7176155115511551, "abs_surfaceSim_minus_score": 0.2823844884488449}
{"golden_code": "def main():\n\n    x = int(eval(input()))\n\n    for a in range(-120, 121):\n\n        for b in range(-120, 121):\n\n            if a**5 - b**5 == x:\n\n                print((a, b))\n\n                return\n\n\n\nif __name__ == \"__main__\":\n\n    main()", "generated_code": "def main():\n\n    x = int(eval(input()))\n\n    for i in range(-120, 121):\n\n        for j in range(-120, 121):\n\n            if i**5 - j**5 == x:\n\n                print((i, j))\n\n                return\n\n\n\nif __name__ == \"__main__\":\n\n    main()", "score": 1.0, "codebleu": 0.7574111814061091, "crystalbleu": 0.7256017249452535, "codebertscore": 0.98, "codescore": 0.029764430597424507, "surfaceSim": 0.9873949579831933, "abs_surfaceSim_minus_score": 0.012605042016806678}
{"golden_code": "from collections import deque\n\nK = int(eval(input()))\n\nG = [[] for i in range(K)]\n\n\n\nfor n in range(K):\n\n    G[n].append([(n + 1) % K, 1])\n\n    G[n].append([(10 * n) % K, 0])\n\n\n\nque = deque([[1, 1]])\n\ndist = [float('inf')] * K\n\n\n\nwhile que:\n\n    node, cost = que.pop()\n\n    dist[node] = min(cost, dist[node])\n\n    for e, e_cost in G[node]:\n\n        if dist[e] != float('inf'):\n\n            continue\n\n\n\n        if e_cost == 0:\n\n            que.append([e, cost + 0])\n\n\n\n        if e_cost == 1:\n\n            que.appendleft([e, cost + 1])\n\n\n\nprint((dist[0]))\n", "generated_code": "from collections import deque\n\nK = int(eval(input()))\n\nG = [[] for i in range(K)]\n\nfor i in range(K):\n\n    G[i].append(((10 * i) % K, 0))\n\n    G[i].append(((i + 1) % K, 1))\n\n\n\ndist = [float('inf')] * K\n\ndist[1] = 1\n\nque = deque()\n\nque.append(1)\n\n\n\nwhile que:\n\n    n = que.pop()\n\n    for v, c in G[n]:\n\n        if dist[v] > dist[n] + c:\n\n            dist[v] = dist[n] + c\n\n            if c == 0:\n\n                que.append(v)\n\n            else:\n\n                que.appendleft(v)\n\n\n\nprint((dist[0]))\n", "score": 1.0, "codebleu": 0.46694159872029084, "crystalbleu": 0.5237148293758432, "codebertscore": 0.91, "codescore": 0.6250762343406677, "surfaceSim": 0.807735321528425, "abs_surfaceSim_minus_score": 0.19226467847157502}
{"golden_code": "n,k = list(map(int,input().split()))\n\narr = list(map(int,input().split()))\n\n\n\ndp = [False]*(k+1)\n\n\n\nfor stones in range(k+1):\n\n    for x in arr:\n\n        if stones >= x and dp[stones-x] == False:\n\n            dp[stones] = True\n\n\n\nif dp[k]:\n\n    print(\"First\")\n\nelse:\n\n    print(\"Second\")\n", "generated_code": "N,K = list(map(int,input().split()))\n\nA = list(map(int,input().split()))\n\n\n\ndp = [False]*(K+1)\n\n\n\nfor i in range(K+1):\n\n    for j in range(N):\n\n        if i-A[j]>=0 and dp[i-A[j]] == False:\n\n            dp[i] = True\n\n\n\n        \n\nif dp[K]:\n\n    print(\"First\")\n\nelse:\n\n    print(\"Second\")", "score": 1.0, "codebleu": 0.5318704542490293, "crystalbleu": 0.48657171741610983, "codebertscore": 0.92, "codescore": 0.4815831780433655, "surfaceSim": 0.9253472222222222, "abs_surfaceSim_minus_score": 0.07465277777777779}
{"golden_code": "import sys\n\ninput = sys.stdin.readline\n\nsys.setrecursionlimit(1000000)\n\nfrom collections import deque\n\ndef getN():\n\n    return int(eval(input()))\n\ndef getList():\n\n    return list(map(int, input().split()))\n\nimport math\n\n\n\nn = getN()\n\nnums = getList()\n\n\n\n# nums.sort(reverse=True)\n\nmx = max(nums)\n\nmn = (mx+1) // 2\n\nmndx = (mx % 2) + 1\n\n\n\nfrom collections import Counter\n\n\n\ncnt = Counter(nums)\n\n\n\nfor i in range(mn+1, mx+1):\n\n    if cnt[i] < 2:\n\n        print(\"Impossible\")\n\n        sys.exit()\n\n\n\nif cnt[mn] != mndx:\n\n    print(\"Impossible\")\n\nelse:\n\n    print(\"Possible\")", "generated_code": "import sys\n\nimport math\n\nimport copy\n\nfrom heapq import heappush, heappop, heapify\n\nfrom functools import cmp_to_key\n\nfrom bisect import bisect_left, bisect_right\n\nfrom collections import defaultdict, deque, Counter\n\n# sys.setrecursionlimit(1000000)\n\n\n\n# input aliases\n\ninput = sys.stdin.readline\n\ngetS = lambda: input().strip()\n\ngetN = lambda: int(eval(input()))\n\ngetList = lambda: list(map(int, input().split()))\n\ngetZList = lambda: [int(x) - 1 for x in input().split()]\n\n\n\nINF = float(\"inf\")\n\nMOD = 10**9 + 7\n\ndivide = lambda x: pow(x, MOD-2, MOD)\n\n\n\ndef pim():\n\n    print(\"Impossible\")\n\n    sys.exit()\n\ndef pp():\n\n    print(\"Possible\")\n\n    sys.exit()\n\ndef solve():\n\n    n = getN()\n\n    nums = getList()\n\n    cnt = Counter(nums)\n\n    mx = max(nums)\n\n    mn = min(nums)\n\n\n\n    if cnt[mx] < 2:\n\n        pim()\n\n    if mn < (mx + 1) // 2:\n\n        pim()\n\n\n\n    if mx % 2 == 0:\n\n        if cnt[mx//2] != 1:\n\n            pim()\n\n    else:\n\n        if cnt[(mx+1) // 2] != 2:\n\n            pim()\n\n\n\n    for i in range((mx + 1) // 2 + 1, mx+1):\n\n        if cnt[i] < 2:\n\n            pim()\n\n\n\n    pp()\n\n\n\n\n\ndef main():\n\n    n = getN()\n\n    for _ in range(n):\n\n        solve()\n\n\n\n    return\n\nif __name__ == \"__main__\":\n\n    # main()\n\n    solve()\n\n\n\n\n\n\n\n\n\n\n", "score": 1.0, "codebleu": 0.3742991004240066, "crystalbleu": 0.27492796242171147, "codebertscore": 0.83, "codescore": 0.01873091235756874, "surfaceSim": 0.6587869059779172, "abs_surfaceSim_minus_score": 0.3412130940220828}
{"golden_code": "import numpy as np\n\n\n\nn = int(eval(input()))\n\nX = np.array([input().split() for _ in range(n)], np.int64)\n\ndp = np.zeros((n + 1, 3), np.int64)\n\ndp[0, 0] = dp[0, 1] = dp[0, 2] = 0\n\nfor i in range(n):\n\n    for j in range(3):\n\n        dp[i + 1, j] = X[i, j] + max(dp[i, k] for k in range(3) if j != k)\n\nprint((max(dp[n])))", "generated_code": "import sys\n\nread = sys.stdin.readline\n\n\n\n\n\ndef read_ints():\n\n    return list(map(int, read().split()))\n\n\n\n\n\ndef read_a_int():\n\n    return int(read())\n\n\n\n\n\ndef read_matrix(H):\n\n    '''\n\n    H is number of rows\n\n    '''\n\n    return [list(map(int, read().split())) for _ in range(H)]\n\n\n\n\n\ndef read_map(H):\n\n    '''\n\n    H is number of rows\n\n    文字列で与えられた盤面を読み取る用\n\n    '''\n\n    return [read()[:-1] for _ in range(H)]\n\n\n\n\n\ndef read_tuple(H):\n\n    '''\n\n    H is number of rows\n\n    '''\n\n    ret = []\n\n    for _ in range(H):\n\n        ret.append(tuple(map(int, read().split())))\n\n    return ret\n\n\n\n\n\ndef read_col(H, n_cols):\n\n    '''\n\n    H is number of rows\n\n    n_cols is number of cols\n\n\n\n    A列、B列が与えられるようなとき\n\n    '''\n\n    ret = [[] for _ in range(n_cols)]\n\n    for _ in range(H):\n\n        tmp = list(map(int, read().split()))\n\n        for col in range(n_cols):\n\n            ret[col].append(tmp[col])\n\n\n\n    return ret\n\n\n\n\n\nN, K = read_ints()\n\nP = read_ints()\n\n\n\n\n\ndef ret_mean(X):\n\n    return (X + 1) / 2\n\n\n\n\n\n\n\nclass cumsum1d:\n\n    def __init__(self, ls: list):\n\n        '''\n\n        1次元リストを受け取る\n\n        '''\n\n        from itertools import accumulate\n\n        self.ls_accum = [0] + list(accumulate(ls))\n\n\n\n    def total(self, i, j):\n\n        # もとの配列lsにおける[i,j)の中合計\n\n        return self.ls_accum[j] - self.ls_accum[i]\n\n      \n\nP_mean = [ret_mean(p) for p in P]\n\nP_accum = cumsum1d(P_mean)\n\n\n\nans = 0\n\n# print(P_accum)\n\nfor i in range(N - K + 1):\n\n    j = i + K\n\n    ans = max(ans, P_accum.total(i,j))\n\nprint(ans)\n", "score": 0.0, "codebleu": 0.19798645416349897, "crystalbleu": 0.052790055766511905, "codebertscore": 0.67, "codescore": 0.9163785576820374, "surfaceSim": 0.4790806388780678, "abs_surfaceSim_minus_score": 0.4790806388780678}
{"golden_code": "while True:\n\n    try:\n\n        for i in range(3):\n\n            line = input().strip()\n\n            if line == '0':\n\n                raise Exception\n\n\n\n            a = b = 0\n\n            for i, s in enumerate(line):\n\n                if i != 0:\n\n                    if s == 'A':\n\n                        a += 1\n\n                    else:\n\n                        b += 1\n\n            if a > b:\n\n                a += 1\n\n            else:\n\n                b += 1\n\n            print(a, b)\n\n\n\n    except:\n\n        break", "generated_code": "n=int(eval(input()))\n\nans=1\n\nfor i in range(n):\n\n    ans=(ans*(i+1))%(10**9+7)\n\nprint(ans)", "score": 0.0, "codebleu": 0.0895680998236323, "crystalbleu": 0.0, "codebertscore": 0.65, "codescore": 0.05969957634806633, "surfaceSim": 0.5426070601851851, "abs_surfaceSim_minus_score": 0.5426070601851851}
{"golden_code": "import sys\n\nK = int(eval(input()))\n\n\n\npower = 7\n\nSUM = 0\n\n\n\nfor i in range(1, 10 ** 6):\n\n    SUM += power\n\n    if SUM % K == 0:\n\n        print(i)\n\n        sys.exit()\n\n    power *= 10\n\n    power %= K\n\n\n\nprint((-1))", "generated_code": "a = [list(map(int, input().split())) for _ in range(3)]\n\nn = int(eval(input()))\n\nb = [int(eval(input())) for _ in range(n)]\n\n\n\nflag = False\n\nfor i in range(3):\n\n    if a[i][0] in b and a[i][1] in b and a[i][2] in b:\n\n        flag = True\n\n        break\n\n    if a[0][i] in b and a[1][i] in b and a[2][i] in b:\n\n        flag = True\n\n        break\n\nif a[0][0] in b and a[1][1] in b and a[2][2] in b:\n\n    flag = True\n\nif a[2][0] in b and a[1][1] in b and a[0][2] in b:\n\n    flag = True\n\n    \n\nprint((\"Yes\" if flag else \"No\"))", "score": 0.0, "codebleu": 0.18111711874702563, "crystalbleu": 0.09582746890953314, "codebertscore": 0.69, "codescore": 0.4726700782775879, "surfaceSim": 0.4005518234165067, "abs_surfaceSim_minus_score": 0.4005518234165067}
{"golden_code": "import numpy as np\n\n\n\nn = int(eval(input()))\n\ninput_X = [[int(i) for i in input().split()] for i in range(n)]\n\nX = np.array(input_X)\n\n\n\npre_t = 0\n\npre_x = 0\n\npre_y = 0\n\nfor i in range(n):\n\n    x_move = abs(X[i][1] - pre_x)\n\n    y_move = abs(X[i][2] - pre_y)\n\n    xy_sum = x_move + y_move\n\n    spend_time = X[i][0]-pre_t\n\n    if xy_sum%2 == spend_time%2 and spend_time >= xy_sum:\n\n        pre_t = X[i][0]\n\n        pre_x = X[i][1]\n\n        pre_y = X[i][2]\n\n        if i+1 == n:\n\n            print('Yes')\n\n        else:\n\n            continue\n\n    else:\n\n        print('No')\n\n        break", "generated_code": "while True:\n\n    try:\n\n        for i in range(3):\n\n            line = input().strip()\n\n            if line == '0':\n\n                raise Exception\n\n\n\n            if line[0] == 'A':\n\n                a = -1\n\n                b = 0\n\n            else:\n\n                a = 0\n\n                b = -1\n\n            for i, s in enumerate(line):\n\n                if s == 'A':\n\n                    a += 1\n\n                else:\n\n                    b += 1\n\n            if a > b:\n\n                a += 1\n\n            else:\n\n                b += 1\n\n            print(a, b)\n\n\n\n    except:\n\n        break", "score": 0.0, "codebleu": 0.12281927923067923, "crystalbleu": 0.036229236377558614, "codebertscore": 0.71, "codescore": 0.13526780903339386, "surfaceSim": 0.4670178653229501, "abs_surfaceSim_minus_score": 0.4670178653229501}
{"golden_code": "I=lambda:list(map(int,input().split()))\n\nn,m=I()\n\na=I()\n\na.sort(reverse=True)\n\nqq=[I() for i in range(m)]\n\nqq.sort(key=lambda x:x[1],reverse=True)\n\nans=0\n\nfor x,y in qq:\n\n    for j in range(x):\n\n        if not a:\n\n            break\n\n        aa=a.pop()\n\n        ans+=max(aa,y)\n\nans+=sum(a)\n\nprint(ans)\n\n        ", "generated_code": "# 動的計画法による解法\n\n\n\ns = int(eval(input()))\n\nmod = pow(10, 9) + 7\n\n\n\nA = [0] * (s + 1)\n\n\n\nif s >= 3:\n\n    A[3] = 1\n\n\n\nfor i in range(4, s + 1):\n\n    A[i] = (A[i - 3] + A[i - 1]) % mod\n\n\n\nprint((A[s]))", "score": 0.0, "codebleu": 0.10464372068583486, "crystalbleu": 0.0, "codebertscore": 0.69, "codescore": 0.8777279257774353, "surfaceSim": 0.4144153225806452, "abs_surfaceSim_minus_score": 0.4144153225806452}
{"golden_code": "import sys\n\ninput = sys.stdin.readline\n\nimport numpy as np\n\nN = int(eval(input()))\n\nS = [[] for _ in range(N)]\n\nfor i in range(N):\n\n    A = int(eval(input()))\n\n    temp = []\n\n    for _ in range(A):\n\n        temp.append([str(x) for x in input().split()])\n\n        S[i] = temp\n\nans = 0\n\nfor i in range(2 ** N - 1, -1,-1):\n\n    biti = list(bin(i)[2:].zfill(N))\n\n    flag = 0\n\n    for j in range(N):\n\n        if biti[j] == \"1\":\n\n            for k in S[j]:\n\n                if biti[int(k[0])-1] != k[1]:\n\n                    flag = 1\n\n                    break\n\n        if flag:\n\n            break\n\n    if not flag:    \n\n        biti = np.array(biti)\n\n        ans = max(ans, np.count_nonzero(biti == \"1\"))\n\nprint(ans)", "generated_code": "import sys\n\n\n\nn, l = list(map(int, sys.stdin.readline().split()))\n\n\n\ndef main():\n\n    s = (l - 1) * n + (1 + n) * n // 2\n\n    res = []\n\n    for i in range(1, n+1):\n\n        f = l + i - 1\n\n        res.append((abs(f), s - f))\n\n    \n\n    res.sort()\n\n    return res[0][1]\n\n\n\nif __name__=='__main__':\n\n    ans = main()\n\n    print(ans)", "score": 0.0, "codebleu": 0.1434745064017353, "crystalbleu": 0.08041612388013973, "codebertscore": 0.75, "codescore": 0.04412081465125084, "surfaceSim": 0.5404182272159801, "abs_surfaceSim_minus_score": 0.5404182272159801}
{"golden_code": "# ABC 155 C\n\nfrom collections import Counter\n\nimport numpy as np\n\nN = int(eval(input()))\n\nS = [str(eval(input())) for i in range(N)]\n\nS = np.array(S)\n\n\n\ncount = Counter(S)\n\nmax_num = max(count.values())\n\nmax_list = [i for i,j in list(count.items()) if j==max_num]\n\n\n\nmax_list.sort()\n\nprint(('\\n'.join(max_list)))", "generated_code": "# vim: fileencoding=utf-8\n\n\n\n\n\ndef main():\n\n    a, b = list(map(int, input().split()))\n\n    c = 0\n\n    for i in range(a, b + 1):\n\n        #     s = str(i)\n\n        #     r = \"\".join(reversed(list(s)))\n\n        #     if s == r:\n\n        #         c += 1\n\n        if (i % 10) == (i // 10000 % 10) and (i // 10 % 10) == (i // 1000 % 10):\n\n            c += 1\n\n    print(c)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "score": 0.0, "codebleu": 0.1419698285200343, "crystalbleu": 0.0, "codebertscore": 0.7, "codescore": 0.020231351256370544, "surfaceSim": 0.4709443099273608, "abs_surfaceSim_minus_score": 0.4709443099273608}
{"golden_code": "import sys\n\nimport numpy as np \n\n\n\nn, l = list(map(int, sys.stdin.readline().split()))\n\n\n\ndef main():\n\n    f = l + np.arange(1, n+1) - 1\n\n    s = f.sum()\n\n    a = np.absolute(f)\n\n    mi = np.amin(a)\n\n    i = np.argwhere(a == mi)[0, 0]\n\n    return s - f[i]\n\n\n\nif __name__ == '__main__':\n\n    ans = main()\n\n    print(ans)", "generated_code": "n, m = list(map(int, input().split()))\n\na = [int(x) for x in input().split()]\n\n\n\naa = [0]*(10**5+1)\n\naa_sum = [0]*(10**5+1)\n\n\n\nfor x in a:\n\n    aa[x] += 1\n\n    aa_sum[x] += x\n\n\n\nfor i in range(10**5)[::-1]:\n\n    aa[i] = aa[i] + aa[i+1]\n\n    aa_sum[i] = aa_sum[i] + aa_sum[i+1]\n\n\n\n\n\ndef count(x):\n\n    cnt = 0\n\n    sm = 0\n\n    for i in range(n):\n\n        if x-a[i] < 0:\n\n            cnt += n\n\n            sm += aa_sum[0]+n*a[i]\n\n        elif x-a[i] > 10**5:\n\n            continue\n\n        else:\n\n            cnt += aa[x-a[i]]\n\n            sm += aa_sum[x-a[i]]+aa[x-a[i]]*a[i]\n\n\n\n    return cnt, sm\n\n\n\n\n\nbottom = 0\n\ntop = 10**6\n\n\n\nwhile top - bottom > 1:\n\n    mid = (top+bottom) // 2\n\n    cnt, sm = count(mid)\n\n    if cnt < m:\n\n        top = mid\n\n    else:\n\n        bottom = mid\n\n\n\ncnt, sm = count(bottom)\n\nans = sm - (cnt-m)*bottom\n\n\n\nprint(ans)\n", "score": 0.0, "codebleu": 0.1876216069608601, "crystalbleu": 0.07799380609356957, "codebertscore": 0.72, "codescore": 0.7100845575332642, "surfaceSim": 0.49013806706114393, "abs_surfaceSim_minus_score": 0.49013806706114393}
{"golden_code": "import sys\n\nread = sys.stdin.readline\n\n\n\n\n\ndef read_ints():\n\n    return list(map(int, read().split()))\n\n\n\n\n\ndef read_a_int():\n\n    return int(read())\n\n\n\n\n\ndef read_matrix(H):\n\n    '''\n\n    H is number of rows\n\n    '''\n\n    return [list(map(int, read().split())) for _ in range(H)]\n\n\n\n\n\ndef read_map(H):\n\n    '''\n\n    H is number of rows\n\n    文字列で与えられた盤面を読み取る用\n\n    '''\n\n    return [read()[:-1] for _ in range(H)]\n\n\n\n\n\ndef read_tuple(H):\n\n    '''\n\n    H is number of rows\n\n    '''\n\n    ret = []\n\n    for _ in range(H):\n\n        ret.append(tuple(map(int, read().split())))\n\n    return ret\n\n\n\n\n\ndef read_col(H, n_cols):\n\n    '''\n\n    H is number of rows\n\n    n_cols is number of cols\n\n\n\n    A列、B列が与えられるようなとき\n\n    '''\n\n    ret = [[] for _ in range(n_cols)]\n\n    for _ in range(H):\n\n        tmp = list(map(int, read().split()))\n\n        for col in range(n_cols):\n\n            ret[col].append(tmp[col])\n\n\n\n    return ret\n\n\n\n\n\nN, K = read_ints()\n\nP = read_ints()\n\n\n\n\n\ndef ret_mean(X):\n\n    return (X + 1) / 2\n\n\n\n\n\n\n\n\n\nimport numpy as np\n\nP_mean = np.array([ret_mean(p) for p in P])\n\nP_accum = np.zeros(N+1)\n\nP_accum[1:] = P_mean.cumsum()\n\n\n\nans = 0\n\n# print(P_accum)\n\nfor i in range(N - K + 1):\n\n    j = i + K\n\n    ans = max(ans, P_accum[j] - P_accum[i])\n\nprint(ans)\n", "generated_code": "import sys\n\nstdin = sys.stdin\n\n\n\nsys.setrecursionlimit(10 ** 7)\n\n\n\ndef li(): return list(map(int, stdin.readline().split()))\n\ndef li_(): return [int(x) - 1 for x in stdin.readline().split()]\n\ndef lf(): return list(map(float, stdin.readline().split()))\n\ndef ls(): return stdin.readline().split()\n\ndef ns(): return stdin.readline().rstrip()\n\ndef lc(): return list(ns())\n\ndef ni(): return int(stdin.readline())\n\ndef nf(): return float(stdin.readline())\n\n\n\nn = ni()\n\n\n\nans = 0\n\nplus = 0\n\na = [ni() for _ in range(n)]\n\n\n\nfor ai in a:\n\n    ans += ((ai+plus) // 2)\n\n    plus = (ai+plus) % 2 if ai > 0 else 0\n\n\n\nprint(ans)", "score": 0.0, "codebleu": 0.15926945720863134, "crystalbleu": 0.11747006467029653, "codebertscore": 0.74, "codescore": 0.7265891432762146, "surfaceSim": 0.5123015873015873, "abs_surfaceSim_minus_score": 0.5123015873015873}
{"golden_code": "from collections import defaultdict\n\nN = int(eval(input()))\n\nd = defaultdict(int)\n\n\n\nfor i in range(N):\n\n    S = eval(input())\n\n    d[S] += 1\n\n\n\nm = 0\n\nfor k in list(d.keys()):\n\n    m = max(d[k],m)\n\n\n\nli = []\n\nfor k in list(d.keys()):\n\n    if d[k] == m:\n\n        li.append(k)\n\n\n\nli.sort()\n\nfor l in li:\n\n    print(l)", "generated_code": "from itertools import groupby\n\n\n\nS=eval(input())\n\nanswer = sum([1 for _ in groupby(S)]) -1\n\n\n\nprint(answer)", "score": 0.0, "codebleu": 0.11633406980830582, "crystalbleu": 0.0, "codebertscore": 0.72, "codescore": 0.05994613468647003, "surfaceSim": 0.4345991561181435, "abs_surfaceSim_minus_score": 0.4345991561181435}
{"golden_code": "n=int(eval(input()))-1\n\nA=list(map(int,input().split()))\n\ni=0\n\nfor j in range(n):\n\n if A[j]<=A[-1]:A[i],A[j]=A[j],A[i];i+=1\n\nA[i],A[n]=A[n],A[i]\n\nprint((\" \".join(map(str,A[:i]))+\" [\"+str(A[i])+\"] \"+\" \".join(map(str,A[i+1:]))))\n", "generated_code": "n,l=list(map(int,input().split()))\n\na=0\n\nfor i in range(n):\n\n  a+=i+l\n\nif l>=0:\n\n  print((a-l))\n\nelif l+n-1<0:\n\n  print((a-(l+n-1)))\n\nelse:\n\n  print(a)", "score": 0.0, "codebleu": 0.11975313261290843, "crystalbleu": 0.12161009589503917, "codebertscore": 0.82, "codescore": 0.08547720313072205, "surfaceSim": 0.5294273127753304, "abs_surfaceSim_minus_score": 0.5294273127753304}
{"golden_code": "import math\n\nx = int(eval(input()))\n\nprint((math.factorial(x) % (10**9 + 7)))", "generated_code": "#!/usr/bin python3\n\n# -*- coding: utf-8 -*-\n\n\n\ndef main():\n\n    N = int(eval(input()))\n\n    dp = [[0]*3 for i in range(N+1)]\n\n    #dp[i][j] iまでで、j=0はaを選ぶ,j=1はbを選ぶ,j=2はcを選ぶ\n\n    for i in range(1,N+1):\n\n        a, b, c=list(map(int,input().split()))\n\n        dp[i][0] = max(dp[i-1][1]+a, dp[i-1][2]+a, dp[i][0])\n\n        dp[i][1] = max(dp[i-1][2]+b, dp[i-1][0]+b, dp[i][1])\n\n        dp[i][2] = max(dp[i-1][0]+c, dp[i-1][1]+c, dp[i][2])\n\n\n\n    print((max(dp[N])))\n\n\n\nif __name__ == '__main__':\n\n    main()", "score": 0.0, "codebleu": 0.35314679020532785, "crystalbleu": 0.07975191807808181, "codebertscore": 0.6, "codescore": 0.018375052139163017, "surfaceSim": 0.42172688556120347, "abs_surfaceSim_minus_score": 0.42172688556120347}
{"golden_code": "import sys\n\nimport numpy as np\n\n\n\nn = int(sys.stdin.readline().rstrip())\n\nx = []\n\ny = []\n\nfor i in range(n):\n\n    a = int(sys.stdin.readline().rstrip())\n\n    xy = [sys.stdin.readline().split() for _ in range(a)]\n\n    if not xy:\n\n        x.append(None)\n\n        y.append(None)\n\n        continue\n\n    xi, yi = np.array(xy, np.int64).T\n\n    x.append(xi-1)\n\n    y.append(yi)\n\n\n\ndef main():\n\n\n\n    ans = 0\n\n    for comb in range(2 ** n):\n\n        cnt = 0\n\n        for i in range(n):\n\n            if not comb >> i & 1:\n\n                continue\n\n            if x[i] is None:\n\n                cnt += 1\n\n                continue\n\n            if np.count_nonzero(comb >> x[i] & 1 ^ y[i]):\n\n                break\n\n            cnt += 1\n\n        else:\n\n            ans = max(ans, cnt)\n\n    return ans\n\n                \n\nif __name__ == '__main__':\n\n    ans = main()\n\n    print(ans)", "generated_code": "from collections import deque\n\nK = int(eval(input()))\n\nG = [[] for i in range(K)]\n\nfor i in range(K):\n\n    G[i].append(((10 * i) % K, 0))\n\n    G[i].append(((i + 1) % K, 1))\n\n\n\ndist = [float('inf')] * K\n\ndist[1] = 1\n\nque = deque()\n\nque.append(1)\n\n\n\nwhile que:\n\n    n = que.pop()\n\n    for v, c in G[n]:\n\n        if dist[v] > dist[n] + c:\n\n            dist[v] = dist[n] + c\n\n            if c == 0:\n\n                que.append(v)\n\n            else:\n\n                que.appendleft(v)\n\n\n\nprint((dist[0]))\n", "score": 0.0, "codebleu": 0.17619703090106845, "crystalbleu": 0.06391886536750817, "codebertscore": 0.72, "codescore": 0.12388899177312851, "surfaceSim": 0.5349462365591398, "abs_surfaceSim_minus_score": 0.5349462365591398}
{"golden_code": "import sys\n\nimport os\n\nimport math\n\n\n\nii = lambda: int(sys.stdin.buffer.readline().rstrip())\n\nil = lambda: list(map(int, sys.stdin.buffer.readline().split()))\n\niln = lambda n: [int(sys.stdin.buffer.readline().rstrip()) for _ in range(n)]\n\n\n\niss = lambda: sys.stdin.buffer.readline().decode().rstrip()\n\nisn = lambda n: [sys.stdin.buffer.readline().decode().rstrip() for _ in range(n)]\n\n\n\n\n\ndef main():\n\n    if os.getenv(\"LOCAL\"):\n\n        sys.stdin = open(\"input.txt\", \"r\")\n\n\n\n    N = ii()\n\n    ret = float('inf')\n\n    I = int(math.sqrt(N)) * 10\n\n    for i in range(1, I):\n\n        if N%i == 0:\n\n            j = N//i\n\n            ret = min(ret, j + i - 2)\n\n\n\n    print(ret)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "generated_code": "from collections import Counter\n\nn=int(eval(input()))\n\na=[]\n\nfor i in range(n):\n\n  a.append(eval(input()))\n\nac=Counter(a)\n\nacs=sorted(list(ac.items()),key=lambda x:x[1],reverse=1)\n\nz=len(acs)\n\ni=0\n\ntemp=[]\n\n\n\nwhile i<=z-1 and acs[i][1]==acs[0][1] :\n\n  temp.append(acs[i][0])\n\n  i+=1\n\ntemp.sort()\n\nfor i in temp:\n\n  print(i)", "score": 0.0, "codebleu": 0.1324237448058469, "crystalbleu": 0.037786136379998635, "codebertscore": 0.68, "codescore": 0.09727106988430023, "surfaceSim": 0.4541068264917637, "abs_surfaceSim_minus_score": 0.4541068264917637}
{"golden_code": "from functools import lru_cache\n\nimport sys\n\n\n\nsys.setrecursionlimit(10 ** 7)\n\n\n\n\n\n@lru_cache(maxsize=None)\n\ndef check(l, r, n, k=1):\n\n    t = l + '0' * k + r\n\n    e = l + '9' * k + r\n\n\n\n    if int(e) <= n:\n\n        return pow(10, k) + check(l, r, n, k + 1)\n\n\n\n    if int(t) <= n < int(e):\n\n        x = int(str(n)[1:-1])\n\n        if int(str(n)[-1]) < int(r):\n\n            x -= 1\n\n        return x + 1\n\n\n\n    if n < int(t):\n\n        return 0\n\n\n\n\n\ndef main():\n\n    n = int(eval(input()))\n\n\n\n    ret = 0\n\n    for x in range(1, n + 1):\n\n        if x % 10 == 0:\n\n            continue\n\n        s = str(x)\n\n        t = s[-1] + s[0]\n\n        if s[0] == s[-1]:\n\n            ret += 1\n\n        if int(t) <= n:\n\n            ret += 1\n\n        ret += check(s[-1], s[0], n, k=1)\n\n\n\n    print(ret)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "generated_code": "adjacent = (\n\n    (1, 3),       # 0\n\n    (0, 2, 4),    # 1\n\n    (1, 5),       # 2\n\n    (0, 4, 6),    # 3\n\n    (1, 3, 5, 7), # 4\n\n    (2, 4, 8),    # 5\n\n    (3, 7),       # 6\n\n    (4, 6, 8),    # 7\n\n    (5, 7)        # 8\n\n)\n\n\n\nimport collections\n\n\n\nGOAL = [1, 2, 3, 4, 5, 6, 7, 8, 0]\n\n\n\n# Bidirectional search using breadth-first search\n\ndef solve(start):\n\n    if start == GOAL:\n\n        return 0\n\n    # 0: forward, 1: backward\n\n    generated_state = {tuple(start): 0, tuple(GOAL): 1}\n\n    step = {tuple(start): 0, tuple(GOAL): 0}\n\n    s = 0\n\n    state1 = [(start, 0), (GOAL, 1)]\n\n    while state1:\n\n        state2 = state1[:]\n\n        state1 = []\n\n        s += 1\n\n        for s2, d in state2:\n\n            i = s2.index(0)\n\n            for p in adjacent[i]:\n\n                s1 = s2[:]\n\n                s1[i], s1[p] = s1[p], 0\n\n                key = tuple(s1)\n\n                if key in generated_state:\n\n                    if generated_state[key] != d:\n\n                        return s + step[key]\n\n                    continue\n\n                state1.append((s1, d))\n\n                generated_state[key] = d\n\n                step[key] = s\n\n\n\nimport sys\n\n\n\nstart = list(map(int, sys.stdin.read().split()))\n\n\n\nprint((solve(start)))", "score": 0.0, "codebleu": 0.1482481338367548, "crystalbleu": 0.027696196348562695, "codebertscore": 0.7, "codescore": 0.1766015589237213, "surfaceSim": 0.5974394624029661, "abs_surfaceSim_minus_score": 0.5974394624029661}
{"golden_code": "#!usr/bin/env python3\n\nfrom collections import defaultdict\n\nfrom collections import deque\n\nfrom heapq import heappush, heappop\n\nimport sys\n\nimport math\n\nimport bisect\n\nimport random\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\n\ndef I(): return int(sys.stdin.readline())\n\ndef LS():return list(map(list, sys.stdin.readline().split()))\n\ndef S(): return list(sys.stdin.readline())[:-1]\n\ndef IR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = I()\n\n    return l\n\ndef LIR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = LI()\n\n    return l\n\ndef SR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = S()\n\n    return l\n\ndef LSR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = LS()\n\n    return l\n\nsys.setrecursionlimit(1000000)\n\nmod = 1000000007\n\n\n\n#A\n\ndef A():\n\n    return\n\n\n\n#B\n\ndef B():\n\n    return\n\n\n\n#C\n\ndef C():\n\n    return\n\n\n\n#D\n\ndef D():\n\n    return\n\n\n\n#E\n\ndef E():\n\n    return\n\n\n\n#F\n\ndef F():\n\n    a,b,c,X,Y = LI()\n\n    ans = float(\"inf\")\n\n    for z in range(300001):\n\n        if z%2 == 0:\n\n            m = c*z\n\n            x = z//2\n\n            y = z//2\n\n            m += a*max(0,X-x)\n\n            m += b*max(0,Y-y)\n\n            if m < ans:\n\n                ans = m\n\n    print(ans)\n\n    return\n\n\n\n#G\n\ndef G():\n\n    n = I()\n\n    x = LI()\n\n    f = [(i,x[i]) for i in range(n)]\n\n    f.sort(key = lambda x:x[1])\n\n    g = [(f[i][0],i) for i in range(n)]\n\n    g.sort(key = lambda x:x[0])\n\n    for i in range(n):\n\n        if g[i][1] < n//2:\n\n            print((f[n//2][1]))\n\n        else:\n\n            print((f[n//2-1][1]))\n\n    return\n\n\n\n#H\n\ndef H():\n\n    return\n\n\n\n#I\n\ndef I_():\n\n    return\n\n\n\n#J\n\ndef J():\n\n    return\n\n\n\n#Solve\n\nif __name__ == \"__main__\":\n\n    F()\n", "generated_code": "n = int(eval(input()))\n\n\n\nv_list = list(map(int,input().split()))\n\nc_list = list(map(int,input().split()))\n\n\n\ne_list = [v-c if (v-c > 0) else 0 for v,c in zip(v_list, c_list)]\n\n\n\nprint((sum(e_list)))\n", "score": 0.0, "codebleu": 0.06779493115537871, "crystalbleu": 0.0008420726818313339, "codebertscore": 0.66, "codescore": 0.03686504065990448, "surfaceSim": 0.38977920227920226, "abs_surfaceSim_minus_score": 0.38977920227920226}
{"golden_code": "import numpy as np\n\n\n\nS=eval(input())\n\nS=np.array([1 if s=='B' else 0 for s in S])\n\n\n\nprint((np.abs(np.diff(S)).sum()))\n", "generated_code": "from statistics import median_low\n\n\n\nN = int(eval(input()))\n\nA = list(map(int, input().split()))\n\n\n\nD = []\n\nfor i in range(N):\n\n    D.append(A[i] - (i+1))\n\n\n\nm = median_low(D)\n\nans = 0\n\nfor d in D:\n\n    ans += abs(d - m)\n\n\n\nprint(ans)\n", "score": 0.0, "codebleu": 0.19753883494897195, "crystalbleu": 0.0, "codebertscore": 0.73, "codescore": 0.9752213358879089, "surfaceSim": 0.4127659574468085, "abs_surfaceSim_minus_score": 0.4127659574468085}
{"golden_code": "import numpy as np\n\n\n\nN,M = list(map(int,input().split()))\n\n\n\nA = np.array([int(x) for x in input().split()],dtype=np.int64)\n\nA.sort()\n\n\n\nBC = np.array([[int(x) for x in input().split()] for _ in range(M)])\n\nB = BC[:,0]\n\nC = BC[:,1]\n\n\n\nidx = C.argsort()\n\nB = B[idx][::-1]\n\nC = C[idx][::-1]\n\n\n\np = 0\n\nfor b,c in zip(B,C):\n\n  A[p:p+b] = np.maximum(A[p:p+b],c)\n\n  p += b\n\n\n\nanswer = A.sum()\n\nprint(answer)\n", "generated_code": "N, X=list(map(int, input().split()))\n\nL=list(map(int, input().split()))\n\nL=[0]+L\n\n \n\nl=int(0)\n\ncounter=int(0)\n\nwhile l+L[counter]<=X and counter<=N:\n\n  l+=L[counter]\n\n  counter+=int(1)\n\n  if counter==N+1:\n\n    break\n\n  \n\nprint(counter)", "score": 0.0, "codebleu": 0.1281152647975078, "crystalbleu": 0.04027134469307246, "codebertscore": 0.73, "codescore": 0.9910181760787964, "surfaceSim": 0.43895051817252956, "abs_surfaceSim_minus_score": 0.43895051817252956}
{"golden_code": "from scipy.sparse.csgraph import csgraph_from_dense, floyd_warshall\n\n\n\nINF = float('inf')\n\n\n\ndef sol():\n\n    N, M = list(map(int, input().split()))\n\n\n\n    edges = []\n\n\n\n    for _ in range(M):\n\n        fr, to, cost = list(map(int, input().split()))\n\n        fr -= 1\n\n        to -= 1\n\n        edges.append((fr, to, cost))\n\n\n\n    graph = [[INF] * N for _ in range(N)]\n\n    for fr, to, cost in edges:\n\n        graph[fr][to] = cost\n\n\n\n    graph = csgraph_from_dense(graph, null_value=INF)\n\n\n\n    dist = floyd_warshall(graph, directed=False)\n\n    ans = (graph > dist).sum()\n\n    print(ans)\n\n\n\nsol()", "generated_code": "import sys\n\nsys.setrecursionlimit(10000000)\n\nimport heapq\n\nimport math\n\n\n\ndef main():\n\n    N, K = list(map(int, input().split()))\n\n    A = [int(c) for c in input().split()]\n\n    F = [int(c) for c in input().split()]\n\n    \n\n    A.sort()\n\n    F.sort(reverse=True)\n\n\n\n    num = 0\n\n    sum_ = []\n\n    for i in range(len(A)):\n\n        sum_.append(A[i] * F[i])\n\n    left = 0\n\n    right = 10 ** 12\n\n    while(num < 50):\n\n        number = 0\n\n        mid = (left + right) // 2\n\n        # print(mid)\n\n        for i in range(len(A)):\n\n            if sum_[i] <= mid:\n\n                continue\n\n            else:\n\n                number += math.ceil((sum_[i] - mid) / F[i])\n\n            # print(number)\n\n        if number > K:\n\n            # 最大値をmidより小さくできない -> 最大値はもっとでかい\n\n            left = mid + 1\n\n        else:\n\n            right = mid\n\n        num += 1\n\n    print(mid)\n\n                \n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 0.0, "codebleu": 0.25303390659154334, "crystalbleu": 0.09274020116133831, "codebertscore": 0.69, "codescore": 0.02215573936700821, "surfaceSim": 0.6354892110971573, "abs_surfaceSim_minus_score": 0.6354892110971573}
{"golden_code": "import numpy as np\n\n\n\ns = input()[::-1]\n\nlength = len(s)\n\na = np.zeros(length, dtype=int)\n\nd = np.zeros(length, dtype=int)\n\nans = np.zeros(2019, dtype=int)\n\nx = 10\n\n\n\na[0] = int(s[0])\n\nd[0] = a[0]\n\nans[d[0]] += 1\n\n\n\nfor i in range(1, length):\n\n    a[i] = int(s[i]) * x % 2019\n\n    d[i] = (d[i-1] + a[i]) % 2019\n\n    ans[d[i]] += 1\n\n    x = x * 10 % 2019\n\n\n\nans_c = ans[np.nonzero(ans)]\n\n\n\nprint((int(sum([ans_c[i] * (ans_c[i]-1) for i in range(ans_c.shape[0])]) / 2) + ans[0]))", "generated_code": "def main():\n\n    from sys import stdin\n\n    def input():\n\n        return stdin.readline().strip()\n\n\n\n    n, m = list(map(int, input().split()))\n\n    tree = [[] for _ in range(n)]\n\n    for _ in range(m):\n\n        i, j, k = list(map(int, input().split()))\n\n        i -= 1\n\n        j -= 1\n\n        tree[i].append((k, j))\n\n        tree[j].append((k, i))\n\n\n\n    # dijkstra\n\n    import heapq\n\n\n\n    ans = 0\n\n    for i in range(n):\n\n        for j in tree[i]:\n\n            seen = [0] * n\n\n            goal = j[1]\n\n            base = j[0]\n\n            seen[i] = 1\n\n            todo = []\n\n            heapq.heapify(todo)\n\n            for k in tree[i]:\n\n                if k[0] < base and k != j:\n\n                    heapq.heappush(todo, k)\n\n            while len(todo) > 0:\n\n                k = heapq.heappop(todo)\n\n                if k[1] == goal:\n\n                    if k[0] < base:\n\n                        ans += 1\n\n                    break\n\n                seen[k[1]] = 1\n\n                for l in tree[k[1]]:\n\n                    if seen[l[1]] == 0 and k[0] + l[0] < base:\n\n                        heapq.heappush(todo, (k[0] + l[0], l[1]))\n\n\n\n    print((ans // 2))\n\n\n\nmain()", "score": 0.0, "codebleu": 0.1703278114457742, "crystalbleu": 0.0406355319705873, "codebertscore": 0.7, "codescore": 0.17773474752902985, "surfaceSim": 0.5319014957761761, "abs_surfaceSim_minus_score": 0.5319014957761761}
{"golden_code": "import numpy as np\n\nnum=np.array(list(eval(input())))\n\n\n\nfor bit in  range(1<<3):\n\n  op=np.array(['-']*3)\n\n  for i in range(3):\n\n    if (bit>>i)&1:\n\n      op[i]='+'\n\n  formula=np.insert(num,[1,2,3],op)\n\n  \n\n  if eval(''.join(formula))==7:\n\n    flag=True\n\n    print((''.join(formula)+'=7'))\n\n    break", "generated_code": "import sys\n\ninput = sys.stdin.readline\n\n\n\nh, w = [int(x) for x in input().split()]\n\na = []\n\nfor _ in range(h):\n\n    b = list(input().rstrip())\n\n    if '#' in b:\n\n        a.append(b)\n\nh = len(a)\n\nc = [1]*w\n\nfor i in range(w):\n\n    flag = 1\n\n    for j in range(h):\n\n        if a[j][i] == \"#\":\n\n            flag = 0\n\n            break\n\n    if flag:\n\n        c[i] = 0\n\nans = []\n\nfor i in range(h):\n\n    res = []\n\n    for j in range(w):\n\n        if c[j]:\n\n            res.append(a[i][j])\n\n    ans.append(\"\".join(res))\n\nfor i in ans:\n\n    print(i)\n\n\n", "score": 0.0, "codebleu": 0.17917561964349157, "crystalbleu": 0.07966708692676422, "codebertscore": 0.72, "codescore": 0.07786312699317932, "surfaceSim": 0.6194219066937119, "abs_surfaceSim_minus_score": 0.6194219066937119}
{"golden_code": "def main():\n\n    from sys import stdin\n\n    def input():\n\n        return stdin.readline().strip()\n\n\n\n    n, m = list(map(int, input().split()))\n\n    tree = [[] for _ in range(n)]\n\n    for _ in range(m):\n\n        i, j, k = list(map(int, input().split()))\n\n        i -= 1\n\n        j -= 1\n\n        tree[i].append((k, j))\n\n        tree[j].append((k, i))\n\n\n\n    # dijkstra\n\n    import heapq\n\n    from numpy import zeros\n\n\n\n    ans = 0\n\n    for i in range(n):\n\n        for j in tree[i]:\n\n            seen = zeros(n)\n\n            goal = j[1]\n\n            base = j[0]\n\n            seen[i] = 1\n\n            todo = []\n\n            heapq.heapify(todo)\n\n            for k in tree[i]:\n\n                if k[0] < base and k != j:\n\n                    heapq.heappush(todo, k)\n\n            while len(todo) > 0:\n\n                k = heapq.heappop(todo)\n\n                if k[1] == goal:\n\n                    if k[0] < base:\n\n                        ans += 1\n\n                    break\n\n                seen[k[1]] = 1\n\n                for l in tree[k[1]]:\n\n                    if seen[l[1]] == 0 and k[0] + l[0] < base:\n\n                        heapq.heappush(todo, (k[0] + l[0], l[1]))\n\n\n\n    print((ans // 2))\n\n\n\nmain()", "generated_code": "N = int(eval(input()))\n\nV = [int(i) for i in input().split(\" \")]\n\nC = [int(i) for i in input().split(\" \")]\n\n\n\nval = 0\n\n\n\nfor i in range(N):\n\n    vc=V[i]-C[i]\n\n    if vc>0:\n\n        val+=vc\n\nprint(val)", "score": 0.0, "codebleu": 0.09759753095275314, "crystalbleu": 0.011474973126290349, "codebertscore": 0.68, "codescore": 0.7171202898025513, "surfaceSim": 0.560591763833659, "abs_surfaceSim_minus_score": 0.560591763833659}
{"golden_code": "import numpy as np\n\n\n\nn = int(eval(input()))\n\n\n\nv_list = np.array(list(map(int,input().split())))\n\nc_list = np.array(list(map(int,input().split())))\n\ne_list = list(v_list - c_list)\n\n\n\nans = 0\n\n\n\nfor i in range(n):\n\n    if e_list[i] > 0:\n\n        ans += e_list[i]\n\n\n\nprint(ans)\n", "generated_code": "N=int(eval(input()))\n\n\n\nA=[[-1]*N for _ in range(N)]\n\nfor i in range(N):\n\n  a=int(eval(input()))\n\n  for j in range(a):\n\n    x,y=list(map(int, input().split()))\n\n    A[i][x-1]=y\n\n#正直者が正直者に不親切と言われていない\n\n#→正直ものが不親切を正直者と言っていないか\n\nans=0\n\nfor i in range(2**N):\n\n  ok=True\n\n  for j in range(N):\n\n    if (i>>j&1)==1:\n\n      for k in range(N):\n\n        if A[j][k]!=-1 and (i>>k&1)!=A[j][k]:\n\n          ok=False\n\n  if ok:\n\n    ans=max(ans, bin(i).count(\"1\"))\n\n  \n\nprint(ans)", "score": 0.0, "codebleu": 0.3016288970940427, "crystalbleu": 0.10907521229889766, "codebertscore": 0.74, "codescore": 0.9934065341949463, "surfaceSim": 0.4958874458874458, "abs_surfaceSim_minus_score": 0.4958874458874458}
{"golden_code": "from bisect import bisect_left\n\nfrom bisect import bisect_right\n\n\n\nn,m = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\na = sorted(a)\n\n\n\na_count = [0]*100010\n\na_sum = [0]*100010\n\n\n\nfor i in range(n):\n\n    a_count[a[i]] += 1\n\n    a_sum[a[i]] += a[i]\n\n\n\nfor i in range(100005,-1,-1):\n\n    a_count[i] += a_count[i+1]\n\n    a_sum[i] += a_sum[i+1]\n\n\n\ndef chk(x):\n\n    case = 0\n\n    for i in range(n):\n\n        if 0<= x-a[i]<= 10**5+5:\n\n            case += a_count[x-a[i]]\n\n        elif x-a[i] < 0:\n\n            case += n\n\n    if case >= m:\n\n        ch = True\n\n    else:\n\n        ch = False\n\n    return ch\n\n\n\nl = 2*a[-1]+1    #NG\n\nr = 1 #OK\n\n\n\nwhile abs(r-l) > 1:\n\n    kk = (r+l)//2\n\n    if chk(kk):\n\n        r = kk\n\n    else:\n\n        l = kk\n\n\n\nans = 0\n\nsm = sum(a)\n\n\n\nl = r\n\n\n\ncase = 0\n\nfor i in range(n):\n\n    num = n-bisect_right(a,l-a[i]-1)\n\n    case += num\n\n    ans += num*a[i]*2\n\n\n\nans -= (case-m)*l\n\n\n\nprint(ans)", "generated_code": "INF = int(1e5)+5\n\n\n\ndef main():\n\n    a, b, c, x, y = list(map(int, input().split()))\n\n    ans = INF*INF\n\n    for i in range(INF):\n\n        tmp = 2*i*c + a*max(x-i, 0) + b*max(y-i, 0) \n\n        ans = min(tmp, ans)\n\n    print(ans)\n\nmain()\n", "score": 0.0, "codebleu": 0.10175906834972145, "crystalbleu": 0.019684609819351606, "codebertscore": 0.72, "codescore": 0.7344405055046082, "surfaceSim": 0.45405982905982906, "abs_surfaceSim_minus_score": 0.45405982905982906}
{"golden_code": "from itertools import product\n\n\n\nn = int(eval(input()))\n\nA = list(map(int, input().split()))\n\n\n\ncount = 0\n\nfor C in product((-1, 0, 1), repeat=n):\n\n  total = 1\n\n  for a, c in zip(A, C):\n\n    total *= (a + c)\n\n  if total % 2 == 0:\n\n    count += 1\n\nprint(count)", "generated_code": "num = int(input())\n\nprint(int(num/3600), int((num%3600)/60), num%60, sep=\":\")\n", "score": 0.0, "codebleu": 0.06146248064070975, "crystalbleu": 0.0, "codebertscore": 0.67, "codescore": 0.027229731902480125, "surfaceSim": 0.41111969111969116, "abs_surfaceSim_minus_score": 0.41111969111969116}
{"golden_code": "from collections import defaultdict\n\nn = int(eval(input()))\n\n\n\nd = defaultdict(int)\n\nfor _ in range(n):\n\n    key = eval(input())\n\n    d[key] += 1\n\n\n\ndict = sorted(list(d.items()), key=lambda x:x[1], reverse=True)\n\nmax_v = max(d.values())\n\n\n\ndict_li = []\n\nfor a in dict:\n\n    if a[1]==max_v:\n\n        dict_li.append(a[0])\n\n\n\ndict_li.sort()\n\nfor s in dict_li:\n\n    print(s)\n", "generated_code": "from itertools import groupby\n\n\n\nS=eval(input())\n\nanswer = sum([1 for _ in groupby(S)]) -1\n\n\n\nprint(answer)", "score": 0.0, "codebleu": 0.11602915417374948, "crystalbleu": 0.0, "codebertscore": 0.71, "codescore": 0.09154150635004044, "surfaceSim": 0.358678955453149, "abs_surfaceSim_minus_score": 0.358678955453149}
{"golden_code": "s=int(eval(input()))\n\np=10**9+7\n\nif s<=2:\n\n    print((0))\n\n    exit()\n\nn=s//3\n\nans=0\n\ndef f(n,k,p):\n\n    if k==0:\n\n        return 1\n\n    elif k%2==0:\n\n        return (f(n,k//2,p)**2)%p\n\n    else:\n\n        return (n*f(n,k-1,p))%p\n\n\n\nfor k in range(1,n+1):\n\n    a=1\n\n    b=1\n\n    for j in range(k-1):\n\n        a=(a*(s-3*k+1+j))%p\n\n        b=(b*(j+1))%p\n\n    ans=(ans+a*f(b,p-2,p))%p\n\n\n\nprint((ans%p))\n\n\n", "generated_code": "n, m = list(map(int, input().split()))\n\na = [int(x) for x in input().split()]\n\n\n\naa = [0]*(10**5+1)\n\naa_sum = [0]*(10**5+1)\n\n\n\nfor x in a:\n\n    aa[x] += 1\n\n    aa_sum[x] += x\n\n\n\nfor i in range(10**5)[::-1]:\n\n    aa[i] = aa[i] + aa[i+1]\n\n    aa_sum[i] = aa_sum[i] + aa_sum[i+1]\n\n\n\n\n\ndef count(x):\n\n    cnt = 0\n\n    sm = 0\n\n    for i in range(n):\n\n        if x-a[i] < 0:\n\n            cnt += n\n\n            sm += aa_sum[0]+n*a[i]\n\n        elif x-a[i] > 10**5:\n\n            continue\n\n        else:\n\n            cnt += aa[x-a[i]]\n\n            sm += aa_sum[x-a[i]]+aa[x-a[i]]*a[i]\n\n\n\n    return cnt, sm\n\n\n\n\n\nbottom = 0\n\ntop = 10**6\n\n\n\nwhile top - bottom > 1:\n\n    mid = (top+bottom) // 2\n\n    cnt, sm = count(mid)\n\n    if cnt < m:\n\n        top = mid\n\n    else:\n\n        bottom = mid\n\n\n\ncnt, sm = count(bottom)\n\nans = sm - (cnt-m)*bottom\n\n\n\nprint(ans)\n", "score": 0.0, "codebleu": 0.17279969054932878, "crystalbleu": 0.05278599016654181, "codebertscore": 0.77, "codescore": 0.9936198592185974, "surfaceSim": 0.5053254437869823, "abs_surfaceSim_minus_score": 0.5053254437869823}
{"golden_code": "import numpy as np\n\n# Me\n\n\n\n\n\ndef f():\n\n    i = int(eval(input()))\n\n    nums = np.array(list(map(int, input().split())))\n\n    # nums = [int(x) for x in input().split()]\n\n    c = 0\n\n    while True:\n\n        if any(nums % 2 == 1):\n\n            break\n\n        c += 1\n\n        nums = nums / 2\n\n    print(c)\n\n\n\n\n\nf()\n\n\n\n\n\n# Other\n", "generated_code": "def main():\n\n    from sys import stdin\n\n    def input():\n\n        return stdin.readline().strip()\n\n\n\n    n, m = list(map(int, input().split()))\n\n    tree = [[] for _ in range(n)]\n\n    for _ in range(m):\n\n        i, j, k = list(map(int, input().split()))\n\n        i -= 1\n\n        j -= 1\n\n        tree[i].append((k, j))\n\n        tree[j].append((k, i))\n\n\n\n    # dijkstra\n\n    import heapq\n\n\n\n    ans = 0\n\n    for i in range(n):\n\n        for j in tree[i]:\n\n            seen = [0] * n\n\n            goal = j[1]\n\n            base = j[0]\n\n            seen[i] = 1\n\n            todo = []\n\n            heapq.heapify(todo)\n\n            for k in tree[i]:\n\n                if k[0] < base and k != j:\n\n                    heapq.heappush(todo, k)\n\n            while len(todo) > 0:\n\n                k = heapq.heappop(todo)\n\n                if k[1] == goal:\n\n                    if k[0] < base:\n\n                        ans += 1\n\n                    break\n\n                seen[k[1]] = 1\n\n                for l in tree[k[1]]:\n\n                    if seen[l[1]] == 0 and k[0] + l[0] < base:\n\n                        heapq.heappush(todo, (k[0] + l[0], l[1]))\n\n\n\n    print((ans // 2))\n\n\n\nmain()", "score": 0.0, "codebleu": 0.28363995828527366, "crystalbleu": 0.0677060484869702, "codebertscore": 0.7, "codescore": 0.21187274158000946, "surfaceSim": 0.5463874680306906, "abs_surfaceSim_minus_score": 0.5463874680306906}
{"golden_code": "a, b = list(map(int, input().strip().split(\" \")))\n\ncount = 0\n\nfor i in range(a, b + 1):\n\n    if str(i) == str(i)[::-1]:\n\n        count += 1\n\nprint(count)\n", "generated_code": "def solve(string):\n\n    l = [s == \"1\" for s in string]\n\n    l_r = l[::-1]\n\n    index = 0\n\n    h = len(string) // 2\n\n    for i, (c, n, c_r, n_r) in enumerate(zip(l[:h], l[1:h + 1], l_r[:h], l_r[1:h + 1])):\n\n        if c ^ n or c_r ^ n_r:\n\n            index = i + 1\n\n    return str(len(string) - index)\n\n\n\n\n\nif __name__ == '__main__':\n\n    print((solve(eval(input()))))\n", "score": 0.0, "codebleu": 0.21417950536048302, "crystalbleu": 0.0, "codebertscore": 0.74, "codescore": 0.01845395937561989, "surfaceSim": 0.5183423913043479, "abs_surfaceSim_minus_score": 0.5183423913043479}
{"golden_code": "N=int(eval(input()))\n\n\n\nS=[[-1]*N for _ in range(N)]\n\nfor i in range(N):\n\n  A=int(eval(input()))\n\n  for _ in range(A):\n\n    x, y=list(map(int, input().split()))\n\n    S[i][x-1]=y\n\nans=0   \n\nfor s in range(2**N):\n\n  ok=True\n\n  for i in range(N):\n\n    #正直者について見ていく\n\n    if (s>>i&1)==1:\n\n      for j in range(N):\n\n        #それぞれ正直者の証言が矛盾ないか\n\n        if S[i][j]!=-1 and (s>>j&1)!=S[i][j]:\n\n          ok=False\n\n  if ok:\n\n    ans=max(ans, bin(s).count(\"1\"))\n\n    \n\nprint(ans)\n", "generated_code": "s = int(eval(input()))\n\ndp = [0]*(2001)\n\ndp[3] = 1\n\nmod = 10**9+7\n\nfor i in range(4,s+1):\n\n    dp[i] = (dp[i-1] + dp[i-3]) % mod\n\nprint((dp[s]))", "score": 0.0, "codebleu": 0.11061665293313436, "crystalbleu": 0.03633111844686821, "codebertscore": 0.71, "codescore": 0.30614715814590454, "surfaceSim": 0.4861111111111111, "abs_surfaceSim_minus_score": 0.4861111111111111}
{"golden_code": "import numpy as np\n\n \n\ndef main():\n\n    stdin = np.fromstring(open(0).read(), dtype=np.int64, sep=' ')\n\n    A = stdin[1:]\n\n    A = np.mod(A, 2)\n\n    print(\"first\") if np.count_nonzero(A) else print(\"second\")\n\nif __name__ == \"__main__\":\n\n    main()\n", "generated_code": "import sys\n\nfrom collections import Counter\n\nN = int(sys.stdin.readline())\n\nS = sys.stdin.read().split()\n\n\n\ncount = Counter(S)\n\nmax_num = max(count.values())\n\nmax_list = [i for i,j in list(count.items()) if j==max_num]\n\n \n\nmax_list.sort()\n\nprint(('\\n'.join(max_list)))", "score": 0.0, "codebleu": 0.17172838118474656, "crystalbleu": 0.0, "codebertscore": 0.71, "codescore": 0.024750959128141403, "surfaceSim": 0.42568407960199, "abs_surfaceSim_minus_score": 0.42568407960199}
{"golden_code": "import math\n\nN = int(eval(input()))\n\nprint((math.factorial(N)%(10**9+7)))", "generated_code": "import sys\n\nfrom collections import Counter, deque, defaultdict\n\nfrom itertools import accumulate, permutations, combinations, takewhile, compress, cycle\n\nfrom functools import reduce\n\nfrom math import ceil, floor, log10, log2, factorial\n\nfrom pprint import pprint\n\n\n\nsys.setrecursionlimit(1000000)\n\n# MOD = 10 ** 9 + 7\n\n# N = int(input())\n\n# A = [int(x) for x in input().split()]\n\n# V = [[0] * 100 for _ in range(100)]\n\n# A = [int(input()) for _ in range(N)]\n\n\n\nN, W = [int(x) for x in input().split()]\n\n\n\ndp = defaultdict(lambda: float('inf'))\n\ndp[0] = 0\n\n\n\nfor i in range(N):\n\n    w, v = [int(x) for x in input().split()]\n\n\n\n    add = defaultdict(lambda: float('inf'))\n\n    for vv in list(dp.keys()):\n\n        if dp[vv + v] > dp[vv] + w:\n\n            add[vv + v] = dp[vv] + w\n\n    dp.update(add)\n\n\n\nprint((max([i for i in list(dp.items()) if i[1] <= W], key=lambda x:x[0])[0]))\n", "score": 0.0, "codebleu": 0.3215392464049711, "crystalbleu": 0.0, "codebertscore": 0.65, "codescore": 0.8130052089691162, "surfaceSim": 0.4187097994702989, "abs_surfaceSim_minus_score": 0.4187097994702989}
{"golden_code": "import sys\n\nfrom operator import itemgetter\n\nfrom heapq import heapify, heappop, heappush\n\nMAX_INT = int(10e15)\n\nMIN_INT = -MAX_INT\n\nmod = 1000000007\n\nsys.setrecursionlimit(1000000)\n\ndef IL(): return list(map(int,input().split()))\n\ndef SL(): return input().split()\n\ndef I(): return int(sys.stdin.readline())\n\ndef S(): return eval(input())\n\n\n\nN, T = IL()\n\nab = [IL() for i in range(N)]\n\nab.sort(key=itemgetter(0))\n\n#print(ab)\n\n\n\ndp = [[0]*(T+1+3000+1) for _ in range(N+1)]\n\nans = 0\n\nfor i in range(N):\n\n  for j in range(T+1+3000+1):\n\n    time, deli = ab[i]\n\n    if 0 <= j-time < T:\n\n      dp[i + 1][j] = max(dp[i][j], dp[i][j - time] + deli)\n\n    else:\n\n      dp[i + 1][j] = dp[i][j]\n\n    ans = max(ans, dp[i + 1][j])\n\nprint(ans)\n\n\n\n#print(dp)\n", "generated_code": "while True:\n\n    try:\n\n        for i in range(3):\n\n            line = input().strip()\n\n            if line == '0':\n\n                raise Exception\n\n\n\n            if line[0] == 'A':\n\n                a = -1\n\n                b = 0\n\n            else:\n\n                a = 0\n\n                b = -1\n\n            for i, s in enumerate(line):\n\n                if s == 'A':\n\n                    a += 1\n\n                else:\n\n                    b += 1\n\n            if a > b:\n\n                a += 1\n\n            else:\n\n                b += 1\n\n            print(a, b)\n\n\n\n    except:\n\n        break", "score": 0.0, "codebleu": 0.08963117630495349, "crystalbleu": 0.01161758573577614, "codebertscore": 0.69, "codescore": 0.023449311032891273, "surfaceSim": 0.39918918031710604, "abs_surfaceSim_minus_score": 0.39918918031710604}
{"golden_code": "n = int(eval(input()))\n\nedges = []\n\n\n\nfor id in range(n-1):\n\n    a, b = list(map(int, input().split()))\n\n    edges.append([a-1, b-1, id])\n\n\n\nedges.sort()\n\n\n\nused = [0]*(n)\n\nans = [0]*(n-1)\n\nnum = 1\n\nprev = 0\n\nfor edge in edges:\n\n    _from, to, id = edge\n\n    if _from != prev:\n\n        num = 1\n\n    if used[_from] == num:\n\n        num += 1\n\n    ans[id] = num\n\n    used[to] = num\n\n    num += 1\n\n    prev = _from\n\n\n\nprint((max(ans)))\n\nfor color in ans:\n\n    print(color)\n", "generated_code": "s = eval(input())\n\n\n\nstart = 0\n\nfor i in range(len(s)):\n\n    if s[i] == 'A':\n\n        start = i\n\n        break\n\n\n\nend = 0\n\nfor i in reversed(list(range(len(s)))):\n\n    if s[i] == 'Z':\n\n        end = i\n\n        break\n\nprint((end - start + 1))\n", "score": 0.0, "codebleu": 0.10654834794654168, "crystalbleu": 0.030869108793408165, "codebertscore": 0.73, "codescore": 0.11691024154424667, "surfaceSim": 0.5951048329779673, "abs_surfaceSim_minus_score": 0.5951048329779673}
{"golden_code": "def c_repsept():\n\n    K = int(eval(input()))\n\n\n\n    L = 9 * K // 7 if K % 7 == 0 else 9 * K\n\n    if L % 2 == 0 or L % 5 == 0:\n\n        return -1\n\n\n\n    remainder = 1\n\n    for n in range(1, L + 1):\n\n        remainder = (10 * remainder) % L\n\n        if remainder == 1:\n\n            return n\n\n    return -1\n\n\n\nprint((c_repsept()))", "generated_code": "mod = 2019\n\nl, r = list(map(int, input().split()))\n\n\n\nif r//mod - l//mod > 0:\n\n  print((0))\n\nelse:\n\n  l %= mod\n\n  r %= mod\n\n  ans = mod\n\n  for i in range(l, r):\n\n    for j in range(i+1, r+1):\n\n      ans = min(i*j%mod, ans)\n\n    if ans == 0:\n\n      break\n\n  print(ans)", "score": 0.0, "codebleu": 0.14835015779177535, "crystalbleu": 0.0, "codebertscore": 0.75, "codescore": 0.5420891642570496, "surfaceSim": 0.5387195422708888, "abs_surfaceSim_minus_score": 0.5387195422708888}
{"golden_code": "N, L = list(map(int, input().split()))\n\nS = list(eval(input()) for i in range(N))\n\nstr = \"\"\n\nfor i in range(N-1):\n\n    for j in range(N-1):\n\n        if S[j+1] + S[j] <= S[j] + S[j+1]:\n\n            S[j], S[j+1] = S[j+1], S[j]\n\nfor i in S:\n\n    str += i\n\nprint(str)\n", "generated_code": "import collections\n\nimport math\n\nrange = xrange; input = raw_input\n\n\n\n\n\nclass Dinic:\n\n    \"\"\"Dinic Algorithm: find max-flow\n\n       complexity: O(EV^2)\n\n       used in GRL6A(AOJ)\n\n    \"\"\"\n\n    class edge:\n\n        def __init__(self, to, cap, rev):\n\n            self.to, self.cap, self.rev = to, cap, rev\n\n\n\n    def __init__(self, V, E, source, sink):\n\n        \"\"\" V: the number of vertexes\n\n            E: adjacency list\n\n            source: start point\n\n            sink: goal point\n\n        \"\"\"\n\n        self.V = V\n\n        self.E = [[] for _ in range(V)]\n\n        for fr in range(V):\n\n            for to, cap in E[fr]:\n\n                self.E[fr].append(self.edge(to, cap, len(self.E[to])))\n\n                self.E[to].append(self.edge(fr, 0, len(self.E[fr])-1))\n\n        self.maxflow = self.dinic(source, sink)\n\n\n\n    def dinic(self, source, sink):\n\n        \"\"\"find max-flow\"\"\"\n\n        INF = float('inf')\n\n        maxflow = 0\n\n        while True:\n\n            self.bfs(source)\n\n            if self.level[sink] < 0:\n\n                return maxflow\n\n            self.itr = [0] * self.V\n\n            while True:\n\n                flow = self.dfs(source, sink, INF)\n\n                if flow > 0:\n\n                    maxflow += flow\n\n                else:\n\n                    break\n\n\n\n    def dfs(self, vertex, sink, flow):\n\n        \"\"\"find augmenting path\"\"\"\n\n        if vertex == sink:\n\n            return flow\n\n        for i in range(self.itr[vertex], len(self.E[vertex])):\n\n            self.itr[vertex] = i\n\n            e = self.E[vertex][i]\n\n            if e.cap > 0 and self.level[vertex] < self.level[e.to]:\n\n                d = self.dfs(e.to, sink, min(flow, e.cap))\n\n                if d > 0:\n\n                    e.cap -= d\n\n                    self.E[e.to][e.rev].cap += d\n\n                    return d\n\n        return 0\n\n\n\n    def bfs(self, start):\n\n        \"\"\"find shortest path from start\"\"\"\n\n        que = collections.deque()\n\n        self.level = [-1] * self.V\n\n        que.append(start)\n\n        self.level[start] = 0\n\n\n\n        while que:\n\n            fr = que.popleft()\n\n            for e in self.E[fr]:\n\n                if e.cap > 0 and self.level[e.to] < 0:\n\n                    self.level[e.to] = self.level[fr] + 1\n\n                    que.append(e.to)\n\n\n\nwhile True:\n\n    M, N = list(map(int, input().split()))\n\n    if M == 0 and N == 0:\n\n        break\n\n    blue, red = [], []\n\n    while True:\n\n        for x in input().split():\n\n            blue.append(int(x))\n\n        if len(blue) == M:\n\n            break\n\n    while True:\n\n        for x in input().split():\n\n            red.append(int(x))\n\n        if len(red) == N:\n\n            break\n\n    V = M + N + 2\n\n    edge = [set() for _ in range(V)]\n\n    for i, b in enumerate(blue):\n\n        if b != 1:\n\n            for j, r in enumerate(red):\n\n                if r % b == 0:\n\n                    edge[i].add((M+j, 1))\n\n        for j in range(2, int(math.sqrt(b)) + 1):\n\n            if b % j == 0:\n\n                for k, r in enumerate(red):\n\n                    if r % j == 0 or r % (b // j) == 0:\n\n                        edge[i].add((M+k, 1))\n\n    for i in range(M):\n\n        edge[M+N].add((i, 1))\n\n    for j in range(N):\n\n        edge[M+j].add((M+N+1, 1))\n\n    d = Dinic(V, edge, M+N, M+N+1)\n\n    print((d.maxflow))", "score": 0.0, "codebleu": 0.25848481887659625, "crystalbleu": 0.04347350729120538, "codebertscore": 0.68, "codescore": 0.9938855767250061, "surfaceSim": 0.44138990144457946, "abs_surfaceSim_minus_score": 0.44138990144457946}
{"golden_code": "import collections\n\nimport math\n\n\n\n\n\nclass Dinic:\n\n    \"\"\"Dinic Algorithm: find max-flow\n\n       complexity: O(EV^2)\n\n       used in GRL6A(AOJ)\n\n    \"\"\"\n\n    class edge:\n\n        def __init__(self, to, cap, rev):\n\n            self.to, self.cap, self.rev = to, cap, rev\n\n\n\n    def __init__(self, V, E, source, sink):\n\n        \"\"\" V: the number of vertexes\n\n            E: adjacency list\n\n            source: start point\n\n            sink: goal point\n\n        \"\"\"\n\n        self.V = V\n\n        self.E = [[] for _ in range(V)]\n\n        for fr in range(V):\n\n            for to, cap in E[fr]:\n\n                self.E[fr].append(self.edge(to, cap, len(self.E[to])))\n\n                self.E[to].append(self.edge(fr, 0, len(self.E[fr])-1))\n\n        self.maxflow = self.dinic(source, sink)\n\n\n\n    def dinic(self, source, sink):\n\n        \"\"\"find max-flow\"\"\"\n\n        INF = float('inf')\n\n        maxflow = 0\n\n        while True:\n\n            self.bfs(source)\n\n            if self.level[sink] < 0:\n\n                return maxflow\n\n            self.itr = [0] * self.V\n\n            while True:\n\n                flow = self.dfs(source, sink, INF)\n\n                if flow > 0:\n\n                    maxflow += flow\n\n                else:\n\n                    break\n\n\n\n    def dfs(self, vertex, sink, flow):\n\n        \"\"\"find augmenting path\"\"\"\n\n        if vertex == sink:\n\n            return flow\n\n        for i in range(self.itr[vertex], len(self.E[vertex])):\n\n            self.itr[vertex] = i\n\n            e = self.E[vertex][i]\n\n            if e.cap > 0 and self.level[vertex] < self.level[e.to]:\n\n                d = self.dfs(e.to, sink, min(flow, e.cap))\n\n                if d > 0:\n\n                    e.cap -= d\n\n                    self.E[e.to][e.rev].cap += d\n\n                    return d\n\n        return 0\n\n\n\n    def bfs(self, start):\n\n        \"\"\"find shortest path from start\"\"\"\n\n        que = collections.deque()\n\n        self.level = [-1] * self.V\n\n        que.append(start)\n\n        self.level[start] = 0\n\n\n\n        while que:\n\n            fr = que.popleft()\n\n            for e in self.E[fr]:\n\n                if e.cap > 0 and self.level[e.to] < 0:\n\n                    self.level[e.to] = self.level[fr] + 1\n\n                    que.append(e.to)\n\n\n\nwhile True:\n\n    M, N = list(map(int, input().split()))\n\n    if M == 0 and N == 0:\n\n        break\n\n    blue, red = [], []\n\n    while True:\n\n        for x in input().split():\n\n            blue.append(int(x))\n\n        if len(blue) == M:\n\n            break\n\n    while True:\n\n        for x in input().split():\n\n            red.append(int(x))\n\n        if len(red) == N:\n\n            break\n\n    V = M + N + 2\n\n    edge = [set() for _ in range(V)]\n\n    for i, b in enumerate(blue):\n\n        if b != 1:\n\n            for j, r in enumerate(red):\n\n                if r % b == 0:\n\n                    edge[i].add((M+j, 1))\n\n        for j in range(2, int(math.sqrt(b)) + 1):\n\n            if b % j == 0:\n\n                for k, r in enumerate(red):\n\n                    if r % j == 0 or r % (b // j) == 0:\n\n                        edge[i].add((M+k, 1))\n\n    for i in range(M):\n\n        edge[M+N].add((i, 1))\n\n    for j in range(N):\n\n        edge[M+j].add((M+N+1, 1))\n\n    d = Dinic(V, edge, M+N, M+N+1)\n\n    print((d.maxflow))", "generated_code": "n = int(eval(input()))\n\ndef make_divisors(n):\n\n    divisors = []\n\n    for i in range(1, int(n**0.5)+1):\n\n        if n % i == 0:\n\n            divisors.append(i)\n\n            if i != n // i:\n\n                divisors.append(n//i)\n\n\n\n    #divisors.sort(reverse=True)\n\n    return divisors\n\n\n\nl = make_divisors(n)\n\nmin_ = float('inf')\n\nfor i in range(len(l)):\n\n    min_ = min(min_, l[i]-1+n//l[i]-1)\n\nprint(min_)\n", "score": 0.0, "codebleu": 0.10913062450474527, "crystalbleu": 0.0010489861221926768, "codebertscore": 0.69, "codescore": 0.17584584653377533, "surfaceSim": 0.5246531945181009, "abs_surfaceSim_minus_score": 0.5246531945181009}
{"golden_code": "# https://atcoder.jp/contests/abc129/tasks/abc129_c\n\n# 典型的なDP\n\n\n\nMOD = 10**9 + 7\n\nimport numpy as np\n\n# dp[i]をi段目までの通りの数とする。\n\nN, M = list(map(int, input().split()))\n\nto_zero = np.full((N + 1), False, dtype=bool)\n\nfor _ in range(M):\n\n    to_zero[int(eval(input()))] = True  # 床が抜けているところ\n\n\n\n# dpテーブルの用意\n\ndp = np.full((N + 1), -1, dtype='int64')\n\ndp[0] = 1\n\ndp[1] = 0 if to_zero[1] else 1\n\nfor i in range(2, N + 1):\n\n    dp[i] = 0 if to_zero[i] else dp[i - 2] + dp[i - 1]\n\n    if dp[i] > MOD:\n\n        dp[i] %= MOD\n\n\n\nprint((dp[-1]))\n", "generated_code": "import sys\n\ninput = sys.stdin.readline\n\n\n\nh, w = [int(x) for x in input().split()]\n\na = []\n\nfor _ in range(h):\n\n    b = list(input().rstrip())\n\n    if '#' in b:\n\n        a.append(b)\n\nh = len(a)\n\nc = [1]*w\n\nfor i in range(w):\n\n    flag = 1\n\n    for j in range(h):\n\n        if a[j][i] == \"#\":\n\n            flag = 0\n\n            break\n\n    if flag:\n\n        c[i] = 0\n\nans = []\n\nfor i in range(h):\n\n    res = []\n\n    for j in range(w):\n\n        if c[j]:\n\n            res.append(a[i][j])\n\n    ans.append(\"\".join(res))\n\nfor i in ans:\n\n    print(i)\n\n\n", "score": 0.0, "codebleu": 0.1326343421676367, "crystalbleu": 0.09858733762805148, "codebertscore": 0.69, "codescore": 0.09278667718172073, "surfaceSim": 0.502547268907563, "abs_surfaceSim_minus_score": 0.502547268907563}
{"golden_code": "import sys\n\nimport numpy as np\n\nfrom numba import njit\n\n\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\n@njit('(i4[::1],i4,i8[::1])', cache=True)\n\ndef main(A, B, C):\n\n    counts = np.zeros(1 << 18, np.int32)\n\n    popcount = np.zeros(1 << B, np.int32)\n\n    for i in range(B):\n\n        popcount[1 << i:1 << i + 1] = popcount[:1 << i] + 1\n\n\n\n    answer = 0\n\n    for i in range(1 << B):\n\n        k = popcount[i]\n\n        t = 0\n\n        for x in A & i:\n\n            n = counts[x]\n\n            counts[x] += 1\n\n            t -= C[n]\n\n            t += C[n + 1]\n\n        for x in A & i:\n\n            counts[x] = 0\n\n        if k & 1:\n\n            t = -t\n\n        answer += t\n\n    return answer\n\n\n\nN, K, S, T = list(map(int, readline().split()))\n\nA = np.array(readline().split(), np.int32)\n\n\n\ndef convert_problem(S, T, A):\n\n    ng = np.zeros(len(A), np.bool)\n\n    B = np.zeros_like(A)\n\n    n = 0\n\n    for i in range(18):\n\n        s, t = (S >> i) & 1, (T >> i) & 1\n\n        if (s, t) == (0, 0):\n\n            ng |= ((A >> i) & 1) == 1\n\n        elif (s, t) == (1, 1):\n\n            ng |= ((A >> i) & 1) == 0\n\n        elif (s, t) == (1, 0):\n\n            print((0))\n\n            exit()\n\n        else:\n\n            B += ((A >> i) & 1) << n\n\n            n += 1\n\n    return B[~ng], n\n\n\n\nA, B = convert_problem(S, T, A)\n\n\n\nC = np.zeros((100, 100), np.int64)\n\nC[0, 0] = 1\n\nfor n in range(1, 100):\n\n    C[n, :-1] += C[n - 1, :-1]\n\n    C[n, 1:] += C[n - 1, :-1]\n\nC = C[:, 1:K + 1].sum(axis=1)\n\n\n\nprint((main(A, B, C)))", "generated_code": "s=int(eval(input()))\n\np=10**9+7\n\nif s<=2:\n\n    print((0))\n\n    exit()\n\nn=s//3\n\nans=0\n\nx=[0]*(s+1)\n\nx[0]=1\n\nx[1]=1\n\ny=[0]*(s+1)\n\n\n\nfor i in range(2,s+1):\n\n    x[i]=x[i-1]*i%p\n\n\n\ny[s]=pow(x[s],p-2,p)\n\nfor i in range(s):\n\n    y[s-1-i]=y[s-i]*(s-i)%p\n\n\n\nfor k in range(1,n+1):\n\n    ans+=x[s-2*k-1]*y[k-1]*y[s-3*k]%p\n\n\n\nprint((ans%p))\n\n\n", "score": 0.0, "codebleu": 0.0935801760503029, "crystalbleu": 0.02830618978900089, "codebertscore": 0.72, "codescore": 0.8664933443069458, "surfaceSim": 0.42649341732095414, "abs_surfaceSim_minus_score": 0.42649341732095414}
{"golden_code": "a, b, c, x, y = list(map(int, input().split(' ')))\n\n\n\nc = int(c*2)\n\nm = float('inf')\n\nfor i in range(10**5+1):\n\n    m = min(m, a*max(0, x-i)+b*max(0,y-i)+c*i)\n\nprint(m)", "generated_code": "N, M = list(map(int, input().split()))\n\n\n\nleft = 1\n\nright = N\n\n\n\nfor _ in range(M):\n\n    l, r = list(map(int, input().split()))\n\n\n\n    if left < l:\n\n        left = l\n\n    if right > r:\n\n        right = r\n\n\n\nans = right - left\n\n\n\nprint((ans + 1 if ans >= 0 else 0))\n", "score": 0.0, "codebleu": 0.1391581918881566, "crystalbleu": 0.10520190259598892, "codebertscore": 0.76, "codescore": 0.10612660646438599, "surfaceSim": 0.5710120068610635, "abs_surfaceSim_minus_score": 0.5710120068610635}
{"golden_code": "import heapq\n\n\n\nN = int(eval(input()))\n\nabc = [list(map(int,input().split())) for _ in range(N-1)]\n\nQ,K = list(map(int,input().split()))\n\nxy = [list(map(int,input().split())) for _ in range(Q)]\n\n\n\nconnect = [[] for _ in range(N)]\n\nINFTY = 10**15\n\nfor a,b,c in abc:\n\n    connect[a-1].append([b-1,c])\n\n    connect[b-1].append([a-1,c])\n\n\n\ncost = [[INFTY,False] for _  in range(N)]\n\ncost[K-1][0] = 0\n\nq = [(0,K-1)]\n\nwhile q:\n\n    _,i = heapq.heappop(q)\n\n    if cost[i][1]:\n\n        continue\n\n    cost[i][1] = True\n\n    ci0 = cost[i][0]\n\n    for j,c in connect[i]:\n\n        if cost[j][1]:\n\n            continue\n\n        tmp_cost = ci0+c\n\n        if tmp_cost < cost[j][0]:\n\n            cost[j][0] = tmp_cost\n\n            heapq.heappush(q,(tmp_cost,j))\n\n\n\nfor x,y in xy:\n\n    print((cost[x-1][0] + cost[y-1][0]))", "generated_code": "import sys\n\ndef input(): return sys.stdin.readline().strip()\n\ndef main():\n\n    N = int(input())\n\n    A = (int(input()) for _ in range(N))\n\n    print(\"second\") if all(( a%2==0 for a in A)) else print(\"first\")\n\nif __name__ == \"__main__\":\n\n    main()\n", "score": 0.0, "codebleu": 0.08741936558144783, "crystalbleu": 0.008093434190719936, "codebertscore": 0.68, "codescore": 0.3577052056789398, "surfaceSim": 0.4162404092071611, "abs_surfaceSim_minus_score": 0.4162404092071611}
{"golden_code": "def popcount(x):\n\n  r = 0\n\n  while x:\n\n    if x & 1:\n\n      r += 1\n\n    x >>= 1\n\n  return r\n\n\n\nn = int(eval(input()))\n\nr = list(range(n))\n\na = [[0, 0] for _ in r]\n\nfor i in r:\n\n  for _ in range(int(eval(input()))):\n\n    x, y = list(map(int, input().split()))\n\n    a[i][y] |= 1 << (x - 1)\n\n\n\nm = 0\n\nl = (1 << n) - 1\n\nfor x in range(1, l + 1):\n\n  if all(a[i][0] & x == a[i][1] & l - x == 0 for i in r if x >> i & 1):\n\n    m = max(m, popcount(x))\n\nprint(m)\n", "generated_code": "import sys\n\nfrom collections import Counter, deque, defaultdict\n\nfrom itertools import accumulate, permutations, combinations, takewhile, compress, cycle\n\nfrom functools import reduce\n\nfrom math import ceil, floor, log10, log2, factorial\n\nfrom pprint import pprint\n\n\n\nsys.setrecursionlimit(1000000)\n\n# MOD = 10 ** 9 + 7\n\n# N = int(input())\n\n# A = [int(x) for x in input().split()]\n\n# V = [[0] * 100 for _ in range(100)]\n\n# A = [int(input()) for _ in range(N)]\n\n\n\nN, W = [int(x) for x in input().split()]\n\n\n\ndp = defaultdict(lambda: float('inf'))\n\ndp[0] = 0\n\n\n\nfor i in range(N):\n\n    w, v = [int(x) for x in input().split()]\n\n\n\n    add = defaultdict(lambda: float('inf'))\n\n    for vv in list(dp.keys()):\n\n        if dp[vv + v] > dp[vv] + w:\n\n            add[vv + v] = dp[vv] + w\n\n    dp.update(add)\n\n\n\nprint((max([i for i in list(dp.items()) if i[1] <= W], key=lambda x:x[0])[0]))\n", "score": 0.0, "codebleu": 0.16924461756484904, "crystalbleu": 0.051056627116075795, "codebertscore": 0.72, "codescore": 0.6292438507080078, "surfaceSim": 0.5037031782065835, "abs_surfaceSim_minus_score": 0.5037031782065835}
{"golden_code": "# 初期入力\n\nimport sys\n\nimport math\n\n#input = sys.stdin.readline\n\nX = int(eval(input()))\n\nlimit =10**5\n\na=0\n\nb=0\n\nfor b in range(-1*limit ,limit):\n\n    a5 =X+pow(b,5)\n\n    if 0 <= a5: \n\n        a=math.pow(a5,0.2)\n\n        a_int =int(a)\n\n        dif =a_int**5 -b**5 -X\n\n        if abs(dif)<10**(-5):\n\n            break\n\n    else:\n\n        continue\n\nprint((a_int,b))", "generated_code": "#!/usr/bin/env python3\n\ndef main():\n\n    import numpy as np\n\n\n\n    N, W = list(map(int, input().split()))\n\n    lst = [list(map(int, input().split())) for _ in range(N)]\n\n    v_max = 10 ** 3 * 100 * 10\n\n    w_max = 10 ** 9 * v_max\n\n\n\n    # i以上の価値を持つときの最小重量\n\n    dp = np.full(v_max, w_max, dtype=np.int64)\n\n    # initialize\n\n    dp[0] = 0\n\n\n\n    for w, v in lst:\n\n        dp[v:] = np.minimum(dp[v:], dp[:-v] + w)\n\n\n\n    print((np.asarray(dp <= W).nonzero()[0].max()))\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 0.0, "codebleu": 0.10282535909773993, "crystalbleu": 0.027435818657052587, "codebertscore": 0.69, "codescore": 0.019950946792960167, "surfaceSim": 0.5701680672268907, "abs_surfaceSim_minus_score": 0.5701680672268907}
{"golden_code": "n=int(eval(input()))\n\nnode={i:[] for i in range(1,n+1)}\n\nvisited=[False for i in range(n+1)]\n\nq=[]\n\nfor _ in range(n-1):\n\n    a,b=list(map(int,input().split()))\n\n    node[a].append(b)\n\n    node[b].append(a)\n\n    q.append((a,b))\n\n\n\nmother=q[0][0]\n\nvisited[mother]=True\n\n\n\nd=[]\n\ne=[]\n\n\n\n\n\npaint={i:{} for i in range(1,n+1)}\n\n\n\nmother_paint=[0 for i in range(n+1)]\n\n\n\n#使う要素 node visited paint mother_paint の四つのリスト\n\nc=1\n\nfor child in node[mother]:\n\n    visited[child]=True\n\n    paint[mother][child]=c\n\n    paint[child][mother]=c\n\n    mother_paint[child]=c\n\n    c+=1\n\n    d.append(child)\n\n    \n\nwhile d:\n\n    for parent in d:\n\n        p=1 \n\n        for child in node[parent]:\n\n            if visited[child]==False:\n\n                visited[child]=True\n\n                if p!=mother_paint[parent]:\n\n                    paint[parent][child]=p\n\n                    paint[child][parent]=p\n\n                    mother_paint[child]=p\n\n                    p+=1\n\n                    e.append(child)\n\n                else:\n\n                    p+=1\n\n                    paint[parent][child]=p\n\n                    paint[child][parent]=p\n\n                    mother_paint[child]=p\n\n                    p+=1\n\n                    e.append(child)\n\n    if e:\n\n        d=e\n\n        e=[]\n\n    else:\n\n        d=[]\n\n        e=[]\n\nK=0\n\nfor i in range(1,n+1):\n\n    K=max(K,len(node[i]))\n\nprint(K)\n\nfor i in range(n-1):\n\n    s,t=q[i][0],q[i][1]\n\n    print((paint[s][t]))", "generated_code": "import sys\n\nK = int(eval(input()))\n\n\n\nL = 9 * K\n\n\n\nif K % 7 == 0:\n\n    L //= 7\n\n\n\npower = 1\n\n\n\nfor i in range(1, 10 ** 6):\n\n    power *= 10\n\n    power %= L\n\n    if power == 1:\n\n        print(i)\n\n        sys.exit()\n\n\n\nprint((-1))", "score": 0.0, "codebleu": 0.07269365777165074, "crystalbleu": 0.0020517848078157393, "codebertscore": 0.67, "codescore": 0.7672216892242432, "surfaceSim": 0.44004748713889985, "abs_surfaceSim_minus_score": 0.44004748713889985}
{"golden_code": "import sys\n\n\n\ninit = ''.join(sys.stdin.read().split())\n\n\n\n# Bidirectional search using breadth-first search\n\ndef solve(start, goal):\n\n    if start == goal:\n\n        return 0\n\n    generated_state = {start: 0, goal: 1}   # 0: foreward, 1: backward\n\n    step = {start: 0, goal: 0}\n\n    s = 0\n\n    c_d = [(start, 0), (goal, 1)] # configure and direction\n\n    while True:\n\n        q = iter(c_d)\n\n        c_d = []\n\n        s += 1\n\n        for c, d in q:\n\n            i = c.find('0')\n\n            if 0 <= i <= 5:\n\n                t = str.maketrans('0' + c[i+3], c[i+3] + '0')\n\n                t_c = c.translate(t)\n\n                if t_c in generated_state:\n\n                    if generated_state[t_c] != d:\n\n                        return s + step[t_c]\n\n                else:\n\n                    generated_state[t_c] = d\n\n                    step[t_c] = s\n\n                    c_d.append((t_c, d))\n\n            if i >= 3:\n\n                t = str.maketrans('0' + c[i-3], c[i-3] + '0')\n\n                t_c = c.translate(t)\n\n                if t_c in generated_state:\n\n                    if generated_state[t_c] != d:\n\n                        return s + step[t_c]\n\n                else:\n\n                    generated_state[t_c] = d\n\n                    step[t_c] = s\n\n                    c_d.append((t_c, d))\n\n            if i == 0 or i == 1 or i == 3 or i == 4 or i == 6 or i == 7:\n\n                t = str.maketrans('0' + c[i+1], c[i+1] + '0')\n\n                t_c = c.translate(t)\n\n                if t_c in generated_state:\n\n                    if generated_state[t_c] != d:\n\n                        return s + step[t_c]\n\n                else:\n\n                    generated_state[t_c] = d\n\n                    step[t_c] = s\n\n                    c_d.append((t_c, d))\n\n            if i == 1 or i == 2 or i == 4 or i == 5 or i == 7 or i == 8:\n\n                t = str.maketrans('0' + c[i-1], c[i-1] + '0')\n\n                t_c = c.translate(t)\n\n                if t_c in generated_state:\n\n                    if generated_state[t_c] != d:\n\n                        return s + step[t_c]\n\n                else:\n\n                    generated_state[t_c] = d\n\n                    step[t_c] = s\n\n                    c_d.append((t_c, d))\n\n\n\nprint((solve(init, '123456780')))", "generated_code": "#!usr/bin/env python3\n\nfrom collections import defaultdict,deque\n\nfrom heapq import heappush, heappop\n\nfrom itertools import permutations\n\nimport sys\n\nimport math\n\nimport bisect\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\n\ndef I(): return int(sys.stdin.readline())\n\ndef LS():return [list(x) for x in sys.stdin.readline().split()]\n\ndef S():\n\n    res = list(sys.stdin.readline())\n\n    if res[-1] == \"\\n\":\n\n        return res[:-1]\n\n    return res\n\ndef IR(n):\n\n    return [I() for i in range(n)]\n\ndef LIR(n):\n\n    return [LI() for i in range(n)]\n\ndef SR(n):\n\n    return [S() for i in range(n)]\n\ndef LSR(n):\n\n    return [LS() for i in range(n)]\n\n\n\nsys.setrecursionlimit(1000000)\n\nmod = 1000000007\n\n\n\ndef solve():\n\n    A,B,C,x,y = LI()\n\n    ans = float(\"inf\")\n\n    for c in range(200001)[::2]:\n\n        a = b = c >> 1\n\n        a = max(0,x-a)\n\n        b = max(0,y-b)\n\n        s = A*a+B*b+C*c\n\n        if s < ans:\n\n            ans = s\n\n    print(ans)\n\n    return\n\n\n\n#Solve\n\nif __name__ == \"__main__\":\n\n    solve()\n", "score": 0.0, "codebleu": 0.09643670613232076, "crystalbleu": 0.025906485864928518, "codebertscore": 0.69, "codescore": 0.05024626851081848, "surfaceSim": 0.5866063548102383, "abs_surfaceSim_minus_score": 0.5866063548102383}
{"golden_code": "import sys\n\nsys.setrecursionlimit(2147483647)\n\nINF=float(\"inf\")\n\nMOD=10**9+7\n\ninput=lambda :sys.stdin.readline().rstrip()\n\ndef resolve():\n\n    n,T=list(map(int,input().split()))\n\n    AB=[tuple(map(int,input().split())) for _ in range(n)]\n\n    ans=-INF\n\n\n\n    # 何も考えずやる\n\n    dp=[0]*T\n\n    for i in range(n):\n\n        a,b=AB[i]\n\n        ndp=dp[:]\n\n        for t in range(T):\n\n            if(t+a<T):\n\n                ndp[t+a]=max(ndp[t+a],dp[t]+b)\n\n            else:\n\n                ans=max(ans,dp[t]+b)\n\n        dp=ndp\n\n    ans=max(ans,max(dp))\n\n\n\n    # 時間が最もかかるもののうち、価値が最大のものを最後にする\n\n    AB.sort()\n\n    la,lb=AB[-1]\n\n\n\n    dp=[0]*T\n\n    for i in range(n-1):\n\n        a,b=AB[i]\n\n        ndp=dp[:]\n\n        for t in range(T):\n\n            if(t+a<T):\n\n                ndp[t+a]=max(ndp[t+a],dp[t]+b)\n\n            else:\n\n                ans=max(ans,dp[t]+b)\n\n        dp=ndp\n\n    ans=max(ans,max(dp)+lb)\n\n\n\n    # 価値が最大のもののうち、時間が最もかかるものを最後にする\n\n    AB.sort(lambda x:(x[1],x[0]))\n\n    la,lb=AB[-1]\n\n\n\n    dp=[0]*T\n\n    for i in range(n-1):\n\n        a,b=AB[i]\n\n        ndp=dp[:]\n\n        for t in range(T):\n\n            if(t+a<T):\n\n                ndp[t+a]=max(ndp[t+a],dp[t]+b)\n\n            else:\n\n                ans=max(ans,dp[t]+b)\n\n        dp=ndp\n\n    ans=max(ans,max(dp)+lb)\n\n\n\n    print(ans)\n\nresolve()", "generated_code": "import sys\n\nfrom collections import Counter, deque, defaultdict\n\nfrom itertools import accumulate, permutations, combinations, takewhile, compress, cycle\n\nfrom functools import reduce\n\nfrom math import ceil, floor, log10, log2, factorial\n\nfrom pprint import pprint\n\n\n\nsys.setrecursionlimit(1000000)\n\n# MOD = 10 ** 9 + 7\n\n# N = int(input())\n\n# A = [int(x) for x in input().split()]\n\n# V = [[0] * 100 for _ in range(100)]\n\n# A = [int(input()) for _ in range(N)]\n\n\n\nN, W = [int(x) for x in input().split()]\n\n\n\ndp = defaultdict(lambda: float('inf'))\n\ndp[0] = 0\n\n\n\nfor i in range(N):\n\n    w, v = [int(x) for x in input().split()]\n\n\n\n    add = defaultdict(lambda: float('inf'))\n\n    for vv in list(dp.keys()):\n\n        if dp[vv + v] > dp[vv] + w:\n\n            add[vv + v] = dp[vv] + w\n\n    dp.update(add)\n\n\n\nprint((max([i for i in list(dp.items()) if i[1] <= W], key=lambda x:x[0])[0]))\n", "score": 0.0, "codebleu": 0.12986358227620773, "crystalbleu": 0.05141833944803314, "codebertscore": 0.73, "codescore": 0.5838907957077026, "surfaceSim": 0.5824136925831841, "abs_surfaceSim_minus_score": 0.5824136925831841}
{"golden_code": "N = int(eval(input()))\n\nA = list(map(int, input().split()))\n\n# 中央値\n\nB = []\n\nfor i in range(N):\n\n    B.append(A[i] - (i+1))\n\nb = sorted(B)[N//2]\n\n\n\nans = 0\n\nfor i in range(N):\n\n    ans += abs(A[i] - (i + 1) - b)\n\n\n\nprint(ans)\n\n\n", "generated_code": "import sys\n\n\n\ndef main():\n\n    input = sys.stdin.readline\n\n    N = int(eval(input()))\n\n    S = list(map(int, input().split()))\n\n\n\n    ans = 0\n\n    # C = A - B\n\n    for C in range(1, N//2):\n\n        n = (N-1) // C\n\n        point = 0\n\n        for k in range(1, n):\n\n            A = N-1 - k*C\n\n\n\n            # Check A and B are positive integer, and S_i is not used twice.\n\n            #\n\n            # B = A - C and B >= 0, so A must be over C (A > C).\n\n            #\n\n            # If C is aliquot of N-1 (N-1 % C = 0), A is also aliquot of N-1\n\n            # (N-1 % A = 0) because A + kC = N-1. Therefore when A is less than\n\n            # or equal kC, the A's value is already used by kC.\n\n            if A < C or ((N-1) % C == 0 and A <= k*C):\n\n                break\n\n\n\n            point += S[A] + S[k*C]\n\n            ans = max(ans, point)\n\n\n\n    return ans\n\n\n\n\n\nif __name__ == '__main__':\n\n    print((main()))\n", "score": 0.0, "codebleu": 0.23672970979548819, "crystalbleu": 0.1707412858437947, "codebertscore": 0.72, "codescore": 0.019725240767002106, "surfaceSim": 0.6443044906900328, "abs_surfaceSim_minus_score": 0.6443044906900328}
{"golden_code": "def main():\n\n    S = eval(input())\n\n    w1 = 'dream'[::-1]\n\n    w2 = 'dreamer'[::-1]\n\n    w3 = 'erase'[::-1]\n\n    w4 = 'eraser'[::-1]\n\n    # print(w1,w2,w3,w4)\n\n    S = S[::-1]\n\n    # print(S)\n\n\n\n    # words = ['dream', 'dreamer', 'erase', 'eraser']\n\n    words = [w1, w2, w3, w4]\n\n    T = ''\n\n    while S != T:\n\n        cand = []\n\n        for w in words:\n\n            new_t = T + w\n\n            cand.append(new_t) \n\n        # print('cand', cand)\n\n        ans = False\n\n        for c in cand:\n\n            if c == S[:len(c)]:\n\n                T = c\n\n                ans = True\n\n\n\n        if not ans:\n\n            break\n\n\n\n    if S == T:\n\n        print('YES')\n\n    else:\n\n        print(\"NO\")\n\n\n\nif __name__ == \"__main__\":\n\n    main()", "generated_code": "def main():\n\n    mod = 998244353\n\n    s, k = input().split()\n\n    k, n, one, cnt, z, zero_list = int(k), len(s), s.count(\"1\")+1, 0, 0, []\n\n    for i in range(n):\n\n        if s[i] == \"0\":\n\n            zero_list.append(cnt)\n\n            cnt = 0\n\n        else:\n\n            cnt += 1\n\n    mm = min(one-1, k)\n\n\n\n    dp = [[0]*(mm+1) for _ in [0]*one]\n\n    dp[0][0] = 1\n\n\n\n    for i in zero_list:\n\n        dp2 = [[0]*(mm+1) for _ in [0]*one]\n\n        for j in range(one):\n\n            for l in range(max(z+i-j, 0), one-j):\n\n                ml = max(l-i, 0)\n\n                for p in range(min(j, mm-ml)+1):\n\n                    dp2[j+l][p+ml] = (dp2[j+l][p+ml]+dp[j][p]) % mod\n\n        z += i\n\n        dp = dp2\n\n    print((sum([sum(i) for i in dp]) % mod))\n\n\n\n\n\nmain()", "score": 0.0, "codebleu": 0.1571790404571173, "crystalbleu": 0.03659523982787592, "codebertscore": 0.68, "codescore": 0.9938865303993225, "surfaceSim": 0.5346611085379034, "abs_surfaceSim_minus_score": 0.5346611085379034}
{"golden_code": "import numpy as np \n\nn = int(eval(input()))\n\nx = list(map(int, input().split()))\n\nx = np.array(x)\n\nans = float('inf')\n\nidx = 200\n\nfor i in range(100):\n\n  y = x \n\n  ans = min(ans, np.sum((y-i)**2))\n\n  \n\nprint(ans)", "generated_code": "n, m = list(map(int, input().split()))\n\na = [int(x) for x in input().split()]\n\n\n\naa = [0]*(10**5+1)\n\naa_sum = [0]*(10**5+1)\n\n\n\nfor x in a:\n\n    aa[x] += 1\n\n    aa_sum[x] += x\n\n\n\nfor i in range(10**5)[::-1]:\n\n    aa[i] = aa[i] + aa[i+1]\n\n    aa_sum[i] = aa_sum[i] + aa_sum[i+1]\n\n\n\n\n\ndef count(x):\n\n    cnt = 0\n\n    sm = 0\n\n    for i in range(n):\n\n        if x-a[i] < 0:\n\n            cnt += n\n\n            sm += aa_sum[0]+n*a[i]\n\n        elif x-a[i] > 10**5:\n\n            continue\n\n        else:\n\n            cnt += aa[x-a[i]]\n\n            sm += aa_sum[x-a[i]]+aa[x-a[i]]*a[i]\n\n\n\n    return cnt, sm\n\n\n\n\n\nbottom = 0\n\ntop = 10**6\n\n\n\nwhile top - bottom > 1:\n\n    mid = (top+bottom) // 2\n\n    cnt, sm = count(mid)\n\n    if cnt < m:\n\n        top = mid\n\n    else:\n\n        bottom = mid\n\n\n\ncnt, sm = count(bottom)\n\nans = sm - (cnt-m)*bottom\n\n\n\nprint(ans)\n", "score": 0.0, "codebleu": 0.2331913380406894, "crystalbleu": 0.09347451236359669, "codebertscore": 0.71, "codescore": 0.9911288022994995, "surfaceSim": 0.4018218623481782, "abs_surfaceSim_minus_score": 0.4018218623481782}
{"golden_code": "s = eval(input())\n\nlen_s = len(s)\n\ncnt = [0, 0]\n\nfor i in range(1, len(s)):\n\n    memo_0 = s[i - 1]\n\n    memo_1 = s[len_s - i]\n\n    if s[i] != memo_0:\n\n        cnt[0] += 1\n\n    if s[len_s - i - 1] != memo_1:\n\n        cnt[1] += 1\n\nprint((min(cnt)))\n", "generated_code": "import sys\n\ndef input(): return sys.stdin.readline().rstrip()\n\ndef main():\n\n    x=int(eval(input()))\n\n    for a in range(-118,120):\n\n        for diff in range(238):\n\n            if a**5-(a-diff)**5>10**9:\n\n                break\n\n            if a**5-(a-diff)**5==x:\n\n                print((a,a-diff))\n\n                sys.exit()\n\n\n\nif __name__=='__main__':\n\n    main()", "score": 0.0, "codebleu": 0.10593023869593682, "crystalbleu": 0.040319994812872274, "codebertscore": 0.68, "codescore": 0.01856466569006443, "surfaceSim": 0.4347326294277929, "abs_surfaceSim_minus_score": 0.4347326294277929}
{"golden_code": "N = int(eval(input()))\n\na = [int(eval(input())) for i in range(N)]\n\nnow = a[0]\n\ncount = 1\n\nc = 0\n\nfor i in range(10**6):\n\n    if now != 2:\n\n        count += 1\n\n        now = a[now - 1]\n\n    else:\n\n        print(count)\n\n        c = 1\n\n        break\n\nif c == 0:\n\n    print((-1))\n", "generated_code": "n,a=open(0);a=a.split();print((*sorted(list(range(1,int(n)+1)),key=lambda x:int(a[x-1]))))", "score": 0.0, "codebleu": 0.08448275862068966, "crystalbleu": 0.0, "codebertscore": 0.72, "codescore": 0.16505782306194305, "surfaceSim": 0.4486123646209386, "abs_surfaceSim_minus_score": 0.4486123646209386}
{"golden_code": "N, D = list(map(int, input().split()))\n\ncnt = 0\n\nfor _ in range(N):\n\n    x, y = list(map(int, input().split()))\n\n    if x ** 2 + y ** 2 <= D ** 2:\n\n        cnt += 1\n\n        \n\nprint(cnt)", "generated_code": "#!/usr/bin/env python3\n\n\n\nn = int(eval(input()))\n\ns = [eval(input()) for _ in range(n)]\n\nd = {}\n\n\n\nfor c in s:\n\n    if c[0] not in d:\n\n        d[c[0]] = 1 \n\n    else:\n\n        d[c[0]] += 1\n\n\n\ntmp = d.copy()\n\nt = ['M', 'A', 'R', 'C', 'H']\n\nfor c in tmp:\n\n    if c not in t:\n\n        d.pop(c)\n\n\n\nans = 0 \n\ndlist = list(d.items())\n\nfor i in range(len(dlist)):\n\n    for j in range(i+1, len(dlist)):\n\n        for k in range(j+1, len(dlist)):\n\n            ans += dlist[i][1]*dlist[j][1]*dlist[k][1]\n\nprint(ans)\n", "score": 0.0, "codebleu": 0.23049160290833298, "crystalbleu": 0.030186317137713053, "codebertscore": 0.7, "codescore": 0.9369089007377625, "surfaceSim": 0.5211348057882711, "abs_surfaceSim_minus_score": 0.5211348057882711}
{"golden_code": "def main():\n\n    mod = 998244353\n\n    s, k = input().split()\n\n    k = int(k)\n\n    n = len(s)\n\n\n\n    one = s.count(\"1\")\n\n\n\n    cnt = 0\n\n    zero_list = []\n\n    for i in range(n):\n\n        if s[i] == \"0\":\n\n            zero_list.append(cnt)\n\n            cnt = 0\n\n        else:\n\n            cnt += 1\n\n\n\n    z = 0\n\n    mm = min(one, k)\n\n\n\n    dp = [[0]*(one+1) for _ in [0]*(one+1)]\n\n    dp[0][0] = 1\n\n\n\n    for i in range(len(zero_list)):\n\n        dp2 = [[0]*(mm+1) for _ in [0]*(one+1)]\n\n        base = zero_list[i]\n\n        # j:何個今までに入れたか\n\n        for j in range(one+1):\n\n            # l:何個入れるか\n\n            for l in range(one+1-j):\n\n                if l < z+base-j:\n\n                    continue\n\n                ml = max(l-base, 0)\n\n                # p:これまでのペナルティ\n\n                for p in range(min(one, k)+1):\n\n                    q = p+ml\n\n                    if q <= mm:\n\n                        dp2[j+l][q] = (dp2[j+l][q]+dp[j][p]) % mod\n\n                    else:\n\n                        break\n\n        z += base\n\n        dp = dp2\n\n    print((sum([sum(i) for i in dp]) % mod))\n\n\n\n\n\nmain()", "generated_code": "from statistics import median_low\n\n\n\nN = int(eval(input()))\n\nA = list(map(int, input().split()))\n\n\n\nD = []\n\nfor i in range(N):\n\n    D.append(A[i] - (i+1))\n\n\n\nm = median_low(D)\n\nans = 0\n\nfor d in D:\n\n    ans += abs(d - m)\n\n\n\nprint(ans)\n", "score": 0.0, "codebleu": 0.11866845156591349, "crystalbleu": 0.013688519952953025, "codebertscore": 0.69, "codescore": 0.9298348426818848, "surfaceSim": 0.5552926525529265, "abs_surfaceSim_minus_score": 0.5552926525529265}
{"golden_code": "N,L = list(map(int, input().split()))\n\ntaste = [L+i-1 for i in range(1,N+1)]\n\nif taste[-1] < 0:\n\n  print((sum(taste) + min([abs(x) for x in taste])))\n\nelse:\n\n  print((sum(taste) - min([abs(x) for x in taste])))", "generated_code": "N=int(eval(input()))\n\n\n\nA=[[-1]*N for _ in range(N)]\n\nfor i in range(N):\n\n  a=int(eval(input()))\n\n  for j in range(a):\n\n    x,y=list(map(int, input().split()))\n\n    A[i][x-1]=y\n\n#正直者が正直者に不親切と言われていない\n\n#→正直ものが不親切を正直者と言っていないか\n\nans=0\n\nfor i in range(2**N):\n\n  ok=True\n\n  for j in range(N):\n\n    if (i>>j&1)==1:\n\n      for k in range(N):\n\n        if A[j][k]!=-1 and (i>>k&1)!=A[j][k]:\n\n          ok=False\n\n  if ok:\n\n    ans=max(ans, bin(i).count(\"1\"))\n\n  \n\nprint(ans)", "score": 0.0, "codebleu": 0.22787916698819177, "crystalbleu": 0.11031537932584937, "codebertscore": 0.72, "codescore": 0.9889573454856873, "surfaceSim": 0.5484307359307359, "abs_surfaceSim_minus_score": 0.5484307359307359}
{"golden_code": "class prime_factorize_by_osa_k():\n\n    def __init__(self, max_val):\n\n        '''\n\n        割ることが出来る最小の値を格納したリストを返す\n\n        :param max_val:\n\n        :return:\n\n        '''\n\n        self.minFactor = [-1] * (max_val + 1)\n\n        for i in range(2, max_val + 1):\n\n            if self.minFactor[i] == -1:\n\n                self.minFactor[i] = i\n\n                # エラトステネスの篩と同様の処理を行う\n\n                for j in range(i * i, max_val + 1, i):\n\n                    if self.minFactor[j] == -1:\n\n                        self.minFactor[j] = i\n\n\n\n    def osa_k(self, n):\n\n        '''\n\n        preprocessをしたあと、O(logN)で素因数分解を行う。nの最大値をn_maxとする。\n\n        :param n:\n\n        :return:\n\n        '''\n\n        from collections import defaultdict\n\n        d = defaultdict(int)\n\n        now = n\n\n        while now > 1:\n\n            d[self.minFactor[now]] += 1\n\n            now //= self.minFactor[now]\n\n        return d\n\ndef gcd(a, b):\n\n    while b: a, b = b, a % b\n\n    return a\n\n\n\nN = int(eval(input()))\n\nA = list(map(int, input().split()))\n\n# N = 10 ** 6\n\n# A = [10 ** 6] * N\n\nob = prime_factorize_by_osa_k(10 ** 6)\n\npairwise = False\n\nprime_key = set(ob.osa_k(A[-1]).keys())\n\nbreak_flag = False\n\nprime_flags = [False] * (10 ** 6 + 1)\n\nfor i in range(N):\n\n    for key in list(ob.osa_k(A[i]).keys()):\n\n        if prime_flags[key]:\n\n            break_flag = True\n\n            break\n\n        else:\n\n            prime_flags[key] = True\n\n    if break_flag:\n\n        break\n\nelse:\n\n    pairwise = True\n\nif pairwise:\n\n    print('pairwise coprime')\n\n    exit()\n\nwork = gcd(A[0], A[1])\n\nfor i in range(2, N):\n\n    work = gcd(work, A[i])\n\nif work != 1:\n\n    print('not coprime')\n\nelse:\n\n    print('setwise coprime')", "generated_code": "n=int(eval(input()))\n\nans=1\n\nfor i in range(n):\n\n    ans=(ans*(i+1))%(10**9+7)\n\nprint(ans)", "score": 0.0, "codebleu": 0.05381957905057754, "crystalbleu": 0.0003729488142612993, "codebertscore": 0.63, "codescore": 0.05000412464141846, "surfaceSim": 0.3867458042070676, "abs_surfaceSim_minus_score": 0.3867458042070676}
{"golden_code": "n = int(eval(input()))\n\nimport math\n\nm = int(math.sqrt(n))+1\n\nanss = []\n\nfor x in range(1, m+1):\n\n  y = n//x\n\n  z = n%x\n\n  if z == 0:\n\n    anss.append(abs(x-1)+abs(y-1))\n\nprint((min(anss)))\n", "generated_code": "from itertools import combinations\n\n \n\nn = int(eval(input()))\n\nr = list(range(n))\n\na = [(set(), set()) for _ in r]\n\nfor i in r:\n\n  for _ in range(int(eval(input()))):\n\n    x, y = list(map(int, input().split()))\n\n    a[i][y].add(x - 1)\n\n \n\nfail = lambda x: not all(a[i][0].isdisjoint(x) and a[i][1] < x for i in x)\n\n \n\nwhile all(map(fail, list(map(set, combinations(r, n))))):\n\n  n -= 1\n\nprint(n)", "score": 0.0, "codebleu": 0.25343514718559806, "crystalbleu": 0.08416443710869823, "codebertscore": 0.75, "codescore": 0.8946942090988159, "surfaceSim": 0.37661558960692876, "abs_surfaceSim_minus_score": 0.37661558960692876}
{"golden_code": "N=int(eval(input()))\n\nd=list(map(int, input().split()))\n\n\n\nimport numpy as np\n\nd = np.array(d)\n\n\n\nprint(( ( (np.sum(d))**2 - np.sum(d**2) ) // 2 ))\n", "generated_code": "n,l=list(map(int,input().split()))\n\na=0\n\nfor i in range(n):\n\n  a+=i+l\n\nif l>=0:\n\n  print((a-l))\n\nelif l+n-1<0:\n\n  print((a-(l+n-1)))\n\nelse:\n\n  print(a)", "score": 0.0, "codebleu": 0.1691017316017316, "crystalbleu": 0.0, "codebertscore": 0.74, "codescore": 0.06112673878669739, "surfaceSim": 0.42456089835876765, "abs_surfaceSim_minus_score": 0.42456089835876765}
{"golden_code": "a, b, c = sorted(map(int, input().split()))\n\n\n\nprint((c*10 + b + a))", "generated_code": "s = eval(input())\n\n\n\nstart = 0\n\nfor i in range(len(s)):\n\n    if s[i] == 'A':\n\n        start = i\n\n        break\n\n\n\nend = 0\n\nfor i in reversed(list(range(len(s)))):\n\n    if s[i] == 'Z':\n\n        end = i\n\n        break\n\nprint((end - start + 1))\n", "score": 0.0, "codebleu": 0.1809170037225159, "crystalbleu": 0.0, "codebertscore": 0.69, "codescore": 0.022131051868200302, "surfaceSim": 0.4674340810704447, "abs_surfaceSim_minus_score": 0.4674340810704447}
{"golden_code": "import numpy as np\n\n\n\na = [list(map(int, input().split())) for _ in range(3)]\n\na = np.array(a)\n\nn = int(eval(input()))\n\n\n\nfor _ in range(n):\n\n    b = int(eval(input()))\n\n    \n\n    for j in range(3):\n\n        for i in range(3):\n\n            if a[j][i] == b:\n\n                a[j][i] = 0\n\n\n\nat = a.transpose()\n\nflag = False\n\nfor i in range(3):\n\n    if sum(a[:][i]) == 0 or sum(at[:][i]) == 0:\n\n        flag = True\n\n        break\n\ndiag = a[0][0] + a[1][1] + a[2][2]\n\ndiag2 = a[2][0] + a[1][1] + a[0][2]\n\nif diag == 0 or diag2 == 0:\n\n    flag = True\n\n\n\nprint((\"Yes\" if flag else \"No\"))", "generated_code": "import sys\n\nimport numpy as np\n\nfrom numba import njit\n\n\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\n@njit('(i4[::1],i4,i8[::1])', cache=True)\n\ndef main(A, B, C):\n\n    counts = np.zeros(1 << 18, np.int32)\n\n    popcount = np.zeros(1 << B, np.int32)\n\n    for i in range(B):\n\n        popcount[1 << i:1 << i + 1] = popcount[:1 << i] + 1\n\n\n\n    answer = 0\n\n    for i in range(1 << B):\n\n        k = popcount[i]\n\n        t = 0\n\n        for x in A & i:\n\n            n = counts[x]\n\n            counts[x] += 1\n\n            t -= C[n]\n\n            t += C[n + 1]\n\n        for x in A & i:\n\n            counts[x] = 0\n\n        if k & 1:\n\n            t = -t\n\n        answer += t\n\n    return answer\n\n  \n\nif sys.argv[-1] == 'ONLINE_JUDGE':\n\n    from numba.pycc import CC\n\n    cc = CC('my_module')\n\n    cc.export('main', '(i4[::1],i4,i8[::1])')(main)\n\n    cc.compile()\n\n    exit()\n\nfrom my_module import main\n\n\n\nN, K, S, T = list(map(int, readline().split()))\n\nA = np.array(readline().split(), np.int32)\n\n\n\ndef convert_problem(S, T, A):\n\n    ng = np.zeros(len(A), np.bool)\n\n    B = np.zeros_like(A)\n\n    n = 0\n\n    for i in range(18):\n\n        s, t = (S >> i) & 1, (T >> i) & 1\n\n        if (s, t) == (0, 0):\n\n            ng |= ((A >> i) & 1) == 1\n\n        elif (s, t) == (1, 1):\n\n            ng |= ((A >> i) & 1) == 0\n\n        elif (s, t) == (1, 0):\n\n            print((0))\n\n            exit()\n\n        else:\n\n            B += ((A >> i) & 1) << n\n\n            n += 1\n\n    return B[~ng], n\n\n\n\nA, B = convert_problem(S, T, A)\n\n\n\nC = np.zeros((100, 100), np.int64)\n\nC[0, 0] = 1\n\nfor n in range(1, 100):\n\n    C[n, :-1] += C[n - 1, :-1]\n\n    C[n, 1:] += C[n - 1, :-1]\n\nC = C[:, 1:K + 1].sum(axis=1)\n\n\n\nprint((main(A, B, C)))", "score": 0.0, "codebleu": 0.19279836669586703, "crystalbleu": 0.05120984412916742, "codebertscore": 0.73, "codescore": 0.9917663931846619, "surfaceSim": 0.45990808290974217, "abs_surfaceSim_minus_score": 0.45990808290974217}
{"golden_code": "import sys\n\nstdin = sys.stdin\n\n \n\nsys.setrecursionlimit(10**8) \n\n \n\ndef li(): return list(map(int, stdin.readline().split()))\n\ndef li_(): return [int(x)-1 for x in stdin.readline().split()]\n\ndef lf(): return list(map(float, stdin.readline().split()))\n\ndef ls(): return stdin.readline().split()\n\ndef ns(): return stdin.readline().rstrip()\n\ndef lc(): return list(ns())\n\ndef ni(): return int(stdin.readline())\n\ndef nf(): return float(stdin.readline())\n\n\n\n\n\nn = ni()\n\na = [ni() for _ in range(n)]\n\n\n\ncnt = {i+1: ai for i, ai in enumerate(a)}\n\n\n\nprev = -100\n\ncur = 0\n\nans = 0\n\nfor key in sorted(cnt.keys()):\n\n    if cnt[key] == 0:\n\n        continue\n\n    \n\n    if prev == -100:\n\n        prev = key\n\n    \n\n    if (key-prev) < 2:\n\n        cur += cnt[key]\n\n    else:\n\n        cur = cnt[key]\n\n        \n\n    ans += cur // 2\n\n    cur -= 2 * (cur//2)\n\n    \n\n    prev = key\n\n        \n\nprint(ans)", "generated_code": "# https://atcoder.jp/contests/abc129/tasks/abc129_c\n\n# 典型的なDP\n\n\n\nMOD = 10**9 + 7\n\nimport numpy as np\n\n# dp[i]をi段目までの通りの数とする。\n\nN, M = list(map(int, input().split()))\n\nto_zero = np.full((N + 1), False).tolist()\n\nfor _ in range(M):\n\n    to_zero[int(eval(input()))] = True  # 床が抜けているところ\n\n\n\n# dpテーブルの用意\n\ndp = np.full((N + 1), -1).tolist()\n\ndp[0] = 1\n\ndp[1] = 0 if to_zero[1] else 1\n\nfor i in range(2, N + 1):\n\n    dp[i] = 0 if to_zero[i] else dp[i - 2] + dp[i - 1]\n\n    if dp[i] > MOD:\n\n        dp[i] %= MOD\n\n\n\nprint((dp[-1]))\n", "score": 0.0, "codebleu": 0.142750823714411, "crystalbleu": 0.06545281464140762, "codebertscore": 0.68, "codescore": 0.0986342802643776, "surfaceSim": 0.524075512276719, "abs_surfaceSim_minus_score": 0.524075512276719}
{"golden_code": "def factorial(N):\n\n    power_r = 1\n\n    for n in range(2,N+1):\n\n        power_r *= n\n\n        power_r %= 10**9+7\n\n    return power_r\n\n\n\nif __name__ == '__main__':\n\n    N = int(eval(input()))\n\n    print((factorial(N)))", "generated_code": "class Queue:\n\n    def __init__(self,l):\n\n        self.values = []\n\n        self.l = l\n\n        for _ in range(l):\n\n            self.values.append(None)\n\n        self.head = 0\n\n        self.tail = 0\n\n    def inc(self,n):\n\n        if n+1 >= self.l:\n\n            return 0\n\n        else:\n\n            return n+1\n\n    def enqueue(self,v):\n\n        if self.inc(self.head) == self.tail:\n\n            print('overflow')\n\n            exit()\n\n        self.values[self.head] = v\n\n        self.head = self.inc(self.head)\n\n    def dequeue(self):\n\n        if self.head == self.tail:\n\n            print('underflow')\n\n            exit()\n\n        v = self.values[self.tail]\n\n        self.tail = self.inc(self.tail)\n\n        return v\n\n    def size(self):\n\n        if self.head >= self.tail:\n\n            return self.head-self.tail\n\n        else:\n\n            self.head + (self.l-self.tail)\n\n\n\nn,q = list(map(int,input().split(' ')))\n\nqueue = Queue(200000)\n\nfor _ in range(n):\n\n    n,t = input().split(' ')\n\n    t = int(t)\n\n    queue.enqueue((n,t))\n\n\n\nc = 0\n\nwhile queue.size()>0:\n\n    n,t = queue.dequeue()\n\n    if t <= q:\n\n        c += t\n\n        print(n,c)\n\n    else:\n\n        queue.enqueue((n,t-q))\n\n        c += q", "score": 0.0, "codebleu": 0.21275924807212032, "crystalbleu": 0.011023208672800374, "codebertscore": 0.64, "codescore": 0.09799376130104065, "surfaceSim": 0.504072443972277, "abs_surfaceSim_minus_score": 0.504072443972277}
{"golden_code": "import sys\n\nfrom collections import Counter, deque, defaultdict\n\nfrom itertools import accumulate, permutations, combinations, takewhile, compress, cycle\n\nfrom functools import reduce\n\nfrom math import ceil, floor, log10, log2, factorial\n\nfrom pprint import pprint\n\n\n\nsys.setrecursionlimit(1000000)\n\n# MOD = 10 ** 9 + 7\n\n# N = int(input())\n\n# A = [int(x) for x in input().split()]\n\n# V = [[0] * 100 for _ in range(100)]\n\n# A = [int(input()) for _ in range(N)]\n\n\n\nN, W = [int(x) for x in input().split()]\n\n\n\ndp = [float('inf')] * 1000 * 100*10\n\nvs = set()\n\nvs.add(0)\n\ndp[0] = 0\n\n\n\nfor i in range(N):\n\n    w, v = [int(x) for x in input().split()]\n\n\n\n    tmpDP = dp.copy()\n\n    for vv in list(vs):\n\n        if dp[vv + v] > dp[vv] + w:\n\n            tmpDP[vv + v] = dp[vv] + w\n\n            vs.add(vv + v)\n\n    dp = tmpDP\n\n\n\n\n\nans = 0\n\nfor v in list(vs):\n\n    if dp[v] <= W:\n\n        ans = max(ans, v)\n\nprint(ans)\n", "generated_code": "S = eval(input())\n\nl = len(S)\n\nd = set()\n\nK = int(eval(input()))\n\nfor i in range(5):\n\n    for j in range(l-i):\n\n        d.add(S[j:j+i+1])\n\nD = sorted(list(d))\n\nprint((D[K-1]))", "score": 0.0, "codebleu": 0.10977208685537743, "crystalbleu": 0.015670254472275727, "codebertscore": 0.68, "codescore": 0.18425233662128448, "surfaceSim": 0.4856828193832599, "abs_surfaceSim_minus_score": 0.4856828193832599}
{"golden_code": "import sys\n\ndef input(): return sys.stdin.readline().rstrip()\n\ndef main():\n\n    x=int(eval(input()))\n\n    for i in range(-300,300):\n\n        for j in range(-300,300):\n\n            if i**5-j**5==x:\n\n                print((i,j))\n\n                sys.exit()\n\n\n\nif __name__=='__main__':\n\n    main()", "generated_code": "#problem1\n\nfrom collections import deque\n\nd=deque()\n\ne=deque()\n\n\n\nN=int(eval(input()))\n\ngraph=[[] for i in range(N+1)]\n\nD=[]\n\nfor _ in range(N-1):\n\n    a,b=list(map(int,input().split()))\n\n    graph[a].append(b)\n\n    graph[b].append(a)\n\n    D.append((a,b))\n\n    \n\n#頂点1からスタート\n\nK=0\n\nd.append(1)\n\nvisited=[False for i in range(N+1)]\n\ncolor=[-1 for i in range(N+1)]\n\nvisited[1]=True\n\ncolor[1]=-1\n\ndic={}\n\nwhile d:\n\n    while d:\n\n        x=d.popleft()\n\n        par_color=color[x]\n\n        c=1\n\n        for node in graph[x]:\n\n            if visited[node]==False:\n\n                visited[node]=True\n\n                e.append(node)                \n\n                if c!=par_color:\n\n                    color[node]=c\n\n                    dic[(x,node)]=c\n\n                elif c==par_color:\n\n                    c+=1\n\n                    color[node]=c\n\n                    dic[(x,node)]=c\n\n                c+=1\n\n    if e:\n\n        d=e\n\n        e=deque()\n\n\n\nA=max(color)\n\nprint(A)\n\nfor que in D:\n\n    a,b=que\n\n    if (a,b) in list(dic.keys()):\n\n        print((dic[que]))\n\n    else:\n\n        print((dic[(b,a)]))\n\n    ", "score": 0.0, "codebleu": 0.2604761897895483, "crystalbleu": 0.049765713302584245, "codebertscore": 0.67, "codescore": 0.9345319271087646, "surfaceSim": 0.5057514567008238, "abs_surfaceSim_minus_score": 0.5057514567008238}
{"golden_code": "#!/usr/bin/env python3\n\ndef main():\n\n    import numpy as np\n\n\n\n    np.set_printoptions(linewidth=200)\n\n\n\n    N, W = list(map(int, input().split()))\n\n    lst = [list(map(int, input().split())) for _ in range(N)]\n\n    v_max = 10 ** 3 * 100 * 10\n\n    w_max = 10 ** 9 * v_max\n\n\n\n    # i以上の価値を持つときの最小重量\n\n    dp = np.full(v_max, w_max, dtype=np.int64)\n\n    # initialize\n\n    dp[0] = 0\n\n\n\n    for n in range(N):\n\n        w, v = lst[n]\n\n        dp[v:] = np.minimum(dp[v:], dp[:-v] + w)\n\n\n\n    ans = 0\n\n    for i, w in enumerate(dp):\n\n        if w <= W:\n\n            ans = i\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "generated_code": "for a in sorted(map(int,[*open(c:=0)][1].split())):c=a-c\n\nprint(c)", "score": 0.0, "codebleu": 0.07281999964882806, "crystalbleu": 0.0004751802277647555, "codebertscore": 0.6, "codescore": 0.03127152472734451, "surfaceSim": 0.42053856686444546, "abs_surfaceSim_minus_score": 0.42053856686444546}
{"golden_code": "mod = 2019\n\nl, r = list(map(int, input().split()))\n\n\n\nif r//mod - l//mod > 0:\n\n  print((0))\n\nelse:\n\n  l %= mod\n\n  r %= mod\n\n  ans = mod\n\n  for i in range(l+1, r+1):\n\n    for j in range(l, i):\n\n      ans = min(i*j%mod, ans)\n\n    if ans == 0:\n\n      break\n\n  print(ans)", "generated_code": "def factorial(N):\n\n    power_r = 1\n\n    for n in range(2,N+1):\n\n        power_r = power_r*n % (10**9+7)\n\n    return power_r\n\n\n\nif __name__ == '__main__':\n\n    N = int(eval(input()))\n\n    print((factorial(N)))", "score": 0.0, "codebleu": 0.1243716830450708, "crystalbleu": 0.0, "codebertscore": 0.73, "codescore": 0.02950291521847248, "surfaceSim": 0.48796147672552165, "abs_surfaceSim_minus_score": 0.48796147672552165}
{"golden_code": "S = eval(input())\n\nk = int(eval(input()))\n\nA = set()\n\nfor l in range(k+1):\n\n\tfor i in range(len(S)-l):\n\n\t\t\tA.add(S[i:i+l+1])\n\nA = sorted(list(A))\n\nprint((A[k-1]))", "generated_code": "import sys\n\nstdin = sys.stdin\n\n\n\nsys.setrecursionlimit(10 ** 7)\n\n\n\ndef li(): return list(map(int, stdin.readline().split()))\n\ndef li_(): return [int(x) - 1 for x in stdin.readline().split()]\n\ndef lf(): return list(map(float, stdin.readline().split()))\n\ndef ls(): return stdin.readline().split()\n\ndef ns(): return stdin.readline().rstrip()\n\ndef lc(): return list(ns())\n\ndef ni(): return int(stdin.readline())\n\ndef nf(): return float(stdin.readline())\n\n\n\nn = ni()\n\n\n\nans = 0\n\nplus = 0\n\na = [ni() for _ in range(n)]\n\n\n\nfor ai in a:\n\n    ans += ((ai+plus) // 2)\n\n    plus = (ai+plus) % 2 if ai > 0 else 0\n\n\n\nprint(ans)", "score": 0.0, "codebleu": 0.234990665483926, "crystalbleu": 0.025200794133643026, "codebertscore": 0.68, "codescore": 0.15519532561302185, "surfaceSim": 0.3689467969598263, "abs_surfaceSim_minus_score": 0.3689467969598263}
{"golden_code": "import sys\n\ninput = sys.stdin.readline\n\nimport numpy as np\n\nN = int(eval(input()))\n\ndp = np.zeros((N+1,3), dtype=np.int)\n\nX = list(map(int, input().split()))\n\nfor _ in range(3):\n\n  dp[1][_] = X[_]\n\nfor n in range(2,N+1):\n\n  X = list(map(int, input().split()))\n\n  dp[n][0] = max(dp[n-1][1],dp[n-1][2]) + X[0]\n\n  dp[n][1] = max(dp[n-1][2],dp[n-1][0]) + X[1]\n\n  dp[n][2] = max(dp[n-1][0],dp[n-1][1]) + X[2]\n\nprint((max(dp[N])))", "generated_code": "import sys\n\nfrom collections import deque\n\nMAX_INT = int(10e10)\n\nMIN_INT = -MAX_INT\n\nmod = 1000000007\n\nsys.setrecursionlimit(1000000)\n\ndef IL(): return list(map(int,input().split()))\n\ndef SL(): return input().split()\n\ndef I(): return int(sys.stdin.readline())\n\ndef S(): return eval(input())\n\n\n\nN,T = IL()\n\nab = [IL() for i in range(N)]\n\nab.sort()\n\n\n\nans = 0\n\ndp = [[0]*T for i in range(N+1)]\n\nfor i in range(1,N+1):\n\n  a,b = ab[i-1]\n\n  for j in range(T):\n\n    if 0 <= j-a < T:\n\n      dp[i][j] = max(dp[i-1][j], dp[i-1][j-a] + b)\n\n    else:\n\n      dp[i][j] = dp[i-1][j]\n\n  else:\n\n    ans = max(ans, dp[i-1][-1] + b)\n\nprint(ans)", "score": 0.0, "codebleu": 0.16822216681820737, "crystalbleu": 0.17190490534623556, "codebertscore": 0.8, "codescore": 0.12053182721138, "surfaceSim": 0.4899796688934069, "abs_surfaceSim_minus_score": 0.4899796688934069}
{"golden_code": "#python3\n\nINF = int(1e9)\n\ndef main():\n\n    a, b, c, x, y = list(map(int, input().split()))\n\n    ans = INF\n\n    for i in range(2*10**5+100):\n\n        t = 2*c*i + max(x-i, 0) * a + max(y-i, 0) * b\n\n        ans = min(ans, t)\n\n    print(ans)\n\nmain()", "generated_code": "N=int(eval(input()))\n\nd=list(map(int, input().split()))\n\n\n\ncumsum = 0\n\nfor n in range(N):\n\n    cumsum += d[n]\n\nsub_cumsum = 0\n\nans = 0\n\nfor n in range(N):\n\n    sub_cumsum += d[n]\n\n    ans += d[n] * (cumsum-sub_cumsum)\n\nprint(ans)\n", "score": 0.0, "codebleu": 0.16040756823042873, "crystalbleu": 0.2836071473526874, "codebertscore": 0.75, "codescore": 0.09449220448732376, "surfaceSim": 0.5884353741496599, "abs_surfaceSim_minus_score": 0.5884353741496599}
{"golden_code": "s = eval(input())\n\n\n\nstart = -1\n\nend = 0\n\nfor i in range(len(s)):\n\n    if s[i] == 'A' and start < 0:\n\n        start = i\n\n    elif s[i] == 'Z':\n\n        end = i\n\nprint((end - start + 1))\n", "generated_code": "from collections import deque\n\nK = int(eval(input()))\n\nG = [[] for i in range(K)]\n\nfor i in range(K):\n\n    G[i].append(((10 * i) % K, 0))\n\n    G[i].append(((i + 1) % K, 1))\n\n\n\ndist = [float('inf')] * K\n\ndist[1] = 1\n\nque = deque()\n\nque.append(1)\n\n\n\nwhile que:\n\n    n = que.pop()\n\n    for v, c in G[n]:\n\n        if dist[v] > dist[n] + c:\n\n            dist[v] = dist[n] + c\n\n            if c == 0:\n\n                que.append(v)\n\n            else:\n\n                que.appendleft(v)\n\n\n\nprint((dist[0]))\n", "score": 0.0, "codebleu": 0.1741162607254244, "crystalbleu": 0.06084112436965077, "codebertscore": 0.72, "codescore": 0.9294880032539368, "surfaceSim": 0.4844242424242424, "abs_surfaceSim_minus_score": 0.4844242424242424}
{"golden_code": "import numpy as np\n\n\n\nn,l=list(map(int,input().split()))\n\nli=[]\n\nfor i in range(n):\n\n  li.append(l+i)\n\ns=sum(li)\n\np=np.array(li)\n\na=np.abs(p).tolist()\n\nk=min(a)\n\nb=a.index(k)\n\nprint((s-li[b]))", "generated_code": "from statistics import median_low\n\n\n\nN = int(eval(input()))\n\nA = list(map(int, input().split()))\n\n\n\nD = []\n\nfor i in range(N):\n\n    D.append(A[i] - (i+1))\n\n\n\nm = median_low(D)\n\nans = 0\n\nfor d in D:\n\n    ans += abs(d - m)\n\n\n\nprint(ans)\n", "score": 0.0, "codebleu": 0.2521801844289476, "crystalbleu": 0.0, "codebertscore": 0.79, "codescore": 0.9433016777038574, "surfaceSim": 0.6405268490374874, "abs_surfaceSim_minus_score": 0.6405268490374874}
{"golden_code": "import sys\n\n\n\ndef main():\n\n    input = sys.stdin.readline\n\n    N = int(eval(input()))\n\n    S = list(map(int, input().split()))\n\n\n\n    ans = 0\n\n    for C in range(1, N//2):\n\n        n = N // C\n\n        point = 0\n\n        used = set([0])\n\n        for k in range(1, n):\n\n            A = N - 1 - k*C\n\n\n\n            if A in used or k*C in used or A == k*C:\n\n                break\n\n            used.add(A)\n\n            used.add(k*C)\n\n\n\n            point += S[A] + S[k*C]\n\n            ans = max(ans, point)\n\n\n\n    return ans\n\n\n\n\n\nif __name__ == '__main__':\n\n    print((main()))\n", "generated_code": "s = eval(input())\n\nlen_s = len(s)\n\ncnt = 0\n\nfor i in range(1, len(s)):\n\n    memo_0 = s[i - 1]\n\n    if s[i] != memo_0:\n\n        cnt += 1\n\nprint(cnt)\n", "score": 0.0, "codebleu": 0.0666525588145118, "crystalbleu": 0.01478998085391329, "codebertscore": 0.68, "codescore": 0.07303332537412643, "surfaceSim": 0.5353272767075307, "abs_surfaceSim_minus_score": 0.5353272767075307}
{"golden_code": "import bisect\n\n\n\nN, X = list(map(int, input().split()))\n\nl = list(map(int, input().split()))\n\nd = [-1]*(N+1) #0-index #バウンドする位置を格納するリスト\n\nd[0] = 0 #バウンドする初期値は0\n\n\n\nfor i in range(1, N+1):\n\n    d[i] = d[i-1] + l[i-1]\n\n\n\n#print(d)\n\n#print('left:', bisect.bisect_left(d, X))\n\n#print('right:', bisect.bisect_right(d, X))\n\nprint((bisect.bisect_right(d, X)))", "generated_code": "num = int(input())\n\nprint(int(num/3600), int((num%3600)/60), num%60, sep=\":\")\n", "score": 0.0, "codebleu": 0.08408545191101076, "crystalbleu": 0.0, "codebertscore": 0.62, "codescore": 0.027451734989881516, "surfaceSim": 0.4757142857142857, "abs_surfaceSim_minus_score": 0.4757142857142857}
{"golden_code": "import numpy as np\n\nN = int(eval(input()))\n\nV = np.array([int(i) for i in input().split(\" \")])\n\nC = np.array([int(i) for i in input().split(\" \")])\n\n\n\nvc = V-C\n\n\n\nval = 0\n\n\n\nfor i in range(N):\n\n    if vc[i]>0:\n\n        val+=vc[i]\n\nprint(val)", "generated_code": "#problem1\n\nfrom collections import deque\n\nd=deque()\n\ne=deque()\n\n\n\nN=int(eval(input()))\n\ngraph=[[] for i in range(N+1)]\n\nD=[]\n\nfor _ in range(N-1):\n\n    a,b=list(map(int,input().split()))\n\n    graph[a].append(b)\n\n    graph[b].append(a)\n\n    D.append((a,b))\n\n    \n\n#頂点1からスタート\n\nK=0\n\nd.append(1)\n\nvisited=[False for i in range(N+1)]\n\ncolor=[-1 for i in range(N+1)]\n\nvisited[1]=True\n\ncolor[1]=-1\n\ndic={}\n\nwhile d:\n\n    while d:\n\n        x=d.popleft()\n\n        par_color=color[x]\n\n        c=1\n\n        for node in graph[x]:\n\n            if visited[node]==False:\n\n                visited[node]=True\n\n                e.append(node)                \n\n                if c!=par_color:\n\n                    color[node]=c\n\n                    dic[(x,node)]=c\n\n                elif c==par_color:\n\n                    c+=1\n\n                    color[node]=c\n\n                    dic[(x,node)]=c\n\n                c+=1\n\n    if e:\n\n        d=e\n\n        e=deque()\n\n\n\nA=max(color)\n\nprint(A)\n\nfor que in D:\n\n    a,b=que\n\n    if (a,b) in list(dic.keys()):\n\n        print((dic[que]))\n\n    else:\n\n        print((dic[(b,a)]))\n\n    ", "score": 0.0, "codebleu": 0.2823532986217371, "crystalbleu": 0.05466495462686241, "codebertscore": 0.7, "codescore": 0.977603554725647, "surfaceSim": 0.5663734999178037, "abs_surfaceSim_minus_score": 0.5663734999178037}
{"golden_code": "a,b,c,d,e,f=[int(eval(input())) for _ in range(6)]\n\nprint((sum([a,b,c,d,max(e,f)])-min([a,b,c,d])))", "generated_code": "import sys\n\nstdin = sys.stdin\n\n\n\nsys.setrecursionlimit(10 ** 7)\n\n\n\ndef li(): return list(map(int, stdin.readline().split()))\n\ndef li_(): return [int(x) - 1 for x in stdin.readline().split()]\n\ndef lf(): return list(map(float, stdin.readline().split()))\n\ndef ls(): return stdin.readline().split()\n\ndef ns(): return stdin.readline().rstrip()\n\ndef lc(): return list(ns())\n\ndef ni(): return int(stdin.readline())\n\ndef nf(): return float(stdin.readline())\n\n\n\nn = ni()\n\n\n\nans = 0\n\nplus = 0\n\na = [ni() for _ in range(n)]\n\n\n\nfor ai in a:\n\n    ans += ((ai+plus) // 2)\n\n    plus = (ai+plus) % 2 if ai > 0 else 0\n\n\n\nprint(ans)", "score": 0.0, "codebleu": 0.23259160640321236, "crystalbleu": 0.04672524435352552, "codebertscore": 0.64, "codescore": 0.44839903712272644, "surfaceSim": 0.3363753790857015, "abs_surfaceSim_minus_score": 0.3363753790857015}
{"golden_code": "from numpy import*;_,a=open(0);print((*argsort(int32(a.split()))+1))", "generated_code": "import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\nfrom operator import itemgetter\n\n\n\nN,M = list(map(int,readline().split()))\n\nA = list(map(int,readline().split()))\n\nm = list(map(int,read().split()))\n\nBC = list(zip(m,m))\n\n\n\nBC.sort(key = itemgetter(1),reverse=True)\n\n\n\nBC.append((N,-1))\n\n\n\nchange = []\n\nfor b,c in BC:\n\n    change += [c] * b\n\n    if len(change) > N:\n\n        break\n\n\n\nA += change\n\nA.sort()\n\nanswer = sum(A[-N:])\n\nprint(answer)", "score": 0.0, "codebleu": 0.2647290533115692, "crystalbleu": 0.008186502007209627, "codebertscore": 0.64, "codescore": 0.974452793598175, "surfaceSim": 0.3661356456274787, "abs_surfaceSim_minus_score": 0.3661356456274787}
{"golden_code": "import sys\n\nsys.setrecursionlimit(10000000)\n\nimport heapq\n\nimport math\n\n \n\ndef main():\n\n    N, K = list(map(int, input().split()))\n\n    A = [int(c) for c in input().split()]\n\n    F = [int(c) for c in input().split()]\n\n    \n\n    A.sort()\n\n    F.sort(reverse=True)\n\n \n\n    num = 0\n\n    sum_ = []\n\n    for i in range(N):\n\n      sum_.append(A[i] * F[i])\n\n    left = 0\n\n    right = 10 ** 12\n\n    while(num < 90):\n\n        number = 0\n\n        mid = (left + right) // 2\n\n        # print(mid)\n\n        for i in range(len(A)):\n\n            if sum_[i] <= mid:\n\n                continue\n\n            else:\n\n                number += math.ceil((sum_[i] - mid) / F[i])\n\n            # print(number)\n\n        if number > K:\n\n            # 最大値をmidより小さくできない -> 最大値はもっとでかい\n\n            left = mid + 1\n\n        else:\n\n            right = mid\n\n        num += 1\n\n    print(mid)\n\n                \n\n        \n\n \n\n \n\n \n\nif __name__ == '__main__':\n\n    main()", "generated_code": "n=int(eval(input()))\n\nans=1\n\nfor i in range(n):\n\n    ans=(ans*(i+1))%(10**9+7)\n\nprint(ans)", "score": 0.0, "codebleu": 0.07979799212649892, "crystalbleu": 0.0032769581893958206, "codebertscore": 0.66, "codescore": 0.03727997839450836, "surfaceSim": 0.4357900377954532, "abs_surfaceSim_minus_score": 0.4357900377954532}
{"golden_code": "import sys\n\nreadline = sys.stdin.readline\n\nsys.setrecursionlimit(10**8)\n\nmod = 10**9+7\n\n#mod = 998244353\n\nINF = 10**18\n\neps = 10**-7\n\n\n\nm,n,k = list(map(int,readline().split()))\n\n\n\ndef comb(n, r, mod):\n\n    r = min(r, n-r)\n\n    mol = 1\n\n    deno = 1\n\n    for i in range(1, r+1):\n\n        mol = mol * (n-r+i) % mod\n\n        deno = deno * i % mod\n\n    ret = mol * pow(deno, mod-2, mod) % mod\n\n    return ret\n\n\n\ndef f1(x,y,a,b):\n\n    return (a+b-x-y)*(a-x+1)*(b-y+1)//2\n\n\n\ndef f2(x,a):\n\n    return (a-x)*(a-x+1)//2\n\n\n\nans = 0\n\n\n\nfor x in range(1,n+1):\n\n    for y in range(1,m+1):\n\n        a = n-x+1\n\n        b = m-y+1\n\n        c = m*(a*(a-1)+x*(x-1))\n\n        d = n*(b*(b-1)+y*(y-1))\n\n        ans += (c+d)//2\n\n        ans %= mod\n\n\n\nans = (ans * comb(m*n-2,k-2,mod))%mod\n\nans = ans*pow(2,mod-2,mod)%mod\n\n\n\nprint(ans)\n\n\n", "generated_code": "def main():\n\n    from sys import stdin\n\n    def input():\n\n        return stdin.readline().strip()\n\n\n\n    n, m = list(map(int, input().split()))\n\n    tree = [[] for _ in range(n)]\n\n    for _ in range(m):\n\n        i, j, k = list(map(int, input().split()))\n\n        i -= 1\n\n        j -= 1\n\n        tree[i].append((k, j))\n\n        tree[j].append((k, i))\n\n\n\n    # dijkstra\n\n    import heapq\n\n\n\n    ans = 0\n\n    for i in range(n):\n\n        for j in tree[i]:\n\n            seen = [0] * n\n\n            goal = j[1]\n\n            base = j[0]\n\n            seen[i] = 1\n\n            todo = []\n\n            heapq.heapify(todo)\n\n            for k in tree[i]:\n\n                if k[0] < base and k != j:\n\n                    heapq.heappush(todo, k)\n\n            while len(todo) > 0:\n\n                k = heapq.heappop(todo)\n\n                if k[1] == goal:\n\n                    if k[0] < base:\n\n                        ans += 1\n\n                    break\n\n                seen[k[1]] = 1\n\n                for l in tree[k[1]]:\n\n                    if seen[l[1]] == 0 and k[0] + l[0] < base:\n\n                        heapq.heappush(todo, (k[0] + l[0], l[1]))\n\n\n\n    print((ans // 2))\n\n\n\nmain()", "score": 0.0, "codebleu": 0.1500581564476856, "crystalbleu": 0.09376594999335144, "codebertscore": 0.71, "codescore": 0.3435254991054535, "surfaceSim": 0.5375701342215349, "abs_surfaceSim_minus_score": 0.5375701342215349}
{"golden_code": "import math\n\n\n\nN = int(eval(input()))\n\n\n\npower = math.factorial(N)\n\n\n\nprint((power % 1000000007))\n\n\n", "generated_code": "import sys\n\nstdin = sys.stdin\n\n\n\nsys.setrecursionlimit(10 ** 7)\n\n\n\ndef li(): return list(map(int, stdin.readline().split()))\n\ndef li_(): return [int(x) - 1 for x in stdin.readline().split()]\n\ndef lf(): return list(map(float, stdin.readline().split()))\n\ndef ls(): return stdin.readline().split()\n\ndef ns(): return stdin.readline().rstrip()\n\ndef lc(): return list(ns())\n\ndef ni(): return int(stdin.readline())\n\ndef nf(): return float(stdin.readline())\n\n\n\nn = ni()\n\n\n\nans = 0\n\nplus = 0\n\na = [ni() for _ in range(n)]\n\n\n\nfor ai in a:\n\n    ans += ((ai+plus) // 2)\n\n    plus = (ai+plus) % 2 if ai > 0 else 0\n\n\n\nprint(ans)", "score": 0.0, "codebleu": 0.30332538136945614, "crystalbleu": 0.015394516389231406, "codebertscore": 0.64, "codescore": 0.9245554208755493, "surfaceSim": 0.3702195681023043, "abs_surfaceSim_minus_score": 0.3702195681023043}
{"golden_code": "#ABC 130 B\n\nN,X=list(map(int,input().split()))\n\nL= [int(j) for j in input().split()]\n\ncnt=0\n\nimport numpy as np\n\njump = list(np.cumsum(L))\n\nfor j in jump:\n\n    if j <= X:\n\n        cnt+=1\n\n    else:\n\n        break\n\nprint((cnt+1))", "generated_code": "num = int(input())\n\nprint(int(num/3600), int((num%3600)/60), num%60, sep=\":\")\n", "score": 0.0, "codebleu": 0.058683792837545455, "crystalbleu": 0.0, "codebertscore": 0.66, "codescore": 0.03253745660185814, "surfaceSim": 0.39710526315789474, "abs_surfaceSim_minus_score": 0.39710526315789474}
{"golden_code": "a,b=list(map(int,input().split()))\n\n\n\nans=0\n\n\n\nfor i in range(a,b+1):\n\n    buf=str(i)\n\n    #print(buf[0:int(len(buf)/2)],buf[int(len(buf)/2+1):])\n\n    str1=buf[0:int(len(buf)/2)]\n\n    str2=buf[int(len(buf)/2+1):]\n\n    if str1[0]==str2[1] and str1[1]==str2[0]:\n\n        ans+=1\n\n\n\nprint(ans)\n", "generated_code": "n = int(eval(input()))\n\n\n\nv_list = list(map(int,input().split()))\n\nc_list = list(map(int,input().split()))\n\n\n\ne_list = [v-c if (v-c > 0) else 0 for v,c in zip(v_list, c_list)]\n\n\n\nprint((sum(e_list)))\n", "score": 0.0, "codebleu": 0.139271578110859, "crystalbleu": 0.07674270609214423, "codebertscore": 0.73, "codescore": 0.5475661158561707, "surfaceSim": 0.4556650246305418, "abs_surfaceSim_minus_score": 0.4556650246305418}
{"golden_code": "n = int(eval(input()))\n\nmx = n//3\n\nans = 0\n\nmod = 10**9+7\n\nimport math\n\ndef combinations_count(n, r): #組み合わせ(nCr)\n\n    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\n\nfor i in range(1,mx+1):\n\n    if i == 1:\n\n        ans += 1\n\n    else:\n\n        ans += combinations_count(n-2*i-1,i-1) % mod\n\nprint((ans%mod))", "generated_code": "N = int(eval(input()))\n\na = [0] + [int(eval(input())) for _ in range(N)]\n\nx = 1\n\nvisited = set([1])\n\nanswer = 0\n\n\n\nwhile True:\n\n  x = a[x]\n\n  if x in visited:\n\n    answer = -1\n\n    break\n\n  visited.add(x)\n\n  answer += 1\n\n  if x == 2:\n\n    break\n\n    \n\nprint(answer)\n", "score": 0.0, "codebleu": 0.1648715670712848, "crystalbleu": 0.08313266219285691, "codebertscore": 0.73, "codescore": 0.9299938678741455, "surfaceSim": 0.4240882448713774, "abs_surfaceSim_minus_score": 0.4240882448713774}
{"golden_code": "a,b,c,x,y = list(map(int,input().split()))\n\nans = a*x + b*y\n\nfor i in range(max(x,y) + 1):\n\n\tmoney = max(0,(x-i)*a) + max(0,(y-i)*b) + 2*i*c\n\n\tif money <= ans:\n\n\t\tans = money\n\nprint(ans)", "generated_code": "import sys\n\nimport os\n\n\n\nii = lambda: int(sys.stdin.buffer.readline().rstrip())\n\nil = lambda: list(map(int, sys.stdin.buffer.readline().split()))\n\niln = lambda n: [int(sys.stdin.buffer.readline().rstrip()) for _ in range(n)]\n\n\n\niss = lambda: sys.stdin.buffer.readline().decode().rstrip()\n\nisn = lambda n: [sys.stdin.buffer.readline().decode().rstrip() for _ in range(n)]\n\n\n\n\n\ndef main():\n\n    if os.getenv(\"LOCAL\"):\n\n        sys.stdin = open(\"input.txt\", \"r\")\n\n\n\n    N = ii()\n\n    m = int(N ** .5)\n\n    while N % m != 0:\n\n        m -= 1\n\n    else:\n\n        print((int(N / m + m - 2)))\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 0.0, "codebleu": 0.13135201172557126, "crystalbleu": 0.08210068779100795, "codebertscore": 0.67, "codescore": 0.018323782831430435, "surfaceSim": 0.3901816254757431, "abs_surfaceSim_minus_score": 0.3901816254757431}
{"golden_code": "N, M = list(map(int, input().split()))\n\nLR = [list(map(int, input().split())) for _ in range(M)]\n\n\n\nleft = 1\n\nright = N\n\n\n\nfor l, r in LR:\n\n    if left < l:\n\n        left = l\n\n    if right > r:\n\n        right = r\n\n\n\nans = right - left\n\n\n\nprint((ans + 1 if ans >= 0 else 0))\n", "generated_code": "import sys\n\nimport numpy as np\n\nfrom numba import njit\n\n\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\n@njit('(i4[::1],i4,i8[::1])', cache=True)\n\ndef main(A, B, C):\n\n    counts = np.zeros(1 << 18, np.int32)\n\n    popcount = np.zeros(1 << B, np.int32)\n\n    for i in range(B):\n\n        popcount[1 << i:1 << i + 1] = popcount[:1 << i] + 1\n\n\n\n    answer = 0\n\n    for i in range(1 << B):\n\n        k = popcount[i]\n\n        t = 0\n\n        for x in A & i:\n\n            n = counts[x]\n\n            counts[x] += 1\n\n            t -= C[n]\n\n            t += C[n + 1]\n\n        for x in A & i:\n\n            counts[x] = 0\n\n        if k & 1:\n\n            t = -t\n\n        answer += t\n\n    return answer\n\n  \n\nif sys.argv[-1] == 'ONLINE_JUDGE':\n\n    from numba.pycc import CC\n\n    cc = CC('my_module')\n\n    cc.export('main', '(i4[::1],i4,i8[::1])')(main)\n\n    cc.compile()\n\n    exit()\n\nfrom my_module import main\n\n\n\nN, K, S, T = list(map(int, readline().split()))\n\nA = np.array(readline().split(), np.int32)\n\n\n\ndef convert_problem(S, T, A):\n\n    ng = np.zeros(len(A), np.bool)\n\n    B = np.zeros_like(A)\n\n    n = 0\n\n    for i in range(18):\n\n        s, t = (S >> i) & 1, (T >> i) & 1\n\n        if (s, t) == (0, 0):\n\n            ng |= ((A >> i) & 1) == 1\n\n        elif (s, t) == (1, 1):\n\n            ng |= ((A >> i) & 1) == 0\n\n        elif (s, t) == (1, 0):\n\n            print((0))\n\n            exit()\n\n        else:\n\n            B += ((A >> i) & 1) << n\n\n            n += 1\n\n    return B[~ng], n\n\n\n\nA, B = convert_problem(S, T, A)\n\n\n\nC = np.zeros((100, 100), np.int64)\n\nC[0, 0] = 1\n\nfor n in range(1, 100):\n\n    C[n, :-1] += C[n - 1, :-1]\n\n    C[n, 1:] += C[n - 1, :-1]\n\nC = C[:, 1:K + 1].sum(axis=1)\n\n\n\nprint((main(A, B, C)))", "score": 0.0, "codebleu": 0.28399909249071087, "crystalbleu": 0.039174964215858234, "codebertscore": 0.67, "codescore": 0.972666323184967, "surfaceSim": 0.39131264979325237, "abs_surfaceSim_minus_score": 0.39131264979325237}
{"golden_code": "import numpy as np\n\n\n\ntemp=list(map(int, input().split()))\n\n\n\nN=temp[0]\n\nX=temp[1]\n\n\n\nL=list(map(int, input().split()))\n\n\n\nind=1\n\nwhile np.sum(L[:ind])<=X and ind<=N:\n\n  ind+=1\n\n  \n\nprint(ind)", "generated_code": "INF = 10 ** 9\n\nimport sys\n\nsys.setrecursionlimit(100000000)\n\ndy = (-1,0,1,0)\n\ndx = (0,1,0,-1)\n\nfrom  heapq import heappop,heapify,heappush\n\nfrom bisect import bisect_left\n\n\n\ndef main():\n\n    s = eval(input())\n\n    for bit in range(8):\n\n        op = []\n\n        for i in range(3):\n\n            if (bit>>i)&1:\n\n                op.append('+')\n\n            else:\n\n                op.append('-')\n\n        \n\n        tmp = s[0]\n\n        for i in range(3):\n\n            tmp += op[i]\n\n            tmp += s[i + 1]\n\n\n\n        if eval(tmp) == 7:\n\n            ans = tmp + '=7'\n\n            break\n\n    print(ans)\n\nif __name__ == '__main__':\n\n    main()\n", "score": 0.0, "codebleu": 0.17163621206717664, "crystalbleu": 0.007059315196688294, "codebertscore": 0.63, "codescore": 0.018978063017129898, "surfaceSim": 0.47496087636932705, "abs_surfaceSim_minus_score": 0.47496087636932705}
{"golden_code": "import numpy as np\n\n\n\nn, m = list(map(int, input().split()))\n\na = [int(eval(input())) for _ in range(m)] + [0]\n\nmod = 10 ** 9 + 7\n\n\n\ndp = np.zeros(n + 1, dtype=np.int64)\n\ndp[0] = 1\n\nb = a[0]\n\nj = 1\n\nfor i in range(1, n + 1):\n\n    if i == b:\n\n        b = a[j]\n\n        j += 1\n\n    else:\n\n        tmp = dp[i - 2] + dp[i - 1]\n\n        if tmp >= mod:\n\n            tmp -= mod\n\n        dp[i] = tmp\n\nprint((int(dp[-1])))", "generated_code": "import math\n\nN = int(eval(input()))\n\na = 1\n\nfor n in range(2,N+1):\n\n    a = a*n % (10**9+7)\n\nprint(a)", "score": 0.0, "codebleu": 0.0991960166540789, "crystalbleu": 0.03228851106507667, "codebertscore": 0.75, "codescore": 0.6242474317550659, "surfaceSim": 0.46572336561743344, "abs_surfaceSim_minus_score": 0.46572336561743344}
{"golden_code": "a = int(eval(input()))\n\nh = int(a / 3600)\n\nm = int((a - h * 3600) / 60)\n\ns = int(a - h * 3600 - m * 60)\n\nprint((\":\" .join(map(str, [h, m, s]))))", "generated_code": "class Queue:\n\n    def __init__(self,l):\n\n        self.values = []\n\n        self.l = l\n\n        for _ in range(l):\n\n            self.values.append(None)\n\n        self.head = 0\n\n        self.tail = 0\n\n    def inc(self,n):\n\n        if n+1 >= self.l:\n\n            return 0\n\n        else:\n\n            return n+1\n\n    def enqueue(self,v):\n\n        if self.inc(self.head) == self.tail:\n\n            print('overflow')\n\n            exit()\n\n        self.values[self.head] = v\n\n        self.head = self.inc(self.head)\n\n    def dequeue(self):\n\n        if self.head == self.tail:\n\n            print('underflow')\n\n            exit()\n\n        v = self.values[self.tail]\n\n        self.tail = self.inc(self.tail)\n\n        return v\n\n    def size(self):\n\n        if self.head >= self.tail:\n\n            return self.head-self.tail\n\n        else:\n\n            self.head + (self.l-self.tail)\n\n\n\nn,q = list(map(int,input().split(' ')))\n\nqueue = Queue(200000)\n\nfor _ in range(n):\n\n    n,t = input().split(' ')\n\n    t = int(t)\n\n    queue.enqueue((n,t))\n\n\n\nc = 0\n\nwhile queue.size()>0:\n\n    n,t = queue.dequeue()\n\n    if t <= q:\n\n        c += t\n\n        print(n,c)\n\n    else:\n\n        queue.enqueue((n,t-q))\n\n        c += q", "score": 0.0, "codebleu": 0.1181556653723447, "crystalbleu": 0.006445222491592451, "codebertscore": 0.59, "codescore": 0.9837945103645325, "surfaceSim": 0.3940943238731219, "abs_surfaceSim_minus_score": 0.3940943238731219}
{"golden_code": "_,s=open(c:=0)\n\nfor a in sorted(map(int,s.split())):c=a-c\n\nprint(c)", "generated_code": "import sys\n\nimport numpy as np\n\nfrom numba import njit\n\n\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\n@njit('(i4[::1],i4,i8[::1])', cache=True)\n\ndef main(A, B, C):\n\n    counts = np.zeros(1 << 18, np.int32)\n\n    popcount = np.zeros(1 << B, np.int32)\n\n    for i in range(B):\n\n        popcount[1 << i:1 << i + 1] = popcount[:1 << i] + 1\n\n\n\n    answer = 0\n\n    for i in range(1 << B):\n\n        k = popcount[i]\n\n        t = 0\n\n        for x in A & i:\n\n            n = counts[x]\n\n            counts[x] += 1\n\n            t -= C[n]\n\n            t += C[n + 1]\n\n        for x in A & i:\n\n            counts[x] = 0\n\n        if k & 1:\n\n            t = -t\n\n        answer += t\n\n    return answer\n\n  \n\nif sys.argv[-1] == 'ONLINE_JUDGE':\n\n    from numba.pycc import CC\n\n    cc = CC('my_module')\n\n    cc.export('main', '(i4[::1],i4,i8[::1])')(main)\n\n    cc.compile()\n\n    exit()\n\nfrom my_module import main\n\n\n\nN, K, S, T = list(map(int, readline().split()))\n\nA = np.array(readline().split(), np.int32)\n\n\n\ndef convert_problem(S, T, A):\n\n    ng = np.zeros(len(A), np.bool)\n\n    B = np.zeros_like(A)\n\n    n = 0\n\n    for i in range(18):\n\n        s, t = (S >> i) & 1, (T >> i) & 1\n\n        if (s, t) == (0, 0):\n\n            ng |= ((A >> i) & 1) == 1\n\n        elif (s, t) == (1, 1):\n\n            ng |= ((A >> i) & 1) == 0\n\n        elif (s, t) == (1, 0):\n\n            print((0))\n\n            exit()\n\n        else:\n\n            B += ((A >> i) & 1) << n\n\n            n += 1\n\n    return B[~ng], n\n\n\n\nA, B = convert_problem(S, T, A)\n\n\n\nC = np.zeros((100, 100), np.int64)\n\nC[0, 0] = 1\n\nfor n in range(1, 100):\n\n    C[n, :-1] += C[n - 1, :-1]\n\n    C[n, 1:] += C[n - 1, :-1]\n\nC = C[:, 1:K + 1].sum(axis=1)\n\n\n\nprint((main(A, B, C)))", "score": 0.0, "codebleu": 0.22776204346141687, "crystalbleu": 0.01642499039013872, "codebertscore": 0.61, "codescore": 0.9933606386184692, "surfaceSim": 0.35706622161292245, "abs_surfaceSim_minus_score": 0.35706622161292245}
{"golden_code": "import numpy as np\n\nN = int(eval(input()))\n\n\n\nabc = np.array([list(map(int, input().split())) for i in range(N)])\n\n\n\ndp = [[0]*3 for i in range(N+1)]\n\n\n\nfor i in range(1, N+1):\n\n    dp[i][0] = max(dp[i - 1][1] + abc[i - 1][1], dp[i - 1][2] + abc[i - 1][2])\n\n    dp[i][1] = max(dp[i - 1][0] + abc[i - 1][0], dp[i - 1][2] + abc[i - 1][2])\n\n    dp[i][2] = max(dp[i - 1][1] + abc[i - 1][1], dp[i - 1][0] + abc[i - 1][0])\n\n\n\nprint((max(dp[-1])))\n", "generated_code": "n=int(eval(input()))\n\nans=1\n\nfor i in range(n):\n\n    ans=(ans*(i+1))%(10**9+7)\n\nprint(ans)", "score": 0.0, "codebleu": 0.08050193482293838, "crystalbleu": 0.004774095167493629, "codebertscore": 0.71, "codescore": 0.16792036592960358, "surfaceSim": 0.4202721088435374, "abs_surfaceSim_minus_score": 0.4202721088435374}
{"golden_code": "import numpy as np\n\nn,l = list(map(int,input().split()))\n\ntaste = np.array([l+i-1 for i in range(1,n+1)])\n\ntaste[np.fabs(taste).argmin()]=0\n\nprint((taste.sum()))", "generated_code": "INF = int(1e5)+5\n\n\n\ndef main():\n\n    a, b, c, x, y = list(map(int, input().split()))\n\n    ans = INF*INF\n\n    for i in range(INF):\n\n        tmp = 2*i*c + a*max(x-i, 0) + b*max(y-i, 0) \n\n        ans = min(tmp, ans)\n\n    print(ans)\n\nmain()\n", "score": 0.0, "codebleu": 0.1863341954160211, "crystalbleu": 0.0, "codebertscore": 0.74, "codescore": 0.9654086828231812, "surfaceSim": 0.5526508897450009, "abs_surfaceSim_minus_score": 0.5526508897450009}
{"golden_code": "from math import factorial\n\n\n\ns = int(eval(input()))\n\nmod = pow(10, 9) + 7\n\n\n\n\n\ndef nCr(n, r):\n\n    return int(factorial(n) // factorial(r) // factorial (n - r) % mod)\n\n\n\nans = 0\n\nseq_len = s // 3\n\n\n\nfor i in range(1, seq_len + 1):\n\n    ans += nCr(s - 3 * i + (i - 1), i - 1)\n\n\n\nprint((ans % mod))", "generated_code": "N, M = list(map(int, input().split()))\n\nINF = 10**18\n\n\n\nminDist = [[INF] * N for _ in range(N)]\n\nfor i in range(N):\n\n    minDist[i][i] = 0\n\n\n\nedges = []\n\nfor _ in range(M):\n\n    fr, to, d = list(map(int, input().split()))\n\n    fr -= 1\n\n    to -= 1\n\n    edges.append((fr, to, d))\n\n    minDist[fr][to] = d\n\n    minDist[to][fr] = d\n\n\n\nfor k in range(N):\n\n    for i in range(N):\n\n        for j in range(N):\n\n            d = minDist[i][k] + minDist[k][j]\n\n            if minDist[i][j] > d:\n\n                minDist[i][j] = d\n\n\n\nans = 0\n\nfor fr, to, d in edges:\n\n    if minDist[fr][to] < d:\n\n        ans += 1\n\nprint(ans)\n", "score": 0.0, "codebleu": 0.1472531908977338, "crystalbleu": 0.05250488899392665, "codebertscore": 0.71, "codescore": 0.7732280492782593, "surfaceSim": 0.434337637494022, "abs_surfaceSim_minus_score": 0.434337637494022}
{"golden_code": "# vim: fileencoding=utf-8\n\n\n\n\n\ndef main():\n\n    a, b = list(map(int, input().split()))\n\n    c = 0\n\n    for i in range(a, b + 1):\n\n        s = str(i)\n\n        r = \"\".join(reversed(list(s)))\n\n        if s == r:\n\n            c += 1\n\n    print(c)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "generated_code": "class Queue:\n\n    def __init__(self,l):\n\n        self.values = []\n\n        self.l = l\n\n        for _ in range(l):\n\n            self.values.append(None)\n\n        self.head = 0\n\n        self.tail = 0\n\n    def inc(self,n):\n\n        if n+1 >= self.l:\n\n            return 0\n\n        else:\n\n            return n+1\n\n    def enqueue(self,v):\n\n        if self.inc(self.head) == self.tail:\n\n            print('overflow')\n\n            exit()\n\n        self.values[self.head] = v\n\n        self.head = self.inc(self.head)\n\n    def dequeue(self):\n\n        if self.head == self.tail:\n\n            print('underflow')\n\n            exit()\n\n        v = self.values[self.tail]\n\n        self.tail = self.inc(self.tail)\n\n        return v\n\n    def size(self):\n\n        if self.head >= self.tail:\n\n            return self.head-self.tail\n\n        else:\n\n            self.head + (self.l-self.tail)\n\n\n\nn,q = list(map(int,input().split(' ')))\n\nqueue = Queue(200000)\n\nfor _ in range(n):\n\n    n,t = input().split(' ')\n\n    t = int(t)\n\n    queue.enqueue((n,t))\n\n\n\nc = 0\n\nwhile queue.size()>0:\n\n    n,t = queue.dequeue()\n\n    if t <= q:\n\n        c += t\n\n        print(n,c)\n\n    else:\n\n        queue.enqueue((n,t-q))\n\n        c += q", "score": 0.0, "codebleu": 0.24015307860468674, "crystalbleu": 0.07742869913776905, "codebertscore": 0.66, "codescore": 0.02326878532767296, "surfaceSim": 0.5370339454646633, "abs_surfaceSim_minus_score": 0.5370339454646633}
{"golden_code": "import sys\n\ninput = sys.stdin.readline\n\nH, W = [int(x) for x in input().split()]\n\na = []\n\nfor _ in range(H):\n\n    a.append(list(input().rstrip()))\n\nimport numpy as np\n\na = np.array(a, np.object)\n\na = a.T\n\nretsu = []\n\ngyou = []\n\nfor i in range(W):\n\n    if \"#\" not in a[i]:\n\n        retsu.append(i)\n\na = a.T\n\nfor i in range(H):\n\n    if \"#\" not in a[i]:\n\n        gyou.append(i)\n\na = np.delete(a, retsu, 1)\n\na = np.delete(a, gyou, 0)\n\nfor j in a:\n\n    j = list(j)\n\n    print((\"\".join(j)))", "generated_code": "N, M = list(map(int, input().split()))\n\n\n\nleft = 1\n\nright = N\n\n\n\nfor _ in range(M):\n\n    l, r = list(map(int, input().split()))\n\n\n\n    if left < l:\n\n        left = l\n\n    if right > r:\n\n        right = r\n\n\n\nans = right - left\n\n\n\nprint((ans + 1 if ans >= 0 else 0))\n", "score": 0.0, "codebleu": 0.1153411756196665, "crystalbleu": 0.034067356508270925, "codebertscore": 0.73, "codescore": 0.16291861236095428, "surfaceSim": 0.43565525383707204, "abs_surfaceSim_minus_score": 0.43565525383707204}
{"golden_code": "class Queue:\n\n    def __init__(self,values):\n\n        self.values = values\n\n\n\n    def empty(self):\n\n        if len(self.values) == 0:\n\n            return True\n\n        else:\n\n            return False\n\n\n\n    def enqueue(self,v):\n\n        self.values.append(v)\n\n\n\n    def dequeue(self):\n\n        if len(self.values) <= 0:\n\n            raise\n\n        else:\n\n            v = self.values[0]\n\n            del self.values[0]\n\n            return v\n\n\n\nn,q = list(map(int,input().split(' ')))\n\nprocesses = []\n\nfor i in range(n):\n\n    n,t = input().split(' ')\n\n    processes.append((n,int(t)))\n\n\n\nqueue = Queue(processes)\n\n\n\nclock = 0\n\ndone = []\n\nwhile not queue.empty():\n\n    p = queue.dequeue()\n\n    n = p[0]\n\n    t = p[1]\n\n    if t <= q:\n\n        clock+=t\n\n        done.append((n,clock))\n\n    else:\n\n        queue.enqueue((n,t-q))\n\n        clock+=q\n\n\n\nfor p in done:\n\n    print(p[0],p[1])", "generated_code": "N,K = list(map(int,input().split()))\n\nA = list(map(int,input().split()))\n\n\n\ndp = [False]*(K+1)\n\n\n\nfor i in range(K+1):\n\n    for j in range(N):\n\n        if i-A[j]>=0 and dp[i-A[j]] == False:\n\n            dp[i] = True\n\n\n\n        \n\nif dp[K]:\n\n    print(\"First\")\n\nelse:\n\n    print(\"Second\")", "score": 0.0, "codebleu": 0.1034350708453512, "crystalbleu": 0.06223341769418623, "codebertscore": 0.67, "codescore": 0.9438098073005676, "surfaceSim": 0.5009520884520884, "abs_surfaceSim_minus_score": 0.5009520884520884}
{"golden_code": "#!/usr/bin/env python3\n\n# coding=utf-8\n\n\n\nimport sys\n\n\n\ns = sys.stdin.readline().strip()\n\nl = [_s is \"1\" for _s in list(s)]\n\nl_r = l[::-1]\n\nindex = 0\n\nfor i, (c, n, c_r, n_r) in enumerate(\n\n        zip(l[:len(s) // 2], l[1:len(s) // 2 + 1], l_r[:len(s) // 2], l_r[1:len(s) // 2 + 1])):\n\n    if c ^ n or c_r ^ n_r:\n\n        index = i + 1\n\nprint((len(s) - index))", "generated_code": "n, m = list(map(int, input().split()))\n\na = [int(x) for x in input().split()]\n\n\n\naa = [0]*(10**5+1)\n\naa_sum = [0]*(10**5+1)\n\n\n\nfor x in a:\n\n    aa[x] += 1\n\n    aa_sum[x] += x\n\n\n\nfor i in range(10**5)[::-1]:\n\n    aa[i] = aa[i] + aa[i+1]\n\n    aa_sum[i] = aa_sum[i] + aa_sum[i+1]\n\n\n\n\n\ndef count(x):\n\n    cnt = 0\n\n    sm = 0\n\n    for i in range(n):\n\n        if x-a[i] < 0:\n\n            cnt += n\n\n            sm += aa_sum[0]+n*a[i]\n\n        elif x-a[i] > 10**5:\n\n            continue\n\n        else:\n\n            cnt += aa[x-a[i]]\n\n            sm += aa_sum[x-a[i]]+aa[x-a[i]]*a[i]\n\n\n\n    return cnt, sm\n\n\n\n\n\nbottom = 0\n\ntop = 10**6\n\n\n\nwhile top - bottom > 1:\n\n    mid = (top+bottom) // 2\n\n    cnt, sm = count(mid)\n\n    if cnt < m:\n\n        top = mid\n\n    else:\n\n        bottom = mid\n\n\n\ncnt, sm = count(bottom)\n\nans = sm - (cnt-m)*bottom\n\n\n\nprint(ans)\n", "score": 0.0, "codebleu": 0.18940077502549457, "crystalbleu": 0.04479681589070516, "codebertscore": 0.7, "codescore": 0.9930208325386047, "surfaceSim": 0.5033953226260919, "abs_surfaceSim_minus_score": 0.5033953226260919}
{"golden_code": "import collections\n\nn = int(eval(input()))\n\na=[eval(input()) for _ in range(n)]\n\nanslist=[]\n\nb=collections.Counter(a)\n\nc=max(list(b.values()))\n\nfor i in b:\n\n    if b[i]==c:\n\n        anslist.append(i)\n\nd=sorted(anslist)\n\nfor i in tuple(d):\n\n    print(i)", "generated_code": "n, m = list(map(int, input().split()))\n\na = [int(x) for x in input().split()]\n\n\n\naa = [0]*(10**5+1)\n\naa_sum = [0]*(10**5+1)\n\n\n\nfor x in a:\n\n    aa[x] += 1\n\n    aa_sum[x] += x\n\n\n\nfor i in range(10**5)[::-1]:\n\n    aa[i] = aa[i] + aa[i+1]\n\n    aa_sum[i] = aa_sum[i] + aa_sum[i+1]\n\n\n\n\n\ndef count(x):\n\n    cnt = 0\n\n    sm = 0\n\n    for i in range(n):\n\n        if x-a[i] < 0:\n\n            cnt += n\n\n            sm += aa_sum[0]+n*a[i]\n\n        elif x-a[i] > 10**5:\n\n            continue\n\n        else:\n\n            cnt += aa[x-a[i]]\n\n            sm += aa_sum[x-a[i]]+aa[x-a[i]]*a[i]\n\n\n\n    return cnt, sm\n\n\n\n\n\nbottom = 0\n\ntop = 10**6\n\n\n\nwhile top - bottom > 1:\n\n    mid = (top+bottom) // 2\n\n    cnt, sm = count(mid)\n\n    if cnt < m:\n\n        top = mid\n\n    else:\n\n        bottom = mid\n\n\n\ncnt, sm = count(bottom)\n\nans = sm - (cnt-m)*bottom\n\n\n\nprint(ans)\n", "score": 0.0, "codebleu": 0.22376952709207656, "crystalbleu": 0.05335283448555253, "codebertscore": 0.7, "codescore": 0.9912248253822327, "surfaceSim": 0.44122287968441815, "abs_surfaceSim_minus_score": 0.44122287968441815}
{"golden_code": "#!/usr/bin/env python3\n\n\n\nn = int(eval(input()))\n\ns = [eval(input()) for _ in range(n)]\n\n\n\nc = [0 for _ in range(5)]\n\nt = 'MARCH'\n\n\n\nfor i in range(n):\n\n    for j in range(5):\n\n        if s[i][0] == t[j]:\n\n            c[j] += 1\n\nans = 0 \n\nfor i in range(5):\n\n    for j in range(i+1, 5): \n\n        for k in range(j+1, 5): \n\n            ans += c[i]*c[k]*c[j]\n\nprint(ans)\n", "generated_code": "N, D = list(map(int, input().split()))\n\ncnt = 0\n\nfor _ in range(N):\n\n    x, y = list(map(int, input().split()))\n\n    if x * x + y * y <= D * D:\n\n        cnt += 1\n\n        \n\nprint(cnt)", "score": 0.0, "codebleu": 0.12174136468219166, "crystalbleu": 0.02768764963741073, "codebertscore": 0.75, "codescore": 0.8342627882957458, "surfaceSim": 0.5970896665488394, "abs_surfaceSim_minus_score": 0.5970896665488394}
{"golden_code": "def main():\n\n    x = int(eval(input()))\n\n    for a in range(-120, 121):\n\n        for b in range(-120, 121):\n\n            if a**5 - b**5 == x:\n\n                print((a, b))\n\n                return\n\n\n\nif __name__ == \"__main__\":\n\n    main()", "generated_code": "#!/usr/bin/env python3\n\n\n\nn = int(eval(input()))\n\ns = [eval(input()) for _ in range(n)]\n\nd = {}\n\n\n\nfor c in s:\n\n    if c[0] not in d:\n\n        d[c[0]] = 1 \n\n    else:\n\n        d[c[0]] += 1\n\n\n\ntmp = d.copy()\n\nt = ['M', 'A', 'R', 'C', 'H']\n\nfor c in tmp:\n\n    if c not in t:\n\n        d.pop(c)\n\n\n\nans = 0 \n\ndlist = list(d.items())\n\nfor i in range(len(dlist)):\n\n    for j in range(i+1, len(dlist)):\n\n        for k in range(j+1, len(dlist)):\n\n            ans += dlist[i][1]*dlist[j][1]*dlist[k][1]\n\nprint(ans)\n", "score": 0.0, "codebleu": 0.2137414155702294, "crystalbleu": 0.043846314962167295, "codebertscore": 0.69, "codescore": 0.9170389175415039, "surfaceSim": 0.4172029702970297, "abs_surfaceSim_minus_score": 0.4172029702970297}
{"golden_code": "from collections import deque\n\nK = int(eval(input()))\n\nG = [[] for i in range(K)]\n\n\n\nfor n in range(K):\n\n    G[n].append([(n + 1) % K, 1])\n\n    G[n].append([(10 * n) % K, 0])\n\n\n\nque = deque([[1, 1]])\n\ndist = [float('inf')] * K\n\n\n\nwhile que:\n\n    node, cost = que.pop()\n\n    dist[node] = min(cost, dist[node])\n\n    for e, e_cost in G[node]:\n\n        if dist[e] != float('inf'):\n\n            continue\n\n\n\n        if e_cost == 0:\n\n            que.append([e, cost + 0])\n\n\n\n        if e_cost == 1:\n\n            que.appendleft([e, cost + 1])\n\n\n\nprint((dist[0]))\n", "generated_code": "def s():\n\n n=int(eval(input()))-1\n\n A=list(map(int,input().split()))\n\n i=0\n\n for j in range(n):\n\n  if A[j]<=A[-1]:A[i],A[j]=A[j],A[i];i+=1\n\n A[i],A[n]=A[n],A[i]\n\n print((\" \".join(map(str,A[:i]))+\" [\"+str(A[i])+\"] \"+\" \".join(map(str,A[i+1:]))))\n\nif'__main__'==__name__:s()\n", "score": 0.0, "codebleu": 0.13507921888903918, "crystalbleu": 0.08692520819648394, "codebertscore": 0.7, "codescore": 0.04320523887872696, "surfaceSim": 0.47072072072072074, "abs_surfaceSim_minus_score": 0.47072072072072074}
{"golden_code": "n,k = list(map(int,input().split()))\n\narr = list(map(int,input().split()))\n\n\n\ndp = [False]*(k+1)\n\n\n\nfor stones in range(k+1):\n\n    for x in arr:\n\n        if stones >= x and dp[stones-x] == False:\n\n            dp[stones] = True\n\n\n\nif dp[k]:\n\n    print(\"First\")\n\nelse:\n\n    print(\"Second\")\n", "generated_code": "N, M = list(map(int, input().split()))\n\n\n\nleft = 1\n\nright = N\n\n\n\nfor _ in range(M):\n\n    l, r = list(map(int, input().split()))\n\n\n\n    if left < l:\n\n        left = l\n\n    if right > r:\n\n        right = r\n\n\n\nans = right - left\n\n\n\nprint((ans + 1 if ans >= 0 else 0))\n", "score": 0.0, "codebleu": 0.24485229360931404, "crystalbleu": 0.09399828158575246, "codebertscore": 0.77, "codescore": 0.09502965211868286, "surfaceSim": 0.5543981481481481, "abs_surfaceSim_minus_score": 0.5543981481481481}
{"golden_code": "import sys\n\ninput = sys.stdin.readline\n\nsys.setrecursionlimit(1000000)\n\nfrom collections import deque\n\ndef getN():\n\n    return int(eval(input()))\n\ndef getList():\n\n    return list(map(int, input().split()))\n\nimport math\n\n\n\nn = getN()\n\nnums = getList()\n\n\n\n# nums.sort(reverse=True)\n\nmx = max(nums)\n\nmn = (mx+1) // 2\n\nmndx = (mx % 2) + 1\n\n\n\nfrom collections import Counter\n\n\n\ncnt = Counter(nums)\n\n\n\nfor i in range(mn+1, mx+1):\n\n    if cnt[i] < 2:\n\n        print(\"Impossible\")\n\n        sys.exit()\n\n\n\nif cnt[mn] != mndx:\n\n    print(\"Impossible\")\n\nelse:\n\n    print(\"Possible\")", "generated_code": "N, L = list(map(int, input().split()))\n\nS = list(eval(input()) for i in range(N))\n\nS.sort()\n\nstr = \"\"\n\nfor i in S:\n\n    str += i\n\nprint(str)\n", "score": 0.0, "codebleu": 0.11006372152135765, "crystalbleu": 0.06945811595571562, "codebertscore": 0.69, "codescore": 0.05583961680531502, "surfaceSim": 0.37982456140350873, "abs_surfaceSim_minus_score": 0.37982456140350873}
