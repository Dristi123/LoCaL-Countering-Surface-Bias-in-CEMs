{"golden_code": "import numpy as np\n\n\n\nN, D = list(map(int, input().split()))\n\npoints = [list(map(int, input().split())) for _ in range(N)]\n\ncount = 0\n\nfor i in range(N):\n\n    for j in range(N):\n\n        if j == i:\n\n            continue\n\n        dist = np.sqrt(sum([(points[i][d] - points[j][d]) ** 2 for d in range(D)]))\n\n        if dist.is_integer():\n\n            count += 1\n\nprint((count // 2))", "generated_code": "import sys\n\nsys.setrecursionlimit(10 ** 6)\n\n\n\n\n\ndef calc_dist(x, y):\n\n    dist = 0\n\n    for xi, yi in zip(x, y):\n\n        dist += (yi - xi) ** 2\n\n    return dist ** (1/2)\n\n\n\n\n\ndef main():\n\n    N, D = list(map(int, sys.stdin.readline().rstrip().split()))\n\n    X = [list(map(int, sys.stdin.readline().rstrip().split())) for _ in range(N)]\n\n\n\n    ans = 0\n\n    for i in range(N):\n\n        for j in range(i+1, N):\n\n            dist = calc_dist(X[i], X[j])\n\n            if dist.is_integer():\n\n                ans += 1\n\n    \n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()", "score": 1.0, "codebleu": 0.3631493984972547, "crystalbleu": 0.25453927053447467, "codebertscore": 0.81, "codescore": 0.01856362260878086, "surfaceSim": 0.6462575823223571, "abs_surfaceSim_minus_score": 0.3537424176776429}
{"golden_code": "import sys\n\nfrom scipy.sparse import csr_matrix\n\nfrom scipy.sparse.csgraph import floyd_warshall\n\n\n\ndef solve(N: int, M: int, a: \"List[int]\", b: \"List[int]\"):\n\n    answer = 0\n\n    for i in range(M): ## iの辺を消す\n\n        matrix = [[0]*(N) for _ in range(N)]\n\n        for j in range(M):\n\n            if j == i:\n\n                continue\n\n            aa = a[j]-1\n\n            bb = b[j]-1\n\n            matrix[aa][bb] = 1\n\n           \n\n        dist_matrix = floyd_warshall(csgraph=csr_matrix(matrix), directed=False)\n\n        \n\n        if dist_matrix[a[i]-1][b[i]-1] == float('inf'):\n\n            answer += 1\n\n            \n\n    print(answer)\n\n    return\n\n\n\n\n\ndef main():\n\n    def iterate_tokens():\n\n        for line in sys.stdin:\n\n            for word in line.split():\n\n                yield word\n\n    tokens = iterate_tokens()\n\n    N = int(next(tokens))  # type: int\n\n    M = int(next(tokens))  # type: int\n\n    a = [int()] * (M)  # type: \"List[int]\"\n\n    b = [int()] * (M)  # type: \"List[int]\"\n\n    for i in range(M):\n\n        a[i] = int(next(tokens))\n\n        b[i] = int(next(tokens))\n\n    solve(N, M, a, b)\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "generated_code": "#!/usr/bin/env python3\n\nimport sys\n\ninput = sys.stdin.readline\n\ndef INT(): return int(eval(input()))\n\ndef MAP(): return list(map(int,input().split()))\n\ndef LI(): return list(map(int,input().split()))\n\n\n\nclass UnionFind():\n\n    def __init__(self, n):\n\n        self.n = n\n\n        self.parents = [-1] * n\n\n        \n\n    def find(self, x): # 根を探す\n\n        if self.parents[x] < 0:\n\n            return x\n\n        else:\n\n            self.parents[x] = self.find(self.parents[x])\n\n            return self.parents[x]\n\n    \n\n    def union(self, x, y):\n\n        x = self.find(x)\n\n        y = self.find(y)\n\n        \n\n        if x == y:\n\n            return\n\n        \n\n        if self.parents[x] > self.parents[y]:\n\n            x, y = y, x\n\n        \n\n        self.parents[x] += self.parents[y]\n\n        self.parents[y] = x\n\n    \n\n    def size(self, x):\n\n        return -self.parents[self.find(x)]\n\n        \n\n    def same(self, x, y):\n\n        return self.find(x) == self.find(y)\n\n    \n\n    def members(self, x):\n\n        root = self.find(x)\n\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    \n\n    def roots(self):\n\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n\n\n    def group_count(self):\n\n        return len(self.roots())\n\n    \n\n    def all_group_members(self):\n\n        return {r: self.members(r) for r in self.roots()}\n\n    \n\n    def __str__(self):\n\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n\n\ndef main():\n\n    N,M=MAP()\n\n    \n\n    edges = []\n\n    for _ in range(M):\n\n        a,b = MAP()\n\n        edges.append((a-1,b-1))\n\n\n\n    answer = 0\n\n    for i in range(M): # i番目の辺を使わない\n\n        uf = UnionFind(N)\n\n\n\n        for j in range(M):\n\n            if i == j:\n\n                continue\n\n\n\n            a,b = edges[j]\n\n            uf.union(a,b)\n\n        if uf.group_count() > 1:\n\n            answer += 1\n\n    print(answer)\n\n    return\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 1.0, "codebleu": 0.2950212217985968, "crystalbleu": 0.14386136984649348, "codebertscore": 0.74, "codescore": 0.15722301602363586, "surfaceSim": 0.6271589000576542, "abs_surfaceSim_minus_score": 0.3728410999423458}
{"golden_code": "n = int(eval(input()))\n\nprint((1 if n == 0 else 0))\n", "generated_code": "n = int(eval(input()))\n\nprint((0 if n else 1))\n", "score": 1.0, "codebleu": 0.45523015794853083, "crystalbleu": 0.0, "codebertscore": 0.96, "codescore": 0.3363740146160126, "surfaceSim": 0.861013986013986, "abs_surfaceSim_minus_score": 0.13898601398601396}
{"golden_code": "import sys\n\nimport numpy as np\n\n\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\ndef main(N):\n\n    div = np.zeros(N+1, np.int64)\n\n    for n in range(1, N+1):\n\n      for m in range(n, N+1, n):\n\n        div[m] += m\n\n    return div.sum()\n\n\n\nif sys.argv[-1] == 'ONLINE_JUDGE':\n\n    import numba\n\n    from numba.pycc import CC\n\n    i8 = numba.int64\n\n    cc = CC('my_module')\n\n\n\n    def cc_export(f, signature):\n\n        cc.export(f.__name__, signature)(f)\n\n        return numba.njit(f)\n\n\n\n    main = cc_export(main, (i8, ))\n\n    cc.compile()\n\n\n\nfrom my_module import main\n\n\n\nN = int(read())\n\nprint((main(N)))\n", "generated_code": "import sys\n\nimport numpy as np\n\n\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\ndef main(N):\n\n    x = 0\n\n    for a in range(1, N+1):\n\n        for b in range(1, N//a+1):\n\n            x += a*b\n\n    return x\n\n\n\nif sys.argv[-1] == 'ONLINE_JUDGE':\n\n    import numba\n\n    from numba.pycc import CC\n\n    i8 = numba.int64\n\n    cc = CC('my_module')\n\n\n\n    def cc_export(f, signature):\n\n        cc.export(f.__name__, signature)(f)\n\n        return numba.njit(f)\n\n\n\n    main = cc_export(main, (i8, ))\n\n    cc.compile()\n\n\n\nfrom my_module import main\n\n\n\nN = int(read())\n\nprint((main(N)))\n", "score": 1.0, "codebleu": 0.7129705636570907, "crystalbleu": 0.7213595826396544, "codebertscore": 0.96, "codescore": 0.9067520499229431, "surfaceSim": 0.9284357821089455, "abs_surfaceSim_minus_score": 0.0715642178910545}
{"golden_code": "import numpy as np\n\nN = int(eval(input()))\n\nlist_ai = list(map(int,input().split()))\n\nlist1 = [x-(i+1) for i,x in enumerate(list_ai)]\n\na1 = np.array(list1)\n\nmedian1 = int(np.floor(np.median(a1)))\n\nans = np.sum(np.abs(a1-median1))\n\nprint(ans)", "generated_code": "import numpy as np\n\nN = int(eval(input()))\n\nlist_ai = list(map(int,input().split()))\n\na1 = np.array(list_ai)-np.arange(1,N+1)\n\nmedian1 = int(np.floor(np.median(a1)))\n\nans = np.sum(np.abs(a1-median1))\n\nprint(ans)\n", "score": 1.0, "codebleu": 0.6417047816651265, "crystalbleu": 0.0, "codebertscore": 0.95, "codescore": 0.9700177907943726, "surfaceSim": 0.8308518428118135, "abs_surfaceSim_minus_score": 0.16914815718818654}
{"golden_code": "import numpy as np\n\nN_1=list(map(int, input().split()))\n\nN_2=list(map(int, input().split()))\n\nN_3=list(map(int, input().split()))\n\nN=int(eval(input()))\n\na=[int(eval(input())) for i in range(N)]\n\n\n\nn=np.array([N_1,N_2,N_3])\n\n\n\nfor a_n in a:\n\n    if a_n in n:\n\n        n[n==a_n]=0\n\n    else:\n\n        pass\n\ni=0\n\n    \n\nif np.all(n[0:,0]==0)==True:\n\n    i=+1\n\n    \n\nelif np.all(n[0:,1]==0)==True:\n\n    i+=1\n\n    \n\nelif np.all(n[0:,2]==0)==True:\n\n    i+=1\n\n    \n\nelif np.all(n[0,0:]==0)==True:\n\n    i+=1\n\n    \n\nelif np.all(n[1,0:]==0)==True:\n\n    i+=1\n\n\n\nelif np.all(n[2,0:]==0)==True:\n\n    i+=1\n\n\n\nelif n[0,0]==0 and n[1,1]==0  and n[2,2] ==0:\n\n    i+=1\n\n    \n\nelif n[0,2]==0 and n[1,1]==0 and n[2,0] ==0:\n\n    i+=1\n\n    \n\nif i>0:\n\n    print(\"Yes\")\n\nelse:\n\n    print(\"No\")", "generated_code": "a_1=list(map(int, input().split()))\n\na_2=list(map(int, input().split()))\n\na_3=list(map(int, input().split()))\n\n\n\nc=[a_1,a_2,a_3]\n\n\n\nN=int(eval(input()))\n\n\n\nb=[int(eval(input())) for _ in range(N)]\n\n\n\nfor i in range(3):\n\n    for j in range(3):\n\n        if c[i][j] in b:\n\n            c[i][j]=0\n\n            \n\n            \n\ni=0\n\nif c[0][0]==0 and c[0][1]==0 and c[0][2]==0:\n\n    i+=1\n\nif c[1][0]==0 and c[1][1]==0 and c[1][2]==0:\n\n    i+=1\n\nif c[2][0]==0 and c[2][1]==0 and c[2][2]==0:\n\n    i+=1\n\nif c[0][0]==0 and c[1][0]==0 and c[2][0]==0:\n\n    i+=1\n\nif c[0][1]==0 and c[1][1]==0 and c[2][1]==0:\n\n    i+=1\n\nif c[0][2]==0 and c[1][2]==0 and c[2][2]==0:\n\n    i+=1\n\nif c[0][0]==0 and c[1][1]==0 and c[2][2]==0:\n\n    i+=1\n\nif c[0][2]==0 and c[1][1]==0 and c[2][0]==0:\n\n    i+=1\n\n    \n\nif i>0:\n\n    print(\"Yes\")\n\nelse:\n\n  print(\"No\")", "score": 1.0, "codebleu": 0.3141180079646291, "crystalbleu": 0.43074943134461113, "codebertscore": 0.89, "codescore": 0.8679244518280029, "surfaceSim": 0.6924123337363965, "abs_surfaceSim_minus_score": 0.30758766626360345}
{"golden_code": "import sys\n\ninput = sys.stdin.readline\n\nsys.setrecursionlimit(10 ** 7)\n\n\n\nN = int(eval(input()))\n\nA = [int(i) for i in input().split()]\n\nB = [int(i) for i in input().split()]\n\nbefore = sum(A)\n\n\n\nfor i in range(N):\n\n    nokori = B[i]\n\n    for j in range(i,i+2):\n\n        if nokori >= A[j]:\n\n            nokori -= A[j]\n\n            A[j] = 0\n\n        else:\n\n            A[j] -= nokori\n\n            nokori = 0\n\nafter = sum(A)\n\n\n\nprint((before - after))", "generated_code": "N = int(eval(input()))\n\nA = [int(i) for i in input().split()]\n\nB = [int(i) for i in input().split()]\n\n\n\ncnt = 0\n\nfor i in range(N):\n\n    if B[i] >= A[i]:\n\n        cnt += A[i]\n\n        B[i] -= A[i]\n\n    else:\n\n        cnt += B[i]\n\n        B[i] = 0\n\n    if B[i] == 0:\n\n        continue\n\n    if B[i] >= A[i+1]:\n\n        cnt += A[i+1]\n\n        A[i+1] = 0\n\n    else:\n\n        cnt += B[i]\n\n        A[i+1] -= B[i]\n\n\n\nprint(cnt)", "score": 1.0, "codebleu": 0.4094408094356795, "crystalbleu": 0.43670551042039385, "codebertscore": 0.82, "codescore": 0.7907236218452454, "surfaceSim": 0.6795157967032968, "abs_surfaceSim_minus_score": 0.32048420329670324}
{"golden_code": "N = int(eval(input()))\n\nB =list(map(int,input().split()))\n\nA=[0]*N\n\n\n\nA[0]=B[0]\n\nfor i in range(1,N-1):\n\n    A[i]=min(B[i],B[i-1])\n\nA[-1]=B[-1]\n\nprint((sum(A)))", "generated_code": "import sys\n\ninput = sys.stdin.readline\n\n\n\ndef I(): return int(eval(input()))\n\ndef MI(): return list(map(int, input().split()))\n\ndef LI(): return list(map(int, input().split()))\n\n\n\ndef main():\n\n    mod=10**9+7\n\n    N=I()\n\n    B=LI()\n\n    A=[0]*N\n\n    A[0]=B[0]\n\n    A[-1]=B[-1]\n\n    for i in range(N-2):\n\n        A[i+1]=min(B[i],B[i+1])\n\n        \n\n    print((sum(A)))\n\n\n\nmain()\n", "score": 1.0, "codebleu": 0.3420747834033106, "crystalbleu": 0.3501257756758309, "codebertscore": 0.85, "codescore": 0.5377168655395508, "surfaceSim": 0.6225994694960212, "abs_surfaceSim_minus_score": 0.3774005305039788}
{"golden_code": "from numpy import*\n\na,b=median(t:=loadtxt(open(0),skiprows=1),0)\n\nprint((int((a-b)*~(~len(t)%2))+1))", "generated_code": "from statistics import*\n\n(n,),*t=[list(map(int,t.split()))for t in open(0)]\n\na,b=list(map(median,list(zip(*t))))\n\nprint((int((b-a)*(2-n%2))+1))", "score": 1.0, "codebleu": 0.24364115598855923, "crystalbleu": 0.0, "codebertscore": 0.84, "codescore": 0.9279803037643433, "surfaceSim": 0.5466200466200466, "abs_surfaceSim_minus_score": 0.4533799533799534}
{"golden_code": "n, q = [ int( val ) for val in input( ).split( \" \" ) ]\n\nps = [0]*n\n\nt = [0]*n\n\nfor i in range( n ):\n\n\tps[i], t[i] = input( ).split( \" \" )\n\n\n\n\n\noutput = []\n\nqsum = 0\n\nwhile t:\n\n\tpsi = ps.pop( 0 )\n\n\tti = int( t.pop( 0 ) )\n\n\tif ti <= q:\n\n\t\tqsum += ti\t\n\n\t\toutput.append( psi+\" \"+str( qsum ) )\n\n\telse:\n\n\t\tt.append( ti - q )\n\n\t\tps.append( psi )\n\n\t\tqsum += q\n\n\n\nprint(( \"\\n\".join( output ) ))", "generated_code": "n, q = [ int( val ) for val in input( ).split( \" \" ) ]\n\nps = [0]*n\n\nt = [0]*n\n\nfor i in range( n ):\n\n    ps[i], t[i] = input( ).split( \" \" )\n\n \n\n \n\noutput = []\n\nqsum = 0\n\nwhile t:\n\n    psi = ps.pop( 0 )\n\n    ti = int( t.pop( 0 ) )\n\n    if ti <= q:\n\n        qsum += ti\n\n        output.append( \"\".join( ( psi, \" \", str( qsum ) ) ) )\n\n    else:\n\n        t.append( ti - q )\n\n        ps.append( psi )\n\n        qsum += q\n\n \n\nprint(( \"\\n\".join( output ) ))", "score": 1.0, "codebleu": 0.9169507813983201, "crystalbleu": 0.9072327470401259, "codebertscore": 0.97, "codescore": 0.6795209050178528, "surfaceSim": 0.9855233853006682, "abs_surfaceSim_minus_score": 0.014476614699331813}
{"golden_code": "a,b,c,x,y=list(map(int,input().split()))\n\n\n\nans=a*x+b*y\n\nfor ci in range(max(x,y)+1):\n\n    sumc = 2*ci*c\n\n    sumc += (x-ci)*a if (x-ci)>0 else 0\n\n    sumc += (y-ci)*b if (y-ci)>0 else 0\n\n    ans=min(ans,sumc)\n\n\n\nprint(ans)", "generated_code": "a,b,c,x,y=list(map(int,input().split()))\n\nans=a*x+b*y\n\nif x==y:\n\n    ans=min(ans,2*x*c)\n\nelif x>y:\n\n    ans=min(ans,a*(x-y)+2*y*c)\n\n    ans=min(ans,2*x*c)\n\nelse:\n\n    ans=min(ans,b*(y-x)+2*x*c)\n\n    ans=min(ans,2*y*c)\n\nprint(ans)", "score": 1.0, "codebleu": 0.2997308617398364, "crystalbleu": 0.4571735917560744, "codebertscore": 0.87, "codescore": 0.09689239412546158, "surfaceSim": 0.6735288001663547, "abs_surfaceSim_minus_score": 0.32647119983364525}
{"golden_code": "n=int(eval(input()))\n\na=[list(map(int,input().split()))for _ in range(n)]\n\ndef f():\n\n for i in range(n-1):\n\n  d=a[i][:];d[3],d[4]=d[4],d[3]\n\n  for j in range(i+1,n):\n\n   e=a[j][:];e[3],e[4]=e[4],e[3]\n\n   for p in([0,1,2,3,4,5],[1,5,2,0,4,3],[2,1,5,3,0,4],[3,0,2,5,4,1],[4,1,0,3,5,2],[5,1,4,3,2,0]):\n\n    f=[d[k]for k in p]\n\n    if f[0]==e[0]and f[5]==e[5]:\n\n     f=f[1:5]*2\n\n     for k in range(4):\n\n      if f[k:k+4]==e[1:5]:return'No'\n\n return'Yes'\n\nprint((f()))\n", "generated_code": "n=int(eval(input()))\n\na=[[int(s)for s in input().split()]for _ in range(n)]\n\ndef f():\n\n for i in range(n-1):\n\n  d=a[i][:];d[3],d[4]=d[4],d[3]\n\n  for j in range(i+1,n):\n\n   e=a[j][:];e[3],e[4]=e[4],e[3]\n\n   for p in([0,1,2,3,4,5],[1,5,2,0,4,3],[2,1,5,3,0,4],[3,0,2,5,4,1],[4,1,0,3,5,2],[5,1,4,3,2,0]):\n\n    f=[d[k]for k in p]\n\n    if f[0]==e[0]and f[5]==e[5]:\n\n     f=f[1:5]*2\n\n     for k in range(4):\n\n      if f[k:k+4]==e[1:5]:return'No'\n\n return'Yes'\n\nprint((f()))\n", "score": 1.0, "codebleu": 0.7944470675843004, "crystalbleu": 0.9467469051426798, "codebertscore": 0.99, "codescore": 0.9937811493873596, "surfaceSim": 0.987152034261242, "abs_surfaceSim_minus_score": 0.012847965738758016}
{"golden_code": "import sys\n\ninput = sys.stdin.readline\n\nsys.setrecursionlimit(10 ** 7)\n\n\n\n\"\"\"\n\n奇数番目集合、偶数番目集合の中で自由にできるのが操作2．\n\n操作1で集合間のやりとりをする\n\n\"\"\"\n\n\n\nimport numpy as np\n\n\n\nN = int(eval(input()))\n\nA = np.fromstring(sys.stdin.read(),dtype=np.int64,sep='\\n')\n\n\n\nB = np.sort(A)\n\n\n\nanswer = len(np.setdiff1d(A[::2],B[::2]))\n\nprint(answer)", "generated_code": "import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\n\"\"\"\n\n・偶数番号、奇数番号の中では入れ替え放題\n\n・偶、奇の間：並べてからスワップ。操作2を1回で、正しいものを2つ増やせる\n\n\"\"\"\n\n\n\nN,*A = list(map(int,read().split()))\n\n\n\nx_to_i = {x:i for i,x in enumerate(sorted(A))}\n\nrank = [x_to_i[x] for x in A]\n\n\n\nanswer = sum((x^i) & 1 for i,x in enumerate(rank)) // 2\n\nprint(answer)", "score": 1.0, "codebleu": 0.23074092695025478, "crystalbleu": 0.052989305111456796, "codebertscore": 0.79, "codescore": 0.2320290058851242, "surfaceSim": 0.4430051813471503, "abs_surfaceSim_minus_score": 0.5569948186528497}
{"golden_code": "from collections import defaultdict\n\nimport numpy as np\n\ndef main():\n\n    s = eval(input())\n\n    n = len(s)\n\n    d = np.zeros(2019,np.int64)\n\n    ans = 0\n\n    num = 0\n\n    pow10 = 1\n\n    d[0] = 1\n\n    for i in reversed(list(range(n))):\n\n        pow10 = pow10 * 10 % 2019\n\n        num += int(s[i]) * pow10\n\n        #print(num, num % 2019, i)\n\n        mod = num % 2019\n\n        ans += d[mod]\n\n        d[mod] += 1\n\n    print(ans)\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "generated_code": "from collections import defaultdict\n\n\n\ndef main():\n\n    s = eval(input())\n\n    n = len(s)\n\n    ans = 0\n\n    num = 0\n\n    pow10 = 1\n\n    d = defaultdict(int)\n\n    d[0] = 1\n\n    for i in reversed(list(range(n))):\n\n        # pow10を10 ** (n-1-i)にしてるだけでTLEしていた\n\n        pow10 = pow10 * 10 % 2019\n\n        num += int(s[i]) * pow10\n\n        mod = num % 2019\n\n        ans += d[mod]\n\n        d[mod] += 1\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "score": 1.0, "codebleu": 0.6604584671820345, "crystalbleu": 0.8467833182814646, "codebertscore": 0.91, "codescore": 0.018564000725746155, "surfaceSim": 0.9002985074626866, "abs_surfaceSim_minus_score": 0.09970149253731342}
{"golden_code": "import numpy as np\n\n\n\nn = int(eval(input()))\n\nv = np.array(list(map(int, input().split())))\n\nc = np.array(list(map(int, input().split())))\n\np = v-c\n\nans = 0\n\nfor i in p:\n\n    if i>0:\n\n        ans+=i\n\n\n\nprint(ans)\n", "generated_code": "n=int(eval(input()))\n\nV=list(map(int,input().split()))\n\nC=list(map(int,input().split()))\n\nans=0\n\nfor v,c in zip(V,C):\n\n    diff=v-c\n\n    if 0<diff:\n\n        ans+=diff\n\nprint(ans)", "score": 1.0, "codebleu": 0.29762443362993635, "crystalbleu": 0.3229475823434128, "codebertscore": 0.88, "codescore": 0.7383496165275574, "surfaceSim": 0.7166331321260898, "abs_surfaceSim_minus_score": 0.2833668678739102}
{"golden_code": "# -*- coding: utf-8 -*-\n\n\n\nimport sys\n\nfrom collections import Counter\n\n\n\ndef input(): return sys.stdin.readline().strip()\n\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\n\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\n\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\n\ndef ceil(x, y=1): return int(-(-x // y))\n\ndef INT(): return int(eval(input()))\n\ndef MAP(): return list(map(int, input().split()))\n\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\n\ndef Yes(): print('Yes')\n\ndef No(): print('No')\n\ndef YES(): print('YES')\n\ndef NO(): print('NO')\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = 10 ** 18\n\nMOD = 10 ** 9 + 7\n\n\n\ndef fft(A, B):\n\n    \"\"\" \n\n    高速フーリエ変換(FFT)\n\n        A：出現回数をカウントしたリスト\n\n        B：出現回数をカウントしたリスト\n\n    \"\"\"\n\n    import numpy as np\n\n    from numpy.fft import rfft, irfft\n\n\n\n    # 出現数カウント\n\n    MAXA = max(A)\n\n    MAXB = max(B)\n\n    C1 = [0] * (MAXA+1)\n\n    C2 = [0] * (MAXB+1)\n\n    for a in A:\n\n        C1[a] += 1\n\n    for b in B:\n\n        C2[b] += 1\n\n    # max(A)+max(B)より大きい2冪\n\n    L = 1\n\n    k = 0\n\n    while L <= MAXA + MAXB:\n\n        k += 1\n\n        L = 2**k\n\n    # FFT\n\n    res = irfft(rfft(C1, L) * rfft(C2, L), L)\n\n    # 四捨五入して整数に\n\n    res = np.rint(res).astype(np.int64)\n\n    return res\n\n\n\nN, M, L = MAP()\n\nA = LIST()\n\nB = LIST()\n\n\n\nres = list(fft(A, B))\n\n\n\nmn = INF\n\nfor i, a in enumerate(res):\n\n    if a != 0:\n\n        mn = i\n\n        break\n\n\n\nfor _ in range(L):\n\n    x, y, c = MAP()\n\n    x -= 1; y -= 1\n\n    mn = min(mn, A[x] + B[y] - c)\n\nprint(mn)\n", "generated_code": "# -*- coding: utf-8 -*-\n\n\n\nimport sys\n\nfrom collections import Counter\n\n\n\ndef input(): return sys.stdin.readline().strip()\n\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\n\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\n\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\n\ndef ceil(x, y=1): return int(-(-x // y))\n\ndef INT(): return int(eval(input()))\n\ndef MAP(): return list(map(int, input().split()))\n\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\n\ndef Yes(): print('Yes')\n\ndef No(): print('No')\n\ndef YES(): print('YES')\n\ndef NO(): print('NO')\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = 10 ** 18\n\nMOD = 10 ** 9 + 7\n\n\n\nN, M, L = MAP()\n\nA = LIST()\n\nB = LIST()\n\n\n\nmn = min(A) + min(B)\n\nfor _ in range(L):\n\n    x, y, c = MAP()\n\n    x -= 1; y -= 1\n\n    mn = min(mn, A[x] + B[y] - c)\n\nprint(mn)\n", "score": 1.0, "codebleu": 0.6020281576727804, "crystalbleu": 0.6206387260897029, "codebertscore": 0.89, "codescore": 0.25776082277297974, "surfaceSim": 0.8161741713570982, "abs_surfaceSim_minus_score": 0.18382582864290176}
{"golden_code": "N,M,K = list(map(int,input().split()))\n\n\n\nfor i in range(N+1):\n\n    for j in range(M+1):\n\n        t = i*M + j*N - i*j*2\n\n        if t==K:\n\n            print('Yes')\n\n            exit()\n\nprint('No')", "generated_code": "N,M,K = list(map(int,input().split()))\n\n\n\nfor i in range(N+1):\n\n    for j in range(M+1):\n\n        if i*(M-j) + j*(N-i) == K:\n\n            print('Yes')\n\n            exit()\n\nprint('No')", "score": 1.0, "codebleu": 0.6557212908234747, "crystalbleu": 0.7989770211677567, "codebertscore": 0.96, "codescore": 0.9445545673370361, "surfaceSim": 0.9642857142857143, "abs_surfaceSim_minus_score": 0.0357142857142857}
{"golden_code": "from math import sqrt\n\nfrom bisect import bisect_left\n\ndef circle_center(x1, y1, x2, y2):\n\n    xd = x2 - x1; yd = y2 - y1\n\n    d = xd**2 + yd**2\n\n    k = sqrt((4.0 - d) / d) / 2.0\n\n    xc = (x1 + x2) / 2.0\n\n    yc = (y1 + y2) / 2.0\n\n    return [[xc - k*yd, yc + k*xd], [xc + k*yd, yc - k*xd]]\n\nwhile 1:\n\n    n = int(input())\n\n    if n==0: break\n\n    p = [list(map(float, input().split())) for i in range(n)]\n\n    p.sort()\n\n    prev = 0\n\n    ans = 1\n\n    for i in range(n):\n\n        bx, by = p[i]\n\n        while bx - p[prev][0] >= 2.0: prev += 1\n\n        for j in range(i+1, n):\n\n            cx, cy = p[j]\n\n            if cx - bx >= 2.0: break\n\n            if (bx - cx)**2 + (by - cy)**2 <= 4.0:\n\n                for ex, ey in circle_center(bx, by, cx, cy):\n\n                    count = 2\n\n                    for k in range(prev, n):\n\n                        if k==i or k==j: continue\n\n                        dx, dy = p[k]\n\n                        if dx - bx >= 2.0: break\n\n                        if (ex - dx)**2 + (ey - dy)**2 <= 1.0:\n\n                            count += 1\n\n                    ans = max(ans, count)\n\n    print(ans)", "generated_code": "from math import sqrt\n\nfrom bisect import bisect_left\n\ndef circle_center(x1, y1, x2, y2):\n\n    xd = x2 - x1; yd = y2 - y1\n\n    d = xd**2 + yd**2\n\n    k = sqrt((4.0 - d) / d) / 2.0\n\n    xc = (x1 + x2) / 2.0; yc = (y1 + y2) / 2.0\n\n    xd *= k; yd *= k\n\n    return [[xc - yd, yc + xd], [xc + yd, yc - xd]]\n\nwhile 1:\n\n    n = int(input())\n\n    if n==0: break\n\n    p = sorted(list(map(float, input().split())) for i in range(n))\n\n    prev = 0\n\n    ans = 1\n\n    for i in range(n):\n\n        bx, by = p[i]\n\n        while bx - p[prev][0] >= 2.0: prev += 1\n\n        for j in range(i+1, n):\n\n            cx, cy = p[j]\n\n            if cx - bx >= 2.0: break\n\n            if (bx - cx)**2 + (by - cy)**2 <= 4.0:\n\n                for ex, ey in circle_center(bx, by, cx, cy):\n\n                    count = 2\n\n                    for k in range(prev, n):\n\n                        if k==i or k==j: continue\n\n                        dx, dy = p[k]\n\n                        if dx - ex >= 1.0: break\n\n                        if (ex - dx)**2 + (ey - dy)**2 <= 1.0:\n\n                            count += 1\n\n                    ans = max(ans, count)\n\n    print(ans)", "score": 1.0, "codebleu": 0.8725141875683035, "crystalbleu": 0.897185654793022, "codebertscore": 0.98, "codescore": 0.9434788227081299, "surfaceSim": 0.9578646748681898, "abs_surfaceSim_minus_score": 0.042135325131810175}
{"golden_code": "import numpy as np\n\nN = int(eval(input()))\n\nVlist = np.array(list(map(int,input().split())))\n\nClist = np.array(list(map(int,input().split())))\n\n\n\nDlist = Vlist-Clist\n\n\n\nsum_ = 0\n\nfor d in Dlist:\n\n    if d >= 0:\n\n        sum_ += d\n\n\n\nprint(sum_)\n", "generated_code": "# 入力\n\nN = int(eval(input()))\n\nVlist = list(map(int, input().split()))\n\nClist = list(map(int, input().split()))\n\n\n\nans = 0\n\nfor i in range(N):\n\n    Z = Vlist[i] - Clist[i]\n\n    if Z > 0:\n\n        ans += Z\n\n\n\nprint(ans)\n", "score": 1.0, "codebleu": 0.3702720442864497, "crystalbleu": 0.2714626260738996, "codebertscore": 0.87, "codescore": 0.8142921924591064, "surfaceSim": 0.6983302411873841, "abs_surfaceSim_minus_score": 0.30166975881261593}
{"golden_code": "import numpy as np\n\nk,n = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\nb = np.zeros(n)\n\nfor i in range(0,n-1):\n\n  b[i] = a[i+1] -a[i]\n\n  \n\nb[n-1] = k - a[n-1] + a[0]\n\nans = k - max(b)\n\nprint((int(ans)))", "generated_code": "k,n = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\nb = [0 for i in range(n)]\n\nfor i in range(0,n-1):\n\n  b[i] = a[i+1] -a[i]\n\n\n\nb[n-1] = k - a[n-1] + a[0]\n\nans = k - max(b)\n\nprint((int(ans)))", "score": 1.0, "codebleu": 0.711035896451019, "crystalbleu": 0.8076589700572653, "codebertscore": 0.95, "codescore": 0.6413142085075378, "surfaceSim": 0.8361233480176211, "abs_surfaceSim_minus_score": 0.16387665198237888}
{"golden_code": "def main():\n\n\tn, ma, mb, *L = list(map(int, open(0).read().split()))\n\n\tM = 1<<30\n\n\tdp = [[M] * 420 for _ in range(420)]\n\n\tdp[0][0] = 0\n\n\tfor a, b, c in zip(*[iter(L)] * 3):\n\n\t\tfor i in range(400, -1, -1):\n\n\t\t\tfor j in range(400, -1, -1):\n\n\t\t\t\tt = dp[i][j] + c\n\n\t\t\t\tif dp[i + a][j + b] > t:\n\n\t\t\t\t\tdp[i + a][j + b] = t\n\n\tans = M\n\n\t_ma, _mb = ma, mb\n\n\twhile _ma < 410 > _mb:\n\n\t\tans = min(ans, dp[_ma][_mb])\n\n\t\t_ma += ma\n\n\t\t_mb += mb\n\n\tprint((ans if ans < M else -1))\n\n\n\nif __name__==\"__main__\":\n\n\tmain()", "generated_code": "def main():\n\n\tn, ma, mb, *L = list(map(int, open(0).read().split()))\n\n\tM = 1 << 30\n\n\tdp = [[M] * 420 for _ in range(420)]\n\n\tdp[0][0] = 0\n\n\tua = ub = 15\n\n\tfor a, b, c in zip(*[iter(L)] * 3):\n\n\t\tfor i in range(ua, -1, -1):\n\n\t\t\tfor j in range(ub, -1, -1):\n\n\t\t\t\tt = dp[i][j] + c\n\n\t\t\t\tif dp[i + a][j + b] > t:\n\n\t\t\t\t\tdp[i + a][j + b] = t\n\n\t\t\t\t\tif ua < i + a:\n\n\t\t\t\t\t\tua = i + a\n\n\t\t\t\t\tif ub < j + b:\n\n\t\t\t\t\t\tub = j + b\n\n\tans = M\n\n\t_ma, _mb = ma, mb\n\n\twhile _ma < 410 > _mb:\n\n\t\tans = min(ans, dp[_ma][_mb])\n\n\t\t_ma += ma\n\n\t\t_mb += mb\n\n\tprint((ans if ans < M else -1))\n\n\n\n\n\nif __name__ == \"__main__\":\n\n\tmain()\n", "score": 1.0, "codebleu": 0.7888409546721616, "crystalbleu": 0.8238017274344019, "codebertscore": 0.95, "codescore": 0.0357273668050766, "surfaceSim": 0.9590301003344481, "abs_surfaceSim_minus_score": 0.04096989966555187}
{"golden_code": "import sys\n\nimport numpy as np \n\n\n\nn, l = list(map(int, sys.stdin.readline().split()))\n\n\n\ndef main():\n\n    f = l + np.arange(1, n+1) - 1\n\n    s = f.sum()\n\n    a = np.absolute(f)\n\n    mi = np.amin(a)\n\n    i = np.argwhere(a == mi)[0, 0]\n\n    return s - f[i]\n\n\n\nif __name__ == '__main__':\n\n    ans = main()\n\n    print(ans)", "generated_code": "import sys\n\n\n\nn, l = list(map(int, sys.stdin.readline().split()))\n\n\n\ndef main():\n\n    s = (l - 1) * n + (1 + n) * n // 2\n\n    res = []\n\n    for i in range(1, n+1):\n\n        f = l + i - 1\n\n        res.append((abs(f), s - f))\n\n    \n\n    res.sort()\n\n    return res[0][1]\n\n\n\nif __name__=='__main__':\n\n    ans = main()\n\n    print(ans)", "score": 1.0, "codebleu": 0.36882509177801026, "crystalbleu": 0.3441407826763586, "codebertscore": 0.87, "codescore": 0.018584780395030975, "surfaceSim": 0.7693909715186311, "abs_surfaceSim_minus_score": 0.23060902848136888}
{"golden_code": "import sys\n\ninput = sys.stdin.readline\n\n\n\nn, m = list(map(int, input().split()))\n\nbroken = set([int(eval(input())) for _ in range(m)]) # ここが'list'だとPypyでも通らない\n\n\n\ndef ptn_num(x): # 'x'stepまでのパターン数\n\n    dp = [0] * (x+1) # DP枠_including step'0'\n\n    if 1 in broken: # in case, step'1' broken \n\n        dp[:2] = 1, 0\n\n    else:\n\n        dp[:2] = 1, 1 # Usually\n\n\n\n    for i in range(2, x+1):\n\n        if i not in broken: # 階段が壊れてない場合...\n\n            dp[i] = (dp[i-1] + dp[i-2]) % (10**9+7) # -1段目と-2段目の合計\n\n    print((dp[-1]))\n\n\n\nptn_num(n)\n", "generated_code": "import sys\n\ninput = sys.stdin.readline\n\n\n\nn, m = list(map(int, input().split()))\n\nbroken = set([int(eval(input())) for _ in range(m)]) # ここが'list'だとPypyでも通らない\n\n\n\ndef ptn_num(x): # 'x'stepまでのパターン数\n\n    dp = [0] * (x+1) # DP枠_including step'0'\n\n    if 1 in broken: # 固定部分_in case, step'1' broken \n\n        dp[:2] = 1, 0\n\n    else:\n\n        dp[:2] = 1, 1 # 固定部分_Usually\n\n\n\n    for i in range(2, x+1):\n\n        if i not in broken: # 階段が壊れてない場合...\n\n            dp[i] = (dp[i-1] + dp[i-2]) % (10**9+7) # -1段目と-2段目の合計\n\n    print((dp[-1]))\n\n\n\nptn_num(n)", "score": 1.0, "codebleu": 0.9636621435803967, "crystalbleu": 1.0, "codebertscore": 0.97, "codescore": 0.9937402009963989, "surfaceSim": 1.0, "abs_surfaceSim_minus_score": 0.0}
{"golden_code": "import sys\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\nreadlines = sys.stdin.readlines\n\n\n\ndef main():\n\n    S = readline().strip()\n\n    T = readline().strip()\n\n\n\n    idx_in_S = []\n\n    last_idx = 0\n\n    for t in T:\n\n        t_idx = S.find(t, last_idx) + 1\n\n        if t_idx:\n\n            idx_in_S.append(t_idx)\n\n            last_idx = t_idx\n\n        else:\n\n            t_idx = S.find(t, 0, last_idx) + 1\n\n            if not t_idx:\n\n                print((-1))\n\n                exit()\n\n            else:\n\n                idx_in_S.append(t_idx)\n\n                last_idx = t_idx\n\n\n\n    \n\n    rep = 0\n\n    for i in range(len(T) - 1):\n\n        if idx_in_S[i] < idx_in_S[i+1]:\n\n            continue\n\n        else:\n\n            rep += 1\n\n\n\n    ans = len(S) * rep + idx_in_S[-1]\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "generated_code": "# S.find()の部分を高速化する\n\nfrom collections import defaultdict\n\nfrom bisect import bisect_right\n\nimport sys\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\nreadlines = sys.stdin.readlines\n\n\n\ndef main():\n\n    S = readline().strip()\n\n    T = readline().strip()\n\n\n\n    S_idx = defaultdict(list)\n\n    for i, s in enumerate(S):\n\n        S_idx[s].append(i)\n\n    \n\n    rep = 0\n\n    last_idx = -1\n\n    for t in T:\n\n        t_idx_list = S_idx[t]\n\n        if t_idx_list:\n\n            t_idx = bisect_right(t_idx_list, last_idx)\n\n            if t_idx < len(t_idx_list):\n\n                last_idx = t_idx_list[t_idx]\n\n            else:\n\n                last_idx = t_idx_list[0]\n\n                rep += 1\n\n        else:\n\n            print((-1))\n\n            exit()\n\n    \n\n    ans = len(S) * rep + last_idx + 1\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "score": 1.0, "codebleu": 0.44129293567913513, "crystalbleu": 0.402424502714305, "codebertscore": 0.87, "codescore": 0.023220349103212357, "surfaceSim": 0.7405557176196033, "abs_surfaceSim_minus_score": 0.25944428238039674}
{"golden_code": "N, D = list(map(int, input().split()))\n\ncount = 0\n\nfor i in range(N):\n\n    a, b = list(map(int, input().split()))\n\n    if (a**2 + b**2) <= D**2:\n\n        count += 1\n\nprint(count)\n", "generated_code": "N, D = list(map(int, input().split()))\n\ncount = 0\n\nfor i in range(N):\n\n    a, b = list(map(int, input().split()))\n\n    if (a*a + b*b) <= D*D:\n\n        count += 1\n\nprint(count)\n", "score": 1.0, "codebleu": 0.8234237254204527, "crystalbleu": 0.8235513743313198, "codebertscore": 0.96, "codescore": 0.5806714296340942, "surfaceSim": 0.9306086445163188, "abs_surfaceSim_minus_score": 0.06939135548368125}
{"golden_code": "import sys\n\ninput = sys.stdin.readline\n\n \n\ns = input().rstrip()\n\nk = int(eval(input()))\n\n    \n\ndef check_count(s):\n\n    cnt_list = [1]\n\n    cnt = 1\n\n    for i in range(1, len(s)):\n\n        if s[i-1] == s[i]:\n\n            cnt_list[-1] += 1\n\n        else:\n\n            cnt_list.append(1)\n\n    return cnt_list\n\n\n\ndef calc_ans(cnt_list, k):\n\n    _ans = 0\n\n    for c in cnt_list:\n\n        _ans += c//2\n\n    return(_ans * k)\n\n\n\nif len(s)==1:\n\n    ans = k//2\n\nelse:\n\n    cnt_list = check_count(s)\n\n    if len(cnt_list)==1:\n\n        ans = (len(s)*k)//2\n\n    else:\n\n        ans = calc_ans(cnt_list, k)\n\n        if s[0]==s[-1]:\n\n            if cnt_list[0]%2==1 and cnt_list[-1]%2==1:\n\n                ans += k - 1\n\n\n\nprint(ans)", "generated_code": "import sys\n\ninput = sys.stdin.readline\n\n \n\ns = input().rstrip()\n\nk = int(eval(input()))\n\n\n\ndef check_count(s):\n\n    cnt_list = []\n\n    cnt = 1\n\n    for i in range(1, len(s)):\n\n        if s[i-1] == s[i]:\n\n            cnt += 1\n\n        else:\n\n            cnt_list.append(cnt)\n\n            cnt = 1\n\n    if cnt>1:\n\n        cnt_list.append(cnt)\n\n    return cnt_list\n\n\n\ndef calc_ans(cnt_list, k):\n\n    _ans = 0\n\n    for c in cnt_list:\n\n        _ans += c//2\n\n    return(_ans * k)\n\n\n\nif len(s)==1:\n\n    ans = k//2\n\nelse:\n\n    cnt_list = check_count(s)\n\n    if len(cnt_list)==1:\n\n        ans = (len(s)*k)//2\n\n    else:\n\n        ans = calc_ans(cnt_list, k)\n\n        if s[0]==s[-1]:\n\n            if cnt_list[0]%2==1 and cnt_list[-1]%2==1:\n\n                ans += k - 1\n\n\n\nprint(ans)", "score": 1.0, "codebleu": 0.8367322296865563, "crystalbleu": 0.8992156272013391, "codebertscore": 0.97, "codescore": 0.9938470721244812, "surfaceSim": 0.9593537804226748, "abs_surfaceSim_minus_score": 0.04064621957732517}
{"golden_code": "from sys import stdin,stdout\n\n\n\nif __name__==\"__main__\":\n\n    n=int(stdin.readline())\n\n\n\n    a=[int(x) for x in stdin.readline().split()]\n\n    b=[int(x) for x in stdin.readline().split()]\n\n\n\n    cnt=0\n\n\n\n    for i in range(n):\n\n        if(a[i]>=b[i]):\n\n            cnt+=b[i]\n\n        else:\n\n            cnt+=a[i]\n\n            d=b[i]-a[i]\n\n            cnt+=min(a[i+1],d)\n\n            if(d>a[i+1]):\n\n                a[i+1]=0\n\n            else: a[i+1]-=d\n\n            \n\n    stdout.write(str(cnt)+\"\\n\")\n", "generated_code": "n = int(eval(input()))\n\nA = list(map(int, input().split()))\n\nB = list(map(int, input().split()))\n\na1 = sum(A)\n\nfor i in range(n):\n\n  b = B[i]\n\n  if A[i] >= b:A[i] -= b\n\n  else:\n\n    if A[i+1]+A[i] >= b:\n\n      A[i+1] = A[i+1]+A[i]-b\n\n      A[i] = 0\n\n    else:A[i], A[i+1] = 0, 0\n\na2 = sum(A)\n\nprint((a1-a2))", "score": 1.0, "codebleu": 0.24673195657983402, "crystalbleu": 0.13273061840367759, "codebertscore": 0.79, "codescore": 0.15545782446861267, "surfaceSim": 0.6559657777092647, "abs_surfaceSim_minus_score": 0.3440342222907353}
{"golden_code": "import fractions\n\nimport sys\n\ninput = sys.stdin.readline\n\n\n\nN,M=list(map(int,input().split()))\n\na = list(map(int, input().split()))\n\n\n\n\n\nlcm = a[0]\n\nfor i in range(1, N):\n\n    g= fractions.gcd(lcm, a[i])\n\n    lcm = lcm * a[i] // g\n\n\n\n\n\ng=a[0]\n\nfor i in range(N):\n\n    g=fractions.gcd(g,a[i])\n\n\n\nfor i in range(N):\n\n    if (a[i]//g)%2==0:\n\n        lcm=0\n\n        break    \n\n    \n\n    \n\nans=0\n\nl=lcm//2\n\nif l:\n\n    ans=(M//l)-(M//(l+l))\n\nprint(ans)\n\n\n", "generated_code": "import sys\n\ninput = sys.stdin.readline\n\n\n\ndef I(): return int(eval(input()))\n\ndef MI(): return list(map(int, input().split()))\n\ndef LI(): return list(map(int, input().split()))\n\n\n\n\"\"\"\n\n2X = ak * (2p+1)\n\n基本的には最小公倍数/2を基本とし，これの奇数倍か．\n\n\n\nX  = (ak//2) * (2p+1)\n\nと書ける．第二項が奇数なので，各akが2で割り切れれう回数が同じでなければならない\n\na=[2,4]だと無理\n\n\"\"\"\n\ndef main():\n\n    from math import gcd\n\n    N,M=MI()\n\n    A=LI()\n\n    \n\n    def count(X):\n\n        cnt=0\n\n        while X%2==0:\n\n            cnt+=1\n\n            X=X//2\n\n        return cnt\n\n    \n\n    C=count(A[0])\n\n    for i in range(1,N):\n\n        if count(A[i])!=C:\n\n            print((0))\n\n            exit()\n\n            \n\n    lca=1\n\n    for i in range(N):\n\n        g=gcd(lca,A[i])\n\n        lca=(lca*A[i])//g\n\n        \n\n    lca2=lca//2\n\n    ans=M//lca2 - M//lca\n\n    \n\n    print(ans)\n\n    \n\n            \n\n    \n\n\n\nmain()\n", "score": 1.0, "codebleu": 0.3153728879169681, "crystalbleu": 0.3059824573411566, "codebertscore": 0.78, "codescore": 0.9903315305709839, "surfaceSim": 0.6365803445660418, "abs_surfaceSim_minus_score": 0.36341965543395816}
{"golden_code": "#                         author:  kagemeka \n\n#                         created: 2019-11-08 14:51:29(JST)\n\n## internal modules\n\nimport sys\n\n# import collections\n\n# import math\n\n# import string\n\n# import bisect\n\n# import re\n\n# import itertools\n\nimport statistics\n\n# import functools\n\n# import operator\n\n## external modules\n\n# import scipy.special   # if use comb function on AtCoder, \n\n# import scipy.misc      # select scipy.misc.comb (old version) \n\n\n\ndef main():\n\n    n, *a = (int(x) for x in sys.stdin.read().split())\n\n    \n\n    for i in range(n):\n\n        a[i] -= (i + 1)\n\n\n\n    if n % 2 != 0:\n\n        b = statistics.median(a)\n\n    else:\n\n        if a.count(statistics.median_high(a)) >= a.count(statistics.median_low(a)):\n\n            b = statistics.median_high(a)\n\n        else:\n\n            b = statistics.median_low(a)\n\n    \n\n    ans = sum([abs(a[i] - b) for i in range(n)])\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    # execute only if run as a script\n\n    main()\n\n\n\n\n", "generated_code": "import sys\n\n\n\nn, *a = list(map(int, sys.stdin.read().split()))\n\n\n\ndef main():\n\n    for i in range(n):\n\n        a[i] -= (i + 1)\n\n    a.sort()\n\n    b = a[n // 2]\n\n    res = 0\n\n    for i in range(n):\n\n        res += abs(a[i] - b)\n\n    \n\n    return res\n\n    \n\nif __name__ == '__main__':\n\n    ans = main()\n\n    print(ans)", "score": 1.0, "codebleu": 0.2878900710030735, "crystalbleu": 0.2880074381064377, "codebertscore": 0.75, "codescore": 0.018949206918478012, "surfaceSim": 0.7541678179976052, "abs_surfaceSim_minus_score": 0.24583218200239476}
{"golden_code": "l,r=list(map(int,input().split()))\n\ns=list(range(l,r+1))[:2019]\n\nprint((min(i*j%2019for i in s for j in s if i<j)))", "generated_code": "l,r=list(map(int,input().split()));s=list(range(l,r+1))[:673];print((min(i*j%2019for i in s for j in s if i<j)))", "score": 1.0, "codebleu": 0.8656298019485317, "crystalbleu": 0.0, "codebertscore": 0.97, "codescore": 0.9778019785881042, "surfaceSim": 0.9739130434782608, "abs_surfaceSim_minus_score": 0.026086956521739202}
{"golden_code": "a, b, c, x, y = list(map(int, input().split()))\n\nans = float('inf')\n\n\n\nfor i in range(200005):\n\n    tmp = i * 2 * c\n\n    tmp += max(0, x-i) * a\n\n    tmp += max(0, y-i) * b\n\n    ans = min(ans, tmp)\n\n\n\nprint(ans)", "generated_code": "a, b, c, x, y = list(map(int, input().split()))\n\nans = float('inf')\n\n\n\nfor i in range(100005):\n\n    tmp = i * 2 * c\n\n    tmp += max(0, x-i) * a\n\n    tmp += max(0, y-i) * b\n\n    ans = min(ans, tmp)\n\n\n\nprint(ans)", "score": 1.0, "codebleu": 0.9661796765376377, "crystalbleu": 0.943530344863199, "codebertscore": 0.99, "codescore": 0.9937642812728882, "surfaceSim": 0.9976190476190476, "abs_surfaceSim_minus_score": 0.0023809523809523725}
{"golden_code": "import sys\n\ninput = sys.stdin.readline\n\nsys.setrecursionlimit(10**7)\n\nINF = 10**10\n\nMOD = 10**9 + 7\n\nX = int(eval(input()))\n\nfor i in range(1000):\n\n    for j in range(-1000,1000):\n\n        #print (i**5 - j**5)\n\n        if i**5 - j**5 == X:\n\n            print((i,j))\n\n            exit()\n\n   ", "generated_code": "import sys\n\ninput = sys.stdin.readline\n\nsys.setrecursionlimit(10**7)\n\nINF = 10**10\n\nMOD = 10**9 + 7\n\nX = int(eval(input()))\n\nMAX_X = 10**9\n\nn = 0\n\nwhile(1):\n\n    n+=1\n\n    if n**5 - (n-1)**5 > MAX_X:\n\n        break\n\nfor i in range(n):\n\n    for j in range(-n+1,n-1):\n\n        if i**5 - j**5 == X:\n\n            print((i,j))\n\n            exit()\n\n   ", "score": 1.0, "codebleu": 0.6920880411136854, "crystalbleu": 0.5821554665807663, "codebertscore": 0.92, "codescore": 0.8389092087745667, "surfaceSim": 0.8190306803023566, "abs_surfaceSim_minus_score": 0.1809693196976434}
{"golden_code": "n = int(eval(input()))\n\nl = list(map(int, input().split()))\n\nprint((sum(l[i]<l[i+1]<l[i+2] or l[i]>l[i+1]>l[i+2] for i in range(n-2))))", "generated_code": "n=int(eval(input()))\n\nl=list(map(int,input().split()))\n\na=0\n\nfor i in range(n-2):\n\n  p,q,r=l[i:i+3]\n\n  if p<q<r or r<q<p: a+=1\n\nprint(a)", "score": 1.0, "codebleu": 0.3181606641624132, "crystalbleu": 0.0, "codebertscore": 0.87, "codescore": 0.9685288071632385, "surfaceSim": 0.6026583710407241, "abs_surfaceSim_minus_score": 0.39734162895927594}
{"golden_code": "n = int(eval(input()))\n\ns = input().split()\n\ns = set(s)\n\nprint(('Four' if len(s) == 4 else 'Three'))", "generated_code": "n = int(eval(input()))\n\ns = input().split()\n\nprint(('Four' if len(set(s)) == 4 else 'Three'))", "score": 1.0, "codebleu": 0.6072373739061012, "crystalbleu": 0.0, "codebertscore": 0.98, "codescore": 0.9937594532966614, "surfaceSim": 0.9299999999999999, "abs_surfaceSim_minus_score": 0.07000000000000006}
{"golden_code": "import sys\n\nif sys.argv[-1] == 'ONLINE_JUDGE':\n\n    import os\n\n    import re\n\n    with open(__file__) as f:\n\n        source = f.read().split('###''nbacl')\n\n    for s in source[1:]:\n\n        s = re.sub(\"'''.*\", '', s)\n\n        sp = s.split(maxsplit=1)\n\n        if os.path.dirname(sp[0]):\n\n            os.makedirs(os.path.dirname(sp[0]), exist_ok=True)\n\n        with open(sp[0], 'w') as f:\n\n            f.write(sp[1])\n\n    from nbmodule import cc\n\n    cc.compile()\n\nimport numpy as np\n\nfrom numpy import int64\n\nfrom nbmodule import solve\n\n\n\n\n\nf = open(0)\n\nN, K = [int(x) for x in f.readline().split()]\n\nA = np.fromstring(f.read(), dtype=int64, sep=' ')\n\nans = solve(N, K, A)\n\nprint(ans)\n\n\n\n'''\n\n###nbacl nbmodule.py\n\nimport numpy as np\n\nfrom numpy import int64\n\nfrom numba import njit\n\nfrom numba.types import i8\n\nfrom numba.pycc import CC\n\nimport nbacl.segtree as seg\n\ncc = CC('my_module')\n\n\n\n\n\n@cc.export('solve', (i8, i8, i8[:]))\n\n@njit\n\ndef solve(N, K, A):\n\n    dp = np.zeros(300_001, dtype=int64)\n\n    d = seg.segtree(dp, max, 0)\n\n    for i in range(N):\n\n        x = seg.prod(d, max, (A[i] - K) if A[i] > K else 0, (A[i] + K + 1) if A[i] + K < 300_000 else 300_001) + 1\n\n        seg.set(d, max, A[i], x)\n\n    return seg.all_prod(d)\n\n\n\n\n\nif __name__ == '__main__':\n\n    cc.compile()\n\n###nbacl nbacl/segtree.py\n\nimport numpy as np\n\nfrom numba import njit\n\nfrom numba.types import i8\n\n\n\n\n\n@njit\n\ndef ceil_pow2(n):\n\n    x = 0\n\n    while (1 << x) < n:\n\n        x += 1\n\n    return x\n\n\n\n\n\n@njit\n\ndef segtree(a, op, e):\n\n    log = ceil_pow2(a.shape[0])\n\n    size = 1 << log\n\n    d = np.empty(size * 2, dtype=a.dtype)\n\n    d[size:size + len(a)] = a\n\n    d[size + len(a):] = e\n\n    # e\n\n    d[0] = e\n\n    for i in range(size - 1, 0, -1):\n\n        update(d, i, op)\n\n    return d\n\n\n\n\n\n@njit\n\ndef update(d, k, op):\n\n    d[k] = op(d[2 * k], d[2 * k + 1])\n\n\n\n\n\n@njit\n\ndef set(d, op, p, x):\n\n    p += d.shape[0] // 2\n\n    d[p] = x\n\n    while p > 1:\n\n        p >>= 1\n\n        update(d, p, op)\n\n\n\n\n\n@njit\n\ndef get(d, p):\n\n    return d[p + d.shape[0] // 2]\n\n\n\n\n\n@njit\n\ndef prod(d, op, left, right):\n\n    size = d.shape[0] // 2\n\n    sml = d[0]\n\n    smr = d[0]\n\n    left += size\n\n    right += size\n\n\n\n    while left < right:\n\n        if left & 1:\n\n            sml = op(sml, d[left])\n\n            left += 1\n\n        if right & 1:\n\n            right -= 1\n\n            smr = op(d[right], smr)\n\n        left >>= 1\n\n        right >>= 1\n\n\n\n    return op(sml, smr)\n\n\n\n\n\n@njit\n\ndef all_prod(d):\n\n    return d[1]\n\n\n\n'''\n", "generated_code": "import sys\n\nif sys.argv[-1] == 'ONLINE_JUDGE':\n\n    import os\n\n    import re\n\n    with open(__file__) as f:\n\n        source = f.read().split('###''nbacl')\n\n    for s in source[1:]:\n\n        s = re.sub(\"'''.*\", '', s)\n\n        sp = s.split(maxsplit=1)\n\n        if os.path.dirname(sp[0]):\n\n            os.makedirs(os.path.dirname(sp[0]), exist_ok=True)\n\n        with open(sp[0], 'w') as f:\n\n            f.write(sp[1])\n\n    from nbmodule import cc\n\n    cc.compile()\n\nimport numpy as np\n\nfrom numpy import int64\n\nfrom nbmodule import solve\n\n\n\n\n\nf = open(0)\n\nN, K = [int(x) for x in f.readline().split()]\n\nA = np.fromstring(f.read(), dtype=int64, sep=' ')\n\nans = solve(N, K, A)\n\nprint(ans)\n\n\n\n'''\n\n###nbacl nbmodule.py\n\nimport numpy as np\n\nfrom numpy import int64\n\nfrom numba import njit\n\nfrom numba.types import i8\n\nfrom numba.pycc import CC\n\nimport nbacl.segtree as seg\n\ncc = CC('nbmodule')\n\n\n\n\n\n@cc.export('solve', (i8, i8, i8[:]))\n\n@njit\n\ndef solve(N, K, A):\n\n    dp = np.zeros(300_001, dtype=int64)\n\n    d = seg.segtree(dp, max, 0)\n\n    for i in range(N):\n\n        x = seg.prod(d, max, (A[i] - K) if A[i] > K else 0, (A[i] + K + 1) if A[i] + K < 300_000 else 300_001) + 1\n\n        seg.set(d, max, A[i], x)\n\n    return seg.all_prod(d)\n\n\n\n\n\nif __name__ == '__main__':\n\n    cc.compile()\n\n###nbacl nbacl/segtree.py\n\nimport numpy as np\n\nfrom numba import njit\n\nfrom numba.types import i8\n\n\n\n\n\n@njit\n\ndef ceil_pow2(n):\n\n    x = 0\n\n    while (1 << x) < n:\n\n        x += 1\n\n    return x\n\n\n\n\n\n@njit\n\ndef segtree(a, op, e):\n\n    log = ceil_pow2(a.shape[0])\n\n    size = 1 << log\n\n    d = np.empty(size * 2, dtype=a.dtype)\n\n    d[size:size + len(a)] = a\n\n    d[size + len(a):] = e\n\n    # e\n\n    d[0] = e\n\n    for i in range(size - 1, 0, -1):\n\n        update(d, i, op)\n\n    return d\n\n\n\n\n\n@njit\n\ndef update(d, k, op):\n\n    d[k] = op(d[2 * k], d[2 * k + 1])\n\n\n\n\n\n@njit\n\ndef set(d, op, p, x):\n\n    p += d.shape[0] // 2\n\n    d[p] = x\n\n    while p > 1:\n\n        p >>= 1\n\n        update(d, p, op)\n\n\n\n\n\n@njit\n\ndef get(d, p):\n\n    return d[p + d.shape[0] // 2]\n\n\n\n\n\n@njit\n\ndef prod(d, op, left, right):\n\n    size = d.shape[0] // 2\n\n    sml = d[0]\n\n    smr = d[0]\n\n    left += size\n\n    right += size\n\n\n\n    while left < right:\n\n        if left & 1:\n\n            sml = op(sml, d[left])\n\n            left += 1\n\n        if right & 1:\n\n            right -= 1\n\n            smr = op(d[right], smr)\n\n        left >>= 1\n\n        right >>= 1\n\n\n\n    return op(sml, smr)\n\n\n\n\n\n@njit\n\ndef all_prod(d):\n\n    return d[1]\n\n\n\n'''\n", "score": 1.0, "codebleu": 0.9965890327851343, "crystalbleu": 0.9906257119998134, "codebertscore": 1.0, "codescore": 0.983805239200592, "surfaceSim": 0.9993983152827919, "abs_surfaceSim_minus_score": 0.0006016847172081174}
{"golden_code": "import numpy as np\n\n\n\n(N,M) = list(map(int,input().split()))\n\nB = np.ones(M,dtype=np.int)\n\n\n\nfor _ in range(N):\n\n    A = np.array(list(map(int,input().split())))[1:]\n\n    for i in range(M):\n\n        if not i+1 in A:\n\n            B[i] = 0\n\nprint((B.sum()))", "generated_code": "(N,M) = list(map(int,input().split()))\n\nr = int(-1)\n\nfor i in range(N):\n\n  A = list(map(int,input().split()))\n\n  A.pop(0)\n\n  c = 0\n\n  for a in A:\n\n    c |= (1 << (a-1))\n\n  r &= c\n\n\n\nans = sum([(r>>n)&1 for n in range(M)])\n\nprint(ans)", "score": 1.0, "codebleu": 0.32082146487051477, "crystalbleu": 0.24786981281288478, "codebertscore": 0.83, "codescore": 0.8829721212387085, "surfaceSim": 0.46951871657754013, "abs_surfaceSim_minus_score": 0.5304812834224599}
{"golden_code": "# -*- coding: utf-8 -*-\n\nfrom collections import deque\n\ndef inpl(): return list(map(int, input().split()))\n\n\n\nS = eval(input())\n\nA = set(\"ATCG\")\n\nans = 0\n\nmode = 0\n\nfor i, s in enumerate(S):\n\n    if s in A:\n\n        if mode == 0:\n\n            mode = 1\n\n            start = i\n\n    else:\n\n        if mode == 1:\n\n            ans = max(i - start, ans)\n\n            mode = 0\n\nif mode == 1:\n\n    ans = max(len(S) - start, ans)\n\nprint(ans)", "generated_code": "def inpl(): return list(map(int, input().split()))\n\nS = eval(input())\n\nC = set(\"ACGT\")\n\n\n\ntmp = 0\n\nans = 0\n\n\n\nfor s in S:\n\n    if s in C:\n\n        tmp += 1\n\n    else:\n\n        ans = max(ans, tmp)\n\n        tmp = 0\n\nans = max(ans, tmp)\n\nprint(ans)", "score": 1.0, "codebleu": 0.36099008835346236, "crystalbleu": 0.33068892821961493, "codebertscore": 0.83, "codescore": 0.22359389066696167, "surfaceSim": 0.6944444444444444, "abs_surfaceSim_minus_score": 0.3055555555555556}
{"golden_code": "import numpy as np\n\n\n\nn,l = [int(x) for x in input().split()] \n\nx = np.arange(l,l+n)\n\ny = np.abs(x)\n\nx = np.delete(x, np.argmin(y))\n\nprint((np.sum(x)))", "generated_code": "N, L = list(map(int, input().split()))\n\napples = [i for i in range(L, L+N)]\n\napples_abs = [abs(i) for i in apples]\n\nmin_idx = apples_abs.index(min(apples_abs))\n\n\n\nprint((sum(apples) - apples[min_idx]))", "score": 1.0, "codebleu": 0.18772444172970487, "crystalbleu": 0.0, "codebertscore": 0.79, "codescore": 0.2972283363342285, "surfaceSim": 0.5451907131011609, "abs_surfaceSim_minus_score": 0.45480928689883915}
{"golden_code": "while True:\n\n    n, x = [int(i) for i in input().split()]\n\n\n\n    if n == x == 0:\n\n        break\n\n\n\n    count = 0\n\n    for s in range(1, n - 1):\n\n        for m in range(s + 1, n):\n\n            for e in range(m + 1, n + 1):\n\n                if x == sum([s, m, e]):\n\n                    count += 1\n\n\n\n    print(count)", "generated_code": "while True:\n\n    n, x = [int(i) for i in input().split()]\n\n\n\n    if n == x == 0:\n\n        break\n\n\n\n    count = 0\n\n    for s in range(1, n - 1):\n\n        for m in range(s + 1, n):\n\n            for e in range(m + 1, n + 1):\n\n                if x == s+m+e:\n\n                    count += 1\n\n\n\n    print(count)", "score": 1.0, "codebleu": 0.8777419799918909, "crystalbleu": 0.0, "codebertscore": 0.99, "codescore": 0.8695460557937622, "surfaceSim": 0.9639296593741347, "abs_surfaceSim_minus_score": 0.03607034062586534}
{"golden_code": "import math\n\nimport numpy as np\n\n\n\nn, d = list(map(int, input().split()))\n\n\n\nx = np.zeros([n, d])\n\n\n\nfor i in range(n):\n\n    line = list(map(int, input().split()))\n\n    for j in range(d):\n\n        x[i, j] = line[j]\n\n\n\ncnt = 0\n\n\n\nfor i in range(n):\n\n    for j in range(i+1, n):\n\n        xx = (x[i] - x[j]) ** 2\n\n        dist = math.sqrt(xx.sum())\n\n        if dist % 1 == 0:\n\n            cnt += 1\n\n\n\nprint(cnt)", "generated_code": "import math\n\n\n\nn, d = list(map(int, input().split()))\n\n\n\nx = [list(map(int, input().split())) for i in range(n)]\n\n\n\ncnt = 0\n\n\n\nfor i in range(n):\n\n    for j in range(i+1, n):\n\n        dist = 0\n\n        for k in range(d):\n\n            dist += (x[i][k] - x[j][k]) ** 2\n\n        if math.sqrt(dist).is_integer():\n\n            cnt += 1\n\n\n\nprint(cnt)", "score": 1.0, "codebleu": 0.4363713868038893, "crystalbleu": 0.5314052221305681, "codebertscore": 0.92, "codescore": 0.8638122081756592, "surfaceSim": 0.735702614379085, "abs_surfaceSim_minus_score": 0.264297385620915}
{"golden_code": "N, K, C = list(map(int, input().split()))\n\nS = eval(input())\n\n\n\nlatest = [None]*K\n\ni = len(S)+C\n\nfor j in range(K-1, -1, -1):\n\n  i = S.rindex(\"o\", 0, i-C)\n\n  latest[j] = i\n\n\n\nif i<=C or \"o\" not in S[:i-C]:\n\n  i = -C-1\n\n  for j in latest:\n\n    i = S.index(\"o\", i+C+1)\n\n    if i == j:\n\n      print((i+1))\n", "generated_code": "def solve():\n\n  N, K, C = list(map(int, input().split()))\n\n  workable = [i for i, s in enumerate(eval(input())) if s==\"o\"]\n\n  if len(workable) == K:\n\n    return workable\n\n    \n\n  prev = workable[-1]\n\n  latest = {prev}\n\n  i = len(workable)-1\n\n  while i > 0:\n\n    i -= 1\n\n    if prev - workable[i] > C:\n\n      latest.add(workable[i])\n\n      prev = workable[i]\n\n      if len(latest) > K:\n\n        return []\n\n  must = []\n\n  i = -1\n\n  prev = -C-1\n\n  while i < len(workable)-1:\n\n    i += 1\n\n    if workable[i] - prev > C:\n\n      if workable[i] in latest:\n\n        must.append(workable[i])\n\n      prev = workable[i]\n\n  return must\n\n\n\nfor i in solve():\n\n  print((i+1))", "score": 1.0, "codebleu": 0.26014677465408986, "crystalbleu": 0.21982840792429317, "codebertscore": 0.79, "codescore": 0.9932172894477844, "surfaceSim": 0.532051282051282, "abs_surfaceSim_minus_score": 0.46794871794871795}
{"golden_code": "N=int(eval(input()))\n\n\n\nS=[[-1]*N for _ in range(N)]\n\nfor i in range(N):\n\n  A=int(eval(input()))\n\n  for _ in range(A):\n\n    x, y=list(map(int, input().split()))\n\n    S[i][x-1]=y\n\nans=0   \n\nfor s in range(2**N):\n\n  ok=True\n\n  for i in range(N):\n\n    #正直者について見ていく\n\n    if (s>>i&1)==1:\n\n      for j in range(N):\n\n        #それぞれ正直者の証言が矛盾ないか\n\n        if S[i][j]!=-1 and (s>>j&1)!=S[i][j]:\n\n          ok=False\n\n  if ok:\n\n    ans=max(ans, bin(s).count(\"1\"))\n\n    \n\nprint(ans)\n", "generated_code": "N=int(eval(input()))\n\n\n\nA=[[-1]*N for _ in range(N)]\n\nfor i in range(N):\n\n  a=int(eval(input()))\n\n  for j in range(a):\n\n    x,y=list(map(int, input().split()))\n\n    A[i][x-1]=y\n\n#正直者が正直者に不親切と言われていない\n\n#→正直ものが不親切を正直者と言っていないか\n\nans=0\n\nfor i in range(2**N):\n\n  ok=True\n\n  for j in range(N):\n\n    if (i>>j&1)==1:\n\n      for k in range(N):\n\n        if A[j][k]!=-1 and (i>>k&1)!=A[j][k]:\n\n          ok=False\n\n  if ok:\n\n    ans=max(ans, bin(i).count(\"1\"))\n\n  \n\nprint(ans)", "score": 1.0, "codebleu": 0.6160689630520192, "crystalbleu": 0.7293791569454686, "codebertscore": 0.91, "codescore": 0.833073079586029, "surfaceSim": 0.9797008547008548, "abs_surfaceSim_minus_score": 0.020299145299145227}
{"golden_code": "import math\n\n\n\nN = int(eval(input()))\n\nans = 0\n\n\n\nans =math.factorial(N) % (10**9 +7)\n\n\n\nprint(ans)", "generated_code": "N = int(eval(input()))\n\npower = 1\n\n\n\nfor i in range(N):\n\n    power = ((i+1) * power) % 1000000007\n\n\n\nprint(power)", "score": 1.0, "codebleu": 0.257377670210069, "crystalbleu": 0.0, "codebertscore": 0.78, "codescore": 0.17444808781147003, "surfaceSim": 0.5536179073399272, "abs_surfaceSim_minus_score": 0.4463820926600728}
{"golden_code": "MOD = 1000000007\n\n\n\n\n\nS = int(eval(input()))\n\n\n\n#dp[i]:=i桁の数列で条件を満たすものの数\n\ndp = [0]*(S+1)\n\n\n\nfor i in range(3,S+1):\n\n    #dp[i]=sum(dp[0],..,dp[i-3])+1\n\n    for j in range(i-3+1):\n\n        dp[i] = (dp[i]+dp[j])%MOD\n\n    dp[i] = (dp[i]+1)%MOD\n\n\n\nprint((dp[S]))", "generated_code": "MOD = 1000000007\n\n\n\n\n\nS = int(eval(input()))\n\n\n\n#dp[i]:=i桁の数列で条件を満たすものの数\n\ndp = [0]*(S+1)\n\ndp_sum = [0]*(S+1)\n\n\n\nfor i in range(3,S+1):\n\n    #dp[i]=sum(dp[0],..,dp[i-3])+1\n\n    \n\n    dp[i] = (dp_sum[i-3]+1)%MOD\n\n    dp_sum[i] = (dp[i]+dp_sum[i-1])%MOD\n\n\n\nprint((dp[S]))", "score": 1.0, "codebleu": 0.5993420564438696, "crystalbleu": 0.7303934818254109, "codebertscore": 0.97, "codescore": 0.960956335067749, "surfaceSim": 0.9216417910447761, "abs_surfaceSim_minus_score": 0.07835820895522394}
{"golden_code": "import numpy as np\n\n\n\nN, M = list(map(int, input().split()))\n\n\n\nlike_total = np.zeros(M)\n\ncnt = 0\n\nfor _ in range(N):\n\n    l = [v for v in map(int, input().split())]\n\n    #print(l)\n\n    for i in range(1, l[0]+1, 1):\n\n        like_total[l[i]-1] += 1\n\n\n\n#print(like_total, N)\n\n#print(like_total[4], like_total[9], like_total[-1])\n\nans = len(np.where(like_total==N)[0])\n\n\n\nprint(ans)\n", "generated_code": "N, M = list(map(int, input().split()))\n\n\n\nlike_total = [0]*M\n\ncnt = 0\n\nfor _ in range(N):\n\n    l = list(map(int, input().split()))\n\n    for i in range(1, l[0]+1, 1):\n\n        like_total[l[i]-1] += 1\n\n\n\nfor v in like_total:\n\n    cnt += v==N\n\nprint(cnt)\n", "score": 1.0, "codebleu": 0.47576170182861593, "crystalbleu": 0.5979933876009014, "codebertscore": 0.9, "codescore": 0.858599841594696, "surfaceSim": 0.796010498687664, "abs_surfaceSim_minus_score": 0.20398950131233595}
{"golden_code": "H, W = list(map(int, input().split()))\n\nimport numpy as np\n\nGrid = np.array([[0 if x == '.' else -1 for x in eval(input())] for _ in range(H)],dtype='int64')\n\n\n\ndef solveMase(Grid, start, goal): #bfsで迷路を解き、スタート-ゴール間の最低必要白マス数を返す\n\n    seen = {start}\n\n    V = [start]\n\n    while len(V) != 0: #bfs\n\n        v = V.pop(0)\n\n        if v == goal:\n\n            return Grid[goal]\n\n        #移動先nvをリストにまとめる\n\n        y,x = v\n\n        nV = []\n\n        if x > 0: nV.append((y,x-1))\n\n        if y > 0: nV.append((y-1,x))\n\n        if x < W-1: nV.append((y,x+1))\n\n        if y < H-1: nV.append((y+1,x))\n\n        #bfs\n\n        for nv in nV:\n\n            if Grid[nv] == -1 or nv in seen:\n\n                continue\n\n            Grid[nv] = Grid[v] + 1\n\n            V.append(nv)\n\n            seen.add(nv)\n\n    return 0\n\n\n\nwhite = len(Grid[Grid == 0])-1\n\nnes_white = solveMase(Grid, (0,0), (H-1,W-1))\n\nprint((white-nes_white if nes_white > 0 else -1))", "generated_code": "from collections import deque, Counter\n\n\n\ndef main():\n\n    with open(0) as f:\n\n        H, W = list(map(int, f.readline().split()))\n\n        maze = [list(line) for line in f.readlines()]\n\n\n\n    rank = [[None]*W for _ in range(H)]\n\n    rank[0][0] = 0\n\n    #bfs\n\n    reserved = deque([(0,0)])\n\n    while len(reserved) > 0:\n\n        x, y = reserved.popleft()\n\n        for u,v in [(s,t) for s,t in [(x-1,y), (x+1,y), (x,y-1), (x,y+1)] if 0<=s<H and 0<=t<W]:\n\n            if rank[u][v] is not None:\n\n                continue\n\n            if maze[u][v] == '.':\n\n                rank[u][v] = rank[x][y] + 1\n\n                reserved.append((u,v))\n\n\n\n    if rank[H-1][W-1] is None:\n\n        print((-1))\n\n    else:\n\n        counter = Counter()\n\n        for line in maze:\n\n            counter.update(line)\n\n        print((counter['.'] - rank[H-1][W-1]-1))\n\n\n\nmain()", "score": 1.0, "codebleu": 0.2135523639128973, "crystalbleu": 0.16933118644278344, "codebertscore": 0.75, "codescore": 0.3531612455844879, "surfaceSim": 0.5665521872179292, "abs_surfaceSim_minus_score": 0.4334478127820708}
{"golden_code": "A,B = list(map(int,input().split()))\n\nj = 0\n\nfor i in range(A,B+1):\n\n  l = list(str(i))\n\n  l_reverse = list(reversed(l))\n\n  if l == l_reverse:\n\n    j += 1\n\nprint(j)", "generated_code": "A, B = list(map(int,input().split()))\n\n\n\nans = 0\n\nfor n in range(A, B+1):\n\n    n = str(n)\n\n    if n == n[::-1]:\n\n        ans += 1\n\nprint(ans)", "score": 1.0, "codebleu": 0.37832943406915276, "crystalbleu": 0.0, "codebertscore": 0.89, "codescore": 0.8830099701881409, "surfaceSim": 0.7340301974448316, "abs_surfaceSim_minus_score": 0.26596980255516844}
{"golden_code": "import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\nN = int(readline())\n\nS = read().split()\n\n\n\nS = sorted(S)\n\nls = [[] for i in range(N + 1)]\n\nmax_num = 0\n\nleft = 0\n\nright = 0\n\nwhile right < N:\n\n    while right < N and S[left] == S[right]:\n\n        right += 1\n\n    if (right  - left) >= max_num:\n\n        ls[right - left].append(S[left].decode())\n\n        max_num = right - left\n\n    left = right\n\n    \n\nprint(('\\n'.join(ls[max_num])))\n", "generated_code": "from collections import Counter\n\n\n\nimport sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\nN = int(readline())\n\nS = read().split()\n\n\n\nres = []\n\nc = Counter(S)\n\nmax_num = c.most_common(1)[0][1]\n\nfor i, j in list(c.items()):\n\n    if j == max_num:\n\n        res.append(i)\n\n        \n\nres.sort()\n\n\n\n        \n\nprint(('\\n'.join(list([x.decode() for x in res]))))\n", "score": 1.0, "codebleu": 0.3220499377044138, "crystalbleu": 0.32804613121326287, "codebertscore": 0.85, "codescore": 0.5324311256408691, "surfaceSim": 0.6030785970302099, "abs_surfaceSim_minus_score": 0.39692140296979006}
{"golden_code": "def main():\n\n    N = int(input())\n\n    A = [int(i) for i in input().split()]\n\n    if N == 1:\n\n        return print(1 if A[0] % 2 == 0 else 2)\n\n    ans = 0\n\n    d = (-1, 0, 1)\n\n    from itertools import product\n\n    for i in product(range(3), repeat=N):\n\n        cur = 1\n\n        for j in range(N):\n\n            cur *= (A[j] + d[i[j]])\n\n        if cur % 2 == 0:\n\n            ans += 1\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "generated_code": "def main():\n\n    N = int(eval(input()))\n\n    A = [int(i) for i in input().split()]\n\n    ans = 3**N\n\n    cnt = len([a for a in A if a % 2 == 0])\n\n    ans -= 2**cnt\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 1.0, "codebleu": 0.27604189956635083, "crystalbleu": 0.24057904577337144, "codebertscore": 0.82, "codescore": 0.018435178324580193, "surfaceSim": 0.5988248572566724, "abs_surfaceSim_minus_score": 0.40117514274332755}
{"golden_code": "import math\n\nx = int(eval(input()))\n\nprint((math.factorial(x) % (10**9 + 7)))", "generated_code": "M = 1000000007\n\nn=int(eval(input()))\n\nf = 1\n\nfor i in range(1, n + 1):  \n\n    f = (f * i) % M \n\nprint(f)", "score": 1.0, "codebleu": 0.21865774537505162, "crystalbleu": 0.0, "codebertscore": 0.77, "codescore": 0.0810130313038826, "surfaceSim": 0.5831447963800904, "abs_surfaceSim_minus_score": 0.4168552036199096}
{"golden_code": "import numpy as np\n\neval(input())\n\nx = np.array(input().split(),dtype=np.int32)\n\n\n\nans = 0\n\nwhile (x%2 == 0).all():\n\n  x = x//2\n\n  ans += 1\n\nprint(ans)", "generated_code": "N = int(eval(input()))\n\nA = [int(x) for x in input().split()]\n\nresult = float('inf')\n\nfor i in range(N):\n\n  r=0\n\n  while A[i]%2==0:\n\n    A[i]=A[i]/2\n\n    r +=1\n\n  result=min(result,r)\n\nprint(result)", "score": 1.0, "codebleu": 0.22768033337713556, "crystalbleu": 0.0, "codebertscore": 0.78, "codescore": 0.8667666912078857, "surfaceSim": 0.5425407925407926, "abs_surfaceSim_minus_score": 0.45745920745920743}
{"golden_code": "import math\n\nN = int(eval(input()))\n\np = math.factorial(N)\n\nprint((p % 1000000007))", "generated_code": "N = int(eval(input()))\n\np = 1\n\nfor i in range(1,N+1):\n\n    p *= i\n\n    p %= 1000000007\n\nprint(p)\n", "score": 1.0, "codebleu": 0.35373732956578885, "crystalbleu": 0.0, "codebertscore": 0.83, "codescore": 0.5681946277618408, "surfaceSim": 0.5621588841722256, "abs_surfaceSim_minus_score": 0.4378411158277744}
{"golden_code": "from collections import Counter\n\nN, M = list(map(int, input().split()))\n\nA = list(map(int, input().split()))\n\n\n\nX = Counter(A)\n\nfor i in range(M):\n\n    B, C = list(map(int, input().split()))\n\n    X[C] += B\n\n\n\nZ = []\n\nfor key, value in list(X.items()):\n\n    Z.append((key, value))\n\n\n\nZ.sort(key=lambda x: x[0], reverse=True)\n\n\n\nans = 0\n\ncnt = 0\n\n\n\nfor value, key in Z:\n\n    if cnt + key <= N:\n\n        ans += key * value\n\n        cnt += key\n\n    else:\n\n        ans += (N - cnt) * value\n\n        break\n\n\n\nprint(ans)\n", "generated_code": "N, M = list(map(int, input().split()))\n\nA = sorted(list(map(int, input().split())))\n\nquery = []\n\nfor i in range(M):\n\n    b, c = list(map(int, input().split()))\n\n    query.append([b, c])\n\nquery.sort(key=lambda q: q[1], reverse=True)\n\n\n\n\n\ni = 0\n\nfor b, c in query:\n\n    while i < N and b > 0:\n\n        if A[i] < c:\n\n            A[i] = c\n\n            b -= 1\n\n        i += 1\n\n\n\nprint((sum(A)))\n", "score": 1.0, "codebleu": 0.30848539159379307, "crystalbleu": 0.26677791567402614, "codebertscore": 0.83, "codescore": 0.32729607820510864, "surfaceSim": 0.6514648661020829, "abs_surfaceSim_minus_score": 0.3485351338979171}
{"golden_code": "import numpy as np\n\nn = int(eval(input()))\n\nal = list(map(int,input().split()))\n\n\n\nfor i in range(n):\n\n    al[i] -= i + 1\n\n\n\nmed = np.median(np.array(al))\n\n\n\nans = 0\n\nfor a in al:\n\n    ans += abs(a-med)\n\nprint((int(ans)))", "generated_code": "import statistics\n\nn = int(eval(input()))\n\nal = list(map(int,input().split()))\n\n\n\nfor i in range(n):\n\n    al[i] -= i + 1\n\n\n\nmedian = statistics.median(al)\n\n\n\nans = 0\n\nfor a in al:\n\n    ans += abs(median - a)\n\n\n\nprint((int(ans)))\n", "score": 1.0, "codebleu": 0.7506519606924393, "crystalbleu": 0.0, "codebertscore": 0.95, "codescore": 0.8713123798370361, "surfaceSim": 0.9235807860262009, "abs_surfaceSim_minus_score": 0.07641921397379914}
{"golden_code": "k, n = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\n\n\ndiff = []\n\n\n\nfor i in range(n - 1):\n\n    diff.append(a[i + 1] - a[i])\n\ndiff.append(k - a[-1] + a[0])\n\n\n\nprint((k - max(diff)))\n", "generated_code": "k, n = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\n\n\na.append(k + a[0])\n\ndiff = [a1 - a0 for a0, a1 in zip(a, a[1:])]\n\n\n\nprint((k - max(diff)))\n", "score": 1.0, "codebleu": 0.5084277869685716, "crystalbleu": 0.45600467305519793, "codebertscore": 0.91, "codescore": 0.0982401892542839, "surfaceSim": 0.6952780229479258, "abs_surfaceSim_minus_score": 0.30472197705207416}
{"golden_code": "M=998244353\n\nn,m,k=list(map(int,input().split()))\n\na=0\n\nc=1\n\nfor i in range(k+1):\n\n  a+=c*m*pow(m-1,n-i-1,M)\n\n  c=c*(n-i-1)*pow(i+1,M-2,M)%M\n\nprint((a%M))", "generated_code": "M=998244353\n\nn,m,k=list(map(int,input().split()))\n\na,c=0,1\n\nfor i in range(k+1):\n\n  a+=c*m*pow(m-1,n+~i,M)\n\n  c=c*(n+~i)*pow(i+1,-1,M)%M\n\nprint((a%M))", "score": 1.0, "codebleu": 0.5361426195531298, "crystalbleu": 0.0, "codebertscore": 0.97, "codescore": 0.4227750599384308, "surfaceSim": 0.8762987012987014, "abs_surfaceSim_minus_score": 0.12370129870129865}
{"golden_code": "print((sum(si != ti for si, ti in zip(eval(input()), eval(input())))))\n", "generated_code": "print((sum(a!=b for a,b in zip(*open(0)))))", "score": 1.0, "codebleu": 0.18016002888564955, "crystalbleu": 0.0, "codebertscore": 0.85, "codescore": 0.8042500615119934, "surfaceSim": 0.7118093174431203, "abs_surfaceSim_minus_score": 0.28819068255687974}
{"golden_code": "# -*- coding: utf-8 -*-\n\n\"\"\"\n\nCreated on Sat May 25 21:24:29 2019\n\n\n\n@author: Yamazaki Kenichi\n\n\"\"\"\n\n\n\nN, M, K = list(map(int,input().split()))\n\nmod = 10**9+7\n\n\n\ndef cmb(n, r, mod):\n\n    if (r < 0 or r > n):\n\n        return 0\n\n    r = min(r, n-r)\n\n    return g1[n] * g2[r] * g2[n-r] % mod\n\n\n\ng1 = [1, 1] # 元テーブル\n\ng2 = [1, 1] # 逆元テーブル\n\ninv = [0, 1] # 逆元テーブル計算用テーブル\n\n\n\nfor i in range(2, N*M+1):\n\n    g1.append((g1[-1] * i) % mod)\n\n    inv.append((-inv[mod % i] * (mod//i)) % mod)\n\n    g2.append((g2[-1] * inv[-1]) % mod)\n\n\n\ndef a(N,M):\n\n    return N*(N+1)//2*(M+1) + M*(M+1)//2*(N+1)\n\ndef b(N):\n\n    return N*(N+1)//2\n\n\n\nans = 0\n\nfor i in range(N):\n\n    for j in range(M):\n\n        ans += a(i,j) + a(N-i-1,j) + a(i,M-j-1) + a(N-i-1,M-j-1)\n\n        ans -= b(i) + b(j) + b(N-i-1) + b(M-j-1)\n\n        ans %= mod\n\n#        print(i,j,a(i,j),a(N-i-1,j),a(i,M-j-1),a(N-i-1,M-j-1),b(i),b(j),ans)\n\nans *= g2[2]\n\n\n\nans *= cmb(N*M-2,K-2,mod)\n\nans %= mod\n\n\n\nprint(ans)\n", "generated_code": "# -*- coding: utf-8 -*-\n\n\"\"\"\n\nCreated on Wed May 29 22:49:19 2019\n\n\n\n@author: Yamazaki Kenichi\n\n\"\"\"\n\n\n\n# -*- coding: utf-8 -*-\n\n\"\"\"\n\nCreated on Sat May 25 21:24:29 2019\n\n\n\n@author: Yamazaki Kenichi\n\n\"\"\"\n\n\n\nN, M, K = list(map(int,input().split()))\n\nmod = 10**9+7\n\n\n\ndef cmb(n, r, mod):\n\n    if (r < 0 or r > n):\n\n        return 0\n\n    r = min(r, n-r)\n\n    return g1[n] * g2[r] * g2[n-r] % mod\n\n\n\ng1 = [1, 1] # 元テーブル\n\ng2 = [1, 1] # 逆元テーブル\n\ninv = [0, 1] # 逆元テーブル計算用テーブル\n\n\n\nfor i in range(2, N*M+1):\n\n    g1.append((g1[-1] * i) % mod)\n\n    inv.append((-inv[mod % i] * (mod//i)) % mod)\n\n    g2.append((g2[-1] * inv[-1]) % mod)\n\n\n\nans1 = 0\n\ndef c(N,M):\n\n    res = 0\n\n    for i in range(1,N):\n\n        res += i*(N-i)*M*M\n\n    return res\n\nans1 += c(N,M) + c(M,N)\n\nans1 %= mod\n\n\n\nans1 *= cmb(N*M-2,K-2,mod)\n\nans1 %= mod\n\n\n\nprint(ans1)\n", "score": 1.0, "codebleu": 0.6910088932970917, "crystalbleu": 0.5292356284296632, "codebertscore": 0.91, "codescore": 0.9855560064315796, "surfaceSim": 0.881675392670157, "abs_surfaceSim_minus_score": 0.11832460732984296}
{"golden_code": "N = int(eval(input()))\n\n\n\nseq = list(map(int, input().split()))\n\n\n\ncnt = 0\n\n\n\nfor num in seq:\n\n    while num % 2 == 0:\n\n        cnt += 1\n\n        num /= 2\n\n\n\nprint(cnt)\n", "generated_code": "n = int(eval(input()))\n\na = list(map(int, input().split()))\n\nans = 0\n\nfor num in a:\n\n    ans += format(num, 'b')[::-1].find('1')\n\nprint(ans)", "score": 1.0, "codebleu": 0.4818615528657325, "crystalbleu": 0.0, "codebertscore": 0.85, "codescore": 0.16307468712329865, "surfaceSim": 0.6484669176976869, "abs_surfaceSim_minus_score": 0.35153308230231306}
{"golden_code": "import copy\n\nn,k = list(map(int,input().split()))\n\nai = [int(i) for i in input().split()]\n\n\n\nold_ai = ai\n\ncnt = 0\n\n\n\nwhile 1 == 1:\n\n    old_ai = copy.deepcopy(ai)\n\n    li = [0]*(n+1)\n\n    for i in range(n):\n\n        li[max(0,i-ai[i])] += 1\n\n        li[min(n,i+1+ai[i])] -= 1\n\n        #print(li)\n\n    #print(li)\n\n    tmp = 0\n\n    for i in range(n):\n\n        if i == 0:\n\n            ai[i] = li[i]\n\n            tmp += ai[i]\n\n        else:\n\n            ai[i] = li[i] + ai[i-1]\n\n            tmp += ai[i]\n\n    #print(rui)\n\n    if ai == old_ai:\n\n        print((*ai))\n\n        exit()\n\n        break\n\n    cnt += 1\n\n    if cnt == k:\n\n        print((*ai))\n\n        exit()\n\n    old_ai = ai", "generated_code": "import copy\n\nn,k = list(map(int,input().split()))\n\nai = [int(i) for i in input().split()]\n\n\n\n#old_ai = ai\n\ncnt = 0\n\nold_tmp = sum(ai)\n\n\n\nwhile 1 == 1:\n\n    #old_ai = copy.deepcopy(ai)\n\n    li = [0]*(n+1)\n\n    for i in range(n):\n\n        li[max(0,i-ai[i])] += 1\n\n        li[min(n,i+1+ai[i])] -= 1\n\n        #print(li)\n\n    #print(li)\n\n    tmp = 0\n\n    for i in range(n):\n\n        if i == 0:\n\n            ai[i] = li[i]\n\n            tmp += ai[i]\n\n        else:\n\n            ai[i] = li[i] + ai[i-1]\n\n            tmp += ai[i]\n\n    #print(rui)\n\n    if old_tmp == tmp:\n\n        print((*ai))\n\n        exit()\n\n        break\n\n    cnt += 1\n\n    if cnt == k:\n\n        print((*ai))\n\n        exit()\n\n    old_tmp = tmp", "score": 1.0, "codebleu": 0.761001086990531, "crystalbleu": 0.815518851027449, "codebertscore": 0.98, "codescore": 0.9938526153564453, "surfaceSim": 0.957977207977208, "abs_surfaceSim_minus_score": 0.04202279202279202}
{"golden_code": "import numpy as np\n\n\n\nN=int(eval(input()))\n\nA=list(map(int, input().split()))\n\n\n\nAA=[]\n\nfor i,a in enumerate(A):\n\n    AA.append(a-i+1)\n\n\n\nb=np.median(AA)\n\nans=0\n\n\n\nfor a in AA:\n\n    ans+=abs(a-b)\n\nprint((int(ans)))", "generated_code": "N=int(eval(input()))\n\nA=list(map(int,input().split()))\n\nB=[]\n\nfor i in range(N):\n\n    B.append(A[i]-i-1)\n\nB.sort()\n\nif N%2:\n\n    b=B[N//2]\n\nelse:\n\n    b=(B[N//2]+B[N//2-1])//2\n\nans=0\n\nfor k in B:\n\n    ans+=abs(k-b)\n\nprint(ans)", "score": 1.0, "codebleu": 0.29497144912198503, "crystalbleu": 0.3839666177464585, "codebertscore": 0.86, "codescore": 0.807434618473053, "surfaceSim": 0.6114851866102347, "abs_surfaceSim_minus_score": 0.38851481338976535}
{"golden_code": "import numpy as np\n\n\n\n\n\ndef main(n, m, a):\n\n    dp = np.zeros(n + 1, dtype=int)\n\n    dp[0] = 1\n\n    dp[1] = 1 if 1 not in a else 0\n\n\n\n    for i in range(2, len(dp)):\n\n        dp[i] = dp[i - 1] + dp[i - 2] if i not in a else 0\n\n        dp[i] %= 1000000007\n\n\n\n    return dp[-1]\n\n\n\n\n\nif __name__ == '__main__':\n\n    N, M = list(map(int, input().split()))\n\n    A = set()\n\n    for _ in range(M):\n\n        A.add(int(eval(input())))\n\n\n\n    print((main(N, M, A)))\n", "generated_code": "import math\n\n\n\nMOD = int(math.pow(10, 9)) + 7\n\nN, M = list(map(int, input().split(' ')))\n\nbroken_steps = {int(eval(input())) for _ in range(M)}\n\n\n\ndp = [0] * (N + 1)\n\n\n\ndp[0] = 1\n\nif 1 not in broken_steps:\n\n    dp[1] = 1\n\n\n\nfor step in range(2, N + 1):\n\n    if step not in broken_steps:\n\n        dp[step] = (dp[step - 1] + dp[step - 2]) % MOD\n\n\n\nprint((dp[N]))\n", "score": 1.0, "codebleu": 0.2760852837085974, "crystalbleu": 0.297385066494751, "codebertscore": 0.82, "codescore": 0.050649482756853104, "surfaceSim": 0.5380116959064327, "abs_surfaceSim_minus_score": 0.4619883040935673}
{"golden_code": "#!usr/bin/env python3\n\nfrom collections import defaultdict\n\nfrom collections import deque\n\nfrom heapq import heappush, heappop\n\nimport sys\n\nimport math\n\nimport bisect\n\nimport random\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\n\ndef I(): return int(sys.stdin.readline())\n\ndef LS():return list(map(list, sys.stdin.readline().split()))\n\ndef S(): return list(sys.stdin.readline())[:-1]\n\ndef IR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = I()\n\n    return l\n\ndef LIR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = LI()\n\n    return l\n\ndef SR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = S()\n\n    return l\n\ndef LSR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = LS()\n\n    return l\n\nsys.setrecursionlimit(1000000)\n\nmod = 1000000007\n\n\n\n#A\n\ndef A():\n\n    return\n\n\n\n#B\n\ndef B():\n\n    return\n\n\n\n#C\n\ndef C():\n\n    return\n\n\n\n#D\n\ndef D():\n\n    return\n\n\n\n#E\n\ndef E():\n\n    return\n\n\n\n#F\n\ndef F():\n\n    a,b,c,X,Y = LI()\n\n    ans = float(\"inf\")\n\n    for z in range(300001):\n\n        if z%2 == 0:\n\n            m = c*z\n\n            x = z//2\n\n            y = z//2\n\n            m += a*max(0,X-x)\n\n            m += b*max(0,Y-y)\n\n            if m < ans:\n\n                ans = m\n\n    print(ans)\n\n    return\n\n\n\n#G\n\ndef G():\n\n    n = I()\n\n    x = LI()\n\n    f = [(i,x[i]) for i in range(n)]\n\n    f.sort(key = lambda x:x[1])\n\n    g = [(f[i][0],i) for i in range(n)]\n\n    g.sort(key = lambda x:x[0])\n\n    for i in range(n):\n\n        if g[i][1] < n//2:\n\n            print((f[n//2][1]))\n\n        else:\n\n            print((f[n//2-1][1]))\n\n    return\n\n\n\n#H\n\ndef H():\n\n    return\n\n\n\n#I\n\ndef I_():\n\n    return\n\n\n\n#J\n\ndef J():\n\n    return\n\n\n\n#Solve\n\nif __name__ == \"__main__\":\n\n    F()\n", "generated_code": "#!usr/bin/env python3\n\nfrom collections import defaultdict,deque\n\nfrom heapq import heappush, heappop\n\nfrom itertools import permutations\n\nimport sys\n\nimport math\n\nimport bisect\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\n\ndef I(): return int(sys.stdin.readline())\n\ndef LS():return [list(x) for x in sys.stdin.readline().split()]\n\ndef S():\n\n    res = list(sys.stdin.readline())\n\n    if res[-1] == \"\\n\":\n\n        return res[:-1]\n\n    return res\n\ndef IR(n):\n\n    return [I() for i in range(n)]\n\ndef LIR(n):\n\n    return [LI() for i in range(n)]\n\ndef SR(n):\n\n    return [S() for i in range(n)]\n\ndef LSR(n):\n\n    return [LS() for i in range(n)]\n\n\n\nsys.setrecursionlimit(1000000)\n\nmod = 1000000007\n\n\n\ndef solve():\n\n    A,B,C,x,y = LI()\n\n    ans = float(\"inf\")\n\n    for c in range(200001)[::2]:\n\n        a = b = c >> 1\n\n        a = max(0,x-a)\n\n        b = max(0,y-b)\n\n        s = A*a+B*b+C*c\n\n        if s < ans:\n\n            ans = s\n\n    print(ans)\n\n    return\n\n\n\n#Solve\n\nif __name__ == \"__main__\":\n\n    solve()\n", "score": 1.0, "codebleu": 0.3065474436834128, "crystalbleu": 0.22486624152797977, "codebertscore": 0.88, "codescore": 0.023735543712973595, "surfaceSim": 0.7418803418803419, "abs_surfaceSim_minus_score": 0.2581196581196581}
{"golden_code": "# vim: fileencoding=utf-8\n\n\n\n\n\ndef main():\n\n    a, b = list(map(int, input().split()))\n\n    c = 0\n\n    for i in range(a, b + 1):\n\n        s = str(i)\n\n        r = \"\".join(reversed(list(s)))\n\n        if s == r:\n\n            c += 1\n\n    print(c)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "generated_code": "# vim: fileencoding=utf-8\n\n\n\n\n\ndef main():\n\n    a, b = list(map(int, input().split()))\n\n    c = 0\n\n    for i in range(a, b + 1):\n\n        #     s = str(i)\n\n        #     r = \"\".join(reversed(list(s)))\n\n        #     if s == r:\n\n        #         c += 1\n\n        if (i % 10) == (i // 10000 % 10) and (i // 10 % 10) == (i // 1000 % 10):\n\n            c += 1\n\n    print(c)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "score": 1.0, "codebleu": 0.6581976170512275, "crystalbleu": 0.6195181310124266, "codebertscore": 0.95, "codescore": 0.9641032218933105, "surfaceSim": 0.8585640593746711, "abs_surfaceSim_minus_score": 0.14143594062532894}
{"golden_code": "import sys\n\nsys.setrecursionlimit(10000000)\n\nimport heapq\n\nimport math\n\n \n\ndef main():\n\n    N, K = list(map(int, input().split()))\n\n    A = [int(c) for c in input().split()]\n\n    F = [int(c) for c in input().split()]\n\n    \n\n    A.sort()\n\n    F.sort(reverse=True)\n\n \n\n    num = 0\n\n    sum_ = []\n\n    for i in range(N):\n\n      sum_.append(A[i] * F[i])\n\n    left = 0\n\n    right = 10 ** 12\n\n    while(num < 90):\n\n        number = 0\n\n        mid = (left + right) // 2\n\n        # print(mid)\n\n        for i in range(len(A)):\n\n            if sum_[i] <= mid:\n\n                continue\n\n            else:\n\n                number += math.ceil((sum_[i] - mid) / F[i])\n\n            # print(number)\n\n        if number > K:\n\n            # 最大値をmidより小さくできない -> 最大値はもっとでかい\n\n            left = mid + 1\n\n        else:\n\n            right = mid\n\n        num += 1\n\n    print(mid)\n\n                \n\n        \n\n \n\n \n\n \n\nif __name__ == '__main__':\n\n    main()", "generated_code": "import sys\n\nsys.setrecursionlimit(10000000)\n\nimport heapq\n\nimport math\n\n\n\ndef main():\n\n    N, K = list(map(int, input().split()))\n\n    A = [int(c) for c in input().split()]\n\n    F = [int(c) for c in input().split()]\n\n    \n\n    A.sort()\n\n    F.sort(reverse=True)\n\n\n\n    num = 0\n\n    sum_ = []\n\n    for i in range(len(A)):\n\n        sum_.append(A[i] * F[i])\n\n    left = 0\n\n    right = 10 ** 12\n\n    while(num < 50):\n\n        number = 0\n\n        mid = (left + right) // 2\n\n        # print(mid)\n\n        for i in range(len(A)):\n\n            if sum_[i] <= mid:\n\n                continue\n\n            else:\n\n                number += math.ceil((sum_[i] - mid) / F[i])\n\n            # print(number)\n\n        if number > K:\n\n            # 最大値をmidより小さくできない -> 最大値はもっとでかい\n\n            left = mid + 1\n\n        else:\n\n            right = mid\n\n        num += 1\n\n    print(mid)\n\n                \n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 1.0, "codebleu": 0.9017024327752274, "crystalbleu": 0.956303373775195, "codebertscore": 0.99, "codescore": 0.9938251972198486, "surfaceSim": 0.9962486602357985, "abs_surfaceSim_minus_score": 0.0037513397642015}
{"golden_code": "A, B, C, X, Y = list(map(int, input().split()))\n\n\n\nans = 5000 * 2 * 10 ** 5\n\nfor i in range(10 ** 5 + 1):\n\n    s = i * 2 * C + max(0, X - i) * A + max(0, Y - i) * B\n\n    ans = min(ans, s)\n\n\n\nprint(ans)", "generated_code": "A, B, C, X, Y = list(map(int, input().split()))\n\n\n\nif X > Y:\n\n    v = A\n\nelse:\n\n    v = B\n\n\n\nans = min(A*X+B*Y, C*max(X, Y)*2, C*min(X,Y)*2+(max(X,Y)-min(X,Y))*v)\n\n\n\nprint(ans)", "score": 1.0, "codebleu": 0.3077067099016239, "crystalbleu": 0.0, "codebertscore": 0.83, "codescore": 0.8821012377738953, "surfaceSim": 0.6942916993977482, "abs_surfaceSim_minus_score": 0.30570830060225185}
{"golden_code": "k,n = list(map(int,input().split()))\n\na=list(map(int,input().split()))\n\na.append(a[0]+k)\n\nlongd=0\n\nfor i in range(n):\n\n    tmp=abs(a[i+1]-a[i])\n\n    longd=max(longd,tmp)\n\nprint((k-longd))", "generated_code": "k,n=list(map(int,input().split()))\n\na=list(map(int,input().split()))\n\na.append(a[0]+k)\n\n\n\nx=0\n\nfor i in range(len(a)-1):\n\n    dis=abs(a[i+1]-a[i])\n\n    x=max(x,dis)\n\n\n\nprint((k-x))", "score": 1.0, "codebleu": 0.4907752087750694, "crystalbleu": 0.6708073881787768, "codebertscore": 0.94, "codescore": 0.909515917301178, "surfaceSim": 0.9117647058823529, "abs_surfaceSim_minus_score": 0.08823529411764708}
{"golden_code": "n=int(eval(input()))\n\ns=list(map(str,input().split()))\n\ntotal=[]\n\nfor i in range(n):\n\n    if s[i] not in total:\n\n        total.append(s[i])\n\nprint(('Three' if len(total)==3 else 'Four'))", "generated_code": "eval(input())\n\nl=list(map(str,input().split()))\n\nprint(('Three' if len(set(l))==3 else 'Four'))", "score": 1.0, "codebleu": 0.17312266649453495, "crystalbleu": 0.0, "codebertscore": 0.84, "codescore": 0.5673249959945679, "surfaceSim": 0.6344086021505376, "abs_surfaceSim_minus_score": 0.3655913978494624}
{"golden_code": "import sys\n\n\n\nn, m, *lr = list(map(int, sys.stdin.read().split()))\n\nlr = list(zip(*[iter(lr)] * 2))\n\n\n\ndef main():\n\n    cnt = [0] * (n + 1)\n\n    for l, r in lr:\n\n        cnt[l-1] += 1\n\n        cnt[r] -= 1\n\n    \n\n    for i in range(n):\n\n        cnt[i+1] += cnt[i]\n\n    \n\n    res = 0\n\n    for i in range(n):\n\n        res += (cnt[i] == m) & 1\n\n    \n\n    return res\n\n\n\nif __name__ == '__main__':\n\n    ans = main()\n\n    print(ans)", "generated_code": "import sys\n\n\n\nn, m, *lr = list(map(int, sys.stdin.read().split()))\n\nl, r = lr[::2], lr[1::2]\n\n\n\ndef main():\n\n    ans = max(min(r) - max(l) + 1, 0)\n\n    return ans\n\n\n\nif __name__ == '__main__':\n\n    ans = main()\n\n    print(ans)", "score": 1.0, "codebleu": 0.30662618959757326, "crystalbleu": 0.2800354182309023, "codebertscore": 0.84, "codescore": 0.01977350004017353, "surfaceSim": 0.7303921568627452, "abs_surfaceSim_minus_score": 0.26960784313725483}
{"golden_code": "a,b,c,d,e,f=[int(eval(input())) for _ in range(6)]\n\nprint((sum([a,b,c,d,max(e,f)])-min([a,b,c,d])))", "generated_code": "print((sum(sorted(int(eval(input())) for _ in range(4))[1:])+max([int(eval(input())) for _ in range(2)])))", "score": 1.0, "codebleu": 0.2242737827628642, "crystalbleu": 0.23837482432405213, "codebertscore": 0.82, "codescore": 0.018561378121376038, "surfaceSim": 0.49947589098532497, "abs_surfaceSim_minus_score": 0.500524109014675}
{"golden_code": "# ABC102C - Linear Approximation (ARC100C)\n\nfrom statistics import median\n\n\n\n\n\ndef main():\n\n    n = int(eval(input()))\n\n    A = tuple(map(int, input().rstrip().split()))\n\n    A = tuple(j - i for i, j in enumerate(A, start=1))\n\n    b = median(A)\n\n    ans = sum(abs(a - b) for a in A)\n\n    print((int(ans)))\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()", "generated_code": "# ABC102C - Linear Approximation (ARC100C)\n\ndef main():\n\n    n = int(eval(input()))\n\n    A = tuple(map(int, input().rstrip().split()))\n\n    A = sorted(j - i for i, j in enumerate(A, start=1))\n\n    b = A[n // 2]\n\n    ans = sum(abs(a - b) for a in A)\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()", "score": 1.0, "codebleu": 0.674285129333551, "crystalbleu": 0.7405360191846485, "codebertscore": 0.96, "codescore": 0.03532777726650238, "surfaceSim": 0.8312320916905445, "abs_surfaceSim_minus_score": 0.16876790830945554}
{"golden_code": "from math import factorial\n\nN = int(eval(input()))\n\nprint((factorial(N) % (10**9 + 7)))", "generated_code": "from math import factorial\n\nN = int(eval(input()))\n\nans = 1\n\nfor i in range(1,N+1):\n\n    ans *= i % (10**9 + 7)\n\n    ans %= 10**9 + 7\n\nprint(ans)", "score": 1.0, "codebleu": 0.5155116125588945, "crystalbleu": 0.0, "codebertscore": 0.88, "codescore": 0.961179792881012, "surfaceSim": 0.7393509127789046, "abs_surfaceSim_minus_score": 0.26064908722109537}
{"golden_code": "n,m=list(map(int,input().split()))\n\nc=[0]*(n+2)\n\nfor i in range(m):\n\n  l,r=list(map(int,input().split()))\n\n  c[l-1]+=1\n\n  c[r]-=1\n\nfor i in range(1,n+2):\n\n  c[i]=c[i]+c[i-1]\n\nans=0\n\nfor i in range(n+2):\n\n  if c[i]==m:\n\n    ans+=1\n\nprint(ans)", "generated_code": "n,m=list(map(int,input().split()))\n\nl,r=list(map(int,input().split()))\n\nfor i in range(m-1):\n\n  tl,tr=list(map(int,input().split()))\n\n  if l<tl:\n\n    l=tl\n\n  if tr<r:\n\n    r=tr\n\nprint((max(r-l+1,0)))", "score": 1.0, "codebleu": 0.2118312531149506, "crystalbleu": 0.22829217769272614, "codebertscore": 0.87, "codescore": 0.27119114995002747, "surfaceSim": 0.598863431354862, "abs_surfaceSim_minus_score": 0.401136568645138}
{"golden_code": "a,b,c=1,0,0\n\nexec('a,b,c=b,c,(a+c)%(10**9+7);'*(int(eval(input()))-2))\n\nprint(c)", "generated_code": "a,b,c=1,0,0\n\nexec('a,b,c=b,c,a+c;'*(int(eval(input()))-2))\n\nprint((c%(10**9+7)))", "score": 1.0, "codebleu": 0.5057864365426399, "crystalbleu": 0.0, "codebertscore": 0.97, "codescore": 0.9939192533493042, "surfaceSim": 0.75, "abs_surfaceSim_minus_score": 0.25}
{"golden_code": "from scipy.sparse.csgraph import csgraph_from_dense, floyd_warshall\n\n\n\nINF = float('inf')\n\n\n\ndef sol():\n\n    N, M = list(map(int, input().split()))\n\n\n\n    edges = []\n\n\n\n    for _ in range(M):\n\n        fr, to, cost = list(map(int, input().split()))\n\n        fr -= 1\n\n        to -= 1\n\n        edges.append((fr, to, cost))\n\n\n\n    graph = [[INF] * N for _ in range(N)]\n\n    for fr, to, cost in edges:\n\n        graph[fr][to] = cost\n\n\n\n    graph = csgraph_from_dense(graph, null_value=INF)\n\n\n\n    dist = floyd_warshall(graph, directed=False)\n\n    ans = (graph > dist).sum()\n\n    print(ans)\n\n\n\nsol()", "generated_code": "N, M = list(map(int, input().split()))\n\nINF = 10**18\n\n\n\nminDist = [[INF] * N for _ in range(N)]\n\nfor i in range(N):\n\n    minDist[i][i] = 0\n\n\n\nedges = []\n\nfor _ in range(M):\n\n    fr, to, d = list(map(int, input().split()))\n\n    fr -= 1\n\n    to -= 1\n\n    edges.append((fr, to, d))\n\n    minDist[fr][to] = d\n\n    minDist[to][fr] = d\n\n\n\nfor k in range(N):\n\n    for i in range(N):\n\n        for j in range(N):\n\n            d = minDist[i][k] + minDist[k][j]\n\n            if minDist[i][j] > d:\n\n                minDist[i][j] = d\n\n\n\nans = 0\n\nfor fr, to, d in edges:\n\n    if minDist[fr][to] < d:\n\n        ans += 1\n\nprint(ans)\n", "score": 1.0, "codebleu": 0.47322317218413795, "crystalbleu": 0.42492648120315435, "codebertscore": 0.8, "codescore": 0.32738590240478516, "surfaceSim": 0.6190663519538422, "abs_surfaceSim_minus_score": 0.3809336480461578}
{"golden_code": "#E\n\nfrom itertools import accumulate\n\nfrom bisect import bisect_left\n\ndef main():\n\n    n,m=list(map(int,input().split()))\n\n    A=list(map(int,input().split()))\n\n    A.sort()\n\n    \n\n    def count(k):\n\n        cnt=0\n\n        for a in A:\n\n            cnt+=bisect_left(A,k-a)\n\n        return cnt\n\n    \n\n    ok=0\n\n    ng=10**10+1\n\n    while ng-ok>1:\n\n        mid=(ok+ng)//2\n\n        if count(mid)<n**2-m:\n\n            ok=mid\n\n        else:\n\n            ng=mid\n\n    border=ok\n\n    \n\n    k=n**2-count(border)\n\n    Acc=[0]+list(accumulate(A))\n\n    s=Acc[-1]\n\n    ans=0\n\n    for a in A:\n\n        idx=bisect_left(A,border-a)\n\n        ans+=a*(n-idx)+(s-Acc[idx])\n\n    ans-=border*(k-m)\n\n    print(ans)\n\n    \n\nif __name__=='__main__':\n\n    main()", "generated_code": "from itertools import accumulate\n\nfrom bisect import bisect_left\n\ndef main():\n\n    n,m=list(map(int,input().split()))\n\n    A=list(map(int,input().split()))\n\n    A.sort()\n\n    \n\n    def count(k):\n\n        cnt=0\n\n        for a in A:\n\n            cnt+=bisect_left(A,k-a)\n\n        return cnt\n\n    \n\n    ok=0\n\n    ng=2*10**5+1\n\n    while ng-ok>1:\n\n        mid=(ok+ng)//2\n\n        if count(mid)<n**2-m:\n\n            ok=mid\n\n        else:\n\n            ng=mid\n\n    border=ok\n\n    \n\n    k=n**2-count(border)\n\n    Acc=[0]+list(accumulate(A))\n\n    s=Acc[-1]\n\n    ans=0\n\n    for a in A:\n\n        idx=bisect_left(A,border-a)\n\n        ans+=a*(n-idx)+(s-Acc[idx])\n\n    ans-=border*(k-m)\n\n    print(ans)\n\n    \n\nif __name__=='__main__':\n\n    main()", "score": 1.0, "codebleu": 0.9039643902680069, "crystalbleu": 0.9631758660180704, "codebertscore": 0.99, "codescore": 0.9938042163848877, "surfaceSim": 0.9972752043596731, "abs_surfaceSim_minus_score": 0.0027247956403269047}
{"golden_code": "from collections import Counter\n\n\n\nimport numpy as np\n\n\n\n\n\ndef part(pts, a, ans):\n\n    b = np.dot(pts, [np.sin(a), np.cos(a)])\n\n    c = np.argmax(b, axis=0)\n\n    for i, v in list(Counter(c).items()):\n\n        ans[i] += v\n\n\n\n\n\ndef solve(n, pts):\n\n    ans = [0] * n\n\n    part(pts, np.linspace(0, np.pi, 100000, endpoint=False), ans)\n\n    part(pts, np.linspace(np.pi, 2 * np.pi, 100000, endpoint=False), ans)\n\n    return [v / 200000 for v in ans]\n\n\n\n\n\nn = int(eval(input()))\n\npts = np.array([list(map(int, input().split())) for _ in range(n)])\n\nprint(('\\n'.join(map(str, solve(n, pts)))))\n", "generated_code": "from collections import Counter\n\nimport numpy as np\n\n\n\n\n\ndef part(pts, s, t, num, ans):\n\n    a = np.linspace(s, t, num, endpoint=False)\n\n    for i, v in list(Counter(np.argmax(np.dot(pts, [np.sin(a), np.cos(a)]), axis=0)).items()):\n\n        ans[i] += v\n\n\n\n\n\ndef solve(n, pts):\n\n    ans = np.zeros(n)\n\n    part(pts, 0, np.pi, 1e5, ans)\n\n    part(pts, np.pi, 2 * np.pi, 1e5, ans)\n\n    return ans / 2e5\n\n\n\n\n\nn = int(eval(input()))\n\nprint(('\\n'.join(map(str, solve(n, [list(map(int, input().split())) for _ in range(n)])))))\n", "score": 1.0, "codebleu": 0.45949864874471963, "crystalbleu": 0.6701756000648613, "codebertscore": 0.93, "codescore": 0.32030147314071655, "surfaceSim": 0.7909556313993173, "abs_surfaceSim_minus_score": 0.20904436860068265}
{"golden_code": "import numpy as np\n\nn,k=list(map(int,input().split()))\n\nexp=tuple([(int(x)+1)/2 for x in input().split()])\n\nl=np.cumsum(exp)\n\n\n\nans=l[k-1]\n\nfor i in range(0,n-k):\n\n  x=l[i+k]-l[i]\n\n  ans=max(ans,x)\n\nprint(ans)", "generated_code": "def main():\n\n    from itertools import accumulate\n\n    n, k = list(map(int, input().split()))\n\n    *exp, = [(int(x) + 1) / 2 for x in input().split()]\n\n    l = accumulate(exp)\n\n    l = list(l)\n\n    ans = l[k - 1]\n\n    for i in range(0, n - k):\n\n        x = l[i + k] - l[i]\n\n        ans = max(ans, x)\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 1.0, "codebleu": 0.3578977981197397, "crystalbleu": 0.5650958210653207, "codebertscore": 0.88, "codescore": 0.018316447734832764, "surfaceSim": 0.7321428571428572, "abs_surfaceSim_minus_score": 0.2678571428571428}
{"golden_code": "import numpy as np\n\n\n\nn = int(eval(input()))\n\na = np.array(list(map(int,input().split())))\n\n\n\ncount = 0\n\nwhile np.all(a%2==0):\n\n    count+=1\n\n    a=a/2\n\nprint(count)\n", "generated_code": "N=int(eval(input()))\n\na = [int(i) for i in input().split()]\n\n\n\ncount=0\n\nwhile 1:\n\n    if sum([i%2 for i in a]) == 0:\n\n        a = [i/2 for i in a]\n\n        count=count+1\n\n    else:\n\n        print(count)\n\n        break\n", "score": 1.0, "codebleu": 0.23312890830139688, "crystalbleu": 0.0, "codebertscore": 0.82, "codescore": 0.9294070601463318, "surfaceSim": 0.6391104906262465, "abs_surfaceSim_minus_score": 0.3608895093737535}
{"golden_code": "s = eval(input())\n\n\n\nstart = -1\n\nend = 0\n\nfor i in range(len(s)):\n\n    if s[i] == 'A' and start < 0:\n\n        start = i\n\n    elif s[i] == 'Z':\n\n        end = i\n\nprint((end - start + 1))\n", "generated_code": "s = eval(input())\n\n\n\nstart = 0\n\nfor i in range(len(s)):\n\n    if s[i] == 'A':\n\n        start = i\n\n        break\n\n\n\nend = 0\n\nfor i in reversed(list(range(len(s)))):\n\n    if s[i] == 'Z':\n\n        end = i\n\n        break\n\nprint((end - start + 1))\n", "score": 1.0, "codebleu": 0.6117105849764274, "crystalbleu": 0.6050930169057582, "codebertscore": 0.93, "codescore": 0.20202386379241943, "surfaceSim": 0.739399928135106, "abs_surfaceSim_minus_score": 0.260600071864894}
{"golden_code": "s = input()[::-1]\n\n\n\nwhile True:\n\n    if len(s) == 0:\n\n        break\n\n    if s[:7] == \"remaerd\":\n\n        s = s[7:]\n\n    elif s[:6] == \"resare\":\n\n        s = s[6:]\n\n    elif s[:5] == \"maerd\" or s[:5] == \"esare\":\n\n        s = s[5:]\n\n    else:\n\n        print(\"NO\")\n\n        exit()\n\n\n\nprint(\"YES\")", "generated_code": "import re\n\n\n\ns = eval(input())\n\n\n\nif re.fullmatch(r\"(dream|dreamer|erase|eraser)+\", s):\n\n    print(\"YES\")\n\nelse:\n\n    print(\"NO\")", "score": 1.0, "codebleu": 0.10333360166566952, "crystalbleu": 0.0, "codebertscore": 0.72, "codescore": 0.9630269408226013, "surfaceSim": 0.47155225726654304, "abs_surfaceSim_minus_score": 0.528447742733457}
{"golden_code": "N = int(eval(input()))\n\n\n\ncount = 0\n\nfor i in range(1, N + 1):\n\n    num_dig = 0\n\n    ii = i\n\n    while ii > 0:\n\n        ii = int(ii / 10)\n\n        num_dig += 1\n\n    if num_dig % 2 != 0:\n\n        count += 1\n\n\n\nprint(count)", "generated_code": "N = int(eval(input()))\n\n\n\ncount = 0\n\nfor i in range(1, N + 1):\n\n    if len(str(i)) % 2 != 0:\n\n        count += 1\n\nprint(count)", "score": 1.0, "codebleu": 0.5373822397794952, "crystalbleu": 0.0, "codebertscore": 0.9, "codescore": 0.9934179782867432, "surfaceSim": 0.7988806858775899, "abs_surfaceSim_minus_score": 0.20111931412241013}
{"golden_code": "W,H,x,y,r = [int(i) for i in input().split()]\n\nif x - r >= 0 and x + r <= W and y - r >= 0 and y + r <= H:\n\n    print(\"Yes\")\n\nelse:\n\n    print(\"No\")", "generated_code": "W, H, x, y, r = list(map(int, input().split()))\n\nif r <= x <= W-r and r <= y <= H-r:\n\n    print('Yes')\n\nelse:\n\n    print('No')\n", "score": 1.0, "codebleu": 0.24356409202473264, "crystalbleu": 0.0, "codebertscore": 0.9, "codescore": 0.6411425471305847, "surfaceSim": 0.7763835263835264, "abs_surfaceSim_minus_score": 0.22361647361647363}
{"golden_code": "from math import floor, sqrt\n\nfrom collections import Counter\n\n\n\nMOD = 10 ** 9 + 7\n\n\n\n# xを素因数分解する\n\ndef getPrimeFactor(x):\n\n    ans = []\n\n    for d in range(2, floor(sqrt(x)) + 1):\n\n        while x % d == 0:\n\n            ans.append(d)\n\n            x //= d\n\n\n\n    if x != 1:\n\n        ans.append(x)\n\n\n\n    return ans\n\n\n\n# xのn乗（二分累乗法）\n\ndef power(x, n):\n\n    ans = 1\n\n    while n:\n\n        if n % 2 == 1:\n\n            ans = (ans * x) % MOD\n\n        x = (x * x) % MOD\n\n        n //= 2\n\n    return ans\n\n\n\n\n\nN, M = list(map(int, input().split()))\n\n\n\nPFs = getPrimeFactor(M)\n\ncnt = Counter(PFs)\n\n\n\nN2 = N\n\nif len(cnt):\n\n    N2 += max(cnt.values())\n\n\n\n# facts[x]: xの階乗\n\nfacts = [1] + [0] * N2\n\nfor x in range(1, N2 + 1):\n\n    facts[x] = (facts[x - 1] * x) % MOD\n\n\n\n# invFs[x]: xの階乗の逆元\n\ninvFs = [0] * N2 + [power(facts[N2], MOD - 2)]\n\nfor x in reversed(list(range(N2))):\n\n    invFs[x] = (invFs[x + 1] * (x + 1)) % MOD\n\n\n\ndef comb(n, k):\n\n    return ((facts[n] * invFs[k]) % MOD * invFs[n - k]) % MOD\n\n\n\n\n\nans = 1\n\nfor num in list(cnt.values()):\n\n    ans = (ans * comb(N + num - 1, num)) % MOD\n\nprint(ans)\n", "generated_code": "from math import floor, sqrt\n\nfrom collections import Counter\n\n\n\nMOD = 10 ** 9 + 7\n\n\n\n# xを素因数分解する\n\ndef getPrimeFactor(x):\n\n    ans = []\n\n    for d in range(2, floor(sqrt(x)) + 1):\n\n        while x % d == 0:\n\n            ans.append(d)\n\n            x //= d\n\n    if x != 1:\n\n        ans.append(x)\n\n    return ans\n\n\n\ndef comb(n, k):\n\n    k = min(k, n - k)\n\n    ans = 1\n\n    for i in range(n, n - k, -1):\n\n        ans *= i\n\n    for i in range(1, k + 1):\n\n        ans //= i \n\n    return ans\n\n\n\n\n\nN, M = list(map(int, input().split()))\n\n\n\nPFs = getPrimeFactor(M)\n\ncnt = Counter(PFs)\n\n\n\nans = 1\n\nfor num in list(cnt.values()):\n\n    ans *= comb(N + num - 1, num)\n\nprint((ans % MOD))\n", "score": 1.0, "codebleu": 0.4402052513109228, "crystalbleu": 0.38525969984631075, "codebertscore": 0.88, "codescore": 0.7780672311782837, "surfaceSim": 0.7838077827108906, "abs_surfaceSim_minus_score": 0.21619221728910942}
{"golden_code": "'''\n\nある平面のブロック数×(0,1)\n\n一つでも偶数があれば、均等分割可能\n\nすべて奇数のとき、\n\nある平面のブロック数を最小となるようにすると、その数が答えになる\n\n'''\n\n\n\narr = list(map(int, input().split()))\n\n\n\nret = -1\n\nif 0 in list([x % 2 for x in arr]):\n\n    ret = 0\n\nelse:\n\n    arr_sorted = sorted(arr)\n\n    ret = arr_sorted[0] * arr_sorted[1]\n\nprint(ret)", "generated_code": "a = list(map(int, input().split()))\n\n\n\nif any([x % 2 == 0 for x in a]):\n\n    print((0))\n\nelse:\n\n    a = list(sorted(a))\n\n    print((a[0] * a[1]))\n", "score": 1.0, "codebleu": 0.253092184374594, "crystalbleu": 0.0, "codebertscore": 0.72, "codescore": 0.5096893906593323, "surfaceSim": 0.635239318984902, "abs_surfaceSim_minus_score": 0.36476068101509795}
{"golden_code": "import sys\n\nimport numpy as np\n\n\n\n\n\ndef main():\n\n    h, w = list(map(int, sys.stdin.buffer.readline().split()))\n\n    n = int(sys.stdin.buffer.readline())\n\n    a = list(map(int, sys.stdin.buffer.readline().split()))\n\n    ans = np.zeros(w*h, np.int64)\n\n    now = 0\n\n    for i, x in enumerate(a):\n\n        for j in range(x):\n\n            ans[now + j] = i+1\n\n        now += x\n\n\n\n    ans = ans.reshape(h, w)\n\n    for i in range(h):\n\n        if i % 2:\n\n            print((*ans[i, ::-1]))\n\n        else:\n\n            print((*ans[i]))\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "generated_code": "import sys\n\n\n\n\n\ndef main():\n\n    h, w = list(map(int, sys.stdin.buffer.readline().split()))\n\n    n = int(sys.stdin.buffer.readline())\n\n    a = list(map(int, sys.stdin.buffer.readline().split()))\n\n    ans = [0]*(w*h)\n\n    now = 0\n\n    for i, x in enumerate(a):\n\n        for j in range(x):\n\n            ans[now + j] = i+1\n\n        now += x\n\n\n\n    for i in range(h):\n\n        if i % 2:\n\n            print((*reversed(ans[i*w:(i+1)*w])))\n\n        else:\n\n            print((*ans[i*w:(i+1)*w]))\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "score": 1.0, "codebleu": 0.6247421075451611, "crystalbleu": 0.7815885645247879, "codebertscore": 0.94, "codescore": 0.018409745767712593, "surfaceSim": 0.8636800180780747, "abs_surfaceSim_minus_score": 0.1363199819219253}
{"golden_code": "n = int(eval(input()))\n\nv = list(map(int, input().split()))\n\nc = list(map(int, input().split()))\n\nresult = 0\n\nfor i in range(n):\n\n  if v[i] > c[i]:\n\n    result += v[i] - c[i]\n\nprint(result)", "generated_code": "N = int(eval(input()))\n\nV = list(map(int, input().split()))\n\nC = list(map(int, input().split()))\n\nprint((sum([V[i] - C[i] for i in range(N) if V[i] > C[i]])))\n", "score": 1.0, "codebleu": 0.4144833762482961, "crystalbleu": 0.32776309440480517, "codebertscore": 0.92, "codescore": 0.2537161409854889, "surfaceSim": 0.6825396825396826, "abs_surfaceSim_minus_score": 0.31746031746031744}
{"golden_code": "from bisect import bisect_right\n\nimport sys\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\nreadlines = sys.stdin.readlines\n\n\n\ndef main():\n\n    x = int(readline())\n\n\n\n    for a in range(-120, 120):\n\n        for b in range(-120, 120):\n\n            if a**5 - b**5 == x:\n\n                print((a, b))\n\n                exit()\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "generated_code": "# AC: 33 msec(Python3)\n\nfrom itertools import combinations_with_replacement\n\nimport sys\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\nreadlines = sys.stdin.readlines\n\n\n\ndef main():\n\n    x = int(readline())\n\n\n\n    ab = [i**5 for i in range(200)]\n\n\n\n    C = combinations_with_replacement(ab, 2)\n\n    for a, b in C:\n\n        if a + b == x:\n\n            print((int(pow(b, 0.2)), -int(pow(a, 0.2))))\n\n            break\n\n        \n\n        if b - a == x:\n\n            print((int(pow(b, 0.2)), int(pow(a, 0.2))))\n\n            break\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "score": 1.0, "codebleu": 0.46739699897790676, "crystalbleu": 0.3286111663475004, "codebertscore": 0.84, "codescore": 0.8093866109848022, "surfaceSim": 0.7786580836840802, "abs_surfaceSim_minus_score": 0.22134191631591982}
{"golden_code": "s=eval(input())\n\nt=eval(input())\n\ns*=2\n\nnext=[[-1]*26 for _ in range(len(s))]\n\nalph=[[]for _ in range(26)]\n\nfor i in range(len(s)):\n\n\talph[ord(s[i])-ord(\"a\")].append(i)\n\nfrom bisect import bisect_right\n\nfor i in range(len(s)//2):\n\n\tfor j in range(26):\n\n\t\tif len(alph[j])>bisect_right(alph[j],i):\n\n\t\t\tnext[i][j]=alph[j][bisect_right(alph[j],i)]\n\nans=1\n\nnow=len(s)//2-1\n\nfor x in t:\n\n\tr=ord(x)-ord(\"a\")\n\n\tnow=next[now][r]\n\n\tif now==-1:\n\n\t\tprint((-1))\n\n\t\texit()\n\n\tif now>=len(s)//2:\n\n\t\tans+=len(s)//2\n\n\t\tnow-=len(s)//2\n\nprint((ans+now-len(s)//2))", "generated_code": "#O(|S|log|s|)\n\ndef main():\n\n\ts=eval(input())\n\n\tt=eval(input())\n\n\tn=len(s)\n\n\tnow=-1\n\n\tans=1\n\n\tif not set(t)<=set(s):#tがsの部分集合でない\n\n\t\tprint((-1))\n\n\t\texit()\n\n\tfor x in t:\n\n\t\tnow=s.find(x,now+1)#nowより大きいところからxを探す\n\n\t\tif now==-1:#nowより大きいところでxが見つからなかったら\n\n\t\t\tans+=n\n\n\t\t\tnow=s.find(x)\n\n\tprint((ans+now))\n\nif __name__ == '__main__':\n\n\tmain()", "score": 1.0, "codebleu": 0.16404167581080745, "crystalbleu": 0.0966474554057038, "codebertscore": 0.74, "codescore": 0.02793213725090027, "surfaceSim": 0.4332141696457589, "abs_surfaceSim_minus_score": 0.5667858303542411}
{"golden_code": "#template\n\ndef inputlist(): return [int(j) for j in input().split()]\n\n#template\n\n#issueから始める\n\nK,N = inputlist()\n\nA = inputlist()\n\nlia = [0]*N\n\nfor i in range(1,N):\n\n    k = A[i] - A[i-1]\n\n    lia[i] = k\n\nlia[0] = (K+A[0]-A[-1])\n\nlia.sort()\n\nans = 0\n\nfor i in range(N-1):\n\n    ans += lia[i]\n\nprint(ans)", "generated_code": "#template\n\ndef inputlist(): return [int(j) for j in input().split()]\n\ndef listinput(): return input().split()\n\n#template\n\nK,N = inputlist()\n\nA = inputlist()\n\ndis = [0]*(N)\n\nfor i in range(N):\n\n    if i == N-1:\n\n        dis[i] = K+A[0] - A[i]\n\n        continue\n\n    dis[i] = A[i+1] - A[i]\n\ndis.sort()\n\nprint((sum(dis[:-1])))", "score": 1.0, "codebleu": 0.44308812600523384, "crystalbleu": 0.4225097971617697, "codebertscore": 0.9, "codescore": 0.1069948747754097, "surfaceSim": 0.7159193049036252, "abs_surfaceSim_minus_score": 0.2840806950963748}
{"golden_code": "#! /usr/bin/env python3\n\n\n\nimport sys\n\nint1 = lambda x: int(x) - 1\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\nsys.setrecursionlimit(500000)\n\n\n\n\n\ndef isMultiple(s, m):\n\n    tmp = 0\n\n    for i in range(len(s)):\n\n        tmp = (tmp * 10 + int(s[i])) % m\n\n        if tmp == 0:\n\n            return i\n\n    return -1\n\n\n\n\n\nk = int(readline())\n\nacc = \"7\" * 50000000\n\nif k % 2 == 0:\n\n    ans = -1\n\nelse:\n\n\n\n    ans = isMultiple(acc, k)\n\n    if ans != -1:\n\n        ans += 1\n\n\n\nprint(ans)\n", "generated_code": "#! /usr/bin/env python3\n\n\n\nimport sys\n\nint1 = lambda x: int(x) - 1\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\nsys.setrecursionlimit(500000)\n\n\n\nk = int(readline())\n\n\n\nans = -1\n\nacc = 7 % k\n\nfor n in range(1, k + 10):\n\n    if acc == 0:\n\n        ans = n\n\n        break\n\n    acc = (10 * acc + 7) % k\n\n\n\nprint(ans)\n", "score": 1.0, "codebleu": 0.44668800795647723, "crystalbleu": 0.36251708798701154, "codebertscore": 0.91, "codescore": 0.527802050113678, "surfaceSim": 0.750661832412523, "abs_surfaceSim_minus_score": 0.24933816758747696}
{"golden_code": "import sys\n\ncan = True; eval(input())\n\ne = [[0, 0, 0]] + [list(map(int, e.split())) for e in sys.stdin]\n\nfor a, b in zip(e[1:], e):\n\n    t = a[0] - b[0] - abs(a[1] - b[1]) - abs(a[2] - b[2])\n\n    if t < 0 or t % 2 == 1: can = False; break\n\nprint((['No', 'Yes'][can]))", "generated_code": "import sys\n\nans = 'Yes'; eval(input())\n\nfor e in sys.stdin:\n\n    t, x, y = list(map(int, e.split()))\n\n    t = t - x - y\n\n    if t < 0 or t % 2 == 1: ans = 'No'; break\n\nprint(ans)", "score": 1.0, "codebleu": 0.25451653474995944, "crystalbleu": 0.2186313111646685, "codebertscore": 0.87, "codescore": 0.9739446640014648, "surfaceSim": 0.6473782771535581, "abs_surfaceSim_minus_score": 0.3526217228464419}
{"golden_code": "import numpy as np\n\nN = int(eval(input()))\n\nabc = []\n\nfor i in range(N):\n\n    abc.append(list(map(int, input().split())))\n\n    \n\ndp = np.zeros(shape=(N, 3), dtype=int)\n\ndp[0, :] = abc[0]\n\nfor i in range(N-1):\n\n    dp[i+1, 0] = max(dp[i+1, 0], dp[i, 1] + abc[i+1][0], dp[i, 2] + abc[i+1][0])\n\n    dp[i+1, 1] = max(dp[i+1, 1], dp[i, 0] + abc[i+1][1], dp[i, 2] + abc[i+1][1])\n\n    dp[i+1, 2] = max(dp[i+1, 2], dp[i, 0] + abc[i+1][2], dp[i, 1] + abc[i+1][2])\n\nprint((max(dp[N-1, :])))", "generated_code": "N = int(eval(input()))\n\nabc = []\n\nfor i in range(N):\n\n    data = list(map(int, input().split()))\n\n    abc.append(data)\n\n\n\ndp = [[0 for i in range(3)] for j in range(N)]\n\ndp[0][0] = abc[0][0]\n\ndp[0][1] = abc[0][1]\n\ndp[0][2] = abc[0][2]\n\n\n\nfor i in range(N-1):\n\n    for j in range(3):\n\n        if j == 0:\n\n            dp[i+1][1] = max(dp[i][0] + abc[i+1][1], dp[i+1][1])\n\n            dp[i+1][2] = max(dp[i][0] + abc[i+1][2], dp[i+1][2])\n\n        if j == 1:\n\n            dp[i+1][0] = max(dp[i][1] + abc[i+1][0], dp[i+1][0])\n\n            dp[i+1][2] = max(dp[i][1] + abc[i+1][2], dp[i+1][2])\n\n        if j == 2:\n\n            dp[i+1][1] = max(dp[i][2] + abc[i+1][1], dp[i+1][1])\n\n            dp[i+1][0] = max(dp[i][2] + abc[i+1][0], dp[i+1][0])\n\n\n\nprint((max(dp[N-1])))", "score": 1.0, "codebleu": 0.31765678630399047, "crystalbleu": 0.4803360304723532, "codebertscore": 0.91, "codescore": 0.6425799131393433, "surfaceSim": 0.6075675938061259, "abs_surfaceSim_minus_score": 0.3924324061938741}
{"golden_code": "import math\n\nn = int(eval(input()))\n\n\n\nans = math.factorial(n)  # nの階乗を計算\n\n\n\nif ans >= (10 ** 9)+7:\n\n    ans = ans % ((10 ** 9)+7)\n\n\n\nprint(ans)\n", "generated_code": "n = int(eval(input()))\n\n\n\nans = 1\n\nfor i in range(1, n+1):\n\n    ans = ans * i\n\n    ans = ans % ((10 ** 9)+7)  # 途中で割り算の余りを求めても、最終結果は同じになる\n\n\n\nprint(ans)", "score": 1.0, "codebleu": 0.45508450301466985, "crystalbleu": 0.0, "codebertscore": 0.8, "codescore": 0.19459687173366547, "surfaceSim": 0.6609271523178808, "abs_surfaceSim_minus_score": 0.3390728476821192}
{"golden_code": "S = int(eval(input()))\n\nMOD = 10 ** 9 + 7\n\n\n\n#dp[i]最後に切った場所がi　スタートが1なのは、そこまでの切り方が1通りなので\n\n#３以下はダメなので、3個前の結果を見るようにする\n\ndp =  [0] * (S+1)\n\ndp[0] = 1\n\n\n\nfor i in range(1, S+1):\n\n    #たとえばi=6のとき、i=6で初めて切れ目を入れる時で＋１、i=3に切れ目をいれるときで＋１で合計＋２\n\n    for j in range(0, (i-3)+1):\n\n        dp[i] += dp[j]\n\n        dp[i] %= MOD\n\nprint((dp[S]))        ", "generated_code": "S = int(eval(input()))\n\nMOD = 10 ** 9 + 7\n\n\n\n#dp[i]最後に切った場所がi　スタートが1なのは、そこまでの切り方が1通りなので\n\n#３以下はダメなので、3個前の結果を見るようにする\n\ndp =  [0] * (S+1)\n\ndp[0] = 1\n\n\n\n#これまでの和をxに保存しておく\n\nx = 0\n\nfor i in range(1, S+1):\n\n    if i-3 >= 0:\n\n        x += dp[i-3]\n\n        x %= MOD\n\n    dp[i] = x\n\nprint((dp[S]))        ", "score": 1.0, "codebleu": 0.6621869494388611, "crystalbleu": 0.6288731490918487, "codebertscore": 0.93, "codescore": 0.9935899972915649, "surfaceSim": 0.8745892661555312, "abs_surfaceSim_minus_score": 0.12541073384446877}
{"golden_code": "N,K=list(map(int,input().split()))\n\n\n\ncon = 0\n\nans = list(int() for _ in range(100000))\n\npre = 0\n\n\n\n\n\nfor _ in range(K):\n\n\n\n    D = int(eval(input()))\n\n    arr = list(map(int,input().split()))\n\n\n\n    for j in range(D):\n\n\n\n        ans[pre+j]=arr[j]\n\n\n\n    pre += D\n\n\n\n        \n\nfin = (N+1) - len(set(ans))\n\n\n\nprint(fin)", "generated_code": "N,K=list(map(int,input().split()))\n\n\n\ncon = 0\n\nans = list(int() for _ in range(10001))\n\npre = 0\n\n\n\n\n\nfor _ in range(K):\n\n\n\n    D = int(eval(input()))\n\n    arr = list(map(int,input().split()))\n\n\n\n    for j in range(D):\n\n\n\n        ans[pre+j]=arr[j]\n\n\n\n    pre += D\n\n\n\n        \n\nfin = (N+1) - len(set(ans))\n\n\n\nprint(fin)", "score": 1.0, "codebleu": 0.9655676097906438, "crystalbleu": 0.9440375310909427, "codebertscore": 1.0, "codescore": 0.9938422441482544, "surfaceSim": 0.9968553459119497, "abs_surfaceSim_minus_score": 0.0031446540880503138}
{"golden_code": "import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\nN = int(readline())\n\nAB = [list(map(int,readline().split())) for i in range(N-1)]\n\n\n\ngraph = [[] for _ in range(N+1)] #隣接リスト\n\nfor a,b in AB:\n\n    graph[a].append(b)\n\n    graph[b].append(a)\n\n\n\n#親のノードに子を入れてくdfs\n\nstack = [1]\n\nparent = [0]*(N+1)\n\norder = []\n\nwhile stack:\n\n    x = stack.pop()\n\n    order.append(x)\n\n    for i in graph[x]:\n\n        if i == parent[x]:\n\n            continue\n\n        parent[i] = x\n\n        stack.append(i)\n\n\n\n#各子の色を決めていく。\n\ncolor = [-1]*(N+1)\n\nfor x in order:\n\n    ng = color[x]\n\n    c = 1\n\n    for y in graph[x]:\n\n        if parent[x] == y:\n\n            continue\n\n        if c == ng:\n\n            c += 1\n\n        color[y] = c\n\n        c += 1\n\n\n\nans = []\n\nfor a,b in AB:\n\n    if parent[a] == b: #子の頂点の色を入れる\n\n        ans.append(color[a])\n\n    else:\n\n        ans.append(color[b])\n\n\n\nprint((max(ans)))\n\nfor i in ans:\n\n    print(i)\n\n        \n", "generated_code": "import sys\n\nfrom collections import deque\n\nreadline = sys.stdin.buffer.readline\n\ndef even(n): return 1 if n%2==0 else 0\n\nn = int(readline())\n\ng = [[] for _ in range(n)] #隣接リスト\n\nab = []\n\nfor i in range(n-1):\n\n    a,b = list(map(int,readline().split()))\n\n    a,b = a-1,b-1\n\n    ab.append((a,b))\n\n    g[a].append(b)\n\n    g[b].append(a)\n\n\n\nroot = 0\n\nparent = [0]*n\n\ndeq = deque([root])\n\norder = [root]\n\n\n\ncolor = [-1]*n\n\ndeq = deque([root])\n\nwhile deq:\n\n    fr = deq.pop()\n\n    ng = color[fr]\n\n    c = 0\n\n    for go in g[fr]:\n\n        if go == parent[fr]:\n\n            continue\n\n        if c == ng:\n\n            c += 1\n\n        parent[go] = fr\n\n        color[go] = c\n\n        c += 1\n\n        deq.append(go)\n\n        order.append(go)\n\nrank = [0]*n\n\nfor i,j in enumerate(order):\n\n    rank[j] = i\n\nprint((max(color)+1))\n\nfor a,b in ab:\n\n    if rank[a] < rank[b]:\n\n        print((color[b]+1))\n\n    else:\n\n        print((color[a]+1))", "score": 1.0, "codebleu": 0.3688076409564845, "crystalbleu": 0.3196865245306567, "codebertscore": 0.83, "codescore": 0.8044518232345581, "surfaceSim": 0.6708789740849586, "abs_surfaceSim_minus_score": 0.32912102591504144}
{"golden_code": "N = int(eval(input()))\n\np = 1\n\nfor i in range(N):\n\n    p *= (i + 1)\n\n    p %= (1e9 + 7)\n\nprint((int(p)))", "generated_code": "N = int(eval(input()))\n\np = 1\n\nfor i in range(N):\n\n    p = p * (i + 1) % (1e9 + 7)\n\nprint((int(p)))", "score": 1.0, "codebleu": 0.7433297555071704, "crystalbleu": 0.0, "codebertscore": 0.98, "codescore": 0.9937638640403748, "surfaceSim": 0.9354395604395604, "abs_surfaceSim_minus_score": 0.06456043956043955}
{"golden_code": "import sys\n\nimport itertools\n\nfrom operator import itemgetter #sortedの対象を決めたい\n\nfrom fractions import gcd #最大公約数\n\nfrom math import ceil, floor, sqrt, isinf #小数点切り上げ、切り捨て、平方根\n\nfrom copy import deepcopy #参照で影響されないコピー\n\nfrom collections import Counter, deque #要素ごとの出現回数、双方向アクセス可能データ型\n\nimport heapq\n\nimport numpy as np\n\nfrom functools import reduce\n\nsys.setrecursionlimit(200000)\n\n\n\ninput = sys.stdin.readline\n\n# template\n\n\n\ndef retmax(a, b):\n\n    if a > b:\n\n        return a\n\n    else:\n\n        return b\n\n\n\ndef main():\n\n    n = int(eval(input()))\n\n    a = [list(map(int, input().split())) for _ in range(n)]\n\n\n\n    dp = np.zeros([3, n+1])\n\n\n\n    for i, a_l in enumerate(a):\n\n        for j in range(3):\n\n            for k in range(3):\n\n                if j != k:\n\n                    dp[k, i+1] = retmax(dp[k, i+1], dp[j, i] + a_l[k])\n\n\n\n    print((int(np.max(dp[:, n], axis=0))))\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n\n\n", "generated_code": "import sys\n\nimport itertools\n\nfrom operator import itemgetter #sortedの対象を決めたい\n\nfrom fractions import gcd #最大公約数\n\nfrom math import ceil, floor, sqrt, isinf #小数点切り上げ、切り捨て、平方根\n\nfrom copy import deepcopy #参照で影響されないコピー\n\nfrom collections import Counter, deque #要素ごとの出現回数、双方向アクセス可能データ型\n\nimport heapq\n\nimport numpy as np\n\nfrom functools import reduce\n\nsys.setrecursionlimit(200000)\n\n\n\ninput = sys.stdin.readline\n\n# template\n\n\n\ndef main():\n\n    n = int(eval(input()))\n\n    abc = [list(map(int, input().split())) for _ in range(n)]\n\n\n\n    a, b, c = 0, 0, 0\n\n    for x, y, z in abc:\n\n        a, b, c = max(b, c) + x, max(a, c) + y, max(a, b) + z\n\n\n\n    print((max(a, b, c)))\n\n\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n\n\n", "score": 1.0, "codebleu": 0.50509112661777, "crystalbleu": 0.4961548465445824, "codebertscore": 0.94, "codescore": 0.025614794343709946, "surfaceSim": 0.7551080840983122, "abs_surfaceSim_minus_score": 0.2448919159016878}
{"golden_code": "n = int(eval(input()))\n\na = [int(x) for x in input().split()]\n\n\n\nans = list(range(n))\n\n\n\nfor i in range(n):\n\n    ans[a[i]-1] = i+1\n\n    \n\nprint((' '.join(map(str,ans))))", "generated_code": "def main():\n\n\n\n    N = int(eval(input()))\n\n    A = list(int(x) for x in input().split())\n\n    ans = [0] * N\n\n\n\n    for i, a in enumerate(A):\n\n        ans[a-1] = i+1\n\n\n\n    print((' '.join(map(str, ans))))\n\n    \n\nif __name__ == '__main__':\n\n    main()", "score": 1.0, "codebleu": 0.32523524558963185, "crystalbleu": 0.0, "codebertscore": 0.9, "codescore": 0.03181112930178642, "surfaceSim": 0.6556923076923077, "abs_surfaceSim_minus_score": 0.3443076923076923}
{"golden_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "generated_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "score": 0.0, "codebleu": 0.9316722029744632, "crystalbleu": 0.9942110332335385, "codebertscore": 1.0, "codescore": 0.9935764670372009, "surfaceSim": 0.9988589685075309, "abs_surfaceSim_minus_score": 0.9988589685075309}
{"golden_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "generated_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    pass\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "score": 0.0, "codebleu": 0.8384159641342932, "crystalbleu": 0.9572728308036055, "codebertscore": 0.99, "codescore": 0.9938318729400635, "surfaceSim": 0.9721826977803074, "abs_surfaceSim_minus_score": 0.9721826977803074}
{"golden_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "generated_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] ** self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "score": 0.0, "codebleu": 0.9945883912637858, "crystalbleu": 0.9958766805969164, "codebertscore": 1.0, "codescore": 0.9935526847839355, "surfaceSim": 0.9869513849897061, "abs_surfaceSim_minus_score": 0.9869513849897061}
{"golden_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "generated_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\npass\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "score": 0.0, "codebleu": 0.9564664922648272, "crystalbleu": 0.9844422263261756, "codebertscore": 0.99, "codescore": 0.9829372763633728, "surfaceSim": 0.9831060316616556, "abs_surfaceSim_minus_score": 0.9831060316616556}
{"golden_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "generated_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        pass\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "score": 0.0, "codebleu": 0.9067380354256456, "crystalbleu": 0.9913167545986485, "codebertscore": 1.0, "codescore": 0.9935523271560669, "surfaceSim": 0.9855820430900303, "abs_surfaceSim_minus_score": 0.9855820430900303}
{"golden_code": "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nMOD = (10 ** 9) + 7\nfac = [1, 1]\nf_inv = [1, 1]\ninv = [0, 1]\ndef prepare(n, mod):\n    for i in range(2, n + 1):\n        fac.append((fac[-1] * i) % mod)\n        inv.append(((-(inv[mod % i])) * (mod // i)) % mod)\n        f_inv.append((f_inv[-1] * inv[-1]) % mod)\ndef cmb(n, r, mod):\n    if (n < 0 or r < 0):\n        return 0\n    if r > n:\n        return 0\n    return ((fac[n] * f_inv[r]) * f_inv[n - r]) % mod\ndef prime_factorization(n):\n    d = []\n    (i, e) = (2, 0)\n    while i * i <= n:\n        while n % i == 0:\n            n //= i\n            e += 1\n        if e > 0:\n            d.append((i, e))\n        i += 1\n        e = 0\n    if n > 1:\n        d.append((n, 1))\n    return d\ndef main():\n    (N, M) = list(map(int, readline().split()))\n    prepare(N + 100, MOD)\n    d = prime_factorization(M)\n    ans = 1\n    for (i, e) in d:\n        ans *= cmb((N - 1) + e, e, MOD)\n        ans %= MOD\n    print(ans)", "generated_code": "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nMOD = (10 ** 9) + 7\nfac = [1, 1]\nf_inv = [1, 1]\ninv = [0, 1]\ndef prepare(n, mod):\n    for i in range(2, n + 1):\n        fac.append((fac[+1] * i) % mod)\n        inv.append(((-(inv[mod % i])) * (mod // i)) % mod)\n        f_inv.append((f_inv[-1] * inv[-1]) % mod)\ndef cmb(n, r, mod):\n    if (n < 0 or r < 0):\n        return 0\n    if r > n:\n        return 0\n    return ((fac[n] * f_inv[r]) * f_inv[n - r]) % mod\ndef prime_factorization(n):\n    d = []\n    (i, e) = (2, 0)\n    while i * i <= n:\n        while n % i == 0:\n            n //= i\n            e += 1\n        if e > 0:\n            d.append((i, e))\n        i += 1\n        e = 0\n    if n > 1:\n        d.append((n, 1))\n    return d\ndef main():\n    (N, M) = list(map(int, readline().split()))\n    prepare(N + 100, MOD)\n    d = prime_factorization(M)\n    ans = 1\n    for (i, e) in d:\n        ans *= cmb((N - 1) + e, e, MOD)\n        ans %= MOD\n    print(ans)", "score": 0.0, "codebleu": 0.9927498121985038, "crystalbleu": 0.9930313168671425, "codebertscore": 1.0, "codescore": 0.9937465190887451, "surfaceSim": 0.987, "abs_surfaceSim_minus_score": 0.987}
{"golden_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "generated_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "score": 0.0, "codebleu": 1.0, "crystalbleu": 1.0, "codebertscore": 1.0, "codescore": 0.9938342571258545, "surfaceSim": 1.0, "abs_surfaceSim_minus_score": 1.0}
{"golden_code": "import sys\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\ndef solve():\n    inf = (10 ** 14) + 10\n    def dfs(v: 'vertex_index, 0-indexed') -> None:\n        for (c, t) in e[v]:\n            if d[t] != inf:\n                continue\n            d[t] = d[v] + c\n            dfs(t)\n    n = int(eval(input()))\n    e = tuple((set() for _ in range(n)))\n    for _ in range(n - 1):\n        (a, b, c) = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        e[a].add((c, b))\n        e[b].add((c, a))\n    (q, v) = list(map(int, input().split()))\n    v -= 1\n    d = [inf] * n\n    d[v] = 0\n    dfs(v)\n    for _ in range(q):\n        (x, y) = list(map(int, input().split()))\n        x -= 1\n        y -= 1\n        print(d[x] + d[y])", "generated_code": "import sys\nsys.setrecursionlimit(10 * 7)\ninput = sys.stdin.readline\ndef solve():\n    inf = (10 ** 14) + 10\n    def dfs(v: 'vertex_index, 0-indexed') -> None:\n        for (c, t) in e[v]:\n            if d[t] != inf:\n                continue\n            d[t] = d[v] + c\n            dfs(t)\n    n = int(eval(input()))\n    e = tuple((set() for _ in range(n)))\n    for _ in range(n - 1):\n        (a, b, c) = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        e[a].add((c, b))\n        e[b].add((c, a))\n    (q, v) = list(map(int, input().split()))\n    v -= 1\n    d = [inf] * n\n    d[v] = 0\n    dfs(v)\n    for _ in range(q):\n        (x, y) = list(map(int, input().split()))\n        x -= 1\n        y -= 1\n        print(d[x] + d[y])", "score": 0.0, "codebleu": 0.9881398574370538, "crystalbleu": 0.993332298381219, "codebertscore": 1.0, "codescore": 0.993811845779419, "surfaceSim": 0.9993243243243244, "abs_surfaceSim_minus_score": 0.9993243243243244}
{"golden_code": "INF = 10 ** 10\n(N, M) = list(map(int, input().split()))\ncosts = []\nkeys = []\nfor _ in range(M):\n    (A, B) = list(map(int, input().split()))\n    cs = list(map(int, input().split()))\n    costs.append(A)\n    key = 0\n    for c in cs:\n        key |= 1 << (c - 1)\n    keys.append(key)\nmaskss = [[] for _ in range(N + 1)]\nnum1s = [0] * (2 ** N)\nfor S in range(2 ** N):\n    num = bin(S).count('1')\n    maskss[num].append(S)\n    num1s[S] = num\ndpAll = [INF] * (2 ** N)\nfor S in range(2 ** N):\n    for (cost, key) in zip(costs, keys):\n        if S & key == S:\n            if cost < dpAll[S]:\n                dpAll[S] = cost\ndp = [INF] * (2 ** N)\nfor S in range(2 ** N):\n    cost = dpAll[S]\n    num1 = num1s[S]\n    for k in range(1, ((num1 + 1) // 2) + 1):\n        for mask in maskss[k]:\n            if mask & S == mask:\n                m2 = S ^ mask\n                c2 = dp[mask] + dp[m2]\n                if c2 < cost:\n                    cost = c2\n    dp[S] = cost\nif dp[(2 ** N) - 1] == INF:\n    print(-1)\nelse:\n    print(dp[(2 ** N) - 1])", "generated_code": "INF = 10 ** 10\n(N, M) = list(map(int, input().split()))\ncosts = []\nkeys = []\nfor _ in range(M):\n    (A, B) = list(map(int, input().split()))\n    cs = list(map(int, input().split()))\n    costs.append(A)\n    key = 0\n    for c in cs:\n        key |= 1 << (c - 1)\n    keys.append(key)\nmaskss = [[] for _ in range(N + 1)]\nnum1s = [0] ** (2 ** N)\nfor S in range(2 ** N):\n    num = bin(S).count('1')\n    maskss[num].append(S)\n    num1s[S] = num\ndpAll = [INF] * (2 ** N)\nfor S in range(2 ** N):\n    for (cost, key) in zip(costs, keys):\n        if S & key == S:\n            if cost < dpAll[S]:\n                dpAll[S] = cost\ndp = [INF] * (2 ** N)\nfor S in range(2 ** N):\n    cost = dpAll[S]\n    num1 = num1s[S]\n    for k in range(1, ((num1 + 1) // 2) + 1):\n        for mask in maskss[k]:\n            if mask & S == mask:\n                m2 = S ^ mask\n                c2 = dp[mask] + dp[m2]\n                if c2 < cost:\n                    cost = c2\n    dp[S] = cost\nif dp[(2 ** N) - 1] == INF:\n    print(-1)\nelse:\n    print(dp[(2 ** N) - 1])", "score": 0.0, "codebleu": 0.9931217231346744, "crystalbleu": 0.9962960475029206, "codebertscore": 1.0, "codescore": 0.9937931299209595, "surfaceSim": 0.999515972894482, "abs_surfaceSim_minus_score": 0.999515972894482}
{"golden_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "generated_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        break\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "score": 0.0, "codebleu": 0.9757550966986483, "crystalbleu": 0.9626898460033498, "codebertscore": 1.0, "codescore": 0.9935131669044495, "surfaceSim": 0.9901871291647649, "abs_surfaceSim_minus_score": 0.9901871291647649}
{"golden_code": "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nMOD = (10 ** 9) + 7\nfac = [1, 1]\nf_inv = [1, 1]\ninv = [0, 1]\ndef prepare(n, mod):\n    for i in range(2, n + 1):\n        fac.append((fac[-1] * i) % mod)\n        inv.append(((-(inv[mod % i])) * (mod // i)) % mod)\n        f_inv.append((f_inv[-1] * inv[-1]) % mod)\ndef cmb(n, r, mod):\n    if (n < 0 or r < 0):\n        return 0\n    if r > n:\n        return 0\n    return ((fac[n] * f_inv[r]) * f_inv[n - r]) % mod\ndef prime_factorization(n):\n    d = []\n    (i, e) = (2, 0)\n    while i * i <= n:\n        while n % i == 0:\n            n //= i\n            e += 1\n        if e > 0:\n            d.append((i, e))\n        i += 1\n        e = 0\n    if n > 1:\n        d.append((n, 1))\n    return d\ndef main():\n    (N, M) = list(map(int, readline().split()))\n    prepare(N + 100, MOD)\n    d = prime_factorization(M)\n    ans = 1\n    for (i, e) in d:\n        ans *= cmb((N - 1) + e, e, MOD)\n        ans %= MOD\n    print(ans)", "generated_code": "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nMOD = (10 ** 9) + 7\nfac = [1, 1]\nf_inv = [1, 1]\ninv = [0, 1]\ndef prepare(n, mod):\n    for i in range(2, n + 1):\n        fac.append((fac[-1] * i) % mod)\n        inv.append((inv[mod % i] * (mod // i)) % mod)\n        f_inv.append((f_inv[-1] * inv[-1]) % mod)\ndef cmb(n, r, mod):\n    if (n < 0 or r < 0):\n        return 0\n    if r > n:\n        return 0\n    return ((fac[n] * f_inv[r]) * f_inv[n - r]) % mod\ndef prime_factorization(n):\n    d = []\n    (i, e) = (2, 0)\n    while i * i <= n:\n        while n % i == 0:\n            n //= i\n            e += 1\n        if e > 0:\n            d.append((i, e))\n        i += 1\n        e = 0\n    if n > 1:\n        d.append((n, 1))\n    return d\ndef main():\n    (N, M) = list(map(int, readline().split()))\n    prepare(N + 100, MOD)\n    d = prime_factorization(M)\n    ans = 1\n    for (i, e) in d:\n        ans *= cmb((N - 1) + e, e, MOD)\n        ans %= MOD\n    print(ans)", "score": 0.0, "codebleu": 0.9680526427541045, "crystalbleu": 0.9797480430335415, "codebertscore": 1.0, "codescore": 0.9938405752182007, "surfaceSim": 0.9975, "abs_surfaceSim_minus_score": 0.9975}
{"golden_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "generated_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    @classmethod\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "score": 0.0, "codebleu": 0.9933297651216333, "crystalbleu": 0.9932615708925326, "codebertscore": 0.99, "codescore": 0.9865819215774536, "surfaceSim": 0.9960462287104623, "abs_surfaceSim_minus_score": 0.9960462287104623}
{"golden_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "generated_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if not (g.M[s][d] < v):\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "score": 0.0, "codebleu": 0.9852855484256073, "crystalbleu": 0.9895673542995259, "codebertscore": 1.0, "codescore": 0.9935964345932007, "surfaceSim": 0.9860415718403883, "abs_surfaceSim_minus_score": 0.9860415718403883}
{"golden_code": "import sys\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\ndef solve():\n    inf = (10 ** 14) + 10\n    def dfs(v: 'vertex_index, 0-indexed') -> None:\n        for (c, t) in e[v]:\n            if d[t] != inf:\n                continue\n            d[t] = d[v] + c\n            dfs(t)\n    n = int(eval(input()))\n    e = tuple((set() for _ in range(n)))\n    for _ in range(n - 1):\n        (a, b, c) = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        e[a].add((c, b))\n        e[b].add((c, a))\n    (q, v) = list(map(int, input().split()))\n    v -= 1\n    d = [inf] * n\n    d[v] = 0\n    dfs(v)\n    for _ in range(q):\n        (x, y) = list(map(int, input().split()))\n        x -= 1\n        y -= 1\n        print(d[x] + d[y])", "generated_code": "import sys\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\ndef solve():\n    inf = (10 ** 14) + 10\n    def dfs(v: 'vertex_index, 0-indexed') -> None:\n        for (c, t) in e[v]:\n            if d[t] != inf:\n                continue\n            d[t] = d[v] - c\n            dfs(t)\n    n = int(eval(input()))\n    e = tuple((set() for _ in range(n)))\n    for _ in range(n - 1):\n        (a, b, c) = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        e[a].add((c, b))\n        e[b].add((c, a))\n    (q, v) = list(map(int, input().split()))\n    v -= 1\n    d = [inf] * n\n    d[v] = 0\n    dfs(v)\n    for _ in range(q):\n        (x, y) = list(map(int, input().split()))\n        x -= 1\n        y -= 1\n        print(d[x] + d[y])", "score": 0.0, "codebleu": 0.9881398574370538, "crystalbleu": 0.9907582847077829, "codebertscore": 1.0, "codescore": 0.8324663043022156, "surfaceSim": 0.9993243243243244, "abs_surfaceSim_minus_score": 0.9993243243243244}
{"golden_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "generated_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] // (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "score": 0.0, "codebleu": 0.9950293033173805, "crystalbleu": 0.9943164908202797, "codebertscore": 1.0, "codescore": 0.9849219918251038, "surfaceSim": 0.9993857493857494, "abs_surfaceSim_minus_score": 0.9993857493857494}
{"golden_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "generated_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        break\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "score": 0.0, "codebleu": 0.9706943679537091, "crystalbleu": 0.9626898460033498, "codebertscore": 1.0, "codescore": 0.9935449361801147, "surfaceSim": 0.9901871291647649, "abs_surfaceSim_minus_score": 0.9901871291647649}
{"golden_code": "import queue\nINF = 123456789\ndef main():\n    (n, m) = list(map(int, input().split()))\n    G = [[] for _ in range(n)]\n    for _ in range(m):\n        (a, b, c) = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        G[a].append((b, c))\n        G[b].append((a, c))\n    used = set()\n    for i in range(n):\n        d = [INF for _ in range(n)]\n        par = [-1 for _ in range(n)]\n        que = queue.PriorityQueue()\n        d[i] = 0\n        que.put((0, i))\n        while not (que.empty()):\n            p = que.get()\n            v = p[1]\n            if d[v] < p[0]:\n                continue\n            for (to, cost) in G[v]:\n                if d[to] > d[v] + cost:\n                    d[to] = d[v] + cost\n                    par[to] = v\n                    que.put((d[to], to))\n        for j in range(n):\n            if i != j:\n                (a, b) = (j, par[j])\n                if a > b:\n                    (a, b) = (b, a)\n                used.add((a, b))\n    print(m - len(used))", "generated_code": "import queue\nINF = 123456789\ndef main():\n    (n, m) = list(map(int, input().split()))\n    G = [[] for _ in range(n)]\n    for _ in range(m):\n        (a, b, c) = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        G[a].append((b, c))\n        G[b].append((a, c))\n    used = set()\n    for i in range(n):\n        d = [INF for _ in range(n)]\n        par = [-1 for _ in range(n)]\n        que = queue.PriorityQueue()\n        d[i] = 0\n        que.put((0, i))\n        while not ((not (que.empty()))):\n            p = que.get()\n            v = p[1]\n            if d[v] < p[0]:\n                continue\n            for (to, cost) in G[v]:\n                if d[to] > d[v] + cost:\n                    d[to] = d[v] + cost\n                    par[to] = v\n                    que.put((d[to], to))\n        for j in range(n):\n            if i != j:\n                (a, b) = (j, par[j])\n                if a > b:\n                    (a, b) = (b, a)\n                used.add((a, b))\n    print(m - len(used))", "score": 0.0, "codebleu": 0.9795888975617973, "crystalbleu": 0.9838745655513632, "codebertscore": 1.0, "codescore": 0.9937864542007446, "surfaceSim": 0.9965139442231076, "abs_surfaceSim_minus_score": 0.9965139442231076}
{"golden_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "generated_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\npass\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "score": 0.0, "codebleu": 0.8703422099040631, "crystalbleu": 0.9766462657171, "codebertscore": 0.99, "codescore": 0.9846640229225159, "surfaceSim": 0.982829635619346, "abs_surfaceSim_minus_score": 0.982829635619346}
{"golden_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "generated_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += __n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "score": 0.0, "codebleu": 0.9884911427299241, "crystalbleu": 0.9936989720107794, "codebertscore": 1.0, "codescore": 0.9824743866920471, "surfaceSim": 0.9984634296250768, "abs_surfaceSim_minus_score": 0.9984634296250768}
{"golden_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "generated_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        break\n\n\n\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "score": 0.0, "codebleu": 0.9389276367665139, "crystalbleu": 0.9433112340413564, "codebertscore": 0.96, "codescore": 0.18436068296432495, "surfaceSim": 0.9325567291656138, "abs_surfaceSim_minus_score": 0.9325567291656138}
{"golden_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "generated_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        pass\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "score": 0.0, "codebleu": 0.9809083980500957, "crystalbleu": 0.9791306644241836, "codebertscore": 0.99, "codescore": 0.9843667149543762, "surfaceSim": 0.966212063323311, "abs_surfaceSim_minus_score": 0.966212063323311}
{"golden_code": "from collections import defaultdict\nfrom collections import deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\ndef I():\n    return int(sys.stdin.readline())\ndef LS():\n    return list(map(list, sys.stdin.readline().split()))\ndef S():\n    return list(sys.stdin.readline())[:-1]\ndef IR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = I()\n    return l\ndef LIR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = LI()\n    return l\ndef SR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = S()\n    return l\ndef LSR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = SR()\n    return l\nmod = 1000000007\ndef A():\n    s = S()\n    t = S()\n    if s + t == t[::-1] + s[::-1]:\n        print('YES')else:print('NO')\ndef B():\n    n = I()\n    for i in range(int(n ** 0.5) + 2)[::-1]:\n        if i * i <= n:\n            print(i * i)\n            quit()\ndef C():\n    n = I()\n    a = LI()\n    b = LI()\n    c = LI()\n    q = [0 for i in range(n)]\n    ans = 0\n    a.sort()\n    b.sort()\n    c.sort()\n    for i in range(n):\n        j = bisect.bisect_left(a, b[i])\n        q[i] = j\n    for i in range(n - 1):\n        q[i + 1] += q[i]\n    q.insert(0, 0)\n    for i in range(n):\n        j = bisect.bisect_left(b, c[i])\n        ans += q[j]\n    print(ans)\ndef D():\n    def dijkstra():\n        d = [float('inf') for i in range(k)]\n        q = [[0, 1]]\n        d[1] = 0\n        while q:\n            (dx, x) = heappop(q)\n            for (y, dy) in v[x]:\n                if d[y] > dx + dy:\n                    d[y] = dx + dy\n                    heappush(q, [d[y], y])\n        print(d[0] + 1)\n    k = I()\n    if k == 1:\n        print(1)\n        quit()\n    v = [[] for i in range(k)]\n    for i in range(1, k):\n        v[i].append([(i + 1) % k, 1])\n        v[i].append([(i * 10) % k, 0])\n    dijkstra()\ndef E():\n    return\ndef F():\n    return\ndef G():\n    return\ndef H():\n    return", "generated_code": "from collections import defaultdict\nfrom collections import deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\ndef I():\n    return int(sys.stdin.readline())\ndef LS():\n    return list(map(list, sys.stdin.readline().split()))\ndef S():\n    return list(sys.stdin.readline())[:-1]\ndef IR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = I()\n    return l\ndef LIR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = LI()\n    return l\ndef SR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = S()\n    return l\ndef LSR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = SR()\n    return l\nmod = 1000000007\ndef A():\n    s = S()\n    t = S()\n    if s + t == t[::-1] + s[::1]:\n        print('YES')else:print('NO')\ndef B():\n    n = I()\n    for i in range(int(n ** 0.5) + 2)[::-1]:\n        if i * i <= n:\n            print(i * i)\n            quit()\ndef C():\n    n = I()\n    a = LI()\n    b = LI()\n    c = LI()\n    q = [0 for i in range(n)]\n    ans = 0\n    a.sort()\n    b.sort()\n    c.sort()\n    for i in range(n):\n        j = bisect.bisect_left(a, b[i])\n        q[i] = j\n    for i in range(n - 1):\n        q[i + 1] += q[i]\n    q.insert(0, 0)\n    for i in range(n):\n        j = bisect.bisect_left(b, c[i])\n        ans += q[j]\n    print(ans)\ndef D():\n    def dijkstra():\n        d = [float('inf') for i in range(k)]\n        q = [[0, 1]]\n        d[1] = 0\n        while q:\n            (dx, x) = heappop(q)\n            for (y, dy) in v[x]:\n                if d[y] > dx + dy:\n                    d[y] = dx + dy\n                    heappush(q, [d[y], y])\n        print(d[0] + 1)\n    k = I()\n    if k == 1:\n        print(1)\n        quit()\n    v = [[] for i in range(k)]\n    for i in range(1, k):\n        v[i].append([(i + 1) % k, 1])\n        v[i].append([(i * 10) % k, 0])\n    dijkstra()\ndef E():\n    return\ndef F():\n    return\ndef G():\n    return\ndef H():\n    return", "score": 0.0, "codebleu": 0.9923222637065301, "crystalbleu": 0.9960534380417496, "codebertscore": 1.0, "codescore": 0.9862737059593201, "surfaceSim": 0.499755859375, "abs_surfaceSim_minus_score": 0.499755859375}
{"golden_code": "class Queue:\n    def __init__(self, values):\n        self.values = values\n    def empty(self):\n        if len(self.values) == 0:\n            return True\n        else:\n            return False\n    def enqueue(self, v):\n        self.values.append(v)\n    def dequeue(self):\n        if len(self.values) <= 0:\n            raise\n        else:\n            v = self.values[0]\n            del self.values[0]\n            return v\n(n, q) = list(map(int, input().split(' ')))\nprocesses = []\nfor i in range(n):\n    (n, t) = input().split(' ')\n    processes.append((n, int(t)))\nqueue = Queue(processes)\nclock = 0\ndone = []\nwhile not (queue.empty()):\n    p = queue.dequeue()\n    n = p[0]\n    t = p[1]\n    if t <= q:\n        clock += t\n        done.append((n, clock))\n    else:\n        queue.enqueue((n, t - q))\n        clock += q\nfor p in done:\n    print(p[0], p[1])", "generated_code": "class Queue:\n    def __init__(self, values):\n        self.values = values\n    def empty(self):\n        if len(self.values) == 0:\n            return True\n        else:\n            return False\n    def enqueue(self, v):\n        self.values.append(v)\n    @classmethod\n    def dequeue(self):\n        if len(self.values) <= 0:\n            raise\n        else:\n            v = self.values[0]\n            del self.values[0]\n            return v(n, q) = list(map(int, input().split(' ')))\nprocesses = []\nfor i in range(n):\n    (n, t) = input().split(' ')\n    processes.append((n, int(t)))\nqueue = Queue(processes)\nclock = 0\ndone = []\nwhile not (queue.empty()):\n    p = queue.dequeue()\n    n = p[0]\n    t = p[1]\n    if t <= q:\n        clock += t\n        done.append((n, clock))\n    else:\n        queue.enqueue((n, t - q))\n        clock += q\nfor p in done:\n    print(p[0], p[1])", "score": 0.0, "codebleu": 0.853479262656621, "crystalbleu": 0.9835387416011647, "codebertscore": 0.98, "codescore": 0.9937356114387512, "surfaceSim": 0.49192618223760093, "abs_surfaceSim_minus_score": 0.49192618223760093}
{"golden_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "generated_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] ** (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "score": 0.0, "codebleu": 0.9950293033173805, "crystalbleu": 0.9972035188725032, "codebertscore": 1.0, "codescore": 0.9831228852272034, "surfaceSim": 0.9996928746928747, "abs_surfaceSim_minus_score": 0.9996928746928747}
{"golden_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "generated_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    @staticmethod\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "score": 0.0, "codebleu": 0.9933297651216333, "crystalbleu": 0.9932615708925326, "codebertscore": 0.99, "codescore": 0.9848809242248535, "surfaceSim": 0.9957446808510638, "abs_surfaceSim_minus_score": 0.9957446808510638}
{"golden_code": "def popcount(x):\n    x = x - ((x >> 1) & 1431655765)\n    x = (x & 858993459) + ((x >> 2) & 858993459)\n    x = (x + (x >> 4)) & 252645135\n    x = x + (x >> 8)\n    x = x + (x >> 16)\n    return x & 127\ncmb = [[0 for i in range(51)] for j in range(51)]\ncmb[0][0] = 1\nfor i in range(51):\n    for j in range(51):\n        if (i != 50 and j != 50):\n            cmb[i + 1][j + 1] += cmb[i][j]\n        if i != 50:\n            cmb[i + 1][j] += cmb[i][j]\nfor i in range(1, 51):\n    for j in range(2, 51):\n        cmb[i][j] += cmb[i][j - 1]\n(N, K, T, S) = list(map(int, input().split()))\na = list(map(int, input().split()))\nmust0 = [i for i in range(18) if (S >> i) & 1 == 0]\nmust1 = [i for i in range(18) if (T >> i) & 1 == 1]\nA = []\nfor val in a:\n    check = True\n    for j in must0:\n        check = check & (val >> j) & 1 == 0\n    for j in must1:\n        check = check & (val >> j) & 1 == 1\n    if check:\n        A.append(val)\nif not A:\n    print(0)\n    exit()\nbit = []\nfor i in range(18):\n    if (i not in must0 and i not in must1):\n        bit.append(i)\nfor i in range(len(A)):\n    temp = 0\n    for j in range(len(bit)):\n        temp += (A[i] >> bit[j]) & 1 == 1 * (2 ** j)\n    A[i] = temp\nans = 0\nn = len(bit)\ndata = [0] * (2 ** n)\nfor i in range(2 ** n):\n    t = set([])\n    for a in A:\n        data[a & i] += 1\n        t.add(a & i)\n    temp = 0\n    for val in t:\n        temp += cmb[data[val]][min(K, data[val])]\n    ans += temp * ((-1) ** popcount(i))\n    for val in t:\n        data[val] = 0\nprint(ans)", "generated_code": "def popcount(x):\n    x = x - ((x >> 1) & 1431655765)\n    x = (x & 858993459) + ((x >> 2) & 858993459)\n    x = (x + (x >> 4)) & 252645135\n    x = x + (x >> 8)\n    x = x + (x >> 16)\n    return x & 127\ncmb = [[0 for i in range(51)] for j in range(51)]\ncmb[0][0] = 1\nfor i in range(51):\n    for j in range(51):\n        if (i != 50 and j != 50):\n            cmb[i + 1][j + 1] += cmb[i][j]\n        if i != 50:\n            cmb[i + 1][j] += cmb[i][j]\nfor i in range(1, 51):\n    for j in range(2, 51):\n        cmb[i][j] += cmb[i][j - 1]\n(N, K, T, S) = list(map(int, input().split()))\npass\nmust0 = [i for i in range(18) if (S >> i) & 1 == 0]\nmust1 = [i for i in range(18) if (T >> i) & 1 == 1]\nA = []\nfor val in a:\n    check = True\n    for j in must0:\n        check = check & (val >> j) & 1 == 0\n    for j in must1:\n        check = check & (val >> j) & 1 == 1\n    if check:\n        A.append(val)\nif not A:\n    print(0)\n    exit()\nbit = []\nfor i in range(18):\n    if (i not in must0 and i not in must1):\n        bit.append(i)\nfor i in range(len(A)):\n    temp = 0\n    for j in range(len(bit)):\n        temp += (A[i] >> bit[j]) & 1 == 1 * (2 ** j)\n    A[i] = temp\nans = 0\nn = len(bit)\ndata = [0] * (2 ** n)\nfor i in range(2 ** n):\n    t = set([])\n    for a in A:\n        data[a & i] += 1\n        t.add(a & i)\n    temp = 0\n    for val in t:\n        temp += cmb[data[val]][min(K, data[val])]\n    ans += temp * ((-1) ** popcount(i))\n    for val in t:\n        data[val] = 0\nprint(ans)", "score": 0.0, "codebleu": 0.9581225612370494, "crystalbleu": 0.9647596558832509, "codebertscore": 0.99, "codescore": 0.9937043786048889, "surfaceSim": 0.9771661360446406, "abs_surfaceSim_minus_score": 0.9771661360446406}
{"golden_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "generated_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "score": 0.0, "codebleu": 0.9838233903573866, "crystalbleu": 0.9942139050865672, "codebertscore": 1.0, "codescore": 0.9935709238052368, "surfaceSim": 0.9988589685075309, "abs_surfaceSim_minus_score": 0.9988589685075309}
{"golden_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "generated_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        __n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "score": 0.0, "codebleu": 0.9564398606786421, "crystalbleu": 0.9936960855615548, "codebertscore": 1.0, "codescore": 0.9819460511207581, "surfaceSim": 0.9984634296250768, "abs_surfaceSim_minus_score": 0.9984634296250768}
{"golden_code": "class UnionFind:\n    def __init__(self, size):\n        self.table = [i for i in range(size)]\n    def find(self, x):\n        return self.table[x]\n    def union(self, x, y):\n        x1 = self.find(x)\n        y1 = self.find(y)\n        if x1 == y1:\n            return False\n        for i in range(len(self.table)):\n            if self.table[i] == y1:\n                self.table[i] = x1\n        return True\n(N, M) = list(map(int, input().split()))\nedges = []\nfor _ in range(M):\n    (a, b) = list(map(int, input().split()))\n    edges.append([a - 1, b - 1])\nmat = [[0] * N for _ in range(N)]\nfor (s, g) in edges:\n    mat[s][g] = 1\n    mat[g][s] = 1\nans = 0\nfor i in range(M):\n    uni = UnionFind(N)\n    for j in range(M):\n        if i != j:\n            uni.union(edges[j][0], edges[j][1])\n    if not (all((uni.find(0) == uni.find(x) for x in range(N)))):\n        ans += 1\nprint(ans)", "generated_code": "class UnionFind:\n    def __init__(self, size):\n        self.table = [i for i in range(size)]\n    def find(self, x):\n        return self.table[x]\n    def union(self, x, y):\n        x1 = self.find(x)\n        y1 = self.find(y)\n        if x1 == y1:\n            return False\n        for i in range(len(self.table)):\n            if self.table[i] == y1:\n                self.table[i] = x1\n        return True\n(N, M) = list(map(int, input().split()))\nedges = []\nfor _ in range(M):\n    (a, b) = list(map(int, input().split()))\n    edges.append([a - 1, b - 1])\nmat = [[0] ** N for _ in range(N)]\nfor (s, g) in edges:\n    mat[s][g] = 1\n    mat[g][s] = 1\nans = 0\nfor i in range(M):\n    uni = UnionFind(N)\n    for j in range(M):\n        if i != j:\n            uni.union(edges[j][0], edges[j][1])\n    if not (all((uni.find(0) == uni.find(x) for x in range(N)))):\n        ans += 1\nprint(ans)", "score": 0.0, "codebleu": 0.9898100982097378, "crystalbleu": 0.9882506574211402, "codebertscore": 1.0, "codescore": 0.9936927556991577, "surfaceSim": 0.9700174590384099, "abs_surfaceSim_minus_score": 0.9700174590384099}
{"golden_code": "import sys\n(n, m, *abcdef) = list(map(int, sys.stdin.buffer.read().split()))\nver_lines = []\nhor_lines = []\nx_list = set()\ny_list = set()\nn3 = n * 3\nfor (a, b, c) in zip(abcdef[0:n3:3], abcdef[1:n3:3], abcdef[2:n3:3]):\n    y_list.add(a)\n    y_list.add(b)\n    x_list.add(c)\n    ver_lines.append((a, b, c))\nfor (d, e, f) in zip(abcdef[n3 + 0::3], abcdef[n3 + 1::3], abcdef[n3 + 2::3]):\n    y_list.add(d)\n    x_list.add(e)\n    x_list.add(f)\n    hor_lines.append((d, e, f))\nx_list.add(0)\ny_list.add(0)\nx_list = sorted(x_list)\ny_list = sorted(y_list)\nx_dict = {x: i for (i, x) in enumerate(x_list, start=1)}\ny_dict = {y: i for (i, y) in enumerate(y_list, start=1)}\nrow_real = len(x_list)\ncol_real = len(y_list)\nrow = row_real + 2\ncol = col_real + 2\nbanned_up_ij = [[0] * row for _ in range(col)]\nbanned_down_ij = [[0] * row for _ in range(col)]\nbanned_left_ij = [[0] * col for _ in range(row)]\nbanned_right_ij = [[0] * col for _ in range(row)]\nfor (a, b, c) in ver_lines:\n    if a > b:\n        (a, b) = (b, a)\n    ai = y_dict[a]\n    bi = y_dict[b]\n    j = x_dict[c]\n    banned_left_ij[j][ai] += 1\n    banned_left_ij[j][bi] -= 1\n    banned_right_ij[j - 1][ai] += 1\n    banned_right_ij[j - 1][bi] -= 1\nfor (d, e, f) in hor_lines:\n    if e > f:\n        (e, f) = (f, e)\n    i = y_dict[d]\n    ej = x_dict[e]\n    fj = x_dict[f]\n    banned_up_ij[i][ej] += 1\n    banned_up_ij[i][fj] -= 1\n    banned_down_ij[i - 1][ej] += 1\n    banned_down_ij[i - 1][fj] -= 1\nbanned_up = [0] * (row * col)\nbanned_down = [0] * (row * col)\nbanned_left = [0] * (row * col)\nbanned_right = [0] * (row * col)\nfor i in range(col):\n    ru = banned_up_ij[i]\n    rd = banned_down_ij[i]\n    ri = row * i\n    banned_up[ri] = ru[0]\n    banned_down[ri] = rd[0]\n    for j in range(1, row):\n        banned_up[ri + j] = banned_up[(ri + j) - 1] + ru[j]\n        banned_down[ri + j] = banned_down[(ri + j) - 1] + rd[j]\nfor j in range(row):\n    rl = banned_left_ij[j]\n    rr = banned_right_ij[j]\n    banned_left[j] = rl[0]\n    banned_right[j] = rr[0]\n    for i in range(1, col):\n        ri0 = (i - 1) * row\n        ri1 = i * row\n        banned_left[ri1 + j] = banned_left[ri0 + j] + rl[i]\n        banned_right[ri1 + j] = banned_right[ri0 + j] + rr[i]\ns = (row * y_dict[0]) + x_dict[0]\nenable = (([-1] * row) + ((([-1] + ([0] * (row - 2))) + [-1]) * (col - 2))) + ([-1] * row)\nq = [s]\nmoves = [(-row, banned_up), (-1, banned_left), (1, banned_right), (row, banned_down)]\nwhile q:\n    c = q.pop()\n    if enable[c] == 1:\n        continue\n    elif enable[c] == -1:\n        print('INF')\n        exit()\n    enable[c] = 1\n    for (dc, banned) in moves:\n        if banned[c]:\n            continue\n        nc = c + dc\n        if enable[nc] == 1:\n            continue\n        q.append(nc)\nans = 0\nfor i in range(col):\n    ri = i * row\n    for j in range(row):\n        if enable[ri + j] != 1:\n            continue\n        t = y_list[i - 1]\n        b = y_list[i]\n        l = x_list[j - 1]\n        r = x_list[j]\n        ans += (b - t) * (r - l)\nprint(ans)", "generated_code": "import sys\n(n, m, *abcdef) = list(map(int, sys.stdin.buffer.read().split()))\nver_lines = []\nhor_lines = []\nx_list = set()\ny_list = set()\nn3 = n * 3\nfor (a, b, c) in zip(abcdef[0:n3:3], abcdef[1:n3:3], abcdef[2:n3:3]):\n    y_list.add(a)\n    y_list.add(b)\n    x_list.add(c)\n    ver_lines.append((a, b, c))\nfor (d, e, f) in zip(abcdef[n3 + 0::3], abcdef[n3 + 1::3], abcdef[n3 + 2::3]):\n    y_list.add(d)\n    x_list.add(e)\n    x_list.add(f)\n    hor_lines.append((d, e, f))\nx_list.add(0)\ny_list.add(0)\nx_list = sorted(x_list)\ny_list = sorted(y_list)\nx_dict = {x: i for (i, x) in enumerate(x_list, start=1)}\ny_dict = {y: i for (i, y) in enumerate(y_list, start=1)}\nrow_real = len(x_list)\ncol_real = len(y_list)\nrow = row_real + 2\ncol = col_real + 2\nbanned_up_ij = [[0] * row for _ in range(col)]\nbanned_down_ij = [[0] * row for _ in range(col)]\nbanned_left_ij = [[0] * col for _ in range(row)]\nbanned_right_ij = [[0] * col for _ in range(row)]\nfor (a, b, c) in ver_lines:\n    if a > b:\n        (a, b) = (b, a)\n    ai = y_dict[a]\n    bi = y_dict[b]\n    j = x_dict[c]\n    banned_left_ij[j][ai] += 1\n    banned_left_ij[j][bi] -= 1\n    banned_right_ij[j - 1][ai] += 1\n    banned_right_ij[j - 1][bi] -= 1\nfor (d, e, f) in hor_lines:\n    if e > f:\n        (e, f) = (f, e)\n    i = y_dict[d]\n    ej = x_dict[e]\n    fj = x_dict[f]\n    banned_up_ij[i][ej] += 1\n    banned_up_ij[i][fj] -= 1\n    banned_down_ij[i - 1][ej] += 1\n    banned_down_ij[i - 1][fj] -= 1\nbanned_up = [0] * (row * col)\nbanned_down = [0] * (row * col)\nbanned_left = [0] * (row * col)\nbanned_right = [0] * (row * col)\nfor i in range(col):\n    ru = banned_up_ij[i]\n    rd = banned_down_ij[i]\n    ri = row * i\n    banned_up[ri] = ru[0]\n    banned_down[ri] = rd[0]\n    for j in range(1, row):\n        banned_up[ri + j] = banned_up[(ri + j) - 1] + ru[j]\n        banned_down[ri + j] = banned_down[(ri + j) - 1] + rd[j]\nfor j in range(row):\n    rl = banned_left_ij[j]\n    rr = banned_right_ij[j]\n    banned_left[j] = rl[0]\n    banned_right[j] = rr[0]\n    for i in range(1, col):\n        ri0 = (i - 1) * row\n        ri1 = i * row\n        banned_left[ri1 + j] = banned_left[ri0 + j] + rl[i]\n        banned_right[ri1 + j] = banned_right[ri0 + j] + rr[i]\ns = (row * y_dict[0]) + x_dict[0]\nenable = (([-1] * row) + ((([-1] + ([0] * (row - 2))) + [-1]) * (col - 2))) + ([-1] ** row)\nq = [s]\nmoves = [(-row, banned_up), (-1, banned_left), (1, banned_right), (row, banned_down)]\nwhile q:\n    c = q.pop()\n    if enable[c] == 1:\n        continue\n    elif enable[c] == -1:\n        print('INF')\n        exit()\n    enable[c] = 1\n    for (dc, banned) in moves:\n        if banned[c]:\n            continue\n        nc = c + dc\n        if enable[nc] == 1:\n            continue\n        q.append(nc)\nans = 0\nfor i in range(col):\n    ri = i * row\n    for j in range(row):\n        if enable[ri + j] != 1:\n            continue\n        t = y_list[i - 1]\n        b = y_list[i]\n        l = x_list[j - 1]\n        r = x_list[j]\n        ans += (b - t) * (r - l)\nprint(ans)", "score": 0.0, "codebleu": 0.9973984967720897, "crystalbleu": 0.9984515353021304, "codebertscore": 1.0, "codescore": 0.9542193412780762, "surfaceSim": 0.9863192624062189, "abs_surfaceSim_minus_score": 0.9863192624062189}
{"golden_code": "import sys\n(n, m, *abcdef) = list(map(int, sys.stdin.buffer.read().split()))\nver_lines = []\nhor_lines = []\nx_list = set()\ny_list = set()\nn3 = n * 3\nfor (a, b, c) in zip(abcdef[0:n3:3], abcdef[1:n3:3], abcdef[2:n3:3]):\n    y_list.add(a)\n    y_list.add(b)\n    x_list.add(c)\n    ver_lines.append((a, b, c))\nfor (d, e, f) in zip(abcdef[n3 + 0::3], abcdef[n3 + 1::3], abcdef[n3 + 2::3]):\n    y_list.add(d)\n    x_list.add(e)\n    x_list.add(f)\n    hor_lines.append((d, e, f))\nx_list.add(0)\ny_list.add(0)\nx_list = sorted(x_list)\ny_list = sorted(y_list)\nx_dict = {x: i for (i, x) in enumerate(x_list, start=1)}\ny_dict = {y: i for (i, y) in enumerate(y_list, start=1)}\nrow_real = len(x_list)\ncol_real = len(y_list)\nrow = row_real + 2\ncol = col_real + 2\nbanned_up_ij = [[0] * row for _ in range(col)]\nbanned_down_ij = [[0] * row for _ in range(col)]\nbanned_left_ij = [[0] * col for _ in range(row)]\nbanned_right_ij = [[0] * col for _ in range(row)]\nfor (a, b, c) in ver_lines:\n    if a > b:\n        (a, b) = (b, a)\n    ai = y_dict[a]\n    bi = y_dict[b]\n    j = x_dict[c]\n    banned_left_ij[j][ai] += 1\n    banned_left_ij[j][bi] -= 1\n    banned_right_ij[j - 1][ai] += 1\n    banned_right_ij[j - 1][bi] -= 1\nfor (d, e, f) in hor_lines:\n    if e > f:\n        (e, f) = (f, e)\n    i = y_dict[d]\n    ej = x_dict[e]\n    fj = x_dict[f]\n    banned_up_ij[i][ej] += 1\n    banned_up_ij[i][fj] -= 1\n    banned_down_ij[i - 1][ej] += 1\n    banned_down_ij[i - 1][fj] -= 1\nbanned_up = [0] * (row * col)\nbanned_down = [0] * (row * col)\nbanned_left = [0] * (row * col)\nbanned_right = [0] * (row * col)\nfor i in range(col):\n    ru = banned_up_ij[i]\n    rd = banned_down_ij[i]\n    ri = row * i\n    banned_up[ri] = ru[0]\n    banned_down[ri] = rd[0]\n    for j in range(1, row):\n        banned_up[ri + j] = banned_up[(ri + j) - 1] + ru[j]\n        banned_down[ri + j] = banned_down[(ri + j) - 1] + rd[j]\nfor j in range(row):\n    rl = banned_left_ij[j]\n    rr = banned_right_ij[j]\n    banned_left[j] = rl[0]\n    banned_right[j] = rr[0]\n    for i in range(1, col):\n        ri0 = (i - 1) * row\n        ri1 = i * row\n        banned_left[ri1 + j] = banned_left[ri0 + j] + rl[i]\n        banned_right[ri1 + j] = banned_right[ri0 + j] + rr[i]\ns = (row * y_dict[0]) + x_dict[0]\nenable = (([-1] * row) + ((([-1] + ([0] * (row - 2))) + [-1]) * (col - 2))) + ([-1] * row)\nq = [s]\nmoves = [(-row, banned_up), (-1, banned_left), (1, banned_right), (row, banned_down)]\nwhile q:\n    c = q.pop()\n    if enable[c] == 1:\n        continue\n    elif enable[c] == -1:\n        print('INF')\n        exit()\n    enable[c] = 1\n    for (dc, banned) in moves:\n        if banned[c]:\n            continue\n        nc = c + dc\n        if enable[nc] == 1:\n            continue\n        q.append(nc)\nans = 0\nfor i in range(col):\n    ri = i * row\n    for j in range(row):\n        if enable[ri + j] != 1:\n            continue\n        t = y_list[i - 1]\n        b = y_list[i]\n        l = x_list[j - 1]\n        r = x_list[j]\n        ans += (b - t) * (r - l)\nprint(ans)", "generated_code": "import sys\n(n, m, *abcdef) = list(map(int, sys.stdin.buffer.read().split()))\nver_lines = []\nhor_lines = []\nx_list = set()\ny_list = set()\nn3 = n * 3\nfor (a, b, c) in zip(abcdef[0:n3:3], abcdef[1:n3:3], abcdef[2:n3:3]):\n    y_list.add(a)\n    y_list.add(b)\n    x_list.add(c)\n    ver_lines.append((a, b, c))\nfor (d, e, f) in zip(abcdef[n3 + 0::3], abcdef[n3 + 1::3], abcdef[n3 + 2::3]):\n    y_list.add(d)\n    x_list.add(e)\n    x_list.add(f)\n    hor_lines.append((d, e, f))\nx_list.add(0)\ny_list.add(0)\nx_list = sorted(x_list)\ny_list = sorted(y_list)\nx_dict = {x: i for (i, x) in enumerate(x_list, start=1)}\ny_dict = {y: i for (i, y) in enumerate(y_list, start=1)}\nrow_real = len(x_list)\ncol_real = len(y_list)\nrow = row_real + 2\ncol = col_real + 2\nbanned_up_ij = [[0] * row for _ in range(col)]\nbanned_down_ij = [[0] * row for _ in range(col)]\nbanned_left_ij = [[0] * col for _ in range(row)]\nbanned_right_ij = [[0] * col for _ in range(row)]\nfor (a, b, c) in ver_lines:\n    if a > b:\n        (a, b) = (b, a)\n    ai = y_dict[a]\n    bi = y_dict[b]\n    j = x_dict[c]\n    banned_left_ij[j][ai] += 1\n    banned_left_ij[j][bi] -= 1\n    banned_right_ij[j - 1][ai] += 1\n    banned_right_ij[j - 1][bi] -= 1\nfor (d, e, f) in hor_lines:\n    if e > f:\n        (e, f) = (f, e)\n    i = y_dict[d]\n    ej = x_dict[e]\n    fj = x_dict[f]\n    banned_up_ij[i][ej] += 1\n    banned_up_ij[i][fj] -= 1\n    banned_down_ij[i - 1][ej] += 1\n    banned_down_ij[i - 1][fj] -= 1\nbanned_up = [0] * (row * col)\nbanned_down = [0] * (row * col)\nbanned_left = [0] * (row * col)\nbanned_right = [0] * (row * col)\nfor i in range(col):\n    ru = banned_up_ij[i]\n    rd = banned_down_ij[i]\n    ri = row * i\n    banned_up[ri] = ru[0]\n    banned_down[ri] = rd[0]\n    for j in range(1, row):\n        banned_up[ri + j] = banned_up[(ri + j) - 1] + ru[j]\n        banned_down[ri + j] = banned_down[(ri + j) - 1] + rd[j]\nfor j in range(row):\n    rl = banned_left_ij[j]\n    rr = banned_right_ij[j]\n    banned_left[j] = rl[0]\n    banned_right[j] = rr[0]\n    for i in range(1, col):\n        ri0 = (i - 1) * row\n        ri1 = i * row\n        banned_left[ri1 + j] = banned_left[ri0 + j] + rl[i]\n        banned_right[ri1 + j] = banned_right[ri0 + j] + rr[i]\ns = (row * y_dict[0]) + x_dict[0]\nenable = (([-1] * row) + ((([-1] + ([0] * (row - 2))) + [-1]) * (col - 2))) - ([-1] * row)\nq = [s]\nmoves = [(-row, banned_up), (-1, banned_left), (1, banned_right), (row, banned_down)]\nwhile q:\n    c = q.pop()\n    if enable[c] == 1:\n        continue\n    elif enable[c] == -1:\n        print('INF')\n        exit()\n    enable[c] = 1\n    for (dc, banned) in moves:\n        if banned[c]:\n            continue\n        nc = c + dc\n        if enable[nc] == 1:\n            continue\n        q.append(nc)\nans = 0\nfor i in range(col):\n    ri = i * row\n    for j in range(row):\n        if enable[ri + j] != 1:\n            continue\n        t = y_list[i - 1]\n        b = y_list[i]\n        l = x_list[j - 1]\n        r = x_list[j]\n        ans += (b - t) * (r - l)\nprint(ans)", "score": 0.0, "codebleu": 0.9973984967720897, "crystalbleu": 0.9976473158075668, "codebertscore": 1.0, "codescore": 0.9542193412780762, "surfaceSim": 0.9998327199732352, "abs_surfaceSim_minus_score": 0.9998327199732352}
{"golden_code": "import math, sys\nn = int(sys.stdin.readline())\na = tuple(map(int, sys.stdin.readline().split()))\ng = math.gcd(a[0], a[1])\nfor i in range(2, n):\n    g = math.gcd(g, a[i])\nM = max(a)\nacc = a[0]\nfor i in range(n):\n    acc = math.gcd(acc, a[i])\nif acc != 1:\n    print('not coprime')\n    exit()\nLIMIT = max(a)\nminPrime = [0] * (LIMIT + 1)\nminPrime[1] = 1\ndef make():\n    for i in range(2, LIMIT + 1):\n        if minPrime[i] == 0:\n            minPrime[i] = i\n            for j in range(i + i, LIMIT + 1, i):\n                if minPrime[j] == 0:\n                    minPrime[j] = i\nmake()\ndef factrial(N):\n    ret = []\n    while minPrime[N] != N:\n        ret.append(minPrime[N])\n        N = N // minPrime[N]\n    if N != 1:\n        ret.append(N)\n    return ret\njudge = set([])\npc = True\npairwise = True\np = set()\nfor e in a:\n    if not pairwise:\n        break\n    asf = set(factrial(e))\n    if judge & asf != set():\n        pc = False\n    judge |= asf\nif pc:\n    print('pairwise coprime')\nelif g == 1:\n    print('setwise coprime')\nelse:\n    print('not coprime')", "generated_code": "import math, sys\npass\na = tuple(map(int, sys.stdin.readline().split()))\ng = math.gcd(a[0], a[1])\nfor i in range(2, n):\n    g = math.gcd(g, a[i])\nM = max(a)\nacc = a[0]\nfor i in range(n):\n    acc = math.gcd(acc, a[i])\nif acc != 1:\n    print('not coprime')\n    exit()\nLIMIT = max(a)\nminPrime = [0] * (LIMIT + 1)\nminPrime[1] = 1\ndef make():\n    for i in range(2, LIMIT + 1):\n        if minPrime[i] == 0:\n            minPrime[i] = i\n            for j in range(i + i, LIMIT + 1, i):\n                if minPrime[j] == 0:\n                    minPrime[j] = i\nmake()\ndef factrial(N):\n    ret = []\n    while minPrime[N] != N:\n        ret.append(minPrime[N])\n        N = N // minPrime[N]\n    if N != 1:\n        ret.append(N)\n    return ret\njudge = set([])\npc = True\npairwise = True\np = set()\nfor e in a:\n    if not pairwise:\n        break\n    asf = set(factrial(e))\n    if judge & asf != set():\n        pc = False\n    judge |= asf\nif pc:\n    print('pairwise coprime')\nelif g == 1:\n    print('setwise coprime')\nelse:\n    print('not coprime')", "score": 0.0, "codebleu": 0.9111907358780357, "crystalbleu": 0.9559320614638346, "codebertscore": 0.99, "codescore": 0.9937435984611511, "surfaceSim": 0.9738434405101072, "abs_surfaceSim_minus_score": 0.9738434405101072}
{"golden_code": "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nfac = [1, 1]\nf_inv = [1, 1]\ninv = [0, 1]\ndef prepare(n, mod):\n    for i in range(2, n + 1):\n        fac.append((fac[-1] * i) % mod)\n        inv.append(((-(inv[mod % i])) * (mod // i)) % mod)\n        f_inv.append((f_inv[-1] * inv[-1]) % mod)\ndef cmb(n, r, mod):\n    if (n < 0 or r < 0):\n        return 0\n    if r > n:\n        return 0\n    return ((fac[n] * f_inv[r]) * f_inv[n - r]) % mod\ndef main():\n    (N, M, K) = list(map(int, readline().split()))\n    MOD = 998244353\n    prepare(N + 10, MOD)\n    if (M == 1 and K == N - 1):\n        print(1)\n        exit()\n    m = M\n    for _ in range(N - 1):\n        m *= M - 1\n        m %= MOD\n    ans = 0\n    for k in range(K + 1):\n        ans += (m * cmb(N - 1, k, MOD)) % MOD\n        ans %= MOD\n        m *= pow(M - 1, MOD - 2, MOD)\n        m %= MOD\n    print(ans)", "generated_code": "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nfac = [1, 1]\nf_inv = [1, 1]\ninv = [0, 1]\ndef prepare(n, mod):\n    for i in range(2, n + 1):\n        fac.append((fac[1] * i) % mod)\n        inv.append(((-(inv[mod % i])) * (mod // i)) % mod)\n        f_inv.append((f_inv[-1] * inv[-1]) % mod)\ndef cmb(n, r, mod):\n    if (n < 0 or r < 0):\n        return 0\n    if r > n:\n        return 0\n    return ((fac[n] * f_inv[r]) * f_inv[n - r]) % mod\ndef main():\n    (N, M, K) = list(map(int, readline().split()))\n    MOD = 998244353\n    prepare(N + 10, MOD)\n    if (M == 1 and K == N - 1):\n        print(1)\n        exit()\n    m = M\n    for _ in range(N - 1):\n        m *= M - 1\n        m %= MOD\n    ans = 0\n    for k in range(K + 1):\n        ans += (m * cmb(N - 1, k, MOD)) % MOD\n        ans %= MOD\n        m *= pow(M - 1, MOD - 2, MOD)\n        m %= MOD\n    print(ans)", "score": 0.0, "codebleu": 0.9755236812410836, "crystalbleu": 0.9919065664360349, "codebertscore": 1.0, "codescore": 0.9937313199043274, "surfaceSim": 0.9994450610432852, "abs_surfaceSim_minus_score": 0.9994450610432852}
{"golden_code": "class UnionFind:\n    def __init__(self, size):\n        self.table = [i for i in range(size)]\n    def find(self, x):\n        return self.table[x]\n    def union(self, x, y):\n        x1 = self.find(x)\n        y1 = self.find(y)\n        if x1 == y1:\n            return False\n        for i in range(len(self.table)):\n            if self.table[i] == y1:\n                self.table[i] = x1\n        return True\n(N, M) = list(map(int, input().split()))\nedges = []\nfor _ in range(M):\n    (a, b) = list(map(int, input().split()))\n    edges.append([a - 1, b - 1])\nmat = [[0] * N for _ in range(N)]\nfor (s, g) in edges:\n    mat[s][g] = 1\n    mat[g][s] = 1\nans = 0\nfor i in range(M):\n    uni = UnionFind(N)\n    for j in range(M):\n        if i != j:\n            uni.union(edges[j][0], edges[j][1])\n    if not (all((uni.find(0) == uni.find(x) for x in range(N)))):\n        ans += 1\nprint(ans)", "generated_code": "class UnionFind:\n    def __init__(self, size):\n        self.table = [i for i in range(size)]\n    def find(self, x):\n        return self.table[x]\n    def union(self, x, y):\n        x1 = self.find(x)\n        y1 = self.find(y)\n        if x1 == y1:\n            return False\n        for i in range(len(self.table)):\n            if self.table[i] == y1:\n                self.table[i] = x1\n        return True\n(N, M) = list(map(int, input().split()))\nedges = []\nfor _ in range(M):\n    (a, b) = list(map(int, input().split()))\n    edges.append([a - 1, b - 1])\nmat = [[0] // N for _ in range(N)]\nfor (s, g) in edges:\n    mat[s][g] = 1\n    mat[g][s] = 1\nans = 0\nfor i in range(M):\n    uni = UnionFind(N)\n    for j in range(M):\n        if i != j:\n            uni.union(edges[j][0], edges[j][1])\n    if not (all((uni.find(0) == uni.find(x) for x in range(N)))):\n        ans += 1\nprint(ans)", "score": 0.0, "codebleu": 0.9898100982097378, "crystalbleu": 0.9761951409275657, "codebertscore": 1.0, "codescore": 0.9937119483947754, "surfaceSim": 0.9694466827827022, "abs_surfaceSim_minus_score": 0.9694466827827022}
{"golden_code": "import sys\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\ndef solve():\n    inf = (10 ** 14) + 10\n    def dfs(v: 'vertex_index, 0-indexed') -> None:\n        for (c, t) in e[v]:\n            if d[t] != inf:\n                continue\n            d[t] = d[v] + c\n            dfs(t)\n    n = int(eval(input()))\n    e = tuple((set() for _ in range(n)))\n    for _ in range(n - 1):\n        (a, b, c) = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        e[a].add((c, b))\n        e[b].add((c, a))\n    (q, v) = list(map(int, input().split()))\n    v -= 1\n    d = [inf] * n\n    d[v] = 0\n    dfs(v)\n    for _ in range(q):\n        (x, y) = list(map(int, input().split()))\n        x -= 1\n        y -= 1\n        print(d[x] + d[y])", "generated_code": "import sys\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\ndef solve():\n    inf = (10 ** 14) + 10\n    def dfs(v: 'vertex_index, 0-indexed') -> None:\n        for (c, t) in e[v]:\n            if d[t] != inf:\n                continue\n            d[t] = d[v] + c\n            dfs(t)\n    n = int(eval(input()))\n    e = tuple((set() for _ in range(n)))\n    for _ in range(n - 1):\n        (a, b, c) = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        e[a].add((c, b))\n        e[b].add((c, a))\n    (q, v) = list(map(int, input().split()))\n    v -= 1\n    d = [inf] * n\n    d[v] = 0\n    dfs(v)\n    for _ in range(q):\n        (x, y) = list(map(int, input().split()))\n        x -= 1\n        y -= 1\n        print(d[x] - d[y])", "score": 0.0, "codebleu": 0.9917965913003897, "crystalbleu": 0.9907582847077829, "codebertscore": 1.0, "codescore": 0.9938232898712158, "surfaceSim": 0.9993243243243244, "abs_surfaceSim_minus_score": 0.9993243243243244}
{"golden_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "generated_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] // self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "score": 0.0, "codebleu": 0.9945883912637858, "crystalbleu": 0.9915876446894797, "codebertscore": 1.0, "codescore": 0.9935296177864075, "surfaceSim": 0.986723282799925, "abs_surfaceSim_minus_score": 0.986723282799925}
{"golden_code": "import math, sys\nn = int(sys.stdin.readline())\na = tuple(map(int, sys.stdin.readline().split()))\ng = math.gcd(a[0], a[1])\nfor i in range(2, n):\n    g = math.gcd(g, a[i])\nM = max(a)\nacc = a[0]\nfor i in range(n):\n    acc = math.gcd(acc, a[i])\nif acc != 1:\n    print('not coprime')\n    exit()\nLIMIT = max(a)\nminPrime = [0] * (LIMIT + 1)\nminPrime[1] = 1\ndef make():\n    for i in range(2, LIMIT + 1):\n        if minPrime[i] == 0:\n            minPrime[i] = i\n            for j in range(i + i, LIMIT + 1, i):\n                if minPrime[j] == 0:\n                    minPrime[j] = i\nmake()\ndef factrial(N):\n    ret = []\n    while minPrime[N] != N:\n        ret.append(minPrime[N])\n        N = N // minPrime[N]\n    if N != 1:\n        ret.append(N)\n    return ret\njudge = set([])\npc = True\npairwise = True\np = set()\nfor e in a:\n    if not pairwise:\n        break\n    asf = set(factrial(e))\n    if judge & asf != set():\n        pc = False\n    judge |= asf\nif pc:\n    print('pairwise coprime')\nelif g == 1:\n    print('setwise coprime')\nelse:\n    print('not coprime')", "generated_code": "import math, sys\nn = int(sys.stdin.readline())\na = tuple(map(int, sys.stdin.readline().split()))\ng = math.gcd(a[0], a[1])\nfor i in range(2, n):\n    g = math.gcd(g, a[i])\nM = max(a)\nacc = a[0]\nfor i in range(n):\n    acc = math.gcd(acc, a[i])\nif acc != 1:\n    print('not coprime')\n    exit()\nLIMIT = max(a)\nminPrime = [0] * (LIMIT + 1)\nminPrime[1] = 1\ndef make():\n    for i in range(2, LIMIT + 1):\n        if minPrime[i] == 0:\n            minPrime[i] = i\n            for j in range(i + i, LIMIT + 1, i):\n                if minPrime[j] == 0:\n                    minPrime[j] = i\nmake()\ndef factrial(N):\n    ret = []\n    while minPrime[N] != N:\n        ret.append(minPrime[N])\n        N = N // minPrime[N]\n    if N != 1:\n        ret.append(N)\n    return ret\njudge = set([])\npc = True\npairwise = True\np = set()\nfor e in a:\n    if not pairwise:\n        break\n    asf = set(factrial(e))\n    if judge & asf != set():\n        pc = False\n    judge |= asf\n    break\nif pc:\n    print('pairwise coprime')elif g == 1:\n    print('setwise coprime')\nelse:\n    print('not coprime')", "score": 0.0, "codebleu": 0.9695590696930568, "crystalbleu": 0.9890192409220128, "codebertscore": 1.0, "codescore": 0.9937384128570557, "surfaceSim": 0.4967043314500942, "abs_surfaceSim_minus_score": 0.4967043314500942}
{"golden_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "generated_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 / N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "score": 0.0, "codebleu": 0.9963221036285097, "crystalbleu": 0.9937384331224636, "codebertscore": 1.0, "codescore": 0.9856463074684143, "surfaceSim": 0.9890647900136453, "abs_surfaceSim_minus_score": 0.9890647900136453}
{"golden_code": "from collections import defaultdict\nfrom collections import deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\ndef I():\n    return int(sys.stdin.readline())\ndef LS():\n    return list(map(list, sys.stdin.readline().split()))\ndef S():\n    return list(sys.stdin.readline())[:-1]\ndef IR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = I()\n    return l\ndef LIR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = LI()\n    return l\ndef SR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = S()\n    return l\ndef LSR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = SR()\n    return l\nmod = 1000000007\ndef A():\n    s = S()\n    t = S()\n    if s + t == t[::-1] + s[::-1]:\n        print('YES')else:print('NO')\ndef B():\n    n = I()\n    for i in range(int(n ** 0.5) + 2)[::-1]:\n        if i * i <= n:\n            print(i * i)\n            quit()\ndef C():\n    n = I()\n    a = LI()\n    b = LI()\n    c = LI()\n    q = [0 for i in range(n)]\n    ans = 0\n    a.sort()\n    b.sort()\n    c.sort()\n    for i in range(n):\n        j = bisect.bisect_left(a, b[i])\n        q[i] = j\n    for i in range(n - 1):\n        q[i + 1] += q[i]\n    q.insert(0, 0)\n    for i in range(n):\n        j = bisect.bisect_left(b, c[i])\n        ans += q[j]\n    print(ans)\ndef D():\n    def dijkstra():\n        d = [float('inf') for i in range(k)]\n        q = [[0, 1]]\n        d[1] = 0\n        while q:\n            (dx, x) = heappop(q)\n            for (y, dy) in v[x]:\n                if d[y] > dx + dy:\n                    d[y] = dx + dy\n                    heappush(q, [d[y], y])\n        print(d[0] + 1)\n    k = I()\n    if k == 1:\n        print(1)\n        quit()\n    v = [[] for i in range(k)]\n    for i in range(1, k):\n        v[i].append([(i + 1) % k, 1])\n        v[i].append([(i * 10) % k, 0])\n    dijkstra()\ndef E():\n    return\ndef F():\n    return\ndef G():\n    return\ndef H():\n    return", "generated_code": "from collections import defaultdict\nfrom collections import deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\ndef I():\n    return int(sys.stdin.readline())\ndef LS():\n    return list(map(list, sys.stdin.readline().split()))\ndef S():\n    return list(sys.stdin.readline())[:-1]\ndef IR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = I()\n    return l\ndef LIR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = LI()\n    return l\ndef SR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = S()\n    return l\ndef LSR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = SR()\n    return l\nmod = 1000000007\ndef A():\n    s = S()\n    t = S()\n    if s - t == t[::-1] + s[::-1]:\n        print('YES')else:print('NO')\ndef B():\n    n = I()\n    for i in range(int(n ** 0.5) + 2)[::-1]:\n        if i * i <= n:\n            print(i * i)\n            quit()\ndef C():\n    n = I()\n    a = LI()\n    b = LI()\n    c = LI()\n    q = [0 for i in range(n)]\n    ans = 0\n    a.sort()\n    b.sort()\n    c.sort()\n    for i in range(n):\n        j = bisect.bisect_left(a, b[i])\n        q[i] = j\n    for i in range(n - 1):\n        q[i + 1] += q[i]\n    q.insert(0, 0)\n    for i in range(n):\n        j = bisect.bisect_left(b, c[i])\n        ans += q[j]\n    print(ans)\ndef D():\n    def dijkstra():\n        d = [float('inf') for i in range(k)]\n        q = [[0, 1]]\n        d[1] = 0\n        while q:\n            (dx, x) = heappop(q)\n            for (y, dy) in v[x]:\n                if d[y] > dx + dy:\n                    d[y] = dx + dy\n                    heappush(q, [d[y], y])\n        print(d[0] + 1)\n    k = I()\n    if k == 1:\n        print(1)\n        quit()\n    v = [[] for i in range(k)]\n    for i in range(1, k):\n        v[i].append([(i + 1) % k, 1])\n        v[i].append([(i * 10) % k, 0])\n    dijkstra()\ndef E():\n    return\ndef F():\n    return\ndef G():\n    return\ndef H():\n    return", "score": 0.0, "codebleu": 0.9960259674102339, "crystalbleu": 0.9948180583890528, "codebertscore": 1.0, "codescore": 0.986501157283783, "surfaceSim": 0.499755859375, "abs_surfaceSim_minus_score": 0.499755859375}
{"golden_code": "n = int(eval(input()))\nnode = {i: [] for i in range(1, n + 1)}\nvisited = [False for i in range(n + 1)]\nq = []\nfor _ in range(n - 1):\n    (a, b) = list(map(int, input().split()))\n    node[a].append(b)\n    node[b].append(a)\n    q.append((a, b))\nmother = q[0][0]\nvisited[mother] = True\nd = []\ne = []\npaint = {i: {} for i in range(1, n + 1)}\nmother_paint = [0 for i in range(n + 1)]\nc = 1\nfor child in node[mother]:\n    visited[child] = True\n    paint[mother][child] = c\n    paint[child][mother] = c\n    mother_paint[child] = c\n    c += 1\n    d.append(child)\nwhile d:\n    for parent in d:\n        p = 1\n        for child in node[parent]:\n            if visited[child] == False:\n                visited[child] = True\n                if p != mother_paint[parent]:\n                    paint[parent][child] = p\n                    paint[child][parent] = p\n                    mother_paint[child] = p\n                    p += 1\n                    e.append(child)\n                else:\n                    p += 1\n                    paint[parent][child] = p\n                    paint[child][parent] = p\n                    mother_paint[child] = p\n                    p += 1\n                    e.append(child)\n    if e:\n        d = e\n        e = []\n    else:\n        d = []\n        e = []\nK = 0\nfor i in range(1, n + 1):\n    K = max(K, len(node[i]))\nprint(K)\nfor i in range(n - 1):\n    (s, t) = (q[i][0], q[i][1])\n    print(paint[s][t])", "generated_code": "n = int(eval(input()))\nnode = {i: [] for i in range(1, n + 1)}\nvisited = [False for i in range(n + 1)]\nq = []\nfor _ in range(n - 1):\n    (a, b) = list(map(int, input().split()))\n    node[a].append(b)\n    node[b].append(a)\n    q.append((a, b))\nmother = q[0][0]\nvisited[mother] = True\nd = []\ne = []\npaint = {i: {} for i in range(1, n - 1)}\nmother_paint = [0 for i in range(n + 1)]\nc = 1\nfor child in node[mother]:\n    visited[child] = True\n    paint[mother][child] = c\n    paint[child][mother] = c\n    mother_paint[child] = c\n    c += 1\n    d.append(child)\nwhile d:\n    for parent in d:\n        p = 1\n        for child in node[parent]:\n            if visited[child] == False:\n                visited[child] = True\n                if p != mother_paint[parent]:\n                    paint[parent][child] = p\n                    paint[child][parent] = p\n                    mother_paint[child] = p\n                    p += 1\n                    e.append(child)\n                else:\n                    p += 1\n                    paint[parent][child] = p\n                    paint[child][parent] = p\n                    mother_paint[child] = p\n                    p += 1\n                    e.append(child)\n    if e:\n        d = e\n        e = []\n    else:\n        d = []\n        e = []\nK = 0\nfor i in range(1, n + 1):\n    K = max(K, len(node[i]))\nprint(K)\nfor i in range(n - 1):\n    (s, t) = (q[i][0], q[i][1])\n    print(paint[s][t])", "score": 0.0, "codebleu": 0.9935280794812529, "crystalbleu": 0.9907006509253066, "codebertscore": 1.0, "codescore": 0.9938231706619263, "surfaceSim": 0.9996496145760336, "abs_surfaceSim_minus_score": 0.9996496145760336}
{"golden_code": "N = int(eval(input()))\nX = [[] for i in range(N)]\nfor i in range(N - 1):\n    (x, y) = list(map(int, input().split()))\n    X[x - 1].append(y - 1)\n    X[y - 1].append(x - 1)\nP = [-1] * N\nDE = [0] * N\nQ = [0]\nwhile Q:\n    i = Q.pop()\n    for a in X[i][::-1]:\n        if a != P[i]:\n            P[a] = i\n            DE[a] = DE[i] + 1\n            X[a].remove(i)\n            Q.append(a)\ndef lp(u, v):\n    t = 0\n    while u != v:\n        if DE[u] > DE[v]:\n            t += 1 << (u - 1)\n            u = P[u]\n        elif DE[u] < DE[v]:\n            t += 1 << (v - 1)\n            v = P[v]\n        else:\n            t += 1 << (u - 1)\n            t += 1 << (v - 1)\n            u = P[u]\n            v = P[v]\n    return t\nY = []\nM = int(eval(input()))\nfor _ in range(M):\n    (a, b) = list(map(int, input().split()))\n    (a, b) = (a - 1, b - 1)\n    Y.append(lp(a, b))\nD = {1 << i: i for i in range(50)}\nZ = [0] * (1 << M)\nans = 0\nCC = [0] * N\nBC = [0] * (1 << 17)\nfor m in range(1, 1 << 17):\n    a = m & (-m)\n    BC[m] = BC[m ^ a] + 1\nfor m in range(1 << M):\n    a = m & (-m)\n    if a == m:\n        if a == 0:\n            Z[m] = 0\n        else:\n            Z[m] = Y[D[a]]\n    else:\n        Z[m] = Z[m ^ a] | Y[D[a]]\n    aa = Z[m]\n    bc = BC[aa % (1 << 17)]\n    aa >>= 17\n    bc += BC[aa % (1 << 17)]\n    aa >>= 17\n    bc += BC[aa]\n    CC[(N - 1) - bc] += 1 if (BC[m % 1024] + BC[m >> 10]) & 1 == 0 else -1\nprint(sum([(2 ** i) * CC[i] for i in range(N)]))", "generated_code": "N = int(eval(input()))\nX = [[] for i in range(N)]\nfor i in range(N - 1):\n    (x, y) = list(map(int, input().split()))\n    X[x + 1].append(y - 1)\n    X[y - 1].append(x - 1)\nP = [-1] * N\nDE = [0] * N\nQ = [0]\nwhile Q:\n    i = Q.pop()\n    for a in X[i][::-1]:\n        if a != P[i]:\n            P[a] = i\n            DE[a] = DE[i] + 1\n            X[a].remove(i)\n            Q.append(a)\ndef lp(u, v):\n    t = 0\n    while u != v:\n        if DE[u] > DE[v]:\n            t += 1 << (u - 1)\n            u = P[u]\n        elif DE[u] < DE[v]:\n            t += 1 << (v - 1)\n            v = P[v]\n        else:\n            t += 1 << (u - 1)\n            t += 1 << (v - 1)\n            u = P[u]\n            v = P[v]\n    return t\nY = []\nM = int(eval(input()))\nfor _ in range(M):\n    (a, b) = list(map(int, input().split()))\n    (a, b) = (a - 1, b - 1)\n    Y.append(lp(a, b))\nD = {1 << i: i for i in range(50)}\nZ = [0] * (1 << M)\nans = 0\nCC = [0] * N\nBC = [0] * (1 << 17)\nfor m in range(1, 1 << 17):\n    a = m & (-m)\n    BC[m] = BC[m ^ a] + 1\nfor m in range(1 << M):\n    a = m & (-m)\n    if a == m:\n        if a == 0:\n            Z[m] = 0\n        else:\n            Z[m] = Y[D[a]]\n    else:\n        Z[m] = Z[m ^ a] | Y[D[a]]\n    aa = Z[m]\n    bc = BC[aa % (1 << 17)]\n    aa >>= 17\n    bc += BC[aa % (1 << 17)]\n    aa >>= 17\n    bc += BC[aa]\n    CC[(N - 1) - bc] += 1 if (BC[m % 1024] + BC[m >> 10]) & 1 == 0 else -1\nprint(sum([(2 ** i) * CC[i] for i in range(N)]))", "score": 0.0, "codebleu": 0.9957864818034221, "crystalbleu": 0.9959665946353381, "codebertscore": 1.0, "codescore": 0.9938023090362549, "surfaceSim": 0.9996525364836693, "abs_surfaceSim_minus_score": 0.9996525364836693}
{"golden_code": "N = int(eval(input()))\nX = [[] for i in range(N)]\nfor i in range(N - 1):\n    (x, y) = list(map(int, input().split()))\n    X[x - 1].append(y - 1)\n    X[y - 1].append(x - 1)\nP = [-1] * N\nDE = [0] * N\nQ = [0]\nwhile Q:\n    i = Q.pop()\n    for a in X[i][::-1]:\n        if a != P[i]:\n            P[a] = i\n            DE[a] = DE[i] + 1\n            X[a].remove(i)\n            Q.append(a)\ndef lp(u, v):\n    t = 0\n    while u != v:\n        if DE[u] > DE[v]:\n            t += 1 << (u - 1)\n            u = P[u]\n        elif DE[u] < DE[v]:\n            t += 1 << (v - 1)\n            v = P[v]\n        else:\n            t += 1 << (u - 1)\n            t += 1 << (v - 1)\n            u = P[u]\n            v = P[v]\n    return t\nY = []\nM = int(eval(input()))\nfor _ in range(M):\n    (a, b) = list(map(int, input().split()))\n    (a, b) = (a - 1, b - 1)\n    Y.append(lp(a, b))\nD = {1 << i: i for i in range(50)}\nZ = [0] * (1 << M)\nans = 0\nCC = [0] * N\nBC = [0] * (1 << 17)\nfor m in range(1, 1 << 17):\n    a = m & (-m)\n    BC[m] = BC[m ^ a] + 1\nfor m in range(1 << M):\n    a = m & (-m)\n    if a == m:\n        if a == 0:\n            Z[m] = 0\n        else:\n            Z[m] = Y[D[a]]\n    else:\n        Z[m] = Z[m ^ a] | Y[D[a]]\n    aa = Z[m]\n    bc = BC[aa % (1 << 17)]\n    aa >>= 17\n    bc += BC[aa % (1 << 17)]\n    aa >>= 17\n    bc += BC[aa]\n    CC[(N - 1) - bc] += 1 if (BC[m % 1024] + BC[m >> 10]) & 1 == 0 else -1\nprint(sum([(2 ** i) * CC[i] for i in range(N)]))", "generated_code": "N = int(eval(input()))\nX = [[] for i in range(N)]\nfor i in range(N - 1):\n    (x, y) = list(map(int, input().split()))\n    X[x - 1].append(y - 1)\n    X[y - 1].append(x + 1)\nP = [-1] * N\nDE = [0] * N\nQ = [0]\nwhile Q:\n    i = Q.pop()\n    for a in X[i][::-1]:\n        if a != P[i]:\n            P[a] = i\n            DE[a] = DE[i] + 1\n            X[a].remove(i)\n            Q.append(a)\ndef lp(u, v):\n    t = 0\n    while u != v:\n        if DE[u] > DE[v]:\n            t += 1 << (u - 1)\n            u = P[u]\n        elif DE[u] < DE[v]:\n            t += 1 << (v - 1)\n            v = P[v]\n        else:\n            t += 1 << (u - 1)\n            t += 1 << (v - 1)\n            u = P[u]\n            v = P[v]\n    return t\nY = []\nM = int(eval(input()))\nfor _ in range(M):\n    (a, b) = list(map(int, input().split()))\n    (a, b) = (a - 1, b - 1)\n    Y.append(lp(a, b))\nD = {1 << i: i for i in range(50)}\nZ = [0] * (1 << M)\nans = 0\nCC = [0] * N\nBC = [0] * (1 << 17)\nfor m in range(1, 1 << 17):\n    a = m & (-m)\n    BC[m] = BC[m ^ a] + 1\nfor m in range(1 << M):\n    a = m & (-m)\n    if a == m:\n        if a == 0:\n            Z[m] = 0\n        else:\n            Z[m] = Y[D[a]]\n    else:\n        Z[m] = Z[m ^ a] | Y[D[a]]\n    aa = Z[m]\n    bc = BC[aa % (1 << 17)]\n    aa >>= 17\n    bc += BC[aa % (1 << 17)]\n    aa >>= 17\n    bc += BC[aa]\n    CC[(N - 1) - bc] += 1 if (BC[m % 1024] + BC[m >> 10]) & 1 == 0 else -1\nprint(sum([(2 ** i) * CC[i] for i in range(N)]))", "score": 0.0, "codebleu": 0.9957864818034221, "crystalbleu": 0.9959688151505878, "codebertscore": 1.0, "codescore": 0.9938011765480042, "surfaceSim": 0.9996525364836693, "abs_surfaceSim_minus_score": 0.9996525364836693}
{"golden_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "generated_code": "import sys\ninput = sys.stdin.readline\npass\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "score": 0.0, "codebleu": 0.8092105719967482, "crystalbleu": 0.959251613302722, "codebertscore": 0.98, "codescore": 0.9842482209205627, "surfaceSim": 0.9792666902511751, "abs_surfaceSim_minus_score": 0.9792666902511751}
{"golden_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "generated_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\npass\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "score": 0.0, "codebleu": 0.8529709541200763, "crystalbleu": 0.9903169647968395, "codebertscore": 0.99, "codescore": 0.870341420173645, "surfaceSim": 0.9866894931015313, "abs_surfaceSim_minus_score": 0.9866894931015313}
{"golden_code": "class Calc:\n    def __init__(self, max_value, mod):\n        fact = [-1] * (max_value + 1)\n        fact[0] = 1\n        fact[1] = 1\n        for x in range(2, max_value + 1):\n            fact[x] = (x * fact[x - 1]) % mod\n        invs = [1] * (max_value + 1)\n        invs[max_value] = pow(fact[max_value], mod - 2, mod)\n        for x in range(max_value - 1, 0, -1):\n            invs[x] = (invs[x + 1] * (x + 1)) % mod\n        self.fact = fact\n        self.invs = invs\n        self.mod = mod\n    def combination(self, n, r):\n        if n - r < r:\n            return self.combination(n, n - r)\n        if r < 0:\n            return 0\n        if r == 0:\n            return 1\n        if r == 1:\n            return n\n        return ((self.fact[n] * self.invs[r]) * self.invs[n - r]) % self.mod\ndef gen(n):\n    x = n\n    d = 2\n    cnt = 0\n    while x % d == 0:\n        x //= d\n        cnt += 1\n    yield cnt\n    d = 3\n    ma = d * d\n    while ma <= n:\n        cnt = 0\n        while x % d == 0:\n            x //= d\n            cnt += 1\n        yield cnt\n        ma += (d * 4) + 4\n        d += 2\n    if x > 1:\n        yield 1\ndef main():\n    MOD = (10 ** 9) + 7\n    (N, M) = list(map(int, input().split()))\n    cal = Calc(max_value=N + 30, mod=MOD)\n    ans = 1\n    for cnt in gen(M):\n        ans = (ans * cal.combination((N + cnt) - 1, cnt)) % MOD\n    print(ans)", "generated_code": "class Calc:\n    def __init__(self, max_value, mod):\n        fact = [-1] ** (max_value + 1)\n        fact[0] = 1\n        fact[1] = 1\n        for x in range(2, max_value + 1):\n            fact[x] = (x * fact[x - 1]) % mod\n        invs = [1] * (max_value + 1)\n        invs[max_value] = pow(fact[max_value], mod - 2, mod)\n        for x in range(max_value - 1, 0, -1):\n            invs[x] = (invs[x + 1] * (x + 1)) % mod\n        self.fact = fact\n        self.invs = invs\n        self.mod = mod\n    def combination(self, n, r):\n        if n - r < r:\n            return self.combination(n, n - r)\n        if r < 0:\n            return 0\n        if r == 0:\n            return 1\n        if r == 1:\n            return n\n        return ((self.fact[n] * self.invs[r]) * self.invs[n - r]) % self.mod\ndef gen(n):\n    x = n\n    d = 2\n    cnt = 0\n    while x % d == 0:\n        x //= d\n        cnt += 1\n    yield cnt\n    d = 3\n    ma = d * d\n    while ma <= n:\n        cnt = 0\n        while x % d == 0:\n            x //= d\n            cnt += 1\n        yield cnt\n        ma += (d * 4) + 4\n        d += 2\n    if x > 1:\n        yield 1\ndef main():\n    MOD = (10 ** 9) + 7\n    (N, M) = list(map(int, input().split()))\n    cal = Calc(max_value=N + 30, mod=MOD)\n    ans = 1\n    for cnt in gen(M):\n        ans = (ans * cal.combination((N + cnt) - 1, cnt)) % MOD\n    print(ans)", "score": 0.0, "codebleu": 0.9945974577626977, "crystalbleu": 0.9960653185340224, "codebertscore": 1.0, "codescore": 0.9937525391578674, "surfaceSim": 0.9996296296296296, "abs_surfaceSim_minus_score": 0.9996296296296296}
{"golden_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "generated_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N + 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "score": 0.0, "codebleu": 0.9950293033173805, "crystalbleu": 0.9962838094937879, "codebertscore": 1.0, "codescore": 0.9849040508270264, "surfaceSim": 0.9996926859250154, "abs_surfaceSim_minus_score": 0.9996926859250154}
{"golden_code": "n = int(eval(input()))\nnode = {i: [] for i in range(1, n + 1)}\nvisited = [False for i in range(n + 1)]\nq = []\nfor _ in range(n - 1):\n    (a, b) = list(map(int, input().split()))\n    node[a].append(b)\n    node[b].append(a)\n    q.append((a, b))\nmother = q[0][0]\nvisited[mother] = True\nd = []\ne = []\npaint = {i: {} for i in range(1, n + 1)}\nmother_paint = [0 for i in range(n + 1)]\nc = 1\nfor child in node[mother]:\n    visited[child] = True\n    paint[mother][child] = c\n    paint[child][mother] = c\n    mother_paint[child] = c\n    c += 1\n    d.append(child)\nwhile d:\n    for parent in d:\n        p = 1\n        for child in node[parent]:\n            if visited[child] == False:\n                visited[child] = True\n                if p != mother_paint[parent]:\n                    paint[parent][child] = p\n                    paint[child][parent] = p\n                    mother_paint[child] = p\n                    p += 1\n                    e.append(child)\n                else:\n                    p += 1\n                    paint[parent][child] = p\n                    paint[child][parent] = p\n                    mother_paint[child] = p\n                    p += 1\n                    e.append(child)\n    if e:\n        d = e\n        e = []\n    else:\n        d = []\n        e = []\nK = 0\nfor i in range(1, n + 1):\n    K = max(K, len(node[i]))\nprint(K)\nfor i in range(n - 1):\n    (s, t) = (q[i][0], q[i][1])\n    print(paint[s][t])", "generated_code": "n = int(eval(input()))\nnode = {i: [] for i in range(1, n - 1)}\nvisited = [False for i in range(n + 1)]\nq = []\nfor _ in range(n - 1):\n    (a, b) = list(map(int, input().split()))\n    node[a].append(b)\n    node[b].append(a)\n    q.append((a, b))\nmother = q[0][0]\nvisited[mother] = True\nd = []\ne = []\npaint = {i: {} for i in range(1, n + 1)}\nmother_paint = [0 for i in range(n + 1)]\nc = 1\nfor child in node[mother]:\n    visited[child] = True\n    paint[mother][child] = c\n    paint[child][mother] = c\n    mother_paint[child] = c\n    c += 1\n    d.append(child)\nwhile d:\n    for parent in d:\n        p = 1\n        for child in node[parent]:\n            if visited[child] == False:\n                visited[child] = True\n                if p != mother_paint[parent]:\n                    paint[parent][child] = p\n                    paint[child][parent] = p\n                    mother_paint[child] = p\n                    p += 1\n                    e.append(child)\n                else:\n                    p += 1\n                    paint[parent][child] = p\n                    paint[child][parent] = p\n                    mother_paint[child] = p\n                    p += 1\n                    e.append(child)\n    if e:\n        d = e\n        e = []\n    else:\n        d = []\n        e = []\nK = 0\nfor i in range(1, n + 1):\n    K = max(K, len(node[i]))\nprint(K)\nfor i in range(n - 1):\n    (s, t) = (q[i][0], q[i][1])\n    print(paint[s][t])", "score": 0.0, "codebleu": 0.9935280794812529, "crystalbleu": 0.9907006509253066, "codebertscore": 1.0, "codescore": 0.9938232898712158, "surfaceSim": 0.9996496145760336, "abs_surfaceSim_minus_score": 0.9996496145760336}
{"golden_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "generated_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "score": 0.0, "codebleu": 0.9873402191687952, "crystalbleu": 0.9942110332335385, "codebertscore": 1.0, "codescore": 0.9935773015022278, "surfaceSim": 0.9988589685075309, "abs_surfaceSim_minus_score": 0.9988589685075309}
{"golden_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "generated_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "score": 0.0, "codebleu": 1.0, "crystalbleu": 1.0, "codebertscore": 1.0, "codescore": 0.9938342571258545, "surfaceSim": 1.0, "abs_surfaceSim_minus_score": 1.0}
{"golden_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "generated_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "score": 0.0, "codebleu": 1.0, "crystalbleu": 1.0, "codebertscore": 1.0, "codescore": 0.9938342571258545, "surfaceSim": 1.0, "abs_surfaceSim_minus_score": 1.0}
{"golden_code": "from collections import defaultdict\nfrom collections import deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\ndef I():\n    return int(sys.stdin.readline())\ndef LS():\n    return list(map(list, sys.stdin.readline().split()))\ndef S():\n    return list(sys.stdin.readline())[:-1]\ndef IR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = I()\n    return l\ndef LIR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = LI()\n    return l\ndef SR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = S()\n    return l\ndef LSR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = LS()\n    return l\nsys.setrecursionlimit(1000000)\nmod = 1000000007\ndef A():\n    return\ndef B():\n    return\ndef C():\n    return\ndef D():\n    return\ndef E():\n    return\ndef F():\n    (a, b, c, X, Y) = LI()\n    ans = float('inf')\n    for z in range(300001):\n        if z % 2 == 0:\n            m = c * z\n            x = z // 2\n            y = z // 2\n            m += a * max(0, X - x)\n            m += b * max(0, Y - y)\n            if m < ans:\n                ans = m\n    print(ans)\n    return\ndef G():\n    n = I()\n    x = LI()\n    f = [(i, x[i]) for i in range(n)]\n    f.sort(key=lambda x: (x[1]))\n    g = [(f[i][0], i) for i in range(n)]\n    g.sort(key=lambda x: (x[0]))\n    for i in range(n):\n        if g[i][1] < n // 2:\n            print(f[n // 2][1])else:print(f[(n // 2) - 1][1])\n    return\ndef H():\n    return\ndef I_():\n    return\ndef J():\n    return", "generated_code": "from collections import defaultdict\nfrom collections import deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\ndef I():\n    return int(sys.stdin.readline())\ndef LS():\n    return list(map(list, sys.stdin.readline().split()))\ndef S():\n    return list(sys.stdin.readline())[:+1]\ndef IR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = I()\n    return l\ndef LIR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = LI()\n    return l\ndef SR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = S()\n    return l\ndef LSR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = LS()\n    return l\nsys.setrecursionlimit(1000000)\nmod = 1000000007\ndef A():\n    return\ndef B():\n    return\ndef C():\n    return\ndef D():\n    return\ndef E():\n    return\ndef F():\n    (a, b, c, X, Y) = LI()\n    ans = float('inf')\n    for z in range(300001):\n        if z % 2 == 0:\n            m = c * z\n            x = z // 2\n            y = z // 2\n            m += a * max(0, X - x)\n            m += b * max(0, Y - y)\n            if m < ans:\n                ans = m\n    print(ans)\n    return\ndef G():\n    n = I()\n    x = LI()\n    f = [(i, x[i]) for i in range(n)]\n    f.sort(key=lambda x: (x[1]))\n    g = [(f[i][0], i) for i in range(n)]\n    g.sort(key=lambda x: (x[0]))\n    for i in range(n):\n        if g[i][1] < n // 2:\n            print(f[n // 2][1])else:print(f[(n // 2) - 1][1])\n    return\ndef H():\n    return\ndef I_():\n    return\ndef J():\n    return", "score": 0.0, "codebleu": 0.9950684650874879, "crystalbleu": 0.9932265613224579, "codebertscore": 1.0, "codescore": 0.9934326410293579, "surfaceSim": 0.49969097651421507, "abs_surfaceSim_minus_score": 0.49969097651421507}
{"golden_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "generated_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    @classmethod\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "score": 0.0, "codebleu": 0.9933297651216333, "crystalbleu": 0.9932615708925326, "codebertscore": 0.99, "codescore": 0.9851191639900208, "surfaceSim": 0.9960462287104623, "abs_surfaceSim_minus_score": 0.9960462287104623}
{"golden_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "generated_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] // self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "score": 0.0, "codebleu": 0.9945883912637858, "crystalbleu": 0.9915876446894797, "codebertscore": 1.0, "codescore": 0.9935560822486877, "surfaceSim": 0.986723282799925, "abs_surfaceSim_minus_score": 0.986723282799925}
{"golden_code": "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nMOD = (10 ** 9) + 7\nfac = [1, 1]\nf_inv = [1, 1]\ninv = [0, 1]\ndef prepare(n, mod):\n    for i in range(2, n + 1):\n        fac.append((fac[-1] * i) % mod)\ndef cmb(n, r, mod):\n    if (n < 0 or r < 0):\n        return 0\n    if r > n:\n        return 0\n    return ((fac[n] * pow(fac[r], MOD - 2, MOD)) * pow(fac[n - r], MOD - 2, MOD)) % mod\ndef prime_factorization(n):\n    d = []\n    (i, e) = (2, 0)\n    while i * i <= n:\n        while n % i == 0:\n            n //= i\n            e += 1\n        if e > 0:\n            d.append((i, e))\n        i += 1\n        e = 0\n    if n > 1:\n        d.append((n, 1))\n    return d\ndef main():\n    (N, M) = list(map(int, readline().split()))\n    prepare(N + 100, MOD)\n    d = prime_factorization(M)\n    ans = 1\n    for (i, e) in d:\n        ans *= cmb((N - 1) + e, e, MOD)\n        ans %= MOD\n    print(ans)", "generated_code": "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nMOD = (10 ** 9) + 7\nfac = [1, 1]\nf_inv = [1, 1]\ninv = [0, 1]\ndef prepare(n, mod):\n    for i in range(2, n + 1):\n        fac.append((fac[+1] * i) % mod)\ndef cmb(n, r, mod):\n    if (n < 0 or r < 0):\n        return 0\n    if r > n:\n        return 0\n    return ((fac[n] * pow(fac[r], MOD - 2, MOD)) * pow(fac[n - r], MOD - 2, MOD)) % mod\ndef prime_factorization(n):\n    d = []\n    (i, e) = (2, 0)\n    while i * i <= n:\n        while n % i == 0:\n            n //= i\n            e += 1\n        if e > 0:\n            d.append((i, e))\n        i += 1\n        e = 0\n    if n > 1:\n        d.append((n, 1))\n    return d\ndef main():\n    (N, M) = list(map(int, readline().split()))\n    prepare(N + 100, MOD)\n    d = prime_factorization(M)\n    ans = 1\n    for (i, e) in d:\n        ans *= cmb((N - 1) + e, e, MOD)\n        ans %= MOD\n    print(ans)", "score": 0.0, "codebleu": 0.9924868895723431, "crystalbleu": 0.9925125428898525, "codebertscore": 1.0, "codescore": 0.8499395251274109, "surfaceSim": 0.9744594594594594, "abs_surfaceSim_minus_score": 0.9744594594594594}
{"golden_code": "import collections\nimport math\nclass Dinic:\n    class edge:\n        def __init__(self, to, cap, rev):\n            (self.to, self.cap, self.rev) = (to, cap, rev)\n    def __init__(self, V, E, source, sink):\n        self.V = V\n        self.E = [[] for _ in range(V)]\n        for fr in range(V):\n            for (to, cap) in E[fr]:\n                self.E[fr].append(self.edge(to, cap, len(self.E[to])))\n                self.E[to].append(self.edge(fr, 0, len(self.E[fr]) - 1))\n        self.maxflow = self.dinic(source, sink)\n    def dinic(self, source, sink):\n        INF = float('inf')\n        maxflow = 0\n        while True:\n            self.bfs(source)\n            if self.level[sink] < 0:\n                return maxflow\n            self.itr = [0] * self.V\n            while True:\n                flow = self.dfs(source, sink, INF)\n                if flow > 0:\n                    maxflow += flow\n                else:\n                    break\n    def dfs(self, vertex, sink, flow):\n        if vertex == sink:\n            return flow\n        for i in range(self.itr[vertex], len(self.E[vertex])):\n            self.itr[vertex] = i\n            e = self.E[vertex][i]\n            if (e.cap > 0 and self.level[vertex] < self.level[e.to]):\n                d = self.dfs(e.to, sink, min(flow, e.cap))\n                if d > 0:\n                    e.cap -= d\n                    self.E[e.to][e.rev].cap += d\n                    return d\n        return 0\n    def bfs(self, start):\n        que = collections.deque()\n        self.level = [-1] * self.V\n        que.append(start)\n        self.level[start] = 0\n        while que:\n            fr = que.popleft()\n            for e in self.E[fr]:\n                if (e.cap > 0 and self.level[e.to] < 0):\n                    self.level[e.to] = self.level[fr] + 1\n                    que.append(e.to)\nwhile True:\n    (M, N) = list(map(int, input().split()))\n    if (M == 0 and N == 0):\n        break\n    (blue, red) = ([], [])\n    while True:\n        for x in input().split():\n            blue.append(int(x))\n        if len(blue) == M:\n            break\n    while True:\n        for x in input().split():\n            red.append(int(x))\n        if len(red) == N:\n            break\n    V = (M + N) + 2\n    edge = [set() for _ in range(V)]\n    for (i, b) in enumerate(blue):\n        if b != 1:\n            for (j, r) in enumerate(red):\n                if r % b == 0:\n                    edge[i].add((M + j, 1))\n        for j in range(2, int(math.sqrt(b)) + 1):\n            if b % j == 0:\n                for (k, r) in enumerate(red):\n                    if (r % j == 0 or r % (b // j) == 0):\n                        edge[i].add((M + k, 1))\n    for i in range(M):\n        edge[M + N].add((i, 1))\n    for j in range(N):\n        edge[M + j].add(((M + N) + 1, 1))\n    d = Dinic(V, edge, M + N, (M + N) + 1)\n    print(d.maxflow)", "generated_code": "import collections\nimport math\nclass Dinic:\n    class edge:\n        def __init__(self, to, cap, rev):\n            (self.to, self.cap, self.rev) = (to, cap, rev)\n    def __init__(self, V, E, source, sink):\n        self.V = V\n        self.E = [[] for _ in range(V)]\n        for fr in range(V):\n            for (to, cap) in E[fr]:\n                self.E[fr].append(self.edge(to, cap, len(self.E[to])))\n                self.E[to].append(self.edge(fr, 0, len(self.E[fr]) - 1))\n        self.maxflow = self.dinic(source, sink)\n    def dinic(self, source, sink):\n        INF = float('inf')\n        maxflow = 0\n        while True:\n            self.bfs(source)\n            if self.level[sink] < 0:\n                return maxflow\n            self.itr = [0] * self.V\n            while True:\n                flow = self.dfs(source, sink, INF)\n                if flow > 0:\n                    maxflow += flow\n                else:\n                    break\n    def dfs(self, vertex, sink, flow):\n        if vertex == sink:\n            return flow\n        for i in range(self.itr[vertex], len(self.E[vertex])):\n            self.itr[vertex] = i\n            e = self.E[vertex][i]\n            if (e.cap > 0 and self.level[vertex] < self.level[e.to]):\n                d = self.dfs(e.to, sink, min(flow, e.cap))\n                if d > 0:\n                    e.cap -= d\n                    self.E[e.to][e.rev].cap += d\n                    return d\n        return 0\n    def bfs(self, start):\n        que = collections.deque()\n        self.level = [-1] * self.V\n        que.append(start)\n        self.level[start] = 0\n        while que:\n            fr = que.popleft()\n            for e in self.E[fr]:\n                if (e.cap > 0 and self.level[e.to] < 0):\n                    self.level[e.to] = self.level[fr] + 1\n                    que.append(e.to)\nwhile True:\n    (M, N) = list(map(int, input().split()))\n    if (M == 0 and N == 0):\n        break\n    (blue, red) = ([], [])\n    while True:\n        for x in input().split():\n            blue.append(int(x))\n        if len(blue) == M:\n            break\n    while True:\n        for x in input().split():\n            break\n        if len(red) == N:\n            break\n    V = (M + N) + 2\n    edge = [set() for _ in range(V)]\n    for (i, b) in enumerate(blue):\n        if b != 1:\n            for (j, r) in enumerate(red):\n                if r % b == 0:\n                    edge[i].add((M + j, 1))\n        for j in range(2, int(math.sqrt(b)) + 1):\n            if b % j == 0:\n                for (k, r) in enumerate(red):\n                    if (r % j == 0 or r % (b // j) == 0):\n                        edge[i].add((M + k, 1))\n    for i in range(M):\n        edge[M + N].add((i, 1))\n    for j in range(N):\n        edge[M + j].add(((M + N) + 1, 1))\n    d = Dinic(V, edge, M + N, (M + N) + 1)\n    print(d.maxflow)", "score": 0.0, "codebleu": 0.9912879883960847, "crystalbleu": 0.9859581357317814, "codebertscore": 1.0, "codescore": 0.9702878594398499, "surfaceSim": 0.997191011235955, "abs_surfaceSim_minus_score": 0.997191011235955}
{"golden_code": "from collections import defaultdict\nfrom collections import deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\ndef I():\n    return int(sys.stdin.readline())\ndef LS():\n    return list(map(list, sys.stdin.readline().split()))\ndef S():\n    return list(sys.stdin.readline())[:-1]\ndef IR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = I()\n    return l\ndef LIR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = LI()\n    return l\ndef SR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = S()\n    return l\ndef LSR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = SR()\n    return l\nmod = 1000000007\ndef A():\n    s = S()\n    t = S()\n    if s + t == t[::-1] + s[::-1]:\n        print('YES')else:print('NO')\ndef B():\n    n = I()\n    for i in range(int(n ** 0.5) + 2)[::-1]:\n        if i * i <= n:\n            print(i * i)\n            quit()\ndef C():\n    n = I()\n    a = LI()\n    b = LI()\n    c = LI()\n    q = [0 for i in range(n)]\n    ans = 0\n    a.sort()\n    b.sort()\n    c.sort()\n    for i in range(n):\n        j = bisect.bisect_left(a, b[i])\n        q[i] = j\n    for i in range(n - 1):\n        q[i + 1] += q[i]\n    q.insert(0, 0)\n    for i in range(n):\n        j = bisect.bisect_left(b, c[i])\n        ans += q[j]\n    print(ans)\ndef D():\n    def dijkstra():\n        d = [float('inf') for i in range(k)]\n        q = [[0, 1]]\n        d[1] = 0\n        while q:\n            (dx, x) = heappop(q)\n            for (y, dy) in v[x]:\n                if d[y] > dx + dy:\n                    d[y] = dx + dy\n                    heappush(q, [d[y], y])\n        print(d[0] + 1)\n    k = I()\n    if k == 1:\n        print(1)\n        quit()\n    v = [[] for i in range(k)]\n    for i in range(1, k):\n        v[i].append([(i + 1) % k, 1])\n        v[i].append([(i * 10) % k, 0])\n    dijkstra()\ndef E():\n    return\ndef F():\n    return\ndef G():\n    return\ndef H():\n    return", "generated_code": "from collections import defaultdict\nfrom collections import deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\ndef I():\n    return int(sys.stdin.readline())\ndef LS():\n    return list(map(list, sys.stdin.readline().split()))\ndef S():\n    return list(sys.stdin.readline())[:-1]\ndef IR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = I()\n    return l\ndef LIR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = LI()\n    return l\ndef SR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = S()\n    return l\ndef LSR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = SR()\n    return l\nmod = 1000000007\ndef A():\n    s = S()\n    t = S()\n    if s + t == t[::-1] - s[::-1]:\n        print('YES')else:print('NO')\ndef B():\n    n = I()\n    for i in range(int(n ** 0.5) + 2)[::-1]:\n        if i * i <= n:\n            print(i * i)\n            quit()\ndef C():\n    n = I()\n    a = LI()\n    b = LI()\n    c = LI()\n    q = [0 for i in range(n)]\n    ans = 0\n    a.sort()\n    b.sort()\n    c.sort()\n    for i in range(n):\n        j = bisect.bisect_left(a, b[i])\n        q[i] = j\n    for i in range(n - 1):\n        q[i + 1] += q[i]\n    q.insert(0, 0)\n    for i in range(n):\n        j = bisect.bisect_left(b, c[i])\n        ans += q[j]\n    print(ans)\ndef D():\n    def dijkstra():\n        d = [float('inf') for i in range(k)]\n        q = [[0, 1]]\n        d[1] = 0\n        while q:\n            (dx, x) = heappop(q)\n            for (y, dy) in v[x]:\n                if d[y] > dx + dy:\n                    d[y] = dx + dy\n                    heappush(q, [d[y], y])\n        print(d[0] + 1)\n    k = I()\n    if k == 1:\n        print(1)\n        quit()\n    v = [[] for i in range(k)]\n    for i in range(1, k):\n        v[i].append([(i + 1) % k, 1])\n        v[i].append([(i * 10) % k, 0])\n    dijkstra()\ndef E():\n    return\ndef F():\n    return\ndef G():\n    return\ndef H():\n    return", "score": 0.0, "codebleu": 0.9960259674102339, "crystalbleu": 0.9948180583890528, "codebertscore": 1.0, "codescore": 0.9874531626701355, "surfaceSim": 0.499755859375, "abs_surfaceSim_minus_score": 0.499755859375}
{"golden_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "generated_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] / (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "score": 0.0, "codebleu": 0.9963221036285097, "crystalbleu": 0.9937360383325433, "codebertscore": 1.0, "codescore": 0.9859413504600525, "surfaceSim": 0.9890647900136453, "abs_surfaceSim_minus_score": 0.9890647900136453}
{"golden_code": "import queue\nINF = 123456789\ndef main():\n    (n, m) = list(map(int, input().split()))\n    G = [[] for _ in range(n)]\n    for _ in range(m):\n        (a, b, c) = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        G[a].append((b, c))\n        G[b].append((a, c))\n    used = set()\n    for i in range(n):\n        d = [INF for _ in range(n)]\n        par = [-1 for _ in range(n)]\n        que = queue.PriorityQueue()\n        d[i] = 0\n        que.put((0, i))\n        while not (que.empty()):\n            p = que.get()\n            v = p[1]\n            if d[v] < p[0]:\n                continue\n            for (to, cost) in G[v]:\n                if d[to] > d[v] + cost:\n                    d[to] = d[v] + cost\n                    par[to] = v\n                    que.put((d[to], to))\n        for j in range(n):\n            if i != j:\n                (a, b) = (j, par[j])\n                if a > b:\n                    (a, b) = (b, a)\n                used.add((a, b))\n    print(m - len(used))", "generated_code": "import queue\nINF = 123456789\ndef main():\n    (n, m) = list(map(int, input().split()))\n    G = [[] for _ in range(n)]\n    for _ in range(m):\n        (a, b, c) = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        G[a].append((b, c))\n        G[b].append((a, c))\n    used = set()\n    for i in range(n):\n        d = [INF for _ in range(n)]\n        par = [-1 for _ in range(n)]\n        que = queue.PriorityQueue()\n        d[i] = 0\n        que.put((0, i))\n        while not (que.empty()):\n            p = que.get()\n            v = p[1]\n            if d[v] < p[0]:\n                continue\n            for (to, cost) in G[v]:\n                if d[to] > d[v] - cost:\n                    d[to] = d[v] + cost\n                    par[to] = v\n                    que.put((d[to], to))\n        for j in range(n):\n            if i != j:\n                (a, b) = (j, par[j])\n                if a > b:\n                    (a, b) = (b, a)\n                used.add((a, b))\n    print(m - len(used))", "score": 0.0, "codebleu": 0.9904103276685203, "crystalbleu": 0.99196049219345, "codebertscore": 1.0, "codescore": 0.9937834739685059, "surfaceSim": 0.9994979919678715, "abs_surfaceSim_minus_score": 0.9994979919678715}
{"golden_code": "import math, sys\nn = int(sys.stdin.readline())\na = tuple(map(int, sys.stdin.readline().split()))\ng = math.gcd(a[0], a[1])\nfor i in range(2, n):\n    g = math.gcd(g, a[i])\nM = max(a)\nacc = a[0]\nfor i in range(n):\n    acc = math.gcd(acc, a[i])\nif acc != 1:\n    print('not coprime')\n    exit()\nLIMIT = max(a)\nminPrime = [0] * (LIMIT + 1)\nminPrime[1] = 1\ndef make():\n    for i in range(2, LIMIT + 1):\n        if minPrime[i] == 0:\n            minPrime[i] = i\n            for j in range(i + i, LIMIT + 1, i):\n                if minPrime[j] == 0:\n                    minPrime[j] = i\nmake()\ndef factrial(N):\n    ret = []\n    while minPrime[N] != N:\n        ret.append(minPrime[N])\n        N = N // minPrime[N]\n    if N != 1:\n        ret.append(N)\n    return ret\njudge = set([])\npc = True\npairwise = True\np = set()\nfor e in a:\n    if not pairwise:\n        break\n    asf = set(factrial(e))\n    if judge & asf != set():\n        pc = False\n    judge |= asf\nif pc:\n    print('pairwise coprime')\nelif g == 1:\n    print('setwise coprime')\nelse:\n    print('not coprime')", "generated_code": "import math, sys\nn = int(sys.stdin.readline())\na = tuple(map(int, sys.stdin.readline().split()))\ng = math.gcd(a[0], a[1])\nfor i in range(2, n):\n    g = math.gcd(g, a[i])\nM = max(a)\nacc = a[0]\nfor i in range(n):\n    acc = math.gcd(acc, a[i])\nif acc != 1:\n    print('not coprime')\n    exit()\nLIMIT = max(a)\nminPrime = [0] * (LIMIT + 1)\nminPrime[1] = 1\ndef make():\n    for i in range(2, LIMIT + 1):\n        if minPrime[i] == 0:\n            minPrime[i] = i\n            for j in range(i + i, LIMIT + 1, i):\n                if minPrime[j] == 0:\n                    minPrime[j] = i\n                break\nmake()\ndef factrial(N):\n    ret = []\n    while minPrime[N] != N:\n        ret.append(minPrime[N])\n        N = N // minPrime[N]\n    if N != 1:\n        ret.append(N)\n    return ret\njudge = set([])\npc = True\npairwise = True\np = set()\nfor e in a:\n    if not pairwise:\n        break\n    asf = set(factrial(e))\n    if judge & asf != set():\n        pc = False\n    judge |= asf\nif pc:\n    print('pairwise coprime')elif g == 1:\n    print('setwise coprime')\nelse:\n    print('not coprime')", "score": 0.0, "codebleu": 0.9618271109301703, "crystalbleu": 0.9890192409220128, "codebertscore": 0.99, "codescore": 0.9937385320663452, "surfaceSim": 0.4967411545623836, "abs_surfaceSim_minus_score": 0.4967411545623836}
{"golden_code": "from collections import defaultdict\nfrom collections import deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\ndef I():\n    return int(sys.stdin.readline())\ndef LS():\n    return list(map(list, sys.stdin.readline().split()))\ndef S():\n    return list(sys.stdin.readline())[:-1]\ndef IR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = I()\n    return l\ndef LIR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = LI()\n    return l\ndef SR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = S()\n    return l\ndef LSR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = LS()\n    return l\nsys.setrecursionlimit(1000000)\nmod = 1000000007\ndef A():\n    return\ndef B():\n    return\ndef C():\n    return\ndef D():\n    return\ndef E():\n    return\ndef F():\n    (a, b, c, X, Y) = LI()\n    ans = float('inf')\n    for z in range(300001):\n        if z % 2 == 0:\n            m = c * z\n            x = z // 2\n            y = z // 2\n            m += a * max(0, X - x)\n            m += b * max(0, Y - y)\n            if m < ans:\n                ans = m\n    print(ans)\n    return\ndef G():\n    n = I()\n    x = LI()\n    f = [(i, x[i]) for i in range(n)]\n    f.sort(key=lambda x: (x[1]))\n    g = [(f[i][0], i) for i in range(n)]\n    g.sort(key=lambda x: (x[0]))\n    for i in range(n):\n        if g[i][1] < n // 2:\n            print(f[n // 2][1])else:print(f[(n // 2) - 1][1])\n    return\ndef H():\n    return\ndef I_():\n    return\ndef J():\n    return", "generated_code": "from collections import defaultdict\nfrom collections import deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\ndef I():\n    return int(sys.stdin.readline())\ndef LS():\n    return list(map(list, sys.stdin.readline().split()))\ndef S():\n    return list(sys.stdin.readline())[:-1]\ndef IR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = I()\n    return l\ndef LIR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = LI()\n    return l\ndef SR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = S()\n    return l\ndef LSR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = LS()\n    return l\nsys.setrecursionlimit(1000000)\nmod = 1000000007\ndef A():\n    return\ndef B():\n    return\ndef C():\n    return\ndef D():\n    return\ndef E():\n    return\ndef F():\n    (a, b, c, X, Y) = LI()\n    ans = float('inf')\n    for z in range(300001):\n        if z % 2 == 0:\n            m = c * z\n            x = z * 2\n            y = z // 2\n            m += a * max(0, X - x)\n            m += b * max(0, Y - y)\n            if m < ans:\n                ans = m\n    print(ans)\n    return\ndef G():\n    n = I()\n    x = LI()\n    f = [(i, x[i]) for i in range(n)]\n    f.sort(key=lambda x: (x[1]))\n    g = [(f[i][0], i) for i in range(n)]\n    g.sort(key=lambda x: (x[0]))\n    for i in range(n):\n        if g[i][1] < n // 2:\n            print(f[n // 2][1])else:print(f[(n // 2) - 1][1])\n    return\ndef H():\n    return\ndef I_():\n    return\ndef J():\n    return", "score": 0.0, "codebleu": 0.9950684650874879, "crystalbleu": 0.9914241489727199, "codebertscore": 1.0, "codescore": 0.9934820532798767, "surfaceSim": 0.49938195302843014, "abs_surfaceSim_minus_score": 0.49938195302843014}
{"golden_code": "from collections import defaultdict\nfrom collections import deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\ndef I():\n    return int(sys.stdin.readline())\ndef LS():\n    return list(map(list, sys.stdin.readline().split()))\ndef S():\n    return list(sys.stdin.readline())[:-1]\ndef IR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = I()\n    return l\ndef LIR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = LI()\n    return l\ndef SR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = S()\n    return l\ndef LSR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = SR()\n    return l\nmod = 1000000007\ndef A():\n    s = S()\n    t = S()\n    if s + t == t[::-1] + s[::-1]:\n        print('YES')else:print('NO')\ndef B():\n    n = I()\n    for i in range(int(n ** 0.5) + 2)[::-1]:\n        if i * i <= n:\n            print(i * i)\n            quit()\ndef C():\n    n = I()\n    a = LI()\n    b = LI()\n    c = LI()\n    q = [0 for i in range(n)]\n    ans = 0\n    a.sort()\n    b.sort()\n    c.sort()\n    for i in range(n):\n        j = bisect.bisect_left(a, b[i])\n        q[i] = j\n    for i in range(n - 1):\n        q[i + 1] += q[i]\n    q.insert(0, 0)\n    for i in range(n):\n        j = bisect.bisect_left(b, c[i])\n        ans += q[j]\n    print(ans)\ndef D():\n    def dijkstra():\n        d = [float('inf') for i in range(k)]\n        q = [[0, 1]]\n        d[1] = 0\n        while q:\n            (dx, x) = heappop(q)\n            for (y, dy) in v[x]:\n                if d[y] > dx + dy:\n                    d[y] = dx + dy\n                    heappush(q, [d[y], y])\n        print(d[0] + 1)\n    k = I()\n    if k == 1:\n        print(1)\n        quit()\n    v = [[] for i in range(k)]\n    for i in range(1, k):\n        v[i].append([(i + 1) % k, 1])\n        v[i].append([(i * 10) % k, 0])\n    dijkstra()\ndef E():\n    return\ndef F():\n    return\ndef G():\n    return\ndef H():\n    return", "generated_code": "from collections import defaultdict\nfrom collections import deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\ndef I():\n    return int(sys.stdin.readline())\ndef LS():\n    return list(map(list, sys.stdin.readline().split()))\ndef S():\n    return list(sys.stdin.readline())[:-1]\ndef IR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = I()\n    return l\ndef LIR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = LI()\n    return l\ndef SR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = S()\n    return l\ndef LSR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = SR()\n    return l\nmod = 1000000007\ndef A():\n    s = S()\n    t = S()\n    if s + t == t[::-1] + s[::+1]:\n        print('YES')else:print('NO')\ndef B():\n    n = I()\n    for i in range(int(n ** 0.5) + 2)[::-1]:\n        if i * i <= n:\n            print(i * i)\n            quit()\ndef C():\n    n = I()\n    a = LI()\n    b = LI()\n    c = LI()\n    q = [0 for i in range(n)]\n    ans = 0\n    a.sort()\n    b.sort()\n    c.sort()\n    for i in range(n):\n        j = bisect.bisect_left(a, b[i])\n        q[i] = j\n    for i in range(n - 1):\n        q[i + 1] += q[i]\n    q.insert(0, 0)\n    for i in range(n):\n        j = bisect.bisect_left(b, c[i])\n        ans += q[j]\n    print(ans)\ndef D():\n    def dijkstra():\n        d = [float('inf') for i in range(k)]\n        q = [[0, 1]]\n        d[1] = 0\n        while q:\n            (dx, x) = heappop(q)\n            for (y, dy) in v[x]:\n                if d[y] > dx + dy:\n                    d[y] = dx + dy\n                    heappush(q, [d[y], y])\n        print(d[0] + 1)\n    k = I()\n    if k == 1:\n        print(1)\n        quit()\n    v = [[] for i in range(k)]\n    for i in range(1, k):\n        v[i].append([(i + 1) % k, 1])\n        v[i].append([(i * 10) % k, 0])\n    dijkstra()\ndef E():\n    return\ndef F():\n    return\ndef G():\n    return\ndef H():\n    return", "score": 0.0, "codebleu": 0.9960259674102339, "crystalbleu": 0.9961383241450749, "codebertscore": 1.0, "codescore": 0.9813350439071655, "surfaceSim": 0.499755859375, "abs_surfaceSim_minus_score": 0.499755859375}
{"golden_code": "import sys\n(n, m, *abcdef) = list(map(int, sys.stdin.buffer.read().split()))\nver_lines = []\nhor_lines = []\nx_list = set()\ny_list = set()\nn3 = n * 3\nfor (a, b, c) in zip(abcdef[0:n3:3], abcdef[1:n3:3], abcdef[2:n3:3]):\n    y_list.add(a)\n    y_list.add(b)\n    x_list.add(c)\n    ver_lines.append((a, b, c))\nfor (d, e, f) in zip(abcdef[n3 + 0::3], abcdef[n3 + 1::3], abcdef[n3 + 2::3]):\n    y_list.add(d)\n    x_list.add(e)\n    x_list.add(f)\n    hor_lines.append((d, e, f))\nx_list.add(0)\ny_list.add(0)\nx_list = sorted(x_list)\ny_list = sorted(y_list)\nx_dict = {x: i for (i, x) in enumerate(x_list, start=1)}\ny_dict = {y: i for (i, y) in enumerate(y_list, start=1)}\nrow_real = len(x_list)\ncol_real = len(y_list)\nrow = row_real + 2\ncol = col_real + 2\nbanned_up_ij = [[0] * row for _ in range(col)]\nbanned_down_ij = [[0] * row for _ in range(col)]\nbanned_left_ij = [[0] * col for _ in range(row)]\nbanned_right_ij = [[0] * col for _ in range(row)]\nfor (a, b, c) in ver_lines:\n    if a > b:\n        (a, b) = (b, a)\n    ai = y_dict[a]\n    bi = y_dict[b]\n    j = x_dict[c]\n    banned_left_ij[j][ai] += 1\n    banned_left_ij[j][bi] -= 1\n    banned_right_ij[j - 1][ai] += 1\n    banned_right_ij[j - 1][bi] -= 1\nfor (d, e, f) in hor_lines:\n    if e > f:\n        (e, f) = (f, e)\n    i = y_dict[d]\n    ej = x_dict[e]\n    fj = x_dict[f]\n    banned_up_ij[i][ej] += 1\n    banned_up_ij[i][fj] -= 1\n    banned_down_ij[i - 1][ej] += 1\n    banned_down_ij[i - 1][fj] -= 1\nbanned_up = [0] * (row * col)\nbanned_down = [0] * (row * col)\nbanned_left = [0] * (row * col)\nbanned_right = [0] * (row * col)\nfor i in range(col):\n    ru = banned_up_ij[i]\n    rd = banned_down_ij[i]\n    ri = row * i\n    banned_up[ri] = ru[0]\n    banned_down[ri] = rd[0]\n    for j in range(1, row):\n        banned_up[ri + j] = banned_up[(ri + j) - 1] + ru[j]\n        banned_down[ri + j] = banned_down[(ri + j) - 1] + rd[j]\nfor j in range(row):\n    rl = banned_left_ij[j]\n    rr = banned_right_ij[j]\n    banned_left[j] = rl[0]\n    banned_right[j] = rr[0]\n    for i in range(1, col):\n        ri0 = (i - 1) * row\n        ri1 = i * row\n        banned_left[ri1 + j] = banned_left[ri0 + j] + rl[i]\n        banned_right[ri1 + j] = banned_right[ri0 + j] + rr[i]\ns = (row * y_dict[0]) + x_dict[0]\nenable = (([-1] * row) + ((([-1] + ([0] * (row - 2))) + [-1]) * (col - 2))) + ([-1] * row)\nq = [s]\nmoves = [(-row, banned_up), (-1, banned_left), (1, banned_right), (row, banned_down)]\nwhile q:\n    c = q.pop()\n    if enable[c] == 1:\n        continue\n    elif enable[c] == -1:\n        print('INF')\n        exit()\n    enable[c] = 1\n    for (dc, banned) in moves:\n        if banned[c]:\n            continue\n        nc = c + dc\n        if enable[nc] == 1:\n            continue\n        q.append(nc)\nans = 0\nfor i in range(col):\n    ri = i * row\n    for j in range(row):\n        if enable[ri + j] != 1:\n            continue\n        t = y_list[i - 1]\n        b = y_list[i]\n        l = x_list[j - 1]\n        r = x_list[j]\n        ans += (b - t) * (r - l)\nprint(ans)", "generated_code": "import sys\n(n, m, *abcdef) = list(map(int, sys.stdin.buffer.read().split()))\nver_lines = []\nhor_lines = []\nx_list = set()\ny_list = set()\nn3 = n * 3\nfor (a, b, c) in zip(abcdef[0:n3:3], abcdef[1:n3:3], abcdef[2:n3:3]):\n    y_list.add(a)\n    y_list.add(b)\n    x_list.add(c)\n    ver_lines.append((a, b, c))\nfor (d, e, f) in zip(abcdef[n3 + 0::3], abcdef[n3 + 1::3], abcdef[n3 + 2::3]):\n    y_list.add(d)\n    x_list.add(e)\n    x_list.add(f)\n    hor_lines.append((d, e, f))\nx_list.add(0)\ny_list.add(0)\nx_list = sorted(x_list)\ny_list = sorted(y_list)\nx_dict = {x: i for (i, x) in enumerate(x_list, start=1)}\ny_dict = {y: i for (i, y) in enumerate(y_list, start=1)}\nrow_real = len(x_list)\ncol_real = len(y_list)\nrow = row_real + 2\ncol = col_real - 2\nbanned_up_ij = [[0] * row for _ in range(col)]\nbanned_down_ij = [[0] * row for _ in range(col)]\nbanned_left_ij = [[0] * col for _ in range(row)]\nbanned_right_ij = [[0] * col for _ in range(row)]\nfor (a, b, c) in ver_lines:\n    if a > b:\n        (a, b) = (b, a)\n    ai = y_dict[a]\n    bi = y_dict[b]\n    j = x_dict[c]\n    banned_left_ij[j][ai] += 1\n    banned_left_ij[j][bi] -= 1\n    banned_right_ij[j - 1][ai] += 1\n    banned_right_ij[j - 1][bi] -= 1\nfor (d, e, f) in hor_lines:\n    if e > f:\n        (e, f) = (f, e)\n    i = y_dict[d]\n    ej = x_dict[e]\n    fj = x_dict[f]\n    banned_up_ij[i][ej] += 1\n    banned_up_ij[i][fj] -= 1\n    banned_down_ij[i - 1][ej] += 1\n    banned_down_ij[i - 1][fj] -= 1\nbanned_up = [0] * (row * col)\nbanned_down = [0] * (row * col)\nbanned_left = [0] * (row * col)\nbanned_right = [0] * (row * col)\nfor i in range(col):\n    ru = banned_up_ij[i]\n    rd = banned_down_ij[i]\n    ri = row * i\n    banned_up[ri] = ru[0]\n    banned_down[ri] = rd[0]\n    for j in range(1, row):\n        banned_up[ri + j] = banned_up[(ri + j) - 1] + ru[j]\n        banned_down[ri + j] = banned_down[(ri + j) - 1] + rd[j]\nfor j in range(row):\n    rl = banned_left_ij[j]\n    rr = banned_right_ij[j]\n    banned_left[j] = rl[0]\n    banned_right[j] = rr[0]\n    for i in range(1, col):\n        ri0 = (i - 1) * row\n        ri1 = i * row\n        banned_left[ri1 + j] = banned_left[ri0 + j] + rl[i]\n        banned_right[ri1 + j] = banned_right[ri0 + j] + rr[i]\ns = (row * y_dict[0]) + x_dict[0]\nenable = (([-1] * row) + ((([-1] + ([0] * (row - 2))) + [-1]) * (col - 2))) + ([-1] * row)\nq = [s]\nmoves = [(-row, banned_up), (-1, banned_left), (1, banned_right), (row, banned_down)]\nwhile q:\n    c = q.pop()\n    if enable[c] == 1:\n        continue\n    elif enable[c] == -1:\n        print('INF')\n        exit()\n    enable[c] = 1\n    for (dc, banned) in moves:\n        if banned[c]:\n            continue\n        nc = c + dc\n        if enable[nc] == 1:\n            continue\n        q.append(nc)\nans = 0\nfor i in range(col):\n    ri = i * row\n    for j in range(row):\n        if enable[ri + j] != 1:\n            continue\n        t = y_list[i - 1]\n        b = y_list[i]\n        l = x_list[j - 1]\n        r = x_list[j]\n        ans += (b - t) * (r - l)\nprint(ans)", "score": 0.0, "codebleu": 0.9973984967720897, "crystalbleu": 0.9976473158075668, "codebertscore": 1.0, "codescore": 0.9547488689422607, "surfaceSim": 0.9998327199732352, "abs_surfaceSim_minus_score": 0.9998327199732352}
{"golden_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "generated_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        pass\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "score": 0.0, "codebleu": 0.8007963721005158, "crystalbleu": 0.9648784456962497, "codebertscore": 0.98, "codescore": 0.988802969455719, "surfaceSim": 0.9643681788734032, "abs_surfaceSim_minus_score": 0.9643681788734032}
{"golden_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "generated_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 // N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "score": 0.0, "codebleu": 0.9963221036285097, "crystalbleu": 0.9902733286696281, "codebertscore": 1.0, "codescore": 0.9858070611953735, "surfaceSim": 0.9887682303175706, "abs_surfaceSim_minus_score": 0.9887682303175706}
{"golden_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "generated_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "score": 0.0, "codebleu": 0.9865939505120788, "crystalbleu": 0.9942110332335385, "codebertscore": 1.0, "codescore": 0.9935803413391113, "surfaceSim": 0.9988589685075309, "abs_surfaceSim_minus_score": 0.9988589685075309}
{"golden_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "generated_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "score": 0.0, "codebleu": 1.0, "crystalbleu": 1.0, "codebertscore": 1.0, "codescore": 0.993831992149353, "surfaceSim": 1.0, "abs_surfaceSim_minus_score": 1.0}
{"golden_code": "from functools import lru_cache\nimport sys\nsys.setrecursionlimit(10 ** 7)\n\n@lru_cache(maxsize=None)\ndef check(l, r, n, k=1):t = (l + ('0' * k)) + r\n    e = (l + ('9' * k)) + r\n    if int(e) <= n:\n        return pow(10, k) + check(l, r, n, k + 1)\n    if int(t) <= n < int(e):\n        x = int(str(n)[1:-1])\n        if int(str(n)[-1]) < int(r):\n            x -= 1\n        return x + 1\n    if n < int(t):\n        return 0\ndef main():\n    n = int(eval(input()))\n    ret = 0\n    for x in range(1, n + 1):\n        if x % 10 == 0:\n            continue\n        s = str(x)\n        t = s[-1] + s[0]\n        if s[0] == s[-1]:\n            ret += 1\n        if int(t) <= n:\n            ret += 1\n        ret += check(s[-1], s[0], n, k=1)\n    print(ret)", "generated_code": "from functools import lru_cache\nimport sys\nsys.setrecursionlimit(10 ** 7)\n\n@lru_cache(maxsize=None)\ndef check(l, r, n, k=1):t = (l + ('0' * k)) + r\n    e = (l + ('9' * k)) + r\n    if int(e) <= n:\n        return pow(10, k) + check(l, r, n, k + 1)\n    if int(t) <= n < int(e):\n        x = int(str(n)[1:-1])\n        if int(str(n)[1]) < int(r):\n            x -= 1\n        return x + 1\n    if n < int(t):\n        return 0\ndef main():\n    n = int(eval(input()))\n    ret = 0\n    for x in range(1, n + 1):\n        if x % 10 == 0:\n            continue\n        s = str(x)\n        t = s[-1] + s[0]\n        if s[0] == s[-1]:\n            ret += 1\n        if int(t) <= n:\n            ret += 1\n        ret += check(s[-1], s[0], n, k=1)\n    print(ret)", "score": 0.0, "codebleu": 0.975942333324992, "crystalbleu": 0.9902419169655517, "codebertscore": 1.0, "codescore": 0.9937546253204346, "surfaceSim": 0.499320652173913, "abs_surfaceSim_minus_score": 0.499320652173913}
{"golden_code": "import sys\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\ndef solve():\n    inf = (10 ** 14) + 10\n    def dfs(v: 'vertex_index, 0-indexed') -> None:\n        for (c, t) in e[v]:\n            if d[t] != inf:\n                continue\n            d[t] = d[v] + c\n            dfs(t)\n    n = int(eval(input()))\n    e = tuple((set() for _ in range(n)))\n    for _ in range(n - 1):\n        (a, b, c) = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        e[a].add((c, b))\n        e[b].add((c, a))\n    (q, v) = list(map(int, input().split()))\n    v -= 1\n    d = [inf] * n\n    d[v] = 0\n    dfs(v)\n    for _ in range(q):\n        (x, y) = list(map(int, input().split()))\n        x -= 1\n        y -= 1\n        print(d[x] + d[y])", "generated_code": "import sys\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\ndef solve():\n    inf = (10 ** 14) - 10\n    def dfs(v: 'vertex_index, 0-indexed') -> None:\n        for (c, t) in e[v]:\n            if d[t] != inf:\n                continue\n            d[t] = d[v] + c\n            dfs(t)\n    n = int(eval(input()))\n    e = tuple((set() for _ in range(n)))\n    for _ in range(n - 1):\n        (a, b, c) = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        e[a].add((c, b))\n        e[b].add((c, a))\n    (q, v) = list(map(int, input().split()))\n    v -= 1\n    d = [inf] * n\n    d[v] = 0\n    dfs(v)\n    for _ in range(q):\n        (x, y) = list(map(int, input().split()))\n        x -= 1\n        y -= 1\n        print(d[x] + d[y])", "score": 0.0, "codebleu": 0.9881398574370538, "crystalbleu": 0.9907582847077829, "codebertscore": 1.0, "codescore": 0.9938209652900696, "surfaceSim": 0.9993243243243244, "abs_surfaceSim_minus_score": 0.9993243243243244}
{"golden_code": "INF = 10 ** 10\n(N, M) = list(map(int, input().split()))\ncosts = []\nkeys = []\nfor _ in range(M):\n    (A, B) = list(map(int, input().split()))\n    cs = list(map(int, input().split()))\n    costs.append(A)\n    key = 0\n    for c in cs:\n        key |= 1 << (c - 1)\n    keys.append(key)\nmaskss = [[] for _ in range(N + 1)]\nnum1s = [0] * (2 ** N)\nfor S in range(2 ** N):\n    num = bin(S).count('1')\n    maskss[num].append(S)\n    num1s[S] = num\ndpAll = [INF] * (2 ** N)\nfor S in range(2 ** N):\n    for (cost, key) in zip(costs, keys):\n        if S & key == S:\n            if cost < dpAll[S]:\n                dpAll[S] = cost\ndp = [INF] * (2 ** N)\nfor S in range(2 ** N):\n    cost = dpAll[S]\n    num1 = num1s[S]\n    for k in range(1, ((num1 + 1) // 2) + 1):\n        for mask in maskss[k]:\n            if mask & S == mask:\n                m2 = S ^ mask\n                c2 = dp[mask] + dp[m2]\n                if c2 < cost:\n                    cost = c2\n    dp[S] = cost\nif dp[(2 ** N) - 1] == INF:\n    print(-1)\nelse:\n    print(dp[(2 ** N) - 1])", "generated_code": "INF = 10 ** 10\n(N, M) = list(map(int, input().split()))\ncosts = []\nkeys = []\nfor _ in range(M):\n    (A, B) = list(map(int, input().split()))\n    cs = list(map(int, input().split()))\n    costs.append(A)\n    key = 0\n    for c in cs:\n        key |= 1 << (c - 1)\n    keys.append(key)\nmaskss = [[] for _ in range(N - 1)]\nnum1s = [0] * (2 ** N)\nfor S in range(2 ** N):\n    num = bin(S).count('1')\n    maskss[num].append(S)\n    num1s[S] = num\ndpAll = [INF] * (2 ** N)\nfor S in range(2 ** N):\n    for (cost, key) in zip(costs, keys):\n        if S & key == S:\n            if cost < dpAll[S]:\n                dpAll[S] = cost\ndp = [INF] * (2 ** N)\nfor S in range(2 ** N):\n    cost = dpAll[S]\n    num1 = num1s[S]\n    for k in range(1, ((num1 + 1) // 2) + 1):\n        for mask in maskss[k]:\n            if mask & S == mask:\n                m2 = S ^ mask\n                c2 = dp[mask] + dp[m2]\n                if c2 < cost:\n                    cost = c2\n    dp[S] = cost\nif dp[(2 ** N) - 1] == INF:\n    print(-1)\nelse:\n    print(dp[(2 ** N) - 1])", "score": 0.0, "codebleu": 0.9931217231346744, "crystalbleu": 0.993839919995461, "codebertscore": 1.0, "codescore": 0.9937952756881714, "surfaceSim": 0.999515503875969, "abs_surfaceSim_minus_score": 0.999515503875969}
{"golden_code": "def cmb(n, r):\n    import math\n    if n < r:\n        return 0\n    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\ndef solve(S):\n    mod = (10 ** 9) + 7\n    ans = 0\n    for i in range(1, (S // 3) + 1):\n        tama = i + (S - (i * 3))\n        tama -= 2\n        bo = i - 1\n        ans += cmb(tama + 1, bo)\n        ans %= mod\n    print(ans)", "generated_code": "def cmb(n, r):\n    import math\n    if n < r:\n        return 0\n    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\ndef solve(S):\n    mod = (10 ** 9) + 7\n    pass\n    for i in range(1, (S // 3) + 1):\n        tama = i + (S - (i * 3))\n        tama -= 2\n        bo = i - 1\n        ans += cmb(tama + 1, bo)\n        ans %= mod\n    print(ans)", "score": 0.0, "codebleu": 0.8347949180891591, "crystalbleu": 0.9384831828379085, "codebertscore": 0.99, "codescore": 0.9937518239021301, "surfaceSim": 0.976602690937871, "abs_surfaceSim_minus_score": 0.976602690937871}
{"golden_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "generated_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    pass\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "score": 0.0, "codebleu": 0.852304853023182, "crystalbleu": 0.9572704047647298, "codebertscore": 0.99, "codescore": 0.9938321113586426, "surfaceSim": 0.9701906659077975, "abs_surfaceSim_minus_score": 0.9701906659077975}
{"golden_code": "from functools import lru_cache\nimport sys\nsys.setrecursionlimit(10 ** 7)\n\n@lru_cache(maxsize=None)\ndef check(l, r, n, k=1):t = (l + ('0' * k)) + r\n    e = (l + ('9' * k)) + r\n    if int(e) <= n:\n        return pow(10, k) + check(l, r, n, k + 1)\n    if int(t) <= n < int(e):\n        x = int(str(n)[1:-1])\n        if int(str(n)[-1]) < int(r):\n            x -= 1\n        return x + 1\n    if n < int(t):\n        return 0\ndef main():\n    n = int(eval(input()))\n    ret = 0\n    for x in range(1, n + 1):\n        if x % 10 == 0:\n            continue\n        s = str(x)\n        t = s[-1] + s[0]\n        if s[0] == s[-1]:\n            ret += 1\n        if int(t) <= n:\n            ret += 1\n        ret += check(s[-1], s[0], n, k=1)\n    print(ret)", "generated_code": "from functools import lru_cache\nimport sys\nsys.setrecursionlimit(10 ** 7)\n\n@lru_cache(maxsize=None)\ndef check(l, r, n, k=1):t = (l + ('0' * k)) + r\n    e = (l + ('9' * k)) + r\n    if int(e) <= n:\n        return pow(10, k) + check(l, r, n, k + 1)\n    if int(t) <= n < int(e):\n        x = int(str(n)[1:-1])\n        if int(str(n)[-1]) < int(r):\n            x -= 1\n        return x + 1\n    if n < int(t):\n        return 0\ndef main():\n    n = int(eval(input()))\n    ret = 0\n    for x in range(1, n + 1):\n        if x % 10 == 0:\n            continue\n        s = str(x)\n        t = s[-1] + s[0]\n        if s[0] == s[-1]:\n            ret += 1\n        if int(t) <= n:\n            ret += 1\n        ret += check(s[1], s[0], n, k=1)\n    print(ret)", "score": 0.0, "codebleu": 0.974206222213881, "crystalbleu": 0.9902419169655517, "codebertscore": 1.0, "codescore": 0.9937633872032166, "surfaceSim": 0.499320652173913, "abs_surfaceSim_minus_score": 0.499320652173913}
{"golden_code": "from functools import lru_cache\nimport sys\nsys.setrecursionlimit(10 ** 7)\n\n@lru_cache(maxsize=None)\ndef check(l, r, n, k=1):t = (l + ('0' * k)) + r\n    e = (l + ('9' * k)) + r\n    if int(e) <= n:\n        return pow(10, k) + check(l, r, n, k + 1)\n    if int(t) <= n < int(e):\n        x = int(str(n)[1:-1])\n        if int(str(n)[-1]) < int(r):\n            x -= 1\n        return x + 1\n    if n < int(t):\n        return 0\ndef main():\n    n = int(eval(input()))\n    ret = 0\n    for x in range(1, n + 1):\n        if x % 10 == 0:\n            continue\n        s = str(x)\n        t = s[-1] + s[0]\n        if s[0] == s[-1]:\n            ret += 1\n        if int(t) <= n:\n            ret += 1\n        ret += check(s[-1], s[0], n, k=1)\n    print(ret)", "generated_code": "from functools import lru_cache\nimport sys\nsys.setrecursionlimit(10 ** 7)\n\n@lru_cache(maxsize=None)\ndef check(l, r, n, k=1):t = (l + ('0' * k)) + r\n    e = (l + ('9' * k)) + r\n    if int(e) <= n:\n        return pow(10, k) + check(l, r, n, k + 1)\n    if int(t) <= n < int(e):\n        x = int(str(n)[1:1])\n        if int(str(n)[-1]) < int(r):\n            x -= 1\n        return x + 1\n    if n < int(t):\n        return 0\ndef main():\n    n = int(eval(input()))\n    ret = 0\n    for x in range(1, n + 1):\n        if x % 10 == 0:\n            continue\n        s = str(x)\n        t = s[-1] + s[0]\n        if s[0] == s[-1]:\n            ret += 1\n        if int(t) <= n:\n            ret += 1\n        ret += check(s[-1], s[0], n, k=1)\n    print(ret)", "score": 0.0, "codebleu": 0.974206222213881, "crystalbleu": 0.9902168666916028, "codebertscore": 1.0, "codescore": 0.9937648773193359, "surfaceSim": 0.499320652173913, "abs_surfaceSim_minus_score": 0.499320652173913}
{"golden_code": "def cmb(n, r):\n    import math\n    if n < r:\n        return 0\n    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\ndef solve(S):\n    mod = (10 ** 9) + 7\n    ans = 0\n    for i in range(1, (S // 3) + 1):\n        tama = i + (S - (i * 3))\n        tama -= 2\n        bo = i - 1\n        ans += cmb(tama + 1, bo)\n        ans %= mod\n    print(ans)", "generated_code": "def cmb(n, r):\n    import math\n    if n < r:\n        return 0\n    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\ndef solve(S):\n    mod = (10 ** 9) + 7\n    ans = 0\n    for i in range(1, (S // 3) + 1):\n        tama = i + (S - (i * 3))\n        tama -= 2\n        bo = i - 1\n        ans += cmb(tama + 1, bo)\n        ans %= mod\n    print(ans)", "score": 0.0, "codebleu": 1.0, "crystalbleu": 1.0, "codebertscore": 1.0, "codescore": 0.9937244057655334, "surfaceSim": 1.0, "abs_surfaceSim_minus_score": 1.0}
{"golden_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "generated_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    pass\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "score": 0.0, "codebleu": 0.8123074616171126, "crystalbleu": 0.916083301294518, "codebertscore": 0.99, "codescore": 0.993760883808136, "surfaceSim": 0.9417093530639348, "abs_surfaceSim_minus_score": 0.9417093530639348}
{"golden_code": "from functools import lru_cache\nimport sys\nsys.setrecursionlimit(10 ** 7)\n\n@lru_cache(maxsize=None)\ndef check(l, r, n, k=1):t = (l + ('0' * k)) + r\n    e = (l + ('9' * k)) + r\n    if int(e) <= n:\n        return pow(10, k) + check(l, r, n, k + 1)\n    if int(t) <= n < int(e):\n        x = int(str(n)[1:-1])\n        if int(str(n)[-1]) < int(r):\n            x -= 1\n        return x + 1\n    if n < int(t):\n        return 0\ndef main():\n    n = int(eval(input()))\n    ret = 0\n    for x in range(1, n + 1):\n        if x % 10 == 0:\n            continue\n        s = str(x)\n        t = s[-1] + s[0]\n        if s[0] == s[-1]:\n            ret += 1\n        if int(t) <= n:\n            ret += 1\n        ret += check(s[-1], s[0], n, k=1)\n    print(ret)", "generated_code": "from functools import lru_cache\nimport sys\nsys.setrecursionlimit(10 ** 7)\n\n@lru_cache(maxsize=None)\ndef check(l, r, n, k=1):t = (l - ('0' * k)) + r\n    e = (l + ('9' * k)) + r\n    if int(e) <= n:\n        return pow(10, k) + check(l, r, n, k + 1)\n    if int(t) <= n < int(e):\n        x = int(str(n)[1:-1])\n        if int(str(n)[-1]) < int(r):\n            x -= 1\n        return x + 1\n    if n < int(t):\n        return 0\ndef main():\n    n = int(eval(input()))\n    ret = 0\n    for x in range(1, n + 1):\n        if x % 10 == 0:\n            continue\n        s = str(x)\n        t = s[-1] + s[0]\n        if s[0] == s[-1]:\n            ret += 1\n        if int(t) <= n:\n            ret += 1\n        ret += check(s[-1], s[0], n, k=1)\n    print(ret)", "score": 0.0, "codebleu": 0.989831222213881, "crystalbleu": 0.9906756962652876, "codebertscore": 1.0, "codescore": 0.9937620759010315, "surfaceSim": 0.499320652173913, "abs_surfaceSim_minus_score": 0.499320652173913}
{"golden_code": "import math, string, itertools, fractions, heapq, collections, re, array, bisect, sys, random, time, copy, functools\nsys.setrecursionlimit(10 ** 7)\ninf = 10 ** 20\neps = 1.0 / (10 ** 15)\nmod = (10 ** 9) + 7\ndef LI():\n    return [int(x) for x in sys.stdin.readline().split()]\ndef LI_():\n    return [int(x) - 1 for x in sys.stdin.readline().split()]\ndef LF():\n    return [float(x) for x in sys.stdin.readline().split()]\ndef LS():\n    return sys.stdin.readline().split()\ndef I():\n    return int(sys.stdin.readline())\ndef F():\n    return float(sys.stdin.readline())\ndef S():\n    return input()\ndef pf(s):\n    return print(s, flush=True)\ndef divisions(n):\n    sq = int(math.sqrt(n) + 1)\n    d = collections.defaultdict(int)\n    while n % 2 == 0:\n        n //= 2\n        d[2] += 1\n    i = 3\n    while (n > 1 and sq >= i):\n        if n % i == 0:\n            n //= i\n            d[i] += 1else:i += 2\n    if n > 1:\n        d[n] += 1\n    r = [1]\n    for (k, v) in d.items():\n        for c in r[:]:\n            for i in range(1, v + 1):\n                r.append(c * (k ** i))\n    return sorted(r)\ndef main():\n    n = I()\n    a = LI()\n    s = set()\n    for i in range(n, 0, -1):\n        d = divisions(i)\n        ld = len(d)\n        for j in range(1, 2 ** ld):\n            c = []\n            ff = True\n            for k in range(ld):\n                if j & (1 << k):\n                    f = True\n                    for e in c:\n                        if d[k] % e == 0:\n                            f = False\n                            ff = False\n                            break\n                    if f:\n                        c.append(d[k])\n                if not ff:\n                    break\n            if ff:\n                s.add(tuple(c + [n + 1]))\n    b = sorted(list(s), reverse=True)\n    for c in b:\n        t = 0\n        for j in range(1, n + 1):\n            f = False\n            for e in c:\n                if j % e == 0:\n                    f = True\n                    break\n            if f:\n                t += a[j - 1]\n        if t < 0:\n            for j in range(1, n + 1):\n                f = False\n                for e in c:\n                    if j % e == 0:\n                        f = True\n                        break\n                if f:\n                    a[j - 1] = 0\n    return sum(a)\nprint(main())", "generated_code": "import math, string, itertools, fractions, heapq, collections, re, array, bisect, sys, random, time, copy, functools\nsys.setrecursionlimit(10 ** 7)\ninf = 10 ** 20\neps = 1.0 / (10 ** 15)\nmod = (10 * 9) + 7\ndef LI():\n    return [int(x) for x in sys.stdin.readline().split()]\ndef LI_():\n    return [int(x) - 1 for x in sys.stdin.readline().split()]\ndef LF():\n    return [float(x) for x in sys.stdin.readline().split()]\ndef LS():\n    return sys.stdin.readline().split()\ndef I():\n    return int(sys.stdin.readline())\ndef F():\n    return float(sys.stdin.readline())\ndef S():\n    return input()\ndef pf(s):\n    return print(s, flush=True)\ndef divisions(n):\n    sq = int(math.sqrt(n) + 1)\n    d = collections.defaultdict(int)\n    while n % 2 == 0:\n        n //= 2\n        d[2] += 1\n    i = 3\n    while (n > 1 and sq >= i):\n        if n % i == 0:\n            n //= i\n            d[i] += 1else:i += 2\n    if n > 1:\n        d[n] += 1\n    r = [1]\n    for (k, v) in d.items():\n        for c in r[:]:\n            for i in range(1, v + 1):\n                r.append(c * (k ** i))\n    return sorted(r)\ndef main():\n    n = I()\n    a = LI()\n    s = set()\n    for i in range(n, 0, -1):\n        d = divisions(i)\n        ld = len(d)\n        for j in range(1, 2 ** ld):\n            c = []\n            ff = True\n            for k in range(ld):\n                if j & (1 << k):\n                    f = True\n                    for e in c:\n                        if d[k] % e == 0:\n                            f = False\n                            ff = False\n                            break\n                    if f:\n                        c.append(d[k])\n                if not ff:\n                    break\n            if ff:\n                s.add(tuple(c + [n + 1]))\n    b = sorted(list(s), reverse=True)\n    for c in b:\n        t = 0\n        for j in range(1, n + 1):\n            f = False\n            for e in c:\n                if j % e == 0:\n                    f = True\n                    break\n            if f:\n                t += a[j - 1]\n        if t < 0:\n            for j in range(1, n + 1):\n                f = False\n                for e in c:\n                    if j % e == 0:\n                        f = True\n                        break\n                if f:\n                    a[j - 1] = 0\n    return sum(a)\nprint(main())", "score": 0.0, "codebleu": 0.9962096427720554, "crystalbleu": 0.997208742053556, "codebertscore": 1.0, "codescore": 0.9919079542160034, "surfaceSim": 0.49978466838931956, "abs_surfaceSim_minus_score": 0.49978466838931956}
{"golden_code": "def popcount(x):\n    x = x - ((x >> 1) & 1431655765)\n    x = (x & 858993459) + ((x >> 2) & 858993459)\n    x = (x + (x >> 4)) & 252645135\n    x = x + (x >> 8)\n    x = x + (x >> 16)\n    return x & 127\ncmb = [[0 for i in range(51)] for j in range(51)]\ncmb[0][0] = 1\nfor i in range(51):\n    for j in range(51):\n        if (i != 50 and j != 50):\n            cmb[i + 1][j + 1] += cmb[i][j]\n        if i != 50:\n            cmb[i + 1][j] += cmb[i][j]\nfor i in range(1, 51):\n    for j in range(2, 51):\n        cmb[i][j] += cmb[i][j - 1]\n(N, K, T, S) = list(map(int, input().split()))\na = list(map(int, input().split()))\nmust0 = [i for i in range(18) if (S >> i) & 1 == 0]\nmust1 = [i for i in range(18) if (T >> i) & 1 == 1]\nA = []\nfor val in a:\n    check = True\n    for j in must0:\n        check = check & (val >> j) & 1 == 0\n    for j in must1:\n        check = check & (val >> j) & 1 == 1\n    if check:\n        A.append(val)\nif not A:\n    print(0)\n    exit()\nbit = []\nfor i in range(18):\n    if (i not in must0 and i not in must1):\n        bit.append(i)\nfor i in range(len(A)):\n    temp = 0\n    for j in range(len(bit)):\n        temp += (A[i] >> bit[j]) & 1 == 1 * (2 ** j)\n    A[i] = temp\nans = 0\nn = len(bit)\ndata = [0] * (2 ** n)\nfor i in range(2 ** n):\n    t = set([])\n    for a in A:\n        data[a & i] += 1\n        t.add(a & i)\n    temp = 0\n    for val in t:\n        temp += cmb[data[val]][min(K, data[val])]\n    ans += temp * ((-1) ** popcount(i))\n    for val in t:\n        data[val] = 0\nprint(ans)", "generated_code": "def popcount(x):\n    x = x - ((x >> 1) & 1431655765)\n    x = (x & 858993459) + ((x >> 2) & 858993459)\n    x = (x + (x >> 4)) & 252645135\n    x = x + (x >> 8)\n    x = x + (x >> 16)\n    return x & 127\ncmb = [[0 for i in range(51)] for j in range(51)]\ncmb[0][0] = 1\nfor i in range(51):\n    for j in range(51):\n        if (i != 50 and j != 50):\n            cmb[i + 1][j + 1] += cmb[i][j]\n        if i != 50:\n            cmb[i + 1][j] += cmb[i][j]\nfor i in range(1, 51):\n    for j in range(2, 51):\n        cmb[i][j] += cmb[i][j - 1]\n(N, K, T, S) = list(map(int, input().split()))\na = list(map(int, input().split()))\nmust0 = [i for i in range(18) if (S >> i) & 1 == 0]\nmust1 = [i for i in range(18) if (T >> i) & 1 == 1]\nA = []\nfor val in a:\n    pass\n    for j in must0:\n        check = check & (val >> j) & 1 == 0\n    for j in must1:\n        check = check & (val >> j) & 1 == 1\n    if check:\n        A.append(val)\nif not A:\n    print(0)\n    exit()\nbit = []\nfor i in range(18):\n    if (i not in must0 and i not in must1):\n        bit.append(i)\nfor i in range(len(A)):\n    temp = 0\n    for j in range(len(bit)):\n        temp += (A[i] >> bit[j]) & 1 == 1 * (2 ** j)\n    A[i] = temp\nans = 0\nn = len(bit)\ndata = [0] * (2 ** n)\nfor i in range(2 ** n):\n    t = set([])\n    for a in A:\n        data[a & i] += 1\n        t.add(a & i)\n    temp = 0\n    for val in t:\n        temp += cmb[data[val]][min(K, data[val])]\n    ans += temp * ((-1) ** popcount(i))\n    for val in t:\n        data[val] = 0\nprint(ans)", "score": 0.0, "codebleu": 0.9518440560589566, "crystalbleu": 0.9898085097984597, "codebertscore": 1.0, "codescore": 0.9936563372612, "surfaceSim": 0.9838417034678717, "abs_surfaceSim_minus_score": 0.9838417034678717}
{"golden_code": "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nfac = [1, 1]\nf_inv = [1, 1]\ninv = [0, 1]\ndef prepare(n, mod):\n    for i in range(2, n + 1):\n        fac.append((fac[-1] * i) % mod)\n        inv.append(((-(inv[mod % i])) * (mod // i)) % mod)\n        f_inv.append((f_inv[-1] * inv[-1]) % mod)\ndef cmb(n, r, mod):\n    if (n < 0 or r < 0):\n        return 0\n    if r > n:\n        return 0\n    return ((fac[n] * f_inv[r]) * f_inv[n - r]) % mod\ndef main():\n    (N, M, K) = list(map(int, readline().split()))\n    MOD = 998244353\n    prepare(N + 10, MOD)\n    if (M == 1 and K == N - 1):\n        print(1)\n        exit()\n    m = M\n    for _ in range(N - 1):\n        m *= M - 1\n        m %= MOD\n    ans = 0\n    for k in range(K + 1):\n        ans += (m * cmb(N - 1, k, MOD)) % MOD\n        ans %= MOD\n        m *= pow(M - 1, MOD - 2, MOD)\n        m %= MOD\n    print(ans)", "generated_code": "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nfac = [1, 1]\nf_inv = [1, 1]\ninv = [0, 1]\ndef prepare(n, mod):\n    for i in range(2, n - 1):\n        fac.append((fac[-1] * i) % mod)\n        inv.append(((-(inv[mod % i])) * (mod // i)) % mod)\n        f_inv.append((f_inv[-1] * inv[-1]) % mod)\ndef cmb(n, r, mod):\n    if (n < 0 or r < 0):\n        return 0\n    if r > n:\n        return 0\n    return ((fac[n] * f_inv[r]) * f_inv[n - r]) % mod\ndef main():\n    (N, M, K) = list(map(int, readline().split()))\n    MOD = 998244353\n    prepare(N + 10, MOD)\n    if (M == 1 and K == N - 1):\n        print(1)\n        exit()\n    m = M\n    for _ in range(N - 1):\n        m *= M - 1\n        m %= MOD\n    ans = 0\n    for k in range(K + 1):\n        ans += (m * cmb(N - 1, k, MOD)) % MOD\n        ans %= MOD\n        m *= pow(M - 1, MOD - 2, MOD)\n        m %= MOD\n    print(ans)", "score": 0.0, "codebleu": 0.9922919739240104, "crystalbleu": 0.9934237349989072, "codebertscore": 1.0, "codescore": 0.9937343001365662, "surfaceSim": 0.9994450610432852, "abs_surfaceSim_minus_score": 0.9994450610432852}
{"golden_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "generated_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] // (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "score": 0.0, "codebleu": 0.9950293033173805, "crystalbleu": 0.9943164908202797, "codebertscore": 1.0, "codescore": 0.9864991903305054, "surfaceSim": 0.9993857493857494, "abs_surfaceSim_minus_score": 0.9993857493857494}
{"golden_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "generated_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] - self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "score": 0.0, "codebleu": 0.9945883912637858, "crystalbleu": 0.9944481893084814, "codebertscore": 1.0, "codescore": 0.9934737086296082, "surfaceSim": 0.9869512808809933, "abs_surfaceSim_minus_score": 0.9869512808809933}
{"golden_code": "n = int(eval(input()))\nnode = {i: [] for i in range(1, n + 1)}\nvisited = [False for i in range(n + 1)]\nq = []\nfor _ in range(n - 1):\n    (a, b) = list(map(int, input().split()))\n    node[a].append(b)\n    node[b].append(a)\n    q.append((a, b))\nmother = q[0][0]\nvisited[mother] = True\nd = []\ne = []\npaint = {i: {} for i in range(1, n + 1)}\nmother_paint = [0 for i in range(n + 1)]\nc = 1\nfor child in node[mother]:\n    visited[child] = True\n    paint[mother][child] = c\n    paint[child][mother] = c\n    mother_paint[child] = c\n    c += 1\n    d.append(child)\nwhile d:\n    for parent in d:\n        p = 1\n        for child in node[parent]:\n            if visited[child] == False:\n                visited[child] = True\n                if p != mother_paint[parent]:\n                    paint[parent][child] = p\n                    paint[child][parent] = p\n                    mother_paint[child] = p\n                    p += 1\n                    e.append(child)\n                else:\n                    p += 1\n                    paint[parent][child] = p\n                    paint[child][parent] = p\n                    mother_paint[child] = p\n                    p += 1\n                    e.append(child)\n    if e:\n        d = e\n        e = []\n    else:\n        d = []\n        e = []\nK = 0\nfor i in range(1, n + 1):\n    K = max(K, len(node[i]))\nprint(K)\nfor i in range(n - 1):\n    (s, t) = (q[i][0], q[i][1])\n    print(paint[s][t])", "generated_code": "n = int(eval(input()))\nnode = {i: [] for i in range(1, n + 1)}\nvisited = [False for i in range(n + 1)]\nq = []\nfor _ in range(n + 1):\n    (a, b) = list(map(int, input().split()))\n    node[a].append(b)\n    node[b].append(a)\n    q.append((a, b))\nmother = q[0][0]\nvisited[mother] = True\nd = []\ne = []\npaint = {i: {} for i in range(1, n + 1)}\nmother_paint = [0 for i in range(n + 1)]\nc = 1\nfor child in node[mother]:\n    visited[child] = True\n    paint[mother][child] = c\n    paint[child][mother] = c\n    mother_paint[child] = c\n    c += 1\n    d.append(child)\nwhile d:\n    for parent in d:\n        p = 1\n        for child in node[parent]:\n            if visited[child] == False:\n                visited[child] = True\n                if p != mother_paint[parent]:\n                    paint[parent][child] = p\n                    paint[child][parent] = p\n                    mother_paint[child] = p\n                    p += 1\n                    e.append(child)\n                else:\n                    p += 1\n                    paint[parent][child] = p\n                    paint[child][parent] = p\n                    mother_paint[child] = p\n                    p += 1\n                    e.append(child)\n    if e:\n        d = e\n        e = []\n    else:\n        d = []\n        e = []\nK = 0\nfor i in range(1, n + 1):\n    K = max(K, len(node[i]))\nprint(K)\nfor i in range(n - 1):\n    (s, t) = (q[i][0], q[i][1])\n    print(paint[s][t])", "score": 0.0, "codebleu": 0.9935280794812529, "crystalbleu": 0.993782183160194, "codebertscore": 1.0, "codescore": 0.9938235282897949, "surfaceSim": 0.9996496145760336, "abs_surfaceSim_minus_score": 0.9996496145760336}
{"golden_code": "import numpy as np\nN_1 = list(map(int, input().split()))\nN_2 = list(map(int, input().split()))\nN_3 = list(map(int, input().split()))\nN = int(eval(input()))\na = [int(eval(input())) for i in range(N)]\nn = np.array([N_1, N_2, N_3])\nfor a_n in a:\n    if a_n in n:\n        n[n == a_n] = 0\n    else:\n        pass\ni = 0\nif np.all(n[(0:, 0)] == 0) == True:\n    i = +1\nelif np.all(n[(0:, 1)] == 0) == True:\n    i += 1\nelif np.all(n[(0:, 2)] == 0) == True:\n    i += 1\nelif np.all(n[(0, 0:)] == 0) == True:\n    i += 1\nelif np.all(n[(1, 0:)] == 0) == True:\n    i += 1\nelif np.all(n[(2, 0:)] == 0) == True:\n    i += 1\nelif (n[(0, 0)] == 0 and n[(1, 1)] == 0 and n[(2, 2)] == 0):\n    i += 1\nelif (n[(0, 2)] == 0 and n[(1, 1)] == 0 and n[(2, 0)] == 0):\n    i += 1\nif i > 0:\n    print('Yes')\nelse:\n    print('No')", "generated_code": "import numpy as np\nN_1 = list(map(int, input().split()))\nN_2 = list(map(int, input().split()))\nN_3 = list(map(int, input().split()))\nN = int(eval(input()))\na = [int(eval(input())) for i in range(N)]\nn = np.array([N_1, N_2, N_3])\nfor a_n in a:\n    if not (a_n in n):\n        n[n == a_n] = 0\n    else:\n        pass\ni = 0\nif np.all(n[(0:, 0)] == 0) == True:\n    i = +1\nelif np.all(n[(0:, 1)] == 0) == True:\n    i += 1\nelif np.all(n[(0:, 2)] == 0) == True:\n    i += 1\nelif np.all(n[(0, 0:)] == 0) == True:\n    i += 1\nelif np.all(n[(1, 0:)] == 0) == True:\n    i += 1\nelif np.all(n[(2, 0:)] == 0) == True:\n    i += 1\nelif (n[(0, 0)] == 0 and n[(1, 1)] == 0 and n[(2, 2)] == 0):\n    i += 1\nelif (n[(0, 2)] == 0 and n[(1, 1)] == 0 and n[(2, 0)] == 0):\n    i += 1\nif i > 0:\n    print('Yes')\nelse:\n    print('No')", "score": 0.0, "codebleu": 0.9793827440413371, "crystalbleu": 0.9772189226399943, "codebertscore": 1.0, "codescore": 0.9937319159507751, "surfaceSim": 0.49688667496886674, "abs_surfaceSim_minus_score": 0.49688667496886674}
{"golden_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "generated_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        __node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "score": 0.0, "codebleu": 0.9867305793496425, "crystalbleu": 0.9936989720107794, "codebertscore": 1.0, "codescore": 0.9816981554031372, "surfaceSim": 0.9984634296250768, "abs_surfaceSim_minus_score": 0.9984634296250768}
{"golden_code": "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nfac = [1, 1]\nf_inv = [1, 1]\ninv = [0, 1]\ndef prepare(n, mod):\n    for i in range(2, n + 1):\n        fac.append((fac[-1] * i) % mod)\n        inv.append(((-(inv[mod % i])) * (mod // i)) % mod)\n        f_inv.append((f_inv[-1] * inv[-1]) % mod)\ndef cmb(n, r, mod):\n    if (n < 0 or r < 0):\n        return 0\n    if r > n:\n        return 0\n    return ((fac[n] * f_inv[r]) * f_inv[n - r]) % mod\ndef main():\n    (N, M, K) = list(map(int, readline().split()))\n    MOD = 998244353\n    prepare(N + 10, MOD)\n    if (M == 1 and K == N - 1):\n        print(1)\n        exit()\n    m = M\n    for _ in range(N - 1):\n        m *= M - 1\n        m %= MOD\n    ans = 0\n    for k in range(K + 1):\n        ans += (m * cmb(N - 1, k, MOD)) % MOD\n        ans %= MOD\n        m *= pow(M - 1, MOD - 2, MOD)\n        m %= MOD\n    print(ans)", "generated_code": "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nfac = [1, 1]\nf_inv = [1, 1]\ninv = [0, 1]\ndef prepare(n, mod):\n    for i in range(2, n + 1):\n        fac.append((fac[+1] * i) % mod)\n        inv.append(((-(inv[mod % i])) * (mod // i)) % mod)\n        f_inv.append((f_inv[-1] * inv[-1]) % mod)\ndef cmb(n, r, mod):\n    if (n < 0 or r < 0):\n        return 0\n    if r > n:\n        return 0\n    return ((fac[n] * f_inv[r]) * f_inv[n - r]) % mod\ndef main():\n    (N, M, K) = list(map(int, readline().split()))\n    MOD = 998244353\n    prepare(N + 10, MOD)\n    if (M == 1 and K == N - 1):\n        print(1)\n        exit()\n    m = M\n    for _ in range(N - 1):\n        m *= M - 1\n        m %= MOD\n    ans = 0\n    for k in range(K + 1):\n        ans += (m * cmb(N - 1, k, MOD)) % MOD\n        ans %= MOD\n        m *= pow(M - 1, MOD - 2, MOD)\n        m %= MOD\n    print(ans)", "score": 0.0, "codebleu": 0.9922919739240104, "crystalbleu": 0.9924328516838384, "codebertscore": 1.0, "codescore": 0.9937356114387512, "surfaceSim": 0.9862871663064432, "abs_surfaceSim_minus_score": 0.9862871663064432}
{"golden_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "generated_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\npass\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "score": 0.0, "codebleu": 0.8492014325727167, "crystalbleu": 0.9744682701837961, "codebertscore": 0.99, "codescore": 0.9938759207725525, "surfaceSim": 0.9728467084044774, "abs_surfaceSim_minus_score": 0.9728467084044774}
{"golden_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "generated_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    @classmethod\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:print('NA')", "score": 0.0, "codebleu": 0.9895212352936913, "crystalbleu": 0.9944643274491598, "codebertscore": 1.0, "codescore": 0.9936095476150513, "surfaceSim": 0.9968109339407745, "abs_surfaceSim_minus_score": 0.9968109339407745}
{"golden_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "generated_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 ** i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "score": 0.0, "codebleu": 0.9963221036285097, "crystalbleu": 0.9972409634447433, "codebertscore": 1.0, "codescore": 0.9854987859725952, "surfaceSim": 0.9997032640949555, "abs_surfaceSim_minus_score": 0.9997032640949555}
{"golden_code": "from functools import lru_cache\nimport sys\nsys.setrecursionlimit(10 ** 7)\n\n@lru_cache(maxsize=None)\ndef check(l, r, n, k=1):t = (l + ('0' * k)) + r\n    e = (l + ('9' * k)) + r\n    if int(e) <= n:\n        return pow(10, k) + check(l, r, n, k + 1)\n    if int(t) <= n < int(e):\n        x = int(str(n)[1:-1])\n        if int(str(n)[-1]) < int(r):\n            x -= 1\n        return x + 1\n    if n < int(t):\n        return 0\ndef main():\n    n = int(eval(input()))\n    ret = 0\n    for x in range(1, n + 1):\n        if x % 10 == 0:\n            continue\n        s = str(x)\n        t = s[-1] + s[0]\n        if s[0] == s[-1]:\n            ret += 1\n        if int(t) <= n:\n            ret += 1\n        ret += check(s[-1], s[0], n, k=1)\n    print(ret)", "generated_code": "from functools import lru_cache\nimport sys\nsys.setrecursionlimit(10 ** 7)\n\n@lru_cache(maxsize=None)\ndef check(l, r, n, k=1):t = (l + ('0' * k)) + r\n    e = (l + ('9' * k)) + r\n    if int(e) <= n:\n        return pow(10, k) + check(l, r, n, k + 1)\n    if int(t) <= n < int(e):\n        x = int(str(n)[1:-1])\n        if int(str(n)[-1]) < int(r):\n            x -= 1\n        return x + 1\n    if n < int(t):\n        return 0\ndef main():\n    n = int(eval(input()))\n    ret = 0\n    for x in range(1, n + 1):\n        if x % 10 == 0:\n            continue\n        s = str(x)\n        t = s[-1] + s[0]\n        if s[0] == s[1]:\n            ret += 1\n        if int(t) <= n:\n            ret += 1\n        ret += check(s[-1], s[0], n, k=1)\n    print(ret)", "score": 0.0, "codebleu": 0.9776784444361031, "crystalbleu": 0.9902419169655517, "codebertscore": 1.0, "codescore": 0.9937629103660583, "surfaceSim": 0.499320652173913, "abs_surfaceSim_minus_score": 0.499320652173913}
{"golden_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "generated_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 / i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "score": 0.0, "codebleu": 0.9963221036285097, "crystalbleu": 0.9937377563162054, "codebertscore": 1.0, "codescore": 0.9820054769515991, "surfaceSim": 0.9890647900136453, "abs_surfaceSim_minus_score": 0.9890647900136453}
{"golden_code": "import sys\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\ndef solve():\n    inf = (10 ** 14) + 10\n    def dfs(v: 'vertex_index, 0-indexed') -> None:\n        for (c, t) in e[v]:\n            if d[t] != inf:\n                continue\n            d[t] = d[v] + c\n            dfs(t)\n    n = int(eval(input()))\n    e = tuple((set() for _ in range(n)))\n    for _ in range(n - 1):\n        (a, b, c) = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        e[a].add((c, b))\n        e[b].add((c, a))\n    (q, v) = list(map(int, input().split()))\n    v -= 1\n    d = [inf] * n\n    d[v] = 0\n    dfs(v)\n    for _ in range(q):\n        (x, y) = list(map(int, input().split()))\n        x -= 1\n        y -= 1\n        print(d[x] + d[y])", "generated_code": "import sys\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\ndef solve():\n    inf = (10 ** 14) + 10\n    def dfs(v: 'vertex_index, 0-indexed') -> None:\n        for (c, t) in e[v]:\n            if d[t] != inf:\n                continue\n            d[t] = d[v] + c\n            dfs(t)\n    n = int(eval(input()))\n    e = tuple((set() for _ in range(n)))\n    for _ in range(n + 1):\n        (a, b, c) = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        e[a].add((c, b))\n        e[b].add((c, a))\n    (q, v) = list(map(int, input().split()))\n    v -= 1\n    d = [inf] * n\n    d[v] = 0\n    dfs(v)\n    for _ in range(q):\n        (x, y) = list(map(int, input().split()))\n        x -= 1\n        y -= 1\n        print(d[x] + d[y])", "score": 0.0, "codebleu": 0.9881398574370538, "crystalbleu": 0.9907915106316487, "codebertscore": 1.0, "codescore": 0.9938175082206726, "surfaceSim": 0.9993243243243244, "abs_surfaceSim_minus_score": 0.9993243243243244}
{"golden_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "generated_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in reversed(enumerate(As[1:])):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "score": 0.0, "codebleu": 0.9926796891531877, "crystalbleu": 0.9901248331023985, "codebertscore": 1.0, "codescore": 0.9871261715888977, "surfaceSim": 0.9970484061393152, "abs_surfaceSim_minus_score": 0.9970484061393152}
{"golden_code": "class UnionFind:\n    def __init__(self, size):\n        self.table = [i for i in range(size)]\n    def find(self, x):\n        return self.table[x]\n    def union(self, x, y):\n        x1 = self.find(x)\n        y1 = self.find(y)\n        if x1 == y1:\n            return False\n        for i in range(len(self.table)):\n            if self.table[i] == y1:\n                self.table[i] = x1\n        return True\n(N, M) = list(map(int, input().split()))\nedges = []\nfor _ in range(M):\n    (a, b) = list(map(int, input().split()))\n    edges.append([a - 1, b - 1])\nmat = [[0] * N for _ in range(N)]\nfor (s, g) in edges:\n    mat[s][g] = 1\n    mat[g][s] = 1\nans = 0\nfor i in range(M):\n    uni = UnionFind(N)\n    for j in range(M):\n        if i != j:\n            uni.union(edges[j][0], edges[j][1])\n    if not (all((uni.find(0) == uni.find(x) for x in range(N)))):\n        ans += 1\nprint(ans)", "generated_code": "class UnionFind:\n    def __init__(self, size):\n        self.table = [i for i in range(size)]\n    def find(self, x):\n        return self.table[x]\n    def union(self, x, y):\n        x1 = self.find(x)\n        y1 = self.find(y)\n        if x1 == y1:\n            return False\n        for i in range(len(self.table)):\n            if self.table[i] == y1:\n                self.table[i] = x1\n        return True\n(N, M) = list(map(int, input().split()))\nedges = []\nfor _ in range(M):\n    (a, b) = list(map(int, input().split()))\n    edges.append([a - 1, b + 1])\nmat = [[0] * N for _ in range(N)]\nfor (s, g) in edges:\n    mat[s][g] = 1\n    mat[g][s] = 1\nans = 0\nfor i in range(M):\n    uni = UnionFind(N)\n    for j in range(M):\n        if i != j:\n            uni.union(edges[j][0], edges[j][1])\n    if not (all((uni.find(0) == uni.find(x) for x in range(N)))):\n        ans += 1\nprint(ans)", "score": 0.0, "codebleu": 0.9898100982097378, "crystalbleu": 0.9852893211659387, "codebertscore": 1.0, "codescore": 0.993698239326477, "surfaceSim": 0.9994285714285714, "abs_surfaceSim_minus_score": 0.9994285714285714}
{"golden_code": "import math, string, itertools, fractions, heapq, collections, re, array, bisect, sys, random, time, copy, functools\nsys.setrecursionlimit(10 ** 7)\ninf = 10 ** 20\neps = 1.0 / (10 ** 15)\nmod = (10 ** 9) + 7\ndef LI():\n    return [int(x) for x in sys.stdin.readline().split()]\ndef LI_():\n    return [int(x) - 1 for x in sys.stdin.readline().split()]\ndef LF():\n    return [float(x) for x in sys.stdin.readline().split()]\ndef LS():\n    return sys.stdin.readline().split()\ndef I():\n    return int(sys.stdin.readline())\ndef F():\n    return float(sys.stdin.readline())\ndef S():\n    return input()\ndef pf(s):\n    return print(s, flush=True)\ndef divisions(n):\n    sq = int(math.sqrt(n) + 1)\n    d = collections.defaultdict(int)\n    while n % 2 == 0:\n        n //= 2\n        d[2] += 1\n    i = 3\n    while (n > 1 and sq >= i):\n        if n % i == 0:\n            n //= i\n            d[i] += 1else:i += 2\n    if n > 1:\n        d[n] += 1\n    r = [1]\n    for (k, v) in d.items():\n        for c in r[:]:\n            for i in range(1, v + 1):\n                r.append(c * (k ** i))\n    return sorted(r)\ndef main():\n    n = I()\n    a = LI()\n    s = set()\n    for i in range(n, 0, -1):\n        d = divisions(i)\n        ld = len(d)\n        for j in range(1, 2 ** ld):\n            c = []\n            ff = True\n            for k in range(ld):\n                if j & (1 << k):\n                    f = True\n                    for e in c:\n                        if d[k] % e == 0:\n                            f = False\n                            ff = False\n                            break\n                    if f:\n                        c.append(d[k])\n                if not ff:\n                    break\n            if ff:\n                s.add(tuple(c + [n + 1]))\n    b = sorted(list(s), reverse=True)\n    for c in b:\n        t = 0\n        for j in range(1, n + 1):\n            f = False\n            for e in c:\n                if j % e == 0:\n                    f = True\n                    break\n            if f:\n                t += a[j - 1]\n        if t < 0:\n            for j in range(1, n + 1):\n                f = False\n                for e in c:\n                    if j % e == 0:\n                        f = True\n                        break\n                if f:\n                    a[j - 1] = 0\n    return sum(a)\nprint(main())", "generated_code": "import math, string, itertools, fractions, heapq, collections, re, array, bisect, sys, random, time, copy, functools\nsys.setrecursionlimit(10 ** 7)\ninf = 10 ** 20\neps = 1.0 / (10 ** 15)\nmod = (10 ** 9) + 7\ndef LI():\n    return [int(x) for x in sys.stdin.readline().split()]\ndef LI_():\n    return [int(x) + 1 for x in sys.stdin.readline().split()]\ndef LF():\n    return [float(x) for x in sys.stdin.readline().split()]\ndef LS():\n    return sys.stdin.readline().split()\ndef I():\n    return int(sys.stdin.readline())\ndef F():\n    return float(sys.stdin.readline())\ndef S():\n    return input()\ndef pf(s):\n    return print(s, flush=True)\ndef divisions(n):\n    sq = int(math.sqrt(n) + 1)\n    d = collections.defaultdict(int)\n    while n % 2 == 0:\n        n //= 2\n        d[2] += 1\n    i = 3\n    while (n > 1 and sq >= i):\n        if n % i == 0:\n            n //= i\n            d[i] += 1else:i += 2\n    if n > 1:\n        d[n] += 1\n    r = [1]\n    for (k, v) in d.items():\n        for c in r[:]:\n            for i in range(1, v + 1):\n                r.append(c * (k ** i))\n    return sorted(r)\ndef main():\n    n = I()\n    a = LI()\n    s = set()\n    for i in range(n, 0, -1):\n        d = divisions(i)\n        ld = len(d)\n        for j in range(1, 2 ** ld):\n            c = []\n            ff = True\n            for k in range(ld):\n                if j & (1 << k):\n                    f = True\n                    for e in c:\n                        if d[k] % e == 0:\n                            f = False\n                            ff = False\n                            break\n                    if f:\n                        c.append(d[k])\n                if not ff:\n                    break\n            if ff:\n                s.add(tuple(c + [n + 1]))\n    b = sorted(list(s), reverse=True)\n    for c in b:\n        t = 0\n        for j in range(1, n + 1):\n            f = False\n            for e in c:\n                if j % e == 0:\n                    f = True\n                    break\n            if f:\n                t += a[j - 1]\n        if t < 0:\n            for j in range(1, n + 1):\n                f = False\n                for e in c:\n                    if j % e == 0:\n                        f = True\n                        break\n                if f:\n                    a[j - 1] = 0\n    return sum(a)\nprint(main())", "score": 0.0, "codebleu": 0.9962096427720554, "crystalbleu": 0.9961810745545907, "codebertscore": 1.0, "codescore": 0.9732672572135925, "surfaceSim": 0.49978466838931956, "abs_surfaceSim_minus_score": 0.49978466838931956}
{"golden_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "generated_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\npass\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "score": 0.0, "codebleu": 0.8103597296619469, "crystalbleu": 0.9609783379528823, "codebertscore": 0.98, "codescore": 0.9834862947463989, "surfaceSim": 0.9576931823924799, "abs_surfaceSim_minus_score": 0.9576931823924799}
{"golden_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "generated_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "score": 0.0, "codebleu": 0.9858502976595016, "crystalbleu": 0.9936960855615548, "codebertscore": 1.0, "codescore": 0.9823940992355347, "surfaceSim": 0.9984634296250768, "abs_surfaceSim_minus_score": 0.9984634296250768}
{"golden_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "generated_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\npass", "score": 0.0, "codebleu": 0.9959359756750711, "crystalbleu": 0.9913778096467993, "codebertscore": 1.0, "codescore": 0.9823901653289795, "surfaceSim": 0.9872833173295599, "abs_surfaceSim_minus_score": 0.9872833173295599}
{"golden_code": "import queue\nINF = 123456789\ndef main():\n    (n, m) = list(map(int, input().split()))\n    G = [[] for _ in range(n)]\n    for _ in range(m):\n        (a, b, c) = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        G[a].append((b, c))\n        G[b].append((a, c))\n    used = set()\n    for i in range(n):\n        d = [INF for _ in range(n)]\n        par = [-1 for _ in range(n)]\n        que = queue.PriorityQueue()\n        d[i] = 0\n        que.put((0, i))\n        while not (que.empty()):\n            p = que.get()\n            v = p[1]\n            if d[v] < p[0]:\n                continue\n            for (to, cost) in G[v]:\n                if d[to] > d[v] + cost:\n                    d[to] = d[v] + cost\n                    par[to] = v\n                    que.put((d[to], to))\n        for j in range(n):\n            if i != j:\n                (a, b) = (j, par[j])\n                if a > b:\n                    (a, b) = (b, a)\n                used.add((a, b))\n    print(m - len(used))", "generated_code": "import queue\nINF = 123456789\ndef main():\n    (n, m) = list(map(int, input().split()))\n    G = [[] for _ in range(n)]\n    for _ in range(m):\n        (a, b, c) = list(map(int, input().split()))\n        a += 1\n        b -= 1\n        G[a].append((b, c))\n        G[b].append((a, c))\n    used = set()\n    for i in range(n):\n        d = [INF for _ in range(n)]\n        par = [-1 for _ in range(n)]\n        que = queue.PriorityQueue()\n        d[i] = 0\n        que.put((0, i))\n        while not (que.empty()):\n            p = que.get()\n            v = p[1]\n            if d[v] < p[0]:\n                continue\n            for (to, cost) in G[v]:\n                if d[to] > d[v] + cost:\n                    d[to] = d[v] + cost\n                    par[to] = v\n                    que.put((d[to], to))\n        for j in range(n):\n            if i != j:\n                (a, b) = (j, par[j])\n                if a > b:\n                    (a, b) = (b, a)\n                used.add((a, b))\n    print(m - len(used))", "score": 0.0, "codebleu": 0.9904103276685203, "crystalbleu": 0.9879581348354282, "codebertscore": 1.0, "codescore": 0.9937823414802551, "surfaceSim": 0.9994979919678715, "abs_surfaceSim_minus_score": 0.9994979919678715}
{"golden_code": "def cmb(n, r):\n    import math\n    if n < r:\n        return 0\n    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\ndef solve(S):\n    mod = (10 ** 9) + 7\n    ans = 0\n    for i in range(1, (S // 3) + 1):\n        tama = i + (S - (i * 3))\n        tama -= 2\n        bo = i - 1\n        ans += cmb(tama + 1, bo)\n        ans %= mod\n    print(ans)", "generated_code": "def cmb(n, r):\n    import math\n    if n < r:\n        return 0\n    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\ndef solve(S):\n    mod = (10 ** 9) + 7\n    ans = 0\n    for i in range(1, (S / 3) + 1):\n        tama = i + (S - (i * 3))\n        tama -= 2\n        bo = i - 1\n        ans += cmb(tama + 1, bo)\n        ans %= mod\n    print(ans)", "score": 0.0, "codebleu": 0.980976656443197, "crystalbleu": 0.9848626345039097, "codebertscore": 1.0, "codescore": 0.993720531463623, "surfaceSim": 0.9807578155916106, "abs_surfaceSim_minus_score": 0.9807578155916106}
{"golden_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "generated_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        pass\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "score": 0.0, "codebleu": 0.9836611123487224, "crystalbleu": 0.9882005395026185, "codebertscore": 0.99, "codescore": 0.9935052394866943, "surfaceSim": 0.9832999801050919, "abs_surfaceSim_minus_score": 0.9832999801050919}
