{"golden_code": "import sys\n\nread = sys.stdin.readline\n\n\n\n\n\ndef read_ints():\n\n    return list(map(int, read().split()))\n\n\n\n\n\ndef read_a_int():\n\n    return int(read())\n\n\n\n\n\ndef read_matrix(H):\n\n    '''\n\n    H is number of rows\n\n    '''\n\n    return [list(map(int, read().split())) for _ in range(H)]\n\n\n\n\n\ndef read_map(H):\n\n    '''\n\n    H is number of rows\n\n    文字列で与えられた盤面を読み取る用\n\n    '''\n\n    return [read()[:-1] for _ in range(H)]\n\n\n\n\n\ndef read_tuple(H):\n\n    '''\n\n    H is number of rows\n\n    '''\n\n    ret = []\n\n    for _ in range(H):\n\n        ret.append(tuple(map(int, read().split())))\n\n    return ret\n\n\n\n\n\ndef read_col(H, n_cols):\n\n    '''\n\n    H is number of rows\n\n    n_cols is number of cols\n\n\n\n    A列、B列が与えられるようなとき\n\n    '''\n\n    ret = [[] for _ in range(n_cols)]\n\n    for _ in range(H):\n\n        tmp = list(map(int, read().split()))\n\n        for col in range(n_cols):\n\n            ret[col].append(tmp[col])\n\n\n\n    return ret\n\n\n\n\n\nN, K = read_ints()\n\nP = read_ints()\n\n\n\n\n\ndef ret_mean(X):\n\n    return (X + 1) / 2\n\n\n\n\n\n\n\n\n\nimport numpy as np\n\nP_mean = np.array([ret_mean(p) for p in P])\n\nP_accum = np.zeros(N+1)\n\nP_accum[1:] = P_mean.cumsum()\n\n\n\nans = 0\n\n# print(P_accum)\n\nfor i in range(N - K + 1):\n\n    j = i + K\n\n    ans = max(ans, P_accum[j] - P_accum[i])\n\nprint(ans)\n", "generated_code": "import sys\n\nread = sys.stdin.readline\n\n\n\n\n\ndef read_ints():\n\n    return list(map(int, read().split()))\n\n\n\n\n\ndef read_a_int():\n\n    return int(read())\n\n\n\n\n\ndef read_matrix(H):\n\n    '''\n\n    H is number of rows\n\n    '''\n\n    return [list(map(int, read().split())) for _ in range(H)]\n\n\n\n\n\ndef read_map(H):\n\n    '''\n\n    H is number of rows\n\n    文字列で与えられた盤面を読み取る用\n\n    '''\n\n    return [read()[:-1] for _ in range(H)]\n\n\n\n\n\ndef read_tuple(H):\n\n    '''\n\n    H is number of rows\n\n    '''\n\n    ret = []\n\n    for _ in range(H):\n\n        ret.append(tuple(map(int, read().split())))\n\n    return ret\n\n\n\n\n\ndef read_col(H, n_cols):\n\n    '''\n\n    H is number of rows\n\n    n_cols is number of cols\n\n\n\n    A列、B列が与えられるようなとき\n\n    '''\n\n    ret = [[] for _ in range(n_cols)]\n\n    for _ in range(H):\n\n        tmp = list(map(int, read().split()))\n\n        for col in range(n_cols):\n\n            ret[col].append(tmp[col])\n\n\n\n    return ret\n\n\n\n\n\nN, K = read_ints()\n\nP = read_ints()\n\n\n\n\n\ndef ret_mean(X):\n\n    return (X + 1) / 2\n\n\n\n\n\n\n\nclass cumsum1d:\n\n    def __init__(self, ls: list):\n\n        '''\n\n        1次元リストを受け取る\n\n        '''\n\n        from itertools import accumulate\n\n        self.ls_accum = [0] + list(accumulate(ls))\n\n\n\n    def total(self, i, j):\n\n        # もとの配列lsにおける[i,j)の中合計\n\n        return self.ls_accum[j] - self.ls_accum[i]\n\n      \n\nP_mean = [ret_mean(p) for p in P]\n\nP_accum = cumsum1d(P_mean)\n\n\n\nans = 0\n\n# print(P_accum)\n\nfor i in range(N - K + 1):\n\n    j = i + K\n\n    ans = max(ans, P_accum.total(i,j))\n\nprint(ans)\n", "score": 1.0, "codebleu": 0.8474133660024165, "crystalbleu": 0.7401668573263896, "codebertscore": 0.94, "codescore": 0.9924657344818115, "surfaceSim": 0.8972121341593676, "abs_surfaceSim_minus_score": 0.10278786584063238}
{"golden_code": "s = eval(input())\n\n\n\nstart = -1\n\nend = 0\n\nfor i in range(len(s)):\n\n    if s[i] == 'A' and start < 0:\n\n        start = i\n\n    elif s[i] == 'Z':\n\n        end = i\n\nprint((end - start + 1))\n", "generated_code": "s = eval(input())\n\n\n\nstart = 0\n\nfor i in range(len(s)):\n\n    if s[i] == 'A':\n\n        start = i\n\n        break\n\n\n\nend = 0\n\nfor i in reversed(list(range(len(s)))):\n\n    if s[i] == 'Z':\n\n        end = i\n\n        break\n\nprint((end - start + 1))\n", "score": 1.0, "codebleu": 0.6117105849764274, "crystalbleu": 0.6050930169057582, "codebertscore": 0.93, "codescore": 0.20197734236717224, "surfaceSim": 0.739399928135106, "abs_surfaceSim_minus_score": 0.260600071864894}
{"golden_code": "#!/usr/bin/env pypy3\n\n\n\nimport math\n\nprint((math.factorial(int(eval(input()))) % 1000000007))", "generated_code": "n = int(eval(input()))\n\nfor i in range(n - 1, 1, -1):\n\n\tn *= i\n\n\tn %= 10**9 + 7\n\nprint(n)", "score": 1.0, "codebleu": 0.21323529411764708, "crystalbleu": 0.0, "codebertscore": 0.7, "codescore": 0.08943955600261688, "surfaceSim": 0.36789554531490015, "abs_surfaceSim_minus_score": 0.6321044546850998}
{"golden_code": "n, m = list(map(int, input().split()))\n\nans = 0\n\nfor i in range(n, m+1):\n\n    if str(i)[0]+str(i)[1] == str(i)[-1]+str(i)[-2]: ans += 1\n\nprint(ans)", "generated_code": "a, b = list(map(int, input().split()))\n\nans = 0\n\nfor n in range(a, b+1):\n\n    if str(n) == str(n)[::-1]: ans += 1\n\nprint(ans)", "score": 1.0, "codebleu": 0.601258954032463, "crystalbleu": 0.0, "codebertscore": 0.93, "codescore": 0.8830499649047852, "surfaceSim": 0.8457019171304885, "abs_surfaceSim_minus_score": 0.15429808286951152}
{"golden_code": "k, n = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\n\n\ndiff = []\n\n\n\nfor i in range(n - 1):\n\n    diff.append(a[i + 1] - a[i])\n\ndiff.append(k - a[-1] + a[0])\n\n\n\nprint((k - max(diff)))\n", "generated_code": "k, n = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\n\n\na.append(k + a[0])\n\ndiff = [a1 - a0 for a0, a1 in zip(a, a[1:])]\n\n\n\nprint((k - max(diff)))\n", "score": 1.0, "codebleu": 0.5084277869685716, "crystalbleu": 0.45600467305519793, "codebertscore": 0.91, "codescore": 0.09820450097322464, "surfaceSim": 0.6952780229479258, "abs_surfaceSim_minus_score": 0.30472197705207416}
{"golden_code": "#E\n\nfrom itertools import accumulate\n\nfrom bisect import bisect_left\n\ndef main():\n\n    n,m=list(map(int,input().split()))\n\n    A=list(map(int,input().split()))\n\n    A.sort()\n\n    \n\n    def count(k):\n\n        cnt=0\n\n        for a in A:\n\n            cnt+=bisect_left(A,k-a)\n\n        return cnt\n\n    \n\n    ok=0\n\n    ng=10**10+1\n\n    while ng-ok>1:\n\n        mid=(ok+ng)//2\n\n        if count(mid)<n**2-m:\n\n            ok=mid\n\n        else:\n\n            ng=mid\n\n    border=ok\n\n    \n\n    k=n**2-count(border)\n\n    Acc=[0]+list(accumulate(A))\n\n    s=Acc[-1]\n\n    ans=0\n\n    for a in A:\n\n        idx=bisect_left(A,border-a)\n\n        ans+=a*(n-idx)+(s-Acc[idx])\n\n    ans-=border*(k-m)\n\n    print(ans)\n\n    \n\nif __name__=='__main__':\n\n    main()", "generated_code": "from itertools import accumulate\n\nfrom bisect import bisect_left\n\ndef main():\n\n    n,m=list(map(int,input().split()))\n\n    A=list(map(int,input().split()))\n\n    A.sort()\n\n    \n\n    def count(k):\n\n        cnt=0\n\n        for a in A:\n\n            cnt+=bisect_left(A,k-a)\n\n        return cnt\n\n    \n\n    ok=0\n\n    ng=2*10**5+1\n\n    while ng-ok>1:\n\n        mid=(ok+ng)//2\n\n        if count(mid)<n**2-m:\n\n            ok=mid\n\n        else:\n\n            ng=mid\n\n    border=ok\n\n    \n\n    k=n**2-count(border)\n\n    Acc=[0]+list(accumulate(A))\n\n    s=Acc[-1]\n\n    ans=0\n\n    for a in A:\n\n        idx=bisect_left(A,border-a)\n\n        ans+=a*(n-idx)+(s-Acc[idx])\n\n    ans-=border*(k-m)\n\n    print(ans)\n\n    \n\nif __name__=='__main__':\n\n    main()", "score": 1.0, "codebleu": 0.9039643902680069, "crystalbleu": 0.9631758660180704, "codebertscore": 0.99, "codescore": 0.9938191771507263, "surfaceSim": 0.9972752043596731, "abs_surfaceSim_minus_score": 0.0027247956403269047}
{"golden_code": "# -*- coding: utf-8 -*-\n\nx, y, z, k = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\nb = list(map(int, input().split()))\n\nc = list(map(int, input().split()))\n\n\n\na.sort(reverse=True)\n\nb.sort(reverse=True)\n\nc.sort(reverse=True)\n\n\n\nabc = []\n\n\n\nfor i, _a in enumerate(a):\n\n    for j, _b in enumerate(b):\n\n        if (i+1) * (j+1) > k:\n\n            break\n\n        for l, _c in enumerate(c):\n\n            if (i+1) * (j+1) * (l+1) > k:\n\n                break\n\n            abc.append(_a + _b + _c)\n\n\n\nabc.sort(reverse=True)\n\nfor x in abc[:k]:\n\n    print(x)\n", "generated_code": "# -*- coding: utf-8 -*-\n\nimport heapq\n\n\n\nx, y, z, k = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\nb = list(map(int, input().split()))\n\nc = list(map(int, input().split()))\n\n\n\nla, lb, lc = len(a), len(b), len(c)\n\n\n\na.sort(reverse=True)\n\nb.sort(reverse=True)\n\nc.sort(reverse=True)\n\n\n\nfix = set()\n\n\n\nq = [(-(a[0]+b[0]+c[0]), 0, 0, 0)]\n\n\n\nfor _ in range(k):\n\n    abc, i, j, l = heapq.heappop(q)\n\n    print((-abc))\n\n\n\n    if i+1 < la and (i+1, j, l) not in fix:\n\n        heapq.heappush(q, (-(a[i+1]+b[j]+c[l]), i+1, j, l))\n\n        fix.add((i+1, j, l))\n\n\n\n    if j+1 < lb and (i, j+1, l) not in fix:\n\n        heapq.heappush(q, (-(a[i]+b[j+1]+c[l]), i, j+1, l))\n\n        fix.add((i, j+1, l))\n\n\n\n    if l+1 < lc and (i, j, l+1) not in fix:\n\n        heapq.heappush(q, (-(a[i]+b[j]+c[l+1]), i, j, l+1))\n\n        fix.add((i, j, l+1))\n", "score": 1.0, "codebleu": 0.45639122124696185, "crystalbleu": 0.2301056352778679, "codebertscore": 0.85, "codescore": 0.21019503474235535, "surfaceSim": 0.5830198715756678, "abs_surfaceSim_minus_score": 0.4169801284243322}
{"golden_code": "n, l = list(map(int, input().split()))\n\nS = [eval(input()) for i in range(n)]\n\nS.sort()\n\nprint((\"\".join(S)))", "generated_code": "n, l = list(map(int, input().split()))\n\nA = [eval(input()) for _ in range(n)]\n\nA.sort()\n\nprint((\"\".join(A)))\n", "score": 1.0, "codebleu": 0.6987423786227978, "crystalbleu": 0.0, "codebertscore": 0.97, "codescore": 0.8824740648269653, "surfaceSim": 0.981651376146789, "abs_surfaceSim_minus_score": 0.01834862385321101}
{"golden_code": "n,t=int(input()),list(map(int,input().split()));T=sum(t)\n\nprint(*[T-t[i-1]+j for i,j in [list(map(int,input().split())) for _ in range(int(input()))]],sep='\\n')\n", "generated_code": "input();t=list(map(int,input().split()));T=sum(t)\n\nprint(*[T-t[i-1]+j for i,j in [list(map(int,input().split())) for _ in range(int(input()))]],sep='\\n')\n", "score": 1.0, "codebleu": 0.7952267100596858, "crystalbleu": 0.8631532256580251, "codebertscore": 0.97, "codescore": 0.9937478303909302, "surfaceSim": 0.9658385093167702, "abs_surfaceSim_minus_score": 0.03416149068322982}
{"golden_code": "import math\n\nN = int(eval(input()))\n\nprint((math.factorial(N)%(10**9+7)))", "generated_code": "import math\n\nN = int(eval(input()))\n\na = 1\n\nfor n in range(2,N+1):\n\n    a = a*n % (10**9+7)\n\nprint(a)", "score": 1.0, "codebleu": 0.5101463671792871, "crystalbleu": 0.0, "codebertscore": 0.87, "codescore": 0.9002766013145447, "surfaceSim": 0.7434478741991846, "abs_surfaceSim_minus_score": 0.25655212580081543}
{"golden_code": "import numpy as np\n\n\n\nn = int(eval(input()))\n\na_list = list(map(int, input().split()))\n\n\n\nalice_point = 0\n\nbob_point = 0\n\nfor i in range(n):\n\n    argmax_a = np.argmax(a_list)\n\n    max_a = np.max(a_list)\n\n    if i % 2 == 0: # If Alice takes a card\n\n        alice_point += max_a\n\n    else: # If Bob takes a card\n\n        bob_point += max_a\n\n    del a_list[argmax_a] # No confidence -> Review how to delete list element!\n\n\n\nprint((alice_point - bob_point))", "generated_code": "n = int(eval(input()))\n\na_list = list(map(int, input().split()))\n\na_list = sorted(a_list, reverse=True)\n\n\n\nalice_point = 0\n\nbob_point = 0\n\nfor i in range(n):\n\n    if i % 2 == 0:\n\n        alice_point += a_list[i]\n\n    else:\n\n        bob_point += a_list[i]\n\n\n\nprint((alice_point - bob_point))", "score": 1.0, "codebleu": 0.38257761150963643, "crystalbleu": 0.48360038823132057, "codebertscore": 0.88, "codescore": 0.2056482583284378, "surfaceSim": 0.7741721854304636, "abs_surfaceSim_minus_score": 0.22582781456953638}
{"golden_code": "#!/usr/bin/env python3\n\n\n\nn = int(eval(input()))\n\ns = [eval(input()) for _ in range(n)]\n\n\n\nc = [0 for _ in range(5)]\n\nt = 'MARCH'\n\n\n\nfor i in range(n):\n\n    for j in range(5):\n\n        if s[i][0] == t[j]:\n\n            c[j] += 1\n\nans = 0 \n\nfor i in range(5):\n\n    for j in range(i+1, 5): \n\n        for k in range(j+1, 5): \n\n            ans += c[i]*c[k]*c[j]\n\nprint(ans)\n", "generated_code": "#!/usr/bin/env python3\n\n\n\nn = int(eval(input()))\n\ns = [eval(input()) for _ in range(n)]\n\nd = {}\n\n\n\nfor c in s:\n\n    if c[0] not in d:\n\n        d[c[0]] = 1 \n\n    else:\n\n        d[c[0]] += 1\n\n\n\ntmp = d.copy()\n\nt = ['M', 'A', 'R', 'C', 'H']\n\nfor c in tmp:\n\n    if c not in t:\n\n        d.pop(c)\n\n\n\nans = 0 \n\ndlist = list(d.items())\n\nfor i in range(len(dlist)):\n\n    for j in range(i+1, len(dlist)):\n\n        for k in range(j+1, len(dlist)):\n\n            ans += dlist[i][1]*dlist[j][1]*dlist[k][1]\n\nprint(ans)\n", "score": 1.0, "codebleu": 0.3760107470229889, "crystalbleu": 0.23570064443031385, "codebertscore": 0.86, "codescore": 0.985281765460968, "surfaceSim": 0.7176155115511551, "abs_surfaceSim_minus_score": 0.2823844884488449}
{"golden_code": "import sys\n\nimport numpy as np\n\nn,m = [int(x) for x in sys.stdin.readline().split()]\n\nr = np.zeros(n)\n\nfor i in range(m):\n\n\ta, b = [int(x) for x in sys.stdin.readline().split()]\n\n\tr[a-1] += 1\n\n\tr[b-1] += 1\n\nfor i in range(n):\n\n\tprint((int(r[i])))", "generated_code": "import sys\n\nn,m = [int(x) for x in sys.stdin.readline().split()]\n\nr = [0]*n\n\nfor _ in range(m):\n\n\ta, b = [int(x) for x in sys.stdin.readline().split()]\n\n\tr[a-1] += 1\n\n\tr[b-1] += 1\n\nfor i in r:\n\n\tprint(i)", "score": 1.0, "codebleu": 0.6350656929620216, "crystalbleu": 0.5783954287139919, "codebertscore": 0.95, "codescore": 0.24033905565738678, "surfaceSim": 0.8670908448214917, "abs_surfaceSim_minus_score": 0.13290915517850832}
{"golden_code": "a,b,c,x,y=list(map(int,input().split()))\n\nans=a*x+b*y\n\nn=max(x,y)\n\nfor i in range(1,n+1):\n\n  ans=min(ans,2*i*c+a*max(0,x-i)+b*max(0,y-i))\n\nprint(ans)\n\n\n\n\n", "generated_code": "a,b,c,x,y=list(map(int,input().split()))\n\nans1=a*x+b*y\n\nans2=2*c*max(x,y)\n\nans3=2*c*min(x,y)+a*(x-min(x,y))+b*(y-min(x,y))\n\nprint((min(ans1,ans2,ans3)))", "score": 1.0, "codebleu": 0.2953485969793404, "crystalbleu": 0.3256638929033775, "codebertscore": 0.89, "codescore": 0.0947527214884758, "surfaceSim": 0.7393939393939394, "abs_surfaceSim_minus_score": 0.2606060606060606}
{"golden_code": "import numpy as np\n\n\n\nN=int(eval(input()))\n\nA=list(map(int, input().split()))\n\n\n\nAA=[]\n\nfor i,a in enumerate(A):\n\n    AA.append(a-i+1)\n\n\n\nb=np.median(AA)\n\nans=0\n\n\n\nfor a in AA:\n\n    ans+=abs(a-b)\n\nprint((int(ans)))", "generated_code": "N=int(eval(input()))\n\nA=list(map(int,input().split()))\n\nB=[]\n\nfor i in range(N):\n\n    B.append(A[i]-i-1)\n\nB.sort()\n\nif N%2:\n\n    b=B[N//2]\n\nelse:\n\n    b=(B[N//2]+B[N//2-1])//2\n\nans=0\n\nfor k in B:\n\n    ans+=abs(k-b)\n\nprint(ans)", "score": 1.0, "codebleu": 0.29497144912198503, "crystalbleu": 0.3839666177464585, "codebertscore": 0.86, "codescore": 0.8075541853904724, "surfaceSim": 0.6114851866102347, "abs_surfaceSim_minus_score": 0.38851481338976535}
{"golden_code": "from collections import Counter\n\n\n\nimport numpy as np\n\n\n\n\n\ndef part(pts, a, ans):\n\n    b = np.dot(pts, [np.sin(a), np.cos(a)])\n\n    c = np.argmax(b, axis=0)\n\n    for i, v in list(Counter(c).items()):\n\n        ans[i] += v\n\n\n\n\n\ndef solve(n, pts):\n\n    ans = [0] * n\n\n    part(pts, np.linspace(0, np.pi, 100000, endpoint=False), ans)\n\n    part(pts, np.linspace(np.pi, 2 * np.pi, 100000, endpoint=False), ans)\n\n    return [v / 200000 for v in ans]\n\n\n\n\n\nn = int(eval(input()))\n\npts = np.array([list(map(int, input().split())) for _ in range(n)])\n\nprint(('\\n'.join(map(str, solve(n, pts)))))\n", "generated_code": "from collections import Counter\n\nimport numpy as np\n\n\n\n\n\ndef part(pts, s, t, num, ans):\n\n    a = np.linspace(s, t, num, endpoint=False)\n\n    for i, v in list(Counter(np.argmax(np.dot(pts, [np.sin(a), np.cos(a)]), axis=0)).items()):\n\n        ans[i] += v\n\n\n\n\n\ndef solve(n, pts):\n\n    ans = np.zeros(n)\n\n    part(pts, 0, np.pi, 1e5, ans)\n\n    part(pts, np.pi, 2 * np.pi, 1e5, ans)\n\n    return ans / 2e5\n\n\n\n\n\nn = int(eval(input()))\n\nprint(('\\n'.join(map(str, solve(n, [list(map(int, input().split())) for _ in range(n)])))))\n", "score": 1.0, "codebleu": 0.4627881224289302, "crystalbleu": 0.6701756000648613, "codebertscore": 0.93, "codescore": 0.31941133737564087, "surfaceSim": 0.7909556313993173, "abs_surfaceSim_minus_score": 0.20904436860068265}
{"golden_code": "def main():\n\n    n = int(eval(input()))\n\n    import numpy as np\n\n    ans = np.zeros((10,10))\n\n    for i in range(1,n+1):\n\n        h,t = str(i)[0],str(i)[-1]\n\n        ans[int(h)-1][int(t)-1]+=1\n\n    s = 0\n\n    for i in range(10):\n\n        for j in range(10):\n\n            s += ans[i][j]*ans[j][i]\n\n\n\n    print((int(s)))\n\nif __name__ == \"__main__\":\n\n    main()", "generated_code": "def main():\n\n    n = int(eval(input()))\n\n    dp = [[0 for i in range(10)] for i in range(10)]\n\n    for i in range(1,n+1):\n\n        h,t = int(str(i)[0]), int(str(i)[-1])\n\n        dp[h][t] += 1\n\n    ans = 0\n\n    for i in range(10):\n\n        for j in range(10):\n\n            ans += dp[i][j] * dp[j][i]\n\n    print(ans)\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "score": 1.0, "codebleu": 0.47214019955543324, "crystalbleu": 0.6394523388944687, "codebertscore": 0.92, "codescore": 0.018537500873208046, "surfaceSim": 0.790406472741283, "abs_surfaceSim_minus_score": 0.20959352725871705}
{"golden_code": "import sys\n\ninput = sys.stdin.readline\n\n\n\nn,k = list(map(int, input().split()))\n\nAs = [int(eval(input())) for i in range(n)]\n\n\n\n# N: 処理する区間の長さ\n\n\n\nINF = 0\n\n\n\nmx = 300001\n\nLV = (mx-1).bit_length()\n\nN0 = 2**LV\n\ndata = [INF]*(2*N0)\n\nlazy = [None]*(2*N0)\n\n\n\n# 伝搬対象の区間を求める\n\ndef gindex(l, r):\n\n    L = (l + N0) >> 1; R = (r + N0) >> 1\n\n    lc = 0 if l & 1 else (L & -L).bit_length()\n\n    rc = 0 if r & 1 else (R & -R).bit_length()\n\n    for i in range(LV):\n\n        if rc <= i:\n\n            yield R\n\n        if L < R and lc <= i:\n\n            yield L\n\n        L >>= 1; R >>= 1\n\n\n\n# 遅延伝搬処理\n\ndef propagates(*ids):\n\n    for i in reversed(ids):\n\n        v = lazy[i-1]\n\n        if v is None:\n\n            continue\n\n        lazy[2*i-1] = data[2*i-1] = lazy[2*i] = data[2*i] = v\n\n        lazy[i-1] = None\n\n\n\n# 区間[l, r)をxで更新\n\ndef update(l, r, x):\n\n    *ids, = gindex(l, r)\n\n    propagates(*ids)\n\n\n\n    L = N0 + l; R = N0 + r\n\n    while L < R:\n\n        if R & 1:\n\n            R -= 1\n\n            lazy[R-1] = data[R-1] = x\n\n        if L & 1:\n\n            lazy[L-1] = data[L-1] = x\n\n            L += 1\n\n        L >>= 1; R >>= 1\n\n    for i in ids:\n\n        data[i-1] = max(data[2*i-1], data[2*i])\n\n\n\n# 区間[l, r)内の最小値を求める\n\ndef query(l, r):\n\n    propagates(*gindex(l, r))\n\n    L = N0 + l; R = N0 + r\n\n\n\n    s = INF\n\n    while L < R:\n\n        if R & 1:\n\n            R -= 1\n\n            s = max(s, data[R-1])\n\n        if L & 1:\n\n            s = max(s, data[L-1])\n\n            L += 1\n\n        L >>= 1; R >>= 1\n\n    return s\n\n\n\nupdate(As[0],As[0]+1,1)\n\nfor i, a in enumerate(As[1:]):\n\n    l = max(0,a-k)\n\n    r = min(mx,a+k)\n\n    upd = query(l,r+1)\n\n    if upd == -1:continue\n\n    # print(\"i\",i,\"a\",a,\"upd\",upd,\"l\",l,\"r\",r)\n\n    update(a, a+1, upd+1)\n\n\n\nans = 0\n\nfor a in set(As):\n\n    ans = max(ans,query(a,a+1))\n\nprint(ans)", "generated_code": "import sys\n\ninput = sys.stdin.readline\n\n\n\nn,k = list(map(int, input().split()))\n\nAs = [int(eval(input())) for i in range(n)]\n\n\n\n# N: 処理する区間の長さ\n\n\n\nINF = 0\n\n\n\nmx = 300001\n\nLV = (mx-1).bit_length()\n\nN0 = 2**LV\n\ndata = [INF]*(2*N0)\n\nlazy = [None]*(2*N0)\n\n\n\n# 伝搬対象の区間を求める\n\ndef gindex(l, r):\n\n    L = (l + N0) >> 1; R = (r + N0) >> 1\n\n    lc = 0 if l & 1 else (L & -L).bit_length()\n\n    rc = 0 if r & 1 else (R & -R).bit_length()\n\n    for i in range(LV):\n\n        if rc <= i:\n\n            yield R\n\n        if L < R and lc <= i:\n\n            yield L\n\n        L >>= 1; R >>= 1\n\n\n\n# 遅延伝搬処理\n\ndef propagates(*ids):\n\n    for i in reversed(ids):\n\n        v = lazy[i-1]\n\n        if v is None:\n\n            continue\n\n        lazy[2*i-1] = data[2*i-1] = lazy[2*i] = data[2*i] = v\n\n        lazy[i-1] = None\n\n\n\n# 区間[l, r)をxで更新\n\ndef update(l, r, x):\n\n    *ids, = gindex(l, r)\n\n    propagates(*ids)\n\n\n\n    L = N0 + l; R = N0 + r\n\n    while L < R:\n\n        if R & 1:\n\n            R -= 1\n\n            lazy[R-1] = data[R-1] = x\n\n        if L & 1:\n\n            lazy[L-1] = data[L-1] = x\n\n            L += 1\n\n        L >>= 1; R >>= 1\n\n    for i in ids:\n\n        data[i-1] = max(data[2*i-1], data[2*i])\n\n\n\n# 区間[l, r)内の最小値を求める\n\ndef query(l, r):\n\n    propagates(*gindex(l, r))\n\n    L = N0 + l; R = N0 + r\n\n\n\n    s = INF\n\n    while L < R:\n\n        if R & 1:\n\n            R -= 1\n\n            s = max(s, data[R-1])\n\n        if L & 1:\n\n            s = max(s, data[L-1])\n\n            L += 1\n\n        L >>= 1; R >>= 1\n\n    return s\n\n\n\nans = 0\n\nupdate(As[0],As[0]+1,1)\n\nfor i, a in enumerate(As[1:]):\n\n    l = max(0,a-k)\n\n    r = min(mx,a+k)\n\n    upd = query(l,r+1)\n\n    if upd == -1:continue\n\n    # print(\"i\",i,\"a\",a,\"upd\",upd,\"l\",l,\"r\",r)\n\n    update(a, a+1, upd+1)\n\n    ans = max(ans, upd+1)\n\nprint(ans)\n\n\n", "score": 1.0, "codebleu": 0.9596802290704811, "crystalbleu": 0.9642971533467297, "codebertscore": 1.0, "codescore": 0.9937041401863098, "surfaceSim": 0.9899888765294772, "abs_surfaceSim_minus_score": 0.010011123470522798}
{"golden_code": "N = int(eval(input()))\n\nl = [list(map(int, input().split())) for _ in range(N)]\n\n\n\ndp = [[0 for i in range(3)] for j in range(N+1)]\n\n\n\n\n\nfor i in range(1, N+1):\n\n    for j in range(3):\n\n        for k in range(3):\n\n            if j != k:\n\n                dp[i][j] = max(dp[i][j], dp[i-1][k]+l[i-1][k])\n\n\n\nprint((max(dp[N][0], dp[N][1], dp[N][2])))\n\n\n", "generated_code": "N = int(eval(input()))\n\ndp = [[0 for i in range(3)] for j in range(N+1)]\n\n\n\nfor i in range(1, N+1):\n\n    hapiness = list(map(int, input().split()))\n\n    for j in range(3):\n\n        for k in range(3):\n\n            if j != k:\n\n                dp[i][j] = max(dp[i][j], dp[i-1][k] + hapiness[k])\n\n\n\nprint((max(dp[N][0], dp[N][1], dp[N][2])))", "score": 1.0, "codebleu": 0.6343804509339057, "crystalbleu": 0.8243725747317179, "codebertscore": 0.95, "codescore": 0.7191630601882935, "surfaceSim": 0.8796561604584527, "abs_surfaceSim_minus_score": 0.12034383954154726}
{"golden_code": "from collections import defaultdict\n\nfrom bisect import bisect_left\n\n\n\ns = eval(input())\n\nn = len(s)\n\ns = s + s\n\nt = eval(input())\n\nif set(t) - set(s):\n\n\tprint((-1))\n\n\texit()\n\nd = defaultdict(list)\n\nfor i in range(2 * n):\n\n\td[s[i]] += [i]\n\ncur = tot = 0\n\nfor c in t:\n\n\tx = d[c][bisect_left(d[c], cur)]\n\n\tif x < n:\n\n\t\tcur = x + 1\n\n\telse:\n\n\t\tcur = x - n + 1\n\n\t\ttot += n\n\ntot += cur\n\nprint(tot)\n", "generated_code": "from collections import defaultdict\n\nfrom bisect import bisect_left\n\n\n\n\n\ndef main():\n\n\ts = eval(input())\n\n\tn = len(s)\n\n\ts = s + s\n\n\tt = eval(input())\n\n\tif set(t) - set(s):\n\n\t\tprint((-1))\n\n\t\texit()\n\n\td = defaultdict(list)\n\n\tfor i in range(2 * n):\n\n\t\td[s[i]] += [i]\n\n\tcur = ncnt = 0\n\n\n\n\tfor c in t:\n\n\t\tx = d[c][bisect_left(d[c], cur)]\n\n\t\tif x < n:\n\n\t\t\tcur = x + 1\n\n\t\telse:\n\n\t\t\tcur = x - n + 1\n\n\t\t\tncnt += 1\n\n\tprint((ncnt*n + cur))\n\n\n\n\n\nif __name__ == \"__main__\":\n\n\tmain()", "score": 1.0, "codebleu": 0.7388646918959951, "crystalbleu": 0.6916009035463747, "codebertscore": 0.95, "codescore": 0.01829112321138382, "surfaceSim": 0.8815446576640606, "abs_surfaceSim_minus_score": 0.11845534233593935}
{"golden_code": "a,b = list(map(int, input().split()))\n\ncount = 0\n\nfor i in range(a,b+1):\n\n    j = str(i)\n\n    if j==''.join(reversed(j)):\n\n        count += 1\n\nprint(count)", "generated_code": "a,b = list(map(int, input().split()))\n\nn = [i for i in map(str, list(range(a,b+1))) if i==i[::-1]]\n\nprint((len(n)))", "score": 1.0, "codebleu": 0.3592560489272494, "crystalbleu": 0.0, "codebertscore": 0.87, "codescore": 0.38485851883888245, "surfaceSim": 0.6011220196353436, "abs_surfaceSim_minus_score": 0.3988779803646564}
{"golden_code": "mod = int(1e9+7)\n\nn = int(eval(input()))\n\n\n\npower = 1\n\nfor i in range(1, n+1):\n\n    power = power * i % mod\n\nprint(power)", "generated_code": "import sys\n\n\n\nMOD = 10 ** 9 + 7\n\nn = int(sys.stdin.readline().rstrip())\n\n\n\ndef main():\n\n    res = 1\n\n    for i in range(1, n+1):\n\n        res *= i\n\n        res %= MOD\n\n\n\n    return res\n\n\n\nif __name__ == '__main__':\n\n    ans = main()\n\n    print(ans)", "score": 1.0, "codebleu": 0.3153713093806382, "crystalbleu": 0.0, "codebertscore": 0.83, "codescore": 0.018256841227412224, "surfaceSim": 0.54502688172043, "abs_surfaceSim_minus_score": 0.45497311827957}
{"golden_code": "import numpy as np\n\nN,x = list(map(int,input().split()))\n\nA = np.array(input().split(), dtype = np.int64)\n\nA.sort()\n\nnp.cumsum(A, out = A)\n\nanswer = (A <= x).sum()\n\n\n\nif answer == N and A[-1] != x:\n\n  answer -= 1\n\nprint(answer)\n", "generated_code": "import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\nfrom bisect import bisect_right\n\nimport itertools\n\n\n\nN,X,*A = list(map(int,read().split()))\n\n\n\nA.sort()\n\nAcum = list(itertools.accumulate(A))\n\n\n\nanswer = bisect_right(Acum,X)\n\nif answer == N:\n\n    if Acum[-1] < X:\n\n        answer -= 1\n\nprint(answer)", "score": 1.0, "codebleu": 0.3465742562977088, "crystalbleu": 0.3159148237572417, "codebertscore": 0.77, "codescore": 0.15932291746139526, "surfaceSim": 0.5857886420671066, "abs_surfaceSim_minus_score": 0.41421135793289343}
{"golden_code": "import math\n\n\n\nn = int(eval(input()))\n\nans = math.factorial(n) % (pow(10, 9) + 7)\n\nprint(ans)", "generated_code": "n = int(eval(input()))\n\nans = 1\n\nmod = 10 ** 9 + 7\n\nfor i in range(1, n + 1):\n\n    ans = (ans * i % mod) % mod\n\nprint(ans)", "score": 1.0, "codebleu": 0.35287485833402454, "crystalbleu": 0.0, "codebertscore": 0.83, "codescore": 0.3992074429988861, "surfaceSim": 0.6022179363548699, "abs_surfaceSim_minus_score": 0.39778206364513014}
{"golden_code": "import sys\n\ninput = sys.stdin.readline\n\nsys.setrecursionlimit(10 ** 7)\n\n\n\nK, S = list(map(int, input().split()))\n\n\n\nans = 0\n\nfor z in range(K+1):\n\n    for y in range(K+1):\n\n        x = S - (z + y)\n\n        if x >= 0 and x <= K:\n\n            ans += 1\n\nprint(ans)", "generated_code": "import sys\n\ninput = sys.stdin.readline\n\nsys.setrecursionlimit(10 ** 7)\n\n\n\nK, S = list(map(int, input().split()))\n\n\n\nans = 0\n\nfor z in range(K+1):\n\n    for y in range(K+1):\n\n        x = S - (z + y)\n\n        if 0 <= x <= K:\n\n            ans += 1\n\nprint(ans)", "score": 1.0, "codebleu": 0.8825436459331386, "crystalbleu": 0.9276598729621841, "codebertscore": 0.99, "codescore": 0.6744887828826904, "surfaceSim": 0.9260057471264368, "abs_surfaceSim_minus_score": 0.0739942528735632}
{"golden_code": "A, B = list(map(int, input().split()))\n\ncnt = 0\n\nfor i in range(A, B+1):\n\n    l = list(str(i))\n\n\n\n    if l == list(reversed(l)):\n\n        cnt += 1\n\n\n\nprint(cnt)\n", "generated_code": "A, B = list(map(int, input().split()))\n\ncnt = 0\n\nfor i in range(A, B+1):\n\n    l = str(i)\n\n    if l == l[::-1]:\n\n        cnt += 1\n\n\n\nprint(cnt)\n", "score": 1.0, "codebleu": 0.7711253295607611, "crystalbleu": 0.0, "codebertscore": 0.96, "codescore": 0.890034019947052, "surfaceSim": 0.8364389233954451, "abs_surfaceSim_minus_score": 0.16356107660455488}
{"golden_code": "N,K=list(map(int,input().split()))\n\n\n\ncon = 0\n\nans = list(int() for _ in range(100000))\n\npre = 0\n\n\n\n\n\nfor _ in range(K):\n\n\n\n    D = int(eval(input()))\n\n    arr = list(map(int,input().split()))\n\n\n\n    for j in range(D):\n\n\n\n        ans[pre+j]=arr[j]\n\n\n\n    pre += D\n\n\n\n        \n\nfin = (N+1) - len(set(ans))\n\n\n\nprint(fin)", "generated_code": "N,K=list(map(int,input().split()))\n\n\n\ncon = 0\n\nans = list(int() for _ in range(10001))\n\npre = 0\n\n\n\n\n\nfor _ in range(K):\n\n\n\n    D = int(eval(input()))\n\n    arr = list(map(int,input().split()))\n\n\n\n    for j in range(D):\n\n\n\n        ans[pre+j]=arr[j]\n\n\n\n    pre += D\n\n\n\n        \n\nfin = (N+1) - len(set(ans))\n\n\n\nprint(fin)", "score": 1.0, "codebleu": 0.9655676097906438, "crystalbleu": 0.9440375310909427, "codebertscore": 1.0, "codescore": 0.9938521385192871, "surfaceSim": 0.9968553459119497, "abs_surfaceSim_minus_score": 0.0031446540880503138}
{"golden_code": "import numpy as np\n\nN = int(eval(input()))\n\nA = np.array(list(map(int, input().split())))\n\ncount = 0\n\nwhile True:\n\n    if np.sum(A%2) > 0:\n\n        break\n\n    count +=1\n\n    A = A//2\n\nprint(count)\n", "generated_code": "n = int(eval(input()))\n\na = list(map(int, input().split()))\n\n\n\nans = float(\"inf\")\n\n\n\nfor i in a:\n\n    ans = min(ans, len(bin(i)) - bin(i).rfind(\"1\") - 1) # (1)…2で割った回数が最小のものを探索\n\nprint(ans)", "score": 1.0, "codebleu": 0.21113465302282375, "crystalbleu": 0.0, "codebertscore": 0.73, "codescore": 0.11530126631259918, "surfaceSim": 0.48135069521077023, "abs_surfaceSim_minus_score": 0.5186493047892298}
{"golden_code": "from collections import defaultdict\n\nimport numpy as np\n\ndef main():\n\n    s = eval(input())\n\n    n = len(s)\n\n    d = np.zeros(2019,np.int64)\n\n    ans = 0\n\n    num = 0\n\n    pow10 = 1\n\n    d[0] = 1\n\n    for i in reversed(list(range(n))):\n\n        pow10 = pow10 * 10 % 2019\n\n        num += int(s[i]) * pow10\n\n        #print(num, num % 2019, i)\n\n        mod = num % 2019\n\n        ans += d[mod]\n\n        d[mod] += 1\n\n    print(ans)\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "generated_code": "from collections import defaultdict\n\n\n\ndef main():\n\n    s = eval(input())\n\n    n = len(s)\n\n    ans = 0\n\n    num = 0\n\n    pow10 = 1\n\n    d = defaultdict(int)\n\n    d[0] = 1\n\n    for i in reversed(list(range(n))):\n\n        # pow10を10 ** (n-1-i)にしてるだけでTLEしていた\n\n        pow10 = pow10 * 10 % 2019\n\n        num += int(s[i]) * pow10\n\n        mod = num % 2019\n\n        ans += d[mod]\n\n        d[mod] += 1\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "score": 1.0, "codebleu": 0.6604584671820345, "crystalbleu": 0.8467833182814646, "codebertscore": 0.91, "codescore": 0.01852647215127945, "surfaceSim": 0.9002985074626866, "abs_surfaceSim_minus_score": 0.09970149253731342}
{"golden_code": "import sys\n\n_input = sys.stdin.readline\n\n\n\n\n\ndef resolve():\n\n    N = int(_input())\n\n    T = [list(map(int, _input().split())) for _ in range(N)]\n\n    t, x, y = 0, 0, 0\n\n    for next_t, next_x, next_y in T:\n\n        diff_xy = abs(x - next_x) + abs(y - next_y)\n\n        diff_t = next_t - t\n\n        if diff_xy > diff_t or (diff_xy % 2 != diff_t % 2):\n\n            print('No')\n\n            exit(0)\n\n    print('Yes')\n\n\n\n\n\nif __name__ == '__main__':\n\n    resolve()", "generated_code": "import sys\n\n_input = sys.stdin.readline\n\n\n\n\n\ndef resolve():\n\n    N = int(_input())\n\n    t, x, y = 0, 0, 0\n\n    for _ in range(N):\n\n        next_t, next_x, next_y = list(map(int, _input().split()))\n\n        diff_xy = abs(x - next_x) + abs(y - next_y)\n\n        diff_t = next_t - t\n\n        if diff_xy > diff_t or (diff_xy % 2 != diff_t % 2):\n\n            print('No')\n\n            exit(0)\n\n    print('Yes')\n\n\n\n\n\nif __name__ == '__main__':\n\n    resolve()", "score": 1.0, "codebleu": 0.7613940567439924, "crystalbleu": 0.8829723679745588, "codebertscore": 0.98, "codescore": 0.024845141917467117, "surfaceSim": 0.883675692499222, "abs_surfaceSim_minus_score": 0.11632430750077805}
{"golden_code": "NN = 19\n\nXX = [0] * (2**(NN+1)-1)\n\n\n\ndef addvalue(j, x):\n\n    i = 2**NN + j - 1\n\n    while i >= 0:\n\n        XX[i] += x\n\n        i = (i-1) // 2\n\n\n\ndef rangesum(a, b):\n\n    l = a + (1<<NN)\n\n    r = b + (1<<NN)\n\n    s = 0\n\n    while l < r:\n\n        if l%2:\n\n            s += XX[l-1]\n\n            l += 1\n\n        if r%2:\n\n            r -= 1\n\n            s += XX[r-1]\n\n        l >>= 1\n\n        r >>= 1\n\n    return s\n\n\n\nN, Q = map(int, input().split())\n\nC = [int(a) - 1 for a in input().split()]\n\nX = [[] for _ in range(N)]\n\nfor i in range(Q):\n\n    l, r = map(int, input().split())\n\n    X[r-1].append((l - 1, i))\n\nlast = [-1] * N\n\nANS = [-1] * Q\n\naddvalue(1, N)\n\nfor r in range(N):\n\n    c = C[r]\n\n    addvalue(last[c] + 2, -1)\n\n    addvalue(r + 2, 1)\n\n    last[c] = r\n\n    for l, i in X[r]:\n\n        ANS[i] = rangesum(l + 2, 1 << NN)\n\n    \n\nprint(*ANS, sep = \"\\n\")\n", "generated_code": "##### https://atcoder.jp/contests/abc174/submissions/15644075 を1次元化\n\n\n\nimport sys\n\nINF = 1 << 60\n\nMOD = 10**9 + 7 # 998244353\n\nsys.setrecursionlimit(2147483647)\n\ninput = lambda:sys.stdin.buffer.readline().rstrip()\n\n \n\nclass SegmentTree(object):\n\n    def __init__(self, A, dot, unit):\n\n        n = 1 << (len(A) - 1).bit_length()\n\n        tree = [unit] * (2 * n)\n\n        for i, v in enumerate(A):\n\n            tree[i + n] = v\n\n        for i in range(n - 1, 0, -1):\n\n            tree[i] = dot(tree[i << 1], tree[i << 1 | 1])\n\n        self._n = n\n\n        self._tree = tree\n\n        self._dot = dot\n\n        self._unit = unit\n\n \n\n    def __getitem__(self, i):\n\n        return self._tree[i + self._n]\n\n \n\n    def update(self, i, v):\n\n        i += self._n\n\n        self._tree[i] = v\n\n        while i != 1:\n\n            i >>= 1\n\n            self._tree[i] = self._dot(self._tree[i << 1], self._tree[i << 1 | 1])\n\n \n\n    def add(self, i, v):\n\n        self.update(i, self[i] + v)\n\n \n\n    def sum(self, l, r):\n\n        l += self._n\n\n        r += self._n\n\n        l_val = r_val = self._unit\n\n        while l < r:\n\n            if l & 1:\n\n                l_val = self._dot(l_val, self._tree[l])\n\n                l += 1\n\n            if r & 1:\n\n                r -= 1\n\n                r_val = self._dot(self._tree[r], r_val)\n\n            l >>= 1\n\n            r >>= 1\n\n        return self._dot(l_val, r_val)\n\n\n\nfrom operator import add\n\ndef resolve():\n\n    n, q = map(int, input().split())\n\n    C = list(map(lambda x : int(x) - 1, input().split()))\n\n \n\n    A = [0] * n\n\n    used = [0] * n\n\n    for i, c in enumerate(C):\n\n        if used[c]:\n\n            continue\n\n        used[c] = 1\n\n        A[i] = 1\n\n    tree = SegmentTree(A, add, 0)\n\n \n\n    next = [-1] * n\n\n    used = [-1] * n\n\n    for i in range(n - 1, -1, -1):\n\n        c = C[i]\n\n        if used[c] != -1:\n\n            next[i] = used[c]\n\n        used[c] = i\n\n \n\n    queries = [None] * q\n\n    for i in range(q):\n\n        l, r = map(int, input().split())\n\n        queries[i] = (l - 1 << 40) + (r << 20) + i\n\n    queries.sort(reverse = 1)\n\n    \n\n    m = (1 << 20) - 1\n\n    ans = [0] * q\n\n    for l in range(n):\n\n        while queries and queries[-1] >> 40 == l:\n\n            lri = queries.pop()\n\n            l = lri >> 40\n\n            r = (lri >> 20) & m\n\n            i = lri & m\n\n            ans[i] = tree.sum(l, r)\n\n        if next[l] != -1:\n\n            tree.add(next[l], 1)\n\n \n\n    print(*ans, sep = '\\n')\n\nresolve()\n", "score": 1.0, "codebleu": 0.27344750512101357, "crystalbleu": 0.1369117703405533, "codebertscore": 0.78, "codescore": 0.7629560828208923, "surfaceSim": 0.603565134878677, "abs_surfaceSim_minus_score": 0.396434865121323}
{"golden_code": "N,M = list(map(int,input().split()))\n\nL,R = [],[]\n\nfor i in range(M):\n\n    l,r = list(map(int,input().split()))\n\n    L.append(l)\n\n    R.append(r)\n\nans = min(R)-max(L)+1\n\nprint((ans if ans >= 0 else 0))", "generated_code": "# coding: utf-8\n\nimport sys\n\n\n\nsr = lambda: sys.stdin.readline().rstrip()\n\nir = lambda: int(sr())\n\nlr = lambda: list(map(int, sr().split()))\n\n\n\nN, M = lr()\n\nL = 0; R = 10 ** 6\n\nfor _ in range(M):\n\n    l, r = lr()\n\n    if l > L:\n\n        L = l\n\n    if r < R:\n\n        R = r\n\n\n\nanswer = max(0, R - L + 1)\n\nprint(answer)\n", "score": 1.0, "codebleu": 0.23540274935907246, "crystalbleu": 0.17832527680642812, "codebertscore": 0.79, "codescore": 0.43442046642303467, "surfaceSim": 0.5431785195936139, "abs_surfaceSim_minus_score": 0.45682148040638615}
{"golden_code": "N = int(eval(input()))\n\nA = list(map(int,input().split()))\n\n\n\nSUM = 0\n\nfor i in A:\n\n    count = 0\n\n    while i%2 == 0:\n\n        i//=2\n\n        count += 1\n\n    SUM+=count\n\nprint(SUM)", "generated_code": "N = int(eval(input()))\n\nA = list(map(int,input().split()))\n\nSUM = 0\n\nfor i in A:\n\n    while i%2 == 0:\n\n        i//=2\n\n        SUM += 1\n\nprint(SUM)", "score": 1.0, "codebleu": 0.7171636775984799, "crystalbleu": 0.0, "codebertscore": 0.97, "codescore": 0.6345913410186768, "surfaceSim": 0.9392265193370166, "abs_surfaceSim_minus_score": 0.06077348066298338}
{"golden_code": "import math\n\nimport statistics\n\nn = int(eval(input()))\n\na = list(map(int,input().split()))\n\na = [aa-i-1 for i, aa in enumerate(a)]\n\nanswer = n*10**20\n\nmedian_low = statistics.median_low(a)\n\nmedian_high = statistics.median_high(a)\n\n\n\nfor m in (median_low,median_high):\n\n  ans=0\n\n  for aa in a:\n\n    ans += abs(aa-m)\n\n  answer = min(ans,answer)\n\nprint(answer)\n", "generated_code": "#!/usr/bin/env python3\n\nimport sys\n\n\n\n\n\ndef solve(N: int, A: \"List[int]\"):\n\n    difA = [0]*N\n\n\n\n    for i in range(N):\n\n        difA[i] = A[i]-(i+1)\n\n\n\n    difA.sort()\n\n    if N%2 == 0:\n\n        g1 = difA[N//2]\n\n        g2 = difA[N//2-1]\n\n        a1 = 0\n\n        a2 = 0\n\n        for i in range(N):\n\n            a1 += abs(difA[i]-g1)\n\n            a2 += abs(difA[i]-g2)\n\n        print((min(a1,a2)))\n\n            \n\n    else:\n\n        g = difA[N//2]\n\n        a = 0\n\n        for i in range(N):\n\n            a += abs(difA[i]-g)\n\n        print(a)\n\n    return\n\n\n\n\n\ndef main():\n\n    def iterate_tokens():\n\n        for line in sys.stdin:\n\n            for word in line.split():\n\n                yield word\n\n    tokens = iterate_tokens()\n\n    N = int(next(tokens))  # type: int\n\n    A = [int(next(tokens)) for _ in range(N)]  # type: \"List[int]\"\n\n    solve(N, A)\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 1.0, "codebleu": 0.20623118243701472, "crystalbleu": 0.03593921954282499, "codebertscore": 0.72, "codescore": 0.9727429151535034, "surfaceSim": 0.558807061458402, "abs_surfaceSim_minus_score": 0.441192938541598}
{"golden_code": "class Calc:\n\n    def __init__(self, max_value, mod):\n\n        \"\"\"combination(max_value, all)\"\"\"\n\n        fact = [-1] * (max_value + 1)\n\n        fact[0] = 1\n\n        fact[1] = 1\n\n        for x in range(2, max_value + 1):\n\n            fact[x] = x * fact[x - 1] % mod\n\n\n\n        invs = [1] * (max_value + 1)\n\n        invs[max_value] = pow(fact[max_value], mod - 2, mod)\n\n        for x in range(max_value - 1, 0, -1):\n\n            invs[x] = invs[x + 1] * (x + 1) % mod\n\n\n\n        self.fact = fact\n\n        self.invs = invs\n\n        self.mod = mod\n\n\n\n    def combination(self, n, r):\n\n        if n - r < r:\n\n            return self.combination(n, n - r)\n\n        if r < 0:\n\n            return 0\n\n        if r == 0:\n\n            return 1\n\n        if r == 1:\n\n            return n\n\n        return self.fact[n] * self.invs[r] * self.invs[n - r] % self.mod\n\n\n\n\n\ndef gen(n):\n\n    x = n\n\n    d = 2\n\n    cnt = 0\n\n    while x % d == 0:\n\n        x //= d\n\n        cnt += 1\n\n    yield cnt\n\n\n\n    d = 3\n\n    ma = d * d\n\n    while ma <= n:\n\n        cnt = 0\n\n        while x % d == 0:\n\n            x //= d\n\n            cnt += 1\n\n        yield cnt\n\n        ma += d * 4 + 4\n\n        d += 2\n\n\n\n    if x > 1:\n\n        yield 1\n\n\n\n\n\ndef main():\n\n    MOD = 10 ** 9 + 7\n\n\n\n    N, M = list(map(int, input().split()))\n\n\n\n    cal = Calc(max_value=N + 30, mod=MOD)\n\n\n\n    ans = 1\n\n    for cnt in gen(M):\n\n        ans = (ans * cal.combination(N + cnt - 1, cnt)) % MOD\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "generated_code": "def gen(n):\n\n    x = n\n\n    d = 2\n\n    cnt = 0\n\n    while x % d == 0:\n\n        x //= d\n\n        cnt += 1\n\n    yield cnt\n\n\n\n    d = 3\n\n    while d * d <= n:\n\n        cnt = 0\n\n        while x % d == 0:\n\n            x //= d\n\n            cnt += 1\n\n        yield cnt\n\n        d += 2\n\n\n\n    if x > 1:\n\n        yield 1\n\n\n\n\n\ndef main():\n\n    MOD = 10 ** 9 + 7\n\n\n\n    N, M = list(map(int, input().split()))\n\n\n\n    ans = 1\n\n    for cnt in gen(M):\n\n        for d in range(cnt):\n\n            ans = (ans * (N - 1 + cnt - d) % MOD) * pow(d + 1, MOD - 2, MOD) % MOD\n\n            \n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 1.0, "codebleu": 0.30364613357255194, "crystalbleu": 0.22753835647188972, "codebertscore": 0.81, "codescore": 0.021854596212506294, "surfaceSim": 0.6793730650154799, "abs_surfaceSim_minus_score": 0.3206269349845201}
{"golden_code": "import numpy as np\n\nfrom itertools import product\n\n\n\nn = int(eval(input()))\n\na = list(map(int,input().split()))\n\n\n\na = np.array(a)\n\n\n\nli = [-1,0,1]\n\ncnt = 0\n\nfor v in product(li,repeat = n):\n\n    v = np.array(v)\n\n    L =a+v\n\n    cum = L.cumprod()\n\n    if cum[-1]%2 ==0 :\n\n        cnt +=1\n\nprint(cnt)\n\n        ", "generated_code": "n = int(eval(input()))\n\na = list(map(int,input().split()))\n\n\n\nfrom itertools import product\n\n\n\nli = [-1,0,1]\n\ncnt = 0\n\nfor v in product(li,repeat = n):\n\n    L = []\n\n    for i in range(n):\n\n        L.append(v[i]+a[i])\n\n    if any(x%2==0 for x in L):\n\n        cnt +=1\n\n\n\nprint(cnt)", "score": 1.0, "codebleu": 0.49244072516585424, "crystalbleu": 0.5704553140303206, "codebertscore": 0.9, "codescore": 0.9923842549324036, "surfaceSim": 0.7619625520110958, "abs_surfaceSim_minus_score": 0.23803744798890425}
{"golden_code": "# https://atcoder.jp/contests/abc129/tasks/abc129_c\n\n# 典型的なDP\n\n\n\nMOD = 10**9 + 7\n\nimport numpy as np\n\n# dp[i]をi段目までの通りの数とする。\n\nN, M = list(map(int, input().split()))\n\nto_zero = np.full((N + 1), False).tolist()\n\nfor _ in range(M):\n\n    to_zero[int(eval(input()))] = True  # 床が抜けているところ\n\n\n\n# dpテーブルの用意\n\ndp = np.full((N + 1), -1).tolist()\n\ndp[0] = 1\n\ndp[1] = 0 if to_zero[1] else 1\n\nfor i in range(2, N + 1):\n\n    dp[i] = 0 if to_zero[i] else dp[i - 2] + dp[i - 1]\n\n    if dp[i] > MOD:\n\n        dp[i] %= MOD\n\n\n\nprint((dp[-1]))\n", "generated_code": "# https://atcoder.jp/contests/abc129/tasks/abc129_c\n\n# 典型的なDP\n\n\n\n\n\ndef full(shape, full_value):\n\n    if isinstance(shape, tuple):\n\n        NotImplementedError()\n\n    else:\n\n        return [full_value] * shape\n\n\n\n\n\nMOD = 10**9 + 7\n\n# dp[i]をi段目までの通りの数とする。\n\nN, M = list(map(int, input().split()))\n\nto_zero = full((N + 1), False)\n\nfor _ in range(M):\n\n    to_zero[int(eval(input()))] = True  # 床が抜けているところ\n\n\n\n# dpテーブルの用意\n\ndp = full((N + 1), -1)\n\ndp[0] = 1\n\ndp[1] = 0 if to_zero[1] else 1\n\nfor i in range(2, N + 1):\n\n    dp[i] = 0 if to_zero[i] else dp[i - 2] + dp[i - 1]\n\n    if dp[i] > MOD:\n\n        dp[i] %= MOD\n\n\n\nprint((dp[-1]))\n", "score": 1.0, "codebleu": 0.7030020679166693, "crystalbleu": 0.7187809701451223, "codebertscore": 0.93, "codescore": 0.3877912759780884, "surfaceSim": 0.7751196172248804, "abs_surfaceSim_minus_score": 0.22488038277511957}
{"golden_code": "import numpy as np\n\nN=int(eval(input()))\n\nroot=int(np.sqrt(N)//1)\n\na=N\n\nb=N\n\nfor i in range(root, 0, -1):\n\n    if N%i==0:\n\n        a=i\n\n        b=N//i\n\n        break\n\nprint((a-1+b-1))", "generated_code": "N=int(eval(input()))\n\nroot=int((N**0.5)//1)\n\na=N\n\nb=N\n\nfor i in range(root, 0, -1):\n\n    if N%i==0:\n\n        a=i\n\n        b=N//i\n\n        break\n\nprint((a-1+b-1))\n", "score": 1.0, "codebleu": 0.5931574140209582, "crystalbleu": 0.0, "codebertscore": 0.94, "codescore": 0.8830369114875793, "surfaceSim": 0.8483606557377049, "abs_surfaceSim_minus_score": 0.15163934426229508}
{"golden_code": "import math\n\n\n\nN = int(eval(input()))\n\n\n\nnum = math.factorial(N)\n\n\n\nk, r = divmod(num, 10**9 + 7)\n\nprint(r)", "generated_code": "N = int(eval(input()))\n\n\n\nFACTOR = 10 ** 9 + 7\n\n\n\nnum = 1\n\nfor i in range(1, N+1):\n\n    num *= i\n\n    k, r = divmod(num, FACTOR)\n\n    num = r\n\n\n\nprint(r)", "score": 1.0, "codebleu": 0.3120396009464104, "crystalbleu": 0.0, "codebertscore": 0.85, "codescore": 0.8808392286300659, "surfaceSim": 0.6274509803921569, "abs_surfaceSim_minus_score": 0.37254901960784315}
{"golden_code": "a,b,c=1,0,0\n\nexec('a,b,c=b,c,(a+c)%(10**9+7);'*(int(eval(input()))-2))\n\nprint(c)", "generated_code": "a,b,c=1,0,0\n\nexec('a,b,c=b,c,a+c;'*(int(eval(input()))-2))\n\nprint((c%(10**9+7)))", "score": 1.0, "codebleu": 0.5057864365426399, "crystalbleu": 0.0, "codebertscore": 0.97, "codescore": 0.9939196109771729, "surfaceSim": 0.75, "abs_surfaceSim_minus_score": 0.25}
{"golden_code": "import numpy as np\n\n \n\ndef main():\n\n    stdin = np.fromstring(open(0).read(), dtype=np.int64, sep=' ')\n\n    A = stdin[1:]\n\n    A = np.mod(A, 2)\n\n    print(\"first\") if np.count_nonzero(A) else print(\"second\")\n\nif __name__ == \"__main__\":\n\n    main()\n", "generated_code": "import sys\n\ndef input(): return sys.stdin.readline().strip()\n\ndef main():\n\n    N = int(input())\n\n    A = (int(input()) for _ in range(N))\n\n    print(\"second\") if all(( a%2==0 for a in A)) else print(\"first\")\n\nif __name__ == \"__main__\":\n\n    main()\n", "score": 1.0, "codebleu": 0.282742253183675, "crystalbleu": 0.0, "codebertscore": 0.81, "codescore": 0.025945303961634636, "surfaceSim": 0.6141935483870968, "abs_surfaceSim_minus_score": 0.38580645161290317}
{"golden_code": "K,S=list(map(int,input().split()))\n\nO=0\n\nfor X in range(K+1):\n\n  for Y in range(K+1):\n\n    Z=S-X-Y\n\n    if 0<=Z<=K:\n\n      O+=1\n\nprint(O)\n", "generated_code": "K,S=list(map(int,input().split()))\n\nans=0\n\nfor X in range(K+1):\n\n    for Y in range(K+1):\n\n        Z=S-X-Y\n\n        if 0<=Z<=K:\n\n            ans+=1\n\nprint(ans)\n", "score": 1.0, "codebleu": 0.8643946190991622, "crystalbleu": 0.0, "codebertscore": 0.98, "codescore": 0.799632728099823, "surfaceSim": 0.971875, "abs_surfaceSim_minus_score": 0.028124999999999956}
{"golden_code": "N, M = list(map(int, input().split(\" \")))\n\nA = {int(eval(input())) for _ in range(M)}\n\n\n\nmemo = [0] * (N + 1)\n\nmemo[0] = 1\n\nmemo[1] = 0 if 1 in A else 1\n\n\n\nif N == 1:\n\n    print((memo[1]))\n\nelse:\n\n    for i in range(2, N + 1):\n\n        if i in A:\n\n            continue\n\n        memo[i] = (memo[i - 2] + memo[i - 1]) % 1000000007\n\n\n\n    print((memo[N]))\n", "generated_code": "N, M = list(map(int, input().split(\" \")))\n\nA = {int(input()) for _ in range(M)}\n\n\n\nmemo = [0] * (N + 1)\n\nmemo[0] = 1\n\nmemo[1] = 0 if 1 in A else 1\n\n\n\nif N == 1:\n\n    print((memo[1]))\n\nelse:\n\n    for i in range(2, N + 1):\n\n        if i in A:\n\n            continue\n\n        memo[i] = (memo[i - 2] + memo[i - 1]) % 1000000007\n\n    print((memo[N]))\n", "score": 1.0, "codebleu": 0.824200319050982, "crystalbleu": 0.9698302724622573, "codebertscore": 0.99, "codescore": 0.9938201308250427, "surfaceSim": 0.9915014164305949, "abs_surfaceSim_minus_score": 0.008498583569405138}
{"golden_code": "\n\nX = int(eval(input()))\n\nfor a in range(-200, 200):\n\n    find = False\n\n    for b in range(-200, 200):\n\n        x = a**5-b**5\n\n        if x == X:\n\n            find = True\n\n            print((a, b))\n\n            break\n\n    if find:\n\n        break\n", "generated_code": "\n\nX = int(eval(input()))\n\nfor a in range(-120, 120):\n\n    find = False\n\n    for b in range(-120, 120):\n\n        x = a**5-b**5\n\n        if x == X:\n\n            find = True\n\n            print((a, b))\n\n            break\n\n    if find:\n\n        break\n", "score": 1.0, "codebleu": 0.8296536783044713, "crystalbleu": 0.0, "codebertscore": 0.98, "codescore": 0.9701499342918396, "surfaceSim": 0.983739837398374, "abs_surfaceSim_minus_score": 0.016260162601625994}
{"golden_code": "N=int(eval(input()))\n\nd=list(map(int, input().split()))\n\n\n\nimport numpy as np\n\nd = np.array(d)\n\n\n\nprint(( ( (np.sum(d))**2 - np.sum(d**2) ) // 2 ))\n", "generated_code": "N=int(eval(input()))\n\nd=list(map(int, input().split()))\n\n\n\ncumsum = 0\n\nfor n in range(N):\n\n    cumsum += d[n]\n\nsub_cumsum = 0\n\nans = 0\n\nfor n in range(N):\n\n    sub_cumsum += d[n]\n\n    ans += d[n] * (cumsum-sub_cumsum)\n\nprint(ans)\n", "score": 1.0, "codebleu": 0.318046507533285, "crystalbleu": 0.2536321946942094, "codebertscore": 0.77, "codescore": 0.06187252700328827, "surfaceSim": 0.5314699792960662, "abs_surfaceSim_minus_score": 0.4685300207039338}
{"golden_code": "x = int(eval(input()))\n\n\n\nfor a in range(-118,119):\n\n  for b in range(-119,118):\n\n    if a**5 - b**5 == x:\n\n      print((a,b))\n\n      exit()", "generated_code": "x = int(eval(input()))\n\n\n\nfor i in range(0, 120):\n\n  for j in range(-119, 120):\n\n    if (i**5 - j**5) == x:\n\n      print((i,j))\n\n      exit()\n", "score": 1.0, "codebleu": 0.48071554147734985, "crystalbleu": 0.0, "codebertscore": 0.93, "codescore": 0.8836766481399536, "surfaceSim": 0.943661971830986, "abs_surfaceSim_minus_score": 0.05633802816901401}
{"golden_code": "import sys\n\ninput = sys.stdin.readline\n\n\n\nn, m = list(map(int, input().split()))\n\nbroken = set([int(eval(input())) for _ in range(m)]) # ここが'list'だとPypyでも通らない\n\n\n\ndef ptn_num(x): # 'x'stepまでのパターン数\n\n    dp = [0] * (x+1) # DP枠_including step'0'\n\n    if 1 in broken: # in case, step'1' broken \n\n        dp[:2] = 1, 0\n\n    else:\n\n        dp[:2] = 1, 1 # Usually\n\n\n\n    for i in range(2, x+1):\n\n        if i not in broken: # 階段が壊れてない場合...\n\n            dp[i] = (dp[i-1] + dp[i-2]) % (10**9+7) # -1段目と-2段目の合計\n\n    print((dp[-1]))\n\n\n\nptn_num(n)\n", "generated_code": "import sys\n\ninput = sys.stdin.readline\n\n\n\nn, m = list(map(int, input().split()))\n\nbroken = set([int(eval(input())) for _ in range(m)]) # ここが'list'だとPypyでも通らない\n\n\n\ndef ptn_num(x): # 'x'stepまでのパターン数\n\n    dp = [0] * (x+1) # DP枠_including step'0'\n\n    if 1 in broken: # 固定部分_in case, step'1' broken \n\n        dp[:2] = 1, 0\n\n    else:\n\n        dp[:2] = 1, 1 # 固定部分_Usually\n\n\n\n    for i in range(2, x+1):\n\n        if i not in broken: # 階段が壊れてない場合...\n\n            dp[i] = (dp[i-1] + dp[i-2]) % (10**9+7) # -1段目と-2段目の合計\n\n    print((dp[-1]))\n\n\n\nptn_num(n)", "score": 1.0, "codebleu": 0.9636621435803967, "crystalbleu": 1.0, "codebertscore": 0.97, "codescore": 0.9937630295753479, "surfaceSim": 1.0, "abs_surfaceSim_minus_score": 0.0}
{"golden_code": "n,k = list(map(int,input().split()))\n\nnum = 0\n\nq = []\n\nfor i in range(n):\n\n    a,b = list(map(int,input().split()))\n\n    q.append((a,b))\n\nq.sort()\n\nfor i in range(n):\n\n    a, b = q[i][0], q[i][1]\n\n    num += b\n\n    if num >= k:\n\n        print(a)\n\n        exit()\n\n\n", "generated_code": "n,k = list(map(int,input().split()))\n\ncnt = 0\n\nnum = []\n\nfor i in range(n):\n\n    a,b = list(map(int,input().split()))\n\n    num.append((a,b))\n\nnum.sort()\n\nfor i in range(n):\n\n    cnt += num[i][1]\n\n    if cnt >= k:\n\n        print((num[i][0]))\n\n        exit()", "score": 1.0, "codebleu": 0.6125906000890213, "crystalbleu": 0.6586735930343616, "codebertscore": 0.95, "codescore": 0.7882053852081299, "surfaceSim": 0.9128787878787878, "abs_surfaceSim_minus_score": 0.08712121212121215}
{"golden_code": "import sys, re\n\nfrom collections import deque, defaultdict, Counter\n\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, radians\n\nfrom itertools import accumulate, permutations, combinations, product, groupby\n\nfrom operator import itemgetter, mul\n\nfrom copy import deepcopy\n\nfrom string import ascii_lowercase, ascii_uppercase, digits\n\nfrom bisect import bisect, bisect_left\n\nfrom fractions import gcd\n\nfrom heapq import heappush, heappop\n\nfrom functools import reduce\n\ndef input(): return sys.stdin.readline().strip()\n\ndef INT(): return int(eval(input()))\n\ndef MAP(): return list(map(int, input().split()))\n\ndef LIST(): return list(map(int, input().split()))\n\ndef ZIP(n): return list(zip(*(MAP() for _ in range(n))))\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = float('inf')\n\nmod = 10 ** 9 + 7\n\nimport numpy as np\n\n\n\nK, N = MAP()\n\nA = LIST()\n\nA.append(A[0]+K)\n\n\n\nB = np.zeros(N)\n\nfor i in range(N):\n\n  \t\tB[i] = A[i+1] - A[i]\n\n\n\nprint((int(K - max(B))))", "generated_code": "import sys, re\n\nfrom collections import deque, defaultdict, Counter\n\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, radians\n\nfrom itertools import accumulate, permutations, combinations, product, groupby\n\nfrom operator import itemgetter, mul\n\nfrom copy import deepcopy\n\nfrom string import ascii_lowercase, ascii_uppercase, digits\n\nfrom bisect import bisect, bisect_left\n\nfrom fractions import gcd\n\nfrom heapq import heappush, heappop\n\nfrom functools import reduce\n\ndef input(): return sys.stdin.readline().strip()\n\ndef INT(): return int(eval(input()))\n\ndef MAP(): return list(map(int, input().split()))\n\ndef LIST(): return list(map(int, input().split()))\n\ndef ZIP(n): return list(zip(*(MAP() for _ in range(n))))\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = float('inf')\n\nmod = 10 ** 9 + 7\n\n\n\nK, N = MAP()\n\nA = LIST()\n\ndiff = abs(K - A[-1] + A[0])\n\nd = abs(K - A[-1] + A[0])\n\nif N == 2:\n\n  print((min(d, A[1] - A[0])))\n\n  exit()\n\nfor i in range(1, N):\n\n  d += abs(A[i] - A[i-1])\n\n  diff = max(diff, abs(A[i] - A[i-1]))\n\nprint((d - diff))", "score": 1.0, "codebleu": 0.8107840215799317, "crystalbleu": 0.7045897471053787, "codebertscore": 0.96, "codescore": 0.2482839822769165, "surfaceSim": 0.8430622009569377, "abs_surfaceSim_minus_score": 0.15693779904306226}
{"golden_code": "a,b=list(map(int,input().split()))\n\n\n\nans=0\n\n\n\nfor i in range(a,b+1):\n\n    buf=str(i)\n\n    #print(buf[0:int(len(buf)/2)],buf[int(len(buf)/2+1):])\n\n    str1=buf[0:int(len(buf)/2)]\n\n    str2=buf[int(len(buf)/2+1):]\n\n    if str1[0]==str2[1] and str1[1]==str2[0]:\n\n        ans+=1\n\n\n\nprint(ans)\n", "generated_code": "a,b=list(map(int,input().split()))\n\n\n\nans=0\n\n\n\nfor i in range(a,b+1):\n\n    buf=str(i)\n\n    str1=buf[::-1]\n\n    if buf==str1:\n\n        ans+=1\n\n\n\nprint(ans)\n", "score": 1.0, "codebleu": 0.5071448329890118, "crystalbleu": 0.0, "codebertscore": 0.89, "codescore": 0.8024800419807434, "surfaceSim": 0.7558620689655172, "abs_surfaceSim_minus_score": 0.24413793103448278}
{"golden_code": "import math\n\nn = int(eval(input()))\n\na = list(map(int, input().split()))\n\n\n\n\n\ndef trial_division(n):\n\n    factor = []\n\n    tmp = int(math.sqrt(n)) + 1\n\n    for _ in range(2,tmp):\n\n        while n % 2 == 0:\n\n            n //= 2\n\n            factor.append(2)\n\n    if not factor:\n\n        return [n]\n\n    else:\n\n        factor.append(n)\n\n        return factor\n\n\n\n\n\ncount = 0\n\nfor i in a:\n\n    temp = trial_division(i)\n\n    count += temp.count(2)\n\n\n\nprint(count)", "generated_code": "n = int(eval(input()))\n\na = list(map(int, input().split()))\n\n\n\n\n\ndef trial_division(n):\n\n    #２で割った因数を格納するリスト\n\n    factor = []\n\n    #2で割れなくなった時点でストップ\n\n    while n % 2 == 0:\n\n        n //= 2    # ２で割った商を切り捨てて代入\n\n        factor.append(2)\n\n    #nが一度も２で割れなかったらそのまま返す\n\n    if not factor:\n\n        return [n]\n\n    else:\n\n        factor.append(n)\n\n        return factor\n\n\n\n\n\ncount = 0\n\nfor i in a:\n\n    temp = trial_division(i)\n\n    count += temp.count(2)\n\n\n\nprint(count)", "score": 1.0, "codebleu": 0.6147493320061137, "crystalbleu": 0.7670102272028909, "codebertscore": 0.81, "codescore": 0.7973769307136536, "surfaceSim": 0.9050184729064039, "abs_surfaceSim_minus_score": 0.09498152709359609}
{"golden_code": "n = int(eval(input()))\n\nr = int(n**.5)\n\nfor i in range(r):\n\n  if n % (r-i) == 0:\n\n    print(( (r-i) + n//(r-i) - 2 ))\n\n    break", "generated_code": "n = int(eval(input()))\n\ns = int(n**.5)\n\nfor i in range(s):\n\n  if n % (s-i) == 0:\n\n    print(((s-i) + n // (s-i) - 2))\n\n    break", "score": 1.0, "codebleu": 0.6277574034920292, "crystalbleu": 0.0, "codebertscore": 0.97, "codescore": 0.8126668930053711, "surfaceSim": 0.98046875, "abs_surfaceSim_minus_score": 0.01953125}
{"golden_code": "def solve(string):\n\n    x = int(string)\n\n    a = {i**5: i for i in range(-10000, 10000)}\n\n    for i in range(-10000, 10000):\n\n        if x + i ** 5 in a:\n\n            return str(f\"{a[x+i**5]} {i}\")\n\n\n\n\n\nif __name__ == '__main__':\n\n    import sys\n\n    print((solve(sys.stdin.read().strip())))\n", "generated_code": "def solve(string):\n\n    x = int(string)\n\n    a = {i**5: i for i in range(-120, 121)}\n\n    for i in range(-121, 121):\n\n        if x + i ** 5 in a:\n\n            return str(f\"{a[x+i**5]} {i}\")\n\n\n\n\n\nif __name__ == '__main__':\n\n    import sys\n\n    print((solve(sys.stdin.read().strip())))\n", "score": 1.0, "codebleu": 0.8185383438666693, "crystalbleu": 0.8537487310940012, "codebertscore": 0.98, "codescore": 0.022668296471238136, "surfaceSim": 0.9743150684931507, "abs_surfaceSim_minus_score": 0.02568493150684925}
{"golden_code": "n, m, k = list(map(int, input().split()))\n\n\n\nmod = 1000000007\n\ndef pow(x, n):\n\n    ret = 1\n\n    while n > 0:\n\n        if (n & 1) == 1:\n\n            ret = (ret * x) % mod\n\n        x = (x * x) % mod\n\n        n >>= 1\n\n    return ret\n\n\n\nfac = [1]\n\ninv = [1]\n\nfor i in range(1, n * m + 1):\n\n    fac.append((fac[-1] * i) % mod)\n\n    inv.append(pow(fac[i], mod - 2))\n\n\n\ndef cmb(n, k):\n\n    return (fac[n] * inv[k] * inv[n - k]) % mod\n\n\n\ndef doit(n, m, k):\n\n    ret = 0\n\n    for d in range(m):\n\n        ret = (ret + d * (m - d)) % mod\n\n    return (ret * n * n * cmb(n * m - 2, k - 2)) % mod\n\n\n\nprint(((doit(n, m, k) + doit(m, n, k)) % mod))", "generated_code": "n, m, k = list(map(int, input().split()))\n\n\n\nmod = 1000000007\n\nfac = [1]\n\nfor i in range(1, n * m + 1):\n\n    fac.append((fac[-1] * i) % mod)\n\n\n\ndef pow(x, n):\n\n    ret = 1\n\n    while n > 0:\n\n        if (n & 1) == 1:\n\n            ret = (ret * x) % mod\n\n        x = (x * x) % mod\n\n        n >>= 1\n\n    return ret\n\n\n\ndef inv(i):\n\n    return pow(fac[i], mod - 2)\n\n\n\ndef cmb(n, k):\n\n    return (fac[n] * inv(k) * inv(n - k)) % mod\n\n\n\nx = sum(d * (m - d) for d in range(m)) % mod\n\ny = sum(d * (n - d) for d in range(n)) % mod\n\n\n\nc = cmb(n * m - 2, k - 2)\n\nx = (x * n * n * c) % mod\n\ny = (y * m * m * c) % mod\n\n\n\nprint(((x + y) % mod))", "score": 1.0, "codebleu": 0.6254303506509027, "crystalbleu": 0.6588003888906186, "codebertscore": 0.92, "codescore": 0.7647347450256348, "surfaceSim": 0.7965867992766726, "abs_surfaceSim_minus_score": 0.20341320072332736}
{"golden_code": "A, B, C, X, Y = list(map(int, input().split()))\n\n\n\nans = float('inf')\n\n\n\nfor i in range(10 ** 5 + 1):\n\n    ans = min(ans, A * max(X - i, 0) + B * max(Y - i, 0) + 2 * C * i)\n\nprint(ans)", "generated_code": "A, B, C, X, Y = list(map(int, input().split()))\n\n\n\n# ans = float('inf')\n\n\n\n# for i in range(10 ** 5 + 1):\n\n#     ans = min(ans, A * max(X - i, 0) + B * max(Y - i, 0) + 2 * C * i)\n\n# print(ans)\n\n\n\nmin_xy = min(X, Y)\n\nmax_xy = max(X, Y)\n\nans1 = 2 * C * min_xy + A * (X - min_xy) + B * (Y - min_xy)\n\nans2 = A * X + B * Y\n\nans3 = 2 * C * max_xy\n\nprint((min(ans1, ans2, ans3)))", "score": 1.0, "codebleu": 0.5265728960734188, "crystalbleu": 0.0, "codebertscore": 0.92, "codescore": 0.12496636062860489, "surfaceSim": 0.801747311827957, "abs_surfaceSim_minus_score": 0.198252688172043}
{"golden_code": "\n\n\n\nn = int(eval(input()))\n\n\n\nabn = [list(map(int,input().split())) for _ in range(n)]\n\n\n\n\n\nabn.sort()\n\nabn.sort(key = lambda x:x[1])\n\n\n\n\n\n#print(abn)\n\n\n\nts = 0 # time_stamp\n\nenable = True\n\nfor abi in abn:\n\n    a, b = abi\n\n\n\n    if not ts + a <= b:\n\n        enable = False\n\n        break\n\n    else:\n\n        ts += a\n\n\n\nprint(('Yes' if enable else 'No'))", "generated_code": "\n\nn = int(eval(input()))\n\n\n\nabn = [list(map(int,input().split())) for _ in range(n)]\n\n\n\n\n\n#abn.sort()\n\nabn.sort(key = lambda x:x[1])\n\n\n\n\n\n#print(abn)\n\n\n\nts = 0 # time_stamp\n\nenable = True\n\nfor abi in abn:\n\n    a, b = abi\n\n\n\n    if not ts + a <= b:\n\n        enable = False\n\n        break\n\n    else:\n\n        ts += a\n\n\n\nprint(('Yes' if enable else 'No'))", "score": 1.0, "codebleu": 0.8595188808251866, "crystalbleu": 0.951229424500714, "codebertscore": 1.0, "codescore": 0.9938676953315735, "surfaceSim": 0.9844192634560907, "abs_surfaceSim_minus_score": 0.015580736543909346}
{"golden_code": "n = int(eval(input()))\n\nres = 1\n\nfor num in range(1, n+1):\n\n  res = res * num\n\n  res = res % (pow(10,9) + 7)\n\nprint(res)", "generated_code": "n = int(eval(input()))\n\nres = 1\n\nfor num in range(1, n+1):\n\n    res = res * num\n\n    res = res % (10**9 + 7)\n\nprint(res)\n", "score": 1.0, "codebleu": 0.8327752484672665, "crystalbleu": 0.0, "codebertscore": 0.97, "codescore": 0.4732905328273773, "surfaceSim": 0.9353600944510035, "abs_surfaceSim_minus_score": 0.06463990554899646}
{"golden_code": "ia = [int(i) for i in input().split(\" \")]\n\nW=ia[0]\n\nH=ia[1]\n\nx=ia[2]\n\ny=ia[3]\n\nr=ia[4]\n\nprint((\"Yes\" if 0<=x-r and x+r<=W and 0<=y-r and y+r<=H else \"No\"))", "generated_code": "# encoding:utf-8\n\n\n\ninput = list(map(int, input().split()))\n\nW, H, x, y, r = input\n\n\n\nif x - r < 0 or x + r > W:\n\n\tprint(\"No\")\n\nelif y - r < 0 or y + r > H:\n\n\tprint(\"No\")\n\nelse:\n\n\tprint(\"Yes\")", "score": 1.0, "codebleu": 0.1292306778567408, "crystalbleu": 0.0, "codebertscore": 0.81, "codescore": 0.7919250130653381, "surfaceSim": 0.5140224358974359, "abs_surfaceSim_minus_score": 0.4859775641025641}
{"golden_code": "def resolve():\n\n    '''\n\n    code here\n\n    '''\n\n    import collections\n\n    import itertools\n\n    import numpy as np\n\n    N = int(eval(input()))\n\n    Ss = [input()[0] for _ in range(N)]\n\n\n\n    march_letter = [item for item in Ss if item in ['M', 'A', 'R', 'C', 'H']]\n\n    march_cnt = collections.Counter(march_letter)\n\n\n\n    if len(march_cnt) < 3:\n\n        res = 0\n\n    else:\n\n        res_list = itertools.combinations(list(march_cnt.values()),3)\n\n\n\n        res = 0\n\n        for element in res_list:\n\n            res += np.prod(np.array(element))\n\n    print(res)\n\n\n\nif __name__ == \"__main__\":\n\n    resolve()\n", "generated_code": "def resolve():\n\n    '''\n\n    code here\n\n    '''\n\n    import collections\n\n    import itertools\n\n    N = int(eval(input()))\n\n    Ss = [input()[0] for _ in range(N)]\n\n\n\n    march_letter = [item for item in Ss if item in ['M', 'A', 'R', 'C', 'H']]\n\n    march_cnt = collections.Counter(march_letter)\n\n\n\n    if len(march_cnt) < 3:\n\n        res = 0\n\n    else:\n\n        res_list = itertools.combinations(list(march_cnt.values()),3)\n\n\n\n        res = 0\n\n        for element in res_list:\n\n            res += element[0]*element[1]*element[2]\n\n    print(res)\n\n\n\nif __name__ == \"__main__\":\n\n    resolve()\n", "score": 1.0, "codebleu": 0.7476079180758797, "crystalbleu": 0.8629484066597266, "codebertscore": 0.97, "codescore": 0.01852959580719471, "surfaceSim": 0.9314449917898193, "abs_surfaceSim_minus_score": 0.06855500821018068}
{"golden_code": "import sys\n\nimport numpy as np\n\n\n\nsr = lambda: sys.stdin.readline().rstrip()\n\nir = lambda: int(sr())\n\nlr = lambda: list(map(int, sr().split()))\n\n\n\nN = ir()\n\nP = np.array(lr())\n\n\n\nP_diff = np.diff(P)\n\nP_diff = P_diff > 0\n\nseries = P_diff[:-1] == P_diff[1:]\n\nanswer = series.sum()\n\nprint(answer)\n\n# 23", "generated_code": "N = int(eval(input()))\n\nP = list(map(int, input().split()))\n\nanswer = sum(x>y>z or x<y<z for x, y, z in zip(P[:-2], P[1:-1], P[2:]))\n\nprint(answer)\n\n    ", "score": 1.0, "codebleu": 0.1798161985929805, "crystalbleu": 0.0, "codebertscore": 0.75, "codescore": 0.33917924761772156, "surfaceSim": 0.48745819397993306, "abs_surfaceSim_minus_score": 0.5125418060200669}
{"golden_code": "# coding: utf-8\n\nimport sys\n\nimport numpy as np\n\n\n\nsr = lambda: sys.stdin.readline().rstrip()\n\nir = lambda: int(sr())\n\nlr = lambda: list(map(int, sr().split()))\n\n\n\nN = ir()\n\nV = np.array(lr())\n\nC = np.array(lr())\n\nV -= C\n\nV = V[V>0]\n\nanswer = V.sum()\n\nprint(answer)\n", "generated_code": "# coding: utf-8\n\nimport sys\n\n\n\nsr = lambda: sys.stdin.readline().rstrip()\n\nir = lambda: int(sr())\n\nlr = lambda: list(map(int, sr().split()))\n\n\n\nN = ir()\n\nV = lr()\n\nC = lr()\n\ntotal = 0\n\nfor i in range(N):\n\n    result = V[i] - C[i]\n\n    if result > 0:\n\n        total += result\n\n\n\nprint(total)\n", "score": 1.0, "codebleu": 0.5279808953688327, "crystalbleu": 0.0, "codebertscore": 0.88, "codescore": 0.23328931629657745, "surfaceSim": 0.7687135813536531, "abs_surfaceSim_minus_score": 0.23128641864634691}
{"golden_code": "def examB():\n\n    N = I(); A = [I() for _ in range(N)]\n\n    ans = 0; cur= 0\n\n    for i in A:\n\n        if i==0:\n\n            ans += cur//2\n\n            cur = 0\n\n        else:\n\n            cur += i\n\n    ans += cur // 2\n\n    print(ans)\n\n    return\n\n\n\nimport sys,copy,bisect,itertools,heapq,math\n\nfrom heapq import heappop,heappush,heapify\n\nfrom collections import Counter,defaultdict,deque\n\ndef I(): return int(sys.stdin.readline())\n\ndef LI(): return list(map(int,sys.stdin.readline().split()))\n\ndef LSI(): return list(map(str,sys.stdin.readline().split()))\n\ndef LS(): return sys.stdin.readline().split()\n\ndef SI(): return sys.stdin.readline().strip()\n\nmod = 10**9 + 7\n\ninf = float('inf')\n\n\n\nif __name__ == '__main__':\n\n    examB()\n", "generated_code": "def examA():\n\n    S = SI()\n\n    if \"W\" in S and not \"E\" in S:\n\n        print(\"No\")\n\n    elif \"E\" in S and not \"W\" in S:\n\n        print(\"No\")\n\n    elif \"N\" in S and not \"S\" in S:\n\n        print(\"No\")\n\n    elif \"S\" in S and not \"N\" in S:\n\n        print(\"No\")\n\n    else:\n\n        print(\"Yes\")\n\n    return\n\n\n\ndef examB():\n\n    N = I()\n\n    A = [I()for _ in range(N)]\n\n    ans = 0\n\n    for i in range(N-1):\n\n        ans += A[i]//2\n\n        if A[i]%2 and A[i+1]>=1:\n\n            ans += 1\n\n            A[i+1] -= 1\n\n    ans += A[N-1]//2\n\n    print(ans)\n\n    return\n\n\n\ndef examC():\n\n    ans = 0\n\n    print(ans)\n\n    return\n\n\n\ndef examD():\n\n    N = I()\n\n    S = [I()for _ in range(N)]\n\n\n\n    ans = 0\n\n    print(ans)\n\n    return\n\n\n\ndef examE():\n\n    ans = 0\n\n    print(ans)\n\n    return\n\n\n\ndef examF():\n\n    ans = 0\n\n    print(ans)\n\n    return\n\n\n\nimport sys,bisect,itertools,heapq,math,random\n\nfrom copy import deepcopy\n\nfrom heapq import heappop,heappush,heapify\n\nfrom collections import Counter,defaultdict,deque\n\ndef I(): return int(sys.stdin.readline())\n\ndef LI(): return list(map(int,sys.stdin.readline().split()))\n\ndef LSI(): return list(map(str,sys.stdin.readline().split()))\n\ndef LS(): return sys.stdin.readline().split()\n\ndef SI(): return sys.stdin.readline().strip()\n\nglobal mod,mod2,inf,alphabet,_ep\n\nmod = 10**9 + 7\n\nmod2 = 998244353\n\ninf = 10**18\n\n_ep = 10**(-12)\n\nalphabet = [chr(ord('a') + i) for i in range(26)]\n\n\n\nsys.setrecursionlimit(10**6)\n\n\n\nif __name__ == '__main__':\n\n    examB()\n\n\n\n\"\"\"\n\n\n\n\"\"\"", "score": 1.0, "codebleu": 0.5713942112196712, "crystalbleu": 0.34180008068649, "codebertscore": 0.86, "codescore": 0.059810053557157516, "surfaceSim": 0.6496185610302352, "abs_surfaceSim_minus_score": 0.3503814389697648}
{"golden_code": "#!usr/bin/env python3\n\nfrom collections import defaultdict\n\nfrom collections import deque\n\nfrom heapq import heappush, heappop\n\nimport sys\n\nimport math\n\nimport bisect\n\nimport random\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\n\ndef I(): return int(sys.stdin.readline())\n\ndef LS():return list(map(list, sys.stdin.readline().split()))\n\ndef S(): return list(sys.stdin.readline())[:-1]\n\ndef IR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = I()\n\n    return l\n\ndef LIR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = LI()\n\n    return l\n\ndef SR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = S()\n\n    return l\n\ndef LSR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = SR()\n\n    return l\n\nmod = 1000000007\n\n\n\n#A\n\n\"\"\"\n\ndef gcd(a,b):\n\n    if a == 0:\n\n        return b\n\n    return gcd(b%a,a)\n\nn = I()\n\na = IR(n)\n\nl = a[0]\n\nfor i in range(1,n):\n\n    g = gcd(l,a[i])\n\n    l *= a[i]//g\n\nprint(l)\n\n\"\"\"\n\n\n\n#B\n\nn = I()\n\nv = [[] for i in range(n)]\n\nfor i in range(n-1):\n\n    a,b,c = LI()\n\n    a -= 1\n\n    b -= 1\n\n    v[a].append([b,c])\n\n    v[b].append([a,c])\n\nQ,k = LI()\n\nd = [-1 for i in range(n)]\n\nd[k-1] = 0\n\nq = deque()\n\nq.append(k-1)\n\nwhile q:\n\n    x = q.pop()\n\n    for y,c in v[x]:\n\n        if d[y] == -1:\n\n            d[y] = d[x]+c\n\n            q.append(y)\n\nfor i in range(Q):\n\n    x,y = LI()\n\n    x -= 1\n\n    y -= 1\n\n    print((d[x]+d[y]))\n\n#C\n\n\n\n#D\n\n\n\n#E\n\n\n\n#F\n\n\n\n#G\n\n\n\n#H\n\n\n\n#I\n\n\n\n#J\n\n\n\n#K\n\n\n\n#L\n\n\n\n#M\n\n\n\n#N\n\n\n\n#O\n\n\n\n#P\n\n\n\n#Q\n\n\n\n#R\n\n\n\n#S\n\n\n\n#T\n", "generated_code": "#!usr/bin/env python3\n\nfrom collections import defaultdict\n\nfrom collections import deque\n\nfrom heapq import heappush, heappop\n\nimport sys\n\nimport math\n\nimport bisect\n\nimport random\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\n\ndef I(): return int(sys.stdin.readline())\n\ndef LS():return list(map(list, sys.stdin.readline().split()))\n\ndef S(): return list(sys.stdin.readline())[:-1]\n\ndef IR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = I()\n\n    return l\n\ndef LIR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = LI()\n\n    return l\n\ndef SR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = S()\n\n    return l\n\ndef LSR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = SR()\n\n    return l\n\nmod = 1000000007\n\n\n\n#A\n\n\"\"\"\n\ndef gcd(a,b):\n\n    if a == 0:\n\n        return b\n\n    return gcd(b%a,a)\n\nn = I()\n\na = IR(n)\n\nl = a[0]\n\nfor i in range(1,n):\n\n    g = gcd(l,a[i])\n\n    l *= a[i]//g\n\nprint(l)\n\n\"\"\"\n\n\n\n#B\n\nn = I()\n\nv = [[] for i in range(n)]\n\nfor i in range(n-1):\n\n    a,b,c = LI()\n\n    a -= 1\n\n    b -= 1\n\n    v[a].append([b,c])\n\n    v[b].append([a,c])\n\nQ,k = LI()\n\nd = [-1 for i in range(n)]\n\nd[k-1] = 0\n\nq = deque()\n\nq.append(k-1)\n\nwhile q:\n\n    x = q.popleft()\n\n    for y,c in v[x]:\n\n        if d[y] == -1:\n\n            d[y] = d[x]+c\n\n            q.append(y)\n\nfor i in range(Q):\n\n    x,y = LI()\n\n    x -= 1\n\n    y -= 1\n\n    print((d[x]+d[y]))\n\n#C\n\n\n\n#D\n\n\n\n#E\n\n\n\n#F\n\n\n\n#G\n\n\n\n#H\n\n\n\n#I\n\n\n\n#J\n\n\n\n#K\n\n\n\n#L\n\n\n\n#M\n\n\n\n#N\n\n\n\n#O\n\n\n\n#P\n\n\n\n#Q\n\n\n\n#R\n\n\n\n#S\n\n\n\n#T\n", "score": 1.0, "codebleu": 0.9947836058319586, "crystalbleu": 0.9911907013092056, "codebertscore": 1.0, "codescore": 0.9882578253746033, "surfaceSim": 0.9987021414665802, "abs_surfaceSim_minus_score": 0.0012978585334197934}
{"golden_code": "k,s=list(map(int,input().split()))\n\nans=chk=0\n\nfor i in range(k+1):\n\n    for j in range(k+1):\n\n        if (0<=s-i-j<=k): ans+=1\n\nprint(ans)", "generated_code": "k,s=list(map(int,input().split()))\n\nans=0\n\nx=min(k+1,s+1)\n\ny=max(0,s-k-k)\n\nfor i in range(y,x):\n\n    for j in range(y,x):\n\n        if i+j>s: break\n\n        if 0<=s-i-j<=k:\n\n            ans+=1\n\nprint(ans)", "score": 1.0, "codebleu": 0.388507680535213, "crystalbleu": 0.0, "codebertscore": 0.91, "codescore": 0.8220778107643127, "surfaceSim": 0.8268472906403941, "abs_surfaceSim_minus_score": 0.17315270935960592}
{"golden_code": "from collections import Counter\n\n\n\nN = int(eval(input()))\n\ninputs = [int(i) for i in input().split()]\n\n\n\nans = 0\n\nruisekiwa = [0] * (N+1)\n\n\n\nfor i in range(N):\n\n    ruisekiwa[i+1] = ruisekiwa[i] + inputs[i]\n\n\n\nruisekiwa = ruisekiwa[1:]\n\nruisekiwa.sort()\n\ncounter_ruiseki = Counter(ruisekiwa)\n\n\n\nfor key, value in list(counter_ruiseki.items()):\n\n    if key == 0 and value == 1:\n\n        ans += value\n\n        continue\n\n    elif key == 0 and value > 1:\n\n        ans += value\n\n    if value > 1:\n\n        ans += sum(list(range(value)))\n\n\n\nprint(ans)\n", "generated_code": "from collections import Counter\n\nfrom itertools import accumulate\n\n\n\nN = int(eval(input()))\n\ninputs = [int(i) for i in input().split()]\n\n\n\nans = 0\n\n\n\nruisekiwa = list(accumulate(inputs))\n\nruisekiwa.sort()\n\ncounter_ruiseki = Counter(ruisekiwa)\n\n\n\nfor key, value in list(counter_ruiseki.items()):\n\n    if key == 0 and value == 1:\n\n        ans += value\n\n        continue\n\n    elif key == 0 and value > 1:\n\n        ans += value\n\n    if value > 1:\n\n        ans += sum(list(range(value)))\n\n\n\nprint(ans)\n", "score": 1.0, "codebleu": 0.6536245096727219, "crystalbleu": 0.6488632351815146, "codebertscore": 0.93, "codescore": 0.8304651975631714, "surfaceSim": 0.802930402930403, "abs_surfaceSim_minus_score": 0.19706959706959704}
{"golden_code": "N = int(eval(input()))\n\nA = list(map(int, input().split()))\n\n# 中央値\n\nB = []\n\nfor i in range(N):\n\n    B.append(A[i] - (i+1))\n\nb = sorted(B)[N//2]\n\n\n\nans = 0\n\nfor i in range(N):\n\n    ans += abs(A[i] - (i + 1) - b)\n\n\n\nprint(ans)\n\n\n", "generated_code": "from statistics import median_low\n\n\n\nN = int(eval(input()))\n\nA = list(map(int, input().split()))\n\n\n\nD = []\n\nfor i in range(N):\n\n    D.append(A[i] - (i+1))\n\n\n\nm = median_low(D)\n\nans = 0\n\nfor d in D:\n\n    ans += abs(d - m)\n\n\n\nprint(ans)\n", "score": 1.0, "codebleu": 0.47752634309632747, "crystalbleu": 0.4896264606181011, "codebertscore": 0.88, "codescore": 0.9704909920692444, "surfaceSim": 0.7803191489361703, "abs_surfaceSim_minus_score": 0.21968085106382973}
{"golden_code": "def main():\n\n    import sys\n\n    input = sys.stdin.buffer.readline\n\n    N = int(input())\n\n    TXY = [[int(i) for i in input().split()] for j in range(N)]\n\n    time, px, py = 0, 0, 0\n\n    for t, x, y in TXY:\n\n        move = abs(x-px) + abs(y-py)\n\n        # print(move, t-time)\n\n        if (t - time) % 2 != move % 2 or t - time < move:\n\n            return print(\"No\")\n\n        time, px, py = t, x, y\n\n    print(\"Yes\")\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "generated_code": "def main():\n\n    import sys\n\n    input = sys.stdin.buffer.readline\n\n    N = int(input())\n\n    TXY = [[int(i) for i in input().split()] for j in range(N)]\n\n    time = 0\n\n    px = 0\n\n    py = 0\n\n    for t, x, y in TXY:\n\n        move = abs(py-y) + abs(px - x)\n\n        if (t-time) < move or (t - time) % 2 != move % 2:\n\n            return print(\"No\")\n\n        time = t\n\n        px = x\n\n        py = y\n\n    print(\"Yes\")\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 1.0, "codebleu": 0.7499934351144127, "crystalbleu": 0.7720239407891278, "codebertscore": 0.97, "codescore": 0.018372870981693268, "surfaceSim": 0.955531453362256, "abs_surfaceSim_minus_score": 0.04446854663774402}
{"golden_code": "K = int(eval(input()))\n\n\n\nflg = [False]*K\n\n\n\ntmp = 7 % K\n\ncnt = 1\n\nif tmp == 0:\n\n    print(cnt)\n\n    exit()\n\nwhile True:\n\n    tmp = (tmp*10+7)%K\n\n    if flg[tmp]:\n\n        print((-1))\n\n        break\n\n    else:\n\n        cnt += 1\n\n        if tmp == 0:\n\n            print(cnt)\n\n            break\n\n        flg[tmp] = True\n", "generated_code": "K = int(eval(input()))\n\nt = 7\n\nt %= K\n\n\n\nfor i in range(K+1):\n\n    if t == 0:\n\n        print((i+1))\n\n        exit()\n\n    t = (t*10+7)%K\n\nprint((-1))\n", "score": 1.0, "codebleu": 0.23309663087280003, "crystalbleu": 0.0, "codebertscore": 0.82, "codescore": 0.7718361020088196, "surfaceSim": 0.684748427672956, "abs_surfaceSim_minus_score": 0.31525157232704404}
{"golden_code": "import sys\n\nimport itertools\n\n# import numpy as np\n\nimport time\n\nimport math\n\n \n\nsys.setrecursionlimit(10 ** 7)\n\n \n\nfrom collections import defaultdict\n\n \n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n \n\n \n\nfrom functools import reduce\n\n# from math import *\n\nfrom fractions import *\n\nN, M = list(map(int, readline().split()))\n\nA = list(sorted([int(x) // 2 for x in readline().split()]))\n\nmin_cm = reduce(lambda a, b: (a * b) // gcd(a, b), A)\n\n \n\n# print(all(map(lambda x: (min_cm // x) % 2 == 1, A)))\n\nif not all([(min_cm // x) % 2 == 1 for x in A]):\n\n    print((0))\n\n    exit(0)\n\nif min_cm > M:\n\n    print((0))\n\n    exit(0)\n\nans = (M // min_cm + 1) // 2\n\nprint(ans)", "generated_code": "import sys\n\nimport itertools\n\n# import numpy as np\n\nimport time\n\nimport math\n\nimport heapq\n\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10 ** 7)\n\n \n\nINF = 10 ** 9 + 7\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\n# map(int, input().split())\n\n\n\nN, M = list(map(int, input().split()))\n\nA = list([int(x) // 2 for x in input().split()])\n\n\n\ndef f(n):\n\n    res = 0\n\n    while n % 2 == 0:\n\n        n //= 2\n\n        res += 1\n\n    return res\n\n\n\ndef gcd(a, b):\n\n    if b == 0:\n\n        return a\n\n    return gcd(b, a % b)\n\n\n\nx = f(A[0])\n\nfor a in A:\n\n    y = f(a)\n\n    if y != x:\n\n        print((0))\n\n        exit()\n\n\n\nlcm = A[0]\n\nfor i in range(1, N):\n\n    lcm = lcm * A[i] //  gcd(lcm, A[i])\n\n\n\nprint(((M // lcm + 1) // 2))", "score": 1.0, "codebleu": 0.4309126484399024, "crystalbleu": 0.37389331437846207, "codebertscore": 0.88, "codescore": 0.9938613176345825, "surfaceSim": 0.6538181095055018, "abs_surfaceSim_minus_score": 0.3461818904944982}
{"golden_code": "import sys\n\nsys.setrecursionlimit(100000)\n\nN, M = list(map(int, input().split()))\n\nedges = [list(map(int, input().split())) for _ in range(M)]\n\n\n\ngraph = [[] for _ in range(N)]\n\nfor x, y in edges:\n\n    graph[x - 1].append(y - 1)\n\n    graph[y - 1].append(x - 1)\n\n\n\ndef dfs(v, c):\n\n    # c: color = 1 or -1\n\n    node[v] = c\n\n    for i in graph[v]:\n\n        if node[i] == c:\n\n            return False\n\n        \n\n        if node[i] == 0 and not dfs(i, -c):\n\n            return False\n\n        \n\n    return True\n\n\n\nnode = [0] * N\n\nif dfs(0, 1):\n\n    x = sum(v + 1 for v in node) // 2\n\n    print((x * (N - x) - M))\n\nelse:\n\n    print((N * (N - 1) // 2 - M))\n", "generated_code": "from collections import deque\n\nN, M = list(map(int, input().split()))\n\nedges = [list(map(int, input().split())) for _ in range(M)]\n\n\n\ngraph = [[] for _ in range(N)]\n\nfor x, y in edges:\n\n    graph[x - 1].append(y - 1)\n\n    graph[y - 1].append(x - 1)\n\n\n\ndef dfs(s, c):\n\n    q = deque()\n\n    q.append(s)\n\n    visited[s] = True\n\n    color[s] = c\n\n    \n\n    while len(q) > 0:\n\n        v = q.pop()\n\n        for i in graph[v]:\n\n            if visited[i] and color[i] == color[v]:\n\n                return False\n\n            \n\n            if not visited[i]:\n\n                visited[i] = True\n\n                color[i] = -color[v]\n\n                q.append(i)\n\n                \n\n    return True\n\n\n\nvisited = [False] * N\n\ncolor = [0] * N\n\n\n\nif dfs(0, 1):\n\n    x = sum(v + 1 for v in color) // 2\n\n    print((x * (N - x) - M))\n\nelse:\n\n    print((N * (N - 1) // 2 - M))\n\n    \n\n    ", "score": 1.0, "codebleu": 0.7161617403669099, "crystalbleu": 0.6309638522975549, "codebertscore": 0.9, "codescore": 0.4129442572593689, "surfaceSim": 0.8375428335105755, "abs_surfaceSim_minus_score": 0.16245716648942454}
{"golden_code": "def main():\n\n\tn, ma, mb, *L = list(map(int, open(0).read().split()))\n\n\tM = 1<<30\n\n\tdp = [[M] * 420 for _ in range(420)]\n\n\tdp[0][0] = 0\n\n\tfor a, b, c in zip(*[iter(L)] * 3):\n\n\t\tfor i in range(400, -1, -1):\n\n\t\t\tfor j in range(400, -1, -1):\n\n\t\t\t\tt = dp[i][j] + c\n\n\t\t\t\tif dp[i + a][j + b] > t:\n\n\t\t\t\t\tdp[i + a][j + b] = t\n\n\tans = M\n\n\t_ma, _mb = ma, mb\n\n\twhile _ma < 410 > _mb:\n\n\t\tans = min(ans, dp[_ma][_mb])\n\n\t\t_ma += ma\n\n\t\t_mb += mb\n\n\tprint((ans if ans < M else -1))\n\n\n\nif __name__==\"__main__\":\n\n\tmain()", "generated_code": "def main():\n\n\tn, ma, mb, *L = list(map(int, open(0).read().split()))\n\n\tM = 1 << 30\n\n\tdp = [[M] * 420 for _ in range(420)]\n\n\tdp[0][0] = 0\n\n\tua = ub = 15\n\n\tfor a, b, c in zip(*[iter(L)] * 3):\n\n\t\tfor i in range(ua, -1, -1):\n\n\t\t\tfor j in range(ub, -1, -1):\n\n\t\t\t\tt = dp[i][j] + c\n\n\t\t\t\tif dp[i + a][j + b] > t:\n\n\t\t\t\t\tdp[i + a][j + b] = t\n\n\t\t\t\t\tif ua < i + a:\n\n\t\t\t\t\t\tua = i + a\n\n\t\t\t\t\tif ub < j + b:\n\n\t\t\t\t\t\tub = j + b\n\n\tans = M\n\n\t_ma, _mb = ma, mb\n\n\twhile _ma < 410 > _mb:\n\n\t\tans = min(ans, dp[_ma][_mb])\n\n\t\t_ma += ma\n\n\t\t_mb += mb\n\n\tprint((ans if ans < M else -1))\n\n\n\n\n\nif __name__ == \"__main__\":\n\n\tmain()\n", "score": 1.0, "codebleu": 0.7888409546721616, "crystalbleu": 0.8238017274344019, "codebertscore": 0.95, "codescore": 0.035122379660606384, "surfaceSim": 0.9590301003344481, "abs_surfaceSim_minus_score": 0.04096989966555187}
{"golden_code": "n, q = [ int( val ) for val in input( ).split( \" \" ) ]\n\nps = [0]*n\n\nt = [0]*n\n\nfor i in range( n ):\n\n\tps[i], t[i] = input( ).split( \" \" )\n\n\n\n\n\noutput = []\n\nqsum = 0\n\nwhile t:\n\n\tpsi = ps.pop( 0 )\n\n\tti = int( t.pop( 0 ) )\n\n\tif ti <= q:\n\n\t\tqsum += ti\t\n\n\t\toutput.append( psi+\" \"+str( qsum ) )\n\n\telse:\n\n\t\tt.append( ti - q )\n\n\t\tps.append( psi )\n\n\t\tqsum += q\n\n\n\nprint(( \"\\n\".join( output ) ))", "generated_code": "n, q = [ int( val ) for val in input( ).split( \" \" ) ]\n\nps = [0]*n\n\nt = [0]*n\n\nfor i in range( n ):\n\n    ps[i], t[i] = input( ).split( \" \" )\n\n \n\n \n\noutput = []\n\nqsum = 0\n\nwhile t:\n\n    psi = ps.pop( 0 )\n\n    ti = int( t.pop( 0 ) )\n\n    if ti <= q:\n\n        qsum += ti\n\n        output.append( \"\".join( ( psi, \" \", str( qsum ) ) ) )\n\n    else:\n\n        t.append( ti - q )\n\n        ps.append( psi )\n\n        qsum += q\n\n \n\nprint(( \"\\n\".join( output ) ))", "score": 1.0, "codebleu": 0.9169507813983201, "crystalbleu": 0.9072327470401259, "codebertscore": 0.97, "codescore": 0.6796579360961914, "surfaceSim": 0.9855233853006682, "abs_surfaceSim_minus_score": 0.014476614699331813}
{"golden_code": "import sys\n\ninput = sys.stdin.readline\n\nH, W = [int(x) for x in input().split()]\n\na = []\n\nfor _ in range(H):\n\n    a.append(list(input().rstrip()))\n\nimport numpy as np\n\na = np.array(a, np.object)\n\na = a.T\n\nretsu = []\n\ngyou = []\n\nfor i in range(W):\n\n    if \"#\" not in a[i]:\n\n        retsu.append(i)\n\na = a.T\n\nfor i in range(H):\n\n    if \"#\" not in a[i]:\n\n        gyou.append(i)\n\na = np.delete(a, retsu, 1)\n\na = np.delete(a, gyou, 0)\n\nfor j in a:\n\n    j = list(j)\n\n    print((\"\".join(j)))", "generated_code": "import sys\n\ninput = sys.stdin.readline\n\n\n\nh, w = [int(x) for x in input().split()]\n\na = []\n\nfor _ in range(h):\n\n    b = list(input().rstrip())\n\n    if '#' in b:\n\n        a.append(b)\n\nh = len(a)\n\nc = [1]*w\n\nfor i in range(w):\n\n    flag = 1\n\n    for j in range(h):\n\n        if a[j][i] == \"#\":\n\n            flag = 0\n\n            break\n\n    if flag:\n\n        c[i] = 0\n\nans = []\n\nfor i in range(h):\n\n    res = []\n\n    for j in range(w):\n\n        if c[j]:\n\n            res.append(a[i][j])\n\n    ans.append(\"\".join(res))\n\nfor i in ans:\n\n    print(i)\n\n\n", "score": 1.0, "codebleu": 0.4619863868757336, "crystalbleu": 0.315765857184889, "codebertscore": 0.85, "codescore": 0.16455255448818207, "surfaceSim": 0.7035492081447965, "abs_surfaceSim_minus_score": 0.2964507918552035}
{"golden_code": "import sys\n\ndef input(): return sys.stdin.readline().strip()\n\n\n\ndef resolve():\n\n    import math\n\n    n=int(eval(input()))\n\n    print((math.factorial(n)%(10**9+7)))\n\nresolve()", "generated_code": "import sys\n\ndef input(): return sys.stdin.readline().strip()\n\n\n\ndef resolve():\n\n    answer=1\n\n    n=int(eval(input()))\n\n    for i in range(1,n+1):\n\n        answer*=i\n\n        answer%=10**9+7\n\n    print(answer)\n\nresolve()", "score": 1.0, "codebleu": 0.6072486084788974, "crystalbleu": 0.0, "codebertscore": 0.91, "codescore": 0.44684696197509766, "surfaceSim": 0.8103896103896104, "abs_surfaceSim_minus_score": 0.18961038961038956}
{"golden_code": "H,W = list(map(int,input().split()))\n\nN = int(eval(input()))\n\nA = list(map(int,input().split()))\n\nA.insert(0,0)\n\nC = [[0 for _ in range(W)] for _ in range(H)]\n\ncur = [0,0,\"R\"]\n\nfor k in range(1,N+1):\n\n#     ipdb.set_trace()\n\n    a = A[k]\n\n    cnt = 0\n\n    y,x,d = cur\n\n    for i in range(y,H):\n\n        y = i\n\n        if d==\"R\":\n\n            for j in range(x,W):\n\n                C[i][j]=str(k)\n\n                cnt += 1\n\n                if j+1<W:\n\n                    x = j+1\n\n                else:\n\n                    x = j\n\n                if cnt==a:break\n\n            if cnt==a:break\n\n            d=\"L\"\n\n        else:\n\n            for j in range(x,-1,-1):\n\n                C[i][j]=str(k)\n\n                cnt += 1\n\n                if j>=1:\n\n                    x = j-1\n\n                else:\n\n                    x = 0\n\n                if cnt==a:break\n\n            if cnt==a:break\n\n            d=\"R\"\n\n    if x==W-1:\n\n        if C[y][x]!=0:\n\n            y += 1\n\n            d=\"L\"\n\n    elif x==0:\n\n        if C[y][x]!=0:\n\n            y += 1\n\n            d=\"R\"\n\n    cur = [y,x,d]                \n\nfor i in range(H):\n\n    print((*C[i]))", "generated_code": "H,W = list(map(int,input().split()))\n\nN = int(eval(input()))\n\nA = list(map(int,input().split()))\n\nA.insert(0,0)\n\nB = [[0 for _ in range(W)] for _ in range(H)]\n\ncol = 1\n\ncnt = 0\n\ny = 0\n\nx = 0\n\nd = \"R\"\n\nwhile y<H:\n\n    if cnt<A[col]:\n\n        B[y][x] = col\n\n        cnt += 1\n\n    else:\n\n        col += 1\n\n        cnt = 0\n\n        B[y][x] = col\n\n        cnt += 1\n\n    if x<W-1 and d==\"R\":\n\n        x += 1\n\n    elif x==W-1 and d==\"R\":\n\n        y += 1\n\n        d = \"L\"\n\n    elif d==\"L\" and x>0:\n\n        x -= 1\n\n    elif d==\"L\" and x==0:\n\n        y += 1\n\n        d = \"R\"\n\nfor i in range(H):\n\n    print((*B[i]))", "score": 1.0, "codebleu": 0.37860347117124504, "crystalbleu": 0.3481250876124271, "codebertscore": 0.88, "codescore": 0.45313772559165955, "surfaceSim": 0.7328884060220395, "abs_surfaceSim_minus_score": 0.26711159397796047}
{"golden_code": "S, T = [list(eval(input())) for _ in range(2)]\n\ncnt = 0\n\nfor i in range(len(S)):\n\n    if S[i] != T[i]:\n\n        cnt += 1\n\nprint(cnt)\n", "generated_code": "s, t = [eval(input()) for i in range(2)]\n\nans = 0\n\nfor i in range(len(s)):\n\n  if s[i] != t[i]:\n\n    ans += 1\n\nprint(ans)", "score": 1.0, "codebleu": 0.3752654526811446, "crystalbleu": 0.0, "codebertscore": 0.93, "codescore": 0.7749332785606384, "surfaceSim": 0.9323308270676691, "abs_surfaceSim_minus_score": 0.06766917293233088}
{"golden_code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\n\n\nsys.setrecursionlimit(10**7)\n\ninf = 10**20\n\neps = 1.0 / 10**15\n\nmod = 10**9+7\n\n\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\n\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\n\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\n\ndef LS(): return sys.stdin.readline().split()\n\ndef I(): return int(sys.stdin.readline())\n\ndef F(): return float(sys.stdin.readline())\n\ndef S(): return input()\n\ndef pf(s): return print(s, flush=True)\n\ndef divisions(n):\n\n    sq = int(math.sqrt(n)+1)\n\n    d = collections.defaultdict(int)\n\n    while n % 2 == 0:\n\n        n //= 2\n\n        d[2] += 1\n\n    i = 3\n\n    while n > 1 and sq >= i:\n\n        if n % i == 0:\n\n            n //= i\n\n            d[i] += 1\n\n        else:\n\n            i += 2\n\n\n\n    if n > 1:\n\n        d[n] += 1\n\n\n\n    r = [1]\n\n    for k, v in d.items():\n\n        for c in r[:]:\n\n            for i in range(1,v+1):\n\n                r.append(c*(k**i))\n\n\n\n    return sorted(r)\n\n\n\ndef main():\n\n    n = I()\n\n    a = LI()\n\n    s = set()\n\n    for i in range(n,0,-1):\n\n        d = divisions(i)\n\n        ld = len(d)\n\n        for j in range(1,2**ld):\n\n            c = []\n\n            ff = True\n\n            for k in range(ld):\n\n                if j & (1<<k):\n\n                    f = True\n\n                    for e in c:\n\n                        if d[k] % e == 0:\n\n                            f = False\n\n                            ff = False\n\n                            break\n\n                    if f:\n\n                        c.append(d[k])\n\n                if not ff:\n\n                    break\n\n            if ff:\n\n                s.add(tuple(c + [n+1]))\n\n    b = sorted(list(s), reverse=True)\n\n    for c in b:\n\n        t = 0\n\n        for j in range(1,n+1):\n\n            f = False\n\n            for e in c:\n\n                if j%e == 0:\n\n                    f = True\n\n                    break\n\n            if f:\n\n                t += a[j-1]\n\n        if t < 0:\n\n            for j in range(1,n+1):\n\n                f = False\n\n                for e in c:\n\n                    if j%e == 0:\n\n                        f = True\n\n                        break\n\n                if f:\n\n                    a[j-1] = 0\n\n\n\n    return sum(a)\n\n\n\n\n\n\n\nprint(main())\n\n\n\n\n", "generated_code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,copy,functools\n\nimport time,random\n\n\n\nsys.setrecursionlimit(10**7)\n\ninf = 10**20\n\neps = 1.0 / 10**10\n\nmod = 10**9+7\n\nmod2 = 998244353\n\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\n\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\n\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\n\ndef LLI(): return [list(map(int, l.split())) for l in sys.stdin.readlines()]\n\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\n\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\n\ndef LS(): return sys.stdin.readline().split()\n\ndef I(): return int(sys.stdin.readline())\n\ndef F(): return float(sys.stdin.readline())\n\ndef S(): return input()\n\ndef pf(s): return print(s, flush=True)\n\ndef pe(s): return print(str(s), file=sys.stderr)\n\ndef JA(a, sep): return sep.join(map(str, a))\n\ndef JAA(a, s, t): return s.join(t.join(map(str, b)) for b in a)\n\n\n\n\n\nclass Flow():\n\n    def __init__(self, e, N):\n\n        self.E = e\n\n        self.N = N\n\n\n\n    def max_flow(self, s, t):\n\n        r = 0\n\n        e = self.E\n\n\n\n        def f(c, cap):\n\n            v = self.v\n\n            v[c] = 1\n\n            if c == t:\n\n                return cap\n\n            for i in range(self.N):\n\n                if v[i] or e[c][i] <= 0:\n\n                    continue\n\n                cp = min(cap, e[c][i])\n\n                k = f(i, cp)\n\n                if k > 0:\n\n                    e[c][i] -= k\n\n                    e[i][c] += k\n\n                    return k\n\n            return 0\n\n\n\n        while True:\n\n            self.v = [None] * self.N\n\n            fs = f(s, inf)\n\n            if fs == 0:\n\n                break\n\n            r += fs\n\n\n\n        return r\n\n\n\n\n\ndef main():\n\n    n = I()\n\n    a = LI()\n\n\n\n    s = n\n\n    t = n + 1\n\n    e = [[0] * (n+2) for _ in range(n+2)]\n\n    for i in range(n):\n\n        c = a[i]\n\n        if c < 0:\n\n            e[s][i] = -c\n\n            ii = i + 1\n\n            for j in range(ii*2, n+1, ii):\n\n                e[i][j-1] = inf\n\n        else:\n\n            e[i][t] = c\n\n\n\n\n\n    fl = Flow(e, n+2)\n\n    r = fl.max_flow(s,t)\n\n\n\n    return sum(map(lambda x: max(0,x), a)) - r\n\n\n\n# start = time.time()\n\nprint(main())\n\n# pe(time.time() - start)\n\n\n\n\n\n\n", "score": 1.0, "codebleu": 0.35906984319404855, "crystalbleu": 0.3599668984761092, "codebertscore": 0.85, "codescore": 0.9939075112342834, "surfaceSim": 0.6972525481670526, "abs_surfaceSim_minus_score": 0.3027474518329474}
{"golden_code": "import itertools\n\nfrom collections import Counter\n\nN = int(eval(input()))\n\nsrc = [eval(input()) for i in range(N)]\n\nctr = Counter()\n\nfor s in src:\n\n    ctr[s[0]] += 1\n\n\n\nans = 0\n\nfor ptn in itertools.combinations('MARCH',3):\n\n    a,b,c = ptn\n\n    ans += ctr[a]*ctr[b]*ctr[c]\n\nprint(ans)", "generated_code": "N = int(eval(input()))\n\nS = [eval(input()) for i in range(N)]\n\nfrom collections import Counter\n\nctr = Counter([s[0] for s in S])\n\n\n\nans = 0\n\nimport itertools\n\nfor ptn in itertools.combinations('MARCH', 3):\n\n    t = 1\n\n    for c in ptn:\n\n        t *= ctr[c]\n\n    ans += t\n\nprint(ans)", "score": 1.0, "codebleu": 0.4104047494648608, "crystalbleu": 0.46036999033114373, "codebertscore": 0.93, "codescore": 0.6179091334342957, "surfaceSim": 0.7220279720279721, "abs_surfaceSim_minus_score": 0.2779720279720279}
{"golden_code": "def mi():return list(map(int,input().split()))\n\nimport numpy as np\n\nA,B,M=mi()\n\na=np.array(list(mi()))\n\nb=np.array(list(mi()))\n\nminab=min(a)+min(b)\n\n\n\nans=float(\"inf\")\n\n\n\nfor i in range(M):\n\n    x,y,c=mi()\n\n    tmp=a[x-1]+b[y-1]-c\n\n    ans=min(ans,tmp)\n\nprint((min(ans,minab)))\n", "generated_code": "def mi():return list(map(int,input().split()))\n\nA,B,M=mi()\n\na=list(mi())\n\nb=list(mi())\n\nans=min(a)+min(b)\n\nfor _ in range(M):\n\n    x,y,c=mi()\n\n    ans=min(ans,a[x-1]+b[y-1]-c)\n\nprint(ans)", "score": 1.0, "codebleu": 0.28488932205047557, "crystalbleu": 0.5744646408269557, "codebertscore": 0.93, "codescore": 0.5917640328407288, "surfaceSim": 0.7761219595751969, "abs_surfaceSim_minus_score": 0.22387804042480308}
{"golden_code": "n = int(eval(input()))\n\nary = list(map(int, input().split()))\n\n#print(n,ary)\n\n\n\nary_2 = [ary[0]]\n\nfor i in range(1, n):\n\n    ary_2.append(ary[i] + ary_2[i-1])\n\nary_2 = [0] + ary_2\n\n#print(ary_2)\n\n\n\nfrom collections import Counter\n\nc = Counter(ary_2)\n\nv = (list(c.values()))\n\n#print(v)\n\n\n\nfrom math import factorial\n\ndef combinations_count(n, r):\n\n    return factorial(n) // (factorial(n - r) * factorial(r))\n\n\n\nans = 0\n\nfor j in v:\n\n    if j >1:\n\n        ans += combinations_count(j,2)\n\n\n\nprint(ans)", "generated_code": "n = int(eval(input()))\n\nary = list(map(int, input().split()))\n\n#print(n,ary)\n\n\n\nary_2 = [ary[0]]\n\nfor i in range(1, n):\n\n    ary_2.append(ary[i] + ary_2[i-1])\n\nary_2 = [0] + ary_2\n\n#print(ary_2)\n\n\n\nfrom collections import Counter\n\nc = Counter(ary_2)\n\nv = (list(c.values()))\n\n#print(v)\n\n\n\nans = 0\n\nfor j in v:\n\n    if j >1:\n\n        ans += j * (j-1) // 2\n\n\n\nprint(ans)\n", "score": 1.0, "codebleu": 0.7254718097949892, "crystalbleu": 0.7286698001917592, "codebertscore": 0.95, "codescore": 0.34814295172691345, "surfaceSim": 0.8043229315774405, "abs_surfaceSim_minus_score": 0.1956770684225595}
{"golden_code": "n = int(eval(input()))\n\n\n\nfelicidade = []\n\n\n\nfor x in range(n):\n\n    felicidade.append(list(map(int,input().split())))\n\n\n\nDP = [0,0,0]\n\n\n\nif n == 1:\n\n    print((max(felicidade[0])))\n\n\n\nelse:\n\n\n\n    for x in range(3):\n\n        DP[x] = felicidade[0][x]\n\n\n\n\n\n    for dia in range(1,n):\n\n        m = [0] * 3\n\n        for x  in range(3):#As duas possíveis escolhas são x e y\n\n            for y  in range(3):\n\n                if x != y: #Se elas forem diferentes\n\n                    m[x] = max(m[x], DP[y] + felicidade[dia][x])\n\n        DP = m\n\n    \n\n    print((max(DP)))\n", "generated_code": "nDays = int(eval(input()))\n\n\n\ntoday = [int(x) for x in input().split()]\n\n\n\nfor i in range(nDays - 1):\n\n    tomorrow = [int(x) for x in input().split()]\n\n    tomorrow[0] += max(today[1], today[2])\n\n    tomorrow[1] += max(today[0], today[2])\n\n    tomorrow[2] += max(today[0], today[1])\n\n    today = tomorrow\n\n\n\nprint((max(today)))", "score": 1.0, "codebleu": 0.16521526840636913, "crystalbleu": 0.11115898610601531, "codebertscore": 0.72, "codescore": 0.5693413019180298, "surfaceSim": 0.5835537918871252, "abs_surfaceSim_minus_score": 0.4164462081128748}
{"golden_code": "#!usr/bin/env python3\n\nfrom collections import defaultdict\n\nfrom collections import deque\n\nfrom heapq import heappush, heappop\n\nimport sys\n\nimport math\n\nimport bisect\n\nimport random\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\n\ndef I(): return int(sys.stdin.readline())\n\ndef LS():return list(map(list, sys.stdin.readline().split()))\n\ndef S(): return list(sys.stdin.readline())[:-1]\n\ndef IR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = I()\n\n    return l\n\ndef LIR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = LI()\n\n    return l\n\ndef SR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = S()\n\n    return l\n\ndef LSR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = SR()\n\n    return l\n\nmod = 1000000007\n\n\n\n#A\n\ndef A():\n\n    s = S()\n\n    t = S()\n\n    if s+t == t[::-1]+s[::-1]:\n\n        print(\"YES\")\n\n    else:\n\n        print(\"NO\")\n\n\n\n#B\n\ndef B():\n\n    n = I()\n\n    for i in range(int(n**0.5)+2)[::-1]:\n\n        if i*i <= n:\n\n            print((i*i))\n\n            quit()\n\n#C\n\ndef C():\n\n    n = I()\n\n    a = LI()\n\n    b = LI()\n\n    c = LI()\n\n    q = [0 for i in range(n)]\n\n    ans = 0\n\n    a.sort()\n\n    b.sort()\n\n    c.sort()\n\n    for i in range(n):\n\n        j = bisect.bisect_left(a,b[i])\n\n        q[i] = j\n\n    for i in range(n-1):\n\n        q[i+1] += q[i]\n\n    q.insert(0,0)\n\n    for i in range(n):\n\n        j = bisect.bisect_left(b,c[i])\n\n        ans += q[j]\n\n    print(ans)\n\n#D\n\ndef D():\n\n    def dijkstra():\n\n        d = [float(\"inf\") for i in range(k)]\n\n        q = [[0,1]]\n\n        d[1] = 0\n\n        while q:\n\n            dx,x = heappop(q)\n\n            for y,dy in v[x]:\n\n                if d[y] > dx+dy:\n\n                    d[y] = dx+dy\n\n                    heappush(q,[d[y],y])\n\n        print((d[0]+1))\n\n    k = I()\n\n    if k == 1:\n\n        print((1))\n\n        quit()\n\n    v = [[] for i in range(k)]\n\n    for i in range(1,k):\n\n        v[i].append([(i+1)%k,1])\n\n        v[i].append([i*10%k,0])\n\n    dijkstra()\n\n#E\n\ndef E():\n\n    return\n\n\n\n#F\n\ndef F():\n\n    return\n\n\n\n#G\n\ndef G():\n\n    return\n\n\n\n#H\n\ndef H():\n\n    return\n\n\n\n#Solve\n\nif __name__ == \"__main__\":\n\n    D()\n", "generated_code": "#!usr/bin/env python3\n\nfrom collections import defaultdict,deque\n\nfrom heapq import heappush, heappop\n\nfrom itertools import permutations\n\nimport sys\n\nimport math\n\nimport bisect\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\n\ndef I(): return int(sys.stdin.readline())\n\ndef LS():return [list(x) for x in sys.stdin.readline().split()]\n\ndef S():\n\n    res = list(sys.stdin.readline())\n\n    if res[-1] == \"\\n\":\n\n        return res[:-1]\n\n    return res\n\ndef IR(n):\n\n    return [I() for i in range(n)]\n\ndef LIR(n):\n\n    return [LI() for i in range(n)]\n\ndef SR(n):\n\n    return [S() for i in range(n)]\n\ndef LSR(n):\n\n    return [LS() for i in range(n)]\n\n\n\nsys.setrecursionlimit(1000000)\n\nmod = 1000000007\n\n\n\ndef solve():\n\n    def v(n):\n\n        return [n*10%k, (n+1)%k]\n\n    k = I()\n\n    d = [float(\"inf\")]*k\n\n    d[1] = 1\n\n    q = deque([1])\n\n    while q:\n\n        x = q.popleft()\n\n        vx = v(x)\n\n        dx = d[x]\n\n        for c in range(2):\n\n            nd = dx+c\n\n            y = vx[c]\n\n            if nd < d[y]:\n\n                d[y] = nd\n\n                if c:\n\n                    q.append(y)\n\n                else:\n\n                    q.appendleft(y)\n\n    print((d[0]))\n\n    return\n\n\n\n#Solve\n\nif __name__ == \"__main__\":\n\n    solve()\n", "score": 1.0, "codebleu": 0.2713719993079432, "crystalbleu": 0.17779582378077483, "codebertscore": 0.87, "codescore": 0.018265724182128906, "surfaceSim": 0.7120391705069125, "abs_surfaceSim_minus_score": 0.28796082949308754}
{"golden_code": "# 参考 https://atcoder.jp/contests/abc133/submissions/7966658\n\n\n\nimport numpy as np\n\n\n\ndef abc133_c():\n\n    L, R = list(map(int, input().split()))\n\n    if R - L > 673: return 0\n\n    x = np.arange(L, R+1, dtype=np.int64)\n\n    #y = x[:, None] * x[None, :] % 2019\n\n    y = x.reshape(-1, 1) * x.reshape(1, -1)  # 区間内のすべての組合せの積\n\n    y %= 2019\n\n    np.fill_diagonal(y, 2019)  # 対角成分は無視する (同じ数を2回選べない) のでinf値で埋める\n\n    return y.min()\n\n\n\nprint((abc133_c()))", "generated_code": "def abc133_c():\n\n    L, R = list(map(int, input().split()))\n\n    # 区間の幅が673あれば、673の倍数と3の倍数が含まれて、2019の倍数が作れる\n\n    if R - L > 673: return 0\n\n    # それ以外は試す\n\n    ans = 2019\n\n    for i in range(L, R+1):\n\n        for j in range(L, i):\n\n            m = i * j % 2019\n\n            ans = min(m, ans)\n\n    return ans\n\n\n\nprint((abc133_c()))", "score": 1.0, "codebleu": 0.3066552397176058, "crystalbleu": 0.0, "codebertscore": 0.77, "codescore": 0.8392629623413086, "surfaceSim": 0.7617713004484306, "abs_surfaceSim_minus_score": 0.23822869955156944}
{"golden_code": "import sys\n\ninput = sys.stdin.readline\n\nfrom collections import *\n\n\n\ndef dfs(x, y):\n\n    if x==0 and y==0:\n\n        t[x][y] = False\n\n        return False\n\n    \n\n    if x>=1:\n\n        t[x][y] |= not dfs(x-1, y)\n\n        \n\n    if y>=1:\n\n        t[x][y] |= not dfs(x, y-1)\n\n        \n\n    if min(x, y)>=1:\n\n        t[x][y] |= not dfs(x-1, y-1)\n\n   \n\n    return t[x][y]\n\n    \n\nt = [[False]*7 for _ in range(7)]\n\n\n\nfor i in range(7):\n\n    for j in range(7):\n\n        dfs(i, j)\n\n\n\n\"\"\"\n\nfor ti in t:\n\n    print(*ti)\n\n\"\"\"\n\n\n\nN = int(eval(input()))\n\nflag = True\n\n\n\nfor _ in range(N):\n\n    a = int(eval(input()))\n\n    \n\n    if a%2==1:\n\n        flag = False\n\n        \n\nif flag:\n\n    print('second')\n\nelse:\n\n    print('first')", "generated_code": "import sys\n\ninput = sys.stdin.readline\n\n\n\n\"\"\"\n\ndef dfs(x, y):\n\n    if x==0 and y==0:\n\n        return False\n\n        \n\n    res = False\n\n    \n\n    if x>0:\n\n        res |= not dfs(x-1, y)\n\n    \n\n    if y>0:\n\n        res |= not dfs(x, y-1)\n\n    \n\n    if min(x, y)>0:\n\n        res |= not dfs(x-1, y-1)\n\n    \n\n    return res\n\n    \n\nt = [[False]*5 for _ in range(5)]\n\n\n\nfor i in range(5):\n\n    for j in range(5):\n\n        t[i][j] = dfs(i, j)\n\n\n\nfor ti in t:\n\n    print(*ti)\n\n\"\"\"\n\n\n\nN = int(eval(input()))\n\na = [int(eval(input())) for _ in range(N)]\n\n\n\nfor ai in a:\n\n    if ai%2==1:\n\n        print('first')\n\n        exit()\n\n\n\nprint('second')", "score": 1.0, "codebleu": 0.3247707160429663, "crystalbleu": 0.06314171904629835, "codebertscore": 0.93, "codescore": 0.9104683995246887, "surfaceSim": 0.619428860838398, "abs_surfaceSim_minus_score": 0.380571139161602}
{"golden_code": "k,s=list(map(int,input().split()))\n\ncnt=0\n\nfor i in range(k+1):\n\n    for j in range(k+1):\n\n        if 0 <= s-i-j <= k:\n\n            cnt+=1\n\nprint(cnt)", "generated_code": "k,s=list(map(int,input().split()))\n\na=0\n\nfor i in range(0,k+1):\n\n    for j in range(0,k+1):\n\n        if 0<=s-i-j<=k:\n\n            a+=1\n\nprint(a)", "score": 1.0, "codebleu": 0.473434239461201, "crystalbleu": 0.0, "codebertscore": 0.95, "codescore": 0.7495018839836121, "surfaceSim": 0.9566666666666667, "abs_surfaceSim_minus_score": 0.043333333333333335}
{"golden_code": "import sys\n\nsys.setrecursionlimit(202020)\n\n\n\nN = int(eval(input()))\n\nwon = [[] for i in range(N)]\n\nfor i in range(1,N):\n\n    a = int(eval(input())) - 1\n\n    won[a].append(i)\n\n\n\ndef height(v):\n\n    if not won[v]: return 0\n\n    hs = [height(op) for op in won[v]]\n\n    ret = 0\n\n    for i,h in enumerate(sorted(hs)):\n\n        ret = max(ret, h + len(hs) - i)\n\n    return ret\n\n\n\nprint((height(0)))", "generated_code": "import sys\n\nsys.setrecursionlimit(10**8)\n\nN = int(eval(input()))\n\nA = [int(eval(input()))-1 for i in range(N-1)]\n\nwins = [[] for _ in range(N)]\n\n\n\nfor i,a in enumerate(A):\n\n    wins[a].append(i+1)\n\n\n\ndepth = [-1] * N\n\ndef dep(v):\n\n    if len(wins[v])==0: return 0\n\n    if depth[v] >= 0:\n\n        return depth[v]\n\n    ds = []\n\n    for w in wins[v]:\n\n        ds.append(dep(w))\n\n    ds.sort(reverse=True)\n\n    ret = 0\n\n    for i,d in enumerate(ds):\n\n        ret = max(ret, i+d+1)\n\n    depth[v] = ret\n\n    return ret\n\nprint((dep(0)))", "score": 1.0, "codebleu": 0.36651420744477914, "crystalbleu": 0.2885923556069797, "codebertscore": 0.87, "codescore": 0.45832616090774536, "surfaceSim": 0.6995139076424521, "abs_surfaceSim_minus_score": 0.30048609235754786}
{"golden_code": "from collections import Counter\n\nN = int(eval(input()))\n\ndiv = []\n\nfor i in range(2,N+1):\n\n    while i != 1:\n\n        for d in range(2,i+1):\n\n            while i%d==0:\n\n                i = i//d\n\n                div.append(d)\n\nC = Counter(div).most_common()\n\nAns = 1\n\nfor k,v in C:\n\n    Ans = Ans*(v+1) % (10**9+7)\n\n\n\nprint(Ans)\n", "generated_code": "from collections import defaultdict\n\nN = int(eval(input()))\n\n\n\nF = [True]*(N+1)\n\nF[0]=F[1]=False\n\nP = []\n\n\n\nfor i in range(2,N+1):\n\n    if F[i]==True:\n\n        P.append(i)\n\n        for j in range(i*2,N+1,i):\n\n            F[j]=False\n\n\n\ndic = defaultdict(int)\n\nfor i in range(2,N+1):\n\n    for p in P:\n\n        while i%p==0:\n\n            dic[p] += 1\n\n            i = i//p\n\n        if i==1:\n\n            break\n\n\n\nans = 1\n\nmodulo = 10**9+7\n\nfor v in list(dic.values()):\n\n    ans *= (v+1)\n\n    ans %= modulo\n\n\n\nprint(ans)", "score": 1.0, "codebleu": 0.35876591836831284, "crystalbleu": 0.232217148872886, "codebertscore": 0.83, "codescore": 0.9934343099594116, "surfaceSim": 0.6754268496819551, "abs_surfaceSim_minus_score": 0.3245731503180449}
{"golden_code": "import math\n\nN, M = list(map(int, input().split()))\n\n\n\n\n\ndef factorization(n):\n\n    arr = []\n\n    temp = n\n\n    for i in range(2, int(-(-n**0.5//1))+1):\n\n        if temp % i == 0:\n\n            cnt = 0\n\n            while temp % i == 0:\n\n                cnt += 1\n\n                temp //= i\n\n            arr.append([i, cnt])\n\n    if temp != 1:\n\n        arr.append([temp, 1])\n\n\n\n    if arr == [] and n != 1:\n\n        arr.append([n, 1])\n\n\n\n    return arr\n\n\n\n\n\nmod = 10**9 + 7\n\n\n\n\n\ndef cmb(n, r, mod):\n\n    if (r < 0 or r > n):\n\n        return 0\n\n    r = min(r, n-r)\n\n    return g1[n] * g2[r] * g2[n-r] % mod\n\n\n\n\n\ng1 = [1, 1]\n\ng2 = [1, 1]\n\ninverse = [0, 1]\n\nfor i in range(2, 2*10**5 + 1):\n\n    g1.append((g1[-1] * i) % mod)\n\n    inverse.append((-inverse[mod % i] * (mod//i)) % mod)\n\n    g2.append((g2[-1] * inverse[-1]) % mod)\n\n\n\n\n\nprimes = factorization(M)\n\n# 何箇所に分けるか（cnt以下）,その中でどう分けるか（しきりをどこにおくか（振り分けられないものが出ると選べれないのとおなじになるので、cnt - 選んだ数））\n\n\n\nans = 1\n\n\n\nfor p, cnt in primes:\n\n    tmp = cmb(N+cnt-1, N-1, mod)\n\n    ans *= tmp\n\n    ans %= mod\n\n\n\nprint(ans)\n", "generated_code": "def main():\n\n    N, M = list(map(int, input().split()))\n\n\n\n    def factorization(n):\n\n        arr = []\n\n        temp = n\n\n        for i in range(2, int(-(-n**0.5//1))+1):\n\n            if temp % i == 0:\n\n                cnt = 0\n\n                while temp % i == 0:\n\n                    cnt += 1\n\n                    temp //= i\n\n                arr.append([i, cnt])\n\n        if temp != 1:\n\n            arr.append([temp, 1])\n\n\n\n        if arr == [] and n != 1:\n\n            arr.append([n, 1])\n\n\n\n        return arr\n\n\n\n    mod = 10**9 + 7\n\n\n\n    def cmb(n, r, mod):\n\n        if (r < 0 or r > n):\n\n            return 0\n\n        r = min(r, n-r)\n\n        return g1[n] * g2[r] * g2[n-r] % mod\n\n\n\n    g1 = [1, 1]\n\n    g2 = [1, 1]\n\n    inverse = [0, 1]\n\n    for i in range(2, N+100 + 1):\n\n        g1.append((g1[-1] * i) % mod)\n\n        inverse.append((-inverse[mod % i] * (mod//i)) % mod)\n\n        g2.append((g2[-1] * inverse[-1]) % mod)\n\n\n\n    primes = factorization(M)\n\n    # 何箇所に分けるか（cnt以下）,その中でどう分けるか（しきりをどこにおくか（振り分けられないものが出ると選べれないのとおなじになるので、cnt - 選んだ数））\n\n\n\n    ans = 1\n\n\n\n    for p, cnt in primes:\n\n        tmp = cmb(N+cnt-1, N-1, mod)\n\n        ans *= tmp\n\n        ans %= mod\n\n\n\n    print(ans)\n\n\n\n\n\nmain()\n", "score": 1.0, "codebleu": 0.7849461752061441, "crystalbleu": 0.9454571272518559, "codebertscore": 0.92, "codescore": 0.9938545227050781, "surfaceSim": 0.9658485856905158, "abs_surfaceSim_minus_score": 0.03415141430948421}
{"golden_code": "from math import factorial as f\n\nn = int(eval(input()))\n\nprint((f(n) % (10 ** 9 + 7)))", "generated_code": "n = int(eval(input()))\n\np = 1\n\nfor i in range(n):\n\n    p = (p * (i+1)) % (10 ** 9 + 7)\n\nprint(p)", "score": 1.0, "codebleu": 0.36906906413756657, "crystalbleu": 0.0, "codebertscore": 0.82, "codescore": 0.09762991964817047, "surfaceSim": 0.5885416666666667, "abs_surfaceSim_minus_score": 0.41145833333333326}
{"golden_code": "A, B = list(map(int, input().split()))\n\ncount_target = 0\n\n\n\nfor i in range(A, B + 1):\n\n    str_i = str(i)\n\n    reversed_i = ''\n\n    for n_th_i in reversed(list(range(len(str_i)))):\n\n        reversed_i += str_i[n_th_i]\n\n\n\n    if str_i == reversed_i:\n\n        count_target += 1\n\n\n\nprint(count_target)", "generated_code": "A, B = list(map(int, input().split()))\n\ncount_target = 0\n\n\n\nfor i in range(A, B+1):\n\n    str_i = str(i)\n\n    reversed_i = str_i[::-1]\n\n\n\n    if str_i == reversed_i:\n\n        count_target += 1\n\n\n\nprint(count_target)\n", "score": 1.0, "codebleu": 0.6151073119031076, "crystalbleu": 0.0, "codebertscore": 0.94, "codescore": 0.8587576746940613, "surfaceSim": 0.7966748017083587, "abs_surfaceSim_minus_score": 0.2033251982916413}
{"golden_code": "import numpy as np\n\nn,m=list(map(int,input().split()))\n\na=np.array([int(i) for i in input().split()])\n\nbc=np.array([[int(i) for i in input().split()] for j in range(m)])\n\n\n\na.sort()\n\nb=bc[:,0]\n\nc=bc[:,1]\n\n\n\nidx=np.argsort(c)\n\nb=b[idx][::-1]\n\nc=c[idx][::-1]\n\n\n\np=0\n\nfor b,c in zip(b,c):\n\n    a[p:p+b]=np.maximum(a[p:p+b],c)\n\n    p+=b\n\n    \n\n    \n\nprint((a.sum()))", "generated_code": "from heapq import heappop,heappush\n\nn,m=list(map(int,input().split()))\n\na=[int(i) for i in input().split()]\n\na.sort()\n\nbc=[[int(i) for i in input().split()]for j in range(m)]\n\nbc=sorted(bc, key=lambda x:x[1],reverse=True)\n\n\n\nans=[]\n\nfor b,c in bc:    \n\n    while b>0 and a: \n\n        x = heappop(a)\n\n        if x<c:\n\n            ans.append(c)\n\n            b-=1\n\n        else:\n\n            ans.append(x)\n\nprint((sum(ans)+sum(a)))", "score": 1.0, "codebleu": 0.3036486994290083, "crystalbleu": 0.2970098727268301, "codebertscore": 0.83, "codescore": 0.8965147733688354, "surfaceSim": 0.5467289719626168, "abs_surfaceSim_minus_score": 0.4532710280373832}
{"golden_code": "import statistics\n\nN = int(eval(input()))\n\nA = [int(a)-i-1 for i,a in enumerate(input().split(),1)]\n\nb = statistics.median_low(A)\n\nc = statistics.median_high(A)\n\nd = sum([abs(x-b) for x in A])\n\ne = sum([abs(x-c) for x in A])\n\nprint((min(d,e)))", "generated_code": "N=int(eval(input()))\n\nA=sorted(a-i-1 for i,a in enumerate(map(int,input().split())))\n\nprint((sum(abs(a-A[N//2]) for a in A)))", "score": 1.0, "codebleu": 0.14960714055356095, "crystalbleu": 0.0, "codebertscore": 0.86, "codescore": 0.12573522329330444, "surfaceSim": 0.5554526748971194, "abs_surfaceSim_minus_score": 0.44454732510288064}
{"golden_code": "import heapq\n\n\n\nN = int(eval(input()))\n\nabc = [list(map(int,input().split())) for _ in range(N-1)]\n\nQ,K = list(map(int,input().split()))\n\nxy = [list(map(int,input().split())) for _ in range(Q)]\n\n\n\nconnect = [[] for _ in range(N)]\n\nINFTY = 10**15\n\nfor a,b,c in abc:\n\n    connect[a-1].append([b-1,c])\n\n    connect[b-1].append([a-1,c])\n\n\n\ncost = [[INFTY,False] for _  in range(N)]\n\ncost[K-1][0] = 0\n\nq = [(0,K-1)]\n\nwhile q:\n\n    _,i = heapq.heappop(q)\n\n    if cost[i][1]:\n\n        continue\n\n    cost[i][1] = True\n\n    ci0 = cost[i][0]\n\n    for j,c in connect[i]:\n\n        if cost[j][1]:\n\n            continue\n\n        tmp_cost = ci0+c\n\n        if tmp_cost < cost[j][0]:\n\n            cost[j][0] = tmp_cost\n\n            heapq.heappush(q,(tmp_cost,j))\n\n\n\nfor x,y in xy:\n\n    print((cost[x-1][0] + cost[y-1][0]))", "generated_code": "N = int(eval(input()))\n\nABC = [list(map(int,input().split())) for _ in [0]*(N-1)]\n\nQ,K = list(map(int,input().split()))\n\nXY = [list(map(int,input().split())) for _ in [0]*Q]\n\n\n\nE = [{} for _ in [0]*N]\n\nfor a,b,c in ABC:\n\n    E[a-1][b-1] = c\n\n    E[b-1][a-1] = c\n\n\n\ndef dist_dfs_tree(N,E,start):\n\n    d = [-1]*N\n\n    d[start] = 0\n\n    q = [start]\n\n    while q:\n\n        i = q.pop()\n\n        ci = d[i]\n\n        for j,cj in list(E[i].items()):\n\n            if d[j] !=-1:continue\n\n            d[j] = ci+cj\n\n            q.append(j)\n\n    return d\n\n\n\nd = dist_dfs_tree(N,E,K-1)\n\nfor x,y in XY:\n\n    print((d[x-1]+d[y-1]))", "score": 1.0, "codebleu": 0.2914704976103795, "crystalbleu": 0.33429344237342246, "codebertscore": 0.83, "codescore": 0.7155279517173767, "surfaceSim": 0.625655624568668, "abs_surfaceSim_minus_score": 0.37434437543133203}
{"golden_code": "from collections import deque\n\n\n\nINF = float('inf')\n\n\n\ndr = (-1, 0, 0, 1)\n\ndc = (0, -1, 1, 0)\n\n\n\nH, W = list(map(int, input().split()))\n\n\n\ns = []\n\ntotal_white_count = 0\n\nfor _ in range(H):\n\n    t = eval(input())\n\n    s.append(t)\n\n    total_white_count += t.count('.')\n\np = [[INF for _ in range(W)] for _ in range(H)]\n\n\n\nans = -1\n\n\n\ndq = deque()\n\ndq.append((0, 0, 1))\n\nwhile dq:\n\n    r, c, d = dq.popleft() # 直した\n\n\n\n    nd = d + 1\n\n    for i in range(4):\n\n        nr = r + dr[i]\n\n        nc = c + dc[i]\n\n        if not (0 <= nr < H and 0 <= nc < W): continue\n\n        if s[nr][nc] == '#' : continue\n\n        if p[nr][nc] <= nd: continue\n\n        p[nr][nc] = nd\n\n        if nr == H - 1 and nc == W - 1:\n\n            ans = total_white_count - nd\n\n            break\n\n        dq.append((nr, nc, nd))\n\n    else:\n\n        continue\n\n    break\n\n\n\nprint(ans)\n", "generated_code": "def main():\n\n    from collections import deque\n\n    import sys\n\n\n\n    input = sys.stdin.readline\n\n\n\n    h, w = list(map(int, input().split()))\n\n    s = [eval(input()) for _ in range(h)]\n\n\n\n    bk = 0\n\n    for row in s:\n\n        bk += row.count('#')\n\n\n\n    def coods(r, c):\n\n        if r > 0: yield r - 1, c\n\n        if r < h - 1: yield r + 1, c\n\n        if c > 0: yield r, c - 1\n\n        if c < w - 1: yield r, c + 1\n\n\n\n    q = deque()\n\n    q.append((0, 0))\n\n    count = [[-1] * w for _ in range(h)]\n\n    count[0][0] = 1\n\n    while q:\n\n        r, c = q.popleft()\n\n        k = count[r][c]\n\n        for nr, nc in coods(r, c):\n\n            nchar = s[nr][nc]\n\n            if nchar == '#': continue\n\n            if count[nr][nc] != -1: continue\n\n            count[nr][nc] = k + 1\n\n            if (nr, nc) == (h - 1, w - 1):\n\n                print((h * w - (k + 1) - bk))\n\n                return\n\n            q.append((nr, nc))\n\n    print((-1))\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 1.0, "codebleu": 0.24761018939116627, "crystalbleu": 0.23488780935422077, "codebertscore": 0.82, "codescore": 0.019487066194415092, "surfaceSim": 0.6430454083048183, "abs_surfaceSim_minus_score": 0.35695459169518173}
{"golden_code": "#coding:utf-8\n\nimport bisect\n\nimport sys\n\nsys.setrecursionlimit(10**6)\n\nwrite = sys.stdout.write\n\ndbg = lambda *something : print(*something) if DEBUG else 0\n\nDEBUG = True\n\n\n\n\n\n\n\ndef main(given = sys.stdin.readline):\n\n    input = lambda : given().rstrip()\n\n    LMIIS = lambda : list(map(int,input().split()))\n\n    II = lambda : int(input())\n\n    XLMIIS = lambda x : [LMIIS() for _ in range(x)]\n\n\n\n    n, t = LMIIS()\n\n    ab = XLMIIS(n)\n\n\n\n    dp1 = [[0]*t for _ in range(n)]\n\n    for i in range(1, n):\n\n        for j in range(1, t):\n\n            if j < ab[i-1][0]:\n\n                dp1[i][j] = dp1[i-1][j]\n\n            else:\n\n                dp1[i][j] = max(dp1[i-1][j], dp1[i-1][j-ab[i-1][0]] + ab[i-1][1])\n\n\n\n\n\n    dp2 = [[0]*t for _ in range(n)]\n\n    for i in range(1, n):\n\n        for j in range(1, t):\n\n            if j < ab[n - i][0]:\n\n                dp2[i][j] = dp2[i-1][j]\n\n            else:\n\n                dp2[i][j] = max(dp2[i-1][j], dp2[i-1][j-ab[n-i][0]] + ab[n-i][1])\n\n\n\n    ans = 0\n\n    for i in range(n):\n\n        for j in range(t - 1):\n\n            ans = max(ans, dp1[i][j] + dp2[n - i - 1][t - j - 1] + ab[i][1])\n\n    print(ans)\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "generated_code": "#coding:utf-8\n\nimport bisect\n\nimport sys\n\nsys.setrecursionlimit(10**6)\n\nwrite = sys.stdout.write\n\ndbg = lambda *something : print(*something) if DEBUG else 0\n\nDEBUG = True\n\n\n\n\n\n\n\ndef main(given = sys.stdin.readline):\n\n    input = lambda : given().rstrip()\n\n    LMIIS = lambda : list(map(int,input().split()))\n\n    II = lambda : int(input())\n\n    XLMIIS = lambda x : [LMIIS() for _ in range(x)]\n\n\n\n    n, t = LMIIS()\n\n    ab = XLMIIS(n)\n\n    ab.sort()\n\n\n\n    dp1 = [[0]*t for _ in range(n+1)]\n\n    for i in range(1, n+1):\n\n        for j in range(1, t):\n\n            if j < ab[i-1][0]:\n\n                dp1[i][j] = dp1[i-1][j]\n\n            else:\n\n                dp1[i][j] = max(dp1[i-1][j], dp1[i-1][j-ab[i-1][0]] + ab[i-1][1])\n\n\n\n    ans = 0\n\n    for i in range(n):\n\n        ans = max(ans, dp1[i][t-1] + ab[i][1])\n\n    print(ans)\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 1.0, "codebleu": 0.6123633474249908, "crystalbleu": 0.6076458278211646, "codebertscore": 0.95, "codescore": 0.10821151733398438, "surfaceSim": 0.9118387909319899, "abs_surfaceSim_minus_score": 0.08816120906801006}
{"golden_code": "from collections import Counter\n\nimport numpy as np\n\n\n\nN = int(eval(input()))\n\nA = np.array(input().split(), dtype = np.int64)\n\n\n\nc = Counter(A.cumsum())\n\nc[0] += 1\n\nanswer = sum(x*(x-1)//2 for x in list(c.values()))\n\nprint(answer)", "generated_code": "import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\nimport itertools\n\nfrom collections import defaultdict\n\n\n\nN,*A = list(map(int,read().split()))\n\n\n\nAcum = [0] + list(itertools.accumulate(A))\n\n\n\ncounter = defaultdict(int)\n\nanswer = 0\n\nfor x in Acum:\n\n    answer += counter[x]\n\n    counter[x] += 1\n\n\n\nprint(answer)", "score": 1.0, "codebleu": 0.23373264260406593, "crystalbleu": 0.15796476821233923, "codebertscore": 0.75, "codescore": 0.2947973310947418, "surfaceSim": 0.4975824388357026, "abs_surfaceSim_minus_score": 0.5024175611642974}
{"golden_code": "N = int(eval(input()))\n\ns_list = {}\n\nfor i in range(N):\n\n  S = eval(input())\n\n  if S in list(s_list.keys()):\n\n    s_list[S] += 1\n\n  else:\n\n    s_list[S] = 0\n\nmax = 0\n\nmaxs = []\n\nfor s,c in list(s_list.items()):\n\n  if c > max:\n\n    maxs = [s]\n\n    max = c\n\n  elif c == max:\n\n    maxs.append(s)\n\nmaxs.sort()\n\nfor m in maxs:\n\n  print(m)", "generated_code": "from collections import Counter\n\ndef solve():\n\n  N = int(input())\n\n  S = [input() for _ in range(N)]\n\n  c = Counter(S)\n\n  M = max(c.values())\n\n  ans = []\n\n  for k,v in c.items():\n\n    if v==M:\n\n      ans.append(k)\n\n  ans.sort()\n\n  return ans\n\nprint(*solve(),sep='\\n')\n", "score": 1.0, "codebleu": 0.2332976200856245, "crystalbleu": 0.0, "codebertscore": 0.77, "codescore": 0.6032538414001465, "surfaceSim": 0.4806742226097065, "abs_surfaceSim_minus_score": 0.5193257773902935}
{"golden_code": "import sys\n\nfrom fractions import gcd\n\n\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\nreadlines = sys.stdin.readlines\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = 1 << 60\n\n\n\n\n\ndef lcm(x, y):\n\n    return x * y // gcd(x, y)\n\n\n\n\n\ndef main():\n\n    N, M = list(map(int, input().split()))\n\n    A = list(set(map(int, input().split(\" \"))))\n\n    A = [a // 2 for a in A]\n\n    semi_lcm = 1\n\n    for a in A:\n\n        semi_lcm = lcm(semi_lcm, a)\n\n        if semi_lcm > M:\n\n            print((0))\n\n            return\n\n\n\n    for a in A:\n\n        if semi_lcm // a % 2 == 0:\n\n            print((0))\n\n            return\n\n\n\n    print(((M // semi_lcm + 1) // 2))\n\n    return\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "generated_code": "import sys\n\n\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\nreadlines = sys.stdin.readlines\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = 1 << 60\n\n\n\n\n\ndef gcd(a, b):\n\n    while b:\n\n        a, b = b, a % b\n\n    return a\n\n\n\n\n\ndef lcm(a, b):\n\n    return a * b // gcd(a, b)\n\n\n\n\n\ndef main():\n\n    N, M, *A = list(map(int, read().split()))\n\n    A = list(set(A))\n\n    B = A.copy()\n\n\n\n    while not any(b % 2 for b in B):\n\n        B = [b // 2 for b in B]\n\n\n\n    if not all(b % 2 for b in B):\n\n        print((0))\n\n        return\n\n\n\n    semi_lcm = 1\n\n    for a in A:\n\n        semi_lcm = lcm(semi_lcm, a // 2)\n\n\n\n    print(((M // semi_lcm + 1) // 2))\n\n    return\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 1.0, "codebleu": 0.5562318119267422, "crystalbleu": 0.5371713932412184, "codebertscore": 0.93, "codescore": 0.11938512325286865, "surfaceSim": 0.7624643874643875, "abs_surfaceSim_minus_score": 0.2375356125356125}
{"golden_code": "a, b = list(map(int, input().split()))\n\ncnt = 0\n\n\n\nfor i in range(a, b+1):\n\n    i = str(i)\n\n    if i[0] == i[-1] and i[1] == i[-2]:\n\n        cnt += 1\n\n\n\nprint(cnt)\n", "generated_code": "a, b = list(map(int, input().split()))\n\ncnt = 0\n\n\n\nfor i in range(10):\n\n    for j in range(10):\n\n        for k in range(10):\n\n            c = 10000*i+1000*j+100*k+10*j+i\n\n            if a <= c <= b:\n\n                cnt += 1\n\n\n\nprint(cnt)\n", "score": 1.0, "codebleu": 0.5388050998154557, "crystalbleu": 0.0, "codebertscore": 0.85, "codescore": 0.9725746512413025, "surfaceSim": 0.6840167364016736, "abs_surfaceSim_minus_score": 0.3159832635983264}
{"golden_code": "import numpy as np\n\nN = int(eval(input()))\n\nV = np.array([int(i) for i in input().split(\" \")])\n\nC = np.array([int(i) for i in input().split(\" \")])\n\n\n\nvc = V-C\n\n\n\nval = 0\n\n\n\nfor i in range(N):\n\n    if vc[i]>0:\n\n        val+=vc[i]\n\nprint(val)", "generated_code": "N = int(eval(input()))\n\nV = [int(i) for i in input().split(\" \")]\n\nC = [int(i) for i in input().split(\" \")]\n\n\n\nval = 0\n\n\n\nfor i in range(N):\n\n    vc=V[i]-C[i]\n\n    if vc>0:\n\n        val+=vc\n\nprint(val)", "score": 1.0, "codebleu": 0.43250002834832124, "crystalbleu": 0.6282057680818627, "codebertscore": 0.94, "codescore": 0.8154532313346863, "surfaceSim": 0.833605072463768, "abs_surfaceSim_minus_score": 0.16639492753623197}
{"golden_code": "import sys\n\nread = sys.stdin.readline\n\n\n\n\n\ndef read_ints():\n\n    return list(map(int, read().split()))\n\n\n\n\n\ndef read_a_int():\n\n    return int(read())\n\n\n\n\n\ndef read_matrix(H):\n\n    '''\n\n    H is number of rows\n\n    '''\n\n    return [list(map(int, read().split())) for _ in range(H)]\n\n\n\n\n\ndef read_map(H):\n\n    '''\n\n    H is number of rows\n\n    文字列で与えられた盤面を読み取る用\n\n    '''\n\n    return [read()[:-1] for _ in range(H)]\n\n\n\n\n\ndef read_tuple(H):\n\n    '''\n\n    H is number of rows\n\n    '''\n\n    ret = []\n\n    for _ in range(H):\n\n        ret.append(tuple(map(int, read().split())))\n\n    return ret\n\n\n\n\n\ndef read_col(H, n_cols):\n\n    '''\n\n    H is number of rows\n\n    n_cols is number of cols\n\n\n\n    A列、B列が与えられるようなとき\n\n    '''\n\n    ret = [[] for _ in range(n_cols)]\n\n    for _ in range(H):\n\n        tmp = list(map(int, read().split()))\n\n        for col in range(n_cols):\n\n            ret[col].append(tmp[col])\n\n\n\n    return ret\n\n\n\n\n\nN, K = read_ints()\n\nP = read_ints()\n\n\n\n\n\ndef ret_mean(X):\n\n    return (X + 1) / 2\n\n\n\n\n\n\n\n\n\nimport numpy as np\n\nP_mean = np.array([ret_mean(p) for p in P])\n\nP_accum = np.zeros(N+1)\n\nP_accum[1:] = P_mean.cumsum()\n\n\n\nans = 0\n\n# print(P_accum)\n\nfor i in range(N - K + 1):\n\n    j = i + K\n\n    ans = max(ans, P_accum[j] - P_accum[i])\n\nprint(ans)\n", "generated_code": "n = int(eval(input()))\n\np = 1\n\nfor i in range(n):\n\n    p = (p * (i+1)) % (10 ** 9 + 7)\n\nprint(p)", "score": 0.0, "codebleu": 0.09467400774824339, "crystalbleu": 0.00029355503457230073, "codebertscore": 0.62, "codescore": 0.12420932948589325, "surfaceSim": 0.3306051587301587, "abs_surfaceSim_minus_score": 0.3306051587301587}
{"golden_code": "s = eval(input())\n\n\n\nstart = -1\n\nend = 0\n\nfor i in range(len(s)):\n\n    if s[i] == 'A' and start < 0:\n\n        start = i\n\n    elif s[i] == 'Z':\n\n        end = i\n\nprint((end - start + 1))\n", "generated_code": "# encoding:utf-8\n\n\n\ninput = list(map(int, input().split()))\n\nW, H, x, y, r = input\n\n\n\nif x - r < 0 or x + r > W:\n\n\tprint(\"No\")\n\nelif y - r < 0 or y + r > H:\n\n\tprint(\"No\")\n\nelse:\n\n\tprint(\"Yes\")", "score": 0.0, "codebleu": 0.14908888315679275, "crystalbleu": 0.0, "codebertscore": 0.72, "codescore": 0.2888568639755249, "surfaceSim": 0.5072115384615384, "abs_surfaceSim_minus_score": 0.5072115384615384}
{"golden_code": "#!/usr/bin/env pypy3\n\n\n\nimport math\n\nprint((math.factorial(int(eval(input()))) % 1000000007))", "generated_code": "#!usr/bin/env python3\n\nfrom collections import defaultdict\n\nfrom collections import deque\n\nfrom heapq import heappush, heappop\n\nimport sys\n\nimport math\n\nimport bisect\n\nimport random\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\n\ndef I(): return int(sys.stdin.readline())\n\ndef LS():return list(map(list, sys.stdin.readline().split()))\n\ndef S(): return list(sys.stdin.readline())[:-1]\n\ndef IR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = I()\n\n    return l\n\ndef LIR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = LI()\n\n    return l\n\ndef SR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = S()\n\n    return l\n\ndef LSR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = SR()\n\n    return l\n\nmod = 1000000007\n\n\n\n#A\n\n\"\"\"\n\ndef gcd(a,b):\n\n    if a == 0:\n\n        return b\n\n    return gcd(b%a,a)\n\nn = I()\n\na = IR(n)\n\nl = a[0]\n\nfor i in range(1,n):\n\n    g = gcd(l,a[i])\n\n    l *= a[i]//g\n\nprint(l)\n\n\"\"\"\n\n\n\n#B\n\nn = I()\n\nv = [[] for i in range(n)]\n\nfor i in range(n-1):\n\n    a,b,c = LI()\n\n    a -= 1\n\n    b -= 1\n\n    v[a].append([b,c])\n\n    v[b].append([a,c])\n\nQ,k = LI()\n\nd = [-1 for i in range(n)]\n\nd[k-1] = 0\n\nq = deque()\n\nq.append(k-1)\n\nwhile q:\n\n    x = q.popleft()\n\n    for y,c in v[x]:\n\n        if d[y] == -1:\n\n            d[y] = d[x]+c\n\n            q.append(y)\n\nfor i in range(Q):\n\n    x,y = LI()\n\n    x -= 1\n\n    y -= 1\n\n    print((d[x]+d[y]))\n\n#C\n\n\n\n#D\n\n\n\n#E\n\n\n\n#F\n\n\n\n#G\n\n\n\n#H\n\n\n\n#I\n\n\n\n#J\n\n\n\n#K\n\n\n\n#L\n\n\n\n#M\n\n\n\n#N\n\n\n\n#O\n\n\n\n#P\n\n\n\n#Q\n\n\n\n#R\n\n\n\n#S\n\n\n\n#T\n", "score": 0.0, "codebleu": 0.34445775208732043, "crystalbleu": 0.01172932593790789, "codebertscore": 0.6, "codescore": 0.9766961932182312, "surfaceSim": 0.31709465096875866, "abs_surfaceSim_minus_score": 0.31709465096875866}
{"golden_code": "n, m = list(map(int, input().split()))\n\nans = 0\n\nfor i in range(n, m+1):\n\n    if str(i)[0]+str(i)[1] == str(i)[-1]+str(i)[-2]: ans += 1\n\nprint(ans)", "generated_code": "k,s=list(map(int,input().split()))\n\nans=0\n\nx=min(k+1,s+1)\n\ny=max(0,s-k-k)\n\nfor i in range(y,x):\n\n    for j in range(y,x):\n\n        if i+j>s: break\n\n        if 0<=s-i-j<=k:\n\n            ans+=1\n\nprint(ans)", "score": 0.0, "codebleu": 0.3575502722964686, "crystalbleu": 0.0, "codebertscore": 0.83, "codescore": 0.975470244884491, "surfaceSim": 0.6278817733990147, "abs_surfaceSim_minus_score": 0.6278817733990147}
{"golden_code": "k, n = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\n\n\ndiff = []\n\n\n\nfor i in range(n - 1):\n\n    diff.append(a[i + 1] - a[i])\n\ndiff.append(k - a[-1] + a[0])\n\n\n\nprint((k - max(diff)))\n", "generated_code": "##### https://atcoder.jp/contests/abc174/submissions/15644075 を1次元化\n\n\n\nimport sys\n\nINF = 1 << 60\n\nMOD = 10**9 + 7 # 998244353\n\nsys.setrecursionlimit(2147483647)\n\ninput = lambda:sys.stdin.buffer.readline().rstrip()\n\n \n\nclass SegmentTree(object):\n\n    def __init__(self, A, dot, unit):\n\n        n = 1 << (len(A) - 1).bit_length()\n\n        tree = [unit] * (2 * n)\n\n        for i, v in enumerate(A):\n\n            tree[i + n] = v\n\n        for i in range(n - 1, 0, -1):\n\n            tree[i] = dot(tree[i << 1], tree[i << 1 | 1])\n\n        self._n = n\n\n        self._tree = tree\n\n        self._dot = dot\n\n        self._unit = unit\n\n \n\n    def __getitem__(self, i):\n\n        return self._tree[i + self._n]\n\n \n\n    def update(self, i, v):\n\n        i += self._n\n\n        self._tree[i] = v\n\n        while i != 1:\n\n            i >>= 1\n\n            self._tree[i] = self._dot(self._tree[i << 1], self._tree[i << 1 | 1])\n\n \n\n    def add(self, i, v):\n\n        self.update(i, self[i] + v)\n\n \n\n    def sum(self, l, r):\n\n        l += self._n\n\n        r += self._n\n\n        l_val = r_val = self._unit\n\n        while l < r:\n\n            if l & 1:\n\n                l_val = self._dot(l_val, self._tree[l])\n\n                l += 1\n\n            if r & 1:\n\n                r -= 1\n\n                r_val = self._dot(self._tree[r], r_val)\n\n            l >>= 1\n\n            r >>= 1\n\n        return self._dot(l_val, r_val)\n\n\n\nfrom operator import add\n\ndef resolve():\n\n    n, q = map(int, input().split())\n\n    C = list(map(lambda x : int(x) - 1, input().split()))\n\n \n\n    A = [0] * n\n\n    used = [0] * n\n\n    for i, c in enumerate(C):\n\n        if used[c]:\n\n            continue\n\n        used[c] = 1\n\n        A[i] = 1\n\n    tree = SegmentTree(A, add, 0)\n\n \n\n    next = [-1] * n\n\n    used = [-1] * n\n\n    for i in range(n - 1, -1, -1):\n\n        c = C[i]\n\n        if used[c] != -1:\n\n            next[i] = used[c]\n\n        used[c] = i\n\n \n\n    queries = [None] * q\n\n    for i in range(q):\n\n        l, r = map(int, input().split())\n\n        queries[i] = (l - 1 << 40) + (r << 20) + i\n\n    queries.sort(reverse = 1)\n\n    \n\n    m = (1 << 20) - 1\n\n    ans = [0] * q\n\n    for l in range(n):\n\n        while queries and queries[-1] >> 40 == l:\n\n            lri = queries.pop()\n\n            l = lri >> 40\n\n            r = (lri >> 20) & m\n\n            i = lri & m\n\n            ans[i] = tree.sum(l, r)\n\n        if next[l] != -1:\n\n            tree.add(next[l], 1)\n\n \n\n    print(*ans, sep = '\\n')\n\nresolve()\n", "score": 0.0, "codebleu": 0.22053591078815635, "crystalbleu": 0.05260538507956445, "codebertscore": 0.68, "codescore": 0.7198076248168945, "surfaceSim": 0.4399499619852538, "abs_surfaceSim_minus_score": 0.4399499619852538}
{"golden_code": "#E\n\nfrom itertools import accumulate\n\nfrom bisect import bisect_left\n\ndef main():\n\n    n,m=list(map(int,input().split()))\n\n    A=list(map(int,input().split()))\n\n    A.sort()\n\n    \n\n    def count(k):\n\n        cnt=0\n\n        for a in A:\n\n            cnt+=bisect_left(A,k-a)\n\n        return cnt\n\n    \n\n    ok=0\n\n    ng=10**10+1\n\n    while ng-ok>1:\n\n        mid=(ok+ng)//2\n\n        if count(mid)<n**2-m:\n\n            ok=mid\n\n        else:\n\n            ng=mid\n\n    border=ok\n\n    \n\n    k=n**2-count(border)\n\n    Acc=[0]+list(accumulate(A))\n\n    s=Acc[-1]\n\n    ans=0\n\n    for a in A:\n\n        idx=bisect_left(A,border-a)\n\n        ans+=a*(n-idx)+(s-Acc[idx])\n\n    ans-=border*(k-m)\n\n    print(ans)\n\n    \n\nif __name__=='__main__':\n\n    main()", "generated_code": "n = int(eval(input()))\n\na_list = list(map(int, input().split()))\n\na_list = sorted(a_list, reverse=True)\n\n\n\nalice_point = 0\n\nbob_point = 0\n\nfor i in range(n):\n\n    if i % 2 == 0:\n\n        alice_point += a_list[i]\n\n    else:\n\n        bob_point += a_list[i]\n\n\n\nprint((alice_point - bob_point))", "score": 0.0, "codebleu": 0.14278974410728557, "crystalbleu": 0.03422079781909362, "codebertscore": 0.69, "codescore": 0.0735706016421318, "surfaceSim": 0.5019883643861845, "abs_surfaceSim_minus_score": 0.5019883643861845}
{"golden_code": "# -*- coding: utf-8 -*-\n\nx, y, z, k = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\nb = list(map(int, input().split()))\n\nc = list(map(int, input().split()))\n\n\n\na.sort(reverse=True)\n\nb.sort(reverse=True)\n\nc.sort(reverse=True)\n\n\n\nabc = []\n\n\n\nfor i, _a in enumerate(a):\n\n    for j, _b in enumerate(b):\n\n        if (i+1) * (j+1) > k:\n\n            break\n\n        for l, _c in enumerate(c):\n\n            if (i+1) * (j+1) * (l+1) > k:\n\n                break\n\n            abc.append(_a + _b + _c)\n\n\n\nabc.sort(reverse=True)\n\nfor x in abc[:k]:\n\n    print(x)\n", "generated_code": "a,b = list(map(int, input().split()))\n\nn = [i for i in map(str, list(range(a,b+1))) if i==i[::-1]]\n\nprint((len(n)))", "score": 0.0, "codebleu": 0.14396520474341595, "crystalbleu": 0.014603036214533576, "codebertscore": 0.72, "codescore": 0.2852504849433899, "surfaceSim": 0.49893162393162394, "abs_surfaceSim_minus_score": 0.49893162393162394}
{"golden_code": "n, l = list(map(int, input().split()))\n\nS = [eval(input()) for i in range(n)]\n\nS.sort()\n\nprint((\"\".join(S)))", "generated_code": "k,s=list(map(int,input().split()))\n\na=0\n\nfor i in range(0,k+1):\n\n    for j in range(0,k+1):\n\n        if 0<=s-i-j<=k:\n\n            a+=1\n\nprint(a)", "score": 0.0, "codebleu": 0.3680876010730655, "crystalbleu": 0.0, "codebertscore": 0.79, "codescore": 0.3985181450843811, "surfaceSim": 0.5625, "abs_surfaceSim_minus_score": 0.5625}
{"golden_code": "n,t=int(input()),list(map(int,input().split()));T=sum(t)\n\nprint(*[T-t[i-1]+j for i,j in [list(map(int,input().split())) for _ in range(int(input()))]],sep='\\n')\n", "generated_code": "a,b,c=1,0,0\n\nexec('a,b,c=b,c,a+c;'*(int(eval(input()))-2))\n\nprint((c%(10**9+7)))", "score": 0.0, "codebleu": 0.09399021663172606, "crystalbleu": 0.0, "codebertscore": 0.73, "codescore": 0.04673658683896065, "surfaceSim": 0.39384528514963296, "abs_surfaceSim_minus_score": 0.39384528514963296}
{"golden_code": "import math\n\nN = int(eval(input()))\n\nprint((math.factorial(N)%(10**9+7)))", "generated_code": "a,b=list(map(int,input().split()))\n\n\n\nans=0\n\n\n\nfor i in range(a,b+1):\n\n    buf=str(i)\n\n    str1=buf[::-1]\n\n    if buf==str1:\n\n        ans+=1\n\n\n\nprint(ans)\n", "score": 0.0, "codebleu": 0.1412337662337662, "crystalbleu": 0.0, "codebertscore": 0.71, "codescore": 0.95135897397995, "surfaceSim": 0.4135483870967742, "abs_surfaceSim_minus_score": 0.4135483870967742}
{"golden_code": "import numpy as np\n\n\n\nn = int(eval(input()))\n\na_list = list(map(int, input().split()))\n\n\n\nalice_point = 0\n\nbob_point = 0\n\nfor i in range(n):\n\n    argmax_a = np.argmax(a_list)\n\n    max_a = np.max(a_list)\n\n    if i % 2 == 0: # If Alice takes a card\n\n        alice_point += max_a\n\n    else: # If Bob takes a card\n\n        bob_point += max_a\n\n    del a_list[argmax_a] # No confidence -> Review how to delete list element!\n\n\n\nprint((alice_point - bob_point))", "generated_code": "k,s=list(map(int,input().split()))\n\nans=0\n\nx=min(k+1,s+1)\n\ny=max(0,s-k-k)\n\nfor i in range(y,x):\n\n    for j in range(y,x):\n\n        if i+j>s: break\n\n        if 0<=s-i-j<=k:\n\n            ans+=1\n\nprint(ans)", "score": 0.0, "codebleu": 0.18918623106880894, "crystalbleu": 0.0, "codebertscore": 0.72, "codescore": 0.9827542901039124, "surfaceSim": 0.5693787448754336, "abs_surfaceSim_minus_score": 0.5693787448754336}
{"golden_code": "#!/usr/bin/env python3\n\n\n\nn = int(eval(input()))\n\ns = [eval(input()) for _ in range(n)]\n\n\n\nc = [0 for _ in range(5)]\n\nt = 'MARCH'\n\n\n\nfor i in range(n):\n\n    for j in range(5):\n\n        if s[i][0] == t[j]:\n\n            c[j] += 1\n\nans = 0 \n\nfor i in range(5):\n\n    for j in range(i+1, 5): \n\n        for k in range(j+1, 5): \n\n            ans += c[i]*c[k]*c[j]\n\nprint(ans)\n", "generated_code": "s = eval(input())\n\n\n\nstart = 0\n\nfor i in range(len(s)):\n\n    if s[i] == 'A':\n\n        start = i\n\n        break\n\n\n\nend = 0\n\nfor i in reversed(list(range(len(s)))):\n\n    if s[i] == 'Z':\n\n        end = i\n\n        break\n\nprint((end - start + 1))\n", "score": 0.0, "codebleu": 0.16045543462249007, "crystalbleu": 0.06057016808309746, "codebertscore": 0.77, "codescore": 0.07846569269895554, "surfaceSim": 0.6441241685144125, "abs_surfaceSim_minus_score": 0.6441241685144125}
{"golden_code": "import sys\n\nimport numpy as np\n\nn,m = [int(x) for x in sys.stdin.readline().split()]\n\nr = np.zeros(n)\n\nfor i in range(m):\n\n\ta, b = [int(x) for x in sys.stdin.readline().split()]\n\n\tr[a-1] += 1\n\n\tr[b-1] += 1\n\nfor i in range(n):\n\n\tprint((int(r[i])))", "generated_code": "import sys\n\nsys.setrecursionlimit(10**8)\n\nN = int(eval(input()))\n\nA = [int(eval(input()))-1 for i in range(N-1)]\n\nwins = [[] for _ in range(N)]\n\n\n\nfor i,a in enumerate(A):\n\n    wins[a].append(i+1)\n\n\n\ndepth = [-1] * N\n\ndef dep(v):\n\n    if len(wins[v])==0: return 0\n\n    if depth[v] >= 0:\n\n        return depth[v]\n\n    ds = []\n\n    for w in wins[v]:\n\n        ds.append(dep(w))\n\n    ds.sort(reverse=True)\n\n    ret = 0\n\n    for i,d in enumerate(ds):\n\n        ret = max(ret, i+d+1)\n\n    depth[v] = ret\n\n    return ret\n\nprint((dep(0)))", "score": 0.0, "codebleu": 0.23418383964057493, "crystalbleu": 0.03513438538289318, "codebertscore": 0.74, "codescore": 0.20178432762622833, "surfaceSim": 0.5040507696462327, "abs_surfaceSim_minus_score": 0.5040507696462327}
{"golden_code": "a,b,c,x,y=list(map(int,input().split()))\n\nans=a*x+b*y\n\nn=max(x,y)\n\nfor i in range(1,n+1):\n\n  ans=min(ans,2*i*c+a*max(0,x-i)+b*max(0,y-i))\n\nprint(ans)\n\n\n\n\n", "generated_code": "def main():\n\n    N, M = list(map(int, input().split()))\n\n\n\n    def factorization(n):\n\n        arr = []\n\n        temp = n\n\n        for i in range(2, int(-(-n**0.5//1))+1):\n\n            if temp % i == 0:\n\n                cnt = 0\n\n                while temp % i == 0:\n\n                    cnt += 1\n\n                    temp //= i\n\n                arr.append([i, cnt])\n\n        if temp != 1:\n\n            arr.append([temp, 1])\n\n\n\n        if arr == [] and n != 1:\n\n            arr.append([n, 1])\n\n\n\n        return arr\n\n\n\n    mod = 10**9 + 7\n\n\n\n    def cmb(n, r, mod):\n\n        if (r < 0 or r > n):\n\n            return 0\n\n        r = min(r, n-r)\n\n        return g1[n] * g2[r] * g2[n-r] % mod\n\n\n\n    g1 = [1, 1]\n\n    g2 = [1, 1]\n\n    inverse = [0, 1]\n\n    for i in range(2, N+100 + 1):\n\n        g1.append((g1[-1] * i) % mod)\n\n        inverse.append((-inverse[mod % i] * (mod//i)) % mod)\n\n        g2.append((g2[-1] * inverse[-1]) % mod)\n\n\n\n    primes = factorization(M)\n\n    # 何箇所に分けるか（cnt以下）,その中でどう分けるか（しきりをどこにおくか（振り分けられないものが出ると選べれないのとおなじになるので、cnt - 選んだ数））\n\n\n\n    ans = 1\n\n\n\n    for p, cnt in primes:\n\n        tmp = cmb(N+cnt-1, N-1, mod)\n\n        ans *= tmp\n\n        ans %= mod\n\n\n\n    print(ans)\n\n\n\n\n\nmain()\n", "score": 0.0, "codebleu": 0.23947057609446298, "crystalbleu": 0.09333928732260696, "codebertscore": 0.67, "codescore": 0.9936000108718872, "surfaceSim": 0.47523863735878796, "abs_surfaceSim_minus_score": 0.47523863735878796}
{"golden_code": "import numpy as np\n\n\n\nN=int(eval(input()))\n\nA=list(map(int, input().split()))\n\n\n\nAA=[]\n\nfor i,a in enumerate(A):\n\n    AA.append(a-i+1)\n\n\n\nb=np.median(AA)\n\nans=0\n\n\n\nfor a in AA:\n\n    ans+=abs(a-b)\n\nprint((int(ans)))", "generated_code": "def main():\n\n    n = int(eval(input()))\n\n    dp = [[0 for i in range(10)] for i in range(10)]\n\n    for i in range(1,n+1):\n\n        h,t = int(str(i)[0]), int(str(i)[-1])\n\n        dp[h][t] += 1\n\n    ans = 0\n\n    for i in range(10):\n\n        for j in range(10):\n\n            ans += dp[i][j] * dp[j][i]\n\n    print(ans)\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "score": 0.0, "codebleu": 0.19158993768875282, "crystalbleu": 0.11012166567854234, "codebertscore": 0.77, "codescore": 0.018430178984999657, "surfaceSim": 0.4715686274509804, "abs_surfaceSim_minus_score": 0.4715686274509804}
{"golden_code": "from collections import Counter\n\n\n\nimport numpy as np\n\n\n\n\n\ndef part(pts, a, ans):\n\n    b = np.dot(pts, [np.sin(a), np.cos(a)])\n\n    c = np.argmax(b, axis=0)\n\n    for i, v in list(Counter(c).items()):\n\n        ans[i] += v\n\n\n\n\n\ndef solve(n, pts):\n\n    ans = [0] * n\n\n    part(pts, np.linspace(0, np.pi, 100000, endpoint=False), ans)\n\n    part(pts, np.linspace(np.pi, 2 * np.pi, 100000, endpoint=False), ans)\n\n    return [v / 200000 for v in ans]\n\n\n\n\n\nn = int(eval(input()))\n\npts = np.array([list(map(int, input().split())) for _ in range(n)])\n\nprint(('\\n'.join(map(str, solve(n, pts)))))\n", "generated_code": "N=int(eval(input()))\n\nd=list(map(int, input().split()))\n\n\n\ncumsum = 0\n\nfor n in range(N):\n\n    cumsum += d[n]\n\nsub_cumsum = 0\n\nans = 0\n\nfor n in range(N):\n\n    sub_cumsum += d[n]\n\n    ans += d[n] * (cumsum-sub_cumsum)\n\nprint(ans)\n", "score": 0.0, "codebleu": 0.10042410681025493, "crystalbleu": 0.06585756411002427, "codebertscore": 0.71, "codescore": 0.5001105666160583, "surfaceSim": 0.4458475540386803, "abs_surfaceSim_minus_score": 0.4458475540386803}
{"golden_code": "def main():\n\n    n = int(eval(input()))\n\n    import numpy as np\n\n    ans = np.zeros((10,10))\n\n    for i in range(1,n+1):\n\n        h,t = str(i)[0],str(i)[-1]\n\n        ans[int(h)-1][int(t)-1]+=1\n\n    s = 0\n\n    for i in range(10):\n\n        for j in range(10):\n\n            s += ans[i][j]*ans[j][i]\n\n\n\n    print((int(s)))\n\nif __name__ == \"__main__\":\n\n    main()", "generated_code": "#!/usr/bin/env python3\n\nimport sys\n\n\n\n\n\ndef solve(N: int, A: \"List[int]\"):\n\n    difA = [0]*N\n\n\n\n    for i in range(N):\n\n        difA[i] = A[i]-(i+1)\n\n\n\n    difA.sort()\n\n    if N%2 == 0:\n\n        g1 = difA[N//2]\n\n        g2 = difA[N//2-1]\n\n        a1 = 0\n\n        a2 = 0\n\n        for i in range(N):\n\n            a1 += abs(difA[i]-g1)\n\n            a2 += abs(difA[i]-g2)\n\n        print((min(a1,a2)))\n\n            \n\n    else:\n\n        g = difA[N//2]\n\n        a = 0\n\n        for i in range(N):\n\n            a += abs(difA[i]-g)\n\n        print(a)\n\n    return\n\n\n\n\n\ndef main():\n\n    def iterate_tokens():\n\n        for line in sys.stdin:\n\n            for word in line.split():\n\n                yield word\n\n    tokens = iterate_tokens()\n\n    N = int(next(tokens))  # type: int\n\n    A = [int(next(tokens)) for _ in range(N)]  # type: \"List[int]\"\n\n    solve(N, A)\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 0.0, "codebleu": 0.22013456524500638, "crystalbleu": 0.07206323941838827, "codebertscore": 0.74, "codescore": 0.9930926561355591, "surfaceSim": 0.6334506478963366, "abs_surfaceSim_minus_score": 0.6334506478963366}
{"golden_code": "import sys\n\ninput = sys.stdin.readline\n\n\n\nn,k = list(map(int, input().split()))\n\nAs = [int(eval(input())) for i in range(n)]\n\n\n\n# N: 処理する区間の長さ\n\n\n\nINF = 0\n\n\n\nmx = 300001\n\nLV = (mx-1).bit_length()\n\nN0 = 2**LV\n\ndata = [INF]*(2*N0)\n\nlazy = [None]*(2*N0)\n\n\n\n# 伝搬対象の区間を求める\n\ndef gindex(l, r):\n\n    L = (l + N0) >> 1; R = (r + N0) >> 1\n\n    lc = 0 if l & 1 else (L & -L).bit_length()\n\n    rc = 0 if r & 1 else (R & -R).bit_length()\n\n    for i in range(LV):\n\n        if rc <= i:\n\n            yield R\n\n        if L < R and lc <= i:\n\n            yield L\n\n        L >>= 1; R >>= 1\n\n\n\n# 遅延伝搬処理\n\ndef propagates(*ids):\n\n    for i in reversed(ids):\n\n        v = lazy[i-1]\n\n        if v is None:\n\n            continue\n\n        lazy[2*i-1] = data[2*i-1] = lazy[2*i] = data[2*i] = v\n\n        lazy[i-1] = None\n\n\n\n# 区間[l, r)をxで更新\n\ndef update(l, r, x):\n\n    *ids, = gindex(l, r)\n\n    propagates(*ids)\n\n\n\n    L = N0 + l; R = N0 + r\n\n    while L < R:\n\n        if R & 1:\n\n            R -= 1\n\n            lazy[R-1] = data[R-1] = x\n\n        if L & 1:\n\n            lazy[L-1] = data[L-1] = x\n\n            L += 1\n\n        L >>= 1; R >>= 1\n\n    for i in ids:\n\n        data[i-1] = max(data[2*i-1], data[2*i])\n\n\n\n# 区間[l, r)内の最小値を求める\n\ndef query(l, r):\n\n    propagates(*gindex(l, r))\n\n    L = N0 + l; R = N0 + r\n\n\n\n    s = INF\n\n    while L < R:\n\n        if R & 1:\n\n            R -= 1\n\n            s = max(s, data[R-1])\n\n        if L & 1:\n\n            s = max(s, data[L-1])\n\n            L += 1\n\n        L >>= 1; R >>= 1\n\n    return s\n\n\n\nupdate(As[0],As[0]+1,1)\n\nfor i, a in enumerate(As[1:]):\n\n    l = max(0,a-k)\n\n    r = min(mx,a+k)\n\n    upd = query(l,r+1)\n\n    if upd == -1:continue\n\n    # print(\"i\",i,\"a\",a,\"upd\",upd,\"l\",l,\"r\",r)\n\n    update(a, a+1, upd+1)\n\n\n\nans = 0\n\nfor a in set(As):\n\n    ans = max(ans,query(a,a+1))\n\nprint(ans)", "generated_code": "import sys, re\n\nfrom collections import deque, defaultdict, Counter\n\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, radians\n\nfrom itertools import accumulate, permutations, combinations, product, groupby\n\nfrom operator import itemgetter, mul\n\nfrom copy import deepcopy\n\nfrom string import ascii_lowercase, ascii_uppercase, digits\n\nfrom bisect import bisect, bisect_left\n\nfrom fractions import gcd\n\nfrom heapq import heappush, heappop\n\nfrom functools import reduce\n\ndef input(): return sys.stdin.readline().strip()\n\ndef INT(): return int(eval(input()))\n\ndef MAP(): return list(map(int, input().split()))\n\ndef LIST(): return list(map(int, input().split()))\n\ndef ZIP(n): return list(zip(*(MAP() for _ in range(n))))\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = float('inf')\n\nmod = 10 ** 9 + 7\n\n\n\nK, N = MAP()\n\nA = LIST()\n\ndiff = abs(K - A[-1] + A[0])\n\nd = abs(K - A[-1] + A[0])\n\nif N == 2:\n\n  print((min(d, A[1] - A[0])))\n\n  exit()\n\nfor i in range(1, N):\n\n  d += abs(A[i] - A[i-1])\n\n  diff = max(diff, abs(A[i] - A[i-1]))\n\nprint((d - diff))", "score": 0.0, "codebleu": 0.1012437319742738, "crystalbleu": 0.06673973884390456, "codebertscore": 0.69, "codescore": 0.13366897404193878, "surfaceSim": 0.5782003151649981, "abs_surfaceSim_minus_score": 0.5782003151649981}
{"golden_code": "N = int(eval(input()))\n\nl = [list(map(int, input().split())) for _ in range(N)]\n\n\n\ndp = [[0 for i in range(3)] for j in range(N+1)]\n\n\n\n\n\nfor i in range(1, N+1):\n\n    for j in range(3):\n\n        for k in range(3):\n\n            if j != k:\n\n                dp[i][j] = max(dp[i][j], dp[i-1][k]+l[i-1][k])\n\n\n\nprint((max(dp[N][0], dp[N][1], dp[N][2])))\n\n\n", "generated_code": "n = int(eval(input()))\n\ns = int(n**.5)\n\nfor i in range(s):\n\n  if n % (s-i) == 0:\n\n    print(((s-i) + n // (s-i) - 2))\n\n    break", "score": 0.0, "codebleu": 0.09806850323230569, "crystalbleu": 0.038301202171409005, "codebertscore": 0.76, "codescore": 0.5451942682266235, "surfaceSim": 0.5049283667621777, "abs_surfaceSim_minus_score": 0.5049283667621777}
{"golden_code": "from collections import defaultdict\n\nfrom bisect import bisect_left\n\n\n\ns = eval(input())\n\nn = len(s)\n\ns = s + s\n\nt = eval(input())\n\nif set(t) - set(s):\n\n\tprint((-1))\n\n\texit()\n\nd = defaultdict(list)\n\nfor i in range(2 * n):\n\n\td[s[i]] += [i]\n\ncur = tot = 0\n\nfor c in t:\n\n\tx = d[c][bisect_left(d[c], cur)]\n\n\tif x < n:\n\n\t\tcur = x + 1\n\n\telse:\n\n\t\tcur = x - n + 1\n\n\t\ttot += n\n\ntot += cur\n\nprint(tot)\n", "generated_code": "# coding: utf-8\n\nimport sys\n\n\n\nsr = lambda: sys.stdin.readline().rstrip()\n\nir = lambda: int(sr())\n\nlr = lambda: list(map(int, sr().split()))\n\n\n\nN, M = lr()\n\nL = 0; R = 10 ** 6\n\nfor _ in range(M):\n\n    l, r = lr()\n\n    if l > L:\n\n        L = l\n\n    if r < R:\n\n        R = r\n\n\n\nanswer = max(0, R - L + 1)\n\nprint(answer)\n", "score": 0.0, "codebleu": 0.16427178026041372, "crystalbleu": 0.01184442312283057, "codebertscore": 0.7, "codescore": 0.345621258020401, "surfaceSim": 0.46979921000658326, "abs_surfaceSim_minus_score": 0.46979921000658326}
{"golden_code": "a,b = list(map(int, input().split()))\n\ncount = 0\n\nfor i in range(a,b+1):\n\n    j = str(i)\n\n    if j==''.join(reversed(j)):\n\n        count += 1\n\nprint(count)", "generated_code": "from itertools import accumulate\n\nfrom bisect import bisect_left\n\ndef main():\n\n    n,m=list(map(int,input().split()))\n\n    A=list(map(int,input().split()))\n\n    A.sort()\n\n    \n\n    def count(k):\n\n        cnt=0\n\n        for a in A:\n\n            cnt+=bisect_left(A,k-a)\n\n        return cnt\n\n    \n\n    ok=0\n\n    ng=2*10**5+1\n\n    while ng-ok>1:\n\n        mid=(ok+ng)//2\n\n        if count(mid)<n**2-m:\n\n            ok=mid\n\n        else:\n\n            ng=mid\n\n    border=ok\n\n    \n\n    k=n**2-count(border)\n\n    Acc=[0]+list(accumulate(A))\n\n    s=Acc[-1]\n\n    ans=0\n\n    for a in A:\n\n        idx=bisect_left(A,border-a)\n\n        ans+=a*(n-idx)+(s-Acc[idx])\n\n    ans-=border*(k-m)\n\n    print(ans)\n\n    \n\nif __name__=='__main__':\n\n    main()", "score": 0.0, "codebleu": 0.2921772208788602, "crystalbleu": 0.06143538402324748, "codebertscore": 0.68, "codescore": 0.03680793195962906, "surfaceSim": 0.46447136994332616, "abs_surfaceSim_minus_score": 0.46447136994332616}
{"golden_code": "mod = int(1e9+7)\n\nn = int(eval(input()))\n\n\n\npower = 1\n\nfor i in range(1, n+1):\n\n    power = power * i % mod\n\nprint(power)", "generated_code": "# coding: utf-8\n\nimport sys\n\n\n\nsr = lambda: sys.stdin.readline().rstrip()\n\nir = lambda: int(sr())\n\nlr = lambda: list(map(int, sr().split()))\n\n\n\nN = ir()\n\nV = lr()\n\nC = lr()\n\ntotal = 0\n\nfor i in range(N):\n\n    result = V[i] - C[i]\n\n    if result > 0:\n\n        total += result\n\n\n\nprint(total)\n", "score": 0.0, "codebleu": 0.20121003101781956, "crystalbleu": 0.0, "codebertscore": 0.7, "codescore": 0.13422593474388123, "surfaceSim": 0.451958762886598, "abs_surfaceSim_minus_score": 0.451958762886598}
{"golden_code": "import numpy as np\n\nN,x = list(map(int,input().split()))\n\nA = np.array(input().split(), dtype = np.int64)\n\nA.sort()\n\nnp.cumsum(A, out = A)\n\nanswer = (A <= x).sum()\n\n\n\nif answer == N and A[-1] != x:\n\n  answer -= 1\n\nprint(answer)\n", "generated_code": "k, n = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\n\n\na.append(k + a[0])\n\ndiff = [a1 - a0 for a0, a1 in zip(a, a[1:])]\n\n\n\nprint((k - max(diff)))\n", "score": 0.0, "codebleu": 0.19553395521856248, "crystalbleu": 0.052423309388291144, "codebertscore": 0.76, "codescore": 0.019773196429014206, "surfaceSim": 0.43336162988115445, "abs_surfaceSim_minus_score": 0.43336162988115445}
{"golden_code": "import math\n\n\n\nn = int(eval(input()))\n\nans = math.factorial(n) % (pow(10, 9) + 7)\n\nprint(ans)", "generated_code": "from heapq import heappop,heappush\n\nn,m=list(map(int,input().split()))\n\na=[int(i) for i in input().split()]\n\na.sort()\n\nbc=[[int(i) for i in input().split()]for j in range(m)]\n\nbc=sorted(bc, key=lambda x:x[1],reverse=True)\n\n\n\nans=[]\n\nfor b,c in bc:    \n\n    while b>0 and a: \n\n        x = heappop(a)\n\n        if x<c:\n\n            ans.append(c)\n\n            b-=1\n\n        else:\n\n            ans.append(x)\n\nprint((sum(ans)+sum(a)))", "score": 0.0, "codebleu": 0.2149207562409363, "crystalbleu": 0.0, "codebertscore": 0.67, "codescore": 0.9669732451438904, "surfaceSim": 0.36652202937249667, "abs_surfaceSim_minus_score": 0.36652202937249667}
{"golden_code": "import sys\n\ninput = sys.stdin.readline\n\nsys.setrecursionlimit(10 ** 7)\n\n\n\nK, S = list(map(int, input().split()))\n\n\n\nans = 0\n\nfor z in range(K+1):\n\n    for y in range(K+1):\n\n        x = S - (z + y)\n\n        if x >= 0 and x <= K:\n\n            ans += 1\n\nprint(ans)", "generated_code": "\n\nX = int(eval(input()))\n\nfor a in range(-120, 120):\n\n    find = False\n\n    for b in range(-120, 120):\n\n        x = a**5-b**5\n\n        if x == X:\n\n            find = True\n\n            print((a, b))\n\n            break\n\n    if find:\n\n        break\n", "score": 0.0, "codebleu": 0.10629431106989008, "crystalbleu": 0.0, "codebertscore": 0.73, "codescore": 0.9327317476272583, "surfaceSim": 0.4805008210180624, "abs_surfaceSim_minus_score": 0.4805008210180624}
{"golden_code": "A, B = list(map(int, input().split()))\n\ncnt = 0\n\nfor i in range(A, B+1):\n\n    l = list(str(i))\n\n\n\n    if l == list(reversed(l)):\n\n        cnt += 1\n\n\n\nprint(cnt)\n", "generated_code": "A, B, C, X, Y = list(map(int, input().split()))\n\n\n\n# ans = float('inf')\n\n\n\n# for i in range(10 ** 5 + 1):\n\n#     ans = min(ans, A * max(X - i, 0) + B * max(Y - i, 0) + 2 * C * i)\n\n# print(ans)\n\n\n\nmin_xy = min(X, Y)\n\nmax_xy = max(X, Y)\n\nans1 = 2 * C * min_xy + A * (X - min_xy) + B * (Y - min_xy)\n\nans2 = A * X + B * Y\n\nans3 = 2 * C * max_xy\n\nprint((min(ans1, ans2, ans3)))", "score": 0.0, "codebleu": 0.1734389657720051, "crystalbleu": 0.0, "codebertscore": 0.74, "codescore": 0.018602140247821808, "surfaceSim": 0.663907753254103, "abs_surfaceSim_minus_score": 0.663907753254103}
{"golden_code": "N,K=list(map(int,input().split()))\n\n\n\ncon = 0\n\nans = list(int() for _ in range(100000))\n\npre = 0\n\n\n\n\n\nfor _ in range(K):\n\n\n\n    D = int(eval(input()))\n\n    arr = list(map(int,input().split()))\n\n\n\n    for j in range(D):\n\n\n\n        ans[pre+j]=arr[j]\n\n\n\n    pre += D\n\n\n\n        \n\nfin = (N+1) - len(set(ans))\n\n\n\nprint(fin)", "generated_code": "N=int(eval(input()))\n\nroot=int((N**0.5)//1)\n\na=N\n\nb=N\n\nfor i in range(root, 0, -1):\n\n    if N%i==0:\n\n        a=i\n\n        b=N//i\n\n        break\n\nprint((a-1+b-1))\n", "score": 0.0, "codebleu": 0.118533467285066, "crystalbleu": 0.05335261452891302, "codebertscore": 0.76, "codescore": 0.13530410826206207, "surfaceSim": 0.4438454627133872, "abs_surfaceSim_minus_score": 0.4438454627133872}
{"golden_code": "import numpy as np\n\nN = int(eval(input()))\n\nA = np.array(list(map(int, input().split())))\n\ncount = 0\n\nwhile True:\n\n    if np.sum(A%2) > 0:\n\n        break\n\n    count +=1\n\n    A = A//2\n\nprint(count)\n", "generated_code": "n = int(eval(input()))\n\nary = list(map(int, input().split()))\n\n#print(n,ary)\n\n\n\nary_2 = [ary[0]]\n\nfor i in range(1, n):\n\n    ary_2.append(ary[i] + ary_2[i-1])\n\nary_2 = [0] + ary_2\n\n#print(ary_2)\n\n\n\nfrom collections import Counter\n\nc = Counter(ary_2)\n\nv = (list(c.values()))\n\n#print(v)\n\n\n\nans = 0\n\nfor j in v:\n\n    if j >1:\n\n        ans += j * (j-1) // 2\n\n\n\nprint(ans)\n", "score": 0.0, "codebleu": 0.2811772280591291, "crystalbleu": 0.0, "codebertscore": 0.75, "codescore": 0.14111016690731049, "surfaceSim": 0.5508540372670807, "abs_surfaceSim_minus_score": 0.5508540372670807}
{"golden_code": "from collections import defaultdict\n\nimport numpy as np\n\ndef main():\n\n    s = eval(input())\n\n    n = len(s)\n\n    d = np.zeros(2019,np.int64)\n\n    ans = 0\n\n    num = 0\n\n    pow10 = 1\n\n    d[0] = 1\n\n    for i in reversed(list(range(n))):\n\n        pow10 = pow10 * 10 % 2019\n\n        num += int(s[i]) * pow10\n\n        #print(num, num % 2019, i)\n\n        mod = num % 2019\n\n        ans += d[mod]\n\n        d[mod] += 1\n\n    print(ans)\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "generated_code": "a,b,c=1,0,0\n\nexec('a,b,c=b,c,a+c;'*(int(eval(input()))-2))\n\nprint((c%(10**9+7)))", "score": 0.0, "codebleu": 0.03993055555555555, "crystalbleu": 0.0, "codebertscore": 0.65, "codescore": 0.018280403688549995, "surfaceSim": 0.44882729211087424, "abs_surfaceSim_minus_score": 0.44882729211087424}
{"golden_code": "import sys\n\n_input = sys.stdin.readline\n\n\n\n\n\ndef resolve():\n\n    N = int(_input())\n\n    T = [list(map(int, _input().split())) for _ in range(N)]\n\n    t, x, y = 0, 0, 0\n\n    for next_t, next_x, next_y in T:\n\n        diff_xy = abs(x - next_x) + abs(y - next_y)\n\n        diff_t = next_t - t\n\n        if diff_xy > diff_t or (diff_xy % 2 != diff_t % 2):\n\n            print('No')\n\n            exit(0)\n\n    print('Yes')\n\n\n\n\n\nif __name__ == '__main__':\n\n    resolve()", "generated_code": "#!/usr/bin/env python3\n\n\n\nn = int(eval(input()))\n\ns = [eval(input()) for _ in range(n)]\n\nd = {}\n\n\n\nfor c in s:\n\n    if c[0] not in d:\n\n        d[c[0]] = 1 \n\n    else:\n\n        d[c[0]] += 1\n\n\n\ntmp = d.copy()\n\nt = ['M', 'A', 'R', 'C', 'H']\n\nfor c in tmp:\n\n    if c not in t:\n\n        d.pop(c)\n\n\n\nans = 0 \n\ndlist = list(d.items())\n\nfor i in range(len(dlist)):\n\n    for j in range(i+1, len(dlist)):\n\n        for k in range(j+1, len(dlist)):\n\n            ans += dlist[i][1]*dlist[j][1]*dlist[k][1]\n\nprint(ans)\n", "score": 0.0, "codebleu": 0.16526219851106094, "crystalbleu": 0.0410777322715715, "codebertscore": 0.69, "codescore": 0.1646476686000824, "surfaceSim": 0.44342291371994347, "abs_surfaceSim_minus_score": 0.44342291371994347}
{"golden_code": "NN = 19\n\nXX = [0] * (2**(NN+1)-1)\n\n\n\ndef addvalue(j, x):\n\n    i = 2**NN + j - 1\n\n    while i >= 0:\n\n        XX[i] += x\n\n        i = (i-1) // 2\n\n\n\ndef rangesum(a, b):\n\n    l = a + (1<<NN)\n\n    r = b + (1<<NN)\n\n    s = 0\n\n    while l < r:\n\n        if l%2:\n\n            s += XX[l-1]\n\n            l += 1\n\n        if r%2:\n\n            r -= 1\n\n            s += XX[r-1]\n\n        l >>= 1\n\n        r >>= 1\n\n    return s\n\n\n\nN, Q = map(int, input().split())\n\nC = [int(a) - 1 for a in input().split()]\n\nX = [[] for _ in range(N)]\n\nfor i in range(Q):\n\n    l, r = map(int, input().split())\n\n    X[r-1].append((l - 1, i))\n\nlast = [-1] * N\n\nANS = [-1] * Q\n\naddvalue(1, N)\n\nfor r in range(N):\n\n    c = C[r]\n\n    addvalue(last[c] + 2, -1)\n\n    addvalue(r + 2, 1)\n\n    last[c] = r\n\n    for l, i in X[r]:\n\n        ANS[i] = rangesum(l + 2, 1 << NN)\n\n    \n\nprint(*ANS, sep = \"\\n\")\n", "generated_code": "def main():\n\n    n = int(eval(input()))\n\n    dp = [[0 for i in range(10)] for i in range(10)]\n\n    for i in range(1,n+1):\n\n        h,t = int(str(i)[0]), int(str(i)[-1])\n\n        dp[h][t] += 1\n\n    ans = 0\n\n    for i in range(10):\n\n        for j in range(10):\n\n            ans += dp[i][j] * dp[j][i]\n\n    print(ans)\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "score": 0.0, "codebleu": 0.10318383135384099, "crystalbleu": 0.022274817306841655, "codebertscore": 0.74, "codescore": 0.24121014773845673, "surfaceSim": 0.5572759022118743, "abs_surfaceSim_minus_score": 0.5572759022118743}
{"golden_code": "N,M = list(map(int,input().split()))\n\nL,R = [],[]\n\nfor i in range(M):\n\n    l,r = list(map(int,input().split()))\n\n    L.append(l)\n\n    R.append(r)\n\nans = min(R)-max(L)+1\n\nprint((ans if ans >= 0 else 0))", "generated_code": "import sys\n\ninput = sys.stdin.readline\n\n\n\nn, m = list(map(int, input().split()))\n\nbroken = set([int(eval(input())) for _ in range(m)]) # ここが'list'だとPypyでも通らない\n\n\n\ndef ptn_num(x): # 'x'stepまでのパターン数\n\n    dp = [0] * (x+1) # DP枠_including step'0'\n\n    if 1 in broken: # 固定部分_in case, step'1' broken \n\n        dp[:2] = 1, 0\n\n    else:\n\n        dp[:2] = 1, 1 # 固定部分_Usually\n\n\n\n    for i in range(2, x+1):\n\n        if i not in broken: # 階段が壊れてない場合...\n\n            dp[i] = (dp[i-1] + dp[i-2]) % (10**9+7) # -1段目と-2段目の合計\n\n    print((dp[-1]))\n\n\n\nptn_num(n)", "score": 0.0, "codebleu": 0.2543097414764879, "crystalbleu": 0.08988477924135858, "codebertscore": 0.66, "codescore": 0.14899370074272156, "surfaceSim": 0.5350662589194699, "abs_surfaceSim_minus_score": 0.5350662589194699}
{"golden_code": "N = int(eval(input()))\n\nA = list(map(int,input().split()))\n\n\n\nSUM = 0\n\nfor i in A:\n\n    count = 0\n\n    while i%2 == 0:\n\n        i//=2\n\n        count += 1\n\n    SUM+=count\n\nprint(SUM)", "generated_code": "#!usr/bin/env python3\n\nfrom collections import defaultdict,deque\n\nfrom heapq import heappush, heappop\n\nfrom itertools import permutations\n\nimport sys\n\nimport math\n\nimport bisect\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\n\ndef I(): return int(sys.stdin.readline())\n\ndef LS():return [list(x) for x in sys.stdin.readline().split()]\n\ndef S():\n\n    res = list(sys.stdin.readline())\n\n    if res[-1] == \"\\n\":\n\n        return res[:-1]\n\n    return res\n\ndef IR(n):\n\n    return [I() for i in range(n)]\n\ndef LIR(n):\n\n    return [LI() for i in range(n)]\n\ndef SR(n):\n\n    return [S() for i in range(n)]\n\ndef LSR(n):\n\n    return [LS() for i in range(n)]\n\n\n\nsys.setrecursionlimit(1000000)\n\nmod = 1000000007\n\n\n\ndef solve():\n\n    def v(n):\n\n        return [n*10%k, (n+1)%k]\n\n    k = I()\n\n    d = [float(\"inf\")]*k\n\n    d[1] = 1\n\n    q = deque([1])\n\n    while q:\n\n        x = q.popleft()\n\n        vx = v(x)\n\n        dx = d[x]\n\n        for c in range(2):\n\n            nd = dx+c\n\n            y = vx[c]\n\n            if nd < d[y]:\n\n                d[y] = nd\n\n                if c:\n\n                    q.append(y)\n\n                else:\n\n                    q.appendleft(y)\n\n    print((d[0]))\n\n    return\n\n\n\n#Solve\n\nif __name__ == \"__main__\":\n\n    solve()\n", "score": 0.0, "codebleu": 0.22781052465843776, "crystalbleu": 0.02905433084428338, "codebertscore": 0.65, "codescore": 0.020276067778468132, "surfaceSim": 0.4223817118553961, "abs_surfaceSim_minus_score": 0.4223817118553961}
{"golden_code": "import math\n\nimport statistics\n\nn = int(eval(input()))\n\na = list(map(int,input().split()))\n\na = [aa-i-1 for i, aa in enumerate(a)]\n\nanswer = n*10**20\n\nmedian_low = statistics.median_low(a)\n\nmedian_high = statistics.median_high(a)\n\n\n\nfor m in (median_low,median_high):\n\n  ans=0\n\n  for aa in a:\n\n    ans += abs(aa-m)\n\n  answer = min(ans,answer)\n\nprint(answer)\n", "generated_code": "import sys\n\nn,m = [int(x) for x in sys.stdin.readline().split()]\n\nr = [0]*n\n\nfor _ in range(m):\n\n\ta, b = [int(x) for x in sys.stdin.readline().split()]\n\n\tr[a-1] += 1\n\n\tr[b-1] += 1\n\nfor i in r:\n\n\tprint(i)", "score": 0.0, "codebleu": 0.14311641317550478, "crystalbleu": 0.030665689458871728, "codebertscore": 0.77, "codescore": 0.05837399885058403, "surfaceSim": 0.6052141527001862, "abs_surfaceSim_minus_score": 0.6052141527001862}
{"golden_code": "class Calc:\n\n    def __init__(self, max_value, mod):\n\n        \"\"\"combination(max_value, all)\"\"\"\n\n        fact = [-1] * (max_value + 1)\n\n        fact[0] = 1\n\n        fact[1] = 1\n\n        for x in range(2, max_value + 1):\n\n            fact[x] = x * fact[x - 1] % mod\n\n\n\n        invs = [1] * (max_value + 1)\n\n        invs[max_value] = pow(fact[max_value], mod - 2, mod)\n\n        for x in range(max_value - 1, 0, -1):\n\n            invs[x] = invs[x + 1] * (x + 1) % mod\n\n\n\n        self.fact = fact\n\n        self.invs = invs\n\n        self.mod = mod\n\n\n\n    def combination(self, n, r):\n\n        if n - r < r:\n\n            return self.combination(n, n - r)\n\n        if r < 0:\n\n            return 0\n\n        if r == 0:\n\n            return 1\n\n        if r == 1:\n\n            return n\n\n        return self.fact[n] * self.invs[r] * self.invs[n - r] % self.mod\n\n\n\n\n\ndef gen(n):\n\n    x = n\n\n    d = 2\n\n    cnt = 0\n\n    while x % d == 0:\n\n        x //= d\n\n        cnt += 1\n\n    yield cnt\n\n\n\n    d = 3\n\n    ma = d * d\n\n    while ma <= n:\n\n        cnt = 0\n\n        while x % d == 0:\n\n            x //= d\n\n            cnt += 1\n\n        yield cnt\n\n        ma += d * 4 + 4\n\n        d += 2\n\n\n\n    if x > 1:\n\n        yield 1\n\n\n\n\n\ndef main():\n\n    MOD = 10 ** 9 + 7\n\n\n\n    N, M = list(map(int, input().split()))\n\n\n\n    cal = Calc(max_value=N + 30, mod=MOD)\n\n\n\n    ans = 1\n\n    for cnt in gen(M):\n\n        ans = (ans * cal.combination(N + cnt - 1, cnt)) % MOD\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "generated_code": "#!usr/bin/env python3\n\nfrom collections import defaultdict\n\nfrom collections import deque\n\nfrom heapq import heappush, heappop\n\nimport sys\n\nimport math\n\nimport bisect\n\nimport random\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\n\ndef I(): return int(sys.stdin.readline())\n\ndef LS():return list(map(list, sys.stdin.readline().split()))\n\ndef S(): return list(sys.stdin.readline())[:-1]\n\ndef IR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = I()\n\n    return l\n\ndef LIR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = LI()\n\n    return l\n\ndef SR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = S()\n\n    return l\n\ndef LSR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = SR()\n\n    return l\n\nmod = 1000000007\n\n\n\n#A\n\n\"\"\"\n\ndef gcd(a,b):\n\n    if a == 0:\n\n        return b\n\n    return gcd(b%a,a)\n\nn = I()\n\na = IR(n)\n\nl = a[0]\n\nfor i in range(1,n):\n\n    g = gcd(l,a[i])\n\n    l *= a[i]//g\n\nprint(l)\n\n\"\"\"\n\n\n\n#B\n\nn = I()\n\nv = [[] for i in range(n)]\n\nfor i in range(n-1):\n\n    a,b,c = LI()\n\n    a -= 1\n\n    b -= 1\n\n    v[a].append([b,c])\n\n    v[b].append([a,c])\n\nQ,k = LI()\n\nd = [-1 for i in range(n)]\n\nd[k-1] = 0\n\nq = deque()\n\nq.append(k-1)\n\nwhile q:\n\n    x = q.popleft()\n\n    for y,c in v[x]:\n\n        if d[y] == -1:\n\n            d[y] = d[x]+c\n\n            q.append(y)\n\nfor i in range(Q):\n\n    x,y = LI()\n\n    x -= 1\n\n    y -= 1\n\n    print((d[x]+d[y]))\n\n#C\n\n\n\n#D\n\n\n\n#E\n\n\n\n#F\n\n\n\n#G\n\n\n\n#H\n\n\n\n#I\n\n\n\n#J\n\n\n\n#K\n\n\n\n#L\n\n\n\n#M\n\n\n\n#N\n\n\n\n#O\n\n\n\n#P\n\n\n\n#Q\n\n\n\n#R\n\n\n\n#S\n\n\n\n#T\n", "score": 0.0, "codebleu": 0.14368433052150092, "crystalbleu": 0.06098516626235717, "codebertscore": 0.74, "codescore": 0.9863560199737549, "surfaceSim": 0.5323284761960947, "abs_surfaceSim_minus_score": 0.5323284761960947}
{"golden_code": "import numpy as np\n\nfrom itertools import product\n\n\n\nn = int(eval(input()))\n\na = list(map(int,input().split()))\n\n\n\na = np.array(a)\n\n\n\nli = [-1,0,1]\n\ncnt = 0\n\nfor v in product(li,repeat = n):\n\n    v = np.array(v)\n\n    L =a+v\n\n    cum = L.cumprod()\n\n    if cum[-1]%2 ==0 :\n\n        cnt +=1\n\nprint(cnt)\n\n        ", "generated_code": "from collections import defaultdict\n\nN = int(eval(input()))\n\n\n\nF = [True]*(N+1)\n\nF[0]=F[1]=False\n\nP = []\n\n\n\nfor i in range(2,N+1):\n\n    if F[i]==True:\n\n        P.append(i)\n\n        for j in range(i*2,N+1,i):\n\n            F[j]=False\n\n\n\ndic = defaultdict(int)\n\nfor i in range(2,N+1):\n\n    for p in P:\n\n        while i%p==0:\n\n            dic[p] += 1\n\n            i = i//p\n\n        if i==1:\n\n            break\n\n\n\nans = 1\n\nmodulo = 10**9+7\n\nfor v in list(dic.values()):\n\n    ans *= (v+1)\n\n    ans %= modulo\n\n\n\nprint(ans)", "score": 0.0, "codebleu": 0.2520005809487104, "crystalbleu": 0.08197242289766514, "codebertscore": 0.72, "codescore": 0.9936694502830505, "surfaceSim": 0.5975571562793611, "abs_surfaceSim_minus_score": 0.5975571562793611}
{"golden_code": "# https://atcoder.jp/contests/abc129/tasks/abc129_c\n\n# 典型的なDP\n\n\n\nMOD = 10**9 + 7\n\nimport numpy as np\n\n# dp[i]をi段目までの通りの数とする。\n\nN, M = list(map(int, input().split()))\n\nto_zero = np.full((N + 1), False).tolist()\n\nfor _ in range(M):\n\n    to_zero[int(eval(input()))] = True  # 床が抜けているところ\n\n\n\n# dpテーブルの用意\n\ndp = np.full((N + 1), -1).tolist()\n\ndp[0] = 1\n\ndp[1] = 0 if to_zero[1] else 1\n\nfor i in range(2, N + 1):\n\n    dp[i] = 0 if to_zero[i] else dp[i - 2] + dp[i - 1]\n\n    if dp[i] > MOD:\n\n        dp[i] %= MOD\n\n\n\nprint((dp[-1]))\n", "generated_code": "# encoding:utf-8\n\n\n\ninput = list(map(int, input().split()))\n\nW, H, x, y, r = input\n\n\n\nif x - r < 0 or x + r > W:\n\n\tprint(\"No\")\n\nelif y - r < 0 or y + r > H:\n\n\tprint(\"No\")\n\nelse:\n\n\tprint(\"Yes\")", "score": 0.0, "codebleu": 0.0653315171063223, "crystalbleu": 0.04906728788758096, "codebertscore": 0.62, "codescore": 0.6139909029006958, "surfaceSim": 0.542528735632184, "abs_surfaceSim_minus_score": 0.542528735632184}
{"golden_code": "import numpy as np\n\nN=int(eval(input()))\n\nroot=int(np.sqrt(N)//1)\n\na=N\n\nb=N\n\nfor i in range(root, 0, -1):\n\n    if N%i==0:\n\n        a=i\n\n        b=N//i\n\n        break\n\nprint((a-1+b-1))", "generated_code": "import sys\n\nsys.setrecursionlimit(10**8)\n\nN = int(eval(input()))\n\nA = [int(eval(input()))-1 for i in range(N-1)]\n\nwins = [[] for _ in range(N)]\n\n\n\nfor i,a in enumerate(A):\n\n    wins[a].append(i+1)\n\n\n\ndepth = [-1] * N\n\ndef dep(v):\n\n    if len(wins[v])==0: return 0\n\n    if depth[v] >= 0:\n\n        return depth[v]\n\n    ds = []\n\n    for w in wins[v]:\n\n        ds.append(dep(w))\n\n    ds.sort(reverse=True)\n\n    ret = 0\n\n    for i,d in enumerate(ds):\n\n        ret = max(ret, i+d+1)\n\n    depth[v] = ret\n\n    return ret\n\nprint((dep(0)))", "score": 0.0, "codebleu": 0.23050568603659163, "crystalbleu": 0.07827078057376866, "codebertscore": 0.76, "codescore": 0.28967833518981934, "surfaceSim": 0.4791549583610075, "abs_surfaceSim_minus_score": 0.4791549583610075}
{"golden_code": "import math\n\n\n\nN = int(eval(input()))\n\n\n\nnum = math.factorial(N)\n\n\n\nk, r = divmod(num, 10**9 + 7)\n\nprint(r)", "generated_code": "from statistics import median_low\n\n\n\nN = int(eval(input()))\n\nA = list(map(int, input().split()))\n\n\n\nD = []\n\nfor i in range(N):\n\n    D.append(A[i] - (i+1))\n\n\n\nm = median_low(D)\n\nans = 0\n\nfor d in D:\n\n    ans += abs(d - m)\n\n\n\nprint(ans)\n", "score": 0.0, "codebleu": 0.30849763011348397, "crystalbleu": 0.0, "codebertscore": 0.73, "codescore": 0.9340108036994934, "surfaceSim": 0.5110251450676982, "abs_surfaceSim_minus_score": 0.5110251450676982}
{"golden_code": "a,b,c=1,0,0\n\nexec('a,b,c=b,c,(a+c)%(10**9+7);'*(int(eval(input()))-2))\n\nprint(c)", "generated_code": "import sys\n\nn,m = [int(x) for x in sys.stdin.readline().split()]\n\nr = [0]*n\n\nfor _ in range(m):\n\n\ta, b = [int(x) for x in sys.stdin.readline().split()]\n\n\tr[a-1] += 1\n\n\tr[b-1] += 1\n\nfor i in r:\n\n\tprint(i)", "score": 0.0, "codebleu": 0.11904761904761904, "crystalbleu": 0.0, "codebertscore": 0.74, "codescore": 0.021458912640810013, "surfaceSim": 0.4234311415720711, "abs_surfaceSim_minus_score": 0.4234311415720711}
{"golden_code": "import numpy as np\n\n \n\ndef main():\n\n    stdin = np.fromstring(open(0).read(), dtype=np.int64, sep=' ')\n\n    A = stdin[1:]\n\n    A = np.mod(A, 2)\n\n    print(\"first\") if np.count_nonzero(A) else print(\"second\")\n\nif __name__ == \"__main__\":\n\n    main()\n", "generated_code": "import sys\n\nimport itertools\n\n# import numpy as np\n\nimport time\n\nimport math\n\nimport heapq\n\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10 ** 7)\n\n \n\nINF = 10 ** 9 + 7\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\n# map(int, input().split())\n\n\n\nN, M = list(map(int, input().split()))\n\nA = list([int(x) // 2 for x in input().split()])\n\n\n\ndef f(n):\n\n    res = 0\n\n    while n % 2 == 0:\n\n        n //= 2\n\n        res += 1\n\n    return res\n\n\n\ndef gcd(a, b):\n\n    if b == 0:\n\n        return a\n\n    return gcd(b, a % b)\n\n\n\nx = f(A[0])\n\nfor a in A:\n\n    y = f(a)\n\n    if y != x:\n\n        print((0))\n\n        exit()\n\n\n\nlcm = A[0]\n\nfor i in range(1, N):\n\n    lcm = lcm * A[i] //  gcd(lcm, A[i])\n\n\n\nprint(((M // lcm + 1) // 2))", "score": 0.0, "codebleu": 0.262696830987688, "crystalbleu": 0.0, "codebertscore": 0.67, "codescore": 0.9931085109710693, "surfaceSim": 0.45328136700932675, "abs_surfaceSim_minus_score": 0.45328136700932675}
{"golden_code": "K,S=list(map(int,input().split()))\n\nO=0\n\nfor X in range(K+1):\n\n  for Y in range(K+1):\n\n    Z=S-X-Y\n\n    if 0<=Z<=K:\n\n      O+=1\n\nprint(O)\n", "generated_code": "n = int(eval(input()))\n\na_list = list(map(int, input().split()))\n\na_list = sorted(a_list, reverse=True)\n\n\n\nalice_point = 0\n\nbob_point = 0\n\nfor i in range(n):\n\n    if i % 2 == 0:\n\n        alice_point += a_list[i]\n\n    else:\n\n        bob_point += a_list[i]\n\n\n\nprint((alice_point - bob_point))", "score": 0.0, "codebleu": 0.1823265301749886, "crystalbleu": 0.0, "codebertscore": 0.75, "codescore": 0.13165368139743805, "surfaceSim": 0.5719640179910045, "abs_surfaceSim_minus_score": 0.5719640179910045}
{"golden_code": "N, M = list(map(int, input().split(\" \")))\n\nA = {int(eval(input())) for _ in range(M)}\n\n\n\nmemo = [0] * (N + 1)\n\nmemo[0] = 1\n\nmemo[1] = 0 if 1 in A else 1\n\n\n\nif N == 1:\n\n    print((memo[1]))\n\nelse:\n\n    for i in range(2, N + 1):\n\n        if i in A:\n\n            continue\n\n        memo[i] = (memo[i - 2] + memo[i - 1]) % 1000000007\n\n\n\n    print((memo[N]))\n", "generated_code": "k,s=list(map(int,input().split()))\n\na=0\n\nfor i in range(0,k+1):\n\n    for j in range(0,k+1):\n\n        if 0<=s-i-j<=k:\n\n            a+=1\n\nprint(a)", "score": 0.0, "codebleu": 0.1134369213422267, "crystalbleu": 0.1045799417756852, "codebertscore": 0.76, "codescore": 0.5213841199874878, "surfaceSim": 0.5435674514017779, "abs_surfaceSim_minus_score": 0.5435674514017779}
{"golden_code": "\n\nX = int(eval(input()))\n\nfor a in range(-200, 200):\n\n    find = False\n\n    for b in range(-200, 200):\n\n        x = a**5-b**5\n\n        if x == X:\n\n            find = True\n\n            print((a, b))\n\n            break\n\n    if find:\n\n        break\n", "generated_code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,copy,functools\n\nimport time,random\n\n\n\nsys.setrecursionlimit(10**7)\n\ninf = 10**20\n\neps = 1.0 / 10**10\n\nmod = 10**9+7\n\nmod2 = 998244353\n\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\n\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\n\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\n\ndef LLI(): return [list(map(int, l.split())) for l in sys.stdin.readlines()]\n\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\n\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\n\ndef LS(): return sys.stdin.readline().split()\n\ndef I(): return int(sys.stdin.readline())\n\ndef F(): return float(sys.stdin.readline())\n\ndef S(): return input()\n\ndef pf(s): return print(s, flush=True)\n\ndef pe(s): return print(str(s), file=sys.stderr)\n\ndef JA(a, sep): return sep.join(map(str, a))\n\ndef JAA(a, s, t): return s.join(t.join(map(str, b)) for b in a)\n\n\n\n\n\nclass Flow():\n\n    def __init__(self, e, N):\n\n        self.E = e\n\n        self.N = N\n\n\n\n    def max_flow(self, s, t):\n\n        r = 0\n\n        e = self.E\n\n\n\n        def f(c, cap):\n\n            v = self.v\n\n            v[c] = 1\n\n            if c == t:\n\n                return cap\n\n            for i in range(self.N):\n\n                if v[i] or e[c][i] <= 0:\n\n                    continue\n\n                cp = min(cap, e[c][i])\n\n                k = f(i, cp)\n\n                if k > 0:\n\n                    e[c][i] -= k\n\n                    e[i][c] += k\n\n                    return k\n\n            return 0\n\n\n\n        while True:\n\n            self.v = [None] * self.N\n\n            fs = f(s, inf)\n\n            if fs == 0:\n\n                break\n\n            r += fs\n\n\n\n        return r\n\n\n\n\n\ndef main():\n\n    n = I()\n\n    a = LI()\n\n\n\n    s = n\n\n    t = n + 1\n\n    e = [[0] * (n+2) for _ in range(n+2)]\n\n    for i in range(n):\n\n        c = a[i]\n\n        if c < 0:\n\n            e[s][i] = -c\n\n            ii = i + 1\n\n            for j in range(ii*2, n+1, ii):\n\n                e[i][j-1] = inf\n\n        else:\n\n            e[i][t] = c\n\n\n\n\n\n    fl = Flow(e, n+2)\n\n    r = fl.max_flow(s,t)\n\n\n\n    return sum(map(lambda x: max(0,x), a)) - r\n\n\n\n# start = time.time()\n\nprint(main())\n\n# pe(time.time() - start)\n\n\n\n\n\n\n", "score": 0.0, "codebleu": 0.16386594700914503, "crystalbleu": 0.01886019555006069, "codebertscore": 0.66, "codescore": 0.9939269423484802, "surfaceSim": 0.40967449223878294, "abs_surfaceSim_minus_score": 0.40967449223878294}
{"golden_code": "N=int(eval(input()))\n\nd=list(map(int, input().split()))\n\n\n\nimport numpy as np\n\nd = np.array(d)\n\n\n\nprint(( ( (np.sum(d))**2 - np.sum(d**2) ) // 2 ))\n", "generated_code": "a,b = list(map(int, input().split()))\n\nn = [i for i in map(str, list(range(a,b+1))) if i==i[::-1]]\n\nprint((len(n)))", "score": 0.0, "codebleu": 0.22818513823581066, "crystalbleu": 0.0, "codebertscore": 0.76, "codescore": 0.036593563854694366, "surfaceSim": 0.41621621621621624, "abs_surfaceSim_minus_score": 0.41621621621621624}
{"golden_code": "x = int(eval(input()))\n\n\n\nfor a in range(-118,119):\n\n  for b in range(-119,118):\n\n    if a**5 - b**5 == x:\n\n      print((a,b))\n\n      exit()", "generated_code": "N=int(eval(input()))\n\nA=list(map(int,input().split()))\n\nB=[]\n\nfor i in range(N):\n\n    B.append(A[i]-i-1)\n\nB.sort()\n\nif N%2:\n\n    b=B[N//2]\n\nelse:\n\n    b=(B[N//2]+B[N//2-1])//2\n\nans=0\n\nfor k in B:\n\n    ans+=abs(k-b)\n\nprint(ans)", "score": 0.0, "codebleu": 0.25981504957891477, "crystalbleu": 0.07286366005379401, "codebertscore": 0.75, "codescore": 0.30623897910118103, "surfaceSim": 0.4365214431586113, "abs_surfaceSim_minus_score": 0.4365214431586113}
{"golden_code": "import sys\n\ninput = sys.stdin.readline\n\n\n\nn, m = list(map(int, input().split()))\n\nbroken = set([int(eval(input())) for _ in range(m)]) # ここが'list'だとPypyでも通らない\n\n\n\ndef ptn_num(x): # 'x'stepまでのパターン数\n\n    dp = [0] * (x+1) # DP枠_including step'0'\n\n    if 1 in broken: # in case, step'1' broken \n\n        dp[:2] = 1, 0\n\n    else:\n\n        dp[:2] = 1, 1 # Usually\n\n\n\n    for i in range(2, x+1):\n\n        if i not in broken: # 階段が壊れてない場合...\n\n            dp[i] = (dp[i-1] + dp[i-2]) % (10**9+7) # -1段目と-2段目の合計\n\n    print((dp[-1]))\n\n\n\nptn_num(n)\n", "generated_code": "import sys\n\n\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\nreadlines = sys.stdin.readlines\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = 1 << 60\n\n\n\n\n\ndef gcd(a, b):\n\n    while b:\n\n        a, b = b, a % b\n\n    return a\n\n\n\n\n\ndef lcm(a, b):\n\n    return a * b // gcd(a, b)\n\n\n\n\n\ndef main():\n\n    N, M, *A = list(map(int, read().split()))\n\n    A = list(set(A))\n\n    B = A.copy()\n\n\n\n    while not any(b % 2 for b in B):\n\n        B = [b // 2 for b in B]\n\n\n\n    if not all(b % 2 for b in B):\n\n        print((0))\n\n        return\n\n\n\n    semi_lcm = 1\n\n    for a in A:\n\n        semi_lcm = lcm(semi_lcm, a // 2)\n\n\n\n    print(((M // semi_lcm + 1) // 2))\n\n    return\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 0.0, "codebleu": 0.16373340042453094, "crystalbleu": 0.12041231626572094, "codebertscore": 0.7, "codescore": 0.05869858339428902, "surfaceSim": 0.5584477693516431, "abs_surfaceSim_minus_score": 0.5584477693516431}
{"golden_code": "n,k = list(map(int,input().split()))\n\nnum = 0\n\nq = []\n\nfor i in range(n):\n\n    a,b = list(map(int,input().split()))\n\n    q.append((a,b))\n\nq.sort()\n\nfor i in range(n):\n\n    a, b = q[i][0], q[i][1]\n\n    num += b\n\n    if num >= k:\n\n        print(a)\n\n        exit()\n\n\n", "generated_code": "A, B = list(map(int, input().split()))\n\ncount_target = 0\n\n\n\nfor i in range(A, B+1):\n\n    str_i = str(i)\n\n    reversed_i = str_i[::-1]\n\n\n\n    if str_i == reversed_i:\n\n        count_target += 1\n\n\n\nprint(count_target)\n", "score": 0.0, "codebleu": 0.26825015936320024, "crystalbleu": 0.08144491656435851, "codebertscore": 0.8, "codescore": 0.7309741973876953, "surfaceSim": 0.5946969696969697, "abs_surfaceSim_minus_score": 0.5946969696969697}
{"golden_code": "import sys, re\n\nfrom collections import deque, defaultdict, Counter\n\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, radians\n\nfrom itertools import accumulate, permutations, combinations, product, groupby\n\nfrom operator import itemgetter, mul\n\nfrom copy import deepcopy\n\nfrom string import ascii_lowercase, ascii_uppercase, digits\n\nfrom bisect import bisect, bisect_left\n\nfrom fractions import gcd\n\nfrom heapq import heappush, heappop\n\nfrom functools import reduce\n\ndef input(): return sys.stdin.readline().strip()\n\ndef INT(): return int(eval(input()))\n\ndef MAP(): return list(map(int, input().split()))\n\ndef LIST(): return list(map(int, input().split()))\n\ndef ZIP(n): return list(zip(*(MAP() for _ in range(n))))\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = float('inf')\n\nmod = 10 ** 9 + 7\n\nimport numpy as np\n\n\n\nK, N = MAP()\n\nA = LIST()\n\nA.append(A[0]+K)\n\n\n\nB = np.zeros(N)\n\nfor i in range(N):\n\n  \t\tB[i] = A[i+1] - A[i]\n\n\n\nprint((int(K - max(B))))", "generated_code": "def gen(n):\n\n    x = n\n\n    d = 2\n\n    cnt = 0\n\n    while x % d == 0:\n\n        x //= d\n\n        cnt += 1\n\n    yield cnt\n\n\n\n    d = 3\n\n    while d * d <= n:\n\n        cnt = 0\n\n        while x % d == 0:\n\n            x //= d\n\n            cnt += 1\n\n        yield cnt\n\n        d += 2\n\n\n\n    if x > 1:\n\n        yield 1\n\n\n\n\n\ndef main():\n\n    MOD = 10 ** 9 + 7\n\n\n\n    N, M = list(map(int, input().split()))\n\n\n\n    ans = 1\n\n    for cnt in gen(M):\n\n        for d in range(cnt):\n\n            ans = (ans * (N - 1 + cnt - d) % MOD) * pow(d + 1, MOD - 2, MOD) % MOD\n\n            \n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 0.0, "codebleu": 0.20086190645051186, "crystalbleu": 0.07018354876580685, "codebertscore": 0.69, "codescore": 0.021459704264998436, "surfaceSim": 0.38276260735520806, "abs_surfaceSim_minus_score": 0.38276260735520806}
{"golden_code": "a,b=list(map(int,input().split()))\n\n\n\nans=0\n\n\n\nfor i in range(a,b+1):\n\n    buf=str(i)\n\n    #print(buf[0:int(len(buf)/2)],buf[int(len(buf)/2+1):])\n\n    str1=buf[0:int(len(buf)/2)]\n\n    str2=buf[int(len(buf)/2+1):]\n\n    if str1[0]==str2[1] and str1[1]==str2[0]:\n\n        ans+=1\n\n\n\nprint(ans)\n", "generated_code": "def main():\n\n    N, M = list(map(int, input().split()))\n\n\n\n    def factorization(n):\n\n        arr = []\n\n        temp = n\n\n        for i in range(2, int(-(-n**0.5//1))+1):\n\n            if temp % i == 0:\n\n                cnt = 0\n\n                while temp % i == 0:\n\n                    cnt += 1\n\n                    temp //= i\n\n                arr.append([i, cnt])\n\n        if temp != 1:\n\n            arr.append([temp, 1])\n\n\n\n        if arr == [] and n != 1:\n\n            arr.append([n, 1])\n\n\n\n        return arr\n\n\n\n    mod = 10**9 + 7\n\n\n\n    def cmb(n, r, mod):\n\n        if (r < 0 or r > n):\n\n            return 0\n\n        r = min(r, n-r)\n\n        return g1[n] * g2[r] * g2[n-r] % mod\n\n\n\n    g1 = [1, 1]\n\n    g2 = [1, 1]\n\n    inverse = [0, 1]\n\n    for i in range(2, N+100 + 1):\n\n        g1.append((g1[-1] * i) % mod)\n\n        inverse.append((-inverse[mod % i] * (mod//i)) % mod)\n\n        g2.append((g2[-1] * inverse[-1]) % mod)\n\n\n\n    primes = factorization(M)\n\n    # 何箇所に分けるか（cnt以下）,その中でどう分けるか（しきりをどこにおくか（振り分けられないものが出ると選べれないのとおなじになるので、cnt - 選んだ数））\n\n\n\n    ans = 1\n\n\n\n    for p, cnt in primes:\n\n        tmp = cmb(N+cnt-1, N-1, mod)\n\n        ans *= tmp\n\n        ans %= mod\n\n\n\n    print(ans)\n\n\n\n\n\nmain()\n", "score": 0.0, "codebleu": 0.22450882231674, "crystalbleu": 0.09433353815091139, "codebertscore": 0.69, "codescore": 0.9938960671424866, "surfaceSim": 0.5516014975041597, "abs_surfaceSim_minus_score": 0.5516014975041597}
{"golden_code": "import math\n\nn = int(eval(input()))\n\na = list(map(int, input().split()))\n\n\n\n\n\ndef trial_division(n):\n\n    factor = []\n\n    tmp = int(math.sqrt(n)) + 1\n\n    for _ in range(2,tmp):\n\n        while n % 2 == 0:\n\n            n //= 2\n\n            factor.append(2)\n\n    if not factor:\n\n        return [n]\n\n    else:\n\n        factor.append(n)\n\n        return factor\n\n\n\n\n\ncount = 0\n\nfor i in a:\n\n    temp = trial_division(i)\n\n    count += temp.count(2)\n\n\n\nprint(count)", "generated_code": "n, m, k = list(map(int, input().split()))\n\n\n\nmod = 1000000007\n\nfac = [1]\n\nfor i in range(1, n * m + 1):\n\n    fac.append((fac[-1] * i) % mod)\n\n\n\ndef pow(x, n):\n\n    ret = 1\n\n    while n > 0:\n\n        if (n & 1) == 1:\n\n            ret = (ret * x) % mod\n\n        x = (x * x) % mod\n\n        n >>= 1\n\n    return ret\n\n\n\ndef inv(i):\n\n    return pow(fac[i], mod - 2)\n\n\n\ndef cmb(n, k):\n\n    return (fac[n] * inv(k) * inv(n - k)) % mod\n\n\n\nx = sum(d * (m - d) for d in range(m)) % mod\n\ny = sum(d * (n - d) for d in range(n)) % mod\n\n\n\nc = cmb(n * m - 2, k - 2)\n\nx = (x * n * n * c) % mod\n\ny = (y * m * m * c) % mod\n\n\n\nprint(((x + y) % mod))", "score": 0.0, "codebleu": 0.1739915266028234, "crystalbleu": 0.12626706825817433, "codebertscore": 0.76, "codescore": 0.8532531261444092, "surfaceSim": 0.5521190592846643, "abs_surfaceSim_minus_score": 0.5521190592846643}
{"golden_code": "n = int(eval(input()))\n\nr = int(n**.5)\n\nfor i in range(r):\n\n  if n % (r-i) == 0:\n\n    print(( (r-i) + n//(r-i) - 2 ))\n\n    break", "generated_code": "a, b = list(map(int, input().split()))\n\nans = 0\n\nfor n in range(a, b+1):\n\n    if str(n) == str(n)[::-1]: ans += 1\n\nprint(ans)", "score": 0.0, "codebleu": 0.0971328994058166, "crystalbleu": 0.0, "codebertscore": 0.78, "codescore": 0.1072554811835289, "surfaceSim": 0.4996995192307692, "abs_surfaceSim_minus_score": 0.4996995192307692}
{"golden_code": "def solve(string):\n\n    x = int(string)\n\n    a = {i**5: i for i in range(-10000, 10000)}\n\n    for i in range(-10000, 10000):\n\n        if x + i ** 5 in a:\n\n            return str(f\"{a[x+i**5]} {i}\")\n\n\n\n\n\nif __name__ == '__main__':\n\n    import sys\n\n    print((solve(sys.stdin.read().strip())))\n", "generated_code": "import sys\n\nread = sys.stdin.readline\n\n\n\n\n\ndef read_ints():\n\n    return list(map(int, read().split()))\n\n\n\n\n\ndef read_a_int():\n\n    return int(read())\n\n\n\n\n\ndef read_matrix(H):\n\n    '''\n\n    H is number of rows\n\n    '''\n\n    return [list(map(int, read().split())) for _ in range(H)]\n\n\n\n\n\ndef read_map(H):\n\n    '''\n\n    H is number of rows\n\n    文字列で与えられた盤面を読み取る用\n\n    '''\n\n    return [read()[:-1] for _ in range(H)]\n\n\n\n\n\ndef read_tuple(H):\n\n    '''\n\n    H is number of rows\n\n    '''\n\n    ret = []\n\n    for _ in range(H):\n\n        ret.append(tuple(map(int, read().split())))\n\n    return ret\n\n\n\n\n\ndef read_col(H, n_cols):\n\n    '''\n\n    H is number of rows\n\n    n_cols is number of cols\n\n\n\n    A列、B列が与えられるようなとき\n\n    '''\n\n    ret = [[] for _ in range(n_cols)]\n\n    for _ in range(H):\n\n        tmp = list(map(int, read().split()))\n\n        for col in range(n_cols):\n\n            ret[col].append(tmp[col])\n\n\n\n    return ret\n\n\n\n\n\nN, K = read_ints()\n\nP = read_ints()\n\n\n\n\n\ndef ret_mean(X):\n\n    return (X + 1) / 2\n\n\n\n\n\n\n\nclass cumsum1d:\n\n    def __init__(self, ls: list):\n\n        '''\n\n        1次元リストを受け取る\n\n        '''\n\n        from itertools import accumulate\n\n        self.ls_accum = [0] + list(accumulate(ls))\n\n\n\n    def total(self, i, j):\n\n        # もとの配列lsにおける[i,j)の中合計\n\n        return self.ls_accum[j] - self.ls_accum[i]\n\n      \n\nP_mean = [ret_mean(p) for p in P]\n\nP_accum = cumsum1d(P_mean)\n\n\n\nans = 0\n\n# print(P_accum)\n\nfor i in range(N - K + 1):\n\n    j = i + K\n\n    ans = max(ans, P_accum.total(i,j))\n\nprint(ans)\n", "score": 0.0, "codebleu": 0.2422887209175903, "crystalbleu": 0.0233749393344799, "codebertscore": 0.65, "codescore": 0.9175969362258911, "surfaceSim": 0.48758702665987436, "abs_surfaceSim_minus_score": 0.48758702665987436}
{"golden_code": "n, m, k = list(map(int, input().split()))\n\n\n\nmod = 1000000007\n\ndef pow(x, n):\n\n    ret = 1\n\n    while n > 0:\n\n        if (n & 1) == 1:\n\n            ret = (ret * x) % mod\n\n        x = (x * x) % mod\n\n        n >>= 1\n\n    return ret\n\n\n\nfac = [1]\n\ninv = [1]\n\nfor i in range(1, n * m + 1):\n\n    fac.append((fac[-1] * i) % mod)\n\n    inv.append(pow(fac[i], mod - 2))\n\n\n\ndef cmb(n, k):\n\n    return (fac[n] * inv[k] * inv[n - k]) % mod\n\n\n\ndef doit(n, m, k):\n\n    ret = 0\n\n    for d in range(m):\n\n        ret = (ret + d * (m - d)) % mod\n\n    return (ret * n * n * cmb(n * m - 2, k - 2)) % mod\n\n\n\nprint(((doit(n, m, k) + doit(m, n, k)) % mod))", "generated_code": "n = int(eval(input()))\n\np = 1\n\nfor i in range(n):\n\n    p = (p * (i+1)) % (10 ** 9 + 7)\n\nprint(p)", "score": 0.0, "codebleu": 0.06109219622109717, "crystalbleu": 0.0027842536772194034, "codebertscore": 0.7, "codescore": 0.0839272141456604, "surfaceSim": 0.4095309009679821, "abs_surfaceSim_minus_score": 0.4095309009679821}
{"golden_code": "A, B, C, X, Y = list(map(int, input().split()))\n\n\n\nans = float('inf')\n\n\n\nfor i in range(10 ** 5 + 1):\n\n    ans = min(ans, A * max(X - i, 0) + B * max(Y - i, 0) + 2 * C * i)\n\nprint(ans)", "generated_code": "import sys\n\nsys.setrecursionlimit(10**8)\n\nN = int(eval(input()))\n\nA = [int(eval(input()))-1 for i in range(N-1)]\n\nwins = [[] for _ in range(N)]\n\n\n\nfor i,a in enumerate(A):\n\n    wins[a].append(i+1)\n\n\n\ndepth = [-1] * N\n\ndef dep(v):\n\n    if len(wins[v])==0: return 0\n\n    if depth[v] >= 0:\n\n        return depth[v]\n\n    ds = []\n\n    for w in wins[v]:\n\n        ds.append(dep(w))\n\n    ds.sort(reverse=True)\n\n    ret = 0\n\n    for i,d in enumerate(ds):\n\n        ret = max(ret, i+d+1)\n\n    depth[v] = ret\n\n    return ret\n\nprint((dep(0)))", "score": 0.0, "codebleu": 0.165790142958015, "crystalbleu": 0.039046753023034904, "codebertscore": 0.71, "codescore": 0.2082851529121399, "surfaceSim": 0.43000111197598134, "abs_surfaceSim_minus_score": 0.43000111197598134}
{"golden_code": "\n\n\n\nn = int(eval(input()))\n\n\n\nabn = [list(map(int,input().split())) for _ in range(n)]\n\n\n\n\n\nabn.sort()\n\nabn.sort(key = lambda x:x[1])\n\n\n\n\n\n#print(abn)\n\n\n\nts = 0 # time_stamp\n\nenable = True\n\nfor abi in abn:\n\n    a, b = abi\n\n\n\n    if not ts + a <= b:\n\n        enable = False\n\n        break\n\n    else:\n\n        ts += a\n\n\n\nprint(('Yes' if enable else 'No'))", "generated_code": "import sys, re\n\nfrom collections import deque, defaultdict, Counter\n\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, radians\n\nfrom itertools import accumulate, permutations, combinations, product, groupby\n\nfrom operator import itemgetter, mul\n\nfrom copy import deepcopy\n\nfrom string import ascii_lowercase, ascii_uppercase, digits\n\nfrom bisect import bisect, bisect_left\n\nfrom fractions import gcd\n\nfrom heapq import heappush, heappop\n\nfrom functools import reduce\n\ndef input(): return sys.stdin.readline().strip()\n\ndef INT(): return int(eval(input()))\n\ndef MAP(): return list(map(int, input().split()))\n\ndef LIST(): return list(map(int, input().split()))\n\ndef ZIP(n): return list(zip(*(MAP() for _ in range(n))))\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = float('inf')\n\nmod = 10 ** 9 + 7\n\n\n\nK, N = MAP()\n\nA = LIST()\n\ndiff = abs(K - A[-1] + A[0])\n\nd = abs(K - A[-1] + A[0])\n\nif N == 2:\n\n  print((min(d, A[1] - A[0])))\n\n  exit()\n\nfor i in range(1, N):\n\n  d += abs(A[i] - A[i-1])\n\n  diff = max(diff, abs(A[i] - A[i-1]))\n\nprint((d - diff))", "score": 0.0, "codebleu": 0.2079396390737121, "crystalbleu": 0.07858271919131303, "codebertscore": 0.63, "codescore": 0.14171993732452393, "surfaceSim": 0.4041866028708134, "abs_surfaceSim_minus_score": 0.4041866028708134}
{"golden_code": "n = int(eval(input()))\n\nres = 1\n\nfor num in range(1, n+1):\n\n  res = res * num\n\n  res = res % (pow(10,9) + 7)\n\nprint(res)", "generated_code": "s = eval(input())\n\n\n\nstart = 0\n\nfor i in range(len(s)):\n\n    if s[i] == 'A':\n\n        start = i\n\n        break\n\n\n\nend = 0\n\nfor i in reversed(list(range(len(s)))):\n\n    if s[i] == 'Z':\n\n        end = i\n\n        break\n\nprint((end - start + 1))\n", "score": 0.0, "codebleu": 0.15461999959732564, "crystalbleu": 0.0, "codebertscore": 0.75, "codescore": 0.036961402744054794, "surfaceSim": 0.5477272727272727, "abs_surfaceSim_minus_score": 0.5477272727272727}
{"golden_code": "ia = [int(i) for i in input().split(\" \")]\n\nW=ia[0]\n\nH=ia[1]\n\nx=ia[2]\n\ny=ia[3]\n\nr=ia[4]\n\nprint((\"Yes\" if 0<=x-r and x+r<=W and 0<=y-r and y+r<=H else \"No\"))", "generated_code": "n = int(eval(input()))\n\np = 1\n\nfor i in range(n):\n\n    p = (p * (i+1)) % (10 ** 9 + 7)\n\nprint(p)", "score": 0.0, "codebleu": 0.10619902210551009, "crystalbleu": 0.0, "codebertscore": 0.72, "codescore": 0.07356171309947968, "surfaceSim": 0.3580645161290323, "abs_surfaceSim_minus_score": 0.3580645161290323}
{"golden_code": "def resolve():\n\n    '''\n\n    code here\n\n    '''\n\n    import collections\n\n    import itertools\n\n    import numpy as np\n\n    N = int(eval(input()))\n\n    Ss = [input()[0] for _ in range(N)]\n\n\n\n    march_letter = [item for item in Ss if item in ['M', 'A', 'R', 'C', 'H']]\n\n    march_cnt = collections.Counter(march_letter)\n\n\n\n    if len(march_cnt) < 3:\n\n        res = 0\n\n    else:\n\n        res_list = itertools.combinations(list(march_cnt.values()),3)\n\n\n\n        res = 0\n\n        for element in res_list:\n\n            res += np.prod(np.array(element))\n\n    print(res)\n\n\n\nif __name__ == \"__main__\":\n\n    resolve()\n", "generated_code": "A, B = list(map(int, input().split()))\n\ncnt = 0\n\nfor i in range(A, B+1):\n\n    l = str(i)\n\n    if l == l[::-1]:\n\n        cnt += 1\n\n\n\nprint(cnt)\n", "score": 0.0, "codebleu": 0.10965059816761943, "crystalbleu": 0.0, "codebertscore": 0.69, "codescore": 0.21552307903766632, "surfaceSim": 0.45346681497960695, "abs_surfaceSim_minus_score": 0.45346681497960695}
{"golden_code": "import sys\n\nimport numpy as np\n\n\n\nsr = lambda: sys.stdin.readline().rstrip()\n\nir = lambda: int(sr())\n\nlr = lambda: list(map(int, sr().split()))\n\n\n\nN = ir()\n\nP = np.array(lr())\n\n\n\nP_diff = np.diff(P)\n\nP_diff = P_diff > 0\n\nseries = P_diff[:-1] == P_diff[1:]\n\nanswer = series.sum()\n\nprint(answer)\n\n# 23", "generated_code": "n = int(eval(input()))\n\nary = list(map(int, input().split()))\n\n#print(n,ary)\n\n\n\nary_2 = [ary[0]]\n\nfor i in range(1, n):\n\n    ary_2.append(ary[i] + ary_2[i-1])\n\nary_2 = [0] + ary_2\n\n#print(ary_2)\n\n\n\nfrom collections import Counter\n\nc = Counter(ary_2)\n\nv = (list(c.values()))\n\n#print(v)\n\n\n\nans = 0\n\nfor j in v:\n\n    if j >1:\n\n        ans += j * (j-1) // 2\n\n\n\nprint(ans)\n", "score": 0.0, "codebleu": 0.19363743043648302, "crystalbleu": 0.0, "codebertscore": 0.71, "codescore": 0.12083308398723602, "surfaceSim": 0.4216339410939691, "abs_surfaceSim_minus_score": 0.4216339410939691}
{"golden_code": "# coding: utf-8\n\nimport sys\n\nimport numpy as np\n\n\n\nsr = lambda: sys.stdin.readline().rstrip()\n\nir = lambda: int(sr())\n\nlr = lambda: list(map(int, sr().split()))\n\n\n\nN = ir()\n\nV = np.array(lr())\n\nC = np.array(lr())\n\nV -= C\n\nV = V[V>0]\n\nanswer = V.sum()\n\nprint(answer)\n", "generated_code": "from statistics import median_low\n\n\n\nN = int(eval(input()))\n\nA = list(map(int, input().split()))\n\n\n\nD = []\n\nfor i in range(N):\n\n    D.append(A[i] - (i+1))\n\n\n\nm = median_low(D)\n\nans = 0\n\nfor d in D:\n\n    ans += abs(d - m)\n\n\n\nprint(ans)\n", "score": 0.0, "codebleu": 0.2063813249001132, "crystalbleu": 0.0, "codebertscore": 0.73, "codescore": 0.8752691745758057, "surfaceSim": 0.5134711779448622, "abs_surfaceSim_minus_score": 0.5134711779448622}
{"golden_code": "def examB():\n\n    N = I(); A = [I() for _ in range(N)]\n\n    ans = 0; cur= 0\n\n    for i in A:\n\n        if i==0:\n\n            ans += cur//2\n\n            cur = 0\n\n        else:\n\n            cur += i\n\n    ans += cur // 2\n\n    print(ans)\n\n    return\n\n\n\nimport sys,copy,bisect,itertools,heapq,math\n\nfrom heapq import heappop,heappush,heapify\n\nfrom collections import Counter,defaultdict,deque\n\ndef I(): return int(sys.stdin.readline())\n\ndef LI(): return list(map(int,sys.stdin.readline().split()))\n\ndef LSI(): return list(map(str,sys.stdin.readline().split()))\n\ndef LS(): return sys.stdin.readline().split()\n\ndef SI(): return sys.stdin.readline().strip()\n\nmod = 10**9 + 7\n\ninf = float('inf')\n\n\n\nif __name__ == '__main__':\n\n    examB()\n", "generated_code": "k,s=list(map(int,input().split()))\n\nans=0\n\nx=min(k+1,s+1)\n\ny=max(0,s-k-k)\n\nfor i in range(y,x):\n\n    for j in range(y,x):\n\n        if i+j>s: break\n\n        if 0<=s-i-j<=k:\n\n            ans+=1\n\nprint(ans)", "score": 0.0, "codebleu": 0.12059054378962232, "crystalbleu": 0.04509749217268801, "codebertscore": 0.67, "codescore": 0.8776875734329224, "surfaceSim": 0.407916279481393, "abs_surfaceSim_minus_score": 0.407916279481393}
{"golden_code": "#!usr/bin/env python3\n\nfrom collections import defaultdict\n\nfrom collections import deque\n\nfrom heapq import heappush, heappop\n\nimport sys\n\nimport math\n\nimport bisect\n\nimport random\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\n\ndef I(): return int(sys.stdin.readline())\n\ndef LS():return list(map(list, sys.stdin.readline().split()))\n\ndef S(): return list(sys.stdin.readline())[:-1]\n\ndef IR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = I()\n\n    return l\n\ndef LIR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = LI()\n\n    return l\n\ndef SR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = S()\n\n    return l\n\ndef LSR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = SR()\n\n    return l\n\nmod = 1000000007\n\n\n\n#A\n\n\"\"\"\n\ndef gcd(a,b):\n\n    if a == 0:\n\n        return b\n\n    return gcd(b%a,a)\n\nn = I()\n\na = IR(n)\n\nl = a[0]\n\nfor i in range(1,n):\n\n    g = gcd(l,a[i])\n\n    l *= a[i]//g\n\nprint(l)\n\n\"\"\"\n\n\n\n#B\n\nn = I()\n\nv = [[] for i in range(n)]\n\nfor i in range(n-1):\n\n    a,b,c = LI()\n\n    a -= 1\n\n    b -= 1\n\n    v[a].append([b,c])\n\n    v[b].append([a,c])\n\nQ,k = LI()\n\nd = [-1 for i in range(n)]\n\nd[k-1] = 0\n\nq = deque()\n\nq.append(k-1)\n\nwhile q:\n\n    x = q.pop()\n\n    for y,c in v[x]:\n\n        if d[y] == -1:\n\n            d[y] = d[x]+c\n\n            q.append(y)\n\nfor i in range(Q):\n\n    x,y = LI()\n\n    x -= 1\n\n    y -= 1\n\n    print((d[x]+d[y]))\n\n#C\n\n\n\n#D\n\n\n\n#E\n\n\n\n#F\n\n\n\n#G\n\n\n\n#H\n\n\n\n#I\n\n\n\n#J\n\n\n\n#K\n\n\n\n#L\n\n\n\n#M\n\n\n\n#N\n\n\n\n#O\n\n\n\n#P\n\n\n\n#Q\n\n\n\n#R\n\n\n\n#S\n\n\n\n#T\n", "generated_code": "def main():\n\n    import sys\n\n    input = sys.stdin.buffer.readline\n\n    N = int(input())\n\n    TXY = [[int(i) for i in input().split()] for j in range(N)]\n\n    time = 0\n\n    px = 0\n\n    py = 0\n\n    for t, x, y in TXY:\n\n        move = abs(py-y) + abs(px - x)\n\n        if (t-time) < move or (t - time) % 2 != move % 2:\n\n            return print(\"No\")\n\n        time = t\n\n        px = x\n\n        py = y\n\n    print(\"Yes\")\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 0.0, "codebleu": 0.133528312334512, "crystalbleu": 0.009415032568544203, "codebertscore": 0.7, "codescore": 0.01832730509340763, "surfaceSim": 0.5168660227215855, "abs_surfaceSim_minus_score": 0.5168660227215855}
{"golden_code": "k,s=list(map(int,input().split()))\n\nans=chk=0\n\nfor i in range(k+1):\n\n    for j in range(k+1):\n\n        if (0<=s-i-j<=k): ans+=1\n\nprint(ans)", "generated_code": "a, b = list(map(int, input().split()))\n\ncnt = 0\n\n\n\nfor i in range(10):\n\n    for j in range(10):\n\n        for k in range(10):\n\n            c = 10000*i+1000*j+100*k+10*j+i\n\n            if a <= c <= b:\n\n                cnt += 1\n\n\n\nprint(cnt)\n", "score": 0.0, "codebleu": 0.33851624832987903, "crystalbleu": 0.0, "codebertscore": 0.83, "codescore": 0.7505538463592529, "surfaceSim": 0.8072010570358952, "abs_surfaceSim_minus_score": 0.8072010570358952}
{"golden_code": "from collections import Counter\n\n\n\nN = int(eval(input()))\n\ninputs = [int(i) for i in input().split()]\n\n\n\nans = 0\n\nruisekiwa = [0] * (N+1)\n\n\n\nfor i in range(N):\n\n    ruisekiwa[i+1] = ruisekiwa[i] + inputs[i]\n\n\n\nruisekiwa = ruisekiwa[1:]\n\nruisekiwa.sort()\n\ncounter_ruiseki = Counter(ruisekiwa)\n\n\n\nfor key, value in list(counter_ruiseki.items()):\n\n    if key == 0 and value == 1:\n\n        ans += value\n\n        continue\n\n    elif key == 0 and value > 1:\n\n        ans += value\n\n    if value > 1:\n\n        ans += sum(list(range(value)))\n\n\n\nprint(ans)\n", "generated_code": "def main():\n\n    from collections import deque\n\n    import sys\n\n\n\n    input = sys.stdin.readline\n\n\n\n    h, w = list(map(int, input().split()))\n\n    s = [eval(input()) for _ in range(h)]\n\n\n\n    bk = 0\n\n    for row in s:\n\n        bk += row.count('#')\n\n\n\n    def coods(r, c):\n\n        if r > 0: yield r - 1, c\n\n        if r < h - 1: yield r + 1, c\n\n        if c > 0: yield r, c - 1\n\n        if c < w - 1: yield r, c + 1\n\n\n\n    q = deque()\n\n    q.append((0, 0))\n\n    count = [[-1] * w for _ in range(h)]\n\n    count[0][0] = 1\n\n    while q:\n\n        r, c = q.popleft()\n\n        k = count[r][c]\n\n        for nr, nc in coods(r, c):\n\n            nchar = s[nr][nc]\n\n            if nchar == '#': continue\n\n            if count[nr][nc] != -1: continue\n\n            count[nr][nc] = k + 1\n\n            if (nr, nc) == (h - 1, w - 1):\n\n                print((h * w - (k + 1) - bk))\n\n                return\n\n            q.append((nr, nc))\n\n    print((-1))\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 0.0, "codebleu": 0.21683163726771357, "crystalbleu": 0.07182384864988103, "codebertscore": 0.71, "codescore": 0.023267837241292, "surfaceSim": 0.5981325388751635, "abs_surfaceSim_minus_score": 0.5981325388751635}
{"golden_code": "N = int(eval(input()))\n\nA = list(map(int, input().split()))\n\n# 中央値\n\nB = []\n\nfor i in range(N):\n\n    B.append(A[i] - (i+1))\n\nb = sorted(B)[N//2]\n\n\n\nans = 0\n\nfor i in range(N):\n\n    ans += abs(A[i] - (i + 1) - b)\n\n\n\nprint(ans)\n\n\n", "generated_code": "A, B = list(map(int, input().split()))\n\ncnt = 0\n\nfor i in range(A, B+1):\n\n    l = str(i)\n\n    if l == l[::-1]:\n\n        cnt += 1\n\n\n\nprint(cnt)\n", "score": 0.0, "codebleu": 0.2178505677655983, "crystalbleu": 0.1552684300113797, "codebertscore": 0.81, "codescore": 0.49495789408683777, "surfaceSim": 0.5641409691629956, "abs_surfaceSim_minus_score": 0.5641409691629956}
{"golden_code": "def main():\n\n    import sys\n\n    input = sys.stdin.buffer.readline\n\n    N = int(input())\n\n    TXY = [[int(i) for i in input().split()] for j in range(N)]\n\n    time, px, py = 0, 0, 0\n\n    for t, x, y in TXY:\n\n        move = abs(x-px) + abs(y-py)\n\n        # print(move, t-time)\n\n        if (t - time) % 2 != move % 2 or t - time < move:\n\n            return print(\"No\")\n\n        time, px, py = t, x, y\n\n    print(\"Yes\")\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "generated_code": "import sys\n\ninput = sys.stdin.readline\n\n\n\nn,k = list(map(int, input().split()))\n\nAs = [int(eval(input())) for i in range(n)]\n\n\n\n# N: 処理する区間の長さ\n\n\n\nINF = 0\n\n\n\nmx = 300001\n\nLV = (mx-1).bit_length()\n\nN0 = 2**LV\n\ndata = [INF]*(2*N0)\n\nlazy = [None]*(2*N0)\n\n\n\n# 伝搬対象の区間を求める\n\ndef gindex(l, r):\n\n    L = (l + N0) >> 1; R = (r + N0) >> 1\n\n    lc = 0 if l & 1 else (L & -L).bit_length()\n\n    rc = 0 if r & 1 else (R & -R).bit_length()\n\n    for i in range(LV):\n\n        if rc <= i:\n\n            yield R\n\n        if L < R and lc <= i:\n\n            yield L\n\n        L >>= 1; R >>= 1\n\n\n\n# 遅延伝搬処理\n\ndef propagates(*ids):\n\n    for i in reversed(ids):\n\n        v = lazy[i-1]\n\n        if v is None:\n\n            continue\n\n        lazy[2*i-1] = data[2*i-1] = lazy[2*i] = data[2*i] = v\n\n        lazy[i-1] = None\n\n\n\n# 区間[l, r)をxで更新\n\ndef update(l, r, x):\n\n    *ids, = gindex(l, r)\n\n    propagates(*ids)\n\n\n\n    L = N0 + l; R = N0 + r\n\n    while L < R:\n\n        if R & 1:\n\n            R -= 1\n\n            lazy[R-1] = data[R-1] = x\n\n        if L & 1:\n\n            lazy[L-1] = data[L-1] = x\n\n            L += 1\n\n        L >>= 1; R >>= 1\n\n    for i in ids:\n\n        data[i-1] = max(data[2*i-1], data[2*i])\n\n\n\n# 区間[l, r)内の最小値を求める\n\ndef query(l, r):\n\n    propagates(*gindex(l, r))\n\n    L = N0 + l; R = N0 + r\n\n\n\n    s = INF\n\n    while L < R:\n\n        if R & 1:\n\n            R -= 1\n\n            s = max(s, data[R-1])\n\n        if L & 1:\n\n            s = max(s, data[L-1])\n\n            L += 1\n\n        L >>= 1; R >>= 1\n\n    return s\n\n\n\nans = 0\n\nupdate(As[0],As[0]+1,1)\n\nfor i, a in enumerate(As[1:]):\n\n    l = max(0,a-k)\n\n    r = min(mx,a+k)\n\n    upd = query(l,r+1)\n\n    if upd == -1:continue\n\n    # print(\"i\",i,\"a\",a,\"upd\",upd,\"l\",l,\"r\",r)\n\n    update(a, a+1, upd+1)\n\n    ans = max(ans, upd+1)\n\nprint(ans)\n\n\n", "score": 0.0, "codebleu": 0.21689424749672082, "crystalbleu": 0.04833254282364355, "codebertscore": 0.68, "codescore": 0.9938257932662964, "surfaceSim": 0.516997216022824, "abs_surfaceSim_minus_score": 0.516997216022824}
{"golden_code": "K = int(eval(input()))\n\n\n\nflg = [False]*K\n\n\n\ntmp = 7 % K\n\ncnt = 1\n\nif tmp == 0:\n\n    print(cnt)\n\n    exit()\n\nwhile True:\n\n    tmp = (tmp*10+7)%K\n\n    if flg[tmp]:\n\n        print((-1))\n\n        break\n\n    else:\n\n        cnt += 1\n\n        if tmp == 0:\n\n            print(cnt)\n\n            break\n\n        flg[tmp] = True\n", "generated_code": "\n\nX = int(eval(input()))\n\nfor a in range(-120, 120):\n\n    find = False\n\n    for b in range(-120, 120):\n\n        x = a**5-b**5\n\n        if x == X:\n\n            find = True\n\n            print((a, b))\n\n            break\n\n    if find:\n\n        break\n", "score": 0.0, "codebleu": 0.1418579312140234, "crystalbleu": 0.0, "codebertscore": 0.73, "codescore": 0.8401386737823486, "surfaceSim": 0.5733752620545074, "abs_surfaceSim_minus_score": 0.5733752620545074}
{"golden_code": "import sys\n\nimport itertools\n\n# import numpy as np\n\nimport time\n\nimport math\n\n \n\nsys.setrecursionlimit(10 ** 7)\n\n \n\nfrom collections import defaultdict\n\n \n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n \n\n \n\nfrom functools import reduce\n\n# from math import *\n\nfrom fractions import *\n\nN, M = list(map(int, readline().split()))\n\nA = list(sorted([int(x) // 2 for x in readline().split()]))\n\nmin_cm = reduce(lambda a, b: (a * b) // gcd(a, b), A)\n\n \n\n# print(all(map(lambda x: (min_cm // x) % 2 == 1, A)))\n\nif not all([(min_cm // x) % 2 == 1 for x in A]):\n\n    print((0))\n\n    exit(0)\n\nif min_cm > M:\n\n    print((0))\n\n    exit(0)\n\nans = (M // min_cm + 1) // 2\n\nprint(ans)", "generated_code": "# https://atcoder.jp/contests/abc129/tasks/abc129_c\n\n# 典型的なDP\n\n\n\n\n\ndef full(shape, full_value):\n\n    if isinstance(shape, tuple):\n\n        NotImplementedError()\n\n    else:\n\n        return [full_value] * shape\n\n\n\n\n\nMOD = 10**9 + 7\n\n# dp[i]をi段目までの通りの数とする。\n\nN, M = list(map(int, input().split()))\n\nto_zero = full((N + 1), False)\n\nfor _ in range(M):\n\n    to_zero[int(eval(input()))] = True  # 床が抜けているところ\n\n\n\n# dpテーブルの用意\n\ndp = full((N + 1), -1)\n\ndp[0] = 1\n\ndp[1] = 0 if to_zero[1] else 1\n\nfor i in range(2, N + 1):\n\n    dp[i] = 0 if to_zero[i] else dp[i - 2] + dp[i - 1]\n\n    if dp[i] > MOD:\n\n        dp[i] %= MOD\n\n\n\nprint((dp[-1]))\n", "score": 0.0, "codebleu": 0.19269922533076556, "crystalbleu": 0.11724417027997888, "codebertscore": 0.67, "codescore": 0.9080281257629395, "surfaceSim": 0.4799211248285322, "abs_surfaceSim_minus_score": 0.4799211248285322}
{"golden_code": "import sys\n\nsys.setrecursionlimit(100000)\n\nN, M = list(map(int, input().split()))\n\nedges = [list(map(int, input().split())) for _ in range(M)]\n\n\n\ngraph = [[] for _ in range(N)]\n\nfor x, y in edges:\n\n    graph[x - 1].append(y - 1)\n\n    graph[y - 1].append(x - 1)\n\n\n\ndef dfs(v, c):\n\n    # c: color = 1 or -1\n\n    node[v] = c\n\n    for i in graph[v]:\n\n        if node[i] == c:\n\n            return False\n\n        \n\n        if node[i] == 0 and not dfs(i, -c):\n\n            return False\n\n        \n\n    return True\n\n\n\nnode = [0] * N\n\nif dfs(0, 1):\n\n    x = sum(v + 1 for v in node) // 2\n\n    print((x * (N - x) - M))\n\nelse:\n\n    print((N * (N - 1) // 2 - M))\n", "generated_code": "# coding: utf-8\n\nimport sys\n\n\n\nsr = lambda: sys.stdin.readline().rstrip()\n\nir = lambda: int(sr())\n\nlr = lambda: list(map(int, sr().split()))\n\n\n\nN, M = lr()\n\nL = 0; R = 10 ** 6\n\nfor _ in range(M):\n\n    l, r = lr()\n\n    if l > L:\n\n        L = l\n\n    if r < R:\n\n        R = r\n\n\n\nanswer = max(0, R - L + 1)\n\nprint(answer)\n", "score": 0.0, "codebleu": 0.13984553782175932, "crystalbleu": 0.05758506258666137, "codebertscore": 0.73, "codescore": 0.5960257053375244, "surfaceSim": 0.48826923076923073, "abs_surfaceSim_minus_score": 0.48826923076923073}
{"golden_code": "def main():\n\n\tn, ma, mb, *L = list(map(int, open(0).read().split()))\n\n\tM = 1<<30\n\n\tdp = [[M] * 420 for _ in range(420)]\n\n\tdp[0][0] = 0\n\n\tfor a, b, c in zip(*[iter(L)] * 3):\n\n\t\tfor i in range(400, -1, -1):\n\n\t\t\tfor j in range(400, -1, -1):\n\n\t\t\t\tt = dp[i][j] + c\n\n\t\t\t\tif dp[i + a][j + b] > t:\n\n\t\t\t\t\tdp[i + a][j + b] = t\n\n\tans = M\n\n\t_ma, _mb = ma, mb\n\n\twhile _ma < 410 > _mb:\n\n\t\tans = min(ans, dp[_ma][_mb])\n\n\t\t_ma += ma\n\n\t\t_mb += mb\n\n\tprint((ans if ans < M else -1))\n\n\n\nif __name__==\"__main__\":\n\n\tmain()", "generated_code": "n = int(eval(input()))\n\nfor i in range(n - 1, 1, -1):\n\n\tn *= i\n\n\tn %= 10**9 + 7\n\nprint(n)", "score": 0.0, "codebleu": 0.05883572764822117, "crystalbleu": 0.0031368215059503425, "codebertscore": 0.7, "codescore": 0.01847805455327034, "surfaceSim": 0.3963333333333333, "abs_surfaceSim_minus_score": 0.3963333333333333}
{"golden_code": "n, q = [ int( val ) for val in input( ).split( \" \" ) ]\n\nps = [0]*n\n\nt = [0]*n\n\nfor i in range( n ):\n\n\tps[i], t[i] = input( ).split( \" \" )\n\n\n\n\n\noutput = []\n\nqsum = 0\n\nwhile t:\n\n\tpsi = ps.pop( 0 )\n\n\tti = int( t.pop( 0 ) )\n\n\tif ti <= q:\n\n\t\tqsum += ti\t\n\n\t\toutput.append( psi+\" \"+str( qsum ) )\n\n\telse:\n\n\t\tt.append( ti - q )\n\n\t\tps.append( psi )\n\n\t\tqsum += q\n\n\n\nprint(( \"\\n\".join( output ) ))", "generated_code": "from heapq import heappop,heappush\n\nn,m=list(map(int,input().split()))\n\na=[int(i) for i in input().split()]\n\na.sort()\n\nbc=[[int(i) for i in input().split()]for j in range(m)]\n\nbc=sorted(bc, key=lambda x:x[1],reverse=True)\n\n\n\nans=[]\n\nfor b,c in bc:    \n\n    while b>0 and a: \n\n        x = heappop(a)\n\n        if x<c:\n\n            ans.append(c)\n\n            b-=1\n\n        else:\n\n            ans.append(x)\n\nprint((sum(ans)+sum(a)))", "score": 0.0, "codebleu": 0.1608921879037597, "crystalbleu": 0.06657176725649235, "codebertscore": 0.74, "codescore": 0.34297680854797363, "surfaceSim": 0.541188251001335, "abs_surfaceSim_minus_score": 0.541188251001335}
{"golden_code": "import sys\n\ninput = sys.stdin.readline\n\nH, W = [int(x) for x in input().split()]\n\na = []\n\nfor _ in range(H):\n\n    a.append(list(input().rstrip()))\n\nimport numpy as np\n\na = np.array(a, np.object)\n\na = a.T\n\nretsu = []\n\ngyou = []\n\nfor i in range(W):\n\n    if \"#\" not in a[i]:\n\n        retsu.append(i)\n\na = a.T\n\nfor i in range(H):\n\n    if \"#\" not in a[i]:\n\n        gyou.append(i)\n\na = np.delete(a, retsu, 1)\n\na = np.delete(a, gyou, 0)\n\nfor j in a:\n\n    j = list(j)\n\n    print((\"\".join(j)))", "generated_code": "N, M = list(map(int, input().split(\" \")))\n\nA = {int(input()) for _ in range(M)}\n\n\n\nmemo = [0] * (N + 1)\n\nmemo[0] = 1\n\nmemo[1] = 0 if 1 in A else 1\n\n\n\nif N == 1:\n\n    print((memo[1]))\n\nelse:\n\n    for i in range(2, N + 1):\n\n        if i in A:\n\n            continue\n\n        memo[i] = (memo[i - 2] + memo[i - 1]) % 1000000007\n\n    print((memo[N]))\n", "score": 0.0, "codebleu": 0.1364050831916167, "crystalbleu": 0.07021316317627069, "codebertscore": 0.73, "codescore": 0.06774932146072388, "surfaceSim": 0.4880365235937083, "abs_surfaceSim_minus_score": 0.4880365235937083}
{"golden_code": "import sys\n\ndef input(): return sys.stdin.readline().strip()\n\n\n\ndef resolve():\n\n    import math\n\n    n=int(eval(input()))\n\n    print((math.factorial(n)%(10**9+7)))\n\nresolve()", "generated_code": "N = int(eval(input()))\n\nP = list(map(int, input().split()))\n\nanswer = sum(x>y>z or x<y<z for x, y, z in zip(P[:-2], P[1:-1], P[2:]))\n\nprint(answer)\n\n    ", "score": 0.0, "codebleu": 0.22510162601626016, "crystalbleu": 0.0, "codebertscore": 0.72, "codescore": 0.11777853965759277, "surfaceSim": 0.3080459770114943, "abs_surfaceSim_minus_score": 0.3080459770114943}
{"golden_code": "H,W = list(map(int,input().split()))\n\nN = int(eval(input()))\n\nA = list(map(int,input().split()))\n\nA.insert(0,0)\n\nC = [[0 for _ in range(W)] for _ in range(H)]\n\ncur = [0,0,\"R\"]\n\nfor k in range(1,N+1):\n\n#     ipdb.set_trace()\n\n    a = A[k]\n\n    cnt = 0\n\n    y,x,d = cur\n\n    for i in range(y,H):\n\n        y = i\n\n        if d==\"R\":\n\n            for j in range(x,W):\n\n                C[i][j]=str(k)\n\n                cnt += 1\n\n                if j+1<W:\n\n                    x = j+1\n\n                else:\n\n                    x = j\n\n                if cnt==a:break\n\n            if cnt==a:break\n\n            d=\"L\"\n\n        else:\n\n            for j in range(x,-1,-1):\n\n                C[i][j]=str(k)\n\n                cnt += 1\n\n                if j>=1:\n\n                    x = j-1\n\n                else:\n\n                    x = 0\n\n                if cnt==a:break\n\n            if cnt==a:break\n\n            d=\"R\"\n\n    if x==W-1:\n\n        if C[y][x]!=0:\n\n            y += 1\n\n            d=\"L\"\n\n    elif x==0:\n\n        if C[y][x]!=0:\n\n            y += 1\n\n            d=\"R\"\n\n    cur = [y,x,d]                \n\nfor i in range(H):\n\n    print((*C[i]))", "generated_code": "# coding: utf-8\n\nimport sys\n\n\n\nsr = lambda: sys.stdin.readline().rstrip()\n\nir = lambda: int(sr())\n\nlr = lambda: list(map(int, sr().split()))\n\n\n\nN, M = lr()\n\nL = 0; R = 10 ** 6\n\nfor _ in range(M):\n\n    l, r = lr()\n\n    if l > L:\n\n        L = l\n\n    if r < R:\n\n        R = r\n\n\n\nanswer = max(0, R - L + 1)\n\nprint(answer)\n", "score": 0.0, "codebleu": 0.10675168209065564, "crystalbleu": 0.018998838701087963, "codebertscore": 0.71, "codescore": 0.1623438596725464, "surfaceSim": 0.5386616827909704, "abs_surfaceSim_minus_score": 0.5386616827909704}
{"golden_code": "S, T = [list(eval(input())) for _ in range(2)]\n\ncnt = 0\n\nfor i in range(len(S)):\n\n    if S[i] != T[i]:\n\n        cnt += 1\n\nprint(cnt)\n", "generated_code": "k,s=list(map(int,input().split()))\n\na=0\n\nfor i in range(0,k+1):\n\n    for j in range(0,k+1):\n\n        if 0<=s-i-j<=k:\n\n            a+=1\n\nprint(a)", "score": 0.0, "codebleu": 0.21098321423970312, "crystalbleu": 0.0, "codebertscore": 0.8, "codescore": 0.4079107642173767, "surfaceSim": 0.6064311594202899, "abs_surfaceSim_minus_score": 0.6064311594202899}
{"golden_code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\n\n\nsys.setrecursionlimit(10**7)\n\ninf = 10**20\n\neps = 1.0 / 10**15\n\nmod = 10**9+7\n\n\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\n\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\n\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\n\ndef LS(): return sys.stdin.readline().split()\n\ndef I(): return int(sys.stdin.readline())\n\ndef F(): return float(sys.stdin.readline())\n\ndef S(): return input()\n\ndef pf(s): return print(s, flush=True)\n\ndef divisions(n):\n\n    sq = int(math.sqrt(n)+1)\n\n    d = collections.defaultdict(int)\n\n    while n % 2 == 0:\n\n        n //= 2\n\n        d[2] += 1\n\n    i = 3\n\n    while n > 1 and sq >= i:\n\n        if n % i == 0:\n\n            n //= i\n\n            d[i] += 1\n\n        else:\n\n            i += 2\n\n\n\n    if n > 1:\n\n        d[n] += 1\n\n\n\n    r = [1]\n\n    for k, v in d.items():\n\n        for c in r[:]:\n\n            for i in range(1,v+1):\n\n                r.append(c*(k**i))\n\n\n\n    return sorted(r)\n\n\n\ndef main():\n\n    n = I()\n\n    a = LI()\n\n    s = set()\n\n    for i in range(n,0,-1):\n\n        d = divisions(i)\n\n        ld = len(d)\n\n        for j in range(1,2**ld):\n\n            c = []\n\n            ff = True\n\n            for k in range(ld):\n\n                if j & (1<<k):\n\n                    f = True\n\n                    for e in c:\n\n                        if d[k] % e == 0:\n\n                            f = False\n\n                            ff = False\n\n                            break\n\n                    if f:\n\n                        c.append(d[k])\n\n                if not ff:\n\n                    break\n\n            if ff:\n\n                s.add(tuple(c + [n+1]))\n\n    b = sorted(list(s), reverse=True)\n\n    for c in b:\n\n        t = 0\n\n        for j in range(1,n+1):\n\n            f = False\n\n            for e in c:\n\n                if j%e == 0:\n\n                    f = True\n\n                    break\n\n            if f:\n\n                t += a[j-1]\n\n        if t < 0:\n\n            for j in range(1,n+1):\n\n                f = False\n\n                for e in c:\n\n                    if j%e == 0:\n\n                        f = True\n\n                        break\n\n                if f:\n\n                    a[j-1] = 0\n\n\n\n    return sum(a)\n\n\n\n\n\n\n\nprint(main())\n\n\n\n\n", "generated_code": "N=int(eval(input()))\n\nA=list(map(int,input().split()))\n\nB=[]\n\nfor i in range(N):\n\n    B.append(A[i]-i-1)\n\nB.sort()\n\nif N%2:\n\n    b=B[N//2]\n\nelse:\n\n    b=(B[N//2]+B[N//2-1])//2\n\nans=0\n\nfor k in B:\n\n    ans+=abs(k-b)\n\nprint(ans)", "score": 0.0, "codebleu": 0.07543278798619747, "crystalbleu": 0.002577161244119221, "codebertscore": 0.7, "codescore": 0.14811113476753235, "surfaceSim": 0.4667340138947965, "abs_surfaceSim_minus_score": 0.4667340138947965}
{"golden_code": "import itertools\n\nfrom collections import Counter\n\nN = int(eval(input()))\n\nsrc = [eval(input()) for i in range(N)]\n\nctr = Counter()\n\nfor s in src:\n\n    ctr[s[0]] += 1\n\n\n\nans = 0\n\nfor ptn in itertools.combinations('MARCH',3):\n\n    a,b,c = ptn\n\n    ans += ctr[a]*ctr[b]*ctr[c]\n\nprint(ans)", "generated_code": "import sys\n\nn,m = [int(x) for x in sys.stdin.readline().split()]\n\nr = [0]*n\n\nfor _ in range(m):\n\n\ta, b = [int(x) for x in sys.stdin.readline().split()]\n\n\tr[a-1] += 1\n\n\tr[b-1] += 1\n\nfor i in r:\n\n\tprint(i)", "score": 0.0, "codebleu": 0.15570508811115208, "crystalbleu": 0.0, "codebertscore": 0.77, "codescore": 0.36834344267845154, "surfaceSim": 0.652534965034965, "abs_surfaceSim_minus_score": 0.652534965034965}
{"golden_code": "def mi():return list(map(int,input().split()))\n\nimport numpy as np\n\nA,B,M=mi()\n\na=np.array(list(mi()))\n\nb=np.array(list(mi()))\n\nminab=min(a)+min(b)\n\n\n\nans=float(\"inf\")\n\n\n\nfor i in range(M):\n\n    x,y,c=mi()\n\n    tmp=a[x-1]+b[y-1]-c\n\n    ans=min(ans,tmp)\n\nprint((min(ans,minab)))\n", "generated_code": "N = int(eval(input()))\n\nS = [eval(input()) for i in range(N)]\n\nfrom collections import Counter\n\nctr = Counter([s[0] for s in S])\n\n\n\nans = 0\n\nimport itertools\n\nfor ptn in itertools.combinations('MARCH', 3):\n\n    t = 1\n\n    for c in ptn:\n\n        t *= ctr[c]\n\n    ans += t\n\nprint(ans)", "score": 0.0, "codebleu": 0.17525534504757279, "crystalbleu": 0.0, "codebertscore": 0.73, "codescore": 0.5761481523513794, "surfaceSim": 0.4373977086743044, "abs_surfaceSim_minus_score": 0.4373977086743044}
{"golden_code": "n = int(eval(input()))\n\nary = list(map(int, input().split()))\n\n#print(n,ary)\n\n\n\nary_2 = [ary[0]]\n\nfor i in range(1, n):\n\n    ary_2.append(ary[i] + ary_2[i-1])\n\nary_2 = [0] + ary_2\n\n#print(ary_2)\n\n\n\nfrom collections import Counter\n\nc = Counter(ary_2)\n\nv = (list(c.values()))\n\n#print(v)\n\n\n\nfrom math import factorial\n\ndef combinations_count(n, r):\n\n    return factorial(n) // (factorial(n - r) * factorial(r))\n\n\n\nans = 0\n\nfor j in v:\n\n    if j >1:\n\n        ans += combinations_count(j,2)\n\n\n\nprint(ans)", "generated_code": "N=int(eval(input()))\n\nd=list(map(int, input().split()))\n\n\n\ncumsum = 0\n\nfor n in range(N):\n\n    cumsum += d[n]\n\nsub_cumsum = 0\n\nans = 0\n\nfor n in range(N):\n\n    sub_cumsum += d[n]\n\n    ans += d[n] * (cumsum-sub_cumsum)\n\nprint(ans)\n", "score": 0.0, "codebleu": 0.21479597555818686, "crystalbleu": 0.19535764144594586, "codebertscore": 0.75, "codescore": 0.12372125685214996, "surfaceSim": 0.5520684225594046, "abs_surfaceSim_minus_score": 0.5520684225594046}
{"golden_code": "n = int(eval(input()))\n\n\n\nfelicidade = []\n\n\n\nfor x in range(n):\n\n    felicidade.append(list(map(int,input().split())))\n\n\n\nDP = [0,0,0]\n\n\n\nif n == 1:\n\n    print((max(felicidade[0])))\n\n\n\nelse:\n\n\n\n    for x in range(3):\n\n        DP[x] = felicidade[0][x]\n\n\n\n\n\n    for dia in range(1,n):\n\n        m = [0] * 3\n\n        for x  in range(3):#As duas possíveis escolhas são x e y\n\n            for y  in range(3):\n\n                if x != y: #Se elas forem diferentes\n\n                    m[x] = max(m[x], DP[y] + felicidade[dia][x])\n\n        DP = m\n\n    \n\n    print((max(DP)))\n", "generated_code": "#!/usr/bin/env python3\n\n\n\nn = int(eval(input()))\n\ns = [eval(input()) for _ in range(n)]\n\nd = {}\n\n\n\nfor c in s:\n\n    if c[0] not in d:\n\n        d[c[0]] = 1 \n\n    else:\n\n        d[c[0]] += 1\n\n\n\ntmp = d.copy()\n\nt = ['M', 'A', 'R', 'C', 'H']\n\nfor c in tmp:\n\n    if c not in t:\n\n        d.pop(c)\n\n\n\nans = 0 \n\ndlist = list(d.items())\n\nfor i in range(len(dlist)):\n\n    for j in range(i+1, len(dlist)):\n\n        for k in range(j+1, len(dlist)):\n\n            ans += dlist[i][1]*dlist[j][1]*dlist[k][1]\n\nprint(ans)\n", "score": 0.0, "codebleu": 0.1554587323587034, "crystalbleu": 0.07422652838008394, "codebertscore": 0.72, "codescore": 0.9146832823753357, "surfaceSim": 0.6474779541446208, "abs_surfaceSim_minus_score": 0.6474779541446208}
{"golden_code": "#!usr/bin/env python3\n\nfrom collections import defaultdict\n\nfrom collections import deque\n\nfrom heapq import heappush, heappop\n\nimport sys\n\nimport math\n\nimport bisect\n\nimport random\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\n\ndef I(): return int(sys.stdin.readline())\n\ndef LS():return list(map(list, sys.stdin.readline().split()))\n\ndef S(): return list(sys.stdin.readline())[:-1]\n\ndef IR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = I()\n\n    return l\n\ndef LIR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = LI()\n\n    return l\n\ndef SR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = S()\n\n    return l\n\ndef LSR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = SR()\n\n    return l\n\nmod = 1000000007\n\n\n\n#A\n\ndef A():\n\n    s = S()\n\n    t = S()\n\n    if s+t == t[::-1]+s[::-1]:\n\n        print(\"YES\")\n\n    else:\n\n        print(\"NO\")\n\n\n\n#B\n\ndef B():\n\n    n = I()\n\n    for i in range(int(n**0.5)+2)[::-1]:\n\n        if i*i <= n:\n\n            print((i*i))\n\n            quit()\n\n#C\n\ndef C():\n\n    n = I()\n\n    a = LI()\n\n    b = LI()\n\n    c = LI()\n\n    q = [0 for i in range(n)]\n\n    ans = 0\n\n    a.sort()\n\n    b.sort()\n\n    c.sort()\n\n    for i in range(n):\n\n        j = bisect.bisect_left(a,b[i])\n\n        q[i] = j\n\n    for i in range(n-1):\n\n        q[i+1] += q[i]\n\n    q.insert(0,0)\n\n    for i in range(n):\n\n        j = bisect.bisect_left(b,c[i])\n\n        ans += q[j]\n\n    print(ans)\n\n#D\n\ndef D():\n\n    def dijkstra():\n\n        d = [float(\"inf\") for i in range(k)]\n\n        q = [[0,1]]\n\n        d[1] = 0\n\n        while q:\n\n            dx,x = heappop(q)\n\n            for y,dy in v[x]:\n\n                if d[y] > dx+dy:\n\n                    d[y] = dx+dy\n\n                    heappush(q,[d[y],y])\n\n        print((d[0]+1))\n\n    k = I()\n\n    if k == 1:\n\n        print((1))\n\n        quit()\n\n    v = [[] for i in range(k)]\n\n    for i in range(1,k):\n\n        v[i].append([(i+1)%k,1])\n\n        v[i].append([i*10%k,0])\n\n    dijkstra()\n\n#E\n\ndef E():\n\n    return\n\n\n\n#F\n\ndef F():\n\n    return\n\n\n\n#G\n\ndef G():\n\n    return\n\n\n\n#H\n\ndef H():\n\n    return\n\n\n\n#Solve\n\nif __name__ == \"__main__\":\n\n    D()\n", "generated_code": "K,S=list(map(int,input().split()))\n\nans=0\n\nfor X in range(K+1):\n\n    for Y in range(K+1):\n\n        Z=S-X-Y\n\n        if 0<=Z<=K:\n\n            ans+=1\n\nprint(ans)\n", "score": 0.0, "codebleu": 0.06973524387689425, "crystalbleu": 1.500811105240024e-05, "codebertscore": 0.7, "codescore": 0.27981024980545044, "surfaceSim": 0.4273130095710741, "abs_surfaceSim_minus_score": 0.4273130095710741}
{"golden_code": "# 参考 https://atcoder.jp/contests/abc133/submissions/7966658\n\n\n\nimport numpy as np\n\n\n\ndef abc133_c():\n\n    L, R = list(map(int, input().split()))\n\n    if R - L > 673: return 0\n\n    x = np.arange(L, R+1, dtype=np.int64)\n\n    #y = x[:, None] * x[None, :] % 2019\n\n    y = x.reshape(-1, 1) * x.reshape(1, -1)  # 区間内のすべての組合せの積\n\n    y %= 2019\n\n    np.fill_diagonal(y, 2019)  # 対角成分は無視する (同じ数を2回選べない) のでinf値で埋める\n\n    return y.min()\n\n\n\nprint((abc133_c()))", "generated_code": "import sys\n\ndef input(): return sys.stdin.readline().strip()\n\ndef main():\n\n    N = int(input())\n\n    A = (int(input()) for _ in range(N))\n\n    print(\"second\") if all(( a%2==0 for a in A)) else print(\"first\")\n\nif __name__ == \"__main__\":\n\n    main()\n", "score": 0.0, "codebleu": 0.12335946236128817, "crystalbleu": 0.0, "codebertscore": 0.62, "codescore": 0.018319739028811455, "surfaceSim": 0.5918920873716187, "abs_surfaceSim_minus_score": 0.5918920873716187}
{"golden_code": "import sys\n\ninput = sys.stdin.readline\n\nfrom collections import *\n\n\n\ndef dfs(x, y):\n\n    if x==0 and y==0:\n\n        t[x][y] = False\n\n        return False\n\n    \n\n    if x>=1:\n\n        t[x][y] |= not dfs(x-1, y)\n\n        \n\n    if y>=1:\n\n        t[x][y] |= not dfs(x, y-1)\n\n        \n\n    if min(x, y)>=1:\n\n        t[x][y] |= not dfs(x-1, y-1)\n\n   \n\n    return t[x][y]\n\n    \n\nt = [[False]*7 for _ in range(7)]\n\n\n\nfor i in range(7):\n\n    for j in range(7):\n\n        dfs(i, j)\n\n\n\n\"\"\"\n\nfor ti in t:\n\n    print(*ti)\n\n\"\"\"\n\n\n\nN = int(eval(input()))\n\nflag = True\n\n\n\nfor _ in range(N):\n\n    a = int(eval(input()))\n\n    \n\n    if a%2==1:\n\n        flag = False\n\n        \n\nif flag:\n\n    print('second')\n\nelse:\n\n    print('first')", "generated_code": "import sys\n\ninput = sys.stdin.readline\n\nsys.setrecursionlimit(10 ** 7)\n\n\n\nK, S = list(map(int, input().split()))\n\n\n\nans = 0\n\nfor z in range(K+1):\n\n    for y in range(K+1):\n\n        x = S - (z + y)\n\n        if 0 <= x <= K:\n\n            ans += 1\n\nprint(ans)", "score": 0.0, "codebleu": 0.11848162317616401, "crystalbleu": 0.0330746152555736, "codebertscore": 0.74, "codescore": 0.22179505228996277, "surfaceSim": 0.46775946704067317, "abs_surfaceSim_minus_score": 0.46775946704067317}
{"golden_code": "k,s=list(map(int,input().split()))\n\ncnt=0\n\nfor i in range(k+1):\n\n    for j in range(k+1):\n\n        if 0 <= s-i-j <= k:\n\n            cnt+=1\n\nprint(cnt)", "generated_code": "import sys\n\n\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\nreadlines = sys.stdin.readlines\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = 1 << 60\n\n\n\n\n\ndef gcd(a, b):\n\n    while b:\n\n        a, b = b, a % b\n\n    return a\n\n\n\n\n\ndef lcm(a, b):\n\n    return a * b // gcd(a, b)\n\n\n\n\n\ndef main():\n\n    N, M, *A = list(map(int, read().split()))\n\n    A = list(set(A))\n\n    B = A.copy()\n\n\n\n    while not any(b % 2 for b in B):\n\n        B = [b // 2 for b in B]\n\n\n\n    if not all(b % 2 for b in B):\n\n        print((0))\n\n        return\n\n\n\n    semi_lcm = 1\n\n    for a in A:\n\n        semi_lcm = lcm(semi_lcm, a // 2)\n\n\n\n    print(((M // semi_lcm + 1) // 2))\n\n    return\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 0.0, "codebleu": 0.26245661320123914, "crystalbleu": 0.054822212205991296, "codebertscore": 0.65, "codescore": 0.019853511825203896, "surfaceSim": 0.41575865679165536, "abs_surfaceSim_minus_score": 0.41575865679165536}
{"golden_code": "import sys\n\nsys.setrecursionlimit(202020)\n\n\n\nN = int(eval(input()))\n\nwon = [[] for i in range(N)]\n\nfor i in range(1,N):\n\n    a = int(eval(input())) - 1\n\n    won[a].append(i)\n\n\n\ndef height(v):\n\n    if not won[v]: return 0\n\n    hs = [height(op) for op in won[v]]\n\n    ret = 0\n\n    for i,h in enumerate(sorted(hs)):\n\n        ret = max(ret, h + len(hs) - i)\n\n    return ret\n\n\n\nprint((height(0)))", "generated_code": "n = int(eval(input()))\n\na = list(map(int, input().split()))\n\n\n\nans = float(\"inf\")\n\n\n\nfor i in a:\n\n    ans = min(ans, len(bin(i)) - bin(i).rfind(\"1\") - 1) # (1)…2で割った回数が最小のものを探索\n\nprint(ans)", "score": 0.0, "codebleu": 0.17190347612920293, "crystalbleu": 0.0444297846374809, "codebertscore": 0.71, "codescore": 0.11711008101701736, "surfaceSim": 0.42911947387650706, "abs_surfaceSim_minus_score": 0.42911947387650706}
{"golden_code": "from collections import Counter\n\nN = int(eval(input()))\n\ndiv = []\n\nfor i in range(2,N+1):\n\n    while i != 1:\n\n        for d in range(2,i+1):\n\n            while i%d==0:\n\n                i = i//d\n\n                div.append(d)\n\nC = Counter(div).most_common()\n\nAns = 1\n\nfor k,v in C:\n\n    Ans = Ans*(v+1) % (10**9+7)\n\n\n\nprint(Ans)\n", "generated_code": "n = int(eval(input()))\n\na = list(map(int,input().split()))\n\n\n\nfrom itertools import product\n\n\n\nli = [-1,0,1]\n\ncnt = 0\n\nfor v in product(li,repeat = n):\n\n    L = []\n\n    for i in range(n):\n\n        L.append(v[i]+a[i])\n\n    if any(x%2==0 for x in L):\n\n        cnt +=1\n\n\n\nprint(cnt)", "score": 0.0, "codebleu": 0.231497835620658, "crystalbleu": 0.12345677205911317, "codebertscore": 0.77, "codescore": 0.993883490562439, "surfaceSim": 0.502910199556541, "abs_surfaceSim_minus_score": 0.502910199556541}
{"golden_code": "import math\n\nN, M = list(map(int, input().split()))\n\n\n\n\n\ndef factorization(n):\n\n    arr = []\n\n    temp = n\n\n    for i in range(2, int(-(-n**0.5//1))+1):\n\n        if temp % i == 0:\n\n            cnt = 0\n\n            while temp % i == 0:\n\n                cnt += 1\n\n                temp //= i\n\n            arr.append([i, cnt])\n\n    if temp != 1:\n\n        arr.append([temp, 1])\n\n\n\n    if arr == [] and n != 1:\n\n        arr.append([n, 1])\n\n\n\n    return arr\n\n\n\n\n\nmod = 10**9 + 7\n\n\n\n\n\ndef cmb(n, r, mod):\n\n    if (r < 0 or r > n):\n\n        return 0\n\n    r = min(r, n-r)\n\n    return g1[n] * g2[r] * g2[n-r] % mod\n\n\n\n\n\ng1 = [1, 1]\n\ng2 = [1, 1]\n\ninverse = [0, 1]\n\nfor i in range(2, 2*10**5 + 1):\n\n    g1.append((g1[-1] * i) % mod)\n\n    inverse.append((-inverse[mod % i] * (mod//i)) % mod)\n\n    g2.append((g2[-1] * inverse[-1]) % mod)\n\n\n\n\n\nprimes = factorization(M)\n\n# 何箇所に分けるか（cnt以下）,その中でどう分けるか（しきりをどこにおくか（振り分けられないものが出ると選べれないのとおなじになるので、cnt - 選んだ数））\n\n\n\nans = 1\n\n\n\nfor p, cnt in primes:\n\n    tmp = cmb(N+cnt-1, N-1, mod)\n\n    ans *= tmp\n\n    ans %= mod\n\n\n\nprint(ans)\n", "generated_code": "from heapq import heappop,heappush\n\nn,m=list(map(int,input().split()))\n\na=[int(i) for i in input().split()]\n\na.sort()\n\nbc=[[int(i) for i in input().split()]for j in range(m)]\n\nbc=sorted(bc, key=lambda x:x[1],reverse=True)\n\n\n\nans=[]\n\nfor b,c in bc:    \n\n    while b>0 and a: \n\n        x = heappop(a)\n\n        if x<c:\n\n            ans.append(c)\n\n            b-=1\n\n        else:\n\n            ans.append(x)\n\nprint((sum(ans)+sum(a)))", "score": 0.0, "codebleu": 0.11007085799290486, "crystalbleu": 0.05332736178893692, "codebertscore": 0.69, "codescore": 0.4657462537288666, "surfaceSim": 0.5753426101623444, "abs_surfaceSim_minus_score": 0.5753426101623444}
{"golden_code": "from math import factorial as f\n\nn = int(eval(input()))\n\nprint((f(n) % (10 ** 9 + 7)))", "generated_code": "import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\nimport itertools\n\nfrom collections import defaultdict\n\n\n\nN,*A = list(map(int,read().split()))\n\n\n\nAcum = [0] + list(itertools.accumulate(A))\n\n\n\ncounter = defaultdict(int)\n\nanswer = 0\n\nfor x in Acum:\n\n    answer += counter[x]\n\n    counter[x] += 1\n\n\n\nprint(answer)", "score": 0.0, "codebleu": 0.2503180827460003, "crystalbleu": 0.0, "codebertscore": 0.66, "codescore": 0.3713785409927368, "surfaceSim": 0.3940288341468952, "abs_surfaceSim_minus_score": 0.3940288341468952}
{"golden_code": "A, B = list(map(int, input().split()))\n\ncount_target = 0\n\n\n\nfor i in range(A, B + 1):\n\n    str_i = str(i)\n\n    reversed_i = ''\n\n    for n_th_i in reversed(list(range(len(str_i)))):\n\n        reversed_i += str_i[n_th_i]\n\n\n\n    if str_i == reversed_i:\n\n        count_target += 1\n\n\n\nprint(count_target)", "generated_code": "#!usr/bin/env python3\n\nfrom collections import defaultdict,deque\n\nfrom heapq import heappush, heappop\n\nfrom itertools import permutations\n\nimport sys\n\nimport math\n\nimport bisect\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\n\ndef I(): return int(sys.stdin.readline())\n\ndef LS():return [list(x) for x in sys.stdin.readline().split()]\n\ndef S():\n\n    res = list(sys.stdin.readline())\n\n    if res[-1] == \"\\n\":\n\n        return res[:-1]\n\n    return res\n\ndef IR(n):\n\n    return [I() for i in range(n)]\n\ndef LIR(n):\n\n    return [LI() for i in range(n)]\n\ndef SR(n):\n\n    return [S() for i in range(n)]\n\ndef LSR(n):\n\n    return [LS() for i in range(n)]\n\n\n\nsys.setrecursionlimit(1000000)\n\nmod = 1000000007\n\n\n\ndef solve():\n\n    def v(n):\n\n        return [n*10%k, (n+1)%k]\n\n    k = I()\n\n    d = [float(\"inf\")]*k\n\n    d[1] = 1\n\n    q = deque([1])\n\n    while q:\n\n        x = q.popleft()\n\n        vx = v(x)\n\n        dx = d[x]\n\n        for c in range(2):\n\n            nd = dx+c\n\n            y = vx[c]\n\n            if nd < d[y]:\n\n                d[y] = nd\n\n                if c:\n\n                    q.append(y)\n\n                else:\n\n                    q.appendleft(y)\n\n    print((d[0]))\n\n    return\n\n\n\n#Solve\n\nif __name__ == \"__main__\":\n\n    solve()\n", "score": 0.0, "codebleu": 0.22692407796119277, "crystalbleu": 0.032265966148754925, "codebertscore": 0.66, "codescore": 0.0198732390999794, "surfaceSim": 0.4562068048910154, "abs_surfaceSim_minus_score": 0.4562068048910154}
{"golden_code": "import numpy as np\n\nn,m=list(map(int,input().split()))\n\na=np.array([int(i) for i in input().split()])\n\nbc=np.array([[int(i) for i in input().split()] for j in range(m)])\n\n\n\na.sort()\n\nb=bc[:,0]\n\nc=bc[:,1]\n\n\n\nidx=np.argsort(c)\n\nb=b[idx][::-1]\n\nc=c[idx][::-1]\n\n\n\np=0\n\nfor b,c in zip(b,c):\n\n    a[p:p+b]=np.maximum(a[p:p+b],c)\n\n    p+=b\n\n    \n\n    \n\nprint((a.sum()))", "generated_code": "import sys\n\ninput = sys.stdin.readline\n\n\n\nn,k = list(map(int, input().split()))\n\nAs = [int(eval(input())) for i in range(n)]\n\n\n\n# N: 処理する区間の長さ\n\n\n\nINF = 0\n\n\n\nmx = 300001\n\nLV = (mx-1).bit_length()\n\nN0 = 2**LV\n\ndata = [INF]*(2*N0)\n\nlazy = [None]*(2*N0)\n\n\n\n# 伝搬対象の区間を求める\n\ndef gindex(l, r):\n\n    L = (l + N0) >> 1; R = (r + N0) >> 1\n\n    lc = 0 if l & 1 else (L & -L).bit_length()\n\n    rc = 0 if r & 1 else (R & -R).bit_length()\n\n    for i in range(LV):\n\n        if rc <= i:\n\n            yield R\n\n        if L < R and lc <= i:\n\n            yield L\n\n        L >>= 1; R >>= 1\n\n\n\n# 遅延伝搬処理\n\ndef propagates(*ids):\n\n    for i in reversed(ids):\n\n        v = lazy[i-1]\n\n        if v is None:\n\n            continue\n\n        lazy[2*i-1] = data[2*i-1] = lazy[2*i] = data[2*i] = v\n\n        lazy[i-1] = None\n\n\n\n# 区間[l, r)をxで更新\n\ndef update(l, r, x):\n\n    *ids, = gindex(l, r)\n\n    propagates(*ids)\n\n\n\n    L = N0 + l; R = N0 + r\n\n    while L < R:\n\n        if R & 1:\n\n            R -= 1\n\n            lazy[R-1] = data[R-1] = x\n\n        if L & 1:\n\n            lazy[L-1] = data[L-1] = x\n\n            L += 1\n\n        L >>= 1; R >>= 1\n\n    for i in ids:\n\n        data[i-1] = max(data[2*i-1], data[2*i])\n\n\n\n# 区間[l, r)内の最小値を求める\n\ndef query(l, r):\n\n    propagates(*gindex(l, r))\n\n    L = N0 + l; R = N0 + r\n\n\n\n    s = INF\n\n    while L < R:\n\n        if R & 1:\n\n            R -= 1\n\n            s = max(s, data[R-1])\n\n        if L & 1:\n\n            s = max(s, data[L-1])\n\n            L += 1\n\n        L >>= 1; R >>= 1\n\n    return s\n\n\n\nans = 0\n\nupdate(As[0],As[0]+1,1)\n\nfor i, a in enumerate(As[1:]):\n\n    l = max(0,a-k)\n\n    r = min(mx,a+k)\n\n    upd = query(l,r+1)\n\n    if upd == -1:continue\n\n    # print(\"i\",i,\"a\",a,\"upd\",upd,\"l\",l,\"r\",r)\n\n    update(a, a+1, upd+1)\n\n    ans = max(ans, upd+1)\n\nprint(ans)\n\n\n", "score": 0.0, "codebleu": 0.23378544848694943, "crystalbleu": 0.04956891650229091, "codebertscore": 0.7, "codescore": 0.9938212633132935, "surfaceSim": 0.5082095996545851, "abs_surfaceSim_minus_score": 0.5082095996545851}
{"golden_code": "import statistics\n\nN = int(eval(input()))\n\nA = [int(a)-i-1 for i,a in enumerate(input().split(),1)]\n\nb = statistics.median_low(A)\n\nc = statistics.median_high(A)\n\nd = sum([abs(x-b) for x in A])\n\ne = sum([abs(x-c) for x in A])\n\nprint((min(d,e)))", "generated_code": "def resolve():\n\n    '''\n\n    code here\n\n    '''\n\n    import collections\n\n    import itertools\n\n    N = int(eval(input()))\n\n    Ss = [input()[0] for _ in range(N)]\n\n\n\n    march_letter = [item for item in Ss if item in ['M', 'A', 'R', 'C', 'H']]\n\n    march_cnt = collections.Counter(march_letter)\n\n\n\n    if len(march_cnt) < 3:\n\n        res = 0\n\n    else:\n\n        res_list = itertools.combinations(list(march_cnt.values()),3)\n\n\n\n        res = 0\n\n        for element in res_list:\n\n            res += element[0]*element[1]*element[2]\n\n    print(res)\n\n\n\nif __name__ == \"__main__\":\n\n    resolve()\n", "score": 0.0, "codebleu": 0.23375130156267876, "crystalbleu": 0.04026800014928971, "codebertscore": 0.69, "codescore": 0.018539145588874817, "surfaceSim": 0.46598984771573604, "abs_surfaceSim_minus_score": 0.46598984771573604}
{"golden_code": "import heapq\n\n\n\nN = int(eval(input()))\n\nabc = [list(map(int,input().split())) for _ in range(N-1)]\n\nQ,K = list(map(int,input().split()))\n\nxy = [list(map(int,input().split())) for _ in range(Q)]\n\n\n\nconnect = [[] for _ in range(N)]\n\nINFTY = 10**15\n\nfor a,b,c in abc:\n\n    connect[a-1].append([b-1,c])\n\n    connect[b-1].append([a-1,c])\n\n\n\ncost = [[INFTY,False] for _  in range(N)]\n\ncost[K-1][0] = 0\n\nq = [(0,K-1)]\n\nwhile q:\n\n    _,i = heapq.heappop(q)\n\n    if cost[i][1]:\n\n        continue\n\n    cost[i][1] = True\n\n    ci0 = cost[i][0]\n\n    for j,c in connect[i]:\n\n        if cost[j][1]:\n\n            continue\n\n        tmp_cost = ci0+c\n\n        if tmp_cost < cost[j][0]:\n\n            cost[j][0] = tmp_cost\n\n            heapq.heappush(q,(tmp_cost,j))\n\n\n\nfor x,y in xy:\n\n    print((cost[x-1][0] + cost[y-1][0]))", "generated_code": "a,b,c,x,y=list(map(int,input().split()))\n\nans1=a*x+b*y\n\nans2=2*c*max(x,y)\n\nans3=2*c*min(x,y)+a*(x-min(x,y))+b*(y-min(x,y))\n\nprint((min(ans1,ans2,ans3)))", "score": 0.0, "codebleu": 0.08229813664596272, "crystalbleu": 0.02072366750607649, "codebertscore": 0.68, "codescore": 0.08289637416601181, "surfaceSim": 0.4066770186335404, "abs_surfaceSim_minus_score": 0.4066770186335404}
{"golden_code": "from collections import deque\n\n\n\nINF = float('inf')\n\n\n\ndr = (-1, 0, 0, 1)\n\ndc = (0, -1, 1, 0)\n\n\n\nH, W = list(map(int, input().split()))\n\n\n\ns = []\n\ntotal_white_count = 0\n\nfor _ in range(H):\n\n    t = eval(input())\n\n    s.append(t)\n\n    total_white_count += t.count('.')\n\np = [[INF for _ in range(W)] for _ in range(H)]\n\n\n\nans = -1\n\n\n\ndq = deque()\n\ndq.append((0, 0, 1))\n\nwhile dq:\n\n    r, c, d = dq.popleft() # 直した\n\n\n\n    nd = d + 1\n\n    for i in range(4):\n\n        nr = r + dr[i]\n\n        nc = c + dc[i]\n\n        if not (0 <= nr < H and 0 <= nc < W): continue\n\n        if s[nr][nc] == '#' : continue\n\n        if p[nr][nc] <= nd: continue\n\n        p[nr][nc] = nd\n\n        if nr == H - 1 and nc == W - 1:\n\n            ans = total_white_count - nd\n\n            break\n\n        dq.append((nr, nc, nd))\n\n    else:\n\n        continue\n\n    break\n\n\n\nprint(ans)\n", "generated_code": "import sys\n\ndef input(): return sys.stdin.readline().strip()\n\n\n\ndef resolve():\n\n    answer=1\n\n    n=int(eval(input()))\n\n    for i in range(1,n+1):\n\n        answer*=i\n\n        answer%=10**9+7\n\n    print(answer)\n\nresolve()", "score": 0.0, "codebleu": 0.09168432284287642, "crystalbleu": 0.00708546091355804, "codebertscore": 0.66, "codescore": 0.17958062887191772, "surfaceSim": 0.39458186101295645, "abs_surfaceSim_minus_score": 0.39458186101295645}
{"golden_code": "#coding:utf-8\n\nimport bisect\n\nimport sys\n\nsys.setrecursionlimit(10**6)\n\nwrite = sys.stdout.write\n\ndbg = lambda *something : print(*something) if DEBUG else 0\n\nDEBUG = True\n\n\n\n\n\n\n\ndef main(given = sys.stdin.readline):\n\n    input = lambda : given().rstrip()\n\n    LMIIS = lambda : list(map(int,input().split()))\n\n    II = lambda : int(input())\n\n    XLMIIS = lambda x : [LMIIS() for _ in range(x)]\n\n\n\n    n, t = LMIIS()\n\n    ab = XLMIIS(n)\n\n\n\n    dp1 = [[0]*t for _ in range(n)]\n\n    for i in range(1, n):\n\n        for j in range(1, t):\n\n            if j < ab[i-1][0]:\n\n                dp1[i][j] = dp1[i-1][j]\n\n            else:\n\n                dp1[i][j] = max(dp1[i-1][j], dp1[i-1][j-ab[i-1][0]] + ab[i-1][1])\n\n\n\n\n\n    dp2 = [[0]*t for _ in range(n)]\n\n    for i in range(1, n):\n\n        for j in range(1, t):\n\n            if j < ab[n - i][0]:\n\n                dp2[i][j] = dp2[i-1][j]\n\n            else:\n\n                dp2[i][j] = max(dp2[i-1][j], dp2[i-1][j-ab[n-i][0]] + ab[n-i][1])\n\n\n\n    ans = 0\n\n    for i in range(n):\n\n        for j in range(t - 1):\n\n            ans = max(ans, dp1[i][j] + dp2[n - i - 1][t - j - 1] + ab[i][1])\n\n    print(ans)\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "generated_code": "\n\nX = int(eval(input()))\n\nfor a in range(-120, 120):\n\n    find = False\n\n    for b in range(-120, 120):\n\n        x = a**5-b**5\n\n        if x == X:\n\n            find = True\n\n            print((a, b))\n\n            break\n\n    if find:\n\n        break\n", "score": 0.0, "codebleu": 0.046114839534306895, "crystalbleu": 0.00047997654240150794, "codebertscore": 0.65, "codescore": 0.8678745627403259, "surfaceSim": 0.4266722642037503, "abs_surfaceSim_minus_score": 0.4266722642037503}
{"golden_code": "from collections import Counter\n\nimport numpy as np\n\n\n\nN = int(eval(input()))\n\nA = np.array(input().split(), dtype = np.int64)\n\n\n\nc = Counter(A.cumsum())\n\nc[0] += 1\n\nanswer = sum(x*(x-1)//2 for x in list(c.values()))\n\nprint(answer)", "generated_code": "input();t=list(map(int,input().split()));T=sum(t)\n\nprint(*[T-t[i-1]+j for i,j in [list(map(int,input().split())) for _ in range(int(input()))]],sep='\\n')\n", "score": 0.0, "codebleu": 0.15529114572361252, "crystalbleu": 0.042066981581774916, "codebertscore": 0.76, "codescore": 0.0610923133790493, "surfaceSim": 0.4743589743589744, "abs_surfaceSim_minus_score": 0.4743589743589744}
{"golden_code": "N = int(eval(input()))\n\ns_list = {}\n\nfor i in range(N):\n\n  S = eval(input())\n\n  if S in list(s_list.keys()):\n\n    s_list[S] += 1\n\n  else:\n\n    s_list[S] = 0\n\nmax = 0\n\nmaxs = []\n\nfor s,c in list(s_list.items()):\n\n  if c > max:\n\n    maxs = [s]\n\n    max = c\n\n  elif c == max:\n\n    maxs.append(s)\n\nmaxs.sort()\n\nfor m in maxs:\n\n  print(m)", "generated_code": "from collections import deque\n\nN, M = list(map(int, input().split()))\n\nedges = [list(map(int, input().split())) for _ in range(M)]\n\n\n\ngraph = [[] for _ in range(N)]\n\nfor x, y in edges:\n\n    graph[x - 1].append(y - 1)\n\n    graph[y - 1].append(x - 1)\n\n\n\ndef dfs(s, c):\n\n    q = deque()\n\n    q.append(s)\n\n    visited[s] = True\n\n    color[s] = c\n\n    \n\n    while len(q) > 0:\n\n        v = q.pop()\n\n        for i in graph[v]:\n\n            if visited[i] and color[i] == color[v]:\n\n                return False\n\n            \n\n            if not visited[i]:\n\n                visited[i] = True\n\n                color[i] = -color[v]\n\n                q.append(i)\n\n                \n\n    return True\n\n\n\nvisited = [False] * N\n\ncolor = [0] * N\n\n\n\nif dfs(0, 1):\n\n    x = sum(v + 1 for v in color) // 2\n\n    print((x * (N - x) - M))\n\nelse:\n\n    print((N * (N - 1) // 2 - M))\n\n    \n\n    ", "score": 0.0, "codebleu": 0.20062970687025355, "crystalbleu": 0.06363902937552059, "codebertscore": 0.74, "codescore": 0.37229788303375244, "surfaceSim": 0.4903478700685624, "abs_surfaceSim_minus_score": 0.4903478700685624}
{"golden_code": "import sys\n\nfrom fractions import gcd\n\n\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\nreadlines = sys.stdin.readlines\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = 1 << 60\n\n\n\n\n\ndef lcm(x, y):\n\n    return x * y // gcd(x, y)\n\n\n\n\n\ndef main():\n\n    N, M = list(map(int, input().split()))\n\n    A = list(set(map(int, input().split(\" \"))))\n\n    A = [a // 2 for a in A]\n\n    semi_lcm = 1\n\n    for a in A:\n\n        semi_lcm = lcm(semi_lcm, a)\n\n        if semi_lcm > M:\n\n            print((0))\n\n            return\n\n\n\n    for a in A:\n\n        if semi_lcm // a % 2 == 0:\n\n            print((0))\n\n            return\n\n\n\n    print(((M // semi_lcm + 1) // 2))\n\n    return\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "generated_code": "K,S=list(map(int,input().split()))\n\nans=0\n\nfor X in range(K+1):\n\n    for Y in range(K+1):\n\n        Z=S-X-Y\n\n        if 0<=Z<=K:\n\n            ans+=1\n\nprint(ans)\n", "score": 0.0, "codebleu": 0.09703261643149605, "crystalbleu": 0.0, "codebertscore": 0.67, "codescore": 0.5032723546028137, "surfaceSim": 0.4328389475448299, "abs_surfaceSim_minus_score": 0.4328389475448299}
{"golden_code": "a, b = list(map(int, input().split()))\n\ncnt = 0\n\n\n\nfor i in range(a, b+1):\n\n    i = str(i)\n\n    if i[0] == i[-1] and i[1] == i[-2]:\n\n        cnt += 1\n\n\n\nprint(cnt)\n", "generated_code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,copy,functools\n\nimport time,random\n\n\n\nsys.setrecursionlimit(10**7)\n\ninf = 10**20\n\neps = 1.0 / 10**10\n\nmod = 10**9+7\n\nmod2 = 998244353\n\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\n\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\n\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\n\ndef LLI(): return [list(map(int, l.split())) for l in sys.stdin.readlines()]\n\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\n\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\n\ndef LS(): return sys.stdin.readline().split()\n\ndef I(): return int(sys.stdin.readline())\n\ndef F(): return float(sys.stdin.readline())\n\ndef S(): return input()\n\ndef pf(s): return print(s, flush=True)\n\ndef pe(s): return print(str(s), file=sys.stderr)\n\ndef JA(a, sep): return sep.join(map(str, a))\n\ndef JAA(a, s, t): return s.join(t.join(map(str, b)) for b in a)\n\n\n\n\n\nclass Flow():\n\n    def __init__(self, e, N):\n\n        self.E = e\n\n        self.N = N\n\n\n\n    def max_flow(self, s, t):\n\n        r = 0\n\n        e = self.E\n\n\n\n        def f(c, cap):\n\n            v = self.v\n\n            v[c] = 1\n\n            if c == t:\n\n                return cap\n\n            for i in range(self.N):\n\n                if v[i] or e[c][i] <= 0:\n\n                    continue\n\n                cp = min(cap, e[c][i])\n\n                k = f(i, cp)\n\n                if k > 0:\n\n                    e[c][i] -= k\n\n                    e[i][c] += k\n\n                    return k\n\n            return 0\n\n\n\n        while True:\n\n            self.v = [None] * self.N\n\n            fs = f(s, inf)\n\n            if fs == 0:\n\n                break\n\n            r += fs\n\n\n\n        return r\n\n\n\n\n\ndef main():\n\n    n = I()\n\n    a = LI()\n\n\n\n    s = n\n\n    t = n + 1\n\n    e = [[0] * (n+2) for _ in range(n+2)]\n\n    for i in range(n):\n\n        c = a[i]\n\n        if c < 0:\n\n            e[s][i] = -c\n\n            ii = i + 1\n\n            for j in range(ii*2, n+1, ii):\n\n                e[i][j-1] = inf\n\n        else:\n\n            e[i][t] = c\n\n\n\n\n\n    fl = Flow(e, n+2)\n\n    r = fl.max_flow(s,t)\n\n\n\n    return sum(map(lambda x: max(0,x), a)) - r\n\n\n\n# start = time.time()\n\nprint(main())\n\n# pe(time.time() - start)\n\n\n\n\n\n\n", "score": 0.0, "codebleu": 0.1655887109729976, "crystalbleu": 0.03368599045469859, "codebertscore": 0.66, "codescore": 0.9939356446266174, "surfaceSim": 0.4383054306337629, "abs_surfaceSim_minus_score": 0.4383054306337629}
{"golden_code": "import numpy as np\n\nN = int(eval(input()))\n\nV = np.array([int(i) for i in input().split(\" \")])\n\nC = np.array([int(i) for i in input().split(\" \")])\n\n\n\nvc = V-C\n\n\n\nval = 0\n\n\n\nfor i in range(N):\n\n    if vc[i]>0:\n\n        val+=vc[i]\n\nprint(val)", "generated_code": "N = int(eval(input()))\n\n\n\nFACTOR = 10 ** 9 + 7\n\n\n\nnum = 1\n\nfor i in range(1, N+1):\n\n    num *= i\n\n    k, r = divmod(num, FACTOR)\n\n    num = r\n\n\n\nprint(r)", "score": 0.0, "codebleu": 0.2058118360376645, "crystalbleu": 0.0, "codebertscore": 0.74, "codescore": 0.9176826477050781, "surfaceSim": 0.43701923076923077, "abs_surfaceSim_minus_score": 0.43701923076923077}
