{"golden_code": "import numpy as np\n\n\n\nX, Y, Z, K = list(map(int, input().split()))\n\nA = np.array([int(i) for i in input().split()])\n\nB = np.array([int(i) for i in input().split()])\n\nC =np.array([int(i) for i in input().split()])\n\nA = -np.sort(-A) #要チェックや\n\nB = -np.sort(-B)\n\nC = -np.sort(-C)\n\nD = []\n\nfor i in range(min(K, X)):\n\n    for j in range(min(K, Y)):\n\n        if (i + 1) * (j + 1) > K:\n\n            break\n\n        for k in range(min(K, Z)):\n\n            if (i + 1) * (j + 1) * (k + 1) > K:\n\n                break\n\n            else:\n\n\n\n                D.append(A[i] + B[j] + C[k])\n\n\n\nX = np.array(D)\n\nX = -np.sort(-X)\n\nfor i in range(K):\n\n    print((X[i]))", "generated_code": "X, Y, Z, K = list(map(int, input().split()))\n\nA = sorted([int(i) for i in input().split()], reverse=True)\n\nB = sorted([int(i) for i in input().split()], reverse=True)\n\nC = sorted([int(i) for i in input().split()], reverse=True)\n\nD = []\n\nfor i in range(min(K, X)):\n\n    for j in range(min(K, Y)):\n\n        if (i + 1) * (j + 1) > K:\n\n            break\n\n        for k in range(min(K, Z)):\n\n            if (i + 1) * (j + 1) * (k + 1) > K:\n\n                break\n\n            else:\n\n\n\n                D.append(A[i] + B[j] + C[k])\n\n\n\nD.sort(reverse=True)\n\nfor i in range(K):\n\n    print((D[i]))", "score": 1.0, "codebleu": 0.6179577441641066, "crystalbleu": 0.6596971537851387, "codebertscore": 0.9, "codescore": 0.8679231405258179, "surfaceSim": 0.8117962022521528, "abs_surfaceSim_minus_score": 0.18820379774784723}
{"golden_code": "def popcount(x):\n\n  r = 0\n\n  while x:\n\n    if x & 1:\n\n      r += 1\n\n    x >>= 1\n\n  return r\n\n\n\nn = int(eval(input()))\n\nr = list(range(n))\n\na = [[0, 0] for _ in r]\n\nfor i in r:\n\n  for _ in range(int(eval(input()))):\n\n    x, y = list(map(int, input().split()))\n\n    a[i][y] |= 1 << (x - 1)\n\n\n\nm = 0\n\nl = (1 << n) - 1\n\nfor x in range(1, l + 1):\n\n  if all(a[i][0] & x == a[i][1] & l - x == 0 for i in r if x >> i & 1):\n\n    m = max(m, popcount(x))\n\nprint(m)\n", "generated_code": "from itertools import combinations\n\n \n\nn = int(eval(input()))\n\nr = list(range(n))\n\na = [(set(), set()) for _ in r]\n\nfor i in r:\n\n  for _ in range(int(eval(input()))):\n\n    x, y = list(map(int, input().split()))\n\n    a[i][y].add(x - 1)\n\n \n\nfail = lambda x: not all(a[i][0].isdisjoint(x) and a[i][1] < x for i in x)\n\n \n\nwhile all(map(fail, list(map(set, combinations(r, n))))):\n\n  n -= 1\n\nprint(n)", "score": 1.0, "codebleu": 0.3504181129455211, "crystalbleu": 0.3292495512397752, "codebertscore": 0.83, "codescore": 0.8624736666679382, "surfaceSim": 0.6020737079617493, "abs_surfaceSim_minus_score": 0.3979262920382507}
{"golden_code": "import numpy as np\n\n\n\nN, K= list(map(int, input().split()))\n\np = np.array(list(map(int, input().split())))\n\n\n\ntmp = np.sum(p[:K])\n\nmax = tmp\n\nfor i in range(N-K):\n\n    tmp = tmp-p[i]+p[i+K]\n\n    if tmp>max:\n\n        max = tmp\n\n\n\nprint(((max+K)/2))", "generated_code": "N, K= list(map(int, input().split()))\n\np = list(map(int, input().split()))\n\n\n\ntmp = sum(p[:K])\n\nmax = tmp\n\nfor i in range(N-K):\n\n    tmp = tmp-p[i]+p[i+K]\n\n    if tmp>max:\n\n        max = tmp\n\n\n\nprint(((max+K)/2))", "score": 1.0, "codebleu": 0.6565883081422969, "crystalbleu": 0.8528085939151825, "codebertscore": 0.95, "codescore": 0.8761606216430664, "surfaceSim": 0.8978172856891392, "abs_surfaceSim_minus_score": 0.10218271431086079}
{"golden_code": "# 2019-11-12 22:21:08(JST)\n\nimport sys\n\n# import collections\n\n# import math\n\n# from string import ascii_lowercase, ascii_uppercase, digits\n\n# from bisect import bisect_left as bi_l, bisect_right as bi_r\n\nimport itertools\n\n# from functools import reduce\n\n# import operator as op\n\n# from scipy.misc import comb # float\n\n# import numpy as np \n\n\n\ndef main():\n\n    s = sys.stdin.readline().rstrip()\n\n    \n\n    all_words = []\n\n    for i in range(1, len(s) + 1):\n\n        for letters in itertools.product('ATCG', repeat=i):\n\n            word = ''.join(letters)\n\n            all_words.append(word)\n\n    \n\n    for i in range(len(all_words)-1, 0-1, -1):\n\n        if all_words[i] in s:\n\n            print((len(all_words[i])))\n\n            sys.exit()\n\n    print((0))\n\n\n\n\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "generated_code": "# 2019-11-12 22:21:08(JST)\n\nimport sys\n\n# import collections\n\n# import math\n\n# from string import ascii_lowercase, ascii_uppercase, digits\n\n# from bisect import bisect_left as bi_l, bisect_right as bi_r\n\n# import itertools\n\n# from functools import reduce\n\n# import operator as op\n\n# from scipy.misc import comb # float\n\n# import numpy as np \n\n\n\ndef main():\n\n    s = sys.stdin.readline().rstrip()\n\n    \n\n    permitted = 'ACGT'\n\n    continuous_count = []\n\n    count = 0\n\n\n\n    for i in range(len(s)):\n\n        char = s[i]\n\n        if char in permitted:\n\n            count += 1\n\n        else:\n\n            continuous_count.append(count)\n\n            count = 0\n\n        if i == len(s) - 1:\n\n            continuous_count.append(count)\n\n    \n\n    if not continuous_count:\n\n        print((len(s)))\n\n    else:\n\n        print((max(continuous_count)))\n\n\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "score": 1.0, "codebleu": 0.550324828479362, "crystalbleu": 0.3064552932033026, "codebertscore": 0.92, "codescore": 0.01891731470823288, "surfaceSim": 0.8026561043802423, "abs_surfaceSim_minus_score": 0.19734389561975774}
{"golden_code": "import sys\n\nfrom operator import itemgetter\n\nfrom heapq import heapify, heappop, heappush\n\nMAX_INT = int(10e15)\n\nMIN_INT = -MAX_INT\n\nmod = 1000000007\n\nsys.setrecursionlimit(1000000)\n\ndef IL(): return list(map(int,input().split()))\n\ndef SL(): return input().split()\n\ndef I(): return int(sys.stdin.readline())\n\ndef S(): return eval(input())\n\n\n\nN, T = IL()\n\nab = [IL() for i in range(N)]\n\nab.sort(key=itemgetter(0))\n\n#print(ab)\n\n\n\ndp = [[0]*(T+1+3000+1) for _ in range(N+1)]\n\nans = 0\n\nfor i in range(N):\n\n  for j in range(T+1+3000+1):\n\n    time, deli = ab[i]\n\n    if 0 <= j-time < T:\n\n      dp[i + 1][j] = max(dp[i][j], dp[i][j - time] + deli)\n\n    else:\n\n      dp[i + 1][j] = dp[i][j]\n\n    ans = max(ans, dp[i + 1][j])\n\nprint(ans)\n\n\n\n#print(dp)\n", "generated_code": "import sys\n\nfrom collections import deque\n\nMAX_INT = int(10e10)\n\nMIN_INT = -MAX_INT\n\nmod = 1000000007\n\nsys.setrecursionlimit(1000000)\n\ndef IL(): return list(map(int,input().split()))\n\ndef SL(): return input().split()\n\ndef I(): return int(sys.stdin.readline())\n\ndef S(): return eval(input())\n\n\n\nN,T = IL()\n\nab = [IL() for i in range(N)]\n\nab.sort()\n\n\n\nans = 0\n\ndp = [[0]*T for i in range(N+1)]\n\nfor i in range(1,N+1):\n\n  a,b = ab[i-1]\n\n  for j in range(T):\n\n    if 0 <= j-a < T:\n\n      dp[i][j] = max(dp[i-1][j], dp[i-1][j-a] + b)\n\n    else:\n\n      dp[i][j] = dp[i-1][j]\n\n  else:\n\n    ans = max(ans, dp[i-1][-1] + b)\n\nprint(ans)", "score": 1.0, "codebleu": 0.4549237617824019, "crystalbleu": 0.6568401202082702, "codebertscore": 0.91, "codescore": 0.49557241797447205, "surfaceSim": 0.8758309882132225, "abs_surfaceSim_minus_score": 0.12416901178677753}
{"golden_code": "N, D = list(map(int, input().split()))\n\ncnt = 0\n\nfor _ in range(N):\n\n    x, y = list(map(int, input().split()))\n\n    if x ** 2 + y ** 2 <= D ** 2:\n\n        cnt += 1\n\n        \n\nprint(cnt)", "generated_code": "N, D = list(map(int, input().split()))\n\ncnt = 0\n\nfor _ in range(N):\n\n    x, y = list(map(int, input().split()))\n\n    if x * x + y * y <= D * D:\n\n        cnt += 1\n\n        \n\nprint(cnt)", "score": 1.0, "codebleu": 0.7862404220058002, "crystalbleu": 0.8164474750850377, "codebertscore": 0.96, "codescore": 0.7885560989379883, "surfaceSim": 0.9312393887945671, "abs_surfaceSim_minus_score": 0.06876061120543286}
{"golden_code": "x = int(eval(input()))\n\n\n\nfor a in range(10**4):\n\n    for b in range(10**4):\n\n        if(a**5 + b**5 == x):\n\n            print((a, -b))\n\n            break\n\n        elif(a**5 - b**5 == x):\n\n            print((a, b))\n\n            break\n\n    else:\n\n        continue\n\n    break", "generated_code": "x = int(eval(input()))\n\n\n\nfor a in range(10**3):\n\n    for b in range(10**3):\n\n        if(a**5 + b**5 == x):\n\n            print((a, -b))\n\n            break\n\n        elif(a**5 - b**5 == x):\n\n            print((a, b))\n\n            break\n\n    else:\n\n        continue\n\n    break\n", "score": 1.0, "codebleu": 0.910202325144862, "crystalbleu": 0.8716710129026546, "codebertscore": 0.99, "codescore": 0.14229194819927216, "surfaceSim": 0.9963503649635037, "abs_surfaceSim_minus_score": 0.0036496350364962904}
{"golden_code": "import numpy as np\n\nfrom itertools import combinations \n\nINF = int(1e9)*15\n\ndef main():\n\n    n, k = list(map(int, input().split())) \n\n    a = np.array(input().split(), np.int32)\n\n    c = np.array([int(i) for i in range(1, n)])\n\n    ans = INF\n\n    for comb in combinations(c, k-1):\n\n        s = set(comb)\n\n        mx = a[0]\n\n        cost = 0\n\n        for i in range(n):\n\n            if i in s:\n\n                if a[i] > mx:\n\n                    mx = a[i]\n\n                    continue\n\n                else:\n\n                    mx += 1\n\n                    cost += mx-a[i] \n\n                    continue\n\n            mx = max(mx, a[i])\n\n        ans = min(cost, ans)\n\n    print(ans)\n\nif __name__ == '__main__':\n\n    main()\n", "generated_code": "from itertools import combinations \n\nINF = int(1e9)*15\n\ndef main():\n\n    n, k = list(map(int, input().split())) \n\n    a = [int(i) for i in input().split()]\n\n    c = [int(i) for i in range(1, n)]\n\n    ans = INF\n\n    for comb in combinations(c, k-1):\n\n        s = set(comb)\n\n        mx = a[0]\n\n        cost = 0\n\n        for i in range(n):\n\n            if i in s:\n\n                if a[i] > mx:\n\n                    mx = a[i]\n\n                    continue\n\n                else:\n\n                    mx += 1\n\n                    cost += mx-a[i] \n\n                    continue\n\n            mx = max(mx, a[i])\n\n        ans = min(cost, ans)\n\n    print(ans)\n\nif __name__ == '__main__':\n\n    main()\n", "score": 1.0, "codebleu": 0.7136843267760621, "crystalbleu": 0.8816471365423566, "codebertscore": 0.97, "codescore": 0.018495874479413033, "surfaceSim": 0.9513675099272744, "abs_surfaceSim_minus_score": 0.04863249007272563}
{"golden_code": "from collections import defaultdict\n\nN = int(eval(input()))\n\nd = defaultdict(int)\n\n\n\nfor i in range(N):\n\n    S = eval(input())\n\n    d[S] += 1\n\n\n\nm = 0\n\nfor k in list(d.keys()):\n\n    m = max(d[k],m)\n\n\n\nli = []\n\nfor k in list(d.keys()):\n\n    if d[k] == m:\n\n        li.append(k)\n\n\n\nli.sort()\n\nfor l in li:\n\n    print(l)", "generated_code": "from collections import defaultdict\n\nN = int(eval(input()))\n\nSs = [eval(input()) for i in range(N)]\n\n\n\nd = defaultdict(int)\n\nfor S in Ss:\n\n    d[S] += 1\n\n\n\nmx = max([d[k] for k in list(d.keys())])\n\n\n\nans = []\n\nfor k in list(d.keys()):\n\n    if d[k] == mx:\n\n       ans.append(k)\n\n       \n\nfor a in sorted(ans):\n\n    print(a)", "score": 1.0, "codebleu": 0.5354580236609368, "crystalbleu": 0.5250993742678821, "codebertscore": 0.93, "codescore": 0.9414618611335754, "surfaceSim": 0.8272162619988708, "abs_surfaceSim_minus_score": 0.17278373800112923}
{"golden_code": "import heapq\n\n\n\nx, y, z, k = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\nb = list(map(int, input().split()))\n\nc = list(map(int, input().split()))\n\n\n\ndef diff(l):\n\n    m = max(l)\n\n    return sorted(m - v for v in l)[1:]\n\n\n\ns = sum(map(max, [a, b, c]))\n\nsa, sb, sc = list(map(diff, [a, b, c]))\n\nda, db, dc = [0], [0], [0]\n\nq = [0]\n\nwhile k > 0:\n\n    while True:\n\n        if len(sa) > 0 and (len(q) == 0 or q[0] > sa[0]):\n\n            for v in [sa[0] + bb + cc for bb in db for cc in dc]:\n\n                heapq.heappush(q, v)\n\n            da.append(sa[0])\n\n            sa = sa[1:]\n\n        elif len(sb) > 0 and (len(q) == 0 or q[0] > sb[0]):\n\n            for v in [sb[0] + aa + cc for aa in da for cc in dc]:\n\n                heapq.heappush(q, v)\n\n            db.append(sb[0])\n\n            sb = sb[1:]\n\n        elif len(sc) > 0 and (len(q) == 0 or q[0] > sc[0]):\n\n            for v in [sc[0] + aa + bb for aa in da for bb in db]:\n\n                heapq.heappush(q, v)\n\n            dc.append(sc[0])\n\n            sc = sc[1:]\n\n        else:\n\n            break\n\n    v = heapq.heappop(q)\n\n    print(s - v)\n\n    k -= 1\n", "generated_code": "import heapq\n\n\n\nx, y, z, k = list(map(int, input().split()))\n\na = sorted(map(int, input().split()))\n\nb = sorted(map(int, input().split()))\n\nc = sorted(map(int, input().split()))\n\n\n\nq = []\n\nmemo = set()\n\ndef qpush(q, ai, bi, ci):\n\n    t = (-(a[ai] + b[bi] + c[ci]), ai, bi, ci)\n\n    if not t in memo:\n\n        memo.add(t)\n\n        heapq.heappush(q, t)\n\n\n\nqpush(q, len(a) - 1, len(b) - 1, len(c) - 1)\n\nfor _ in range(k):\n\n    s, ai, bi, ci = heapq.heappop(q)\n\n    if ai > 0:\n\n        qpush(q, ai - 1, bi, ci)\n\n    if bi > 0:\n\n        qpush(q, ai, bi - 1, ci)\n\n    if ci > 0:\n\n        qpush(q, ai, bi, ci - 1)\n\n    print(-s)\n", "score": 1.0, "codebleu": 0.2287366964443709, "crystalbleu": 0.1550992212295912, "codebertscore": 0.81, "codescore": 0.2204899787902832, "surfaceSim": 0.6056696055087201, "abs_surfaceSim_minus_score": 0.39433039449127993}
{"golden_code": "answer = 0\n\nN = int(eval(input()))\n\nA = list(map(int,input().split()))\n\nfor i in range(N) :\n\n    while A[i] % 2 == 0 :\n\n        A[i] = A[i] / 2\n\n        answer += 1\n\nprint(answer)\n\n\n", "generated_code": "N = int(eval(input()))\n\nL = list(map(int,input().split()))\n\n\n\nans = 0\n\nfor i in range(N) :\n\n    flag = 0\n\n    while flag == 0 :\n\n        if (L[i] % 2) == 0 :\n\n            ans += 1\n\n            L[i] = L[i]//2\n\n        else :\n\n            flag = 1\n\nprint(ans)\n", "score": 1.0, "codebleu": 0.42894117402748133, "crystalbleu": 0.49704771506945317, "codebertscore": 0.91, "codescore": 0.4999038279056549, "surfaceSim": 0.8174770965468641, "abs_surfaceSim_minus_score": 0.18252290345313593}
{"golden_code": "n, m, l = list(map(int, input().split()))\n\n\n\na = [0]*n\n\nb = [0]*m\n\nc = [[0 for col in range(l)] for row in range(n)]\n\n\n\nfor i in range(n):\n\n    a[i] = list(map(int,input().split()))\n\n\n\nfor i in range(m):\n\n    b[i] = list(map(int,input().split()))\n\n\n\n\n\nfor i in range(n):\n\n    for j in range(l):\n\n        for k in range(m):\n\n            c[i][j] += a[i][k]*b[k][j]\n\n    print((*c[i]))", "generated_code": "n, m, l = list(map(int, input().split()))\n\n\n\na = [0]*n\n\nb = [0]*m\n\nc = [[0 for col in range(l)] for row in range(n)]\n\n\n\nfor i in range(n):\n\n    a[i] = list(map(int,input().split()))\n\n\n\nfor i in range(m):\n\n    b[i] = list(map(int,input().split()))\n\n\n\n\n\nfor i in range(n):\n\n    for j in range(l):\n\n        c[i][j] = sum([a[i][k]*b[k][j] for k in range(m)])\n\n#        for k in range(m):\n\n#            c[i][j] += a[i][k]*b[k][j]\n\n    print((*c[i]))", "score": 1.0, "codebleu": 0.8979897652717481, "crystalbleu": 0.8668387424249506, "codebertscore": 0.98, "codescore": 0.9937830567359924, "surfaceSim": 0.9129665379665379, "abs_surfaceSim_minus_score": 0.08703346203346207}
{"golden_code": "a = int(eval(input()))\n\nh = int(a / 3600)\n\nm = int((a - h * 3600) / 60)\n\ns = int(a - h * 3600 - m * 60)\n\nprint((\":\" .join(map(str, [h, m, s]))))", "generated_code": "num = int(input())\n\nprint(int(num/3600), int((num%3600)/60), num%60, sep=\":\")\n", "score": 1.0, "codebleu": 0.11035332920854249, "crystalbleu": 0.0, "codebertscore": 0.82, "codescore": 0.023724190890789032, "surfaceSim": 0.5590277777777778, "abs_surfaceSim_minus_score": 0.4409722222222222}
{"golden_code": "from collections import deque\n\nK = int(eval(input()))\n\nG = [[] for i in range(K)]\n\n\n\nfor n in range(K):\n\n    G[n].append([(n + 1) % K, 1])\n\n    G[n].append([(10 * n) % K, 0])\n\n\n\nque = deque([[1, 1]])\n\ndist = [float('inf')] * K\n\n\n\nwhile que:\n\n    node, cost = que.pop()\n\n    dist[node] = min(cost, dist[node])\n\n    for e, e_cost in G[node]:\n\n        if dist[e] != float('inf'):\n\n            continue\n\n\n\n        if e_cost == 0:\n\n            que.append([e, cost + 0])\n\n\n\n        if e_cost == 1:\n\n            que.appendleft([e, cost + 1])\n\n\n\nprint((dist[0]))\n", "generated_code": "from collections import deque\n\nK = int(eval(input()))\n\nG = [[] for i in range(K)]\n\nfor i in range(K):\n\n    G[i].append(((10 * i) % K, 0))\n\n    G[i].append(((i + 1) % K, 1))\n\n\n\ndist = [float('inf')] * K\n\ndist[1] = 1\n\nque = deque()\n\nque.append(1)\n\n\n\nwhile que:\n\n    n = que.pop()\n\n    for v, c in G[n]:\n\n        if dist[v] > dist[n] + c:\n\n            dist[v] = dist[n] + c\n\n            if c == 0:\n\n                que.append(v)\n\n            else:\n\n                que.appendleft(v)\n\n\n\nprint((dist[0]))\n", "score": 1.0, "codebleu": 0.46694159872029084, "crystalbleu": 0.5237148293758432, "codebertscore": 0.91, "codescore": 0.6249884963035583, "surfaceSim": 0.807735321528425, "abs_surfaceSim_minus_score": 0.19226467847157502}
{"golden_code": "import math\n\nN = int(eval(input()))\n\nprint((math.factorial(N)%(10**9+7)))", "generated_code": "import math\n\nN = int(eval(input()))\n\na = 1\n\nfor n in range(2,N+1):\n\n    a = a*n % (10**9+7)\n\nprint(a)", "score": 1.0, "codebleu": 0.5101463671792871, "crystalbleu": 0.0, "codebertscore": 0.87, "codescore": 0.9002873301506042, "surfaceSim": 0.7434478741991846, "abs_surfaceSim_minus_score": 0.25655212580081543}
{"golden_code": "N=int(eval(input()))\n\n\n\nS=[[-1]*N for _ in range(N)]\n\nfor i in range(N):\n\n  A=int(eval(input()))\n\n  for _ in range(A):\n\n    x, y=list(map(int, input().split()))\n\n    S[i][x-1]=y\n\nans=0   \n\nfor s in range(2**N):\n\n  ok=True\n\n  for i in range(N):\n\n    #正直者について見ていく\n\n    if (s>>i&1)==1:\n\n      for j in range(N):\n\n        #それぞれ正直者の証言が矛盾ないか\n\n        if S[i][j]!=-1 and (s>>j&1)!=S[i][j]:\n\n          ok=False\n\n  if ok:\n\n    ans=max(ans, bin(s).count(\"1\"))\n\n    \n\nprint(ans)\n", "generated_code": "N=int(eval(input()))\n\n\n\nA=[[-1]*N for _ in range(N)]\n\nfor i in range(N):\n\n  a=int(eval(input()))\n\n  for j in range(a):\n\n    x,y=list(map(int, input().split()))\n\n    A[i][x-1]=y\n\n#正直者が正直者に不親切と言われていない\n\n#→正直ものが不親切を正直者と言っていないか\n\nans=0\n\nfor i in range(2**N):\n\n  ok=True\n\n  for j in range(N):\n\n    if (i>>j&1)==1:\n\n      for k in range(N):\n\n        if A[j][k]!=-1 and (i>>k&1)!=A[j][k]:\n\n          ok=False\n\n  if ok:\n\n    ans=max(ans, bin(i).count(\"1\"))\n\n  \n\nprint(ans)", "score": 1.0, "codebleu": 0.6160689630520192, "crystalbleu": 0.7293791569454686, "codebertscore": 0.91, "codescore": 0.8327347636222839, "surfaceSim": 0.9797008547008548, "abs_surfaceSim_minus_score": 0.020299145299145227}
{"golden_code": "import sys\n\ncan = True; eval(input())\n\ne = [[0, 0, 0]] + [list(map(int, e.split())) for e in sys.stdin]\n\nfor a, b in zip(e[1:], e):\n\n    t = a[0] - b[0] - abs(a[1] - b[1]) - abs(a[2] - b[2])\n\n    if t < 0 or t % 2 == 1: can = False; break\n\nprint((['No', 'Yes'][can]))", "generated_code": "import sys\n\nans = 'Yes'; eval(input())\n\nfor e in sys.stdin:\n\n    t, x, y = list(map(int, e.split()))\n\n    t = t - x - y\n\n    if t < 0 or t % 2 == 1: ans = 'No'; break\n\nprint(ans)", "score": 1.0, "codebleu": 0.25451653474995944, "crystalbleu": 0.2186313111646685, "codebertscore": 0.87, "codescore": 0.9739088416099548, "surfaceSim": 0.6473782771535581, "abs_surfaceSim_minus_score": 0.3526217228464419}
{"golden_code": "N, M, R = list(map(int, input().split()))\n\nr = list(map(int, input().split()))\n\nd = [[float('inf')]*N for _ in range(N)]\n\nfor i in range(M): #ひとまず枝があるペアは枝の長さをセット\n\n  a,b,t = list(map(int, input().split()))\n\n  d[a-1][b-1] = t\n\n  d[b-1][a-1] = t\n\n\n\nfor i in range(N):\n\n  d[i][i] = 0 #自身への最短経路は0\n\n#三重ループ\n\nfor k in range(N):\n\n  for i in range(N):\n\n    for j in range(N):\n\n      d[i][j] = min(d[i][j], d[i][k]+d[k][j])\n\n\n\nfrom itertools import groupby, accumulate, product, permutations, combinations\n\n\n\nans = float('inf')\n\nfor p in permutations(r,R):\n\n  cnt = 0\n\n  for i in range(1,R):\n\n    cnt += d[p[i-1]-1][p[i]-1]\n\n  ans = min(ans,cnt)\n\nprint(ans)", "generated_code": "N, M, r = list(map(int, input().split()))\n\nR = list([int(x)-1 for x in input().split()])\n\nd = [[1<<30]*N for _ in range(N)]\n\nfor i in range(M): #ひとまず枝があるペアは枝の長さをセット\n\n  a,b,t = list(map(int, input().split()))\n\n  d[a-1][b-1] = t\n\n  d[b-1][a-1] = t\n\n\n\nfor i in range(N):\n\n  d[i][i] = 0 #自身への最短経路は0\n\n#三重ループ\n\nfor k in range(N):\n\n  for i in range(N):\n\n    for j in range(N):\n\n      d[i][j] = min(d[i][j], d[i][k]+d[k][j])\n\nfrom itertools import groupby, accumulate, product, permutations, combinations\n\nans = 1<<30\n\nfor per in permutations(R,r):\n\n  cnt = 0\n\n  for i in range(r-1):\n\n    cnt += d[per[i]][per[i+1]]\n\n  ans = min(ans, cnt)\n\nprint(ans)", "score": 1.0, "codebleu": 0.7132631903543508, "crystalbleu": 0.7578004435593567, "codebertscore": 0.97, "codescore": 0.3640533685684204, "surfaceSim": 0.9335010319917441, "abs_surfaceSim_minus_score": 0.06649896800825594}
{"golden_code": "import numpy as np\n\nn, k = list(map(int, input().split()))\n\np = np.array(list(map(int, input().split())))\n\np += 1\n\nsum_E = np.cumsum(p)\n\nsum_e = np.append([0], sum_E)\n\nans = -1\n\nfor i in range(n-k+1):\n\n    ans = max(ans, sum_e[i+k] - sum_e[i])\n\nprint((ans/2))", "generated_code": "n, k = list(map(int, input().split()))\n\np = list(map(int, input().split()))\n\n\n\ndef calc(x):\n\n    return (x + 1) / 2\n\n\n\n\n\nw = 0\n\n\n\nfor i in range(k):\n\n    w += calc(p[i])\n\n\n\nans = w\n\nfor i in range(k, n):\n\n    w += calc(p[i]) - calc(p[i - k])\n\n    ans = max(ans, w)\n\nprint(ans)", "score": 1.0, "codebleu": 0.32069355178686754, "crystalbleu": 0.363704997316923, "codebertscore": 0.84, "codescore": 0.2213427573442459, "surfaceSim": 0.6141304347826086, "abs_surfaceSim_minus_score": 0.38586956521739135}
{"golden_code": "while True:\n\n    try:\n\n        for i in range(3):\n\n            line = input().strip()\n\n            if line == '0':\n\n                raise Exception\n\n\n\n            a = b = 0\n\n            for i, s in enumerate(line):\n\n                if i != 0:\n\n                    if s == 'A':\n\n                        a += 1\n\n                    else:\n\n                        b += 1\n\n            if a > b:\n\n                a += 1\n\n            else:\n\n                b += 1\n\n            print(a, b)\n\n\n\n    except:\n\n        break", "generated_code": "while True:\n\n    try:\n\n        for i in range(3):\n\n            line = input().strip()\n\n            if line == '0':\n\n                raise Exception\n\n\n\n            if line[0] == 'A':\n\n                a = -1\n\n                b = 0\n\n            else:\n\n                a = 0\n\n                b = -1\n\n            for i, s in enumerate(line):\n\n                if s == 'A':\n\n                    a += 1\n\n                else:\n\n                    b += 1\n\n            if a > b:\n\n                a += 1\n\n            else:\n\n                b += 1\n\n            print(a, b)\n\n\n\n    except:\n\n        break", "score": 1.0, "codebleu": 0.717942208700939, "crystalbleu": 0.7205067144620672, "codebertscore": 0.95, "codescore": 0.987359344959259, "surfaceSim": 0.8718141870684244, "abs_surfaceSim_minus_score": 0.1281858129315756}
{"golden_code": "INF = 10**10\n\n\n\nN, M = list(map(int, input().split()))\n\ncosts = []\n\nkeys = []\n\nfor _ in range(M):\n\n    A, B = list(map(int, input().split()))\n\n    cs = list(map(int, input().split()))\n\n    costs.append(A)\n\n    # 鍵を2進数化する\n\n    key = 0\n\n    for c in cs:\n\n        key |= 1<<(c-1)\n\n    keys.append(key)\n\n\n\n# [1]の個数で分類する\n\nmaskss = [[] for _ in range(N+1)]\n\nnum1s = [0] * (2**N)\n\nfor S in range(2**N):\n\n    num = bin(S).count('1')\n\n    maskss[num].append(S)\n\n    num1s[S] = num\n\n\n\ndpAll = [INF] * (2**N)\n\nfor S in range(2**N):\n\n    for cost, key in zip(costs, keys):\n\n        if S & key == S:\n\n            if cost < dpAll[S]:\n\n                dpAll[S] = cost\n\n\n\ndp = [INF] * (2**N)\n\nfor S in range(2**N):\n\n    cost = dpAll[S]\n\n    num1 = num1s[S]\n\n    for k in range(1, (num1+1)//2+1):\n\n        for mask in maskss[k]:\n\n            if mask & S == mask:\n\n                m2 = S^mask\n\n                c2 = dp[mask] + dp[m2]\n\n                if c2 < cost:\n\n                    cost = c2\n\n    dp[S] = cost\n\n\n\nif dp[2**N-1] == INF:\n\n    print((-1))\n\nelse:\n\n    print((dp[2**N-1]))\n", "generated_code": "import sys\n\ninput = sys.stdin.readline\n\n\n\ndef solve():\n\n    INF = 10**10\n\n\n\n    N, M = list(map(int, input().split()))\n\n    keys = []\n\n    costs = []\n\n    for _ in range(M):\n\n        a, b = list(map(int, input().split()))\n\n        costs.append(a)\n\n        cs = list(map(int, input().split()))\n\n        key = 0\n\n        for c in cs:\n\n            key |= 1<<(c-1)\n\n        keys.append(key)\n\n\n\n    dp = [INF] * (1<<N)\n\n    dp[0] = 0\n\n    for S in range(1<<N):\n\n        for key, cost in zip(keys, costs):\n\n            S2 = S | key\n\n            c2 = dp[S] + cost\n\n            if c2 < dp[S2]:\n\n                dp[S2] = c2\n\n\n\n    if dp[-1] == INF:\n\n        print((-1))\n\n    else:\n\n        print((dp[-1]))\n\n\n\n\n\nsolve()\n", "score": 1.0, "codebleu": 0.3288440634134301, "crystalbleu": 0.3064642039611672, "codebertscore": 0.85, "codescore": 0.7040684223175049, "surfaceSim": 0.6721108386215964, "abs_surfaceSim_minus_score": 0.3278891613784036}
{"golden_code": "S = int(eval(input()))\n\n\n\ndp = [0] * (S + 1)\n\ndp[0] = 1\n\nM = 10 ** 9 + 7\n\n\n\nfor i in range(1, S + 1):\n\n    num = 0\n\n    for j in range(i - 2):\n\n        num += dp[j]\n\n        dp[i] = num % M\n\n\n\nprint((dp[S]))\n\n\n", "generated_code": "S = int(eval(input()))\n\n\n\n\n\ndef cmb(n, r, p):\n\n    r = min(n - r, r)\n\n    if r == 0:\n\n        return 1\n\n    over = 1\n\n    for i in range(n, n - r, -1):\n\n        over = over * i % p\n\n    under = 1\n\n    for i in range(1, r + 1):\n\n        under = under * i % p\n\n    inv = pow(under, p - 2, p)\n\n    return over * inv % p\n\n\n\n\n\nM = 10 ** 9 + 7\n\nans = 0\n\nfor i in range(1, S):\n\n    if S - 3 * i < 0:\n\n        break\n\n    ans += cmb(S - 3 * i + i - 1, i - 1, M)\n\n    ans %= M\n\nprint(ans)\n", "score": 1.0, "codebleu": 0.3575171735449353, "crystalbleu": 0.1806566732713135, "codebertscore": 0.81, "codescore": 0.9877598881721497, "surfaceSim": 0.5537230340988171, "abs_surfaceSim_minus_score": 0.44627696590118293}
{"golden_code": "from collections import defaultdict\n\n\n\nfrom scipy.misc import comb\n\n\n\nN, M = list(map(int, input().split()))\n\nA = [int(x) for x in input().split()]\n\n\n\nB = [0] * N\n\nB[0] = A[0]\n\nfor i in range(1, N):\n\n    B[i] = B[i - 1] + A[i]\n\nB = [0] + B\n\n\n\nc = defaultdict(int)\n\nfor i in range(N + 1):\n\n    c[B[i] % M] += 1\n\n\n\nans = 0\n\nfor k, v in list(c.items()):\n\n    if v >= 2:\n\n        ans += comb(v, 2, exact=True)\n\nprint(ans)", "generated_code": "from collections import defaultdict\n\n\n\nN, M = list(map(int, input().split()))\n\nA = [int(x) for x in input().split()]\n\n\n\nB = [0] * N\n\nB[0] = A[0]\n\nfor i in range(1, N):\n\n    B[i] = B[i - 1] + A[i]\n\nB = [0] + B\n\n\n\nc = defaultdict(int)\n\nfor i in range(N + 1):\n\n    c[B[i] % M] += 1\n\n\n\nans = 0\n\nfor k, v in list(c.items()):\n\n    if v >= 2:\n\n        ans += v * (v - 1) // 2\n\nprint(ans)", "score": 1.0, "codebleu": 0.7321857575690038, "crystalbleu": 0.8269586672435174, "codebertscore": 0.97, "codescore": 0.7892976403236389, "surfaceSim": 0.9139584883817085, "abs_surfaceSim_minus_score": 0.08604151161829154}
{"golden_code": "import numpy as np\n\n\n\nN, M = [int(x) for x in input().split()]\n\nL = [[int (y) for y in input().split()] for _ in range(M)]\n\nL = sum(L, [])\n\n\n\nfor i in np.arange(1, N+1):\n\n    print((L.count(i)))", "generated_code": "N, M = [int(x) for x in input().split()]\n\nL = [[int (y) for y in input().split()] for _ in range(M)]\n\nL = sum(L, [])\n\n\n\nfor i in range(1, N+1):\n\n    print((L.count(i)))", "score": 1.0, "codebleu": 0.7203254785898876, "crystalbleu": 0.8601799609084799, "codebertscore": 0.95, "codescore": 0.7413896918296814, "surfaceSim": 0.8928980526918671, "abs_surfaceSim_minus_score": 0.10710194730813294}
{"golden_code": "from statistics import mean\n\n\n\ninputCount = int(eval(input()))\n\nprices = [int(eval(input())) for lp in range(inputCount)]\n\naverage = mean(prices)\n\nprint((int(average)))\n\n\n", "generated_code": "inputCount = int(eval(input()))\n\nprices = [int(eval(input())) for lp in range(inputCount)]\n\naverage = sum(prices) // inputCount\n\nprint(average)\n\n\n", "score": 1.0, "codebleu": 0.607107434864954, "crystalbleu": 0.0, "codebertscore": 0.94, "codescore": 0.09041574597358704, "surfaceSim": 0.7204228520017993, "abs_surfaceSim_minus_score": 0.27957714799820066}
{"golden_code": "import sys, re\n\nfrom collections import deque, defaultdict, Counter\n\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, tan, asin, acos, atan, radians, degrees#, log2, log\n\nfrom itertools import accumulate, permutations, combinations, combinations_with_replacement, product, groupby\n\nfrom operator import itemgetter, mul\n\nfrom copy import deepcopy\n\nfrom string import ascii_lowercase, ascii_uppercase, digits\n\nfrom bisect import bisect, bisect_left, insort, insort_left\n\nfrom fractions import gcd\n\nfrom heapq import heappush, heappop\n\nfrom functools import reduce\n\nfrom decimal import Decimal\n\ndef input(): return sys.stdin.readline().strip()\n\ndef INT(): return int(eval(input()))\n\ndef MAP(): return list(map(int, input().split()))\n\ndef LIST(): return list(map(int, input().split()))\n\ndef ZIP(n): return list(zip(*(MAP() for _ in range(n))))\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = float('inf')\n\nmod = 10**9 + 7\n\nfrom decimal import *\n\n\n\nN = INT()\n\nxy = []\n\n\n\nfor i in range(N):\n\n\tA = INT()\n\n\txy.append([LIST() for _ in range(A)])\n\n\n\nans = 0\n\nfor i in range(1<<N):\n\n\ti = list(\"{:b}\".format(i).zfill(N))\n\n\tfor j in range(N):\n\n\t\tif i[j] == \"1\":\n\n\t\t\tfor x, y in xy[j]:\n\n\t\t\t\tif y != int(i[x-1]):\n\n\t\t\t\t\tbreak\n\n\t\t\telse:\n\n\t\t\t\tcontinue\n\n\t\t\tbreak\n\n\telse:\n\n\t\ttmp = sum([int(x) for x in i])\n\n\t\tans = max(ans, tmp)\n\nprint(ans)\n", "generated_code": "import sys, re\n\nfrom collections import deque, defaultdict, Counter\n\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, tan, asin, acos, atan, radians, degrees#, log2, log\n\nfrom itertools import accumulate, permutations, combinations, combinations_with_replacement, product, groupby\n\nfrom operator import itemgetter, mul\n\nfrom copy import deepcopy\n\nfrom string import ascii_lowercase, ascii_uppercase, digits\n\nfrom bisect import bisect, bisect_left, insort, insort_left\n\nfrom fractions import gcd\n\nfrom heapq import heappush, heappop\n\nfrom functools import reduce\n\nfrom decimal import Decimal\n\ndef input(): return sys.stdin.readline().strip()\n\ndef INT(): return int(eval(input()))\n\ndef MAP(): return list(map(int, input().split()))\n\ndef LIST(): return list(map(int, input().split()))\n\ndef ZIP(n): return list(zip(*(MAP() for _ in range(n))))\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = float('inf')\n\nmod = 10**9 + 7\n\nfrom decimal import *\n\n\n\nN = INT()\n\nxy = []\n\n\n\nfor i in range(N):\n\n\tA = INT()\n\n\txy.append([LIST() for _ in range(A)])\n\n\n\nans = 0\n\nfor X in product((0, 1), repeat=N):\n\n\tfor j in range(N):\n\n\t\tif X[j] == 1:\n\n\t\t\tfor x, y in xy[j]:\n\n\t\t\t\tif X[x-1] != y:\n\n\t\t\t\t\tbreak\n\n\t\t\telse:\n\n\t\t\t\tcontinue\n\n\t\t\tbreak\n\n\telse:\n\n\t\tans = max(ans, sum(X))\n\n\n\nprint(ans)", "score": 1.0, "codebleu": 0.7573185521421449, "crystalbleu": 0.8236876381585133, "codebertscore": 0.98, "codescore": 0.41339218616485596, "surfaceSim": 0.9408732750877766, "abs_surfaceSim_minus_score": 0.05912672491222337}
{"golden_code": "import sys\n\nsys.setrecursionlimit(10000000)\n\n\n\n#const\n\ndxdy=((1,0),(0,1))\n\n#my functions here!\n\ndef pin(type=int):\n\n    return list(map(type,input().rstrip().split()))\n\n\n\n\n\n#your code here!\n\ndef resolve():\n\n    S=eval(input())\n\n    ans=0\n\n    \n\n    hidari=0\n\n    for i,c in enumerate(S):\n\n        if c==\"W\":\n\n            ans+=i-hidari\n\n            hidari+=1\n\n    print(ans)\n\n\n\nimport sys\n\nfrom io import StringIO\n\nimport unittest\n\n\n\n\n\nclass TestClass(unittest.TestCase):\n\n    def assertIO(self, input, output):\n\n        stdout, stdin = sys.stdout, sys.stdin\n\n        sys.stdout, sys.stdin = StringIO(), StringIO(input)\n\n        resolve()\n\n        sys.stdout.seek(0)\n\n        out = sys.stdout.read()[:-1]\n\n        sys.stdout, sys.stdin = stdout, stdin\n\n        self.assertEqual(out, output)\n\n\n\n    def test_入力例_1(self):\n\n        input = \"\"\"BBW\"\"\"\n\n        output = \"\"\"2\"\"\"\n\n        self.assertIO(input, output)\n\n\n\n    def test_入力例_2(self):\n\n        input = \"\"\"BWBWBW\"\"\"\n\n        output = \"\"\"6\"\"\"\n\n        self.assertIO(input, output)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    #unittest.main()\n\n\n\n\n\n    resolve()#and submit 2 atcoder!\n\n\n", "generated_code": "import sys\n\ninput= lambda: sys.stdin.readline().rstrip()\n\ndef pin(type=int):\n\n    return list(map(type,input().split()))\n\n\n\n#%%code\n\n\n\ndef resolve():\n\n    \n\n    S=eval(input())\n\n    index=0\n\n    ans=0\n\n    for i in range(len(S)):\n\n        if S[i]==\"W\":\n\n            ans+=i-index\n\n            index+=1\n\n    print(ans)\n\n#%%submit!\n\nresolve()", "score": 1.0, "codebleu": 0.17057181028346852, "crystalbleu": 0.12371835952235022, "codebertscore": 0.77, "codescore": 0.8013305068016052, "surfaceSim": 0.6170353982300885, "abs_surfaceSim_minus_score": 0.38296460176991154}
{"golden_code": "# -*- coding: utf-8 -*-\n\n\"\"\"\n\nCreated on Sat May 25 21:24:29 2019\n\n\n\n@author: Yamazaki Kenichi\n\n\"\"\"\n\n\n\nN, M, K = list(map(int,input().split()))\n\nmod = 10**9+7\n\n\n\ndef cmb(n, r, mod):\n\n    if (r < 0 or r > n):\n\n        return 0\n\n    r = min(r, n-r)\n\n    return g1[n] * g2[r] * g2[n-r] % mod\n\n\n\ng1 = [1, 1] # 元テーブル\n\ng2 = [1, 1] # 逆元テーブル\n\ninv = [0, 1] # 逆元テーブル計算用テーブル\n\n\n\nfor i in range(2, N*M+1):\n\n    g1.append((g1[-1] * i) % mod)\n\n    inv.append((-inv[mod % i] * (mod//i)) % mod)\n\n    g2.append((g2[-1] * inv[-1]) % mod)\n\n\n\ndef a(N,M):\n\n    return N*(N+1)//2*(M+1) + M*(M+1)//2*(N+1)\n\ndef b(N):\n\n    return N*(N+1)//2\n\n\n\nans = 0\n\nfor i in range(N):\n\n    for j in range(M):\n\n        ans += a(i,j) + a(N-i-1,j) + a(i,M-j-1) + a(N-i-1,M-j-1)\n\n        ans -= b(i) + b(j) + b(N-i-1) + b(M-j-1)\n\n        ans %= mod\n\n#        print(i,j,a(i,j),a(N-i-1,j),a(i,M-j-1),a(N-i-1,M-j-1),b(i),b(j),ans)\n\nans *= g2[2]\n\n\n\nans *= cmb(N*M-2,K-2,mod)\n\nans %= mod\n\n\n\nprint(ans)\n", "generated_code": "# -*- coding: utf-8 -*-\n\n\"\"\"\n\nCreated on Wed May 29 22:49:19 2019\n\n\n\n@author: Yamazaki Kenichi\n\n\"\"\"\n\n\n\n# -*- coding: utf-8 -*-\n\n\"\"\"\n\nCreated on Sat May 25 21:24:29 2019\n\n\n\n@author: Yamazaki Kenichi\n\n\"\"\"\n\n\n\nN, M, K = list(map(int,input().split()))\n\nmod = 10**9+7\n\n\n\ndef cmb(n, r, mod):\n\n    if (r < 0 or r > n):\n\n        return 0\n\n    r = min(r, n-r)\n\n    return g1[n] * g2[r] * g2[n-r] % mod\n\n\n\ng1 = [1, 1] # 元テーブル\n\ng2 = [1, 1] # 逆元テーブル\n\ninv = [0, 1] # 逆元テーブル計算用テーブル\n\n\n\nfor i in range(2, N*M+1):\n\n    g1.append((g1[-1] * i) % mod)\n\n    inv.append((-inv[mod % i] * (mod//i)) % mod)\n\n    g2.append((g2[-1] * inv[-1]) % mod)\n\n\n\nans1 = 0\n\ndef c(N,M):\n\n    res = 0\n\n    for i in range(1,N):\n\n        res += i*(N-i)*M*M\n\n    return res\n\nans1 += c(N,M) + c(M,N)\n\nans1 %= mod\n\n\n\nans1 *= cmb(N*M-2,K-2,mod)\n\nans1 %= mod\n\n\n\nprint(ans1)\n", "score": 1.0, "codebleu": 0.6910088932970917, "crystalbleu": 0.5292356284296632, "codebertscore": 0.91, "codescore": 0.9856470227241516, "surfaceSim": 0.881675392670157, "abs_surfaceSim_minus_score": 0.11832460732984296}
{"golden_code": "def main():\n\n    from statistics import median\n\n\n\n    n, *a, = list(map(int, open(0).read().split()))\n\n    a = [x - i for i, x in enumerate(a, 1)]\n\n    a.sort()\n\n    m = int(median(a))\n\n\n\n    ans = sum([abs(x - m) for x in a])\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "generated_code": "def main():\n\n    n, *a, = list(map(int, open(0).read().split()))\n\n    a = [x - i for i, x in enumerate(a, 1)]\n\n    a.sort()\n\n    if n % 2 == 0:\n\n        ans = sum(a[n // 2:]) - sum(a[:n // 2])\n\n    else:\n\n        ans = sum(a[n // 2 + 1:]) - sum(a[:n // 2])\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 1.0, "codebleu": 0.5043908947580552, "crystalbleu": 0.627499892340081, "codebertscore": 0.89, "codescore": 0.01862676441669464, "surfaceSim": 0.7331463956069634, "abs_surfaceSim_minus_score": 0.2668536043930366}
{"golden_code": "from fractions import gcd\n\n\n\nn,m=list(map(int,input().split()))\n\na=list(map(int,input().split()))\n\na=list(set(a))\n\n\n\na=list([x//2 for x in a])\n\n\n\ndef lcm(q):\n\n  x = q[0]\n\n  for i in range(1, len(q)):\n\n    x = (x * q[i]) // gcd(x, q[i])\n\n  return x\n\n\n\nlcma=lcm(a)\n\n\n\nif (lcma//a[0])%2==0:\n\n  print((0))\n\nelse:\n\n  flg=0\n\n  for i in range(1,len(a)):\n\n    if (lcma//a[i])%2==0:\n\n      print((0))\n\n      flg=1\n\n      break\n\n  if flg==0:\n\n    temp=m//lcma\n\n    print((temp//2 if temp%2==0 else temp//2+1))", "generated_code": "from math import gcd\n\nn,m=list(map(int,input().split()))\n\na=list(map(int,input().split()))\n\na=list(set(a))\n\na=list([x//2 for x in a])\n\n\n\ndef lcm(q):\n\n  x = q[0]\n\n  for i in range(1, len(q)):\n\n    x = (x * q[i]) // gcd(x, q[i])\n\n  return x\n\n\n\nlcma=lcm(a)\n\nfor i in range(len(a)):\n\n  if (lcma//a[i])%2==0:\n\n    print((0))\n\n    exit()\n\ntemp=m//lcma\n\nprint((temp//2 if temp%2==0 else temp//2+1))", "score": 1.0, "codebleu": 0.7667790229313646, "crystalbleu": 0.77239021698609, "codebertscore": 0.96, "codescore": 0.95814049243927, "surfaceSim": 0.9117266791647811, "abs_surfaceSim_minus_score": 0.08827332083521888}
{"golden_code": "l, r=list(map(int, input().split()))\n\nif r-l>672:\n\n\tp=0\n\nelse:\n\n\tp=2019\n\n\tfor i in range(l, r):\n\n\t\tfor j in range(i+1, r+1):\n\n\t\t\tp=min(p, (((i%2019)*(j%2019))%2019))\n\n\t\t\tif not p:\n\n\t\t\t\tbreak\n\n\t\tif not p:\n\n\t\t\tbreak\n\nprint(p)", "generated_code": "l, r=list(map(int, input().split()))\n\nif r-l>672:\n\n\tp=0\n\nelse:\n\n\tp=2019\n\n\tfor i in range(l, r):\n\n\t\tfor j in range(i+1, r+1):\n\n\t\t\tp=min(p, (i*j%2019))\n\n\t\t\tif not p:\n\n\t\t\t\tbreak\n\n\t\tif not p:\n\n\t\t\tbreak\n\nprint(p)", "score": 1.0, "codebleu": 0.8726330193482528, "crystalbleu": 0.8526724299959368, "codebertscore": 0.99, "codescore": 0.9937398433685303, "surfaceSim": 0.9641255605381166, "abs_surfaceSim_minus_score": 0.0358744394618834}
{"golden_code": "n = int(eval(input()))\n\n\n\ncnt = 0\n\nfor i in range(1, n+1):\n\n    i_str = str(i)\n\n    if len(i_str) == 1:\n\n        cnt += 1\n\n        continue\n\n    if len(i_str) == 2:\n\n        if int(i_str[0]) == int(i_str[1]):\n\n            cnt += 3\n\n        elif int(i_str[1]) != 0 and int(i_str[0]) > int(i_str[1]):\n\n            cnt += 2\n\n        continue\n\n    if len(i_str) == 3:\n\n        if int(i_str[0]) == int(i_str[2]):\n\n            cnt += 4 + (2 * (int(i_str[1])+1) - 1)\n\n        elif int(i_str[2]) != 0 and int(i_str[0]) > int(i_str[2]):\n\n            cnt += 22\n\n        elif int(i_str[0]) < int(i_str[2]):\n\n            cnt += 2\n\n        continue\n\n    if len(i_str) == 4:\n\n        if int(i_str[0]) == int(i_str[3]):\n\n            cnt += 24 + 20 * int(i_str[1]) + 2 * (int(i_str[2])+1) - 1\n\n        elif int(i_str[3]) != 0 and int(i_str[0]) > int(i_str[3]):\n\n            cnt += 222\n\n        elif int(i_str[0]) < int(i_str[3]):\n\n            cnt += 22\n\n        continue\n\n    if len(i_str) == 5:\n\n        if int(i_str[0]) == int(i_str[4]):\n\n            cnt += 224 + 200 * int(i_str[1]) + 20 * int(i_str[2]) + 2 * (int(i_str[3])+1) - 1\n\n        elif int(i_str[4]) != 0 and int(i_str[0]) > int(i_str[4]):\n\n            cnt += 2222\n\n        elif int(i_str[0]) < int(i_str[4]):\n\n            cnt += 222\n\n        continue\n\n    if len(i_str) == 6:\n\n        if int(i_str[0]) == int(i_str[5]):\n\n            cnt += 2224 + 2000 * int(i_str[1]) + 200 * int(i_str[2]) + 20 * int(i_str[3]) + 2 * (int(i_str[4])+1) - 1\n\n        elif int(i_str[5]) != 0 and int(i_str[0]) > int(i_str[5]):\n\n            cnt += 22222\n\n        elif int(i_str[0]) < int(i_str[5]):\n\n            cnt += 2222\n\n        continue\n\n\n\nprint(cnt)", "generated_code": "n = int(eval(input()))\n\n\n\nc = [[0 for _ in range(10)] for __ in range(10)]\n\nfor i in range(1, n+1):\n\n    str_i = str(i)\n\n    head = int(str_i[0])\n\n    tail = int(str_i[-1])\n\n    c[head][tail] += 1\n\n\n\ncnt = 0\n\nfor i in range(10):\n\n    for j in range(10):\n\n        cnt += c[i][j] * c[j][i]\n\n\n\nprint(cnt)", "score": 1.0, "codebleu": 0.1642108521285065, "crystalbleu": 0.006336518982264703, "codebertscore": 0.77, "codescore": 0.9205753207206726, "surfaceSim": 0.4827586206896552, "abs_surfaceSim_minus_score": 0.5172413793103448}
{"golden_code": "import sys\n\ninput = sys.stdin.readline\n\n\n\nn,k = list(map(int, input().split()))\n\nAs = [int(eval(input())) for i in range(n)]\n\n\n\n# N: 処理する区間の長さ\n\n\n\nINF = 0\n\n\n\nmx = 300001\n\nLV = (mx-1).bit_length()\n\nN0 = 2**LV\n\ndata = [INF]*(2*N0)\n\nlazy = [None]*(2*N0)\n\n\n\n# 伝搬対象の区間を求める\n\ndef gindex(l, r):\n\n    L = (l + N0) >> 1; R = (r + N0) >> 1\n\n    lc = 0 if l & 1 else (L & -L).bit_length()\n\n    rc = 0 if r & 1 else (R & -R).bit_length()\n\n    for i in range(LV):\n\n        if rc <= i:\n\n            yield R\n\n        if L < R and lc <= i:\n\n            yield L\n\n        L >>= 1; R >>= 1\n\n\n\n# 遅延伝搬処理\n\ndef propagates(*ids):\n\n    for i in reversed(ids):\n\n        v = lazy[i-1]\n\n        if v is None:\n\n            continue\n\n        lazy[2*i-1] = data[2*i-1] = lazy[2*i] = data[2*i] = v\n\n        lazy[i-1] = None\n\n\n\n# 区間[l, r)をxで更新\n\ndef update(l, r, x):\n\n    *ids, = gindex(l, r)\n\n    propagates(*ids)\n\n\n\n    L = N0 + l; R = N0 + r\n\n    while L < R:\n\n        if R & 1:\n\n            R -= 1\n\n            lazy[R-1] = data[R-1] = x\n\n        if L & 1:\n\n            lazy[L-1] = data[L-1] = x\n\n            L += 1\n\n        L >>= 1; R >>= 1\n\n    for i in ids:\n\n        data[i-1] = max(data[2*i-1], data[2*i])\n\n\n\n# 区間[l, r)内の最小値を求める\n\ndef query(l, r):\n\n    propagates(*gindex(l, r))\n\n    L = N0 + l; R = N0 + r\n\n\n\n    s = INF\n\n    while L < R:\n\n        if R & 1:\n\n            R -= 1\n\n            s = max(s, data[R-1])\n\n        if L & 1:\n\n            s = max(s, data[L-1])\n\n            L += 1\n\n        L >>= 1; R >>= 1\n\n    return s\n\n\n\nans = 0\n\nupdate(As[0],As[0]+1,1)\n\nfor i, a in enumerate(As[1:]):\n\n    l = max(0,a-k)\n\n    r = min(mx,a+k)\n\n    upd = query(l,r+1)\n\n    if upd == -1:continue\n\n    # print(\"i\",i,\"a\",a,\"upd\",upd,\"l\",l,\"r\",r)\n\n    update(a, a+1, upd+1)\n\n    ans = max(ans, upd+1)\n\nprint(ans)\n\n\n", "generated_code": "# セグメント木\n\n# segment tree\n\nimport sys\n\ninput = sys.stdin.readline\n\n\n\nclass segmented_tree:\n\n    X_unit = 0\n\n    X_f = lambda self, a, b: max(a,b)\n\n    def __init__(self, N):\n\n        self.N = N\n\n        self.X = [self.X_unit] * (2*N)\n\n        \n\n    def build(self, seq):\n\n        for i, x in enumerate(seq, self.N):\n\n            self.X[i] = x \n\n        # 後ろから入れていく\n\n        for i in range(self.N-1, 0, -1):\n\n            self.X[i] = self.X_f(self.X[i<<1], self.X[i<<1|1])\n\n\n\n    # 1点更新\n\n    def set_val(self, i, x):\n\n        i += self.N\n\n        self.X[i] = x\n\n        while i > 1:\n\n            i >>= 1\n\n            self.X[i] = self.X_f(self.X[i<<1],self.X[i<<1|1])\n\n    \n\n    # 区間取得\n\n    def fold(self, l, r):\n\n        l += self.N\n\n        r += self.N\n\n        vl = self.X_unit\n\n        vr = self.X_unit\n\n        # 外から決めていく\n\n        while l < r:\n\n            # print(l,r)\n\n            if l & 1:\n\n                vl = self.X_f(vl, self.X[l])\n\n                l += 1\n\n            if r & 1:\n\n                r -= 1\n\n                vr = self.X_f(vr, self.X[r])\n\n            l >>= 1\n\n            r >>= 1\n\n        return self.X_f(vl,vr)\n\n\n\nn,k = list(map(int, input().split()))\n\nAs = [int(eval(input())) for i in range(n)]\n\nmx = 300001\n\nans = 0\n\nsg = segmented_tree(330000)\n\n\n\nfor a in As:\n\n    l = max(0,a-k)\n\n    r = min(mx,a+k)\n\n\n\n    upd = sg.fold(l,r+1)\n\n    ans = max(ans, upd+1)\n\n\n\n    sg.set_val(a, upd+1)\n\nprint(ans)\n\n\n", "score": 1.0, "codebleu": 0.22988305887602573, "crystalbleu": 0.24338612659573675, "codebertscore": 0.79, "codescore": 0.9931260347366333, "surfaceSim": 0.6328779538873046, "abs_surfaceSim_minus_score": 0.3671220461126954}
{"golden_code": "while 1:\n\n n,x=list(map(int,input().split()))\n\n if n+x==0:break\n\n print((len([1 for i in range(3,n+1)for j in range(2,x-i)if x-i-j<j<i])))", "generated_code": "while 1:\n\n n,x=list(map(int,input().split()))\n\n if n+x==0:break\n\n print((len([1 for i in range(1,n-1)for j in range(i+1,n)if j<x-i-j<=n])))", "score": 1.0, "codebleu": 0.6555341323424959, "crystalbleu": 0.0, "codebertscore": 0.96, "codescore": 0.02430276945233345, "surfaceSim": 0.9341072596468281, "abs_surfaceSim_minus_score": 0.06589274035317194}
{"golden_code": "A,B,C,X,Y = list(map(int,input().split()))\n\nl = []\n\nfor i in range(max(X,Y)+1):\n\n    T = i * C * 2\n\n    if i < X: \n\n        T += (X-i)*A\n\n    if i < Y:\n\n        T += (Y-i)*B\n\n    l.append(T)\n\nl.sort()\n\nprint((l[0]))", "generated_code": "A,B,C,X,Y = list(map(int,input().split()))\n\nans = 0\n\nif 2*C <= A+B:\n\n    Z = min(X,Y)\n\n    ans = 2*C*Z\n\n    X -= Z\n\n    Y -= Z\n\nans += min(2*C*X,A*X)\n\nans += min(2*C*Y,B*Y)\n\nprint(ans)", "score": 1.0, "codebleu": 0.240291100090611, "crystalbleu": 0.3911449759496443, "codebertscore": 0.83, "codescore": 0.4166127145290375, "surfaceSim": 0.6765419615773508, "abs_surfaceSim_minus_score": 0.3234580384226492}
{"golden_code": "A,B = list(map(int,input().split()))\n\n\n\n\n\ndef kaibun(n):\n\n\tkey = 0\n\n\tfor i in range(1,n+1):\n\n\t\tif str(i) == str(i)[::-1]:\n\n\t\t\tkey += 1\n\n\treturn key\n\n\n\nprint((kaibun(B)-kaibun(A-1)))", "generated_code": "A,B = list(map(int,input().split()))\n\n\n\n\n\ndef kaibun(m, n):\n\n\tkey = 0\n\n\tfor i in range(m,n+1):\n\n\t\tif str(i) == str(i)[::-1]:\n\n\t\t\tkey += 1\n\n\treturn key\n\n\n\nprint((kaibun(A,B)))", "score": 1.0, "codebleu": 0.6762767030820076, "crystalbleu": 0.0, "codebertscore": 0.97, "codescore": 0.4447327256202698, "surfaceSim": 0.939332766680833, "abs_surfaceSim_minus_score": 0.06066723331916701}
{"golden_code": "n,m,k=list(map(int,input().split()))\n\nmod=10**9+7\n\nf=[1]\n\nfor i in range(2*10**5+7):f+=[f[-1]*(i+1)%mod]\n\ndef comb(a,b):return f[a]*pow(f[b],mod-2,mod)*pow(f[a-b],mod-2,mod)%mod\n\nans=0\n\nfor i in range(1,n):\n\n  ans+=(i*(n-i)*m**2)*(comb(n*m-2,k-2))\n\n  ans%=mod\n\nfor i in range(1,m):\n\n  ans+=(i*(m-i)*n**2)*(comb(n*m-2,k-2))\n\n  ans%=mod\n\nprint(ans)", "generated_code": "n,m,k=list(map(int,input().split()))\n\n\n\nmod = 10**9+7\n\nf = [1]\n\nfor i in range(n*m):\n\n  f += [f[-1]*(i+1) % mod]\n\ndef comb(a, b):\n\n  return f[a]*pow(f[b], mod-2, mod)*pow(f[a-b], mod-2, mod) % mod\n\n\n\nans=0\n\nfor dist in range(1,n):\n\n  c=n-dist\n\n  p=(c*m*m)%mod\n\n  ans+=p*dist\n\nfor dist in range(1,m):\n\n  c=m-dist\n\n  p=(c*n*n)%mod\n\n  ans+=p*dist\n\nans%=mod\n\nprint((ans*comb(n*m-2,k-2)%mod))", "score": 1.0, "codebleu": 0.3629923337355096, "crystalbleu": 0.6369429828703653, "codebertscore": 0.93, "codescore": 0.6853729486465454, "surfaceSim": 0.8656330749354005, "abs_surfaceSim_minus_score": 0.13436692506459946}
{"golden_code": "import sys\n\n\n\ninput = sys.stdin.readline\n\n\n\ndef main():\n\n    ans = 0\n\n    n = int(input())\n\n    o = list(map(int, input().split()))\n\n    l = [0]*n\n\n    for i in range(n):\n\n        l[o[i]-1] = i+1\n\n    for i in range(len(l)):\n\n        if  i != len(l)-1:\n\n            print(\"{} \".format(l[i]), end='')\n\n        else:\n\n            print(l[i])\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "generated_code": "import sys\n\n\n\ninput = sys.stdin.readline\n\n\n\ndef main():\n\n    ans = 0\n\n    n = int(eval(input()))\n\n    o = list(map(int, input().split()))\n\n    l = [0]*n\n\n    for i in range(n):\n\n        l[o[i]-1] = i+1\n\n    print((\" \".join(map(str,l))))\n\nif __name__ == '__main__':\n\n    main()", "score": 1.0, "codebleu": 0.5746027634535364, "crystalbleu": 0.5953190229481397, "codebertscore": 0.95, "codescore": 0.9623745679855347, "surfaceSim": 0.8620620217478856, "abs_surfaceSim_minus_score": 0.1379379782521144}
{"golden_code": "A,B,C,X,Y=list(map(int,input().split()))\n\n\n\nK=10**9\n\nfor i in range(10**5+1):\n\n    S=i*2*C+max(0,X-i)*A+max(0,Y-i)*B\n\n    K=min(K,S)\n\nprint(K)", "generated_code": "A,B,C,X,Y=list(map(int,input().split()))\n\n\n\na=min(X,Y)*min(A+B,2*C)\n\n\n\na+=max(0,X-Y)*min(A,2*C)\n\na+=max(0,Y-X)*min(B,2*C)\n\n\n\n\n\nprint(a)", "score": 1.0, "codebleu": 0.28000529861426593, "crystalbleu": 0.5309289436354834, "codebertscore": 0.85, "codescore": 0.10631226003170013, "surfaceSim": 0.7251449875724938, "abs_surfaceSim_minus_score": 0.2748550124275062}
{"golden_code": "class SegmentTree:\n\n    seg_len = 1\n\n    node = []\n\n    def __init__(self, n):\n\n        while self.seg_len < n:\n\n            self.seg_len <<= 1\n\n        self.node = [ 0 for _ in range(self.seg_len*2) ]\n\n\n\n    def add(self, idx, v):\n\n        idx += self.seg_len\n\n        self.node[idx] += v\n\n        while True:\n\n            idx //= 2\n\n            if idx == 0:\n\n                break\n\n            self.node[idx] = self.node[idx*2] + self.node[idx*2+1]\n\n\n\n    def sum(self, l, r):\n\n        l += self.seg_len\n\n        r += self.seg_len\n\n        ret = 0\n\n        while l < r:\n\n            if l & 1 == 1:\n\n                ret += self.node[l]\n\n                l += 1\n\n            if r & 1 == 1:\n\n                ret += self.node[r-1]\n\n                r -= 1\n\n            l //= 2; r //= 2;\n\n        return ret\n\n\n\n\n\nn, k = list(map(int, input().split()))\n\np = [ int(x) for x in input().split() ]\n\n\n\nseg_tree = SegmentTree(n)\n\nfor i in range(n):\n\n    seg_tree.add(i, (1+p[i])/2)\n\n\n\nans = 0\n\nfor i in range(n-k+1):\n\n    ans = max(ans, seg_tree.sum(i, i+k))\n\n\n\nprint(ans)\n", "generated_code": "class SegmentTree:\n\n    seg_len = 1\n\n    node = []\n\n    def __init__(self, n):\n\n        while self.seg_len < n:\n\n            self.seg_len <<= 1\n\n        self.node = [ 0 for _ in range(self.seg_len*2) ]\n\n\n\n    def add(self, idx, v):\n\n        idx += self.seg_len\n\n        self.node[idx] += v\n\n        while True:\n\n            idx >>= 1\n\n            if idx == 0:\n\n                break\n\n            self.node[idx] = self.node[idx*2] + self.node[idx*2+1]\n\n\n\n    def sum(self, l, r):\n\n        l += self.seg_len\n\n        r += self.seg_len\n\n        ret = 0\n\n        while l < r:\n\n            if l & 1 == 1:\n\n                ret += self.node[l]\n\n                l += 1\n\n            if r & 1 == 1:\n\n                ret += self.node[r-1]\n\n                r -= 1\n\n            l >>= 1; r >>= 1;\n\n        return ret\n\n\n\n\n\nn, k = list(map(int, input().split()))\n\np = [ int(x) for x in input().split() ]\n\n\n\nseg_tree = SegmentTree(n)\n\nfor i in range(n):\n\n    seg_tree.add(i, (1+p[i])/2)\n\n\n\nans = 0\n\nfor i in range(n-k+1):\n\n    ans = max(ans, seg_tree.sum(i, i+k))\n\n\n\nprint(ans)\n", "score": 1.0, "codebleu": 0.9518794997963271, "crystalbleu": 0.9366687466080638, "codebertscore": 1.0, "codescore": 0.9935217499732971, "surfaceSim": 0.9687316911633594, "abs_surfaceSim_minus_score": 0.03126830883664056}
{"golden_code": "import sys\n\ndef input(): return sys.stdin.readline().rstrip()\n\ndef main():\n\n    x=int(eval(input()))\n\n    for i in range(-300,300):\n\n        for j in range(-300,300):\n\n            if i**5-j**5==x:\n\n                print((i,j))\n\n                sys.exit()\n\n\n\nif __name__=='__main__':\n\n    main()", "generated_code": "import sys\n\ndef input(): return sys.stdin.readline().rstrip()\n\ndef main():\n\n    x=int(eval(input()))\n\n    for a in range(-118,120):\n\n        for diff in range(238):\n\n            if a**5-(a-diff)**5>10**9:\n\n                break\n\n            if a**5-(a-diff)**5==x:\n\n                print((a,a-diff))\n\n                sys.exit()\n\n\n\nif __name__=='__main__':\n\n    main()", "score": 1.0, "codebleu": 0.5992785572757102, "crystalbleu": 0.5605509036053881, "codebertscore": 0.9, "codescore": 0.044257454574108124, "surfaceSim": 0.8797945923286523, "abs_surfaceSim_minus_score": 0.12020540767134769}
{"golden_code": "import numpy as np\n\n\n\nh, w = tuple(map(int, input().split()))\n\nmatrix = np.zeros((h, w), dtype=bool)\n\nfor i in range(h):\n\n    row = np.array(list(input()))\n\n    matrix[i, :] = row == \".\"\n\n\n\nfor i in range(h)[::-1]:\n\n    if np.all(matrix[i, :]):\n\n        matrix = np.delete(matrix, i, 0)\n\n\n\nfor i in range(w)[::-1]:\n\n    if np.all(matrix[:, i]):\n\n        matrix = np.delete(matrix, i, 1)\n\n\n\nmatrix = np.where(matrix, \".\", \"#\")\n\nfor row in matrix:\n\n    for e in row:\n\n        print(e, end=\"\")\n\n    print()\n", "generated_code": "# h wの読み込み\n\nh, w = list(map(int, input().split()))\n\n# 行列作成\n\nmat = [eval(input()) for _ in range(h)]\n\n\n\n# #が含まれていない行を削除\n\n[mat.remove(row) for row in mat[::-1] if (\"#\" not in row)]\n\n# #が含まれている列のインデックスを取得\n\nshowCol = [i for i in range(w) if \"#\" in [row[i] for row in mat]]\n\n\n\n# 表示\n\nprint((\"\\n\".join([\"\".join([row[c] for c in showCol]) for row in mat])))\n", "score": 1.0, "codebleu": 0.1660572143512553, "crystalbleu": 0.15459603599980595, "codebertscore": 0.74, "codescore": 0.1272967904806137, "surfaceSim": 0.5383597883597884, "abs_surfaceSim_minus_score": 0.46164021164021163}
{"golden_code": "print((sum(si != ti for si, ti in zip(eval(input()), eval(input())))))\n", "generated_code": "print((sum(a!=b for a,b in zip(*open(0)))))", "score": 1.0, "codebleu": 0.18016002888564955, "crystalbleu": 0.0, "codebertscore": 0.85, "codescore": 0.8047320246696472, "surfaceSim": 0.7118093174431203, "abs_surfaceSim_minus_score": 0.28819068255687974}
{"golden_code": "N = int(eval(input()))\n\n\n\n\n\ndef dist(i, j):\n\n    return i + j - 2\n\n\n\n\n\nmin = 10 ** 24\n\ni = 1\n\nwhile (i ** 2) <= N:\n\n    if 0 == N % i:\n\n        j = N // i\n\n        d = dist(i, j)\n\n        if min > d:\n\n            min = d\n\n    i += 1\n\nprint(d)\n", "generated_code": "import math\n\nn = int(eval(input()))\n\n\n\nans = 0\n\nfor i in range(math.ceil(math.sqrt(n) + 1))[:0:-1]:\n\n    if 0 == n % i:\n\n        ans = i\n\n        break\n\nans_partner = n // ans\n\nprint((ans + ans_partner - 2))\n", "score": 1.0, "codebleu": 0.19368205363963475, "crystalbleu": 0.0, "codebertscore": 0.78, "codescore": 0.874176025390625, "surfaceSim": 0.5027838295812153, "abs_surfaceSim_minus_score": 0.49721617041878474}
{"golden_code": "M=998244353\n\nn,m,k=list(map(int,input().split()))\n\na=0\n\nc=1\n\nfor i in range(k+1):\n\n  a+=c*m*pow(m-1,n-i-1,M)\n\n  c=c*(n-i-1)*pow(i+1,M-2,M)%M\n\nprint((a%M))", "generated_code": "M=998244353\n\nn,m,k=list(map(int,input().split()))\n\na,c=0,1\n\nfor i in range(k+1):\n\n  a+=c*m*pow(m-1,n+~i,M)\n\n  c=c*(n+~i)*pow(i+1,-1,M)%M\n\nprint((a%M))", "score": 1.0, "codebleu": 0.5361426195531298, "crystalbleu": 0.0, "codebertscore": 0.97, "codescore": 0.422839879989624, "surfaceSim": 0.8762987012987014, "abs_surfaceSim_minus_score": 0.12370129870129865}
{"golden_code": "import numpy as np\n\n\n\nncity, nlines = list(map(int, input().rstrip(\"\\n\").split()))\n\nmatrix = np.zeros((ncity, ncity), dtype=int)\n\nfor _ in range(nlines):\n\n    l, c = [int(x) - 1 for x in input().rstrip(\"\\n\").split()]\n\n    matrix[l][c] += 1\n\n    matrix[c][l] += 1\n\n\n\nfor list_ in matrix:\n\n    print((sum(list_)))", "generated_code": "n, m = map(int, input().split())\n\nroads = [0] * n\n\n[exec(\"roads[%d] += 1; roads[%d] += 1\" % tuple(map(lambda c: int(c) - 1, input().split()))) for _ in range(m)]\n\nprint(*roads, sep=\"\\n\", end=\"\")\n", "score": 1.0, "codebleu": 0.15267890807688173, "crystalbleu": 0.10184591487898655, "codebertscore": 0.78, "codescore": 0.4202759861946106, "surfaceSim": 0.4515467346712496, "abs_surfaceSim_minus_score": 0.5484532653287504}
{"golden_code": "import sys\n\ns = input()\n\nts = ['']\n\nwhile True:\n\n  nts= []\n\n  for t in ts:\n\n    for w in ['dreamer', 'eraser', 'dream', 'erase']:\n\n      if s == t + w:\n\n        print('YES')\n\n        sys.exit()\n\n      if s.startswith(t + w):\n\n        nts.append(t + w)\n\n  if len(nts) == 0:\n\n    print('NO')\n\n    sys.exit()\n\n  ts = nts\n", "generated_code": "from sys import exit\n\ns = eval(input())\n\nts = ['']\n\nwhile True:\n\n  nts= []\n\n  for t in ts:\n\n    for w in ['dreamer', 'eraser', 'dream', 'erase']:\n\n      tw = t + w\n\n      if s == tw:\n\n        print('YES')\n\n        exit()\n\n      if s.startswith(tw):\n\n        nts.append(tw)\n\n  if len(nts) == 0:\n\n    print('NO')\n\n    exit()\n\n  ts = nts\n", "score": 1.0, "codebleu": 0.5413355107243876, "crystalbleu": 0.7112491134269354, "codebertscore": 0.96, "codescore": 0.9937346577644348, "surfaceSim": 0.8977611940298508, "abs_surfaceSim_minus_score": 0.10223880597014923}
{"golden_code": "import numpy as np\n\nN = int(eval(input()))\n\ndp = [[0, 0, 0] for i in range(N+1)]\n\nfor i in range(1, N+1):\n\n    a, b, c = list(map(int, input().split(' ')))\n\n    dp[i][0] = max(dp[i-1][1], dp[i-1][2]) + a\n\n    dp[i][1] = max(dp[i-1][0], dp[i-1][2]) + b\n\n    dp[i][2] = max(dp[i-1][0], dp[i-1][1]) + c\n\nprint((np.max(dp[-1])))", "generated_code": "N = int(eval(input()))\n\ndp = [[0, 0, 0] for i in range(N+1)]\n\nfor i in range(1, N+1):\n\n    a, b, c = list(map(int, input().split(' ')))\n\n    dp[i][0] = max(dp[i-1][1], dp[i-1][2]) + a\n\n    dp[i][1] = max(dp[i-1][0], dp[i-1][2]) + b\n\n    dp[i][2] = max(dp[i-1][0], dp[i-1][1]) + c\n\nprint((max(dp[-1])))", "score": 1.0, "codebleu": 0.7572312415781933, "crystalbleu": 0.9539170162018228, "codebertscore": 0.98, "codescore": 0.9658122658729553, "surfaceSim": 0.9272007514761138, "abs_surfaceSim_minus_score": 0.0727992485238862}
{"golden_code": "H, W = list(map(int, input().split()))\n\nimport numpy as np\n\nGrid = np.array([[0 if x == '.' else -1 for x in eval(input())] for _ in range(H)],dtype='int64')\n\n\n\ndef solveMase(Grid, start, goal): #bfsで迷路を解き、スタート-ゴール間の最低必要白マス数を返す\n\n    seen = {start}\n\n    V = [start]\n\n    while len(V) != 0: #bfs\n\n        v = V.pop(0)\n\n        if v == goal:\n\n            return Grid[goal]\n\n        #移動先nvをリストにまとめる\n\n        y,x = v\n\n        nV = []\n\n        if x > 0: nV.append((y,x-1))\n\n        if y > 0: nV.append((y-1,x))\n\n        if x < W-1: nV.append((y,x+1))\n\n        if y < H-1: nV.append((y+1,x))\n\n        #bfs\n\n        for nv in nV:\n\n            if Grid[nv] == -1 or nv in seen:\n\n                continue\n\n            Grid[nv] = Grid[v] + 1\n\n            V.append(nv)\n\n            seen.add(nv)\n\n    return 0\n\n\n\nwhite = len(Grid[Grid == 0])-1\n\nnes_white = solveMase(Grid, (0,0), (H-1,W-1))\n\nprint((white-nes_white if nes_white > 0 else -1))", "generated_code": "from collections import deque, Counter\n\n\n\ndef main():\n\n    with open(0) as f:\n\n        H, W = list(map(int, f.readline().split()))\n\n        maze = [list(line) for line in f.readlines()]\n\n\n\n    rank = [[None]*W for _ in range(H)]\n\n    rank[0][0] = 0\n\n    #bfs\n\n    reserved = deque([(0,0)])\n\n    while len(reserved) > 0:\n\n        x, y = reserved.popleft()\n\n        for u,v in [(s,t) for s,t in [(x-1,y), (x+1,y), (x,y-1), (x,y+1)] if 0<=s<H and 0<=t<W]:\n\n            if rank[u][v] is not None:\n\n                continue\n\n            if maze[u][v] == '.':\n\n                rank[u][v] = rank[x][y] + 1\n\n                reserved.append((u,v))\n\n\n\n    if rank[H-1][W-1] is None:\n\n        print((-1))\n\n    else:\n\n        counter = Counter()\n\n        for line in maze:\n\n            counter.update(line)\n\n        print((counter['.'] - rank[H-1][W-1]-1))\n\n\n\nmain()", "score": 1.0, "codebleu": 0.21110138352074045, "crystalbleu": 0.16933118644278344, "codebertscore": 0.75, "codescore": 0.35489100217819214, "surfaceSim": 0.5665521872179292, "abs_surfaceSim_minus_score": 0.4334478127820708}
{"golden_code": "n,m=list(map(int,input().split()))\n\nc=[0]*(n+2)\n\nfor i in range(m):\n\n  l,r=list(map(int,input().split()))\n\n  c[l-1]+=1\n\n  c[r]-=1\n\nfor i in range(1,n+2):\n\n  c[i]=c[i]+c[i-1]\n\nans=0\n\nfor i in range(n+2):\n\n  if c[i]==m:\n\n    ans+=1\n\nprint(ans)", "generated_code": "n,m=list(map(int,input().split()))\n\nl,r=list(map(int,input().split()))\n\nfor i in range(m-1):\n\n  tl,tr=list(map(int,input().split()))\n\n  if l<tl:\n\n    l=tl\n\n  if tr<r:\n\n    r=tr\n\nprint((max(r-l+1,0)))", "score": 1.0, "codebleu": 0.2118312531149506, "crystalbleu": 0.22829217769272614, "codebertscore": 0.87, "codescore": 0.2711767852306366, "surfaceSim": 0.598863431354862, "abs_surfaceSim_minus_score": 0.401136568645138}
{"golden_code": "#                         author:  kagemeka \n\n#                         created: 2019-11-08 14:51:29(JST)\n\n## internal modules\n\nimport sys\n\n# import collections\n\n# import math\n\n# import string\n\n# import bisect\n\n# import re\n\n# import itertools\n\nimport statistics\n\n# import functools\n\n# import operator\n\n## external modules\n\n# import scipy.special   # if use comb function on AtCoder, \n\n# import scipy.misc      # select scipy.misc.comb (old version) \n\n\n\ndef main():\n\n    n, *a = (int(x) for x in sys.stdin.read().split())\n\n    \n\n    for i in range(n):\n\n        a[i] -= (i + 1)\n\n\n\n    if n % 2 != 0:\n\n        b = statistics.median(a)\n\n    else:\n\n        if a.count(statistics.median_high(a)) >= a.count(statistics.median_low(a)):\n\n            b = statistics.median_high(a)\n\n        else:\n\n            b = statistics.median_low(a)\n\n    \n\n    ans = sum([abs(a[i] - b) for i in range(n)])\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    # execute only if run as a script\n\n    main()\n\n\n\n\n", "generated_code": "import sys\n\n\n\nn, *a = list(map(int, sys.stdin.read().split()))\n\n\n\ndef main():\n\n    for i in range(n):\n\n        a[i] -= (i + 1)\n\n    a.sort()\n\n    b = a[n // 2]\n\n    res = 0\n\n    for i in range(n):\n\n        res += abs(a[i] - b)\n\n    \n\n    return res\n\n    \n\nif __name__ == '__main__':\n\n    ans = main()\n\n    print(ans)", "score": 1.0, "codebleu": 0.2878900710030735, "crystalbleu": 0.2880074381064377, "codebertscore": 0.75, "codescore": 0.018860172480344772, "surfaceSim": 0.7541678179976052, "abs_surfaceSim_minus_score": 0.24583218200239476}
{"golden_code": "import statistics\n\nN = int(eval(input()))\n\nA = [int(a)-i-1 for i,a in enumerate(input().split(),1)]\n\nb = statistics.median_low(A)\n\nc = statistics.median_high(A)\n\nd = sum([abs(x-b) for x in A])\n\ne = sum([abs(x-c) for x in A])\n\nprint((min(d,e)))", "generated_code": "N=int(eval(input()))\n\nA=sorted(a-i-1 for i,a in enumerate(map(int,input().split())))\n\nprint((sum(abs(a-A[N//2]) for a in A)))", "score": 1.0, "codebleu": 0.14960714055356095, "crystalbleu": 0.0, "codebertscore": 0.86, "codescore": 0.12574052810668945, "surfaceSim": 0.5554526748971194, "abs_surfaceSim_minus_score": 0.44454732510288064}
{"golden_code": "'''\n\n    Auther: ghoshashis545 Ashis Ghosh\n\n    College: jalpaiguri Govt Enggineering College\n\n\n\n'''\n\nfrom os import path\n\nimport sys\n\nfrom functools import cmp_to_key as ctk\n\nfrom collections import deque,defaultdict as dd \n\nfrom bisect import bisect,bisect_left,bisect_right,insort,insort_left,insort_right\n\nfrom itertools import permutations\n\nfrom datetime import datetime\n\nfrom math import ceil,sqrt,log,gcd\n\ndef ii():return int(eval(input()))\n\ndef si():return eval(input())\n\ndef mi():return list(map(int,input().split()))\n\ndef li():return list(mi())\n\nabc='abcdefghijklmnopqrstuvwxyz'\n\nmod=1000000007\n\n#mod=998244353\n\ninf = float(\"inf\")\n\nvow=['a','e','i','o','u']\n\ndx,dy=[-1,1,0,0],[0,0,1,-1]\n\n\n\ndef bo(i):\n\n    return ord(i)-ord('a')\n\n\n\nfile = 0\n\n\n\ndef solve():\n\n    \n\n\n\n\n\n\n\n    # for _ in range(ii()):\n\n\n\n    n=ii()\n\n    n%=1000\n\n    if n!=0:\n\n        n=1000-n\n\n    print(n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nif __name__ ==\"__main__\":\n\n\n\n    if(file):\n\n\n\n        if path.exists('input1.txt'):\n\n            sys.stdin=open('input1.txt', 'r')\n\n            sys.stdout=open('output1.txt','w')\n\n        else:\n\n            input=sys.stdin.readline\n\n    solve()", "generated_code": "'''\n\n    Auther: ghoshashis545 Ashis Ghosh\n\n    College: jalpaiguri Govt Enggineering College\n\n\n\n'''\n\nfrom os import path\n\nimport sys\n\nfrom heapq import heappush,heappop\n\nfrom functools import cmp_to_key as ctk\n\nfrom collections import deque,defaultdict as dd \n\nfrom bisect import bisect,bisect_left,bisect_right,insort,insort_left,insort_right\n\nfrom itertools import permutations\n\nfrom datetime import datetime\n\nfrom math import ceil,sqrt,log,gcd\n\ndef ii():return int(eval(input()))\n\ndef si():return eval(input())\n\ndef mi():return list(map(int,input().split()))\n\ndef li():return list(mi())\n\nabc='abcdefghijklmnopqrstuvwxyz'\n\nmod=1000000007\n\n# mod=998244353\n\ninf = float(\"inf\")\n\nvow=['a','e','i','o','u']\n\ndx,dy=[-1,1,0,0],[0,0,1,-1]\n\n\n\ndef bo(i):\n\n    return ord(i)-ord('a')\n\n\n\nfile=0\n\n\n\n\n\n\n\n\n\n\n\ndef solve():\n\n\n\n\n\n    # for _ in range(ii()):\n\n    \n\n        \n\n\n\n    n=ii()\n\n    n%=1000\n\n    if(n!=0):\n\n        n=1000-n\n\n    print(n)\n\n \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n        \n\nif __name__ ==\"__main__\":\n\n\n\n    if(file):\n\n\n\n        if path.exists('input1.txt'):\n\n            sys.stdin=open('input1.txt', 'r')\n\n            sys.stdout=open('output1.txt','w')\n\n        else:\n\n            input=sys.stdin.readline\n\n    solve()\n", "score": 1.0, "codebleu": 0.9305926241207527, "crystalbleu": 0.9540105209643884, "codebertscore": 0.98, "codescore": 0.9937593936920166, "surfaceSim": 0.9859271523178808, "abs_surfaceSim_minus_score": 0.01407284768211925}
{"golden_code": "n,k = list(map(int,input().split()))\n\narr = list(map(int,input().split()))\n\n\n\ndp = [False]*(k+1)\n\n\n\nfor stones in range(k+1):\n\n    for x in arr:\n\n        if stones >= x and dp[stones-x] == False:\n\n            dp[stones] = True\n\n\n\nif dp[k]:\n\n    print(\"First\")\n\nelse:\n\n    print(\"Second\")\n", "generated_code": "N,K = list(map(int,input().split()))\n\nA = list(map(int,input().split()))\n\n\n\ndp = [False]*(K+1)\n\n\n\nfor i in range(K+1):\n\n    for j in range(N):\n\n        if i-A[j]>=0 and dp[i-A[j]] == False:\n\n            dp[i] = True\n\n\n\n        \n\nif dp[K]:\n\n    print(\"First\")\n\nelse:\n\n    print(\"Second\")", "score": 1.0, "codebleu": 0.5318704542490293, "crystalbleu": 0.48657171741610983, "codebertscore": 0.92, "codescore": 0.4815407693386078, "surfaceSim": 0.9253472222222222, "abs_surfaceSim_minus_score": 0.07465277777777779}
{"golden_code": "import re\n\n\n\nS = eval(input())\n\nmax = 0\n\n\n\nfor i in range(len(S)) :\n\n    for j in range(i + 1, len(S) + 1) :\n\n        pattern = re.compile(r'[A|T|C|G]{%d}' % int(j - i))\n\n        subStr = S[i:j]\n\n\n\n        if pattern.match(subStr) and j - i > max :\n\n            max = j - i\n\n\n\nprint(max)\n", "generated_code": "S = eval(input())\n\n\n\nans = 0\n\n\n\nfor i in range(len(S)) :\n\n    for j in range(i, len(S)) :\n\n        if all('ACGT'.count(c) == 1 for c in S[i : j + 1]) :\n\n            ans = max(ans, j - i + 1)\n\n\n\n\n\nprint(ans)\n", "score": 1.0, "codebleu": 0.32209897746239663, "crystalbleu": 0.0, "codebertscore": 0.85, "codescore": 0.5921406745910645, "surfaceSim": 0.6550480769230769, "abs_surfaceSim_minus_score": 0.34495192307692313}
{"golden_code": "from functools import lru_cache\n\nimport sys\n\n\n\nsys.setrecursionlimit(10 ** 7)\n\n\n\n\n\n@lru_cache(maxsize=None)\n\ndef check(l, r, n, k=1):\n\n    t = l + '0' * k + r\n\n    e = l + '9' * k + r\n\n\n\n    if int(e) <= n:\n\n        return pow(10, k) + check(l, r, n, k + 1)\n\n\n\n    if int(t) <= n < int(e):\n\n        x = int(str(n)[1:-1])\n\n        if int(str(n)[-1]) < int(r):\n\n            x -= 1\n\n        return x + 1\n\n\n\n    if n < int(t):\n\n        return 0\n\n\n\n\n\ndef main():\n\n    n = int(eval(input()))\n\n\n\n    ret = 0\n\n    for x in range(1, n + 1):\n\n        if x % 10 == 0:\n\n            continue\n\n        s = str(x)\n\n        t = s[-1] + s[0]\n\n        if s[0] == s[-1]:\n\n            ret += 1\n\n        if int(t) <= n:\n\n            ret += 1\n\n        ret += check(s[-1], s[0], n, k=1)\n\n\n\n    print(ret)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "generated_code": "# 解説放送\n\n\n\ndef main():\n\n    from collections import defaultdict\n\n\n\n    n = int(eval(input()))\n\n\n\n    d = defaultdict(int)\n\n    for x in range(1, n + 1):\n\n        if x % 10 == 0:\n\n            continue\n\n\n\n        tail = x % 10\n\n        head = 0\n\n        while x:\n\n            head = x\n\n            x //= 10\n\n\n\n        d[head, tail] += 1\n\n\n\n    ret = 0\n\n    for (head, tail), cnt in tuple(d.items()):\n\n        # RuntimeError: dictionary changed size during iteration\n\n        # defaultdictの未定義(?)のkeyにアクセスするせいで、REになる\n\n        # d.items()をtuple化して回避\n\n        ret += d[head, tail] * d[tail, head]\n\n        # (head,tail)の出現数を辞書で管理する\n\n        # (head,tail)*(tail,head)の組み合わせがある\n\n\n\n    print(ret)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 1.0, "codebleu": 0.25529698486621005, "crystalbleu": 0.12295908885761007, "codebertscore": 0.7, "codescore": 0.04738388583064079, "surfaceSim": 0.603805798721053, "abs_surfaceSim_minus_score": 0.396194201278947}
{"golden_code": "N = int(eval(input()))\n\nx = list(map(int, input().split()))\n\ncnt = 0\n\nfor i in x:\n\n  while i % 2 == 0:\n\n    cnt += 1\n\n    i /= 2\n\nprint(cnt)", "generated_code": "n = int(eval(input()))\n\nans = 0\n\nfor i in map(int, input().split()):\n\n    cnt = 0\n\n    while i % 2 == 0:\n\n        i >>= 1\n\n        cnt += 1\n\n    ans += cnt\n\nprint(ans)", "score": 1.0, "codebleu": 0.5065154785810035, "crystalbleu": 0.0, "codebertscore": 0.92, "codescore": 0.8493110537528992, "surfaceSim": 0.8365899779388591, "abs_surfaceSim_minus_score": 0.16341002206114086}
{"golden_code": "import math\n\nN = int(eval(input()))\n\nprint((math.factorial(N)%(10**9+7)))", "generated_code": "ans=1\n\nn=int(eval(input()))\n\nfor i in range(1,n+1):\n\n    ans*=i\n\n    ans=ans%(10**9+7)\n\nprint(ans)", "score": 1.0, "codebleu": 0.2435064935064935, "crystalbleu": 0.0, "codebertscore": 0.83, "codescore": 0.9895403981208801, "surfaceSim": 0.5884353741496599, "abs_surfaceSim_minus_score": 0.41156462585034015}
{"golden_code": "a, b, m = list(map(int,input().split()))\n\ndr = list(map(int,input().split()))\n\nwa = list(map(int,input().split()))\n\nxyc = [list(map(int,input().split())) for i in range(m)]\n\nlow = 200001\n\n\n\nfor i in range(m):\n\n    f = xyc[i][0] - 1\n\n    d = xyc[i][1] - 1\n\n    if low >= dr[f]+wa[d]-xyc[i][2]:\n\n        low = dr[f]+wa[d]-xyc[i][2]\n\n\n\ndr.sort()\n\nwa.sort()\n\n\n\nif low >= (dr[0] + wa[0]):\n\n    print((dr[0] + wa[0]))\n\nelse:\n\n    print(low)", "generated_code": "a, b, m = list(map(int,input().split()))\n\nal = list(map(int,input().split()))\n\nbl = list(map(int,input().split()))\n\nlow = min(al)+min(bl)\n\nx = [0] * m\n\ny = [0] * m\n\nc = [0] * m\n\n\n\nfor i in range(m):\n\n    x[i],y[i],c[i] = list(map(int, input().split()))\n\n    x[i] -= 1\n\n    y[i] -= 1\n\n \n\nfor i in range(m):\n\n    low = min(low,al[x[i]]+bl[y[i]]-c[i])\n\n\n\nprint(low)", "score": 1.0, "codebleu": 0.35418127921457465, "crystalbleu": 0.27596498931287516, "codebertscore": 0.85, "codescore": 0.2725650668144226, "surfaceSim": 0.6340245775729647, "abs_surfaceSim_minus_score": 0.3659754224270353}
{"golden_code": "import numpy as np\n\n\n\nN = int(eval(input()))\n\nX = np.array(list(int(x) for x in input().split()))\n\nm = round(np.mean(X))\n\n\n\nprint((int(sum((X-m)**2))))", "generated_code": "N = int(eval(input()))\n\nX = list(int(x) for x in input().split())\n\np = round(sum(X)/len(X))\n\nans = 0\n\n\n\nfor i in range(N):\n\n    ans += (X[i] - p)**2\n\n\n\nprint(ans)", "score": 1.0, "codebleu": 0.32363271384830844, "crystalbleu": 0.0, "codebertscore": 0.86, "codescore": 0.37843117117881775, "surfaceSim": 0.5928731762065096, "abs_surfaceSim_minus_score": 0.4071268237934904}
{"golden_code": "import sys\n\nimport numpy as np\n\n\n\nsr = lambda: sys.stdin.readline().rstrip()\n\nir = lambda: int(sr())\n\nlr = lambda: list(map(int, sr().split()))\n\n\n\nN = ir()\n\n# Aの先頭の桁と末尾の桁の組み合わせは9*10=90通りだけ\n\ntable = [[0] * 10 for i in range(10)]\n\nfor x in range(1, N+1):\n\n    x = str(x)\n\n    i = int(x[0])\n\n    j = int(x[-1])\n\n    table[i][j] += 1\n\n\n\ntable = np.array(table)\n\nanswer = (table * table.T).sum()\n\nprint(answer)\n", "generated_code": "import sys\n\n\n\nsr = lambda: sys.stdin.readline().rstrip()\n\nir = lambda: int(sr())\n\nlr = lambda: list(map(int, sr().split()))\n\n\n\nN = ir()\n\ncount = [[0] * 10 for _ in range(10)] # dp[head][tail]\n\nfor i in range(1, N+1):\n\n    s = str(i)\n\n    head = int(s[0]); tail = int(s[-1])\n\n    count[head][tail] += 1\n\n\n\nanswer = 0\n\nfor h in range(10):\n\n    for t in range(10):\n\n        answer += count[h][t] * count[t][h]\n\nprint(answer)\n", "score": 1.0, "codebleu": 0.4882229826890777, "crystalbleu": 0.47060759502469945, "codebertscore": 0.83, "codescore": 0.8622820973396301, "surfaceSim": 0.8767772511848342, "abs_surfaceSim_minus_score": 0.12322274881516582}
{"golden_code": "N,M = [int(c) for c in input().split()]\n\nab = [list(map(int,input().split())) for c in range(N)]\n\ncd = [list(map(int,input().split())) for c in range(M)]\n\nfor i in range(N):\n\n    mi = 2*10**9\n\n    for j in range(M):\n\n        tmp = abs(ab[i][0]-cd[j][0])+abs(ab[i][1]-cd[j][1])\n\n        if mi > tmp:\n\n            mi = tmp\n\n            ans = j+1\n\n    print(ans)\n", "generated_code": "N,M = [int(c) for c in input().split()]\n\nab = [list(map(int,input().split())) for c in range(N)]\n\ncd = [list(map(int,input().split())) for c in range(M)]\n\nfor i in range(N):\n\n    mi = 10**9\n\n    for j in range(M):\n\n        tmp = abs(ab[i][0]-cd[j][0])+abs(ab[i][1]-cd[j][1])\n\n        if mi > tmp:\n\n            mi = tmp\n\n            ans = j+1\n\n    print(ans)\n", "score": 1.0, "codebleu": 0.8946322967985552, "crystalbleu": 0.974761372879885, "codebertscore": 0.99, "codescore": 0.7421724796295166, "surfaceSim": 0.9754830917874396, "abs_surfaceSim_minus_score": 0.024516908212560362}
{"golden_code": "import itertools\n\nfrom collections import Counter\n\nN = int(eval(input()))\n\nsrc = [eval(input()) for i in range(N)]\n\nctr = Counter()\n\nfor s in src:\n\n    ctr[s[0]] += 1\n\n\n\nans = 0\n\nfor ptn in itertools.combinations('MARCH',3):\n\n    a,b,c = ptn\n\n    ans += ctr[a]*ctr[b]*ctr[c]\n\nprint(ans)", "generated_code": "N = int(eval(input()))\n\nS = [eval(input()) for i in range(N)]\n\nfrom collections import Counter\n\nctr = Counter([s[0] for s in S])\n\n\n\nans = 0\n\nimport itertools\n\nfor ptn in itertools.combinations('MARCH', 3):\n\n    t = 1\n\n    for c in ptn:\n\n        t *= ctr[c]\n\n    ans += t\n\nprint(ans)", "score": 1.0, "codebleu": 0.39758423664434794, "crystalbleu": 0.46036999033114373, "codebertscore": 0.93, "codescore": 0.6177493929862976, "surfaceSim": 0.7220279720279721, "abs_surfaceSim_minus_score": 0.2779720279720279}
{"golden_code": "import numpy as np\n\nimport numba\n\nfrom numba import njit, b1, i4, i8, f8\n\n\n\n@njit((i8, i8[:]), cache=True)\n\ndef main(N,A):\n\n  Amax = np.max(A)\n\n  lis = np.zeros(Amax+1, np.int64)\n\n  for i in range(N):\n\n    lis[A[i]] += 1\n\n  setwise = False\n\n  for t in range(2,Amax+1):\n\n    cnt = np.sum(lis[t:Amax+1:t])\n\n    if cnt==N:\n\n      return 'not'\n\n    if 2<=cnt<N:\n\n      setwise=True\n\n  if setwise==True:\n\n    return 'setwise'\n\n  return 'pairwise'\n\n\n\nN = int(eval(input()))\n\nA = np.array(list(map(int, input().split())))\n\nprint((main(N,A)+' coprime'))\n\n\n", "generated_code": "def sieve(n):\n\n  is_prime = [True for _ in range(n+1)]\n\n  is_prime[0] = False\n\n  for i in range(2, n+1):\n\n    if is_prime[i-1]:\n\n      j = 2 * i\n\n      while j <= n:\n\n        is_prime[j-1] = False\n\n        j += i\n\n  table = [i for i in range(1, n+1) if is_prime[i-1]]\n\n  return table\n\n\n\nN = int(eval(input()))\n\nA = list(map(int, input().split()))\n\nAmax = max(A)\n\nlis = [0]*(Amax+1)\n\nfor i in range(N):\n\n  lis[A[i]] += 1\n\ntable = sieve(Amax)\n\nsetwise = False\n\nfor t in table:\n\n  cnt = sum(lis[t:Amax+1:t])\n\n  if cnt==N:\n\n    print('not coprime')\n\n    break\n\n  if 2<=cnt<N:\n\n    setwise=True\n\nelse:\n\n  if setwise==True:\n\n    print('setwise coprime')\n\n  else:\n\n    print('pairwise coprime')\n", "score": 1.0, "codebleu": 0.3197419166934511, "crystalbleu": 0.33208856196294406, "codebertscore": 0.82, "codescore": 0.9593887329101562, "surfaceSim": 0.5645820238843495, "abs_surfaceSim_minus_score": 0.4354179761156505}
{"golden_code": "#!usr/bin/env python3\n\nfrom collections import defaultdict\n\nfrom collections import deque\n\nfrom heapq import heappush, heappop\n\nimport sys\n\nimport math\n\nimport bisect\n\nimport random\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\n\ndef I(): return int(sys.stdin.readline())\n\ndef LS():return list(map(list, sys.stdin.readline().split()))\n\ndef S(): return list(sys.stdin.readline())[:-1]\n\ndef IR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = I()\n\n    return l\n\ndef LIR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = LI()\n\n    return l\n\ndef SR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = S()\n\n    return l\n\ndef LSR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = LS()\n\n    return l\n\nsys.setrecursionlimit(1000000)\n\nmod = 1000000007\n\n\n\n#A\n\ndef A():\n\n    return\n\n\n\n#B\n\ndef B():\n\n    return\n\n\n\n#C\n\ndef C():\n\n    return\n\n\n\n#D\n\ndef D():\n\n    return\n\n\n\n#E\n\ndef E():\n\n    return\n\n\n\n#F\n\ndef F():\n\n    a,b,c,X,Y = LI()\n\n    ans = float(\"inf\")\n\n    for z in range(300001):\n\n        if z%2 == 0:\n\n            m = c*z\n\n            x = z//2\n\n            y = z//2\n\n            m += a*max(0,X-x)\n\n            m += b*max(0,Y-y)\n\n            if m < ans:\n\n                ans = m\n\n    print(ans)\n\n    return\n\n\n\n#G\n\ndef G():\n\n    n = I()\n\n    x = LI()\n\n    f = [(i,x[i]) for i in range(n)]\n\n    f.sort(key = lambda x:x[1])\n\n    g = [(f[i][0],i) for i in range(n)]\n\n    g.sort(key = lambda x:x[0])\n\n    for i in range(n):\n\n        if g[i][1] < n//2:\n\n            print((f[n//2][1]))\n\n        else:\n\n            print((f[n//2-1][1]))\n\n    return\n\n\n\n#H\n\ndef H():\n\n    return\n\n\n\n#I\n\ndef I_():\n\n    return\n\n\n\n#J\n\ndef J():\n\n    return\n\n\n\n#Solve\n\nif __name__ == \"__main__\":\n\n    F()\n", "generated_code": "#!usr/bin/env python3\n\nfrom collections import defaultdict,deque\n\nfrom heapq import heappush, heappop\n\nfrom itertools import permutations\n\nimport sys\n\nimport math\n\nimport bisect\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\n\ndef I(): return int(sys.stdin.readline())\n\ndef LS():return [list(x) for x in sys.stdin.readline().split()]\n\ndef S():\n\n    res = list(sys.stdin.readline())\n\n    if res[-1] == \"\\n\":\n\n        return res[:-1]\n\n    return res\n\ndef IR(n):\n\n    return [I() for i in range(n)]\n\ndef LIR(n):\n\n    return [LI() for i in range(n)]\n\ndef SR(n):\n\n    return [S() for i in range(n)]\n\ndef LSR(n):\n\n    return [LS() for i in range(n)]\n\n\n\nsys.setrecursionlimit(1000000)\n\nmod = 1000000007\n\n\n\ndef solve():\n\n    A,B,C,x,y = LI()\n\n    ans = float(\"inf\")\n\n    for c in range(200001)[::2]:\n\n        a = b = c >> 1\n\n        a = max(0,x-a)\n\n        b = max(0,y-b)\n\n        s = A*a+B*b+C*c\n\n        if s < ans:\n\n            ans = s\n\n    print(ans)\n\n    return\n\n\n\n#Solve\n\nif __name__ == \"__main__\":\n\n    solve()\n", "score": 1.0, "codebleu": 0.302056425719341, "crystalbleu": 0.22486624152797977, "codebertscore": 0.88, "codescore": 0.02360607497394085, "surfaceSim": 0.7418803418803419, "abs_surfaceSim_minus_score": 0.2581196581196581}
{"golden_code": "from collections import Counter\n\ndef factorization(n) -> list:\n\n\tif n==1:\n\n\t\treturn [1]\n\n\tret = []\n\n\ti = 2\n\n\twhile i*i<=n:\n\n\t\twhile n%i==0:\n\n\t\t\tn //= i\n\n\t\t\tret.append(i)\n\n\t\ti += 1\n\n\tif n!=1:\n\n\t\tret.append(n)\n\n\treturn ret\n\n\n\nn,m = list(map(int,input().split()))\n\nmod = 10**9+7\n\nif m==1:\n\n\tprint((1));exit()\n\n\n\nfactors = Counter(factorization(m))\n\nmx = n+max(factors.values())\n\n\n\nfac = [1]*(mx+1)\n\ninv = [1]*(mx+1)\n\nfor i in range(1,mx+1):\n\n\tfac[i] = fac[i-1] * i % mod\n\ninv[-1] = pow(fac[-1], mod - 2, mod)\n\nfor i in range(mx-1, -1, -1):\n\n\tinv[i] = inv[i+1] * (i+1) % mod\n\ndef cmb(n,r):\n\n\tassert n >= r >= 0\n\n\treturn fac[n] * inv[n-r] * inv[r] % mod\n\n\t\n\nans=1\n\nfor v in list(factors.values()):\n\n\tans*=cmb(n+v-1,v)\n\n\tans%=mod\n\n\n\nprint(ans)", "generated_code": "from collections import Counter\n\ndef factorization(n) -> list:\n\n\tif n==1:return [1]\n\n\tret = []\n\n\ti = 2\n\n\twhile i*i<=n:\n\n\t\twhile n%i==0:\n\n\t\t\tn //= i\n\n\t\t\tret.append(i)\n\n\t\ti += 1\n\n\tif n!=1:ret.append(n)\n\n\treturn ret\n\n\t\n\nfrom operator import mul\n\nfrom functools import reduce\n\ndef cmb(n,r):\n\n\tif n < r:return 0\n\n\tr = min(n-r,r)\n\n\tif r==0:return 1\n\n\tu = reduce(mul, list(range(n, n-r, -1)))\n\n\td = reduce(mul, list(range(1,r+1)))\n\n\treturn u//d\n\n\n\ndef main():\n\n\tn,m = list(map(int,input().split()))\n\n\tmod = 10**9+7\n\n\tif m==1:\n\n\t\tprint((1))\n\n\t\texit()\n\n\tans=1\n\n\tfor v in list(Counter(factorization(m)).values()):\n\n\t\tans*=cmb(n+v-1,v)\n\n\t\tans%=mod\n\n\tprint(ans)\n\n\t\n\nif __name__==\"__main__\":main()", "score": 1.0, "codebleu": 0.4541721296144605, "crystalbleu": 0.48714103462370495, "codebertscore": 0.87, "codescore": 0.024348987266421318, "surfaceSim": 0.7052325783669067, "abs_surfaceSim_minus_score": 0.29476742163309333}
{"golden_code": "def main():\n\n\n\n    while True:\n\n        n, x = tuple(map(int, input().split()))\n\n        pattern = 0\n\n\n\n        if n == x == 0:\n\n            break\n\n        else:\n\n            for a in range(1, n+1):\n\n                for b in range(1, a):\n\n                    for c in range(1, b):\n\n                        pattern += 1 if a + b + c == x and a > b > c else 0\n\n            print(pattern)\n\n                            \n\n\n\nif __name__ == '__main__':\n\n    main()\n", "generated_code": "def divide_two(c, z):\n\n    min_b = z // 2 + 1\n\n    max_b = min(c-1, z-1)\n\n    return max(max_b-min_b+1, 0)\n\n    \n\n\n\nnum_set = []\n\ncnt = 0\n\nwhile True:\n\n    n, x = list(map(int, input().split()))\n\n    if (n, x) == (0, 0):\n\n        break\n\n    else:\n\n        num_set.append((n, x))\n\n        cnt += 1\n\n\n\nfor i in range(cnt):\n\n    num_count = 0\n\n    (n, x) = num_set[i]\n\n    for c in range(x//3, n+1):\n\n        num_count += divide_two(c, x-c)\n\n    print(num_count)\n", "score": 1.0, "codebleu": 0.24725808949807654, "crystalbleu": 0.20760833334463058, "codebertscore": 0.8, "codescore": 0.9832853674888611, "surfaceSim": 0.5911684782608696, "abs_surfaceSim_minus_score": 0.4088315217391304}
{"golden_code": "import math\n\nx = int(eval(input()))\n\nprint((math.factorial(x) % (10**9 + 7)))", "generated_code": "M = 1000000007\n\nn=int(eval(input()))\n\nf = 1\n\nfor i in range(1, n + 1):  \n\n    f = (f * i) % M \n\nprint(f)", "score": 1.0, "codebleu": 0.21865774537505162, "crystalbleu": 0.0, "codebertscore": 0.77, "codescore": 0.08128807693719864, "surfaceSim": 0.5831447963800904, "abs_surfaceSim_minus_score": 0.4168552036199096}
{"golden_code": "import math\n\n\n\nn = int(eval(input()))\n\nans = math.factorial(n) % (pow(10, 9) + 7)\n\nprint(ans)", "generated_code": "n = int(eval(input()))\n\nans = 1\n\nmod = 10 ** 9 + 7\n\nfor i in range(1, n + 1):\n\n    ans = (ans * i % mod) % mod\n\nprint(ans)", "score": 1.0, "codebleu": 0.35287485833402454, "crystalbleu": 0.0, "codebertscore": 0.83, "codescore": 0.3994392156600952, "surfaceSim": 0.6022179363548699, "abs_surfaceSim_minus_score": 0.39778206364513014}
{"golden_code": "def isPrime(x):\n\n    if x == 2:\n\n        return True\n\n    if x < 2 or x % 2 == 0:\n\n        return False\n\n    i, root_x = 3, int(pow(x, 0.5))\n\n    while i <= root_x:\n\n        if x % i == 0:\n\n            return False\n\n        i += 2\n\n    return True\n\n\n\nprimes = [2]\n\nfor i in range(3, 104730):\n\n    if isPrime(i):\n\n        primes.append(primes[-1]+i)\n\nwhile True:\n\n    n = int(eval(input()))\n\n    if n == 0:\n\n        break\n\n    print((primes[n-1]))", "generated_code": "primes = [0, 0] + [1] * 150000\n\nfor i in range(2, 388):\n\n    if primes[i]:\n\n        for j in range(i*i, 150001, i):\n\n            primes[j] = 0\n\n\n\nvalues = [i for i, v in enumerate(primes) if v]\n\nwhile True:\n\n    n = int(eval(input()))\n\n    if n == 0:\n\n        break\n\n    print((sum(values[:n])))", "score": 1.0, "codebleu": 0.24961245842388874, "crystalbleu": 0.19868800898164216, "codebertscore": 0.78, "codescore": 0.49645882844924927, "surfaceSim": 0.5636063252301156, "abs_surfaceSim_minus_score": 0.43639367476988444}
{"golden_code": "import sys\n\nstdin = sys.stdin\n\n \n\nsys.setrecursionlimit(10**8) \n\n \n\ndef li(): return list(map(int, stdin.readline().split()))\n\ndef li_(): return [int(x)-1 for x in stdin.readline().split()]\n\ndef lf(): return list(map(float, stdin.readline().split()))\n\ndef ls(): return stdin.readline().split()\n\ndef ns(): return stdin.readline().rstrip()\n\ndef lc(): return list(ns())\n\ndef ni(): return int(stdin.readline())\n\ndef nf(): return float(stdin.readline())\n\n\n\n\n\nn = ni()\n\na = [ni() for _ in range(n)]\n\n\n\ncnt = {i+1: ai for i, ai in enumerate(a)}\n\n\n\nprev = -100\n\ncur = 0\n\nans = 0\n\nfor key in sorted(cnt.keys()):\n\n    if cnt[key] == 0:\n\n        continue\n\n    \n\n    if prev == -100:\n\n        prev = key\n\n    \n\n    if (key-prev) < 2:\n\n        cur += cnt[key]\n\n    else:\n\n        cur = cnt[key]\n\n        \n\n    ans += cur // 2\n\n    cur -= 2 * (cur//2)\n\n    \n\n    prev = key\n\n        \n\nprint(ans)", "generated_code": "import sys\n\nstdin = sys.stdin\n\n\n\nsys.setrecursionlimit(10 ** 7)\n\n\n\ndef li(): return list(map(int, stdin.readline().split()))\n\ndef li_(): return [int(x) - 1 for x in stdin.readline().split()]\n\ndef lf(): return list(map(float, stdin.readline().split()))\n\ndef ls(): return stdin.readline().split()\n\ndef ns(): return stdin.readline().rstrip()\n\ndef lc(): return list(ns())\n\ndef ni(): return int(stdin.readline())\n\ndef nf(): return float(stdin.readline())\n\n\n\nn = ni()\n\n\n\nans = 0\n\nplus = 0\n\na = [ni() for _ in range(n)]\n\n\n\nfor ai in a:\n\n    ans += ((ai+plus) // 2)\n\n    plus = (ai+plus) % 2 if ai > 0 else 0\n\n\n\nprint(ans)", "score": 1.0, "codebleu": 0.5423049581901753, "crystalbleu": 0.5658281485753505, "codebertscore": 0.92, "codescore": 0.5120608806610107, "surfaceSim": 0.7028496325945397, "abs_surfaceSim_minus_score": 0.2971503674054603}
{"golden_code": "import heapq\n\nK=int(eval(input()))\n\ndist=[10**15 for i in range(K)]\n\ndist[1]=1\n\nq=[]\n\nheapq.heappush(q,(0,1))\n\nwhile (len(q)!=0):\n\n    prc,src=heapq.heappop(q)\n\n    if dist[src]<prc:\n\n        continue\n\n    if dist[(src+1)%K]>dist[src]+1:\n\n        dist[(src+1)%K]=dist[src]+1\n\n        heapq.heappush(q,(dist[(src+1)%K],(src+1)%K))\n\n    if dist[(10*src)%K]>dist[src]:\n\n        dist[(10*src)%K]=dist[src]\n\n        heapq.heappush(q,(dist[(src*10)%K],(src*10)%K))\n\nprint((dist[0]))\n", "generated_code": "from collections import deque\n\nK=int(eval(input()))\n\ndist=[10**15 for i in range(K)]\n\ndist[1]=1\n\nq=deque([1])\n\nwhile(len(q)>0):\n\n    r=q.popleft()\n\n    s=(r+1)%K\n\n    if dist[r]+1<dist[s]:\n\n        dist[s]=dist[r]+1\n\n        q.append(s)\n\n    t=(r*10)%K\n\n    if dist[r]<dist[t]:\n\n        dist[t]=dist[r]\n\n        q.appendleft(t)\n\nprint((dist[0]))\n", "score": 1.0, "codebleu": 0.3898046322749057, "crystalbleu": 0.284894406467935, "codebertscore": 0.85, "codescore": 0.9505230188369751, "surfaceSim": 0.7091194968553459, "abs_surfaceSim_minus_score": 0.2908805031446541}
{"golden_code": "import queue\n\nn = int(eval(input()))\n\n\n\nabc = [[] for i in range(n+1)]\n\n\n\nfor i in range(n-1):\n\n    a,b,c = list(map(int,input().split()))\n\n    abc[a].append([b,c])\n\n    abc[b].append([a,c])\n\n\n\nQ,k = list(map(int,input().split()))\n\nxy = [[int(i) for i in input().split()] for j in range(Q)]\n\n\n\nq = queue.Queue()\n\n\n\nq.put(k)\n\n\n\npath = [-1]*(n+1)\n\npath[k] = 0\n\n\n\nwhile not q.empty():\n\n    tmp = q.get()\n\n    for i in range(len(abc[tmp])):\n\n        #print(abc[tmp])\n\n        #exit()\n\n        num = abc[tmp][i][0]\n\n        if path[num] != -1:\n\n            continue\n\n        else:\n\n            path[num] = path[tmp] + abc[tmp][i][1]\n\n            q.put(num)\n\n            \n\nfor i in range(Q):\n\n    print((path[xy[i][0]]+path[xy[i][1]]))", "generated_code": "import queue\n\nimport sys\n\nsys.setrecursionlimit(10**7)\n\nn = int(eval(input()))\n\n\n\nabc = [[] for i in range(n+1)]\n\n\n\nfor i in range(n-1):\n\n    a,b,c = list(map(int,input().split()))\n\n    abc[a].append([b,c])\n\n    abc[b].append([a,c])\n\n\n\nQ,k = list(map(int,input().split()))\n\nxy = [[int(i) for i in input().split()] for j in range(Q)]\n\n\n\nq = queue.Queue()\n\n\n\nq.put(k)\n\n\n\npath = [-1]*(n+1)\n\npath[k] = 0\n\n\n\ndef dfs(p):\n\n    for i in range(len(abc[p])):\n\n        num = abc[p][i][0]\n\n        if path[num] != -1:\n\n            continue\n\n        else:\n\n            path[num] = path[p] + abc[p][i][1]\n\n            dfs(num)\n\n\n\ndfs(k)\n\n\n\nfor i in range(Q):\n\n    print((path[xy[i][0]]+path[xy[i][1]]))", "score": 1.0, "codebleu": 0.7178943260402467, "crystalbleu": 0.7768406651850385, "codebertscore": 0.94, "codescore": 0.9774681329727173, "surfaceSim": 0.8534656661018316, "abs_surfaceSim_minus_score": 0.1465343338981684}
{"golden_code": "\n\n\n\n# N個の荷物、ナップザックの容量はW\n\nN, W = list(map(int, input().split()))\n\nw = [0] * N\n\nv = [0] * N\n\n\n\nfor i in range(N):\n\n    a, b = list(map(int, input().split()))\n\n    w[i] = a\n\n    v[i] = b\n\n\n\n# 1 <= W <= 10^9なので横軸をWにするとテーブルがでかすぎる\n\n# そのかわりにVの方を横軸にする\n\n\n\n# 価値の総合計はまだ不明なので、適当にでかい値にしとく\n\n# 最上部と最左部に0が入るので、その分を+1\n\nV = N*1000+1\n\ndp = [ [float('inf') for _ in range(V+1)] for _ in range(N+1) ]\n\n\n\n# 最小値を求めるので、上記でinfが入ってるので、初期値は0をいれる必要がある\n\ndp[0][0] = 0\n\n\n\n# dp[i][sum_v] = これまで(i-1)番目までの品物から価値がsum_v以上になるように選んだときの、重さの総和の最小値\n\nfor i in range(N):\n\n    for sum_v in range(V):\n\n        if sum_v - v[i] >= 0:\n\n            dp[i+1][sum_v] = min(dp[i+1][sum_v], dp[i][sum_v-v[i]]+w[i])\n\n\n\n        dp[i+1][sum_v] = min(dp[i+1][sum_v], dp[i][sum_v])\n\n\n\n\n\n# 中身がWなので、W以下であるうちのsum_vの最大値を求めればいい\n\nfor sum_v in range(V):\n\n    # 最終行だけ見ればいいので、端からsum_vの最大値をなめるだけ\n\n    if dp[N][sum_v] <= W:\n\n        ans = sum_v\n\n\n\nprint(ans)", "generated_code": "\n\n\n\nimport sys\n\ninput = sys.stdin.readline\n\nsys.setrecursionlimit(2147483647)\n\nINF=float(\"inf\")\n\nMOD=10**9+7\n\n# A = [ int(input()) for _ in range(N) ]\n\n##############################\n\n\n\nN, W = list(map(int, input().split()))\n\nw = []\n\nv = []\n\nfor i in range(N):\n\n    a, b = list(map(int, input().split()))\n\n    w.append(a)\n\n    v.append(b)\n\n\n\nV = sum(v)\n\n\n\ndp = [ [INF for _ in range(V+1)] for _ in range(N+1) ]\n\n\n\ndp[0][0] = 0\n\n\n\nfor i in range(N):\n\n    for j in range(V+1):\n\n        if j - v[i] < 0:\n\n            dp[i+1][j] = dp[i][j]\n\n        else:\n\n            dp[i+1][j] = min(dp[i][j], dp[i][j-v[i]]+w[i])\n\n\n\n#print(dp[N])\n\n\n\nans = 0\n\nfor v in range(V+1):\n\n    if dp[N][v] <= W:\n\n        ans = v\n\n\n\nprint(ans)\n", "score": 1.0, "codebleu": 0.38976059261779145, "crystalbleu": 0.5226506231908651, "codebertscore": 0.75, "codescore": 0.7921295166015625, "surfaceSim": 0.7595613048368954, "abs_surfaceSim_minus_score": 0.24043869516310457}
{"golden_code": "import math\n\nn = int(eval(input()))\n\n\n\nans = math.factorial(n)  # nの階乗を計算\n\n\n\nif ans >= (10 ** 9)+7:\n\n    ans = ans % ((10 ** 9)+7)\n\n\n\nprint(ans)\n", "generated_code": "n = int(eval(input()))\n\n\n\nans = 1\n\nfor i in range(1, n+1):\n\n    ans = ans * i\n\n    ans = ans % ((10 ** 9)+7)  # 途中で割り算の余りを求めても、最終結果は同じになる\n\n\n\nprint(ans)", "score": 1.0, "codebleu": 0.45508450301466985, "crystalbleu": 0.0, "codebertscore": 0.8, "codescore": 0.1947074830532074, "surfaceSim": 0.6609271523178808, "abs_surfaceSim_minus_score": 0.3390728476821192}
{"golden_code": "import numpy as np\n\nn,k=list(map(int, input().split()))\n\nexp=list([(int(x)+1)/2 for x in input().split()]) # 入力と同時に期待値計算\n\n\n\nl=np.cumsum(exp) # 累積和の計算\n\n\n\nans=l[k-1]\n\nfor i in range(n-k):\n\n    ans=max(ans,l[i+k]-l[i])\n\n    \n\nprint(ans)", "generated_code": "n,k=list(map(int, input().split()))\n\nexp=list([(int(x)+1)/2 for x in input().split()]) # 入力と同時に期待値計算\n\n\n\nl=[0]*n\n\nsum1=0\n\nfor i in range(n):# 累積和の計算\n\n    sum1+=exp[i]\n\n    l[i]=sum1 \n\n\n\nans=l[k-1]\n\nfor i in range(n-k):\n\n    ans=max(ans,l[i+k]-l[i])\n\n    \n\nprint(ans)", "score": 1.0, "codebleu": 0.6212222443518568, "crystalbleu": 0.6308762309208408, "codebertscore": 0.94, "codescore": 0.9932953715324402, "surfaceSim": 0.7845125786163523, "abs_surfaceSim_minus_score": 0.21548742138364774}
{"golden_code": "import sys\n\ninput = sys.stdin.readline\n\nN, M = list(map(int,input().split()))\n\nhole = [0] * (N+1)\n\nfor i in range(M):\n\n    hole[int(eval(input()))] = 1\n\nif N == 1:\n\n    print((1))\n\n    exit()\n\nif N == 2:\n\n    if hole[1] == 1:\n\n        print((1))\n\n        exit()\n\n    if hole[1] == 0:\n\n        print((2))\n\n        exit()\n\nflg_one = False\n\nflg_two = False\n\nfirst = 1\n\nsecond = 2\n\nif hole[1] == 1:\n\n    first = 0\n\n    second = 1\n\n    flg_one = True\n\nif hole[2] == 1:\n\n    first = 1\n\n    second = 0\n\n    flg_two = True\n\nif flg_one and flg_two:\n\n    print((0))\n\n    exit()\n\n\n\nfor i in range(3,N):\n\n    if hole[i] == 1:\n\n        first = second\n\n        second = 0\n\n        continue\n\n    tmp = first + second\n\n    tmp %= 1000000007\n\n    first = second\n\n    second = tmp\n\ntmp = first + second\n\ntmp %= 1000000007\n\nprint(tmp)", "generated_code": "MOD = 10**9 + 7\n\nN, M = list(map(int, input().split()))\n\nstairs = [0]*(N+1)\n\nfor _ in range(M):\n\n    stairs[int(eval(input()))] = 1\n\nif N == 1:\n\n    print((1))\n\n    exit()\n\nans = [0]*(N+1)\n\nans[1] = 1 if stairs[1] == 0 else 0\n\nans[2] = 1 + ans[1] if stairs[2] == 0 else 0\n\nfor i in range(3,N+1):\n\n    if stairs[i] == 1:\n\n        ans[i] = 0\n\n        continue\n\n    ans[i] = (ans[i-1] + ans[i-2]) % MOD\n\nprint((ans[N]))", "score": 1.0, "codebleu": 0.28544642899014083, "crystalbleu": 0.3407277700174666, "codebertscore": 0.81, "codescore": 0.16139020025730133, "surfaceSim": 0.6445807770961145, "abs_surfaceSim_minus_score": 0.3554192229038855}
{"golden_code": "a,b,c,x,y = list(map(int,input().split()))\n\nprice = 10**10\n\nfor k in range(10**5+1):\n\n    re = 2*c*k + max(0,x-k)*a + max(0,y-k)*b\n\n    price = min(re,price)\n\nprint(price)", "generated_code": "a,b,c,x,y = list(map(int,input().split()))\n\na1 = a*x + b*y\n\na2 = max(x,y) * 2*c\n\nif y >= x:\n\n    a3 = 2*c*x + (y-x)*b\n\nelse:\n\n    a3 = 2*c*y + (x-y)*a\n\nprint((min(a1,a2,a3)))", "score": 1.0, "codebleu": 0.24307201683299928, "crystalbleu": 0.0, "codebertscore": 0.84, "codescore": 0.18286991119384766, "surfaceSim": 0.6299153055051421, "abs_surfaceSim_minus_score": 0.3700846944948579}
{"golden_code": "import sys\n\nimport numpy as np\n\n\n\nsr = lambda: sys.stdin.readline().rstrip()\n\nir = lambda: int(sr())\n\nlr = lambda: list(map(int, sr().split()))\n\n\n\nN = ir()\n\nA = np.array(lr())\n\nA = A[A%2==0].tolist()\n\nbool = True\n\nfor a in A:\n\n    if a%3 != 0 and a%5 != 0:\n\n        bool = False\n\n\n\nprint(('APPROVED' if bool else 'DENIED'))\n", "generated_code": "# coding: utf-8\n\nimport sys\n\n\n\nsr = lambda: sys.stdin.readline().rstrip()\n\nir = lambda: int(sr())\n\nlr = lambda: list(map(int, sr().split()))\n\n\n\nN = ir()\n\nA = lr()\n\nbl = all(x % 3 == 0 or x % 5 == 0 for x in A if x % 2 == 0)\n\nprint(('APPROVED' if bl else 'DENIED'))\n", "score": 1.0, "codebleu": 0.5014620306635333, "crystalbleu": 0.4928700427079986, "codebertscore": 0.89, "codescore": 0.4694461226463318, "surfaceSim": 0.7142857142857143, "abs_surfaceSim_minus_score": 0.2857142857142857}
{"golden_code": "import sys\n\nsys.setrecursionlimit(2147483647)\n\nINF=float(\"inf\")\n\nMOD=10**9+7\n\ninput=lambda :sys.stdin.readline().rstrip()\n\ndef resolve():\n\n    n,W=list(map(int,input().split()))\n\n    WV=[tuple(map(int,input().split())) for _ in range(n)]\n\n\n\n    V=100000\n\n    dp=[INF]*(V+1)\n\n    dp[0]=0\n\n\n\n    for w,v in WV:\n\n        for x in range(V,-1,-1):\n\n            if(x+v<=V):\n\n                dp[x+v]=min(dp[x+v],dp[x]+w)\n\n\n\n    for x in range(V,-1,-1):\n\n        if(dp[x]<=W):\n\n            print(x)\n\n            return\n\nresolve()", "generated_code": "import sys\n\nINF = 1 << 60\n\nMOD = 10**9 + 7 # 998244353\n\nsys.setrecursionlimit(2147483647)\n\ninput = lambda:sys.stdin.readline().rstrip()\n\ndef resolve():\n\n    n, W = list(map(int, input().split()))\n\n    dp = [INF] * (n * 1001 + 1)\n\n    dp[0] = 0\n\n    for _ in range(n):\n\n        w, v = list(map(int, input().split()))\n\n        for v0 in range(n * 1001, -1, -1):\n\n            if dp[v0] == INF:\n\n                continue\n\n            if v + v0 <= n * 1001:\n\n                dp[v + v0] = min(dp[v + v0], dp[v0] + w)\n\n    for v in range(n * 1001, -1, -1):\n\n        if dp[v] <= W:\n\n            print(v)\n\n            return\n\nresolve()", "score": 1.0, "codebleu": 0.32402816079808483, "crystalbleu": 0.5942410233603401, "codebertscore": 0.89, "codescore": 0.508742094039917, "surfaceSim": 0.7834993422289043, "abs_surfaceSim_minus_score": 0.21650065777109573}
{"golden_code": "def ii():return int(eval(input()))\n\ndef iim():return list(map(int,input().split()))\n\ndef iil():return list(map(int,input().split()))\n\ndef ism():return list(map(str,input().split()))\n\ndef isl():return list(map(str,input().split()))\n\n\n\nn = ii()\n\nD = iil()\n\nans = 0\n\nfor i in range(n):\n\n    for j in range(i+1,n):\n\n#        print(i,j)\n\n        ans += D[i]*D[j] \n\nprint(ans)", "generated_code": "def ii():return int(eval(input()))\n\ndef iim():return list(map(int,input().split()))\n\ndef iil():return list(map(int,input().split()))\n\ndef ism():return list(map(str,input().split()))\n\ndef isl():return list(map(str,input().split()))\n\n\n\nn = ii()\n\nD = iil()\n\nsumD = sum(D)\n\nans = 0\n\nfor i in range(n):\n\n    ans += D[i]*(sum(D)-D[i])\n\nprint((ans//2))", "score": 1.0, "codebleu": 0.7628122863783082, "crystalbleu": 0.7416060847549237, "codebertscore": 0.96, "codescore": 0.16221681237220764, "surfaceSim": 0.8996782496782496, "abs_surfaceSim_minus_score": 0.10032175032175039}
{"golden_code": "while 1:\n\n    ans=0\n\n    n,x=list(map(int,input().split()))\n\n    if n:\n\n        for i in range(1,n-1):\n\n            for j in range(i+1,n):\n\n                for k in range(j+1,n+1):\n\n                    if i+j+k==x:ans+=1\n\n    else:break\n\n    print(ans)", "generated_code": "while 1:\n\n    a=0\n\n    n,x=list(map(int,input().split()))\n\n    if n==0:break\n\n    for i in range(1,n-1):\n\n        for j in range(i+1,n):\n\n            c=x-i-j\n\n            if c>j and c<=n:a+=1\n\n    print(a)", "score": 1.0, "codebleu": 0.5798587799321157, "crystalbleu": 0.0, "codebertscore": 0.92, "codescore": 0.47693806886672974, "surfaceSim": 0.8134920634920635, "abs_surfaceSim_minus_score": 0.1865079365079365}
{"golden_code": "n = int(eval(input()))\n\nedges = []\n\n\n\nfor id in range(n-1):\n\n    a, b = list(map(int, input().split()))\n\n    edges.append([a-1, b-1, id])\n\n\n\nedges.sort()\n\n\n\nused = [0]*(n)\n\nans = [0]*(n-1)\n\nnum = 1\n\nprev = 0\n\nfor edge in edges:\n\n    _from, to, id = edge\n\n    if _from != prev:\n\n        num = 1\n\n    if used[_from] == num:\n\n        num += 1\n\n    ans[id] = num\n\n    used[to] = num\n\n    num += 1\n\n    prev = _from\n\n\n\nprint((max(ans)))\n\nfor color in ans:\n\n    print(color)\n", "generated_code": "import sys\n\ninput = sys.stdin.readline\n\n\n\nn = int(eval(input()))\n\nedges = []\n\n\n\nfor id in range(n-1):\n\n    a, b = list(map(int, input().split()))\n\n    edges.append([a-1, b-1, id])\n\n\n\nedges.sort()\n\n\n\nused = [0]*(n)\n\nans = [0]*(n-1)\n\nnum = 1\n\nprev = 0\n\nfor edge in edges:\n\n    _from, to, id = edge\n\n    if _from != prev:\n\n        num = 1\n\n    if used[_from] == num:\n\n        num += 1\n\n    ans[id] = num\n\n    used[to] = num\n\n    num += 1\n\n    prev = _from\n\n\n\nprint((max(ans)))\n\nfor color in ans:\n\n    print(color)\n", "score": 1.0, "codebleu": 0.8361913065320064, "crystalbleu": 0.8617974445251831, "codebertscore": 0.97, "codescore": 0.9938521385192871, "surfaceSim": 0.9257534246575343, "abs_surfaceSim_minus_score": 0.0742465753424657}
{"golden_code": "n = int(eval(input()))\n\nA = [int(i) for i in input().split()]\n\nS = [0]*(n+1)\n\nnum={}\n\nfor i in range(n):\n\n    S[i+1] = S[i] + A[i]\n\nfor i in S:\n\n    if str(i) in list(num.keys()):\n\n        num[str(i)] += 1\n\n    else:\n\n        num[str(i)] = 1\n\nout = [i*(i-1)//2 for i in list(num.values()) if i>1]\n\nprint((sum(out)))", "generated_code": "n = int(eval(input()))\n\nA = [int(i) for i in input().split()]\n\nS = [0]*(n+1)\n\nnum = {}\n\nfor i in range(n):\n\n    S[i+1] = S[i] + A[i]\n\nfor i in S:\n\n    s = str(i)\n\n    num[s] = 1 if s not in list(num.keys()) else num[s]+1\n\nout = [i*(i-1)//2 for i in list(num.values()) if i > 1]\n\nprint((sum(out)))", "score": 1.0, "codebleu": 0.7265674671348996, "crystalbleu": 0.8217024765419595, "codebertscore": 0.97, "codescore": 0.9928327798843384, "surfaceSim": 0.8456349206349206, "abs_surfaceSim_minus_score": 0.15436507936507937}
{"golden_code": "s = eval(input())\n\nt = eval(input())\n\nfor i in range(len(s)):\n\n        if s[i:]+s[:i]==t:\n\n                print('Yes')\n\n                exit()\n\nprint('No')", "generated_code": "s = eval(input())\n\nt = eval(input())\n\n\n\nfor i in range(len(s)):\n\n    s = s[1:] + s[0]\n\n    if s == t:\n\n        print(\"Yes\")\n\n        exit()\n\nprint(\"No\")", "score": 1.0, "codebleu": 0.6407178766430354, "crystalbleu": 0.0, "codebertscore": 0.95, "codescore": 0.9414380788803101, "surfaceSim": 0.9321266968325792, "abs_surfaceSim_minus_score": 0.0678733031674208}
{"golden_code": "import sys\n\n\n\nn, m, *lr = list(map(int, sys.stdin.read().split()))\n\nlr = list(zip(*[iter(lr)] * 2))\n\n\n\ndef main():\n\n    cnt = [0] * (n + 1)\n\n    for l, r in lr:\n\n        cnt[l-1] += 1\n\n        cnt[r] -= 1\n\n    \n\n    for i in range(n):\n\n        cnt[i+1] += cnt[i]\n\n    \n\n    res = 0\n\n    for i in range(n):\n\n        res += (cnt[i] == m) & 1\n\n    \n\n    return res\n\n\n\nif __name__ == '__main__':\n\n    ans = main()\n\n    print(ans)", "generated_code": "import sys\n\n\n\nn, m, *lr = list(map(int, sys.stdin.read().split()))\n\nl, r = lr[::2], lr[1::2]\n\n\n\ndef main():\n\n    ans = max(min(r) - max(l) + 1, 0)\n\n    return ans\n\n\n\nif __name__ == '__main__':\n\n    ans = main()\n\n    print(ans)", "score": 1.0, "codebleu": 0.30662618959757326, "crystalbleu": 0.2800354182309023, "codebertscore": 0.84, "codescore": 0.01949533075094223, "surfaceSim": 0.7303921568627452, "abs_surfaceSim_minus_score": 0.26960784313725483}
{"golden_code": "S=eval(input())\n\nprint((S.rfind('Z')-S.find('A')+1))", "generated_code": "s=input().strip()\n\na = s.find('A')\n\nz = s.rfind('Z')\n\nprint((z-a+1))\n", "score": 1.0, "codebleu": 0.36904761904761907, "crystalbleu": 0.0, "codebertscore": 0.9, "codescore": 0.31453460454940796, "surfaceSim": 0.7463768115942029, "abs_surfaceSim_minus_score": 0.2536231884057971}
{"golden_code": "import numpy as np\n\n\n\na = [list(map(int, input().split())) for _ in range(3)]\n\na = np.array(a)\n\nn = int(eval(input()))\n\n\n\nfor _ in range(n):\n\n    b = int(eval(input()))\n\n    \n\n    for j in range(3):\n\n        for i in range(3):\n\n            if a[j][i] == b:\n\n                a[j][i] = 0\n\n\n\nat = a.transpose()\n\nflag = False\n\nfor i in range(3):\n\n    if sum(a[:][i]) == 0 or sum(at[:][i]) == 0:\n\n        flag = True\n\n        break\n\ndiag = a[0][0] + a[1][1] + a[2][2]\n\ndiag2 = a[2][0] + a[1][1] + a[0][2]\n\nif diag == 0 or diag2 == 0:\n\n    flag = True\n\n\n\nprint((\"Yes\" if flag else \"No\"))", "generated_code": "a = [list(map(int, input().split())) for _ in range(3)]\n\nn = int(eval(input()))\n\nb = [int(eval(input())) for _ in range(n)]\n\n\n\nflag = False\n\nfor i in range(3):\n\n    if a[i][0] in b and a[i][1] in b and a[i][2] in b:\n\n        flag = True\n\n        break\n\n    if a[0][i] in b and a[1][i] in b and a[2][i] in b:\n\n        flag = True\n\n        break\n\nif a[0][0] in b and a[1][1] in b and a[2][2] in b:\n\n    flag = True\n\nif a[2][0] in b and a[1][1] in b and a[0][2] in b:\n\n    flag = True\n\n    \n\nprint((\"Yes\" if flag else \"No\"))", "score": 1.0, "codebleu": 0.3309127319675109, "crystalbleu": 0.656405177203806, "codebertscore": 0.86, "codescore": 0.7095048427581787, "surfaceSim": 0.6774956970740104, "abs_surfaceSim_minus_score": 0.32250430292598964}
{"golden_code": "n = int(eval(input()))\n\na = list(map(int, input().split()))\n\nD = {i: [0] for i in range(1, n+1)}\n\nfor i in range(n+1):\n\n  D[a[i]][0] += 1\n\n  D[a[i]].append(i)\n\npl, pr = 0, 0\n\nfor i in D:\n\n  if D[i][0] == 2:\n\n    pl = D[i][1]\n\n    pr = D[i][2]\n\n    break\n\nL = pl\n\nM = pr - pl - 1\n\nN = n - pr\n\nmod = int(1e9) + 7 # <-- input modulo\n\nmaxf = n+11          # <-- input factional limitation\n\n\n\ndef make_fact(n, k):\n\n    tmp = n\n\n    perm = [i for i in range(k)]\n\n    L = [0 for _ in range(k)]\n\n    for i in range(k):\n\n        L[i] = tmp % (i + 1)\n\n        tmp //= i + 1\n\n    LL = [0 for _ in range(k)]\n\n    for i in range(k):\n\n        LL[i] = perm[L[-i-1]]\n\n        for j in range(L[-i-1]+1, k):\n\n            perm[j-1] = perm[j]\n\n    return LL\n\n\n\ndef doubling(n, m, modulo=mod):\n\n    y = 1\n\n    base = n\n\n    tmp = m\n\n    while tmp != 0:\n\n        if tmp % 2 == 1:\n\n            y *= base\n\n            if modulo > 0:\n\n                y %= modulo\n\n        base *= base\n\n        if modulo > 0:\n\n            base %= modulo\n\n        tmp //= 2\n\n    return y\n\n\n\ndef inved(a, modulo=mod):\n\n    x, y, u, v, k, l = 1, 0, 0, 1, a, modulo\n\n    while l != 0:\n\n        x, y, u, v = u, v, x - u * (k // l), y - v * (k // l)\n\n        k, l = l, k % l\n\n    return x % modulo\n\n\n\nfact = [1 for _ in range(maxf+1)]\n\ninvf = [1 for _ in range(maxf+1)]\n\n\n\nfor i in range(maxf):\n\n    fact[i+1] = (fact[i] * (i+1)) % mod\n\ninvf[-1] = inved(fact[-1])\n\nfor i in range(maxf, 0, -1):\n\n    invf[i-1] = (invf[i] * i) % mod\n\n\n\nfor i in range(1, n+2):\n\n  S = fact[n]*invf[i-1]*invf[n-i+1]%mod\n\n  if i <= n-1:\n\n    S += fact[n-1]*invf[i]*invf[n-1-i]%mod\n\n    S %= mod\n\n  if i <= n-M:\n\n    S -= fact[n-1-M]*invf[i-1]*invf[n-M-i]%mod\n\n    S %= mod\n\n  if i <= n:\n\n    S += fact[n-1]*invf[i-1]*invf[n-i]%mod\n\n    S %= mod\n\n  print(S)", "generated_code": "n = int(eval(input()))\n\na = list(map(int, input().split()))\n\nD = {i: [0] for i in range(1, n+1)}\n\nfor i in range(n+1):\n\n  D[a[i]][0] += 1\n\n  D[a[i]].append(i)\n\npl, pr = 0, 0\n\nfor i in D:\n\n  if D[i][0] == 2:\n\n    pl = D[i][1]\n\n    pr = D[i][2]\n\n    break\n\nL = pl\n\nM = pr - pl - 1\n\nN = n - pr\n\nmod = int(1e9) + 7 # <-- input modulo\n\nmaxf = n+11          # <-- input factional limitation\n\n\n\ndef make_fact(n, k):\n\n    tmp = n\n\n    perm = [i for i in range(k)]\n\n    L = [0 for _ in range(k)]\n\n    for i in range(k):\n\n        L[i] = tmp % (i + 1)\n\n        tmp //= i + 1\n\n    LL = [0 for _ in range(k)]\n\n    for i in range(k):\n\n        LL[i] = perm[L[-i-1]]\n\n        for j in range(L[-i-1]+1, k):\n\n            perm[j-1] = perm[j]\n\n    return LL\n\n\n\ndef doubling(n, m, modulo=mod):\n\n    y = 1\n\n    base = n\n\n    tmp = m\n\n    while tmp != 0:\n\n        if tmp % 2 == 1:\n\n            y *= base\n\n            if modulo > 0:\n\n                y %= modulo\n\n        base *= base\n\n        if modulo > 0:\n\n            base %= modulo\n\n        tmp //= 2\n\n    return y\n\n\n\ndef inved(a, modulo=mod):\n\n    x, y, u, v, k, l = 1, 0, 0, 1, a, modulo\n\n    while l != 0:\n\n        x, y, u, v = u, v, x - u * (k // l), y - v * (k // l)\n\n        k, l = l, k % l\n\n    return x % modulo\n\n\n\nfact = [1 for _ in range(maxf+1)]\n\ninvf = [1 for _ in range(maxf+1)]\n\n\n\nfor i in range(maxf):\n\n    fact[i+1] = (fact[i] * (i+1)) % mod\n\ninvf[-1] = inved(fact[-1])\n\nfor i in range(maxf, 0, -1):\n\n    invf[i-1] = (invf[i] * i) % mod\n\n\n\nfor i in range(1, n+2):\n\n  S = fact[n+1]*invf[i]*invf[n-i+1]%mod\n\n  if i <= n-M:\n\n    S -= fact[n-1-M]*invf[i-1]*invf[n-M-i]%mod\n\n    S %= mod\n\n  print(S)\n", "score": 1.0, "codebleu": 0.919362408664107, "crystalbleu": 0.8860239572969915, "codebertscore": 0.99, "codescore": 0.9935855269432068, "surfaceSim": 0.9694848824188129, "abs_surfaceSim_minus_score": 0.03051511758118708}
{"golden_code": "K,S = list(map(int,input().split(\" \")))\n\nans = 0\n\nfor i in range(K+1):\n\n\tfor j in range(K+1):\n\n\t\tif (S - i - j) <= K and (S-i-j) >= 0:\n\n\t\t\tans += 1\n\n\n\nprint(ans)\n", "generated_code": "K, S = list(map(int,input().split(\" \")))\n\nans = 0\n\nfor X in range(K+1):\n\n    for Y in range(K+1):\n\n        if 0 <= (S - X - Y) <= K:\n\n            ans += 1\n\n\n\nprint(ans)", "score": 1.0, "codebleu": 0.6038621847558385, "crystalbleu": 0.42987053188505947, "codebertscore": 0.95, "codescore": 0.8513803482055664, "surfaceSim": 0.8779761904761905, "abs_surfaceSim_minus_score": 0.12202380952380953}
{"golden_code": "from numpy import*\n\na,b=median(t:=loadtxt(open(0),skiprows=1),0)\n\nprint((int((a-b)*~(~len(t)%2))+1))", "generated_code": "from statistics import*\n\n(n,),*t=[list(map(int,t.split()))for t in open(0)]\n\na,b=list(map(median,list(zip(*t))))\n\nprint((int((b-a)*(2-n%2))+1))", "score": 1.0, "codebleu": 0.24364115598855923, "crystalbleu": 0.0, "codebertscore": 0.84, "codescore": 0.9283572435379028, "surfaceSim": 0.5466200466200466, "abs_surfaceSim_minus_score": 0.4533799533799534}
{"golden_code": "import sys\n\nimport numpy as np\n\n\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\nBsize = 700\n\n\n\ndef Mo_argsort(LR):\n\n    L = LR[:, 0]\n\n    R = LR[:, 1]\n\n    key1 = L // Bsize\n\n    key2 = np.where(key1 & 1, -R, R)\n\n    key = (key1 << 32) + key2\n\n    return np.argsort(key)\n\n\n\ndef main(A, LR):\n\n    N = len(A)\n\n    Q = len(LR)\n\n    ind = Mo_argsort(LR)\n\n    count = np.zeros(N + 1, np.int64)\n\n    ans = 0\n\n\n\n    def add(x):\n\n        nonlocal ans\n\n        if not count[x]:\n\n            ans += 1\n\n        count[x] += 1\n\n\n\n    def rem(x):\n\n        nonlocal ans\n\n        count[x] -= 1\n\n        if not count[x]:\n\n            ans -= 1\n\n\n\n    answers = np.empty(Q, np.int64)\n\n    nl, nr = 0, 0\n\n    for i in ind:\n\n        l, r = LR[i]\n\n        l -= 1\n\n        # 区間 [l, r) に対する計算\n\n        while nl > l:\n\n            nl -= 1\n\n            add(A[nl])\n\n        while nr < r:\n\n            add(A[nr])\n\n            nr += 1\n\n        while nl < l:\n\n            rem(A[nl])\n\n            nl += 1\n\n        while nr > r:\n\n            nr -= 1\n\n            rem(A[nr])\n\n        #  答を求めて ans[i] に格納する\n\n        answers[i] = ans\n\n    return answers\n\n\n\nif sys.argv[-1] == 'ONLINE_JUDGE':\n\n    import numba\n\n    from numba.pycc import CC\n\n    i4 = numba.int32\n\n    i8 = numba.int64\n\n    cc = CC('my_module')\n\n\n\n    def cc_export(f, signature):\n\n        cc.export(f.__name__, signature)(f)\n\n        return numba.njit(f)\n\n\n\n    Mo_argsort = cc_export(Mo_argsort, (i8[:,:],))\n\n    main = cc_export(main, (i8[:], i8[:, :]))\n\n    cc.compile()\n\n\n\nfrom my_module import main\n\n\n\nN, Q = list(map(int, readline().split()))\n\nA = np.array(readline().split(), np.int64)\n\nLR = np.array(read().split(), np.int64).reshape(Q, 2)\n\n\n\nans = main(A, LR)\n\nprint(('\\n'.join(map(str, ans.tolist()))))", "generated_code": "import sys\n\nimport numpy as np\n\n\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\nBsize = 1000\n\n\n\ndef Mo_argsort(LR):\n\n    L = LR[:, 0]\n\n    R = LR[:, 1]\n\n    key1 = L // Bsize\n\n    key2 = np.where(key1 & 1, -R, R)\n\n    key = (key1 << 32) + key2\n\n    return np.argsort(key)\n\n\n\ndef main(A, LR):\n\n    N = len(A)\n\n    Q = len(LR)\n\n    ind = Mo_argsort(LR)\n\n    count = np.zeros(N + 1, np.int64)\n\n    ans = 0\n\n\n\n    def add(x):\n\n        nonlocal ans\n\n        if not count[x]:\n\n            ans += 1\n\n        count[x] += 1\n\n\n\n    def rem(x):\n\n        nonlocal ans\n\n        count[x] -= 1\n\n        if not count[x]:\n\n            ans -= 1\n\n\n\n    answers = np.empty(Q, np.int64)\n\n    nl, nr = 0, 0\n\n    for i in ind:\n\n        l, r = LR[i]\n\n        l -= 1\n\n        # 区間 [l, r) に対する計算\n\n        while nl > l:\n\n            nl -= 1\n\n            add(A[nl])\n\n        while nr < r:\n\n            add(A[nr])\n\n            nr += 1\n\n        while nl < l:\n\n            rem(A[nl])\n\n            nl += 1\n\n        while nr > r:\n\n            nr -= 1\n\n            rem(A[nr])\n\n        #  答を求めて ans[i] に格納する\n\n        answers[i] = ans\n\n    return answers\n\n\n\nif sys.argv[-1] == 'ONLINE_JUDGE':\n\n    import numba\n\n    from numba.pycc import CC\n\n    i4 = numba.int32\n\n    i8 = numba.int64\n\n    cc = CC('my_module')\n\n\n\n    def cc_export(f, signature):\n\n        cc.export(f.__name__, signature)(f)\n\n        return numba.njit(f)\n\n\n\n    Mo_argsort = cc_export(Mo_argsort, (i8[:,:],))\n\n    main = cc_export(main, (i8[:], i8[:, :]))\n\n    cc.compile()\n\n\n\nfrom my_module import main\n\n\n\nN, Q = list(map(int, readline().split()))\n\nA = np.array(readline().split(), np.int64)\n\nLR = np.array(read().split(), np.int64).reshape(Q, 2)\n\n\n\nans = main(A, LR)\n\nprint(('\\n'.join(map(str, ans.tolist()))))\n", "score": 1.0, "codebleu": 0.994432375556713, "crystalbleu": 0.9930883541538292, "codebertscore": 1.0, "codescore": 0.9938156604766846, "surfaceSim": 0.9994472084024323, "abs_surfaceSim_minus_score": 0.0005527915975677145}
{"golden_code": "import sys\n\ndef main():\n\n    input = sys.stdin.readline\n\n    N = int(eval(input()))\n\n    E = [[] for _ in range(N)]\n\n    for i in range(N-1):\n\n        a, b = list(map(int, input().split()))\n\n        a, b = a-1, b-1\n\n        E[a].append((b,i))\n\n        E[b].append((a,i))\n\n    \n\n    def dfs(s, g):\n\n        par = [(-1,-1)] * N\n\n        par[s] = (s,-1)\n\n        stack = [s]\n\n        while stack:\n\n            v = stack.pop()\n\n            for to, i in E[v]:\n\n                if par[to][0] >= 0: continue\n\n                par[to] = (v, i)\n\n                if to == g: break\n\n                stack.append(to)\n\n        r = set()\n\n        v = g\n\n        while v != s:\n\n            v, i = par[v]\n\n            r.add(i)\n\n        return r\n\n    \n\n    M = int(eval(input()))\n\n    path = [None] * M\n\n    for i in range(M):\n\n        u, v = list(map(int, input().split()))\n\n        u, v = u-1, v-1\n\n        path[i] = dfs(u, v)\n\n\n\n    def calc(s): return 1<<(N-1-len(s))\n\n\n\n    i_ans = 0\n\n    for p in range(1, 1<<M):\n\n        is_odd = bin(p).count('1') & 1\n\n        s = set()\n\n        for i in range(M):\n\n            if p&1: s |= path[i]\n\n            p >>= 1\n\n        if is_odd: i_ans += calc(s)\n\n        else: i_ans -= calc(s)\n\n\n\n    print(((1<<(N-1)) - i_ans))\n\n\n\nif __name__ == '__main__':\n\n    main()", "generated_code": "import sys\n\ndef main():\n\n    input = sys.stdin.readline\n\n    N = int(eval(input()))\n\n    E = [[] for _ in range(N)]\n\n    for i in range(N-1):\n\n        a, b = list(map(int, input().split()))\n\n        a, b = a-1, b-1\n\n        E[a].append((b,i))\n\n        E[b].append((a,i))\n\n    \n\n    def dfs(s, g):\n\n        par = [(-1,-1)] * N\n\n        par[s] = (s,-1)\n\n        stack = [s]\n\n        while stack:\n\n            v = stack.pop()\n\n            for to, i in E[v]:\n\n                if par[to][0] >= 0: continue\n\n                par[to] = (v, i)\n\n                if to == g: break\n\n                stack.append(to)\n\n        r = set()\n\n        v = g\n\n        while v != s:\n\n            v, i = par[v]\n\n            r.add(i)\n\n        return r\n\n    \n\n    M = int(eval(input()))\n\n    path = [None] * M\n\n    for i in range(M):\n\n        u, v = list(map(int, input().split()))\n\n        u, v = u-1, v-1\n\n        path[i] = dfs(u, v)\n\n\n\n    def calc(s): return 1<<(N-1-len(s))\n\n\n\n    i_ans = 0\n\n    for p in range(1, 1<<M):\n\n        is_odd = 0\n\n        s = set()\n\n        for i in range(M):\n\n            if p&1:\n\n                s |= path[i]\n\n                is_odd ^= 1\n\n            p >>= 1\n\n        if is_odd: i_ans += calc(s)\n\n        else: i_ans -= calc(s)\n\n\n\n    print(((1<<(N-1)) - i_ans))\n\n\n\nif __name__ == '__main__':\n\n    main()", "score": 1.0, "codebleu": 0.9568097751262357, "crystalbleu": 0.9531004729642536, "codebertscore": 0.99, "codescore": 0.9922886490821838, "surfaceSim": 0.9766797129810829, "abs_surfaceSim_minus_score": 0.023320287018917085}
{"golden_code": "N, W = list(map(int, input().split()))\n\nitems = sorted([list(map(int, input().split())) for i in range(N)])\n\n\n\n# dp1[i][j] := 商品0 ~ i が対象\n\ndp = [[0] * (W + 1) for i in range(N + 1)]\n\n\n\n# dpテーブルを埋める\n\nfor i in range(N):\n\n    wi, vi = items[i]\n\n    for j in range(W + 1):\n\n        if j + wi <= W:\n\n            dp[i + 1][j + wi] = max(dp[i + 1][j + wi], dp[i][j] + vi)\n\n        dp[i + 1][j] = max(dp[i][j], dp[i + 1][j])\n\n\n\n\n\nans = 0\n\nfor i, (wi, vi) in enumerate(items):\n\n    for j in range(W):\n\n        ans = max(ans, dp[i][j] + vi)\n\n\n\nprint(ans)\n", "generated_code": "N, W = list(map(int, input().split()))\n\nitems = sorted([list(map(int, input().split())) for i in range(N)])\n\n\n\n# dp1[i][j] := 商品0 ~ i が対象\n\ndp = [[0] * (W + 1) for i in range(N + 1)]\n\n\n\n# dpテーブルを埋める\n\nfor i in range(N):\n\n    wi, vi = items[i]\n\n    for j in range(W + 1):\n\n        if j + wi <= W:\n\n            dp[i + 1][j + wi] = max(dp[i + 1][j + wi], dp[i][j] + vi)\n\n        dp[i + 1][j] = max(dp[i][j], dp[i + 1][j])\n\n\n\n\n\nans = 0\n\nfor i, (wi, vi) in enumerate(items):\n\n    ans = max(ans, dp[i][W - 1] + vi)\n\n\n\nprint(ans)\n", "score": 1.0, "codebleu": 0.9227180449026888, "crystalbleu": 0.9405429918970332, "codebertscore": 0.99, "codescore": 0.9938456416130066, "surfaceSim": 0.9608296769046669, "abs_surfaceSim_minus_score": 0.03917032309533308}
{"golden_code": "a,b,c,x,y=list(map(int,input().split()))\n\nans=a*x+b*y\n\nfor HaH in range(0,2*max(x,y)+1,2):\n\n    ans = min(ans, c*HaH+max(0, a*(x-HaH//2))+max(0, b*(y-HaH//2)))\n\nprint(ans)", "generated_code": "a,b,c,x,y=list(map(int,input().split()))\n\nans=0\n\nm=min(x,y)\n\nif a+b>=2*c: #Half and Half購入で安くなる可能性あるパターン\n\n    # HaHをm枚買って残りHaH購入,または全部HaH購入,このいずれかしかあり得ない\n\n    ans = min(2*c*m+a*(x-m)+b*(y-m), 2*c*max(x,y))\n\nelse:\n\n    ans = a*x+b*y\n\nprint(ans)", "score": 1.0, "codebleu": 0.29557257681577, "crystalbleu": 0.520929876533342, "codebertscore": 0.79, "codescore": 0.23209752142429352, "surfaceSim": 0.7058696123023609, "abs_surfaceSim_minus_score": 0.2941303876976391}
{"golden_code": "import numpy as np\n\nN,M=list(map(int, input().split()))\n\nhuman=[]\n\nfor i in range(N):\n\n  a,b=list(map(int, input().split()))\n\n  human.append((a,b))\n\nC=[]\n\nfor i in range(M):\n\n  c,d=list(map(int, input().split()))\n\n  C.append((c,d))\n\n  \n\nfor h in human:\n\n  a,b=h\n\n  now=0\n\n  mini=np.inf\n\n  for i,ch in enumerate(C):\n\n    c,d=ch\n\n    L=abs(a-c)+abs(b-d)\n\n    if mini>L:\n\n      mini=L\n\n      now=i+1\n\n  print(now)", "generated_code": "N,M=list(map(int, input().split()))\n\nS=[]\n\nfor i in range(N):\n\n    a,b=list(map(int, input().split()))\n\n    S.append((a,b))\n\n\n\nC=[]\n\nfor i in range(M):\n\n    c,d=list(map(int, input().split()))\n\n    C.append((c,d,i+1))\n\n#print(C)\n\nfor s in S:\n\n    a,b=s\n\n    now=0\n\n    dis=10**9\n\n\n\n    for t in C:\n\n        c,d,n=t\n\n        D=abs(c-a)+abs(d-b)\n\n        \n\n        if D<dis:\n\n            dis=D\n\n            now=n\n\n    print(now)", "score": 1.0, "codebleu": 0.5013610159052655, "crystalbleu": 0.5271492880998471, "codebertscore": 0.9, "codescore": 0.9920123219490051, "surfaceSim": 0.7901195049082372, "abs_surfaceSim_minus_score": 0.20988049509176276}
{"golden_code": "import numpy as np\n\nN = int(eval(input()))\n\nabc = []\n\nfor i in range(N):\n\n    abc.append(list(map(int, input().split())))\n\n    \n\ndp = np.zeros(shape=(N, 3), dtype=int)\n\ndp[0, :] = abc[0]\n\nfor i in range(N-1):\n\n    dp[i+1, 0] = max(dp[i+1, 0], dp[i, 1] + abc[i+1][0], dp[i, 2] + abc[i+1][0])\n\n    dp[i+1, 1] = max(dp[i+1, 1], dp[i, 0] + abc[i+1][1], dp[i, 2] + abc[i+1][1])\n\n    dp[i+1, 2] = max(dp[i+1, 2], dp[i, 0] + abc[i+1][2], dp[i, 1] + abc[i+1][2])\n\nprint((max(dp[N-1, :])))", "generated_code": "N = int(eval(input()))\n\nabc = []\n\nfor i in range(N):\n\n    data = list(map(int, input().split()))\n\n    abc.append(data)\n\n\n\ndp = [[0 for i in range(3)] for j in range(N)]\n\ndp[0][0] = abc[0][0]\n\ndp[0][1] = abc[0][1]\n\ndp[0][2] = abc[0][2]\n\n\n\nfor i in range(N-1):\n\n    for j in range(3):\n\n        if j == 0:\n\n            dp[i+1][1] = max(dp[i][0] + abc[i+1][1], dp[i+1][1])\n\n            dp[i+1][2] = max(dp[i][0] + abc[i+1][2], dp[i+1][2])\n\n        if j == 1:\n\n            dp[i+1][0] = max(dp[i][1] + abc[i+1][0], dp[i+1][0])\n\n            dp[i+1][2] = max(dp[i][1] + abc[i+1][2], dp[i+1][2])\n\n        if j == 2:\n\n            dp[i+1][1] = max(dp[i][2] + abc[i+1][1], dp[i+1][1])\n\n            dp[i+1][0] = max(dp[i][2] + abc[i+1][0], dp[i+1][0])\n\n\n\nprint((max(dp[N-1])))", "score": 1.0, "codebleu": 0.31765678630399047, "crystalbleu": 0.4803360304723532, "codebertscore": 0.92, "codescore": 0.6426865458488464, "surfaceSim": 0.6075675938061259, "abs_surfaceSim_minus_score": 0.3924324061938741}
{"golden_code": "class SegmentTree():\n\n    \"\"\"\n\n    update, get を提供するSegmentTree\n\n\n\n    Attributes\n\n    ----------\n\n    __n : int\n\n        葉の数。2 ^ i - 1\n\n    __dot :\n\n        Segment function\n\n    __e: int\n\n        単位元\n\n    __node: list\n\n        Segment Tree\n\n    \"\"\"\n\n    def __init__(self, A, dot, e):\n\n        \"\"\"\n\n        Parameters\n\n        ----------\n\n        A : list\n\n            対象の配列\n\n        dot :\n\n            Segment function\n\n        e : int\n\n            単位元\n\n        \"\"\"\n\n        n = 2 ** (len(A) - 1).bit_length()\n\n        self.__n = n\n\n        self.__dot = dot\n\n        self.__e = e\n\n        self.__node = [e] * (2 * n)\n\n        for i in range(len(A)):\n\n            self.__node[i + n] = A[i]\n\n        for i in range(n - 1, 0, -1):\n\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[2 * i + 1])\n\n    \n\n    def update(self, i, c):\n\n        i += self.__n\n\n        node = self.__node\n\n        node[i] = c\n\n        while i > 1:\n\n            i //= 2\n\n            node[i] = self.__dot(node[2 * i], node[2 * i + 1])\n\n\n\n    def get(self, l, r):\n\n        vl, vr = self.__e, self.__e\n\n        l += self.__n\n\n        r += self.__n\n\n        while (l < r):\n\n            if l & 1:\n\n                vl = self.__dot(vl, self.__node[l])\n\n                l += 1\n\n            l //= 2\n\n            if r & 1:\n\n                r -= 1\n\n                vr = self.__dot(vr, self.__node[r])\n\n            r //= 2\n\n        return self.__dot(vl, vr)\n\n\n\n\n\nN, K = list(map(int, input().split()))\n\nA = [int(eval(input())) for _ in range(N)]\n\nmax_A = max(A)\n\n\n\nst = SegmentTree([N] * (max_A + 1), min, N)\n\nedge = [set() for _ in range(N)]\n\nfor i, a in enumerate(reversed(A)):\n\n    j = N - 1 - i\n\n    p1 = st.get(a, min(max_A + 1, a + K + 1))\n\n    if p1 < N:\n\n        edge[j].add(p1)\n\n    p2 = st.get(max(0, a - K), a)\n\n    if p2 < N:\n\n        edge[j].add(p2)\n\n    p0 = st.get(a, a + 1)\n\n    if p0 < N:\n\n        edge[j].add(p0)\n\n    st.update(a, j)\n\n\n\ndp = [1] * N\n\nfor i in range(N - 1):\n\n    here = dp[i]\n\n    for ni in edge[i]:\n\n        if ni < N:\n\n            dp[ni] = max(dp[ni], dp[i] + 1)\n\n\n\nprint((max(dp)))\n", "generated_code": "class SegmentTree():\n\n    \"\"\"\n\n    update, get を提供するSegmentTree\n\n\n\n    Attributes\n\n    ----------\n\n    __n : int\n\n        葉の数。2 ^ i - 1\n\n    __dot :\n\n        Segment function\n\n    __e: int\n\n        単位元\n\n    __node: list\n\n        Segment Tree\n\n    \"\"\"\n\n    def __init__(self, A, dot, e):\n\n        \"\"\"\n\n        Parameters\n\n        ----------\n\n        A : list\n\n            対象の配列\n\n        dot :\n\n            Segment function\n\n        e : int\n\n            単位元\n\n        \"\"\"\n\n        n = 2 ** (len(A) - 1).bit_length()\n\n        self.__n = n\n\n        self.__dot = dot\n\n        self.__e = e\n\n        self.__node = [e] * (2 * n)\n\n        for i in range(len(A)):\n\n            self.__node[i + n] = A[i]\n\n        for i in range(n - 1, 0, -1):\n\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[2 * i + 1])\n\n    \n\n    def update(self, i, c):\n\n        i += self.__n\n\n        node = self.__node\n\n        node[i] = c\n\n        while i > 1:\n\n            i //= 2\n\n            node[i] = self.__dot(node[2 * i], node[2 * i + 1])\n\n\n\n    def get(self, l, r):\n\n        vl, vr = self.__e, self.__e\n\n        l += self.__n\n\n        r += self.__n\n\n        while (l < r):\n\n            if l & 1:\n\n                vl = self.__dot(vl, self.__node[l])\n\n                l += 1\n\n            l //= 2\n\n            if r & 1:\n\n                r -= 1\n\n                vr = self.__dot(vr, self.__node[r])\n\n            r //= 2\n\n        return self.__dot(vl, vr)\n\n\n\n\n\nN, K = list(map(int, input().split()))\n\nA = [int(eval(input())) for _ in range(N)]\n\nmax_A = max(A)\n\n\n\nst = SegmentTree([N] * (max_A + 1), min, N)\n\nedge = [set() for _ in range(N)]\n\nfor i, a in enumerate(reversed(A)):\n\n    j = N - 1 - i\n\n    p1 = st.get(a, min(max_A + 1, a + K + 1))\n\n    if p1 < N:\n\n        edge[j].add(p1)\n\n    p2 = st.get(max(0, a - K), a)\n\n    if p2 < N:\n\n        edge[j].add(p2)\n\n    st.update(a, j)\n\n\n\ndp = [1] * N\n\nfor i in range(N - 1):\n\n    here = dp[i]\n\n    for ni in edge[i]:\n\n        if ni < N:\n\n            dp[ni] = max(dp[ni], dp[i] + 1)\n\n\n\nprint((max(dp)))\n", "score": 1.0, "codebleu": 0.9497343170429732, "crystalbleu": 0.9514438471742339, "codebertscore": 0.99, "codescore": 0.9799550175666809, "surfaceSim": 0.9902520209224916, "abs_surfaceSim_minus_score": 0.00974797907750835}
{"golden_code": "from functools import reduce\n\nfrom itertools import product\n\n\n\nN = int(eval(input()))\n\n*A, = list(map(int, input().split()))\n\nans = 0\n\nfor t in product([-1, 0, 1], repeat=N):\n\n    prod = reduce(lambda x, y: x*y, [a + t[i] for i, a in enumerate(A)])\n\n    if prod % 2 == 0: ans += 1\n\nprint(ans)", "generated_code": "N = int(eval(input()))\n\n*A, = list(map(int, input().split()))\n\nevens = 0\n\nfor a in A:\n\n    if a % 2 == 0: evens += 1\n\nans = 3**N - 2**evens\n\nprint(ans)", "score": 1.0, "codebleu": 0.3160169837524915, "crystalbleu": 0.0, "codebertscore": 0.82, "codescore": 0.1503193974494934, "surfaceSim": 0.5162915851272015, "abs_surfaceSim_minus_score": 0.4837084148727985}
{"golden_code": "import re;print((max(list(map(len,re.split('[^ACGT]',eval(input())))))))", "generated_code": "p=m=0\n\nfor c in eval(input()):p=-~p*(c in'ATGC');m=max(m,p)\n\nprint(m)", "score": 1.0, "codebleu": 0.18452380952380953, "crystalbleu": 0.0, "codebertscore": 0.74, "codescore": 0.9424779415130615, "surfaceSim": 0.25511695906432746, "abs_surfaceSim_minus_score": 0.7448830409356726}
{"golden_code": "import numpy as np\n\n\n\nX, Y, Z, K = list(map(int, input().split()))\n\nA = np.array([int(i) for i in input().split()])\n\nB = np.array([int(i) for i in input().split()])\n\nC =np.array([int(i) for i in input().split()])\n\nA = -np.sort(-A) #要チェックや\n\nB = -np.sort(-B)\n\nC = -np.sort(-C)\n\nD = []\n\nfor i in range(min(K, X)):\n\n    for j in range(min(K, Y)):\n\n        if (i + 1) * (j + 1) > K:\n\n            break\n\n        for k in range(min(K, Z)):\n\n            if (i + 1) * (j + 1) * (k + 1) > K:\n\n                break\n\n            else:\n\n\n\n                D.append(A[i] + B[j] + C[k])\n\n\n\nX = np.array(D)\n\nX = -np.sort(-X)\n\nfor i in range(K):\n\n    print((X[i]))", "generated_code": "import queue\n\nimport sys\n\nsys.setrecursionlimit(10**7)\n\nn = int(eval(input()))\n\n\n\nabc = [[] for i in range(n+1)]\n\n\n\nfor i in range(n-1):\n\n    a,b,c = list(map(int,input().split()))\n\n    abc[a].append([b,c])\n\n    abc[b].append([a,c])\n\n\n\nQ,k = list(map(int,input().split()))\n\nxy = [[int(i) for i in input().split()] for j in range(Q)]\n\n\n\nq = queue.Queue()\n\n\n\nq.put(k)\n\n\n\npath = [-1]*(n+1)\n\npath[k] = 0\n\n\n\ndef dfs(p):\n\n    for i in range(len(abc[p])):\n\n        num = abc[p][i][0]\n\n        if path[num] != -1:\n\n            continue\n\n        else:\n\n            path[num] = path[p] + abc[p][i][1]\n\n            dfs(num)\n\n\n\ndfs(k)\n\n\n\nfor i in range(Q):\n\n    print((path[xy[i][0]]+path[xy[i][1]]))", "score": 0.0, "codebleu": 0.24428269164444832, "crystalbleu": 0.14579776923982055, "codebertscore": 0.77, "codescore": 0.9130517244338989, "surfaceSim": 0.5987517099863202, "abs_surfaceSim_minus_score": 0.5987517099863202}
{"golden_code": "def popcount(x):\n\n  r = 0\n\n  while x:\n\n    if x & 1:\n\n      r += 1\n\n    x >>= 1\n\n  return r\n\n\n\nn = int(eval(input()))\n\nr = list(range(n))\n\na = [[0, 0] for _ in r]\n\nfor i in r:\n\n  for _ in range(int(eval(input()))):\n\n    x, y = list(map(int, input().split()))\n\n    a[i][y] |= 1 << (x - 1)\n\n\n\nm = 0\n\nl = (1 << n) - 1\n\nfor x in range(1, l + 1):\n\n  if all(a[i][0] & x == a[i][1] & l - x == 0 for i in r if x >> i & 1):\n\n    m = max(m, popcount(x))\n\nprint(m)\n", "generated_code": "from collections import deque, Counter\n\n\n\ndef main():\n\n    with open(0) as f:\n\n        H, W = list(map(int, f.readline().split()))\n\n        maze = [list(line) for line in f.readlines()]\n\n\n\n    rank = [[None]*W for _ in range(H)]\n\n    rank[0][0] = 0\n\n    #bfs\n\n    reserved = deque([(0,0)])\n\n    while len(reserved) > 0:\n\n        x, y = reserved.popleft()\n\n        for u,v in [(s,t) for s,t in [(x-1,y), (x+1,y), (x,y-1), (x,y+1)] if 0<=s<H and 0<=t<W]:\n\n            if rank[u][v] is not None:\n\n                continue\n\n            if maze[u][v] == '.':\n\n                rank[u][v] = rank[x][y] + 1\n\n                reserved.append((u,v))\n\n\n\n    if rank[H-1][W-1] is None:\n\n        print((-1))\n\n    else:\n\n        counter = Counter()\n\n        for line in maze:\n\n            counter.update(line)\n\n        print((counter['.'] - rank[H-1][W-1]-1))\n\n\n\nmain()", "score": 0.0, "codebleu": 0.1437315113600865, "crystalbleu": 0.09314298958722353, "codebertscore": 0.73, "codescore": 0.9460538029670715, "surfaceSim": 0.5016344652615145, "abs_surfaceSim_minus_score": 0.5016344652615145}
{"golden_code": "import numpy as np\n\n\n\nN, K= list(map(int, input().split()))\n\np = np.array(list(map(int, input().split())))\n\n\n\ntmp = np.sum(p[:K])\n\nmax = tmp\n\nfor i in range(N-K):\n\n    tmp = tmp-p[i]+p[i+K]\n\n    if tmp>max:\n\n        max = tmp\n\n\n\nprint(((max+K)/2))", "generated_code": "from collections import deque\n\nK = int(eval(input()))\n\nG = [[] for i in range(K)]\n\nfor i in range(K):\n\n    G[i].append(((10 * i) % K, 0))\n\n    G[i].append(((i + 1) % K, 1))\n\n\n\ndist = [float('inf')] * K\n\ndist[1] = 1\n\nque = deque()\n\nque.append(1)\n\n\n\nwhile que:\n\n    n = que.pop()\n\n    for v, c in G[n]:\n\n        if dist[v] > dist[n] + c:\n\n            dist[v] = dist[n] + c\n\n            if c == 0:\n\n                que.append(v)\n\n            else:\n\n                que.appendleft(v)\n\n\n\nprint((dist[0]))\n", "score": 0.0, "codebleu": 0.1779868931645621, "crystalbleu": 0.04741939591998809, "codebertscore": 0.72, "codescore": 0.8252364993095398, "surfaceSim": 0.5514516129032259, "abs_surfaceSim_minus_score": 0.5514516129032259}
{"golden_code": "# 2019-11-12 22:21:08(JST)\n\nimport sys\n\n# import collections\n\n# import math\n\n# from string import ascii_lowercase, ascii_uppercase, digits\n\n# from bisect import bisect_left as bi_l, bisect_right as bi_r\n\nimport itertools\n\n# from functools import reduce\n\n# import operator as op\n\n# from scipy.misc import comb # float\n\n# import numpy as np \n\n\n\ndef main():\n\n    s = sys.stdin.readline().rstrip()\n\n    \n\n    all_words = []\n\n    for i in range(1, len(s) + 1):\n\n        for letters in itertools.product('ATCG', repeat=i):\n\n            word = ''.join(letters)\n\n            all_words.append(word)\n\n    \n\n    for i in range(len(all_words)-1, 0-1, -1):\n\n        if all_words[i] in s:\n\n            print((len(all_words[i])))\n\n            sys.exit()\n\n    print((0))\n\n\n\n\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "generated_code": "import sys\n\ninput = sys.stdin.readline\n\n\n\ndef solve():\n\n    INF = 10**10\n\n\n\n    N, M = list(map(int, input().split()))\n\n    keys = []\n\n    costs = []\n\n    for _ in range(M):\n\n        a, b = list(map(int, input().split()))\n\n        costs.append(a)\n\n        cs = list(map(int, input().split()))\n\n        key = 0\n\n        for c in cs:\n\n            key |= 1<<(c-1)\n\n        keys.append(key)\n\n\n\n    dp = [INF] * (1<<N)\n\n    dp[0] = 0\n\n    for S in range(1<<N):\n\n        for key, cost in zip(keys, costs):\n\n            S2 = S | key\n\n            c2 = dp[S] + cost\n\n            if c2 < dp[S2]:\n\n                dp[S2] = c2\n\n\n\n    if dp[-1] == INF:\n\n        print((-1))\n\n    else:\n\n        print((dp[-1]))\n\n\n\n\n\nsolve()\n", "score": 0.0, "codebleu": 0.22917293495824226, "crystalbleu": 0.06362232618130698, "codebertscore": 0.68, "codescore": 0.8575340509414673, "surfaceSim": 0.6739982418870413, "abs_surfaceSim_minus_score": 0.6739982418870413}
{"golden_code": "import sys\n\nfrom operator import itemgetter\n\nfrom heapq import heapify, heappop, heappush\n\nMAX_INT = int(10e15)\n\nMIN_INT = -MAX_INT\n\nmod = 1000000007\n\nsys.setrecursionlimit(1000000)\n\ndef IL(): return list(map(int,input().split()))\n\ndef SL(): return input().split()\n\ndef I(): return int(sys.stdin.readline())\n\ndef S(): return eval(input())\n\n\n\nN, T = IL()\n\nab = [IL() for i in range(N)]\n\nab.sort(key=itemgetter(0))\n\n#print(ab)\n\n\n\ndp = [[0]*(T+1+3000+1) for _ in range(N+1)]\n\nans = 0\n\nfor i in range(N):\n\n  for j in range(T+1+3000+1):\n\n    time, deli = ab[i]\n\n    if 0 <= j-time < T:\n\n      dp[i + 1][j] = max(dp[i][j], dp[i][j - time] + deli)\n\n    else:\n\n      dp[i + 1][j] = dp[i][j]\n\n    ans = max(ans, dp[i + 1][j])\n\nprint(ans)\n\n\n\n#print(dp)\n", "generated_code": "N = int(eval(input()))\n\nabc = []\n\nfor i in range(N):\n\n    data = list(map(int, input().split()))\n\n    abc.append(data)\n\n\n\ndp = [[0 for i in range(3)] for j in range(N)]\n\ndp[0][0] = abc[0][0]\n\ndp[0][1] = abc[0][1]\n\ndp[0][2] = abc[0][2]\n\n\n\nfor i in range(N-1):\n\n    for j in range(3):\n\n        if j == 0:\n\n            dp[i+1][1] = max(dp[i][0] + abc[i+1][1], dp[i+1][1])\n\n            dp[i+1][2] = max(dp[i][0] + abc[i+1][2], dp[i+1][2])\n\n        if j == 1:\n\n            dp[i+1][0] = max(dp[i][1] + abc[i+1][0], dp[i+1][0])\n\n            dp[i+1][2] = max(dp[i][1] + abc[i+1][2], dp[i+1][2])\n\n        if j == 2:\n\n            dp[i+1][1] = max(dp[i][2] + abc[i+1][1], dp[i+1][1])\n\n            dp[i+1][0] = max(dp[i][2] + abc[i+1][0], dp[i+1][0])\n\n\n\nprint((max(dp[N-1])))", "score": 0.0, "codebleu": 0.18143670109573068, "crystalbleu": 0.3078736344349423, "codebertscore": 0.78, "codescore": 0.3909304141998291, "surfaceSim": 0.48219104155423637, "abs_surfaceSim_minus_score": 0.48219104155423637}
{"golden_code": "N, D = list(map(int, input().split()))\n\ncnt = 0\n\nfor _ in range(N):\n\n    x, y = list(map(int, input().split()))\n\n    if x ** 2 + y ** 2 <= D ** 2:\n\n        cnt += 1\n\n        \n\nprint(cnt)", "generated_code": "def sieve(n):\n\n  is_prime = [True for _ in range(n+1)]\n\n  is_prime[0] = False\n\n  for i in range(2, n+1):\n\n    if is_prime[i-1]:\n\n      j = 2 * i\n\n      while j <= n:\n\n        is_prime[j-1] = False\n\n        j += i\n\n  table = [i for i in range(1, n+1) if is_prime[i-1]]\n\n  return table\n\n\n\nN = int(eval(input()))\n\nA = list(map(int, input().split()))\n\nAmax = max(A)\n\nlis = [0]*(Amax+1)\n\nfor i in range(N):\n\n  lis[A[i]] += 1\n\ntable = sieve(Amax)\n\nsetwise = False\n\nfor t in table:\n\n  cnt = sum(lis[t:Amax+1:t])\n\n  if cnt==N:\n\n    print('not coprime')\n\n    break\n\n  if 2<=cnt<N:\n\n    setwise=True\n\nelse:\n\n  if setwise==True:\n\n    print('setwise coprime')\n\n  else:\n\n    print('pairwise coprime')\n", "score": 0.0, "codebleu": 0.3192952634061944, "crystalbleu": 0.06565605092088322, "codebertscore": 0.71, "codescore": 0.993530809879303, "surfaceSim": 0.4213406292749658, "abs_surfaceSim_minus_score": 0.4213406292749658}
{"golden_code": "x = int(eval(input()))\n\n\n\nfor a in range(10**4):\n\n    for b in range(10**4):\n\n        if(a**5 + b**5 == x):\n\n            print((a, -b))\n\n            break\n\n        elif(a**5 - b**5 == x):\n\n            print((a, b))\n\n            break\n\n    else:\n\n        continue\n\n    break", "generated_code": "n,m,k=list(map(int,input().split()))\n\n\n\nmod = 10**9+7\n\nf = [1]\n\nfor i in range(n*m):\n\n  f += [f[-1]*(i+1) % mod]\n\ndef comb(a, b):\n\n  return f[a]*pow(f[b], mod-2, mod)*pow(f[a-b], mod-2, mod) % mod\n\n\n\nans=0\n\nfor dist in range(1,n):\n\n  c=n-dist\n\n  p=(c*m*m)%mod\n\n  ans+=p*dist\n\nfor dist in range(1,m):\n\n  c=m-dist\n\n  p=(c*n*n)%mod\n\n  ans+=p*dist\n\nans%=mod\n\nprint((ans*comb(n*m-2,k-2)%mod))", "score": 0.0, "codebleu": 0.1710186054710224, "crystalbleu": 0.04043965064647946, "codebertscore": 0.73, "codescore": 0.9520978927612305, "surfaceSim": 0.42054263565891475, "abs_surfaceSim_minus_score": 0.42054263565891475}
{"golden_code": "import numpy as np\n\nfrom itertools import combinations \n\nINF = int(1e9)*15\n\ndef main():\n\n    n, k = list(map(int, input().split())) \n\n    a = np.array(input().split(), np.int32)\n\n    c = np.array([int(i) for i in range(1, n)])\n\n    ans = INF\n\n    for comb in combinations(c, k-1):\n\n        s = set(comb)\n\n        mx = a[0]\n\n        cost = 0\n\n        for i in range(n):\n\n            if i in s:\n\n                if a[i] > mx:\n\n                    mx = a[i]\n\n                    continue\n\n                else:\n\n                    mx += 1\n\n                    cost += mx-a[i] \n\n                    continue\n\n            mx = max(mx, a[i])\n\n        ans = min(cost, ans)\n\n    print(ans)\n\nif __name__ == '__main__':\n\n    main()\n", "generated_code": "import sys\n\ninput= lambda: sys.stdin.readline().rstrip()\n\ndef pin(type=int):\n\n    return list(map(type,input().split()))\n\n\n\n#%%code\n\n\n\ndef resolve():\n\n    \n\n    S=eval(input())\n\n    index=0\n\n    ans=0\n\n    for i in range(len(S)):\n\n        if S[i]==\"W\":\n\n            ans+=i-index\n\n            index+=1\n\n    print(ans)\n\n#%%submit!\n\nresolve()", "score": 0.0, "codebleu": 0.146832265021678, "crystalbleu": 0.07591495586457064, "codebertscore": 0.74, "codescore": 0.04822666198015213, "surfaceSim": 0.6376820437718655, "abs_surfaceSim_minus_score": 0.6376820437718655}
{"golden_code": "from collections import defaultdict\n\nN = int(eval(input()))\n\nd = defaultdict(int)\n\n\n\nfor i in range(N):\n\n    S = eval(input())\n\n    d[S] += 1\n\n\n\nm = 0\n\nfor k in list(d.keys()):\n\n    m = max(d[k],m)\n\n\n\nli = []\n\nfor k in list(d.keys()):\n\n    if d[k] == m:\n\n        li.append(k)\n\n\n\nli.sort()\n\nfor l in li:\n\n    print(l)", "generated_code": "N,M=list(map(int, input().split()))\n\nS=[]\n\nfor i in range(N):\n\n    a,b=list(map(int, input().split()))\n\n    S.append((a,b))\n\n\n\nC=[]\n\nfor i in range(M):\n\n    c,d=list(map(int, input().split()))\n\n    C.append((c,d,i+1))\n\n#print(C)\n\nfor s in S:\n\n    a,b=s\n\n    now=0\n\n    dis=10**9\n\n\n\n    for t in C:\n\n        c,d,n=t\n\n        D=abs(c-a)+abs(d-b)\n\n        \n\n        if D<dis:\n\n            dis=D\n\n            now=n\n\n    print(now)", "score": 0.0, "codebleu": 0.244361895714533, "crystalbleu": 0.07544721296535638, "codebertscore": 0.77, "codescore": 0.9937210083007812, "surfaceSim": 0.5311737089201878, "abs_surfaceSim_minus_score": 0.5311737089201878}
{"golden_code": "import heapq\n\n\n\nx, y, z, k = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\nb = list(map(int, input().split()))\n\nc = list(map(int, input().split()))\n\n\n\ndef diff(l):\n\n    m = max(l)\n\n    return sorted(m - v for v in l)[1:]\n\n\n\ns = sum(map(max, [a, b, c]))\n\nsa, sb, sc = list(map(diff, [a, b, c]))\n\nda, db, dc = [0], [0], [0]\n\nq = [0]\n\nwhile k > 0:\n\n    while True:\n\n        if len(sa) > 0 and (len(q) == 0 or q[0] > sa[0]):\n\n            for v in [sa[0] + bb + cc for bb in db for cc in dc]:\n\n                heapq.heappush(q, v)\n\n            da.append(sa[0])\n\n            sa = sa[1:]\n\n        elif len(sb) > 0 and (len(q) == 0 or q[0] > sb[0]):\n\n            for v in [sb[0] + aa + cc for aa in da for cc in dc]:\n\n                heapq.heappush(q, v)\n\n            db.append(sb[0])\n\n            sb = sb[1:]\n\n        elif len(sc) > 0 and (len(q) == 0 or q[0] > sc[0]):\n\n            for v in [sc[0] + aa + bb for aa in da for bb in db]:\n\n                heapq.heappush(q, v)\n\n            dc.append(sc[0])\n\n            sc = sc[1:]\n\n        else:\n\n            break\n\n    v = heapq.heappop(q)\n\n    print(s - v)\n\n    k -= 1\n", "generated_code": "# 解説放送\n\n\n\ndef main():\n\n    from collections import defaultdict\n\n\n\n    n = int(eval(input()))\n\n\n\n    d = defaultdict(int)\n\n    for x in range(1, n + 1):\n\n        if x % 10 == 0:\n\n            continue\n\n\n\n        tail = x % 10\n\n        head = 0\n\n        while x:\n\n            head = x\n\n            x //= 10\n\n\n\n        d[head, tail] += 1\n\n\n\n    ret = 0\n\n    for (head, tail), cnt in tuple(d.items()):\n\n        # RuntimeError: dictionary changed size during iteration\n\n        # defaultdictの未定義(?)のkeyにアクセスするせいで、REになる\n\n        # d.items()をtuple化して回避\n\n        ret += d[head, tail] * d[tail, head]\n\n        # (head,tail)の出現数を辞書で管理する\n\n        # (head,tail)*(tail,head)の組み合わせがある\n\n\n\n    print(ret)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 0.0, "codebleu": 0.07458280797043942, "crystalbleu": 0.003237905884052449, "codebertscore": 0.64, "codescore": 0.1998397409915924, "surfaceSim": 0.5117162960170876, "abs_surfaceSim_minus_score": 0.5117162960170876}
{"golden_code": "answer = 0\n\nN = int(eval(input()))\n\nA = list(map(int,input().split()))\n\nfor i in range(N) :\n\n    while A[i] % 2 == 0 :\n\n        A[i] = A[i] / 2\n\n        answer += 1\n\nprint(answer)\n\n\n", "generated_code": "from math import gcd\n\nn,m=list(map(int,input().split()))\n\na=list(map(int,input().split()))\n\na=list(set(a))\n\na=list([x//2 for x in a])\n\n\n\ndef lcm(q):\n\n  x = q[0]\n\n  for i in range(1, len(q)):\n\n    x = (x * q[i]) // gcd(x, q[i])\n\n  return x\n\n\n\nlcma=lcm(a)\n\nfor i in range(len(a)):\n\n  if (lcma//a[i])%2==0:\n\n    print((0))\n\n    exit()\n\ntemp=m//lcma\n\nprint((temp//2 if temp%2==0 else temp//2+1))", "score": 0.0, "codebleu": 0.23769543105025223, "crystalbleu": 0.08725867330741394, "codebertscore": 0.78, "codescore": 0.9147874116897583, "surfaceSim": 0.46345811051693403, "abs_surfaceSim_minus_score": 0.46345811051693403}
{"golden_code": "n, m, l = list(map(int, input().split()))\n\n\n\na = [0]*n\n\nb = [0]*m\n\nc = [[0 for col in range(l)] for row in range(n)]\n\n\n\nfor i in range(n):\n\n    a[i] = list(map(int,input().split()))\n\n\n\nfor i in range(m):\n\n    b[i] = list(map(int,input().split()))\n\n\n\n\n\nfor i in range(n):\n\n    for j in range(l):\n\n        for k in range(m):\n\n            c[i][j] += a[i][k]*b[k][j]\n\n    print((*c[i]))", "generated_code": "import sys\n\nINF = 1 << 60\n\nMOD = 10**9 + 7 # 998244353\n\nsys.setrecursionlimit(2147483647)\n\ninput = lambda:sys.stdin.readline().rstrip()\n\ndef resolve():\n\n    n, W = list(map(int, input().split()))\n\n    dp = [INF] * (n * 1001 + 1)\n\n    dp[0] = 0\n\n    for _ in range(n):\n\n        w, v = list(map(int, input().split()))\n\n        for v0 in range(n * 1001, -1, -1):\n\n            if dp[v0] == INF:\n\n                continue\n\n            if v + v0 <= n * 1001:\n\n                dp[v + v0] = min(dp[v + v0], dp[v0] + w)\n\n    for v in range(n * 1001, -1, -1):\n\n        if dp[v] <= W:\n\n            print(v)\n\n            return\n\nresolve()", "score": 0.0, "codebleu": 0.20290546062738998, "crystalbleu": 0.08294766045316654, "codebertscore": 0.73, "codescore": 0.5842148661613464, "surfaceSim": 0.5220536031238907, "abs_surfaceSim_minus_score": 0.5220536031238907}
{"golden_code": "a = int(eval(input()))\n\nh = int(a / 3600)\n\nm = int((a - h * 3600) / 60)\n\ns = int(a - h * 3600 - m * 60)\n\nprint((\":\" .join(map(str, [h, m, s]))))", "generated_code": "from sys import exit\n\ns = eval(input())\n\nts = ['']\n\nwhile True:\n\n  nts= []\n\n  for t in ts:\n\n    for w in ['dreamer', 'eraser', 'dream', 'erase']:\n\n      tw = t + w\n\n      if s == tw:\n\n        print('YES')\n\n        exit()\n\n      if s.startswith(tw):\n\n        nts.append(tw)\n\n  if len(nts) == 0:\n\n    print('NO')\n\n    exit()\n\n  ts = nts\n", "score": 0.0, "codebleu": 0.14095283300552672, "crystalbleu": 0.0, "codebertscore": 0.63, "codescore": 0.9913434982299805, "surfaceSim": 0.4783582089552239, "abs_surfaceSim_minus_score": 0.4783582089552239}
{"golden_code": "from collections import deque\n\nK = int(eval(input()))\n\nG = [[] for i in range(K)]\n\n\n\nfor n in range(K):\n\n    G[n].append([(n + 1) % K, 1])\n\n    G[n].append([(10 * n) % K, 0])\n\n\n\nque = deque([[1, 1]])\n\ndist = [float('inf')] * K\n\n\n\nwhile que:\n\n    node, cost = que.pop()\n\n    dist[node] = min(cost, dist[node])\n\n    for e, e_cost in G[node]:\n\n        if dist[e] != float('inf'):\n\n            continue\n\n\n\n        if e_cost == 0:\n\n            que.append([e, cost + 0])\n\n\n\n        if e_cost == 1:\n\n            que.appendleft([e, cost + 1])\n\n\n\nprint((dist[0]))\n", "generated_code": "from sys import exit\n\ns = eval(input())\n\nts = ['']\n\nwhile True:\n\n  nts= []\n\n  for t in ts:\n\n    for w in ['dreamer', 'eraser', 'dream', 'erase']:\n\n      tw = t + w\n\n      if s == tw:\n\n        print('YES')\n\n        exit()\n\n      if s.startswith(tw):\n\n        nts.append(tw)\n\n  if len(nts) == 0:\n\n    print('NO')\n\n    exit()\n\n  ts = nts\n", "score": 0.0, "codebleu": 0.11300849077605421, "crystalbleu": 0.03586085403536356, "codebertscore": 0.68, "codescore": 0.962755024433136, "surfaceSim": 0.5816280566280567, "abs_surfaceSim_minus_score": 0.5816280566280567}
{"golden_code": "import math\n\nN = int(eval(input()))\n\nprint((math.factorial(N)%(10**9+7)))", "generated_code": "from sys import exit\n\ns = eval(input())\n\nts = ['']\n\nwhile True:\n\n  nts= []\n\n  for t in ts:\n\n    for w in ['dreamer', 'eraser', 'dream', 'erase']:\n\n      tw = t + w\n\n      if s == tw:\n\n        print('YES')\n\n        exit()\n\n      if s.startswith(tw):\n\n        nts.append(tw)\n\n  if len(nts) == 0:\n\n    print('NO')\n\n    exit()\n\n  ts = nts\n", "score": 0.0, "codebleu": 0.24896205408589173, "crystalbleu": 0.0, "codebertscore": 0.63, "codescore": 0.9736325740814209, "surfaceSim": 0.4906377204884667, "abs_surfaceSim_minus_score": 0.4906377204884667}
{"golden_code": "N=int(eval(input()))\n\n\n\nS=[[-1]*N for _ in range(N)]\n\nfor i in range(N):\n\n  A=int(eval(input()))\n\n  for _ in range(A):\n\n    x, y=list(map(int, input().split()))\n\n    S[i][x-1]=y\n\nans=0   \n\nfor s in range(2**N):\n\n  ok=True\n\n  for i in range(N):\n\n    #正直者について見ていく\n\n    if (s>>i&1)==1:\n\n      for j in range(N):\n\n        #それぞれ正直者の証言が矛盾ないか\n\n        if S[i][j]!=-1 and (s>>j&1)!=S[i][j]:\n\n          ok=False\n\n  if ok:\n\n    ans=max(ans, bin(s).count(\"1\"))\n\n    \n\nprint(ans)\n", "generated_code": "n, m = map(int, input().split())\n\nroads = [0] * n\n\n[exec(\"roads[%d] += 1; roads[%d] += 1\" % tuple(map(lambda c: int(c) - 1, input().split()))) for _ in range(m)]\n\nprint(*roads, sep=\"\\n\", end=\"\")\n", "score": 0.0, "codebleu": 0.11582362448247085, "crystalbleu": 0.04600201887220753, "codebertscore": 0.7, "codescore": 0.5126024484634399, "surfaceSim": 0.4519230769230769, "abs_surfaceSim_minus_score": 0.4519230769230769}
{"golden_code": "import sys\n\ncan = True; eval(input())\n\ne = [[0, 0, 0]] + [list(map(int, e.split())) for e in sys.stdin]\n\nfor a, b in zip(e[1:], e):\n\n    t = a[0] - b[0] - abs(a[1] - b[1]) - abs(a[2] - b[2])\n\n    if t < 0 or t % 2 == 1: can = False; break\n\nprint((['No', 'Yes'][can]))", "generated_code": "n,m=list(map(int,input().split()))\n\nl,r=list(map(int,input().split()))\n\nfor i in range(m-1):\n\n  tl,tr=list(map(int,input().split()))\n\n  if l<tl:\n\n    l=tl\n\n  if tr<r:\n\n    r=tr\n\nprint((max(r-l+1,0)))", "score": 0.0, "codebleu": 0.09391000279421563, "crystalbleu": 0.04037796995662265, "codebertscore": 0.76, "codescore": 0.16294653713703156, "surfaceSim": 0.5080524344569288, "abs_surfaceSim_minus_score": 0.5080524344569288}
{"golden_code": "N, M, R = list(map(int, input().split()))\n\nr = list(map(int, input().split()))\n\nd = [[float('inf')]*N for _ in range(N)]\n\nfor i in range(M): #ひとまず枝があるペアは枝の長さをセット\n\n  a,b,t = list(map(int, input().split()))\n\n  d[a-1][b-1] = t\n\n  d[b-1][a-1] = t\n\n\n\nfor i in range(N):\n\n  d[i][i] = 0 #自身への最短経路は0\n\n#三重ループ\n\nfor k in range(N):\n\n  for i in range(N):\n\n    for j in range(N):\n\n      d[i][j] = min(d[i][j], d[i][k]+d[k][j])\n\n\n\nfrom itertools import groupby, accumulate, product, permutations, combinations\n\n\n\nans = float('inf')\n\nfor p in permutations(r,R):\n\n  cnt = 0\n\n  for i in range(1,R):\n\n    cnt += d[p[i-1]-1][p[i]-1]\n\n  ans = min(ans,cnt)\n\nprint(ans)", "generated_code": "n = int(eval(input()))\n\n\n\nans = 1\n\nfor i in range(1, n+1):\n\n    ans = ans * i\n\n    ans = ans % ((10 ** 9)+7)  # 途中で割り算の余りを求めても、最終結果は同じになる\n\n\n\nprint(ans)", "score": 0.0, "codebleu": 0.09323040378116955, "crystalbleu": 0.0017185976598803926, "codebertscore": 0.72, "codescore": 0.13042059540748596, "surfaceSim": 0.41724458204334364, "abs_surfaceSim_minus_score": 0.41724458204334364}
{"golden_code": "import numpy as np\n\nn, k = list(map(int, input().split()))\n\np = np.array(list(map(int, input().split())))\n\np += 1\n\nsum_E = np.cumsum(p)\n\nsum_e = np.append([0], sum_E)\n\nans = -1\n\nfor i in range(n-k+1):\n\n    ans = max(ans, sum_e[i+k] - sum_e[i])\n\nprint((ans/2))", "generated_code": "import sys\n\n\n\nn, *a = list(map(int, sys.stdin.read().split()))\n\n\n\ndef main():\n\n    for i in range(n):\n\n        a[i] -= (i + 1)\n\n    a.sort()\n\n    b = a[n // 2]\n\n    res = 0\n\n    for i in range(n):\n\n        res += abs(a[i] - b)\n\n    \n\n    return res\n\n    \n\nif __name__ == '__main__':\n\n    ans = main()\n\n    print(ans)", "score": 0.0, "codebleu": 0.15518051562521745, "crystalbleu": 0.14792505880701842, "codebertscore": 0.79, "codescore": 0.018315233290195465, "surfaceSim": 0.5627807268272764, "abs_surfaceSim_minus_score": 0.5627807268272764}
{"golden_code": "while True:\n\n    try:\n\n        for i in range(3):\n\n            line = input().strip()\n\n            if line == '0':\n\n                raise Exception\n\n\n\n            a = b = 0\n\n            for i, s in enumerate(line):\n\n                if i != 0:\n\n                    if s == 'A':\n\n                        a += 1\n\n                    else:\n\n                        b += 1\n\n            if a > b:\n\n                a += 1\n\n            else:\n\n                b += 1\n\n            print(a, b)\n\n\n\n    except:\n\n        break", "generated_code": "def ii():return int(eval(input()))\n\ndef iim():return list(map(int,input().split()))\n\ndef iil():return list(map(int,input().split()))\n\ndef ism():return list(map(str,input().split()))\n\ndef isl():return list(map(str,input().split()))\n\n\n\nn = ii()\n\nD = iil()\n\nsumD = sum(D)\n\nans = 0\n\nfor i in range(n):\n\n    ans += D[i]*(sum(D)-D[i])\n\nprint((ans//2))", "score": 0.0, "codebleu": 0.1741128990227012, "crystalbleu": 0.05775651654114743, "codebertscore": 0.68, "codescore": 0.08996650576591492, "surfaceSim": 0.451171875, "abs_surfaceSim_minus_score": 0.451171875}
{"golden_code": "INF = 10**10\n\n\n\nN, M = list(map(int, input().split()))\n\ncosts = []\n\nkeys = []\n\nfor _ in range(M):\n\n    A, B = list(map(int, input().split()))\n\n    cs = list(map(int, input().split()))\n\n    costs.append(A)\n\n    # 鍵を2進数化する\n\n    key = 0\n\n    for c in cs:\n\n        key |= 1<<(c-1)\n\n    keys.append(key)\n\n\n\n# [1]の個数で分類する\n\nmaskss = [[] for _ in range(N+1)]\n\nnum1s = [0] * (2**N)\n\nfor S in range(2**N):\n\n    num = bin(S).count('1')\n\n    maskss[num].append(S)\n\n    num1s[S] = num\n\n\n\ndpAll = [INF] * (2**N)\n\nfor S in range(2**N):\n\n    for cost, key in zip(costs, keys):\n\n        if S & key == S:\n\n            if cost < dpAll[S]:\n\n                dpAll[S] = cost\n\n\n\ndp = [INF] * (2**N)\n\nfor S in range(2**N):\n\n    cost = dpAll[S]\n\n    num1 = num1s[S]\n\n    for k in range(1, (num1+1)//2+1):\n\n        for mask in maskss[k]:\n\n            if mask & S == mask:\n\n                m2 = S^mask\n\n                c2 = dp[mask] + dp[m2]\n\n                if c2 < cost:\n\n                    cost = c2\n\n    dp[S] = cost\n\n\n\nif dp[2**N-1] == INF:\n\n    print((-1))\n\nelse:\n\n    print((dp[2**N-1]))\n", "generated_code": "# -*- coding: utf-8 -*-\n\n\"\"\"\n\nCreated on Wed May 29 22:49:19 2019\n\n\n\n@author: Yamazaki Kenichi\n\n\"\"\"\n\n\n\n# -*- coding: utf-8 -*-\n\n\"\"\"\n\nCreated on Sat May 25 21:24:29 2019\n\n\n\n@author: Yamazaki Kenichi\n\n\"\"\"\n\n\n\nN, M, K = list(map(int,input().split()))\n\nmod = 10**9+7\n\n\n\ndef cmb(n, r, mod):\n\n    if (r < 0 or r > n):\n\n        return 0\n\n    r = min(r, n-r)\n\n    return g1[n] * g2[r] * g2[n-r] % mod\n\n\n\ng1 = [1, 1] # 元テーブル\n\ng2 = [1, 1] # 逆元テーブル\n\ninv = [0, 1] # 逆元テーブル計算用テーブル\n\n\n\nfor i in range(2, N*M+1):\n\n    g1.append((g1[-1] * i) % mod)\n\n    inv.append((-inv[mod % i] * (mod//i)) % mod)\n\n    g2.append((g2[-1] * inv[-1]) % mod)\n\n\n\nans1 = 0\n\ndef c(N,M):\n\n    res = 0\n\n    for i in range(1,N):\n\n        res += i*(N-i)*M*M\n\n    return res\n\nans1 += c(N,M) + c(M,N)\n\nans1 %= mod\n\n\n\nans1 *= cmb(N*M-2,K-2,mod)\n\nans1 %= mod\n\n\n\nprint(ans1)\n", "score": 0.0, "codebleu": 0.14404092566054866, "crystalbleu": 0.09470171827206073, "codebertscore": 0.73, "codescore": 0.9720184803009033, "surfaceSim": 0.5528075018823153, "abs_surfaceSim_minus_score": 0.5528075018823153}
{"golden_code": "S = int(eval(input()))\n\n\n\ndp = [0] * (S + 1)\n\ndp[0] = 1\n\nM = 10 ** 9 + 7\n\n\n\nfor i in range(1, S + 1):\n\n    num = 0\n\n    for j in range(i - 2):\n\n        num += dp[j]\n\n        dp[i] = num % M\n\n\n\nprint((dp[S]))\n\n\n", "generated_code": "def main():\n\n    n, *a, = list(map(int, open(0).read().split()))\n\n    a = [x - i for i, x in enumerate(a, 1)]\n\n    a.sort()\n\n    if n % 2 == 0:\n\n        ans = sum(a[n // 2:]) - sum(a[:n // 2])\n\n    else:\n\n        ans = sum(a[n // 2 + 1:]) - sum(a[:n // 2])\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 0.0, "codebleu": 0.10041184301285444, "crystalbleu": 0.02218228511282667, "codebertscore": 0.73, "codescore": 0.018554463982582092, "surfaceSim": 0.43365218276177875, "abs_surfaceSim_minus_score": 0.43365218276177875}
{"golden_code": "from collections import defaultdict\n\n\n\nfrom scipy.misc import comb\n\n\n\nN, M = list(map(int, input().split()))\n\nA = [int(x) for x in input().split()]\n\n\n\nB = [0] * N\n\nB[0] = A[0]\n\nfor i in range(1, N):\n\n    B[i] = B[i - 1] + A[i]\n\nB = [0] + B\n\n\n\nc = defaultdict(int)\n\nfor i in range(N + 1):\n\n    c[B[i] % M] += 1\n\n\n\nans = 0\n\nfor k, v in list(c.items()):\n\n    if v >= 2:\n\n        ans += comb(v, 2, exact=True)\n\nprint(ans)", "generated_code": "import sys\n\nans = 'Yes'; eval(input())\n\nfor e in sys.stdin:\n\n    t, x, y = list(map(int, e.split()))\n\n    t = t - x - y\n\n    if t < 0 or t % 2 == 1: ans = 'No'; break\n\nprint(ans)", "score": 0.0, "codebleu": 0.11060109410891461, "crystalbleu": 0.03866688303303353, "codebertscore": 0.73, "codescore": 0.9770540595054626, "surfaceSim": 0.45743405275779375, "abs_surfaceSim_minus_score": 0.45743405275779375}
{"golden_code": "import numpy as np\n\n\n\nN, M = [int(x) for x in input().split()]\n\nL = [[int (y) for y in input().split()] for _ in range(M)]\n\nL = sum(L, [])\n\n\n\nfor i in np.arange(1, N+1):\n\n    print((L.count(i)))", "generated_code": "S = int(eval(input()))\n\n\n\n\n\ndef cmb(n, r, p):\n\n    r = min(n - r, r)\n\n    if r == 0:\n\n        return 1\n\n    over = 1\n\n    for i in range(n, n - r, -1):\n\n        over = over * i % p\n\n    under = 1\n\n    for i in range(1, r + 1):\n\n        under = under * i % p\n\n    inv = pow(under, p - 2, p)\n\n    return over * inv % p\n\n\n\n\n\nM = 10 ** 9 + 7\n\nans = 0\n\nfor i in range(1, S):\n\n    if S - 3 * i < 0:\n\n        break\n\n    ans += cmb(S - 3 * i + i - 1, i - 1, M)\n\n    ans %= M\n\nprint(ans)\n", "score": 0.0, "codebleu": 0.19937670306225647, "crystalbleu": 0.02501611970100486, "codebertscore": 0.72, "codescore": 0.9928326606750488, "surfaceSim": 0.4269004052560481, "abs_surfaceSim_minus_score": 0.4269004052560481}
{"golden_code": "from statistics import mean\n\n\n\ninputCount = int(eval(input()))\n\nprices = [int(eval(input())) for lp in range(inputCount)]\n\naverage = mean(prices)\n\nprint((int(average)))\n\n\n", "generated_code": "N = int(eval(input()))\n\nS = [eval(input()) for i in range(N)]\n\nfrom collections import Counter\n\nctr = Counter([s[0] for s in S])\n\n\n\nans = 0\n\nimport itertools\n\nfor ptn in itertools.combinations('MARCH', 3):\n\n    t = 1\n\n    for c in ptn:\n\n        t *= ctr[c]\n\n    ans += t\n\nprint(ans)", "score": 0.0, "codebleu": 0.3062420329931812, "crystalbleu": 0.0, "codebertscore": 0.75, "codescore": 0.9600255489349365, "surfaceSim": 0.473581560283688, "abs_surfaceSim_minus_score": 0.473581560283688}
{"golden_code": "import sys, re\n\nfrom collections import deque, defaultdict, Counter\n\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, tan, asin, acos, atan, radians, degrees#, log2, log\n\nfrom itertools import accumulate, permutations, combinations, combinations_with_replacement, product, groupby\n\nfrom operator import itemgetter, mul\n\nfrom copy import deepcopy\n\nfrom string import ascii_lowercase, ascii_uppercase, digits\n\nfrom bisect import bisect, bisect_left, insort, insort_left\n\nfrom fractions import gcd\n\nfrom heapq import heappush, heappop\n\nfrom functools import reduce\n\nfrom decimal import Decimal\n\ndef input(): return sys.stdin.readline().strip()\n\ndef INT(): return int(eval(input()))\n\ndef MAP(): return list(map(int, input().split()))\n\ndef LIST(): return list(map(int, input().split()))\n\ndef ZIP(n): return list(zip(*(MAP() for _ in range(n))))\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = float('inf')\n\nmod = 10**9 + 7\n\nfrom decimal import *\n\n\n\nN = INT()\n\nxy = []\n\n\n\nfor i in range(N):\n\n\tA = INT()\n\n\txy.append([LIST() for _ in range(A)])\n\n\n\nans = 0\n\nfor i in range(1<<N):\n\n\ti = list(\"{:b}\".format(i).zfill(N))\n\n\tfor j in range(N):\n\n\t\tif i[j] == \"1\":\n\n\t\t\tfor x, y in xy[j]:\n\n\t\t\t\tif y != int(i[x-1]):\n\n\t\t\t\t\tbreak\n\n\t\t\telse:\n\n\t\t\t\tcontinue\n\n\t\t\tbreak\n\n\telse:\n\n\t\ttmp = sum([int(x) for x in i])\n\n\t\tans = max(ans, tmp)\n\nprint(ans)\n", "generated_code": "a,b,c,x,y=list(map(int,input().split()))\n\nans=0\n\nm=min(x,y)\n\nif a+b>=2*c: #Half and Half購入で安くなる可能性あるパターン\n\n    # HaHをm枚買って残りHaH購入,または全部HaH購入,このいずれかしかあり得ない\n\n    ans = min(2*c*m+a*(x-m)+b*(y-m), 2*c*max(x,y))\n\nelse:\n\n    ans = a*x+b*y\n\nprint(ans)", "score": 0.0, "codebleu": 0.12410894743043233, "crystalbleu": 0.014159748318850932, "codebertscore": 0.63, "codescore": 0.5274200439453125, "surfaceSim": 0.31934727301637783, "abs_surfaceSim_minus_score": 0.31934727301637783}
{"golden_code": "import sys\n\nsys.setrecursionlimit(10000000)\n\n\n\n#const\n\ndxdy=((1,0),(0,1))\n\n#my functions here!\n\ndef pin(type=int):\n\n    return list(map(type,input().rstrip().split()))\n\n\n\n\n\n#your code here!\n\ndef resolve():\n\n    S=eval(input())\n\n    ans=0\n\n    \n\n    hidari=0\n\n    for i,c in enumerate(S):\n\n        if c==\"W\":\n\n            ans+=i-hidari\n\n            hidari+=1\n\n    print(ans)\n\n\n\nimport sys\n\nfrom io import StringIO\n\nimport unittest\n\n\n\n\n\nclass TestClass(unittest.TestCase):\n\n    def assertIO(self, input, output):\n\n        stdout, stdin = sys.stdout, sys.stdin\n\n        sys.stdout, sys.stdin = StringIO(), StringIO(input)\n\n        resolve()\n\n        sys.stdout.seek(0)\n\n        out = sys.stdout.read()[:-1]\n\n        sys.stdout, sys.stdin = stdout, stdin\n\n        self.assertEqual(out, output)\n\n\n\n    def test_入力例_1(self):\n\n        input = \"\"\"BBW\"\"\"\n\n        output = \"\"\"2\"\"\"\n\n        self.assertIO(input, output)\n\n\n\n    def test_入力例_2(self):\n\n        input = \"\"\"BWBWBW\"\"\"\n\n        output = \"\"\"6\"\"\"\n\n        self.assertIO(input, output)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    #unittest.main()\n\n\n\n\n\n    resolve()#and submit 2 atcoder!\n\n\n", "generated_code": "n, m, l = list(map(int, input().split()))\n\n\n\na = [0]*n\n\nb = [0]*m\n\nc = [[0 for col in range(l)] for row in range(n)]\n\n\n\nfor i in range(n):\n\n    a[i] = list(map(int,input().split()))\n\n\n\nfor i in range(m):\n\n    b[i] = list(map(int,input().split()))\n\n\n\n\n\nfor i in range(n):\n\n    for j in range(l):\n\n        c[i][j] = sum([a[i][k]*b[k][j] for k in range(m)])\n\n#        for k in range(m):\n\n#            c[i][j] += a[i][k]*b[k][j]\n\n    print((*c[i]))", "score": 0.0, "codebleu": 0.10278586566989248, "crystalbleu": 0.03188524335213808, "codebertscore": 0.67, "codescore": 0.12045431137084961, "surfaceSim": 0.4084316617502458, "abs_surfaceSim_minus_score": 0.4084316617502458}
{"golden_code": "# -*- coding: utf-8 -*-\n\n\"\"\"\n\nCreated on Sat May 25 21:24:29 2019\n\n\n\n@author: Yamazaki Kenichi\n\n\"\"\"\n\n\n\nN, M, K = list(map(int,input().split()))\n\nmod = 10**9+7\n\n\n\ndef cmb(n, r, mod):\n\n    if (r < 0 or r > n):\n\n        return 0\n\n    r = min(r, n-r)\n\n    return g1[n] * g2[r] * g2[n-r] % mod\n\n\n\ng1 = [1, 1] # 元テーブル\n\ng2 = [1, 1] # 逆元テーブル\n\ninv = [0, 1] # 逆元テーブル計算用テーブル\n\n\n\nfor i in range(2, N*M+1):\n\n    g1.append((g1[-1] * i) % mod)\n\n    inv.append((-inv[mod % i] * (mod//i)) % mod)\n\n    g2.append((g2[-1] * inv[-1]) % mod)\n\n\n\ndef a(N,M):\n\n    return N*(N+1)//2*(M+1) + M*(M+1)//2*(N+1)\n\ndef b(N):\n\n    return N*(N+1)//2\n\n\n\nans = 0\n\nfor i in range(N):\n\n    for j in range(M):\n\n        ans += a(i,j) + a(N-i-1,j) + a(i,M-j-1) + a(N-i-1,M-j-1)\n\n        ans -= b(i) + b(j) + b(N-i-1) + b(M-j-1)\n\n        ans %= mod\n\n#        print(i,j,a(i,j),a(N-i-1,j),a(i,M-j-1),a(N-i-1,M-j-1),b(i),b(j),ans)\n\nans *= g2[2]\n\n\n\nans *= cmb(N*M-2,K-2,mod)\n\nans %= mod\n\n\n\nprint(ans)\n", "generated_code": "import math\n\nN = int(eval(input()))\n\na = 1\n\nfor n in range(2,N+1):\n\n    a = a*n % (10**9+7)\n\nprint(a)", "score": 0.0, "codebleu": 0.06749922966855379, "crystalbleu": 0.00033776779231661346, "codebertscore": 0.67, "codescore": 0.2958418130874634, "surfaceSim": 0.41015125072716696, "abs_surfaceSim_minus_score": 0.41015125072716696}
{"golden_code": "def main():\n\n    from statistics import median\n\n\n\n    n, *a, = list(map(int, open(0).read().split()))\n\n    a = [x - i for i, x in enumerate(a, 1)]\n\n    a.sort()\n\n    m = int(median(a))\n\n\n\n    ans = sum([abs(x - m) for x in a])\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "generated_code": "#!usr/bin/env python3\n\nfrom collections import defaultdict,deque\n\nfrom heapq import heappush, heappop\n\nfrom itertools import permutations\n\nimport sys\n\nimport math\n\nimport bisect\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\n\ndef I(): return int(sys.stdin.readline())\n\ndef LS():return [list(x) for x in sys.stdin.readline().split()]\n\ndef S():\n\n    res = list(sys.stdin.readline())\n\n    if res[-1] == \"\\n\":\n\n        return res[:-1]\n\n    return res\n\ndef IR(n):\n\n    return [I() for i in range(n)]\n\ndef LIR(n):\n\n    return [LI() for i in range(n)]\n\ndef SR(n):\n\n    return [S() for i in range(n)]\n\ndef LSR(n):\n\n    return [LS() for i in range(n)]\n\n\n\nsys.setrecursionlimit(1000000)\n\nmod = 1000000007\n\n\n\ndef solve():\n\n    A,B,C,x,y = LI()\n\n    ans = float(\"inf\")\n\n    for c in range(200001)[::2]:\n\n        a = b = c >> 1\n\n        a = max(0,x-a)\n\n        b = max(0,y-b)\n\n        s = A*a+B*b+C*c\n\n        if s < ans:\n\n            ans = s\n\n    print(ans)\n\n    return\n\n\n\n#Solve\n\nif __name__ == \"__main__\":\n\n    solve()\n", "score": 0.0, "codebleu": 0.26435718752183524, "crystalbleu": 0.052911522218098785, "codebertscore": 0.71, "codescore": 0.01956913247704506, "surfaceSim": 0.5074001947419668, "abs_surfaceSim_minus_score": 0.5074001947419668}
{"golden_code": "from fractions import gcd\n\n\n\nn,m=list(map(int,input().split()))\n\na=list(map(int,input().split()))\n\na=list(set(a))\n\n\n\na=list([x//2 for x in a])\n\n\n\ndef lcm(q):\n\n  x = q[0]\n\n  for i in range(1, len(q)):\n\n    x = (x * q[i]) // gcd(x, q[i])\n\n  return x\n\n\n\nlcma=lcm(a)\n\n\n\nif (lcma//a[0])%2==0:\n\n  print((0))\n\nelse:\n\n  flg=0\n\n  for i in range(1,len(a)):\n\n    if (lcma//a[i])%2==0:\n\n      print((0))\n\n      flg=1\n\n      break\n\n  if flg==0:\n\n    temp=m//lcma\n\n    print((temp//2 if temp%2==0 else temp//2+1))", "generated_code": "n = int(eval(input()))\n\na = list(map(int, input().split()))\n\nD = {i: [0] for i in range(1, n+1)}\n\nfor i in range(n+1):\n\n  D[a[i]][0] += 1\n\n  D[a[i]].append(i)\n\npl, pr = 0, 0\n\nfor i in D:\n\n  if D[i][0] == 2:\n\n    pl = D[i][1]\n\n    pr = D[i][2]\n\n    break\n\nL = pl\n\nM = pr - pl - 1\n\nN = n - pr\n\nmod = int(1e9) + 7 # <-- input modulo\n\nmaxf = n+11          # <-- input factional limitation\n\n\n\ndef make_fact(n, k):\n\n    tmp = n\n\n    perm = [i for i in range(k)]\n\n    L = [0 for _ in range(k)]\n\n    for i in range(k):\n\n        L[i] = tmp % (i + 1)\n\n        tmp //= i + 1\n\n    LL = [0 for _ in range(k)]\n\n    for i in range(k):\n\n        LL[i] = perm[L[-i-1]]\n\n        for j in range(L[-i-1]+1, k):\n\n            perm[j-1] = perm[j]\n\n    return LL\n\n\n\ndef doubling(n, m, modulo=mod):\n\n    y = 1\n\n    base = n\n\n    tmp = m\n\n    while tmp != 0:\n\n        if tmp % 2 == 1:\n\n            y *= base\n\n            if modulo > 0:\n\n                y %= modulo\n\n        base *= base\n\n        if modulo > 0:\n\n            base %= modulo\n\n        tmp //= 2\n\n    return y\n\n\n\ndef inved(a, modulo=mod):\n\n    x, y, u, v, k, l = 1, 0, 0, 1, a, modulo\n\n    while l != 0:\n\n        x, y, u, v = u, v, x - u * (k // l), y - v * (k // l)\n\n        k, l = l, k % l\n\n    return x % modulo\n\n\n\nfact = [1 for _ in range(maxf+1)]\n\ninvf = [1 for _ in range(maxf+1)]\n\n\n\nfor i in range(maxf):\n\n    fact[i+1] = (fact[i] * (i+1)) % mod\n\ninvf[-1] = inved(fact[-1])\n\nfor i in range(maxf, 0, -1):\n\n    invf[i-1] = (invf[i] * i) % mod\n\n\n\nfor i in range(1, n+2):\n\n  S = fact[n+1]*invf[i]*invf[n-i+1]%mod\n\n  if i <= n-M:\n\n    S -= fact[n-1-M]*invf[i-1]*invf[n-M-i]%mod\n\n    S %= mod\n\n  print(S)\n", "score": 0.0, "codebleu": 0.2543073320461047, "crystalbleu": 0.08435681565339471, "codebertscore": 0.77, "codescore": 0.9937460422515869, "surfaceSim": 0.5833890697225071, "abs_surfaceSim_minus_score": 0.5833890697225071}
{"golden_code": "l, r=list(map(int, input().split()))\n\nif r-l>672:\n\n\tp=0\n\nelse:\n\n\tp=2019\n\n\tfor i in range(l, r):\n\n\t\tfor j in range(i+1, r+1):\n\n\t\t\tp=min(p, (((i%2019)*(j%2019))%2019))\n\n\t\t\tif not p:\n\n\t\t\t\tbreak\n\n\t\tif not p:\n\n\t\t\tbreak\n\nprint(p)", "generated_code": "import sys, re\n\nfrom collections import deque, defaultdict, Counter\n\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, tan, asin, acos, atan, radians, degrees#, log2, log\n\nfrom itertools import accumulate, permutations, combinations, combinations_with_replacement, product, groupby\n\nfrom operator import itemgetter, mul\n\nfrom copy import deepcopy\n\nfrom string import ascii_lowercase, ascii_uppercase, digits\n\nfrom bisect import bisect, bisect_left, insort, insort_left\n\nfrom fractions import gcd\n\nfrom heapq import heappush, heappop\n\nfrom functools import reduce\n\nfrom decimal import Decimal\n\ndef input(): return sys.stdin.readline().strip()\n\ndef INT(): return int(eval(input()))\n\ndef MAP(): return list(map(int, input().split()))\n\ndef LIST(): return list(map(int, input().split()))\n\ndef ZIP(n): return list(zip(*(MAP() for _ in range(n))))\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = float('inf')\n\nmod = 10**9 + 7\n\nfrom decimal import *\n\n\n\nN = INT()\n\nxy = []\n\n\n\nfor i in range(N):\n\n\tA = INT()\n\n\txy.append([LIST() for _ in range(A)])\n\n\n\nans = 0\n\nfor X in product((0, 1), repeat=N):\n\n\tfor j in range(N):\n\n\t\tif X[j] == 1:\n\n\t\t\tfor x, y in xy[j]:\n\n\t\t\t\tif X[x-1] != y:\n\n\t\t\t\t\tbreak\n\n\t\t\telse:\n\n\t\t\t\tcontinue\n\n\t\t\tbreak\n\n\telse:\n\n\t\tans = max(ans, sum(X))\n\n\n\nprint(ans)", "score": 0.0, "codebleu": 0.24946013351271631, "crystalbleu": 0.05663453757843948, "codebertscore": 0.64, "codescore": 0.18528935313224792, "surfaceSim": 0.3371666376996312, "abs_surfaceSim_minus_score": 0.3371666376996312}
{"golden_code": "n = int(eval(input()))\n\n\n\ncnt = 0\n\nfor i in range(1, n+1):\n\n    i_str = str(i)\n\n    if len(i_str) == 1:\n\n        cnt += 1\n\n        continue\n\n    if len(i_str) == 2:\n\n        if int(i_str[0]) == int(i_str[1]):\n\n            cnt += 3\n\n        elif int(i_str[1]) != 0 and int(i_str[0]) > int(i_str[1]):\n\n            cnt += 2\n\n        continue\n\n    if len(i_str) == 3:\n\n        if int(i_str[0]) == int(i_str[2]):\n\n            cnt += 4 + (2 * (int(i_str[1])+1) - 1)\n\n        elif int(i_str[2]) != 0 and int(i_str[0]) > int(i_str[2]):\n\n            cnt += 22\n\n        elif int(i_str[0]) < int(i_str[2]):\n\n            cnt += 2\n\n        continue\n\n    if len(i_str) == 4:\n\n        if int(i_str[0]) == int(i_str[3]):\n\n            cnt += 24 + 20 * int(i_str[1]) + 2 * (int(i_str[2])+1) - 1\n\n        elif int(i_str[3]) != 0 and int(i_str[0]) > int(i_str[3]):\n\n            cnt += 222\n\n        elif int(i_str[0]) < int(i_str[3]):\n\n            cnt += 22\n\n        continue\n\n    if len(i_str) == 5:\n\n        if int(i_str[0]) == int(i_str[4]):\n\n            cnt += 224 + 200 * int(i_str[1]) + 20 * int(i_str[2]) + 2 * (int(i_str[3])+1) - 1\n\n        elif int(i_str[4]) != 0 and int(i_str[0]) > int(i_str[4]):\n\n            cnt += 2222\n\n        elif int(i_str[0]) < int(i_str[4]):\n\n            cnt += 222\n\n        continue\n\n    if len(i_str) == 6:\n\n        if int(i_str[0]) == int(i_str[5]):\n\n            cnt += 2224 + 2000 * int(i_str[1]) + 200 * int(i_str[2]) + 20 * int(i_str[3]) + 2 * (int(i_str[4])+1) - 1\n\n        elif int(i_str[5]) != 0 and int(i_str[0]) > int(i_str[5]):\n\n            cnt += 22222\n\n        elif int(i_str[0]) < int(i_str[5]):\n\n            cnt += 2222\n\n        continue\n\n\n\nprint(cnt)", "generated_code": "from collections import deque\n\nK = int(eval(input()))\n\nG = [[] for i in range(K)]\n\nfor i in range(K):\n\n    G[i].append(((10 * i) % K, 0))\n\n    G[i].append(((i + 1) % K, 1))\n\n\n\ndist = [float('inf')] * K\n\ndist[1] = 1\n\nque = deque()\n\nque.append(1)\n\n\n\nwhile que:\n\n    n = que.pop()\n\n    for v, c in G[n]:\n\n        if dist[v] > dist[n] + c:\n\n            dist[v] = dist[n] + c\n\n            if c == 0:\n\n                que.append(v)\n\n            else:\n\n                que.appendleft(v)\n\n\n\nprint((dist[0]))\n", "score": 0.0, "codebleu": 0.0779267018906275, "crystalbleu": 0.010133938296974506, "codebertscore": 0.7, "codescore": 0.9275764226913452, "surfaceSim": 0.4870602224242848, "abs_surfaceSim_minus_score": 0.4870602224242848}
{"golden_code": "import sys\n\ninput = sys.stdin.readline\n\n\n\nn,k = list(map(int, input().split()))\n\nAs = [int(eval(input())) for i in range(n)]\n\n\n\n# N: 処理する区間の長さ\n\n\n\nINF = 0\n\n\n\nmx = 300001\n\nLV = (mx-1).bit_length()\n\nN0 = 2**LV\n\ndata = [INF]*(2*N0)\n\nlazy = [None]*(2*N0)\n\n\n\n# 伝搬対象の区間を求める\n\ndef gindex(l, r):\n\n    L = (l + N0) >> 1; R = (r + N0) >> 1\n\n    lc = 0 if l & 1 else (L & -L).bit_length()\n\n    rc = 0 if r & 1 else (R & -R).bit_length()\n\n    for i in range(LV):\n\n        if rc <= i:\n\n            yield R\n\n        if L < R and lc <= i:\n\n            yield L\n\n        L >>= 1; R >>= 1\n\n\n\n# 遅延伝搬処理\n\ndef propagates(*ids):\n\n    for i in reversed(ids):\n\n        v = lazy[i-1]\n\n        if v is None:\n\n            continue\n\n        lazy[2*i-1] = data[2*i-1] = lazy[2*i] = data[2*i] = v\n\n        lazy[i-1] = None\n\n\n\n# 区間[l, r)をxで更新\n\ndef update(l, r, x):\n\n    *ids, = gindex(l, r)\n\n    propagates(*ids)\n\n\n\n    L = N0 + l; R = N0 + r\n\n    while L < R:\n\n        if R & 1:\n\n            R -= 1\n\n            lazy[R-1] = data[R-1] = x\n\n        if L & 1:\n\n            lazy[L-1] = data[L-1] = x\n\n            L += 1\n\n        L >>= 1; R >>= 1\n\n    for i in ids:\n\n        data[i-1] = max(data[2*i-1], data[2*i])\n\n\n\n# 区間[l, r)内の最小値を求める\n\ndef query(l, r):\n\n    propagates(*gindex(l, r))\n\n    L = N0 + l; R = N0 + r\n\n\n\n    s = INF\n\n    while L < R:\n\n        if R & 1:\n\n            R -= 1\n\n            s = max(s, data[R-1])\n\n        if L & 1:\n\n            s = max(s, data[L-1])\n\n            L += 1\n\n        L >>= 1; R >>= 1\n\n    return s\n\n\n\nans = 0\n\nupdate(As[0],As[0]+1,1)\n\nfor i, a in enumerate(As[1:]):\n\n    l = max(0,a-k)\n\n    r = min(mx,a+k)\n\n    upd = query(l,r+1)\n\n    if upd == -1:continue\n\n    # print(\"i\",i,\"a\",a,\"upd\",upd,\"l\",l,\"r\",r)\n\n    update(a, a+1, upd+1)\n\n    ans = max(ans, upd+1)\n\nprint(ans)\n\n\n", "generated_code": "n,k=list(map(int, input().split()))\n\nexp=list([(int(x)+1)/2 for x in input().split()]) # 入力と同時に期待値計算\n\n\n\nl=[0]*n\n\nsum1=0\n\nfor i in range(n):# 累積和の計算\n\n    sum1+=exp[i]\n\n    l[i]=sum1 \n\n\n\nans=l[k-1]\n\nfor i in range(n-k):\n\n    ans=max(ans,l[i+k]-l[i])\n\n    \n\nprint(ans)", "score": 0.0, "codebleu": 0.07442077316611981, "crystalbleu": 0.007660857977717322, "codebertscore": 0.72, "codescore": 0.8624777793884277, "surfaceSim": 0.47650459353786373, "abs_surfaceSim_minus_score": 0.47650459353786373}
{"golden_code": "while 1:\n\n n,x=list(map(int,input().split()))\n\n if n+x==0:break\n\n print((len([1 for i in range(3,n+1)for j in range(2,x-i)if x-i-j<j<i])))", "generated_code": "def sieve(n):\n\n  is_prime = [True for _ in range(n+1)]\n\n  is_prime[0] = False\n\n  for i in range(2, n+1):\n\n    if is_prime[i-1]:\n\n      j = 2 * i\n\n      while j <= n:\n\n        is_prime[j-1] = False\n\n        j += i\n\n  table = [i for i in range(1, n+1) if is_prime[i-1]]\n\n  return table\n\n\n\nN = int(eval(input()))\n\nA = list(map(int, input().split()))\n\nAmax = max(A)\n\nlis = [0]*(Amax+1)\n\nfor i in range(N):\n\n  lis[A[i]] += 1\n\ntable = sieve(Amax)\n\nsetwise = False\n\nfor t in table:\n\n  cnt = sum(lis[t:Amax+1:t])\n\n  if cnt==N:\n\n    print('not coprime')\n\n    break\n\n  if 2<=cnt<N:\n\n    setwise=True\n\nelse:\n\n  if setwise==True:\n\n    print('setwise coprime')\n\n  else:\n\n    print('pairwise coprime')\n", "score": 0.0, "codebleu": 0.24217330864860476, "crystalbleu": 0.10478558228407643, "codebertscore": 0.73, "codescore": 0.993736743927002, "surfaceSim": 0.4818093727977449, "abs_surfaceSim_minus_score": 0.4818093727977449}
{"golden_code": "A,B,C,X,Y = list(map(int,input().split()))\n\nl = []\n\nfor i in range(max(X,Y)+1):\n\n    T = i * C * 2\n\n    if i < X: \n\n        T += (X-i)*A\n\n    if i < Y:\n\n        T += (Y-i)*B\n\n    l.append(T)\n\nl.sort()\n\nprint((l[0]))", "generated_code": "n = int(eval(input()))\n\na = list(map(int, input().split()))\n\nD = {i: [0] for i in range(1, n+1)}\n\nfor i in range(n+1):\n\n  D[a[i]][0] += 1\n\n  D[a[i]].append(i)\n\npl, pr = 0, 0\n\nfor i in D:\n\n  if D[i][0] == 2:\n\n    pl = D[i][1]\n\n    pr = D[i][2]\n\n    break\n\nL = pl\n\nM = pr - pl - 1\n\nN = n - pr\n\nmod = int(1e9) + 7 # <-- input modulo\n\nmaxf = n+11          # <-- input factional limitation\n\n\n\ndef make_fact(n, k):\n\n    tmp = n\n\n    perm = [i for i in range(k)]\n\n    L = [0 for _ in range(k)]\n\n    for i in range(k):\n\n        L[i] = tmp % (i + 1)\n\n        tmp //= i + 1\n\n    LL = [0 for _ in range(k)]\n\n    for i in range(k):\n\n        LL[i] = perm[L[-i-1]]\n\n        for j in range(L[-i-1]+1, k):\n\n            perm[j-1] = perm[j]\n\n    return LL\n\n\n\ndef doubling(n, m, modulo=mod):\n\n    y = 1\n\n    base = n\n\n    tmp = m\n\n    while tmp != 0:\n\n        if tmp % 2 == 1:\n\n            y *= base\n\n            if modulo > 0:\n\n                y %= modulo\n\n        base *= base\n\n        if modulo > 0:\n\n            base %= modulo\n\n        tmp //= 2\n\n    return y\n\n\n\ndef inved(a, modulo=mod):\n\n    x, y, u, v, k, l = 1, 0, 0, 1, a, modulo\n\n    while l != 0:\n\n        x, y, u, v = u, v, x - u * (k // l), y - v * (k // l)\n\n        k, l = l, k % l\n\n    return x % modulo\n\n\n\nfact = [1 for _ in range(maxf+1)]\n\ninvf = [1 for _ in range(maxf+1)]\n\n\n\nfor i in range(maxf):\n\n    fact[i+1] = (fact[i] * (i+1)) % mod\n\ninvf[-1] = inved(fact[-1])\n\nfor i in range(maxf, 0, -1):\n\n    invf[i-1] = (invf[i] * i) % mod\n\n\n\nfor i in range(1, n+2):\n\n  S = fact[n+1]*invf[i]*invf[n-i+1]%mod\n\n  if i <= n-M:\n\n    S -= fact[n-1-M]*invf[i-1]*invf[n-M-i]%mod\n\n    S %= mod\n\n  print(S)\n", "score": 0.0, "codebleu": 0.22439201287890723, "crystalbleu": 0.0493949688910975, "codebertscore": 0.73, "codescore": 0.9935812950134277, "surfaceSim": 0.4861716589321708, "abs_surfaceSim_minus_score": 0.4861716589321708}
{"golden_code": "A,B = list(map(int,input().split()))\n\n\n\n\n\ndef kaibun(n):\n\n\tkey = 0\n\n\tfor i in range(1,n+1):\n\n\t\tif str(i) == str(i)[::-1]:\n\n\t\t\tkey += 1\n\n\treturn key\n\n\n\nprint((kaibun(B)-kaibun(A-1)))", "generated_code": "X, Y, Z, K = list(map(int, input().split()))\n\nA = sorted([int(i) for i in input().split()], reverse=True)\n\nB = sorted([int(i) for i in input().split()], reverse=True)\n\nC = sorted([int(i) for i in input().split()], reverse=True)\n\nD = []\n\nfor i in range(min(K, X)):\n\n    for j in range(min(K, Y)):\n\n        if (i + 1) * (j + 1) > K:\n\n            break\n\n        for k in range(min(K, Z)):\n\n            if (i + 1) * (j + 1) * (k + 1) > K:\n\n                break\n\n            else:\n\n\n\n                D.append(A[i] + B[j] + C[k])\n\n\n\nD.sort(reverse=True)\n\nfor i in range(K):\n\n    print((D[i]))", "score": 0.0, "codebleu": 0.2208750883256217, "crystalbleu": 0.0719802868370732, "codebertscore": 0.73, "codescore": 0.10267695039510727, "surfaceSim": 0.46868423689748473, "abs_surfaceSim_minus_score": 0.46868423689748473}
{"golden_code": "n,m,k=list(map(int,input().split()))\n\nmod=10**9+7\n\nf=[1]\n\nfor i in range(2*10**5+7):f+=[f[-1]*(i+1)%mod]\n\ndef comb(a,b):return f[a]*pow(f[b],mod-2,mod)*pow(f[a-b],mod-2,mod)%mod\n\nans=0\n\nfor i in range(1,n):\n\n  ans+=(i*(n-i)*m**2)*(comb(n*m-2,k-2))\n\n  ans%=mod\n\nfor i in range(1,m):\n\n  ans+=(i*(m-i)*n**2)*(comb(n*m-2,k-2))\n\n  ans%=mod\n\nprint(ans)", "generated_code": "import sys\n\nfrom collections import deque\n\nMAX_INT = int(10e10)\n\nMIN_INT = -MAX_INT\n\nmod = 1000000007\n\nsys.setrecursionlimit(1000000)\n\ndef IL(): return list(map(int,input().split()))\n\ndef SL(): return input().split()\n\ndef I(): return int(sys.stdin.readline())\n\ndef S(): return eval(input())\n\n\n\nN,T = IL()\n\nab = [IL() for i in range(N)]\n\nab.sort()\n\n\n\nans = 0\n\ndp = [[0]*T for i in range(N+1)]\n\nfor i in range(1,N+1):\n\n  a,b = ab[i-1]\n\n  for j in range(T):\n\n    if 0 <= j-a < T:\n\n      dp[i][j] = max(dp[i-1][j], dp[i-1][j-a] + b)\n\n    else:\n\n      dp[i][j] = dp[i-1][j]\n\n  else:\n\n    ans = max(ans, dp[i-1][-1] + b)\n\nprint(ans)", "score": 0.0, "codebleu": 0.14422434848855986, "crystalbleu": 0.11276122715215847, "codebertscore": 0.75, "codescore": 0.2155141979455948, "surfaceSim": 0.5047479588214412, "abs_surfaceSim_minus_score": 0.5047479588214412}
{"golden_code": "import sys\n\n\n\ninput = sys.stdin.readline\n\n\n\ndef main():\n\n    ans = 0\n\n    n = int(input())\n\n    o = list(map(int, input().split()))\n\n    l = [0]*n\n\n    for i in range(n):\n\n        l[o[i]-1] = i+1\n\n    for i in range(len(l)):\n\n        if  i != len(l)-1:\n\n            print(\"{} \".format(l[i]), end='')\n\n        else:\n\n            print(l[i])\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "generated_code": "def sieve(n):\n\n  is_prime = [True for _ in range(n+1)]\n\n  is_prime[0] = False\n\n  for i in range(2, n+1):\n\n    if is_prime[i-1]:\n\n      j = 2 * i\n\n      while j <= n:\n\n        is_prime[j-1] = False\n\n        j += i\n\n  table = [i for i in range(1, n+1) if is_prime[i-1]]\n\n  return table\n\n\n\nN = int(eval(input()))\n\nA = list(map(int, input().split()))\n\nAmax = max(A)\n\nlis = [0]*(Amax+1)\n\nfor i in range(N):\n\n  lis[A[i]] += 1\n\ntable = sieve(Amax)\n\nsetwise = False\n\nfor t in table:\n\n  cnt = sum(lis[t:Amax+1:t])\n\n  if cnt==N:\n\n    print('not coprime')\n\n    break\n\n  if 2<=cnt<N:\n\n    setwise=True\n\nelse:\n\n  if setwise==True:\n\n    print('setwise coprime')\n\n  else:\n\n    print('pairwise coprime')\n", "score": 0.0, "codebleu": 0.19395189835599347, "crystalbleu": 0.13535465637142818, "codebertscore": 0.75, "codescore": 0.9923802614212036, "surfaceSim": 0.5344799741602068, "abs_surfaceSim_minus_score": 0.5344799741602068}
{"golden_code": "A,B,C,X,Y=list(map(int,input().split()))\n\n\n\nK=10**9\n\nfor i in range(10**5+1):\n\n    S=i*2*C+max(0,X-i)*A+max(0,Y-i)*B\n\n    K=min(K,S)\n\nprint(K)", "generated_code": "p=m=0\n\nfor c in eval(input()):p=-~p*(c in'ATGC');m=max(m,p)\n\nprint(m)", "score": 0.0, "codebleu": 0.09488333633520714, "crystalbleu": 0.0, "codebertscore": 0.72, "codescore": 0.0782947763800621, "surfaceSim": 0.4379610999329309, "abs_surfaceSim_minus_score": 0.4379610999329309}
{"golden_code": "class SegmentTree:\n\n    seg_len = 1\n\n    node = []\n\n    def __init__(self, n):\n\n        while self.seg_len < n:\n\n            self.seg_len <<= 1\n\n        self.node = [ 0 for _ in range(self.seg_len*2) ]\n\n\n\n    def add(self, idx, v):\n\n        idx += self.seg_len\n\n        self.node[idx] += v\n\n        while True:\n\n            idx //= 2\n\n            if idx == 0:\n\n                break\n\n            self.node[idx] = self.node[idx*2] + self.node[idx*2+1]\n\n\n\n    def sum(self, l, r):\n\n        l += self.seg_len\n\n        r += self.seg_len\n\n        ret = 0\n\n        while l < r:\n\n            if l & 1 == 1:\n\n                ret += self.node[l]\n\n                l += 1\n\n            if r & 1 == 1:\n\n                ret += self.node[r-1]\n\n                r -= 1\n\n            l //= 2; r //= 2;\n\n        return ret\n\n\n\n\n\nn, k = list(map(int, input().split()))\n\np = [ int(x) for x in input().split() ]\n\n\n\nseg_tree = SegmentTree(n)\n\nfor i in range(n):\n\n    seg_tree.add(i, (1+p[i])/2)\n\n\n\nans = 0\n\nfor i in range(n-k+1):\n\n    ans = max(ans, seg_tree.sum(i, i+k))\n\n\n\nprint(ans)\n", "generated_code": "N, W = list(map(int, input().split()))\n\nitems = sorted([list(map(int, input().split())) for i in range(N)])\n\n\n\n# dp1[i][j] := 商品0 ~ i が対象\n\ndp = [[0] * (W + 1) for i in range(N + 1)]\n\n\n\n# dpテーブルを埋める\n\nfor i in range(N):\n\n    wi, vi = items[i]\n\n    for j in range(W + 1):\n\n        if j + wi <= W:\n\n            dp[i + 1][j + wi] = max(dp[i + 1][j + wi], dp[i][j] + vi)\n\n        dp[i + 1][j] = max(dp[i][j], dp[i + 1][j])\n\n\n\n\n\nans = 0\n\nfor i, (wi, vi) in enumerate(items):\n\n    ans = max(ans, dp[i][W - 1] + vi)\n\n\n\nprint(ans)\n", "score": 0.0, "codebleu": 0.14061280663114029, "crystalbleu": 0.159353844955989, "codebertscore": 0.72, "codescore": 0.9120174646377563, "surfaceSim": 0.5564867412181267, "abs_surfaceSim_minus_score": 0.5564867412181267}
{"golden_code": "import sys\n\ndef input(): return sys.stdin.readline().rstrip()\n\ndef main():\n\n    x=int(eval(input()))\n\n    for i in range(-300,300):\n\n        for j in range(-300,300):\n\n            if i**5-j**5==x:\n\n                print((i,j))\n\n                sys.exit()\n\n\n\nif __name__=='__main__':\n\n    main()", "generated_code": "K, S = list(map(int,input().split(\" \")))\n\nans = 0\n\nfor X in range(K+1):\n\n    for Y in range(K+1):\n\n        if 0 <= (S - X - Y) <= K:\n\n            ans += 1\n\n\n\nprint(ans)", "score": 0.0, "codebleu": 0.14043892601864416, "crystalbleu": 0.0, "codebertscore": 0.74, "codescore": 0.5156992077827454, "surfaceSim": 0.5294784580498866, "abs_surfaceSim_minus_score": 0.5294784580498866}
{"golden_code": "import numpy as np\n\n\n\nh, w = tuple(map(int, input().split()))\n\nmatrix = np.zeros((h, w), dtype=bool)\n\nfor i in range(h):\n\n    row = np.array(list(input()))\n\n    matrix[i, :] = row == \".\"\n\n\n\nfor i in range(h)[::-1]:\n\n    if np.all(matrix[i, :]):\n\n        matrix = np.delete(matrix, i, 0)\n\n\n\nfor i in range(w)[::-1]:\n\n    if np.all(matrix[:, i]):\n\n        matrix = np.delete(matrix, i, 1)\n\n\n\nmatrix = np.where(matrix, \".\", \"#\")\n\nfor row in matrix:\n\n    for e in row:\n\n        print(e, end=\"\")\n\n    print()\n", "generated_code": "class SegmentTree:\n\n    seg_len = 1\n\n    node = []\n\n    def __init__(self, n):\n\n        while self.seg_len < n:\n\n            self.seg_len <<= 1\n\n        self.node = [ 0 for _ in range(self.seg_len*2) ]\n\n\n\n    def add(self, idx, v):\n\n        idx += self.seg_len\n\n        self.node[idx] += v\n\n        while True:\n\n            idx >>= 1\n\n            if idx == 0:\n\n                break\n\n            self.node[idx] = self.node[idx*2] + self.node[idx*2+1]\n\n\n\n    def sum(self, l, r):\n\n        l += self.seg_len\n\n        r += self.seg_len\n\n        ret = 0\n\n        while l < r:\n\n            if l & 1 == 1:\n\n                ret += self.node[l]\n\n                l += 1\n\n            if r & 1 == 1:\n\n                ret += self.node[r-1]\n\n                r -= 1\n\n            l >>= 1; r >>= 1;\n\n        return ret\n\n\n\n\n\nn, k = list(map(int, input().split()))\n\np = [ int(x) for x in input().split() ]\n\n\n\nseg_tree = SegmentTree(n)\n\nfor i in range(n):\n\n    seg_tree.add(i, (1+p[i])/2)\n\n\n\nans = 0\n\nfor i in range(n-k+1):\n\n    ans = max(ans, seg_tree.sum(i, i+k))\n\n\n\nprint(ans)\n", "score": 0.0, "codebleu": 0.19795442261062257, "crystalbleu": 0.08609541136045863, "codebertscore": 0.69, "codescore": 0.710493266582489, "surfaceSim": 0.4447647020143349, "abs_surfaceSim_minus_score": 0.4447647020143349}
{"golden_code": "print((sum(si != ti for si, ti in zip(eval(input()), eval(input())))))\n", "generated_code": "S = eval(input())\n\n\n\nans = 0\n\n\n\nfor i in range(len(S)) :\n\n    for j in range(i, len(S)) :\n\n        if all('ACGT'.count(c) == 1 for c in S[i : j + 1]) :\n\n            ans = max(ans, j - i + 1)\n\n\n\n\n\nprint(ans)\n", "score": 0.0, "codebleu": 0.16605976001159162, "crystalbleu": 0.0, "codebertscore": 0.73, "codescore": 0.7525575757026672, "surfaceSim": 0.436429512516469, "abs_surfaceSim_minus_score": 0.436429512516469}
{"golden_code": "N = int(eval(input()))\n\n\n\n\n\ndef dist(i, j):\n\n    return i + j - 2\n\n\n\n\n\nmin = 10 ** 24\n\ni = 1\n\nwhile (i ** 2) <= N:\n\n    if 0 == N % i:\n\n        j = N // i\n\n        d = dist(i, j)\n\n        if min > d:\n\n            min = d\n\n    i += 1\n\nprint(d)\n", "generated_code": "S = int(eval(input()))\n\n\n\n\n\ndef cmb(n, r, p):\n\n    r = min(n - r, r)\n\n    if r == 0:\n\n        return 1\n\n    over = 1\n\n    for i in range(n, n - r, -1):\n\n        over = over * i % p\n\n    under = 1\n\n    for i in range(1, r + 1):\n\n        under = under * i % p\n\n    inv = pow(under, p - 2, p)\n\n    return over * inv % p\n\n\n\n\n\nM = 10 ** 9 + 7\n\nans = 0\n\nfor i in range(1, S):\n\n    if S - 3 * i < 0:\n\n        break\n\n    ans += cmb(S - 3 * i + i - 1, i - 1, M)\n\n    ans %= M\n\nprint(ans)\n", "score": 0.0, "codebleu": 0.279371038845206, "crystalbleu": 0.1256186239482841, "codebertscore": 0.77, "codescore": 0.9583345651626587, "surfaceSim": 0.6226345208431544, "abs_surfaceSim_minus_score": 0.6226345208431544}
{"golden_code": "M=998244353\n\nn,m,k=list(map(int,input().split()))\n\na=0\n\nc=1\n\nfor i in range(k+1):\n\n  a+=c*m*pow(m-1,n-i-1,M)\n\n  c=c*(n-i-1)*pow(i+1,M-2,M)%M\n\nprint((a%M))", "generated_code": "#!usr/bin/env python3\n\nfrom collections import defaultdict,deque\n\nfrom heapq import heappush, heappop\n\nfrom itertools import permutations\n\nimport sys\n\nimport math\n\nimport bisect\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\n\ndef I(): return int(sys.stdin.readline())\n\ndef LS():return [list(x) for x in sys.stdin.readline().split()]\n\ndef S():\n\n    res = list(sys.stdin.readline())\n\n    if res[-1] == \"\\n\":\n\n        return res[:-1]\n\n    return res\n\ndef IR(n):\n\n    return [I() for i in range(n)]\n\ndef LIR(n):\n\n    return [LI() for i in range(n)]\n\ndef SR(n):\n\n    return [S() for i in range(n)]\n\ndef LSR(n):\n\n    return [LS() for i in range(n)]\n\n\n\nsys.setrecursionlimit(1000000)\n\nmod = 1000000007\n\n\n\ndef solve():\n\n    A,B,C,x,y = LI()\n\n    ans = float(\"inf\")\n\n    for c in range(200001)[::2]:\n\n        a = b = c >> 1\n\n        a = max(0,x-a)\n\n        b = max(0,y-b)\n\n        s = A*a+B*b+C*c\n\n        if s < ans:\n\n            ans = s\n\n    print(ans)\n\n    return\n\n\n\n#Solve\n\nif __name__ == \"__main__\":\n\n    solve()\n", "score": 0.0, "codebleu": 0.2100771608451132, "crystalbleu": 0.03280936850362576, "codebertscore": 0.68, "codescore": 0.01870492473244667, "surfaceSim": 0.3836011035378124, "abs_surfaceSim_minus_score": 0.3836011035378124}
{"golden_code": "import numpy as np\n\n\n\nncity, nlines = list(map(int, input().rstrip(\"\\n\").split()))\n\nmatrix = np.zeros((ncity, ncity), dtype=int)\n\nfor _ in range(nlines):\n\n    l, c = [int(x) - 1 for x in input().rstrip(\"\\n\").split()]\n\n    matrix[l][c] += 1\n\n    matrix[c][l] += 1\n\n\n\nfor list_ in matrix:\n\n    print((sum(list_)))", "generated_code": "N = int(eval(input()))\n\nS = [eval(input()) for i in range(N)]\n\nfrom collections import Counter\n\nctr = Counter([s[0] for s in S])\n\n\n\nans = 0\n\nimport itertools\n\nfor ptn in itertools.combinations('MARCH', 3):\n\n    t = 1\n\n    for c in ptn:\n\n        t *= ctr[c]\n\n    ans += t\n\nprint(ans)", "score": 0.0, "codebleu": 0.13260624132260318, "crystalbleu": 0.0, "codebertscore": 0.72, "codescore": 0.31307417154312134, "surfaceSim": 0.5566720257234727, "abs_surfaceSim_minus_score": 0.5566720257234727}
{"golden_code": "import sys\n\ns = input()\n\nts = ['']\n\nwhile True:\n\n  nts= []\n\n  for t in ts:\n\n    for w in ['dreamer', 'eraser', 'dream', 'erase']:\n\n      if s == t + w:\n\n        print('YES')\n\n        sys.exit()\n\n      if s.startswith(t + w):\n\n        nts.append(t + w)\n\n  if len(nts) == 0:\n\n    print('NO')\n\n    sys.exit()\n\n  ts = nts\n", "generated_code": "import sys\n\nans = 'Yes'; eval(input())\n\nfor e in sys.stdin:\n\n    t, x, y = list(map(int, e.split()))\n\n    t = t - x - y\n\n    if t < 0 or t % 2 == 1: ans = 'No'; break\n\nprint(ans)", "score": 0.0, "codebleu": 0.16399727637351574, "crystalbleu": 0.0, "codebertscore": 0.73, "codescore": 0.9921790361404419, "surfaceSim": 0.5561199806482826, "abs_surfaceSim_minus_score": 0.5561199806482826}
{"golden_code": "import numpy as np\n\nN = int(eval(input()))\n\ndp = [[0, 0, 0] for i in range(N+1)]\n\nfor i in range(1, N+1):\n\n    a, b, c = list(map(int, input().split(' ')))\n\n    dp[i][0] = max(dp[i-1][1], dp[i-1][2]) + a\n\n    dp[i][1] = max(dp[i-1][0], dp[i-1][2]) + b\n\n    dp[i][2] = max(dp[i-1][0], dp[i-1][1]) + c\n\nprint((np.max(dp[-1])))", "generated_code": "import sys\n\nans = 'Yes'; eval(input())\n\nfor e in sys.stdin:\n\n    t, x, y = list(map(int, e.split()))\n\n    t = t - x - y\n\n    if t < 0 or t % 2 == 1: ans = 'No'; break\n\nprint(ans)", "score": 0.0, "codebleu": 0.10494532323647757, "crystalbleu": 0.033579308297068865, "codebertscore": 0.71, "codescore": 0.9888203740119934, "surfaceSim": 0.4533552369573875, "abs_surfaceSim_minus_score": 0.4533552369573875}
{"golden_code": "H, W = list(map(int, input().split()))\n\nimport numpy as np\n\nGrid = np.array([[0 if x == '.' else -1 for x in eval(input())] for _ in range(H)],dtype='int64')\n\n\n\ndef solveMase(Grid, start, goal): #bfsで迷路を解き、スタート-ゴール間の最低必要白マス数を返す\n\n    seen = {start}\n\n    V = [start]\n\n    while len(V) != 0: #bfs\n\n        v = V.pop(0)\n\n        if v == goal:\n\n            return Grid[goal]\n\n        #移動先nvをリストにまとめる\n\n        y,x = v\n\n        nV = []\n\n        if x > 0: nV.append((y,x-1))\n\n        if y > 0: nV.append((y-1,x))\n\n        if x < W-1: nV.append((y,x+1))\n\n        if y < H-1: nV.append((y+1,x))\n\n        #bfs\n\n        for nv in nV:\n\n            if Grid[nv] == -1 or nv in seen:\n\n                continue\n\n            Grid[nv] = Grid[v] + 1\n\n            V.append(nv)\n\n            seen.add(nv)\n\n    return 0\n\n\n\nwhite = len(Grid[Grid == 0])-1\n\nnes_white = solveMase(Grid, (0,0), (H-1,W-1))\n\nprint((white-nes_white if nes_white > 0 else -1))", "generated_code": "n = int(eval(input()))\n\nans = 0\n\nfor i in map(int, input().split()):\n\n    cnt = 0\n\n    while i % 2 == 0:\n\n        i >>= 1\n\n        cnt += 1\n\n    ans += cnt\n\nprint(ans)", "score": 0.0, "codebleu": 0.054241466292127144, "crystalbleu": 0.004120443565293213, "codebertscore": 0.64, "codescore": 0.3215937316417694, "surfaceSim": 0.40831862312444833, "abs_surfaceSim_minus_score": 0.40831862312444833}
{"golden_code": "n,m=list(map(int,input().split()))\n\nc=[0]*(n+2)\n\nfor i in range(m):\n\n  l,r=list(map(int,input().split()))\n\n  c[l-1]+=1\n\n  c[r]-=1\n\nfor i in range(1,n+2):\n\n  c[i]=c[i]+c[i-1]\n\nans=0\n\nfor i in range(n+2):\n\n  if c[i]==m:\n\n    ans+=1\n\nprint(ans)", "generated_code": "inputCount = int(eval(input()))\n\nprices = [int(eval(input())) for lp in range(inputCount)]\n\naverage = sum(prices) // inputCount\n\nprint(average)\n\n\n", "score": 0.0, "codebleu": 0.08793346826967342, "crystalbleu": 0.002221632341455676, "codebertscore": 0.71, "codescore": 0.24384523928165436, "surfaceSim": 0.34464730290456436, "abs_surfaceSim_minus_score": 0.34464730290456436}
{"golden_code": "#                         author:  kagemeka \n\n#                         created: 2019-11-08 14:51:29(JST)\n\n## internal modules\n\nimport sys\n\n# import collections\n\n# import math\n\n# import string\n\n# import bisect\n\n# import re\n\n# import itertools\n\nimport statistics\n\n# import functools\n\n# import operator\n\n## external modules\n\n# import scipy.special   # if use comb function on AtCoder, \n\n# import scipy.misc      # select scipy.misc.comb (old version) \n\n\n\ndef main():\n\n    n, *a = (int(x) for x in sys.stdin.read().split())\n\n    \n\n    for i in range(n):\n\n        a[i] -= (i + 1)\n\n\n\n    if n % 2 != 0:\n\n        b = statistics.median(a)\n\n    else:\n\n        if a.count(statistics.median_high(a)) >= a.count(statistics.median_low(a)):\n\n            b = statistics.median_high(a)\n\n        else:\n\n            b = statistics.median_low(a)\n\n    \n\n    ans = sum([abs(a[i] - b) for i in range(n)])\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    # execute only if run as a script\n\n    main()\n\n\n\n\n", "generated_code": "n = int(eval(input()))\n\na = list(map(int, input().split()))\n\nD = {i: [0] for i in range(1, n+1)}\n\nfor i in range(n+1):\n\n  D[a[i]][0] += 1\n\n  D[a[i]].append(i)\n\npl, pr = 0, 0\n\nfor i in D:\n\n  if D[i][0] == 2:\n\n    pl = D[i][1]\n\n    pr = D[i][2]\n\n    break\n\nL = pl\n\nM = pr - pl - 1\n\nN = n - pr\n\nmod = int(1e9) + 7 # <-- input modulo\n\nmaxf = n+11          # <-- input factional limitation\n\n\n\ndef make_fact(n, k):\n\n    tmp = n\n\n    perm = [i for i in range(k)]\n\n    L = [0 for _ in range(k)]\n\n    for i in range(k):\n\n        L[i] = tmp % (i + 1)\n\n        tmp //= i + 1\n\n    LL = [0 for _ in range(k)]\n\n    for i in range(k):\n\n        LL[i] = perm[L[-i-1]]\n\n        for j in range(L[-i-1]+1, k):\n\n            perm[j-1] = perm[j]\n\n    return LL\n\n\n\ndef doubling(n, m, modulo=mod):\n\n    y = 1\n\n    base = n\n\n    tmp = m\n\n    while tmp != 0:\n\n        if tmp % 2 == 1:\n\n            y *= base\n\n            if modulo > 0:\n\n                y %= modulo\n\n        base *= base\n\n        if modulo > 0:\n\n            base %= modulo\n\n        tmp //= 2\n\n    return y\n\n\n\ndef inved(a, modulo=mod):\n\n    x, y, u, v, k, l = 1, 0, 0, 1, a, modulo\n\n    while l != 0:\n\n        x, y, u, v = u, v, x - u * (k // l), y - v * (k // l)\n\n        k, l = l, k % l\n\n    return x % modulo\n\n\n\nfact = [1 for _ in range(maxf+1)]\n\ninvf = [1 for _ in range(maxf+1)]\n\n\n\nfor i in range(maxf):\n\n    fact[i+1] = (fact[i] * (i+1)) % mod\n\ninvf[-1] = inved(fact[-1])\n\nfor i in range(maxf, 0, -1):\n\n    invf[i-1] = (invf[i] * i) % mod\n\n\n\nfor i in range(1, n+2):\n\n  S = fact[n+1]*invf[i]*invf[n-i+1]%mod\n\n  if i <= n-M:\n\n    S -= fact[n-1-M]*invf[i-1]*invf[n-M-i]%mod\n\n    S %= mod\n\n  print(S)\n", "score": 0.0, "codebleu": 0.20008671692974858, "crystalbleu": 0.03648813206554912, "codebertscore": 0.71, "codescore": 0.9937745332717896, "surfaceSim": 0.5415090061363603, "abs_surfaceSim_minus_score": 0.5415090061363603}
{"golden_code": "import statistics\n\nN = int(eval(input()))\n\nA = [int(a)-i-1 for i,a in enumerate(input().split(),1)]\n\nb = statistics.median_low(A)\n\nc = statistics.median_high(A)\n\nd = sum([abs(x-b) for x in A])\n\ne = sum([abs(x-c) for x in A])\n\nprint((min(d,e)))", "generated_code": "n = int(eval(input()))\n\n\n\nans = 1\n\nfor i in range(1, n+1):\n\n    ans = ans * i\n\n    ans = ans % ((10 ** 9)+7)  # 途中で割り算の余りを求めても、最終結果は同じになる\n\n\n\nprint(ans)", "score": 0.0, "codebleu": 0.1279247153135148, "crystalbleu": 0.0, "codebertscore": 0.7, "codescore": 0.12044885009527206, "surfaceSim": 0.3994708994708994, "abs_surfaceSim_minus_score": 0.3994708994708994}
{"golden_code": "'''\n\n    Auther: ghoshashis545 Ashis Ghosh\n\n    College: jalpaiguri Govt Enggineering College\n\n\n\n'''\n\nfrom os import path\n\nimport sys\n\nfrom functools import cmp_to_key as ctk\n\nfrom collections import deque,defaultdict as dd \n\nfrom bisect import bisect,bisect_left,bisect_right,insort,insort_left,insort_right\n\nfrom itertools import permutations\n\nfrom datetime import datetime\n\nfrom math import ceil,sqrt,log,gcd\n\ndef ii():return int(eval(input()))\n\ndef si():return eval(input())\n\ndef mi():return list(map(int,input().split()))\n\ndef li():return list(mi())\n\nabc='abcdefghijklmnopqrstuvwxyz'\n\nmod=1000000007\n\n#mod=998244353\n\ninf = float(\"inf\")\n\nvow=['a','e','i','o','u']\n\ndx,dy=[-1,1,0,0],[0,0,1,-1]\n\n\n\ndef bo(i):\n\n    return ord(i)-ord('a')\n\n\n\nfile = 0\n\n\n\ndef solve():\n\n    \n\n\n\n\n\n\n\n    # for _ in range(ii()):\n\n\n\n    n=ii()\n\n    n%=1000\n\n    if n!=0:\n\n        n=1000-n\n\n    print(n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nif __name__ ==\"__main__\":\n\n\n\n    if(file):\n\n\n\n        if path.exists('input1.txt'):\n\n            sys.stdin=open('input1.txt', 'r')\n\n            sys.stdout=open('output1.txt','w')\n\n        else:\n\n            input=sys.stdin.readline\n\n    solve()", "generated_code": "n = int(eval(input()))\n\n\n\nans = 1\n\nfor i in range(1, n+1):\n\n    ans = ans * i\n\n    ans = ans % ((10 ** 9)+7)  # 途中で割り算の余りを求めても、最終結果は同じになる\n\n\n\nprint(ans)", "score": 0.0, "codebleu": 0.08326792527491714, "crystalbleu": 0.0009494157266887637, "codebertscore": 0.6, "codescore": 0.13062915205955505, "surfaceSim": 0.31133474576271186, "abs_surfaceSim_minus_score": 0.31133474576271186}
{"golden_code": "n,k = list(map(int,input().split()))\n\narr = list(map(int,input().split()))\n\n\n\ndp = [False]*(k+1)\n\n\n\nfor stones in range(k+1):\n\n    for x in arr:\n\n        if stones >= x and dp[stones-x] == False:\n\n            dp[stones] = True\n\n\n\nif dp[k]:\n\n    print(\"First\")\n\nelse:\n\n    print(\"Second\")\n", "generated_code": "N = int(eval(input()))\n\ndp = [[0, 0, 0] for i in range(N+1)]\n\nfor i in range(1, N+1):\n\n    a, b, c = list(map(int, input().split(' ')))\n\n    dp[i][0] = max(dp[i-1][1], dp[i-1][2]) + a\n\n    dp[i][1] = max(dp[i-1][0], dp[i-1][2]) + b\n\n    dp[i][2] = max(dp[i-1][0], dp[i-1][1]) + c\n\nprint((max(dp[-1])))", "score": 0.0, "codebleu": 0.1966772056546774, "crystalbleu": 0.16042190110205812, "codebertscore": 0.77, "codescore": 0.0763222873210907, "surfaceSim": 0.49626245847176076, "abs_surfaceSim_minus_score": 0.49626245847176076}
{"golden_code": "import re\n\n\n\nS = eval(input())\n\nmax = 0\n\n\n\nfor i in range(len(S)) :\n\n    for j in range(i + 1, len(S) + 1) :\n\n        pattern = re.compile(r'[A|T|C|G]{%d}' % int(j - i))\n\n        subStr = S[i:j]\n\n\n\n        if pattern.match(subStr) and j - i > max :\n\n            max = j - i\n\n\n\nprint(max)\n", "generated_code": "a,b,c,x,y = list(map(int,input().split()))\n\na1 = a*x + b*y\n\na2 = max(x,y) * 2*c\n\nif y >= x:\n\n    a3 = 2*c*x + (y-x)*b\n\nelse:\n\n    a3 = 2*c*y + (x-y)*a\n\nprint((min(a1,a2,a3)))", "score": 0.0, "codebleu": 0.15158487184330285, "crystalbleu": 0.0, "codebertscore": 0.68, "codescore": 0.24157314002513885, "surfaceSim": 0.4879807692307692, "abs_surfaceSim_minus_score": 0.4879807692307692}
{"golden_code": "from functools import lru_cache\n\nimport sys\n\n\n\nsys.setrecursionlimit(10 ** 7)\n\n\n\n\n\n@lru_cache(maxsize=None)\n\ndef check(l, r, n, k=1):\n\n    t = l + '0' * k + r\n\n    e = l + '9' * k + r\n\n\n\n    if int(e) <= n:\n\n        return pow(10, k) + check(l, r, n, k + 1)\n\n\n\n    if int(t) <= n < int(e):\n\n        x = int(str(n)[1:-1])\n\n        if int(str(n)[-1]) < int(r):\n\n            x -= 1\n\n        return x + 1\n\n\n\n    if n < int(t):\n\n        return 0\n\n\n\n\n\ndef main():\n\n    n = int(eval(input()))\n\n\n\n    ret = 0\n\n    for x in range(1, n + 1):\n\n        if x % 10 == 0:\n\n            continue\n\n        s = str(x)\n\n        t = s[-1] + s[0]\n\n        if s[0] == s[-1]:\n\n            ret += 1\n\n        if int(t) <= n:\n\n            ret += 1\n\n        ret += check(s[-1], s[0], n, k=1)\n\n\n\n    print(ret)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "generated_code": "import sys\n\ninput = sys.stdin.readline\n\n\n\nn = int(eval(input()))\n\nedges = []\n\n\n\nfor id in range(n-1):\n\n    a, b = list(map(int, input().split()))\n\n    edges.append([a-1, b-1, id])\n\n\n\nedges.sort()\n\n\n\nused = [0]*(n)\n\nans = [0]*(n-1)\n\nnum = 1\n\nprev = 0\n\nfor edge in edges:\n\n    _from, to, id = edge\n\n    if _from != prev:\n\n        num = 1\n\n    if used[_from] == num:\n\n        num += 1\n\n    ans[id] = num\n\n    used[to] = num\n\n    num += 1\n\n    prev = _from\n\n\n\nprint((max(ans)))\n\nfor color in ans:\n\n    print(color)\n", "score": 0.0, "codebleu": 0.15841609033664392, "crystalbleu": 0.051406615319548585, "codebertscore": 0.72, "codescore": 0.9919894337654114, "surfaceSim": 0.5447631464580617, "abs_surfaceSim_minus_score": 0.5447631464580617}
{"golden_code": "N = int(eval(input()))\n\nx = list(map(int, input().split()))\n\ncnt = 0\n\nfor i in x:\n\n  while i % 2 == 0:\n\n    cnt += 1\n\n    i /= 2\n\nprint(cnt)", "generated_code": "import math\n\nn = int(eval(input()))\n\n\n\nans = 0\n\nfor i in range(math.ceil(math.sqrt(n) + 1))[:0:-1]:\n\n    if 0 == n % i:\n\n        ans = i\n\n        break\n\nans_partner = n // ans\n\nprint((ans + ans_partner - 2))\n", "score": 0.0, "codebleu": 0.26404342706771083, "crystalbleu": 0.0, "codebertscore": 0.77, "codescore": 0.7446645498275757, "surfaceSim": 0.520260989010989, "abs_surfaceSim_minus_score": 0.520260989010989}
{"golden_code": "import math\n\nN = int(eval(input()))\n\nprint((math.factorial(N)%(10**9+7)))", "generated_code": "n, m, l = list(map(int, input().split()))\n\n\n\na = [0]*n\n\nb = [0]*m\n\nc = [[0 for col in range(l)] for row in range(n)]\n\n\n\nfor i in range(n):\n\n    a[i] = list(map(int,input().split()))\n\n\n\nfor i in range(m):\n\n    b[i] = list(map(int,input().split()))\n\n\n\n\n\nfor i in range(n):\n\n    for j in range(l):\n\n        c[i][j] = sum([a[i][k]*b[k][j] for k in range(m)])\n\n#        for k in range(m):\n\n#            c[i][j] += a[i][k]*b[k][j]\n\n    print((*c[i]))", "score": 0.0, "codebleu": 0.2580941778981124, "crystalbleu": 0.027748565638965536, "codebertscore": 0.63, "codescore": 0.5816817283630371, "surfaceSim": 0.43581081081081086, "abs_surfaceSim_minus_score": 0.43581081081081086}
{"golden_code": "a, b, m = list(map(int,input().split()))\n\ndr = list(map(int,input().split()))\n\nwa = list(map(int,input().split()))\n\nxyc = [list(map(int,input().split())) for i in range(m)]\n\nlow = 200001\n\n\n\nfor i in range(m):\n\n    f = xyc[i][0] - 1\n\n    d = xyc[i][1] - 1\n\n    if low >= dr[f]+wa[d]-xyc[i][2]:\n\n        low = dr[f]+wa[d]-xyc[i][2]\n\n\n\ndr.sort()\n\nwa.sort()\n\n\n\nif low >= (dr[0] + wa[0]):\n\n    print((dr[0] + wa[0]))\n\nelse:\n\n    print(low)", "generated_code": "\n\n\n\nimport sys\n\ninput = sys.stdin.readline\n\nsys.setrecursionlimit(2147483647)\n\nINF=float(\"inf\")\n\nMOD=10**9+7\n\n# A = [ int(input()) for _ in range(N) ]\n\n##############################\n\n\n\nN, W = list(map(int, input().split()))\n\nw = []\n\nv = []\n\nfor i in range(N):\n\n    a, b = list(map(int, input().split()))\n\n    w.append(a)\n\n    v.append(b)\n\n\n\nV = sum(v)\n\n\n\ndp = [ [INF for _ in range(V+1)] for _ in range(N+1) ]\n\n\n\ndp[0][0] = 0\n\n\n\nfor i in range(N):\n\n    for j in range(V+1):\n\n        if j - v[i] < 0:\n\n            dp[i+1][j] = dp[i][j]\n\n        else:\n\n            dp[i+1][j] = min(dp[i][j], dp[i][j-v[i]]+w[i])\n\n\n\n#print(dp[N])\n\n\n\nans = 0\n\nfor v in range(V+1):\n\n    if dp[N][v] <= W:\n\n        ans = v\n\n\n\nprint(ans)\n", "score": 0.0, "codebleu": 0.2338018017835431, "crystalbleu": 0.12074655253380323, "codebertscore": 0.75, "codescore": 0.5767775774002075, "surfaceSim": 0.6633773633773634, "abs_surfaceSim_minus_score": 0.6633773633773634}
{"golden_code": "import numpy as np\n\n\n\nN = int(eval(input()))\n\nX = np.array(list(int(x) for x in input().split()))\n\nm = round(np.mean(X))\n\n\n\nprint((int(sum((X-m)**2))))", "generated_code": "n = int(eval(input()))\n\na = list(map(int, input().split()))\n\nD = {i: [0] for i in range(1, n+1)}\n\nfor i in range(n+1):\n\n  D[a[i]][0] += 1\n\n  D[a[i]].append(i)\n\npl, pr = 0, 0\n\nfor i in D:\n\n  if D[i][0] == 2:\n\n    pl = D[i][1]\n\n    pr = D[i][2]\n\n    break\n\nL = pl\n\nM = pr - pl - 1\n\nN = n - pr\n\nmod = int(1e9) + 7 # <-- input modulo\n\nmaxf = n+11          # <-- input factional limitation\n\n\n\ndef make_fact(n, k):\n\n    tmp = n\n\n    perm = [i for i in range(k)]\n\n    L = [0 for _ in range(k)]\n\n    for i in range(k):\n\n        L[i] = tmp % (i + 1)\n\n        tmp //= i + 1\n\n    LL = [0 for _ in range(k)]\n\n    for i in range(k):\n\n        LL[i] = perm[L[-i-1]]\n\n        for j in range(L[-i-1]+1, k):\n\n            perm[j-1] = perm[j]\n\n    return LL\n\n\n\ndef doubling(n, m, modulo=mod):\n\n    y = 1\n\n    base = n\n\n    tmp = m\n\n    while tmp != 0:\n\n        if tmp % 2 == 1:\n\n            y *= base\n\n            if modulo > 0:\n\n                y %= modulo\n\n        base *= base\n\n        if modulo > 0:\n\n            base %= modulo\n\n        tmp //= 2\n\n    return y\n\n\n\ndef inved(a, modulo=mod):\n\n    x, y, u, v, k, l = 1, 0, 0, 1, a, modulo\n\n    while l != 0:\n\n        x, y, u, v = u, v, x - u * (k // l), y - v * (k // l)\n\n        k, l = l, k % l\n\n    return x % modulo\n\n\n\nfact = [1 for _ in range(maxf+1)]\n\ninvf = [1 for _ in range(maxf+1)]\n\n\n\nfor i in range(maxf):\n\n    fact[i+1] = (fact[i] * (i+1)) % mod\n\ninvf[-1] = inved(fact[-1])\n\nfor i in range(maxf, 0, -1):\n\n    invf[i-1] = (invf[i] * i) % mod\n\n\n\nfor i in range(1, n+2):\n\n  S = fact[n+1]*invf[i]*invf[n-i+1]%mod\n\n  if i <= n-M:\n\n    S -= fact[n-1-M]*invf[i-1]*invf[n-M-i]%mod\n\n    S %= mod\n\n  print(S)\n", "score": 0.0, "codebleu": 0.26969276079262855, "crystalbleu": 0.041625150126810555, "codebertscore": 0.65, "codescore": 0.9937321543693542, "surfaceSim": 0.3540088796030295, "abs_surfaceSim_minus_score": 0.3540088796030295}
{"golden_code": "import sys\n\nimport numpy as np\n\n\n\nsr = lambda: sys.stdin.readline().rstrip()\n\nir = lambda: int(sr())\n\nlr = lambda: list(map(int, sr().split()))\n\n\n\nN = ir()\n\n# Aの先頭の桁と末尾の桁の組み合わせは9*10=90通りだけ\n\ntable = [[0] * 10 for i in range(10)]\n\nfor x in range(1, N+1):\n\n    x = str(x)\n\n    i = int(x[0])\n\n    j = int(x[-1])\n\n    table[i][j] += 1\n\n\n\ntable = np.array(table)\n\nanswer = (table * table.T).sum()\n\nprint(answer)\n", "generated_code": "def main():\n\n    n, *a, = list(map(int, open(0).read().split()))\n\n    a = [x - i for i, x in enumerate(a, 1)]\n\n    a.sort()\n\n    if n % 2 == 0:\n\n        ans = sum(a[n // 2:]) - sum(a[:n // 2])\n\n    else:\n\n        ans = sum(a[n // 2 + 1:]) - sum(a[:n // 2])\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 0.0, "codebleu": 0.1236784773466513, "crystalbleu": 0.10875054593504468, "codebertscore": 0.69, "codescore": 0.018834395334124565, "surfaceSim": 0.42610837438423643, "abs_surfaceSim_minus_score": 0.42610837438423643}
{"golden_code": "N,M = [int(c) for c in input().split()]\n\nab = [list(map(int,input().split())) for c in range(N)]\n\ncd = [list(map(int,input().split())) for c in range(M)]\n\nfor i in range(N):\n\n    mi = 2*10**9\n\n    for j in range(M):\n\n        tmp = abs(ab[i][0]-cd[j][0])+abs(ab[i][1]-cd[j][1])\n\n        if mi > tmp:\n\n            mi = tmp\n\n            ans = j+1\n\n    print(ans)\n", "generated_code": "N, M = [int(x) for x in input().split()]\n\nL = [[int (y) for y in input().split()] for _ in range(M)]\n\nL = sum(L, [])\n\n\n\nfor i in range(1, N+1):\n\n    print((L.count(i)))", "score": 0.0, "codebleu": 0.19521917054603963, "crystalbleu": 0.07417055574191346, "codebertscore": 0.81, "codescore": 0.20282626152038574, "surfaceSim": 0.5847222222222223, "abs_surfaceSim_minus_score": 0.5847222222222223}
{"golden_code": "import itertools\n\nfrom collections import Counter\n\nN = int(eval(input()))\n\nsrc = [eval(input()) for i in range(N)]\n\nctr = Counter()\n\nfor s in src:\n\n    ctr[s[0]] += 1\n\n\n\nans = 0\n\nfor ptn in itertools.combinations('MARCH',3):\n\n    a,b,c = ptn\n\n    ans += ctr[a]*ctr[b]*ctr[c]\n\nprint(ans)", "generated_code": "N, W = list(map(int, input().split()))\n\nitems = sorted([list(map(int, input().split())) for i in range(N)])\n\n\n\n# dp1[i][j] := 商品0 ~ i が対象\n\ndp = [[0] * (W + 1) for i in range(N + 1)]\n\n\n\n# dpテーブルを埋める\n\nfor i in range(N):\n\n    wi, vi = items[i]\n\n    for j in range(W + 1):\n\n        if j + wi <= W:\n\n            dp[i + 1][j + wi] = max(dp[i + 1][j + wi], dp[i][j] + vi)\n\n        dp[i + 1][j] = max(dp[i][j], dp[i + 1][j])\n\n\n\n\n\nans = 0\n\nfor i, (wi, vi) in enumerate(items):\n\n    ans = max(ans, dp[i][W - 1] + vi)\n\n\n\nprint(ans)\n", "score": 0.0, "codebleu": 0.24979782262493605, "crystalbleu": 0.08593218187677044, "codebertscore": 0.7, "codescore": 0.8323856592178345, "surfaceSim": 0.5866922584772873, "abs_surfaceSim_minus_score": 0.5866922584772873}
{"golden_code": "import numpy as np\n\nimport numba\n\nfrom numba import njit, b1, i4, i8, f8\n\n\n\n@njit((i8, i8[:]), cache=True)\n\ndef main(N,A):\n\n  Amax = np.max(A)\n\n  lis = np.zeros(Amax+1, np.int64)\n\n  for i in range(N):\n\n    lis[A[i]] += 1\n\n  setwise = False\n\n  for t in range(2,Amax+1):\n\n    cnt = np.sum(lis[t:Amax+1:t])\n\n    if cnt==N:\n\n      return 'not'\n\n    if 2<=cnt<N:\n\n      setwise=True\n\n  if setwise==True:\n\n    return 'setwise'\n\n  return 'pairwise'\n\n\n\nN = int(eval(input()))\n\nA = np.array(list(map(int, input().split())))\n\nprint((main(N,A)+' coprime'))\n\n\n", "generated_code": "# 2019-11-12 22:21:08(JST)\n\nimport sys\n\n# import collections\n\n# import math\n\n# from string import ascii_lowercase, ascii_uppercase, digits\n\n# from bisect import bisect_left as bi_l, bisect_right as bi_r\n\n# import itertools\n\n# from functools import reduce\n\n# import operator as op\n\n# from scipy.misc import comb # float\n\n# import numpy as np \n\n\n\ndef main():\n\n    s = sys.stdin.readline().rstrip()\n\n    \n\n    permitted = 'ACGT'\n\n    continuous_count = []\n\n    count = 0\n\n\n\n    for i in range(len(s)):\n\n        char = s[i]\n\n        if char in permitted:\n\n            count += 1\n\n        else:\n\n            continuous_count.append(count)\n\n            count = 0\n\n        if i == len(s) - 1:\n\n            continuous_count.append(count)\n\n    \n\n    if not continuous_count:\n\n        print((len(s)))\n\n    else:\n\n        print((max(continuous_count)))\n\n\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "score": 0.0, "codebleu": 0.1824169112966859, "crystalbleu": 0.03459142872455749, "codebertscore": 0.68, "codescore": 0.041166119277477264, "surfaceSim": 0.623970398970399, "abs_surfaceSim_minus_score": 0.623970398970399}
{"golden_code": "#!usr/bin/env python3\n\nfrom collections import defaultdict\n\nfrom collections import deque\n\nfrom heapq import heappush, heappop\n\nimport sys\n\nimport math\n\nimport bisect\n\nimport random\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\n\ndef I(): return int(sys.stdin.readline())\n\ndef LS():return list(map(list, sys.stdin.readline().split()))\n\ndef S(): return list(sys.stdin.readline())[:-1]\n\ndef IR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = I()\n\n    return l\n\ndef LIR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = LI()\n\n    return l\n\ndef SR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = S()\n\n    return l\n\ndef LSR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = LS()\n\n    return l\n\nsys.setrecursionlimit(1000000)\n\nmod = 1000000007\n\n\n\n#A\n\ndef A():\n\n    return\n\n\n\n#B\n\ndef B():\n\n    return\n\n\n\n#C\n\ndef C():\n\n    return\n\n\n\n#D\n\ndef D():\n\n    return\n\n\n\n#E\n\ndef E():\n\n    return\n\n\n\n#F\n\ndef F():\n\n    a,b,c,X,Y = LI()\n\n    ans = float(\"inf\")\n\n    for z in range(300001):\n\n        if z%2 == 0:\n\n            m = c*z\n\n            x = z//2\n\n            y = z//2\n\n            m += a*max(0,X-x)\n\n            m += b*max(0,Y-y)\n\n            if m < ans:\n\n                ans = m\n\n    print(ans)\n\n    return\n\n\n\n#G\n\ndef G():\n\n    n = I()\n\n    x = LI()\n\n    f = [(i,x[i]) for i in range(n)]\n\n    f.sort(key = lambda x:x[1])\n\n    g = [(f[i][0],i) for i in range(n)]\n\n    g.sort(key = lambda x:x[0])\n\n    for i in range(n):\n\n        if g[i][1] < n//2:\n\n            print((f[n//2][1]))\n\n        else:\n\n            print((f[n//2-1][1]))\n\n    return\n\n\n\n#H\n\ndef H():\n\n    return\n\n\n\n#I\n\ndef I_():\n\n    return\n\n\n\n#J\n\ndef J():\n\n    return\n\n\n\n#Solve\n\nif __name__ == \"__main__\":\n\n    F()\n", "generated_code": "def main():\n\n    n, *a, = list(map(int, open(0).read().split()))\n\n    a = [x - i for i, x in enumerate(a, 1)]\n\n    a.sort()\n\n    if n % 2 == 0:\n\n        ans = sum(a[n // 2:]) - sum(a[:n // 2])\n\n    else:\n\n        ans = sum(a[n // 2 + 1:]) - sum(a[:n // 2])\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 0.0, "codebleu": 0.10618212706118535, "crystalbleu": 0.011101955548289286, "codebertscore": 0.7, "codescore": 0.01949312351644039, "surfaceSim": 0.5188034188034188, "abs_surfaceSim_minus_score": 0.5188034188034188}
{"golden_code": "from collections import Counter\n\ndef factorization(n) -> list:\n\n\tif n==1:\n\n\t\treturn [1]\n\n\tret = []\n\n\ti = 2\n\n\twhile i*i<=n:\n\n\t\twhile n%i==0:\n\n\t\t\tn //= i\n\n\t\t\tret.append(i)\n\n\t\ti += 1\n\n\tif n!=1:\n\n\t\tret.append(n)\n\n\treturn ret\n\n\n\nn,m = list(map(int,input().split()))\n\nmod = 10**9+7\n\nif m==1:\n\n\tprint((1));exit()\n\n\n\nfactors = Counter(factorization(m))\n\nmx = n+max(factors.values())\n\n\n\nfac = [1]*(mx+1)\n\ninv = [1]*(mx+1)\n\nfor i in range(1,mx+1):\n\n\tfac[i] = fac[i-1] * i % mod\n\ninv[-1] = pow(fac[-1], mod - 2, mod)\n\nfor i in range(mx-1, -1, -1):\n\n\tinv[i] = inv[i+1] * (i+1) % mod\n\ndef cmb(n,r):\n\n\tassert n >= r >= 0\n\n\treturn fac[n] * inv[n-r] * inv[r] % mod\n\n\t\n\nans=1\n\nfor v in list(factors.values()):\n\n\tans*=cmb(n+v-1,v)\n\n\tans%=mod\n\n\n\nprint(ans)", "generated_code": "M = 1000000007\n\nn=int(eval(input()))\n\nf = 1\n\nfor i in range(1, n + 1):  \n\n    f = (f * i) % M \n\nprint(f)", "score": 0.0, "codebleu": 0.06454179247568598, "crystalbleu": 0.0004420890680636748, "codebertscore": 0.7, "codescore": 0.7441391348838806, "surfaceSim": 0.3128436763550668, "abs_surfaceSim_minus_score": 0.3128436763550668}
{"golden_code": "def main():\n\n\n\n    while True:\n\n        n, x = tuple(map(int, input().split()))\n\n        pattern = 0\n\n\n\n        if n == x == 0:\n\n            break\n\n        else:\n\n            for a in range(1, n+1):\n\n                for b in range(1, a):\n\n                    for c in range(1, b):\n\n                        pattern += 1 if a + b + c == x and a > b > c else 0\n\n            print(pattern)\n\n                            \n\n\n\nif __name__ == '__main__':\n\n    main()\n", "generated_code": "from collections import defaultdict\n\nN = int(eval(input()))\n\nSs = [eval(input()) for i in range(N)]\n\n\n\nd = defaultdict(int)\n\nfor S in Ss:\n\n    d[S] += 1\n\n\n\nmx = max([d[k] for k in list(d.keys())])\n\n\n\nans = []\n\nfor k in list(d.keys()):\n\n    if d[k] == mx:\n\n       ans.append(k)\n\n       \n\nfor a in sorted(ans):\n\n    print(a)", "score": 0.0, "codebleu": 0.13986711010111114, "crystalbleu": 0.0, "codebertscore": 0.72, "codescore": 0.09434135258197784, "surfaceSim": 0.5160343886462881, "abs_surfaceSim_minus_score": 0.5160343886462881}
{"golden_code": "import math\n\nx = int(eval(input()))\n\nprint((math.factorial(x) % (10**9 + 7)))", "generated_code": "while True:\n\n    try:\n\n        for i in range(3):\n\n            line = input().strip()\n\n            if line == '0':\n\n                raise Exception\n\n\n\n            if line[0] == 'A':\n\n                a = -1\n\n                b = 0\n\n            else:\n\n                a = 0\n\n                b = -1\n\n            for i, s in enumerate(line):\n\n                if s == 'A':\n\n                    a += 1\n\n                else:\n\n                    b += 1\n\n            if a > b:\n\n                a += 1\n\n            else:\n\n                b += 1\n\n            print(a, b)\n\n\n\n    except:\n\n        break", "score": 0.0, "codebleu": 0.11108156089622342, "crystalbleu": 0.0, "codebertscore": 0.57, "codescore": 0.03307603299617767, "surfaceSim": 0.5028157463094587, "abs_surfaceSim_minus_score": 0.5028157463094587}
{"golden_code": "import math\n\n\n\nn = int(eval(input()))\n\nans = math.factorial(n) % (pow(10, 9) + 7)\n\nprint(ans)", "generated_code": "N,K = list(map(int,input().split()))\n\nA = list(map(int,input().split()))\n\n\n\ndp = [False]*(K+1)\n\n\n\nfor i in range(K+1):\n\n    for j in range(N):\n\n        if i-A[j]>=0 and dp[i-A[j]] == False:\n\n            dp[i] = True\n\n\n\n        \n\nif dp[K]:\n\n    print(\"First\")\n\nelse:\n\n    print(\"Second\")", "score": 0.0, "codebleu": 0.21857901607853555, "crystalbleu": 0.0, "codebertscore": 0.66, "codescore": 0.9695165157318115, "surfaceSim": 0.4152421652421653, "abs_surfaceSim_minus_score": 0.4152421652421653}
{"golden_code": "def isPrime(x):\n\n    if x == 2:\n\n        return True\n\n    if x < 2 or x % 2 == 0:\n\n        return False\n\n    i, root_x = 3, int(pow(x, 0.5))\n\n    while i <= root_x:\n\n        if x % i == 0:\n\n            return False\n\n        i += 2\n\n    return True\n\n\n\nprimes = [2]\n\nfor i in range(3, 104730):\n\n    if isPrime(i):\n\n        primes.append(primes[-1]+i)\n\nwhile True:\n\n    n = int(eval(input()))\n\n    if n == 0:\n\n        break\n\n    print((primes[n-1]))", "generated_code": "ans=1\n\nn=int(eval(input()))\n\nfor i in range(1,n+1):\n\n    ans*=i\n\n    ans=ans%(10**9+7)\n\nprint(ans)", "score": 0.0, "codebleu": 0.09828110703668974, "crystalbleu": 0.0, "codebertscore": 0.71, "codescore": 0.06058104708790779, "surfaceSim": 0.4204658694569009, "abs_surfaceSim_minus_score": 0.4204658694569009}
{"golden_code": "import sys\n\nstdin = sys.stdin\n\n \n\nsys.setrecursionlimit(10**8) \n\n \n\ndef li(): return list(map(int, stdin.readline().split()))\n\ndef li_(): return [int(x)-1 for x in stdin.readline().split()]\n\ndef lf(): return list(map(float, stdin.readline().split()))\n\ndef ls(): return stdin.readline().split()\n\ndef ns(): return stdin.readline().rstrip()\n\ndef lc(): return list(ns())\n\ndef ni(): return int(stdin.readline())\n\ndef nf(): return float(stdin.readline())\n\n\n\n\n\nn = ni()\n\na = [ni() for _ in range(n)]\n\n\n\ncnt = {i+1: ai for i, ai in enumerate(a)}\n\n\n\nprev = -100\n\ncur = 0\n\nans = 0\n\nfor key in sorted(cnt.keys()):\n\n    if cnt[key] == 0:\n\n        continue\n\n    \n\n    if prev == -100:\n\n        prev = key\n\n    \n\n    if (key-prev) < 2:\n\n        cur += cnt[key]\n\n    else:\n\n        cur = cnt[key]\n\n        \n\n    ans += cur // 2\n\n    cur -= 2 * (cur//2)\n\n    \n\n    prev = key\n\n        \n\nprint(ans)", "generated_code": "import queue\n\nimport sys\n\nsys.setrecursionlimit(10**7)\n\nn = int(eval(input()))\n\n\n\nabc = [[] for i in range(n+1)]\n\n\n\nfor i in range(n-1):\n\n    a,b,c = list(map(int,input().split()))\n\n    abc[a].append([b,c])\n\n    abc[b].append([a,c])\n\n\n\nQ,k = list(map(int,input().split()))\n\nxy = [[int(i) for i in input().split()] for j in range(Q)]\n\n\n\nq = queue.Queue()\n\n\n\nq.put(k)\n\n\n\npath = [-1]*(n+1)\n\npath[k] = 0\n\n\n\ndef dfs(p):\n\n    for i in range(len(abc[p])):\n\n        num = abc[p][i][0]\n\n        if path[num] != -1:\n\n            continue\n\n        else:\n\n            path[num] = path[p] + abc[p][i][1]\n\n            dfs(num)\n\n\n\ndfs(k)\n\n\n\nfor i in range(Q):\n\n    print((path[xy[i][0]]+path[xy[i][1]]))", "score": 0.0, "codebleu": 0.19172008371728516, "crystalbleu": 0.1076570142863005, "codebertscore": 0.76, "codescore": 0.6523249745368958, "surfaceSim": 0.6091612402174562, "abs_surfaceSim_minus_score": 0.6091612402174562}
{"golden_code": "import heapq\n\nK=int(eval(input()))\n\ndist=[10**15 for i in range(K)]\n\ndist[1]=1\n\nq=[]\n\nheapq.heappush(q,(0,1))\n\nwhile (len(q)!=0):\n\n    prc,src=heapq.heappop(q)\n\n    if dist[src]<prc:\n\n        continue\n\n    if dist[(src+1)%K]>dist[src]+1:\n\n        dist[(src+1)%K]=dist[src]+1\n\n        heapq.heappush(q,(dist[(src+1)%K],(src+1)%K))\n\n    if dist[(10*src)%K]>dist[src]:\n\n        dist[(10*src)%K]=dist[src]\n\n        heapq.heappush(q,(dist[(src*10)%K],(src*10)%K))\n\nprint((dist[0]))\n", "generated_code": "import sys\n\ninput = sys.stdin.readline\n\n\n\ndef solve():\n\n    INF = 10**10\n\n\n\n    N, M = list(map(int, input().split()))\n\n    keys = []\n\n    costs = []\n\n    for _ in range(M):\n\n        a, b = list(map(int, input().split()))\n\n        costs.append(a)\n\n        cs = list(map(int, input().split()))\n\n        key = 0\n\n        for c in cs:\n\n            key |= 1<<(c-1)\n\n        keys.append(key)\n\n\n\n    dp = [INF] * (1<<N)\n\n    dp[0] = 0\n\n    for S in range(1<<N):\n\n        for key, cost in zip(keys, costs):\n\n            S2 = S | key\n\n            c2 = dp[S] + cost\n\n            if c2 < dp[S2]:\n\n                dp[S2] = c2\n\n\n\n    if dp[-1] == INF:\n\n        print((-1))\n\n    else:\n\n        print((dp[-1]))\n\n\n\n\n\nsolve()\n", "score": 0.0, "codebleu": 0.16280812911133902, "crystalbleu": 0.03376850734470133, "codebertscore": 0.69, "codescore": 0.9932855367660522, "surfaceSim": 0.5292343806428313, "abs_surfaceSim_minus_score": 0.5292343806428313}
{"golden_code": "import queue\n\nn = int(eval(input()))\n\n\n\nabc = [[] for i in range(n+1)]\n\n\n\nfor i in range(n-1):\n\n    a,b,c = list(map(int,input().split()))\n\n    abc[a].append([b,c])\n\n    abc[b].append([a,c])\n\n\n\nQ,k = list(map(int,input().split()))\n\nxy = [[int(i) for i in input().split()] for j in range(Q)]\n\n\n\nq = queue.Queue()\n\n\n\nq.put(k)\n\n\n\npath = [-1]*(n+1)\n\npath[k] = 0\n\n\n\nwhile not q.empty():\n\n    tmp = q.get()\n\n    for i in range(len(abc[tmp])):\n\n        #print(abc[tmp])\n\n        #exit()\n\n        num = abc[tmp][i][0]\n\n        if path[num] != -1:\n\n            continue\n\n        else:\n\n            path[num] = path[tmp] + abc[tmp][i][1]\n\n            q.put(num)\n\n            \n\nfor i in range(Q):\n\n    print((path[xy[i][0]]+path[xy[i][1]]))", "generated_code": "n,k=list(map(int, input().split()))\n\nexp=list([(int(x)+1)/2 for x in input().split()]) # 入力と同時に期待値計算\n\n\n\nl=[0]*n\n\nsum1=0\n\nfor i in range(n):# 累積和の計算\n\n    sum1+=exp[i]\n\n    l[i]=sum1 \n\n\n\nans=l[k-1]\n\nfor i in range(n-k):\n\n    ans=max(ans,l[i+k]-l[i])\n\n    \n\nprint(ans)", "score": 0.0, "codebleu": 0.15789703976774708, "crystalbleu": 0.07382699468644308, "codebertscore": 0.73, "codescore": 0.8711692690849304, "surfaceSim": 0.5614711934156378, "abs_surfaceSim_minus_score": 0.5614711934156378}
{"golden_code": "\n\n\n\n# N個の荷物、ナップザックの容量はW\n\nN, W = list(map(int, input().split()))\n\nw = [0] * N\n\nv = [0] * N\n\n\n\nfor i in range(N):\n\n    a, b = list(map(int, input().split()))\n\n    w[i] = a\n\n    v[i] = b\n\n\n\n# 1 <= W <= 10^9なので横軸をWにするとテーブルがでかすぎる\n\n# そのかわりにVの方を横軸にする\n\n\n\n# 価値の総合計はまだ不明なので、適当にでかい値にしとく\n\n# 最上部と最左部に0が入るので、その分を+1\n\nV = N*1000+1\n\ndp = [ [float('inf') for _ in range(V+1)] for _ in range(N+1) ]\n\n\n\n# 最小値を求めるので、上記でinfが入ってるので、初期値は0をいれる必要がある\n\ndp[0][0] = 0\n\n\n\n# dp[i][sum_v] = これまで(i-1)番目までの品物から価値がsum_v以上になるように選んだときの、重さの総和の最小値\n\nfor i in range(N):\n\n    for sum_v in range(V):\n\n        if sum_v - v[i] >= 0:\n\n            dp[i+1][sum_v] = min(dp[i+1][sum_v], dp[i][sum_v-v[i]]+w[i])\n\n\n\n        dp[i+1][sum_v] = min(dp[i+1][sum_v], dp[i][sum_v])\n\n\n\n\n\n# 中身がWなので、W以下であるうちのsum_vの最大値を求めればいい\n\nfor sum_v in range(V):\n\n    # 最終行だけ見ればいいので、端からsum_vの最大値をなめるだけ\n\n    if dp[N][sum_v] <= W:\n\n        ans = sum_v\n\n\n\nprint(ans)", "generated_code": "import sys\n\nans = 'Yes'; eval(input())\n\nfor e in sys.stdin:\n\n    t, x, y = list(map(int, e.split()))\n\n    t = t - x - y\n\n    if t < 0 or t % 2 == 1: ans = 'No'; break\n\nprint(ans)", "score": 0.0, "codebleu": 0.0880629603804329, "crystalbleu": 0.01609684956436601, "codebertscore": 0.61, "codescore": 0.9904650449752808, "surfaceSim": 0.5408991844769404, "abs_surfaceSim_minus_score": 0.5408991844769404}
{"golden_code": "import math\n\nn = int(eval(input()))\n\n\n\nans = math.factorial(n)  # nの階乗を計算\n\n\n\nif ans >= (10 ** 9)+7:\n\n    ans = ans % ((10 ** 9)+7)\n\n\n\nprint(ans)\n", "generated_code": "#!usr/bin/env python3\n\nfrom collections import defaultdict,deque\n\nfrom heapq import heappush, heappop\n\nfrom itertools import permutations\n\nimport sys\n\nimport math\n\nimport bisect\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\n\ndef I(): return int(sys.stdin.readline())\n\ndef LS():return [list(x) for x in sys.stdin.readline().split()]\n\ndef S():\n\n    res = list(sys.stdin.readline())\n\n    if res[-1] == \"\\n\":\n\n        return res[:-1]\n\n    return res\n\ndef IR(n):\n\n    return [I() for i in range(n)]\n\ndef LIR(n):\n\n    return [LI() for i in range(n)]\n\ndef SR(n):\n\n    return [S() for i in range(n)]\n\ndef LSR(n):\n\n    return [LS() for i in range(n)]\n\n\n\nsys.setrecursionlimit(1000000)\n\nmod = 1000000007\n\n\n\ndef solve():\n\n    A,B,C,x,y = LI()\n\n    ans = float(\"inf\")\n\n    for c in range(200001)[::2]:\n\n        a = b = c >> 1\n\n        a = max(0,x-a)\n\n        b = max(0,y-b)\n\n        s = A*a+B*b+C*c\n\n        if s < ans:\n\n            ans = s\n\n    print(ans)\n\n    return\n\n\n\n#Solve\n\nif __name__ == \"__main__\":\n\n    solve()\n", "score": 0.0, "codebleu": 0.23669235971336844, "crystalbleu": 0.01738092252726337, "codebertscore": 0.63, "codescore": 0.01834801770746708, "surfaceSim": 0.37602305323824314, "abs_surfaceSim_minus_score": 0.37602305323824314}
{"golden_code": "import numpy as np\n\nn,k=list(map(int, input().split()))\n\nexp=list([(int(x)+1)/2 for x in input().split()]) # 入力と同時に期待値計算\n\n\n\nl=np.cumsum(exp) # 累積和の計算\n\n\n\nans=l[k-1]\n\nfor i in range(n-k):\n\n    ans=max(ans,l[i+k]-l[i])\n\n    \n\nprint(ans)", "generated_code": "from collections import defaultdict\n\nN = int(eval(input()))\n\nSs = [eval(input()) for i in range(N)]\n\n\n\nd = defaultdict(int)\n\nfor S in Ss:\n\n    d[S] += 1\n\n\n\nmx = max([d[k] for k in list(d.keys())])\n\n\n\nans = []\n\nfor k in list(d.keys()):\n\n    if d[k] == mx:\n\n       ans.append(k)\n\n       \n\nfor a in sorted(ans):\n\n    print(a)", "score": 0.0, "codebleu": 0.20235237156168895, "crystalbleu": 0.0, "codebertscore": 0.71, "codescore": 0.9735006093978882, "surfaceSim": 0.5230043708304577, "abs_surfaceSim_minus_score": 0.5230043708304577}
{"golden_code": "import sys\n\ninput = sys.stdin.readline\n\nN, M = list(map(int,input().split()))\n\nhole = [0] * (N+1)\n\nfor i in range(M):\n\n    hole[int(eval(input()))] = 1\n\nif N == 1:\n\n    print((1))\n\n    exit()\n\nif N == 2:\n\n    if hole[1] == 1:\n\n        print((1))\n\n        exit()\n\n    if hole[1] == 0:\n\n        print((2))\n\n        exit()\n\nflg_one = False\n\nflg_two = False\n\nfirst = 1\n\nsecond = 2\n\nif hole[1] == 1:\n\n    first = 0\n\n    second = 1\n\n    flg_one = True\n\nif hole[2] == 1:\n\n    first = 1\n\n    second = 0\n\n    flg_two = True\n\nif flg_one and flg_two:\n\n    print((0))\n\n    exit()\n\n\n\nfor i in range(3,N):\n\n    if hole[i] == 1:\n\n        first = second\n\n        second = 0\n\n        continue\n\n    tmp = first + second\n\n    tmp %= 1000000007\n\n    first = second\n\n    second = tmp\n\ntmp = first + second\n\ntmp %= 1000000007\n\nprint(tmp)", "generated_code": "a = [list(map(int, input().split())) for _ in range(3)]\n\nn = int(eval(input()))\n\nb = [int(eval(input())) for _ in range(n)]\n\n\n\nflag = False\n\nfor i in range(3):\n\n    if a[i][0] in b and a[i][1] in b and a[i][2] in b:\n\n        flag = True\n\n        break\n\n    if a[0][i] in b and a[1][i] in b and a[2][i] in b:\n\n        flag = True\n\n        break\n\nif a[0][0] in b and a[1][1] in b and a[2][2] in b:\n\n    flag = True\n\nif a[2][0] in b and a[1][1] in b and a[0][2] in b:\n\n    flag = True\n\n    \n\nprint((\"Yes\" if flag else \"No\"))", "score": 0.0, "codebleu": 0.10988494993856009, "crystalbleu": 0.22303263866902762, "codebertscore": 0.76, "codescore": 0.405238538980484, "surfaceSim": 0.497239263803681, "abs_surfaceSim_minus_score": 0.497239263803681}
{"golden_code": "a,b,c,x,y = list(map(int,input().split()))\n\nprice = 10**10\n\nfor k in range(10**5+1):\n\n    re = 2*c*k + max(0,x-k)*a + max(0,y-k)*b\n\n    price = min(re,price)\n\nprint(price)", "generated_code": "a, b, m = list(map(int,input().split()))\n\nal = list(map(int,input().split()))\n\nbl = list(map(int,input().split()))\n\nlow = min(al)+min(bl)\n\nx = [0] * m\n\ny = [0] * m\n\nc = [0] * m\n\n\n\nfor i in range(m):\n\n    x[i],y[i],c[i] = list(map(int, input().split()))\n\n    x[i] -= 1\n\n    y[i] -= 1\n\n \n\nfor i in range(m):\n\n    low = min(low,al[x[i]]+bl[y[i]]-c[i])\n\n\n\nprint(low)", "score": 0.0, "codebleu": 0.2283868122640798, "crystalbleu": 0.11652486193665261, "codebertscore": 0.79, "codescore": 0.10613008588552475, "surfaceSim": 0.5890883977900552, "abs_surfaceSim_minus_score": 0.5890883977900552}
{"golden_code": "import sys\n\nimport numpy as np\n\n\n\nsr = lambda: sys.stdin.readline().rstrip()\n\nir = lambda: int(sr())\n\nlr = lambda: list(map(int, sr().split()))\n\n\n\nN = ir()\n\nA = np.array(lr())\n\nA = A[A%2==0].tolist()\n\nbool = True\n\nfor a in A:\n\n    if a%3 != 0 and a%5 != 0:\n\n        bool = False\n\n\n\nprint(('APPROVED' if bool else 'DENIED'))\n", "generated_code": "# セグメント木\n\n# segment tree\n\nimport sys\n\ninput = sys.stdin.readline\n\n\n\nclass segmented_tree:\n\n    X_unit = 0\n\n    X_f = lambda self, a, b: max(a,b)\n\n    def __init__(self, N):\n\n        self.N = N\n\n        self.X = [self.X_unit] * (2*N)\n\n        \n\n    def build(self, seq):\n\n        for i, x in enumerate(seq, self.N):\n\n            self.X[i] = x \n\n        # 後ろから入れていく\n\n        for i in range(self.N-1, 0, -1):\n\n            self.X[i] = self.X_f(self.X[i<<1], self.X[i<<1|1])\n\n\n\n    # 1点更新\n\n    def set_val(self, i, x):\n\n        i += self.N\n\n        self.X[i] = x\n\n        while i > 1:\n\n            i >>= 1\n\n            self.X[i] = self.X_f(self.X[i<<1],self.X[i<<1|1])\n\n    \n\n    # 区間取得\n\n    def fold(self, l, r):\n\n        l += self.N\n\n        r += self.N\n\n        vl = self.X_unit\n\n        vr = self.X_unit\n\n        # 外から決めていく\n\n        while l < r:\n\n            # print(l,r)\n\n            if l & 1:\n\n                vl = self.X_f(vl, self.X[l])\n\n                l += 1\n\n            if r & 1:\n\n                r -= 1\n\n                vr = self.X_f(vr, self.X[r])\n\n            l >>= 1\n\n            r >>= 1\n\n        return self.X_f(vl,vr)\n\n\n\nn,k = list(map(int, input().split()))\n\nAs = [int(eval(input())) for i in range(n)]\n\nmx = 300001\n\nans = 0\n\nsg = segmented_tree(330000)\n\n\n\nfor a in As:\n\n    l = max(0,a-k)\n\n    r = min(mx,a+k)\n\n\n\n    upd = sg.fold(l,r+1)\n\n    ans = max(ans, upd+1)\n\n\n\n    sg.set_val(a, upd+1)\n\nprint(ans)\n\n\n", "score": 0.0, "codebleu": 0.2331152820991147, "crystalbleu": 0.053675570298191956, "codebertscore": 0.64, "codescore": 0.9938682913780212, "surfaceSim": 0.468125114657861, "abs_surfaceSim_minus_score": 0.468125114657861}
{"golden_code": "import sys\n\nsys.setrecursionlimit(2147483647)\n\nINF=float(\"inf\")\n\nMOD=10**9+7\n\ninput=lambda :sys.stdin.readline().rstrip()\n\ndef resolve():\n\n    n,W=list(map(int,input().split()))\n\n    WV=[tuple(map(int,input().split())) for _ in range(n)]\n\n\n\n    V=100000\n\n    dp=[INF]*(V+1)\n\n    dp[0]=0\n\n\n\n    for w,v in WV:\n\n        for x in range(V,-1,-1):\n\n            if(x+v<=V):\n\n                dp[x+v]=min(dp[x+v],dp[x]+w)\n\n\n\n    for x in range(V,-1,-1):\n\n        if(dp[x]<=W):\n\n            print(x)\n\n            return\n\nresolve()", "generated_code": "X, Y, Z, K = list(map(int, input().split()))\n\nA = sorted([int(i) for i in input().split()], reverse=True)\n\nB = sorted([int(i) for i in input().split()], reverse=True)\n\nC = sorted([int(i) for i in input().split()], reverse=True)\n\nD = []\n\nfor i in range(min(K, X)):\n\n    for j in range(min(K, Y)):\n\n        if (i + 1) * (j + 1) > K:\n\n            break\n\n        for k in range(min(K, Z)):\n\n            if (i + 1) * (j + 1) * (k + 1) > K:\n\n                break\n\n            else:\n\n\n\n                D.append(A[i] + B[j] + C[k])\n\n\n\nD.sort(reverse=True)\n\nfor i in range(K):\n\n    print((D[i]))", "score": 0.0, "codebleu": 0.132480226995406, "crystalbleu": 0.092749014543403, "codebertscore": 0.73, "codescore": 0.26300522685050964, "surfaceSim": 0.5362511273674717, "abs_surfaceSim_minus_score": 0.5362511273674717}
{"golden_code": "def ii():return int(eval(input()))\n\ndef iim():return list(map(int,input().split()))\n\ndef iil():return list(map(int,input().split()))\n\ndef ism():return list(map(str,input().split()))\n\ndef isl():return list(map(str,input().split()))\n\n\n\nn = ii()\n\nD = iil()\n\nans = 0\n\nfor i in range(n):\n\n    for j in range(i+1,n):\n\n#        print(i,j)\n\n        ans += D[i]*D[j] \n\nprint(ans)", "generated_code": "n = int(eval(input()))\n\nans = 0\n\nfor i in map(int, input().split()):\n\n    cnt = 0\n\n    while i % 2 == 0:\n\n        i >>= 1\n\n        cnt += 1\n\n    ans += cnt\n\nprint(ans)", "score": 0.0, "codebleu": 0.27220531353748867, "crystalbleu": 0.06781174002495899, "codebertscore": 0.78, "codescore": 0.49662134051322937, "surfaceSim": 0.47759009009009007, "abs_surfaceSim_minus_score": 0.47759009009009007}
{"golden_code": "while 1:\n\n    ans=0\n\n    n,x=list(map(int,input().split()))\n\n    if n:\n\n        for i in range(1,n-1):\n\n            for j in range(i+1,n):\n\n                for k in range(j+1,n+1):\n\n                    if i+j+k==x:ans+=1\n\n    else:break\n\n    print(ans)", "generated_code": "'''\n\n    Auther: ghoshashis545 Ashis Ghosh\n\n    College: jalpaiguri Govt Enggineering College\n\n\n\n'''\n\nfrom os import path\n\nimport sys\n\nfrom heapq import heappush,heappop\n\nfrom functools import cmp_to_key as ctk\n\nfrom collections import deque,defaultdict as dd \n\nfrom bisect import bisect,bisect_left,bisect_right,insort,insort_left,insort_right\n\nfrom itertools import permutations\n\nfrom datetime import datetime\n\nfrom math import ceil,sqrt,log,gcd\n\ndef ii():return int(eval(input()))\n\ndef si():return eval(input())\n\ndef mi():return list(map(int,input().split()))\n\ndef li():return list(mi())\n\nabc='abcdefghijklmnopqrstuvwxyz'\n\nmod=1000000007\n\n# mod=998244353\n\ninf = float(\"inf\")\n\nvow=['a','e','i','o','u']\n\ndx,dy=[-1,1,0,0],[0,0,1,-1]\n\n\n\ndef bo(i):\n\n    return ord(i)-ord('a')\n\n\n\nfile=0\n\n\n\n\n\n\n\n\n\n\n\ndef solve():\n\n\n\n\n\n    # for _ in range(ii()):\n\n    \n\n        \n\n\n\n    n=ii()\n\n    n%=1000\n\n    if(n!=0):\n\n        n=1000-n\n\n    print(n)\n\n \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n        \n\nif __name__ ==\"__main__\":\n\n\n\n    if(file):\n\n\n\n        if path.exists('input1.txt'):\n\n            sys.stdin=open('input1.txt', 'r')\n\n            sys.stdout=open('output1.txt','w')\n\n        else:\n\n            input=sys.stdin.readline\n\n    solve()\n", "score": 0.0, "codebleu": 0.16632041497017835, "crystalbleu": 0.052092432705688065, "codebertscore": 0.66, "codescore": 0.11726224422454834, "surfaceSim": 0.4155629139072848, "abs_surfaceSim_minus_score": 0.4155629139072848}
{"golden_code": "n = int(eval(input()))\n\nedges = []\n\n\n\nfor id in range(n-1):\n\n    a, b = list(map(int, input().split()))\n\n    edges.append([a-1, b-1, id])\n\n\n\nedges.sort()\n\n\n\nused = [0]*(n)\n\nans = [0]*(n-1)\n\nnum = 1\n\nprev = 0\n\nfor edge in edges:\n\n    _from, to, id = edge\n\n    if _from != prev:\n\n        num = 1\n\n    if used[_from] == num:\n\n        num += 1\n\n    ans[id] = num\n\n    used[to] = num\n\n    num += 1\n\n    prev = _from\n\n\n\nprint((max(ans)))\n\nfor color in ans:\n\n    print(color)\n", "generated_code": "from collections import deque\n\nK=int(eval(input()))\n\ndist=[10**15 for i in range(K)]\n\ndist[1]=1\n\nq=deque([1])\n\nwhile(len(q)>0):\n\n    r=q.popleft()\n\n    s=(r+1)%K\n\n    if dist[r]+1<dist[s]:\n\n        dist[s]=dist[r]+1\n\n        q.append(s)\n\n    t=(r*10)%K\n\n    if dist[r]<dist[t]:\n\n        dist[t]=dist[r]\n\n        q.appendleft(t)\n\nprint((dist[0]))\n", "score": 0.0, "codebleu": 0.15464837101163753, "crystalbleu": 0.08604201284678707, "codebertscore": 0.72, "codescore": 0.9046955108642578, "surfaceSim": 0.4756463219616205, "abs_surfaceSim_minus_score": 0.4756463219616205}
{"golden_code": "n = int(eval(input()))\n\nA = [int(i) for i in input().split()]\n\nS = [0]*(n+1)\n\nnum={}\n\nfor i in range(n):\n\n    S[i+1] = S[i] + A[i]\n\nfor i in S:\n\n    if str(i) in list(num.keys()):\n\n        num[str(i)] += 1\n\n    else:\n\n        num[str(i)] = 1\n\nout = [i*(i-1)//2 for i in list(num.values()) if i>1]\n\nprint((sum(out)))", "generated_code": "n,m,k=list(map(int,input().split()))\n\n\n\nmod = 10**9+7\n\nf = [1]\n\nfor i in range(n*m):\n\n  f += [f[-1]*(i+1) % mod]\n\ndef comb(a, b):\n\n  return f[a]*pow(f[b], mod-2, mod)*pow(f[a-b], mod-2, mod) % mod\n\n\n\nans=0\n\nfor dist in range(1,n):\n\n  c=n-dist\n\n  p=(c*m*m)%mod\n\n  ans+=p*dist\n\nfor dist in range(1,m):\n\n  c=m-dist\n\n  p=(c*n*n)%mod\n\n  ans+=p*dist\n\nans%=mod\n\nprint((ans*comb(n*m-2,k-2)%mod))", "score": 0.0, "codebleu": 0.11665506996051131, "crystalbleu": 0.10139494743935701, "codebertscore": 0.77, "codescore": 0.8395420908927917, "surfaceSim": 0.4431893687707641, "abs_surfaceSim_minus_score": 0.4431893687707641}
{"golden_code": "s = eval(input())\n\nt = eval(input())\n\nfor i in range(len(s)):\n\n        if s[i:]+s[:i]==t:\n\n                print('Yes')\n\n                exit()\n\nprint('No')", "generated_code": "import sys\n\n\n\nsr = lambda: sys.stdin.readline().rstrip()\n\nir = lambda: int(sr())\n\nlr = lambda: list(map(int, sr().split()))\n\n\n\nN = ir()\n\ncount = [[0] * 10 for _ in range(10)] # dp[head][tail]\n\nfor i in range(1, N+1):\n\n    s = str(i)\n\n    head = int(s[0]); tail = int(s[-1])\n\n    count[head][tail] += 1\n\n\n\nanswer = 0\n\nfor h in range(10):\n\n    for t in range(10):\n\n        answer += count[h][t] * count[t][h]\n\nprint(answer)\n", "score": 0.0, "codebleu": 0.19054126306611996, "crystalbleu": 0.0, "codebertscore": 0.72, "codescore": 0.9086134433746338, "surfaceSim": 0.41424252328811895, "abs_surfaceSim_minus_score": 0.41424252328811895}
{"golden_code": "import sys\n\n\n\nn, m, *lr = list(map(int, sys.stdin.read().split()))\n\nlr = list(zip(*[iter(lr)] * 2))\n\n\n\ndef main():\n\n    cnt = [0] * (n + 1)\n\n    for l, r in lr:\n\n        cnt[l-1] += 1\n\n        cnt[r] -= 1\n\n    \n\n    for i in range(n):\n\n        cnt[i+1] += cnt[i]\n\n    \n\n    res = 0\n\n    for i in range(n):\n\n        res += (cnt[i] == m) & 1\n\n    \n\n    return res\n\n\n\nif __name__ == '__main__':\n\n    ans = main()\n\n    print(ans)", "generated_code": "N=int(eval(input()))\n\n\n\nA=[[-1]*N for _ in range(N)]\n\nfor i in range(N):\n\n  a=int(eval(input()))\n\n  for j in range(a):\n\n    x,y=list(map(int, input().split()))\n\n    A[i][x-1]=y\n\n#正直者が正直者に不親切と言われていない\n\n#→正直ものが不親切を正直者と言っていないか\n\nans=0\n\nfor i in range(2**N):\n\n  ok=True\n\n  for j in range(N):\n\n    if (i>>j&1)==1:\n\n      for k in range(N):\n\n        if A[j][k]!=-1 and (i>>k&1)!=A[j][k]:\n\n          ok=False\n\n  if ok:\n\n    ans=max(ans, bin(i).count(\"1\"))\n\n  \n\nprint(ans)", "score": 0.0, "codebleu": 0.155143012135835, "crystalbleu": 0.13080810234894172, "codebertscore": 0.74, "codescore": 0.9884904623031616, "surfaceSim": 0.5198222829801777, "abs_surfaceSim_minus_score": 0.5198222829801777}
{"golden_code": "S=eval(input())\n\nprint((S.rfind('Z')-S.find('A')+1))", "generated_code": "n, k = list(map(int, input().split()))\n\np = list(map(int, input().split()))\n\n\n\ndef calc(x):\n\n    return (x + 1) / 2\n\n\n\n\n\nw = 0\n\n\n\nfor i in range(k):\n\n    w += calc(p[i])\n\n\n\nans = w\n\nfor i in range(k, n):\n\n    w += calc(p[i]) - calc(p[i - k])\n\n    ans = max(ans, w)\n\nprint(ans)", "score": 0.0, "codebleu": 0.12380952380952381, "crystalbleu": 0.0, "codebertscore": 0.65, "codescore": 0.05998235568404198, "surfaceSim": 0.461133069828722, "abs_surfaceSim_minus_score": 0.461133069828722}
{"golden_code": "import numpy as np\n\n\n\na = [list(map(int, input().split())) for _ in range(3)]\n\na = np.array(a)\n\nn = int(eval(input()))\n\n\n\nfor _ in range(n):\n\n    b = int(eval(input()))\n\n    \n\n    for j in range(3):\n\n        for i in range(3):\n\n            if a[j][i] == b:\n\n                a[j][i] = 0\n\n\n\nat = a.transpose()\n\nflag = False\n\nfor i in range(3):\n\n    if sum(a[:][i]) == 0 or sum(at[:][i]) == 0:\n\n        flag = True\n\n        break\n\ndiag = a[0][0] + a[1][1] + a[2][2]\n\ndiag2 = a[2][0] + a[1][1] + a[0][2]\n\nif diag == 0 or diag2 == 0:\n\n    flag = True\n\n\n\nprint((\"Yes\" if flag else \"No\"))", "generated_code": "N = int(eval(input()))\n\nX = list(int(x) for x in input().split())\n\np = round(sum(X)/len(X))\n\nans = 0\n\n\n\nfor i in range(N):\n\n    ans += (X[i] - p)**2\n\n\n\nprint(ans)", "score": 0.0, "codebleu": 0.10981540802935857, "crystalbleu": 0.025981812922973156, "codebertscore": 0.72, "codescore": 0.4620440900325775, "surfaceSim": 0.4622452945422242, "abs_surfaceSim_minus_score": 0.4622452945422242}
{"golden_code": "n = int(eval(input()))\n\na = list(map(int, input().split()))\n\nD = {i: [0] for i in range(1, n+1)}\n\nfor i in range(n+1):\n\n  D[a[i]][0] += 1\n\n  D[a[i]].append(i)\n\npl, pr = 0, 0\n\nfor i in D:\n\n  if D[i][0] == 2:\n\n    pl = D[i][1]\n\n    pr = D[i][2]\n\n    break\n\nL = pl\n\nM = pr - pl - 1\n\nN = n - pr\n\nmod = int(1e9) + 7 # <-- input modulo\n\nmaxf = n+11          # <-- input factional limitation\n\n\n\ndef make_fact(n, k):\n\n    tmp = n\n\n    perm = [i for i in range(k)]\n\n    L = [0 for _ in range(k)]\n\n    for i in range(k):\n\n        L[i] = tmp % (i + 1)\n\n        tmp //= i + 1\n\n    LL = [0 for _ in range(k)]\n\n    for i in range(k):\n\n        LL[i] = perm[L[-i-1]]\n\n        for j in range(L[-i-1]+1, k):\n\n            perm[j-1] = perm[j]\n\n    return LL\n\n\n\ndef doubling(n, m, modulo=mod):\n\n    y = 1\n\n    base = n\n\n    tmp = m\n\n    while tmp != 0:\n\n        if tmp % 2 == 1:\n\n            y *= base\n\n            if modulo > 0:\n\n                y %= modulo\n\n        base *= base\n\n        if modulo > 0:\n\n            base %= modulo\n\n        tmp //= 2\n\n    return y\n\n\n\ndef inved(a, modulo=mod):\n\n    x, y, u, v, k, l = 1, 0, 0, 1, a, modulo\n\n    while l != 0:\n\n        x, y, u, v = u, v, x - u * (k // l), y - v * (k // l)\n\n        k, l = l, k % l\n\n    return x % modulo\n\n\n\nfact = [1 for _ in range(maxf+1)]\n\ninvf = [1 for _ in range(maxf+1)]\n\n\n\nfor i in range(maxf):\n\n    fact[i+1] = (fact[i] * (i+1)) % mod\n\ninvf[-1] = inved(fact[-1])\n\nfor i in range(maxf, 0, -1):\n\n    invf[i-1] = (invf[i] * i) % mod\n\n\n\nfor i in range(1, n+2):\n\n  S = fact[n]*invf[i-1]*invf[n-i+1]%mod\n\n  if i <= n-1:\n\n    S += fact[n-1]*invf[i]*invf[n-1-i]%mod\n\n    S %= mod\n\n  if i <= n-M:\n\n    S -= fact[n-1-M]*invf[i-1]*invf[n-M-i]%mod\n\n    S %= mod\n\n  if i <= n:\n\n    S += fact[n-1]*invf[i-1]*invf[n-i]%mod\n\n    S %= mod\n\n  print(S)", "generated_code": "import math\n\nn = int(eval(input()))\n\n\n\nans = 0\n\nfor i in range(math.ceil(math.sqrt(n) + 1))[:0:-1]:\n\n    if 0 == n % i:\n\n        ans = i\n\n        break\n\nans_partner = n // ans\n\nprint((ans + ans_partner - 2))\n", "score": 0.0, "codebleu": 0.05068644962774424, "crystalbleu": 3.8911855648382125e-05, "codebertscore": 0.72, "codescore": 0.4083881676197052, "surfaceSim": 0.47657935705896814, "abs_surfaceSim_minus_score": 0.47657935705896814}
{"golden_code": "K,S = list(map(int,input().split(\" \")))\n\nans = 0\n\nfor i in range(K+1):\n\n\tfor j in range(K+1):\n\n\t\tif (S - i - j) <= K and (S-i-j) >= 0:\n\n\t\t\tans += 1\n\n\n\nprint(ans)\n", "generated_code": "N = int(eval(input()))\n\nabc = []\n\nfor i in range(N):\n\n    data = list(map(int, input().split()))\n\n    abc.append(data)\n\n\n\ndp = [[0 for i in range(3)] for j in range(N)]\n\ndp[0][0] = abc[0][0]\n\ndp[0][1] = abc[0][1]\n\ndp[0][2] = abc[0][2]\n\n\n\nfor i in range(N-1):\n\n    for j in range(3):\n\n        if j == 0:\n\n            dp[i+1][1] = max(dp[i][0] + abc[i+1][1], dp[i+1][1])\n\n            dp[i+1][2] = max(dp[i][0] + abc[i+1][2], dp[i+1][2])\n\n        if j == 1:\n\n            dp[i+1][0] = max(dp[i][1] + abc[i+1][0], dp[i+1][0])\n\n            dp[i+1][2] = max(dp[i][1] + abc[i+1][2], dp[i+1][2])\n\n        if j == 2:\n\n            dp[i+1][1] = max(dp[i][2] + abc[i+1][1], dp[i+1][1])\n\n            dp[i+1][0] = max(dp[i][2] + abc[i+1][0], dp[i+1][0])\n\n\n\nprint((max(dp[N-1])))", "score": 0.0, "codebleu": 0.149132495949244, "crystalbleu": 0.12722344848055708, "codebertscore": 0.73, "codescore": 0.3711332082748413, "surfaceSim": 0.4737148682102811, "abs_surfaceSim_minus_score": 0.4737148682102811}
{"golden_code": "from numpy import*\n\na,b=median(t:=loadtxt(open(0),skiprows=1),0)\n\nprint((int((a-b)*~(~len(t)%2))+1))", "generated_code": "import sys\n\ndef main():\n\n    input = sys.stdin.readline\n\n    N = int(eval(input()))\n\n    E = [[] for _ in range(N)]\n\n    for i in range(N-1):\n\n        a, b = list(map(int, input().split()))\n\n        a, b = a-1, b-1\n\n        E[a].append((b,i))\n\n        E[b].append((a,i))\n\n    \n\n    def dfs(s, g):\n\n        par = [(-1,-1)] * N\n\n        par[s] = (s,-1)\n\n        stack = [s]\n\n        while stack:\n\n            v = stack.pop()\n\n            for to, i in E[v]:\n\n                if par[to][0] >= 0: continue\n\n                par[to] = (v, i)\n\n                if to == g: break\n\n                stack.append(to)\n\n        r = set()\n\n        v = g\n\n        while v != s:\n\n            v, i = par[v]\n\n            r.add(i)\n\n        return r\n\n    \n\n    M = int(eval(input()))\n\n    path = [None] * M\n\n    for i in range(M):\n\n        u, v = list(map(int, input().split()))\n\n        u, v = u-1, v-1\n\n        path[i] = dfs(u, v)\n\n\n\n    def calc(s): return 1<<(N-1-len(s))\n\n\n\n    i_ans = 0\n\n    for p in range(1, 1<<M):\n\n        is_odd = 0\n\n        s = set()\n\n        for i in range(M):\n\n            if p&1:\n\n                s |= path[i]\n\n                is_odd ^= 1\n\n            p >>= 1\n\n        if is_odd: i_ans += calc(s)\n\n        else: i_ans -= calc(s)\n\n\n\n    print(((1<<(N-1)) - i_ans))\n\n\n\nif __name__ == '__main__':\n\n    main()", "score": 0.0, "codebleu": 0.14764267990074442, "crystalbleu": 0.018663673006125012, "codebertscore": 0.6, "codescore": 0.7395043969154358, "surfaceSim": 0.400061530489977, "abs_surfaceSim_minus_score": 0.400061530489977}
{"golden_code": "import sys\n\nimport numpy as np\n\n\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\nBsize = 700\n\n\n\ndef Mo_argsort(LR):\n\n    L = LR[:, 0]\n\n    R = LR[:, 1]\n\n    key1 = L // Bsize\n\n    key2 = np.where(key1 & 1, -R, R)\n\n    key = (key1 << 32) + key2\n\n    return np.argsort(key)\n\n\n\ndef main(A, LR):\n\n    N = len(A)\n\n    Q = len(LR)\n\n    ind = Mo_argsort(LR)\n\n    count = np.zeros(N + 1, np.int64)\n\n    ans = 0\n\n\n\n    def add(x):\n\n        nonlocal ans\n\n        if not count[x]:\n\n            ans += 1\n\n        count[x] += 1\n\n\n\n    def rem(x):\n\n        nonlocal ans\n\n        count[x] -= 1\n\n        if not count[x]:\n\n            ans -= 1\n\n\n\n    answers = np.empty(Q, np.int64)\n\n    nl, nr = 0, 0\n\n    for i in ind:\n\n        l, r = LR[i]\n\n        l -= 1\n\n        # 区間 [l, r) に対する計算\n\n        while nl > l:\n\n            nl -= 1\n\n            add(A[nl])\n\n        while nr < r:\n\n            add(A[nr])\n\n            nr += 1\n\n        while nl < l:\n\n            rem(A[nl])\n\n            nl += 1\n\n        while nr > r:\n\n            nr -= 1\n\n            rem(A[nr])\n\n        #  答を求めて ans[i] に格納する\n\n        answers[i] = ans\n\n    return answers\n\n\n\nif sys.argv[-1] == 'ONLINE_JUDGE':\n\n    import numba\n\n    from numba.pycc import CC\n\n    i4 = numba.int32\n\n    i8 = numba.int64\n\n    cc = CC('my_module')\n\n\n\n    def cc_export(f, signature):\n\n        cc.export(f.__name__, signature)(f)\n\n        return numba.njit(f)\n\n\n\n    Mo_argsort = cc_export(Mo_argsort, (i8[:,:],))\n\n    main = cc_export(main, (i8[:], i8[:, :]))\n\n    cc.compile()\n\n\n\nfrom my_module import main\n\n\n\nN, Q = list(map(int, readline().split()))\n\nA = np.array(readline().split(), np.int64)\n\nLR = np.array(read().split(), np.int64).reshape(Q, 2)\n\n\n\nans = main(A, LR)\n\nprint(('\\n'.join(map(str, ans.tolist()))))", "generated_code": "A,B,C,X,Y = list(map(int,input().split()))\n\nans = 0\n\nif 2*C <= A+B:\n\n    Z = min(X,Y)\n\n    ans = 2*C*Z\n\n    X -= Z\n\n    Y -= Z\n\nans += min(2*C*X,A*X)\n\nans += min(2*C*Y,B*Y)\n\nprint(ans)", "score": 0.0, "codebleu": 0.05198284135220037, "crystalbleu": 0.002597440725528714, "codebertscore": 0.63, "codescore": 0.8516648411750793, "surfaceSim": 0.39656080014037554, "abs_surfaceSim_minus_score": 0.39656080014037554}
{"golden_code": "import sys\n\ndef main():\n\n    input = sys.stdin.readline\n\n    N = int(eval(input()))\n\n    E = [[] for _ in range(N)]\n\n    for i in range(N-1):\n\n        a, b = list(map(int, input().split()))\n\n        a, b = a-1, b-1\n\n        E[a].append((b,i))\n\n        E[b].append((a,i))\n\n    \n\n    def dfs(s, g):\n\n        par = [(-1,-1)] * N\n\n        par[s] = (s,-1)\n\n        stack = [s]\n\n        while stack:\n\n            v = stack.pop()\n\n            for to, i in E[v]:\n\n                if par[to][0] >= 0: continue\n\n                par[to] = (v, i)\n\n                if to == g: break\n\n                stack.append(to)\n\n        r = set()\n\n        v = g\n\n        while v != s:\n\n            v, i = par[v]\n\n            r.add(i)\n\n        return r\n\n    \n\n    M = int(eval(input()))\n\n    path = [None] * M\n\n    for i in range(M):\n\n        u, v = list(map(int, input().split()))\n\n        u, v = u-1, v-1\n\n        path[i] = dfs(u, v)\n\n\n\n    def calc(s): return 1<<(N-1-len(s))\n\n\n\n    i_ans = 0\n\n    for p in range(1, 1<<M):\n\n        is_odd = bin(p).count('1') & 1\n\n        s = set()\n\n        for i in range(M):\n\n            if p&1: s |= path[i]\n\n            p >>= 1\n\n        if is_odd: i_ans += calc(s)\n\n        else: i_ans -= calc(s)\n\n\n\n    print(((1<<(N-1)) - i_ans))\n\n\n\nif __name__ == '__main__':\n\n    main()", "generated_code": "a, b, m = list(map(int,input().split()))\n\nal = list(map(int,input().split()))\n\nbl = list(map(int,input().split()))\n\nlow = min(al)+min(bl)\n\nx = [0] * m\n\ny = [0] * m\n\nc = [0] * m\n\n\n\nfor i in range(m):\n\n    x[i],y[i],c[i] = list(map(int, input().split()))\n\n    x[i] -= 1\n\n    y[i] -= 1\n\n \n\nfor i in range(m):\n\n    low = min(low,al[x[i]]+bl[y[i]]-c[i])\n\n\n\nprint(low)", "score": 0.0, "codebleu": 0.10549792598758047, "crystalbleu": 0.045273776422094764, "codebertscore": 0.75, "codescore": 0.15487928688526154, "surfaceSim": 0.5073284350855931, "abs_surfaceSim_minus_score": 0.5073284350855931}
{"golden_code": "N, W = list(map(int, input().split()))\n\nitems = sorted([list(map(int, input().split())) for i in range(N)])\n\n\n\n# dp1[i][j] := 商品0 ~ i が対象\n\ndp = [[0] * (W + 1) for i in range(N + 1)]\n\n\n\n# dpテーブルを埋める\n\nfor i in range(N):\n\n    wi, vi = items[i]\n\n    for j in range(W + 1):\n\n        if j + wi <= W:\n\n            dp[i + 1][j + wi] = max(dp[i + 1][j + wi], dp[i][j] + vi)\n\n        dp[i + 1][j] = max(dp[i][j], dp[i + 1][j])\n\n\n\n\n\nans = 0\n\nfor i, (wi, vi) in enumerate(items):\n\n    for j in range(W):\n\n        ans = max(ans, dp[i][j] + vi)\n\n\n\nprint(ans)\n", "generated_code": "MOD = 10**9 + 7\n\nN, M = list(map(int, input().split()))\n\nstairs = [0]*(N+1)\n\nfor _ in range(M):\n\n    stairs[int(eval(input()))] = 1\n\nif N == 1:\n\n    print((1))\n\n    exit()\n\nans = [0]*(N+1)\n\nans[1] = 1 if stairs[1] == 0 else 0\n\nans[2] = 1 + ans[1] if stairs[2] == 0 else 0\n\nfor i in range(3,N+1):\n\n    if stairs[i] == 1:\n\n        ans[i] = 0\n\n        continue\n\n    ans[i] = (ans[i-1] + ans[i-2]) % MOD\n\nprint((ans[N]))", "score": 0.0, "codebleu": 0.2035547297806659, "crystalbleu": 0.14518080848680334, "codebertscore": 0.78, "codescore": 0.25141823291778564, "surfaceSim": 0.6007536041939712, "abs_surfaceSim_minus_score": 0.6007536041939712}
{"golden_code": "a,b,c,x,y=list(map(int,input().split()))\n\nans=a*x+b*y\n\nfor HaH in range(0,2*max(x,y)+1,2):\n\n    ans = min(ans, c*HaH+max(0, a*(x-HaH//2))+max(0, b*(y-HaH//2)))\n\nprint(ans)", "generated_code": "n, m, l = list(map(int, input().split()))\n\n\n\na = [0]*n\n\nb = [0]*m\n\nc = [[0 for col in range(l)] for row in range(n)]\n\n\n\nfor i in range(n):\n\n    a[i] = list(map(int,input().split()))\n\n\n\nfor i in range(m):\n\n    b[i] = list(map(int,input().split()))\n\n\n\n\n\nfor i in range(n):\n\n    for j in range(l):\n\n        c[i][j] = sum([a[i][k]*b[k][j] for k in range(m)])\n\n#        for k in range(m):\n\n#            c[i][j] += a[i][k]*b[k][j]\n\n    print((*c[i]))", "score": 0.0, "codebleu": 0.17167642998315957, "crystalbleu": 0.06712669915505973, "codebertscore": 0.75, "codescore": 0.060931213200092316, "surfaceSim": 0.5623464373464373, "abs_surfaceSim_minus_score": 0.5623464373464373}
{"golden_code": "import numpy as np\n\nN,M=list(map(int, input().split()))\n\nhuman=[]\n\nfor i in range(N):\n\n  a,b=list(map(int, input().split()))\n\n  human.append((a,b))\n\nC=[]\n\nfor i in range(M):\n\n  c,d=list(map(int, input().split()))\n\n  C.append((c,d))\n\n  \n\nfor h in human:\n\n  a,b=h\n\n  now=0\n\n  mini=np.inf\n\n  for i,ch in enumerate(C):\n\n    c,d=ch\n\n    L=abs(a-c)+abs(b-d)\n\n    if mini>L:\n\n      mini=L\n\n      now=i+1\n\n  print(now)", "generated_code": "a,b,c,x,y=list(map(int,input().split()))\n\nans=0\n\nm=min(x,y)\n\nif a+b>=2*c: #Half and Half購入で安くなる可能性あるパターン\n\n    # HaHをm枚買って残りHaH購入,または全部HaH購入,このいずれかしかあり得ない\n\n    ans = min(2*c*m+a*(x-m)+b*(y-m), 2*c*max(x,y))\n\nelse:\n\n    ans = a*x+b*y\n\nprint(ans)", "score": 0.0, "codebleu": 0.16017627571364657, "crystalbleu": 0.05524558961438893, "codebertscore": 0.7, "codescore": 0.3222092390060425, "surfaceSim": 0.5396895787139689, "abs_surfaceSim_minus_score": 0.5396895787139689}
{"golden_code": "import numpy as np\n\nN = int(eval(input()))\n\nabc = []\n\nfor i in range(N):\n\n    abc.append(list(map(int, input().split())))\n\n    \n\ndp = np.zeros(shape=(N, 3), dtype=int)\n\ndp[0, :] = abc[0]\n\nfor i in range(N-1):\n\n    dp[i+1, 0] = max(dp[i+1, 0], dp[i, 1] + abc[i+1][0], dp[i, 2] + abc[i+1][0])\n\n    dp[i+1, 1] = max(dp[i+1, 1], dp[i, 0] + abc[i+1][1], dp[i, 2] + abc[i+1][1])\n\n    dp[i+1, 2] = max(dp[i+1, 2], dp[i, 0] + abc[i+1][2], dp[i, 1] + abc[i+1][2])\n\nprint((max(dp[N-1, :])))", "generated_code": "from collections import defaultdict\n\nN = int(eval(input()))\n\nSs = [eval(input()) for i in range(N)]\n\n\n\nd = defaultdict(int)\n\nfor S in Ss:\n\n    d[S] += 1\n\n\n\nmx = max([d[k] for k in list(d.keys())])\n\n\n\nans = []\n\nfor k in list(d.keys()):\n\n    if d[k] == mx:\n\n       ans.append(k)\n\n       \n\nfor a in sorted(ans):\n\n    print(a)", "score": 0.0, "codebleu": 0.10437664057495724, "crystalbleu": 0.05357592012508359, "codebertscore": 0.71, "codescore": 0.9825205206871033, "surfaceSim": 0.43987068965517245, "abs_surfaceSim_minus_score": 0.43987068965517245}
{"golden_code": "class SegmentTree():\n\n    \"\"\"\n\n    update, get を提供するSegmentTree\n\n\n\n    Attributes\n\n    ----------\n\n    __n : int\n\n        葉の数。2 ^ i - 1\n\n    __dot :\n\n        Segment function\n\n    __e: int\n\n        単位元\n\n    __node: list\n\n        Segment Tree\n\n    \"\"\"\n\n    def __init__(self, A, dot, e):\n\n        \"\"\"\n\n        Parameters\n\n        ----------\n\n        A : list\n\n            対象の配列\n\n        dot :\n\n            Segment function\n\n        e : int\n\n            単位元\n\n        \"\"\"\n\n        n = 2 ** (len(A) - 1).bit_length()\n\n        self.__n = n\n\n        self.__dot = dot\n\n        self.__e = e\n\n        self.__node = [e] * (2 * n)\n\n        for i in range(len(A)):\n\n            self.__node[i + n] = A[i]\n\n        for i in range(n - 1, 0, -1):\n\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[2 * i + 1])\n\n    \n\n    def update(self, i, c):\n\n        i += self.__n\n\n        node = self.__node\n\n        node[i] = c\n\n        while i > 1:\n\n            i //= 2\n\n            node[i] = self.__dot(node[2 * i], node[2 * i + 1])\n\n\n\n    def get(self, l, r):\n\n        vl, vr = self.__e, self.__e\n\n        l += self.__n\n\n        r += self.__n\n\n        while (l < r):\n\n            if l & 1:\n\n                vl = self.__dot(vl, self.__node[l])\n\n                l += 1\n\n            l //= 2\n\n            if r & 1:\n\n                r -= 1\n\n                vr = self.__dot(vr, self.__node[r])\n\n            r //= 2\n\n        return self.__dot(vl, vr)\n\n\n\n\n\nN, K = list(map(int, input().split()))\n\nA = [int(eval(input())) for _ in range(N)]\n\nmax_A = max(A)\n\n\n\nst = SegmentTree([N] * (max_A + 1), min, N)\n\nedge = [set() for _ in range(N)]\n\nfor i, a in enumerate(reversed(A)):\n\n    j = N - 1 - i\n\n    p1 = st.get(a, min(max_A + 1, a + K + 1))\n\n    if p1 < N:\n\n        edge[j].add(p1)\n\n    p2 = st.get(max(0, a - K), a)\n\n    if p2 < N:\n\n        edge[j].add(p2)\n\n    p0 = st.get(a, a + 1)\n\n    if p0 < N:\n\n        edge[j].add(p0)\n\n    st.update(a, j)\n\n\n\ndp = [1] * N\n\nfor i in range(N - 1):\n\n    here = dp[i]\n\n    for ni in edge[i]:\n\n        if ni < N:\n\n            dp[ni] = max(dp[ni], dp[i] + 1)\n\n\n\nprint((max(dp)))\n", "generated_code": "A,B,C,X,Y = list(map(int,input().split()))\n\nans = 0\n\nif 2*C <= A+B:\n\n    Z = min(X,Y)\n\n    ans = 2*C*Z\n\n    X -= Z\n\n    Y -= Z\n\nans += min(2*C*X,A*X)\n\nans += min(2*C*Y,B*Y)\n\nprint(ans)", "score": 0.0, "codebleu": 0.05659683933688503, "crystalbleu": 0.0014115132648976777, "codebertscore": 0.63, "codescore": 0.7486271262168884, "surfaceSim": 0.4439475138476565, "abs_surfaceSim_minus_score": 0.4439475138476565}
{"golden_code": "from functools import reduce\n\nfrom itertools import product\n\n\n\nN = int(eval(input()))\n\n*A, = list(map(int, input().split()))\n\nans = 0\n\nfor t in product([-1, 0, 1], repeat=N):\n\n    prod = reduce(lambda x, y: x*y, [a + t[i] for i, a in enumerate(A)])\n\n    if prod % 2 == 0: ans += 1\n\nprint(ans)", "generated_code": "n = int(eval(input()))\n\n\n\nans = 1\n\nfor i in range(1, n+1):\n\n    ans = ans * i\n\n    ans = ans % ((10 ** 9)+7)  # 途中で割り算の余りを求めても、最終結果は同じになる\n\n\n\nprint(ans)", "score": 0.0, "codebleu": 0.13598600565209681, "crystalbleu": 0.0, "codebertscore": 0.69, "codescore": 0.3779894709587097, "surfaceSim": 0.3932312651087832, "abs_surfaceSim_minus_score": 0.3932312651087832}
{"golden_code": "import re;print((max(list(map(len,re.split('[^ACGT]',eval(input())))))))", "generated_code": "# coding: utf-8\n\nimport sys\n\n\n\nsr = lambda: sys.stdin.readline().rstrip()\n\nir = lambda: int(sr())\n\nlr = lambda: list(map(int, sr().split()))\n\n\n\nN = ir()\n\nA = lr()\n\nbl = all(x % 3 == 0 or x % 5 == 0 for x in A if x % 2 == 0)\n\nprint(('APPROVED' if bl else 'DENIED'))\n", "score": 0.0, "codebleu": 0.38859475356166073, "crystalbleu": 0.0, "codebertscore": 0.68, "codescore": 0.8238049149513245, "surfaceSim": 0.42152658662092624, "abs_surfaceSim_minus_score": 0.42152658662092624}
