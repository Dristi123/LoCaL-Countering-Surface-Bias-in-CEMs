{"golden_code": "n, m = list(map(int, input().split()))\n\ngate = []\n\nl, r = list(map(int, input().split()))\n\nfor i in range(1, m):\n\n    m, s = list(map(int, input().split()))\n\n    if l < m:\n\n        l = m\n\n    if s < r:\n\n        r = s\n\nprint((len([i for i in range(l, r + 1)])))", "generated_code": "n, m = list(map(int, input().split()))\n\nl, r = [0] * m, [0] * m\n\nfor i in range(m):\n\n    l[i], r[i] = list(map(int, input().split()))\n\nprint((max(min(r) - max(l) + 1, 0)))", "score": 1.0}
{"golden_code": "import numpy as np\n\n\n\nN = int(eval(input()))\n\nA = list(map(int, input().split()))\n\n\n\nA = np.array(A)\n\ncounter = 0\n\nwhile True:\n\n    if all( i%2==0 for i in A):\n\n        counter  += 1\n\n        A = A/2\n\n    else:\n\n        print(counter)\n\n        break", "generated_code": "N = int(eval(input()))\n\nA = list(map(int, input().split()))\n\n\n\nc = 0\n\nwhile True:\n\n    if all(a% 2 ==0 for a in A):\n\n        c += 1\n\n        A = list([x//2 for x in A])\n\n    else:\n\n        break\n\nprint(c)", "score": 1.0}
{"golden_code": "# C - Go to School\n\ndef main():\n\n    import numpy as np\n\n    n = int(input())\n\n    a = list(map(int, input().split()))\n\n    a = np.array(a)\n\n    a = np.argsort(a)\n\n    for i in a:\n\n        print(i+1,end=\" \")\n\n\n\nif __name__ ==  \"__main__\":\n\n    main()\n", "generated_code": "# C - Go to School\n\ndef main():\n\n    n = int(eval(input()))\n\n    a = list(map(int, input().split()))\n\n    ans = [0] * n\n\n\n\n    for i, o in enumerate(a):\n\n        ans[o-1] = i + 1 \n\n    \n\n    print((*ans))\n\n\n\nif __name__ ==  \"__main__\":\n\n    main()", "score": 1.0}
{"golden_code": "n = int(eval(input()))\n\n\n\nINF = 10**9 + 7\n\n\n\nans = [0] * (10**5 + 1)\n\nans[0] = 1\n\n\n\nfor i in range(1,10**5 + 1):\n\n    ans[i] = ans[i-1] * i % INF\n\n\n\nprint((ans[n]))\n", "generated_code": "n = int(eval(input()))\n\nmod = 10**9 + 7\n\n\n\nans = 1\n\n\n\nfor i in range(1,n+1):\n\n    ans = ans * i % mod\n\n\n\nprint(ans)", "score": 1.0}
{"golden_code": "import numpy as np\n\nn,d=list(map(int,input().split()))\n\nnda=np.empty((0,d),int)\n\nans=0\n\nfor i in range(0,n):\n\n  a=np.array([list(map(int,input().split()))])\n\n  for j in range(i):\n\n    chklen=np.linalg.norm(a-nda[j])\n\n    if chklen==chklen//1:\n\n      ans+=1\n\n  nda=np.append(nda,a,axis=0)\n\nprint(ans)", "generated_code": "import math\n\nn,d=list(map(int,input().split()))\n\na=[0]*n\n\nfor i in range(n):\n\n  a[i]=list(map(int,input().split()))\n\nans=0\n\nfor i in range(n-1):\n\n  for j in range(i+1,n):\n\n    chklen=0\n\n    wk=0\n\n    for k in range(d):\n\n      wk+=abs(a[i][k]-a[j][k])**2\n\n    chklen=math.sqrt(wk)\n\n    if chklen==chklen//1:\n\n      ans+=1\n\nprint(ans)", "score": 1.0}
{"golden_code": "# coding: utf-8\n\n# Your code here!\n\nimport sys\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\n\n\n#a,b,c,d = map(int,readline().split())\n\ns,k = readline().split()\n\n\n\n\n\na = [len(i) for i in s.split(\"0\")]\n\nwhile a and a[-1] == 0: a.pop()\n\n\n\nif not a:\n\n    print((1))\n\n    exit()\n\n\n\nMOD = 998244353\n\n\n\nM = sum(a)+1\n\nk = min(int(k),M)\n\n\n\n\n\ndp = [[0]*M for _ in range(k+1)] # j 使って（上限 k）、l 余ってる\n\ndp[0][0] = 1\n\n\n\n#print(a)\n\nfor ai in a[::-1]:\n\n    ndp = [[0]*M for _ in range(k+1)] # j 使って（上限 k）、l 余ってる\n\n    for j in range(k+1):\n\n        for l in range(M):\n\n            for ll in range(l):\n\n                ndp[j][ll] += dp[j][l]\n\n                ndp[j][ll] %= MOD\n\n            \n\n            V = min(M-l,k-j+1,ai+1)\n\n            for i in range(V):\n\n                #if j+i > k: break\n\n                ndp[j+i][l+i] += dp[j][l]\n\n                ndp[j+i][l+i] %= MOD\n\n    \n\n    dp = ndp\n\n    #print(dp)\n\n\n\nans = 0\n\nfor jj in range(k+1):\n\n    ans += dp[jj][0]\n\n\n\nprint((ans%MOD))\n\n\n\n\n\n\n\n\n\n\n", "generated_code": "# coding: utf-8\n\n# Your code here!\n\nimport sys\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\n\n\n#a,b,c,d = map(int,readline().split())\n\ns,k = readline().split()\n\n\n\n\n\na = [len(i) for i in s.split(\"0\")]\n\nwhile a and a[-1] == 0: a.pop()\n\n\n\nif not a:\n\n    print((1))\n\n    exit()\n\n\n\nMOD = 998244353\n\n\n\nM = sum(a)+1\n\nk = min(int(k),M)\n\n\n\n\n\ndp = [[0]*M for _ in range(k+1)] # j 使って（上限 k）、l 余ってる\n\ndp[0][0] = 1\n\n\n\n#print(a)\n\nfor ai in a[::-1]:\n\n    ndp = [[0]*M for _ in range(k+1)] # j 使って（上限 k）、l 余ってる\n\n    for j in range(k+1):\n\n        for l in range(M):\n\n            if dp[j][l]:\n\n                for ll in range(l):\n\n                    ndp[j][ll] += dp[j][l]\n\n                    ndp[j][ll] %= MOD\n\n\n\n                V = min(M-l,k-j+1,ai+1)\n\n                for i in range(V):\n\n                    #if j+i > k: break\n\n                    ndp[j+i][l+i] += dp[j][l]\n\n                    ndp[j+i][l+i] %= MOD\n\n    \n\n    dp = ndp\n\n    #print(dp)\n\n\n\nans = 0\n\nfor jj in range(k+1):\n\n    ans += dp[jj][0]\n\n\n\nprint((ans%MOD))\n\n\n\n\n\n\n\n\n\n\n", "score": 1.0}
{"golden_code": "A,B = list(map(int,input().split()))\n\nj = 0\n\nfor i in range(A,B+1):\n\n  l = list(str(i))\n\n  l_reverse = list(reversed(l))\n\n  if l == l_reverse:\n\n    j += 1\n\nprint(j)", "generated_code": "A, B = list(map(int,input().split()))\n\n\n\nans = 0\n\nfor n in range(A, B+1):\n\n    n = str(n)\n\n    if n == n[::-1]:\n\n        ans += 1\n\nprint(ans)", "score": 1.0}
{"golden_code": "def post_from_pre_in(preorder_elements, inorder_elements):\n\n    if preorder_elements:\n\n        global cnt\n\n        root = preorder_elements[0]\n\n        root_index = inorder_elements.index(root)\n\n        preorder_left = preorder_elements[1:root_index+1]\n\n        inorder_left = inorder_elements[:root_index]\n\n        preorder_right = preorder_elements[root_index+1:]\n\n        inorder_right = inorder_elements[root_index+1:]\n\n        post_from_pre_in(preorder_left, inorder_left)\n\n        post_from_pre_in(preorder_right, inorder_right)\n\n        if cnt:\n\n            print(root, end = ' ')\n\n            cnt -= 1\n\n        else:\n\n            print(root)\n\n\n\n\n\ncnt = int(input()) - 1\n\n\n\na = list(map(int, input().split()))\n\nb = list(map(int, input().split()))\n\n\n\npost_from_pre_in(a, b)\n", "generated_code": "postorder_elements = []\n\n\n\ndef post_from_pre_in(preorder_elements, inorder_elements):\n\n    if preorder_elements:\n\n        root = preorder_elements[0]\n\n        root_index = inorder_elements.index(root)\n\n        preorder_left = preorder_elements[1:root_index+1]\n\n        inorder_left = inorder_elements[:root_index]\n\n        preorder_right = preorder_elements[root_index+1:]\n\n        inorder_right = inorder_elements[root_index+1:]\n\n        post_from_pre_in(preorder_left, inorder_left)\n\n        post_from_pre_in(preorder_right, inorder_right)\n\n        postorder_elements.append(root)\n\n\n\n\n\n\n\nn = int(eval(input()))\n\n\n\na = list(map(int, input().split()))\n\nb = list(map(int, input().split()))\n\n\n\npost_from_pre_in(a, b)\n\n\n\nprint((*postorder_elements))", "score": 1.0}
{"golden_code": "import sys\n\nimport numpy as np\n\n\n\n\n\ndef main():\n\n    h, w = list(map(int, sys.stdin.buffer.readline().split()))\n\n    n = int(sys.stdin.buffer.readline())\n\n    a = list(map(int, sys.stdin.buffer.readline().split()))\n\n    ans = np.zeros(w*h, np.int64)\n\n    now = 0\n\n    for i, x in enumerate(a):\n\n        for j in range(x):\n\n            ans[now + j] = i+1\n\n        now += x\n\n\n\n    ans = ans.reshape(h, w)\n\n    for i in range(h):\n\n        if i % 2:\n\n            print((*ans[i, ::-1]))\n\n        else:\n\n            print((*ans[i]))\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "generated_code": "import sys\n\n\n\n\n\ndef main():\n\n    h, w = list(map(int, sys.stdin.buffer.readline().split()))\n\n    n = int(sys.stdin.buffer.readline())\n\n    a = list(map(int, sys.stdin.buffer.readline().split()))\n\n    ans = [0]*(w*h)\n\n    now = 0\n\n    for i, x in enumerate(a):\n\n        for j in range(x):\n\n            ans[now + j] = i+1\n\n        now += x\n\n\n\n    for i in range(h):\n\n        if i % 2:\n\n            print((*reversed(ans[i*w:(i+1)*w])))\n\n        else:\n\n            print((*ans[i*w:(i+1)*w]))\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "score": 1.0}
{"golden_code": "a, b, c, x, y = list(map(int, input().split()))\n\n# print(a, b, c, x, y)\n\n\n\nans = 10000 * (10 **5) + 7\n\nc_max = 0\n\nif x > y:\n\n  c_max = x * 2\n\nelse:\n\n  c_max = y * 2\n\n\n\nfor cc in range(c_max+1):\n\n  ac = x - (cc // 2)\n\n  bc = y - (cc // 2)\n\n  \n\n  if ac < 0:\n\n    ac = 0\n\n  if bc < 0:\n\n    bc = 0\n\n  price = ac * a + bc * b + cc * c\n\n  # print('price: {}, ac: {}, bc: {}, cc: {}'.format(price, ac, bc, cc))\n\n  ans = min(ans, price)\n\n\n\nprint(ans)", "generated_code": "a, b, c, x, y = list(map(int, input().split()))\n\n# print(a, b, c, x, y)\n\n\n\nans = 10000 * (10 **5) + 7\n\nc_max = 0\n\nif x > y:\n\n  c_max = x * 2\n\nelse:\n\n  c_max = y * 2\n\n\n\nfor cc in range(0, c_max+1, 2):\n\n  ac = x - (cc // 2)\n\n  bc = y - (cc // 2)\n\n  \n\n  if ac < 0:\n\n    ac = 0\n\n  if bc < 0:\n\n    bc = 0\n\n  price = ac * a + bc * b + cc * c\n\n  # print('price: {}, ac: {}, bc: {}, cc: {}'.format(price, ac, bc, cc))\n\n  ans = min(ans, price)\n\n\n\nprint(ans)\n\n  ", "score": 1.0}
{"golden_code": "import numpy as np\n\nN,M=list(map(int,input().split()))\n\nA=np.zeros((N+1,M+1))\n\nA[0]=np.ones(M+1)\n\nfor i in range(1,N+1):\n\n    B=list(map(int,input().split()))\n\n    for m in range(1,B[0]+1):\n\n        A[i][B[m]]=A[i-1][B[m]]\n\na=sum(A[N])\n\nprint((int(a)))", "generated_code": "N,M=list(map(int,input().split()))\n\nA = [[1 for _ in range(M)]]+[[0 for _ in range(M)] for _ in range(N)]\n\nfor i in range(1,N+1):\n\n    B=list(map(int,input().split()))\n\n    Ai=B[1:]\n\n    for m in Ai:\n\n        A[i][m-1]=A[i-1][m-1]\n\na=sum(A[N])\n\nprint((int(a)))", "score": 1.0}
{"golden_code": "n,t=int(input()),list(map(int,input().split()));T=sum(t)\n\nprint(*[T-t[i-1]+j for i,j in [list(map(int,input().split())) for _ in range(int(input()))]],sep='\\n')\n", "generated_code": "input();t=list(map(int,input().split()));T=sum(t)\n\nprint(*[T-t[i-1]+j for i,j in [list(map(int,input().split())) for _ in range(int(input()))]],sep='\\n')\n", "score": 1.0}
{"golden_code": "def findSumDigit(num):\n\n    global total\n\n    total = \"\"\n\n    while num > 0:\n\n        total += str(num % 10)\n\n        num //= 10\n\n    return total\n\n\n\ndef main():\n\n    a,b = list(map(int, input().split()))\n\n    ans = 0\n\n    for i in range(a,b+1):\n\n        tmp = str(findSumDigit(i))\n\n        if tmp == str(i):\n\n            ans += 1\n\n    print(ans)\n\n\n\nif __name__ == '__main__':\n\n    main()", "generated_code": "a, b = list(map(int, input().split()))\n\nans = 0\n\n\n\nfor i in range(a,b+1):\n\n    seki_gyaku = str(i)\n\n    if seki_gyaku == seki_gyaku[::-1]:\n\n        ans += 1\n\n\n\nprint(ans)\n", "score": 1.0}
{"golden_code": "from itertools import combinations\n\nimport numpy as np\n\nN = int(eval(input()))\n\nD = list(map(int, input().split()))\n\nList = np.array(list(combinations(D,2)))\n\nprint((sum(np.product(List, axis = 1))))\n\n\n\n\n", "generated_code": "N = int(eval(input()))\n\nD = list(map(int, input().split()))\n\nfrom itertools import accumulate\n\nprint((sum(list(d*c for d, c in zip(D[1:], accumulate(D))))))\n", "score": 1.0}
{"golden_code": "import sys\n\nsys.setrecursionlimit(10**6)\n\ndef dfs(v,p,d):\n\n    for i, j in tree[v]:\n\n        if i != p:\n\n            depth[i] = d + j\n\n            dfs(i,v,d+j)\n\n\n\nN = int(eval(input()))\n\n\n\ntree = [[] for _ in range(N)]\n\n\n\nfor i in range(N-1):\n\n    a, b, c = list(map(int, input().split()))\n\n    a -= 1\n\n    b -= 1\n\n    tree[a].append((b,c))\n\n    tree[b].append((a,c))\n\n\n\nQ, K = list(map(int, input().split()))\n\n\n\ndepth = [0 for i in range(N)]\n\ndepth[K-1] = 0\n\n\n\ndfs(K-1,-1,0)\n\n\n\nfor _ in range(Q):\n\n    x, y = list(map(int, input().split()))\n\n    print((depth[x-1] + depth[y-1]))", "generated_code": "import heapq\n\nimport sys\n\n\n\ninput = sys.stdin.readline\n\n\n\ndef dijkstra(s, edge, N):\n\n    d = [float('inf')] * N\n\n    used = [True] * N\n\n    d[s] = 0\n\n    used[s] = False\n\n    edgelist = []\n\n    for a, b in edge[s]:\n\n        heapq.heappush(edgelist, a * (10 ** 6) + b)\n\n    while len(edgelist):\n\n        minedge = heapq.heappop(edgelist)\n\n\n\n        if not used[minedge%(10 ** 6)]:\n\n            continue\n\n        v = minedge % (10 ** 6)\n\n        d[v] = minedge // (10 ** 6)\n\n        used[v] = False\n\n        for e in edge[v]:\n\n            if used[e[1]]:\n\n                heapq.heappush(edgelist, (e[0] + d[v]) * (10 ** 6) + e[1])\n\n    return d\n\n\n\ndef main():\n\n    N = int(eval(input()))\n\n    edge = [[] for _ in range(N)]\n\n    for _ in range(N-1):\n\n        a, b, c = list(map(int, input().split()))\n\n        a -= 1\n\n        b -= 1\n\n        edge[a].append([c,b])\n\n        edge[b].append([c,a])\n\n    Q, K = list(map(int, input().split()))\n\n    K -= 1\n\n    d = dijkstra(K, edge, N)\n\n    for _ in range(Q):\n\n        x, y = list(map(int, input().split()))\n\n        x -= 1\n\n        y -= 1\n\n        print((d[x] + d[y]))\n\n\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()", "score": 1.0}
{"golden_code": "mod = 2019\n\nl, r = list(map(int, input().split()))\n\n\n\nif r//mod - l//mod > 0:\n\n  print((0))\n\nelse:\n\n  l %= mod\n\n  r %= mod\n\n  ans = mod\n\n  for i in range(l+1, r+1):\n\n    for j in range(l, i):\n\n      ans = min(i*j%mod, ans)\n\n    if ans == 0:\n\n      break\n\n  print(ans)", "generated_code": "mod = 2019\n\nl, r = list(map(int, input().split()))\n\n\n\nif r//mod - l//mod > 0:\n\n  print((0))\n\nelse:\n\n  l %= mod\n\n  r %= mod\n\n  ans = mod\n\n  for i in range(l, r):\n\n    for j in range(i+1, r+1):\n\n      ans = min(i*j%mod, ans)\n\n    if ans == 0:\n\n      break\n\n  print(ans)", "score": 1.0}
{"golden_code": "H,W = list(map(int,input().split()))\n\nN = int(eval(input()))\n\nA = list(map(int,input().split()))\n\nA.insert(0,0)\n\nC = [[0 for _ in range(W)] for _ in range(H)]\n\ncur = [0,0,\"R\"]\n\nfor k in range(1,N+1):\n\n#     ipdb.set_trace()\n\n    a = A[k]\n\n    cnt = 0\n\n    y,x,d = cur\n\n    for i in range(y,H):\n\n        y = i\n\n        if d==\"R\":\n\n            for j in range(x,W):\n\n                C[i][j]=str(k)\n\n                cnt += 1\n\n                if j+1<W:\n\n                    x = j+1\n\n                else:\n\n                    x = j\n\n                if cnt==a:break\n\n            if cnt==a:break\n\n            d=\"L\"\n\n        else:\n\n            for j in range(x,-1,-1):\n\n                C[i][j]=str(k)\n\n                cnt += 1\n\n                if j>=1:\n\n                    x = j-1\n\n                else:\n\n                    x = 0\n\n                if cnt==a:break\n\n            if cnt==a:break\n\n            d=\"R\"\n\n    if x==W-1:\n\n        if C[y][x]!=0:\n\n            y += 1\n\n            d=\"L\"\n\n    elif x==0:\n\n        if C[y][x]!=0:\n\n            y += 1\n\n            d=\"R\"\n\n    cur = [y,x,d]                \n\nfor i in range(H):\n\n    print((*C[i]))", "generated_code": "H,W = list(map(int,input().split()))\n\nN = int(eval(input()))\n\nA = list(map(int,input().split()))\n\nA.insert(0,0)\n\nB = [[0 for _ in range(W)] for _ in range(H)]\n\ncol = 1\n\ncnt = 0\n\ny = 0\n\nx = 0\n\nd = \"R\"\n\nwhile y<H:\n\n    if cnt<A[col]:\n\n        B[y][x] = col\n\n        cnt += 1\n\n    else:\n\n        col += 1\n\n        cnt = 0\n\n        B[y][x] = col\n\n        cnt += 1\n\n    if x<W-1 and d==\"R\":\n\n        x += 1\n\n    elif x==W-1 and d==\"R\":\n\n        y += 1\n\n        d = \"L\"\n\n    elif d==\"L\" and x>0:\n\n        x -= 1\n\n    elif d==\"L\" and x==0:\n\n        y += 1\n\n        d = \"R\"\n\nfor i in range(H):\n\n    print((*B[i]))", "score": 1.0}
{"golden_code": "X,Y,Z,K = list(map(int,input().split()))\n\nA = list(map(int,input().split()))\n\nB = list(map(int,input().split()))\n\nC = list(map(int,input().split()))\n\nasort,bsort,csort = sorted(A,reverse=True),sorted(B,reverse=True),sorted(C,reverse=True)\n\nprint((asort[0] + bsort[0] + csort[0]))\n\nalready = [[0,0,0]]\n\nx,y,z = 0,0,0\n\nplace_sum = []\n\ncheck = []\n\nfor k in range(K - 1):\n\n    if [x + 1,y,z] not in already and x + 1 < X:\n\n        already.append([x + 1,y,z])\n\n        place_sum.append([x + 1,y,z])\n\n        check.append(asort[x + 1] + bsort[y] + csort[z])\n\n    if [x,y + 1,z] not in already and y + 1 < Y:\n\n        already.append([x,y + 1,z])\n\n        place_sum.append([x,y + 1,z])\n\n        check.append(asort[x] + bsort[y + 1] + csort[z])\n\n    if [x,y,z + 1] not in already and z + 1 < Z:\n\n        already.append([x,y,z + 1])\n\n        place_sum.append([x,y,z + 1])\n\n        check.append(asort[x] + bsort[y] + csort[z + 1])\n\n    print((max(check)))\n\n    x,y,z = place_sum[check.index(max(check))][0],place_sum[check.index(max(check))][1],place_sum[check.index(max(check))][2]\n\n    place_sum.pop(check.index(max(check)))\n\n    check.remove(max(check))", "generated_code": "import heapq\n\nX,Y,Z,K = list(map(int,input().split()))\n\nA = list(map(int,input().split()))\n\nB = list(map(int,input().split()))\n\nC = list(map(int,input().split()))\n\nasort,bsort,csort = sorted(A,reverse=True),sorted(B,reverse=True),sorted(C,reverse=True)\n\nalready = [[0,0,0]]\n\nprint((asort[0] + bsort[0] + csort[0]))\n\nx,y,z = 0,0,0\n\ncheck = []\n\nfor k in range(K - 1):\n\n    if [x + 1,y,z] not in already and x + 1 < X:\n\n        already.append([x + 1,y,z])\n\n        heapq.heappush(check,(-(asort[x + 1] + bsort[y] + csort[z]),x + 1,y,z))\n\n    if [x,y + 1,z] not in already and y + 1 < Y:\n\n        already.append([x,y + 1,z])\n\n        heapq.heappush(check,(-(asort[x] + bsort[y + 1] + csort[z]),x,y + 1,z))\n\n    if [x,y,z + 1] not in already and z + 1 < Z:\n\n        already.append([x,y,z + 1])\n\n        heapq.heappush(check,(-(asort[x] + bsort[y] + csort[z + 1]),x,y,z + 1))\n\n    maxsum = heapq.heappop(check)\n\n    print((-maxsum[0]))\n\n    x,y,z = maxsum[1],maxsum[2],maxsum[3]", "score": 1.0}
{"golden_code": "import numpy as np\n\n\n\nS=eval(input())\n\nS=np.array([1 if s=='B' else 0 for s in S])\n\n\n\nprint((np.abs(np.diff(S)).sum()))\n", "generated_code": "from itertools import groupby\n\n\n\nS=eval(input())\n\nanswer = sum([1 for _ in groupby(S)]) -1\n\n\n\nprint(answer)", "score": 1.0}
{"golden_code": "while 1:\n\n    ans=0\n\n    n,x=list(map(int,input().split()))\n\n    if n:\n\n        for i in range(1,n-1):\n\n            for j in range(i+1,n):\n\n                for k in range(j+1,n+1):\n\n                    if i+j+k==x:ans+=1\n\n    else:break\n\n    print(ans)", "generated_code": "while 1:\n\n    a=0\n\n    n,x=list(map(int,input().split()))\n\n    if n==0:break\n\n    for i in range(1,n-1):\n\n        for j in range(i+1,n):\n\n            c=x-i-j\n\n            if c>j and c<=n:a+=1\n\n    print(a)", "score": 1.0}
{"golden_code": "import sys\n\nimport numpy as np\n\n\n\nx, y, z, k = map(int, sys.stdin.readline().split())\n\na, b, c = (np.array(sys.stdin.readline().split(), dtype=np.int64) for _ in range(3))\n\n\n\ndef main():\n\n    res = np.sort(np.ravel(a[:, None] + b))[::-1]\n\n    res = np.sort(np.ravel(c[:, None] + res[:min(k, x*y)]))[::-1]\n\n    return res[:k]\n\n\n\nif __name__ == '__main__':\n\n    ans = main()\n\n    print(*ans, sep='\\n')\n", "generated_code": "import sys\n\n\n\nx, y, z, K = map(int, sys.stdin.readline().split())\n\na, b, c = (sorted(map(int, sys.stdin.readline().split()), reverse=True) for _ in range(3))\n\ndef main():\n\n    res = []\n\n    for i in range(1, min(K, x) + 1):\n\n        for j in range(1, min(K // i, y) + 1):\n\n            for k in range(1, min(K // (i * j), z) + 1):\n\n                res.append(a[i-1] + b[j-1] + c[k-1])\n\n\n\n    return sorted(res, reverse=True)[:K]\n\n\n\nif __name__ == '__main__':\n\n    ans = main()\n\n    print(*ans, sep='\\n')\n", "score": 1.0}
{"golden_code": "K = int(eval(input()))\n\n\n\nflg = [False]*K\n\n\n\ntmp = 7 % K\n\ncnt = 1\n\nif tmp == 0:\n\n    print(cnt)\n\n    exit()\n\nwhile True:\n\n    tmp = (tmp*10+7)%K\n\n    if flg[tmp]:\n\n        print((-1))\n\n        break\n\n    else:\n\n        cnt += 1\n\n        if tmp == 0:\n\n            print(cnt)\n\n            break\n\n        flg[tmp] = True\n", "generated_code": "K = int(eval(input()))\n\nt = 7\n\nt %= K\n\n\n\nfor i in range(K+1):\n\n    if t == 0:\n\n        print((i+1))\n\n        exit()\n\n    t = (t*10+7)%K\n\nprint((-1))\n", "score": 1.0}
{"golden_code": "import numpy as np\n\nimport numba\n\nfrom numba import njit, b1, i4, i8, f8\n\n\n\n@njit((i8, i8[:]), cache=True)\n\ndef main(N,A):\n\n  Amax = np.max(A)\n\n  lis = np.zeros(Amax+1, np.int64)\n\n  for i in range(N):\n\n    lis[A[i]] += 1\n\n  setwise = False\n\n  for t in range(2,Amax+1):\n\n    cnt = np.sum(lis[t:Amax+1:t])\n\n    if cnt==N:\n\n      return 'not'\n\n    if 2<=cnt<N:\n\n      setwise=True\n\n  if setwise==True:\n\n    return 'setwise'\n\n  return 'pairwise'\n\n\n\nN = int(eval(input()))\n\nA = np.array(list(map(int, input().split())))\n\nprint((main(N,A)+' coprime'))\n\n\n", "generated_code": "def sieve(n):\n\n  is_prime = [True for _ in range(n+1)]\n\n  is_prime[0] = False\n\n  for i in range(2, n+1):\n\n    if is_prime[i-1]:\n\n      j = 2 * i\n\n      while j <= n:\n\n        is_prime[j-1] = False\n\n        j += i\n\n  table = [i for i in range(1, n+1) if is_prime[i-1]]\n\n  return table\n\n\n\nN = int(eval(input()))\n\nA = list(map(int, input().split()))\n\nAmax = max(A)\n\nlis = [0]*(Amax+1)\n\nfor i in range(N):\n\n  lis[A[i]] += 1\n\ntable = sieve(Amax)\n\nsetwise = False\n\nfor t in table:\n\n  cnt = sum(lis[t:Amax+1:t])\n\n  if cnt==N:\n\n    print('not coprime')\n\n    break\n\n  if 2<=cnt<N:\n\n    setwise=True\n\nelse:\n\n  if setwise==True:\n\n    print('setwise coprime')\n\n  else:\n\n    print('pairwise coprime')\n", "score": 1.0}
{"golden_code": "import numpy as np\n\nN = int(eval(input()))\n\n\n\nabc = np.array([list(map(int, input().split())) for i in range(N)])\n\n\n\ndp = [[0]*3 for i in range(N+1)]\n\n\n\nfor i in range(1, N+1):\n\n    dp[i][0] = max(dp[i - 1][1] + abc[i - 1][1], dp[i - 1][2] + abc[i - 1][2])\n\n    dp[i][1] = max(dp[i - 1][0] + abc[i - 1][0], dp[i - 1][2] + abc[i - 1][2])\n\n    dp[i][2] = max(dp[i - 1][1] + abc[i - 1][1], dp[i - 1][0] + abc[i - 1][0])\n\n\n\nprint((max(dp[-1])))\n", "generated_code": "N = int(eval(input()))\n\n\n\nA = [0] * (N + 1)\n\nB = [0] * (N + 1)\n\nC = [0] * (N + 1)\n\n\n\nfor i in range(1, N + 1):\n\n    A[i], B[i], C[i] = list(map(int, input().split()))\n\n\n\ndp = [[0] * 3 for _ in range(N + 1)]\n\nfor i in range(1, N + 1):\n\n    dp[i][0] = A[i] + max(dp[i-1][1], dp[i-1][2])\n\n    dp[i][1] = B[i] + max(dp[i-1][2], dp[i-1][0])\n\n    dp[i][2] = C[i] + max(dp[i-1][0], dp[i-1][1])\n\n\n\nprint((max(dp[N])))", "score": 1.0}
{"golden_code": "import math\n\nN = int(eval(input()))\n\nans = math.factorial(N) % (10 ** 9 + 7)\n\nprint(ans)", "generated_code": "n = int(eval(input()))\n\nfrom functools import reduce\n\nprint((reduce(lambda x,y:x*y%1000000007,list(range(1,n+1)))))", "score": 1.0}
{"golden_code": "import numpy as np\n\nn = int(eval(input()))\n\nballs = np.array(list(map(int, input().split())))\n\ntime = 0\n\nwhile np.all(balls % 2 == 0) and np.all(balls > 0):\n\n    time += 1\n\n    balls = balls / 2\n\nprint(time)", "generated_code": "import math\n\nn = eval(input())\n\na = list(map(int, input().split()))\n\nans = float(\"inf\")\n\nfor i in a:\n\n    ans = min(ans, len(bin(i)) - bin(i).rfind(\"1\") - 1)\n\nprint((round(ans)))", "score": 1.0}
{"golden_code": "import math\n\nn=int(eval(input()))\n\nans=n\n\ni=1\n\nwhile(i<=math.sqrt(n)):\n\n    if n%i==0:\n\n        d=i+n/i-2\n\n        ans=min(ans,d)\n\n    i+=1\n\nprint((int(ans)))", "generated_code": "from math import floor\n\nfrom math import sqrt\n\nn=int(eval(input()))\n\nnn=floor(sqrt(n))\n\nrest=n%nn\n\nwhile rest!=0:\n\n    nn-=1\n\n    rest=n%nn\n\nnnn=n/nn\n\nprint((int(nn+nnn-2)))", "score": 1.0}
{"golden_code": "def main():\n\n    n = int(eval(input()))\n\n    import numpy as np\n\n    ans = np.zeros((10,10))\n\n    for i in range(1,n+1):\n\n        h,t = str(i)[0],str(i)[-1]\n\n        ans[int(h)-1][int(t)-1]+=1\n\n    s = 0\n\n    for i in range(10):\n\n        for j in range(10):\n\n            s += ans[i][j]*ans[j][i]\n\n\n\n    print((int(s)))\n\nif __name__ == \"__main__\":\n\n    main()", "generated_code": "def main():\n\n    n = int(eval(input()))\n\n    dp = [[0 for i in range(10)] for i in range(10)]\n\n    for i in range(1,n+1):\n\n        h,t = int(str(i)[0]), int(str(i)[-1])\n\n        dp[h][t] += 1\n\n    ans = 0\n\n    for i in range(10):\n\n        for j in range(10):\n\n            ans += dp[i][j] * dp[j][i]\n\n    print(ans)\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "score": 1.0}
{"golden_code": "import numpy\n\nN, D = list(map(int, input().split()))\n\nlistx = []\n\ncount = 0\n\nfor i in range(N):\n\n    x = list(map(int, input().split()))\n\n    listx.append(x)\n\n\n\nfor j in range(0, N):\n\n    for k in range(j+1,N):\n\n        a = numpy.array(listx[j])\n\n        b = numpy.array(listx[k])\n\n        u = b - a\n\n        c = float(numpy.linalg.norm(u))\n\n        if c.is_integer() :\n\n            count += 1\n\nprint(count)", "generated_code": "def LI(): return list(map(int,input().split()))\n\nN,D = LI()\n\nX = [LI() for _ in range(N)]\n\nans = 0\n\nfor i in range(N):\n\n    for j in range(i+1,N):\n\n        temp = 0\n\n        for k in range(D):\n\n            temp += (X[j][k]-X[i][k])**2\n\n        if temp **0.5%1==0:\n\n            ans += 1\n\nprint(ans)", "score": 1.0}
{"golden_code": "import sys\n\n\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\nreadlines = sys.stdin.readlines\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = 1 << 60\n\nMOD = 1000000007\n\n\n\n# Reference: https://www.geeksforgeeks.org/queries-number-distinct-elements-subarray/\n\n# Python3 code to find number of\n\n# distinct numbers in a subarray\n\nMAX = 1000001\n\n\n\n# structure to store queries\n\nclass Query:\n\n    def __init__(self, l, r, idx):\n\n        self.l = l\n\n        self.r = r\n\n        self.idx = idx\n\n\n\n\n\n# updating the bit array\n\ndef update(idx, val, bit, n):\n\n    while idx <= n:\n\n        bit[idx] += val\n\n        idx += idx & -idx\n\n\n\n\n\n# querying the bit array\n\ndef query(idx, bit, n):\n\n    summ = 0\n\n    while idx:\n\n        summ += bit[idx]\n\n        idx -= idx & -idx\n\n    return summ\n\n\n\n\n\ndef answeringQueries(arr, n, queries, q):\n\n\n\n    # initialising bit array\n\n    bit = [0] * (n + 1)\n\n\n\n    # holds the rightmost index of\n\n    # any number as numbers of a[i]\n\n    # are less than or equal to 10^6\n\n    last_visit = [-1] * MAX\n\n\n\n    # answer for each query\n\n    ans = [0] * q\n\n\n\n    query_counter = 0\n\n    for i in range(n):\n\n\n\n        # If last visit is not -1 update -1 at the\n\n        # idx equal to last_visit[arr[i]]\n\n        if last_visit[arr[i]] != -1:\n\n            update(last_visit[arr[i]] + 1, -1, bit, n)\n\n\n\n        # Setting last_visit[arr[i]] as i and\n\n        # updating the bit array accordingly\n\n        last_visit[arr[i]] = i\n\n        update(i + 1, 1, bit, n)\n\n\n\n        # If i is equal to r of any query store answer\n\n        # for that query in ans[]\n\n        while query_counter < q and queries[query_counter].r == i:\n\n            ans[queries[query_counter].idx] = query(queries[query_counter].r + 1, bit, n) - query(\n\n                queries[query_counter].l, bit, n\n\n            )\n\n            query_counter += 1\n\n\n\n    # print answer for each query\n\n    for i in range(q):\n\n        print((ans[i]))\n\n\n\n\n\n# This code is contributed by\n\n# sanjeev2552\n\n\n\n\n\ndef main():\n\n    N, Q = list(map(int, readline().split()))\n\n    C = list(map(int, readline().split()))\n\n    (*LR,) = list(map(int, read().split()))\n\n\n\n    queries = [0] * Q\n\n    for i, (l, r) in enumerate(zip(*[iter(LR)] * 2)):\n\n        queries[i] = Query(l - 1, r - 1, i)\n\n\n\n    queries.sort(key=lambda x: x.r)\n\n    answeringQueries(C, N, queries, Q)\n\n\n\n    return\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n\n\n", "generated_code": "import sys\n\n\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\nreadlines = sys.stdin.readlines\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = 1 << 60\n\nMOD = 1000000007\n\n\n\n\n\nclass BIT:\n\n    def __init__(self, n):\n\n        self.n = n\n\n        self.data = [0] * (n + 1)\n\n\n\n    def add(self, i, x=1):\n\n        i += 1\n\n        while i <= self.n:\n\n            self.data[i] += x\n\n            i += i & -i\n\n\n\n    def get_sum(self, i):\n\n        i += 1\n\n        x = 0\n\n        while i > 0:\n\n            x += self.data[i]\n\n            i -= i & -i\n\n        return x\n\n\n\n    # Return sum for [l, r)\n\n    def get_sum_range(self, l, r):\n\n        return self.get_sum(r - 1) - self.get_sum(l - 1)\n\n\n\n\n\ndef main():\n\n    N, Q = map(int, readline().split())\n\n    C = list(map(int, readline().split()))\n\n    LR = map(int, read().split())\n\n\n\n    prev = [-1] * (N + 1)\n\n    ps = [[] for _ in range(N)]\n\n    for i, c in enumerate(C):\n\n        if prev[c] != -1:\n\n            ps[prev[c]].append(i)\n\n        prev[c] = i\n\n\n\n    qs = [[] for _ in range(N + 1)]\n\n    for i, (l, r) in enumerate(zip(*[iter(LR)] * 2)):\n\n        l -= 1\n\n        r -= 1\n\n        qs[l].append((r, i))\n\n\n\n    ans = [0] * Q\n\n    bit = BIT(N)\n\n\n\n    for l in range(N - 1, -1, -1):\n\n        for r in ps[l]:\n\n            bit.add(r)\n\n        for r, i in qs[l]:\n\n            ans[i] = (r - l + 1) - bit.get_sum(r)\n\n\n\n    print(*ans, sep='\\n')\n\n\n\n    return\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 1.0}
{"golden_code": "def popcount(x):\n\n  r = 0\n\n  while x:\n\n    if x & 1:\n\n      r += 1\n\n    x >>= 1\n\n  return r\n\n\n\nn = int(eval(input()))\n\nr = list(range(n))\n\na = [[0, 0] for _ in r]\n\nfor i in r:\n\n  for _ in range(int(eval(input()))):\n\n    x, y = list(map(int, input().split()))\n\n    a[i][y] |= 1 << (x - 1)\n\n\n\nm = 0\n\nl = (1 << n) - 1\n\nfor x in range(1, l + 1):\n\n  if all(a[i][0] & x == a[i][1] & l - x == 0 for i in r if x >> i & 1):\n\n    m = max(m, popcount(x))\n\nprint(m)\n", "generated_code": "from itertools import combinations\n\n \n\nn = int(eval(input()))\n\nr = list(range(n))\n\na = [(set(), set()) for _ in r]\n\nfor i in r:\n\n  for _ in range(int(eval(input()))):\n\n    x, y = list(map(int, input().split()))\n\n    a[i][y].add(x - 1)\n\n \n\nfail = lambda x: not all(a[i][0].isdisjoint(x) and a[i][1] < x for i in x)\n\n \n\nwhile all(map(fail, list(map(set, combinations(r, n))))):\n\n  n -= 1\n\nprint(n)", "score": 1.0}
{"golden_code": "N = int(eval(input()))\n\ncount = [[0 for _ in range(9)] for _ in range(9)]\n\nfor i in range(1, N + 1):\n\n    if str(i)[0] != \"0\" and str(i)[-1] != \"0\":\n\n        count[int(str(i)[0]) - 1][int(str(i)[-1]) - 1] += 1\n\nans = 0\n\nfor i in range(0, 9):\n\n    for k in range(0, 9):\n\n        ans += count[i][k] * count[k][i]\n\nprint(ans)", "generated_code": "N = int(eval(input()))\n\nnums = [0 for i in range(100)]\n\nfor i in range(1, N + 1):\n\n    i = str(i)\n\n    nums[int(i[0] + i[-1])] += 1\n\nans = 0\n\nfor i in range(1, 10):\n\n    for j in range(i, 10):\n\n        i = str(i)\n\n        j = str(j)\n\n        if i != j:\n\n            ans += nums[int(i + j)] * nums[int(j + i)] * 2\n\n        else:\n\n            n = nums[int(i + j)]\n\n            ans += n * (n - 1)\n\n            ans += n\n\nprint(ans)", "score": 1.0}
{"golden_code": "import numpy as np\n\n\n\nh, w = map(int, input().split())\n\nal = list(list(input()) for _ in range(h))\n\nal_n = np.array(al)\n\nrow = [0]*w\n\ncol = [0]*h\n\nfor i in range(h):\n\n    for j in range(w):\n\n        if al_n[i][j] == '.':\n\n            row[j] += 1\n\n            col[i] += 1\n\nrow_ = []\n\ncol_ = []\n\nfor i in range(w):\n\n    if row[i] == h:\n\n        row_.append(i)\n\n\n\nfor j in range(h):\n\n    if col[j] == w:\n\n        col_.append(j)\n\n\n\nif len(col_) > 0:\n\n    al_n = np.delete(al_n, col_, axis=0)\n\n\n\nif len(row_) > 0:\n\n    al_n = np.delete(al_n, row_, axis=1)\n\n\n\nfor a in al_n:\n\n    print(*a, sep='')\n", "generated_code": "h, w = map(int, input().split())\n\nal = list(list(input()) for _ in range(h))\n\nrow = [0]*w\n\ncol = [0]*h\n\n\n\nfor i in range(h):\n\n    for j in range(w):\n\n        if al[i][j] == '#':\n\n            col[i] += 1\n\n            row[j] += 1\n\nans = []\n\nw_len = len(row) - row.count(0)\n\nfor i in range(h):\n\n    tmp = ''\n\n    if col[i] != 0:\n\n        for j in range(w):\n\n            if row[j] != 0:\n\n                tmp += al[i][j]\n\n        ans.append(tmp)\n\n\n\nfor a in ans:\n\n    print(*a, sep='')\n", "score": 1.0}
{"golden_code": "import numpy as np\n\nN, K= list(map(int, input().split()))\n\nA=[int(i) for i in input().split()]\n\nF=[int(i) for i in input().split()]\n\n\n\nA=np.array(sorted(A, reverse=True))\n\nF=np.array(sorted(F))\n\n\n\nlower_bound=0\n\nupper_bound=np.max(A*F)\n\nK_tmp=0\n\n\n\nwhile upper_bound>=lower_bound:\n\n    mid=(lower_bound+upper_bound)//2\n\n    K_tmp=np.sum(np.maximum(A-mid//F, 0))\n\n    if K_tmp<=K:\n\n        upper_bound=mid-1\n\n    else:\n\n        lower_bound=mid+1\n\n\n\nprint(lower_bound)", "generated_code": "n,k=list(map(int,input().split()))\n\n*a,= list(map(int,input().split()))\n\n*f,= list(map(int,input().split()))\n\na=sorted(a)\n\nf=sorted(f, reverse=True)\n\n\n\ndef is_ok(arg):\n\n    cnt=0\n\n    for i in range(n):\n\n        cnt+=max(a[i]-arg//f[i], 0)\n\n    return cnt<=k\n\n\n\ndef meguru_bisect(ng, ok):\n\n    while (abs(ok - ng) > 1):\n\n        mid = (ok + ng) // 2\n\n        if is_ok(mid):\n\n            ok = mid\n\n        else:\n\n            ng = mid\n\n    return ok\n\n\n\nprint((meguru_bisect(-1, 10**12)))", "score": 1.0}
{"golden_code": "from scipy.sparse.csgraph import floyd_warshall\n\n\n\nn,m=list(map(int,input().split()))\n\nl=[list(map(int,input().split())) for i in range(m)]\n\n\n\nans=0\n\nfor i in range(m):\n\n    ll=l[:i]+l[i+1:]\n\n\n\n    d=[[float('inf')]*n for i in range(n)]\n\n    for i in range(n):\n\n        d[i][i]=0\n\n\n\n    for j in ll:\n\n        d[j[0]-1][j[1]-1]=1\n\n        d[j[1]-1][j[0]-1]=1\n\n\n\n    d=floyd_warshall(d)\n\n\n\n    if float('inf') in d:\n\n        ans+=1\n\n\n\nprint(ans)", "generated_code": "class UnionFind():\n\n    def __init__(self, n):\n\n        self.n = n\n\n        self.parents = [-1] * n\n\n\n\n    def find(self, x):\n\n        if self.parents[x] < 0:\n\n            return x\n\n        else:\n\n            self.parents[x] = self.find(self.parents[x])\n\n            return self.parents[x]\n\n\n\n    def union(self, x, y):\n\n        x = self.find(x)\n\n        y = self.find(y)\n\n\n\n        if x == y:\n\n            return\n\n\n\n        if self.parents[x] > self.parents[y]:\n\n            x, y = y, x\n\n\n\n        self.parents[x] += self.parents[y]\n\n        self.parents[y] = x\n\n\n\n    def roots(self):\n\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n\n\n    def group_count(self):\n\n        return len(self.roots())\n\n\n\nfrom copy import deepcopy\n\n\n\nn,m=list(map(int,input().split()))\n\nl=[list(map(int,input().split())) for i in range(m)]\n\n\n\ncnt=0\n\nfor i in range(m):\n\n  uf=UnionFind(n)\n\n  ll=deepcopy(l)\n\n  del ll[i]\n\n  for a,b in ll:\n\n    a-=1\n\n    b-=1\n\n    uf.union(a,b)\n\n  if uf.group_count()>=2:\n\n    cnt+=1\n\nprint(cnt)", "score": 1.0}
{"golden_code": "n,m=list(map(int,input().split()))\n\nc=[0]*(n+2)\n\nfor i in range(m):\n\n  l,r=list(map(int,input().split()))\n\n  c[l-1]+=1\n\n  c[r]-=1\n\nfor i in range(1,n+2):\n\n  c[i]=c[i]+c[i-1]\n\nans=0\n\nfor i in range(n+2):\n\n  if c[i]==m:\n\n    ans+=1\n\nprint(ans)", "generated_code": "n,m=list(map(int,input().split()))\n\nl,r=list(map(int,input().split()))\n\nfor i in range(m-1):\n\n  tl,tr=list(map(int,input().split()))\n\n  if l<tl:\n\n    l=tl\n\n  if tr<r:\n\n    r=tr\n\nprint((max(r-l+1,0)))", "score": 1.0}
{"golden_code": "import sys\n\nsys.setrecursionlimit(100000)\n\n\n\ndef intinput(): return list(map(int,sys.stdin.readline().split()))\n\n\n\nfib={0:0,1:1,2:1}\n\nfor i in range(3,100003):\n\n    fib[i]=fib[i-1]+fib[i-2]\n\n  #  fib.append(fib[i-1]+fib[i-2])\n\n\n\nn,m=intinput()\n\nmod=10**9+7\n\na=[int(sys.stdin.readline()) for _ in range(m)]\n\nif m!=0:\n\n    l=[a[0]]\n\n    for i in range(len(a)-1):\n\n        l.append(a[i+1]-a[i]-1)\n\n    l.append(n-a[-1])\n\n    k=1\n\n    for i in l:\n\n        k=fib[i]*k%mod\n\n    print((k%mod))\n\nelse:\n\n    print((fib[n+1]%mod))", "generated_code": "import sys\n\nsys.setrecursionlimit(100000)\n\n\n\ndef intinput(): return list(map(int,sys.stdin.readline().split()))\n\n\n\n\n\nn, m = intinput()\n\na = {int(sys.stdin.readline()) for _ in range(m)}\n\nmemo = [0 for x in range(n + 4)]\n\nmemo[0] = 1\n\nmod = 10 ** 9 + 7\n\nfor i in range(n):\n\n    if i + 1 not in a:\n\n        memo[i + 1] = (memo[i + 1] + memo[i]) % mod\n\n    if i + 2 not in a:\n\n        memo[i + 2] = (memo[i + 2] + memo[i]) % mod\n\nprint((memo[n]))", "score": 1.0}
{"golden_code": "from scipy.sparse.csgraph import csgraph_from_dense, floyd_warshall\n\n\n\nINF = float('inf')\n\n\n\ndef sol():\n\n    N, M = list(map(int, input().split()))\n\n\n\n    edges = []\n\n\n\n    for _ in range(M):\n\n        fr, to, cost = list(map(int, input().split()))\n\n        fr -= 1\n\n        to -= 1\n\n        edges.append((fr, to, cost))\n\n\n\n    graph = [[INF] * N for _ in range(N)]\n\n    for fr, to, cost in edges:\n\n        graph[fr][to] = cost\n\n\n\n    graph = csgraph_from_dense(graph, null_value=INF)\n\n\n\n    dist = floyd_warshall(graph, directed=False)\n\n    ans = (graph > dist).sum()\n\n    print(ans)\n\n\n\nsol()", "generated_code": "N, M = list(map(int, input().split()))\n\nINF = 10**18\n\n\n\nminDist = [[INF] * N for _ in range(N)]\n\nfor i in range(N):\n\n    minDist[i][i] = 0\n\n\n\nedges = []\n\nfor _ in range(M):\n\n    fr, to, d = list(map(int, input().split()))\n\n    fr -= 1\n\n    to -= 1\n\n    edges.append((fr, to, d))\n\n    minDist[fr][to] = d\n\n    minDist[to][fr] = d\n\n\n\nfor k in range(N):\n\n    for i in range(N):\n\n        for j in range(N):\n\n            d = minDist[i][k] + minDist[k][j]\n\n            if minDist[i][j] > d:\n\n                minDist[i][j] = d\n\n\n\nans = 0\n\nfor fr, to, d in edges:\n\n    if minDist[fr][to] < d:\n\n        ans += 1\n\nprint(ans)\n", "score": 1.0}
{"golden_code": "import numpy as np\n\nN_1=list(map(int, input().split()))\n\nN_2=list(map(int, input().split()))\n\nN_3=list(map(int, input().split()))\n\nN=int(eval(input()))\n\na=[int(eval(input())) for i in range(N)]\n\n\n\nn=np.array([N_1,N_2,N_3])\n\n\n\nfor a_n in a:\n\n    if a_n in n:\n\n        n[n==a_n]=0\n\n    else:\n\n        pass\n\ni=0\n\n    \n\nif np.all(n[0:,0]==0)==True:\n\n    i=+1\n\n    \n\nelif np.all(n[0:,1]==0)==True:\n\n    i+=1\n\n    \n\nelif np.all(n[0:,2]==0)==True:\n\n    i+=1\n\n    \n\nelif np.all(n[0,0:]==0)==True:\n\n    i+=1\n\n    \n\nelif np.all(n[1,0:]==0)==True:\n\n    i+=1\n\n\n\nelif np.all(n[2,0:]==0)==True:\n\n    i+=1\n\n\n\nelif n[0,0]==0 and n[1,1]==0  and n[2,2] ==0:\n\n    i+=1\n\n    \n\nelif n[0,2]==0 and n[1,1]==0 and n[2,0] ==0:\n\n    i+=1\n\n    \n\nif i>0:\n\n    print(\"Yes\")\n\nelse:\n\n    print(\"No\")", "generated_code": "a_1=list(map(int, input().split()))\n\na_2=list(map(int, input().split()))\n\na_3=list(map(int, input().split()))\n\n\n\nc=[a_1,a_2,a_3]\n\n\n\nN=int(eval(input()))\n\n\n\nb=[int(eval(input())) for _ in range(N)]\n\n\n\nfor i in range(3):\n\n    for j in range(3):\n\n        if c[i][j] in b:\n\n            c[i][j]=0\n\n            \n\n            \n\ni=0\n\nif c[0][0]==0 and c[0][1]==0 and c[0][2]==0:\n\n    i+=1\n\nif c[1][0]==0 and c[1][1]==0 and c[1][2]==0:\n\n    i+=1\n\nif c[2][0]==0 and c[2][1]==0 and c[2][2]==0:\n\n    i+=1\n\nif c[0][0]==0 and c[1][0]==0 and c[2][0]==0:\n\n    i+=1\n\nif c[0][1]==0 and c[1][1]==0 and c[2][1]==0:\n\n    i+=1\n\nif c[0][2]==0 and c[1][2]==0 and c[2][2]==0:\n\n    i+=1\n\nif c[0][0]==0 and c[1][1]==0 and c[2][2]==0:\n\n    i+=1\n\nif c[0][2]==0 and c[1][1]==0 and c[2][0]==0:\n\n    i+=1\n\n    \n\nif i>0:\n\n    print(\"Yes\")\n\nelse:\n\n  print(\"No\")", "score": 1.0}
{"golden_code": "import math\n\n\n\nN = int(eval(input()))\n\nans = math.factorial(N) % (10**9 + 7)\n\nprint(ans)", "generated_code": "N = int(eval(input()))\n\nmod = 10**9 + 7\n\nans = 1\n\nfor i in range(1, N + 1):\n\n    ans *= i\n\n    ans %= mod\n\nprint(ans)\n", "score": 1.0}
{"golden_code": "import sys\n\ninput = sys.stdin.readline\n\nsys.setrecursionlimit(10 ** 7)\n\n\n\nN = int(eval(input()))\n\nA = [int(i) for i in input().split()]\n\nB = [int(i) for i in input().split()]\n\nbefore = sum(A)\n\n\n\nfor i in range(N):\n\n    nokori = B[i]\n\n    for j in range(i,i+2):\n\n        if nokori >= A[j]:\n\n            nokori -= A[j]\n\n            A[j] = 0\n\n        else:\n\n            A[j] -= nokori\n\n            nokori = 0\n\nafter = sum(A)\n\n\n\nprint((before - after))", "generated_code": "N = int(eval(input()))\n\nA = [int(i) for i in input().split()]\n\nB = [int(i) for i in input().split()]\n\n\n\ncnt = 0\n\nfor i in range(N):\n\n    if B[i] >= A[i]:\n\n        cnt += A[i]\n\n        B[i] -= A[i]\n\n    else:\n\n        cnt += B[i]\n\n        B[i] = 0\n\n    if B[i] == 0:\n\n        continue\n\n    if B[i] >= A[i+1]:\n\n        cnt += A[i+1]\n\n        A[i+1] = 0\n\n    else:\n\n        cnt += B[i]\n\n        A[i+1] -= B[i]\n\n\n\nprint(cnt)", "score": 1.0}
{"golden_code": "import sys\n\ninput = sys.stdin.readline\n\nfrom collections import *\n\n\n\nK = int(eval(input()))\n\nA, B = list(map(int, input().split()))\n\n\n\nfor i in range(A, B+1):\n\n    if i%K==0:\n\n        print('OK')\n\n        exit()\n\n    \n\nprint('NG')", "generated_code": "K = int(eval(input()))\n\nA, B = list(map(int, input().split()))\n\n\n\nif (A-1)//K!=B//K:\n\n    print('OK')\n\nelse:\n\n    print('NG')", "score": 1.0}
{"golden_code": "import numpy as np\n\nimport math\n\n\n\ndef bigger_devisor(n):\n\n  s = np.sqrt(n)\n\n  i = math.ceil(s)\n\n  while(n % i != 0):\n\n    i += 1\n\n  return i\n\n\n\nn = int(eval(input()))\n\nif bigger_devisor(n) > 9:\n\n  print('No')\n\nelse:\n\n  print('Yes')", "generated_code": "n = int(eval(input()))\n\nans = 0\n\nfor i in range(1, 10):\n\n  if n % i == 0:\n\n    if n / i < 10:\n\n      ans = 1\n\nif ans == 0:\n\n  print('No')\n\nelse:\n\n  print('Yes')", "score": 1.0}
{"golden_code": "import sys\n\nreadline = sys.stdin.readline\n\nsys.setrecursionlimit(10**8)\n\nmod = 10**9+7\n\n#mod = 998244353\n\nINF = 10**18\n\neps = 10**-7\n\n\n\nm,n,k = list(map(int,readline().split()))\n\n\n\ndef comb(n, r, mod):\n\n    r = min(r, n-r)\n\n    mol = 1\n\n    deno = 1\n\n    for i in range(1, r+1):\n\n        mol = mol * (n-r+i) % mod\n\n        deno = deno * i % mod\n\n    ret = mol * pow(deno, mod-2, mod) % mod\n\n    return ret\n\n\n\ndef f1(x,y,a,b):\n\n    return (a+b-x-y)*(a-x+1)*(b-y+1)//2\n\n\n\ndef f2(x,a):\n\n    return (a-x)*(a-x+1)//2\n\n\n\nans = 0\n\n\n\nfor x in range(1,n+1):\n\n    for y in range(1,m+1):\n\n        ans += f1(x,y,n,m)+f1(1,1,x,y)+f1(1,y,x,m)+f1(x,1,n,y)\n\n        ans -= f2(x,n) + f2(1,x) + f2(1,y) + f2(y,m)\n\n        ans %= mod\n\n\n\nans = (ans * comb(m*n-2,k-2,mod))%mod\n\nans = ans*pow(2,mod-2,mod)%mod\n\n\n\nprint(ans)\n", "generated_code": "import sys\n\nreadline = sys.stdin.readline\n\nsys.setrecursionlimit(10**8)\n\nmod = 10**9+7\n\n#mod = 998244353\n\nINF = 10**18\n\neps = 10**-7\n\n\n\nm,n,k = list(map(int,readline().split()))\n\n\n\ndef comb(n, r, mod):\n\n    r = min(r, n-r)\n\n    mol = 1\n\n    deno = 1\n\n    for i in range(1, r+1):\n\n        mol = mol * (n-r+i) % mod\n\n        deno = deno * i % mod\n\n    ret = mol * pow(deno, mod-2, mod) % mod\n\n    return ret\n\n\n\ndef f1(x,y,a,b):\n\n    return (a+b-x-y)*(a-x+1)*(b-y+1)//2\n\n\n\ndef f2(x,a):\n\n    return (a-x)*(a-x+1)//2\n\n\n\nans = 0\n\n\n\nfor x in range(1,n+1):\n\n    for y in range(1,m+1):\n\n        a = n-x+1\n\n        b = m-y+1\n\n        c = m*(a*(a-1)+x*(x-1))\n\n        d = n*(b*(b-1)+y*(y-1))\n\n        ans += (c+d)//2\n\n        ans %= mod\n\n\n\nans = (ans * comb(m*n-2,k-2,mod))%mod\n\nans = ans*pow(2,mod-2,mod)%mod\n\n\n\nprint(ans)\n\n\n", "score": 1.0}
{"golden_code": "\n\nclass UnionFind:\n\n    def __init__(self, size):\n\n        self.table = [i for i in range(size)]\n\n\n\n    def find(self, x):\n\n        return self.table[x]\n\n\n\n    def union(self, x, y):\n\n        x1 = self.find(x)\n\n        y1 = self.find(y)\n\n\n\n        if x1 == y1:\n\n            return False\n\n\n\n        for i in range(len(self.table)):\n\n            if self.table[i] == y1:\n\n                self.table[i] = x1\n\n        return True\n\n\n\n\n\nN, M = list(map(int, input().split()))\n\n\n\nedges = []\n\nfor _ in range(M):\n\n    a, b = list(map(int, input().split()))\n\n    edges.append([a-1, b-1])\n\n\n\nmat = [[0]*N for _ in range(N)]\n\nfor s, g in edges:\n\n    mat[s][g] = 1\n\n    mat[g][s] = 1\n\n\n\nans = 0\n\n\n\nfor i in range(M):\n\n    uni = UnionFind(N)\n\n\n\n    for j in range(M):\n\n        if i != j:\n\n            uni.union(edges[j][0], edges[j][1])\n\n\n\n    if not all(uni.find(0) == uni.find(x) for x in range(N)):\n\n        ans += 1\n\nprint(ans)\n", "generated_code": "# python template for atcoder1\n\nimport sys\n\nsys.setrecursionlimit(10**9)\n\ninput = sys.stdin.readline\n\n\n\n\n\nclass UnionFind:\n\n    def __init__(self, size):\n\n        \"\"\"\n\n        size:頂点の数\n\n        \"\"\"\n\n        self.parent = [i for i in range(size)]\n\n        self.rank = [0 for _ in range(size)]\n\n\n\n    def find(self, x):\n\n        \"\"\"\n\n        xのrootを返す\n\n        \"\"\"\n\n        if self.parent[x] == x:\n\n            return x\n\n        else:\n\n            return self.find(self.parent[x])\n\n\n\n    def union(self, x, y):\n\n        \"\"\"\n\n        x,yを同じグループとしてまとめる\n\n        \"\"\"\n\n        x = self.find(x)\n\n        y = self.find(y)\n\n        if x == y:\n\n            return\n\n\n\n        if self.rank[x] < self.rank[y]:\n\n            self.parent[x] = y\n\n        else:\n\n            self.parent[y] = x\n\n            if self.rank[x] == self.rank[y]:\n\n                self.rank[x] += 1\n\n\n\n    def same(self, x, y):\n\n        \"\"\"\n\n        xとyが同じグループならTrue\n\n        \"\"\"\n\n        return self.find(x) == self.find(y)\n\n\n\n    def component(self):\n\n        \"\"\"\n\n        各連結成分のrootの集合を返す\n\n        len()をとれば連結成分の数が求められる\n\n        return-> set()\n\n        \"\"\"\n\n        comp = set()\n\n        for i in self.parent:\n\n            p = self.find(i)\n\n            comp.add(p)\n\n        return comp\n\n\n\n    def __str__(self):\n\n        \"\"\"\n\n        for debug\n\n        クラスのlistの情報を出力\n\n        \"\"\"\n\n        ret = \"parents\\n\"\n\n        ret += \" \".join(map(str, self.parent))\n\n        ret += '\\n'\n\n        ret += \" \".join(map(str, self.rank))\n\n        return ret\n\n\n\n\n\nN, M = list(map(int, input().split()))\n\nedges = []\n\n\n\nfor _ in range(M):\n\n    a, b = [int(x)-1 for x in input().split()]\n\n    edges.append([a, b])\n\n\n\nans = 0\n\nfor e in edges:\n\n    Un = UnionFind(N)\n\n    for g in edges:\n\n        if e == g:\n\n            continue\n\n        else:\n\n            Un.union(g[0], g[1])\n\n    if not Un.same(e[0], e[1]):\n\n        ans += 1\n\nprint(ans)\n", "score": 1.0}
{"golden_code": "N,X = list(map(int,input().split()))\n\nL = [0] + [int(x) for x in input().split()]\n\n\n\nD = [0] * (N+2)\n\nanswer = 1\n\nfor n in range(2,N+2):\n\n  D[n] = D[n-1] + L[n-1]\n\n  if D[n] <= X:\n\n    answer += 1\n\n    \n\nprint(answer)", "generated_code": "import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\nimport itertools\n\n\n\nN,X,*L = list(map(int,read().split()))\n\n\n\nanswer = sum(x <= X for x in itertools.accumulate([0]+L))\n\nprint(answer)", "score": 1.0}
{"golden_code": "N = int(eval(input()))\n\nx = list(map(int, input().split()))\n\ncnt = 0\n\nfor i in x:\n\n  while i % 2 == 0:\n\n    cnt += 1\n\n    i /= 2\n\nprint(cnt)", "generated_code": "n = int(eval(input()))\n\nans = 0\n\nfor i in map(int, input().split()):\n\n    cnt = 0\n\n    while i % 2 == 0:\n\n        i >>= 1\n\n        cnt += 1\n\n    ans += cnt\n\nprint(ans)", "score": 1.0}
{"golden_code": "import math\n\nn = int(eval(input()))\n\n\n\nans = math.factorial(n)  # nの階乗を計算\n\n\n\nif ans >= (10 ** 9)+7:\n\n    ans = ans % ((10 ** 9)+7)\n\n\n\nprint(ans)\n", "generated_code": "n = int(eval(input()))\n\n\n\nans = 1\n\nfor i in range(1, n+1):\n\n    ans = ans * i\n\n    ans = ans % ((10 ** 9)+7)  # 途中で割り算の余りを求めても、最終結果は同じになる\n\n\n\nprint(ans)", "score": 1.0}
{"golden_code": "import statistics\n\nN = int(eval(input()))\n\na = [int(i) for i in input().split()]\n\nans = 0\n\n\n\nfor i in range(1,N+1):\n\n  a[i-1] -= i\n\n\n\nb = statistics.median(a)\n\nfor i in range(N):\n\n  ans += abs(a[i]-b)\n\nprint((int(ans)))", "generated_code": "N = int(eval(input()))\n\nA = [int(i) for i in input().split()]\n\nC = [A[i]-i for i in range(N)]\n\nC.sort()\n\nans = 0\n\nmed = C[N//2]\n\nfor i in range(N):\n\n  ans += abs(C[i]-med)\n\nprint(ans)", "score": 1.0}
{"golden_code": "print((eval(input())))", "generated_code": "print(eval(input()))", "score": 1.0}
{"golden_code": "import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\nimport numpy as np\n\n\n\nN = int(readline())\n\nS = np.array(read().split(),np.int64)\n\n\n\ndef F(d):\n\n    # 公差を固定\n\n    L = S[:-d:d].cumsum()\n\n    R = S[::-1][:-d:d].cumsum()\n\n    if (N-1)%d == 0:\n\n        n = (N-1)//d\n\n        x = np.arange(1,n+1)\n\n        bl = (x+x <= n+1)\n\n        L = L[bl]; R = R[bl]\n\n    return (L+R).max()\n\n\n\ndef G(n):\n\n    # 項数n+1を固定\n\n    D = (N-1-n)//n\n\n    L = np.zeros(D+1,np.int64)\n\n    R = np.zeros(D+1,np.int64)\n\n    for i in range(1,n+1):\n\n        L += S[:i*(D+1):i]\n\n        R += S[::-1][:i*(D+1):i]\n\n    ok = np.ones(D+1,np.bool)\n\n    overlap = (np.arange(D+1) * (n+n) >= N-1)\n\n    overlap[1:] &= ((N-1)%np.arange(1,D+1) == 0)\n\n    x = L+R\n\n    x[overlap] = 0\n\n    return x.max()\n\n\n\nL = int((N-1)**.5 + 10)\n\nL = min(N-1,L)\n\n\n\nx = max(F(n) for n in range(1,L+1))\n\ny = max(G(n) for n in range(1,L+1))\n\nanswer = max(x,y)\n\nprint(answer)", "generated_code": "import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\nimport itertools\n\n\n\nN = int(readline())\n\nS = list(map(int,read().split()))\n\n\n\nanswer = 0\n\nfor d in range(1,N):\n\n    n = (N-1)//d\n\n    if (N-1)%d == 0:\n\n        n = ((N-1)//d+1)//2\n\n    if n <= 1:\n\n        continue\n\n    x = max(itertools.accumulate(x+y for x,y in zip(S[d:d*n:d],S[N-1-d:N-1-d*n:-d])))\n\n    if answer < x:\n\n        answer = x\n\n\n\nprint(answer)", "score": 1.0}
{"golden_code": "N = int(eval(input()))\n\ns_list = {}\n\nfor i in range(N):\n\n  S = eval(input())\n\n  if S in list(s_list.keys()):\n\n    s_list[S] += 1\n\n  else:\n\n    s_list[S] = 0\n\nmax = 0\n\nmaxs = []\n\nfor s,c in list(s_list.items()):\n\n  if c > max:\n\n    maxs = [s]\n\n    max = c\n\n  elif c == max:\n\n    maxs.append(s)\n\nmaxs.sort()\n\nfor m in maxs:\n\n  print(m)", "generated_code": "from collections import Counter\n\ndef solve():\n\n  N = int(input())\n\n  S = [input() for _ in range(N)]\n\n  c = Counter(S)\n\n  M = max(c.values())\n\n  ans = []\n\n  for k,v in c.items():\n\n    if v==M:\n\n      ans.append(k)\n\n  ans.sort()\n\n  return ans\n\nprint(*solve(),sep='\\n')\n", "score": 1.0}
{"golden_code": "# ABC 120 C\n\n\n\nimport re\n\n\n\nS = eval(input())\n\n\n\nl0 = 0\n\nl1 = 0\n\n\n\nfor i in range(len(S)):\n\n    if S[i] == '0':\n\n        l0 += 1\n\n    elif S[i] == '1':\n\n        l1 += 1\n\n\n\nprint((min(l0, l1) * 2))\n", "generated_code": "def resolve():\n\n  S = eval(input())\n\n  arr = []\n\n  for s in S:\n\n    if len(arr) != 0 and arr[-1] != s:\n\n      arr.pop()\n\n    else:\n\n      arr.append(s)\n\n\n\n  print((len(S) - len(arr)))\n\n  return\n\n\n\nif __name__ == \"__main__\":\n\n  resolve()\n", "score": 1.0}
{"golden_code": "from scipy.sparse.csgraph import floyd_warshall\n\nimport numpy as np\n\nimport sys\n\n\n\ninput = sys.stdin.readline\n\n\n\nN, M = list(map(int, input().split()))\n\nAB = []\n\nedge = np.zeros((N, N), dtype=int)\n\nfor _ in range(M):\n\n    a, b = list(map(int, input().split()))\n\n    a -= 1\n\n    b -= 1\n\n    AB.append((a, b))\n\n    edge[a][b] = 1\n\n    edge[b][a] = 1\n\n\n\nans = 0\n\nfor i in range(M):\n\n    graph = np.copy(edge)\n\n    a, b = AB[i]\n\n    graph[a][b] = 0\n\n    graph[b][a] = 0\n\n    fw = floyd_warshall(graph)\n\n    if fw.max() > 10000:\n\n        ans += 1\n\n\n\nprint(ans)\n", "generated_code": "import sys\n\ninput = sys.stdin.buffer.readline\n\nsys.setrecursionlimit(10 ** 7)\n\n\n\n\n\nclass UF_tree:\n\n    def __init__(self, n):\n\n        self.root = [-1] * (n + 1)  # -1ならそのノードが根,で絶対値が木の要素数\n\n        self.rank = [0] * (n + 1)\n\n\n\n    def find(self, x):  # xの根となる要素番号を返す\n\n        if self.root[x] < 0:\n\n            return x\n\n        else:\n\n            self.root[x] = self.find(self.root[x])\n\n            return self.root[x]\n\n\n\n    def isSame(self, x, y):\n\n        return self.find(x) == self.find(y)\n\n\n\n    def unite(self, x, y):\n\n        x = self.find(x)\n\n        y = self.find(y)\n\n        if x == y:\n\n            return\n\n        elif self.rank[x] < self.rank[y]:\n\n            self.root[y] += self.root[x]\n\n            self.root[x] = y\n\n        else:\n\n            self.root[x] += self.root[y]\n\n            self.root[y] = x\n\n            if self.rank[x] == self.rank[y]:\n\n                self.rank[x] += 1\n\n\n\n    def getNodeLen(self, x):\n\n        return -self.root[self.find(x)]\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    N, M = list(map(int, input().split()))\n\n    AB = tuple(tuple(map(int, input().split())) for _ in range(M))\n\n\n\n    ans = 0\n\n    for i in range(M):\n\n        uf = UF_tree(N)\n\n        for j, (a, b) in enumerate(AB):\n\n            if i == j:\n\n                continue\n\n            uf.unite(a, b)\n\n        a, b = AB[i]\n\n        if not uf.isSame(a, b):\n\n            ans += 1\n\n    print(ans)", "score": 1.0}
{"golden_code": "def main():\n\n    S = eval(input())\n\n    w1 = 'dream'[::-1]\n\n    w2 = 'dreamer'[::-1]\n\n    w3 = 'erase'[::-1]\n\n    w4 = 'eraser'[::-1]\n\n    # print(w1,w2,w3,w4)\n\n    S = S[::-1]\n\n    # print(S)\n\n\n\n    # words = ['dream', 'dreamer', 'erase', 'eraser']\n\n    words = [w1, w2, w3, w4]\n\n    T = ''\n\n    while S != T:\n\n        cand = []\n\n        for w in words:\n\n            new_t = T + w\n\n            cand.append(new_t) \n\n        # print('cand', cand)\n\n        ans = False\n\n        for c in cand:\n\n            if c == S[:len(c)]:\n\n                T = c\n\n                ans = True\n\n\n\n        if not ans:\n\n            break\n\n\n\n    if S == T:\n\n        print('YES')\n\n    else:\n\n        print(\"NO\")\n\n\n\nif __name__ == \"__main__\":\n\n    main()", "generated_code": "def main():\n\n    S = eval(input())\n\n    w1 = 'dream'[::-1]\n\n    w2 = 'dreamer'[::-1]\n\n    w3 = 'erase'[::-1]\n\n    w4 = 'eraser'[::-1]\n\n    S = S[::-1]\n\n    words = [w1, w2, w3, w4]\n\n\n\n    flag = False\n\n    i = 0\n\n    while i < len(S):\n\n        for w in words:\n\n            if S[i:].startswith(w):\n\n                i += len(w)\n\n                flag = True\n\n                break\n\n\n\n        if not flag:\n\n            print(\"NO\")\n\n            exit()\n\n        flag = False\n\n\n\n    print(\"YES\")\n\n\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()", "score": 1.0}
{"golden_code": "import math\n\nN = int(eval(input()))\n\np = math.factorial(N)\n\nprint((p % 1000000007))", "generated_code": "N = int(eval(input()))\n\np = 1\n\nfor i in range(1,N+1):\n\n    p *= i\n\n    p %= 1000000007\n\nprint(p)\n", "score": 1.0}
{"golden_code": "S, T = input().split()\n\nA, B= list(map(int, input().split()))\n\nU = eval(input())\n\nif S == U:\n\n    print((A - 1, B))\n\nelse:\n\n    print((A, B - 1))", "generated_code": "S, T = input().split()\n\nA, B= list(map(int, input().split()))\n\nU = eval(input())\n\nif S == U:\n\n    A-=1\n\nelse:\n\n    B-=1\n\nprint((A,B))", "score": 1.0}
{"golden_code": "n=int(eval(input()))\n\na=[list(map(int,input().split()))for _ in range(n)]\n\ndef f():\n\n for i in range(n-1):\n\n  d=a[i][:];d[3],d[4]=d[4],d[3]\n\n  for j in range(i+1,n):\n\n   e=a[j][:];e[3],e[4]=e[4],e[3]\n\n   for p in('012345','152043','215304','302541','410352','514320'):\n\n    f=[d[int(k)]for k in p]\n\n    g=f[1:5]*2\n\n    for k in range(4):\n\n     if(g[k:k+4]==e[1:5])*(f[0]==e[0])*(f[5]==e[5]):return 'No'\n\n return 'Yes'\n\nprint((f()))\n", "generated_code": "n=int(eval(input()))\n\na=[list(map(int,input().split()))for _ in range(n)]\n\ndef f():\n\n for i in range(n-1):\n\n  d=a[i][:];d[3],d[4]=d[4],d[3]\n\n  for j in range(i+1,n):\n\n   e=a[j][:];e[3],e[4]=e[4],e[3]\n\n   for p in('012345','152043','215304','302541','410352','514320'):\n\n    f=[d[int(k)]for k in p]\n\n    g=f[1:5]*2\n\n    for k in range(4):\n\n     if g[k:k+4]==e[1:5]:\n\n      if f[0]==e[0]:\n\n       if f[5]==e[5]:return 'No'\n\n return 'Yes'\n\nprint((f()))\n", "score": 1.0}
{"golden_code": "def main():\n\n  n = int(eval(input()))\n\n  \n\n  dp = [0]*(n+1)\n\n  dp[0] = 1\n\n  mod = pow(10, 9) + 7\n\n  for i in range(n+1):\n\n    for j in range(i-2):\n\n      dp[i] += dp[j]\n\n      dp[i] %= mod\n\n  \n\n  print((dp[n]))\n\n\n\nif __name__ == \"__main__\":\n\n  main()", "generated_code": "def main():\n\n  n = int(eval(input()))\n\n  \n\n  dp = [0]*(n+1)\n\n  dp[0] = 1\n\n  mod = pow(10, 9) + 7\n\n  for i in range(3, n+1):\n\n    dp[i] = dp[i-1] + dp[i-3]\n\n    dp[i] %= mod\n\n  \n\n  print((dp[n]))\n\n\n\nif __name__ == \"__main__\":\n\n  main()", "score": 1.0}
{"golden_code": "import numpy as np\n\n\n\nn,l=list(map(int,input().split()))\n\nli=[]\n\nfor i in range(n):\n\n  li.append(l+i)\n\ns=sum(li)\n\np=np.array(li)\n\na=np.abs(p).tolist()\n\nk=min(a)\n\nb=a.index(k)\n\nprint((s-li[b]))", "generated_code": "n,l=list(map(int,input().split()))\n\na=0\n\nfor i in range(n):\n\n  a+=i+l\n\nif l>=0:\n\n  print((a-l))\n\nelif l+n-1<0:\n\n  print((a-(l+n-1)))\n\nelse:\n\n  print(a)", "score": 1.0}
{"golden_code": "import sys\n\ninput = sys.stdin.readline\n\nread = sys.stdin.read\n\n\n\nn = int(eval(input()))\n\nA = list(map(int, read().split()))\n\nL = sorted([(j, i) for i, j in enumerate(A)])\n\ncount = 0\n\nfor i in range(n):\n\n  if (L[i][1]-i)%2:\n\n    count += 1\n\nans = (count+1) // 2\n\nprint(ans)", "generated_code": "import sys\n\ninput = sys.stdin.readline\n\nread = sys.stdin.read\n\n\n\nn = int(eval(input()))\n\nA = list(map(int, read().split()))\n\nL = sorted([(j, i) for i, j in enumerate(A)])\n\ncount = 0\n\nfor i in range(n):\n\n  count += (L[i][1]-i)%2\n\nans = (count+1) // 2\n\nprint(ans)\n", "score": 1.0}
{"golden_code": "# Problem https://atcoder.jp/contests/abc053/tasks/abc053_b\n\n# Python 1st Try\n\nimport copy\n\n\n\n\n\nclass Problem:\n\n    def __init__(self, stringdata):\n\n        self.stringdata = stringdata\n\n\n\n    def solver(self):\n\n        strcont = copy.copy(self.stringdata)\n\n        result = 0\n\n        rightposition = 0\n\n        leftposition = len(strcont)\n\n        j = 0\n\n        while True:\n\n            if strcont[j] == 'A':\n\n                rightposition = j\n\n                break\n\n            else:\n\n                j = j + 1\n\n        j = leftposition - 1\n\n        while True:\n\n            if strcont[j] == 'Z':\n\n                leftposition = j\n\n                break\n\n            else:\n\n                j = j - 1\n\n\n\n        result = leftposition - rightposition + 1\n\n        return result\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    s = eval(input())\n\n    print((\"{}\".format(Problem(s).solver())))\n", "generated_code": "# Problem https://atcoder.jp/contests/abc053/tasks/abc053_b\n\n# Python 2nd Try\n\n\n\n\n\ndef solver(string):\n\n    result = 200000\n\n    aposi = 0\n\n    zposi = len(string)\n\n    for j in range(0, len(string), 1):\n\n        if string[j] == 'A':\n\n            aposi = j\n\n            break\n\n    for j in range(len(string)-1, -1, -1):\n\n        if string[j] == 'Z':\n\n            zposi = j\n\n            break\n\n    result = zposi - aposi + 1\n\n    return result\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    s = eval(input())\n\n    print(('{}'.format(solver(s))))\n", "score": 1.0}
{"golden_code": "n, m = list(map(int, input().split()))\n\ndp = [0] * n\n\nfor i in range(m):\n\n    x, y = list(map(int, input().split()))\n\n    dp[x - 1] += 1\n\n    dp[y - 1] += 1\n\nfor i in range(n):\n\n    print((dp[i]))", "generated_code": "n, m = list(map(int, input().split()))\n\nA = [0] * n\n\nfor i in range(m):\n\n    a, b = list(map(int, input().split()))\n\n    A[a - 1] += 1\n\n    A[b - 1] += 1\n\n    \n\nfor i in range(n):\n\n    print((A[i]))", "score": 1.0}
{"golden_code": "mod = 998244353\n\nN = int(eval(input()))\n\nX = []\n\nfor _ in range(N):\n\n    x, d = list(map(int, input().split()))\n\n    X.append((x, x + d))\n\n\n\nX = sorted(X, key = lambda x: x[0])\n\nL = [(0, -(10**9+1), 10**9+1)]\n\nP = [-1] * (N+1)\n\nfor i, (x, y) in enumerate(X):\n\n    while L[-1][2] <= y:\n\n        if L[-1][2] > x and P[i+1] < 0:\n\n            P[i+1] = L[-1][0]\n\n        L.pop()\n\n    if P[i+1] < 0:\n\n        P[i+1] = L[-1][0]\n\n    L.append((i+1, x, y))\n\n\n\nC = [[] for _ in range(N+1)]\n\nfor i, p in enumerate(P):\n\n    if p >= 0:\n\n        C[p].append(i)\n\n\n\nY = [1] * (N+1)\n\nfor i in range(N+1)[::-1]:\n\n    s = 1\n\n    for j in C[i]:\n\n        s = s * (Y[j] + 1) % mod\n\n    Y[i] = s\n\n\n\nprint((Y[0]))", "generated_code": "import sys\n\ninput = sys.stdin.readline\n\n\n\nmod = 998244353\n\nN = int(eval(input()))\n\nX = []\n\nfor _ in range(N):\n\n    x, d = list(map(int, input().split()))\n\n    X.append((x, x + d))\n\n\n\nX = sorted(X, key = lambda x: x[0])\n\nL = [(0, -(10**9+1), 10**9+1)]\n\nP = [-1] * (N+1)\n\nfor i, (x, y) in enumerate(X):\n\n    while L[-1][2] <= y:\n\n        if L[-1][2] > x and P[i+1] < 0:\n\n            P[i+1] = L[-1][0]\n\n        L.pop()\n\n    if P[i+1] < 0:\n\n        P[i+1] = L[-1][0]\n\n    L.append((i+1, x, y))\n\n\n\nC = [[] for _ in range(N+1)]\n\nfor i, p in enumerate(P):\n\n    if p >= 0:\n\n        C[p].append(i)\n\n\n\nY = [1] * (N+1)\n\nfor i in range(N+1)[::-1]:\n\n    s = 1\n\n    for j in C[i]:\n\n        s = s * (Y[j] + 1) % mod\n\n    Y[i] = s\n\n\n\nprint((Y[0]))", "score": 1.0}
{"golden_code": "n = int(eval(input()))\n\n\n\nfelicidade = []\n\n\n\nfor x in range(n):\n\n    felicidade.append(list(map(int,input().split())))\n\n\n\nDP = [0,0,0]\n\n\n\nif n == 1:\n\n    print((max(felicidade[0])))\n\n\n\nelse:\n\n\n\n    for x in range(3):\n\n        DP[x] = felicidade[0][x]\n\n\n\n\n\n    for dia in range(1,n):\n\n        m = [0] * 3\n\n        for x  in range(3):#As duas possíveis escolhas são x e y\n\n            for y  in range(3):\n\n                if x != y: #Se elas forem diferentes\n\n                    m[x] = max(m[x], DP[y] + felicidade[dia][x])\n\n        DP = m\n\n    \n\n    print((max(DP)))\n", "generated_code": "nDays = int(eval(input()))\n\n\n\ntoday = [int(x) for x in input().split()]\n\n\n\nfor i in range(nDays - 1):\n\n    tomorrow = [int(x) for x in input().split()]\n\n    tomorrow[0] += max(today[1], today[2])\n\n    tomorrow[1] += max(today[0], today[2])\n\n    tomorrow[2] += max(today[0], today[1])\n\n    today = tomorrow\n\n\n\nprint((max(today)))", "score": 1.0}
{"golden_code": "n,m=list(map(int,input().split()))\n\na=[int(x) for x in input().split()]\n\nb=[0 for x in range(n+1)]\n\nl=list([0])\n\n\n\nfor i in range(1,n+1):\n\n  b[i]=b[i-1]+a[i-1]\n\n\n\nfor i in range(1,n+1):\n\n  l.append(b[i]%m)\n\n\n\nd=list()\n\nl.sort()\n\nt,c=0,1\n\nfor i in range(1,n+1):\n\n  if l[i]==l[i-1]:\n\n    c+=1\n\n  else:\n\n    if c!=1:\n\n      t += c*(c-1)//2\n\n      c=1\n\n\n\nif c!=1:\n\n  t += c*(c-1)//2  \n\n\n\nprint(t)\n", "generated_code": "n,m=list(map(int,input().split()))\n\na=[int(x) for x in input().split()]\n\nl=list([0])\n\n\n\nb=0\n\nfor i in range(0,n):\n\n  b += a[i]\n\n  l.append(b%m)\n\nl.append(m)\n\n\n\nl.sort()\n\nt,c=0,1\n\nfor i in range(1,n+2):\n\n  if l[i]==l[i-1]:\n\n    c+=1\n\n  else:\n\n    if c!=1:\n\n      t += c*(c-1)//2\n\n      c=1\n\nprint(t)\n", "score": 1.0}
{"golden_code": "# C - Walk on Multiplication Table\n\n# https://atcoder.jp/contests/abc144/tasks/abc144_c\n\n\n\nn = int(eval(input()))\n\n\n\nans = 10 ** 12\n\nfor i in range(1, 10 ** 6 + 1):\n\n  if n % i == 0:\n\n    ans = min(ans, n // i + i)\n\n\n\nprint((ans - 2))", "generated_code": "# C - Walk on Multiplication Table\n\n# https://atcoder.jp/contests/abc144/tasks/abc144_c\n\n\n\nn = int(eval(input()))\n\n\n\nans = n\n\nfor i in range(1, int(n**.5) + 2):\n\n  if n % i == 0:\n\n    ans = min(ans, n // i + i - 2)\n\n\n\nprint(ans)", "score": 1.0}
{"golden_code": "n, m, k = list(map(int, input().split()))\n\nmod = 10 ** 9 + 7\n\nMAX = n * m\n\n\n\n\n\nclass ModInt:\n\n    def __init__(self, num):\n\n        self.num = num\n\n\n\n    def __str__(self):\n\n        return str(self.num)\n\n\n\n    def __repr__(self):\n\n        return \"ModInt(num: {}, mod: {}\".format(self.num, mod)\n\n\n\n    def __add__(self, other):\n\n        ret = self.num + other.num\n\n        ret %= mod\n\n        return ModInt(ret)\n\n\n\n    def __sub__(self, other):\n\n        ret = self.num - other.num\n\n        ret %= mod\n\n        return ModInt(ret)\n\n\n\n    def __mul__(self, other):\n\n        ret = self.num * other.num\n\n        ret %= mod\n\n        return ModInt(ret)\n\n\n\n    def pow(self, times):\n\n        pw = pow(self.num, times, mod)\n\n        return ModInt(pw)\n\n\n\n    def inverse(self):\n\n        return ModInt(inv[self.num])\n\n\n\n    def __truediv__(self, other):\n\n        num = self * other.inverse()\n\n        return ModInt(num)\n\n\n\n\n\ndef comb(n, k):\n\n    return fact[n] * inv[n-k] * inv[k]\n\n\n\n\n\nfact = [None] * (MAX + 1)\n\nfact[0] = ModInt(1)\n\nfor i in range(1, MAX + 1):\n\n    fact[i] = fact[i-1] * ModInt(i)\n\n\n\ninv = [None] * (MAX + 1)\n\ninv[MAX] = fact[MAX].pow(mod - 2)\n\nfor i in range(MAX, 0, -1):\n\n    inv[i-1] = inv[i] * ModInt(i)\n\n\n\nans = ModInt(0)\n\nfor i in range(n):\n\n    for j in range(m):\n\n        add = ModInt(n - i) * ModInt(m - j) * ModInt(i + j)\n\n        if i != 0 and j != 0:\n\n            add *= ModInt(2)\n\n\n\n        ans += add\n\n\n\nans *= comb(n * m - 2, k - 2)\n\nprint(ans)\n", "generated_code": "n, m, k = list(map(int, input().split()))\n\n\n\nmod = 10 ** 9 + 7\n\nMAX = n * m\n\n\n\nfact = [1] * (MAX + 1)\n\nfor i in range(1, MAX + 1):\n\n    fact[i] = (fact[i-1] * i) % mod\n\n\n\ninv = [1] * (MAX + 1)\n\ninv[MAX] = pow(fact[MAX], mod - 2, mod)\n\nfor i in range(MAX, 0, -1):\n\n    inv[i-1] = (inv[i] * i) % mod\n\n\n\n\n\ndef comb(n, k):\n\n    return fact[n] * inv[n-k] * inv[k] % mod\n\n\n\n\n\nans = 0\n\nfor i in range(n):\n\n    for j in range(m):\n\n        add = (n - i) * (m - j) * (i + j) % mod\n\n        if i != 0 and j != 0:\n\n            add *= 2\n\n            add %= mod\n\n\n\n        ans += add\n\n        ans %= mod\n\n\n\nans *= comb(MAX - 2, k - 2)\n\nans %= mod\n\nprint(ans)\n", "score": 1.0}
{"golden_code": "import numpy as np\n\n\n\nn = int(eval(input()))\n\na = np.array(list(map(int,input().split())))\n\n\n\ncount = 0\n\nwhile np.all(a%2==0):\n\n    count+=1\n\n    a=a/2\n\nprint(count)\n", "generated_code": "N=int(eval(input()))\n\na = [int(i) for i in input().split()]\n\n\n\ncount=0\n\nwhile 1:\n\n    if sum([i%2 for i in a]) == 0:\n\n        a = [i/2 for i in a]\n\n        count=count+1\n\n    else:\n\n        print(count)\n\n        break\n", "score": 1.0}
{"golden_code": "a,b = list(map(int, input().split()))\n\ncount = 0\n\nfor i in range(a,b+1):\n\n    j = str(i)\n\n    if j==''.join(reversed(j)):\n\n        count += 1\n\nprint(count)", "generated_code": "a,b = list(map(int, input().split()))\n\nn = [i for i in map(str, list(range(a,b+1))) if i==i[::-1]]\n\nprint((len(n)))", "score": 1.0}
{"golden_code": "import sys\n\nread = sys.stdin.readline\n\n\n\n\n\ndef read_ints():\n\n    return list(map(int, read().split()))\n\n\n\n\n\ndef read_a_int():\n\n    return int(read())\n\n\n\n\n\ndef read_matrix(H):\n\n    '''\n\n    H is number of rows\n\n    '''\n\n    return [list(map(int, read().split())) for _ in range(H)]\n\n\n\n\n\ndef read_map(H):\n\n    '''\n\n    H is number of rows\n\n    文字列で与えられた盤面を読み取る用\n\n    '''\n\n    return [read()[:-1] for _ in range(H)]\n\n\n\n\n\ndef read_tuple(H):\n\n    '''\n\n    H is number of rows\n\n    '''\n\n    ret = []\n\n    for _ in range(H):\n\n        ret.append(tuple(map(int, read().split())))\n\n    return ret\n\n\n\n\n\ndef read_col(H, n_cols):\n\n    '''\n\n    H is number of rows\n\n    n_cols is number of cols\n\n\n\n    A列、B列が与えられるようなとき\n\n    '''\n\n    ret = [[] for _ in range(n_cols)]\n\n    for _ in range(H):\n\n        tmp = list(map(int, read().split()))\n\n        for col in range(n_cols):\n\n            ret[col].append(tmp[col])\n\n\n\n    return ret\n\n\n\n\n\nN, K = read_ints()\n\nP = read_ints()\n\n\n\n\n\ndef ret_mean(X):\n\n    return (X + 1) / 2\n\n\n\n\n\n\n\n\n\nimport numpy as np\n\nP_mean = np.array([ret_mean(p) for p in P])\n\nP_accum = np.zeros(N+1)\n\nP_accum[1:] = P_mean.cumsum()\n\n\n\nans = 0\n\n# print(P_accum)\n\nfor i in range(N - K + 1):\n\n    j = i + K\n\n    ans = max(ans, P_accum[j] - P_accum[i])\n\nprint(ans)\n", "generated_code": "import sys\n\nread = sys.stdin.readline\n\n\n\n\n\ndef read_ints():\n\n    return list(map(int, read().split()))\n\n\n\n\n\ndef read_a_int():\n\n    return int(read())\n\n\n\n\n\ndef read_matrix(H):\n\n    '''\n\n    H is number of rows\n\n    '''\n\n    return [list(map(int, read().split())) for _ in range(H)]\n\n\n\n\n\ndef read_map(H):\n\n    '''\n\n    H is number of rows\n\n    文字列で与えられた盤面を読み取る用\n\n    '''\n\n    return [read()[:-1] for _ in range(H)]\n\n\n\n\n\ndef read_tuple(H):\n\n    '''\n\n    H is number of rows\n\n    '''\n\n    ret = []\n\n    for _ in range(H):\n\n        ret.append(tuple(map(int, read().split())))\n\n    return ret\n\n\n\n\n\ndef read_col(H, n_cols):\n\n    '''\n\n    H is number of rows\n\n    n_cols is number of cols\n\n\n\n    A列、B列が与えられるようなとき\n\n    '''\n\n    ret = [[] for _ in range(n_cols)]\n\n    for _ in range(H):\n\n        tmp = list(map(int, read().split()))\n\n        for col in range(n_cols):\n\n            ret[col].append(tmp[col])\n\n\n\n    return ret\n\n\n\n\n\nN, K = read_ints()\n\nP = read_ints()\n\n\n\n\n\ndef ret_mean(X):\n\n    return (X + 1) / 2\n\n\n\n\n\n\n\nclass cumsum1d:\n\n    def __init__(self, ls: list):\n\n        '''\n\n        1次元リストを受け取る\n\n        '''\n\n        from itertools import accumulate\n\n        self.ls_accum = [0] + list(accumulate(ls))\n\n\n\n    def total(self, i, j):\n\n        # もとの配列lsにおける[i,j)の中合計\n\n        return self.ls_accum[j] - self.ls_accum[i]\n\n      \n\nP_mean = [ret_mean(p) for p in P]\n\nP_accum = cumsum1d(P_mean)\n\n\n\nans = 0\n\n# print(P_accum)\n\nfor i in range(N - K + 1):\n\n    j = i + K\n\n    ans = max(ans, P_accum.total(i,j))\n\nprint(ans)\n", "score": 1.0}
{"golden_code": "import numpy as np\n\nk,n = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\nb = np.zeros(n)\n\nfor i in range(0,n-1):\n\n  b[i] = a[i+1] -a[i]\n\n  \n\nb[n-1] = k - a[n-1] + a[0]\n\nans = k - max(b)\n\nprint((int(ans)))", "generated_code": "k,n = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\nb = [0 for i in range(n)]\n\nfor i in range(0,n-1):\n\n  b[i] = a[i+1] -a[i]\n\n\n\nb[n-1] = k - a[n-1] + a[0]\n\nans = k - max(b)\n\nprint((int(ans)))", "score": 1.0}
{"golden_code": "import sys\n\nimport numpy as np\n\n\n\nn = int(sys.stdin.readline().rstrip())\n\nx = []\n\ny = []\n\nfor i in range(n):\n\n    a = int(sys.stdin.readline().rstrip())\n\n    xy = [sys.stdin.readline().split() for _ in range(a)]\n\n    if not xy:\n\n        x.append(None)\n\n        y.append(None)\n\n        continue\n\n    xi, yi = np.array(xy, np.int64).T\n\n    x.append(xi-1)\n\n    y.append(yi)\n\n\n\ndef main():\n\n\n\n    ans = 0\n\n    for comb in range(2 ** n):\n\n        cnt = 0\n\n        for i in range(n):\n\n            if not comb >> i & 1:\n\n                continue\n\n            if x[i] is None:\n\n                cnt += 1\n\n                continue\n\n            if np.count_nonzero(comb >> x[i] & 1 ^ y[i]):\n\n                break\n\n            cnt += 1\n\n        else:\n\n            ans = max(ans, cnt)\n\n    return ans\n\n                \n\nif __name__ == '__main__':\n\n    ans = main()\n\n    print(ans)", "generated_code": "import sys\n\n\n\nn = int(sys.stdin.readline().rstrip())\n\nxy = [[] for _ in range(n)]\n\nfor i in range(n):\n\n    a = int(sys.stdin.readline().rstrip())\n\n    for j in range(a):\n\n        x, y = list(map(int, sys.stdin.readline().split()))\n\n        xy[i].append((x-1, y))\n\n\n\ndef main():\n\n    ans = 0\n\n    for comb in range(2 ** n):\n\n        cnt = 0\n\n        for i in range(n):\n\n            if comb >> i & 1 ^ 1:\n\n                continue\n\n            for x, y in xy[i]:\n\n                if comb >> x & 1 ^ y:\n\n                    break\n\n            else:\n\n                cnt += 1\n\n                continue\n\n            break\n\n        else:\n\n            ans = max(ans, cnt)\n\n    return ans\n\n                \n\nif __name__ == '__main__':\n\n    ans = main()\n\n    print(ans)", "score": 1.0}
{"golden_code": "from collections import deque\n\nn,*t=list(map(int,open(0).read().split()))\n\ncon=[[] for _ in range(n)]\n\ndist_f_k=[0]*n\n\n\n\nfor a,b,c in zip(t[:3*n-3:3],t[1::3],t[2::3]):\n\n\tcon[a-1].append((b-1,c))\n\n\tcon[b-1].append((a-1,c))\n\n\n\nk=t[3*n-2]\n\nque=deque([k-1])\n\nwhile que:\n\n\tcur=que.popleft()\n\n\tfor nxt,dd in con[cur]:\n\n\t\tif dist_f_k[nxt]==0 and nxt!=k-1:\n\n\t\t\tque.append(nxt)\n\n\t\t\tdist_f_k[nxt]=dist_f_k[cur]+dd\n\n\n\nfor x,y in zip(t[3*n-1::2],t[3*n::2]):\n\n\tprint((dist_f_k[x-1]+dist_f_k[y-1]))", "generated_code": "def solve():\n\n\tfrom collections import deque\n\n\tn,*t=list(map(int,open(0).read().split()))\n\n\tcon=[[] for _ in range(n)]\n\n\tdist_f_k=[0]*n\n\n\tl1,l2=t[:3*n-3],t[3*n-1:]\n\n\n\n\tfor a,b,c in zip(*[iter(l1)]*3):\n\n\t\tcon[a-1].append((b-1,c))\n\n\t\tcon[b-1].append((a-1,c))\n\n\n\n\tk=t[3*n-2]\n\n\tque=deque([k-1])\n\n\twhile que:\n\n\t\tcur=que.popleft()\n\n\t\tfor nxt,dd in con[cur]:\n\n\t\t\tif dist_f_k[nxt]==0 and nxt!=k-1:\n\n\t\t\t\tque.append(nxt)\n\n\t\t\t\tdist_f_k[nxt]=dist_f_k[cur]+dd\n\n\n\n\tfor x,y in zip(*[iter(l2)]*2):\n\n\t\tprint((dist_f_k[x-1]+dist_f_k[y-1]))\n\n\t\t\n\nif __name__==\"__main__\":\n\n\tsolve()", "score": 1.0}
{"golden_code": "import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\nN = int(readline())\n\nS = read().split()\n\n\n\nS = sorted(S)\n\nls = [[] for i in range(N + 1)]\n\nmax_num = 0\n\nleft = 0\n\nright = 0\n\nwhile right < N:\n\n    while right < N and S[left] == S[right]:\n\n        right += 1\n\n    if (right  - left) >= max_num:\n\n        ls[right - left].append(S[left].decode())\n\n        max_num = right - left\n\n    left = right\n\n    \n\nprint(('\\n'.join(ls[max_num])))\n", "generated_code": "from collections import Counter\n\n\n\nimport sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\nN = int(readline())\n\nS = read().split()\n\n\n\nres = []\n\nc = Counter(S)\n\nmax_num = c.most_common(1)[0][1]\n\nfor i, j in list(c.items()):\n\n    if j == max_num:\n\n        res.append(i)\n\n        \n\nres.sort()\n\n\n\n        \n\nprint(('\\n'.join(list([x.decode() for x in res]))))\n", "score": 1.0}
{"golden_code": "from fractions import gcd\n\nn, m = list(map(int, input().split()))\n\na = [int(i) // 2 for i in input().split()]\n\nx = 1\n\nfor i in range(n):\n\n    x *= a[i] // gcd(x, a[i])\n\nfor i in a:\n\n    if x // i % 2 == 0:\n\n        print((0))\n\n        exit()\n\nprint(((m // x + 1) // 2))", "generated_code": "from math import gcd, ceil\n\nn, m = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\na = [i // 2 for i in a]\n\nl = 1\n\nfor i in a:\n\n    l *= i // gcd(l, i)\n\nfor i in a:\n\n    if l // i % 2 == 0:\n\n        print((0))\n\n        exit()\n\nprint((ceil((m // l) / 2)))", "score": 1.0}
{"golden_code": "from math import floor, sqrt\n\nfrom collections import Counter\n\n\n\nMOD = 10 ** 9 + 7\n\n\n\n# xを素因数分解する\n\ndef getPrimeFactor(x):\n\n    ans = []\n\n    for d in range(2, floor(sqrt(x)) + 1):\n\n        while x % d == 0:\n\n            ans.append(d)\n\n            x //= d\n\n\n\n    if x != 1:\n\n        ans.append(x)\n\n\n\n    return ans\n\n\n\n# xのn乗（二分累乗法）\n\ndef power(x, n):\n\n    ans = 1\n\n    while n:\n\n        if n % 2 == 1:\n\n            ans = (ans * x) % MOD\n\n        x = (x * x) % MOD\n\n        n //= 2\n\n    return ans\n\n\n\n\n\nN, M = list(map(int, input().split()))\n\n\n\nPFs = getPrimeFactor(M)\n\ncnt = Counter(PFs)\n\n\n\nN2 = N\n\nif len(cnt):\n\n    N2 += max(cnt.values())\n\n\n\n# facts[x]: xの階乗\n\nfacts = [1] + [0] * N2\n\nfor x in range(1, N2 + 1):\n\n    facts[x] = (facts[x - 1] * x) % MOD\n\n\n\n# invFs[x]: xの階乗の逆元\n\ninvFs = [0] * N2 + [power(facts[N2], MOD - 2)]\n\nfor x in reversed(list(range(N2))):\n\n    invFs[x] = (invFs[x + 1] * (x + 1)) % MOD\n\n\n\ndef comb(n, k):\n\n    return ((facts[n] * invFs[k]) % MOD * invFs[n - k]) % MOD\n\n\n\n\n\nans = 1\n\nfor num in list(cnt.values()):\n\n    ans = (ans * comb(N + num - 1, num)) % MOD\n\nprint(ans)\n", "generated_code": "from math import floor, sqrt\n\nfrom collections import Counter\n\n\n\nMOD = 10 ** 9 + 7\n\n\n\n# xを素因数分解する\n\ndef getPrimeFactor(x):\n\n    ans = []\n\n    for d in range(2, floor(sqrt(x)) + 1):\n\n        while x % d == 0:\n\n            ans.append(d)\n\n            x //= d\n\n    if x != 1:\n\n        ans.append(x)\n\n    return ans\n\n\n\ndef comb(n, k):\n\n    k = min(k, n - k)\n\n    ans = 1\n\n    for i in range(n, n - k, -1):\n\n        ans *= i\n\n    for i in range(1, k + 1):\n\n        ans //= i \n\n    return ans\n\n\n\n\n\nN, M = list(map(int, input().split()))\n\n\n\nPFs = getPrimeFactor(M)\n\ncnt = Counter(PFs)\n\n\n\nans = 1\n\nfor num in list(cnt.values()):\n\n    ans *= comb(N + num - 1, num)\n\nprint((ans % MOD))\n", "score": 1.0}
{"golden_code": "def main():\n\n\tn, ma, mb, *L = list(map(int, open(0).read().split()))\n\n\tM = 1<<30\n\n\tdp = [[M] * 420 for _ in range(420)]\n\n\tdp[0][0] = 0\n\n\tfor a, b, c in zip(*[iter(L)] * 3):\n\n\t\tfor i in range(400, -1, -1):\n\n\t\t\tfor j in range(400, -1, -1):\n\n\t\t\t\tt = dp[i][j] + c\n\n\t\t\t\tif dp[i + a][j + b] > t:\n\n\t\t\t\t\tdp[i + a][j + b] = t\n\n\tans = M\n\n\t_ma, _mb = ma, mb\n\n\twhile _ma < 410 > _mb:\n\n\t\tans = min(ans, dp[_ma][_mb])\n\n\t\t_ma += ma\n\n\t\t_mb += mb\n\n\tprint((ans if ans < M else -1))\n\n\n\nif __name__==\"__main__\":\n\n\tmain()", "generated_code": "def main():\n\n\tn, ma, mb, *L = list(map(int, open(0).read().split()))\n\n\tM = 1 << 30\n\n\tdp = [[M] * 420 for _ in range(420)]\n\n\tdp[0][0] = 0\n\n\tua = ub = 15\n\n\tfor a, b, c in zip(*[iter(L)] * 3):\n\n\t\tfor i in range(ua, -1, -1):\n\n\t\t\tfor j in range(ub, -1, -1):\n\n\t\t\t\tt = dp[i][j] + c\n\n\t\t\t\tif dp[i + a][j + b] > t:\n\n\t\t\t\t\tdp[i + a][j + b] = t\n\n\t\t\t\t\tif ua < i + a:\n\n\t\t\t\t\t\tua = i + a\n\n\t\t\t\t\tif ub < j + b:\n\n\t\t\t\t\t\tub = j + b\n\n\tans = M\n\n\t_ma, _mb = ma, mb\n\n\twhile _ma < 410 > _mb:\n\n\t\tans = min(ans, dp[_ma][_mb])\n\n\t\t_ma += ma\n\n\t\t_mb += mb\n\n\tprint((ans if ans < M else -1))\n\n\n\n\n\nif __name__ == \"__main__\":\n\n\tmain()\n", "score": 1.0}
{"golden_code": "n_str = eval(input())\n\nn_int = int(n_str)\n\n# 1 ~ 50000\n\n# 桁数が奇数= 1桁, 3桁, 5桁\n\n# 1 ~ 9, 100 ~ 999,10000 ~ 99999の90909個しかないので全探索いけるか?\n\nexs_list = []\n\nfor i in range(1, 100000):\n\n    if len(str(i)) % 2 == 1:\n\n        exs_list.append(i)\n\n\n\nexs = {i: i for i in exs_list}\n\n\n\nn_s = []\n\nans = 0\n\nfor i in range(1, n_int + 1):\n\n    if len(str(i)) % 2 == 0:\n\n        continue\n\n    if i in exs:\n\n        ans += 1\n\n\n\nprint(ans)\n\n\n\n\n\n\n\n\n\n\n", "generated_code": "def digit_sum(n):\n\n    # 各桁の和を求める\n\n    # 計算量: O(logN)\n\n    ans = 0\n\n    while n > 0:\n\n        ans += 1\n\n        n //= 10\n\n    return ans\n\n\n\nn = int(eval(input()))\n\ncnt = 0\n\n\n\nfor i in range(1, n+1):\n\n    cnt += digit_sum(i) % 2\n\n\n\nprint(cnt)\n", "score": 1.0}
{"golden_code": "def check(x, y):\n\n    for a, b in zip(x, y):\n\n        if a != b and b != -1:\n\n            return False\n\n    else:\n\n        return True\n\n\n\n\n\nn = int(eval(input()))\n\nremarks = []\n\ncnt_max = 0\n\nfor _ in range(n):\n\n    a = int(eval(input()))\n\n    x = [tuple(map(int, input().split())) for i in range(a)]\n\n    r = [-1] * n\n\n    for i, j in x:\n\n        r[i - 1] = j\n\n    remarks.append(r)\n\nfor r in range(2 ** n):\n\n    r = list(bin(r)[2:].zfill(n))\n\n    r = [int(i) for i in r[:]]\n\n    cnt = 0\n\n    for i in range(n):\n\n        if r[i] == 1:\n\n            flag = check(r, remarks[i])\n\n            cnt += 1\n\n            if not flag:\n\n                cnt = 0\n\n                break\n\n    cnt_max = max(cnt, cnt_max)\n\nprint(cnt_max)", "generated_code": "import numpy as np\n\nimport itertools\n\n\n\nn = int(eval(input()))\n\ninfo = []\n\nfor i in range(n):\n\n    a = int(eval(input()))\n\n    for _ in range(a):\n\n        x, y = list(map(int, input().split()))\n\n        info.append((i, x - 1, y))\n\n\n\na = np.array(list(itertools.product([0, 1], repeat=n)), dtype=np.bool)\n\nfor i, x, y in info:\n\n    bl = (~a[:, i]) | (a[:, x] == bool(y))\n\n    a = a[bl]\n\n\n\nans = a.sum(axis=1).max()\n\nprint(ans)", "score": 1.0}
{"golden_code": "A, B, C, X, Y = list(map(int, input().split()))\n\n\n\nans = 5000 * 2 * 10 ** 5\n\nfor i in range(10 ** 5 + 1):\n\n    s = i * 2 * C + max(0, X - i) * A + max(0, Y - i) * B\n\n    ans = min(ans, s)\n\n\n\nprint(ans)", "generated_code": "A, B, C, X, Y = list(map(int, input().split()))\n\n\n\nif X > Y:\n\n    v = A\n\nelse:\n\n    v = B\n\n\n\nans = min(A*X+B*Y, C*max(X, Y)*2, C*min(X,Y)*2+(max(X,Y)-min(X,Y))*v)\n\n\n\nprint(ans)", "score": 1.0}
{"golden_code": "from collections import Counter\n\nS = input()[::-1]\n\n\n\nmemo = [0]\n\nd = 0\n\nmod = 2019\n\n\n\nfor s in S:\n\n    tmp = int(s) * pow(10, d, mod) % mod\n\n    tmp = memo[-1] + tmp\n\n    memo.append(tmp % mod)\n\n    d += 1\n\n\n\nc = Counter(memo)\n\nans = sum(v * (v - 1) // 2 for v in list(c.values()))\n\nprint(ans)", "generated_code": "from collections import defaultdict\n\nS = eval(input())\n\nN = len(S)\n\n\n\nmemo = defaultdict(int)\n\nmemo[0] += 1\n\n\n\nmod = 2019\n\nd = 1\n\nval = 0\n\n\n\nfor s in S[::-1]:\n\n    s = int(s)\n\n    val += s * d\n\n    val %= mod\n\n    memo[val] += 1\n\n    d *= 10\n\n    d %= mod\n\n\n\nprint((sum(v * (v - 1) // 2 for v in list(memo.values()))))", "score": 1.0}
{"golden_code": "import numpy as np\n\nn = int(eval(input()))\n\nal = list(map(int,input().split()))\n\n\n\nfor i in range(n):\n\n    al[i] -= i + 1\n\n\n\nmed = np.median(np.array(al))\n\n\n\nans = 0\n\nfor a in al:\n\n    ans += abs(a-med)\n\nprint((int(ans)))", "generated_code": "import statistics\n\nn = int(eval(input()))\n\nal = list(map(int,input().split()))\n\n\n\nfor i in range(n):\n\n    al[i] -= i + 1\n\n\n\nmedian = statistics.median(al)\n\n\n\nans = 0\n\nfor a in al:\n\n    ans += abs(median - a)\n\n\n\nprint((int(ans)))\n", "score": 1.0}
{"golden_code": "from collections import deque\n\nfrom copy import deepcopy, copy\n\ndy = [-1, 0, 0, 1]\n\ndx = [0, -1, 1, 0]\n\nN = 3\n\ndef g(i, j, a):\n\n    t = a // (10 ** j) % 10\n\n    return a - t * (10 ** j) + t * (10 ** i)\n\ndef MAIN():\n\n    m = {8:{7, 5}, 7:{8, 6, 4}, 6:{7, 3}, 5:{8, 4, 2}, 4:{7, 5, 3, 1}, 3:{6, 4, 0}, 2:{5, 1}, 1:{4, 2, 0}, 0:{3, 1}}\n\n    MAP = \"\".join(input().replace(\" \", \"\") for _ in range(N))\n\n    start = 8 - MAP.find(\"0\")\n\n    MAP = int(MAP)\n\n    goal = ('1', '2', '3', '4', '5', '6', '7', '8', '0')\n\n    goal = 123456780\n\n    dp = deque([(0, start, MAP)])\n\n    LOG = {MAP}\n\n    while dp:\n\n        cnt, yx, M = dp.popleft()\n\n        if M == goal:\n\n            print(cnt)\n\n            break\n\n        cnt += 1\n\n        for nyx in m[yx]:\n\n            CM = g(yx, nyx, M)\n\n            if not CM in LOG:\n\n                dp.append((cnt, nyx, CM))\n\n                LOG.add(CM)\n\nMAIN()\n\n\n", "generated_code": "from collections import deque\n\nfrom copy import deepcopy, copy\n\nN = 3\n\ndef g(i, j, a):\n\n    if i > j:\n\n        i, j = j, i\n\n    return a[:i] + a[j] + a[i + 1:j] + a[i] + a[j + 1:]\n\ndef MAIN():\n\n    m = {8:{7, 5}, 7:{8, 6, 4}, 6:{7, 3}, 5:{8, 4, 2}, 4:{7, 5, 3, 1}, 3:{6, 4, 0}, 2:{5, 1}, 1:{4, 2, 0}, 0:{3, 1}}\n\n    MAP = \"\".join(input().replace(\" \", \"\") for _ in range(N))\n\n    start = MAP.find(\"0\")\n\n    goal = \"123456780\"\n\n    dp = deque([(0, start, MAP)])\n\n    LOG = {MAP}\n\n    while dp:\n\n        cnt, yx, M = dp.popleft()\n\n        if M == goal:\n\n            print(cnt)\n\n            break\n\n        cnt += 1\n\n        for nyx in m[yx]:\n\n            CM = g(yx, nyx, M)\n\n            if not CM in LOG:\n\n                dp.append((cnt, nyx, CM))\n\n                LOG.add(CM)\n\nMAIN()\n\n\n", "score": 1.0}
{"golden_code": "import numpy as np\n\nN = int(eval(input()))\n\nV = np.array([int(i) for i in input().split(\" \")])\n\nC = np.array([int(i) for i in input().split(\" \")])\n\n\n\nvc = V-C\n\n\n\nval = 0\n\n\n\nfor i in range(N):\n\n    if vc[i]>0:\n\n        val+=vc[i]\n\nprint(val)", "generated_code": "N = int(eval(input()))\n\nV = [int(i) for i in input().split(\" \")]\n\nC = [int(i) for i in input().split(\" \")]\n\n\n\nval = 0\n\n\n\nfor i in range(N):\n\n    vc=V[i]-C[i]\n\n    if vc>0:\n\n        val+=vc\n\nprint(val)", "score": 1.0}
{"golden_code": "n = int(eval(input()))\n\nimport math\n\nm = int(math.sqrt(n))+1\n\nanss = []\n\nfor x in range(1, m+1):\n\n  y = n//x\n\n  z = n%x\n\n  if z == 0:\n\n    anss.append(abs(x-1)+abs(y-1))\n\nprint((min(anss)))\n", "generated_code": "n = int(eval(input()))\n\ndef make_divisors(n):\n\n    divisors = []\n\n    for i in range(1, int(n**0.5)+1):\n\n        if n % i == 0:\n\n            divisors.append(i)\n\n            if i != n // i:\n\n                divisors.append(n//i)\n\n\n\n    #divisors.sort(reverse=True)\n\n    return divisors\n\n\n\nl = make_divisors(n)\n\nmin_ = float('inf')\n\nfor i in range(len(l)):\n\n    min_ = min(min_, l[i]-1+n//l[i]-1)\n\nprint(min_)\n", "score": 1.0}
{"golden_code": "# ABC 155 C\n\nfrom collections import Counter\n\nimport numpy as np\n\nN = int(eval(input()))\n\nS = [str(eval(input())) for i in range(N)]\n\nS = np.array(S)\n\n\n\ncount = Counter(S)\n\nmax_num = max(count.values())\n\nmax_list = [i for i,j in list(count.items()) if j==max_num]\n\n\n\nmax_list.sort()\n\nprint(('\\n'.join(max_list)))", "generated_code": "import sys\n\nfrom collections import Counter\n\nN = int(sys.stdin.readline())\n\nS = sys.stdin.read().split()\n\n\n\ncount = Counter(S)\n\nmax_num = max(count.values())\n\nmax_list = [i for i,j in list(count.items()) if j==max_num]\n\n \n\nmax_list.sort()\n\nprint(('\\n'.join(max_list)))", "score": 1.0}
{"golden_code": "def main():\n\n    x = int(eval(input()))\n\n    for a in range(-120, 121):\n\n        for b in range(-120, 121):\n\n            if a**5 - b**5 == x:\n\n                print((a, b))\n\n                return\n\n\n\nif __name__ == \"__main__\":\n\n    main()", "generated_code": "def main():\n\n    x = int(eval(input()))\n\n    for i in range(-120, 121):\n\n        for j in range(-120, 121):\n\n            if i**5 - j**5 == x:\n\n                print((i, j))\n\n                return\n\n\n\nif __name__ == \"__main__\":\n\n    main()", "score": 1.0}
{"golden_code": "n,m,k=list(map(int,input().split()))\n\nmod=10**9+7\n\nf=[1]\n\nfor i in range(2*10**5+7):f+=[f[-1]*(i+1)%mod]\n\ndef comb(a,b):return f[a]*pow(f[b],mod-2,mod)*pow(f[a-b],mod-2,mod)%mod\n\nans=0\n\nfor i in range(1,n):\n\n  ans+=(i*(n-i)*m**2)*(comb(n*m-2,k-2))\n\n  ans%=mod\n\nfor i in range(1,m):\n\n  ans+=(i*(m-i)*n**2)*(comb(n*m-2,k-2))\n\n  ans%=mod\n\nprint(ans)", "generated_code": "n,m,k=list(map(int,input().split()))\n\n\n\nmod = 10**9+7\n\nf = [1]\n\nfor i in range(n*m):\n\n  f += [f[-1]*(i+1) % mod]\n\ndef comb(a, b):\n\n  return f[a]*pow(f[b], mod-2, mod)*pow(f[a-b], mod-2, mod) % mod\n\n\n\nans=0\n\nfor dist in range(1,n):\n\n  c=n-dist\n\n  p=(c*m*m)%mod\n\n  ans+=p*dist\n\nfor dist in range(1,m):\n\n  c=m-dist\n\n  p=(c*n*n)%mod\n\n  ans+=p*dist\n\nans%=mod\n\nprint((ans*comb(n*m-2,k-2)%mod))", "score": 1.0}
{"golden_code": "def getN():\n\n    return int(eval(input()))\n\ndef getNM():\n\n    return list(map(int, input().split()))\n\ndef getList():\n\n    return list(map(int, input().split()))\n\ndef getArray(intn):\n\n    return [int(eval(input())) for i in range(intn)]\n\ndef input():\n\n    return sys.stdin.readline().rstrip()\n\ndef rand_N(ran1, ran2):\n\n    return random.randint(ran1, ran2)\n\ndef rand_List(ran1, ran2, rantime):\n\n    return [random.randint(ran1, ran2) for i in range(rantime)]\n\ndef rand_ints_nodup(ran1, ran2, rantime):\n\n  ns = []\n\n  while len(ns) < rantime:\n\n    n = random.randint(ran1, ran2)\n\n    if not n in ns:\n\n      ns.append(n)\n\n  return sorted(ns)\n\n\n\ndef rand_query(ran1, ran2, rantime):\n\n  r_query = []\n\n  while len(r_query) < rantime:\n\n    n_q = rand_ints_nodup(ran1, ran2, 2)\n\n    if not n_q in r_query:\n\n      r_query.append(n_q)\n\n  return sorted(r_query)\n\n\n\nfrom collections import defaultdict, deque, Counter\n\nfrom sys import exit\n\nfrom decimal import *\n\nfrom heapq import heapify, heappop, heappush\n\nimport math\n\nimport random\n\nimport string\n\nfrom copy import deepcopy\n\nfrom itertools import combinations, permutations, product\n\nfrom operator import mul, itemgetter\n\nfrom functools import reduce\n\nfrom bisect import bisect_left, bisect_right\n\n\n\nimport sys\n\nsys.setrecursionlimit(1000000000)\n\nmod = 10 ** 9 + 7\n\n\n\n#############\n\n# Main Code #\n\n#############\n\n\n\nS = getN()\n\n\n\n# 逆元事前処理ver\n\n# nが小さい場合に\n\nlim = 10 ** 5 + 1\n\nfact = [1, 1]\n\nfactinv = [1, 1]\n\ninv = [0, 1]\n\n\n\nfor i in range(2, lim + 1):\n\n    fact.append((fact[-1] * i) % mod)\n\n    inv.append((-inv[mod % i] * (mod // i)) % mod)\n\n    # 累計\n\n    factinv.append((factinv[-1] * inv[-1]) % mod)\n\n\n\ndef cmb(n, r):\n\n    if (r < 0) or (n < r):\n\n        return 0\n\n    r = min(r, n - r)\n\n    return fact[n] * factinv[r] * factinv[n - r] % mod\n\n\n\nans = 0\n\n# 長さNの時最低でも3 * N使う\n\n# 残りは分配する\n\nfor i in range(1, 2001):\n\n    s = S - (3 * i)\n\n    if s < 0:\n\n        break\n\n    # sをN個に分配する通りがいくつあるか\n\n    # 重複組み合わせ\n\n    # 仕切りの数はi - 1個\n\n    ans += cmb(s + i - 1, i - 1)\n\nprint((ans % mod))", "generated_code": "def getN():\n\n    return int(eval(input()))\n\ndef getNM():\n\n    return list(map(int, input().split()))\n\ndef getList():\n\n    return list(map(int, input().split()))\n\ndef getArray(intn):\n\n    return [int(eval(input())) for i in range(intn)]\n\ndef input():\n\n    return sys.stdin.readline().rstrip()\n\ndef rand_N(ran1, ran2):\n\n    return random.randint(ran1, ran2)\n\ndef rand_List(ran1, ran2, rantime):\n\n    return [random.randint(ran1, ran2) for i in range(rantime)]\n\ndef rand_ints_nodup(ran1, ran2, rantime):\n\n  ns = []\n\n  while len(ns) < rantime:\n\n    n = random.randint(ran1, ran2)\n\n    if not n in ns:\n\n      ns.append(n)\n\n  return sorted(ns)\n\n\n\ndef rand_query(ran1, ran2, rantime):\n\n  r_query = []\n\n  while len(r_query) < rantime:\n\n    n_q = rand_ints_nodup(ran1, ran2, 2)\n\n    if not n_q in r_query:\n\n      r_query.append(n_q)\n\n  return sorted(r_query)\n\n\n\nfrom collections import defaultdict, deque, Counter\n\nfrom sys import exit\n\nfrom decimal import *\n\nfrom heapq import heapify, heappop, heappush\n\nimport math\n\nimport random\n\nimport string\n\nfrom copy import deepcopy\n\nfrom itertools import combinations, permutations, product\n\nfrom operator import mul, itemgetter\n\nfrom functools import reduce\n\nfrom bisect import bisect_left, bisect_right\n\n\n\nimport sys\n\nsys.setrecursionlimit(1000000000)\n\nmod = 10 ** 9 + 7\n\n\n\n#############\n\n# Main Code #\n\n#############\n\n\n\nN = getN()\n\nlogk = N.bit_length()\n\n\n\n# 漸化式にできるなら行列計算に落とし込める\n\n# A[n] = A[n - 1] + A[n - 3]なので\n\n# [a2, a1, a0] = [0, 0, 1]\n\n# [[1, 1, 0], [0, 0, 1], [1, 0, 0]]のN乗をすれば\n\n# [an+2, an+1, an] が出る\n\n\n\ndp = [[[0, 0, 0] for i in range(3)] for i in range(logk)]\n\ndp[0] = [\n\n[1, 1, 0],\n\n[0, 0, 1],\n\n[1, 0, 0]\n\n]\n\n\n\n# 行列掛け算 O(n3)かかる\n\ndef array_cnt(ar1, ar2):\n\n    h = len(ar1)\n\n    w = len(ar2[0])\n\n    row = ar1\n\n    col = []\n\n    for j in range(w):\n\n        opt = []\n\n        for i in range(len(ar2)):\n\n            opt.append(ar2[i][j])\n\n        col.append(opt)\n\n\n\n    res = [[[0, 0] for i in range(w)] for i in range(h)]\n\n    for i in range(h):\n\n        for j in range(w):\n\n            cnt = 0\n\n            for x, y in zip(row[i], col[j]):\n\n                cnt += x * y\n\n            res[i][j] = cnt\n\n            res[i][j] %= mod\n\n    return res\n\n\n\nfor i in range(1, logk):\n\n    dp[i] = array_cnt(dp[i - 1], dp[i - 1])\n\n\n\nans = [[0, 0, 1]]\n\nfor i in range(logk):\n\n    if N & (1 << i):\n\n        ans = array_cnt(ans, dp[i])\n\nprint((ans[0][2] % mod))", "score": 1.0}
{"golden_code": "k = int(eval(input()))\n\ncount = 1\n\nn = 0\n\nif k % 2 == 0 or k % 5 == 0:\n\n    print((-1))\n\nelse:\n\n  while 1:\n\n      n = (n * 10 + 7) % k  \n\n      if n == 0:\n\n        break \n\n      count += 1\n\n  print(count)", "generated_code": "def main(h):\n\n  count = 1\n\n  n = 0\n\n  for i in range (k):\n\n    n = (n * 10 + 7) % k  \n\n    if n == 0: \n\n      print(count)\n\n      return 0\n\n    count += 1\n\n  print((-1))\n\n  \n\nif __name__ == '__main__':\n\n  k = int(eval(input()))\n\n  main(k)", "score": 1.0}
{"golden_code": "import numpy as np\n\nn=int(eval(input()))\n\ns=np.argsort(np.array(list(map(int,input().split()))))+1\n\nprint((*s))", "generated_code": "n=int(eval(input()))\n\na=list(map(int,input().split()))\n\nl=sorted([[inx+1,j] for inx,j in enumerate(a)],key=lambda x:x[1])\n\nans=[i for i,j in l]\n\nprint((*ans))", "score": 1.0}
{"golden_code": "N=int(eval(input()))\n\na=list(map(int,input().split()))\n\nfor i in range(N):\n\n  for j in range(1,31):\n\n    if a[i]%(2**j)!=0:\n\n      a[i]=j-1\n\n      break\n\nprint((sum(a)))", "generated_code": "import sys\n\ninput = sys.stdin.buffer.readline\n\n\n\nN = int(eval(input()))\n\nA = list(map(int, input().split()))\n\n\n\ndef f(n):\n\n  res = 0\n\n  while n % 2 == 0:\n\n    n //= 2\n\n    res += 1\n\n  return res\n\n\n\nanswer = 0\n\nfor a in A:\n\n  answer += f(a)\n\n\n\nprint(answer)", "score": 1.0}
{"golden_code": "a,b,c=list(map(int,input().split()))\n\ne=(a-b)|(b-c)\n\nprint((bool(e|(a|b|c)%2)*(e^~-e).bit_length()-1))", "generated_code": "a,b,c=list(map(int,input().split()))\n\ne=(a-b)|(b-c)\n\nprint((bool(e|b%2)*(e^~-e).bit_length()-1))", "score": 1.0}
{"golden_code": "import math\n\nprint((math.factorial(int(eval(input())))%(10**9+7)))", "generated_code": "ans=1\n\nn=int(eval(input()))\n\nfor i in range(1,n+1):\n\n  ans*=i\n\n  ans=ans%(10**9+7)\n\nprint(ans)", "score": 1.0}
{"golden_code": "N, K = list(map(int, input().split()))\n\nS = eval(input())\n\nnums = []\n\nnow = 1\n\ncnt = 0\n\nfor i in range(N):\n\n    if S[i] == str(now):\n\n        cnt += 1\n\n    else:\n\n        nums.append(cnt)\n\n        now = 1 - now\n\n        cnt = 1\n\nif cnt != 0:\n\n    nums.append(cnt)\n\nif len(nums) % 2 == 0:\n\n    nums.append(0)\n\n\n\nadd = 2 * K + 1\n\nans = 0\n\nleft = 0\n\nright = 0\n\ntmp = 0\n\nfor i in range(0, len(nums), 2):\n\n\n\n    next_left = i\n\n    next_right = min(i + add, len(nums))\n\n\n\n    while next_left > left:\n\n        tmp -= nums[left]\n\n        left += 1\n\n\n\n    while next_right > right:\n\n        tmp += nums[right]\n\n        right += 1\n\n\n\n    ans = max(ans, tmp)\n\nprint(ans)", "generated_code": "N, K = list(map(int, input().split()))\n\nS = eval(input())\n\nnums = []\n\nnow = 1\n\ncnt = 0\n\nfor i in range(N):\n\n    if S[i] == str(now):\n\n        cnt += 1\n\n    else:\n\n        nums.append(cnt)\n\n        now = 1 - now\n\n        cnt = 1\n\nif cnt != 0:\n\n    nums.append(cnt)\n\nif len(nums) % 2 == 0:\n\n    nums.append(0)\n\n\n\ncsum = [0] * (len(nums) + 1)\n\nfor i in range(len(nums)):\n\n    csum[i + 1] = csum[i] + nums[i]\n\n\n\nadd = 2 * K + 1\n\nans = 0\n\ntmp = 0\n\nfor i in range(0, len(nums), 2):\n\n    left = i\n\n    right = min(i + add, len(nums))\n\n    tmp = csum[right] - csum[left]\n\n    ans = max(ans, tmp)\n\nprint(ans)", "score": 1.0}
{"golden_code": "n,q = list(map(int,input().split()))\n\nqueue = []\n\nfor i in range(n):\n\n\tname,time = input().split()\n\n\tqueue.append([name, int(time)])\n\n\n\nt = 0\n\ni = 0\n\nwhile queue:\n\n\ti %= len(queue)\n\n\tp = queue[i]\n\n\tt += min(q, p[1])\n\n\tif p[1] > q:\n\n\t\tp[1] -= q\n\n\t\ti += 1\n\n\telse:\n\n\t\tprint((p[0], t))\n\n\t\tqueue.pop(i)\n", "generated_code": "from collections import deque\n\n\n\nn,q = list(map(int,input().split()))\n\nqueue = deque()\n\nfor i in range(n):\n\n\tname,time = input().split()\n\n\tqueue.append((name, int(time)))\n\n\n\nt = 0\n\nwhile queue:\n\n\tname,time = queue.popleft()\n\n\tt += min(q, time)\n\n\tif time > q:\n\n\t\tqueue.append((name, time-q))\n\n\telse:\n\n\t\tprint((name,t))\n", "score": 1.0}
{"golden_code": "# -*- coding: utf-8 -*-\n\n\n\n\"\"\"\n\n参考：http://drken1215.hatenablog.com/entry/2018/09/23/224100\n\n　　　http://tutuz.hateblo.jp/entry/2018/09/24/121248\n\n・素因数分解と重複組み合わせ\n\n・毎回階乗やると死ぬから階乗と逆元のテーブル作る(忘れてた)\n\n\"\"\"\n\n\n\nfrom collections import defaultdict\n\nfrom math import sqrt\n\n\n\nMOD = 10 ** 9 + 7\n\n\n\ndef fact_prime(num):\n\n    d = defaultdict(int)\n\n    # 終点はルート切り捨て+1\n\n    end = int(sqrt(num)) + 1\n\n    for i in range(2, end+1):\n\n        cnt = 0\n\n        # 素因数分解：小さい方から割れるだけ割って素数をカウント\n\n        while num % i == 0:\n\n            num //= i\n\n            d[i] += 1\n\n        # 1まで来たら終了\n\n        if num == 1:\n\n            break\n\n    # 最後までそのまま来たやつはnumが素数(ただし1^1は1^0なので数に入れない)\n\n    if num != 1:\n\n        d[num] += 1\n\n    return d\n\n\n\n# とりあえずv+N-1が収まればいいはず\n\nMAX = 10 ** 5 * 2\n\n# 予め組み合わせ計算に必要な階乗と逆元のテーブルを作っておく\n\nfactorial = [1] * (MAX)\n\nfactorial[0] = factorial[1] = 1\n\nfor i in range(2, MAX):\n\n    factorial[i] = factorial[i-1] * i % MOD\n\n\n\ninverse = [1] * (MAX)\n\n# powに第三引数入れると冪乗のmod付計算を高速にやってくれる\n\ninverse[MAX-1] = pow(factorial[MAX-1], MOD-2, MOD)\n\nfor i in range(MAX-2, 0, -1):\n\n    # 最後から戻っていくこのループならH+W回powするより処理が速い\n\n    inverse[i] = inverse[i+1] * (i+1) % MOD\n\n\n\n# 組み合わせの数\n\ndef nCr(n, r):\n\n    # 10C7 = 10C3\n\n    r = min(r, n-r)\n\n    # 分子の計算\n\n    numerator = factorial[n]\n\n    # 分母の計算\n\n    denominator = inverse[r] * inverse[n-r] % MOD\n\n    return numerator * denominator % MOD\n\n\n\nN, M = list(map(int, input().split()))\n\n\n\n# d = fact_prime(M)\n\n# print(d)\n\nans = 1\n\nfor k, v in list(fact_prime(M).items()):\n\n    # 重複組み合わせ\n\n    # v個のkとN-1個の仕切りから、v個を並べる(v+N-1個のマスからv個を選び出す組み合わせ)\n\n    ans = (ans * nCr(v+N-1, v)) % MOD\n\nprint(ans)\n", "generated_code": "# -*- coding: utf-8 -*-\n\n\n\nimport sys\n\n\n\ndef input(): return sys.stdin.readline().strip()\n\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\n\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\n\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\n\ndef ceil(x, y=1): return int(-(-x // y))\n\ndef INT(): return int(eval(input()))\n\ndef MAP(): return list(map(int, input().split()))\n\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\n\ndef Yes(): print('Yes')\n\ndef No(): print('No')\n\ndef YES(): print('YES')\n\ndef NO(): print('NO')\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = float('inf')\n\nMOD = 10 ** 9 + 7\n\n\n\ndef factorize(num: int) -> dict:\n\n    \"\"\" 素因数分解 \"\"\"\n\n    from math import sqrt\n\n    from collections import Counter\n\n\n\n    d = Counter()\n\n    # 終点はルート切り捨て+1\n\n    for i in range(2, int(sqrt(num))+1):\n\n        # 素因数分解：小さい方から割れるだけ割って素数をカウント\n\n        while num % i == 0:\n\n            num //= i\n\n            d[i] += 1\n\n        # 1まで分解したら終了\n\n        if num == 1:\n\n            break\n\n    # 最後に残ったnumは素数(ただし1^1は1^0なので数に入れない)\n\n    if num != 1:\n\n        d[num] += 1\n\n    return d\n\n\n\nclass FactInvMOD:\n\n    \"\"\" 階乗たくさん使う時用のテーブル準備 \"\"\"\n\n\n\n    def __init__(self, MAX, MOD):\n\n        \"\"\" MAX：階乗に使う数値の最大以上まで作る \"\"\"\n\n        \n\n        MAX += 1\n\n        self.MAX = MAX\n\n        self.MOD = MOD\n\n        # 階乗テーブル\n\n        factorial = [1] * MAX\n\n        factorial[0] = factorial[1] = 1\n\n        for i in range(2, MAX):\n\n            factorial[i] = factorial[i-1] * i % MOD\n\n        # 階乗の逆元テーブル\n\n        inverse = [1] * MAX\n\n        # powに第三引数入れると冪乗のmod付計算を高速にやってくれる\n\n        inverse[MAX-1] = pow(factorial[MAX-1], MOD-2, MOD)\n\n        for i in range(MAX-2, 0, -1):\n\n            # 最後から戻っていくこのループならMAX回powするより処理が速い\n\n            inverse[i] = inverse[i+1] * (i+1) % MOD\n\n        self.fact = factorial\n\n        self.inv = inverse\n\n    \n\n    def nCr(self, n, r):\n\n        \"\"\" 組み合わせの数 (必要な階乗と逆元のテーブルを事前に作っておく) \"\"\"\n\n\n\n        if n < r: return 0\n\n        # 10C7 = 10C3\n\n        r = min(r, n-r)\n\n        # 分子の計算\n\n        numerator = self.fact[n]\n\n        # 分母の計算\n\n        denominator = self.inv[r] * self.inv[n-r] % self.MOD\n\n        return numerator * denominator % self.MOD\n\n\n\n    def nPr(self, n, r):\n\n        \"\"\" 順列 \"\"\"\n\n\n\n        if n < r: return 0\n\n        return self.fact[n] * self.inv[n-r] % self.MOD\n\n\n\n    def nHr(self, n, r):\n\n        \"\"\" 重複組み合わせ \"\"\"\n\n\n\n        # r個選ぶところにN-1個の仕切りを入れる\n\n        return self.nCr(r+n-1, r)\n\n\n\nN, M = MAP()\n\n\n\nd = factorize(M)\n\n\n\n# 例外処理\n\nif not d:\n\n    print((1))\n\n    exit()\n\n\n\nMAX = N + max(d.values())\n\nfim = FactInvMOD(MAX, MOD)\n\nans = 1\n\nfor k, v in list(d.items()):\n\n    ans *= fim.nHr(N, v)\n\n    ans %= MOD\n\nprint(ans)\n", "score": 1.0}
{"golden_code": "N,K=list(map(int,input().split()))\n\na = [[0]*N]*K\n\na = [[0 for n in range(N)] for k in range(K)]\n\n\n\nfor k in range(K):\n\n    d=int(eval(input()))\n\n    have_k=list(map(int,input().split()))\n\n    for h in have_k:\n\n        a[k][h-1]=1\n\n\n\nan=[0]*N\n\nfor k in range(K):\n\n  for n in range(N):\n\n    an[n] = an[n]+a[k][n]\n\n\n\nresult=0\n\nfor i in an:\n\n  if i == 0:\n\n    result+=1\n\n\n\nprint(result)", "generated_code": "N,K=list(map(int,input().split()))\n\na = [[0 for n in range(N)] for k in range(K)]\n\n\n\nfor k in range(K):\n\n    d=int(eval(input()))\n\n    have_k=list(map(int,input().split()))\n\n    for h in have_k:\n\n        a[k][h-1]=1\n\n\n\nan=[0]*N\n\nfor k in range(K):\n\n  for n in range(N):\n\n    an[n] = an[n]+a[k][n]\n\n\n\nresult=0\n\nfor i in an:\n\n  if i == 0:\n\n    result+=1\n\n\n\nprint(result)", "score": 1.0}
{"golden_code": "import sys\n\ninput = sys.stdin.readline\n\nsys.setrecursionlimit(10**7)\n\nINF = 10**10\n\nMOD = 10**9 + 7\n\nX = int(eval(input()))\n\nfor i in range(1000):\n\n    for j in range(-1000,1000):\n\n        #print (i**5 - j**5)\n\n        if i**5 - j**5 == X:\n\n            print((i,j))\n\n            exit()\n\n   ", "generated_code": "import sys\n\ninput = sys.stdin.readline\n\nsys.setrecursionlimit(10**7)\n\nINF = 10**10\n\nMOD = 10**9 + 7\n\nX = int(eval(input()))\n\nMAX_X = 10**9\n\nn = 0\n\nwhile(1):\n\n    n+=1\n\n    if n**5 - (n-1)**5 > MAX_X:\n\n        break\n\nfor i in range(n):\n\n    for j in range(-n+1,n-1):\n\n        if i**5 - j**5 == X:\n\n            print((i,j))\n\n            exit()\n\n   ", "score": 1.0}
{"golden_code": "n, m = list(map(int, input().split()))\n\ngate = []\n\nl, r = list(map(int, input().split()))\n\nfor i in range(1, m):\n\n    m, s = list(map(int, input().split()))\n\n    if l < m:\n\n        l = m\n\n    if s < r:\n\n        r = s\n\nprint((len([i for i in range(l, r + 1)])))", "generated_code": "def main():\n\n    x = int(eval(input()))\n\n    for i in range(-120, 121):\n\n        for j in range(-120, 121):\n\n            if i**5 - j**5 == x:\n\n                print((i, j))\n\n                return\n\n\n\nif __name__ == \"__main__\":\n\n    main()", "score": 0.0}
{"golden_code": "import numpy as np\n\n\n\nN = int(eval(input()))\n\nA = list(map(int, input().split()))\n\n\n\nA = np.array(A)\n\ncounter = 0\n\nwhile True:\n\n    if all( i%2==0 for i in A):\n\n        counter  += 1\n\n        A = A/2\n\n    else:\n\n        print(counter)\n\n        break", "generated_code": "n, m = list(map(int, input().split()))\n\nA = [0] * n\n\nfor i in range(m):\n\n    a, b = list(map(int, input().split()))\n\n    A[a - 1] += 1\n\n    A[b - 1] += 1\n\n    \n\nfor i in range(n):\n\n    print((A[i]))", "score": 0.0}
{"golden_code": "# C - Go to School\n\ndef main():\n\n    import numpy as np\n\n    n = int(input())\n\n    a = list(map(int, input().split()))\n\n    a = np.array(a)\n\n    a = np.argsort(a)\n\n    for i in a:\n\n        print(i+1,end=\" \")\n\n\n\nif __name__ ==  \"__main__\":\n\n    main()\n", "generated_code": "def LI(): return list(map(int,input().split()))\n\nN,D = LI()\n\nX = [LI() for _ in range(N)]\n\nans = 0\n\nfor i in range(N):\n\n    for j in range(i+1,N):\n\n        temp = 0\n\n        for k in range(D):\n\n            temp += (X[j][k]-X[i][k])**2\n\n        if temp **0.5%1==0:\n\n            ans += 1\n\nprint(ans)", "score": 0.0}
{"golden_code": "n = int(eval(input()))\n\n\n\nINF = 10**9 + 7\n\n\n\nans = [0] * (10**5 + 1)\n\nans[0] = 1\n\n\n\nfor i in range(1,10**5 + 1):\n\n    ans[i] = ans[i-1] * i % INF\n\n\n\nprint((ans[n]))\n", "generated_code": "def main():\n\n    S = eval(input())\n\n    w1 = 'dream'[::-1]\n\n    w2 = 'dreamer'[::-1]\n\n    w3 = 'erase'[::-1]\n\n    w4 = 'eraser'[::-1]\n\n    S = S[::-1]\n\n    words = [w1, w2, w3, w4]\n\n\n\n    flag = False\n\n    i = 0\n\n    while i < len(S):\n\n        for w in words:\n\n            if S[i:].startswith(w):\n\n                i += len(w)\n\n                flag = True\n\n                break\n\n\n\n        if not flag:\n\n            print(\"NO\")\n\n            exit()\n\n        flag = False\n\n\n\n    print(\"YES\")\n\n\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()", "score": 0.0}
{"golden_code": "import numpy as np\n\nn,d=list(map(int,input().split()))\n\nnda=np.empty((0,d),int)\n\nans=0\n\nfor i in range(0,n):\n\n  a=np.array([list(map(int,input().split()))])\n\n  for j in range(i):\n\n    chklen=np.linalg.norm(a-nda[j])\n\n    if chklen==chklen//1:\n\n      ans+=1\n\n  nda=np.append(nda,a,axis=0)\n\nprint(ans)", "generated_code": "n,m=list(map(int,input().split()))\n\nl,r=list(map(int,input().split()))\n\nfor i in range(m-1):\n\n  tl,tr=list(map(int,input().split()))\n\n  if l<tl:\n\n    l=tl\n\n  if tr<r:\n\n    r=tr\n\nprint((max(r-l+1,0)))", "score": 0.0}
{"golden_code": "# coding: utf-8\n\n# Your code here!\n\nimport sys\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\n\n\n#a,b,c,d = map(int,readline().split())\n\ns,k = readline().split()\n\n\n\n\n\na = [len(i) for i in s.split(\"0\")]\n\nwhile a and a[-1] == 0: a.pop()\n\n\n\nif not a:\n\n    print((1))\n\n    exit()\n\n\n\nMOD = 998244353\n\n\n\nM = sum(a)+1\n\nk = min(int(k),M)\n\n\n\n\n\ndp = [[0]*M for _ in range(k+1)] # j 使って（上限 k）、l 余ってる\n\ndp[0][0] = 1\n\n\n\n#print(a)\n\nfor ai in a[::-1]:\n\n    ndp = [[0]*M for _ in range(k+1)] # j 使って（上限 k）、l 余ってる\n\n    for j in range(k+1):\n\n        for l in range(M):\n\n            for ll in range(l):\n\n                ndp[j][ll] += dp[j][l]\n\n                ndp[j][ll] %= MOD\n\n            \n\n            V = min(M-l,k-j+1,ai+1)\n\n            for i in range(V):\n\n                #if j+i > k: break\n\n                ndp[j+i][l+i] += dp[j][l]\n\n                ndp[j+i][l+i] %= MOD\n\n    \n\n    dp = ndp\n\n    #print(dp)\n\n\n\nans = 0\n\nfor jj in range(k+1):\n\n    ans += dp[jj][0]\n\n\n\nprint((ans%MOD))\n\n\n\n\n\n\n\n\n\n\n", "generated_code": "def LI(): return list(map(int,input().split()))\n\nN,D = LI()\n\nX = [LI() for _ in range(N)]\n\nans = 0\n\nfor i in range(N):\n\n    for j in range(i+1,N):\n\n        temp = 0\n\n        for k in range(D):\n\n            temp += (X[j][k]-X[i][k])**2\n\n        if temp **0.5%1==0:\n\n            ans += 1\n\nprint(ans)", "score": 0.0}
{"golden_code": "A,B = list(map(int,input().split()))\n\nj = 0\n\nfor i in range(A,B+1):\n\n  l = list(str(i))\n\n  l_reverse = list(reversed(l))\n\n  if l == l_reverse:\n\n    j += 1\n\nprint(j)", "generated_code": "# -*- coding: utf-8 -*-\n\n\n\nimport sys\n\n\n\ndef input(): return sys.stdin.readline().strip()\n\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\n\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\n\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\n\ndef ceil(x, y=1): return int(-(-x // y))\n\ndef INT(): return int(eval(input()))\n\ndef MAP(): return list(map(int, input().split()))\n\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\n\ndef Yes(): print('Yes')\n\ndef No(): print('No')\n\ndef YES(): print('YES')\n\ndef NO(): print('NO')\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = float('inf')\n\nMOD = 10 ** 9 + 7\n\n\n\ndef factorize(num: int) -> dict:\n\n    \"\"\" 素因数分解 \"\"\"\n\n    from math import sqrt\n\n    from collections import Counter\n\n\n\n    d = Counter()\n\n    # 終点はルート切り捨て+1\n\n    for i in range(2, int(sqrt(num))+1):\n\n        # 素因数分解：小さい方から割れるだけ割って素数をカウント\n\n        while num % i == 0:\n\n            num //= i\n\n            d[i] += 1\n\n        # 1まで分解したら終了\n\n        if num == 1:\n\n            break\n\n    # 最後に残ったnumは素数(ただし1^1は1^0なので数に入れない)\n\n    if num != 1:\n\n        d[num] += 1\n\n    return d\n\n\n\nclass FactInvMOD:\n\n    \"\"\" 階乗たくさん使う時用のテーブル準備 \"\"\"\n\n\n\n    def __init__(self, MAX, MOD):\n\n        \"\"\" MAX：階乗に使う数値の最大以上まで作る \"\"\"\n\n        \n\n        MAX += 1\n\n        self.MAX = MAX\n\n        self.MOD = MOD\n\n        # 階乗テーブル\n\n        factorial = [1] * MAX\n\n        factorial[0] = factorial[1] = 1\n\n        for i in range(2, MAX):\n\n            factorial[i] = factorial[i-1] * i % MOD\n\n        # 階乗の逆元テーブル\n\n        inverse = [1] * MAX\n\n        # powに第三引数入れると冪乗のmod付計算を高速にやってくれる\n\n        inverse[MAX-1] = pow(factorial[MAX-1], MOD-2, MOD)\n\n        for i in range(MAX-2, 0, -1):\n\n            # 最後から戻っていくこのループならMAX回powするより処理が速い\n\n            inverse[i] = inverse[i+1] * (i+1) % MOD\n\n        self.fact = factorial\n\n        self.inv = inverse\n\n    \n\n    def nCr(self, n, r):\n\n        \"\"\" 組み合わせの数 (必要な階乗と逆元のテーブルを事前に作っておく) \"\"\"\n\n\n\n        if n < r: return 0\n\n        # 10C7 = 10C3\n\n        r = min(r, n-r)\n\n        # 分子の計算\n\n        numerator = self.fact[n]\n\n        # 分母の計算\n\n        denominator = self.inv[r] * self.inv[n-r] % self.MOD\n\n        return numerator * denominator % self.MOD\n\n\n\n    def nPr(self, n, r):\n\n        \"\"\" 順列 \"\"\"\n\n\n\n        if n < r: return 0\n\n        return self.fact[n] * self.inv[n-r] % self.MOD\n\n\n\n    def nHr(self, n, r):\n\n        \"\"\" 重複組み合わせ \"\"\"\n\n\n\n        # r個選ぶところにN-1個の仕切りを入れる\n\n        return self.nCr(r+n-1, r)\n\n\n\nN, M = MAP()\n\n\n\nd = factorize(M)\n\n\n\n# 例外処理\n\nif not d:\n\n    print((1))\n\n    exit()\n\n\n\nMAX = N + max(d.values())\n\nfim = FactInvMOD(MAX, MOD)\n\nans = 1\n\nfor k, v in list(d.items()):\n\n    ans *= fim.nHr(N, v)\n\n    ans %= MOD\n\nprint(ans)\n", "score": 0.0}
{"golden_code": "def post_from_pre_in(preorder_elements, inorder_elements):\n\n    if preorder_elements:\n\n        global cnt\n\n        root = preorder_elements[0]\n\n        root_index = inorder_elements.index(root)\n\n        preorder_left = preorder_elements[1:root_index+1]\n\n        inorder_left = inorder_elements[:root_index]\n\n        preorder_right = preorder_elements[root_index+1:]\n\n        inorder_right = inorder_elements[root_index+1:]\n\n        post_from_pre_in(preorder_left, inorder_left)\n\n        post_from_pre_in(preorder_right, inorder_right)\n\n        if cnt:\n\n            print(root, end = ' ')\n\n            cnt -= 1\n\n        else:\n\n            print(root)\n\n\n\n\n\ncnt = int(input()) - 1\n\n\n\na = list(map(int, input().split()))\n\nb = list(map(int, input().split()))\n\n\n\npost_from_pre_in(a, b)\n", "generated_code": "while 1:\n\n    a=0\n\n    n,x=list(map(int,input().split()))\n\n    if n==0:break\n\n    for i in range(1,n-1):\n\n        for j in range(i+1,n):\n\n            c=x-i-j\n\n            if c>j and c<=n:a+=1\n\n    print(a)", "score": 0.0}
{"golden_code": "import sys\n\nimport numpy as np\n\n\n\n\n\ndef main():\n\n    h, w = list(map(int, sys.stdin.buffer.readline().split()))\n\n    n = int(sys.stdin.buffer.readline())\n\n    a = list(map(int, sys.stdin.buffer.readline().split()))\n\n    ans = np.zeros(w*h, np.int64)\n\n    now = 0\n\n    for i, x in enumerate(a):\n\n        for j in range(x):\n\n            ans[now + j] = i+1\n\n        now += x\n\n\n\n    ans = ans.reshape(h, w)\n\n    for i in range(h):\n\n        if i % 2:\n\n            print((*ans[i, ::-1]))\n\n        else:\n\n            print((*ans[i]))\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "generated_code": "from collections import deque\n\nfrom copy import deepcopy, copy\n\nN = 3\n\ndef g(i, j, a):\n\n    if i > j:\n\n        i, j = j, i\n\n    return a[:i] + a[j] + a[i + 1:j] + a[i] + a[j + 1:]\n\ndef MAIN():\n\n    m = {8:{7, 5}, 7:{8, 6, 4}, 6:{7, 3}, 5:{8, 4, 2}, 4:{7, 5, 3, 1}, 3:{6, 4, 0}, 2:{5, 1}, 1:{4, 2, 0}, 0:{3, 1}}\n\n    MAP = \"\".join(input().replace(\" \", \"\") for _ in range(N))\n\n    start = MAP.find(\"0\")\n\n    goal = \"123456780\"\n\n    dp = deque([(0, start, MAP)])\n\n    LOG = {MAP}\n\n    while dp:\n\n        cnt, yx, M = dp.popleft()\n\n        if M == goal:\n\n            print(cnt)\n\n            break\n\n        cnt += 1\n\n        for nyx in m[yx]:\n\n            CM = g(yx, nyx, M)\n\n            if not CM in LOG:\n\n                dp.append((cnt, nyx, CM))\n\n                LOG.add(CM)\n\nMAIN()\n\n\n", "score": 0.0}
{"golden_code": "a, b, c, x, y = list(map(int, input().split()))\n\n# print(a, b, c, x, y)\n\n\n\nans = 10000 * (10 **5) + 7\n\nc_max = 0\n\nif x > y:\n\n  c_max = x * 2\n\nelse:\n\n  c_max = y * 2\n\n\n\nfor cc in range(c_max+1):\n\n  ac = x - (cc // 2)\n\n  bc = y - (cc // 2)\n\n  \n\n  if ac < 0:\n\n    ac = 0\n\n  if bc < 0:\n\n    bc = 0\n\n  price = ac * a + bc * b + cc * c\n\n  # print('price: {}, ac: {}, bc: {}, cc: {}'.format(price, ac, bc, cc))\n\n  ans = min(ans, price)\n\n\n\nprint(ans)", "generated_code": "N = int(eval(input()))\n\nA = [int(i) for i in input().split()]\n\nB = [int(i) for i in input().split()]\n\n\n\ncnt = 0\n\nfor i in range(N):\n\n    if B[i] >= A[i]:\n\n        cnt += A[i]\n\n        B[i] -= A[i]\n\n    else:\n\n        cnt += B[i]\n\n        B[i] = 0\n\n    if B[i] == 0:\n\n        continue\n\n    if B[i] >= A[i+1]:\n\n        cnt += A[i+1]\n\n        A[i+1] = 0\n\n    else:\n\n        cnt += B[i]\n\n        A[i+1] -= B[i]\n\n\n\nprint(cnt)", "score": 0.0}
{"golden_code": "import numpy as np\n\nN,M=list(map(int,input().split()))\n\nA=np.zeros((N+1,M+1))\n\nA[0]=np.ones(M+1)\n\nfor i in range(1,N+1):\n\n    B=list(map(int,input().split()))\n\n    for m in range(1,B[0]+1):\n\n        A[i][B[m]]=A[i-1][B[m]]\n\na=sum(A[N])\n\nprint((int(a)))", "generated_code": "n = int(eval(input()))\n\n\n\nans = 1\n\nfor i in range(1, n+1):\n\n    ans = ans * i\n\n    ans = ans % ((10 ** 9)+7)  # 途中で割り算の余りを求めても、最終結果は同じになる\n\n\n\nprint(ans)", "score": 0.0}
{"golden_code": "n,t=int(input()),list(map(int,input().split()));T=sum(t)\n\nprint(*[T-t[i-1]+j for i,j in [list(map(int,input().split())) for _ in range(int(input()))]],sep='\\n')\n", "generated_code": "n=int(eval(input()))\n\na=list(map(int,input().split()))\n\nl=sorted([[inx+1,j] for inx,j in enumerate(a)],key=lambda x:x[1])\n\nans=[i for i,j in l]\n\nprint((*ans))", "score": 0.0}
{"golden_code": "def findSumDigit(num):\n\n    global total\n\n    total = \"\"\n\n    while num > 0:\n\n        total += str(num % 10)\n\n        num //= 10\n\n    return total\n\n\n\ndef main():\n\n    a,b = list(map(int, input().split()))\n\n    ans = 0\n\n    for i in range(a,b+1):\n\n        tmp = str(findSumDigit(i))\n\n        if tmp == str(i):\n\n            ans += 1\n\n    print(ans)\n\n\n\nif __name__ == '__main__':\n\n    main()", "generated_code": "from collections import deque\n\n\n\nn,q = list(map(int,input().split()))\n\nqueue = deque()\n\nfor i in range(n):\n\n\tname,time = input().split()\n\n\tqueue.append((name, int(time)))\n\n\n\nt = 0\n\nwhile queue:\n\n\tname,time = queue.popleft()\n\n\tt += min(q, time)\n\n\tif time > q:\n\n\t\tqueue.append((name, time-q))\n\n\telse:\n\n\t\tprint((name,t))\n", "score": 0.0}
{"golden_code": "from itertools import combinations\n\nimport numpy as np\n\nN = int(eval(input()))\n\nD = list(map(int, input().split()))\n\nList = np.array(list(combinations(D,2)))\n\nprint((sum(np.product(List, axis = 1))))\n\n\n\n\n", "generated_code": "n,k=list(map(int,input().split()))\n\n*a,= list(map(int,input().split()))\n\n*f,= list(map(int,input().split()))\n\na=sorted(a)\n\nf=sorted(f, reverse=True)\n\n\n\ndef is_ok(arg):\n\n    cnt=0\n\n    for i in range(n):\n\n        cnt+=max(a[i]-arg//f[i], 0)\n\n    return cnt<=k\n\n\n\ndef meguru_bisect(ng, ok):\n\n    while (abs(ok - ng) > 1):\n\n        mid = (ok + ng) // 2\n\n        if is_ok(mid):\n\n            ok = mid\n\n        else:\n\n            ng = mid\n\n    return ok\n\n\n\nprint((meguru_bisect(-1, 10**12)))", "score": 0.0}
{"golden_code": "import sys\n\nsys.setrecursionlimit(10**6)\n\ndef dfs(v,p,d):\n\n    for i, j in tree[v]:\n\n        if i != p:\n\n            depth[i] = d + j\n\n            dfs(i,v,d+j)\n\n\n\nN = int(eval(input()))\n\n\n\ntree = [[] for _ in range(N)]\n\n\n\nfor i in range(N-1):\n\n    a, b, c = list(map(int, input().split()))\n\n    a -= 1\n\n    b -= 1\n\n    tree[a].append((b,c))\n\n    tree[b].append((a,c))\n\n\n\nQ, K = list(map(int, input().split()))\n\n\n\ndepth = [0 for i in range(N)]\n\ndepth[K-1] = 0\n\n\n\ndfs(K-1,-1,0)\n\n\n\nfor _ in range(Q):\n\n    x, y = list(map(int, input().split()))\n\n    print((depth[x-1] + depth[y-1]))", "generated_code": "N = int(eval(input()))\n\np = 1\n\nfor i in range(1,N+1):\n\n    p *= i\n\n    p %= 1000000007\n\nprint(p)\n", "score": 0.0}
{"golden_code": "mod = 2019\n\nl, r = list(map(int, input().split()))\n\n\n\nif r//mod - l//mod > 0:\n\n  print((0))\n\nelse:\n\n  l %= mod\n\n  r %= mod\n\n  ans = mod\n\n  for i in range(l+1, r+1):\n\n    for j in range(l, i):\n\n      ans = min(i*j%mod, ans)\n\n    if ans == 0:\n\n      break\n\n  print(ans)", "generated_code": "postorder_elements = []\n\n\n\ndef post_from_pre_in(preorder_elements, inorder_elements):\n\n    if preorder_elements:\n\n        root = preorder_elements[0]\n\n        root_index = inorder_elements.index(root)\n\n        preorder_left = preorder_elements[1:root_index+1]\n\n        inorder_left = inorder_elements[:root_index]\n\n        preorder_right = preorder_elements[root_index+1:]\n\n        inorder_right = inorder_elements[root_index+1:]\n\n        post_from_pre_in(preorder_left, inorder_left)\n\n        post_from_pre_in(preorder_right, inorder_right)\n\n        postorder_elements.append(root)\n\n\n\n\n\n\n\nn = int(eval(input()))\n\n\n\na = list(map(int, input().split()))\n\nb = list(map(int, input().split()))\n\n\n\npost_from_pre_in(a, b)\n\n\n\nprint((*postorder_elements))", "score": 0.0}
{"golden_code": "H,W = list(map(int,input().split()))\n\nN = int(eval(input()))\n\nA = list(map(int,input().split()))\n\nA.insert(0,0)\n\nC = [[0 for _ in range(W)] for _ in range(H)]\n\ncur = [0,0,\"R\"]\n\nfor k in range(1,N+1):\n\n#     ipdb.set_trace()\n\n    a = A[k]\n\n    cnt = 0\n\n    y,x,d = cur\n\n    for i in range(y,H):\n\n        y = i\n\n        if d==\"R\":\n\n            for j in range(x,W):\n\n                C[i][j]=str(k)\n\n                cnt += 1\n\n                if j+1<W:\n\n                    x = j+1\n\n                else:\n\n                    x = j\n\n                if cnt==a:break\n\n            if cnt==a:break\n\n            d=\"L\"\n\n        else:\n\n            for j in range(x,-1,-1):\n\n                C[i][j]=str(k)\n\n                cnt += 1\n\n                if j>=1:\n\n                    x = j-1\n\n                else:\n\n                    x = 0\n\n                if cnt==a:break\n\n            if cnt==a:break\n\n            d=\"R\"\n\n    if x==W-1:\n\n        if C[y][x]!=0:\n\n            y += 1\n\n            d=\"L\"\n\n    elif x==0:\n\n        if C[y][x]!=0:\n\n            y += 1\n\n            d=\"R\"\n\n    cur = [y,x,d]                \n\nfor i in range(H):\n\n    print((*C[i]))", "generated_code": "n=int(eval(input()))\n\na=[list(map(int,input().split()))for _ in range(n)]\n\ndef f():\n\n for i in range(n-1):\n\n  d=a[i][:];d[3],d[4]=d[4],d[3]\n\n  for j in range(i+1,n):\n\n   e=a[j][:];e[3],e[4]=e[4],e[3]\n\n   for p in('012345','152043','215304','302541','410352','514320'):\n\n    f=[d[int(k)]for k in p]\n\n    g=f[1:5]*2\n\n    for k in range(4):\n\n     if g[k:k+4]==e[1:5]:\n\n      if f[0]==e[0]:\n\n       if f[5]==e[5]:return 'No'\n\n return 'Yes'\n\nprint((f()))\n", "score": 0.0}
{"golden_code": "X,Y,Z,K = list(map(int,input().split()))\n\nA = list(map(int,input().split()))\n\nB = list(map(int,input().split()))\n\nC = list(map(int,input().split()))\n\nasort,bsort,csort = sorted(A,reverse=True),sorted(B,reverse=True),sorted(C,reverse=True)\n\nprint((asort[0] + bsort[0] + csort[0]))\n\nalready = [[0,0,0]]\n\nx,y,z = 0,0,0\n\nplace_sum = []\n\ncheck = []\n\nfor k in range(K - 1):\n\n    if [x + 1,y,z] not in already and x + 1 < X:\n\n        already.append([x + 1,y,z])\n\n        place_sum.append([x + 1,y,z])\n\n        check.append(asort[x + 1] + bsort[y] + csort[z])\n\n    if [x,y + 1,z] not in already and y + 1 < Y:\n\n        already.append([x,y + 1,z])\n\n        place_sum.append([x,y + 1,z])\n\n        check.append(asort[x] + bsort[y + 1] + csort[z])\n\n    if [x,y,z + 1] not in already and z + 1 < Z:\n\n        already.append([x,y,z + 1])\n\n        place_sum.append([x,y,z + 1])\n\n        check.append(asort[x] + bsort[y] + csort[z + 1])\n\n    print((max(check)))\n\n    x,y,z = place_sum[check.index(max(check))][0],place_sum[check.index(max(check))][1],place_sum[check.index(max(check))][2]\n\n    place_sum.pop(check.index(max(check)))\n\n    check.remove(max(check))", "generated_code": "def main():\n\n    x = int(eval(input()))\n\n    for i in range(-120, 121):\n\n        for j in range(-120, 121):\n\n            if i**5 - j**5 == x:\n\n                print((i, j))\n\n                return\n\n\n\nif __name__ == \"__main__\":\n\n    main()", "score": 0.0}
{"golden_code": "import numpy as np\n\n\n\nS=eval(input())\n\nS=np.array([1 if s=='B' else 0 for s in S])\n\n\n\nprint((np.abs(np.diff(S)).sum()))\n", "generated_code": "import sys\n\ninput = sys.stdin.readline\n\nsys.setrecursionlimit(10**7)\n\nINF = 10**10\n\nMOD = 10**9 + 7\n\nX = int(eval(input()))\n\nMAX_X = 10**9\n\nn = 0\n\nwhile(1):\n\n    n+=1\n\n    if n**5 - (n-1)**5 > MAX_X:\n\n        break\n\nfor i in range(n):\n\n    for j in range(-n+1,n-1):\n\n        if i**5 - j**5 == X:\n\n            print((i,j))\n\n            exit()\n\n   ", "score": 0.0}
{"golden_code": "while 1:\n\n    ans=0\n\n    n,x=list(map(int,input().split()))\n\n    if n:\n\n        for i in range(1,n-1):\n\n            for j in range(i+1,n):\n\n                for k in range(j+1,n+1):\n\n                    if i+j+k==x:ans+=1\n\n    else:break\n\n    print(ans)", "generated_code": "import math\n\nn,d=list(map(int,input().split()))\n\na=[0]*n\n\nfor i in range(n):\n\n  a[i]=list(map(int,input().split()))\n\nans=0\n\nfor i in range(n-1):\n\n  for j in range(i+1,n):\n\n    chklen=0\n\n    wk=0\n\n    for k in range(d):\n\n      wk+=abs(a[i][k]-a[j][k])**2\n\n    chklen=math.sqrt(wk)\n\n    if chklen==chklen//1:\n\n      ans+=1\n\nprint(ans)", "score": 0.0}
{"golden_code": "import sys\n\nimport numpy as np\n\n\n\nx, y, z, k = map(int, sys.stdin.readline().split())\n\na, b, c = (np.array(sys.stdin.readline().split(), dtype=np.int64) for _ in range(3))\n\n\n\ndef main():\n\n    res = np.sort(np.ravel(a[:, None] + b))[::-1]\n\n    res = np.sort(np.ravel(c[:, None] + res[:min(k, x*y)]))[::-1]\n\n    return res[:k]\n\n\n\nif __name__ == '__main__':\n\n    ans = main()\n\n    print(*ans, sep='\\n')\n", "generated_code": "n = int(eval(input()))\n\n\n\nans = 1\n\nfor i in range(1, n+1):\n\n    ans = ans * i\n\n    ans = ans % ((10 ** 9)+7)  # 途中で割り算の余りを求めても、最終結果は同じになる\n\n\n\nprint(ans)", "score": 0.0}
{"golden_code": "K = int(eval(input()))\n\n\n\nflg = [False]*K\n\n\n\ntmp = 7 % K\n\ncnt = 1\n\nif tmp == 0:\n\n    print(cnt)\n\n    exit()\n\nwhile True:\n\n    tmp = (tmp*10+7)%K\n\n    if flg[tmp]:\n\n        print((-1))\n\n        break\n\n    else:\n\n        cnt += 1\n\n        if tmp == 0:\n\n            print(cnt)\n\n            break\n\n        flg[tmp] = True\n", "generated_code": "import sys\n\nreadline = sys.stdin.readline\n\nsys.setrecursionlimit(10**8)\n\nmod = 10**9+7\n\n#mod = 998244353\n\nINF = 10**18\n\neps = 10**-7\n\n\n\nm,n,k = list(map(int,readline().split()))\n\n\n\ndef comb(n, r, mod):\n\n    r = min(r, n-r)\n\n    mol = 1\n\n    deno = 1\n\n    for i in range(1, r+1):\n\n        mol = mol * (n-r+i) % mod\n\n        deno = deno * i % mod\n\n    ret = mol * pow(deno, mod-2, mod) % mod\n\n    return ret\n\n\n\ndef f1(x,y,a,b):\n\n    return (a+b-x-y)*(a-x+1)*(b-y+1)//2\n\n\n\ndef f2(x,a):\n\n    return (a-x)*(a-x+1)//2\n\n\n\nans = 0\n\n\n\nfor x in range(1,n+1):\n\n    for y in range(1,m+1):\n\n        a = n-x+1\n\n        b = m-y+1\n\n        c = m*(a*(a-1)+x*(x-1))\n\n        d = n*(b*(b-1)+y*(y-1))\n\n        ans += (c+d)//2\n\n        ans %= mod\n\n\n\nans = (ans * comb(m*n-2,k-2,mod))%mod\n\nans = ans*pow(2,mod-2,mod)%mod\n\n\n\nprint(ans)\n\n\n", "score": 0.0}
{"golden_code": "import numpy as np\n\nimport numba\n\nfrom numba import njit, b1, i4, i8, f8\n\n\n\n@njit((i8, i8[:]), cache=True)\n\ndef main(N,A):\n\n  Amax = np.max(A)\n\n  lis = np.zeros(Amax+1, np.int64)\n\n  for i in range(N):\n\n    lis[A[i]] += 1\n\n  setwise = False\n\n  for t in range(2,Amax+1):\n\n    cnt = np.sum(lis[t:Amax+1:t])\n\n    if cnt==N:\n\n      return 'not'\n\n    if 2<=cnt<N:\n\n      setwise=True\n\n  if setwise==True:\n\n    return 'setwise'\n\n  return 'pairwise'\n\n\n\nN = int(eval(input()))\n\nA = np.array(list(map(int, input().split())))\n\nprint((main(N,A)+' coprime'))\n\n\n", "generated_code": "import sys\n\nfrom collections import Counter\n\nN = int(sys.stdin.readline())\n\nS = sys.stdin.read().split()\n\n\n\ncount = Counter(S)\n\nmax_num = max(count.values())\n\nmax_list = [i for i,j in list(count.items()) if j==max_num]\n\n \n\nmax_list.sort()\n\nprint(('\\n'.join(max_list)))", "score": 0.0}
{"golden_code": "import numpy as np\n\nN = int(eval(input()))\n\n\n\nabc = np.array([list(map(int, input().split())) for i in range(N)])\n\n\n\ndp = [[0]*3 for i in range(N+1)]\n\n\n\nfor i in range(1, N+1):\n\n    dp[i][0] = max(dp[i - 1][1] + abc[i - 1][1], dp[i - 1][2] + abc[i - 1][2])\n\n    dp[i][1] = max(dp[i - 1][0] + abc[i - 1][0], dp[i - 1][2] + abc[i - 1][2])\n\n    dp[i][2] = max(dp[i - 1][1] + abc[i - 1][1], dp[i - 1][0] + abc[i - 1][0])\n\n\n\nprint((max(dp[-1])))\n", "generated_code": "H,W = list(map(int,input().split()))\n\nN = int(eval(input()))\n\nA = list(map(int,input().split()))\n\nA.insert(0,0)\n\nB = [[0 for _ in range(W)] for _ in range(H)]\n\ncol = 1\n\ncnt = 0\n\ny = 0\n\nx = 0\n\nd = \"R\"\n\nwhile y<H:\n\n    if cnt<A[col]:\n\n        B[y][x] = col\n\n        cnt += 1\n\n    else:\n\n        col += 1\n\n        cnt = 0\n\n        B[y][x] = col\n\n        cnt += 1\n\n    if x<W-1 and d==\"R\":\n\n        x += 1\n\n    elif x==W-1 and d==\"R\":\n\n        y += 1\n\n        d = \"L\"\n\n    elif d==\"L\" and x>0:\n\n        x -= 1\n\n    elif d==\"L\" and x==0:\n\n        y += 1\n\n        d = \"R\"\n\nfor i in range(H):\n\n    print((*B[i]))", "score": 0.0}
{"golden_code": "import math\n\nN = int(eval(input()))\n\nans = math.factorial(N) % (10 ** 9 + 7)\n\nprint(ans)", "generated_code": "import sys\n\ninput = sys.stdin.readline\n\n\n\nmod = 998244353\n\nN = int(eval(input()))\n\nX = []\n\nfor _ in range(N):\n\n    x, d = list(map(int, input().split()))\n\n    X.append((x, x + d))\n\n\n\nX = sorted(X, key = lambda x: x[0])\n\nL = [(0, -(10**9+1), 10**9+1)]\n\nP = [-1] * (N+1)\n\nfor i, (x, y) in enumerate(X):\n\n    while L[-1][2] <= y:\n\n        if L[-1][2] > x and P[i+1] < 0:\n\n            P[i+1] = L[-1][0]\n\n        L.pop()\n\n    if P[i+1] < 0:\n\n        P[i+1] = L[-1][0]\n\n    L.append((i+1, x, y))\n\n\n\nC = [[] for _ in range(N+1)]\n\nfor i, p in enumerate(P):\n\n    if p >= 0:\n\n        C[p].append(i)\n\n\n\nY = [1] * (N+1)\n\nfor i in range(N+1)[::-1]:\n\n    s = 1\n\n    for j in C[i]:\n\n        s = s * (Y[j] + 1) % mod\n\n    Y[i] = s\n\n\n\nprint((Y[0]))", "score": 0.0}
{"golden_code": "import numpy as np\n\nn = int(eval(input()))\n\nballs = np.array(list(map(int, input().split())))\n\ntime = 0\n\nwhile np.all(balls % 2 == 0) and np.all(balls > 0):\n\n    time += 1\n\n    balls = balls / 2\n\nprint(time)", "generated_code": "a,b = list(map(int, input().split()))\n\nn = [i for i in map(str, list(range(a,b+1))) if i==i[::-1]]\n\nprint((len(n)))", "score": 0.0}
{"golden_code": "import math\n\nn=int(eval(input()))\n\nans=n\n\ni=1\n\nwhile(i<=math.sqrt(n)):\n\n    if n%i==0:\n\n        d=i+n/i-2\n\n        ans=min(ans,d)\n\n    i+=1\n\nprint((int(ans)))", "generated_code": "n = int(eval(input()))\n\n\n\nans = 1\n\nfor i in range(1, n+1):\n\n    ans = ans * i\n\n    ans = ans % ((10 ** 9)+7)  # 途中で割り算の余りを求めても、最終結果は同じになる\n\n\n\nprint(ans)", "score": 0.0}
{"golden_code": "def main():\n\n    n = int(eval(input()))\n\n    import numpy as np\n\n    ans = np.zeros((10,10))\n\n    for i in range(1,n+1):\n\n        h,t = str(i)[0],str(i)[-1]\n\n        ans[int(h)-1][int(t)-1]+=1\n\n    s = 0\n\n    for i in range(10):\n\n        for j in range(10):\n\n            s += ans[i][j]*ans[j][i]\n\n\n\n    print((int(s)))\n\nif __name__ == \"__main__\":\n\n    main()", "generated_code": "N = int(eval(input()))\n\nD = list(map(int, input().split()))\n\nfrom itertools import accumulate\n\nprint((sum(list(d*c for d, c in zip(D[1:], accumulate(D))))))\n", "score": 0.0}
{"golden_code": "import numpy\n\nN, D = list(map(int, input().split()))\n\nlistx = []\n\ncount = 0\n\nfor i in range(N):\n\n    x = list(map(int, input().split()))\n\n    listx.append(x)\n\n\n\nfor j in range(0, N):\n\n    for k in range(j+1,N):\n\n        a = numpy.array(listx[j])\n\n        b = numpy.array(listx[k])\n\n        u = b - a\n\n        c = float(numpy.linalg.norm(u))\n\n        if c.is_integer() :\n\n            count += 1\n\nprint(count)", "generated_code": "import sys\n\n\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\nreadlines = sys.stdin.readlines\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = 1 << 60\n\nMOD = 1000000007\n\n\n\n\n\nclass BIT:\n\n    def __init__(self, n):\n\n        self.n = n\n\n        self.data = [0] * (n + 1)\n\n\n\n    def add(self, i, x=1):\n\n        i += 1\n\n        while i <= self.n:\n\n            self.data[i] += x\n\n            i += i & -i\n\n\n\n    def get_sum(self, i):\n\n        i += 1\n\n        x = 0\n\n        while i > 0:\n\n            x += self.data[i]\n\n            i -= i & -i\n\n        return x\n\n\n\n    # Return sum for [l, r)\n\n    def get_sum_range(self, l, r):\n\n        return self.get_sum(r - 1) - self.get_sum(l - 1)\n\n\n\n\n\ndef main():\n\n    N, Q = map(int, readline().split())\n\n    C = list(map(int, readline().split()))\n\n    LR = map(int, read().split())\n\n\n\n    prev = [-1] * (N + 1)\n\n    ps = [[] for _ in range(N)]\n\n    for i, c in enumerate(C):\n\n        if prev[c] != -1:\n\n            ps[prev[c]].append(i)\n\n        prev[c] = i\n\n\n\n    qs = [[] for _ in range(N + 1)]\n\n    for i, (l, r) in enumerate(zip(*[iter(LR)] * 2)):\n\n        l -= 1\n\n        r -= 1\n\n        qs[l].append((r, i))\n\n\n\n    ans = [0] * Q\n\n    bit = BIT(N)\n\n\n\n    for l in range(N - 1, -1, -1):\n\n        for r in ps[l]:\n\n            bit.add(r)\n\n        for r, i in qs[l]:\n\n            ans[i] = (r - l + 1) - bit.get_sum(r)\n\n\n\n    print(*ans, sep='\\n')\n\n\n\n    return\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 0.0}
{"golden_code": "import sys\n\n\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\nreadlines = sys.stdin.readlines\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = 1 << 60\n\nMOD = 1000000007\n\n\n\n# Reference: https://www.geeksforgeeks.org/queries-number-distinct-elements-subarray/\n\n# Python3 code to find number of\n\n# distinct numbers in a subarray\n\nMAX = 1000001\n\n\n\n# structure to store queries\n\nclass Query:\n\n    def __init__(self, l, r, idx):\n\n        self.l = l\n\n        self.r = r\n\n        self.idx = idx\n\n\n\n\n\n# updating the bit array\n\ndef update(idx, val, bit, n):\n\n    while idx <= n:\n\n        bit[idx] += val\n\n        idx += idx & -idx\n\n\n\n\n\n# querying the bit array\n\ndef query(idx, bit, n):\n\n    summ = 0\n\n    while idx:\n\n        summ += bit[idx]\n\n        idx -= idx & -idx\n\n    return summ\n\n\n\n\n\ndef answeringQueries(arr, n, queries, q):\n\n\n\n    # initialising bit array\n\n    bit = [0] * (n + 1)\n\n\n\n    # holds the rightmost index of\n\n    # any number as numbers of a[i]\n\n    # are less than or equal to 10^6\n\n    last_visit = [-1] * MAX\n\n\n\n    # answer for each query\n\n    ans = [0] * q\n\n\n\n    query_counter = 0\n\n    for i in range(n):\n\n\n\n        # If last visit is not -1 update -1 at the\n\n        # idx equal to last_visit[arr[i]]\n\n        if last_visit[arr[i]] != -1:\n\n            update(last_visit[arr[i]] + 1, -1, bit, n)\n\n\n\n        # Setting last_visit[arr[i]] as i and\n\n        # updating the bit array accordingly\n\n        last_visit[arr[i]] = i\n\n        update(i + 1, 1, bit, n)\n\n\n\n        # If i is equal to r of any query store answer\n\n        # for that query in ans[]\n\n        while query_counter < q and queries[query_counter].r == i:\n\n            ans[queries[query_counter].idx] = query(queries[query_counter].r + 1, bit, n) - query(\n\n                queries[query_counter].l, bit, n\n\n            )\n\n            query_counter += 1\n\n\n\n    # print answer for each query\n\n    for i in range(q):\n\n        print((ans[i]))\n\n\n\n\n\n# This code is contributed by\n\n# sanjeev2552\n\n\n\n\n\ndef main():\n\n    N, Q = list(map(int, readline().split()))\n\n    C = list(map(int, readline().split()))\n\n    (*LR,) = list(map(int, read().split()))\n\n\n\n    queries = [0] * Q\n\n    for i, (l, r) in enumerate(zip(*[iter(LR)] * 2)):\n\n        queries[i] = Query(l - 1, r - 1, i)\n\n\n\n    queries.sort(key=lambda x: x.r)\n\n    answeringQueries(C, N, queries, Q)\n\n\n\n    return\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n\n\n", "generated_code": "def digit_sum(n):\n\n    # 各桁の和を求める\n\n    # 計算量: O(logN)\n\n    ans = 0\n\n    while n > 0:\n\n        ans += 1\n\n        n //= 10\n\n    return ans\n\n\n\nn = int(eval(input()))\n\ncnt = 0\n\n\n\nfor i in range(1, n+1):\n\n    cnt += digit_sum(i) % 2\n\n\n\nprint(cnt)\n", "score": 0.0}
{"golden_code": "def popcount(x):\n\n  r = 0\n\n  while x:\n\n    if x & 1:\n\n      r += 1\n\n    x >>= 1\n\n  return r\n\n\n\nn = int(eval(input()))\n\nr = list(range(n))\n\na = [[0, 0] for _ in r]\n\nfor i in r:\n\n  for _ in range(int(eval(input()))):\n\n    x, y = list(map(int, input().split()))\n\n    a[i][y] |= 1 << (x - 1)\n\n\n\nm = 0\n\nl = (1 << n) - 1\n\nfor x in range(1, l + 1):\n\n  if all(a[i][0] & x == a[i][1] & l - x == 0 for i in r if x >> i & 1):\n\n    m = max(m, popcount(x))\n\nprint(m)\n", "generated_code": "N = int(eval(input()))\n\nV = [int(i) for i in input().split(\" \")]\n\nC = [int(i) for i in input().split(\" \")]\n\n\n\nval = 0\n\n\n\nfor i in range(N):\n\n    vc=V[i]-C[i]\n\n    if vc>0:\n\n        val+=vc\n\nprint(val)", "score": 0.0}
{"golden_code": "N = int(eval(input()))\n\ncount = [[0 for _ in range(9)] for _ in range(9)]\n\nfor i in range(1, N + 1):\n\n    if str(i)[0] != \"0\" and str(i)[-1] != \"0\":\n\n        count[int(str(i)[0]) - 1][int(str(i)[-1]) - 1] += 1\n\nans = 0\n\nfor i in range(0, 9):\n\n    for k in range(0, 9):\n\n        ans += count[i][k] * count[k][i]\n\nprint(ans)", "generated_code": "K = int(eval(input()))\n\nt = 7\n\nt %= K\n\n\n\nfor i in range(K+1):\n\n    if t == 0:\n\n        print((i+1))\n\n        exit()\n\n    t = (t*10+7)%K\n\nprint((-1))\n", "score": 0.0}
{"golden_code": "import numpy as np\n\n\n\nh, w = map(int, input().split())\n\nal = list(list(input()) for _ in range(h))\n\nal_n = np.array(al)\n\nrow = [0]*w\n\ncol = [0]*h\n\nfor i in range(h):\n\n    for j in range(w):\n\n        if al_n[i][j] == '.':\n\n            row[j] += 1\n\n            col[i] += 1\n\nrow_ = []\n\ncol_ = []\n\nfor i in range(w):\n\n    if row[i] == h:\n\n        row_.append(i)\n\n\n\nfor j in range(h):\n\n    if col[j] == w:\n\n        col_.append(j)\n\n\n\nif len(col_) > 0:\n\n    al_n = np.delete(al_n, col_, axis=0)\n\n\n\nif len(row_) > 0:\n\n    al_n = np.delete(al_n, row_, axis=1)\n\n\n\nfor a in al_n:\n\n    print(*a, sep='')\n", "generated_code": "import statistics\n\nn = int(eval(input()))\n\nal = list(map(int,input().split()))\n\n\n\nfor i in range(n):\n\n    al[i] -= i + 1\n\n\n\nmedian = statistics.median(al)\n\n\n\nans = 0\n\nfor a in al:\n\n    ans += abs(median - a)\n\n\n\nprint((int(ans)))\n", "score": 0.0}
{"golden_code": "import numpy as np\n\nN, K= list(map(int, input().split()))\n\nA=[int(i) for i in input().split()]\n\nF=[int(i) for i in input().split()]\n\n\n\nA=np.array(sorted(A, reverse=True))\n\nF=np.array(sorted(F))\n\n\n\nlower_bound=0\n\nupper_bound=np.max(A*F)\n\nK_tmp=0\n\n\n\nwhile upper_bound>=lower_bound:\n\n    mid=(lower_bound+upper_bound)//2\n\n    K_tmp=np.sum(np.maximum(A-mid//F, 0))\n\n    if K_tmp<=K:\n\n        upper_bound=mid-1\n\n    else:\n\n        lower_bound=mid+1\n\n\n\nprint(lower_bound)", "generated_code": "N = int(eval(input()))\n\nA = [int(i) for i in input().split()]\n\nB = [int(i) for i in input().split()]\n\n\n\ncnt = 0\n\nfor i in range(N):\n\n    if B[i] >= A[i]:\n\n        cnt += A[i]\n\n        B[i] -= A[i]\n\n    else:\n\n        cnt += B[i]\n\n        B[i] = 0\n\n    if B[i] == 0:\n\n        continue\n\n    if B[i] >= A[i+1]:\n\n        cnt += A[i+1]\n\n        A[i+1] = 0\n\n    else:\n\n        cnt += B[i]\n\n        A[i+1] -= B[i]\n\n\n\nprint(cnt)", "score": 0.0}
{"golden_code": "from scipy.sparse.csgraph import floyd_warshall\n\n\n\nn,m=list(map(int,input().split()))\n\nl=[list(map(int,input().split())) for i in range(m)]\n\n\n\nans=0\n\nfor i in range(m):\n\n    ll=l[:i]+l[i+1:]\n\n\n\n    d=[[float('inf')]*n for i in range(n)]\n\n    for i in range(n):\n\n        d[i][i]=0\n\n\n\n    for j in ll:\n\n        d[j[0]-1][j[1]-1]=1\n\n        d[j[1]-1][j[0]-1]=1\n\n\n\n    d=floyd_warshall(d)\n\n\n\n    if float('inf') in d:\n\n        ans+=1\n\n\n\nprint(ans)", "generated_code": "from collections import deque\n\n\n\nn,q = list(map(int,input().split()))\n\nqueue = deque()\n\nfor i in range(n):\n\n\tname,time = input().split()\n\n\tqueue.append((name, int(time)))\n\n\n\nt = 0\n\nwhile queue:\n\n\tname,time = queue.popleft()\n\n\tt += min(q, time)\n\n\tif time > q:\n\n\t\tqueue.append((name, time-q))\n\n\telse:\n\n\t\tprint((name,t))\n", "score": 0.0}
{"golden_code": "n,m=list(map(int,input().split()))\n\nc=[0]*(n+2)\n\nfor i in range(m):\n\n  l,r=list(map(int,input().split()))\n\n  c[l-1]+=1\n\n  c[r]-=1\n\nfor i in range(1,n+2):\n\n  c[i]=c[i]+c[i-1]\n\nans=0\n\nfor i in range(n+2):\n\n  if c[i]==m:\n\n    ans+=1\n\nprint(ans)", "generated_code": "N,K=list(map(int,input().split()))\n\na = [[0 for n in range(N)] for k in range(K)]\n\n\n\nfor k in range(K):\n\n    d=int(eval(input()))\n\n    have_k=list(map(int,input().split()))\n\n    for h in have_k:\n\n        a[k][h-1]=1\n\n\n\nan=[0]*N\n\nfor k in range(K):\n\n  for n in range(N):\n\n    an[n] = an[n]+a[k][n]\n\n\n\nresult=0\n\nfor i in an:\n\n  if i == 0:\n\n    result+=1\n\n\n\nprint(result)", "score": 0.0}
{"golden_code": "import sys\n\nsys.setrecursionlimit(100000)\n\n\n\ndef intinput(): return list(map(int,sys.stdin.readline().split()))\n\n\n\nfib={0:0,1:1,2:1}\n\nfor i in range(3,100003):\n\n    fib[i]=fib[i-1]+fib[i-2]\n\n  #  fib.append(fib[i-1]+fib[i-2])\n\n\n\nn,m=intinput()\n\nmod=10**9+7\n\na=[int(sys.stdin.readline()) for _ in range(m)]\n\nif m!=0:\n\n    l=[a[0]]\n\n    for i in range(len(a)-1):\n\n        l.append(a[i+1]-a[i]-1)\n\n    l.append(n-a[-1])\n\n    k=1\n\n    for i in l:\n\n        k=fib[i]*k%mod\n\n    print((k%mod))\n\nelse:\n\n    print((fib[n+1]%mod))", "generated_code": "# coding: utf-8\n\n# Your code here!\n\nimport sys\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\n\n\n#a,b,c,d = map(int,readline().split())\n\ns,k = readline().split()\n\n\n\n\n\na = [len(i) for i in s.split(\"0\")]\n\nwhile a and a[-1] == 0: a.pop()\n\n\n\nif not a:\n\n    print((1))\n\n    exit()\n\n\n\nMOD = 998244353\n\n\n\nM = sum(a)+1\n\nk = min(int(k),M)\n\n\n\n\n\ndp = [[0]*M for _ in range(k+1)] # j 使って（上限 k）、l 余ってる\n\ndp[0][0] = 1\n\n\n\n#print(a)\n\nfor ai in a[::-1]:\n\n    ndp = [[0]*M for _ in range(k+1)] # j 使って（上限 k）、l 余ってる\n\n    for j in range(k+1):\n\n        for l in range(M):\n\n            if dp[j][l]:\n\n                for ll in range(l):\n\n                    ndp[j][ll] += dp[j][l]\n\n                    ndp[j][ll] %= MOD\n\n\n\n                V = min(M-l,k-j+1,ai+1)\n\n                for i in range(V):\n\n                    #if j+i > k: break\n\n                    ndp[j+i][l+i] += dp[j][l]\n\n                    ndp[j+i][l+i] %= MOD\n\n    \n\n    dp = ndp\n\n    #print(dp)\n\n\n\nans = 0\n\nfor jj in range(k+1):\n\n    ans += dp[jj][0]\n\n\n\nprint((ans%MOD))\n\n\n\n\n\n\n\n\n\n\n", "score": 0.0}
{"golden_code": "from scipy.sparse.csgraph import csgraph_from_dense, floyd_warshall\n\n\n\nINF = float('inf')\n\n\n\ndef sol():\n\n    N, M = list(map(int, input().split()))\n\n\n\n    edges = []\n\n\n\n    for _ in range(M):\n\n        fr, to, cost = list(map(int, input().split()))\n\n        fr -= 1\n\n        to -= 1\n\n        edges.append((fr, to, cost))\n\n\n\n    graph = [[INF] * N for _ in range(N)]\n\n    for fr, to, cost in edges:\n\n        graph[fr][to] = cost\n\n\n\n    graph = csgraph_from_dense(graph, null_value=INF)\n\n\n\n    dist = floyd_warshall(graph, directed=False)\n\n    ans = (graph > dist).sum()\n\n    print(ans)\n\n\n\nsol()", "generated_code": "nDays = int(eval(input()))\n\n\n\ntoday = [int(x) for x in input().split()]\n\n\n\nfor i in range(nDays - 1):\n\n    tomorrow = [int(x) for x in input().split()]\n\n    tomorrow[0] += max(today[1], today[2])\n\n    tomorrow[1] += max(today[0], today[2])\n\n    tomorrow[2] += max(today[0], today[1])\n\n    today = tomorrow\n\n\n\nprint((max(today)))", "score": 0.0}
{"golden_code": "import numpy as np\n\nN_1=list(map(int, input().split()))\n\nN_2=list(map(int, input().split()))\n\nN_3=list(map(int, input().split()))\n\nN=int(eval(input()))\n\na=[int(eval(input())) for i in range(N)]\n\n\n\nn=np.array([N_1,N_2,N_3])\n\n\n\nfor a_n in a:\n\n    if a_n in n:\n\n        n[n==a_n]=0\n\n    else:\n\n        pass\n\ni=0\n\n    \n\nif np.all(n[0:,0]==0)==True:\n\n    i=+1\n\n    \n\nelif np.all(n[0:,1]==0)==True:\n\n    i+=1\n\n    \n\nelif np.all(n[0:,2]==0)==True:\n\n    i+=1\n\n    \n\nelif np.all(n[0,0:]==0)==True:\n\n    i+=1\n\n    \n\nelif np.all(n[1,0:]==0)==True:\n\n    i+=1\n\n\n\nelif np.all(n[2,0:]==0)==True:\n\n    i+=1\n\n\n\nelif n[0,0]==0 and n[1,1]==0  and n[2,2] ==0:\n\n    i+=1\n\n    \n\nelif n[0,2]==0 and n[1,1]==0 and n[2,0] ==0:\n\n    i+=1\n\n    \n\nif i>0:\n\n    print(\"Yes\")\n\nelse:\n\n    print(\"No\")", "generated_code": "import sys\n\nread = sys.stdin.readline\n\n\n\n\n\ndef read_ints():\n\n    return list(map(int, read().split()))\n\n\n\n\n\ndef read_a_int():\n\n    return int(read())\n\n\n\n\n\ndef read_matrix(H):\n\n    '''\n\n    H is number of rows\n\n    '''\n\n    return [list(map(int, read().split())) for _ in range(H)]\n\n\n\n\n\ndef read_map(H):\n\n    '''\n\n    H is number of rows\n\n    文字列で与えられた盤面を読み取る用\n\n    '''\n\n    return [read()[:-1] for _ in range(H)]\n\n\n\n\n\ndef read_tuple(H):\n\n    '''\n\n    H is number of rows\n\n    '''\n\n    ret = []\n\n    for _ in range(H):\n\n        ret.append(tuple(map(int, read().split())))\n\n    return ret\n\n\n\n\n\ndef read_col(H, n_cols):\n\n    '''\n\n    H is number of rows\n\n    n_cols is number of cols\n\n\n\n    A列、B列が与えられるようなとき\n\n    '''\n\n    ret = [[] for _ in range(n_cols)]\n\n    for _ in range(H):\n\n        tmp = list(map(int, read().split()))\n\n        for col in range(n_cols):\n\n            ret[col].append(tmp[col])\n\n\n\n    return ret\n\n\n\n\n\nN, K = read_ints()\n\nP = read_ints()\n\n\n\n\n\ndef ret_mean(X):\n\n    return (X + 1) / 2\n\n\n\n\n\n\n\nclass cumsum1d:\n\n    def __init__(self, ls: list):\n\n        '''\n\n        1次元リストを受け取る\n\n        '''\n\n        from itertools import accumulate\n\n        self.ls_accum = [0] + list(accumulate(ls))\n\n\n\n    def total(self, i, j):\n\n        # もとの配列lsにおける[i,j)の中合計\n\n        return self.ls_accum[j] - self.ls_accum[i]\n\n      \n\nP_mean = [ret_mean(p) for p in P]\n\nP_accum = cumsum1d(P_mean)\n\n\n\nans = 0\n\n# print(P_accum)\n\nfor i in range(N - K + 1):\n\n    j = i + K\n\n    ans = max(ans, P_accum.total(i,j))\n\nprint(ans)\n", "score": 0.0}
{"golden_code": "import math\n\n\n\nN = int(eval(input()))\n\nans = math.factorial(N) % (10**9 + 7)\n\nprint(ans)", "generated_code": "import sys\n\n\n\n\n\ndef main():\n\n    h, w = list(map(int, sys.stdin.buffer.readline().split()))\n\n    n = int(sys.stdin.buffer.readline())\n\n    a = list(map(int, sys.stdin.buffer.readline().split()))\n\n    ans = [0]*(w*h)\n\n    now = 0\n\n    for i, x in enumerate(a):\n\n        for j in range(x):\n\n            ans[now + j] = i+1\n\n        now += x\n\n\n\n    for i in range(h):\n\n        if i % 2:\n\n            print((*reversed(ans[i*w:(i+1)*w])))\n\n        else:\n\n            print((*ans[i*w:(i+1)*w]))\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "score": 0.0}
{"golden_code": "import sys\n\ninput = sys.stdin.readline\n\nsys.setrecursionlimit(10 ** 7)\n\n\n\nN = int(eval(input()))\n\nA = [int(i) for i in input().split()]\n\nB = [int(i) for i in input().split()]\n\nbefore = sum(A)\n\n\n\nfor i in range(N):\n\n    nokori = B[i]\n\n    for j in range(i,i+2):\n\n        if nokori >= A[j]:\n\n            nokori -= A[j]\n\n            A[j] = 0\n\n        else:\n\n            A[j] -= nokori\n\n            nokori = 0\n\nafter = sum(A)\n\n\n\nprint((before - after))", "generated_code": "def main():\n\n    n = int(eval(input()))\n\n    dp = [[0 for i in range(10)] for i in range(10)]\n\n    for i in range(1,n+1):\n\n        h,t = int(str(i)[0]), int(str(i)[-1])\n\n        dp[h][t] += 1\n\n    ans = 0\n\n    for i in range(10):\n\n        for j in range(10):\n\n            ans += dp[i][j] * dp[j][i]\n\n    print(ans)\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "score": 0.0}
{"golden_code": "import sys\n\ninput = sys.stdin.readline\n\nfrom collections import *\n\n\n\nK = int(eval(input()))\n\nA, B = list(map(int, input().split()))\n\n\n\nfor i in range(A, B+1):\n\n    if i%K==0:\n\n        print('OK')\n\n        exit()\n\n    \n\nprint('NG')", "generated_code": "N,K=list(map(int,input().split()))\n\na = [[0 for n in range(N)] for k in range(K)]\n\n\n\nfor k in range(K):\n\n    d=int(eval(input()))\n\n    have_k=list(map(int,input().split()))\n\n    for h in have_k:\n\n        a[k][h-1]=1\n\n\n\nan=[0]*N\n\nfor k in range(K):\n\n  for n in range(N):\n\n    an[n] = an[n]+a[k][n]\n\n\n\nresult=0\n\nfor i in an:\n\n  if i == 0:\n\n    result+=1\n\n\n\nprint(result)", "score": 0.0}
{"golden_code": "import numpy as np\n\nimport math\n\n\n\ndef bigger_devisor(n):\n\n  s = np.sqrt(n)\n\n  i = math.ceil(s)\n\n  while(n % i != 0):\n\n    i += 1\n\n  return i\n\n\n\nn = int(eval(input()))\n\nif bigger_devisor(n) > 9:\n\n  print('No')\n\nelse:\n\n  print('Yes')", "generated_code": "A, B, C, X, Y = list(map(int, input().split()))\n\n\n\nif X > Y:\n\n    v = A\n\nelse:\n\n    v = B\n\n\n\nans = min(A*X+B*Y, C*max(X, Y)*2, C*min(X,Y)*2+(max(X,Y)-min(X,Y))*v)\n\n\n\nprint(ans)", "score": 0.0}
{"golden_code": "import sys\n\nreadline = sys.stdin.readline\n\nsys.setrecursionlimit(10**8)\n\nmod = 10**9+7\n\n#mod = 998244353\n\nINF = 10**18\n\neps = 10**-7\n\n\n\nm,n,k = list(map(int,readline().split()))\n\n\n\ndef comb(n, r, mod):\n\n    r = min(r, n-r)\n\n    mol = 1\n\n    deno = 1\n\n    for i in range(1, r+1):\n\n        mol = mol * (n-r+i) % mod\n\n        deno = deno * i % mod\n\n    ret = mol * pow(deno, mod-2, mod) % mod\n\n    return ret\n\n\n\ndef f1(x,y,a,b):\n\n    return (a+b-x-y)*(a-x+1)*(b-y+1)//2\n\n\n\ndef f2(x,a):\n\n    return (a-x)*(a-x+1)//2\n\n\n\nans = 0\n\n\n\nfor x in range(1,n+1):\n\n    for y in range(1,m+1):\n\n        ans += f1(x,y,n,m)+f1(1,1,x,y)+f1(1,y,x,m)+f1(x,1,n,y)\n\n        ans -= f2(x,n) + f2(1,x) + f2(1,y) + f2(y,m)\n\n        ans %= mod\n\n\n\nans = (ans * comb(m*n-2,k-2,mod))%mod\n\nans = ans*pow(2,mod-2,mod)%mod\n\n\n\nprint(ans)\n", "generated_code": "n = int(eval(input()))\n\ndef make_divisors(n):\n\n    divisors = []\n\n    for i in range(1, int(n**0.5)+1):\n\n        if n % i == 0:\n\n            divisors.append(i)\n\n            if i != n // i:\n\n                divisors.append(n//i)\n\n\n\n    #divisors.sort(reverse=True)\n\n    return divisors\n\n\n\nl = make_divisors(n)\n\nmin_ = float('inf')\n\nfor i in range(len(l)):\n\n    min_ = min(min_, l[i]-1+n//l[i]-1)\n\nprint(min_)\n", "score": 0.0}
{"golden_code": "\n\nclass UnionFind:\n\n    def __init__(self, size):\n\n        self.table = [i for i in range(size)]\n\n\n\n    def find(self, x):\n\n        return self.table[x]\n\n\n\n    def union(self, x, y):\n\n        x1 = self.find(x)\n\n        y1 = self.find(y)\n\n\n\n        if x1 == y1:\n\n            return False\n\n\n\n        for i in range(len(self.table)):\n\n            if self.table[i] == y1:\n\n                self.table[i] = x1\n\n        return True\n\n\n\n\n\nN, M = list(map(int, input().split()))\n\n\n\nedges = []\n\nfor _ in range(M):\n\n    a, b = list(map(int, input().split()))\n\n    edges.append([a-1, b-1])\n\n\n\nmat = [[0]*N for _ in range(N)]\n\nfor s, g in edges:\n\n    mat[s][g] = 1\n\n    mat[g][s] = 1\n\n\n\nans = 0\n\n\n\nfor i in range(M):\n\n    uni = UnionFind(N)\n\n\n\n    for j in range(M):\n\n        if i != j:\n\n            uni.union(edges[j][0], edges[j][1])\n\n\n\n    if not all(uni.find(0) == uni.find(x) for x in range(N)):\n\n        ans += 1\n\nprint(ans)\n", "generated_code": "import math\n\nn = eval(input())\n\na = list(map(int, input().split()))\n\nans = float(\"inf\")\n\nfor i in a:\n\n    ans = min(ans, len(bin(i)) - bin(i).rfind(\"1\") - 1)\n\nprint((round(ans)))", "score": 0.0}
{"golden_code": "N,X = list(map(int,input().split()))\n\nL = [0] + [int(x) for x in input().split()]\n\n\n\nD = [0] * (N+2)\n\nanswer = 1\n\nfor n in range(2,N+2):\n\n  D[n] = D[n-1] + L[n-1]\n\n  if D[n] <= X:\n\n    answer += 1\n\n    \n\nprint(answer)", "generated_code": "n,k=list(map(int,input().split()))\n\n*a,= list(map(int,input().split()))\n\n*f,= list(map(int,input().split()))\n\na=sorted(a)\n\nf=sorted(f, reverse=True)\n\n\n\ndef is_ok(arg):\n\n    cnt=0\n\n    for i in range(n):\n\n        cnt+=max(a[i]-arg//f[i], 0)\n\n    return cnt<=k\n\n\n\ndef meguru_bisect(ng, ok):\n\n    while (abs(ok - ng) > 1):\n\n        mid = (ok + ng) // 2\n\n        if is_ok(mid):\n\n            ok = mid\n\n        else:\n\n            ng = mid\n\n    return ok\n\n\n\nprint((meguru_bisect(-1, 10**12)))", "score": 0.0}
{"golden_code": "N = int(eval(input()))\n\nx = list(map(int, input().split()))\n\ncnt = 0\n\nfor i in x:\n\n  while i % 2 == 0:\n\n    cnt += 1\n\n    i /= 2\n\nprint(cnt)", "generated_code": "print(eval(input()))", "score": 0.0}
{"golden_code": "import math\n\nn = int(eval(input()))\n\n\n\nans = math.factorial(n)  # nの階乗を計算\n\n\n\nif ans >= (10 ** 9)+7:\n\n    ans = ans % ((10 ** 9)+7)\n\n\n\nprint(ans)\n", "generated_code": "class UnionFind():\n\n    def __init__(self, n):\n\n        self.n = n\n\n        self.parents = [-1] * n\n\n\n\n    def find(self, x):\n\n        if self.parents[x] < 0:\n\n            return x\n\n        else:\n\n            self.parents[x] = self.find(self.parents[x])\n\n            return self.parents[x]\n\n\n\n    def union(self, x, y):\n\n        x = self.find(x)\n\n        y = self.find(y)\n\n\n\n        if x == y:\n\n            return\n\n\n\n        if self.parents[x] > self.parents[y]:\n\n            x, y = y, x\n\n\n\n        self.parents[x] += self.parents[y]\n\n        self.parents[y] = x\n\n\n\n    def roots(self):\n\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n\n\n    def group_count(self):\n\n        return len(self.roots())\n\n\n\nfrom copy import deepcopy\n\n\n\nn,m=list(map(int,input().split()))\n\nl=[list(map(int,input().split())) for i in range(m)]\n\n\n\ncnt=0\n\nfor i in range(m):\n\n  uf=UnionFind(n)\n\n  ll=deepcopy(l)\n\n  del ll[i]\n\n  for a,b in ll:\n\n    a-=1\n\n    b-=1\n\n    uf.union(a,b)\n\n  if uf.group_count()>=2:\n\n    cnt+=1\n\nprint(cnt)", "score": 0.0}
{"golden_code": "import statistics\n\nN = int(eval(input()))\n\na = [int(i) for i in input().split()]\n\nans = 0\n\n\n\nfor i in range(1,N+1):\n\n  a[i-1] -= i\n\n\n\nb = statistics.median(a)\n\nfor i in range(N):\n\n  ans += abs(a[i]-b)\n\nprint((int(ans)))", "generated_code": "n, m, k = list(map(int, input().split()))\n\n\n\nmod = 10 ** 9 + 7\n\nMAX = n * m\n\n\n\nfact = [1] * (MAX + 1)\n\nfor i in range(1, MAX + 1):\n\n    fact[i] = (fact[i-1] * i) % mod\n\n\n\ninv = [1] * (MAX + 1)\n\ninv[MAX] = pow(fact[MAX], mod - 2, mod)\n\nfor i in range(MAX, 0, -1):\n\n    inv[i-1] = (inv[i] * i) % mod\n\n\n\n\n\ndef comb(n, k):\n\n    return fact[n] * inv[n-k] * inv[k] % mod\n\n\n\n\n\nans = 0\n\nfor i in range(n):\n\n    for j in range(m):\n\n        add = (n - i) * (m - j) * (i + j) % mod\n\n        if i != 0 and j != 0:\n\n            add *= 2\n\n            add %= mod\n\n\n\n        ans += add\n\n        ans %= mod\n\n\n\nans *= comb(MAX - 2, k - 2)\n\nans %= mod\n\nprint(ans)\n", "score": 0.0}
{"golden_code": "print((eval(input())))", "generated_code": "n = int(eval(input()))\n\nans = 0\n\nfor i in range(1, 10):\n\n  if n % i == 0:\n\n    if n / i < 10:\n\n      ans = 1\n\nif ans == 0:\n\n  print('No')\n\nelse:\n\n  print('Yes')", "score": 0.0}
{"golden_code": "import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\nimport numpy as np\n\n\n\nN = int(readline())\n\nS = np.array(read().split(),np.int64)\n\n\n\ndef F(d):\n\n    # 公差を固定\n\n    L = S[:-d:d].cumsum()\n\n    R = S[::-1][:-d:d].cumsum()\n\n    if (N-1)%d == 0:\n\n        n = (N-1)//d\n\n        x = np.arange(1,n+1)\n\n        bl = (x+x <= n+1)\n\n        L = L[bl]; R = R[bl]\n\n    return (L+R).max()\n\n\n\ndef G(n):\n\n    # 項数n+1を固定\n\n    D = (N-1-n)//n\n\n    L = np.zeros(D+1,np.int64)\n\n    R = np.zeros(D+1,np.int64)\n\n    for i in range(1,n+1):\n\n        L += S[:i*(D+1):i]\n\n        R += S[::-1][:i*(D+1):i]\n\n    ok = np.ones(D+1,np.bool)\n\n    overlap = (np.arange(D+1) * (n+n) >= N-1)\n\n    overlap[1:] &= ((N-1)%np.arange(1,D+1) == 0)\n\n    x = L+R\n\n    x[overlap] = 0\n\n    return x.max()\n\n\n\nL = int((N-1)**.5 + 10)\n\nL = min(N-1,L)\n\n\n\nx = max(F(n) for n in range(1,L+1))\n\ny = max(G(n) for n in range(1,L+1))\n\nanswer = max(x,y)\n\nprint(answer)", "generated_code": "def resolve():\n\n  S = eval(input())\n\n  arr = []\n\n  for s in S:\n\n    if len(arr) != 0 and arr[-1] != s:\n\n      arr.pop()\n\n    else:\n\n      arr.append(s)\n\n\n\n  print((len(S) - len(arr)))\n\n  return\n\n\n\nif __name__ == \"__main__\":\n\n  resolve()\n", "score": 0.0}
{"golden_code": "N = int(eval(input()))\n\ns_list = {}\n\nfor i in range(N):\n\n  S = eval(input())\n\n  if S in list(s_list.keys()):\n\n    s_list[S] += 1\n\n  else:\n\n    s_list[S] = 0\n\nmax = 0\n\nmaxs = []\n\nfor s,c in list(s_list.items()):\n\n  if c > max:\n\n    maxs = [s]\n\n    max = c\n\n  elif c == max:\n\n    maxs.append(s)\n\nmaxs.sort()\n\nfor m in maxs:\n\n  print(m)", "generated_code": "import math\n\nn = eval(input())\n\na = list(map(int, input().split()))\n\nans = float(\"inf\")\n\nfor i in a:\n\n    ans = min(ans, len(bin(i)) - bin(i).rfind(\"1\") - 1)\n\nprint((round(ans)))", "score": 0.0}
{"golden_code": "# ABC 120 C\n\n\n\nimport re\n\n\n\nS = eval(input())\n\n\n\nl0 = 0\n\nl1 = 0\n\n\n\nfor i in range(len(S)):\n\n    if S[i] == '0':\n\n        l0 += 1\n\n    elif S[i] == '1':\n\n        l1 += 1\n\n\n\nprint((min(l0, l1) * 2))\n", "generated_code": "n,l=list(map(int,input().split()))\n\na=0\n\nfor i in range(n):\n\n  a+=i+l\n\nif l>=0:\n\n  print((a-l))\n\nelif l+n-1<0:\n\n  print((a-(l+n-1)))\n\nelse:\n\n  print(a)", "score": 0.0}
{"golden_code": "from scipy.sparse.csgraph import floyd_warshall\n\nimport numpy as np\n\nimport sys\n\n\n\ninput = sys.stdin.readline\n\n\n\nN, M = list(map(int, input().split()))\n\nAB = []\n\nedge = np.zeros((N, N), dtype=int)\n\nfor _ in range(M):\n\n    a, b = list(map(int, input().split()))\n\n    a -= 1\n\n    b -= 1\n\n    AB.append((a, b))\n\n    edge[a][b] = 1\n\n    edge[b][a] = 1\n\n\n\nans = 0\n\nfor i in range(M):\n\n    graph = np.copy(edge)\n\n    a, b = AB[i]\n\n    graph[a][b] = 0\n\n    graph[b][a] = 0\n\n    fw = floyd_warshall(graph)\n\n    if fw.max() > 10000:\n\n        ans += 1\n\n\n\nprint(ans)\n", "generated_code": "N,K=list(map(int,input().split()))\n\na = [[0 for n in range(N)] for k in range(K)]\n\n\n\nfor k in range(K):\n\n    d=int(eval(input()))\n\n    have_k=list(map(int,input().split()))\n\n    for h in have_k:\n\n        a[k][h-1]=1\n\n\n\nan=[0]*N\n\nfor k in range(K):\n\n  for n in range(N):\n\n    an[n] = an[n]+a[k][n]\n\n\n\nresult=0\n\nfor i in an:\n\n  if i == 0:\n\n    result+=1\n\n\n\nprint(result)", "score": 0.0}
{"golden_code": "def main():\n\n    S = eval(input())\n\n    w1 = 'dream'[::-1]\n\n    w2 = 'dreamer'[::-1]\n\n    w3 = 'erase'[::-1]\n\n    w4 = 'eraser'[::-1]\n\n    # print(w1,w2,w3,w4)\n\n    S = S[::-1]\n\n    # print(S)\n\n\n\n    # words = ['dream', 'dreamer', 'erase', 'eraser']\n\n    words = [w1, w2, w3, w4]\n\n    T = ''\n\n    while S != T:\n\n        cand = []\n\n        for w in words:\n\n            new_t = T + w\n\n            cand.append(new_t) \n\n        # print('cand', cand)\n\n        ans = False\n\n        for c in cand:\n\n            if c == S[:len(c)]:\n\n                T = c\n\n                ans = True\n\n\n\n        if not ans:\n\n            break\n\n\n\n    if S == T:\n\n        print('YES')\n\n    else:\n\n        print(\"NO\")\n\n\n\nif __name__ == \"__main__\":\n\n    main()", "generated_code": "while 1:\n\n    a=0\n\n    n,x=list(map(int,input().split()))\n\n    if n==0:break\n\n    for i in range(1,n-1):\n\n        for j in range(i+1,n):\n\n            c=x-i-j\n\n            if c>j and c<=n:a+=1\n\n    print(a)", "score": 0.0}
{"golden_code": "import math\n\nN = int(eval(input()))\n\np = math.factorial(N)\n\nprint((p % 1000000007))", "generated_code": "N,M=list(map(int,input().split()))\n\nA = [[1 for _ in range(M)]]+[[0 for _ in range(M)] for _ in range(N)]\n\nfor i in range(1,N+1):\n\n    B=list(map(int,input().split()))\n\n    Ai=B[1:]\n\n    for m in Ai:\n\n        A[i][m-1]=A[i-1][m-1]\n\na=sum(A[N])\n\nprint((int(a)))", "score": 0.0}
{"golden_code": "S, T = input().split()\n\nA, B= list(map(int, input().split()))\n\nU = eval(input())\n\nif S == U:\n\n    print((A - 1, B))\n\nelse:\n\n    print((A, B - 1))", "generated_code": "from collections import defaultdict\n\nS = eval(input())\n\nN = len(S)\n\n\n\nmemo = defaultdict(int)\n\nmemo[0] += 1\n\n\n\nmod = 2019\n\nd = 1\n\nval = 0\n\n\n\nfor s in S[::-1]:\n\n    s = int(s)\n\n    val += s * d\n\n    val %= mod\n\n    memo[val] += 1\n\n    d *= 10\n\n    d %= mod\n\n\n\nprint((sum(v * (v - 1) // 2 for v in list(memo.values()))))", "score": 0.0}
{"golden_code": "n=int(eval(input()))\n\na=[list(map(int,input().split()))for _ in range(n)]\n\ndef f():\n\n for i in range(n-1):\n\n  d=a[i][:];d[3],d[4]=d[4],d[3]\n\n  for j in range(i+1,n):\n\n   e=a[j][:];e[3],e[4]=e[4],e[3]\n\n   for p in('012345','152043','215304','302541','410352','514320'):\n\n    f=[d[int(k)]for k in p]\n\n    g=f[1:5]*2\n\n    for k in range(4):\n\n     if(g[k:k+4]==e[1:5])*(f[0]==e[0])*(f[5]==e[5]):return 'No'\n\n return 'Yes'\n\nprint((f()))\n", "generated_code": "def resolve():\n\n  S = eval(input())\n\n  arr = []\n\n  for s in S:\n\n    if len(arr) != 0 and arr[-1] != s:\n\n      arr.pop()\n\n    else:\n\n      arr.append(s)\n\n\n\n  print((len(S) - len(arr)))\n\n  return\n\n\n\nif __name__ == \"__main__\":\n\n  resolve()\n", "score": 0.0}
{"golden_code": "def main():\n\n  n = int(eval(input()))\n\n  \n\n  dp = [0]*(n+1)\n\n  dp[0] = 1\n\n  mod = pow(10, 9) + 7\n\n  for i in range(n+1):\n\n    for j in range(i-2):\n\n      dp[i] += dp[j]\n\n      dp[i] %= mod\n\n  \n\n  print((dp[n]))\n\n\n\nif __name__ == \"__main__\":\n\n  main()", "generated_code": "import sys\n\n\n\nn = int(sys.stdin.readline().rstrip())\n\nxy = [[] for _ in range(n)]\n\nfor i in range(n):\n\n    a = int(sys.stdin.readline().rstrip())\n\n    for j in range(a):\n\n        x, y = list(map(int, sys.stdin.readline().split()))\n\n        xy[i].append((x-1, y))\n\n\n\ndef main():\n\n    ans = 0\n\n    for comb in range(2 ** n):\n\n        cnt = 0\n\n        for i in range(n):\n\n            if comb >> i & 1 ^ 1:\n\n                continue\n\n            for x, y in xy[i]:\n\n                if comb >> x & 1 ^ y:\n\n                    break\n\n            else:\n\n                cnt += 1\n\n                continue\n\n            break\n\n        else:\n\n            ans = max(ans, cnt)\n\n    return ans\n\n                \n\nif __name__ == '__main__':\n\n    ans = main()\n\n    print(ans)", "score": 0.0}
{"golden_code": "import numpy as np\n\n\n\nn,l=list(map(int,input().split()))\n\nli=[]\n\nfor i in range(n):\n\n  li.append(l+i)\n\ns=sum(li)\n\np=np.array(li)\n\na=np.abs(p).tolist()\n\nk=min(a)\n\nb=a.index(k)\n\nprint((s-li[b]))", "generated_code": "n,m,k=list(map(int,input().split()))\n\n\n\nmod = 10**9+7\n\nf = [1]\n\nfor i in range(n*m):\n\n  f += [f[-1]*(i+1) % mod]\n\ndef comb(a, b):\n\n  return f[a]*pow(f[b], mod-2, mod)*pow(f[a-b], mod-2, mod) % mod\n\n\n\nans=0\n\nfor dist in range(1,n):\n\n  c=n-dist\n\n  p=(c*m*m)%mod\n\n  ans+=p*dist\n\nfor dist in range(1,m):\n\n  c=m-dist\n\n  p=(c*n*n)%mod\n\n  ans+=p*dist\n\nans%=mod\n\nprint((ans*comb(n*m-2,k-2)%mod))", "score": 0.0}
{"golden_code": "import sys\n\ninput = sys.stdin.readline\n\nread = sys.stdin.read\n\n\n\nn = int(eval(input()))\n\nA = list(map(int, read().split()))\n\nL = sorted([(j, i) for i, j in enumerate(A)])\n\ncount = 0\n\nfor i in range(n):\n\n  if (L[i][1]-i)%2:\n\n    count += 1\n\nans = (count+1) // 2\n\nprint(ans)", "generated_code": "from itertools import groupby\n\n\n\nS=eval(input())\n\nanswer = sum([1 for _ in groupby(S)]) -1\n\n\n\nprint(answer)", "score": 0.0}
{"golden_code": "# Problem https://atcoder.jp/contests/abc053/tasks/abc053_b\n\n# Python 1st Try\n\nimport copy\n\n\n\n\n\nclass Problem:\n\n    def __init__(self, stringdata):\n\n        self.stringdata = stringdata\n\n\n\n    def solver(self):\n\n        strcont = copy.copy(self.stringdata)\n\n        result = 0\n\n        rightposition = 0\n\n        leftposition = len(strcont)\n\n        j = 0\n\n        while True:\n\n            if strcont[j] == 'A':\n\n                rightposition = j\n\n                break\n\n            else:\n\n                j = j + 1\n\n        j = leftposition - 1\n\n        while True:\n\n            if strcont[j] == 'Z':\n\n                leftposition = j\n\n                break\n\n            else:\n\n                j = j - 1\n\n\n\n        result = leftposition - rightposition + 1\n\n        return result\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    s = eval(input())\n\n    print((\"{}\".format(Problem(s).solver())))\n", "generated_code": "A, B, C, X, Y = list(map(int, input().split()))\n\n\n\nif X > Y:\n\n    v = A\n\nelse:\n\n    v = B\n\n\n\nans = min(A*X+B*Y, C*max(X, Y)*2, C*min(X,Y)*2+(max(X,Y)-min(X,Y))*v)\n\n\n\nprint(ans)", "score": 0.0}
{"golden_code": "n, m = list(map(int, input().split()))\n\ndp = [0] * n\n\nfor i in range(m):\n\n    x, y = list(map(int, input().split()))\n\n    dp[x - 1] += 1\n\n    dp[y - 1] += 1\n\nfor i in range(n):\n\n    print((dp[i]))", "generated_code": "import sys\n\n\n\nx, y, z, K = map(int, sys.stdin.readline().split())\n\na, b, c = (sorted(map(int, sys.stdin.readline().split()), reverse=True) for _ in range(3))\n\ndef main():\n\n    res = []\n\n    for i in range(1, min(K, x) + 1):\n\n        for j in range(1, min(K // i, y) + 1):\n\n            for k in range(1, min(K // (i * j), z) + 1):\n\n                res.append(a[i-1] + b[j-1] + c[k-1])\n\n\n\n    return sorted(res, reverse=True)[:K]\n\n\n\nif __name__ == '__main__':\n\n    ans = main()\n\n    print(*ans, sep='\\n')\n", "score": 0.0}
{"golden_code": "mod = 998244353\n\nN = int(eval(input()))\n\nX = []\n\nfor _ in range(N):\n\n    x, d = list(map(int, input().split()))\n\n    X.append((x, x + d))\n\n\n\nX = sorted(X, key = lambda x: x[0])\n\nL = [(0, -(10**9+1), 10**9+1)]\n\nP = [-1] * (N+1)\n\nfor i, (x, y) in enumerate(X):\n\n    while L[-1][2] <= y:\n\n        if L[-1][2] > x and P[i+1] < 0:\n\n            P[i+1] = L[-1][0]\n\n        L.pop()\n\n    if P[i+1] < 0:\n\n        P[i+1] = L[-1][0]\n\n    L.append((i+1, x, y))\n\n\n\nC = [[] for _ in range(N+1)]\n\nfor i, p in enumerate(P):\n\n    if p >= 0:\n\n        C[p].append(i)\n\n\n\nY = [1] * (N+1)\n\nfor i in range(N+1)[::-1]:\n\n    s = 1\n\n    for j in C[i]:\n\n        s = s * (Y[j] + 1) % mod\n\n    Y[i] = s\n\n\n\nprint((Y[0]))", "generated_code": "import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\nimport itertools\n\n\n\nN,X,*L = list(map(int,read().split()))\n\n\n\nanswer = sum(x <= X for x in itertools.accumulate([0]+L))\n\nprint(answer)", "score": 0.0}
{"golden_code": "n = int(eval(input()))\n\n\n\nfelicidade = []\n\n\n\nfor x in range(n):\n\n    felicidade.append(list(map(int,input().split())))\n\n\n\nDP = [0,0,0]\n\n\n\nif n == 1:\n\n    print((max(felicidade[0])))\n\n\n\nelse:\n\n\n\n    for x in range(3):\n\n        DP[x] = felicidade[0][x]\n\n\n\n\n\n    for dia in range(1,n):\n\n        m = [0] * 3\n\n        for x  in range(3):#As duas possíveis escolhas são x e y\n\n            for y  in range(3):\n\n                if x != y: #Se elas forem diferentes\n\n                    m[x] = max(m[x], DP[y] + felicidade[dia][x])\n\n        DP = m\n\n    \n\n    print((max(DP)))\n", "generated_code": "from collections import deque\n\n\n\nn,q = list(map(int,input().split()))\n\nqueue = deque()\n\nfor i in range(n):\n\n\tname,time = input().split()\n\n\tqueue.append((name, int(time)))\n\n\n\nt = 0\n\nwhile queue:\n\n\tname,time = queue.popleft()\n\n\tt += min(q, time)\n\n\tif time > q:\n\n\t\tqueue.append((name, time-q))\n\n\telse:\n\n\t\tprint((name,t))\n", "score": 0.0}
{"golden_code": "n,m=list(map(int,input().split()))\n\na=[int(x) for x in input().split()]\n\nb=[0 for x in range(n+1)]\n\nl=list([0])\n\n\n\nfor i in range(1,n+1):\n\n  b[i]=b[i-1]+a[i-1]\n\n\n\nfor i in range(1,n+1):\n\n  l.append(b[i]%m)\n\n\n\nd=list()\n\nl.sort()\n\nt,c=0,1\n\nfor i in range(1,n+1):\n\n  if l[i]==l[i-1]:\n\n    c+=1\n\n  else:\n\n    if c!=1:\n\n      t += c*(c-1)//2\n\n      c=1\n\n\n\nif c!=1:\n\n  t += c*(c-1)//2  \n\n\n\nprint(t)\n", "generated_code": "h, w = map(int, input().split())\n\nal = list(list(input()) for _ in range(h))\n\nrow = [0]*w\n\ncol = [0]*h\n\n\n\nfor i in range(h):\n\n    for j in range(w):\n\n        if al[i][j] == '#':\n\n            col[i] += 1\n\n            row[j] += 1\n\nans = []\n\nw_len = len(row) - row.count(0)\n\nfor i in range(h):\n\n    tmp = ''\n\n    if col[i] != 0:\n\n        for j in range(w):\n\n            if row[j] != 0:\n\n                tmp += al[i][j]\n\n        ans.append(tmp)\n\n\n\nfor a in ans:\n\n    print(*a, sep='')\n", "score": 0.0}
{"golden_code": "# C - Walk on Multiplication Table\n\n# https://atcoder.jp/contests/abc144/tasks/abc144_c\n\n\n\nn = int(eval(input()))\n\n\n\nans = 10 ** 12\n\nfor i in range(1, 10 ** 6 + 1):\n\n  if n % i == 0:\n\n    ans = min(ans, n // i + i)\n\n\n\nprint((ans - 2))", "generated_code": "import heapq\n\nX,Y,Z,K = list(map(int,input().split()))\n\nA = list(map(int,input().split()))\n\nB = list(map(int,input().split()))\n\nC = list(map(int,input().split()))\n\nasort,bsort,csort = sorted(A,reverse=True),sorted(B,reverse=True),sorted(C,reverse=True)\n\nalready = [[0,0,0]]\n\nprint((asort[0] + bsort[0] + csort[0]))\n\nx,y,z = 0,0,0\n\ncheck = []\n\nfor k in range(K - 1):\n\n    if [x + 1,y,z] not in already and x + 1 < X:\n\n        already.append([x + 1,y,z])\n\n        heapq.heappush(check,(-(asort[x + 1] + bsort[y] + csort[z]),x + 1,y,z))\n\n    if [x,y + 1,z] not in already and y + 1 < Y:\n\n        already.append([x,y + 1,z])\n\n        heapq.heappush(check,(-(asort[x] + bsort[y + 1] + csort[z]),x,y + 1,z))\n\n    if [x,y,z + 1] not in already and z + 1 < Z:\n\n        already.append([x,y,z + 1])\n\n        heapq.heappush(check,(-(asort[x] + bsort[y] + csort[z + 1]),x,y,z + 1))\n\n    maxsum = heapq.heappop(check)\n\n    print((-maxsum[0]))\n\n    x,y,z = maxsum[1],maxsum[2],maxsum[3]", "score": 0.0}
{"golden_code": "n, m, k = list(map(int, input().split()))\n\nmod = 10 ** 9 + 7\n\nMAX = n * m\n\n\n\n\n\nclass ModInt:\n\n    def __init__(self, num):\n\n        self.num = num\n\n\n\n    def __str__(self):\n\n        return str(self.num)\n\n\n\n    def __repr__(self):\n\n        return \"ModInt(num: {}, mod: {}\".format(self.num, mod)\n\n\n\n    def __add__(self, other):\n\n        ret = self.num + other.num\n\n        ret %= mod\n\n        return ModInt(ret)\n\n\n\n    def __sub__(self, other):\n\n        ret = self.num - other.num\n\n        ret %= mod\n\n        return ModInt(ret)\n\n\n\n    def __mul__(self, other):\n\n        ret = self.num * other.num\n\n        ret %= mod\n\n        return ModInt(ret)\n\n\n\n    def pow(self, times):\n\n        pw = pow(self.num, times, mod)\n\n        return ModInt(pw)\n\n\n\n    def inverse(self):\n\n        return ModInt(inv[self.num])\n\n\n\n    def __truediv__(self, other):\n\n        num = self * other.inverse()\n\n        return ModInt(num)\n\n\n\n\n\ndef comb(n, k):\n\n    return fact[n] * inv[n-k] * inv[k]\n\n\n\n\n\nfact = [None] * (MAX + 1)\n\nfact[0] = ModInt(1)\n\nfor i in range(1, MAX + 1):\n\n    fact[i] = fact[i-1] * ModInt(i)\n\n\n\ninv = [None] * (MAX + 1)\n\ninv[MAX] = fact[MAX].pow(mod - 2)\n\nfor i in range(MAX, 0, -1):\n\n    inv[i-1] = inv[i] * ModInt(i)\n\n\n\nans = ModInt(0)\n\nfor i in range(n):\n\n    for j in range(m):\n\n        add = ModInt(n - i) * ModInt(m - j) * ModInt(i + j)\n\n        if i != 0 and j != 0:\n\n            add *= ModInt(2)\n\n\n\n        ans += add\n\n\n\nans *= comb(n * m - 2, k - 2)\n\nprint(ans)\n", "generated_code": "a_1=list(map(int, input().split()))\n\na_2=list(map(int, input().split()))\n\na_3=list(map(int, input().split()))\n\n\n\nc=[a_1,a_2,a_3]\n\n\n\nN=int(eval(input()))\n\n\n\nb=[int(eval(input())) for _ in range(N)]\n\n\n\nfor i in range(3):\n\n    for j in range(3):\n\n        if c[i][j] in b:\n\n            c[i][j]=0\n\n            \n\n            \n\ni=0\n\nif c[0][0]==0 and c[0][1]==0 and c[0][2]==0:\n\n    i+=1\n\nif c[1][0]==0 and c[1][1]==0 and c[1][2]==0:\n\n    i+=1\n\nif c[2][0]==0 and c[2][1]==0 and c[2][2]==0:\n\n    i+=1\n\nif c[0][0]==0 and c[1][0]==0 and c[2][0]==0:\n\n    i+=1\n\nif c[0][1]==0 and c[1][1]==0 and c[2][1]==0:\n\n    i+=1\n\nif c[0][2]==0 and c[1][2]==0 and c[2][2]==0:\n\n    i+=1\n\nif c[0][0]==0 and c[1][1]==0 and c[2][2]==0:\n\n    i+=1\n\nif c[0][2]==0 and c[1][1]==0 and c[2][0]==0:\n\n    i+=1\n\n    \n\nif i>0:\n\n    print(\"Yes\")\n\nelse:\n\n  print(\"No\")", "score": 0.0}
{"golden_code": "import numpy as np\n\n\n\nn = int(eval(input()))\n\na = np.array(list(map(int,input().split())))\n\n\n\ncount = 0\n\nwhile np.all(a%2==0):\n\n    count+=1\n\n    a=a/2\n\nprint(count)\n", "generated_code": "import sys\n\nsys.setrecursionlimit(100000)\n\n\n\ndef intinput(): return list(map(int,sys.stdin.readline().split()))\n\n\n\n\n\nn, m = intinput()\n\na = {int(sys.stdin.readline()) for _ in range(m)}\n\nmemo = [0 for x in range(n + 4)]\n\nmemo[0] = 1\n\nmod = 10 ** 9 + 7\n\nfor i in range(n):\n\n    if i + 1 not in a:\n\n        memo[i + 1] = (memo[i + 1] + memo[i]) % mod\n\n    if i + 2 not in a:\n\n        memo[i + 2] = (memo[i + 2] + memo[i]) % mod\n\nprint((memo[n]))", "score": 0.0}
{"golden_code": "a,b = list(map(int, input().split()))\n\ncount = 0\n\nfor i in range(a,b+1):\n\n    j = str(i)\n\n    if j==''.join(reversed(j)):\n\n        count += 1\n\nprint(count)", "generated_code": "K = int(eval(input()))\n\nt = 7\n\nt %= K\n\n\n\nfor i in range(K+1):\n\n    if t == 0:\n\n        print((i+1))\n\n        exit()\n\n    t = (t*10+7)%K\n\nprint((-1))\n", "score": 0.0}
{"golden_code": "import sys\n\nread = sys.stdin.readline\n\n\n\n\n\ndef read_ints():\n\n    return list(map(int, read().split()))\n\n\n\n\n\ndef read_a_int():\n\n    return int(read())\n\n\n\n\n\ndef read_matrix(H):\n\n    '''\n\n    H is number of rows\n\n    '''\n\n    return [list(map(int, read().split())) for _ in range(H)]\n\n\n\n\n\ndef read_map(H):\n\n    '''\n\n    H is number of rows\n\n    文字列で与えられた盤面を読み取る用\n\n    '''\n\n    return [read()[:-1] for _ in range(H)]\n\n\n\n\n\ndef read_tuple(H):\n\n    '''\n\n    H is number of rows\n\n    '''\n\n    ret = []\n\n    for _ in range(H):\n\n        ret.append(tuple(map(int, read().split())))\n\n    return ret\n\n\n\n\n\ndef read_col(H, n_cols):\n\n    '''\n\n    H is number of rows\n\n    n_cols is number of cols\n\n\n\n    A列、B列が与えられるようなとき\n\n    '''\n\n    ret = [[] for _ in range(n_cols)]\n\n    for _ in range(H):\n\n        tmp = list(map(int, read().split()))\n\n        for col in range(n_cols):\n\n            ret[col].append(tmp[col])\n\n\n\n    return ret\n\n\n\n\n\nN, K = read_ints()\n\nP = read_ints()\n\n\n\n\n\ndef ret_mean(X):\n\n    return (X + 1) / 2\n\n\n\n\n\n\n\n\n\nimport numpy as np\n\nP_mean = np.array([ret_mean(p) for p in P])\n\nP_accum = np.zeros(N+1)\n\nP_accum[1:] = P_mean.cumsum()\n\n\n\nans = 0\n\n# print(P_accum)\n\nfor i in range(N - K + 1):\n\n    j = i + K\n\n    ans = max(ans, P_accum[j] - P_accum[i])\n\nprint(ans)\n", "generated_code": "n = int(eval(input()))\n\nans = 0\n\nfor i in range(1, 10):\n\n  if n % i == 0:\n\n    if n / i < 10:\n\n      ans = 1\n\nif ans == 0:\n\n  print('No')\n\nelse:\n\n  print('Yes')", "score": 0.0}
{"golden_code": "import numpy as np\n\nk,n = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\nb = np.zeros(n)\n\nfor i in range(0,n-1):\n\n  b[i] = a[i+1] -a[i]\n\n  \n\nb[n-1] = k - a[n-1] + a[0]\n\nans = k - max(b)\n\nprint((int(ans)))", "generated_code": "n = int(eval(input()))\n\nans = 0\n\nfor i in map(int, input().split()):\n\n    cnt = 0\n\n    while i % 2 == 0:\n\n        i >>= 1\n\n        cnt += 1\n\n    ans += cnt\n\nprint(ans)", "score": 0.0}
{"golden_code": "import sys\n\nimport numpy as np\n\n\n\nn = int(sys.stdin.readline().rstrip())\n\nx = []\n\ny = []\n\nfor i in range(n):\n\n    a = int(sys.stdin.readline().rstrip())\n\n    xy = [sys.stdin.readline().split() for _ in range(a)]\n\n    if not xy:\n\n        x.append(None)\n\n        y.append(None)\n\n        continue\n\n    xi, yi = np.array(xy, np.int64).T\n\n    x.append(xi-1)\n\n    y.append(yi)\n\n\n\ndef main():\n\n\n\n    ans = 0\n\n    for comb in range(2 ** n):\n\n        cnt = 0\n\n        for i in range(n):\n\n            if not comb >> i & 1:\n\n                continue\n\n            if x[i] is None:\n\n                cnt += 1\n\n                continue\n\n            if np.count_nonzero(comb >> x[i] & 1 ^ y[i]):\n\n                break\n\n            cnt += 1\n\n        else:\n\n            ans = max(ans, cnt)\n\n    return ans\n\n                \n\nif __name__ == '__main__':\n\n    ans = main()\n\n    print(ans)", "generated_code": "A, B, C, X, Y = list(map(int, input().split()))\n\n\n\nif X > Y:\n\n    v = A\n\nelse:\n\n    v = B\n\n\n\nans = min(A*X+B*Y, C*max(X, Y)*2, C*min(X,Y)*2+(max(X,Y)-min(X,Y))*v)\n\n\n\nprint(ans)", "score": 0.0}
{"golden_code": "from collections import deque\n\nn,*t=list(map(int,open(0).read().split()))\n\ncon=[[] for _ in range(n)]\n\ndist_f_k=[0]*n\n\n\n\nfor a,b,c in zip(t[:3*n-3:3],t[1::3],t[2::3]):\n\n\tcon[a-1].append((b-1,c))\n\n\tcon[b-1].append((a-1,c))\n\n\n\nk=t[3*n-2]\n\nque=deque([k-1])\n\nwhile que:\n\n\tcur=que.popleft()\n\n\tfor nxt,dd in con[cur]:\n\n\t\tif dist_f_k[nxt]==0 and nxt!=k-1:\n\n\t\t\tque.append(nxt)\n\n\t\t\tdist_f_k[nxt]=dist_f_k[cur]+dd\n\n\n\nfor x,y in zip(t[3*n-1::2],t[3*n::2]):\n\n\tprint((dist_f_k[x-1]+dist_f_k[y-1]))", "generated_code": "N = int(eval(input()))\n\nnums = [0 for i in range(100)]\n\nfor i in range(1, N + 1):\n\n    i = str(i)\n\n    nums[int(i[0] + i[-1])] += 1\n\nans = 0\n\nfor i in range(1, 10):\n\n    for j in range(i, 10):\n\n        i = str(i)\n\n        j = str(j)\n\n        if i != j:\n\n            ans += nums[int(i + j)] * nums[int(j + i)] * 2\n\n        else:\n\n            n = nums[int(i + j)]\n\n            ans += n * (n - 1)\n\n            ans += n\n\nprint(ans)", "score": 0.0}
{"golden_code": "import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\nN = int(readline())\n\nS = read().split()\n\n\n\nS = sorted(S)\n\nls = [[] for i in range(N + 1)]\n\nmax_num = 0\n\nleft = 0\n\nright = 0\n\nwhile right < N:\n\n    while right < N and S[left] == S[right]:\n\n        right += 1\n\n    if (right  - left) >= max_num:\n\n        ls[right - left].append(S[left].decode())\n\n        max_num = right - left\n\n    left = right\n\n    \n\nprint(('\\n'.join(ls[max_num])))\n", "generated_code": "n,k=list(map(int,input().split()))\n\n*a,= list(map(int,input().split()))\n\n*f,= list(map(int,input().split()))\n\na=sorted(a)\n\nf=sorted(f, reverse=True)\n\n\n\ndef is_ok(arg):\n\n    cnt=0\n\n    for i in range(n):\n\n        cnt+=max(a[i]-arg//f[i], 0)\n\n    return cnt<=k\n\n\n\ndef meguru_bisect(ng, ok):\n\n    while (abs(ok - ng) > 1):\n\n        mid = (ok + ng) // 2\n\n        if is_ok(mid):\n\n            ok = mid\n\n        else:\n\n            ng = mid\n\n    return ok\n\n\n\nprint((meguru_bisect(-1, 10**12)))", "score": 0.0}
{"golden_code": "from fractions import gcd\n\nn, m = list(map(int, input().split()))\n\na = [int(i) // 2 for i in input().split()]\n\nx = 1\n\nfor i in range(n):\n\n    x *= a[i] // gcd(x, a[i])\n\nfor i in a:\n\n    if x // i % 2 == 0:\n\n        print((0))\n\n        exit()\n\nprint(((m // x + 1) // 2))", "generated_code": "from collections import deque\n\n\n\nn,q = list(map(int,input().split()))\n\nqueue = deque()\n\nfor i in range(n):\n\n\tname,time = input().split()\n\n\tqueue.append((name, int(time)))\n\n\n\nt = 0\n\nwhile queue:\n\n\tname,time = queue.popleft()\n\n\tt += min(q, time)\n\n\tif time > q:\n\n\t\tqueue.append((name, time-q))\n\n\telse:\n\n\t\tprint((name,t))\n", "score": 0.0}
{"golden_code": "from math import floor, sqrt\n\nfrom collections import Counter\n\n\n\nMOD = 10 ** 9 + 7\n\n\n\n# xを素因数分解する\n\ndef getPrimeFactor(x):\n\n    ans = []\n\n    for d in range(2, floor(sqrt(x)) + 1):\n\n        while x % d == 0:\n\n            ans.append(d)\n\n            x //= d\n\n\n\n    if x != 1:\n\n        ans.append(x)\n\n\n\n    return ans\n\n\n\n# xのn乗（二分累乗法）\n\ndef power(x, n):\n\n    ans = 1\n\n    while n:\n\n        if n % 2 == 1:\n\n            ans = (ans * x) % MOD\n\n        x = (x * x) % MOD\n\n        n //= 2\n\n    return ans\n\n\n\n\n\nN, M = list(map(int, input().split()))\n\n\n\nPFs = getPrimeFactor(M)\n\ncnt = Counter(PFs)\n\n\n\nN2 = N\n\nif len(cnt):\n\n    N2 += max(cnt.values())\n\n\n\n# facts[x]: xの階乗\n\nfacts = [1] + [0] * N2\n\nfor x in range(1, N2 + 1):\n\n    facts[x] = (facts[x - 1] * x) % MOD\n\n\n\n# invFs[x]: xの階乗の逆元\n\ninvFs = [0] * N2 + [power(facts[N2], MOD - 2)]\n\nfor x in reversed(list(range(N2))):\n\n    invFs[x] = (invFs[x + 1] * (x + 1)) % MOD\n\n\n\ndef comb(n, k):\n\n    return ((facts[n] * invFs[k]) % MOD * invFs[n - k]) % MOD\n\n\n\n\n\nans = 1\n\nfor num in list(cnt.values()):\n\n    ans = (ans * comb(N + num - 1, num)) % MOD\n\nprint(ans)\n", "generated_code": "a,b = list(map(int, input().split()))\n\nn = [i for i in map(str, list(range(a,b+1))) if i==i[::-1]]\n\nprint((len(n)))", "score": 0.0}
{"golden_code": "def main():\n\n\tn, ma, mb, *L = list(map(int, open(0).read().split()))\n\n\tM = 1<<30\n\n\tdp = [[M] * 420 for _ in range(420)]\n\n\tdp[0][0] = 0\n\n\tfor a, b, c in zip(*[iter(L)] * 3):\n\n\t\tfor i in range(400, -1, -1):\n\n\t\t\tfor j in range(400, -1, -1):\n\n\t\t\t\tt = dp[i][j] + c\n\n\t\t\t\tif dp[i + a][j + b] > t:\n\n\t\t\t\t\tdp[i + a][j + b] = t\n\n\tans = M\n\n\t_ma, _mb = ma, mb\n\n\twhile _ma < 410 > _mb:\n\n\t\tans = min(ans, dp[_ma][_mb])\n\n\t\t_ma += ma\n\n\t\t_mb += mb\n\n\tprint((ans if ans < M else -1))\n\n\n\nif __name__==\"__main__\":\n\n\tmain()", "generated_code": "N = int(eval(input()))\n\nnums = [0 for i in range(100)]\n\nfor i in range(1, N + 1):\n\n    i = str(i)\n\n    nums[int(i[0] + i[-1])] += 1\n\nans = 0\n\nfor i in range(1, 10):\n\n    for j in range(i, 10):\n\n        i = str(i)\n\n        j = str(j)\n\n        if i != j:\n\n            ans += nums[int(i + j)] * nums[int(j + i)] * 2\n\n        else:\n\n            n = nums[int(i + j)]\n\n            ans += n * (n - 1)\n\n            ans += n\n\nprint(ans)", "score": 0.0}
{"golden_code": "n_str = eval(input())\n\nn_int = int(n_str)\n\n# 1 ~ 50000\n\n# 桁数が奇数= 1桁, 3桁, 5桁\n\n# 1 ~ 9, 100 ~ 999,10000 ~ 99999の90909個しかないので全探索いけるか?\n\nexs_list = []\n\nfor i in range(1, 100000):\n\n    if len(str(i)) % 2 == 1:\n\n        exs_list.append(i)\n\n\n\nexs = {i: i for i in exs_list}\n\n\n\nn_s = []\n\nans = 0\n\nfor i in range(1, n_int + 1):\n\n    if len(str(i)) % 2 == 0:\n\n        continue\n\n    if i in exs:\n\n        ans += 1\n\n\n\nprint(ans)\n\n\n\n\n\n\n\n\n\n\n", "generated_code": "def sieve(n):\n\n  is_prime = [True for _ in range(n+1)]\n\n  is_prime[0] = False\n\n  for i in range(2, n+1):\n\n    if is_prime[i-1]:\n\n      j = 2 * i\n\n      while j <= n:\n\n        is_prime[j-1] = False\n\n        j += i\n\n  table = [i for i in range(1, n+1) if is_prime[i-1]]\n\n  return table\n\n\n\nN = int(eval(input()))\n\nA = list(map(int, input().split()))\n\nAmax = max(A)\n\nlis = [0]*(Amax+1)\n\nfor i in range(N):\n\n  lis[A[i]] += 1\n\ntable = sieve(Amax)\n\nsetwise = False\n\nfor t in table:\n\n  cnt = sum(lis[t:Amax+1:t])\n\n  if cnt==N:\n\n    print('not coprime')\n\n    break\n\n  if 2<=cnt<N:\n\n    setwise=True\n\nelse:\n\n  if setwise==True:\n\n    print('setwise coprime')\n\n  else:\n\n    print('pairwise coprime')\n", "score": 0.0}
{"golden_code": "def check(x, y):\n\n    for a, b in zip(x, y):\n\n        if a != b and b != -1:\n\n            return False\n\n    else:\n\n        return True\n\n\n\n\n\nn = int(eval(input()))\n\nremarks = []\n\ncnt_max = 0\n\nfor _ in range(n):\n\n    a = int(eval(input()))\n\n    x = [tuple(map(int, input().split())) for i in range(a)]\n\n    r = [-1] * n\n\n    for i, j in x:\n\n        r[i - 1] = j\n\n    remarks.append(r)\n\nfor r in range(2 ** n):\n\n    r = list(bin(r)[2:].zfill(n))\n\n    r = [int(i) for i in r[:]]\n\n    cnt = 0\n\n    for i in range(n):\n\n        if r[i] == 1:\n\n            flag = check(r, remarks[i])\n\n            cnt += 1\n\n            if not flag:\n\n                cnt = 0\n\n                break\n\n    cnt_max = max(cnt, cnt_max)\n\nprint(cnt_max)", "generated_code": "import sys\n\nsys.setrecursionlimit(100000)\n\n\n\ndef intinput(): return list(map(int,sys.stdin.readline().split()))\n\n\n\n\n\nn, m = intinput()\n\na = {int(sys.stdin.readline()) for _ in range(m)}\n\nmemo = [0 for x in range(n + 4)]\n\nmemo[0] = 1\n\nmod = 10 ** 9 + 7\n\nfor i in range(n):\n\n    if i + 1 not in a:\n\n        memo[i + 1] = (memo[i + 1] + memo[i]) % mod\n\n    if i + 2 not in a:\n\n        memo[i + 2] = (memo[i + 2] + memo[i]) % mod\n\nprint((memo[n]))", "score": 0.0}
{"golden_code": "A, B, C, X, Y = list(map(int, input().split()))\n\n\n\nans = 5000 * 2 * 10 ** 5\n\nfor i in range(10 ** 5 + 1):\n\n    s = i * 2 * C + max(0, X - i) * A + max(0, Y - i) * B\n\n    ans = min(ans, s)\n\n\n\nprint(ans)", "generated_code": "import sys\n\ninput = sys.stdin.readline\n\nread = sys.stdin.read\n\n\n\nn = int(eval(input()))\n\nA = list(map(int, read().split()))\n\nL = sorted([(j, i) for i, j in enumerate(A)])\n\ncount = 0\n\nfor i in range(n):\n\n  count += (L[i][1]-i)%2\n\nans = (count+1) // 2\n\nprint(ans)\n", "score": 0.0}
{"golden_code": "from collections import Counter\n\nS = input()[::-1]\n\n\n\nmemo = [0]\n\nd = 0\n\nmod = 2019\n\n\n\nfor s in S:\n\n    tmp = int(s) * pow(10, d, mod) % mod\n\n    tmp = memo[-1] + tmp\n\n    memo.append(tmp % mod)\n\n    d += 1\n\n\n\nc = Counter(memo)\n\nans = sum(v * (v - 1) // 2 for v in list(c.values()))\n\nprint(ans)", "generated_code": "from math import floor, sqrt\n\nfrom collections import Counter\n\n\n\nMOD = 10 ** 9 + 7\n\n\n\n# xを素因数分解する\n\ndef getPrimeFactor(x):\n\n    ans = []\n\n    for d in range(2, floor(sqrt(x)) + 1):\n\n        while x % d == 0:\n\n            ans.append(d)\n\n            x //= d\n\n    if x != 1:\n\n        ans.append(x)\n\n    return ans\n\n\n\ndef comb(n, k):\n\n    k = min(k, n - k)\n\n    ans = 1\n\n    for i in range(n, n - k, -1):\n\n        ans *= i\n\n    for i in range(1, k + 1):\n\n        ans //= i \n\n    return ans\n\n\n\n\n\nN, M = list(map(int, input().split()))\n\n\n\nPFs = getPrimeFactor(M)\n\ncnt = Counter(PFs)\n\n\n\nans = 1\n\nfor num in list(cnt.values()):\n\n    ans *= comb(N + num - 1, num)\n\nprint((ans % MOD))\n", "score": 0.0}
{"golden_code": "import numpy as np\n\nn = int(eval(input()))\n\nal = list(map(int,input().split()))\n\n\n\nfor i in range(n):\n\n    al[i] -= i + 1\n\n\n\nmed = np.median(np.array(al))\n\n\n\nans = 0\n\nfor a in al:\n\n    ans += abs(a-med)\n\nprint((int(ans)))", "generated_code": "N = int(eval(input()))\n\np = 1\n\nfor i in range(1,N+1):\n\n    p *= i\n\n    p %= 1000000007\n\nprint(p)\n", "score": 0.0}
{"golden_code": "from collections import deque\n\nfrom copy import deepcopy, copy\n\ndy = [-1, 0, 0, 1]\n\ndx = [0, -1, 1, 0]\n\nN = 3\n\ndef g(i, j, a):\n\n    t = a // (10 ** j) % 10\n\n    return a - t * (10 ** j) + t * (10 ** i)\n\ndef MAIN():\n\n    m = {8:{7, 5}, 7:{8, 6, 4}, 6:{7, 3}, 5:{8, 4, 2}, 4:{7, 5, 3, 1}, 3:{6, 4, 0}, 2:{5, 1}, 1:{4, 2, 0}, 0:{3, 1}}\n\n    MAP = \"\".join(input().replace(\" \", \"\") for _ in range(N))\n\n    start = 8 - MAP.find(\"0\")\n\n    MAP = int(MAP)\n\n    goal = ('1', '2', '3', '4', '5', '6', '7', '8', '0')\n\n    goal = 123456780\n\n    dp = deque([(0, start, MAP)])\n\n    LOG = {MAP}\n\n    while dp:\n\n        cnt, yx, M = dp.popleft()\n\n        if M == goal:\n\n            print(cnt)\n\n            break\n\n        cnt += 1\n\n        for nyx in m[yx]:\n\n            CM = g(yx, nyx, M)\n\n            if not CM in LOG:\n\n                dp.append((cnt, nyx, CM))\n\n                LOG.add(CM)\n\nMAIN()\n\n\n", "generated_code": "A, B = list(map(int,input().split()))\n\n\n\nans = 0\n\nfor n in range(A, B+1):\n\n    n = str(n)\n\n    if n == n[::-1]:\n\n        ans += 1\n\nprint(ans)", "score": 0.0}
{"golden_code": "import numpy as np\n\nN = int(eval(input()))\n\nV = np.array([int(i) for i in input().split(\" \")])\n\nC = np.array([int(i) for i in input().split(\" \")])\n\n\n\nvc = V-C\n\n\n\nval = 0\n\n\n\nfor i in range(N):\n\n    if vc[i]>0:\n\n        val+=vc[i]\n\nprint(val)", "generated_code": "def solve():\n\n\tfrom collections import deque\n\n\tn,*t=list(map(int,open(0).read().split()))\n\n\tcon=[[] for _ in range(n)]\n\n\tdist_f_k=[0]*n\n\n\tl1,l2=t[:3*n-3],t[3*n-1:]\n\n\n\n\tfor a,b,c in zip(*[iter(l1)]*3):\n\n\t\tcon[a-1].append((b-1,c))\n\n\t\tcon[b-1].append((a-1,c))\n\n\n\n\tk=t[3*n-2]\n\n\tque=deque([k-1])\n\n\twhile que:\n\n\t\tcur=que.popleft()\n\n\t\tfor nxt,dd in con[cur]:\n\n\t\t\tif dist_f_k[nxt]==0 and nxt!=k-1:\n\n\t\t\t\tque.append(nxt)\n\n\t\t\t\tdist_f_k[nxt]=dist_f_k[cur]+dd\n\n\n\n\tfor x,y in zip(*[iter(l2)]*2):\n\n\t\tprint((dist_f_k[x-1]+dist_f_k[y-1]))\n\n\t\t\n\nif __name__==\"__main__\":\n\n\tsolve()", "score": 0.0}
{"golden_code": "n = int(eval(input()))\n\nimport math\n\nm = int(math.sqrt(n))+1\n\nanss = []\n\nfor x in range(1, m+1):\n\n  y = n//x\n\n  z = n%x\n\n  if z == 0:\n\n    anss.append(abs(x-1)+abs(y-1))\n\nprint((min(anss)))\n", "generated_code": "n=int(eval(input()))\n\na=list(map(int,input().split()))\n\nl=sorted([[inx+1,j] for inx,j in enumerate(a)],key=lambda x:x[1])\n\nans=[i for i,j in l]\n\nprint((*ans))", "score": 0.0}
{"golden_code": "# ABC 155 C\n\nfrom collections import Counter\n\nimport numpy as np\n\nN = int(eval(input()))\n\nS = [str(eval(input())) for i in range(N)]\n\nS = np.array(S)\n\n\n\ncount = Counter(S)\n\nmax_num = max(count.values())\n\nmax_list = [i for i,j in list(count.items()) if j==max_num]\n\n\n\nmax_list.sort()\n\nprint(('\\n'.join(max_list)))", "generated_code": "n = int(eval(input()))\n\nfrom functools import reduce\n\nprint((reduce(lambda x,y:x*y%1000000007,list(range(1,n+1)))))", "score": 0.0}
{"golden_code": "def main():\n\n    x = int(eval(input()))\n\n    for a in range(-120, 121):\n\n        for b in range(-120, 121):\n\n            if a**5 - b**5 == x:\n\n                print((a, b))\n\n                return\n\n\n\nif __name__ == \"__main__\":\n\n    main()", "generated_code": "# Problem https://atcoder.jp/contests/abc053/tasks/abc053_b\n\n# Python 2nd Try\n\n\n\n\n\ndef solver(string):\n\n    result = 200000\n\n    aposi = 0\n\n    zposi = len(string)\n\n    for j in range(0, len(string), 1):\n\n        if string[j] == 'A':\n\n            aposi = j\n\n            break\n\n    for j in range(len(string)-1, -1, -1):\n\n        if string[j] == 'Z':\n\n            zposi = j\n\n            break\n\n    result = zposi - aposi + 1\n\n    return result\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    s = eval(input())\n\n    print(('{}'.format(solver(s))))\n", "score": 0.0}
{"golden_code": "n,m,k=list(map(int,input().split()))\n\nmod=10**9+7\n\nf=[1]\n\nfor i in range(2*10**5+7):f+=[f[-1]*(i+1)%mod]\n\ndef comb(a,b):return f[a]*pow(f[b],mod-2,mod)*pow(f[a-b],mod-2,mod)%mod\n\nans=0\n\nfor i in range(1,n):\n\n  ans+=(i*(n-i)*m**2)*(comb(n*m-2,k-2))\n\n  ans%=mod\n\nfor i in range(1,m):\n\n  ans+=(i*(m-i)*n**2)*(comb(n*m-2,k-2))\n\n  ans%=mod\n\nprint(ans)", "generated_code": "n = int(eval(input()))\n\nans = 0\n\nfor i in range(1, 10):\n\n  if n % i == 0:\n\n    if n / i < 10:\n\n      ans = 1\n\nif ans == 0:\n\n  print('No')\n\nelse:\n\n  print('Yes')", "score": 0.0}
{"golden_code": "def getN():\n\n    return int(eval(input()))\n\ndef getNM():\n\n    return list(map(int, input().split()))\n\ndef getList():\n\n    return list(map(int, input().split()))\n\ndef getArray(intn):\n\n    return [int(eval(input())) for i in range(intn)]\n\ndef input():\n\n    return sys.stdin.readline().rstrip()\n\ndef rand_N(ran1, ran2):\n\n    return random.randint(ran1, ran2)\n\ndef rand_List(ran1, ran2, rantime):\n\n    return [random.randint(ran1, ran2) for i in range(rantime)]\n\ndef rand_ints_nodup(ran1, ran2, rantime):\n\n  ns = []\n\n  while len(ns) < rantime:\n\n    n = random.randint(ran1, ran2)\n\n    if not n in ns:\n\n      ns.append(n)\n\n  return sorted(ns)\n\n\n\ndef rand_query(ran1, ran2, rantime):\n\n  r_query = []\n\n  while len(r_query) < rantime:\n\n    n_q = rand_ints_nodup(ran1, ran2, 2)\n\n    if not n_q in r_query:\n\n      r_query.append(n_q)\n\n  return sorted(r_query)\n\n\n\nfrom collections import defaultdict, deque, Counter\n\nfrom sys import exit\n\nfrom decimal import *\n\nfrom heapq import heapify, heappop, heappush\n\nimport math\n\nimport random\n\nimport string\n\nfrom copy import deepcopy\n\nfrom itertools import combinations, permutations, product\n\nfrom operator import mul, itemgetter\n\nfrom functools import reduce\n\nfrom bisect import bisect_left, bisect_right\n\n\n\nimport sys\n\nsys.setrecursionlimit(1000000000)\n\nmod = 10 ** 9 + 7\n\n\n\n#############\n\n# Main Code #\n\n#############\n\n\n\nS = getN()\n\n\n\n# 逆元事前処理ver\n\n# nが小さい場合に\n\nlim = 10 ** 5 + 1\n\nfact = [1, 1]\n\nfactinv = [1, 1]\n\ninv = [0, 1]\n\n\n\nfor i in range(2, lim + 1):\n\n    fact.append((fact[-1] * i) % mod)\n\n    inv.append((-inv[mod % i] * (mod // i)) % mod)\n\n    # 累計\n\n    factinv.append((factinv[-1] * inv[-1]) % mod)\n\n\n\ndef cmb(n, r):\n\n    if (r < 0) or (n < r):\n\n        return 0\n\n    r = min(r, n - r)\n\n    return fact[n] * factinv[r] * factinv[n - r] % mod\n\n\n\nans = 0\n\n# 長さNの時最低でも3 * N使う\n\n# 残りは分配する\n\nfor i in range(1, 2001):\n\n    s = S - (3 * i)\n\n    if s < 0:\n\n        break\n\n    # sをN個に分配する通りがいくつあるか\n\n    # 重複組み合わせ\n\n    # 仕切りの数はi - 1個\n\n    ans += cmb(s + i - 1, i - 1)\n\nprint((ans % mod))", "generated_code": "import sys\n\nread = sys.stdin.readline\n\n\n\n\n\ndef read_ints():\n\n    return list(map(int, read().split()))\n\n\n\n\n\ndef read_a_int():\n\n    return int(read())\n\n\n\n\n\ndef read_matrix(H):\n\n    '''\n\n    H is number of rows\n\n    '''\n\n    return [list(map(int, read().split())) for _ in range(H)]\n\n\n\n\n\ndef read_map(H):\n\n    '''\n\n    H is number of rows\n\n    文字列で与えられた盤面を読み取る用\n\n    '''\n\n    return [read()[:-1] for _ in range(H)]\n\n\n\n\n\ndef read_tuple(H):\n\n    '''\n\n    H is number of rows\n\n    '''\n\n    ret = []\n\n    for _ in range(H):\n\n        ret.append(tuple(map(int, read().split())))\n\n    return ret\n\n\n\n\n\ndef read_col(H, n_cols):\n\n    '''\n\n    H is number of rows\n\n    n_cols is number of cols\n\n\n\n    A列、B列が与えられるようなとき\n\n    '''\n\n    ret = [[] for _ in range(n_cols)]\n\n    for _ in range(H):\n\n        tmp = list(map(int, read().split()))\n\n        for col in range(n_cols):\n\n            ret[col].append(tmp[col])\n\n\n\n    return ret\n\n\n\n\n\nN, K = read_ints()\n\nP = read_ints()\n\n\n\n\n\ndef ret_mean(X):\n\n    return (X + 1) / 2\n\n\n\n\n\n\n\nclass cumsum1d:\n\n    def __init__(self, ls: list):\n\n        '''\n\n        1次元リストを受け取る\n\n        '''\n\n        from itertools import accumulate\n\n        self.ls_accum = [0] + list(accumulate(ls))\n\n\n\n    def total(self, i, j):\n\n        # もとの配列lsにおける[i,j)の中合計\n\n        return self.ls_accum[j] - self.ls_accum[i]\n\n      \n\nP_mean = [ret_mean(p) for p in P]\n\nP_accum = cumsum1d(P_mean)\n\n\n\nans = 0\n\n# print(P_accum)\n\nfor i in range(N - K + 1):\n\n    j = i + K\n\n    ans = max(ans, P_accum.total(i,j))\n\nprint(ans)\n", "score": 0.0}
{"golden_code": "k = int(eval(input()))\n\ncount = 1\n\nn = 0\n\nif k % 2 == 0 or k % 5 == 0:\n\n    print((-1))\n\nelse:\n\n  while 1:\n\n      n = (n * 10 + 7) % k  \n\n      if n == 0:\n\n        break \n\n      count += 1\n\n  print(count)", "generated_code": "a_1=list(map(int, input().split()))\n\na_2=list(map(int, input().split()))\n\na_3=list(map(int, input().split()))\n\n\n\nc=[a_1,a_2,a_3]\n\n\n\nN=int(eval(input()))\n\n\n\nb=[int(eval(input())) for _ in range(N)]\n\n\n\nfor i in range(3):\n\n    for j in range(3):\n\n        if c[i][j] in b:\n\n            c[i][j]=0\n\n            \n\n            \n\ni=0\n\nif c[0][0]==0 and c[0][1]==0 and c[0][2]==0:\n\n    i+=1\n\nif c[1][0]==0 and c[1][1]==0 and c[1][2]==0:\n\n    i+=1\n\nif c[2][0]==0 and c[2][1]==0 and c[2][2]==0:\n\n    i+=1\n\nif c[0][0]==0 and c[1][0]==0 and c[2][0]==0:\n\n    i+=1\n\nif c[0][1]==0 and c[1][1]==0 and c[2][1]==0:\n\n    i+=1\n\nif c[0][2]==0 and c[1][2]==0 and c[2][2]==0:\n\n    i+=1\n\nif c[0][0]==0 and c[1][1]==0 and c[2][2]==0:\n\n    i+=1\n\nif c[0][2]==0 and c[1][1]==0 and c[2][0]==0:\n\n    i+=1\n\n    \n\nif i>0:\n\n    print(\"Yes\")\n\nelse:\n\n  print(\"No\")", "score": 0.0}
{"golden_code": "import numpy as np\n\nn=int(eval(input()))\n\ns=np.argsort(np.array(list(map(int,input().split()))))+1\n\nprint((*s))", "generated_code": "# coding: utf-8\n\n# Your code here!\n\nimport sys\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\n\n\n#a,b,c,d = map(int,readline().split())\n\ns,k = readline().split()\n\n\n\n\n\na = [len(i) for i in s.split(\"0\")]\n\nwhile a and a[-1] == 0: a.pop()\n\n\n\nif not a:\n\n    print((1))\n\n    exit()\n\n\n\nMOD = 998244353\n\n\n\nM = sum(a)+1\n\nk = min(int(k),M)\n\n\n\n\n\ndp = [[0]*M for _ in range(k+1)] # j 使って（上限 k）、l 余ってる\n\ndp[0][0] = 1\n\n\n\n#print(a)\n\nfor ai in a[::-1]:\n\n    ndp = [[0]*M for _ in range(k+1)] # j 使って（上限 k）、l 余ってる\n\n    for j in range(k+1):\n\n        for l in range(M):\n\n            if dp[j][l]:\n\n                for ll in range(l):\n\n                    ndp[j][ll] += dp[j][l]\n\n                    ndp[j][ll] %= MOD\n\n\n\n                V = min(M-l,k-j+1,ai+1)\n\n                for i in range(V):\n\n                    #if j+i > k: break\n\n                    ndp[j+i][l+i] += dp[j][l]\n\n                    ndp[j+i][l+i] %= MOD\n\n    \n\n    dp = ndp\n\n    #print(dp)\n\n\n\nans = 0\n\nfor jj in range(k+1):\n\n    ans += dp[jj][0]\n\n\n\nprint((ans%MOD))\n\n\n\n\n\n\n\n\n\n\n", "score": 0.0}
{"golden_code": "N=int(eval(input()))\n\na=list(map(int,input().split()))\n\nfor i in range(N):\n\n  for j in range(1,31):\n\n    if a[i]%(2**j)!=0:\n\n      a[i]=j-1\n\n      break\n\nprint((sum(a)))", "generated_code": "mod = 2019\n\nl, r = list(map(int, input().split()))\n\n\n\nif r//mod - l//mod > 0:\n\n  print((0))\n\nelse:\n\n  l %= mod\n\n  r %= mod\n\n  ans = mod\n\n  for i in range(l, r):\n\n    for j in range(i+1, r+1):\n\n      ans = min(i*j%mod, ans)\n\n    if ans == 0:\n\n      break\n\n  print(ans)", "score": 0.0}
{"golden_code": "a,b,c=list(map(int,input().split()))\n\ne=(a-b)|(b-c)\n\nprint((bool(e|(a|b|c)%2)*(e^~-e).bit_length()-1))", "generated_code": "a, b = list(map(int, input().split()))\n\nans = 0\n\n\n\nfor i in range(a,b+1):\n\n    seki_gyaku = str(i)\n\n    if seki_gyaku == seki_gyaku[::-1]:\n\n        ans += 1\n\n\n\nprint(ans)\n", "score": 0.0}
{"golden_code": "import math\n\nprint((math.factorial(int(eval(input())))%(10**9+7)))", "generated_code": "def digit_sum(n):\n\n    # 各桁の和を求める\n\n    # 計算量: O(logN)\n\n    ans = 0\n\n    while n > 0:\n\n        ans += 1\n\n        n //= 10\n\n    return ans\n\n\n\nn = int(eval(input()))\n\ncnt = 0\n\n\n\nfor i in range(1, n+1):\n\n    cnt += digit_sum(i) % 2\n\n\n\nprint(cnt)\n", "score": 0.0}
{"golden_code": "N, K = list(map(int, input().split()))\n\nS = eval(input())\n\nnums = []\n\nnow = 1\n\ncnt = 0\n\nfor i in range(N):\n\n    if S[i] == str(now):\n\n        cnt += 1\n\n    else:\n\n        nums.append(cnt)\n\n        now = 1 - now\n\n        cnt = 1\n\nif cnt != 0:\n\n    nums.append(cnt)\n\nif len(nums) % 2 == 0:\n\n    nums.append(0)\n\n\n\nadd = 2 * K + 1\n\nans = 0\n\nleft = 0\n\nright = 0\n\ntmp = 0\n\nfor i in range(0, len(nums), 2):\n\n\n\n    next_left = i\n\n    next_right = min(i + add, len(nums))\n\n\n\n    while next_left > left:\n\n        tmp -= nums[left]\n\n        left += 1\n\n\n\n    while next_right > right:\n\n        tmp += nums[right]\n\n        right += 1\n\n\n\n    ans = max(ans, tmp)\n\nprint(ans)", "generated_code": "postorder_elements = []\n\n\n\ndef post_from_pre_in(preorder_elements, inorder_elements):\n\n    if preorder_elements:\n\n        root = preorder_elements[0]\n\n        root_index = inorder_elements.index(root)\n\n        preorder_left = preorder_elements[1:root_index+1]\n\n        inorder_left = inorder_elements[:root_index]\n\n        preorder_right = preorder_elements[root_index+1:]\n\n        inorder_right = inorder_elements[root_index+1:]\n\n        post_from_pre_in(preorder_left, inorder_left)\n\n        post_from_pre_in(preorder_right, inorder_right)\n\n        postorder_elements.append(root)\n\n\n\n\n\n\n\nn = int(eval(input()))\n\n\n\na = list(map(int, input().split()))\n\nb = list(map(int, input().split()))\n\n\n\npost_from_pre_in(a, b)\n\n\n\nprint((*postorder_elements))", "score": 0.0}
{"golden_code": "n,q = list(map(int,input().split()))\n\nqueue = []\n\nfor i in range(n):\n\n\tname,time = input().split()\n\n\tqueue.append([name, int(time)])\n\n\n\nt = 0\n\ni = 0\n\nwhile queue:\n\n\ti %= len(queue)\n\n\tp = queue[i]\n\n\tt += min(q, p[1])\n\n\tif p[1] > q:\n\n\t\tp[1] -= q\n\n\t\ti += 1\n\n\telse:\n\n\t\tprint((p[0], t))\n\n\t\tqueue.pop(i)\n", "generated_code": "a,b = list(map(int, input().split()))\n\nn = [i for i in map(str, list(range(a,b+1))) if i==i[::-1]]\n\nprint((len(n)))", "score": 0.0}
{"golden_code": "# -*- coding: utf-8 -*-\n\n\n\n\"\"\"\n\n参考：http://drken1215.hatenablog.com/entry/2018/09/23/224100\n\n　　　http://tutuz.hateblo.jp/entry/2018/09/24/121248\n\n・素因数分解と重複組み合わせ\n\n・毎回階乗やると死ぬから階乗と逆元のテーブル作る(忘れてた)\n\n\"\"\"\n\n\n\nfrom collections import defaultdict\n\nfrom math import sqrt\n\n\n\nMOD = 10 ** 9 + 7\n\n\n\ndef fact_prime(num):\n\n    d = defaultdict(int)\n\n    # 終点はルート切り捨て+1\n\n    end = int(sqrt(num)) + 1\n\n    for i in range(2, end+1):\n\n        cnt = 0\n\n        # 素因数分解：小さい方から割れるだけ割って素数をカウント\n\n        while num % i == 0:\n\n            num //= i\n\n            d[i] += 1\n\n        # 1まで来たら終了\n\n        if num == 1:\n\n            break\n\n    # 最後までそのまま来たやつはnumが素数(ただし1^1は1^0なので数に入れない)\n\n    if num != 1:\n\n        d[num] += 1\n\n    return d\n\n\n\n# とりあえずv+N-1が収まればいいはず\n\nMAX = 10 ** 5 * 2\n\n# 予め組み合わせ計算に必要な階乗と逆元のテーブルを作っておく\n\nfactorial = [1] * (MAX)\n\nfactorial[0] = factorial[1] = 1\n\nfor i in range(2, MAX):\n\n    factorial[i] = factorial[i-1] * i % MOD\n\n\n\ninverse = [1] * (MAX)\n\n# powに第三引数入れると冪乗のmod付計算を高速にやってくれる\n\ninverse[MAX-1] = pow(factorial[MAX-1], MOD-2, MOD)\n\nfor i in range(MAX-2, 0, -1):\n\n    # 最後から戻っていくこのループならH+W回powするより処理が速い\n\n    inverse[i] = inverse[i+1] * (i+1) % MOD\n\n\n\n# 組み合わせの数\n\ndef nCr(n, r):\n\n    # 10C7 = 10C3\n\n    r = min(r, n-r)\n\n    # 分子の計算\n\n    numerator = factorial[n]\n\n    # 分母の計算\n\n    denominator = inverse[r] * inverse[n-r] % MOD\n\n    return numerator * denominator % MOD\n\n\n\nN, M = list(map(int, input().split()))\n\n\n\n# d = fact_prime(M)\n\n# print(d)\n\nans = 1\n\nfor k, v in list(fact_prime(M).items()):\n\n    # 重複組み合わせ\n\n    # v個のkとN-1個の仕切りから、v個を並べる(v+N-1個のマスからv個を選び出す組み合わせ)\n\n    ans = (ans * nCr(v+N-1, v)) % MOD\n\nprint(ans)\n", "generated_code": "N,M=list(map(int,input().split()))\n\nA = [[1 for _ in range(M)]]+[[0 for _ in range(M)] for _ in range(N)]\n\nfor i in range(1,N+1):\n\n    B=list(map(int,input().split()))\n\n    Ai=B[1:]\n\n    for m in Ai:\n\n        A[i][m-1]=A[i-1][m-1]\n\na=sum(A[N])\n\nprint((int(a)))", "score": 0.0}
{"golden_code": "N,K=list(map(int,input().split()))\n\na = [[0]*N]*K\n\na = [[0 for n in range(N)] for k in range(K)]\n\n\n\nfor k in range(K):\n\n    d=int(eval(input()))\n\n    have_k=list(map(int,input().split()))\n\n    for h in have_k:\n\n        a[k][h-1]=1\n\n\n\nan=[0]*N\n\nfor k in range(K):\n\n  for n in range(N):\n\n    an[n] = an[n]+a[k][n]\n\n\n\nresult=0\n\nfor i in an:\n\n  if i == 0:\n\n    result+=1\n\n\n\nprint(result)", "generated_code": "import sys\n\ninput = sys.stdin.readline\n\nsys.setrecursionlimit(10**7)\n\nINF = 10**10\n\nMOD = 10**9 + 7\n\nX = int(eval(input()))\n\nMAX_X = 10**9\n\nn = 0\n\nwhile(1):\n\n    n+=1\n\n    if n**5 - (n-1)**5 > MAX_X:\n\n        break\n\nfor i in range(n):\n\n    for j in range(-n+1,n-1):\n\n        if i**5 - j**5 == X:\n\n            print((i,j))\n\n            exit()\n\n   ", "score": 0.0}
{"golden_code": "import sys\n\ninput = sys.stdin.readline\n\nsys.setrecursionlimit(10**7)\n\nINF = 10**10\n\nMOD = 10**9 + 7\n\nX = int(eval(input()))\n\nfor i in range(1000):\n\n    for j in range(-1000,1000):\n\n        #print (i**5 - j**5)\n\n        if i**5 - j**5 == X:\n\n            print((i,j))\n\n            exit()\n\n   ", "generated_code": "import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\nimport itertools\n\n\n\nN,X,*L = list(map(int,read().split()))\n\n\n\nanswer = sum(x <= X for x in itertools.accumulate([0]+L))\n\nprint(answer)", "score": 0.0}
