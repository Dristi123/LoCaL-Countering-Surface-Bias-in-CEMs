{"id": "LOCAL_APPS_1244_20_MUT_23", "golden_code": "import sys\nimport math\n\nn = int(sys.stdin.readline())\nan = [int(x) for x in sys.stdin.readline().split()]\n\nd = dict()\n\nfor i in an:\n    if i in d:\n        d[i] += 1\n    else:\n        d[i] = 1\n\nvmax = 0\nvsum = 0\nfor i in list(d.keys()):\n    vsum += d[i]\n    if d[i] > vmax:\n        vmax = d[i]\n\nif vsum - vmax >= vmax - 1:\n    print('YES')\nelse:\n    print('NO')", "generated_code": "import sys\nimport math\n\nn = int(sys.stdin.readline())\nan = [int(x) for x in sys.stdin.readline().split()]\n\npass\n\nfor i in an:\n    if i in d:\n        d[i] += 1\n    else:\n        d[i] = 1\n\nvmax = 0\nvsum = 0\nfor i in list(d.keys()):\n    vsum += d[i]\n    if d[i] > vmax:\n        vmax = d[i]\n\nif vsum - vmax >= vmax - 1:\n    print('YES')\nelse:\n    print('NO')", "score": 0.0, "codebleu": 0.837653383047801, "crystalbleu": 0.92, "codebertscore": 0.99, "codescore": 0.9939099550247192, "surfaceSim": 0.9696581196581197, "abs_surfaceSim_minus_score": 0.9696581196581197, "codescore_abs_err_vs_score": 0.9939099550247192, "_worst_metric": "codescore", "_worst_rank": 1}
{"id": "LOCAL_PIE_p02612_s197156959_MUT_31", "golden_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "generated_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    pass", "score": 0.0, "codebleu": 0.9835091893087673, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.9939086437225342, "surfaceSim": 0.9596376399165244, "abs_surfaceSim_minus_score": 0.9596376399165244, "codescore_abs_err_vs_score": 0.9939086437225342, "_worst_metric": "codescore", "_worst_rank": 2}
{"id": "LOCAL_APPS_1244_20_MUT_28", "golden_code": "import sys\nimport math\n\nn = int(sys.stdin.readline())\nan = [int(x) for x in sys.stdin.readline().split()]\n\nd = dict()\n\nfor i in an:\n    if i in d:\n        d[i] += 1\n    else:\n        d[i] = 1\n\nvmax = 0\nvsum = 0\nfor i in list(d.keys()):\n    vsum += d[i]\n    if d[i] > vmax:\n        vmax = d[i]\n\nif vsum - vmax >= vmax - 1:\n    print('YES')\nelse:\n    print('NO')", "generated_code": "import sys\nimport math\n\nn = int(sys.stdin.readline())\nan = [int(x) for x in sys.stdin.readline().split()]\n\nd = dict()\n\nfor i in an:\n    if i in d:\n        d[i] += 1\n    else:\n        d[i] = 1\n\nvmax = 0\nvsum = 0\nfor i in list(d.keys()):\n    vsum += d[i]\n    if d[i] > vmax:\n        vmax = d[i]\n\nif vsum - vmax >= vmax - 1:\n    pass\nelse:\n    print('NO')", "score": 0.0, "codebleu": 0.9756249040099523, "crystalbleu": 0.91, "codebertscore": 0.99, "codescore": 0.9939080476760864, "surfaceSim": 0.965491452991453, "abs_surfaceSim_minus_score": 0.965491452991453, "codescore_abs_err_vs_score": 0.9939080476760864, "_worst_metric": "codescore", "_worst_rank": 3}
{"id": "LOCAL_APPS_1244_20_MUT_22", "golden_code": "import sys\nimport math\n\nn = int(sys.stdin.readline())\nan = [int(x) for x in sys.stdin.readline().split()]\n\nd = dict()\n\nfor i in an:\n    if i in d:\n        d[i] += 1\n    else:\n        d[i] = 1\n\nvmax = 0\nvsum = 0\nfor i in list(d.keys()):\n    vsum += d[i]\n    if d[i] > vmax:\n        vmax = d[i]\n\nif vsum - vmax >= vmax - 1:\n    print('YES')\nelse:\n    print('NO')", "generated_code": "import sys\nimport math\n\nn = int(sys.stdin.readline())\npass\n\nd = dict()\n\nfor i in an:\n    if i in d:\n        d[i] += 1\n    else:\n        d[i] = 1\n\nvmax = 0\nvsum = 0\nfor i in list(d.keys()):\n    vsum += d[i]\n    if d[i] > vmax:\n        vmax = d[i]\n\nif vsum - vmax >= vmax - 1:\n    print('YES')\nelse:\n    print('NO')", "score": 0.0, "codebleu": 0.6989911023636715, "crystalbleu": 0.79, "codebertscore": 0.97, "codescore": 0.993902325630188, "surfaceSim": 0.8825854700854701, "abs_surfaceSim_minus_score": 0.8825854700854701, "codescore_abs_err_vs_score": 0.993902325630188, "_worst_metric": "codescore", "_worst_rank": 4}
{"id": "LOCAL_PIE_p02612_s197156959_MUT_30", "golden_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "generated_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        pass\n    print(n)", "score": 0.0, "codebleu": 0.9464720378337097, "crystalbleu": 0.97, "codebertscore": 1.0, "codescore": 0.9939004182815552, "surfaceSim": 0.9768307721494973, "abs_surfaceSim_minus_score": 0.9768307721494973, "codescore_abs_err_vs_score": 0.9939004182815552, "_worst_metric": "codescore", "_worst_rank": 5}
{"id": "LOCAL_APPS_1124_69_MUT_7", "golden_code": "from math import gcd\n\nn = int(input())\nl = list(map(int, input().split()))\n\nGCD = l[0]\nfor i in range(1, n):\n    GCD = gcd(GCD, l[i])\n\nprint(GCD)", "generated_code": "from math import gcd\n\npass\nl = list(map(int, input().split()))\n\nGCD = l[0]\nfor i in range(1, n):\n    GCD = gcd(GCD, l[i])\n\nprint(GCD)", "score": 0.0, "codebleu": 0.7028755134745137, "crystalbleu": 0, "codebertscore": 0.98, "codescore": 0.9938997030258179, "surfaceSim": 0.9218390804597701, "abs_surfaceSim_minus_score": 0.9218390804597701, "codescore_abs_err_vs_score": 0.9938997030258179, "_worst_metric": "codescore", "_worst_rank": 6}
{"id": "LOCAL_APPS_1315_2_MUT_31", "golden_code": "import math, string, itertools, fractions, heapq, collections, re, array, bisect, copy\nfrom itertools import chain, dropwhile, permutations, combinations\nfrom collections import defaultdict, deque\n\ndef VI():\n    return list(map(int, input().split()))\ndef run(n, a):\n    b = copy.copy(a)\n    for i in range(n):\n        b[i] -= n - i\n    b.sort()\n    for i in range(n):\n        if i < n - 1:\n            if b[i] == b[i + 1]:\n                print(':(')\n                return\n        b[i] = str(b[i] + (n - i))\n    print(' '.join(b))\n\n\ndef main(info=0):\n    n = int(input())\n    a = VI()\n    run(n, a)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "generated_code": "import math, string, itertools, fractions, heapq, collections, re, array, bisect, copy\nfrom itertools import chain, dropwhile, permutations, combinations\nfrom collections import defaultdict, deque\n\ndef VI():\n    return list(map(int, input().split()))\ndef run(n, a):\n    b = copy.copy(a)\n    for i in range(n):\n        b[i] -= n - i\n    b.sort()\n    for i in range(n):\n        if i < n - 1:\n            if b[i] == b[i + 1]:\n                print(':(')\n                return\n        b[i] = str(b[i] + (n - i))\n    print(' '.join(b))\n\n\ndef main(info=0):\n    n = int(input())\n    a = VI()\n    run(n, a)\n\ndef __starting_point():\n    main()\n\npass", "score": 0.0, "codebleu": 0.9832532323420162, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.9938991069793701, "surfaceSim": 0.969165757906216, "abs_surfaceSim_minus_score": 0.969165757906216, "codescore_abs_err_vs_score": 0.9938991069793701, "_worst_metric": "codescore", "_worst_rank": 7}
{"id": "LOCAL_APPS_13_1_MUT_44", "golden_code": "import sys\n\ndef main():\n    \n    (n, k) = map(int, sys.stdin.readline().split())\n    courses = list(map(int, sys.stdin.readline().split()))\n    courses = [x - 1 for x in courses]\n    \n    visited = [False] * n\n    used = [False] * n\n    \n    ans = []\n    t = []\n    \n    for i in range(n):\n        temp = list(map(int, sys.stdin.readline().split()))\n        temp = [x - 1 for x in temp]\n        t.append(temp[1:])\n    \n    for i in range(k):\n        c = courses[i]\n        if used[c]:\n            continue\n        \n        q = [c]\n        visited[c] = True\n        while len(q) > 0:\n            cur = q[-1]\n            if len(t[cur]) != 0:\n                s = t[cur].pop()\n                if (visited[s] and not (used[s])):\n                    print(-1)\n                    return\n                if used[s]:\n                    continue\n                q.append(s)\n                visited[s] = True\n            else:\n                ans.append(cur)\n                q.pop()\n                used[cur] = True\n    \n    ans = [str(x + 1) for x in ans]\n    print(len(ans))\n    print(' '.join(ans))\n\nmain()", "generated_code": "import sys\n\ndef main():\n    \n    (n, k) = map(int, sys.stdin.readline().split())\n    courses = list(map(int, sys.stdin.readline().split()))\n    courses = [x - 1 for x in courses]\n    \n    visited = [False] * n\n    used = [False] * n\n    \n    ans = []\n    t = []\n    \n    for i in range(n):\n        temp = list(map(int, sys.stdin.readline().split()))\n        temp = [x - 1 for x in temp]\n        pass\n    \n    for i in range(k):\n        c = courses[i]\n        if used[c]:\n            continue\n        \n        q = [c]\n        visited[c] = True\n        while len(q) > 0:\n            cur = q[-1]\n            if len(t[cur]) != 0:\n                s = t[cur].pop()\n                if (visited[s] and not (used[s])):\n                    print(-1)\n                    return\n                if used[s]:\n                    continue\n                q.append(s)\n                visited[s] = True\n            else:\n                ans.append(cur)\n                q.pop()\n                used[cur] = True\n    \n    ans = [str(x + 1) for x in ans]\n    print(len(ans))\n    print(' '.join(ans))\n\nmain()", "score": 0.0, "codebleu": 0.9220012030604536, "crystalbleu": 0.95, "codebertscore": 0.99, "codescore": 0.9938945174217224, "surfaceSim": 0.965956937799043, "abs_surfaceSim_minus_score": 0.965956937799043, "codescore_abs_err_vs_score": 0.9938945174217224, "_worst_metric": "codescore", "_worst_rank": 8}
{"id": "LOCAL_PIE_p02685_s295745028_MUT_2", "golden_code": "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nfac = [1, 1]\nf_inv = [1, 1]\ninv = [0, 1]\ndef prepare(n, mod):\n    for i in range(2, n + 1):\n        fac.append((fac[-1] * i) % mod)\n        inv.append(((-(inv[mod % i])) * (mod // i)) % mod)\n        f_inv.append((f_inv[-1] * inv[-1]) % mod)\ndef cmb(n, r, mod):\n    if (n < 0 or r < 0):\n        return 0\n    if r > n:\n        return 0\n    return ((fac[n] * f_inv[r]) * f_inv[n - r]) % mod\ndef main():\n    (N, M, K) = list(map(int, readline().split()))\n    MOD = 998244353\n    prepare(N + 10, MOD)\n    if (M == 1 and K == N - 1):\n        print(1)\n        exit()\n    m = M\n    for _ in range(N - 1):\n        m *= M - 1\n        m %= MOD\n    ans = 0\n    for k in range(K + 1):\n        ans += (m * cmb(N - 1, k, MOD)) % MOD\n        ans %= MOD\n        m *= pow(M - 1, MOD - 2, MOD)\n        m %= MOD\n    print(ans)", "generated_code": "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nfac = [1, 1]\nf_inv = [1, 1]\ninv = [0, 1]\ndef prepare(n, mod):\n    for i in range(2, n + 1):\n        fac.append((fac[-1] * i) % mod)\n        inv.append((inv[mod % i] * (mod // i)) % mod)\n        f_inv.append((f_inv[-1] * inv[-1]) % mod)\ndef cmb(n, r, mod):\n    if (n < 0 or r < 0):\n        return 0\n    if r > n:\n        return 0\n    return ((fac[n] * f_inv[r]) * f_inv[n - r]) % mod\ndef main():\n    (N, M, K) = list(map(int, readline().split()))\n    MOD = 998244353\n    prepare(N + 10, MOD)\n    if (M == 1 and K == N - 1):\n        print(1)\n        exit()\n    m = M\n    for _ in range(N - 1):\n        m *= M - 1\n        m %= MOD\n    ans = 0\n    for k in range(K + 1):\n        ans += (m * cmb(N - 1, k, MOD)) % MOD\n        ans %= MOD\n        m *= pow(M - 1, MOD - 2, MOD)\n        m %= MOD\n    print(ans)", "score": 0.0, "codebleu": 0.9655976278032165, "crystalbleu": 0.98, "codebertscore": 0.99, "codescore": 0.9938933253288269, "surfaceSim": 0.9972253052164262, "abs_surfaceSim_minus_score": 0.9972253052164262, "codescore_abs_err_vs_score": 0.9938933253288269, "_worst_metric": "codescore", "_worst_rank": 9}
{"id": "LOCAL_APPS_1384_19_MUT_24", "golden_code": "n = int(input())\na = list(map(int, input().split()))\np = [0] * n\np[0] = a[0]\nfor i in range(1, n):\n    p[i] = p[i - 1] + a[i]\nans = min(n, n - p[n - 1])\nfor i in range(n):\n    l = p[i]\n    r = ((n - i) - 1) - (p[n - 1] - p[i])\n    ans = min(ans, l + r)\nprint(n - ans)", "generated_code": "n = int(input())\npass\np = [0] * n\np[0] = a[0]\nfor i in range(1, n):\n    p[i] = p[i - 1] + a[i]\nans = min(n, n - p[n - 1])\nfor i in range(n):\n    l = p[i]\n    r = ((n - i) - 1) - (p[n - 1] - p[i])\n    ans = min(ans, l + r)\nprint(n - ans)", "score": 0.0, "codebleu": 0.7913049704944293, "crystalbleu": 0.81, "codebertscore": 0.98, "codescore": 0.993893027305603, "surfaceSim": 0.8882646691635455, "abs_surfaceSim_minus_score": 0.8882646691635455, "codescore_abs_err_vs_score": 0.993893027305603, "_worst_metric": "codescore", "_worst_rank": 10}
{"id": "LOCAL_APPS_4638_24_MUT_33", "golden_code": "(n, c) = [int(x) for x in input().split()]\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\ndpst = [0] * (n + 1)\ndplift = [0] * (n + 1)\ndpst[2] = a[0]\ndplift[2] = c + b[0]\nfor i in range(3, n + 1):\n    dpst[i] = a[i - 2] + min(dpst[i - 1], dplift[i - 1])\n    dplift[i] = b[i - 2] + min(c + dpst[i - 1], dplift[i - 1])\n\nfor i in range(1, n + 1):\n    print(min(dpst[i], dplift[i]), end=' ')", "generated_code": "(n, c) = [int(x) for x in input().split()]\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\ndpst = [0] * (n + 1)\npass\ndpst[2] = a[0]\ndplift[2] = c + b[0]\nfor i in range(3, n + 1):\n    dpst[i] = a[i - 2] + min(dpst[i - 1], dplift[i - 1])\n    dplift[i] = b[i - 2] + min(c + dpst[i - 1], dplift[i - 1])\n\nfor i in range(1, n + 1):\n    print(min(dpst[i], dplift[i]), end=' ')", "score": 0.0, "codebleu": 0.9133235891120796, "crystalbleu": 0.93, "codebertscore": 0.99, "codescore": 0.9938884377479553, "surfaceSim": 0.9590245520902456, "abs_surfaceSim_minus_score": 0.9590245520902456, "codescore_abs_err_vs_score": 0.9938884377479553, "_worst_metric": "codescore", "_worst_rank": 11}
{"id": "LOCAL_APPS_1039_1_MUT_30", "golden_code": "import sys\ndef input():\n    return sys.stdin.readline().strip()\nfrom collections import deque\ndef main():\n    N = int(input())\n    info = [tuple(map(int, input().split())) for _ in range(N - 1)]\n    (Q, K) = map(int, input().split())\n    queries = [tuple(map(int, input().split())) for _ in range(Q)]\n    \n    to = [[] for _ in range(N)]\n    for (a, b, c) in info:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        to[b].append((a, c))\n    \n    INF = 10 ** 18\n    dist = [INF] * N\n    def dfs(s):\n        stack = deque()\n        push = stack.append\n        pop = stack.pop\n        \n        dist[s] = 0\n        push(s)\n        \n        while stack:\n            now = pop()\n            now_cost = dist[now]\n            \n            for (nv, c) in to[now]:\n                if dist[nv] != INF:\n                    continue\n                dist[nv] = now_cost + c\n                push(nv)\n    \n    \n    K -= 1\n    dfs(K)\n    ans = []\n    for (x, y) in queries:\n        x -= 1\n        y -= 1\n        xy = dist[x] + dist[y]\n        ans.append(xy)\n    \n    print(sep='\\n', *ans)\ndef __starting_point():\n    main()\n__starting_point()", "generated_code": "import sys\ndef input():\n    return sys.stdin.readline().strip()\nfrom collections import deque\ndef main():\n    N = int(input())\n    pass\n    (Q, K) = map(int, input().split())\n    queries = [tuple(map(int, input().split())) for _ in range(Q)]\n    \n    to = [[] for _ in range(N)]\n    for (a, b, c) in info:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        to[b].append((a, c))\n    \n    INF = 10 ** 18\n    dist = [INF] * N\n    def dfs(s):\n        stack = deque()\n        push = stack.append\n        pop = stack.pop\n        \n        dist[s] = 0\n        push(s)\n        \n        while stack:\n            now = pop()\n            now_cost = dist[now]\n            \n            for (nv, c) in to[now]:\n                if dist[nv] != INF:\n                    continue\n                dist[nv] = now_cost + c\n                push(nv)\n    \n    \n    K -= 1\n    dfs(K)\n    ans = []\n    for (x, y) in queries:\n        x -= 1\n        y -= 1\n        xy = dist[x] + dist[y]\n        ans.append(xy)\n    \n    print(sep='\\n', *ans)\ndef __starting_point():\n    main()\n__starting_point()", "score": 0.0, "codebleu": 0.8614871635201261, "crystalbleu": 0.9, "codebertscore": 0.98, "codescore": 0.9938878417015076, "surfaceSim": 0.9641376696591422, "abs_surfaceSim_minus_score": 0.9641376696591422, "codescore_abs_err_vs_score": 0.9938878417015076, "_worst_metric": "codescore", "_worst_rank": 12}
{"id": "LOCAL_PIE_p02612_s197156959_MUT_24", "golden_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "generated_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\npass\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "score": 0.0, "codebleu": 0.8638737972450814, "crystalbleu": 0.95, "codebertscore": 0.99, "codescore": 0.9938872456550598, "surfaceSim": 0.9721826977803074, "abs_surfaceSim_minus_score": 0.9721826977803074, "codescore_abs_err_vs_score": 0.9938872456550598, "_worst_metric": "codescore", "_worst_rank": 13}
{"id": "LOCAL_APPS_1039_1_MUT_57", "golden_code": "import sys\ndef input():\n    return sys.stdin.readline().strip()\nfrom collections import deque\ndef main():\n    N = int(input())\n    info = [tuple(map(int, input().split())) for _ in range(N - 1)]\n    (Q, K) = map(int, input().split())\n    queries = [tuple(map(int, input().split())) for _ in range(Q)]\n    \n    to = [[] for _ in range(N)]\n    for (a, b, c) in info:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        to[b].append((a, c))\n    \n    INF = 10 ** 18\n    dist = [INF] * N\n    def dfs(s):\n        stack = deque()\n        push = stack.append\n        pop = stack.pop\n        \n        dist[s] = 0\n        push(s)\n        \n        while stack:\n            now = pop()\n            now_cost = dist[now]\n            \n            for (nv, c) in to[now]:\n                if dist[nv] != INF:\n                    continue\n                dist[nv] = now_cost + c\n                push(nv)\n    \n    \n    K -= 1\n    dfs(K)\n    ans = []\n    for (x, y) in queries:\n        x -= 1\n        y -= 1\n        xy = dist[x] + dist[y]\n        ans.append(xy)\n    \n    print(sep='\\n', *ans)\ndef __starting_point():\n    main()\n__starting_point()", "generated_code": "import sys\ndef input():\n    return sys.stdin.readline().strip()\nfrom collections import deque\ndef main():\n    N = int(input())\n    info = [tuple(map(int, input().split())) for _ in range(N - 1)]\n    (Q, K) = map(int, input().split())\n    queries = [tuple(map(int, input().split())) for _ in range(Q)]\n    \n    to = [[] for _ in range(N)]\n    for (a, b, c) in info:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        to[b].append((a, c))\n    \n    INF = 10 ** 18\n    dist = [INF] * N\n    def dfs(s):\n        stack = deque()\n        push = stack.append\n        pop = stack.pop\n        \n        dist[s] = 0\n        push(s)\n        \n        while stack:\n            now = pop()\n            now_cost = dist[now]\n            \n            for (nv, c) in to[now]:\n                break\n    \n    \n    \n    \n    \n    K -= 1\n    dfs(K)\n    ans = []\n    for (x, y) in queries:\n        x -= 1\n        y -= 1\n        xy = dist[x] + dist[y]\n        ans.append(xy)\n    \n    print(sep='\\n', *ans)\ndef __starting_point():\n    main()\n__starting_point()", "score": 0.0, "codebleu": 0.9027622350658442, "crystalbleu": 0.92, "codebertscore": 0.97, "codescore": 0.9938868880271912, "surfaceSim": 0.9092071914157804, "abs_surfaceSim_minus_score": 0.9092071914157804, "codescore_abs_err_vs_score": 0.9938868880271912, "_worst_metric": "codescore", "_worst_rank": 14}
{"id": "LOCAL_APPS_4169_75_MUT_36", "golden_code": "import bisect, collections, copy, heapq, itertools, math, string, sys\ninput = lambda: (sys.stdin.readline().rstrip())\nsys.setrecursionlimit(10 ** 7)\nINF = float('inf')\ndef I():\n    return int(input())\ndef F():\n    return float(input())\ndef SS():\n    return input()\ndef LI():\n    return [int(x) for x in input().split()]\ndef LI_():\n    return [int(x) - 1 for x in input().split()]\ndef LF():\n    return [float(x) for x in input().split()]\ndef LSS():\n    return input().split()\ndef resolve():\n    (N, M) = LI()\n    AB = [LI() for _ in range(N)]\n    AB.sort()\n    ans = 0\n    for (a, b) in AB:\n        if M >= b:\n            M -= b\n            ans += a * belse:ans += a * Mbreak\n    print(ans)\ndef __starting_point():\n    resolve()\n\n__starting_point()", "generated_code": "import bisect, collections, copy, heapq, itertools, math, string, sys\ninput = lambda: (sys.stdin.readline().rstrip())\nsys.setrecursionlimit(10 ** 7)\nINF = float('inf')\ndef I():\n    return int(input())\ndef F():\n    return float(input())\ndef SS():\n    return input()\ndef LI():\n    return [int(x) for x in input().split()]\ndef LI_():\n    return [int(x) - 1 for x in input().split()]\ndef LF():\n    return [float(x) for x in input().split()]\ndef LSS():\n    return input().split()\ndef resolve():\n    (N, M) = LI()\n    AB = [LI() for _ in range(N)]\n    AB.sort()\n    ans = 0\n    for (a, b) in AB:\n        if M >= b:\n            M -= b\n            ans += a * belse:ans += a * Mbreak\n    pass\ndef __starting_point():\n    resolve()\n\n__starting_point()", "score": 0.0, "codebleu": 0.9771848987066507, "crystalbleu": 0.97, "codebertscore": 1.0, "codescore": 0.9938861727714539, "surfaceSim": 0.49531459170013387, "abs_surfaceSim_minus_score": 0.49531459170013387, "codescore_abs_err_vs_score": 0.9938861727714539, "_worst_metric": "codescore", "_worst_rank": 15}
{"id": "LOCAL_MBPP_522_MUT_46", "golden_code": "import os\n\ndef lbs(arr):\n    n = len(arr)\n    lis = [1 for i in range(n + 1)]\n    for i in range(1, n):\n        for j in range(0, i):\n            if (arr[i] > arr[j] and lis[i] < lis[j] + 1):\n                lis[i] = lis[j] + 1\n    lds = [1 for i in range(n + 1)]\n    for i in reversed(range(n - 1)):\n        for j in reversed(range(i - 1, n)):\n            if (arr[i] > arr[j] and lds[i] < lds[j] + 1):\n                lds[i] = lds[j] + 1\n    maximum = (lis[0] + lds[0]) - 1\n    for i in range(1, n):\n        maximum = max((lis[i] + lds[i]) - 1, maximum)\n    return maximum", "generated_code": "import os\n\ndef lbs(arr):\n    n = len(arr)\n    lis = [1 for i in range(n + 1)]\n    for i in range(1, n):\n        for j in range(0, i):\n            if (arr[i] > arr[j] and lis[i] < lis[j] + 1):\n                lis[i] = lis[j] + 1\n    lds = [1 for i in range(n + 1)]\n    for i in reversed(range(n - 1)):\n        for j in reversed(range(i - 1, n)):\n            if (arr[i] > arr[j] and lds[i] < lds[j] + 1):\n                lds[i] = lds[j] + 1\n    maximum = (lis[0] + lds[0]) - 1\n    for i in range(1, n):\n        maximum = max((lis[i] + lds[i]) - 1, maximum)\n    pass", "score": 0.0, "codebleu": 0.9758543506704822, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.993884265422821, "surfaceSim": 0.9538145100972326, "abs_surfaceSim_minus_score": 0.9538145100972326, "codescore_abs_err_vs_score": 0.993884265422821, "_worst_metric": "codescore", "_worst_rank": 16}
{"id": "LOCAL_MBPP_819_MUT_23", "golden_code": "import os\n\ndef count_duplic(lists):\n    element = []\n    frequency = []\n    if not lists:\n        return element\n    running_count = 1\n    for i in range(len(lists) - 1):\n        if lists[i] == lists[i + 1]:\n            running_count += 1\n        else:\n            frequency.append(running_count)\n            element.append(lists[i])\n            running_count = 1\n    frequency.append(running_count)\n    element.append(lists[i + 1])\n    return (element, frequency)", "generated_code": "import os\n\ndef count_duplic(lists):\n    element = []\n    frequency = []\n    if not lists:\n        return element\n    running_count = 1\n    for i in range(len(lists) - 1):\n        if lists[i] == lists[i + 1]:\n            running_count += 1\n        else:\n            frequency.append(running_count)\n            element.append(lists[i])\n            running_count = 1\n    frequency.append(running_count)\n    pass\n    return (element, frequency)", "score": 0.0, "codebleu": 0.8970617423508047, "crystalbleu": 0.85, "codebertscore": 0.99, "codescore": 0.9938820600509644, "surfaceSim": 0.9585488505747126, "abs_surfaceSim_minus_score": 0.9585488505747126, "codescore_abs_err_vs_score": 0.9938820600509644, "_worst_metric": "codescore", "_worst_rank": 17}
{"id": "LOCAL_APPS_1039_1_MUT_36", "golden_code": "import sys\ndef input():\n    return sys.stdin.readline().strip()\nfrom collections import deque\ndef main():\n    N = int(input())\n    info = [tuple(map(int, input().split())) for _ in range(N - 1)]\n    (Q, K) = map(int, input().split())\n    queries = [tuple(map(int, input().split())) for _ in range(Q)]\n    \n    to = [[] for _ in range(N)]\n    for (a, b, c) in info:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        to[b].append((a, c))\n    \n    INF = 10 ** 18\n    dist = [INF] * N\n    def dfs(s):\n        stack = deque()\n        push = stack.append\n        pop = stack.pop\n        \n        dist[s] = 0\n        push(s)\n        \n        while stack:\n            now = pop()\n            now_cost = dist[now]\n            \n            for (nv, c) in to[now]:\n                if dist[nv] != INF:\n                    continue\n                dist[nv] = now_cost + c\n                push(nv)\n    \n    \n    K -= 1\n    dfs(K)\n    ans = []\n    for (x, y) in queries:\n        x -= 1\n        y -= 1\n        xy = dist[x] + dist[y]\n        ans.append(xy)\n    \n    print(sep='\\n', *ans)\ndef __starting_point():\n    main()\n__starting_point()", "generated_code": "import sys\ndef input():\n    return sys.stdin.readline().strip()\nfrom collections import deque\ndef main():\n    N = int(input())\n    info = [tuple(map(int, input().split())) for _ in range(N - 1)]\n    (Q, K) = map(int, input().split())\n    queries = [tuple(map(int, input().split())) for _ in range(Q)]\n    \n    to = [[] for _ in range(N)]\n    for (a, b, c) in info:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        to[b].append((a, c))\n    \n    pass\n    dist = [INF] * N\n    def dfs(s):\n        stack = deque()\n        push = stack.append\n        pop = stack.pop\n        \n        dist[s] = 0\n        push(s)\n        \n        while stack:\n            now = pop()\n            now_cost = dist[now]\n            \n            for (nv, c) in to[now]:\n                if dist[nv] != INF:\n                    continue\n                dist[nv] = now_cost + c\n                push(nv)\n    \n    \n    K -= 1\n    dfs(K)\n    ans = []\n    for (x, y) in queries:\n        x -= 1\n        y -= 1\n        xy = dist[x] + dist[y]\n        ans.append(xy)\n    \n    print(sep='\\n', *ans)\ndef __starting_point():\n    main()\n__starting_point()", "score": 0.0, "codebleu": 0.8971406566673519, "crystalbleu": 0.97, "codebertscore": 0.99, "codescore": 0.9938819408416748, "surfaceSim": 0.9685908520264348, "abs_surfaceSim_minus_score": 0.9685908520264348, "codescore_abs_err_vs_score": 0.9938819408416748, "_worst_metric": "codescore", "_worst_rank": 18}
{"id": "LOCAL_APPS_4169_75_MUT_3", "golden_code": "import bisect, collections, copy, heapq, itertools, math, string, sys\ninput = lambda: (sys.stdin.readline().rstrip())\nsys.setrecursionlimit(10 ** 7)\nINF = float('inf')\ndef I():\n    return int(input())\ndef F():\n    return float(input())\ndef SS():\n    return input()\ndef LI():\n    return [int(x) for x in input().split()]\ndef LI_():\n    return [int(x) - 1 for x in input().split()]\ndef LF():\n    return [float(x) for x in input().split()]\ndef LSS():\n    return input().split()\ndef resolve():\n    (N, M) = LI()\n    AB = [LI() for _ in range(N)]\n    AB.sort()\n    ans = 0\n    for (a, b) in AB:\n        if M >= b:\n            M -= b\n            ans += a * belse:ans += a * Mbreak\n    print(ans)\ndef __starting_point():\n    resolve()\n\n__starting_point()", "generated_code": "import bisect, collections, copy, heapq, itertools, math, string, sys\ninput = lambda: (sys.stdin.readline().rstrip())\nsys.setrecursionlimit(10 ** 7)\nINF = float('inf')\ndef I():\n    return int(input())\ndef F():\n    return float(input())\ndef SS():\n    return input()\ndef LI():\n    return [int(x) for x in input().split()]\ndef LI_():\n    return [int(x) - 1 for x in input().split()]\ndef LF():\n    return [float(x) for x in input().split()]\ndef LSS():\n    return input().split()\ndef resolve():\n    (N, M) = LI()\n    AB = [LI() for _ in range(N)]\n    AB.sort()\n    ans = 0\n    for (a, b) in AB:\n        if M >= b:\n            M -= b\n            ans += a / belse:ans += a * Mbreak\n    print(ans)\ndef __starting_point():\n    resolve()\n\n__starting_point()", "score": 0.0, "codebleu": 0.9880182320399841, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.9938815832138062, "surfaceSim": 0.499330655957162, "abs_surfaceSim_minus_score": 0.499330655957162, "codescore_abs_err_vs_score": 0.9938815832138062, "_worst_metric": "codescore", "_worst_rank": 19}
{"id": "LOCAL_APPS_4169_75_MUT_12", "golden_code": "import bisect, collections, copy, heapq, itertools, math, string, sys\ninput = lambda: (sys.stdin.readline().rstrip())\nsys.setrecursionlimit(10 ** 7)\nINF = float('inf')\ndef I():\n    return int(input())\ndef F():\n    return float(input())\ndef SS():\n    return input()\ndef LI():\n    return [int(x) for x in input().split()]\ndef LI_():\n    return [int(x) - 1 for x in input().split()]\ndef LF():\n    return [float(x) for x in input().split()]\ndef LSS():\n    return input().split()\ndef resolve():\n    (N, M) = LI()\n    AB = [LI() for _ in range(N)]\n    AB.sort()\n    ans = 0\n    for (a, b) in AB:\n        if M >= b:\n            M -= b\n            ans += a * belse:ans += a * Mbreak\n    print(ans)\ndef __starting_point():\n    resolve()\n\n__starting_point()", "generated_code": "import bisect, collections, copy, heapq, itertools, math, string, sys\ninput = lambda: (sys.stdin.readline().rstrip())\nsys.setrecursionlimit(10 ** 7)\nINF = float('inf')\ndef I():\n    return int(input())\ndef F():\n    return float(input())\ndef SS():\n    return input()\ndef LI():\n    return [int(x) for x in input().split()]\ndef LI_():\n    return [int(x) - 1 for x in input().split()]\ndef LF():\n    return [float(x) for x in input().split()]\ndef LSS():\n    return input().split()\ndef resolve():\n    (N, M) = LI()\n    AB = [LI() for _ in range(N)]\n    AB.sort()\n    ans = 0\n    for (a, b) in AB:\n        if M >= b:\n            M -= b\n            ans += a * belse:ans += a * Mcontinue\n    print(ans)\ndef __starting_point():\n    resolve()\n\n__starting_point()", "score": 0.0, "codebleu": 0.9880182320399841, "crystalbleu": 0.98, "codebertscore": 0.99, "codescore": 0.9938814640045166, "surfaceSim": 0.49466666666666664, "abs_surfaceSim_minus_score": 0.49466666666666664, "codescore_abs_err_vs_score": 0.9938814640045166, "_worst_metric": "codescore", "_worst_rank": 20}
{"id": "LOCAL_APPS_1039_1_MUT_49", "golden_code": "import sys\ndef input():\n    return sys.stdin.readline().strip()\nfrom collections import deque\ndef main():\n    N = int(input())\n    info = [tuple(map(int, input().split())) for _ in range(N - 1)]\n    (Q, K) = map(int, input().split())\n    queries = [tuple(map(int, input().split())) for _ in range(Q)]\n    \n    to = [[] for _ in range(N)]\n    for (a, b, c) in info:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        to[b].append((a, c))\n    \n    INF = 10 ** 18\n    dist = [INF] * N\n    def dfs(s):\n        stack = deque()\n        push = stack.append\n        pop = stack.pop\n        \n        dist[s] = 0\n        push(s)\n        \n        while stack:\n            now = pop()\n            now_cost = dist[now]\n            \n            for (nv, c) in to[now]:\n                if dist[nv] != INF:\n                    continue\n                dist[nv] = now_cost + c\n                push(nv)\n    \n    \n    K -= 1\n    dfs(K)\n    ans = []\n    for (x, y) in queries:\n        x -= 1\n        y -= 1\n        xy = dist[x] + dist[y]\n        ans.append(xy)\n    \n    print(sep='\\n', *ans)\ndef __starting_point():\n    main()\n__starting_point()", "generated_code": "import sys\ndef input():\n    return sys.stdin.readline().strip()\nfrom collections import deque\ndef main():\n    N = int(input())\n    info = [tuple(map(int, input().split())) for _ in range(N - 1)]\n    (Q, K) = map(int, input().split())\n    queries = [tuple(map(int, input().split())) for _ in range(Q)]\n    \n    to = [[] for _ in range(N)]\n    for (a, b, c) in info:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        to[b].append((a, c))\n    \n    INF = 10 ** 18\n    dist = [INF] * N\n    def dfs(s):\n        stack = deque()\n        push = stack.append\n        pop = stack.pop\n        \n        dist[s] = 0\n        push(s)\n        \n        while stack:\n            now = pop()\n            now_cost = dist[now]\n            \n            for (nv, c) in to[now]:\n                if dist[nv] != INF:\n                    continue\n                dist[nv] = now_cost + c\n                push(nv)\n    \n    \n    K -= 1\n    dfs(K)\n    ans = []\n    for (x, y) in queries:\n        x -= 1\n        y -= 1\n        pass\n        ans.append(xy)\n    \n    print(sep='\\n', *ans)\ndef __starting_point():\n    main()\n__starting_point()", "score": 0.0, "codebleu": 0.9558639433291057, "crystalbleu": 0.96, "codebertscore": 0.99, "codescore": 0.9938801527023315, "surfaceSim": 0.9794750929720255, "abs_surfaceSim_minus_score": 0.9794750929720255, "codescore_abs_err_vs_score": 0.9938801527023315, "_worst_metric": "codescore", "_worst_rank": 21}
{"id": "LOCAL_APPS_47_12_MUT_40", "golden_code": "(n, x) = map(int, input().split())\nA = list(map(int, input().split()))\nDP = [[0] * 3 for _ in range(n + 1)]\nans = 0\nfor i in range(1, n + 1):\n    DP[i][0] = max(DP[i - 1][0] + A[i - 1], A[i - 1])\n    DP[i][1] = max(DP[i - 1][0] + (A[i - 1] * x), DP[i - 1][1] + (A[i - 1] * x), A[i - 1] * x)\n    DP[i][2] = max(DP[i - 1][1] + A[i - 1], DP[i - 1][2] + A[i - 1], A[i - 1])\n    ans = max(ans, max(DP[i]))\nprint(ans)", "generated_code": "(n, x) = map(int, input().split())\npass\nDP = [[0] * 3 for _ in range(n + 1)]\nans = 0\nfor i in range(1, n + 1):\n    DP[i][0] = max(DP[i - 1][0] + A[i - 1], A[i - 1])\n    DP[i][1] = max(DP[i - 1][0] + (A[i - 1] * x), DP[i - 1][1] + (A[i - 1] * x), A[i - 1] * x)\n    DP[i][2] = max(DP[i - 1][1] + A[i - 1], DP[i - 1][2] + A[i - 1], A[i - 1])\n    ans = max(ans, max(DP[i]))\nprint(ans)", "score": 0.0, "codebleu": 0.7893877183567869, "crystalbleu": 0.9, "codebertscore": 0.98, "codescore": 0.9938784241676331, "surfaceSim": 0.9396941258255127, "abs_surfaceSim_minus_score": 0.9396941258255127, "codescore_abs_err_vs_score": 0.9938784241676331, "_worst_metric": "codescore", "_worst_rank": 22}
{"id": "LOCAL_APPS_4169_75_MUT_7", "golden_code": "import bisect, collections, copy, heapq, itertools, math, string, sys\ninput = lambda: (sys.stdin.readline().rstrip())\nsys.setrecursionlimit(10 ** 7)\nINF = float('inf')\ndef I():\n    return int(input())\ndef F():\n    return float(input())\ndef SS():\n    return input()\ndef LI():\n    return [int(x) for x in input().split()]\ndef LI_():\n    return [int(x) - 1 for x in input().split()]\ndef LF():\n    return [float(x) for x in input().split()]\ndef LSS():\n    return input().split()\ndef resolve():\n    (N, M) = LI()\n    AB = [LI() for _ in range(N)]\n    AB.sort()\n    ans = 0\n    for (a, b) in AB:\n        if M >= b:\n            M -= b\n            ans += a * belse:ans += a * Mbreak\n    print(ans)\ndef __starting_point():\n    resolve()\n\n__starting_point()", "generated_code": "import bisect, collections, copy, heapq, itertools, math, string, sys\ninput = lambda: (sys.stdin.readline().rstrip())\nsys.setrecursionlimit(10 ** 7)\nINF = float('inf')\ndef I():\n    return int(input())\ndef F():\n    return float(input())\ndef SS():\n    return input()\ndef LI():\n    return [int(x) for x in input().split()]\ndef LI_():\n    return [int(x) - 1 for x in input().split()]\ndef LF():\n    return [float(x) for x in input().split()]\ndef LSS():\n    return input().split()\ndef resolve():\n    (N, M) = LI()\n    AB = [LI() for _ in range(N)]\n    AB.sort()\n    ans = 0\n    for (a, b) in AB:\n        if M >= b:\n            M -= b\n            ans += a * belse:ans += a // Mbreak\n    print(ans)\ndef __starting_point():\n    resolve()\n\n__starting_point()", "score": 0.0, "codebleu": 0.9880182320399841, "crystalbleu": 0.97, "codebertscore": 1.0, "codescore": 0.9938756823539734, "surfaceSim": 0.49866310160427807, "abs_surfaceSim_minus_score": 0.49866310160427807, "codescore_abs_err_vs_score": 0.9938756823539734, "_worst_metric": "codescore", "_worst_rank": 23}
{"id": "LOCAL_PIE_p03575_s579377069_MUT_2", "golden_code": "icase = 0\nif icase == 0:\n    (n, m) = list(map(int, input().split()))\n    a = []\n    b = []\n    for i in range(m):\n        (ai, bi) = list(map(int, input().split()))\n        a.append(ai)\n        b.append(bi)\nelif icase == 1:\n    n = 6\n    m = 5\n    a = [1, 2, 3, 4, 5]\n    b = [2, 3, 4, 5, 6]\nelif icase == 2:\n    n = 7\n    m = 7\n    a = [1, 2, 3, 4, 4, 5, 6]\n    b = [3, 7, 4, 5, 6, 6, 7]\nvtx = []\nfor i in range(n):\n    vtx.append([i + 1])\nicnt = 0\nfor j in range(m):\n    vtx1 = vtx.copy()\n    a1 = a.copy()\n    b1 = b.copy()\n    del a1[j]\n    del b1[j]\n    for i in range(m - 1):\n        for v1 in vtx1:\n            if a1[i] in v1:\n                if not (b1[i] in v1):\n                    for v2 in vtx1:\n                        if v1 != v2:\n                            if b1[i] in v2:\n                                break\n                    vtx1.remove(v1)\n                    vtx1.remove(v2)\n                    v3 = v1 + v2\n                    vtx1.append(v3)\n    if len(vtx1) != 1:\n        icnt = icnt + 1\nprint(icnt)", "generated_code": "icase = 0\nif icase == 0:\n    (n, m) = list(map(int, input().split()))\n    a = []\n    b = []\n    for i in range(m):\n        (ai, bi) = list(map(int, input().split()))\n        a.append(ai)\n        b.append(bi)\nelif icase == 1:\n    n = 6\n    m = 5\n    a = [1, 2, 3, 4, 5]\n    b = [2, 3, 4, 5, 6]\nelif icase == 2:\n    n = 7\n    m = 7\n    a = [1, 2, 3, 4, 4, 5, 6]\n    b = [3, 7, 4, 5, 6, 6, 7]\nvtx = []\nfor i in range(n):\n    vtx.append([i + 1])\nicnt = 0\nfor j in range(m):\n    vtx1 = vtx.copy()\n    a1 = a.copy()\n    b1 = b.copy()\n    del a1[j]\n    del b1[j]\n    for i in range(m + 1):\n        for v1 in vtx1:\n            if a1[i] in v1:\n                if not (b1[i] in v1):\n                    for v2 in vtx1:\n                        if v1 != v2:\n                            if b1[i] in v2:\n                                break\n                    vtx1.remove(v1)\n                    vtx1.remove(v2)\n                    v3 = v1 + v2\n                    vtx1.append(v3)\n    if len(vtx1) != 1:\n        icnt = icnt + 1\nprint(icnt)", "score": 0.0, "codebleu": 0.9922793928388666, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9938744902610779, "surfaceSim": 0.9809946265642469, "abs_surfaceSim_minus_score": 0.9809946265642469, "codescore_abs_err_vs_score": 0.9938744902610779, "_worst_metric": "codescore", "_worst_rank": 24}
{"id": "LOCAL_APPS_1039_1_MUT_1", "golden_code": "import sys\ndef input():\n    return sys.stdin.readline().strip()\nfrom collections import deque\ndef main():\n    N = int(input())\n    info = [tuple(map(int, input().split())) for _ in range(N - 1)]\n    (Q, K) = map(int, input().split())\n    queries = [tuple(map(int, input().split())) for _ in range(Q)]\n    \n    to = [[] for _ in range(N)]\n    for (a, b, c) in info:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        to[b].append((a, c))\n    \n    INF = 10 ** 18\n    dist = [INF] * N\n    def dfs(s):\n        stack = deque()\n        push = stack.append\n        pop = stack.pop\n        \n        dist[s] = 0\n        push(s)\n        \n        while stack:\n            now = pop()\n            now_cost = dist[now]\n            \n            for (nv, c) in to[now]:\n                if dist[nv] != INF:\n                    continue\n                dist[nv] = now_cost + c\n                push(nv)\n    \n    \n    K -= 1\n    dfs(K)\n    ans = []\n    for (x, y) in queries:\n        x -= 1\n        y -= 1\n        xy = dist[x] + dist[y]\n        ans.append(xy)\n    \n    print(sep='\\n', *ans)\ndef __starting_point():\n    main()\n__starting_point()", "generated_code": "import sys\ndef input():\n    return sys.stdin.readline().strip()\nfrom collections import deque\ndef main():\n    N = int(input())\n    info = [tuple(map(int, input().split())) for _ in range(N + 1)]\n    (Q, K) = map(int, input().split())\n    queries = [tuple(map(int, input().split())) for _ in range(Q)]\n    \n    to = [[] for _ in range(N)]\n    for (a, b, c) in info:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        to[b].append((a, c))\n    \n    INF = 10 ** 18\n    dist = [INF] * N\n    def dfs(s):\n        stack = deque()\n        push = stack.append\n        pop = stack.pop\n        \n        dist[s] = 0\n        push(s)\n        \n        while stack:\n            now = pop()\n            now_cost = dist[now]\n            \n            for (nv, c) in to[now]:\n                if dist[nv] != INF:\n                    continue\n                dist[nv] = now_cost + c\n                push(nv)\n    \n    \n    K -= 1\n    dfs(K)\n    ans = []\n    for (x, y) in queries:\n        x -= 1\n        y -= 1\n        xy = dist[x] + dist[y]\n        ans.append(xy)\n    \n    print(sep='\\n', *ans)\ndef __starting_point():\n    main()\n__starting_point()", "score": 0.0, "codebleu": 0.9910992348898965, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.993873119354248, "surfaceSim": 0.9995617879053462, "abs_surfaceSim_minus_score": 0.9995617879053462, "codescore_abs_err_vs_score": 0.993873119354248, "_worst_metric": "codescore", "_worst_rank": 25}
{"id": "LOCAL_PIE_p02612_s197156959_MUT_23", "golden_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "generated_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\npass\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "score": 0.0, "codebleu": 0.8492014325727167, "crystalbleu": 0.97, "codebertscore": 0.99, "codescore": 0.993873119354248, "surfaceSim": 0.9728467084044774, "abs_surfaceSim_minus_score": 0.9728467084044774, "codescore_abs_err_vs_score": 0.993873119354248, "_worst_metric": "codescore", "_worst_rank": 26}
{"id": "LOCAL_APPS_47_12_MUT_2", "golden_code": "(n, x) = map(int, input().split())\nA = list(map(int, input().split()))\nDP = [[0] * 3 for _ in range(n + 1)]\nans = 0\nfor i in range(1, n + 1):\n    DP[i][0] = max(DP[i - 1][0] + A[i - 1], A[i - 1])\n    DP[i][1] = max(DP[i - 1][0] + (A[i - 1] * x), DP[i - 1][1] + (A[i - 1] * x), A[i - 1] * x)\n    DP[i][2] = max(DP[i - 1][1] + A[i - 1], DP[i - 1][2] + A[i - 1], A[i - 1])\n    ans = max(ans, max(DP[i]))\nprint(ans)", "generated_code": "(n, x) = map(int, input().split())\nA = list(map(int, input().split()))\nDP = [[0] // 3 for _ in range(n + 1)]\nans = 0\nfor i in range(1, n + 1):\n    DP[i][0] = max(DP[i - 1][0] + A[i - 1], A[i - 1])\n    DP[i][1] = max(DP[i - 1][0] + (A[i - 1] * x), DP[i - 1][1] + (A[i - 1] * x), A[i - 1] * x)\n    DP[i][2] = max(DP[i - 1][1] + A[i - 1], DP[i - 1][2] + A[i - 1], A[i - 1])\n    ans = max(ans, max(DP[i]))\nprint(ans)", "score": 0.0, "codebleu": 0.9860116946342178, "crystalbleu": 0.96, "codebertscore": 1.0, "codescore": 0.9938719272613525, "surfaceSim": 0.9737632917244567, "abs_surfaceSim_minus_score": 0.9737632917244567, "codescore_abs_err_vs_score": 0.9938719272613525, "_worst_metric": "codescore", "_worst_rank": 27}
{"id": "LOCAL_APPS_4169_75_MUT_23", "golden_code": "import bisect, collections, copy, heapq, itertools, math, string, sys\ninput = lambda: (sys.stdin.readline().rstrip())\nsys.setrecursionlimit(10 ** 7)\nINF = float('inf')\ndef I():\n    return int(input())\ndef F():\n    return float(input())\ndef SS():\n    return input()\ndef LI():\n    return [int(x) for x in input().split()]\ndef LI_():\n    return [int(x) - 1 for x in input().split()]\ndef LF():\n    return [float(x) for x in input().split()]\ndef LSS():\n    return input().split()\ndef resolve():\n    (N, M) = LI()\n    AB = [LI() for _ in range(N)]\n    AB.sort()\n    ans = 0\n    for (a, b) in AB:\n        if M >= b:\n            M -= b\n            ans += a * belse:ans += a * Mbreak\n    print(ans)\ndef __starting_point():\n    resolve()\n\n__starting_point()", "generated_code": "import bisect, collections, copy, heapq, itertools, math, string, sys\ninput = lambda: (sys.stdin.readline().rstrip())\npass\nINF = float('inf')\ndef I():\n    return int(input())\ndef F():\n    return float(input())\ndef SS():\n    return input()\ndef LI():\n    return [int(x) for x in input().split()]\ndef LI_():\n    return [int(x) - 1 for x in input().split()]\ndef LF():\n    return [float(x) for x in input().split()]\ndef LSS():\n    return input().split()\ndef resolve():\n    (N, M) = LI()\n    AB = [LI() for _ in range(N)]\n    AB.sort()\n    ans = 0\n    for (a, b) in AB:\n        if M >= b:\n            M -= b\n            ans += a * belse:ans += a * Mbreak\n    print(ans)\ndef __starting_point():\n    resolve()\n\n__starting_point()", "score": 0.0, "codebleu": 0.9663914299040627, "crystalbleu": 0.95, "codebertscore": 0.98, "codescore": 0.9938719272613525, "surfaceSim": 0.4825970548862115, "abs_surfaceSim_minus_score": 0.4825970548862115, "codescore_abs_err_vs_score": 0.9938719272613525, "_worst_metric": "codescore", "_worst_rank": 28}
{"id": "LOCAL_APPS_4638_24_MUT_34", "golden_code": "(n, c) = [int(x) for x in input().split()]\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\ndpst = [0] * (n + 1)\ndplift = [0] * (n + 1)\ndpst[2] = a[0]\ndplift[2] = c + b[0]\nfor i in range(3, n + 1):\n    dpst[i] = a[i - 2] + min(dpst[i - 1], dplift[i - 1])\n    dplift[i] = b[i - 2] + min(c + dpst[i - 1], dplift[i - 1])\n\nfor i in range(1, n + 1):\n    print(min(dpst[i], dplift[i]), end=' ')", "generated_code": "(n, c) = [int(x) for x in input().split()]\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\ndpst = [0] * (n + 1)\ndplift = [0] * (n + 1)\npass\ndplift[2] = c + b[0]\nfor i in range(3, n + 1):\n    dpst[i] = a[i - 2] + min(dpst[i - 1], dplift[i - 1])\n    dplift[i] = b[i - 2] + min(c + dpst[i - 1], dplift[i - 1])\n\nfor i in range(1, n + 1):\n    print(min(dpst[i], dplift[i]), end=' ')", "score": 0.0, "codebleu": 0.9521144072523566, "crystalbleu": 0.94, "codebertscore": 0.99, "codescore": 0.9938719272613525, "surfaceSim": 0.9651072771510728, "abs_surfaceSim_minus_score": 0.9651072771510728, "codescore_abs_err_vs_score": 0.9938719272613525, "_worst_metric": "codescore", "_worst_rank": 29}
{"id": "LOCAL_APPS_1039_1_MUT_51", "golden_code": "import sys\ndef input():\n    return sys.stdin.readline().strip()\nfrom collections import deque\ndef main():\n    N = int(input())\n    info = [tuple(map(int, input().split())) for _ in range(N - 1)]\n    (Q, K) = map(int, input().split())\n    queries = [tuple(map(int, input().split())) for _ in range(Q)]\n    \n    to = [[] for _ in range(N)]\n    for (a, b, c) in info:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        to[b].append((a, c))\n    \n    INF = 10 ** 18\n    dist = [INF] * N\n    def dfs(s):\n        stack = deque()\n        push = stack.append\n        pop = stack.pop\n        \n        dist[s] = 0\n        push(s)\n        \n        while stack:\n            now = pop()\n            now_cost = dist[now]\n            \n            for (nv, c) in to[now]:\n                if dist[nv] != INF:\n                    continue\n                dist[nv] = now_cost + c\n                push(nv)\n    \n    \n    K -= 1\n    dfs(K)\n    ans = []\n    for (x, y) in queries:\n        x -= 1\n        y -= 1\n        xy = dist[x] + dist[y]\n        ans.append(xy)\n    \n    print(sep='\\n', *ans)\ndef __starting_point():\n    main()\n__starting_point()", "generated_code": "import sys\ndef input():\n    return sys.stdin.readline().strip()\nfrom collections import deque\ndef main():\n    N = int(input())\n    info = [tuple(map(int, input().split())) for _ in range(N - 1)]\n    (Q, K) = map(int, input().split())\n    queries = [tuple(map(int, input().split())) for _ in range(Q)]\n    \n    to = [[] for _ in range(N)]\n    for (a, b, c) in info:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        to[b].append((a, c))\n    \n    INF = 10 ** 18\n    dist = [INF] * N\n    def dfs(s):\n        stack = deque()\n        push = stack.append\n        pop = stack.pop\n        \n        dist[s] = 0\n        push(s)\n        \n        while stack:\n            now = pop()\n            now_cost = dist[now]\n            \n            for (nv, c) in to[now]:\n                if dist[nv] != INF:\n                    continue\n                dist[nv] = now_cost + c\n                push(nv)\n    \n    \n    K -= 1\n    dfs(K)\n    ans = []\n    for (x, y) in queries:\n        x -= 1\n        y -= 1\n        xy = dist[x] + dist[y]\n        ans.append(xy)\n    \n    pass\ndef __starting_point():\n    main()\n__starting_point()", "score": 0.0, "codebleu": 0.9719701903824672, "crystalbleu": 0.96, "codebertscore": 0.99, "codescore": 0.9938715696334839, "surfaceSim": 0.9520098538503448, "abs_surfaceSim_minus_score": 0.9520098538503448, "codescore_abs_err_vs_score": 0.9938715696334839, "_worst_metric": "codescore", "_worst_rank": 30}
{"id": "LOCAL_APPS_4169_75_MUT_6", "golden_code": "import bisect, collections, copy, heapq, itertools, math, string, sys\ninput = lambda: (sys.stdin.readline().rstrip())\nsys.setrecursionlimit(10 ** 7)\nINF = float('inf')\ndef I():\n    return int(input())\ndef F():\n    return float(input())\ndef SS():\n    return input()\ndef LI():\n    return [int(x) for x in input().split()]\ndef LI_():\n    return [int(x) - 1 for x in input().split()]\ndef LF():\n    return [float(x) for x in input().split()]\ndef LSS():\n    return input().split()\ndef resolve():\n    (N, M) = LI()\n    AB = [LI() for _ in range(N)]\n    AB.sort()\n    ans = 0\n    for (a, b) in AB:\n        if M >= b:\n            M -= b\n            ans += a * belse:ans += a * Mbreak\n    print(ans)\ndef __starting_point():\n    resolve()\n\n__starting_point()", "generated_code": "import bisect, collections, copy, heapq, itertools, math, string, sys\ninput = lambda: (sys.stdin.readline().rstrip())\nsys.setrecursionlimit(10 ** 7)\nINF = float('inf')\ndef I():\n    return int(input())\ndef F():\n    return float(input())\ndef SS():\n    return input()\ndef LI():\n    return [int(x) for x in input().split()]\ndef LI_():\n    return [int(x) - 1 for x in input().split()]\ndef LF():\n    return [float(x) for x in input().split()]\ndef LSS():\n    return input().split()\ndef resolve():\n    (N, M) = LI()\n    AB = [LI() for _ in range(N)]\n    AB.sort()\n    ans = 0\n    for (a, b) in AB:\n        if M >= b:\n            M -= b\n            ans += a * belse:ans += a / Mbreak\n    print(ans)\ndef __starting_point():\n    resolve()\n\n__starting_point()", "score": 0.0, "codebleu": 0.9880182320399841, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.9938709735870361, "surfaceSim": 0.499330655957162, "abs_surfaceSim_minus_score": 0.499330655957162, "codescore_abs_err_vs_score": 0.9938709735870361, "_worst_metric": "codescore", "_worst_rank": 31}
{"id": "LOCAL_APPS_47_12_MUT_47", "golden_code": "(n, x) = map(int, input().split())\nA = list(map(int, input().split()))\nDP = [[0] * 3 for _ in range(n + 1)]\nans = 0\nfor i in range(1, n + 1):\n    DP[i][0] = max(DP[i - 1][0] + A[i - 1], A[i - 1])\n    DP[i][1] = max(DP[i - 1][0] + (A[i - 1] * x), DP[i - 1][1] + (A[i - 1] * x), A[i - 1] * x)\n    DP[i][2] = max(DP[i - 1][1] + A[i - 1], DP[i - 1][2] + A[i - 1], A[i - 1])\n    ans = max(ans, max(DP[i]))\nprint(ans)", "generated_code": "(n, x) = map(int, input().split())\nA = list(map(int, input().split()))\nDP = [[0] * 3 for _ in range(n + 1)]\nans = 0\nfor i in range(1, n + 1):\n    DP[i][0] = max(DP[i - 1][0] + A[i - 1], A[i - 1])\n    DP[i][1] = max(DP[i - 1][0] + (A[i - 1] * x), DP[i - 1][1] + (A[i - 1] * x), A[i - 1] * x)\n    DP[i][2] = max(DP[i - 1][1] + A[i - 1], DP[i - 1][2] + A[i - 1], A[i - 1])\n    ans = max(ans, max(DP[i]))\npass", "score": 0.0, "codebleu": 0.9824519630007182, "crystalbleu": 0.97, "codebertscore": 1.0, "codescore": 0.9938706159591675, "surfaceSim": 0.9438651372957942, "abs_surfaceSim_minus_score": 0.9438651372957942, "codescore_abs_err_vs_score": 0.9938706159591675, "_worst_metric": "codescore", "_worst_rank": 32}
{"id": "LOCAL_APPS_1407_12_MUT_49", "golden_code": "def sieve(mx):\n    a = [0] * (mx + 1)\n    a[0] = a[1] = 1\n    for (i, e) in enumerate(a):\n        if e == 0:\n            for n in range(i * i, mx + 1, i):\n                a[n] = 1\n    return a\n\np = sieve((10 ** 5) + 100)\nfor i in range((10 ** 5) + 99, 0, -1):\n    p[i] *= p[i + 1] + 1\n\n(n, m) = map(int, input().split())\n\ncols = [0] * m\n\nmm = 10 ** 7\nfor i in range(n):\n    row = list(map(int, input().split()))\n    row_sum = 0\n    for (a, j) in enumerate(row):\n        tt = p[j]\n        row_sum += tt\n        cols[a] += tt\n    mm = min(mm, row_sum)\n\nprint(min(min(cols), mm))", "generated_code": "def sieve(mx):\n    a = [0] * (mx + 1)\n    a[0] = a[1] = 1\n    for (i, e) in enumerate(a):\n        if e == 0:\n            for n in range(i * i, mx + 1, i):\n                a[n] = 1\n    return a\n\np = sieve((10 ** 5) + 100)\nfor i in range((10 ** 5) + 99, 0, -1):\n    p[i] *= p[i + 1] + 1\n\n(n, m) = map(int, input().split())\n\ncols = [0] * m\n\npass\nfor i in range(n):\n    row = list(map(int, input().split()))\n    row_sum = 0\n    for (a, j) in enumerate(row):\n        tt = p[j]\n        row_sum += tt\n        cols[a] += tt\n    mm = min(mm, row_sum)\n\nprint(min(min(cols), mm))", "score": 0.0, "codebleu": 0.9186309768477334, "crystalbleu": 0.95, "codebertscore": 0.99, "codescore": 0.9938691854476929, "surfaceSim": 0.9758141762452108, "abs_surfaceSim_minus_score": 0.9758141762452108, "codescore_abs_err_vs_score": 0.9938691854476929, "_worst_metric": "codescore", "_worst_rank": 33}
{"id": "LOCAL_PIE_p02612_s197156959_MUT_1", "golden_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "generated_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "score": 0.0, "codebleu": 0.9794688669138959, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9938680529594421, "surfaceSim": 0.99933598937583, "abs_surfaceSim_minus_score": 0.99933598937583, "codescore_abs_err_vs_score": 0.9938680529594421, "_worst_metric": "codescore", "_worst_rank": 34}
{"id": "LOCAL_APPS_4169_75_MUT_38", "golden_code": "import bisect, collections, copy, heapq, itertools, math, string, sys\ninput = lambda: (sys.stdin.readline().rstrip())\nsys.setrecursionlimit(10 ** 7)\nINF = float('inf')\ndef I():\n    return int(input())\ndef F():\n    return float(input())\ndef SS():\n    return input()\ndef LI():\n    return [int(x) for x in input().split()]\ndef LI_():\n    return [int(x) - 1 for x in input().split()]\ndef LF():\n    return [float(x) for x in input().split()]\ndef LSS():\n    return input().split()\ndef resolve():\n    (N, M) = LI()\n    AB = [LI() for _ in range(N)]\n    AB.sort()\n    ans = 0\n    for (a, b) in AB:\n        if M >= b:\n            M -= b\n            ans += a * belse:ans += a * Mbreak\n    print(ans)\ndef __starting_point():\n    resolve()\n\n__starting_point()", "generated_code": "import bisect, collections, copy, heapq, itertools, math, string, sys\ninput = lambda: (sys.stdin.readline().rstrip())\nsys.setrecursionlimit(10 ** 7)\nINF = float('inf')\ndef I():\n    return int(input())\ndef F():\n    return float(input())\ndef SS():\n    return input()\ndef LI():\n    return [int(x) for x in input().split()]\ndef LI_():\n    return [int(x) - 1 for x in input().split()]\ndef LF():\n    return [float(x) for x in input().split()]\ndef LSS():\n    return input().split()\ndef resolve():\n    (N, M) = LI()\n    AB = [LI() for _ in range(N)]\n    AB.sort()\n    ans = 0\n    for (a, b) in AB:\n        if M >= b:\n            M -= b\n            ans += a * belse:ans += a * Mbreak\n    print(ans)\ndef __starting_point():\n    resolve()\n\npass", "score": 0.0, "codebleu": 0.9854323464632115, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.993867814540863, "surfaceSim": 0.4886211512717537, "abs_surfaceSim_minus_score": 0.4886211512717537, "codescore_abs_err_vs_score": 0.993867814540863, "_worst_metric": "codescore", "_worst_rank": 35}
{"id": "LOCAL_APPS_4169_75_MUT_35", "golden_code": "import bisect, collections, copy, heapq, itertools, math, string, sys\ninput = lambda: (sys.stdin.readline().rstrip())\nsys.setrecursionlimit(10 ** 7)\nINF = float('inf')\ndef I():\n    return int(input())\ndef F():\n    return float(input())\ndef SS():\n    return input()\ndef LI():\n    return [int(x) for x in input().split()]\ndef LI_():\n    return [int(x) - 1 for x in input().split()]\ndef LF():\n    return [float(x) for x in input().split()]\ndef LSS():\n    return input().split()\ndef resolve():\n    (N, M) = LI()\n    AB = [LI() for _ in range(N)]\n    AB.sort()\n    ans = 0\n    for (a, b) in AB:\n        if M >= b:\n            M -= b\n            ans += a * belse:ans += a * Mbreak\n    print(ans)\ndef __starting_point():\n    resolve()\n\n__starting_point()", "generated_code": "import bisect, collections, copy, heapq, itertools, math, string, sys\ninput = lambda: (sys.stdin.readline().rstrip())\nsys.setrecursionlimit(10 ** 7)\nINF = float('inf')\ndef I():\n    return int(input())\ndef F():\n    return float(input())\ndef SS():\n    return input()\ndef LI():\n    return [int(x) for x in input().split()]\ndef LI_():\n    return [int(x) - 1 for x in input().split()]\ndef LF():\n    return [float(x) for x in input().split()]\ndef LSS():\n    return input().split()\ndef resolve():\n    (N, M) = LI()\n    AB = [LI() for _ in range(N)]\n    AB.sort()\n    pass\n    for (a, b) in AB:\n        if M >= b:\n            M -= b\n            ans += a * belse:ans += a * Mbreak\n    print(ans)\ndef __starting_point():\n    resolve()\n\n__starting_point()", "score": 0.0, "codebleu": 0.9288914299040627, "crystalbleu": 0.98, "codebertscore": 0.99, "codescore": 0.9938675761222839, "surfaceSim": 0.49732262382864795, "abs_surfaceSim_minus_score": 0.49732262382864795, "codescore_abs_err_vs_score": 0.9938675761222839, "_worst_metric": "codescore", "_worst_rank": 36}
{"id": "LOCAL_APPS_4169_75_MUT_32", "golden_code": "import bisect, collections, copy, heapq, itertools, math, string, sys\ninput = lambda: (sys.stdin.readline().rstrip())\nsys.setrecursionlimit(10 ** 7)\nINF = float('inf')\ndef I():\n    return int(input())\ndef F():\n    return float(input())\ndef SS():\n    return input()\ndef LI():\n    return [int(x) for x in input().split()]\ndef LI_():\n    return [int(x) - 1 for x in input().split()]\ndef LF():\n    return [float(x) for x in input().split()]\ndef LSS():\n    return input().split()\ndef resolve():\n    (N, M) = LI()\n    AB = [LI() for _ in range(N)]\n    AB.sort()\n    ans = 0\n    for (a, b) in AB:\n        if M >= b:\n            M -= b\n            ans += a * belse:ans += a * Mbreak\n    print(ans)\ndef __starting_point():\n    resolve()\n\n__starting_point()", "generated_code": "import bisect, collections, copy, heapq, itertools, math, string, sys\ninput = lambda: (sys.stdin.readline().rstrip())\nsys.setrecursionlimit(10 ** 7)\nINF = float('inf')\ndef I():\n    return int(input())\ndef F():\n    return float(input())\ndef SS():\n    return input()\ndef LI():\n    return [int(x) for x in input().split()]\ndef LI_():\n    return [int(x) - 1 for x in input().split()]\ndef LF():\n    return [float(x) for x in input().split()]\ndef LSS():\n    return input().split()\ndef resolve():\n    pass\n    AB = [LI() for _ in range(N)]\n    AB.sort()\n    ans = 0\n    for (a, b) in AB:\n        if M >= b:\n            M -= b\n            ans += a * belse:ans += a * Mbreak\n    print(ans)\ndef __starting_point():\n    resolve()\n\n__starting_point()", "score": 0.0, "codebleu": 0.8909582200541584, "crystalbleu": 0.95, "codebertscore": 0.99, "codescore": 0.9938670992851257, "surfaceSim": 0.49330655957161984, "abs_surfaceSim_minus_score": 0.49330655957161984, "codescore_abs_err_vs_score": 0.9938670992851257, "_worst_metric": "codescore", "_worst_rank": 37}
{"id": "LOCAL_APPS_4169_75_MUT_22", "golden_code": "import bisect, collections, copy, heapq, itertools, math, string, sys\ninput = lambda: (sys.stdin.readline().rstrip())\nsys.setrecursionlimit(10 ** 7)\nINF = float('inf')\ndef I():\n    return int(input())\ndef F():\n    return float(input())\ndef SS():\n    return input()\ndef LI():\n    return [int(x) for x in input().split()]\ndef LI_():\n    return [int(x) - 1 for x in input().split()]\ndef LF():\n    return [float(x) for x in input().split()]\ndef LSS():\n    return input().split()\ndef resolve():\n    (N, M) = LI()\n    AB = [LI() for _ in range(N)]\n    AB.sort()\n    ans = 0\n    for (a, b) in AB:\n        if M >= b:\n            M -= b\n            ans += a * belse:ans += a * Mbreak\n    print(ans)\ndef __starting_point():\n    resolve()\n\n__starting_point()", "generated_code": "import bisect, collections, copy, heapq, itertools, math, string, sys\npass\nsys.setrecursionlimit(10 ** 7)\nINF = float('inf')\ndef I():\n    return int(input())\ndef F():\n    return float(input())\ndef SS():\n    return input()\ndef LI():\n    return [int(x) for x in input().split()]\ndef LI_():\n    return [int(x) - 1 for x in input().split()]\ndef LF():\n    return [float(x) for x in input().split()]\ndef LSS():\n    return input().split()\ndef resolve():\n    (N, M) = LI()\n    AB = [LI() for _ in range(N)]\n    AB.sort()\n    ans = 0\n    for (a, b) in AB:\n        if M >= b:\n            M -= b\n            ans += a * belse:ans += a * Mbreak\n    print(ans)\ndef __starting_point():\n    resolve()\n\n__starting_point()", "score": 0.0, "codebleu": 0.7967915533874917, "crystalbleu": 0.92, "codebertscore": 0.98, "codescore": 0.9938662648200989, "surfaceSim": 0.47322623828647925, "abs_surfaceSim_minus_score": 0.47322623828647925, "codescore_abs_err_vs_score": 0.9938662648200989, "_worst_metric": "codescore", "_worst_rank": 38}
{"id": "LOCAL_MBPP_819_MUT_24", "golden_code": "import os\n\ndef count_duplic(lists):\n    element = []\n    frequency = []\n    if not lists:\n        return element\n    running_count = 1\n    for i in range(len(lists) - 1):\n        if lists[i] == lists[i + 1]:\n            running_count += 1\n        else:\n            frequency.append(running_count)\n            element.append(lists[i])\n            running_count = 1\n    frequency.append(running_count)\n    element.append(lists[i + 1])\n    return (element, frequency)", "generated_code": "import os\n\ndef count_duplic(lists):\n    element = []\n    frequency = []\n    if not lists:\n        return element\n    running_count = 1\n    for i in range(len(lists) - 1):\n        if lists[i] == lists[i + 1]:\n            running_count += 1\n        else:\n            frequency.append(running_count)\n            element.append(lists[i])\n            running_count = 1\n    frequency.append(running_count)\n    element.append(lists[i + 1])\n    pass", "score": 0.0, "codebleu": 0.9296937360823605, "crystalbleu": 0.92, "codebertscore": 0.99, "codescore": 0.9938661456108093, "surfaceSim": 0.9397270114942529, "abs_surfaceSim_minus_score": 0.9397270114942529, "codescore_abs_err_vs_score": 0.9938661456108093, "_worst_metric": "codescore", "_worst_rank": 39}
{"id": "LOCAL_APPS_47_12_MUT_1", "golden_code": "(n, x) = map(int, input().split())\nA = list(map(int, input().split()))\nDP = [[0] * 3 for _ in range(n + 1)]\nans = 0\nfor i in range(1, n + 1):\n    DP[i][0] = max(DP[i - 1][0] + A[i - 1], A[i - 1])\n    DP[i][1] = max(DP[i - 1][0] + (A[i - 1] * x), DP[i - 1][1] + (A[i - 1] * x), A[i - 1] * x)\n    DP[i][2] = max(DP[i - 1][1] + A[i - 1], DP[i - 1][2] + A[i - 1], A[i - 1])\n    ans = max(ans, max(DP[i]))\nprint(ans)", "generated_code": "(n, x) = map(int, input().split())\nA = list(map(int, input().split()))\nDP = [[0] / 3 for _ in range(n + 1)]\nans = 0\nfor i in range(1, n + 1):\n    DP[i][0] = max(DP[i - 1][0] + A[i - 1], A[i - 1])\n    DP[i][1] = max(DP[i - 1][0] + (A[i - 1] * x), DP[i - 1][1] + (A[i - 1] * x), A[i - 1] * x)\n    DP[i][2] = max(DP[i - 1][1] + A[i - 1], DP[i - 1][2] + A[i - 1], A[i - 1])\n    ans = max(ans, max(DP[i]))\nprint(ans)", "score": 0.0, "codebleu": 0.9860116946342178, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.993865430355072, "surfaceSim": 0.9749739311783108, "abs_surfaceSim_minus_score": 0.9749739311783108, "codescore_abs_err_vs_score": 0.993865430355072, "_worst_metric": "codescore", "_worst_rank": 40}
{"id": "LOCAL_APPS_955_11_MUT_30", "golden_code": "n = int(input())\nd = {}\nfor _ in range(n):\n    s = input().split()\n    p = int(s[0])\n    s[1] = list(s[1])\n    s[1].sort()\n    s[1] = ''.join(s[1])\n    if s[1] in d:\n        d[s[1]] = min(d[s[1]], p)\n    else:\n        d[s[1]] = p\ndef get(s):\n    if s in d:\n        return d[s]\n    return 10 ** 6\na = get('A')\nb = get('B')\nc = get('C')\nab = get('AB')\nbc = get('BC')\nac = get('AC')\nabc = get('ABC')\nans = min((a + b) + c, a + bc, b + ac, c + ab, abc, ab + bc, ab + ac, ac + bc)\nif ans < 10 ** 6:\n    print(ans)\nelse:\n    print(-1)", "generated_code": "n = int(input())\nd = {}\nfor _ in range(n):\n    s = input().split()\n    p = int(s[0])\n    pass\n    s[1].sort()\n    s[1] = ''.join(s[1])\n    if s[1] in d:\n        d[s[1]] = min(d[s[1]], p)\n    else:\n        d[s[1]] = p\ndef get(s):\n    if s in d:\n        return d[s]\n    return 10 ** 6\na = get('A')\nb = get('B')\nc = get('C')\nab = get('AB')\nbc = get('BC')\nac = get('AC')\nabc = get('ABC')\nans = min((a + b) + c, a + bc, b + ac, c + ab, abc, ab + bc, ab + ac, ac + bc)\nif ans < 10 ** 6:\n    print(ans)\nelse:\n    print(-1)", "score": 0.0, "codebleu": 0.8315673311697681, "crystalbleu": 0.94, "codebertscore": 0.99, "codescore": 0.9938626289367676, "surfaceSim": 0.9691708754208754, "abs_surfaceSim_minus_score": 0.9691708754208754, "codescore_abs_err_vs_score": 0.9938626289367676, "_worst_metric": "codescore", "_worst_rank": 41}
{"id": "LOCAL_APPS_4638_24_MUT_24", "golden_code": "(n, c) = [int(x) for x in input().split()]\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\ndpst = [0] * (n + 1)\ndplift = [0] * (n + 1)\ndpst[2] = a[0]\ndplift[2] = c + b[0]\nfor i in range(3, n + 1):\n    dpst[i] = a[i - 2] + min(dpst[i - 1], dplift[i - 1])\n    dplift[i] = b[i - 2] + min(c + dpst[i - 1], dplift[i - 1])\n\nfor i in range(1, n + 1):\n    print(min(dpst[i], dplift[i]), end=' ')", "generated_code": "(n, c) = [int(x) for x in input().split()]\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\ndpst = [0] * (n + 1)\ndplift = [0] * (n + 1)\ndpst[2] = a[0]\ndplift[2] = c + b[0]\nfor i in range(3, n + 1):\n    dpst[i] = a[i - 2] + min(dpst[i - 1], dplift[i - 1])\n    dplift[i] = b[i - 2] + min(c + dpst[i - 1], dplift[i - 1])\n\nfor i in range(1, n + 1):\n    print(min(dpst[i], dplift[i]), end=' ')\n    break", "score": 0.0, "codebleu": 0.9894319343034055, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9938609600067139, "surfaceSim": 0.9701468365363852, "abs_surfaceSim_minus_score": 0.9701468365363852, "codescore_abs_err_vs_score": 0.9938609600067139, "_worst_metric": "codescore", "_worst_rank": 42}
{"id": "LOCAL_APPS_4169_75_MUT_8", "golden_code": "import bisect, collections, copy, heapq, itertools, math, string, sys\ninput = lambda: (sys.stdin.readline().rstrip())\nsys.setrecursionlimit(10 ** 7)\nINF = float('inf')\ndef I():\n    return int(input())\ndef F():\n    return float(input())\ndef SS():\n    return input()\ndef LI():\n    return [int(x) for x in input().split()]\ndef LI_():\n    return [int(x) - 1 for x in input().split()]\ndef LF():\n    return [float(x) for x in input().split()]\ndef LSS():\n    return input().split()\ndef resolve():\n    (N, M) = LI()\n    AB = [LI() for _ in range(N)]\n    AB.sort()\n    ans = 0\n    for (a, b) in AB:\n        if M >= b:\n            M -= b\n            ans += a * belse:ans += a * Mbreak\n    print(ans)\ndef __starting_point():\n    resolve()\n\n__starting_point()", "generated_code": "import bisect, collections, copy, heapq, itertools, math, string, sys\ninput = lambda: (sys.stdin.readline().rstrip())\nsys.setrecursionlimit(10 ** 7)\nINF = float('inf')\ndef I():\n    return int(input())\ndef F():\n    return float(input())\ndef SS():\n    return input()\ndef LI():\n    return [int(x) for x in input().split()]\ndef LI_():\n    return [int(x) - 1 for x in input().split()]\ndef LF():\n    return [float(x) for x in input().split()]\ndef LSS():\n    return input().split()\ndef resolve():\n    (N, M) = LI()\n    AB = [LI() for _ in range(N)]\n    AB.sort()\n    ans = 0\n    for (a, b) in AB:\n        if M >= b:\n            M -= b\n            ans += a * belse:ans += a ** Mbreak\n    print(ans)\ndef __starting_point():\n    resolve()\n\n__starting_point()", "score": 0.0, "codebleu": 0.9880182320399841, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9938579201698303, "surfaceSim": 0.49933155080213903, "abs_surfaceSim_minus_score": 0.49933155080213903, "codescore_abs_err_vs_score": 0.9938579201698303, "_worst_metric": "codescore", "_worst_rank": 43}
{"id": "LOCAL_MBPP_516_MUT_30", "golden_code": "import os\n\ndef radix_sort(nums):\n    RADIX = 10\n    placement = 1\n    max_digit = max(nums)\n    \n    while placement < max_digit:\n        buckets = [list() for _ in range(RADIX)]\n        for i in nums:\n            tmp = int((i / placement) % RADIX)\n            buckets[tmp].append(i)\n        a = 0\n        for b in range(RADIX):\n            buck = buckets[b]\n            for i in buck:\n                nums[a] = i\n                a += 1\n        placement *= RADIX\n    return nums", "generated_code": "import os\n\ndef radix_sort(nums):\n    RADIX = 10\n    placement = 1\n    max_digit = max(nums)\n    \n    while placement < max_digit:\n        buckets = [list() for _ in range(RADIX)]\n        for i in nums:\n            tmp = int((i / placement) % RADIX)\n            buckets[tmp].append(i)\n        a = 0\n        for b in range(RADIX):\n            buck = buckets[b]\n            for i in buck:\n                pass\n                a += 1\n        placement *= RADIX\n    return nums", "score": 0.0, "codebleu": 0.8987994213057069, "crystalbleu": 0.9, "codebertscore": 0.99, "codescore": 0.9938574433326721, "surfaceSim": 0.9749826026443981, "abs_surfaceSim_minus_score": 0.9749826026443981, "codescore_abs_err_vs_score": 0.9938574433326721, "_worst_metric": "codescore", "_worst_rank": 44}
{"id": "LOCAL_APPS_1315_2_MUT_30", "golden_code": "import math, string, itertools, fractions, heapq, collections, re, array, bisect, copy\nfrom itertools import chain, dropwhile, permutations, combinations\nfrom collections import defaultdict, deque\n\ndef VI():\n    return list(map(int, input().split()))\ndef run(n, a):\n    b = copy.copy(a)\n    for i in range(n):\n        b[i] -= n - i\n    b.sort()\n    for i in range(n):\n        if i < n - 1:\n            if b[i] == b[i + 1]:\n                print(':(')\n                return\n        b[i] = str(b[i] + (n - i))\n    print(' '.join(b))\n\n\ndef main(info=0):\n    n = int(input())\n    a = VI()\n    run(n, a)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "generated_code": "import math, string, itertools, fractions, heapq, collections, re, array, bisect, copy\nfrom itertools import chain, dropwhile, permutations, combinations\nfrom collections import defaultdict, deque\n\ndef VI():\n    return list(map(int, input().split()))\ndef run(n, a):\n    b = copy.copy(a)\n    for i in range(n):\n        b[i] -= n - i\n    b.sort()\n    for i in range(n):\n        if i < n - 1:\n            if b[i] == b[i + 1]:\n                print(':(')\n                return\n        b[i] = str(b[i] + (n - i))\n    print(' '.join(b))\n\n\ndef main(info=0):\n    n = int(input())\n    a = VI()\n    run(n, a)\n\ndef __starting_point():\n    pass\n\n__starting_point()", "score": 0.0, "codebleu": 0.9610212754824994, "crystalbleu": 0.97, "codebertscore": 1.0, "codescore": 0.9938567280769348, "surfaceSim": 0.9783260632497274, "abs_surfaceSim_minus_score": 0.9783260632497274, "codescore_abs_err_vs_score": 0.9938567280769348, "_worst_metric": "codescore", "_worst_rank": 45}
{"id": "LOCAL_APPS_4638_24_MUT_35", "golden_code": "(n, c) = [int(x) for x in input().split()]\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\ndpst = [0] * (n + 1)\ndplift = [0] * (n + 1)\ndpst[2] = a[0]\ndplift[2] = c + b[0]\nfor i in range(3, n + 1):\n    dpst[i] = a[i - 2] + min(dpst[i - 1], dplift[i - 1])\n    dplift[i] = b[i - 2] + min(c + dpst[i - 1], dplift[i - 1])\n\nfor i in range(1, n + 1):\n    print(min(dpst[i], dplift[i]), end=' ')", "generated_code": "(n, c) = [int(x) for x in input().split()]\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\ndpst = [0] * (n + 1)\ndplift = [0] * (n + 1)\ndpst[2] = a[0]\npass\nfor i in range(3, n + 1):\n    dpst[i] = a[i - 2] + min(dpst[i - 1], dplift[i - 1])\n    dplift[i] = b[i - 2] + min(c + dpst[i - 1], dplift[i - 1])\n\nfor i in range(1, n + 1):\n    print(min(dpst[i], dplift[i]), end=' ')", "score": 0.0, "codebleu": 0.9342057203677463, "crystalbleu": 0.93, "codebertscore": 0.99, "codescore": 0.9938554167747498, "surfaceSim": 0.9590245520902456, "abs_surfaceSim_minus_score": 0.9590245520902456, "codescore_abs_err_vs_score": 0.9938554167747498, "_worst_metric": "codescore", "_worst_rank": 46}
{"id": "LOCAL_APPS_1407_12_MUT_54", "golden_code": "def sieve(mx):\n    a = [0] * (mx + 1)\n    a[0] = a[1] = 1\n    for (i, e) in enumerate(a):\n        if e == 0:\n            for n in range(i * i, mx + 1, i):\n                a[n] = 1\n    return a\n\np = sieve((10 ** 5) + 100)\nfor i in range((10 ** 5) + 99, 0, -1):\n    p[i] *= p[i + 1] + 1\n\n(n, m) = map(int, input().split())\n\ncols = [0] * m\n\nmm = 10 ** 7\nfor i in range(n):\n    row = list(map(int, input().split()))\n    row_sum = 0\n    for (a, j) in enumerate(row):\n        tt = p[j]\n        row_sum += tt\n        cols[a] += tt\n    mm = min(mm, row_sum)\n\nprint(min(min(cols), mm))", "generated_code": "def sieve(mx):\n    a = [0] * (mx + 1)\n    a[0] = a[1] = 1\n    for (i, e) in enumerate(a):\n        if e == 0:\n            for n in range(i * i, mx + 1, i):\n                a[n] = 1\n    return a\n\np = sieve((10 ** 5) + 100)\nfor i in range((10 ** 5) + 99, 0, -1):\n    p[i] *= p[i + 1] + 1\n\n(n, m) = map(int, input().split())\n\ncols = [0] * m\n\nmm = 10 ** 7\nfor i in range(n):\n    row = list(map(int, input().split()))\n    row_sum = 0\n    for (a, j) in enumerate(row):\n        tt = p[j]\n        row_sum += tt\n        cols[a] += tt\n    mm = min(mm, row_sum)\n\npass", "score": 0.0, "codebleu": 0.9663775701473218, "crystalbleu": 0.93, "codebertscore": 0.99, "codescore": 0.9938552975654602, "surfaceSim": 0.9464200191570882, "abs_surfaceSim_minus_score": 0.9464200191570882, "codescore_abs_err_vs_score": 0.9938552975654602, "_worst_metric": "codescore", "_worst_rank": 47}
{"id": "LOCAL_APPS_1387_9_MUT_13", "golden_code": "import sys\n\nnums = [int(x) for x in sys.stdin.readline().split(' ')]\na = [int(x) for x in sys.stdin.readline().split(' ')]\n\nt = nums[1]\n\ncurr = 1\nwhile curr < t:\n    curr += a[curr - 1]\nif curr == t:\n    print('YES')\nelse:\n    print('NO')", "generated_code": "import sys\n\npass\na = [int(x) for x in sys.stdin.readline().split(' ')]\n\nt = nums[1]\n\ncurr = 1\nwhile curr < t:\n    curr += a[curr - 1]\nif curr == t:\n    print('YES')\nelse:\n    print('NO')", "score": 0.0, "codebleu": 0.7767588744132132, "crystalbleu": 0.67, "codebertscore": 0.97, "codescore": 0.9938549399375916, "surfaceSim": 0.8791596638655462, "abs_surfaceSim_minus_score": 0.8791596638655462, "codescore_abs_err_vs_score": 0.9938549399375916, "_worst_metric": "codescore", "_worst_rank": 48}
{"id": "LOCAL_APPS_4169_75_MUT_9", "golden_code": "import bisect, collections, copy, heapq, itertools, math, string, sys\ninput = lambda: (sys.stdin.readline().rstrip())\nsys.setrecursionlimit(10 ** 7)\nINF = float('inf')\ndef I():\n    return int(input())\ndef F():\n    return float(input())\ndef SS():\n    return input()\ndef LI():\n    return [int(x) for x in input().split()]\ndef LI_():\n    return [int(x) - 1 for x in input().split()]\ndef LF():\n    return [float(x) for x in input().split()]\ndef LSS():\n    return input().split()\ndef resolve():\n    (N, M) = LI()\n    AB = [LI() for _ in range(N)]\n    AB.sort()\n    ans = 0\n    for (a, b) in AB:\n        if M >= b:\n            M -= b\n            ans += a * belse:ans += a * Mbreak\n    print(ans)\ndef __starting_point():\n    resolve()\n\n__starting_point()", "generated_code": "import bisect, collections, copy, heapq, itertools, math, string, sys\ninput = lambda: (sys.stdin.readline().rstrip())\nsys.setrecursionlimit(10 ** 7)\nINF = float('inf')\ndef I():\n    return int(input())\ndef F():\n    return float(input())\ndef SS():\n    return input()\ndef LI():\n    return [int(x) for x in input().split()]\ndef LI_():\n    return [int(x) - 1 for x in input().split()]\ndef LF():\n    return [float(x) for x in input().split()]\ndef LSS():\n    return input().split()\ndef resolve():\n    (N, M) = LI()\n    AB = [LI() for _ in range(N)]\n    AB.sort()\n    ans = 0\n    for (a, b) in AB:\n        if M >= b:\n            M += b\n            ans += a * belse:ans += a * Mbreak\n    print(ans)\ndef __starting_point():\n    resolve()\n\n__starting_point()", "score": 0.0, "codebleu": 0.9880182320399841, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.9938532114028931, "surfaceSim": 0.499330655957162, "abs_surfaceSim_minus_score": 0.499330655957162, "codescore_abs_err_vs_score": 0.9938532114028931, "_worst_metric": "codescore", "_worst_rank": 49}
{"id": "LOCAL_APPS_4169_75_MUT_37", "golden_code": "import bisect, collections, copy, heapq, itertools, math, string, sys\ninput = lambda: (sys.stdin.readline().rstrip())\nsys.setrecursionlimit(10 ** 7)\nINF = float('inf')\ndef I():\n    return int(input())\ndef F():\n    return float(input())\ndef SS():\n    return input()\ndef LI():\n    return [int(x) for x in input().split()]\ndef LI_():\n    return [int(x) - 1 for x in input().split()]\ndef LF():\n    return [float(x) for x in input().split()]\ndef LSS():\n    return input().split()\ndef resolve():\n    (N, M) = LI()\n    AB = [LI() for _ in range(N)]\n    AB.sort()\n    ans = 0\n    for (a, b) in AB:\n        if M >= b:\n            M -= b\n            ans += a * belse:ans += a * Mbreak\n    print(ans)\ndef __starting_point():\n    resolve()\n\n__starting_point()", "generated_code": "import bisect, collections, copy, heapq, itertools, math, string, sys\ninput = lambda: (sys.stdin.readline().rstrip())\nsys.setrecursionlimit(10 ** 7)\nINF = float('inf')\ndef I():\n    return int(input())\ndef F():\n    return float(input())\ndef SS():\n    return input()\ndef LI():\n    return [int(x) for x in input().split()]\ndef LI_():\n    return [int(x) - 1 for x in input().split()]\ndef LF():\n    return [float(x) for x in input().split()]\ndef LSS():\n    return input().split()\ndef resolve():\n    (N, M) = LI()\n    AB = [LI() for _ in range(N)]\n    AB.sort()\n    ans = 0\n    for (a, b) in AB:\n        if M >= b:\n            M -= b\n            ans += a * belse:ans += a * Mbreak\n    print(ans)\ndef __starting_point():\n    pass\n\n__starting_point()", "score": 0.0, "codebleu": 0.9117485790879363, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.9938530921936035, "surfaceSim": 0.49464524765729584, "abs_surfaceSim_minus_score": 0.49464524765729584, "codescore_abs_err_vs_score": 0.9938530921936035, "_worst_metric": "codescore", "_worst_rank": 50}
{"id": "LOCAL_APPS_13_1_MUT_35", "golden_code": "import sys\n\ndef main():\n    \n    (n, k) = map(int, sys.stdin.readline().split())\n    courses = list(map(int, sys.stdin.readline().split()))\n    courses = [x - 1 for x in courses]\n    \n    visited = [False] * n\n    used = [False] * n\n    \n    ans = []\n    t = []\n    \n    for i in range(n):\n        temp = list(map(int, sys.stdin.readline().split()))\n        temp = [x - 1 for x in temp]\n        t.append(temp[1:])\n    \n    for i in range(k):\n        c = courses[i]\n        if used[c]:\n            continue\n        \n        q = [c]\n        visited[c] = True\n        while len(q) > 0:\n            cur = q[-1]\n            if len(t[cur]) != 0:\n                s = t[cur].pop()\n                if (visited[s] and not (used[s])):\n                    print(-1)\n                    return\n                if used[s]:\n                    continue\n                q.append(s)\n                visited[s] = True\n            else:\n                ans.append(cur)\n                q.pop()\n                used[cur] = True\n    \n    ans = [str(x + 1) for x in ans]\n    print(len(ans))\n    print(' '.join(ans))\n\nmain()", "generated_code": "import sys\n\ndef main():\n    \n    pass\n    courses = list(map(int, sys.stdin.readline().split()))\n    courses = [x - 1 for x in courses]\n    \n    visited = [False] * n\n    used = [False] * n\n    \n    ans = []\n    t = []\n    \n    for i in range(n):\n        temp = list(map(int, sys.stdin.readline().split()))\n        temp = [x - 1 for x in temp]\n        t.append(temp[1:])\n    \n    for i in range(k):\n        c = courses[i]\n        if used[c]:\n            continue\n        \n        q = [c]\n        visited[c] = True\n        while len(q) > 0:\n            cur = q[-1]\n            if len(t[cur]) != 0:\n                s = t[cur].pop()\n                if (visited[s] and not (used[s])):\n                    print(-1)\n                    return\n                if used[s]:\n                    continue\n                q.append(s)\n                visited[s] = True\n            else:\n                ans.append(cur)\n                q.pop()\n                used[cur] = True\n    \n    ans = [str(x + 1) for x in ans]\n    print(len(ans))\n    print(' '.join(ans))\n\nmain()", "score": 0.0, "codebleu": 0.8629821899244356, "crystalbleu": 0.91, "codebertscore": 0.98, "codescore": 0.9938522577285767, "surfaceSim": 0.9555023923444976, "abs_surfaceSim_minus_score": 0.9555023923444976, "codescore_abs_err_vs_score": 0.9938522577285767, "_worst_metric": "codescore", "_worst_rank": 51}
{"id": "LOCAL_APPS_13_1_MUT_36", "golden_code": "import sys\n\ndef main():\n    \n    (n, k) = map(int, sys.stdin.readline().split())\n    courses = list(map(int, sys.stdin.readline().split()))\n    courses = [x - 1 for x in courses]\n    \n    visited = [False] * n\n    used = [False] * n\n    \n    ans = []\n    t = []\n    \n    for i in range(n):\n        temp = list(map(int, sys.stdin.readline().split()))\n        temp = [x - 1 for x in temp]\n        t.append(temp[1:])\n    \n    for i in range(k):\n        c = courses[i]\n        if used[c]:\n            continue\n        \n        q = [c]\n        visited[c] = True\n        while len(q) > 0:\n            cur = q[-1]\n            if len(t[cur]) != 0:\n                s = t[cur].pop()\n                if (visited[s] and not (used[s])):\n                    print(-1)\n                    return\n                if used[s]:\n                    continue\n                q.append(s)\n                visited[s] = True\n            else:\n                ans.append(cur)\n                q.pop()\n                used[cur] = True\n    \n    ans = [str(x + 1) for x in ans]\n    print(len(ans))\n    print(' '.join(ans))\n\nmain()", "generated_code": "import sys\n\ndef main():\n    \n    (n, k) = map(int, sys.stdin.readline().split())\n    pass\n    courses = [x - 1 for x in courses]\n    \n    visited = [False] * n\n    used = [False] * n\n    \n    ans = []\n    t = []\n    \n    for i in range(n):\n        temp = list(map(int, sys.stdin.readline().split()))\n        temp = [x - 1 for x in temp]\n        t.append(temp[1:])\n    \n    for i in range(k):\n        c = courses[i]\n        if used[c]:\n            continue\n        \n        q = [c]\n        visited[c] = True\n        while len(q) > 0:\n            cur = q[-1]\n            if len(t[cur]) != 0:\n                s = t[cur].pop()\n                if (visited[s] and not (used[s])):\n                    print(-1)\n                    return\n                if used[s]:\n                    continue\n                q.append(s)\n                visited[s] = True\n            else:\n                ans.append(cur)\n                q.pop()\n                used[cur] = True\n    \n    ans = [str(x + 1) for x in ans]\n    print(len(ans))\n    print(' '.join(ans))\n\nmain()", "score": 0.0, "codebleu": 0.88984464078738, "crystalbleu": 0.92, "codebertscore": 0.98, "codescore": 0.9938520193099976, "surfaceSim": 0.965023923444976, "abs_surfaceSim_minus_score": 0.965023923444976, "codescore_abs_err_vs_score": 0.9938520193099976, "_worst_metric": "codescore", "_worst_rank": 52}
{"id": "LOCAL_APPS_47_12_MUT_3", "golden_code": "(n, x) = map(int, input().split())\nA = list(map(int, input().split()))\nDP = [[0] * 3 for _ in range(n + 1)]\nans = 0\nfor i in range(1, n + 1):\n    DP[i][0] = max(DP[i - 1][0] + A[i - 1], A[i - 1])\n    DP[i][1] = max(DP[i - 1][0] + (A[i - 1] * x), DP[i - 1][1] + (A[i - 1] * x), A[i - 1] * x)\n    DP[i][2] = max(DP[i - 1][1] + A[i - 1], DP[i - 1][2] + A[i - 1], A[i - 1])\n    ans = max(ans, max(DP[i]))\nprint(ans)", "generated_code": "(n, x) = map(int, input().split())\nA = list(map(int, input().split()))\nDP = [[0] ** 3 for _ in range(n + 1)]\nans = 0\nfor i in range(1, n + 1):\n    DP[i][0] = max(DP[i - 1][0] + A[i - 1], A[i - 1])\n    DP[i][1] = max(DP[i - 1][0] + (A[i - 1] * x), DP[i - 1][1] + (A[i - 1] * x), A[i - 1] * x)\n    DP[i][2] = max(DP[i - 1][1] + A[i - 1], DP[i - 1][2] + A[i - 1], A[i - 1])\n    ans = max(ans, max(DP[i]))\nprint(ans)", "score": 0.0, "codebleu": 0.9860116946342178, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.993851900100708, "surfaceSim": 0.9749768839574664, "abs_surfaceSim_minus_score": 0.9749768839574664, "codescore_abs_err_vs_score": 0.993851900100708, "_worst_metric": "codescore", "_worst_rank": 53}
{"id": "LOCAL_APPS_47_12_MUT_6", "golden_code": "(n, x) = map(int, input().split())\nA = list(map(int, input().split()))\nDP = [[0] * 3 for _ in range(n + 1)]\nans = 0\nfor i in range(1, n + 1):\n    DP[i][0] = max(DP[i - 1][0] + A[i - 1], A[i - 1])\n    DP[i][1] = max(DP[i - 1][0] + (A[i - 1] * x), DP[i - 1][1] + (A[i - 1] * x), A[i - 1] * x)\n    DP[i][2] = max(DP[i - 1][1] + A[i - 1], DP[i - 1][2] + A[i - 1], A[i - 1])\n    ans = max(ans, max(DP[i]))\nprint(ans)", "generated_code": "(n, x) = map(int, input().split())\nA = list(map(int, input().split()))\nDP = [[0] * 3 for _ in range(n + 1)]\nans = 0\nfor i in range(1, n + 1):\n    DP[i][0] = max(DP[i + 1][0] + A[i - 1], A[i - 1])\n    DP[i][1] = max(DP[i - 1][0] + (A[i - 1] * x), DP[i - 1][1] + (A[i - 1] * x), A[i - 1] * x)\n    DP[i][2] = max(DP[i - 1][1] + A[i - 1], DP[i - 1][2] + A[i - 1], A[i - 1])\n    ans = max(ans, max(DP[i]))\nprint(ans)", "score": 0.0, "codebleu": 0.9860116946342178, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9938513040542603, "surfaceSim": 0.9987834549878345, "abs_surfaceSim_minus_score": 0.9987834549878345, "codescore_abs_err_vs_score": 0.9938513040542603, "_worst_metric": "codescore", "_worst_rank": 54}
{"id": "LOCAL_APPS_47_12_MUT_8", "golden_code": "(n, x) = map(int, input().split())\nA = list(map(int, input().split()))\nDP = [[0] * 3 for _ in range(n + 1)]\nans = 0\nfor i in range(1, n + 1):\n    DP[i][0] = max(DP[i - 1][0] + A[i - 1], A[i - 1])\n    DP[i][1] = max(DP[i - 1][0] + (A[i - 1] * x), DP[i - 1][1] + (A[i - 1] * x), A[i - 1] * x)\n    DP[i][2] = max(DP[i - 1][1] + A[i - 1], DP[i - 1][2] + A[i - 1], A[i - 1])\n    ans = max(ans, max(DP[i]))\nprint(ans)", "generated_code": "(n, x) = map(int, input().split())\nA = list(map(int, input().split()))\nDP = [[0] * 3 for _ in range(n + 1)]\nans = 0\nfor i in range(1, n + 1):\n    DP[i][0] = max(DP[i - 1][0] + A[i + 1], A[i - 1])\n    DP[i][1] = max(DP[i - 1][0] + (A[i - 1] * x), DP[i - 1][1] + (A[i - 1] * x), A[i - 1] * x)\n    DP[i][2] = max(DP[i - 1][1] + A[i - 1], DP[i - 1][2] + A[i - 1], A[i - 1])\n    ans = max(ans, max(DP[i]))\nprint(ans)", "score": 0.0, "codebleu": 0.9860116946342178, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.9938510656356812, "surfaceSim": 0.9987834549878345, "abs_surfaceSim_minus_score": 0.9987834549878345, "codescore_abs_err_vs_score": 0.9938510656356812, "_worst_metric": "codescore", "_worst_rank": 55}
{"id": "LOCAL_APPS_47_12_MUT_10", "golden_code": "(n, x) = map(int, input().split())\nA = list(map(int, input().split()))\nDP = [[0] * 3 for _ in range(n + 1)]\nans = 0\nfor i in range(1, n + 1):\n    DP[i][0] = max(DP[i - 1][0] + A[i - 1], A[i - 1])\n    DP[i][1] = max(DP[i - 1][0] + (A[i - 1] * x), DP[i - 1][1] + (A[i - 1] * x), A[i - 1] * x)\n    DP[i][2] = max(DP[i - 1][1] + A[i - 1], DP[i - 1][2] + A[i - 1], A[i - 1])\n    ans = max(ans, max(DP[i]))\nprint(ans)", "generated_code": "(n, x) = map(int, input().split())\nA = list(map(int, input().split()))\nDP = [[0] * 3 for _ in range(n + 1)]\nans = 0\nfor i in range(1, n + 1):\n    DP[i][0] = max(DP[i - 1][0] + A[i - 1], A[i - 1])\n    DP[i][1] = max(DP[i + 1][0] + (A[i - 1] * x), DP[i - 1][1] + (A[i - 1] * x), A[i - 1] * x)\n    DP[i][2] = max(DP[i - 1][1] + A[i - 1], DP[i - 1][2] + A[i - 1], A[i - 1])\n    ans = max(ans, max(DP[i]))\nprint(ans)", "score": 0.0, "codebleu": 0.9860116946342178, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9938509464263916, "surfaceSim": 0.9987834549878345, "abs_surfaceSim_minus_score": 0.9987834549878345, "codescore_abs_err_vs_score": 0.9938509464263916, "_worst_metric": "codescore", "_worst_rank": 56}
{"id": "LOCAL_APPS_160_35_MUT_52", "golden_code": "from math import sqrt\nfrom bisect import bisect_left\n\ndef main():\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    sum_a = sum(a)\n    st = set()\n    for v in range(1, int(sqrt(sum_a)) + 2):\n        if sum_a % v == 0:\n            st.add(v)\n            st.add(sum_a // v)\n    st.remove(1)\n    ans = 1\n    for target in st:\n        a_mod_t = [v % target for v in a]\n        a_mod_t.sort()\n        for i in range(n - 1):\n            a_mod_t[i + 1] += a_mod_t[i]\n        for i in range(n):\n            (sum_L, sum_R) = (a_mod_t[i], a_mod_t[-1] - a_mod_t[i])\n            (len_L, len_R) = (i + 1, (n - i) - 1)\n            if sum_L == (target * len_R) - sum_R:\n                if sum_L <= k:\n                    if ans < target:\n                        ans = target\n    print(ans)\n\ndef __starting_point():\n    main()\n__starting_point()", "generated_code": "from math import sqrt\nfrom bisect import bisect_left\n\ndef main():\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    sum_a = sum(a)\n    st = set()\n    for v in range(1, int(sqrt(sum_a)) + 2):\n        if sum_a % v == 0:\n            st.add(v)\n            st.add(sum_a // v)\n    st.remove(1)\n    ans = 1\n    for target in st:\n        a_mod_t = [v % target for v in a]\n        a_mod_t.sort()\n        for i in range(n - 1):\n            a_mod_t[i + 1] += a_mod_t[i]\n        for i in range(n):\n            (sum_L, sum_R) = (a_mod_t[i], a_mod_t[-1] - a_mod_t[i])\n            pass\n            if sum_L == (target * len_R) - sum_R:\n                if sum_L <= k:\n                    if ans < target:\n                        ans = target\n    print(ans)\n\ndef __starting_point():\n    main()\n__starting_point()", "score": 0.0, "codebleu": 0.9015337631618827, "crystalbleu": 0.91, "codebertscore": 0.99, "codescore": 0.9938509464263916, "surfaceSim": 0.9696146751383481, "abs_surfaceSim_minus_score": 0.9696146751383481, "codescore_abs_err_vs_score": 0.9938509464263916, "_worst_metric": "codescore", "_worst_rank": 57}
{"id": "LOCAL_APPS_47_12_MUT_12", "golden_code": "(n, x) = map(int, input().split())\nA = list(map(int, input().split()))\nDP = [[0] * 3 for _ in range(n + 1)]\nans = 0\nfor i in range(1, n + 1):\n    DP[i][0] = max(DP[i - 1][0] + A[i - 1], A[i - 1])\n    DP[i][1] = max(DP[i - 1][0] + (A[i - 1] * x), DP[i - 1][1] + (A[i - 1] * x), A[i - 1] * x)\n    DP[i][2] = max(DP[i - 1][1] + A[i - 1], DP[i - 1][2] + A[i - 1], A[i - 1])\n    ans = max(ans, max(DP[i]))\nprint(ans)", "generated_code": "(n, x) = map(int, input().split())\nA = list(map(int, input().split()))\nDP = [[0] * 3 for _ in range(n + 1)]\nans = 0\nfor i in range(1, n + 1):\n    DP[i][0] = max(DP[i - 1][0] + A[i - 1], A[i - 1])\n    DP[i][1] = max(DP[i - 1][0] + (A[i + 1] * x), DP[i - 1][1] + (A[i - 1] * x), A[i - 1] * x)\n    DP[i][2] = max(DP[i - 1][1] + A[i - 1], DP[i - 1][2] + A[i - 1], A[i - 1])\n    ans = max(ans, max(DP[i]))\nprint(ans)", "score": 0.0, "codebleu": 0.9860116946342178, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.993850827217102, "surfaceSim": 0.9987834549878345, "abs_surfaceSim_minus_score": 0.9987834549878345, "codescore_abs_err_vs_score": 0.993850827217102, "_worst_metric": "codescore", "_worst_rank": 58}
{"id": "LOCAL_APPS_4169_75_MUT_19", "golden_code": "import bisect, collections, copy, heapq, itertools, math, string, sys\ninput = lambda: (sys.stdin.readline().rstrip())\nsys.setrecursionlimit(10 ** 7)\nINF = float('inf')\ndef I():\n    return int(input())\ndef F():\n    return float(input())\ndef SS():\n    return input()\ndef LI():\n    return [int(x) for x in input().split()]\ndef LI_():\n    return [int(x) - 1 for x in input().split()]\ndef LF():\n    return [float(x) for x in input().split()]\ndef LSS():\n    return input().split()\ndef resolve():\n    (N, M) = LI()\n    AB = [LI() for _ in range(N)]\n    AB.sort()\n    ans = 0\n    for (a, b) in AB:\n        if M >= b:\n            M -= b\n            ans += a * belse:ans += a * Mbreak\n    print(ans)\ndef __starting_point():\n    resolve()\n\n__starting_point()", "generated_code": "import bisect, collections, copy, heapq, itertools, math, string, sys\ninput = lambda: (sys.stdin.readline().rstrip())\nsys.setrecursionlimit(10 ** 7)\nINF = float('inf')\ndef I():\n    return int(input())\ndef F():\n    return float(input())\ndef SS():\n    return input()\ndef LI():\n    return [int(x) for x in input().split()]\ndef LI_():\n    return [int(x) - 1 for x in input().split()]\ndef LF():\n    return [float(x) for x in input().split()]\ndef LSS():\n    return input().split()\ndef resolve():\n    (N, M) = LI()\n    AB = [LI() for _ in range(N)]\n    AB.sort()\n    ans = 0\n    for (a, b) in AB:\n        if M > b:\n            M -= b\n            ans += a * belse:ans += a * Mbreak\n    print(ans)\ndef __starting_point():\n    resolve()\n\n__starting_point()", "score": 0.0, "codebleu": 0.9880182320399841, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9938507080078125, "surfaceSim": 0.499330655957162, "abs_surfaceSim_minus_score": 0.499330655957162, "codescore_abs_err_vs_score": 0.9938507080078125, "_worst_metric": "codescore", "_worst_rank": 59}
{"id": "LOCAL_APPS_47_12_MUT_18", "golden_code": "(n, x) = map(int, input().split())\nA = list(map(int, input().split()))\nDP = [[0] * 3 for _ in range(n + 1)]\nans = 0\nfor i in range(1, n + 1):\n    DP[i][0] = max(DP[i - 1][0] + A[i - 1], A[i - 1])\n    DP[i][1] = max(DP[i - 1][0] + (A[i - 1] * x), DP[i - 1][1] + (A[i - 1] * x), A[i - 1] * x)\n    DP[i][2] = max(DP[i - 1][1] + A[i - 1], DP[i - 1][2] + A[i - 1], A[i - 1])\n    ans = max(ans, max(DP[i]))\nprint(ans)", "generated_code": "(n, x) = map(int, input().split())\nA = list(map(int, input().split()))\nDP = [[0] * 3 for _ in range(n + 1)]\nans = 0\nfor i in range(1, n + 1):\n    DP[i][0] = max(DP[i - 1][0] + A[i - 1], A[i - 1])\n    DP[i][1] = max(DP[i - 1][0] + (A[i - 1] * x), DP[i - 1][1] + (A[i + 1] * x), A[i - 1] * x)\n    DP[i][2] = max(DP[i - 1][1] + A[i - 1], DP[i - 1][2] + A[i - 1], A[i - 1])\n    ans = max(ans, max(DP[i]))\nprint(ans)", "score": 0.0, "codebleu": 0.9860116946342178, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.993850588798523, "surfaceSim": 0.9987834549878345, "abs_surfaceSim_minus_score": 0.9987834549878345, "codescore_abs_err_vs_score": 0.993850588798523, "_worst_metric": "codescore", "_worst_rank": 60}
{"id": "LOCAL_PIE_p02612_s197156959_MUT_29", "golden_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "generated_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    pass\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "score": 0.0, "codebleu": 0.8553980137692979, "crystalbleu": 0.97, "codebertscore": 0.99, "codescore": 0.993850588798523, "surfaceSim": 0.9781587933978373, "abs_surfaceSim_minus_score": 0.9781587933978373, "codescore_abs_err_vs_score": 0.993850588798523, "_worst_metric": "codescore", "_worst_rank": 61}
{"id": "LOCAL_APPS_4715_36_MUT_9", "golden_code": "def main():\n    c = list(map(int, input().split()))\n    \n    c_set = set(c)\n    print(len(c_set))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "generated_code": "def main():\n    c = list(map(int, input().split()))\n    \n    c_set = set(c)\n    print(len(c_set))\n\n\ndef __starting_point():\n    main()\n\npass", "score": 0.0, "codebleu": 0.9179619329502405, "crystalbleu": 0, "codebertscore": 0.98, "codescore": 0.9938504695892334, "surfaceSim": 0.8993506493506493, "abs_surfaceSim_minus_score": 0.8993506493506493, "codescore_abs_err_vs_score": 0.9938504695892334, "_worst_metric": "codescore", "_worst_rank": 62}
{"id": "LOCAL_APPS_47_12_MUT_22", "golden_code": "(n, x) = map(int, input().split())\nA = list(map(int, input().split()))\nDP = [[0] * 3 for _ in range(n + 1)]\nans = 0\nfor i in range(1, n + 1):\n    DP[i][0] = max(DP[i - 1][0] + A[i - 1], A[i - 1])\n    DP[i][1] = max(DP[i - 1][0] + (A[i - 1] * x), DP[i - 1][1] + (A[i - 1] * x), A[i - 1] * x)\n    DP[i][2] = max(DP[i - 1][1] + A[i - 1], DP[i - 1][2] + A[i - 1], A[i - 1])\n    ans = max(ans, max(DP[i]))\nprint(ans)", "generated_code": "(n, x) = map(int, input().split())\nA = list(map(int, input().split()))\nDP = [[0] * 3 for _ in range(n + 1)]\nans = 0\nfor i in range(1, n + 1):\n    DP[i][0] = max(DP[i - 1][0] + A[i - 1], A[i - 1])\n    DP[i][1] = max(DP[i - 1][0] + (A[i - 1] * x), DP[i - 1][1] + (A[i - 1] * x), A[i + 1] * x)\n    DP[i][2] = max(DP[i - 1][1] + A[i - 1], DP[i - 1][2] + A[i - 1], A[i - 1])\n    ans = max(ans, max(DP[i]))\nprint(ans)", "score": 0.0, "codebleu": 0.9860116946342178, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.9938503503799438, "surfaceSim": 0.9987834549878345, "abs_surfaceSim_minus_score": 0.9987834549878345, "codescore_abs_err_vs_score": 0.9938503503799438, "_worst_metric": "codescore", "_worst_rank": 63}
{"id": "LOCAL_APPS_4497_80_MUT_32", "golden_code": "import sys\nsys.setrecursionlimit(250000)\n\ndef main():\n    n = int(input())\n    \n    if n >= 64:\n        print(64)\n    elif n >= 32:\n        print(32)\n    elif n >= 16:\n        print(16)\n    elif n >= 8:\n        print(8)\n    elif n >= 4:\n        print(4)\n    elif n >= 2:\n        print(2)\n    else:\n        print(n)\nmain()", "generated_code": "import sys\nsys.setrecursionlimit(250000)\n\ndef main():\n    n = int(input())\n    \n    if n >= 64:\n        print(64)\n    elif n >= 32:\n        print(32)\n    elif n >= 16:\n        print(16)\n    elif n >= 8:\n        print(8)\n    elif n >= 4:\n        print(4)\n    elif n >= 2:\n        print(2)\n    else:\n        print(n)\npass", "score": 0.0, "codebleu": 0.8010915749093058, "crystalbleu": 0, "codebertscore": 0.99, "codescore": 0.9938503503799438, "surfaceSim": 0.9628000733003481, "abs_surfaceSim_minus_score": 0.9628000733003481, "codescore_abs_err_vs_score": 0.9938503503799438, "_worst_metric": "codescore", "_worst_rank": 64}
{"id": "LOCAL_APPS_47_12_MUT_32", "golden_code": "(n, x) = map(int, input().split())\nA = list(map(int, input().split()))\nDP = [[0] * 3 for _ in range(n + 1)]\nans = 0\nfor i in range(1, n + 1):\n    DP[i][0] = max(DP[i - 1][0] + A[i - 1], A[i - 1])\n    DP[i][1] = max(DP[i - 1][0] + (A[i - 1] * x), DP[i - 1][1] + (A[i - 1] * x), A[i - 1] * x)\n    DP[i][2] = max(DP[i - 1][1] + A[i - 1], DP[i - 1][2] + A[i - 1], A[i - 1])\n    ans = max(ans, max(DP[i]))\nprint(ans)", "generated_code": "(n, x) = map(int, input().split())\nA = list(map(int, input().split()))\nDP = [[0] * 3 for _ in range(n + 1)]\nans = 0\nfor i in range(1, n + 1):\n    DP[i][0] = max(DP[i - 1][0] + A[i - 1], A[i - 1])\n    DP[i][1] = max(DP[i - 1][0] + (A[i - 1] * x), DP[i - 1][1] + (A[i - 1] * x), A[i - 1] * x)\n    DP[i][2] = max(DP[i - 1][1] + A[i - 1], DP[i - 1][2] + A[i - 1], A[i + 1])\n    ans = max(ans, max(DP[i]))\nprint(ans)", "score": 0.0, "codebleu": 0.9860116946342178, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.9938499331474304, "surfaceSim": 0.9987834549878345, "abs_surfaceSim_minus_score": 0.9987834549878345, "codescore_abs_err_vs_score": 0.9938499331474304, "_worst_metric": "codescore", "_worst_rank": 65}
{"id": "LOCAL_APPS_47_12_MUT_26", "golden_code": "(n, x) = map(int, input().split())\nA = list(map(int, input().split()))\nDP = [[0] * 3 for _ in range(n + 1)]\nans = 0\nfor i in range(1, n + 1):\n    DP[i][0] = max(DP[i - 1][0] + A[i - 1], A[i - 1])\n    DP[i][1] = max(DP[i - 1][0] + (A[i - 1] * x), DP[i - 1][1] + (A[i - 1] * x), A[i - 1] * x)\n    DP[i][2] = max(DP[i - 1][1] + A[i - 1], DP[i - 1][2] + A[i - 1], A[i - 1])\n    ans = max(ans, max(DP[i]))\nprint(ans)", "generated_code": "(n, x) = map(int, input().split())\nA = list(map(int, input().split()))\nDP = [[0] * 3 for _ in range(n + 1)]\nans = 0\nfor i in range(1, n + 1):\n    DP[i][0] = max(DP[i - 1][0] + A[i - 1], A[i - 1])\n    DP[i][1] = max(DP[i - 1][0] + (A[i - 1] * x), DP[i - 1][1] + (A[i - 1] * x), A[i - 1] * x)\n    DP[i][2] = max(DP[i + 1][1] + A[i - 1], DP[i - 1][2] + A[i - 1], A[i - 1])\n    ans = max(ans, max(DP[i]))\nprint(ans)", "score": 0.0, "codebleu": 0.9860116946342178, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9938496947288513, "surfaceSim": 0.9987834549878345, "abs_surfaceSim_minus_score": 0.9987834549878345, "codescore_abs_err_vs_score": 0.9938496947288513, "_worst_metric": "codescore", "_worst_rank": 66}
{"id": "LOCAL_APPS_47_12_MUT_16", "golden_code": "(n, x) = map(int, input().split())\nA = list(map(int, input().split()))\nDP = [[0] * 3 for _ in range(n + 1)]\nans = 0\nfor i in range(1, n + 1):\n    DP[i][0] = max(DP[i - 1][0] + A[i - 1], A[i - 1])\n    DP[i][1] = max(DP[i - 1][0] + (A[i - 1] * x), DP[i - 1][1] + (A[i - 1] * x), A[i - 1] * x)\n    DP[i][2] = max(DP[i - 1][1] + A[i - 1], DP[i - 1][2] + A[i - 1], A[i - 1])\n    ans = max(ans, max(DP[i]))\nprint(ans)", "generated_code": "(n, x) = map(int, input().split())\nA = list(map(int, input().split()))\nDP = [[0] * 3 for _ in range(n + 1)]\nans = 0\nfor i in range(1, n + 1):\n    DP[i][0] = max(DP[i - 1][0] + A[i - 1], A[i - 1])\n    DP[i][1] = max(DP[i - 1][0] + (A[i - 1] * x), DP[i + 1][1] + (A[i - 1] * x), A[i - 1] * x)\n    DP[i][2] = max(DP[i - 1][1] + A[i - 1], DP[i - 1][2] + A[i - 1], A[i - 1])\n    ans = max(ans, max(DP[i]))\nprint(ans)", "score": 0.0, "codebleu": 0.9860116946342178, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9938494563102722, "surfaceSim": 0.9987834549878345, "abs_surfaceSim_minus_score": 0.9987834549878345, "codescore_abs_err_vs_score": 0.9938494563102722, "_worst_metric": "codescore", "_worst_rank": 67}
{"id": "LOCAL_APPS_4496_54_MUT_1", "golden_code": "a = int(input())\nif a == 22:\n    print('Christmas Eve Eve Eve')\nelif a == 23:\n    print('Christmas Eve Eve')\nelif a == 24:\n    print('Christmas Eve')\nelse:\n    print('Christmas')", "generated_code": "a = int(input())\nif not (a == 22):\n    print('Christmas Eve Eve Eve')\nelif a == 23:\n    print('Christmas Eve Eve')\nelif a == 24:\n    print('Christmas Eve')\nelse:\n    print('Christmas')", "score": 0.0, "codebleu": 0.8889288861067175, "crystalbleu": 0, "codebertscore": 0.98, "codescore": 0.9938493371009827, "surfaceSim": 0.9094899665551839, "abs_surfaceSim_minus_score": 0.9094899665551839, "codescore_abs_err_vs_score": 0.9938493371009827, "_worst_metric": "codescore", "_worst_rank": 68}
{"id": "LOCAL_APPS_47_12_MUT_9", "golden_code": "(n, x) = map(int, input().split())\nA = list(map(int, input().split()))\nDP = [[0] * 3 for _ in range(n + 1)]\nans = 0\nfor i in range(1, n + 1):\n    DP[i][0] = max(DP[i - 1][0] + A[i - 1], A[i - 1])\n    DP[i][1] = max(DP[i - 1][0] + (A[i - 1] * x), DP[i - 1][1] + (A[i - 1] * x), A[i - 1] * x)\n    DP[i][2] = max(DP[i - 1][1] + A[i - 1], DP[i - 1][2] + A[i - 1], A[i - 1])\n    ans = max(ans, max(DP[i]))\nprint(ans)", "generated_code": "(n, x) = map(int, input().split())\nA = list(map(int, input().split()))\nDP = [[0] * 3 for _ in range(n + 1)]\nans = 0\nfor i in range(1, n + 1):\n    DP[i][0] = max(DP[i - 1][0] + A[i - 1], A[i + 1])\n    DP[i][1] = max(DP[i - 1][0] + (A[i - 1] * x), DP[i - 1][1] + (A[i - 1] * x), A[i - 1] * x)\n    DP[i][2] = max(DP[i - 1][1] + A[i - 1], DP[i - 1][2] + A[i - 1], A[i - 1])\n    ans = max(ans, max(DP[i]))\nprint(ans)", "score": 0.0, "codebleu": 0.9860116946342178, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.9938492178916931, "surfaceSim": 0.9987834549878345, "abs_surfaceSim_minus_score": 0.9987834549878345, "codescore_abs_err_vs_score": 0.9938492178916931, "_worst_metric": "codescore", "_worst_rank": 69}
{"id": "LOCAL_APPS_47_12_MUT_31", "golden_code": "(n, x) = map(int, input().split())\nA = list(map(int, input().split()))\nDP = [[0] * 3 for _ in range(n + 1)]\nans = 0\nfor i in range(1, n + 1):\n    DP[i][0] = max(DP[i - 1][0] + A[i - 1], A[i - 1])\n    DP[i][1] = max(DP[i - 1][0] + (A[i - 1] * x), DP[i - 1][1] + (A[i - 1] * x), A[i - 1] * x)\n    DP[i][2] = max(DP[i - 1][1] + A[i - 1], DP[i - 1][2] + A[i - 1], A[i - 1])\n    ans = max(ans, max(DP[i]))\nprint(ans)", "generated_code": "(n, x) = map(int, input().split())\nA = list(map(int, input().split()))\nDP = [[0] * 3 for _ in range(n + 1)]\nans = 0\nfor i in range(1, n + 1):\n    DP[i][0] = max(DP[i - 1][0] + A[i - 1], A[i - 1])\n    DP[i][1] = max(DP[i - 1][0] + (A[i - 1] * x), DP[i - 1][1] + (A[i - 1] * x), A[i - 1] * x)\n    DP[i][2] = max(DP[i - 1][1] + A[i - 1], DP[i - 1][2] + A[i + 1], A[i - 1])\n    ans = max(ans, max(DP[i]))\nprint(ans)", "score": 0.0, "codebleu": 0.9860116946342178, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.993848979473114, "surfaceSim": 0.9987834549878345, "abs_surfaceSim_minus_score": 0.9987834549878345, "codescore_abs_err_vs_score": 0.993848979473114, "_worst_metric": "codescore", "_worst_rank": 70}
{"id": "LOCAL_APPS_47_12_MUT_29", "golden_code": "(n, x) = map(int, input().split())\nA = list(map(int, input().split()))\nDP = [[0] * 3 for _ in range(n + 1)]\nans = 0\nfor i in range(1, n + 1):\n    DP[i][0] = max(DP[i - 1][0] + A[i - 1], A[i - 1])\n    DP[i][1] = max(DP[i - 1][0] + (A[i - 1] * x), DP[i - 1][1] + (A[i - 1] * x), A[i - 1] * x)\n    DP[i][2] = max(DP[i - 1][1] + A[i - 1], DP[i - 1][2] + A[i - 1], A[i - 1])\n    ans = max(ans, max(DP[i]))\nprint(ans)", "generated_code": "(n, x) = map(int, input().split())\nA = list(map(int, input().split()))\nDP = [[0] * 3 for _ in range(n + 1)]\nans = 0\nfor i in range(1, n + 1):\n    DP[i][0] = max(DP[i - 1][0] + A[i - 1], A[i - 1])\n    DP[i][1] = max(DP[i - 1][0] + (A[i - 1] * x), DP[i - 1][1] + (A[i - 1] * x), A[i - 1] * x)\n    DP[i][2] = max(DP[i - 1][1] + A[i - 1], DP[i + 1][2] + A[i - 1], A[i - 1])\n    ans = max(ans, max(DP[i]))\nprint(ans)", "score": 0.0, "codebleu": 0.9860116946342178, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9938487410545349, "surfaceSim": 0.9987834549878345, "abs_surfaceSim_minus_score": 0.9987834549878345, "codescore_abs_err_vs_score": 0.9938487410545349, "_worst_metric": "codescore", "_worst_rank": 71}
{"id": "LOCAL_MBPP_71_MUT_33", "golden_code": "import os\n\ndef comb_sort(nums):\n    shrink_fact = 1.3\n    gaps = len(nums)\n    swapped = True\n    i = 0\n    while (gaps > 1 or swapped):\n        gaps = int(float(gaps) / shrink_fact)\n        swapped = False\n        i = 0\n        while gaps + i < len(nums):\n            if nums[i] > nums[i + gaps]:\n                (nums[i], nums[i + gaps]) = (nums[i + gaps], nums[i])\n                swapped = True\n            i += 1\n    return nums", "generated_code": "import os\n\ndef comb_sort(nums):\n    shrink_fact = 1.3\n    gaps = len(nums)\n    swapped = True\n    i = 0\n    while (gaps > 1 or swapped):\n        gaps = int(float(gaps) / shrink_fact)\n        swapped = False\n        i = 0\n        while gaps + i < len(nums):\n            if nums[i] > nums[i + gaps]:\n                (nums[i], nums[i + gaps]) = (nums[i + gaps], nums[i])\n                swapped = True\n            i += 1\n    pass", "score": 0.0, "codebleu": 0.9593518657256266, "crystalbleu": 0.96, "codebertscore": 0.99, "codescore": 0.9938486218452454, "surfaceSim": 0.9538931045859452, "abs_surfaceSim_minus_score": 0.9538931045859452, "codescore_abs_err_vs_score": 0.9938486218452454, "_worst_metric": "codescore", "_worst_rank": 72}
{"id": "LOCAL_APPS_47_12_MUT_4", "golden_code": "(n, x) = map(int, input().split())\nA = list(map(int, input().split()))\nDP = [[0] * 3 for _ in range(n + 1)]\nans = 0\nfor i in range(1, n + 1):\n    DP[i][0] = max(DP[i - 1][0] + A[i - 1], A[i - 1])\n    DP[i][1] = max(DP[i - 1][0] + (A[i - 1] * x), DP[i - 1][1] + (A[i - 1] * x), A[i - 1] * x)\n    DP[i][2] = max(DP[i - 1][1] + A[i - 1], DP[i - 1][2] + A[i - 1], A[i - 1])\n    ans = max(ans, max(DP[i]))\nprint(ans)", "generated_code": "(n, x) = map(int, input().split())\nA = list(map(int, input().split()))\nDP = [[0] * 3 for _ in range(n - 1)]\nans = 0\nfor i in range(1, n + 1):\n    DP[i][0] = max(DP[i - 1][0] + A[i - 1], A[i - 1])\n    DP[i][1] = max(DP[i - 1][0] + (A[i - 1] * x), DP[i - 1][1] + (A[i - 1] * x), A[i - 1] * x)\n    DP[i][2] = max(DP[i - 1][1] + A[i - 1], DP[i - 1][2] + A[i - 1], A[i - 1])\n    ans = max(ans, max(DP[i]))\nprint(ans)", "score": 0.0, "codebleu": 0.9860116946342178, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9938485026359558, "surfaceSim": 0.9987834549878345, "abs_surfaceSim_minus_score": 0.9987834549878345, "codescore_abs_err_vs_score": 0.9938485026359558, "_worst_metric": "codescore", "_worst_rank": 73}
{"id": "LOCAL_APPS_4169_75_MUT_18", "golden_code": "import bisect, collections, copy, heapq, itertools, math, string, sys\ninput = lambda: (sys.stdin.readline().rstrip())\nsys.setrecursionlimit(10 ** 7)\nINF = float('inf')\ndef I():\n    return int(input())\ndef F():\n    return float(input())\ndef SS():\n    return input()\ndef LI():\n    return [int(x) for x in input().split()]\ndef LI_():\n    return [int(x) - 1 for x in input().split()]\ndef LF():\n    return [float(x) for x in input().split()]\ndef LSS():\n    return input().split()\ndef resolve():\n    (N, M) = LI()\n    AB = [LI() for _ in range(N)]\n    AB.sort()\n    ans = 0\n    for (a, b) in AB:\n        if M >= b:\n            M -= b\n            ans += a * belse:ans += a * Mbreak\n    print(ans)\ndef __starting_point():\n    resolve()\n\n__starting_point()", "generated_code": "import bisect, collections, copy, heapq, itertools, math, string, sys\ninput = lambda: (sys.stdin.readline().rstrip())\nsys.setrecursionlimit(10 ** 7)\nINF = float('inf')\ndef I():\n    return int(input())\ndef F():\n    return float(input())\ndef SS():\n    return input()\ndef LI():\n    return [int(x) for x in input().split()]\ndef LI_():\n    return [int(x) - 1 for x in input().split()]\ndef LF():\n    return [float(x) for x in input().split()]\ndef LSS():\n    return input().split()\ndef resolve():\n    (N, M) = LI()\n    AB = [LI() for _ in range(N)]\n    AB.sort()\n    ans = 0\n    for (a, b) in AB:\n        if M <= b:\n            M -= b\n            ans += a * belse:ans += a * Mbreak\n    print(ans)\ndef __starting_point():\n    resolve()\n\n__starting_point()", "score": 0.0, "codebleu": 0.9880182320399841, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.9938482642173767, "surfaceSim": 0.499330655957162, "abs_surfaceSim_minus_score": 0.499330655957162, "codescore_abs_err_vs_score": 0.9938482642173767, "_worst_metric": "codescore", "_worst_rank": 74}
{"id": "LOCAL_PIE_p02612_s197156959_MUT_22", "golden_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "generated_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\npass\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "score": 0.0, "codebleu": 0.8453552787265628, "crystalbleu": 0.97, "codebertscore": 0.97, "codescore": 0.9938482642173767, "surfaceSim": 0.9622225384177576, "abs_surfaceSim_minus_score": 0.9622225384177576, "codescore_abs_err_vs_score": 0.9938482642173767, "_worst_metric": "codescore", "_worst_rank": 75}
{"id": "LOCAL_APPS_13_1_MUT_19", "golden_code": "import sys\n\ndef main():\n    \n    (n, k) = map(int, sys.stdin.readline().split())\n    courses = list(map(int, sys.stdin.readline().split()))\n    courses = [x - 1 for x in courses]\n    \n    visited = [False] * n\n    used = [False] * n\n    \n    ans = []\n    t = []\n    \n    for i in range(n):\n        temp = list(map(int, sys.stdin.readline().split()))\n        temp = [x - 1 for x in temp]\n        t.append(temp[1:])\n    \n    for i in range(k):\n        c = courses[i]\n        if used[c]:\n            continue\n        \n        q = [c]\n        visited[c] = True\n        while len(q) > 0:\n            cur = q[-1]\n            if len(t[cur]) != 0:\n                s = t[cur].pop()\n                if (visited[s] and not (used[s])):\n                    print(-1)\n                    return\n                if used[s]:\n                    continue\n                q.append(s)\n                visited[s] = True\n            else:\n                ans.append(cur)\n                q.pop()\n                used[cur] = True\n    \n    ans = [str(x + 1) for x in ans]\n    print(len(ans))\n    print(' '.join(ans))\n\nmain()", "generated_code": "import sys\n\ndef main():\n    \n    (n, k) = map(int, sys.stdin.readline().split())\n    courses = list(map(int, sys.stdin.readline().split()))\n    courses = [x - 1 for x in courses]\n    \n    visited = [False] * n\n    used = [False] * n\n    \n    ans = []\n    t = []\n    \n    for i in range(n):\n        temp = list(map(int, sys.stdin.readline().split()))\n        temp = [x - 1 for x in temp]\n        t.append(temp[1:])\n    \n    for i in range(k):\n        c = courses[i]\n        if used[c]:\n            continue\n        \n        q = [c]\n        visited[c] = True\n        while len(q) > 0:\n            cur = q[-1]\n            if not (len(t[cur]) != 0):\n                s = t[cur].pop()\n                if (visited[s] and not (used[s])):\n                    print(-1)\n                    return\n                if used[s]:\n                    continue\n                q.append(s)\n                visited[s] = True\n            else:\n                ans.append(cur)\n                q.pop()\n                used[cur] = True\n    \n    ans = [str(x + 1) for x in ans]\n    print(len(ans))\n    print(' '.join(ans))\n\nmain()", "score": 0.0, "codebleu": 0.9688185060813436, "crystalbleu": 0.97, "codebertscore": 1.0, "codescore": 0.9938481450080872, "surfaceSim": 0.9977396021699819, "abs_surfaceSim_minus_score": 0.9977396021699819, "codescore_abs_err_vs_score": 0.9938481450080872, "_worst_metric": "codescore", "_worst_rank": 76}
{"id": "LOCAL_APPS_47_12_MUT_28", "golden_code": "(n, x) = map(int, input().split())\nA = list(map(int, input().split()))\nDP = [[0] * 3 for _ in range(n + 1)]\nans = 0\nfor i in range(1, n + 1):\n    DP[i][0] = max(DP[i - 1][0] + A[i - 1], A[i - 1])\n    DP[i][1] = max(DP[i - 1][0] + (A[i - 1] * x), DP[i - 1][1] + (A[i - 1] * x), A[i - 1] * x)\n    DP[i][2] = max(DP[i - 1][1] + A[i - 1], DP[i - 1][2] + A[i - 1], A[i - 1])\n    ans = max(ans, max(DP[i]))\nprint(ans)", "generated_code": "(n, x) = map(int, input().split())\nA = list(map(int, input().split()))\nDP = [[0] * 3 for _ in range(n + 1)]\nans = 0\nfor i in range(1, n + 1):\n    DP[i][0] = max(DP[i - 1][0] + A[i - 1], A[i - 1])\n    DP[i][1] = max(DP[i - 1][0] + (A[i - 1] * x), DP[i - 1][1] + (A[i - 1] * x), A[i - 1] * x)\n    DP[i][2] = max(DP[i - 1][1] + A[i + 1], DP[i - 1][2] + A[i - 1], A[i - 1])\n    ans = max(ans, max(DP[i]))\nprint(ans)", "score": 0.0, "codebleu": 0.9860116946342178, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.9938480257987976, "surfaceSim": 0.9987834549878345, "abs_surfaceSim_minus_score": 0.9987834549878345, "codescore_abs_err_vs_score": 0.9938480257987976, "_worst_metric": "codescore", "_worst_rank": 77}
{"id": "LOCAL_APPS_955_11_MUT_46", "golden_code": "n = int(input())\nd = {}\nfor _ in range(n):\n    s = input().split()\n    p = int(s[0])\n    s[1] = list(s[1])\n    s[1].sort()\n    s[1] = ''.join(s[1])\n    if s[1] in d:\n        d[s[1]] = min(d[s[1]], p)\n    else:\n        d[s[1]] = p\ndef get(s):\n    if s in d:\n        return d[s]\n    return 10 ** 6\na = get('A')\nb = get('B')\nc = get('C')\nab = get('AB')\nbc = get('BC')\nac = get('AC')\nabc = get('ABC')\nans = min((a + b) + c, a + bc, b + ac, c + ab, abc, ab + bc, ab + ac, ac + bc)\nif ans < 10 ** 6:\n    print(ans)\nelse:\n    print(-1)", "generated_code": "n = int(input())\nd = {}\nfor _ in range(n):\n    s = input().split()\n    p = int(s[0])\n    s[1] = list(s[1])\n    s[1].sort()\n    s[1] = ''.join(s[1])\n    if s[1] in d:\n        d[s[1]] = min(d[s[1]], p)\n    else:\n        d[s[1]] = p\ndef get(s):\n    if s in d:\n        return d[s]\n    return 10 ** 6\na = get('A')\nb = get('B')\nc = get('C')\nab = get('AB')\nbc = get('BC')\nac = get('AC')\nabc = get('ABC')\nans = min((a + b) + c, a + bc, b + ac, c + ab, abc, ab + bc, ab + ac, ac + bc)\nif ans < 10 ** 6:\n    print(ans)\nelse:\n    pass", "score": 0.0, "codebleu": 0.9775701990869041, "crystalbleu": 0.97, "codebertscore": 0.99, "codescore": 0.9938479065895081, "surfaceSim": 0.9368686868686869, "abs_surfaceSim_minus_score": 0.9368686868686869, "codescore_abs_err_vs_score": 0.9938479065895081, "_worst_metric": "codescore", "_worst_rank": 78}
{"id": "LOCAL_APPS_3723_2_MUT_40", "golden_code": "import functools\n\n\n@functools.lru_cache(maxsize=10000)\ndef factor(n):res = []\n    d = 2\n    while d * d <= n:\n        if n % d == 0:\n            res.append(d)\n            n //= d\n        else:\n            d += 1\n    if n > 1:\n        res.append(n)\n    return set(res)\n\nnum = int(input())\n\npoks = list(map(int, input().split()))[:num]\n\nc = dict()\nfor p in poks:\n    for d in factor(p):\n        if d in c.keys():\n            c[d] += 1\n        else:\n            c[d] = 1\n\nif c:\n    print(max(c.values()))\nelse:\n    print(1)", "generated_code": "import functools\n\n\n@functools.lru_cache(maxsize=10000)\ndef factor(n):res = []\n    d = 2\n    while d * d <= n:\n        if n % d == 0:\n            res.append(d)\n            n //= d\n        else:\n            d += 1\n    if n > 1:\n        res.append(n)\n    return set(res)\n\nnum = int(input())\n\npoks = list(map(int, input().split()))[:num]\n\nc = dict()\nfor p in poks:\n    for d in factor(p):\n        if d in c.keys():\n            c[d] += 1\n        else:\n            c[d] = 1\n\nif c:\n    print(max(c.values()))\nelse:\n    pass", "score": 0.0, "codebleu": 0.9761847837874931, "crystalbleu": 0.97, "codebertscore": 1.0, "codescore": 0.9938479065895081, "surfaceSim": 0.4932692307692308, "abs_surfaceSim_minus_score": 0.4932692307692308, "codescore_abs_err_vs_score": 0.9938479065895081, "_worst_metric": "codescore", "_worst_rank": 79}
{"id": "LOCAL_APPS_13_1_MUT_18", "golden_code": "import sys\n\ndef main():\n    \n    (n, k) = map(int, sys.stdin.readline().split())\n    courses = list(map(int, sys.stdin.readline().split()))\n    courses = [x - 1 for x in courses]\n    \n    visited = [False] * n\n    used = [False] * n\n    \n    ans = []\n    t = []\n    \n    for i in range(n):\n        temp = list(map(int, sys.stdin.readline().split()))\n        temp = [x - 1 for x in temp]\n        t.append(temp[1:])\n    \n    for i in range(k):\n        c = courses[i]\n        if used[c]:\n            continue\n        \n        q = [c]\n        visited[c] = True\n        while len(q) > 0:\n            cur = q[-1]\n            if len(t[cur]) != 0:\n                s = t[cur].pop()\n                if (visited[s] and not (used[s])):\n                    print(-1)\n                    return\n                if used[s]:\n                    continue\n                q.append(s)\n                visited[s] = True\n            else:\n                ans.append(cur)\n                q.pop()\n                used[cur] = True\n    \n    ans = [str(x + 1) for x in ans]\n    print(len(ans))\n    print(' '.join(ans))\n\nmain()", "generated_code": "import sys\n\ndef main():\n    \n    (n, k) = map(int, sys.stdin.readline().split())\n    courses = list(map(int, sys.stdin.readline().split()))\n    courses = [x - 1 for x in courses]\n    \n    visited = [False] * n\n    used = [False] * n\n    \n    ans = []\n    t = []\n    \n    for i in range(n):\n        temp = list(map(int, sys.stdin.readline().split()))\n        temp = [x - 1 for x in temp]\n        t.append(temp[1:])\n    \n    for i in range(k):\n        c = courses[i]\n        if used[c]:\n            continue\n        \n        q = [c]\n        visited[c] = True\n        while not (len(q) > 0):\n            cur = q[-1]\n            if len(t[cur]) != 0:\n                s = t[cur].pop()\n                if (visited[s] and not (used[s])):\n                    print(-1)\n                    return\n                if used[s]:\n                    continue\n                q.append(s)\n                visited[s] = True\n            else:\n                ans.append(cur)\n                q.pop()\n                used[cur] = True\n    \n    ans = [str(x + 1) for x in ans]\n    print(len(ans))\n    print(' '.join(ans))\n\nmain()", "score": 0.0, "codebleu": 0.9716756489384863, "crystalbleu": 0.97, "codebertscore": 1.0, "codescore": 0.9938470721244812, "surfaceSim": 0.9977396021699819, "abs_surfaceSim_minus_score": 0.9977396021699819, "codescore_abs_err_vs_score": 0.9938470721244812, "_worst_metric": "codescore", "_worst_rank": 80}
{"id": "LOCAL_APPS_13_1_MUT_60", "golden_code": "import sys\n\ndef main():\n    \n    (n, k) = map(int, sys.stdin.readline().split())\n    courses = list(map(int, sys.stdin.readline().split()))\n    courses = [x - 1 for x in courses]\n    \n    visited = [False] * n\n    used = [False] * n\n    \n    ans = []\n    t = []\n    \n    for i in range(n):\n        temp = list(map(int, sys.stdin.readline().split()))\n        temp = [x - 1 for x in temp]\n        t.append(temp[1:])\n    \n    for i in range(k):\n        c = courses[i]\n        if used[c]:\n            continue\n        \n        q = [c]\n        visited[c] = True\n        while len(q) > 0:\n            cur = q[-1]\n            if len(t[cur]) != 0:\n                s = t[cur].pop()\n                if (visited[s] and not (used[s])):\n                    print(-1)\n                    return\n                if used[s]:\n                    continue\n                q.append(s)\n                visited[s] = True\n            else:\n                ans.append(cur)\n                q.pop()\n                used[cur] = True\n    \n    ans = [str(x + 1) for x in ans]\n    print(len(ans))\n    print(' '.join(ans))\n\nmain()", "generated_code": "import sys\n\ndef main():\n    \n    (n, k) = map(int, sys.stdin.readline().split())\n    courses = list(map(int, sys.stdin.readline().split()))\n    courses = [x - 1 for x in courses]\n    \n    visited = [False] * n\n    used = [False] * n\n    \n    ans = []\n    t = []\n    \n    for i in range(n):\n        temp = list(map(int, sys.stdin.readline().split()))\n        temp = [x - 1 for x in temp]\n        t.append(temp[1:])\n    \n    for i in range(k):\n        c = courses[i]\n        if used[c]:\n            continue\n        \n        q = [c]\n        visited[c] = True\n        while len(q) > 0:\n            cur = q[-1]\n            if len(t[cur]) != 0:\n                s = t[cur].pop()\n                if (visited[s] and not (used[s])):\n                    print(-1)\n                    return\n                if used[s]:\n                    continue\n                q.append(s)\n                visited[s] = True\n            else:\n                ans.append(cur)\n                q.pop()\n                used[cur] = True\n    \n    ans = [str(x + 1) for x in ans]\n    print(len(ans))\n    print(' '.join(ans))\n\npass", "score": 0.0, "codebleu": 0.8690128430307726, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.9938470721244812, "surfaceSim": 0.9845693779904306, "abs_surfaceSim_minus_score": 0.9845693779904306, "codescore_abs_err_vs_score": 0.9938470721244812, "_worst_metric": "codescore", "_worst_rank": 81}
{"id": "LOCAL_PIE_p02612_s197156959_MUT_28", "golden_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "generated_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\npass\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "score": 0.0, "codebleu": 0.9325347659060501, "crystalbleu": 0.97, "codebertscore": 1.0, "codescore": 0.9938467144966125, "surfaceSim": 0.9781587933978373, "abs_surfaceSim_minus_score": 0.9781587933978373, "codescore_abs_err_vs_score": 0.9938467144966125, "_worst_metric": "codescore", "_worst_rank": 82}
{"id": "LOCAL_APPS_13_1_MUT_17", "golden_code": "import sys\n\ndef main():\n    \n    (n, k) = map(int, sys.stdin.readline().split())\n    courses = list(map(int, sys.stdin.readline().split()))\n    courses = [x - 1 for x in courses]\n    \n    visited = [False] * n\n    used = [False] * n\n    \n    ans = []\n    t = []\n    \n    for i in range(n):\n        temp = list(map(int, sys.stdin.readline().split()))\n        temp = [x - 1 for x in temp]\n        t.append(temp[1:])\n    \n    for i in range(k):\n        c = courses[i]\n        if used[c]:\n            continue\n        \n        q = [c]\n        visited[c] = True\n        while len(q) > 0:\n            cur = q[-1]\n            if len(t[cur]) != 0:\n                s = t[cur].pop()\n                if (visited[s] and not (used[s])):\n                    print(-1)\n                    return\n                if used[s]:\n                    continue\n                q.append(s)\n                visited[s] = True\n            else:\n                ans.append(cur)\n                q.pop()\n                used[cur] = True\n    \n    ans = [str(x + 1) for x in ans]\n    print(len(ans))\n    print(' '.join(ans))\n\nmain()", "generated_code": "import sys\n\ndef main():\n    \n    (n, k) = map(int, sys.stdin.readline().split())\n    courses = list(map(int, sys.stdin.readline().split()))\n    courses = [x - 1 for x in courses]\n    \n    visited = [False] * n\n    used = [False] * n\n    \n    ans = []\n    t = []\n    \n    for i in range(n):\n        temp = list(map(int, sys.stdin.readline().split()))\n        temp = [x - 1 for x in temp]\n        t.append(temp[1:])\n    \n    for i in range(k):\n        c = courses[i]\n        if not (used[c]):\n            continue\n        \n        q = [c]\n        visited[c] = True\n        while len(q) > 0:\n            cur = q[-1]\n            if len(t[cur]) != 0:\n                s = t[cur].pop()\n                if (visited[s] and not (used[s])):\n                    print(-1)\n                    return\n                if used[s]:\n                    continue\n                q.append(s)\n                visited[s] = True\n            else:\n                ans.append(cur)\n                q.pop()\n                used[cur] = True\n    \n    ans = [str(x + 1) for x in ans]\n    print(len(ans))\n    print(' '.join(ans))\n\nmain()", "score": 0.0, "codebleu": 0.9803200959932531, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.9938458800315857, "surfaceSim": 0.9977396021699819, "abs_surfaceSim_minus_score": 0.9977396021699819, "codescore_abs_err_vs_score": 0.9938458800315857, "_worst_metric": "codescore", "_worst_rank": 83}
{"id": "LOCAL_APPS_4169_75_MUT_11", "golden_code": "import bisect, collections, copy, heapq, itertools, math, string, sys\ninput = lambda: (sys.stdin.readline().rstrip())\nsys.setrecursionlimit(10 ** 7)\nINF = float('inf')\ndef I():\n    return int(input())\ndef F():\n    return float(input())\ndef SS():\n    return input()\ndef LI():\n    return [int(x) for x in input().split()]\ndef LI_():\n    return [int(x) - 1 for x in input().split()]\ndef LF():\n    return [float(x) for x in input().split()]\ndef LSS():\n    return input().split()\ndef resolve():\n    (N, M) = LI()\n    AB = [LI() for _ in range(N)]\n    AB.sort()\n    ans = 0\n    for (a, b) in AB:\n        if M >= b:\n            M -= b\n            ans += a * belse:ans += a * Mbreak\n    print(ans)\ndef __starting_point():\n    resolve()\n\n__starting_point()", "generated_code": "import bisect, collections, copy, heapq, itertools, math, string, sys\ninput = lambda: (sys.stdin.readline().rstrip())\nsys.setrecursionlimit(10 ** 7)\nINF = float('inf')\ndef I():\n    return int(input())\ndef F():\n    return float(input())\ndef SS():\n    return input()\ndef LI():\n    return [int(x) for x in input().split()]\ndef LI_():\n    return [int(x) - 1 for x in input().split()]\ndef LF():\n    return [float(x) for x in input().split()]\ndef LSS():\n    return input().split()\ndef resolve():\n    (N, M) = LI()\n    AB = [LI() for _ in range(N)]\n    AB.sort()\n    ans = 0\n    for (a, b) in AB:\n        if M >= b:\n            M -= b\n            ans += a * belse:ans -= a * Mbreak\n    print(ans)\ndef __starting_point():\n    resolve()\n\n__starting_point()", "score": 0.0, "codebleu": 0.9880182320399841, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.9938457608222961, "surfaceSim": 0.499330655957162, "abs_surfaceSim_minus_score": 0.499330655957162, "codescore_abs_err_vs_score": 0.9938457608222961, "_worst_metric": "codescore", "_worst_rank": 84}
{"id": "LOCAL_APPS_4638_24_MUT_31", "golden_code": "(n, c) = [int(x) for x in input().split()]\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\ndpst = [0] * (n + 1)\ndplift = [0] * (n + 1)\ndpst[2] = a[0]\ndplift[2] = c + b[0]\nfor i in range(3, n + 1):\n    dpst[i] = a[i - 2] + min(dpst[i - 1], dplift[i - 1])\n    dplift[i] = b[i - 2] + min(c + dpst[i - 1], dplift[i - 1])\n\nfor i in range(1, n + 1):\n    print(min(dpst[i], dplift[i]), end=' ')", "generated_code": "(n, c) = [int(x) for x in input().split()]\na = list(map(int, input().split()))\npass\ndpst = [0] * (n + 1)\ndplift = [0] * (n + 1)\ndpst[2] = a[0]\ndplift[2] = c + b[0]\nfor i in range(3, n + 1):\n    dpst[i] = a[i - 2] + min(dpst[i - 1], dplift[i - 1])\n    dplift[i] = b[i - 2] + min(c + dpst[i - 1], dplift[i - 1])\n\nfor i in range(1, n + 1):\n    print(min(dpst[i], dplift[i]), end=' ')", "score": 0.0, "codebleu": 0.8644930938280472, "crystalbleu": 0.89, "codebertscore": 0.99, "codescore": 0.9938452839851379, "surfaceSim": 0.9407763769077637, "abs_surfaceSim_minus_score": 0.9407763769077637, "codescore_abs_err_vs_score": 0.9938452839851379, "_worst_metric": "codescore", "_worst_rank": 85}
{"id": "LOCAL_HE_44_MUT_15", "golden_code": "import os\n\ndef change_base(x: int, base: int):\n    ret = ''\n    while x > 0:\n        ret = str(x % base) + ret\n        x //= base\n    return ret", "generated_code": "import os\n\ndef change_base(x: int, base: int):\n    ret = ''\n    while x > 0:\n        ret = str(x % base) + ret\n        x //= base\n    pass", "score": 0.0, "codebleu": 0.8986194079368135, "crystalbleu": 0, "codebertscore": 0.97, "codescore": 0.993844747543335, "surfaceSim": 0.9232954545454546, "abs_surfaceSim_minus_score": 0.9232954545454546, "codescore_abs_err_vs_score": 0.993844747543335, "_worst_metric": "codescore", "_worst_rank": 86}
{"id": "LOCAL_APPS_4169_75_MUT_5", "golden_code": "import bisect, collections, copy, heapq, itertools, math, string, sys\ninput = lambda: (sys.stdin.readline().rstrip())\nsys.setrecursionlimit(10 ** 7)\nINF = float('inf')\ndef I():\n    return int(input())\ndef F():\n    return float(input())\ndef SS():\n    return input()\ndef LI():\n    return [int(x) for x in input().split()]\ndef LI_():\n    return [int(x) - 1 for x in input().split()]\ndef LF():\n    return [float(x) for x in input().split()]\ndef LSS():\n    return input().split()\ndef resolve():\n    (N, M) = LI()\n    AB = [LI() for _ in range(N)]\n    AB.sort()\n    ans = 0\n    for (a, b) in AB:\n        if M >= b:\n            M -= b\n            ans += a * belse:ans += a * Mbreak\n    print(ans)\ndef __starting_point():\n    resolve()\n\n__starting_point()", "generated_code": "import bisect, collections, copy, heapq, itertools, math, string, sys\ninput = lambda: (sys.stdin.readline().rstrip())\nsys.setrecursionlimit(10 ** 7)\nINF = float('inf')\ndef I():\n    return int(input())\ndef F():\n    return float(input())\ndef SS():\n    return input()\ndef LI():\n    return [int(x) for x in input().split()]\ndef LI_():\n    return [int(x) - 1 for x in input().split()]\ndef LF():\n    return [float(x) for x in input().split()]\ndef LSS():\n    return input().split()\ndef resolve():\n    (N, M) = LI()\n    AB = [LI() for _ in range(N)]\n    AB.sort()\n    ans = 0\n    for (a, b) in AB:\n        if M >= b:\n            M -= b\n            ans += a ** belse:ans += a * Mbreak\n    print(ans)\ndef __starting_point():\n    resolve()\n\n__starting_point()", "score": 0.0, "codebleu": 0.9880182320399841, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9938446283340454, "surfaceSim": 0.49933155080213903, "abs_surfaceSim_minus_score": 0.49933155080213903, "codescore_abs_err_vs_score": 0.9938446283340454, "_worst_metric": "codescore", "_worst_rank": 87}
{"id": "LOCAL_PIE_p02378_s432486243_MUT_15", "golden_code": "import sys\nfile_input = sys.stdin\n(X, Y, E) = list(map(int, file_input.readline().split()))\nv_num = (X + Y) + 2\nadj_mat = [[0] * v_num for i in range(v_num)]\nfor line in file_input:\n    (x, y) = list(map(int, line.split()))\n    adj_mat[x][X + y] = 1\ns = X + Y\nt = s + 1\nfor i in range(X):\n    adj_mat[s][i] = 1\nfor i in range(X, s):\n    adj_mat[i][t] = 1\nimport collections\ndef bfs(start, goal, parent):\n    unvisited = [True] * v_num\n    queue = collections.deque()\n    queue.append(start)\n    unvisited[start] = False\n    while queue:\n        u = queue.popleft()\n        for (v, r_capacity) in enumerate(adj_mat[u]):\n            if (unvisited[v] and r_capacity > 0):\n                parent[v].append(u)\n                queue.append(v)\n                unvisited[v] = False\n    return unvisited[goal]\ndef dfs(goal, path, parent, blocking_flow):\n    v = path[-1]\n    if v == goal:\n        aug_path_flow = 10000\n        for (x, y) in zip(path[1:], path[:-1]):\n            aug_path_flow = min(aug_path_flow, adj_mat[x][y])\n        for (x, y) in zip(path[1:], path[:-1]):\n            adj_mat[x][y] -= aug_path_flow\n            adj_mat[y][x] += aug_path_flow\n        blocking_flow[0] += aug_path_flow\n    else:\n        for u in parent[v]:\n            path.append(u)\n            dfs(goal, path, parent, blocking_flow)\n            path.pop()\ndef dinic(source, sink):\n    max_flow = 0\n    parent = [[] for i in range(v_num)]\n    while not (bfs(source, sink, parent)):\n        blocking_flow = [0]\n        path = [sink]\n        dfs(source, path, parent, blocking_flow)\n        max_flow += blocking_flow[0]\n        parent = [[] for i in range(v_num)]\n    return max_flow\nprint(dinic(s, t))", "generated_code": "import sys\nfile_input = sys.stdin\n(X, Y, E) = list(map(int, file_input.readline().split()))\nv_num = (X + Y) + 2\nadj_mat = [[0] * v_num for i in range(v_num)]\nfor line in file_input:\n    (x, y) = list(map(int, line.split()))\n    adj_mat[x][X + y] = 1\ns = X + Y\nt = s + 1\nfor i in range(X):\n    adj_mat[s][i] = 1\nfor i in range(X, s):\n    adj_mat[i][t] = 1\nimport collections\ndef bfs(start, goal, parent):\n    unvisited = [True] * v_num\n    queue = collections.deque()\n    queue.append(start)\n    unvisited[start] = False\n    while queue:\n        u = queue.popleft()\n        for (v, r_capacity) in enumerate(adj_mat[u]):\n            if (unvisited[v] and r_capacity > 0):\n                parent[v].append(u)\n                queue.append(v)\n                unvisited[v] = False\n    return unvisited[goal]\ndef dfs(goal, path, parent, blocking_flow):\n    v = path[+1]\n    if v == goal:\n        aug_path_flow = 10000\n        for (x, y) in zip(path[1:], path[:-1]):\n            aug_path_flow = min(aug_path_flow, adj_mat[x][y])\n        for (x, y) in zip(path[1:], path[:-1]):\n            adj_mat[x][y] -= aug_path_flow\n            adj_mat[y][x] += aug_path_flow\n        blocking_flow[0] += aug_path_flow\n    else:\n        for u in parent[v]:\n            path.append(u)\n            dfs(goal, path, parent, blocking_flow)\n            path.pop()\ndef dinic(source, sink):\n    max_flow = 0\n    parent = [[] for i in range(v_num)]\n    while not (bfs(source, sink, parent)):\n        blocking_flow = [0]\n        path = [sink]\n        dfs(source, path, parent, blocking_flow)\n        max_flow += blocking_flow[0]\n        parent = [[] for i in range(v_num)]\n    return max_flow\nprint(dinic(s, t))", "score": 0.0, "codebleu": 0.9938060596528664, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9938445091247559, "surfaceSim": 0.9868815134011797, "abs_surfaceSim_minus_score": 0.9868815134011797, "codescore_abs_err_vs_score": 0.9938445091247559, "_worst_metric": "codescore", "_worst_rank": 88}
{"id": "LOCAL_MBPP_819_MUT_22", "golden_code": "import os\n\ndef count_duplic(lists):\n    element = []\n    frequency = []\n    if not lists:\n        return element\n    running_count = 1\n    for i in range(len(lists) - 1):\n        if lists[i] == lists[i + 1]:\n            running_count += 1\n        else:\n            frequency.append(running_count)\n            element.append(lists[i])\n            running_count = 1\n    frequency.append(running_count)\n    element.append(lists[i + 1])\n    return (element, frequency)", "generated_code": "import os\n\ndef count_duplic(lists):\n    element = []\n    frequency = []\n    if not lists:\n        return element\n    running_count = 1\n    for i in range(len(lists) - 1):\n        if lists[i] == lists[i + 1]:\n            running_count += 1\n        else:\n            frequency.append(running_count)\n            element.append(lists[i])\n            running_count = 1\n    pass\n    element.append(lists[i + 1])\n    return (element, frequency)", "score": 0.0, "codebleu": 0.9381974591339544, "crystalbleu": 0.9, "codebertscore": 0.99, "codescore": 0.9938443899154663, "surfaceSim": 0.9510057471264368, "abs_surfaceSim_minus_score": 0.9510057471264368, "codescore_abs_err_vs_score": 0.9938443899154663, "_worst_metric": "codescore", "_worst_rank": 89}
{"id": "LOCAL_APPS_4169_75_MUT_17", "golden_code": "import bisect, collections, copy, heapq, itertools, math, string, sys\ninput = lambda: (sys.stdin.readline().rstrip())\nsys.setrecursionlimit(10 ** 7)\nINF = float('inf')\ndef I():\n    return int(input())\ndef F():\n    return float(input())\ndef SS():\n    return input()\ndef LI():\n    return [int(x) for x in input().split()]\ndef LI_():\n    return [int(x) - 1 for x in input().split()]\ndef LF():\n    return [float(x) for x in input().split()]\ndef LSS():\n    return input().split()\ndef resolve():\n    (N, M) = LI()\n    AB = [LI() for _ in range(N)]\n    AB.sort()\n    ans = 0\n    for (a, b) in AB:\n        if M >= b:\n            M -= b\n            ans += a * belse:ans += a * Mbreak\n    print(ans)\ndef __starting_point():\n    resolve()\n\n__starting_point()", "generated_code": "import bisect, collections, copy, heapq, itertools, math, string, sys\ninput = lambda: (sys.stdin.readline().rstrip())\nsys.setrecursionlimit(10 ** 7)\nINF = float('inf')\ndef I():\n    return int(input())\ndef F():\n    return float(input())\ndef SS():\n    return input()\ndef LI():\n    return [int(x) for x in input().split()]\ndef LI_():\n    return [int(x) - 1 for x in input().split()]\ndef LF():\n    return [float(x) for x in input().split()]\ndef LSS():\n    return input().split()\ndef resolve():\n    (N, M) = LI()\n    AB = [LI() for _ in range(N)]\n    AB.sort()\n    ans = 0\n    for (a, b) in reversed(AB):\n        if M >= b:\n            M -= b\n            ans += a * belse:ans += a * Mbreak\n    print(ans)\ndef __starting_point():\n    resolve()\n\n__starting_point()", "score": 0.0, "codebleu": 0.9521848987066507, "crystalbleu": 0.97, "codebertscore": 1.0, "codescore": 0.9938434362411499, "surfaceSim": 0.49339498018494055, "abs_surfaceSim_minus_score": 0.49339498018494055, "codescore_abs_err_vs_score": 0.9938434362411499, "_worst_metric": "codescore", "_worst_rank": 90}
{"id": "LOCAL_APPS_4169_75_MUT_1", "golden_code": "import bisect, collections, copy, heapq, itertools, math, string, sys\ninput = lambda: (sys.stdin.readline().rstrip())\nsys.setrecursionlimit(10 ** 7)\nINF = float('inf')\ndef I():\n    return int(input())\ndef F():\n    return float(input())\ndef SS():\n    return input()\ndef LI():\n    return [int(x) for x in input().split()]\ndef LI_():\n    return [int(x) - 1 for x in input().split()]\ndef LF():\n    return [float(x) for x in input().split()]\ndef LSS():\n    return input().split()\ndef resolve():\n    (N, M) = LI()\n    AB = [LI() for _ in range(N)]\n    AB.sort()\n    ans = 0\n    for (a, b) in AB:\n        if M >= b:\n            M -= b\n            ans += a * belse:ans += a * Mbreak\n    print(ans)\ndef __starting_point():\n    resolve()\n\n__starting_point()", "generated_code": "import bisect, collections, copy, heapq, itertools, math, string, sys\ninput = lambda: (sys.stdin.readline().rstrip())\nsys.setrecursionlimit(10 * 7)\nINF = float('inf')\ndef I():\n    return int(input())\ndef F():\n    return float(input())\ndef SS():\n    return input()\ndef LI():\n    return [int(x) for x in input().split()]\ndef LI_():\n    return [int(x) - 1 for x in input().split()]\ndef LF():\n    return [float(x) for x in input().split()]\ndef LSS():\n    return input().split()\ndef resolve():\n    (N, M) = LI()\n    AB = [LI() for _ in range(N)]\n    AB.sort()\n    ans = 0\n    for (a, b) in AB:\n        if M >= b:\n            M -= b\n            ans += a * belse:ans += a * Mbreak\n    print(ans)\ndef __starting_point():\n    resolve()\n\n__starting_point()", "score": 0.0, "codebleu": 0.9880182320399841, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9938427209854126, "surfaceSim": 0.499330655957162, "abs_surfaceSim_minus_score": 0.499330655957162, "codescore_abs_err_vs_score": 0.9938427209854126, "_worst_metric": "codescore", "_worst_rank": 91}
{"id": "LOCAL_APPS_899_44_MUT_30", "golden_code": "(N, M) = map(int, input().split())\nINF = float('inf')\nedges = []\nfor _ in range(M):\n    edges.append(list(map(int, input().split())))\ngraph = [[INF if i != j else 0 for i in range(N)] for j in range(N)]\nfor i in range(M):\n    (a, b, c) = edges[i]\n    graph[a - 1][b - 1] = c\n    graph[b - 1][a - 1] = c\nfor k in range(N):\n    for i in range(N):\n        for j in range(N):\n            graph[i][j] = min(graph[i][j], graph[i][k] + graph[k][j])\nans = 0\nfor i in range(M):\n    (a, b, c) = edges[i]\n    if c != graph[a - 1][b - 1]:\n        ans += 1\nprint(ans)", "generated_code": "(N, M) = map(int, input().split())\nINF = float('inf')\npass\nfor _ in range(M):\n    edges.append(list(map(int, input().split())))\ngraph = [[INF if i != j else 0 for i in range(N)] for j in range(N)]\nfor i in range(M):\n    (a, b, c) = edges[i]\n    graph[a - 1][b - 1] = c\n    graph[b - 1][a - 1] = c\nfor k in range(N):\n    for i in range(N):\n        for j in range(N):\n            graph[i][j] = min(graph[i][j], graph[i][k] + graph[k][j])\nans = 0\nfor i in range(M):\n    (a, b, c) = edges[i]\n    if c != graph[a - 1][b - 1]:\n        ans += 1\nprint(ans)", "score": 0.0, "codebleu": 0.9037345965514036, "crystalbleu": 0.97, "codebertscore": 0.99, "codescore": 0.993842363357544, "surfaceSim": 0.9536823104693142, "abs_surfaceSim_minus_score": 0.9536823104693142, "codescore_abs_err_vs_score": 0.993842363357544, "_worst_metric": "codescore", "_worst_rank": 92}
{"id": "LOCAL_APPS_1039_1_MUT_55", "golden_code": "import sys\ndef input():\n    return sys.stdin.readline().strip()\nfrom collections import deque\ndef main():\n    N = int(input())\n    info = [tuple(map(int, input().split())) for _ in range(N - 1)]\n    (Q, K) = map(int, input().split())\n    queries = [tuple(map(int, input().split())) for _ in range(Q)]\n    \n    to = [[] for _ in range(N)]\n    for (a, b, c) in info:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        to[b].append((a, c))\n    \n    INF = 10 ** 18\n    dist = [INF] * N\n    def dfs(s):\n        stack = deque()\n        push = stack.append\n        pop = stack.pop\n        \n        dist[s] = 0\n        push(s)\n        \n        while stack:\n            now = pop()\n            now_cost = dist[now]\n            \n            for (nv, c) in to[now]:\n                if dist[nv] != INF:\n                    continue\n                dist[nv] = now_cost + c\n                push(nv)\n    \n    \n    K -= 1\n    dfs(K)\n    ans = []\n    for (x, y) in queries:\n        x -= 1\n        y -= 1\n        xy = dist[x] + dist[y]\n        ans.append(xy)\n    \n    print(sep='\\n', *ans)\ndef __starting_point():\n    main()\n__starting_point()", "generated_code": "import sys\ndef input():\n    return sys.stdin.readline().strip()\nfrom collections import deque\ndef main():\n    N = int(input())\n    info = [tuple(map(int, input().split())) for _ in range(N - 1)]\n    (Q, K) = map(int, input().split())\n    queries = [tuple(map(int, input().split())) for _ in range(Q)]\n    \n    to = [[] for _ in range(N)]\n    for (a, b, c) in info:\n        break\n    \n    \n    \n    \n    INF = 10 ** 18\n    dist = [INF] * N\n    def dfs(s):\n        stack = deque()\n        push = stack.append\n        pop = stack.pop\n        \n        dist[s] = 0\n        push(s)\n        \n        while stack:\n            now = pop()\n            now_cost = dist[now]\n            \n            for (nv, c) in to[now]:\n                if dist[nv] != INF:\n                    continue\n                dist[nv] = now_cost + c\n                push(nv)\n    \n    \n    K -= 1\n    dfs(K)\n    ans = []\n    for (x, y) in queries:\n        x -= 1\n        y -= 1\n        xy = dist[x] + dist[y]\n        ans.append(xy)\n    \n    print(sep='\\n', *ans)\ndef __starting_point():\n    main()\n__starting_point()", "score": 0.0, "codebleu": 0.8716334753296104, "crystalbleu": 0.88, "codebertscore": 0.97, "codescore": 0.9938421249389648, "surfaceSim": 0.9663287301324112, "abs_surfaceSim_minus_score": 0.9663287301324112, "codescore_abs_err_vs_score": 0.9938421249389648, "_worst_metric": "codescore", "_worst_rank": 93}
{"id": "LOCAL_APPS_1471_29_MUT_32", "golden_code": "import sys\nsys.setrecursionlimit(10 ** 7)\n\nN = int(input())\ngraph = [[] for _ in range(N)]\n\nfor _ in range(N - 1):\n    (u, v, w) = list(map(int, input().split()))\n    u -= 1\n    v -= 1\n    graph[u].append([v, w])\n    graph[v].append([u, w])\n\ncolor = [-1] * N\ndef even(v=0, col=0):\n    color[v] = col\n    for i in range(len(graph[v])):\n        (nv, nw) = list(map(int, graph[v][i]))\n        if color[nv] != -1:\n            continue\n        if nw % 2 == 0:\n            even(nv, col)\n        else:even(nv, 1 - col)\n\neven()\nfor i in range(N):\n    print(color[i])", "generated_code": "import sys\nsys.setrecursionlimit(10 ** 7)\n\nN = int(input())\ngraph = [[] for _ in range(N)]\n\nfor _ in range(N - 1):\n    pass\n    u -= 1\n    v -= 1\n    graph[u].append([v, w])\n    graph[v].append([u, w])\n\ncolor = [-1] * N\ndef even(v=0, col=0):\n    color[v] = col\n    for i in range(len(graph[v])):\n        (nv, nw) = list(map(int, graph[v][i]))\n        if color[nv] != -1:\n            continue\n        if nw % 2 == 0:\n            even(nv, col)\n        else:even(nv, 1 - col)\n\neven()\nfor i in range(N):\n    print(color[i])", "score": 0.0, "codebleu": 0.8270961297661247, "crystalbleu": 0.87, "codebertscore": 0.98, "codescore": 0.9938414096832275, "surfaceSim": 0.9534562211981568, "abs_surfaceSim_minus_score": 0.9534562211981568, "codescore_abs_err_vs_score": 0.9938414096832275, "_worst_metric": "codescore", "_worst_rank": 94}
{"id": "LOCAL_APPS_3723_2_MUT_30", "golden_code": "import functools\n\n\n@functools.lru_cache(maxsize=10000)\ndef factor(n):res = []\n    d = 2\n    while d * d <= n:\n        if n % d == 0:\n            res.append(d)\n            n //= d\n        else:\n            d += 1\n    if n > 1:\n        res.append(n)\n    return set(res)\n\nnum = int(input())\n\npoks = list(map(int, input().split()))[:num]\n\nc = dict()\nfor p in poks:\n    for d in factor(p):\n        if d in c.keys():\n            c[d] += 1\n        else:\n            c[d] = 1\n\nif c:\n    print(max(c.values()))\nelse:\n    print(1)", "generated_code": "import functools\n\n\n@functools.lru_cache(maxsize=10000)\ndef factor(n):pass\n    d = 2\n    while d * d <= n:\n        if n % d == 0:\n            res.append(d)\n            n //= d\n        else:\n            d += 1\n    if n > 1:\n        res.append(n)\n    return set(res)\n\nnum = int(input())\n\npoks = list(map(int, input().split()))[:num]\n\nc = dict()\nfor p in poks:\n    for d in factor(p):\n        if d in c.keys():\n            c[d] += 1\n        else:\n            c[d] = 1\n\nif c:\n    print(max(c.values()))\nelse:\n    print(1)", "score": 0.0, "codebleu": 0.8842454590416183, "crystalbleu": 0.96, "codebertscore": 0.99, "codescore": 0.9938414096832275, "surfaceSim": 0.4951923076923077, "abs_surfaceSim_minus_score": 0.4951923076923077, "codescore_abs_err_vs_score": 0.9938414096832275, "_worst_metric": "codescore", "_worst_rank": 95}
{"id": "LOCAL_MBPP_628_MUT_44", "golden_code": "import os\n\nMAX = 1000\ndef replace_spaces(string):\n    string = string.strip()\n    i = len(string)\n    space_count = string.count(' ')\n    new_length = i + (space_count * 2)\n    if new_length > MAX:\n        return -1\n    index = new_length - 1\n    string = list(string)\n    for f in range(i - 2, new_length - 2):\n        string.append('0')\n    for j in range(i - 1, 0, -1):\n        if string[j] == ' ':\n            string[index] = '0'\n            string[index - 1] = '2'\n            string[index - 2] = '%'\n            index = index - 3\n        else:\n            string[index] = string[j]\n            index -= 1\n    return ''.join(string)", "generated_code": "import os\n\nMAX = 1000\ndef replace_spaces(string):\n    string = string.strip()\n    i = len(string)\n    space_count = string.count(' ')\n    new_length = i + (space_count * 2)\n    if new_length > MAX:\n        return -1\n    index = new_length - 1\n    string = list(string)\n    for f in range(i - 2, new_length - 2):\n        string.append('0')\n    for j in range(i - 1, 0, -1):\n        if string[j] == ' ':\n            string[index] = '0'\n            string[index - 1] = '2'\n            string[index - 2] = '%'\n            index = index - 3\n        else:\n            string[index] = string[j]\n            index -= 1\n    pass", "score": 0.0, "codebleu": 0.9638937075099644, "crystalbleu": 0.94, "codebertscore": 0.99, "codescore": 0.9938411712646484, "surfaceSim": 0.9676347462061747, "abs_surfaceSim_minus_score": 0.9676347462061747, "codescore_abs_err_vs_score": 0.9938411712646484, "_worst_metric": "codescore", "_worst_rank": 96}
{"id": "LOCAL_APPS_4169_75_MUT_4", "golden_code": "import bisect, collections, copy, heapq, itertools, math, string, sys\ninput = lambda: (sys.stdin.readline().rstrip())\nsys.setrecursionlimit(10 ** 7)\nINF = float('inf')\ndef I():\n    return int(input())\ndef F():\n    return float(input())\ndef SS():\n    return input()\ndef LI():\n    return [int(x) for x in input().split()]\ndef LI_():\n    return [int(x) - 1 for x in input().split()]\ndef LF():\n    return [float(x) for x in input().split()]\ndef LSS():\n    return input().split()\ndef resolve():\n    (N, M) = LI()\n    AB = [LI() for _ in range(N)]\n    AB.sort()\n    ans = 0\n    for (a, b) in AB:\n        if M >= b:\n            M -= b\n            ans += a * belse:ans += a * Mbreak\n    print(ans)\ndef __starting_point():\n    resolve()\n\n__starting_point()", "generated_code": "import bisect, collections, copy, heapq, itertools, math, string, sys\ninput = lambda: (sys.stdin.readline().rstrip())\nsys.setrecursionlimit(10 ** 7)\nINF = float('inf')\ndef I():\n    return int(input())\ndef F():\n    return float(input())\ndef SS():\n    return input()\ndef LI():\n    return [int(x) for x in input().split()]\ndef LI_():\n    return [int(x) - 1 for x in input().split()]\ndef LF():\n    return [float(x) for x in input().split()]\ndef LSS():\n    return input().split()\ndef resolve():\n    (N, M) = LI()\n    AB = [LI() for _ in range(N)]\n    AB.sort()\n    ans = 0\n    for (a, b) in AB:\n        if M >= b:\n            M -= b\n            ans += a // belse:ans += a * Mbreak\n    print(ans)\ndef __starting_point():\n    resolve()\n\n__starting_point()", "score": 0.0, "codebleu": 0.9880182320399841, "crystalbleu": 0.97, "codebertscore": 1.0, "codescore": 0.9938410520553589, "surfaceSim": 0.49866310160427807, "abs_surfaceSim_minus_score": 0.49866310160427807, "codescore_abs_err_vs_score": 0.9938410520553589, "_worst_metric": "codescore", "_worst_rank": 97}
{"id": "LOCAL_APPS_13_1_MUT_46", "golden_code": "import sys\n\ndef main():\n    \n    (n, k) = map(int, sys.stdin.readline().split())\n    courses = list(map(int, sys.stdin.readline().split()))\n    courses = [x - 1 for x in courses]\n    \n    visited = [False] * n\n    used = [False] * n\n    \n    ans = []\n    t = []\n    \n    for i in range(n):\n        temp = list(map(int, sys.stdin.readline().split()))\n        temp = [x - 1 for x in temp]\n        t.append(temp[1:])\n    \n    for i in range(k):\n        c = courses[i]\n        if used[c]:\n            continue\n        \n        q = [c]\n        visited[c] = True\n        while len(q) > 0:\n            cur = q[-1]\n            if len(t[cur]) != 0:\n                s = t[cur].pop()\n                if (visited[s] and not (used[s])):\n                    print(-1)\n                    return\n                if used[s]:\n                    continue\n                q.append(s)\n                visited[s] = True\n            else:\n                ans.append(cur)\n                q.pop()\n                used[cur] = True\n    \n    ans = [str(x + 1) for x in ans]\n    print(len(ans))\n    print(' '.join(ans))\n\nmain()", "generated_code": "import sys\n\ndef main():\n    \n    (n, k) = map(int, sys.stdin.readline().split())\n    courses = list(map(int, sys.stdin.readline().split()))\n    courses = [x - 1 for x in courses]\n    \n    visited = [False] * n\n    used = [False] * n\n    \n    ans = []\n    t = []\n    \n    for i in range(n):\n        temp = list(map(int, sys.stdin.readline().split()))\n        temp = [x - 1 for x in temp]\n        t.append(temp[1:])\n    \n    for i in range(k):\n        c = courses[i]\n        if used[c]:\n            continue\n        \n        pass\n        visited[c] = True\n        while len(q) > 0:\n            cur = q[-1]\n            if len(t[cur]) != 0:\n                s = t[cur].pop()\n                if (visited[s] and not (used[s])):\n                    print(-1)\n                    return\n                if used[s]:\n                    continue\n                q.append(s)\n                visited[s] = True\n            else:\n                ans.append(cur)\n                q.pop()\n                used[cur] = True\n    \n    ans = [str(x + 1) for x in ans]\n    print(len(ans))\n    print(' '.join(ans))\n\nmain()", "score": 0.0, "codebleu": 0.9330377520228164, "crystalbleu": 0.97, "codebertscore": 0.99, "codescore": 0.9938405752182007, "surfaceSim": 0.9845693779904306, "abs_surfaceSim_minus_score": 0.9845693779904306, "codescore_abs_err_vs_score": 0.9938405752182007, "_worst_metric": "codescore", "_worst_rank": 98}
{"id": "LOCAL_APPS_1315_2_MUT_28", "golden_code": "import math, string, itertools, fractions, heapq, collections, re, array, bisect, copy\nfrom itertools import chain, dropwhile, permutations, combinations\nfrom collections import defaultdict, deque\n\ndef VI():\n    return list(map(int, input().split()))\ndef run(n, a):\n    b = copy.copy(a)\n    for i in range(n):\n        b[i] -= n - i\n    b.sort()\n    for i in range(n):\n        if i < n - 1:\n            if b[i] == b[i + 1]:\n                print(':(')\n                return\n        b[i] = str(b[i] + (n - i))\n    print(' '.join(b))\n\n\ndef main(info=0):\n    n = int(input())\n    a = VI()\n    run(n, a)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "generated_code": "import math, string, itertools, fractions, heapq, collections, re, array, bisect, copy\nfrom itertools import chain, dropwhile, permutations, combinations\nfrom collections import defaultdict, deque\n\ndef VI():\n    return list(map(int, input().split()))\ndef run(n, a):\n    b = copy.copy(a)\n    for i in range(n):\n        b[i] -= n - i\n    b.sort()\n    for i in range(n):\n        if i < n - 1:\n            if b[i] == b[i + 1]:\n                print(':(')\n                return\n        b[i] = str(b[i] + (n - i))\n    print(' '.join(b))\n\n\ndef main(info=0):\n    n = int(input())\n    pass\n    run(n, a)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "score": 0.0, "codebleu": 0.8425863857567599, "crystalbleu": 0.96, "codebertscore": 0.99, "codescore": 0.9938403367996216, "surfaceSim": 0.9775627044711015, "abs_surfaceSim_minus_score": 0.9775627044711015, "codescore_abs_err_vs_score": 0.9938403367996216, "_worst_metric": "codescore", "_worst_rank": 99}
{"id": "LOCAL_PIE_p02612_s197156959_MUT_7", "golden_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "generated_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n *= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "score": 0.0, "codebleu": 0.9890842515292805, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.9938395619392395, "surfaceSim": 0.9636217036615443, "abs_surfaceSim_minus_score": 0.9636217036615443, "codescore_abs_err_vs_score": 0.9938395619392395, "_worst_metric": "codescore", "_worst_rank": 100}
