{"golden_code": "import fractions\n\nwhile True:\n\n\ttry:\n\n\t\tx,y = list(map(int,input().split()))\n\n\t\tprint('%d %d' % (fractions.gcd(x,y),x/fractions.gcd(x,y)*y))\n\n\texcept EOFError:\n\n\t\tbreak", "generated_code": "def gcd(x, y):\n\n    if y == 0:\n\n        return x\n\n    else:\n\n        return gcd(y, x%y)\n\n\n\n\n\ndef lcm(x,y):\n\n    return x/gcd(x, y)*y\n\n\n\n\n\nwhile True:\n\n    try:\n\n        x, y = list(map(int, input().split()))\n\n    except EOFError:\n\n        break\n\n\n\n    print(\"%d %d\" % (gcd(x, y), lcm(x, y)))", "score": 1.0, "codebleu": 0.2957030935285835, "crystalbleu": 0.0, "codebertscore": 0.87, "codescore": 0.9917746782302856, "surfaceSim": 0.5841924398625429, "abs_surfaceSim_minus_score": 0.4158075601374571}
{"golden_code": "import numpy as np\n\nn, k = list(map(int, input().split()))\n\np = np.array(list(map(int, input().split())))\n\np += 1\n\nsum_E = np.cumsum(p)\n\nsum_e = np.append([0], sum_E)\n\nans = -1\n\nfor i in range(n-k+1):\n\n    ans = max(ans, sum_e[i+k] - sum_e[i])\n\nprint((ans/2))", "generated_code": "n, k = list(map(int, input().split()))\n\np = list(map(int, input().split()))\n\n\n\ndef calc(x):\n\n    return (x + 1) / 2\n\n\n\n\n\nw = 0\n\n\n\nfor i in range(k):\n\n    w += calc(p[i])\n\n\n\nans = w\n\nfor i in range(k, n):\n\n    w += calc(p[i]) - calc(p[i - k])\n\n    ans = max(ans, w)\n\nprint(ans)", "score": 1.0, "codebleu": 0.32069355178686754, "crystalbleu": 0.363704997316923, "codebertscore": 0.84, "codescore": 0.22147737443447113, "surfaceSim": 0.6141304347826086, "abs_surfaceSim_minus_score": 0.38586956521739135}
{"golden_code": "mod = 10**9+7\n\nn, m = list(map(int, input().split()))\n\nl = [0]*n\n\nfor _ in range(m):\n\n  l[int(eval(input()))-1] = 1\n\n\n\ns = 0\n\nt = 1\n\n\n\nfor i in range(n):\n\n  if l[i] > 0:\n\n    t, s = 0, t\n\n  else:\n\n    t, s = (s+t)%mod, t\n\n\n\nprint(t)", "generated_code": "import sys\n\ninput = sys.stdin.readline\n\n\n\nmod = 10**9+7\n\nn, m = list(map(int, input().split()))\n\nl = [0]*n\n\nfor _ in range(m):\n\n  l[int(eval(input()))-1] = 1\n\n\n\nt, s = 1, 0\n\n\n\nfor i in range(n):\n\n  if l[i]:\n\n    t, s = 0, t\n\n  else:\n\n    t, s = (s+t)%mod, t\n\n\n\nprint(t)", "score": 1.0, "codebleu": 0.652760031884601, "crystalbleu": 0.7868501335451523, "codebertscore": 0.95, "codescore": 0.2893199026584625, "surfaceSim": 0.8382156133828996, "abs_surfaceSim_minus_score": 0.16178438661710037}
{"golden_code": "import sys\n\ninput = sys.stdin.readline\n\nimport bisect\n\n\n\nn = int(eval(input()))\n\nX = list(map(int, input().split()))\n\nl = int(eval(input()))\n\nU = 17\n\ndp = [[0]*n for _ in range(U+1)]\n\nfor i, x in enumerate(X):\n\n  t = bisect.bisect_left(X, x+l)\n\n  dp[0][i] = bisect.bisect_right(X, x+l) - 1\n\nfor k in range(U):\n\n  for i in range(n):\n\n    dp[k+1][i] = dp[k][dp[k][i]]\n\ndef test(x, a, b):\n\n  for i in range(U, -1, -1):\n\n    if x >> i & 1:\n\n      a = dp[i][a]\n\n  return a >= b\n\ndef solve(a, b):\n\n  if a > b:\n\n    a, b = b, a\n\n  ng = 0\n\n  ok = n-1\n\n  while ok - ng > 1:\n\n    mid = (ng + ok) // 2\n\n    if test(mid, a, b):\n\n      ok = mid\n\n    else:\n\n      ng = mid\n\n  print(ok)\n\nq = int(eval(input()))\n\nfor _ in range(q):\n\n  a, b = list(map(int, input().split()))\n\n  a -= 1\n\n  b -= 1\n\n  solve(a, b)", "generated_code": "import sys\n\ninput = sys.stdin.readline\n\nimport bisect\n\n\n\nn = int(eval(input()))\n\nX = list(map(int, input().split()))\n\nl = int(eval(input()))\n\nU = 17\n\ndp = [[0]*n for _ in range(U+1)]\n\nfor i, x in enumerate(X):\n\n  t = bisect.bisect_left(X, x+l)\n\n  dp[0][i] = bisect.bisect_right(X, x+l) - 1\n\nfor k in range(U):\n\n  for i in range(n):\n\n    dp[k+1][i] = dp[k][dp[k][i]]\n\nq = int(eval(input()))\n\nfor _ in range(q):\n\n  a, b = list(map(int, input().split()))\n\n  a -= 1\n\n  b -= 1\n\n  if a > b:\n\n    a, b = b, a\n\n  res = 1\n\n  for k in range(U, -1, -1):\n\n    if dp[k][a] < b:\n\n      a = dp[k][a]\n\n      res += (1<<k)\n\n    if a == b:\n\n      break\n\n  print(res)", "score": 1.0, "codebleu": 0.6735125094366047, "crystalbleu": 0.6764515858037599, "codebertscore": 0.93, "codescore": 0.32695427536964417, "surfaceSim": 0.7076250307957626, "abs_surfaceSim_minus_score": 0.29237496920423744}
{"golden_code": "n = int(eval(input()))\n\nimport math\n\nm = int(math.sqrt(n))+1\n\nanss = []\n\nfor x in range(1, m+1):\n\n  y = n//x\n\n  z = n%x\n\n  if z == 0:\n\n    anss.append(abs(x-1)+abs(y-1))\n\nprint((min(anss)))\n", "generated_code": "n = int(eval(input()))\n\ndef make_divisors(n):\n\n    divisors = []\n\n    for i in range(1, int(n**0.5)+1):\n\n        if n % i == 0:\n\n            divisors.append(i)\n\n            if i != n // i:\n\n                divisors.append(n//i)\n\n\n\n    #divisors.sort(reverse=True)\n\n    return divisors\n\n\n\nl = make_divisors(n)\n\nmin_ = float('inf')\n\nfor i in range(len(l)):\n\n    min_ = min(min_, l[i]-1+n//l[i]-1)\n\nprint(min_)\n", "score": 1.0, "codebleu": 0.27441939244193186, "crystalbleu": 0.17501093795230596, "codebertscore": 0.79, "codescore": 0.163695827126503, "surfaceSim": 0.6045469912102772, "abs_surfaceSim_minus_score": 0.3954530087897228}
{"golden_code": "import math\n\nmod = 10 ** 9 + 7\n\nn = int(eval(input()))\n\nprint((math.factorial(n) % mod))", "generated_code": "mod = 10 ** 9 + 7\n\nn = int(eval(input()))\n\nans = 1\n\nfor i in range(1, n + 1):\n\n    ans *= i\n\n    ans %= mod\n\nprint(ans)", "score": 1.0, "codebleu": 0.47574210334091366, "crystalbleu": 0.0, "codebertscore": 0.85, "codescore": 0.6651487946510315, "surfaceSim": 0.6148459383753502, "abs_surfaceSim_minus_score": 0.3851540616246498}
{"golden_code": "import numpy as np\n\nN=int(eval(input()))\n\nprint((2**int(np.log2(N))))", "generated_code": "import math\n\nN=int(eval(input()))\n\nprint((2**int(math.log2(N))))", "score": 1.0, "codebleu": 0.49332105343485505, "crystalbleu": 0.0, "codebertscore": 0.95, "codescore": 0.8258979916572571, "surfaceSim": 0.9202898550724637, "abs_surfaceSim_minus_score": 0.07971014492753625}
{"golden_code": "import numpy as np\n\n(n, m) = list(map(int, input().split()))\n\na = np.array(list(map(int, input().split()))).astype(\"int64\") \n\na = np.cumsum(a)\n\na %= m\n\ncount = np.sum(a == 0)\n\na.sort()\n\ntc = 1\n\nfor i in range(1, n):\n\n    if a[i - 1] == a[i]:\n\n        tc += 1\n\n    else:\n\n        count += tc * (tc - 1) // 2\n\n        tc = 1\n\nelse:\n\n    count += tc * (tc - 1) // 2\n\nprint(count)", "generated_code": "(n, m) = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\nunique_a = {a[0] % m: 1}\n\nfor i in range(1, n):\n\n    a[i] += a[i - 1]\n\n    a[i] %= m\n\n    if a[i] in unique_a:\n\n        unique_a[a[i]] += 1\n\n    else:\n\n        unique_a[a[i]] = 1\n\ncount = 0\n\nif 0 in unique_a:\n\n    count += unique_a[0]\n\nfor k in unique_a:\n\n    count += unique_a[k] * (unique_a[k] - 1) // 2\n\nprint(count)", "score": 1.0, "codebleu": 0.34886387594795276, "crystalbleu": 0.4334901284891127, "codebertscore": 0.86, "codescore": 0.11140979081392288, "surfaceSim": 0.6662013772566536, "abs_surfaceSim_minus_score": 0.3337986227433464}
{"golden_code": "k,s=list(map(int,input().split()))\n\nans=0\n\nfor i in range(k+1):\n\n    for j in range(k+1):\n\n        z=s-i-j\n\n        if 0<=z<=k:\n\n            ans+=1\n\nprint(ans)\n", "generated_code": "k,s=list(map(int,input().split()))\n\nans=0\n\nfor i in range(k+1):\n\n    for j in range(k+1):\n\n        if 0<=s-i-j<=k:\n\n            ans+=1\n\nprint(ans)\n", "score": 1.0, "codebleu": 0.767959063304084, "crystalbleu": 0.0, "codebertscore": 0.98, "codescore": 0.5260159373283386, "surfaceSim": 0.965625, "abs_surfaceSim_minus_score": 0.034375000000000044}
{"golden_code": "# -*- coding: utf-8 -*-\n\n# モジュールのインポート\n\nimport math\n\nimport numpy as np\n\n\n\n# 標準入力を取得\n\nN = int(eval(input()))\n\nA = list(map(int, input().split()))\n\n\n\n# 求解処理\n\nA = sorted(A, reverse=True)\n\nA = np.array(A)\n\nans = 2 * np.sum(A[:(N // 2)]) - A[0] + (N % 2) * A[math.floor(N / 2)]\n\n\n\n# 結果出力\n\nprint(ans)\n", "generated_code": "# -*- coding: utf-8 -*-\n\n# モジュールのインポート\n\nimport math\n\n\n\n# 標準入力を取得\n\nN = int(eval(input()))\n\nA = list(map(int, input().split()))\n\n\n\n# 求解処理\n\nA = sorted(A, reverse=True)\n\nans = 0\n\nfor n in range(1, N + 1):\n\n    if n == 1:\n\n        continue\n\n    ans += A[math.ceil(n / 2) - 1]\n\n\n\n# 結果出力\n\nprint(ans)\n", "score": 1.0, "codebleu": 0.5130529804393857, "crystalbleu": 0.2773238770712333, "codebertscore": 0.94, "codescore": 0.16735419631004333, "surfaceSim": 0.7014961389961389, "abs_surfaceSim_minus_score": 0.29850386100386106}
{"golden_code": "n=int(eval(input()))\n\nx=list(map(int,input().split()))\n\n\n\nx.sort()\n\n\n\nfor p in range(x[0],x[len(x)-1]+1):\n\n    psum=0\n\n    for i in range(len(x)):\n\n        psum=psum+(x[0]-x[i])**2\n\n#    print(psum)\n\n    pmin=psum    \n\n    for j in range(x[0]+1,x[len(x)-1]):\n\n        psum=0\n\n        for i in range(len(x)):\n\n            psum=psum+(j-x[i])**2\n\n#        print(psum)\n\n        if pmin>psum:\n\n            pmin=psum\n\nprint(pmin)    ", "generated_code": "n=int(eval(input()))\n\nx=list(map(int,input().split()))\n\n\n\nx.sort()\n\n\n\npsum=0\n\nfor i in range(len(x)):\n\n    psum=psum+(x[0]-x[i])**2\n\n#    print(psum)\n\npmin=psum    \n\nfor j in range(x[0]+1,x[len(x)-1]):\n\n    psum=0\n\n    for i in range(len(x)):\n\n        psum=psum+(j-x[i])**2\n\n#        print(psum)\n\n    if pmin>psum:\n\n        pmin=psum\n\nprint(pmin)            \n", "score": 1.0, "codebleu": 0.780767785263546, "crystalbleu": 0.8282159388426334, "codebertscore": 0.96, "codescore": 0.9938936829566956, "surfaceSim": 0.9613583138173303, "abs_surfaceSim_minus_score": 0.03864168618266972}
{"golden_code": "import sys\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\nreadlines = sys.stdin.readlines\n\n\n\nMOD = 10**9+7\n\n\n\nfac = [1, 1]     # 元テーブル\n\nf_inv = [1, 1]   # 逆元テーブル\n\ninv = [0, 1]     # 逆元テーブル計算用テーブル\n\ndef prepare(n, mod):\n\n    for i in range(2, n+1):\n\n        fac.append((fac[-1] * i) % mod)\n\n\n\n\n\ndef cmb(n, r, mod):\n\n    if n < 0 or r < 0:\n\n        return 0\n\n    if r > n:\n\n        return 0\n\n\n\n    return fac[n] * pow(fac[r],MOD-2,MOD) * pow(fac[n-r],MOD-2,MOD) % mod\n\n\n\n\n\ndef prime_factorization(n):\n\n    d = []\n\n    i, e = 2, 0  # factor, exponent\n\n    while i * i <= n:\n\n        while n % i == 0:\n\n            n //= i\n\n            e += 1\n\n        if e > 0:\n\n            d.append((i, e))\n\n        i += 1\n\n        e = 0\n\n    if n > 1:\n\n        d.append((n, 1))\n\n    return d\n\n\n\n\n\ndef main():\n\n    N,M = list(map(int, readline().split()))\n\n\n\n    prepare(N+100, MOD)\n\n    d = prime_factorization(M)\n\n\n\n    ans = 1\n\n    for i, e in d:\n\n        ans *= cmb(N-1+e, e, MOD)\n\n        ans %= MOD\n\n\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "generated_code": "# AC: msec(Python3)\n\nfrom math import factorial\n\nimport sys\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\nreadlines = sys.stdin.readlines\n\n\n\nMOD = 10**9+7\n\n\n\ndef cmb(n, r):\n\n    if n < 0 or r < 0:\n\n        return 0\n\n    if r > n:\n\n        return 0\n\n\n\n    r = min(n-r, r)\n\n    res = 1\n\n    for i in range(r):\n\n        res *= n - i\n\n\n\n    return res // factorial(r)\n\n\n\n\n\ndef prime_factorization(n):\n\n    d = []\n\n    i, e = 2, 0  # factor, exponent\n\n    while i * i <= n:\n\n        while n % i == 0:\n\n            n //= i\n\n            e += 1\n\n        if e > 0:\n\n            d.append((i, e))\n\n        i += 1\n\n        e = 0\n\n    if n > 1:\n\n        d.append((n, 1))\n\n    return d\n\n\n\n\n\ndef main():\n\n    N,M = list(map(int, readline().split()))\n\n\n\n    d = prime_factorization(M)\n\n\n\n    ans = 1\n\n    for i, e in d:\n\n        ans *= cmb(N-1+e, e)\n\n        ans %= MOD\n\n\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "score": 1.0, "codebleu": 0.5858488142192301, "crystalbleu": 0.6205755686981741, "codebertscore": 0.86, "codescore": 0.03477140888571739, "surfaceSim": 0.8375, "abs_surfaceSim_minus_score": 0.16249999999999998}
{"golden_code": "n = int(eval(input()))\n\nmx = n//3\n\nans = 0\n\nmod = 10**9+7\n\nimport math\n\ndef combinations_count(n, r): #組み合わせ(nCr)\n\n    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\n\nfor i in range(1,mx+1):\n\n    if i == 1:\n\n        ans += 1\n\n    else:\n\n        ans += combinations_count(n-2*i-1,i-1) % mod\n\nprint((ans%mod))", "generated_code": "s = int(eval(input()))\n\ndp = [0]*(2001)\n\ndp[3] = 1\n\nmod = 10**9+7\n\nfor i in range(4,s+1):\n\n    dp[i] = (dp[i-1] + dp[i-3]) % mod\n\nprint((dp[s]))", "score": 1.0, "codebleu": 0.16498058488401543, "crystalbleu": 0.23645995471937134, "codebertscore": 0.78, "codescore": 0.1079135611653328, "surfaceSim": 0.4759036144578313, "abs_surfaceSim_minus_score": 0.5240963855421688}
{"golden_code": "import numpy as np\n\n\n\nS=eval(input())\n\nS=np.array([1 if s=='B' else 0 for s in S])\n\n\n\nprint((np.abs(np.diff(S)).sum()))\n", "generated_code": "from itertools import groupby\n\n\n\nS=eval(input())\n\nanswer = sum([1 for _ in groupby(S)]) -1\n\n\n\nprint(answer)", "score": 1.0, "codebleu": 0.20308835009201417, "crystalbleu": 0.0, "codebertscore": 0.8, "codescore": 0.07813593000173569, "surfaceSim": 0.4853070175438597, "abs_surfaceSim_minus_score": 0.5146929824561404}
{"golden_code": "from collections import deque\n\nfrom itertools import product\n\nimport sys\n\nimport math\n\nimport numpy as np\n\nimport bisect\n\n\n\nsys.setrecursionlimit(200000)\n\ninput = sys.stdin.readline\n\n\n\n\n\ndef read():\n\n    N = int(input().strip())\n\n    A = list(map(int, input().strip().split()))\n\n    return N, A\n\n\n\n\n\ndef argsort(seq):\n\n    return sorted(list(range(len(seq))), key=seq.__getitem__)\n\n\n\ndef solve(N, A):\n\n    # x: i-A[i]の列\n\n    X = np.array([i-A[i] for i in range(N)], dtype=np.int)\n\n    # y: i+A[i]の列\n\n    Y = np.array([i+A[i] for i in range(N)], dtype=np.int)\n\n    keys = np.argsort(X)\n\n    X = X[keys]  # x[i] <= x[i+1]\n\n    Y = Y[keys]\n\n    ans = 0\n\n    for y in Y:\n\n        l = bisect.bisect_left(X, y)\n\n        r = bisect.bisect_left(X, y+1)\n\n        ans += r - l\n\n    return ans\n\n\n\n\n\nif __name__ == '__main__':\n\n    inputs = read()\n\n    outputs = solve(*inputs)\n\n    print((\"{}\".format(outputs)))\n", "generated_code": "from collections import defaultdict\n\nfrom itertools import product\n\nimport sys\n\nimport math\n\nimport bisect\n\n\n\nsys.setrecursionlimit(200000)\n\ninput = sys.stdin.readline\n\n\n\n\n\ndef read():\n\n    N = int(input().strip())\n\n    A = list(map(int, input().strip().split()))\n\n    return N, A\n\n\n\n\n\ndef solve(N, A):\n\n    # x: i-A[i]の列\n\n    X = [i-A[i] for i in range(N)]\n\n    # y: i+A[i]の列\n\n    Y = [i+A[i] for i in range(N)]\n\n    z = defaultdict(int)\n\n    for y in Y:\n\n        z[y] += 1\n\n    return sum([z[x] for x in X])\n\n\n\n\n\nif __name__ == '__main__':\n\n    inputs = read()\n\n    outputs = solve(*inputs)\n\n    print((\"{}\".format(outputs)))\n", "score": 1.0, "codebleu": 0.46881920532223054, "crystalbleu": 0.47774518270416466, "codebertscore": 0.89, "codescore": 0.01878857985138893, "surfaceSim": 0.8468010454333894, "abs_surfaceSim_minus_score": 0.1531989545666106}
{"golden_code": "class prime_factorize_by_osa_k():\n\n    def __init__(self, max_val):\n\n        '''\n\n        割ることが出来る最小の値を格納したリストを返す\n\n        :param max_val:\n\n        :return:\n\n        '''\n\n        self.minFactor = [-1] * (max_val + 1)\n\n        for i in range(2, max_val + 1):\n\n            if self.minFactor[i] == -1:\n\n                self.minFactor[i] = i\n\n                # エラトステネスの篩と同様の処理を行う\n\n                for j in range(i * i, max_val + 1, i):\n\n                    if self.minFactor[j] == -1:\n\n                        self.minFactor[j] = i\n\n\n\n    def osa_k(self, n):\n\n        '''\n\n        preprocessをしたあと、O(logN)で素因数分解を行う。nの最大値をn_maxとする。\n\n        :param n:\n\n        :return:\n\n        '''\n\n        from collections import defaultdict\n\n        d = defaultdict(int)\n\n        now = n\n\n        while now > 1:\n\n            d[self.minFactor[now]] += 1\n\n            now //= self.minFactor[now]\n\n        return d\n\ndef gcd(a, b):\n\n    while b: a, b = b, a % b\n\n    return a\n\n\n\nN = int(eval(input()))\n\nA = list(map(int, input().split()))\n\n# N = 10 ** 6\n\n# A = [10 ** 6] * N\n\nob = prime_factorize_by_osa_k(10 ** 6)\n\npairwise = False\n\nprime_key = set(ob.osa_k(A[-1]).keys())\n\nbreak_flag = False\n\nprime_flags = [False] * (10 ** 6 + 1)\n\nfor i in range(N):\n\n    for key in list(ob.osa_k(A[i]).keys()):\n\n        if prime_flags[key]:\n\n            break_flag = True\n\n            break\n\n        else:\n\n            prime_flags[key] = True\n\n    if break_flag:\n\n        break\n\nelse:\n\n    pairwise = True\n\nif pairwise:\n\n    print('pairwise coprime')\n\n    exit()\n\nwork = gcd(A[0], A[1])\n\nfor i in range(2, N):\n\n    work = gcd(work, A[i])\n\nif work != 1:\n\n    print('not coprime')\n\nelse:\n\n    print('setwise coprime')", "generated_code": "def gcd(a, b):\n\n    while b: a, b = b, a % b\n\n    return a\n\ndef isPrimeMR(n):\n\n    d = n - 1\n\n    d = d // (d & -d)\n\n    L = [2]\n\n    for a in L:\n\n        t = d\n\n        y = pow(a, t, n)\n\n        if y == 1: continue\n\n        while y != n - 1:\n\n            y = (y * y) % n\n\n            if y == 1 or t == n - 1: return 0\n\n            t <<= 1\n\n    return 1\n\ndef findFactorRho(n):\n\n    m = 1 << n.bit_length() // 8\n\n    for c in range(1, 99):\n\n        f = lambda x: (x * x + c) % n\n\n        y, r, q, g = 2, 1, 1, 1\n\n        while g == 1:\n\n            x = y\n\n            for i in range(r):\n\n                y = f(y)\n\n            k = 0\n\n            while k < r and g == 1:\n\n                ys = y\n\n                for i in range(min(m, r - k)):\n\n                    y = f(y)\n\n                    q = q * abs(x - y) % n\n\n                g = gcd(q, n)\n\n                k += m\n\n            r <<= 1\n\n        if g == n:\n\n            g = 1\n\n            while g == 1:\n\n                ys = f(ys)\n\n                g = gcd(abs(x - ys), n)\n\n        if g < n:\n\n            if isPrimeMR(g): return g\n\n            elif isPrimeMR(n // g): return n // g\n\n            return findFactorRho(g)\n\ndef primeFactor(n):\n\n    i = 2\n\n    ret = {}\n\n    rhoFlg = 0\n\n    while i*i <= n:\n\n        k = 0\n\n        while n % i == 0:\n\n            n //= i\n\n            k += 1\n\n        if k: ret[i] = k\n\n        i += 1 + i % 2\n\n        if i == 101 and n >= 2 ** 20:\n\n            while n > 1:\n\n                if isPrimeMR(n):\n\n                    ret[n], n = 1, 1\n\n                else:\n\n                    rhoFlg = 1\n\n                    j = findFactorRho(n)\n\n                    k = 0\n\n                    while n % j == 0:\n\n                        n //= j\n\n                        k += 1\n\n                    ret[j] = k\n\n\n\n    if n > 1: ret[n] = 1\n\n    if rhoFlg: ret = {x: ret[x] for x in sorted(ret)}\n\n    return ret\n\ndef gcd(a, b):\n\n    while b: a, b = b, a % b\n\n    return a\n\n\n\nN = int(eval(input()))\n\nA = list(map(int, input().split()))\n\n# N = 10 ** 6\n\n# A = [10 ** 6] * N\n\npairwise = False\n\nprime_key = set(primeFactor(A[-1]).keys())\n\nbreak_flag = False\n\nprime_flags = [False] * (10 ** 6 + 1)\n\nfor i in range(N):\n\n    for key in list(primeFactor(A[i]).keys()):\n\n        if prime_flags[key]:\n\n            break_flag = True\n\n            break\n\n        else:\n\n            prime_flags[key] = True\n\n    if break_flag:\n\n        break\n\nelse:\n\n    pairwise = True\n\nif pairwise:\n\n    print('pairwise coprime')\n\n    exit()\n\nwork = gcd(A[0], A[1])\n\nfor i in range(2, N):\n\n    work = gcd(work, A[i])\n\nif work != 1:\n\n    print('not coprime')\n\nelse:\n\n    print('setwise coprime')", "score": 1.0, "codebleu": 0.4678489629556529, "crystalbleu": 0.33354607939601016, "codebertscore": 0.79, "codescore": 0.9897708892822266, "surfaceSim": 0.69665907365224, "abs_surfaceSim_minus_score": 0.30334092634776}
{"golden_code": "import collections\n\nimport sys\n\na=eval(input())\n\nb=[]\n\n\n\nfor i in a:\n\n  b.append(i)\n\n  \n\nb.sort()\n\nc=collections.Counter(b)\n\nc=list(c.values())\n\n\n\nfor i in range(len(c)):\n\n  if int(c[i])%2==0:\n\n    q=0\n\n  else:\n\n    q=1\n\n    print('No')\n\n    sys.exit()\n\n    \n\nprint('Yes')\n", "generated_code": "w = list(eval(input()))\n\ns = set(w)\n\nfor i in s:\n\n  if w.count(i)%2 != 0:\n\n    print(\"No\")\n\n    break\n\nelse:\n\n  print(\"Yes\")\n\n  ", "score": 1.0, "codebleu": 0.1468778645718564, "crystalbleu": 0.0, "codebertscore": 0.8, "codescore": 0.7526033520698547, "surfaceSim": 0.5507825507825508, "abs_surfaceSim_minus_score": 0.4492174492174492}
{"golden_code": "from heapq import heappop, heappush\n\n\n\nn, m = list(map(int, input().split()))\n\na = tuple(map(int, input().split()))\n\n\n\nhq = []\n\nfor aa in a:\n\n    heappush(hq, (-aa, 1))\n\n\n\nfor _ in range(m):\n\n    b, c = list(map(int, input().split()))\n\n    heappush(hq, (-c, b))\n\n\n\nrest = n\n\nans = 0\n\nwhile rest > 0:\n\n    num, cnt = heappop(hq)\n\n\n\n    num *= (-1)\n\n    use = min(rest, cnt)\n\n    ans += use * num\n\n    rest -= use\n\n\n\nprint(ans)\n", "generated_code": "def main():\n\n    from collections import Counter\n\n    from operator import itemgetter\n\n\n\n    import sys\n\n    input = sys.stdin.readline\n\n\n\n    N, M = list(map(int, input().split()))\n\n    a = list(map(int, input().split()))\n\n\n\n    ctr = Counter(a)\n\n    for _ in range(M):\n\n        b, c = list(map(int, input().split()))\n\n        ctr[c] += b\n\n\n\n    ans = 0\n\n    rest = N\n\n    for integer, count in sorted(list(ctr.items()), key=itemgetter(0), reverse=True):\n\n        take = min(rest, count)\n\n        ans += take * integer\n\n        rest -= take\n\n        if not rest:\n\n            break\n\n\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n\n\n\n# import sys\n\n# input = sys.stdin.readline\n\n# \n\n# sys.setrecursionlimit(10 ** 7)\n\n# \n\n# (int(x)-1 for x in input().split())\n\n# rstrip()\n", "score": 1.0, "codebleu": 0.3669428314668479, "crystalbleu": 0.2081515250393228, "codebertscore": 0.78, "codescore": 0.02086961455643177, "surfaceSim": 0.6238370348139255, "abs_surfaceSim_minus_score": 0.3761629651860745}
{"golden_code": "import math\n\nn = int(eval(input()))\n\nprint((math.factorial(n)%(10**9+7)))\n", "generated_code": "n = int(eval(input()))\n\nmod = 10**9 + 7\n\n\n\npow = 1\n\nfor i in range(n):\n\n    pow = pow*(i+1)%mod\n\n\n\nprint(pow)\n", "score": 1.0, "codebleu": 0.2891986391150476, "crystalbleu": 0.0, "codebertscore": 0.82, "codescore": 0.22798877954483032, "surfaceSim": 0.5711229946524065, "abs_surfaceSim_minus_score": 0.42887700534759354}
{"golden_code": "from fractions import gcd\n\nn, m = list(map(int, input().split()))\n\na = [int(i) // 2 for i in input().split()]\n\nx = 1\n\nfor i in range(n):\n\n    x *= a[i] // gcd(x, a[i])\n\nfor i in a:\n\n    if x // i % 2 == 0:\n\n        print((0))\n\n        exit()\n\nprint(((m // x + 1) // 2))", "generated_code": "from math import gcd, ceil\n\nn, m = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\na = [i // 2 for i in a]\n\nl = 1\n\nfor i in a:\n\n    l *= i // gcd(l, i)\n\nfor i in a:\n\n    if l // i % 2 == 0:\n\n        print((0))\n\n        exit()\n\nprint((ceil((m // l) / 2)))", "score": 1.0, "codebleu": 0.5087864953528614, "crystalbleu": 0.5383805654439339, "codebertscore": 0.93, "codescore": 0.8990383744239807, "surfaceSim": 0.8081723027375202, "abs_surfaceSim_minus_score": 0.19182769726247983}
{"golden_code": "N, K = list(map(int, input().split()))\n\nS = eval(input())\n\nnums = []\n\nnow = 1\n\ncnt = 0\n\nfor i in range(N):\n\n    if S[i] == str(now):\n\n        cnt += 1\n\n    else:\n\n        nums.append(cnt)\n\n        now = 1 - now\n\n        cnt = 1\n\nif cnt != 0:\n\n    nums.append(cnt)\n\nif len(nums) % 2 == 0:\n\n    nums.append(0)\n\n\n\nadd = 2 * K + 1\n\nans = 0\n\nleft = 0\n\nright = 0\n\ntmp = 0\n\nfor i in range(0, len(nums), 2):\n\n\n\n    next_left = i\n\n    next_right = min(i + add, len(nums))\n\n\n\n    while next_left > left:\n\n        tmp -= nums[left]\n\n        left += 1\n\n\n\n    while next_right > right:\n\n        tmp += nums[right]\n\n        right += 1\n\n\n\n    ans = max(ans, tmp)\n\nprint(ans)", "generated_code": "N, K = list(map(int, input().split()))\n\nS = eval(input())\n\nnums = []\n\nnow = 1\n\ncnt = 0\n\nfor i in range(N):\n\n    if S[i] == str(now):\n\n        cnt += 1\n\n    else:\n\n        nums.append(cnt)\n\n        now = 1 - now\n\n        cnt = 1\n\nif cnt != 0:\n\n    nums.append(cnt)\n\nif len(nums) % 2 == 0:\n\n    nums.append(0)\n\n\n\ncsum = [0] * (len(nums) + 1)\n\nfor i in range(len(nums)):\n\n    csum[i + 1] = csum[i] + nums[i]\n\n\n\nadd = 2 * K + 1\n\nans = 0\n\ntmp = 0\n\nfor i in range(0, len(nums), 2):\n\n    left = i\n\n    right = min(i + add, len(nums))\n\n    tmp = csum[right] - csum[left]\n\n    ans = max(ans, tmp)\n\nprint(ans)", "score": 1.0, "codebleu": 0.7612905630082394, "crystalbleu": 0.7639714372116043, "codebertscore": 0.94, "codescore": 0.9353722333908081, "surfaceSim": 0.8500058363487802, "abs_surfaceSim_minus_score": 0.14999416365121976}
{"golden_code": "from copy import deepcopy\n\nfrom scipy.sparse.csgraph import floyd_warshall\n\n\n\nn,m=list(map(int,input().split()))\n\nl=[list(map(int,input().split())) for i in range(m)]\n\n\n\ncnt=0\n\nfor i in range(m):\n\n  ll=deepcopy(l)\n\n  del ll[i]\n\n\n\n  d=[[float('inf')]*n for i in range(n)]\n\n  for i in range(n):\n\n    d[i][i]=0\n\n\n\n  for a,b in ll:\n\n    a-=1\n\n    b-=1\n\n    d[a][b]=1\n\n    d[b][a]=1\n\n\n\n  s=floyd_warshall(d)\n\n  for i in s:\n\n    if float('inf') in i:\n\n      cnt+=1\n\n      break\n\n\n\nprint(cnt)", "generated_code": "from collections import deque\n\nfrom copy import deepcopy\n\n\n\nn,m=list(map(int,input().split()))\n\nl=[list(map(int,input().split())) for i in range(m)]\n\n\n\ndef BFS(m):\n\n  t_l=deepcopy(l)\n\n  del t_l[m]\n\n\n\n  tree=[[] for j in range(n)]\n\n  for a,b in t_l:\n\n    a-=1\n\n    b-=1\n\n    tree[a].append(b)\n\n    tree[b].append(a)\n\n\n\n  dist=[-1 for i in range(n)]\n\n  dist[0]=0\n\n\n\n  que=deque()\n\n  que.append(0)\n\n\n\n  while que:\n\n    x=que.popleft()\n\n    for i in tree[x]:\n\n      if dist[i]==-1:\n\n        que.append(i)\n\n        dist[i]=dist[x]+1\n\n\n\n  return dist\n\n\n\nans=0\n\nfor i in range(m):\n\n  d=BFS(i)\n\n  if -1 in d:\n\n    ans+=1\n\n\n\nprint(ans)", "score": 1.0, "codebleu": 0.4377479022946076, "crystalbleu": 0.3126589101386773, "codebertscore": 0.84, "codescore": 0.9712216854095459, "surfaceSim": 0.637229082117261, "abs_surfaceSim_minus_score": 0.36277091788273896}
{"golden_code": "import sys\n\nimport numpy as np\n\n\n\nsys.setrecursionlimit(10 ** 6)\n\nint1 = lambda x: int(x) - 1\n\nprintV = lambda x: print(*x, sep=\"\\n\")\n\nprintH = lambda x: print(\" \".join(map(str,x)))\n\ndef IS(): return sys.stdin.readline()[:-1]\n\ndef II(): return int(sys.stdin.readline())\n\ndef MI(): return map(int, sys.stdin.readline().split())\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\n\ndef LI1(): return list(map(int1, sys.stdin.readline().split()))\n\ndef LII(rows_number): return [II() for _ in range(rows_number)]\n\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\n\ndef LLI1(rows_number): return [LI1() for _ in range(rows_number)]\n\n\n\ndef main():\n\n\tK,N = MI()\n\n\tA = np.array(LI())\n\n\tA_LAST = K+A[0] - A[N-1]\n\n\tB = A[1:]-A[:N-1]\n\n\tB = np.sort(B)\n\n\tprint(K-max(B[N-2],A_LAST))\n\n\n\nif __name__ == '__main__':\n\n\tmain()\n", "generated_code": "import sys\n\n\n\nsys.setrecursionlimit(10 ** 6)\n\nint1 = lambda x: int(x) - 1\n\nprintV = lambda x: print(*x, sep=\"\\n\")\n\nprintH = lambda x: print(\" \".join(map(str,x)))\n\ndef IS(): return sys.stdin.readline()[:-1]\n\ndef II(): return int(sys.stdin.readline())\n\ndef MI(): return map(int, sys.stdin.readline().split())\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\n\ndef LI1(): return list(map(int1, sys.stdin.readline().split()))\n\ndef LII(rows_number): return [II() for _ in range(rows_number)]\n\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\n\ndef LLI1(rows_number): return [LI1() for _ in range(rows_number)]\n\n\n\ndef main():\n\n\tk,n = MI()\n\n\ta = LI()\n\n\tb = [0]*n\n\n\tfor i in range(n):\n\n\t\tif i == n-1:\n\n\t\t\tb[i] = a[0]+k-a[i]\n\n\t\telse:\n\n\t\t\tb[i] = a[i+1]-a[i]\n\n\tb.sort()\n\n\tprint(k-b[-1])\n\n\n\n\n\nif __name__ == '__main__':\n\n\tmain()\n", "score": 1.0, "codebleu": 0.7198086174363693, "crystalbleu": 0.6886182950167731, "codebertscore": 0.95, "codescore": 0.02985924296081066, "surfaceSim": 0.8984992101105844, "abs_surfaceSim_minus_score": 0.10150078988941558}
{"golden_code": "k = int(eval(input()))\n\ncount = 1\n\nn = 0\n\nif k % 2 == 0 or k % 5 == 0:\n\n    print((-1))\n\nelse:\n\n  while 1:\n\n      n = (n * 10 + 7) % k  \n\n      if n == 0:\n\n        break \n\n      count += 1\n\n  print(count)", "generated_code": "def main(h):\n\n  count = 1\n\n  n = 0\n\n  for i in range (k):\n\n    n = (n * 10 + 7) % k  \n\n    if n == 0: \n\n      print(count)\n\n      return 0\n\n    count += 1\n\n  print((-1))\n\n  \n\nif __name__ == '__main__':\n\n  k = int(eval(input()))\n\n  main(k)", "score": 1.0, "codebleu": 0.47065797982054347, "crystalbleu": 0.0, "codebertscore": 0.87, "codescore": 0.048590175807476044, "surfaceSim": 0.604341736694678, "abs_surfaceSim_minus_score": 0.39565826330532206}
{"golden_code": "from functools import reduce\ndef f(a,b): return [Card[a][0], Card[b][1]]\n\nn = int(input())\n\nCard = [[] for _ in [0]*n]\n\nCost = {}\n\nfor i in range(n):\n\n  Card[i] = list(map(int, input().split()))\n\n  Cost[(i, i)] = 0\n\nfor i in range(1, n):\n\n  for j in range(0, n-i):\n\n    a = j+i\n\n    Cost[(j, a)] = min([reduce(lambda a,b: a*b, f(j, k) + f(k+1, a)) + Cost[(j, k)] + Cost[(k+1, a)] for k in range(j, j+i)])\n\nprint(Cost[0, n-1])", "generated_code": "from functools import reduce\nn = int(input())\n\nCard = [[] for _ in [0]*n]\n\nCost = {}\n\nfor i in range(n):\n\n  Card[i] = list(map(int, input().split()))\n\n  Cost[(i, i)] = 0\n\nfor i in range(1, n):\n\n  for j in range(0, n-i):\n\n    a = j+i\n\n    Cost[(j, a)] = min([reduce(lambda a,b: a*b, [Card[j][0],Card[k][1],Card[k+1][0],Card[a][1]]) + Cost[(j, k)] + Cost[(k+1, a)] for k in range(j, j+i)])\n\nprint(Cost[0, n-1])", "score": 1.0, "codebleu": 0.6863679688130228, "crystalbleu": 0.8694261007044977, "codebertscore": 0.96, "codescore": 0.5770623683929443, "surfaceSim": 0.8713445378151261, "abs_surfaceSim_minus_score": 0.1286554621848739}
{"golden_code": "from collections import Counter,defaultdict,deque\n\nimport sys,bisect,math,itertools,string,queue\n\nfrom heapq import heappop, heappush\n\nsys.setrecursionlimit(10**8)\n\nmod = 10**9+7\n\ndef inp(): return int(sys.stdin.readline())\n\ndef inpl(): return list(map(int, sys.stdin.readline().split()))\n\ndef inpl_str(): return list(sys.stdin.readline().split())\n\ndef inpln(n): return list(int(sys.stdin.readline()) for i in range(n))\n\n\n\nn = inp()\n\nres = float('inf')\n\nfor i in range(1,2*10**6):\n\n    if (n/i).is_integer():\n\n        res = min(res, i + n/i)\n\nprint((int(res-2)))\n", "generated_code": "from collections import Counter,defaultdict,deque\n\nimport sys,bisect,math,itertools,string,queue\n\nfrom heapq import heappop, heappush\n\nsys.setrecursionlimit(10**8)\n\nmod = 10**9+7\n\ndef inp(): return int(sys.stdin.readline())\n\ndef inpl(): return list(map(int, sys.stdin.readline().split()))\n\ndef inpl_str(): return list(sys.stdin.readline().split())\n\ndef inpln(n): return list(int(sys.stdin.readline()) for i in range(n))\n\n\n\nn = inp()\n\nres = float('inf')\n\nfor i in range(1,int(math.sqrt(n))+1):\n\n    if n%i == 0:\n\n        res = min(res, i + n/i)\n\nprint((int(res-2)))\n", "score": 1.0, "codebleu": 0.8316966909881458, "crystalbleu": 0.8724485591152905, "codebertscore": 0.98, "codescore": 0.7161932587623596, "surfaceSim": 0.9062557216966738, "abs_surfaceSim_minus_score": 0.09374427830332621}
{"golden_code": "from fractions import gcd\n\n\n\nn,m=list(map(int,input().split()))\n\na=list(map(int,input().split()))\n\na=list(set(a))\n\n\n\na=list([x//2 for x in a])\n\n\n\ndef lcm(q):\n\n  x = q[0]\n\n  for i in range(1, len(q)):\n\n    x = (x * q[i]) // gcd(x, q[i])\n\n  return x\n\n\n\nlcma=lcm(a)\n\n\n\nif (lcma//a[0])%2==0:\n\n  print((0))\n\nelse:\n\n  flg=0\n\n  for i in range(1,len(a)):\n\n    if (lcma//a[i])%2==0:\n\n      print((0))\n\n      flg=1\n\n      break\n\n  if flg==0:\n\n    temp=m//lcma\n\n    print((temp//2 if temp%2==0 else temp//2+1))", "generated_code": "from math import gcd\n\nn,m=list(map(int,input().split()))\n\na=list(map(int,input().split()))\n\na=list(set(a))\n\na=list([x//2 for x in a])\n\n\n\ndef lcm(q):\n\n  x = q[0]\n\n  for i in range(1, len(q)):\n\n    x = (x * q[i]) // gcd(x, q[i])\n\n  return x\n\n\n\nlcma=lcm(a)\n\nfor i in range(len(a)):\n\n  if (lcma//a[i])%2==0:\n\n    print((0))\n\n    exit()\n\ntemp=m//lcma\n\nprint((temp//2 if temp%2==0 else temp//2+1))", "score": 1.0, "codebleu": 0.7667790229313646, "crystalbleu": 0.77239021698609, "codebertscore": 0.96, "codescore": 0.9583464860916138, "surfaceSim": 0.9117266791647811, "abs_surfaceSim_minus_score": 0.08827332083521888}
{"golden_code": "import itertools\n\nfrom collections import Counter\n\nN = int(eval(input()))\n\nsrc = [eval(input()) for i in range(N)]\n\nctr = Counter()\n\nfor s in src:\n\n    ctr[s[0]] += 1\n\n\n\nans = 0\n\nfor ptn in itertools.combinations('MARCH',3):\n\n    a,b,c = ptn\n\n    ans += ctr[a]*ctr[b]*ctr[c]\n\nprint(ans)", "generated_code": "N = int(eval(input()))\n\nS = [eval(input()) for i in range(N)]\n\nfrom collections import Counter\n\nctr = Counter([s[0] for s in S])\n\n\n\nans = 0\n\nimport itertools\n\nfor ptn in itertools.combinations('MARCH', 3):\n\n    t = 1\n\n    for c in ptn:\n\n        t *= ctr[c]\n\n    ans += t\n\nprint(ans)", "score": 1.0, "codebleu": 0.4104047494648608, "crystalbleu": 0.46036999033114373, "codebertscore": 0.93, "codescore": 0.6181343793869019, "surfaceSim": 0.7220279720279721, "abs_surfaceSim_minus_score": 0.2779720279720279}
{"golden_code": "import sys\n\ninput = sys.stdin.readline\n\nsys.setrecursionlimit(10 ** 7)\n\n\n\n\"\"\"\n\n奇数番目集合、偶数番目集合の中で自由にできるのが操作2．\n\n操作1で集合間のやりとりをする\n\n\"\"\"\n\n\n\nimport numpy as np\n\n\n\nN = int(eval(input()))\n\nA = np.fromstring(sys.stdin.read(),dtype=np.int64,sep='\\n')\n\n\n\nB = np.sort(A)\n\n\n\nanswer = len(np.setdiff1d(A[::2],B[::2]))\n\nprint(answer)", "generated_code": "import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\n\"\"\"\n\n・偶数番号、奇数番号の中では入れ替え放題\n\n・偶、奇の間：並べてからスワップ。操作2を1回で、正しいものを2つ増やせる\n\n\"\"\"\n\n\n\nN,*A = list(map(int,read().split()))\n\n\n\nx_to_i = {x:i for i,x in enumerate(sorted(A))}\n\nrank = [x_to_i[x] for x in A]\n\n\n\nanswer = sum((x^i) & 1 for i,x in enumerate(rank)) // 2\n\nprint(answer)", "score": 1.0, "codebleu": 0.23074092695025478, "crystalbleu": 0.052989305111456796, "codebertscore": 0.79, "codescore": 0.23241733014583588, "surfaceSim": 0.4430051813471503, "abs_surfaceSim_minus_score": 0.5569948186528497}
{"golden_code": "N , L = list(map(int , input().split()))\n\n\n\napple_taste = []\n\n\n\nfor i in range(N):\n\n    taste = L + i + 1 - 1\n\n    apple_taste.append(taste)\n\n    \n\nimport numpy as np\n\n\n\nabs_apple_taste = np.abs(apple_taste)\n\nm = min(abs_apple_taste)\n\n\n\nfor j in range(N):\n\n    if m == abs_apple_taste[j]:\n\n        apple_taste.remove(apple_taste[j])\n\n\n\npie_taste = 0       \n\n\n\nfor k in range(N-1):\n\n    pie_taste += apple_taste[k]\n\n    \n\nprint(pie_taste)", "generated_code": "n,l = list(map(int,input().split()))\n\nans = l\n\neat = l\n\n\n\nfor i in range(n-1):\n\n    l += 1\n\n    ans += l\n\n    \n\n    if abs(l) < abs(eat):\n\n        eat = l\n\n        \n\nprint((ans-eat))", "score": 1.0, "codebleu": 0.17652833887839986, "crystalbleu": 0.0, "codebertscore": 0.79, "codescore": 0.9905984997749329, "surfaceSim": 0.580711289092296, "abs_surfaceSim_minus_score": 0.41928871090770403}
{"golden_code": "import numpy as np\n\nN, K = list(map(int, input().split()))\n\n \n\nA = np.zeros(N, dtype=int)\n\n \n\nfor _ in range(K):\n\n    eval(input())\n\n    for i in input().split():\n\n        A[int(i) - 1] += 1\n\n \n\nans = 0\n\nfor i in A:\n\n    if i == 0:\n\n        ans += 1\n\nprint(ans)\n\n ", "generated_code": "N, K = list(map(int, input().split()))\n\n\n\nA = [0] * N\n\n\n\nfor _ in range(K):\n\n    eval(input())\n\n    for i in map(int, input().split()):\n\n        A[i - 1] += 1\n\n\n\nprint((A.count(0)))\n", "score": 1.0, "codebleu": 0.36561796827243753, "crystalbleu": 0.4816140871063354, "codebertscore": 0.89, "codescore": 0.34853076934814453, "surfaceSim": 0.6828030303030304, "abs_surfaceSim_minus_score": 0.31719696969696964}
{"golden_code": "import numpy as np\n\nN, K= list(map(int, input().split()))\n\nA=[int(i) for i in input().split()]\n\nF=[int(i) for i in input().split()]\n\n\n\nA=np.array(sorted(A, reverse=True))\n\nF=np.array(sorted(F))\n\n\n\nlower_bound=0\n\nupper_bound=np.max(A*F)\n\nK_tmp=0\n\n\n\nwhile upper_bound>=lower_bound:\n\n    mid=(lower_bound+upper_bound)//2\n\n    K_tmp=np.sum(np.maximum(A-mid//F, 0))\n\n    if K_tmp<=K:\n\n        upper_bound=mid-1\n\n    else:\n\n        lower_bound=mid+1\n\n\n\nprint(lower_bound)", "generated_code": "n,k=list(map(int,input().split()))\n\n*a,= list(map(int,input().split()))\n\n*f,= list(map(int,input().split()))\n\na=sorted(a)\n\nf=sorted(f, reverse=True)\n\n\n\ndef is_ok(arg):\n\n    cnt=0\n\n    for i in range(n):\n\n        cnt+=max(a[i]-arg//f[i], 0)\n\n    return cnt<=k\n\n\n\ndef meguru_bisect(ng, ok):\n\n    while (abs(ok - ng) > 1):\n\n        mid = (ok + ng) // 2\n\n        if is_ok(mid):\n\n            ok = mid\n\n        else:\n\n            ng = mid\n\n    return ok\n\n\n\nprint((meguru_bisect(-1, 10**12)))", "score": 1.0, "codebleu": 0.24619909504990498, "crystalbleu": 0.16312147758461068, "codebertscore": 0.79, "codescore": 0.9041702151298523, "surfaceSim": 0.4778350515463918, "abs_surfaceSim_minus_score": 0.5221649484536082}
{"golden_code": "N = int(eval(input()))\n\nans = N - 1\n\np = 1\n\nfor i in range(2, int((N ** 0.5) + 1)):\n\n    if p % 2 == 1 and i > (N ** 0.5):\n\n        break\n\n    if N % i == 0:\n\n        p = i\n\n        j = N // i\n\n        m = i + j - 2\n\n        if m < ans:\n\n            ans = m\n\n        else:\n\n            continue\n\n    else:\n\n        continue\n\nprint(ans)\n", "generated_code": "N = int(eval(input()))\n\nans = N - 1\n\nfor i in range(2, int((N ** 0.5) + 1)):\n\n    if N % i == 0:\n\n        j = N // i\n\n        m = i + j - 2\n\n        ans = min(ans, m)\n\nprint(ans)\n", "score": 1.0, "codebleu": 0.49689460694412724, "crystalbleu": 0.0, "codebertscore": 0.92, "codescore": 0.3801196217536926, "surfaceSim": 0.7663690476190477, "abs_surfaceSim_minus_score": 0.23363095238095233}
{"golden_code": "import numpy as np\n\nN=int(eval(input()))\n\nroot=int(np.sqrt(N)//1)\n\na=N\n\nb=N\n\nfor i in range(root, 0, -1):\n\n    if N%i==0:\n\n        a=i\n\n        b=N//i\n\n        break\n\nprint((a-1+b-1))", "generated_code": "N=int(eval(input()))\n\nroot=int((N**0.5)//1)\n\na=N\n\nb=N\n\nfor i in range(root, 0, -1):\n\n    if N%i==0:\n\n        a=i\n\n        b=N//i\n\n        break\n\nprint((a-1+b-1))\n", "score": 1.0, "codebleu": 0.5931574140209582, "crystalbleu": 0.0, "codebertscore": 0.94, "codescore": 0.882851243019104, "surfaceSim": 0.8483606557377049, "abs_surfaceSim_minus_score": 0.15163934426229508}
{"golden_code": "a, b, c = list(map(int, input().split()))\n\nif (b - a) == (c - b):\n\n    print(\"YES\")\n\nelse:\n\n    print(\"NO\")", "generated_code": "a, b, c = list(map(int, input().split()))\n\nif b - a == c - b:\n\n    print(\"YES\")\n\nelse:\n\n    print(\"NO\")", "score": 1.0, "codebleu": 0.6885766355647422, "crystalbleu": 0.0, "codebertscore": 0.99, "codescore": 0.9927796721458435, "surfaceSim": 0.9813084112149533, "abs_surfaceSim_minus_score": 0.01869158878504673}
{"golden_code": "n,*x=list(map(int,open(0).read().split()))\n\n\n\nimport numpy as np\n\n\n\nxar=np.array(x)\n\n\n\nans=float(\"inf\")\n\nfor p in range(0,101):\n\n    tmp=sum((xar-p)**2)\n\n    ans=min(ans,tmp)\n\n    \n\nprint((int(ans)))", "generated_code": "n,*x=list(map(int,open(0).read().split()))\n\nans=float(\"inf\")\n\nfor p in range(0,101):\n\n  s=0\n\n  for xi in x:\n\n    s+=(xi-p)**2\n\n  ans=min(ans,s)\n\nprint((int(ans)))\n", "score": 1.0, "codebleu": 0.4743992956812364, "crystalbleu": 0.0, "codebertscore": 0.91, "codescore": 0.95076584815979, "surfaceSim": 0.7565458873313938, "abs_surfaceSim_minus_score": 0.24345411266860617}
{"golden_code": "import numpy as np\n\n\n\nN = int(eval(input()))\n\nX = np.array(list(map(int, input().split())))\n\ncost = float(\"inf\")\n\nfor i in range(max(X) - min(X) + 1):\n\n    p = min(X) + i\n\n    cost = min(np.sum((X - p) ** 2), cost)\n\nprint(cost)", "generated_code": "N = int(eval(input()))\n\nX = sorted(list(map(int, input().split())))\n\nif N == 1:\n\n    print((0))\n\nelse:\n\n    r = X[-1] - X[0]\n\n    ans = float(\"inf\")\n\n    for i in range(r + 1):\n\n        R = X[0] + i\n\n        hp = 0\n\n        for j in range(N):\n\n            hp = hp + (R - X[j]) ** 2\n\n\n\n        ans = min(hp, ans)\n\n\n\n    print(ans)\n", "score": 1.0, "codebleu": 0.3331085705108326, "crystalbleu": 0.3107739498454203, "codebertscore": 0.83, "codescore": 0.06743448227643967, "surfaceSim": 0.6164690382081687, "abs_surfaceSim_minus_score": 0.3835309617918313}
{"golden_code": "import numpy as np\n\n\n\nn=int(eval(input()))\n\na_list=list(map(int,input().split()))\n\na_list_2=sorted(a_list,reverse=True)\n\na=np.array(a_list_2,dtype='uint8')\n\n\n\nalice=0\n\nbob=0\n\nfor i in range(n):\n\n\tif i%2==0:\n\n\t\talice+=a[i]\n\n\telse:\n\n\t\tbob+=a[i]\n\n\n\nprint((alice-bob))\n", "generated_code": "n=int(eval(input()))\n\na=list(map(int,input().split()))\n\na.sort(reverse=True)\n\n\n\nalice=0\n\nbob=0\n\n\n\nfor i in range(n):\n\n    if i%2==0:\n\n        alice+=a[i]\n\n    else:\n\n        bob+=a[i]\n\n        \n\nprint((alice-bob))", "score": 1.0, "codebleu": 0.5282923517427665, "crystalbleu": 0.6814678389353974, "codebertscore": 0.92, "codescore": 0.6407596468925476, "surfaceSim": 0.818785890073831, "abs_surfaceSim_minus_score": 0.18121410992616904}
{"golden_code": "#! /usr/bin/env python3\n\n\n\nimport sys\n\nint1 = lambda x: int(x) - 1\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\nsys.setrecursionlimit(500000)\n\n\n\n\n\ndef isMultiple(s, m):\n\n    tmp = 0\n\n    for i in range(len(s)):\n\n        tmp = (tmp * 10 + int(s[i])) % m\n\n        if tmp == 0:\n\n            return i\n\n    return -1\n\n\n\n\n\nk = int(readline())\n\nacc = \"7\" * 50000000\n\nif k % 2 == 0:\n\n    ans = -1\n\nelse:\n\n\n\n    ans = isMultiple(acc, k)\n\n    if ans != -1:\n\n        ans += 1\n\n\n\nprint(ans)\n", "generated_code": "#! /usr/bin/env python3\n\n\n\nimport sys\n\nint1 = lambda x: int(x) - 1\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\nsys.setrecursionlimit(500000)\n\n\n\nk = int(readline())\n\n\n\nans = -1\n\nacc = 7 % k\n\nfor n in range(1, k + 10):\n\n    if acc == 0:\n\n        ans = n\n\n        break\n\n    acc = (10 * acc + 7) % k\n\n\n\nprint(ans)\n", "score": 1.0, "codebleu": 0.44668800795647723, "crystalbleu": 0.36251708798701154, "codebertscore": 0.91, "codescore": 0.5281686782836914, "surfaceSim": 0.750661832412523, "abs_surfaceSim_minus_score": 0.24933816758747696}
{"golden_code": "import numpy as np\n\nS=eval(input())\n\nN=len(S)\n\nmod=[0 for i in range(2019)]\n\nmod2=0\n\nten=1\n\nfor i in range(N-1,-1,-1): \n\n  s=int(S[i])*ten\n\n  mod2+=np.mod(s,2019)\n\n  mod2=np.mod(mod2,2019)\n\n  mod[mod2]+=1\n\n  ten=(ten*10)%2019\n\nans=0\n\nfor i in range(2019):\n\n  k=mod[i]\n\n  if i==0:\n\n    if k>=2:\n\n      ans+=k*(k-1)//2+k\n\n    else:\n\n      ans+=k\n\n  else:\n\n    if k>=2:\n\n      ans+=k*(k-1)//2\n\nprint(ans) ", "generated_code": "S=eval(input())\n\nN=len(S)\n\nmod=[0 for i in range(2019)]\n\ns=0\n\nten=1\n\nfor i in range(N-1,-1,-1): \n\n  s+=int(S[i])*ten\n\n  mod2=s%2019\n\n  mod[mod2]+=1\n\n  ten=(ten*10)%2019\n\nans=0\n\nfor i in range(2019):\n\n  k=mod[i]\n\n  if i==0:\n\n    if k>=2:\n\n      ans+=k*(k-1)//2+k\n\n    else:\n\n      ans+=k\n\n  else:\n\n    if k>=2:\n\n      ans+=k*(k-1)//2\n\nprint(ans) ", "score": 1.0, "codebleu": 0.5861168552361398, "crystalbleu": 0.8123715442595341, "codebertscore": 0.96, "codescore": 0.9542234539985657, "surfaceSim": 0.8811116829644879, "abs_surfaceSim_minus_score": 0.11888831703551206}
{"golden_code": "N, D = list(map(int, input().split()))\n\ncnt = 0\n\nfor _ in range(N):\n\n    x, y = list(map(int, input().split()))\n\n    if x ** 2 + y ** 2 <= D ** 2:\n\n        cnt += 1\n\n        \n\nprint(cnt)", "generated_code": "N, D = list(map(int, input().split()))\n\ncnt = 0\n\nfor _ in range(N):\n\n    x, y = list(map(int, input().split()))\n\n    if x * x + y * y <= D * D:\n\n        cnt += 1\n\n        \n\nprint(cnt)", "score": 1.0, "codebleu": 0.7862404220058002, "crystalbleu": 0.8164474750850377, "codebertscore": 0.96, "codescore": 0.7887548208236694, "surfaceSim": 0.9312393887945671, "abs_surfaceSim_minus_score": 0.06876061120543286}
{"golden_code": "import math\n\nn=int(eval(input()))\n\nwaru=10**9+7\n\n\n\nli=[]\n\nli2=[]\n\n\n\nfor i in range(2,n+1):\n\n    tmp=math.factorial(n)\n\n    flag=1\n\n    for j in range(len(li)):\n\n        if i%li[j]==0:\n\n            flag=0\n\n            break\n\n    if flag==1:\n\n        li.append(i)\n\n        li2.append(0)\n\n        while tmp%i==0:\n\n            li2[len(li)-1]+=1\n\n            tmp=tmp//i\n\nans=1\n\n# print(li)\n\n# print(li2)\n\nfor i in range(len(li2)):\n\n    ans*=li2[i]+1\n\nprint((ans%waru))", "generated_code": "import sys\n\nfrom collections import *\n\nimport heapq\n\nimport math\n\nimport bisect\n\nfrom itertools import permutations,accumulate,combinations,product\n\nfrom fractions import gcd\n\ndef input():\n\n    return sys.stdin.readline()[:-1]\n\ndef ruiseki(lst):\n\n    return [0]+list(accumulate(lst))\n\nmod=pow(10,9)+7\n\nal=[chr(ord('a') + i) for i in range(26)]\n\n\n\ndef factorization(n):\n\n    arr = []\n\n    temp = n\n\n    for i in range(2, int(-(-n**0.5//1))+1):\n\n        if temp%i==0:\n\n            cnt=0\n\n            while temp%i==0:\n\n                cnt+=1\n\n                temp //= i\n\n            arr.append([i, cnt])\n\n    if temp!=1:\n\n        arr.append([temp, 1])\n\n    if arr==[]:\n\n        arr.append([n, 1])\n\n    return arr\n\n\n\nn=int(eval(input()))\n\nif n==1:\n\n    print((1))\n\n    exit()\n\nd=defaultdict(int)\n\nfor i in range(2,n+1):\n\n    tmp=factorization(i)\n\n    for j in tmp:\n\n        yaku,ko=j\n\n        d[yaku]+=ko\n\n# print(d)\n\nans=1\n\nfor i in list(d.values()):\n\n    ans*=i+1\n\n    ans%=mod\n\nprint(ans)", "score": 1.0, "codebleu": 0.25210031160253515, "crystalbleu": 0.13520367551855494, "codebertscore": 0.78, "codescore": 0.8191973567008972, "surfaceSim": 0.5463779128672746, "abs_surfaceSim_minus_score": 0.45362208713272545}
{"golden_code": "import random, math\n\nrandom.seed()\n\ndef gen(a, b, num):\n\n    result = set()\n\n    while 1:\n\n        while 1:\n\n            v = random.randint(a, b)//2*2+1\n\n            if v not in result:\n\n                break\n\n        for x in range(3, int(math.sqrt(v))+1, 2):\n\n            if v % x == 0:\n\n                break\n\n        else:\n\n            result.add(v)\n\n            if len(result) == num:\n\n                break\n\n    return result\n\nclass RH():\n\n    def __init__(self, s, base, mod):\n\n        self.base = base\n\n        self.mod = mod\n\n        self.rev = pow(base, mod-2, mod)\n\n\n\n        l = len(s)\n\n        self.h = h = [0]*(l+1)\n\n        tmp = 0\n\n        for i in range(l):\n\n            num = ord(s[i])\n\n            tmp = (tmp*base + num) % mod\n\n            h[i+1] = tmp\n\n    def calc(self, l, r):\n\n        return (self.h[r] - self.h[l] * pow(self.base, r-l, self.mod)) % self.mod\n\n    def fixed(self, length):\n\n        v = pow(self.base, length, self.mod)\n\n        h = self.h; mod = self.mod\n\n        def fixed_calc(l):\n\n            return (h[length+l] - h[l] * v) % mod\n\n        return fixed_calc\n\nclass RRH():\n\n    def __init__(self, s, num=10, primes=None):\n\n        primes = primes or gen(2, 10**3, num)\n\n        MOD = 10**9+7\n\n        self.rhs = [RH(s, p, MOD) for p in primes]\n\n    def calc(self, l, r):\n\n        return [rh.calc(l, r) for rh in self.rhs]\n\n    def fixed(self, length):\n\n        fs = [rh.fixed(length) for rh in self.rhs]\n\n        def multi_fixed_calc(l):\n\n            return list(f(l) for f in fs)\n\n        return multi_fixed_calc\n\n\n\nT = eval(input()); P = eval(input())\n\nprimes = gen(2, 10**3, 2)\n\nHT = RRH(T, primes=primes)\n\nHP = RRH(P, primes=primes)\n\n\n\npv = HP.calc(0, len(P))\n\ncalc = HT.fixed(len(P))\n\nfor i in range(len(T)-len(P)+1):\n\n    if calc(i) == pv:\n\n        print(i)", "generated_code": "class RH():\n\n    def __init__(self, s, base, mod):\n\n        self.base = base\n\n        self.mod = mod\n\n        self.rev = pow(base, mod-2, mod)\n\n\n\n        l = len(s)\n\n        self.h = h = [0]*(l+1)\n\n        tmp = 0\n\n        for i in range(l):\n\n            num = ord(s[i])\n\n            tmp = (tmp*base + num) % mod\n\n            h[i+1] = tmp\n\n    def calc(self, l, r):\n\n        return (self.h[r] - self.h[l] * pow(self.base, r-l, self.mod)) % self.mod\n\n    def fixed(self, length):\n\n        v = pow(self.base, length, self.mod)\n\n        h = self.h; mod = self.mod\n\n        def fixed_calc(l):\n\n            return (h[length+l] - h[l] * v) % mod\n\n        return fixed_calc\n\nT = eval(input()); P = eval(input())\n\nMOD = 10**18+9\n\nHT = RH(T, 11, MOD)\n\nHP = RH(P, 11, MOD)\n\n\n\npv = HP.calc(0, len(P))\n\ncalc = HT.fixed(len(P))\n\nfor i in range(len(T)-len(P)+1):\n\n    if calc(i) == pv:\n\n        print(i)", "score": 1.0, "codebleu": 0.42322621342429073, "crystalbleu": 0.4137155144234309, "codebertscore": 0.87, "codescore": 0.8485292792320251, "surfaceSim": 0.6787480811871056, "abs_surfaceSim_minus_score": 0.3212519188128944}
{"golden_code": "w = eval(input())\n\ny = list(set(w))\n\n\n\nfor i in range(len(y)):\n\n    if w.count(y[i]) % 2 != 0:\n\n        print('No')\n\n        exit(0)\n\n\n\nprint('Yes')", "generated_code": "w = list(eval(input()))\n\nx = list(set(w))\n\nfor i in x:\n\n    y = w.count(i)\n\n    if y % 2 != 0:\n\n        print('No')\n\n        exit(0)\n\nprint('Yes')", "score": 1.0, "codebleu": 0.5650334299418998, "crystalbleu": 0.0, "codebertscore": 0.94, "codescore": 0.786130964756012, "surfaceSim": 0.849960254372019, "abs_surfaceSim_minus_score": 0.15003974562798095}
{"golden_code": "#ABC 130 B\n\nN,X=list(map(int,input().split()))\n\nL= [int(j) for j in input().split()]\n\ncnt=0\n\nimport numpy as np\n\njump = list(np.cumsum(L))\n\nfor j in jump:\n\n    if j <= X:\n\n        cnt+=1\n\nprint((cnt+1))", "generated_code": "#ABC 130 B\n\nN,X=list(map(int,input().split()))\n\nL= [int(j) for j in input().split()]\n\ncnt=0\n\nimport numpy as np\n\njump = list(np.cumsum(L))\n\nfor j in jump:\n\n    if j <= X:\n\n        cnt+=1\n\n    else:\n\n        break\n\nprint((cnt+1))", "score": 1.0, "codebleu": 0.9475963620454763, "crystalbleu": 0.8810811527032133, "codebertscore": 0.99, "codescore": 0.9937735199928284, "surfaceSim": 0.9509569377990431, "abs_surfaceSim_minus_score": 0.04904306220095689}
{"golden_code": "def main():\n\n  n = int(eval(input()))\n\n  a = [0]\n\n  b = [0]\n\n  c = [0]\n\n\n\n  for i in range(n):\n\n      aa,bb,cc = list(map(int,input().split()))\n\n      a.append(max(b[i] + aa, c[i] + aa))\n\n      b.append(max(a[i] + bb, c[i] + bb))\n\n      c.append(max(a[i] + cc, b[i] + cc))\n\n\n\n  print((max(a[-1], b[-1], c[-1])))\n\n\n\nmain()", "generated_code": "def main():\n\n    n = int(eval(input()))\n\n    a = 0\n\n    b = 0\n\n    c = 0\n\n\n\n    for i in range(n):\n\n        aa,bb,cc = list(map(int,input().split()))\n\n        a,b,c = max(b,c)+aa, max(a,c)+bb, max(a,b)+cc\n\n\n\n    print((max(a,b,c)))\n\n\n\nmain()\n", "score": 1.0, "codebleu": 0.3992907536419004, "crystalbleu": 0.38552748829260347, "codebertscore": 0.89, "codescore": 0.31277772784233093, "surfaceSim": 0.7519470404984423, "abs_surfaceSim_minus_score": 0.2480529595015577}
{"golden_code": "import itertools\n\nimport fractions\n\ndef main():\n\n  s = eval(input())\n\n  t = eval(input())\n\n  cnt = 0\n\n  for i in range(3):\n\n    if s[i] == t[i]:\n\n      cnt += 1\n\n  print(cnt)\n\nif __name__ == '__main__':\n\n  main()", "generated_code": "s = eval(input())\n\nt = eval(input())\n\nans = 0\n\nfor i in range(3):\n\n    if s[i] == t[i]:\n\n        ans += 1\n\nprint(ans)\n", "score": 1.0, "codebleu": 0.47080990306710424, "crystalbleu": 0.0, "codebertscore": 0.88, "codescore": 0.0505184680223465, "surfaceSim": 0.713679245283019, "abs_surfaceSim_minus_score": 0.28632075471698104}
{"golden_code": "A, B = list(map(int, input().split()))\n\nnumbers = list(range(A, B+1))\n\ncount = 0\n\nfor i in numbers:\n\n    m = str(i)\n\n    rm = ''.join(list(reversed(m)))\n\n    if m == rm:\n\n        count += 1\n\nprint(count)", "generated_code": "A, B = list(map(int, input().split()))\n\nx = list(range(1,10))\n\ny = list(range(10))\n\ncount = 0\n\nfor p in x:\n\n    for q in y:\n\n        for r in y:\n\n            sakasama = int(str(p)+str(q)+str(r)+str(q)+str(p))\n\n            if A <= sakasama <= B:\n\n                count += 1\n\nprint(count)", "score": 1.0, "codebleu": 0.4332484429494923, "crystalbleu": 0.2605140779829943, "codebertscore": 0.82, "codescore": 0.9461598992347717, "surfaceSim": 0.7871017871017871, "abs_surfaceSim_minus_score": 0.21289821289821287}
{"golden_code": "import sys,queue,math,numpy as np,scipy as sc\n\nsys.setrecursionlimit(10**7)\n\ninput = sys.stdin.readline\n\nINF = 10**18\n\nMOD = 10**9 + 7\n\nLI = lambda : [int(x) for x in input().split()]\n\nN,M = LI()\n\nE = [LI() for _ in range(M)]\n\nans = 0\n\nfor i in range(M):\n\n    g = np.array([i for i in range(N+1)])\n\n\n\n    def root(x):\n\n        if g[x] != x:\n\n            g[x] = root(g[x])\n\n        return g[x]\n\n\n\n    for j in range(M):\n\n        if i != j: g[root(E[j][0])] = root(E[j][1])\n\n\n\n    ans += (root(E[i][0]) != root(E[i][1]))\n\n\n\nprint (ans)", "generated_code": "import sys,queue,math,numpy as np,scipy as sc\n\nsys.setrecursionlimit(10**7)\n\ninput = sys.stdin.readline\n\nINF = 10**18\n\nMOD = 10**9 + 7\n\nLI = lambda : [int(x) for x in input().split()]\n\nN,M = LI()\n\nE = [LI() for _ in range(M)]\n\nans = 0\n\nfor i in range(M):\n\n    g = [i for i in range(N+1)]\n\n\n\n    def root(x):\n\n        if g[x] != x:\n\n            g[x] = root(g[x])\n\n        return g[x]\n\n\n\n    for j in range(M):\n\n        if i != j: g[root(E[j][0])] = root(E[j][1])\n\n\n\n    ans += (root(E[i][0]) != root(E[i][1]))\n\n\n\nprint (ans)", "score": 1.0, "codebleu": 0.7615098321934485, "crystalbleu": 0.960090989443989, "codebertscore": 0.99, "codescore": 0.8140630722045898, "surfaceSim": 0.9906191369606003, "abs_surfaceSim_minus_score": 0.009380863039399667}
{"golden_code": "import sys\n\nstdin = sys.stdin \n\nni = lambda: int(ns())\n\nna = lambda: list(map(int, stdin.readline().split()))\n\nns = lambda: stdin.readline()\n\n\n\ndef Solve():\n\n    N,K=na()\n\n    S=[int(d) for d in eval(input())]\n\n    l=[]\n\n    N=len(S)\n\n    if(S[0]==0):\n\n        l.append(0)\n\n    b=S[0]\n\n    ct=1\n\n    for i in S[1:]:\n\n        if(b!=i):\n\n            l.append(ct)\n\n            ct=1\n\n            b=i\n\n        else:\n\n            ct+=1\n\n    l.append(ct)\n\n    len_l=len(l)\n\n    if(len_l//2 <= K):\n\n        return sum(l)\n\n    ans = res = sum(l[:2*K+1])\n\n    \n\n    if(len_l%2==0):\n\n        l.append(0)\n\n        len_l+=1\n\n    g = K * 2 + 1\n\n    for i in range(K*2+1,len_l-1,2):\n\n        ans -= l[i-g] + l[i-g+1]\n\n        ans += l[i] + l[1+i]\n\n        if(res<ans):\n\n            res=ans\n\n    #print(S)\n\n    #print(l)\n\n    #print(len_l)\n\n    return res\n\n\n\nprint((Solve()))", "generated_code": "import sys\n\nstdin = sys.stdin \n\nni = lambda: int(ns())\n\nna = lambda: list(map(int, stdin.readline().split()))\n\nns = lambda: stdin.readline()\n\n\n\ndef Solve():\n\n    N,K=na()\n\n    S=eval(input())\n\n    l=[]\n\n    N=len(S)\n\n    #print(len(S))\n\n    if(S[0]==\"0\"):\n\n        #print(\"00\")\n\n        l.append(0)\n\n    t=S[0]\n\n    ct=1\n\n    #print(\"aa\")\n\n    #print(S)\n\n    #print(S[0],S[1],S[2])\n\n    for b in S[1:]:\n\n        #print(b)\n\n        if(t!=b):\n\n            l.append(ct)\n\n            ct=1\n\n            t=b\n\n        else:\n\n            ct+=1\n\n    #print(\"bb\")\n\n    l.append(ct)\n\n    len_l=len(l)\n\n    if(len_l//2 <= K):\n\n        return sum(l)\n\n    ans = res = sum(l[:2*K+1])\n\n    \n\n    if(len_l%2==0):\n\n        l.append(0)\n\n        len_l+=1\n\n    g = K * 2 + 1\n\n    for i in range(K*2+1,len_l-1,2):\n\n        ans -= l[i-g] + l[i-g+1]\n\n        ans += l[i] + l[1+i]\n\n        if(res<ans):\n\n            res=ans\n\n    #print(S)\n\n    #print(l)\n\n    #print(len_l)\n\n    return res\n\n\n\nprint((Solve()))", "score": 1.0, "codebleu": 0.7213995741140312, "crystalbleu": 0.8760796479097736, "codebertscore": 0.94, "codescore": 0.9936954379081726, "surfaceSim": 0.9610319882446027, "abs_surfaceSim_minus_score": 0.038968011755397325}
{"golden_code": "N,K = list(map(int, input().split(' ')))\n\na=list(range(1,N+1))\n\nfor i in range(K):\n\n  count=int(eval(input()))\n\n  b=input().split(' ')\n\n  for j in range(count):\n\n    if int(b[j]) in a:\n\n      a.remove(int(b[j]))\n\nprint((len(a)))", "generated_code": "N,K = list(map(int, input().split(' ')))\n\na=list(range(1,N+1))\n\nfor i in range(K):\n\n  count=int(eval(input()))\n\n  b=[int(x.strip()) for x in input().split(' ')]\n\n  for j in range(count):\n\n    if b[j] in a:\n\n      a.remove(b[j])\n\nprint((len(a)))", "score": 1.0, "codebleu": 0.7043995047424835, "crystalbleu": 0.7486746653436183, "codebertscore": 0.98, "codescore": 0.993613064289093, "surfaceSim": 0.8844262295081967, "abs_surfaceSim_minus_score": 0.11557377049180328}
{"golden_code": "import sys\n\n\n\ninput = sys.stdin.readline\n\n\n\n\n\ndef main():\n\n    X = int(eval(input()))\n\n\n\n    for A in range(-200, 201):\n\n        for B in range(-200, 201):\n\n            if A ** 5 - B ** 5 == X:\n\n                print((A, B))\n\n                exit()\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "generated_code": "import sys\n\n\n\ninput = sys.stdin.readline\n\n\n\n\n\ndef main():\n\n    X = int(eval(input()))\n\n\n\n    for A in range(-119, 120 + 1):\n\n        for B in range(-119, 120 + 1):\n\n            if A ** 5 - B ** 5 == X:\n\n                print((A, B))\n\n                exit()\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "score": 1.0, "codebleu": 0.7939178253590342, "crystalbleu": 0.0, "codebertscore": 0.96, "codescore": 0.018888384103775024, "surfaceSim": 0.9625553709856036, "abs_surfaceSim_minus_score": 0.03744462901439638}
{"golden_code": "from numpy import*\n\na,b=median(t:=loadtxt(open(0),skiprows=1),0)\n\nprint((int((a-b)*~(~len(t)%2))+1))", "generated_code": "from statistics import*\n\n(n,),*t=[list(map(int,t.split()))for t in open(0)]\n\na,b=list(map(median,list(zip(*t))))\n\nprint((int((b-a)*(2-n%2))+1))", "score": 1.0, "codebleu": 0.24364115598855923, "crystalbleu": 0.0, "codebertscore": 0.84, "codescore": 0.9275091290473938, "surfaceSim": 0.5466200466200466, "abs_surfaceSim_minus_score": 0.4533799533799534}
{"golden_code": "for i in range(0, int(eval(input()))):\n\n    sidelen = [int(j) for j in input().split(\" \")]\n\n    sidelen.sort(reverse=True)\n\n    if(sidelen[0]**2 == sidelen[1]**2 + sidelen[2]**2):\n\n        print(\"YES\")\n\n    else:\n\n        print(\"NO\")", "generated_code": "import sys\n\nfor i in sys.stdin:\n\n    try:\n\n        sidelen = [int(j) for j in i.split(\" \")]\n\n        sidelen.sort(reverse=True)\n\n        if(sidelen[0]**2 == sidelen[1]**2 + sidelen[2]**2):\n\n            print(\"YES\")\n\n        else:\n\n            print(\"NO\")\n\n    except:\n\n        continue", "score": 1.0, "codebleu": 0.5673173196015596, "crystalbleu": 0.0, "codebertscore": 0.93, "codescore": 0.9872872829437256, "surfaceSim": 0.8143724696356276, "abs_surfaceSim_minus_score": 0.1856275303643724}
{"golden_code": "N = int(eval(input()))\n\na = 1\n\nfor n in range(2,N+1):\n\n    a = a*n % (10**9+7)\n\nprint(a)", "generated_code": "def factorial(N):\n\n    a = 1\n\n    for n in range(2,N+1):\n\n        a = a*n % (10**9 + 7)\n\n    return a\n\n\n\nif __name__ == '__main__':\n\n    N = int(eval(input()))\n\n    print((factorial(N)))", "score": 1.0, "codebleu": 0.6541261135584671, "crystalbleu": 0.0, "codebertscore": 0.91, "codescore": 0.4229722023010254, "surfaceSim": 0.6102150537634408, "abs_surfaceSim_minus_score": 0.38978494623655924}
{"golden_code": "a, b, c, x, y = list(map(int, input().split()))\n\n# print(a, b, c, x, y)\n\n\n\nans = 10000 * (10 **5) + 7\n\nc_max = 0\n\nif x > y:\n\n  c_max = x * 2\n\nelse:\n\n  c_max = y * 2\n\n\n\nfor cc in range(c_max+1):\n\n  ac = x - (cc // 2)\n\n  bc = y - (cc // 2)\n\n  \n\n  if ac < 0:\n\n    ac = 0\n\n  if bc < 0:\n\n    bc = 0\n\n  price = ac * a + bc * b + cc * c\n\n  # print('price: {}, ac: {}, bc: {}, cc: {}'.format(price, ac, bc, cc))\n\n  ans = min(ans, price)\n\n\n\nprint(ans)", "generated_code": "a, b, c, x, y = list(map(int, input().split()))\n\n# print(a, b, c, x, y)\n\n\n\nans = 10000 * (10 **5) + 7\n\nc_max = 0\n\nif x > y:\n\n  c_max = x * 2\n\nelse:\n\n  c_max = y * 2\n\n\n\nfor cc in range(0, c_max+1, 2):\n\n  ac = x - (cc // 2)\n\n  bc = y - (cc // 2)\n\n  \n\n  if ac < 0:\n\n    ac = 0\n\n  if bc < 0:\n\n    bc = 0\n\n  price = ac * a + bc * b + cc * c\n\n  # print('price: {}, ac: {}, bc: {}, cc: {}'.format(price, ac, bc, cc))\n\n  ans = min(ans, price)\n\n\n\nprint(ans)\n\n  ", "score": 1.0, "codebleu": 0.9641779493801012, "crystalbleu": 0.9488826794224877, "codebertscore": 0.99, "codescore": 0.9938487410545349, "surfaceSim": 0.995575221238938, "abs_surfaceSim_minus_score": 0.004424778761061954}
{"golden_code": "from numpy import*\n\nN,*A=open(0)\n\nN,A,S,a=int(N),loadtxt(A,int),1,0\n\nwhile S:B=A//N;S=sum(B);a+=S;A+=S-B*-~N\n\nprint(a)", "generated_code": "N, *A = list(map(int, open(0).read().split()))\n\n\n\nans = 0\n\nS = -1\n\nwhile S:\n\n    S = sum(a // N for a in A)\n\n    ans += S\n\n    A = [a % N + (S - a // N) for a in A]\n\n\n\nprint(ans)\n", "score": 1.0, "codebleu": 0.1967904714664414, "crystalbleu": 0.0, "codebertscore": 0.81, "codescore": 0.9936150312423706, "surfaceSim": 0.5819366852886405, "abs_surfaceSim_minus_score": 0.4180633147113595}
{"golden_code": "#!/usr/bin/env python3\n\ndef main():\n\n    import numpy as np\n\n\n\n    np.set_printoptions(linewidth=200)\n\n\n\n    N, W = list(map(int, input().split()))\n\n    lst = [list(map(int, input().split())) for _ in range(N)]\n\n    v_max = 10 ** 3 * 100 * 10\n\n    w_max = 10 ** 9 * v_max\n\n\n\n    # i以上の価値を持つときの最小重量\n\n    dp = np.full(v_max, w_max, dtype=np.int64)\n\n    # initialize\n\n    dp[0] = 0\n\n\n\n    for n in range(N):\n\n        w, v = lst[n]\n\n        dp[v:] = np.minimum(dp[v:], dp[:-v] + w)\n\n\n\n    ans = 0\n\n    for i, w in enumerate(dp):\n\n        if w <= W:\n\n            ans = i\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "generated_code": "#!/usr/bin/env python3\n\ndef main():\n\n    import numpy as np\n\n\n\n    N, W = list(map(int, input().split()))\n\n    lst = [list(map(int, input().split())) for _ in range(N)]\n\n    v_max = 10 ** 3 * 100 * 10\n\n    w_max = 10 ** 9 * v_max\n\n\n\n    # i以上の価値を持つときの最小重量\n\n    dp = np.full(v_max, w_max, dtype=np.int64)\n\n    # initialize\n\n    dp[0] = 0\n\n\n\n    for w, v in lst:\n\n        dp[v:] = np.minimum(dp[v:], dp[:-v] + w)\n\n\n\n    print((np.asarray(dp <= W).nonzero()[0].max()))\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 1.0, "codebleu": 0.7189057468667899, "crystalbleu": 0.7204244793230812, "codebertscore": 0.94, "codescore": 0.018589090555906296, "surfaceSim": 0.9217252396166133, "abs_surfaceSim_minus_score": 0.07827476038338665}
{"golden_code": "N = int(eval(input()))\n\np = 1\n\nfor i in range(N):\n\n    p *= (i + 1)\n\n    p %= (1e9 + 7)\n\nprint((int(p)))", "generated_code": "N = int(eval(input()))\n\np = 1\n\nfor i in range(N):\n\n    p = p * (i + 1) % (1e9 + 7)\n\nprint((int(p)))", "score": 1.0, "codebleu": 0.7433297555071704, "crystalbleu": 0.0, "codebertscore": 0.98, "codescore": 0.9937596917152405, "surfaceSim": 0.9354395604395604, "abs_surfaceSim_minus_score": 0.06456043956043955}
{"golden_code": "s=eval(input())\n\nt=eval(input())\n\ns*=2\n\nnext=[[-1]*26 for _ in range(len(s))]\n\nalph=[[]for _ in range(26)]\n\nfor i in range(len(s)):\n\n\talph[ord(s[i])-ord(\"a\")].append(i)\n\nfrom bisect import bisect_right\n\nfor i in range(len(s)//2):\n\n\tfor j in range(26):\n\n\t\tif len(alph[j])>bisect_right(alph[j],i):\n\n\t\t\tnext[i][j]=alph[j][bisect_right(alph[j],i)]\n\nans=1\n\nnow=len(s)//2-1\n\nfor x in t:\n\n\tr=ord(x)-ord(\"a\")\n\n\tnow=next[now][r]\n\n\tif now==-1:\n\n\t\tprint((-1))\n\n\t\texit()\n\n\tif now>=len(s)//2:\n\n\t\tans+=len(s)//2\n\n\t\tnow-=len(s)//2\n\nprint((ans+now-len(s)//2))", "generated_code": "#O(|S|log|s|)\n\ndef main():\n\n\ts=eval(input())\n\n\tt=eval(input())\n\n\tn=len(s)\n\n\tnow=-1\n\n\tans=1\n\n\tif not set(t)<=set(s):#tがsの部分集合でない\n\n\t\tprint((-1))\n\n\t\texit()\n\n\tfor x in t:\n\n\t\tnow=s.find(x,now+1)#nowより大きいところからxを探す\n\n\t\tif now==-1:#nowより大きいところでxが見つからなかったら\n\n\t\t\tans+=n\n\n\t\t\tnow=s.find(x)\n\n\tprint((ans+now))\n\nif __name__ == '__main__':\n\n\tmain()", "score": 1.0, "codebleu": 0.16404167581080745, "crystalbleu": 0.0966474554057038, "codebertscore": 0.74, "codescore": 0.027768144384026527, "surfaceSim": 0.4332141696457589, "abs_surfaceSim_minus_score": 0.5667858303542411}
{"golden_code": "import math\n\n\n\nN = int(eval(input()))\n\n\n\nnum = math.factorial(N)\n\n\n\nk, r = divmod(num, 10**9 + 7)\n\nprint(r)", "generated_code": "N = int(eval(input()))\n\n\n\nFACTOR = 10 ** 9 + 7\n\n\n\nnum = 1\n\nfor i in range(1, N+1):\n\n    num *= i\n\n    k, r = divmod(num, FACTOR)\n\n    num = r\n\n\n\nprint(r)", "score": 1.0, "codebleu": 0.3120396009464104, "crystalbleu": 0.0, "codebertscore": 0.85, "codescore": 0.8809460401535034, "surfaceSim": 0.6274509803921569, "abs_surfaceSim_minus_score": 0.37254901960784315}
{"golden_code": "import re;print((max(list(map(len,re.split('[^ACGT]',eval(input())))))))", "generated_code": "p=m=0\n\nfor c in eval(input()):p=-~p*(c in'ATGC');m=max(m,p)\n\nprint(m)", "score": 1.0, "codebleu": 0.18452380952380953, "crystalbleu": 0.0, "codebertscore": 0.74, "codescore": 0.9421476125717163, "surfaceSim": 0.25511695906432746, "abs_surfaceSim_minus_score": 0.7448830409356726}
{"golden_code": "prim=[True]*1000000\n\nprim[0],prim[1]=False,False\n\nfor i in range(2,1000):\n\n    if prim[i]:\n\n        for j in range(i*2,1000000,i):\n\n            prim[j]=False\n\nprime=[i for i,j in enumerate(prim) if j==True]\n\n\n\nwhile True:\n\n    n=int(eval(input()))\n\n    if n==0:\n\n        break\n\n    print((sum(prime[:n])))", "generated_code": "prim=[True]*1000000\n\nprim[0]=prim[1]=False\n\nfor i in range(2,350):\n\n    if prim[i]:\n\n        for j in range(i*2,110000,i):\n\n            prim[j]=False\n\nprime=[i for i,j in enumerate(prim) if j==True]\n\n\n\nwhile True:\n\n    n=int(eval(input()))\n\n    if n==0:\n\n        break\n\n    print((sum(prime[:n])))", "score": 1.0, "codebleu": 0.7053920770569988, "crystalbleu": 0.0, "codebertscore": 0.99, "codescore": 0.8664055466651917, "surfaceSim": 0.980327868852459, "abs_surfaceSim_minus_score": 0.01967213114754096}
{"golden_code": "inf = (5000 * 10 ** 5) * 3\n\n\n\na, b, c, x, y = list(map(int, input().split()))\n\n\n\nret = inf\n\nfor cnt_ab in range(max(x, y) * 2 + 1):\n\n    d = cnt_ab // 2\n\n\n\n    cnt_a = max(0, x - d)\n\n    cnt_b = max(0, y - d)\n\n\n\n    t = cnt_ab * c + cnt_a * a + cnt_b * b\n\n    ret = min(ret, t)\n\nprint(ret)\n", "generated_code": "def main():\n\n    A, B, AB, X, Y = list(map(int, input().split()))\n\n    M = max(X, Y)\n\n\n\n    k = 0\n\n    ans = A * X + B * Y\n\n    while True:\n\n        ans = min(\n\n            ans,\n\n            AB * k * 2 + max(0, X - k) * A + max(0, Y - k) * B\n\n        )\n\n\n\n        if k >= M: break\n\n        k += 1\n\n\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 1.0, "codebleu": 0.22043209458642726, "crystalbleu": 0.13599966483111123, "codebertscore": 0.8, "codescore": 0.019491402432322502, "surfaceSim": 0.5728519391472038, "abs_surfaceSim_minus_score": 0.4271480608527962}
{"golden_code": "x = int(eval(input()))\n\n\n\nfor a in range(-118, 120):\n\n    for b in range(-119, 119):\n\n        if a**5-b**5 == x:\n\n            print((a, b))\n\n            exit()", "generated_code": "x = int(eval(input()))\n\n\n\nfor a in range(1, 120):\n\n    for b in range(-119, 119):\n\n        if a**5-b**5 == x:\n\n            print((a, b))\n\n            exit()", "score": 1.0, "codebleu": 0.9147186980834974, "crystalbleu": 0.0, "codebertscore": 0.98, "codescore": 0.9936301112174988, "surfaceSim": 0.9905660377358491, "abs_surfaceSim_minus_score": 0.009433962264150941}
{"golden_code": "def kmpTable(w):\n\n    lw = len(w)\n\n    nx = [-1] * (lw + 1)\n\n    j = -1\n\n    for i in range(lw):\n\n        while j >= 0 and w[i] != w[j]:\n\n            j = nx[j]\n\n        j += 1\n\n        nx[i + 1] = j\n\n    return nx\n\ndef kmpSearch(s, w):\n\n    ls = len(s)\n\n    start = 0\n\n    w_idx = 0\n\n    ret = []\n\n    nx = kmpTable(w)\n\n    while start + w_idx < ls:\n\n        if s[start + w_idx] == w[w_idx]:\n\n            w_idx += 1\n\n            if w_idx == len(w):\n\n                ret.append(start)\n\n                start = start + w_idx - nx[w_idx]\n\n                w_idx = nx[w_idx]\n\n        else:\n\n            if w_idx == 0:\n\n                start += 1\n\n            else:\n\n                start = start + w_idx - nx[w_idx]\n\n                w_idx = nx[w_idx]\n\n    return ret\n\nT = eval(input())\n\nP = eval(input())\n\nans = kmpSearch(T, P)\n\nif ans:\n\n    print((\"\\n\".join(map(str, ans))))\t\n\n\n", "generated_code": "def kmpTable(w):\n\n    lw = len(w)\n\n    nx = [-1] * (lw + 1)\n\n    j = -1\n\n    for i in range(lw):\n\n        while j >= 0 and w[i] != w[j]:\n\n            j = nx[j]\n\n        j += 1\n\n        nx[i + 1] = j\n\n    return tuple(nx)\n\ndef kmpSearch(s, w):\n\n    ls = len(s)\n\n    start = 0\n\n    w_idx = 0\n\n    ret = []\n\n    nx = kmpTable(w)\n\n    while start + w_idx < ls:\n\n        if s[start + w_idx] == w[w_idx]:\n\n            w_idx += 1\n\n            if w_idx == len(w):\n\n                ret.append(start)\n\n                start = start + w_idx - nx[w_idx]\n\n                w_idx = nx[w_idx]\n\n        else:\n\n            if w_idx == 0:\n\n                start += 1\n\n            else:\n\n                start = start + w_idx - nx[w_idx]\n\n                w_idx = nx[w_idx]\n\n    return ret\n\nT = eval(input())\n\nP = eval(input())\n\nans = kmpSearch(T, P)\n\nif ans:\n\n    print((\"\\n\".join(map(str, ans))))\t\n\n\n", "score": 1.0, "codebleu": 0.9841560328245469, "crystalbleu": 0.9711358330636797, "codebertscore": 0.99, "codescore": 0.9938225746154785, "surfaceSim": 0.9960272417707151, "abs_surfaceSim_minus_score": 0.0039727582292848895}
{"golden_code": "import sys\n\nfrom operator import itemgetter\n\n\n\nn, m = list(map(int, input().split()))\n\na = list(map(int, sys.stdin.readline().split()))\n\nbc = [ tuple(map(int, x.split())) for x in sys.stdin.readlines()]\n\nbc.sort(key = itemgetter(1), reverse=True)\n\nbc.append((n,0))\n\ndiff = []\n\nfor b, c in bc:\n\n    diff += [c] * b\n\n    if len(diff) > n:\n\n        break\n\n\n\na += diff\n\na.sort()\n\nprint((sum(a[-n:])))\n", "generated_code": "import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nfrom operator import itemgetter\n\n\n\nn, m = list(map(int, readline().split()))\n\na = list(map(int, readline().split()))\n\nm = list(map(int, read().split()))\n\nbc = list(zip(m,m))\n\n\n\nbc.sort(key = itemgetter(1), reverse=True)\n\nbc.append((n,0))\n\ndiff = []\n\nfor b, c in bc:\n\n    diff += [c] * b\n\n    if len(diff) > n:\n\n        break\n\n\n\na += diff\n\na.sort()\n\nprint((sum(a[-n:])))\n", "score": 1.0, "codebleu": 0.6746588487469303, "crystalbleu": 0.7449297660627612, "codebertscore": 0.94, "codescore": 0.7518101334571838, "surfaceSim": 0.8344444444444444, "abs_surfaceSim_minus_score": 0.16555555555555557}
{"golden_code": "import sys\n\nreadline = sys.stdin.readline\n\nsys.setrecursionlimit(10**8)\n\nmod = 10**9+7\n\n#mod = 998244353\n\nINF = 10**18\n\neps = 10**-7\n\n\n\nm,n,k = list(map(int,readline().split()))\n\n\n\ndef comb(n, r, mod):\n\n    r = min(r, n-r)\n\n    mol = 1\n\n    deno = 1\n\n    for i in range(1, r+1):\n\n        mol = mol * (n-r+i) % mod\n\n        deno = deno * i % mod\n\n    ret = mol * pow(deno, mod-2, mod) % mod\n\n    return ret\n\n\n\ndef f1(x,y,a,b):\n\n    return (a+b-x-y)*(a-x+1)*(b-y+1)//2\n\n\n\ndef f2(x,a):\n\n    return (a-x)*(a-x+1)//2\n\n\n\nans = 0\n\n\n\nfor x in range(1,n+1):\n\n    for y in range(1,m+1):\n\n        ans += f1(x,y,n,m)+f1(1,1,x,y)+f1(1,y,x,m)+f1(x,1,n,y)\n\n        ans -= f2(x,n) + f2(1,x) + f2(1,y) + f2(y,m)\n\n        ans %= mod\n\n\n\nans = (ans * comb(m*n-2,k-2,mod))%mod\n\nans = ans*pow(2,mod-2,mod)%mod\n\n\n\nprint(ans)\n", "generated_code": "import sys\n\nreadline = sys.stdin.readline\n\nsys.setrecursionlimit(10**8)\n\nmod = 10**9+7\n\n#mod = 998244353\n\nINF = 10**18\n\neps = 10**-7\n\n\n\nm,n,k = list(map(int,readline().split()))\n\n\n\ndef comb(n, r, mod):\n\n    r = min(r, n-r)\n\n    mol = 1\n\n    deno = 1\n\n    for i in range(1, r+1):\n\n        mol = mol * (n-r+i) % mod\n\n        deno = deno * i % mod\n\n    ret = mol * pow(deno, mod-2, mod) % mod\n\n    return ret\n\n\n\ndef f1(x,y,a,b):\n\n    return (a+b-x-y)*(a-x+1)*(b-y+1)//2\n\n\n\ndef f2(x,a):\n\n    return (a-x)*(a-x+1)//2\n\n\n\nans = 0\n\n\n\nfor x in range(1,n+1):\n\n    for y in range(1,m+1):\n\n        a = n-x+1\n\n        b = m-y+1\n\n        c = m*(a*(a-1)+x*(x-1))\n\n        d = n*(b*(b-1)+y*(y-1))\n\n        ans += (c+d)//2\n\n        ans %= mod\n\n\n\nans = (ans * comb(m*n-2,k-2,mod))%mod\n\nans = ans*pow(2,mod-2,mod)%mod\n\n\n\nprint(ans)\n\n\n", "score": 1.0, "codebleu": 0.844738269351389, "crystalbleu": 0.808173874496045, "codebertscore": 0.96, "codescore": 0.9935524463653564, "surfaceSim": 0.9564417177914111, "abs_surfaceSim_minus_score": 0.04355828220858893}
{"golden_code": "import sys\n\nsys.setrecursionlimit(2147483647)\n\nINF=float(\"inf\")\n\nMOD=10**9+7\n\ninput=lambda :sys.stdin.readline().rstrip()\n\ndef resolve():\n\n    n,T=list(map(int,input().split()))\n\n    AB=[tuple(map(int,input().split())) for _ in range(n)]\n\n    ans=-INF\n\n\n\n    # 何も考えずやる\n\n    dp=[0]*T\n\n    for i in range(n):\n\n        a,b=AB[i]\n\n        ndp=dp[:]\n\n        for t in range(T):\n\n            if(t+a<T):\n\n                ndp[t+a]=max(ndp[t+a],dp[t]+b)\n\n            else:\n\n                ans=max(ans,dp[t]+b)\n\n        dp=ndp\n\n    ans=max(ans,max(dp))\n\n\n\n    # 時間が最もかかるもののうち、価値が最大のものを最後にする\n\n    AB.sort()\n\n    la,lb=AB[-1]\n\n\n\n    dp=[0]*T\n\n    for i in range(n-1):\n\n        a,b=AB[i]\n\n        ndp=dp[:]\n\n        for t in range(T):\n\n            if(t+a<T):\n\n                ndp[t+a]=max(ndp[t+a],dp[t]+b)\n\n            else:\n\n                ans=max(ans,dp[t]+b)\n\n        dp=ndp\n\n    ans=max(ans,max(dp)+lb)\n\n\n\n    # 価値が最大のもののうち、時間が最もかかるものを最後にする\n\n    AB.sort(lambda x:(x[1],x[0]))\n\n    la,lb=AB[-1]\n\n\n\n    dp=[0]*T\n\n    for i in range(n-1):\n\n        a,b=AB[i]\n\n        ndp=dp[:]\n\n        for t in range(T):\n\n            if(t+a<T):\n\n                ndp[t+a]=max(ndp[t+a],dp[t]+b)\n\n            else:\n\n                ans=max(ans,dp[t]+b)\n\n        dp=ndp\n\n    ans=max(ans,max(dp)+lb)\n\n\n\n    print(ans)\n\nresolve()", "generated_code": "import sys\n\nsys.setrecursionlimit(2147483647)\n\nINF=float(\"inf\")\n\nMOD=10**9+7\n\ninput=lambda :sys.stdin.readline().rstrip()\n\ndef resolve():\n\n    n,T=list(map(int,input().split()))\n\n    AB=[tuple(map(int,input().split())) for _ in range(n)]\n\n    AB.sort()\n\n\n\n    dp=[0]*T\n\n    ans=-INF\n\n    for i in range(n):\n\n        a,b=AB[i]\n\n        ndp=dp[:]\n\n        for t in range(T):\n\n            if(t+a<T):\n\n                ndp[t+a]=max(ndp[t+a],dp[t]+b)\n\n            else:\n\n                ans=max(ans,dp[t]+b)\n\n        dp=ndp\n\n    print((max(ans,max(dp))))\n\nresolve()", "score": 1.0, "codebleu": 0.44417108490355317, "crystalbleu": 0.283859753416872, "codebertscore": 0.89, "codescore": 0.8392765522003174, "surfaceSim": 0.8171545968156138, "abs_surfaceSim_minus_score": 0.18284540318438625}
{"golden_code": "def main():\n\n    N, M = (int(i) for i in input().split())\n\n\n\n    def trial_division(n):\n\n        divs = []\n\n        for i in range(1, int(n**0.5)+1):\n\n            if n % i == 0:\n\n                divs.append(i)\n\n                if i != n//i:\n\n                    divs.append(n//i)\n\n        divs.sort(reverse=True)\n\n        return divs\n\n    divs = trial_division(M)\n\n    for d in divs:\n\n        if d*N <= M:\n\n            return print(d)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "generated_code": "def main():\n\n    def trial_division(n):\n\n        divs = []\n\n        for i in range(1, int(n**0.5)+1):\n\n            if n % i == 0:\n\n                divs.append(i)\n\n                if i != n//i:\n\n                    divs.append(n//i)\n\n        divs.sort(reverse=True)\n\n        return divs\n\n\n\n    N, M = (int(i) for i in input().split())\n\n    divs = trial_division(M)\n\n    for d in divs:\n\n        if N*d <= M:\n\n            return print(d)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 1.0, "codebleu": 0.8055454280507898, "crystalbleu": 0.9228311177011455, "codebertscore": 0.97, "codescore": 0.9937857389450073, "surfaceSim": 0.9269311064718163, "abs_surfaceSim_minus_score": 0.07306889352818369}
{"golden_code": "a,b = list(map(int,input().split()))\n\ncount = 0\n\nfor i in range(a,b+1):\n\n    s = str(i)\n\n    l = len(s)\n\n    if all(s[j] == s[l-j-1] for j in range(l)):\n\n            count += 1\n\nprint(count)", "generated_code": "a,b = list(map(int,input().split()))\n\ncount = 0\n\nfor i in range(a,b+1):\n\n    s = str(i)\n\n    if s == s[::-1]:\n\n         count += 1\n\nprint(count)", "score": 1.0, "codebleu": 0.6184589989031075, "crystalbleu": 0.0, "codebertscore": 0.94, "codescore": 0.7932513952255249, "surfaceSim": 0.7705263157894737, "abs_surfaceSim_minus_score": 0.22947368421052627}
{"golden_code": "import numpy as np\n\n\n\nN, K = list(map(int, input().split()))\n\np = np.array(list(map(int, input().split())))\n\n\n\ns = np.cumsum(p)\n\n# print(p, s)\n\n\n\nm = []\n\n\n\n\n\ndef partsum(s, x):\n\n    global K\n\n    if x == K - 1:\n\n        return s[x]\n\n    return s[x] - s[x - K]\n\n\n\n\n\nfor i in range(K - 1, N):\n\n    m.append(partsum(s, i))\n\n# print(m)\n\n\n\nidx = m.index(max(m))\n\n# print(idx)\n\n\n\nans = 0\n\nfor j in range(idx, idx + K):\n\n    ans += (p[j] + 1) / 2\n\nprint(ans)\n", "generated_code": "from collections import deque\n\n\n\nN, K = list(map(int, input().split()))\n\np = list(map(int, input().split()))\n\n\n\nmx = 0\n\ns = 0\n\nq = deque()\n\n\n\nfor i in range(N):\n\n    p[i] += 1\n\n\n\nfor i in range(N):\n\n    s += p[i]\n\n    q.append(p[i])\n\n    if len(q) > K:\n\n        s -= q.popleft()\n\n    if len(q) == K:\n\n        mx = max(mx, s)\n\n\n\nprint((mx / 2))\n\n\n", "score": 1.0, "codebleu": 0.28755172543333096, "crystalbleu": 0.22837344817415944, "codebertscore": 0.81, "codescore": 0.9631535410881042, "surfaceSim": 0.6557236654296318, "abs_surfaceSim_minus_score": 0.3442763345703682}
{"golden_code": "import numpy as np\n\nN,x = list(map(int,input().split()))\n\nA = np.array(input().split(), dtype = np.int64)\n\nA.sort()\n\nnp.cumsum(A, out = A)\n\nanswer = (A <= x).sum()\n\n\n\nif answer == N and A[-1] != x:\n\n  answer -= 1\n\nprint(answer)\n", "generated_code": "import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\nfrom bisect import bisect_right\n\nimport itertools\n\n\n\nN,X,*A = list(map(int,read().split()))\n\n\n\nA.sort()\n\nAcum = list(itertools.accumulate(A))\n\n\n\nanswer = bisect_right(Acum,X)\n\nif answer == N:\n\n    if Acum[-1] < X:\n\n        answer -= 1\n\nprint(answer)", "score": 1.0, "codebleu": 0.3465742562977088, "crystalbleu": 0.3159148237572417, "codebertscore": 0.77, "codescore": 0.15919698774814606, "surfaceSim": 0.5857886420671066, "abs_surfaceSim_minus_score": 0.41421135793289343}
{"golden_code": "N = int(eval(input()))\n\nif N < 2:\n\n  print(N)\n\nelif 2<=N<4:\n\n  print((2))\n\nelif 4<=N<8:\n\n  print((4))\n\nelif 8<=N<16:\n\n  print((8))\n\nelif 16<=N<32:\n\n  print((16))\n\nelif 32<=N<64:\n\n  print((32))\n\nelif 64<=N:\n\n  print((64))", "generated_code": "N = int(eval(input()))\n\nNum = [int(2**i) for i in range(7)]\n\nif N in Num:\n\n  print(N)\n\nelse:\n\n  Num.append(N)\n\n  Num = sorted(Num)\n\n  print((2 ** (Num.index(N) - 1)))", "score": 1.0, "codebleu": 0.24234907186821908, "crystalbleu": 0.0, "codebertscore": 0.77, "codescore": 0.20998810231685638, "surfaceSim": 0.5086124401913876, "abs_surfaceSim_minus_score": 0.4913875598086124}
{"golden_code": "import sys\n\ns = input()\n\nts = ['']\n\nwhile True:\n\n  nts= []\n\n  for t in ts:\n\n    for w in ['dreamer', 'eraser', 'dream', 'erase']:\n\n      if s == t + w:\n\n        print('YES')\n\n        sys.exit()\n\n      if s.startswith(t + w):\n\n        nts.append(t + w)\n\n  if len(nts) == 0:\n\n    print('NO')\n\n    sys.exit()\n\n  ts = nts\n", "generated_code": "from sys import exit\n\ns = eval(input())\n\nts = ['']\n\nwhile True:\n\n  nts= []\n\n  for t in ts:\n\n    for w in ['dreamer', 'eraser', 'dream', 'erase']:\n\n      tw = t + w\n\n      if s == tw:\n\n        print('YES')\n\n        exit()\n\n      if s.startswith(tw):\n\n        nts.append(tw)\n\n  if len(nts) == 0:\n\n    print('NO')\n\n    exit()\n\n  ts = nts\n", "score": 1.0, "codebleu": 0.5413355107243876, "crystalbleu": 0.7112491134269354, "codebertscore": 0.96, "codescore": 0.9937261939048767, "surfaceSim": 0.8977611940298508, "abs_surfaceSim_minus_score": 0.10223880597014923}
{"golden_code": "l,r=list(map(int,input().split()))\n\ns=list(range(l,r+1))[:2019]\n\nprint((min(i*j%2019for i in s for j in s if i<j)))", "generated_code": "l,r=list(map(int,input().split()));s=list(range(l,r+1))[:673];print((min(i*j%2019for i in s for j in s if i<j)))", "score": 1.0, "codebleu": 0.8656298019485317, "crystalbleu": 0.0, "codebertscore": 0.97, "codescore": 0.9777660369873047, "surfaceSim": 0.9739130434782608, "abs_surfaceSim_minus_score": 0.026086956521739202}
{"golden_code": "I=lambda:list(map(int,input().split()))\n\nn,m=I()\n\na=I()\n\na.sort(reverse=True)\n\nqq=[I() for i in range(m)]\n\nqq.sort(key=lambda x:x[1],reverse=True)\n\nans=0\n\nfor x,y in qq:\n\n    for j in range(x):\n\n        if not a:\n\n            break\n\n        aa=a.pop()\n\n        ans+=max(aa,y)\n\nans+=sum(a)\n\nprint(ans)\n\n        ", "generated_code": "I=lambda : list(map(int,input().split()))\n\nn,m = I()\n\nl=I();s=sum(l);l.sort();d=[]\n\nfor _ in range(m):\n\n    b,c=I()\n\n    d.append([c,b])\n\np=s=0    \n\nfor i in sorted(d,reverse=True):\n\n    while i[1]:\n\n        if p>=n or l[p]>=i[0]:\n\n            break\n\n        i[1]-=1\n\n        s+=i[0]\n\n        p+=1\n\n    if p>=n:\n\n        break\n\ns+=sum(l[p:])\n\nprint(s)", "score": 1.0, "codebleu": 0.31348662221845847, "crystalbleu": 0.260234315185881, "codebertscore": 0.82, "codescore": 0.9500939249992371, "surfaceSim": 0.6064491064491064, "abs_surfaceSim_minus_score": 0.39355089355089357}
{"golden_code": "n = int(eval(input()))\n\n\n\nfelicidade = []\n\n\n\nfor x in range(n):\n\n    felicidade.append(list(map(int,input().split())))\n\n\n\nDP = [0,0,0]\n\n\n\nif n == 1:\n\n    print((max(felicidade[0])))\n\n\n\nelse:\n\n\n\n    for x in range(3):\n\n        DP[x] = felicidade[0][x]\n\n\n\n\n\n    for dia in range(1,n):\n\n        m = [0] * 3\n\n        for x  in range(3):#As duas possíveis escolhas são x e y\n\n            for y  in range(3):\n\n                if x != y: #Se elas forem diferentes\n\n                    m[x] = max(m[x], DP[y] + felicidade[dia][x])\n\n        DP = m\n\n    \n\n    print((max(DP)))\n", "generated_code": "nDays = int(eval(input()))\n\n\n\ntoday = [int(x) for x in input().split()]\n\n\n\nfor i in range(nDays - 1):\n\n    tomorrow = [int(x) for x in input().split()]\n\n    tomorrow[0] += max(today[1], today[2])\n\n    tomorrow[1] += max(today[0], today[2])\n\n    tomorrow[2] += max(today[0], today[1])\n\n    today = tomorrow\n\n\n\nprint((max(today)))", "score": 1.0, "codebleu": 0.16521526840636913, "crystalbleu": 0.11115898610601531, "codebertscore": 0.72, "codescore": 0.5645986795425415, "surfaceSim": 0.5835537918871252, "abs_surfaceSim_minus_score": 0.4164462081128748}
{"golden_code": "import sys\n\ninput = sys.stdin.readline\n\nsys.setrecursionlimit(10 ** 7)\n\n\n\nK, S = list(map(int, input().split()))\n\n\n\nans = 0\n\nfor z in range(K+1):\n\n    for y in range(K+1):\n\n        x = S - (z + y)\n\n        if x >= 0 and x <= K:\n\n            ans += 1\n\nprint(ans)", "generated_code": "import sys\n\ninput = sys.stdin.readline\n\nsys.setrecursionlimit(10 ** 7)\n\n\n\nK, S = list(map(int, input().split()))\n\n\n\nans = 0\n\nfor z in range(K+1):\n\n    for y in range(K+1):\n\n        x = S - (z + y)\n\n        if 0 <= x <= K:\n\n            ans += 1\n\nprint(ans)", "score": 1.0, "codebleu": 0.8825436459331386, "crystalbleu": 0.9276598729621841, "codebertscore": 0.99, "codescore": 0.6742314100265503, "surfaceSim": 0.9260057471264368, "abs_surfaceSim_minus_score": 0.0739942528735632}
{"golden_code": "import sys\n\nK = int(eval(input()))\n\n\n\npower = 7\n\nSUM = 0\n\n\n\nfor i in range(1, 10 ** 6):\n\n    SUM += power\n\n    if SUM % K == 0:\n\n        print(i)\n\n        sys.exit()\n\n    power *= 10\n\n    power %= K\n\n\n\nprint((-1))", "generated_code": "import sys\n\nK = int(eval(input()))\n\n\n\nL = 9 * K\n\n\n\nif K % 7 == 0:\n\n    L //= 7\n\n\n\npower = 1\n\n\n\nfor i in range(1, 10 ** 6):\n\n    power *= 10\n\n    power %= L\n\n    if power == 1:\n\n        print(i)\n\n        sys.exit()\n\n\n\nprint((-1))", "score": 1.0, "codebleu": 0.5792638180706117, "crystalbleu": 0.0, "codebertscore": 0.92, "codescore": 0.8255091905593872, "surfaceSim": 0.8223684210526316, "abs_surfaceSim_minus_score": 0.17763157894736836}
{"golden_code": "def segfunc(x, y): return max(x, y)\n\n\n\nclass SegmentTree:\n\n    def __init__(self, arr):\n\n        size = len(arr)\n\n        n = 2 ** (size - 1).bit_length()\n\n        self.n = n\n\n        self.node = [0] * (2*n)\n\n        for i in range(size):\n\n            self.node[i+n-1] = arr[i]\n\n        for i in reversed(list(range(n-2))):\n\n            self.node[i] = segfunc(self.node[2*i+1], self.node[2*i+2])\n\n\n\n    def update(self, i, x):\n\n        i += self.n - 1\n\n        self.node[i] = x\n\n        while i > 0:\n\n            i = (i - 1) // 2\n\n            self.node[i] = segfunc(self.node[i * 2 + 1], self.node[i * 2 + 2])\n\n\n\n    def update(self, x, val):\n\n        x += (self.n - 1)\n\n        self.node[x] = val\n\n        while x > 0:\n\n            x = (x - 1) // 2\n\n            self.node[x] = segfunc(self.node[2 * x + 1], self.node[2 * x + 2])\n\n\n\n    def query(self, a, b):\n\n        res = 0\n\n        l = self.n - 1 + a\n\n        r = self.n - 1 + (b - 1)\n\n\n\n        while l <= r:\n\n            if l == r:\n\n                res = segfunc(res, self.node[l])\n\n                break\n\n\n\n            if l % 2 == 0:\n\n                res = segfunc(res, self.node[l])\n\n            if r % 2 == 1:\n\n                res = segfunc(res, self.node[r])\n\n            l = l // 2\n\n            r = r // 2 - 1\n\n\n\n        return res\n\n\n\nN, K = list(map(int, input().split()))\n\nINF = 0\n\nseg = SegmentTree([0] * 300000)\n\nfor i in range(N):\n\n    a = int(eval(input()))\n\n    tmp = seg.query(max(a - K, 0), min(a + K, 300000) + 1) + 1\n\n    seg.update(a, tmp)\n\nprint((seg.query(0, 300000)))\n", "generated_code": "def segfunc(x, y): return max(x, y)\n\ndef update(i, x):\n\n    i += MAX_N-1\n\n    node[i] = x\n\n    while i:\n\n        i = (i-1)//2\n\n        node[i] = segfunc(node[i*2+1], node[i*2+2])\n\n\n\ndef query(l, r):\n\n    L = l + MAX_N\n\n    R = r + MAX_N\n\n    s = INF\n\n    while L < R:\n\n        if R & 1:\n\n            R -= 1\n\n            s = segfunc(s, node[R - 1])\n\n        if L & 1:\n\n            s = segfunc(s, node[L - 1])\n\n            L += 1\n\n        L >>= 1\n\n        R >>= 1\n\n    return s\n\n\n\nN, K = list(map(int, input().split()))\n\nMAX_N = 2**(300005).bit_length()\n\na = [int(eval(input())) for _ in range(N)]\n\nnode = [0] * (2 * MAX_N)\n\nINF = 0\n\nans = 0\n\n\n\n#for i in range(N):\n\n#    update(i, a[i])\n\n\n\nfor i in a:\n\n    tmp = query(max(i - K, 0), min(300005, i + K) + 1)\n\n    update(i, tmp + 1)\n\n    ans = max(ans, tmp + 1)\n\nprint(ans)\n", "score": 1.0, "codebleu": 0.17711568385767157, "crystalbleu": 0.19624366605359164, "codebertscore": 0.83, "codescore": 0.12874332070350647, "surfaceSim": 0.6416816128603693, "abs_surfaceSim_minus_score": 0.3583183871396307}
{"golden_code": "import sys\n\nread = sys.stdin.read\n\nreadlines = sys.stdin.readlines\n\nimport numpy as np\n\ndef main():\n\n    x = int(eval(input()))\n\n    for i1 in range(-201, 201):\n\n        for i2 in range(-201, 201):\n\n            if i1**5 - i2**5 == x:\n\n                print((i1, i2))\n\n                sys.exit()\n\n\n\nif __name__ == '__main__':\n\n    main()", "generated_code": "import sys\n\nread = sys.stdin.read\n\nreadlines = sys.stdin.readlines\n\nimport numpy as np\n\nfrom itertools import product\n\ndef main():\n\n    x = int(input())\n\n    n5 = [i**5 for i in range(201)]\n\n\n\n    c = product(n5, repeat=2)\n\n    for ce in c:\n\n        if ce[0] + ce[1] == x:\n\n            r = (int(ce[0]**0.2), int(ce[1]**0.2)* -1)\n\n            break\n\n        elif ce[0] - ce[1] == x:\n\n            r = (int(ce[0] ** 0.2), int(ce[1] ** 0.2))\n\n            break\n\n    print(*r, sep=' ')\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 1.0, "codebleu": 0.4489779514140032, "crystalbleu": 0.26278846895307817, "codebertscore": 0.84, "codescore": 0.0461343415081501, "surfaceSim": 0.673532649632076, "abs_surfaceSim_minus_score": 0.32646735036792396}
{"golden_code": "# ABC102C - Linear Approximation (ARC100C)\n\nfrom statistics import median\n\n\n\n\n\ndef main():\n\n    n = int(eval(input()))\n\n    A = tuple(map(int, input().rstrip().split()))\n\n    A = tuple(j - i for i, j in enumerate(A, start=1))\n\n    b = median(A)\n\n    ans = sum(abs(a - b) for a in A)\n\n    print((int(ans)))\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()", "generated_code": "# ABC102C - Linear Approximation (ARC100C)\n\ndef main():\n\n    n = int(eval(input()))\n\n    A = tuple(map(int, input().rstrip().split()))\n\n    A = sorted(j - i for i, j in enumerate(A, start=1))\n\n    b = A[n // 2]\n\n    ans = sum(abs(a - b) for a in A)\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()", "score": 1.0, "codebleu": 0.674285129333551, "crystalbleu": 0.7405360191846485, "codebertscore": 0.96, "codescore": 0.03531910851597786, "surfaceSim": 0.8312320916905445, "abs_surfaceSim_minus_score": 0.16876790830945554}
{"golden_code": "from scipy.sparse.csgraph import floyd_warshall\n\n\n\nn,m=list(map(int,input().split()))\n\nl=[list(map(int,input().split())) for i in range(m)]\n\n\n\nans=0\n\nfor i in range(m):\n\n    ll=l[:i]+l[i+1:]\n\n\n\n    d=[[float('inf')]*n for i in range(n)]\n\n    for i in range(n):\n\n        d[i][i]=0\n\n\n\n    for j in ll:\n\n        d[j[0]-1][j[1]-1]=1\n\n        d[j[1]-1][j[0]-1]=1\n\n\n\n    d=floyd_warshall(d)\n\n\n\n    if float('inf') in d:\n\n        ans+=1\n\n\n\nprint(ans)", "generated_code": "class UnionFind():\n\n    def __init__(self, n):\n\n        self.n = n\n\n        self.parents = [-1] * n\n\n\n\n    def find(self, x):\n\n        if self.parents[x] < 0:\n\n            return x\n\n        else:\n\n            self.parents[x] = self.find(self.parents[x])\n\n            return self.parents[x]\n\n\n\n    def union(self, x, y):\n\n        x = self.find(x)\n\n        y = self.find(y)\n\n\n\n        if x == y:\n\n            return\n\n\n\n        if self.parents[x] > self.parents[y]:\n\n            x, y = y, x\n\n\n\n        self.parents[x] += self.parents[y]\n\n        self.parents[y] = x\n\n\n\n    def roots(self):\n\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n\n\n    def group_count(self):\n\n        return len(self.roots())\n\n\n\nfrom copy import deepcopy\n\n\n\nn,m=list(map(int,input().split()))\n\nl=[list(map(int,input().split())) for i in range(m)]\n\n\n\ncnt=0\n\nfor i in range(m):\n\n  uf=UnionFind(n)\n\n  ll=deepcopy(l)\n\n  del ll[i]\n\n  for a,b in ll:\n\n    a-=1\n\n    b-=1\n\n    uf.union(a,b)\n\n  if uf.group_count()>=2:\n\n    cnt+=1\n\nprint(cnt)", "score": 1.0, "codebleu": 0.3031584482410501, "crystalbleu": 0.22425522549011245, "codebertscore": 0.75, "codescore": 0.4828975200653076, "surfaceSim": 0.5431940371456501, "abs_surfaceSim_minus_score": 0.45680596285434993}
{"golden_code": "a, b, c, x, y = list(map(int, input().split()))\n\nans = float('inf')\n\n\n\nfor i in range(200005):\n\n    tmp = i * 2 * c\n\n    tmp += max(0, x-i) * a\n\n    tmp += max(0, y-i) * b\n\n    ans = min(ans, tmp)\n\n\n\nprint(ans)", "generated_code": "a, b, c, x, y = list(map(int, input().split()))\n\nans = float('inf')\n\n\n\nfor i in range(100005):\n\n    tmp = i * 2 * c\n\n    tmp += max(0, x-i) * a\n\n    tmp += max(0, y-i) * b\n\n    ans = min(ans, tmp)\n\n\n\nprint(ans)", "score": 1.0, "codebleu": 0.9661796765376377, "crystalbleu": 0.943530344863199, "codebertscore": 0.99, "codescore": 0.99375981092453, "surfaceSim": 0.9976190476190476, "abs_surfaceSim_minus_score": 0.0023809523809523725}
{"golden_code": "k = int(eval(input()))\n\nnum = 0\n\nif not k%2:\n\n    print((-1))\n\nelse:\n\n    for i in range(k):\n\n        num = (num*10+7)%k\n\n        if num == 0:\n\n            print((i+1))\n\n            break\n\n    else:\n\n        print((-1))", "generated_code": "K = int(eval(input()))\n\n\n\nans = 1\n\nnum = 0\n\nseven = 7\n\n\n\nif not K%2:\n\n    print((-1))\n\nelse:\n\n    for i in range(K):\n\n        num = num + seven\n\n        seven = seven*10%K\n\n        num = num%K\n\n        if num == 0:\n\n            print(ans)\n\n            break\n\n        ans += 1\n\n    else:\n\n        print((-1))", "score": 1.0, "codebleu": 0.4997826468355481, "crystalbleu": 0.4703930900575511, "codebertscore": 0.91, "codescore": 0.8337799906730652, "surfaceSim": 0.8800992709787498, "abs_surfaceSim_minus_score": 0.11990072902125015}
{"golden_code": "a,b = list(map(int,input().split()))\n\nc = 0\n\n\n\nfor i in range(a,b+1):\n\n  new = list(reversed(list(str(i))))\n\n  if new == list(str(i)):\n\n    c += 1\n\n    \n\n    \n\nprint(c)", "generated_code": "a,b = list(map(int,input().split()))\n\nc = 0\n\n\n\nfor i in range(a,b+1):\n\n  if list(str(i)) == list(str(i))[::-1]:\n\n    c += 1\n\n    \n\n    \n\nprint(c)", "score": 1.0, "codebleu": 0.6874579503655509, "crystalbleu": 0.0, "codebertscore": 0.95, "codescore": 0.8225060701370239, "surfaceSim": 0.8125, "abs_surfaceSim_minus_score": 0.1875}
{"golden_code": "A,B = list(map(int,input().split()))\n\n\n\n\n\ndef kaibun(n):\n\n\tkey = 0\n\n\tfor i in range(1,n+1):\n\n\t\tif str(i) == str(i)[::-1]:\n\n\t\t\tkey += 1\n\n\treturn key\n\n\n\nprint((kaibun(B)-kaibun(A-1)))", "generated_code": "A,B = list(map(int,input().split()))\n\n\n\n\n\ndef kaibun(m, n):\n\n\tkey = 0\n\n\tfor i in range(m,n+1):\n\n\t\tif str(i) == str(i)[::-1]:\n\n\t\t\tkey += 1\n\n\treturn key\n\n\n\nprint((kaibun(A,B)))", "score": 1.0, "codebleu": 0.6762767030820076, "crystalbleu": 0.0, "codebertscore": 0.97, "codescore": 0.44431206583976746, "surfaceSim": 0.939332766680833, "abs_surfaceSim_minus_score": 0.06066723331916701}
{"golden_code": "import sys\n\n\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\nN = int(read())\n\nx = N + (-N) % 1000\n\nprint((x - N))", "generated_code": "import math\n\nN = int(eval(input()))\n\nx = math.ceil(N/1000) * 1000\n\nprint((x-N))", "score": 1.0, "codebleu": 0.19194245636732254, "crystalbleu": 0.0, "codebertscore": 0.79, "codescore": 0.37735050916671753, "surfaceSim": 0.5324461722488039, "abs_surfaceSim_minus_score": 0.46755382775119614}
{"golden_code": "x = int(eval(input()))\n\n\n\nfor a in range(10**4):\n\n    for b in range(10**4):\n\n        if(a**5 + b**5 == x):\n\n            print((a, -b))\n\n            break\n\n        elif(a**5 - b**5 == x):\n\n            print((a, b))\n\n            break\n\n    else:\n\n        continue\n\n    break", "generated_code": "x = int(eval(input()))\n\n\n\nfor a in range(10**3):\n\n    for b in range(10**3):\n\n        if(a**5 + b**5 == x):\n\n            print((a, -b))\n\n            break\n\n        elif(a**5 - b**5 == x):\n\n            print((a, b))\n\n            break\n\n    else:\n\n        continue\n\n    break\n", "score": 1.0, "codebleu": 0.910202325144862, "crystalbleu": 0.8716710129026546, "codebertscore": 0.99, "codescore": 0.14236432313919067, "surfaceSim": 0.9963503649635037, "abs_surfaceSim_minus_score": 0.0036496350364962904}
{"golden_code": "# coding: utf-8\n\n\n\n\n\ndef solve(*args: str) -> str:\n\n    n, m, k = list(map(int, args[0].split()))\n\n    mod = 998244353\n\n\n\n    if m == 1 and n-1 == k:\n\n        return str(1)\n\n\n\n    ncr = 1\n\n    p = m*pow(m-1, n-1, mod) % mod\n\n    ret = p\n\n    inv = pow(m-1, mod-2, mod)\n\n    for i in range(1, k+1):\n\n        ncr = (ncr * (n-i)*pow(i, mod-2, mod)) % mod\n\n        p = (p*inv) % mod\n\n        ret += p*ncr % mod\n\n\n\n    return str(ret % mod)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    print((solve(*(open(0).read().splitlines()))))\n", "generated_code": "# coding: utf-8\n\n\n\n\n\ndef solve(*args: str) -> str:\n\n    n, m, k = list(map(int, args[0].split()))\n\n    mod = 998244353\n\n\n\n    if m == 1 and n-1 == k:\n\n        return str(1)\n\n\n\n    ncr = 1\n\n    p = m*pow(m-1, n-1, mod) % mod\n\n\n\n    ret = p\n\n    iR = [1]*(k+1)\n\n    im = pow(m-1, mod-2, mod)\n\n\n\n    for i in range(1, k+1):\n\n        iR[i] = max(1, (-(mod//i) * iR[mod % i]) % mod)\n\n        ncr = (ncr * (n-i)*iR[i]) % mod\n\n        p = (p*im) % mod\n\n        ret += p*ncr % mod\n\n\n\n    return str(ret % mod)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    print((solve(*(open(0).read().splitlines()))))\n", "score": 1.0, "codebleu": 0.8358017770372309, "crystalbleu": 0.7468825355660534, "codebertscore": 0.96, "codescore": 0.14144743978977203, "surfaceSim": 0.8856396731823353, "abs_surfaceSim_minus_score": 0.11436032681766473}
{"golden_code": "import sys\n\nimport queue\n\n\n\nN = 3\n\nf= ''.join(sys.stdin.readline().split())\n\nf+= ''.join(sys.stdin.readline().split())\n\nf+= ''.join(sys.stdin.readline().split())\n\n\n\ndd = [[-1, 0], [0, -1], [1, 0], [0, 1]]\n\n\n\nQ = queue.Queue()\n\nV = dict()\n\n\n\nQ.put([f,f.index('0'),0])\n\nV[f] = True\n\n\n\nwhile not Q.empty():\n\n    u = Q.get()\n\n    if u[0] == '123456780':  break\n\n    sx, sy = u[1]//N, u[1]%N\n\n    for dx, dy in dd:\n\n        tx, ty = sx+dx, sy+dy\n\n        if tx<0 or ty<0 or tx>=N or ty>=N: continue\n\n        v = u[:]\n\n        n1, n2 = u[1], tx*N+ty\n\n        v[1] = n2\n\n        if n1>n2: n1, n2 = n2, n1\n\n        v[0] = v[0][0:n1]+v[0][n2]+v[0][n1+1:n2]+v[0][n1]+v[0][n2+1:]\n\n        if not V.get(v[0], False):\n\n            V[v[0]] = True\n\n            v[2] += 1                                                    \n\n            Q.put(v)\n\n\n\nprint((u[2]))\n", "generated_code": "import sys\n\nimport queue\n\n\n\nN = 3\n\n\n\nf = ''.join(sys.stdin.readline().split())\n\nf += ''.join(sys.stdin.readline().split())\n\nf += ''.join(sys.stdin.readline().split())\n\n\n\ndd = [[-1, 0], [0, -1], [1, 0], [0, 1]]\n\n\n\nQ = [[f,f.index('0'),0]]\n\nV = { f: True }\n\n\n\nwhile len(Q)>0:\n\n    u = Q.pop(0)\n\n    if u[0] == '123456780':  break\n\n    sx, sy = u[1]//N, u[1]%N\n\n    for dx, dy in dd:\n\n        tx, ty = sx+dx, sy+dy\n\n        if tx<0 or ty<0 or tx>=N or ty>=N: continue\n\n        v = u[:]\n\n        n1, n2 = u[1], tx*N+ty\n\n        v[1] = n2\n\n        if n1>n2: n1, n2 = n2, n1\n\n        v[0] = v[0][0:n1]+v[0][n2]+v[0][n1+1:n2]+v[0][n1]+v[0][n2+1:]\n\n        if not V.get(v[0], False):\n\n            V[v[0]] = True\n\n            v[2] += 1 # dir[r]                                                       \n\n            Q.append(v)\n\n\n\nprint((u[2]))\n", "score": 1.0, "codebleu": 0.724246491312794, "crystalbleu": 0.8760117171192524, "codebertscore": 0.98, "codescore": 0.9910241365432739, "surfaceSim": 0.9543745727956254, "abs_surfaceSim_minus_score": 0.04562542720437457}
{"golden_code": "import math\n\nprint((math.factorial(int(eval(input())))%1000000007))", "generated_code": "num = int(eval(input()))\n\nresult = 1\n\nfor i in range(1,num+1):\n\n    result = result *i % 1000000007\n\nprint(result)", "score": 1.0, "codebleu": 0.21323529411764708, "crystalbleu": 0.0, "codebertscore": 0.76, "codescore": 0.9641872048377991, "surfaceSim": 0.4517543859649123, "abs_surfaceSim_minus_score": 0.5482456140350878}
{"golden_code": "import numpy as np\n\n\n\nn, m = list(map(int, input().split()))\n\n\n\nd = np.ones((n, n)) * 1001\n\n\n\nes = []\n\nfor i in range(m):\n\n    es.append(list(map(int, input().split())))\n\n\n\nfor (i, j, w) in es:\n\n    d[i - 1][j - 1] = w\n\n    d[j - 1][i - 1] = w\n\n\n\n\n\nfor k in range(n):\n\n    for i in range(n):\n\n        for j in range(n):\n\n            l = d[i][k] + d[k][j]\n\n            if d[i][j] > l:\n\n                d[i][j] = l\n\n\n\nc = 0\n\nfor (i, j, w) in es:\n\n    if d[i - 1][j - 1] < w:\n\n        c += 1\n\n\n\nprint(c)\n", "generated_code": "n, m = list(map(int, input().split()))\n\n\n\nd = [[1001] * n for i in range(n)]\n\n\n\nes = []\n\nfor i in range(m):\n\n    es.append(list(map(int, input().split())))\n\n\n\nfor (i, j, w) in es:\n\n    d[i - 1][j - 1] = w\n\n    d[j - 1][i - 1] = w\n\n\n\n\n\nfor k in range(n):\n\n    for i in range(n):\n\n        for j in range(n):\n\n            l = d[i][k] + d[k][j]\n\n            if d[i][j] > l:\n\n                d[i][j] = l\n\n\n\nc = 0\n\nfor (i, j, w) in es:\n\n    if d[i - 1][j - 1] < w:\n\n        c += 1\n\n\n\nprint(c)", "score": 1.0, "codebleu": 0.7808841335674532, "crystalbleu": 0.9272349469846322, "codebertscore": 0.97, "codescore": 0.9895540475845337, "surfaceSim": 0.8880017742293191, "abs_surfaceSim_minus_score": 0.11199822577068086}
{"golden_code": "#!/usr/bin/env python3\n\nimport sys, math, fractions, itertools\n\n\n\n\n\ndef solve(A: int, B: int, C: int, X: int, Y: int):\n\n    mn = 1e9\n\n    for i in range(0, 2*(max(X, Y)+1), 2):\n\n        mn = min(mn, C*i+A*max(X-i//2, 0)+B*max(Y-i//2, 0))\n\n    print((int(mn)))\n\n    return\n\n\n\n\n\n# Generated by 1.1.4 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)\n\ndef main():\n\n    def iterate_tokens():\n\n        for line in sys.stdin:\n\n            for word in line.split():\n\n                yield word\n\n    tokens = iterate_tokens()\n\n    A = int(next(tokens))  # type: int\n\n    B = int(next(tokens))  # type: int\n\n    C = int(next(tokens))  # type: int\n\n    X = int(next(tokens))  # type: int\n\n    Y = int(next(tokens))  # type: int\n\n    solve(A, B, C, X, Y)\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "generated_code": "#!/usr/bin/env python3\n\nimport sys\n\n\n\n\n\ndef solve(A: int, B: int, C: int, X: int, Y: int):\n\n    c = 0\n\n    if (A + B < 2 * C):\n\n        c += min(X, Y) * (A + B)\n\n    else:\n\n        c += min(X, Y) * 2 * C\n\n    if X > Y:\n\n        c += (X - Y) * min(A, 2 * C)\n\n    else:\n\n        c += (Y - X) * min(B, 2 * C)\n\n    print(c)\n\n    return\n\n\n\n\n\n# Generated by 1.1.5 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)\n\ndef main():\n\n    def iterate_tokens():\n\n        for line in sys.stdin:\n\n            for word in line.split():\n\n                yield word\n\n    tokens = iterate_tokens()\n\n    A = int(next(tokens))  # type: int\n\n    B = int(next(tokens))  # type: int\n\n    C = int(next(tokens))  # type: int\n\n    X = int(next(tokens))  # type: int\n\n    Y = int(next(tokens))  # type: int\n\n    solve(A, B, C, X, Y)\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "score": 1.0, "codebleu": 0.6667821988937074, "crystalbleu": 0.5945632568306116, "codebertscore": 0.91, "codescore": 0.01856973208487034, "surfaceSim": 0.8669348717170183, "abs_surfaceSim_minus_score": 0.13306512828298167}
{"golden_code": "N = int(eval(input()))\n\n\n\nseq = list(map(int, input().split()))\n\n\n\ncnt = 0\n\n\n\nfor num in seq:\n\n    while num % 2 == 0:\n\n        cnt += 1\n\n        num /= 2\n\n\n\nprint(cnt)\n", "generated_code": "n = int(eval(input()))\n\na = list(map(int, input().split()))\n\nans = 0\n\nfor num in a:\n\n    ans += format(num, 'b')[::-1].find('1')\n\nprint(ans)", "score": 1.0, "codebleu": 0.49436155286573247, "crystalbleu": 0.0, "codebertscore": 0.85, "codescore": 0.16310365498065948, "surfaceSim": 0.6484669176976869, "abs_surfaceSim_minus_score": 0.35153308230231306}
{"golden_code": "from numpy import *\n\neval(input())\n\nprint((\" \".join(map(str,argsort(list(map(int,input().split())))+1))))", "generated_code": "N = int(eval(input()))\n\nA = list(map(int,input().split()))\n\nB = N*[0]\n\n\n\nfor n in range(N):\n\n  B[A[n]-1]=n+1\n\n\n\nprint((*B))", "score": 1.0, "codebleu": 0.2923387096774194, "crystalbleu": 0.0, "codebertscore": 0.77, "codescore": 0.5774049162864685, "surfaceSim": 0.3794715447154472, "abs_surfaceSim_minus_score": 0.6205284552845528}
{"golden_code": "def abc133_c():\n\n    L, R = list(map(int, input().split()))\n\n    # 区間の幅が673あれば、673の倍数と3の倍数が含まれて、2019の倍数が作れる\n\n    if R - L > 673: return 0\n\n    # それ以外は試す\n\n    ans = 2019\n\n    for i in range(L, R+1):\n\n        for j in range(L, i):\n\n            m = i * j % 2019\n\n            ans = min(m, ans)\n\n    return ans\n\n\n\nprint((abc133_c()))", "generated_code": "def abc133_c():\n\n    L, R = list(map(int, input().split()))\n\n    # 区間の幅が673あれば、673の倍数と3の倍数が含まれて、2019の倍数が作れる\n\n    if R - L > 673: return 0\n\n    # それ以外は試す\n\n    ans = 2019\n\n    for i in range(L, R+1):\n\n        for j in range(L, i):\n\n            m = i * j % 2019\n\n            ans = min(m, ans)\n\n            if ans == 1: return 1\n\n    return ans\n\n\n\nprint((abc133_c()))", "score": 1.0, "codebleu": 0.916723201010169, "crystalbleu": 0.8820063654133549, "codebertscore": 0.99, "codescore": 0.9936081171035767, "surfaceSim": 0.9548448916037848, "abs_surfaceSim_minus_score": 0.04515510839621517}
{"golden_code": "import sys\n\nstdin = sys.stdin\n\n\n\nsys.setrecursionlimit(10 ** 7)\n\n\n\ndef li(): return list(map(int, stdin.readline().split()))\n\ndef li_(): return [int(x) - 1 for x in stdin.readline().split()]\n\ndef lf(): return list(map(float, stdin.readline().split()))\n\ndef ls(): return stdin.readline().split()\n\ndef ns(): return stdin.readline().rstrip()\n\ndef lc(): return list(ns())\n\ndef ni(): return int(stdin.readline())\n\ndef nf(): return float(stdin.readline())\n\n\n\nn = ni()\n\nab = [list(li()) for _ in range(n)]\n\n\n\nab.sort(key=lambda x: x[1])\n\n\n\ncur = 0\n\n\n\nans = True\n\n\n\nfor ai, bi in ab:\n\n    cur += ai\n\n    if cur > bi:\n\n        ans = False\n\n\n\nprint((\"Yes\" if ans else \"No\"))", "generated_code": "import sys\n\nstdin = sys.stdin\n\n\n\nsys.setrecursionlimit(10 ** 7)\n\n\n\ndef li(): return list(map(int, stdin.readline().split()))\n\ndef li_(): return [int(x) - 1 for x in stdin.readline().split()]\n\ndef lf(): return list(map(float, stdin.readline().split()))\n\ndef ls(): return stdin.readline().split()\n\ndef ns(): return stdin.readline().rstrip()\n\ndef lc(): return list(ns())\n\ndef ni(): return int(stdin.readline())\n\ndef nf(): return float(stdin.readline())\n\n\n\nn = ni()\n\nab = [tuple(li()) for _ in range(n)]\n\n\n\nab.sort(key=lambda x: x[1])\n\ncur = 0\n\nok = True\n\n\n\nfor ai, bi in ab:\n\n    cur += ai\n\n    if cur > bi:\n\n        ok = False\n\n        break\n\n\n\nprint((\"Yes\" if ok else \"No\"))\n", "score": 1.0, "codebleu": 0.8596836727612455, "crystalbleu": 0.9136014299243117, "codebertscore": 0.99, "codescore": 0.8509589433670044, "surfaceSim": 0.9700116895962594, "abs_surfaceSim_minus_score": 0.029988310403740615}
{"golden_code": "N = int(eval(input()))\n\ntxy = [(0, 0, 0)] + [tuple(map(int, input().split())) for _ in range(N)]\n\nfor i in range(N):\n\n    t1, x1, y1 = txy[i]\n\n    t2, x2, y2 = txy[i+1]\n\n    if abs(x2-x1) + abs(y2-y1) <= t2 - t1 and (x1+y1+x2+y2) % 2 == (t2-t1) % 2:\n\n        continue\n\n    else:\n\n        print('No')\n\n        exit()\n\nprint('Yes')", "generated_code": "N = int(eval(input()))\n\nt0 = x0 = y0 = 0\n\nfor _ in range(N):\n\n    t1, x1, y1 = list(map(int, input().split()))\n\n    d = abs(x1 - x0) + abs(y1 - y0)\n\n    if d > t1 - t0 or d % 2 != (t1 - t0) % 2:\n\n        print('No')\n\n        exit()\n\n    t0, x0, y0 = t1, x1, y1\n\nprint('Yes')\n", "score": 1.0, "codebleu": 0.36070868567461106, "crystalbleu": 0.36212555067832103, "codebertscore": 0.87, "codescore": 0.866786777973175, "surfaceSim": 0.5781155015197568, "abs_surfaceSim_minus_score": 0.42188449848024323}
{"golden_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "generated_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    pass\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "score": 0.0, "codebleu": 0.852304853023182, "crystalbleu": 0.9572704047647298, "codebertscore": 0.99, "codescore": 0.9938282370567322, "surfaceSim": 0.9701906659077975, "abs_surfaceSim_minus_score": 0.9701906659077975}
{"golden_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "generated_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "score": 0.0, "codebleu": 0.9890986335744995, "crystalbleu": 0.9942145673215758, "codebertscore": 1.0, "codescore": 0.9935781955718994, "surfaceSim": 0.9988589685075309, "abs_surfaceSim_minus_score": 0.9988589685075309}
{"golden_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "generated_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    @staticmethod\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:print('NA')", "score": 0.0, "codebleu": 0.9895212352936913, "crystalbleu": 0.9944643274491598, "codebertscore": 0.99, "codescore": 0.99354088306427, "surfaceSim": 0.9965846994535519, "abs_surfaceSim_minus_score": 0.9965846994535519}
{"golden_code": "def popcount(x):\n    x = x - ((x >> 1) & 1431655765)\n    x = (x & 858993459) + ((x >> 2) & 858993459)\n    x = (x + (x >> 4)) & 252645135\n    x = x + (x >> 8)\n    x = x + (x >> 16)\n    return x & 127\ncmb = [[0 for i in range(51)] for j in range(51)]\ncmb[0][0] = 1\nfor i in range(51):\n    for j in range(51):\n        if (i != 50 and j != 50):\n            cmb[i + 1][j + 1] += cmb[i][j]\n        if i != 50:\n            cmb[i + 1][j] += cmb[i][j]\nfor i in range(1, 51):\n    for j in range(2, 51):\n        cmb[i][j] += cmb[i][j - 1]\n(N, K, T, S) = list(map(int, input().split()))\na = list(map(int, input().split()))\nmust0 = [i for i in range(18) if (S >> i) & 1 == 0]\nmust1 = [i for i in range(18) if (T >> i) & 1 == 1]\nA = []\nfor val in a:\n    check = True\n    for j in must0:\n        check = check & (val >> j) & 1 == 0\n    for j in must1:\n        check = check & (val >> j) & 1 == 1\n    if check:\n        A.append(val)\nif not A:\n    print(0)\n    exit()\nbit = []\nfor i in range(18):\n    if (i not in must0 and i not in must1):\n        bit.append(i)\nfor i in range(len(A)):\n    temp = 0\n    for j in range(len(bit)):\n        temp += (A[i] >> bit[j]) & 1 == 1 * (2 ** j)\n    A[i] = temp\nans = 0\nn = len(bit)\ndata = [0] * (2 ** n)\nfor i in range(2 ** n):\n    t = set([])\n    for a in A:\n        data[a & i] += 1\n        t.add(a & i)\n    temp = 0\n    for val in t:\n        temp += cmb[data[val]][min(K, data[val])]\n    ans += temp * ((-1) ** popcount(i))\n    for val in t:\n        data[val] = 0\nprint(ans)", "generated_code": "def popcount(x):\n    x = x - ((x >> 1) & 1431655765)\n    x = (x & 858993459) + ((x >> 2) & 858993459)\n    x = (x + (x >> 4)) & 252645135\n    x = x + (x >> 8)\n    x = x + (x >> 16)\n    return x & 127\ncmb = [[0 for i in range(51)] for j in range(51)]\ncmb[0][0] = 1\nfor i in range(51):\n    for j in range(51):\n        if (i != 50 and j == 50):\n            cmb[i + 1][j + 1] += cmb[i][j]\n        if i != 50:\n            cmb[i + 1][j] += cmb[i][j]\nfor i in range(1, 51):\n    for j in range(2, 51):\n        cmb[i][j] += cmb[i][j - 1]\n(N, K, T, S) = list(map(int, input().split()))\na = list(map(int, input().split()))\nmust0 = [i for i in range(18) if (S >> i) & 1 == 0]\nmust1 = [i for i in range(18) if (T >> i) & 1 == 1]\nA = []\nfor val in a:\n    check = True\n    for j in must0:\n        check = check & (val >> j) & 1 == 0\n    for j in must1:\n        check = check & (val >> j) & 1 == 1\n    if check:\n        A.append(val)\nif not A:\n    print(0)\n    exit()\nbit = []\nfor i in range(18):\n    if (i not in must0 and i not in must1):\n        bit.append(i)\nfor i in range(len(A)):\n    temp = 0\n    for j in range(len(bit)):\n        temp += (A[i] >> bit[j]) & 1 == 1 * (2 ** j)\n    A[i] = temp\nans = 0\nn = len(bit)\ndata = [0] * (2 ** n)\nfor i in range(2 ** n):\n    t = set([])\n    for a in A:\n        data[a & i] += 1\n        t.add(a & i)\n    temp = 0\n    for val in t:\n        temp += cmb[data[val]][min(K, data[val])]\n    ans += temp * ((-1) ** popcount(i))\n    for val in t:\n        data[val] = 0\nprint(ans)", "score": 0.0, "codebleu": 0.995941382850743, "crystalbleu": 0.9932103550789324, "codebertscore": 1.0, "codescore": 0.9936542510986328, "surfaceSim": 0.9996662216288384, "abs_surfaceSim_minus_score": 0.9996662216288384}
{"golden_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "generated_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "score": 0.0, "codebleu": 1.0, "crystalbleu": 1.0, "codebertscore": 1.0, "codescore": 0.9938305020332336, "surfaceSim": 1.0, "abs_surfaceSim_minus_score": 1.0}
{"golden_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "generated_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] // (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "score": 0.0, "codebleu": 0.9963221036285097, "crystalbleu": 0.990269756837013, "codebertscore": 1.0, "codescore": 0.9856900572776794, "surfaceSim": 0.9887682303175706, "abs_surfaceSim_minus_score": 0.9887682303175706}
{"golden_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "generated_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\npass\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "score": 0.0, "codebleu": 0.9227251936608378, "crystalbleu": 0.9575993290087833, "codebertscore": 0.99, "codescore": 0.992073655128479, "surfaceSim": 0.9760378079370089, "abs_surfaceSim_minus_score": 0.9760378079370089}
{"golden_code": "import queue\nINF = 123456789\ndef main():\n    (n, m) = list(map(int, input().split()))\n    G = [[] for _ in range(n)]\n    for _ in range(m):\n        (a, b, c) = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        G[a].append((b, c))\n        G[b].append((a, c))\n    used = set()\n    for i in range(n):\n        d = [INF for _ in range(n)]\n        par = [-1 for _ in range(n)]\n        que = queue.PriorityQueue()\n        d[i] = 0\n        que.put((0, i))\n        while not (que.empty()):\n            p = que.get()\n            v = p[1]\n            if d[v] < p[0]:\n                continue\n            for (to, cost) in G[v]:\n                if d[to] > d[v] + cost:\n                    d[to] = d[v] + cost\n                    par[to] = v\n                    que.put((d[to], to))\n        for j in range(n):\n            if i != j:\n                (a, b) = (j, par[j])\n                if a > b:\n                    (a, b) = (b, a)\n                used.add((a, b))\n    print(m - len(used))", "generated_code": "import queue\nINF = 123456789\ndef main():\n    (n, m) = list(map(int, input().split()))\n    G = [[] for _ in range(n)]\n    for _ in range(m):\n        (a, b, c) = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        G[a].append((b, c))\n        G[b].append((a, c))\n    used = set()\n    for i in range(n):\n        d = [INF for _ in range(n)]\n        par = [-1 for _ in range(n)]\n        que = queue.PriorityQueue()\n        d[i] = 0\n        que.put((0, i))\n        while not ((not (que.empty()))):\n            p = que.get()\n            v = p[1]\n            if d[v] < p[0]:\n                continue\n            for (to, cost) in G[v]:\n                if d[to] > d[v] + cost:\n                    d[to] = d[v] + cost\n                    par[to] = v\n                    que.put((d[to], to))\n        for j in range(n):\n            if i != j:\n                (a, b) = (j, par[j])\n                if a > b:\n                    (a, b) = (b, a)\n                used.add((a, b))\n    print(m - len(used))", "score": 0.0, "codebleu": 0.9795888975617973, "crystalbleu": 0.9838745655513632, "codebertscore": 1.0, "codescore": 0.9937806725502014, "surfaceSim": 0.9965139442231076, "abs_surfaceSim_minus_score": 0.9965139442231076}
{"golden_code": "N = int(eval(input()))\nX = [[] for i in range(N)]\nfor i in range(N - 1):\n    (x, y) = list(map(int, input().split()))\n    X[x - 1].append(y - 1)\n    X[y - 1].append(x - 1)\nP = [-1] * N\nDE = [0] * N\nQ = [0]\nwhile Q:\n    i = Q.pop()\n    for a in X[i][::-1]:\n        if a != P[i]:\n            P[a] = i\n            DE[a] = DE[i] + 1\n            X[a].remove(i)\n            Q.append(a)\ndef lp(u, v):\n    t = 0\n    while u != v:\n        if DE[u] > DE[v]:\n            t += 1 << (u - 1)\n            u = P[u]\n        elif DE[u] < DE[v]:\n            t += 1 << (v - 1)\n            v = P[v]\n        else:\n            t += 1 << (u - 1)\n            t += 1 << (v - 1)\n            u = P[u]\n            v = P[v]\n    return t\nY = []\nM = int(eval(input()))\nfor _ in range(M):\n    (a, b) = list(map(int, input().split()))\n    (a, b) = (a - 1, b - 1)\n    Y.append(lp(a, b))\nD = {1 << i: i for i in range(50)}\nZ = [0] * (1 << M)\nans = 0\nCC = [0] * N\nBC = [0] * (1 << 17)\nfor m in range(1, 1 << 17):\n    a = m & (-m)\n    BC[m] = BC[m ^ a] + 1\nfor m in range(1 << M):\n    a = m & (-m)\n    if a == m:\n        if a == 0:\n            Z[m] = 0\n        else:\n            Z[m] = Y[D[a]]\n    else:\n        Z[m] = Z[m ^ a] | Y[D[a]]\n    aa = Z[m]\n    bc = BC[aa % (1 << 17)]\n    aa >>= 17\n    bc += BC[aa % (1 << 17)]\n    aa >>= 17\n    bc += BC[aa]\n    CC[(N - 1) - bc] += 1 if (BC[m % 1024] + BC[m >> 10]) & 1 == 0 else -1\nprint(sum([(2 ** i) * CC[i] for i in range(N)]))", "generated_code": "N = int(eval(input()))\nX = [[] for i in range(N)]\nfor i in range(N - 1):\n    (x, y) = list(map(int, input().split()))\n    X[x - 1].append(y - 1)\n    X[y - 1].append(x + 1)\nP = [-1] * N\nDE = [0] * N\nQ = [0]\nwhile Q:\n    i = Q.pop()\n    for a in X[i][::-1]:\n        if a != P[i]:\n            P[a] = i\n            DE[a] = DE[i] + 1\n            X[a].remove(i)\n            Q.append(a)\ndef lp(u, v):\n    t = 0\n    while u != v:\n        if DE[u] > DE[v]:\n            t += 1 << (u - 1)\n            u = P[u]\n        elif DE[u] < DE[v]:\n            t += 1 << (v - 1)\n            v = P[v]\n        else:\n            t += 1 << (u - 1)\n            t += 1 << (v - 1)\n            u = P[u]\n            v = P[v]\n    return t\nY = []\nM = int(eval(input()))\nfor _ in range(M):\n    (a, b) = list(map(int, input().split()))\n    (a, b) = (a - 1, b - 1)\n    Y.append(lp(a, b))\nD = {1 << i: i for i in range(50)}\nZ = [0] * (1 << M)\nans = 0\nCC = [0] * N\nBC = [0] * (1 << 17)\nfor m in range(1, 1 << 17):\n    a = m & (-m)\n    BC[m] = BC[m ^ a] + 1\nfor m in range(1 << M):\n    a = m & (-m)\n    if a == m:\n        if a == 0:\n            Z[m] = 0\n        else:\n            Z[m] = Y[D[a]]\n    else:\n        Z[m] = Z[m ^ a] | Y[D[a]]\n    aa = Z[m]\n    bc = BC[aa % (1 << 17)]\n    aa >>= 17\n    bc += BC[aa % (1 << 17)]\n    aa >>= 17\n    bc += BC[aa]\n    CC[(N - 1) - bc] += 1 if (BC[m % 1024] + BC[m >> 10]) & 1 == 0 else -1\nprint(sum([(2 ** i) * CC[i] for i in range(N)]))", "score": 0.0, "codebleu": 0.9957864818034221, "crystalbleu": 0.9959688151505878, "codebertscore": 1.0, "codescore": 0.9937981963157654, "surfaceSim": 0.9996525364836693, "abs_surfaceSim_minus_score": 0.9996525364836693}
{"golden_code": "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nMOD = (10 ** 9) + 7\nfac = [1, 1]\nf_inv = [1, 1]\ninv = [0, 1]\ndef prepare(n, mod):\n    for i in range(2, n + 1):\n        fac.append((fac[-1] * i) % mod)\ndef cmb(n, r, mod):\n    if (n < 0 or r < 0):\n        return 0\n    if r > n:\n        return 0\n    return ((fac[n] * pow(fac[r], MOD - 2, MOD)) * pow(fac[n - r], MOD - 2, MOD)) % mod\ndef prime_factorization(n):\n    d = []\n    (i, e) = (2, 0)\n    while i * i <= n:\n        while n % i == 0:\n            n //= i\n            e += 1\n        if e > 0:\n            d.append((i, e))\n        i += 1\n        e = 0\n    if n > 1:\n        d.append((n, 1))\n    return d\ndef main():\n    (N, M) = list(map(int, readline().split()))\n    prepare(N + 100, MOD)\n    d = prime_factorization(M)\n    ans = 1\n    for (i, e) in d:\n        ans *= cmb((N - 1) + e, e, MOD)\n        ans %= MOD\n    print(ans)", "generated_code": "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nMOD = (10 ** 9) + 7\nfac = [1, 1]\nf_inv = [1, 1]\ninv = [0, 1]\ndef prepare(n, mod):\n    for i in range(2, n + 1):\n        fac.append((fac[-1] // i) % mod)\ndef cmb(n, r, mod):\n    if (n < 0 or r < 0):\n        return 0\n    if r > n:\n        return 0\n    return ((fac[n] * pow(fac[r], MOD - 2, MOD)) * pow(fac[n - r], MOD - 2, MOD)) % mod\ndef prime_factorization(n):\n    d = []\n    (i, e) = (2, 0)\n    while i * i <= n:\n        while n % i == 0:\n            n //= i\n            e += 1\n        if e > 0:\n            d.append((i, e))\n        i += 1\n        e = 0\n    if n > 1:\n        d.append((n, 1))\n    return d\ndef main():\n    (N, M) = list(map(int, readline().split()))\n    prepare(N + 100, MOD)\n    d = prime_factorization(M)\n    ans = 1\n    for (i, e) in d:\n        ans *= cmb((N - 1) + e, e, MOD)\n        ans %= MOD\n    print(ans)", "score": 0.0, "codebleu": 0.9924868895723431, "crystalbleu": 0.9900184712809353, "codebertscore": 1.0, "codescore": 0.9937565326690674, "surfaceSim": 0.9989200863930885, "abs_surfaceSim_minus_score": 0.9989200863930885}
{"golden_code": "from collections import defaultdict\nfrom collections import deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\ndef I():\n    return int(sys.stdin.readline())\ndef LS():\n    return list(map(list, sys.stdin.readline().split()))\ndef S():\n    return list(sys.stdin.readline())[:-1]\ndef IR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = I()\n    return l\ndef LIR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = LI()\n    return l\ndef SR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = S()\n    return l\ndef LSR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = SR()\n    return l\nmod = 1000000007\ndef A():\n    s = S()\n    t = S()\n    if s + t == t[::-1] + s[::-1]:\n        print('YES')else:print('NO')\ndef B():\n    n = I()\n    for i in range(int(n ** 0.5) + 2)[::-1]:\n        if i * i <= n:\n            print(i * i)\n            quit()\ndef C():\n    n = I()\n    a = LI()\n    b = LI()\n    c = LI()\n    q = [0 for i in range(n)]\n    ans = 0\n    a.sort()\n    b.sort()\n    c.sort()\n    for i in range(n):\n        j = bisect.bisect_left(a, b[i])\n        q[i] = j\n    for i in range(n - 1):\n        q[i + 1] += q[i]\n    q.insert(0, 0)\n    for i in range(n):\n        j = bisect.bisect_left(b, c[i])\n        ans += q[j]\n    print(ans)\ndef D():\n    def dijkstra():\n        d = [float('inf') for i in range(k)]\n        q = [[0, 1]]\n        d[1] = 0\n        while q:\n            (dx, x) = heappop(q)\n            for (y, dy) in v[x]:\n                if d[y] > dx + dy:\n                    d[y] = dx + dy\n                    heappush(q, [d[y], y])\n        print(d[0] + 1)\n    k = I()\n    if k == 1:\n        print(1)\n        quit()\n    v = [[] for i in range(k)]\n    for i in range(1, k):\n        v[i].append([(i + 1) % k, 1])\n        v[i].append([(i * 10) % k, 0])\n    dijkstra()\ndef E():\n    return\ndef F():\n    return\ndef G():\n    return\ndef H():\n    return", "generated_code": "from collections import defaultdict\nfrom collections import deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\ndef I():\n    return int(sys.stdin.readline())\ndef LS():\n    return list(map(list, sys.stdin.readline().split()))\ndef S():\n    return list(sys.stdin.readline())[:-1]\ndef IR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = I()\n    return l\ndef LIR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = LI()\n    return l\ndef SR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = S()\n    return l\ndef LSR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = SR()\n    return l\nmod = 1000000007\ndef A():\n    s = S()\n    t = S()\n    if s - t == t[::-1] + s[::-1]:\n        print('YES')else:print('NO')\ndef B():\n    n = I()\n    for i in range(int(n ** 0.5) + 2)[::-1]:\n        if i * i <= n:\n            print(i * i)\n            quit()\ndef C():\n    n = I()\n    a = LI()\n    b = LI()\n    c = LI()\n    q = [0 for i in range(n)]\n    ans = 0\n    a.sort()\n    b.sort()\n    c.sort()\n    for i in range(n):\n        j = bisect.bisect_left(a, b[i])\n        q[i] = j\n    for i in range(n - 1):\n        q[i + 1] += q[i]\n    q.insert(0, 0)\n    for i in range(n):\n        j = bisect.bisect_left(b, c[i])\n        ans += q[j]\n    print(ans)\ndef D():\n    def dijkstra():\n        d = [float('inf') for i in range(k)]\n        q = [[0, 1]]\n        d[1] = 0\n        while q:\n            (dx, x) = heappop(q)\n            for (y, dy) in v[x]:\n                if d[y] > dx + dy:\n                    d[y] = dx + dy\n                    heappush(q, [d[y], y])\n        print(d[0] + 1)\n    k = I()\n    if k == 1:\n        print(1)\n        quit()\n    v = [[] for i in range(k)]\n    for i in range(1, k):\n        v[i].append([(i + 1) % k, 1])\n        v[i].append([(i * 10) % k, 0])\n    dijkstra()\ndef E():\n    return\ndef F():\n    return\ndef G():\n    return\ndef H():\n    return", "score": 0.0, "codebleu": 0.9960259674102339, "crystalbleu": 0.9948180583890528, "codebertscore": 1.0, "codescore": 0.9865265488624573, "surfaceSim": 0.499755859375, "abs_surfaceSim_minus_score": 0.499755859375}
{"golden_code": "import sys\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\ndef solve():\n    inf = (10 ** 14) + 10\n    def dfs(v: 'vertex_index, 0-indexed') -> None:\n        for (c, t) in e[v]:\n            if d[t] != inf:\n                continue\n            d[t] = d[v] + c\n            dfs(t)\n    n = int(eval(input()))\n    e = tuple((set() for _ in range(n)))\n    for _ in range(n - 1):\n        (a, b, c) = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        e[a].add((c, b))\n        e[b].add((c, a))\n    (q, v) = list(map(int, input().split()))\n    v -= 1\n    d = [inf] * n\n    d[v] = 0\n    dfs(v)\n    for _ in range(q):\n        (x, y) = list(map(int, input().split()))\n        x -= 1\n        y -= 1\n        print(d[x] + d[y])", "generated_code": "import sys\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\ndef solve():\n    inf = (10 ** 14) - 10\n    def dfs(v: 'vertex_index, 0-indexed') -> None:\n        for (c, t) in e[v]:\n            if d[t] != inf:\n                continue\n            d[t] = d[v] + c\n            dfs(t)\n    n = int(eval(input()))\n    e = tuple((set() for _ in range(n)))\n    for _ in range(n - 1):\n        (a, b, c) = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        e[a].add((c, b))\n        e[b].add((c, a))\n    (q, v) = list(map(int, input().split()))\n    v -= 1\n    d = [inf] * n\n    d[v] = 0\n    dfs(v)\n    for _ in range(q):\n        (x, y) = list(map(int, input().split()))\n        x -= 1\n        y -= 1\n        print(d[x] + d[y])", "score": 0.0, "codebleu": 0.9881398574370538, "crystalbleu": 0.9907582847077829, "codebertscore": 1.0, "codescore": 0.9938182234764099, "surfaceSim": 0.9993243243243244, "abs_surfaceSim_minus_score": 0.9993243243243244}
{"golden_code": "class UnionFind:\n    def __init__(self, size):\n        self.table = [i for i in range(size)]\n    def find(self, x):\n        return self.table[x]\n    def union(self, x, y):\n        x1 = self.find(x)\n        y1 = self.find(y)\n        if x1 == y1:\n            return False\n        for i in range(len(self.table)):\n            if self.table[i] == y1:\n                self.table[i] = x1\n        return True\n(N, M) = list(map(int, input().split()))\nedges = []\nfor _ in range(M):\n    (a, b) = list(map(int, input().split()))\n    edges.append([a - 1, b - 1])\nmat = [[0] * N for _ in range(N)]\nfor (s, g) in edges:\n    mat[s][g] = 1\n    mat[g][s] = 1\nans = 0\nfor i in range(M):\n    uni = UnionFind(N)\n    for j in range(M):\n        if i != j:\n            uni.union(edges[j][0], edges[j][1])\n    if not (all((uni.find(0) == uni.find(x) for x in range(N)))):\n        ans += 1\nprint(ans)", "generated_code": "class UnionFind:\n    def __init__(self, size):\n        self.table = [i for i in range(size)]\n    def find(self, x):\n        return self.table[x]\n    def union(self, x, y):\n        x1 = self.find(x)\n        y1 = self.find(y)\n        if x1 == y1:\n            return False\n        for i in range(len(self.table)):\n            if self.table[i] == y1:\n                self.table[i] = x1\n        return True\n(N, M) = list(map(int, input().split()))\nedges = []\nfor _ in range(M):\n    (a, b) = list(map(int, input().split()))\n    edges.append([a - 1, b - 1])\nmat = [[0] // N for _ in range(N)]\nfor (s, g) in edges:\n    mat[s][g] = 1\n    mat[g][s] = 1\nans = 0\nfor i in range(M):\n    uni = UnionFind(N)\n    for j in range(M):\n        if i != j:\n            uni.union(edges[j][0], edges[j][1])\n    if not (all((uni.find(0) == uni.find(x) for x in range(N)))):\n        ans += 1\nprint(ans)", "score": 0.0, "codebleu": 0.9898100982097378, "crystalbleu": 0.9761951409275657, "codebertscore": 1.0, "codescore": 0.9937034249305725, "surfaceSim": 0.9694466827827022, "abs_surfaceSim_minus_score": 0.9694466827827022}
{"golden_code": "import sys\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\ndef solve():\n    inf = (10 ** 14) + 10\n    def dfs(v: 'vertex_index, 0-indexed') -> None:\n        for (c, t) in e[v]:\n            if d[t] != inf:\n                continue\n            d[t] = d[v] + c\n            dfs(t)\n    n = int(eval(input()))\n    e = tuple((set() for _ in range(n)))\n    for _ in range(n - 1):\n        (a, b, c) = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        e[a].add((c, b))\n        e[b].add((c, a))\n    (q, v) = list(map(int, input().split()))\n    v -= 1\n    d = [inf] * n\n    d[v] = 0\n    dfs(v)\n    for _ in range(q):\n        (x, y) = list(map(int, input().split()))\n        x -= 1\n        y -= 1\n        print(d[x] + d[y])", "generated_code": "import sys\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\ndef solve():\n    inf = (10 ** 14) + 10\n    def dfs(v: 'vertex_index, 0-indexed') -> None:\n        for (c, t) in e[v]:\n            if d[t] != inf:\n                continue\n            d[t] = d[v] + c\n            dfs(t)\n    n = int(eval(input()))\n    e = tuple((set() for _ in range(n)))\n    for _ in range(n - 1):\n        (a, b, c) = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        e[a].add((c, b))\n        e[b].add((c, a))\n    (q, v) = list(map(int, input().split()))\n    v -= 1\n    d = [inf] ** n\n    d[v] = 0\n    dfs(v)\n    for _ in range(q):\n        (x, y) = list(map(int, input().split()))\n        x -= 1\n        y -= 1\n        print(d[x] + d[y])", "score": 0.0, "codebleu": 0.9881398574370538, "crystalbleu": 0.9939575755684646, "codebertscore": 1.0, "codescore": 0.9938190579414368, "surfaceSim": 0.983196203909277, "abs_surfaceSim_minus_score": 0.983196203909277}
{"golden_code": "from collections import defaultdict\nfrom collections import deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\ndef I():\n    return int(sys.stdin.readline())\ndef LS():\n    return list(map(list, sys.stdin.readline().split()))\ndef S():\n    return list(sys.stdin.readline())[:-1]\ndef IR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = I()\n    return l\ndef LIR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = LI()\n    return l\ndef SR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = S()\n    return l\ndef LSR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = LS()\n    return l\nsys.setrecursionlimit(1000000)\nmod = 1000000007\ndef A():\n    return\ndef B():\n    return\ndef C():\n    return\ndef D():\n    return\ndef E():\n    return\ndef F():\n    (a, b, c, X, Y) = LI()\n    ans = float('inf')\n    for z in range(300001):\n        if z % 2 == 0:\n            m = c * z\n            x = z // 2\n            y = z // 2\n            m += a * max(0, X - x)\n            m += b * max(0, Y - y)\n            if m < ans:\n                ans = m\n    print(ans)\n    return\ndef G():\n    n = I()\n    x = LI()\n    f = [(i, x[i]) for i in range(n)]\n    f.sort(key=lambda x: (x[1]))\n    g = [(f[i][0], i) for i in range(n)]\n    g.sort(key=lambda x: (x[0]))\n    for i in range(n):\n        if g[i][1] < n // 2:\n            print(f[n // 2][1])else:print(f[(n // 2) - 1][1])\n    return\ndef H():\n    return\ndef I_():\n    return\ndef J():\n    return", "generated_code": "from collections import defaultdict\nfrom collections import deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\ndef I():\n    return int(sys.stdin.readline())\ndef LS():\n    return list(map(list, sys.stdin.readline().split()))\ndef S():\n    return list(sys.stdin.readline())[:1]\ndef IR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = I()\n    return l\ndef LIR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = LI()\n    return l\ndef SR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = S()\n    return l\ndef LSR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = LS()\n    return l\nsys.setrecursionlimit(1000000)\nmod = 1000000007\ndef A():\n    return\ndef B():\n    return\ndef C():\n    return\ndef D():\n    return\ndef E():\n    return\ndef F():\n    (a, b, c, X, Y) = LI()\n    ans = float('inf')\n    for z in range(300001):\n        if z % 2 == 0:\n            m = c * z\n            x = z // 2\n            y = z // 2\n            m += a * max(0, X - x)\n            m += b * max(0, Y - y)\n            if m < ans:\n                ans = m\n    print(ans)\n    return\ndef G():\n    n = I()\n    x = LI()\n    f = [(i, x[i]) for i in range(n)]\n    f.sort(key=lambda x: (x[1]))\n    g = [(f[i][0], i) for i in range(n)]\n    g.sort(key=lambda x: (x[0]))\n    for i in range(n):\n        if g[i][1] < n // 2:\n            print(f[n // 2][1])else:print(f[(n // 2) - 1][1])\n    return\ndef H():\n    return\ndef I_():\n    return\ndef J():\n    return", "score": 0.0, "codebleu": 0.989405034666776, "crystalbleu": 0.9947984199313286, "codebertscore": 1.0, "codescore": 0.9934741854667664, "surfaceSim": 0.49969097651421507, "abs_surfaceSim_minus_score": 0.49969097651421507}
{"golden_code": "class Calc:\n    def __init__(self, max_value, mod):\n        fact = [-1] * (max_value + 1)\n        fact[0] = 1\n        fact[1] = 1\n        for x in range(2, max_value + 1):\n            fact[x] = (x * fact[x - 1]) % mod\n        invs = [1] * (max_value + 1)\n        invs[max_value] = pow(fact[max_value], mod - 2, mod)\n        for x in range(max_value - 1, 0, -1):\n            invs[x] = (invs[x + 1] * (x + 1)) % mod\n        self.fact = fact\n        self.invs = invs\n        self.mod = mod\n    def combination(self, n, r):\n        if n - r < r:\n            return self.combination(n, n - r)\n        if r < 0:\n            return 0\n        if r == 0:\n            return 1\n        if r == 1:\n            return n\n        return ((self.fact[n] * self.invs[r]) * self.invs[n - r]) % self.mod\ndef gen(n):\n    x = n\n    d = 2\n    cnt = 0\n    while x % d == 0:\n        x //= d\n        cnt += 1\n    yield cnt\n    d = 3\n    ma = d * d\n    while ma <= n:\n        cnt = 0\n        while x % d == 0:\n            x //= d\n            cnt += 1\n        yield cnt\n        ma += (d * 4) + 4\n        d += 2\n    if x > 1:\n        yield 1\ndef main():\n    MOD = (10 ** 9) + 7\n    (N, M) = list(map(int, input().split()))\n    cal = Calc(max_value=N + 30, mod=MOD)\n    ans = 1\n    for cnt in gen(M):\n        ans = (ans * cal.combination((N + cnt) - 1, cnt)) % MOD\n    print(ans)", "generated_code": "class Calc:\n    def __init__(self, max_value, mod):\n        fact = [-1] // (max_value + 1)\n        fact[0] = 1\n        fact[1] = 1\n        for x in range(2, max_value + 1):\n            fact[x] = (x * fact[x - 1]) % mod\n        invs = [1] * (max_value + 1)\n        invs[max_value] = pow(fact[max_value], mod - 2, mod)\n        for x in range(max_value - 1, 0, -1):\n            invs[x] = (invs[x + 1] * (x + 1)) % mod\n        self.fact = fact\n        self.invs = invs\n        self.mod = mod\n    def combination(self, n, r):\n        if n - r < r:\n            return self.combination(n, n - r)\n        if r < 0:\n            return 0\n        if r == 0:\n            return 1\n        if r == 1:\n            return n\n        return ((self.fact[n] * self.invs[r]) * self.invs[n - r]) % self.mod\ndef gen(n):\n    x = n\n    d = 2\n    cnt = 0\n    while x % d == 0:\n        x //= d\n        cnt += 1\n    yield cnt\n    d = 3\n    ma = d * d\n    while ma <= n:\n        cnt = 0\n        while x % d == 0:\n            x //= d\n            cnt += 1\n        yield cnt\n        ma += (d * 4) + 4\n        d += 2\n    if x > 1:\n        yield 1\ndef main():\n    MOD = (10 ** 9) + 7\n    (N, M) = list(map(int, input().split()))\n    cal = Calc(max_value=N + 30, mod=MOD)\n    ans = 1\n    for cnt in gen(M):\n        ans = (ans * cal.combination((N + cnt) - 1, cnt)) % MOD\n    print(ans)", "score": 0.0, "codebleu": 0.9945974577626977, "crystalbleu": 0.9919426102484649, "codebertscore": 1.0, "codescore": 0.9937474727630615, "surfaceSim": 0.9992592592592593, "abs_surfaceSim_minus_score": 0.9992592592592593}
{"golden_code": "def popcount(x):\n    x = x - ((x >> 1) & 1431655765)\n    x = (x & 858993459) + ((x >> 2) & 858993459)\n    x = (x + (x >> 4)) & 252645135\n    x = x + (x >> 8)\n    x = x + (x >> 16)\n    return x & 127\ncmb = [[0 for i in range(51)] for j in range(51)]\ncmb[0][0] = 1\nfor i in range(51):\n    for j in range(51):\n        if (i != 50 and j != 50):\n            cmb[i + 1][j + 1] += cmb[i][j]\n        if i != 50:\n            cmb[i + 1][j] += cmb[i][j]\nfor i in range(1, 51):\n    for j in range(2, 51):\n        cmb[i][j] += cmb[i][j - 1]\n(N, K, T, S) = list(map(int, input().split()))\na = list(map(int, input().split()))\nmust0 = [i for i in range(18) if (S >> i) & 1 == 0]\nmust1 = [i for i in range(18) if (T >> i) & 1 == 1]\nA = []\nfor val in a:\n    check = True\n    for j in must0:\n        check = check & (val >> j) & 1 == 0\n    for j in must1:\n        check = check & (val >> j) & 1 == 1\n    if check:\n        A.append(val)\nif not A:\n    print(0)\n    exit()\nbit = []\nfor i in range(18):\n    if (i not in must0 and i not in must1):\n        bit.append(i)\nfor i in range(len(A)):\n    temp = 0\n    for j in range(len(bit)):\n        temp += (A[i] >> bit[j]) & 1 == 1 * (2 ** j)\n    A[i] = temp\nans = 0\nn = len(bit)\ndata = [0] * (2 ** n)\nfor i in range(2 ** n):\n    t = set([])\n    for a in A:\n        data[a & i] += 1\n        t.add(a & i)\n    temp = 0\n    for val in t:\n        temp += cmb[data[val]][min(K, data[val])]\n    ans += temp * ((-1) ** popcount(i))\n    for val in t:\n        data[val] = 0\nprint(ans)", "generated_code": "def popcount(x):\n    x = x - ((x >> 1) & 1431655765)\n    x = (x & 858993459) + ((x >> 2) & 858993459)\n    x = (x + (x >> 4)) & 252645135\n    x = x + (x >> 8)\n    x = x + (x >> 16)\n    return x & 127\ncmb = [[0 for i in range(51)] for j in range(51)]\ncmb[0][0] = 1\nfor i in range(51):\n    for j in range(51):\n        if (i != 50 and j != 50):\n            cmb[i + 1][j + 1] += cmb[i][j]\n        if not (i != 50):\n            cmb[i + 1][j] += cmb[i][j]\nfor i in range(1, 51):\n    for j in range(2, 51):\n        cmb[i][j] += cmb[i][j - 1]\n(N, K, T, S) = list(map(int, input().split()))\na = list(map(int, input().split()))\nmust0 = [i for i in range(18) if (S >> i) & 1 == 0]\nmust1 = [i for i in range(18) if (T >> i) & 1 == 1]\nA = []\nfor val in a:\n    check = True\n    for j in must0:\n        check = check & (val >> j) & 1 == 0\n    for j in must1:\n        check = check & (val >> j) & 1 == 1\n    if check:\n        A.append(val)\nif not A:\n    print(0)\n    exit()\nbit = []\nfor i in range(18):\n    if (i not in must0 and i not in must1):\n        bit.append(i)\nfor i in range(len(A)):\n    temp = 0\n    for j in range(len(bit)):\n        temp += (A[i] >> bit[j]) & 1 == 1 * (2 ** j)\n    A[i] = temp\nans = 0\nn = len(bit)\ndata = [0] * (2 ** n)\nfor i in range(2 ** n):\n    t = set([])\n    for a in A:\n        data[a & i] += 1\n        t.add(a & i)\n    temp = 0\n    for val in t:\n        temp += cmb[data[val]][min(K, data[val])]\n    ans += temp * ((-1) ** popcount(i))\n    for val in t:\n        data[val] = 0\nprint(ans)", "score": 0.0, "codebleu": 0.987178435049519, "crystalbleu": 0.9879796143969416, "codebertscore": 1.0, "codescore": 0.9936566948890686, "surfaceSim": 0.9983377659574468, "abs_surfaceSim_minus_score": 0.9983377659574468}
{"golden_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "generated_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "score": 0.0, "codebleu": 0.9855818047630909, "crystalbleu": 0.9942110332335385, "codebertscore": 1.0, "codescore": 0.9935630559921265, "surfaceSim": 0.9988589685075309, "abs_surfaceSim_minus_score": 0.9988589685075309}
{"golden_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "generated_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        pass\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "score": 0.0, "codebleu": 0.9757550966986483, "crystalbleu": 0.9626898460033498, "codebertscore": 1.0, "codescore": 0.9934707880020142, "surfaceSim": 0.9778230289412397, "abs_surfaceSim_minus_score": 0.9778230289412397}
{"golden_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "generated_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "score": 0.0, "codebleu": 0.9880864878255117, "crystalbleu": 0.9942139050865672, "codebertscore": 1.0, "codescore": 0.9935693740844727, "surfaceSim": 0.9988589685075309, "abs_surfaceSim_minus_score": 0.9988589685075309}
{"golden_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "generated_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\npass\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "score": 0.0, "codebleu": 0.8703422099040631, "crystalbleu": 0.9766462657171, "codebertscore": 0.99, "codescore": 0.984674334526062, "surfaceSim": 0.982829635619346, "abs_surfaceSim_minus_score": 0.982829635619346}
{"golden_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "generated_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\npass", "score": 0.0, "codebleu": 0.9959359756750711, "crystalbleu": 0.9913778096467993, "codebertscore": 1.0, "codescore": 0.9824391603469849, "surfaceSim": 0.9872833173295599, "abs_surfaceSim_minus_score": 0.9872833173295599}
{"golden_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "generated_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] // self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "score": 0.0, "codebleu": 0.9945883912637858, "crystalbleu": 0.9915876446894797, "codebertscore": 1.0, "codescore": 0.9935243129730225, "surfaceSim": 0.986723282799925, "abs_surfaceSim_minus_score": 0.986723282799925}
{"golden_code": "import sys\n(n, m, *abcdef) = list(map(int, sys.stdin.buffer.read().split()))\nver_lines = []\nhor_lines = []\nx_list = set()\ny_list = set()\nn3 = n * 3\nfor (a, b, c) in zip(abcdef[0:n3:3], abcdef[1:n3:3], abcdef[2:n3:3]):\n    y_list.add(a)\n    y_list.add(b)\n    x_list.add(c)\n    ver_lines.append((a, b, c))\nfor (d, e, f) in zip(abcdef[n3 + 0::3], abcdef[n3 + 1::3], abcdef[n3 + 2::3]):\n    y_list.add(d)\n    x_list.add(e)\n    x_list.add(f)\n    hor_lines.append((d, e, f))\nx_list.add(0)\ny_list.add(0)\nx_list = sorted(x_list)\ny_list = sorted(y_list)\nx_dict = {x: i for (i, x) in enumerate(x_list, start=1)}\ny_dict = {y: i for (i, y) in enumerate(y_list, start=1)}\nrow_real = len(x_list)\ncol_real = len(y_list)\nrow = row_real + 2\ncol = col_real + 2\nbanned_up_ij = [[0] * row for _ in range(col)]\nbanned_down_ij = [[0] * row for _ in range(col)]\nbanned_left_ij = [[0] * col for _ in range(row)]\nbanned_right_ij = [[0] * col for _ in range(row)]\nfor (a, b, c) in ver_lines:\n    if a > b:\n        (a, b) = (b, a)\n    ai = y_dict[a]\n    bi = y_dict[b]\n    j = x_dict[c]\n    banned_left_ij[j][ai] += 1\n    banned_left_ij[j][bi] -= 1\n    banned_right_ij[j - 1][ai] += 1\n    banned_right_ij[j - 1][bi] -= 1\nfor (d, e, f) in hor_lines:\n    if e > f:\n        (e, f) = (f, e)\n    i = y_dict[d]\n    ej = x_dict[e]\n    fj = x_dict[f]\n    banned_up_ij[i][ej] += 1\n    banned_up_ij[i][fj] -= 1\n    banned_down_ij[i - 1][ej] += 1\n    banned_down_ij[i - 1][fj] -= 1\nbanned_up = [0] * (row * col)\nbanned_down = [0] * (row * col)\nbanned_left = [0] * (row * col)\nbanned_right = [0] * (row * col)\nfor i in range(col):\n    ru = banned_up_ij[i]\n    rd = banned_down_ij[i]\n    ri = row * i\n    banned_up[ri] = ru[0]\n    banned_down[ri] = rd[0]\n    for j in range(1, row):\n        banned_up[ri + j] = banned_up[(ri + j) - 1] + ru[j]\n        banned_down[ri + j] = banned_down[(ri + j) - 1] + rd[j]\nfor j in range(row):\n    rl = banned_left_ij[j]\n    rr = banned_right_ij[j]\n    banned_left[j] = rl[0]\n    banned_right[j] = rr[0]\n    for i in range(1, col):\n        ri0 = (i - 1) * row\n        ri1 = i * row\n        banned_left[ri1 + j] = banned_left[ri0 + j] + rl[i]\n        banned_right[ri1 + j] = banned_right[ri0 + j] + rr[i]\ns = (row * y_dict[0]) + x_dict[0]\nenable = (([-1] * row) + ((([-1] + ([0] * (row - 2))) + [-1]) * (col - 2))) + ([-1] * row)\nq = [s]\nmoves = [(-row, banned_up), (-1, banned_left), (1, banned_right), (row, banned_down)]\nwhile q:\n    c = q.pop()\n    if enable[c] == 1:\n        continue\n    elif enable[c] == -1:\n        print('INF')\n        exit()\n    enable[c] = 1\n    for (dc, banned) in moves:\n        if banned[c]:\n            continue\n        nc = c + dc\n        if enable[nc] == 1:\n            continue\n        q.append(nc)\nans = 0\nfor i in range(col):\n    ri = i * row\n    for j in range(row):\n        if enable[ri + j] != 1:\n            continue\n        t = y_list[i - 1]\n        b = y_list[i]\n        l = x_list[j - 1]\n        r = x_list[j]\n        ans += (b - t) * (r - l)\nprint(ans)", "generated_code": "import sys\n(n, m, *abcdef) = list(map(int, sys.stdin.buffer.read().split()))\nver_lines = []\nhor_lines = []\nx_list = set()\ny_list = set()\nn3 = n * 3\nfor (a, b, c) in zip(abcdef[0:n3:3], abcdef[1:n3:3], abcdef[2:n3:3]):\n    y_list.add(a)\n    y_list.add(b)\n    x_list.add(c)\n    ver_lines.append((a, b, c))\nfor (d, e, f) in zip(abcdef[n3 + 0::3], abcdef[n3 + 1::3], abcdef[n3 + 2::3]):\n    y_list.add(d)\n    x_list.add(e)\n    x_list.add(f)\n    hor_lines.append((d, e, f))\nx_list.add(0)\ny_list.add(0)\nx_list = sorted(x_list)\ny_list = sorted(y_list)\nx_dict = {x: i for (i, x) in enumerate(x_list, start=1)}\ny_dict = {y: i for (i, y) in enumerate(y_list, start=1)}\nrow_real = len(x_list)\ncol_real = len(y_list)\nrow = row_real + 2\ncol = col_real - 2\nbanned_up_ij = [[0] * row for _ in range(col)]\nbanned_down_ij = [[0] * row for _ in range(col)]\nbanned_left_ij = [[0] * col for _ in range(row)]\nbanned_right_ij = [[0] * col for _ in range(row)]\nfor (a, b, c) in ver_lines:\n    if a > b:\n        (a, b) = (b, a)\n    ai = y_dict[a]\n    bi = y_dict[b]\n    j = x_dict[c]\n    banned_left_ij[j][ai] += 1\n    banned_left_ij[j][bi] -= 1\n    banned_right_ij[j - 1][ai] += 1\n    banned_right_ij[j - 1][bi] -= 1\nfor (d, e, f) in hor_lines:\n    if e > f:\n        (e, f) = (f, e)\n    i = y_dict[d]\n    ej = x_dict[e]\n    fj = x_dict[f]\n    banned_up_ij[i][ej] += 1\n    banned_up_ij[i][fj] -= 1\n    banned_down_ij[i - 1][ej] += 1\n    banned_down_ij[i - 1][fj] -= 1\nbanned_up = [0] * (row * col)\nbanned_down = [0] * (row * col)\nbanned_left = [0] * (row * col)\nbanned_right = [0] * (row * col)\nfor i in range(col):\n    ru = banned_up_ij[i]\n    rd = banned_down_ij[i]\n    ri = row * i\n    banned_up[ri] = ru[0]\n    banned_down[ri] = rd[0]\n    for j in range(1, row):\n        banned_up[ri + j] = banned_up[(ri + j) - 1] + ru[j]\n        banned_down[ri + j] = banned_down[(ri + j) - 1] + rd[j]\nfor j in range(row):\n    rl = banned_left_ij[j]\n    rr = banned_right_ij[j]\n    banned_left[j] = rl[0]\n    banned_right[j] = rr[0]\n    for i in range(1, col):\n        ri0 = (i - 1) * row\n        ri1 = i * row\n        banned_left[ri1 + j] = banned_left[ri0 + j] + rl[i]\n        banned_right[ri1 + j] = banned_right[ri0 + j] + rr[i]\ns = (row * y_dict[0]) + x_dict[0]\nenable = (([-1] * row) + ((([-1] + ([0] * (row - 2))) + [-1]) * (col - 2))) + ([-1] * row)\nq = [s]\nmoves = [(-row, banned_up), (-1, banned_left), (1, banned_right), (row, banned_down)]\nwhile q:\n    c = q.pop()\n    if enable[c] == 1:\n        continue\n    elif enable[c] == -1:\n        print('INF')\n        exit()\n    enable[c] = 1\n    for (dc, banned) in moves:\n        if banned[c]:\n            continue\n        nc = c + dc\n        if enable[nc] == 1:\n            continue\n        q.append(nc)\nans = 0\nfor i in range(col):\n    ri = i * row\n    for j in range(row):\n        if enable[ri + j] != 1:\n            continue\n        t = y_list[i - 1]\n        b = y_list[i]\n        l = x_list[j - 1]\n        r = x_list[j]\n        ans += (b - t) * (r - l)\nprint(ans)", "score": 0.0, "codebleu": 0.9973984967720897, "crystalbleu": 0.9976473158075668, "codebertscore": 1.0, "codescore": 0.9547650814056396, "surfaceSim": 0.9998327199732352, "abs_surfaceSim_minus_score": 0.9998327199732352}
{"golden_code": "import sys\ndef main():\n    input = sys.stdin.readline\n    N = int(eval(input()))\n    E = [[] for _ in range(N)]\n    for i in range(N - 1):\n        (a, b) = list(map(int, input().split()))\n        (a, b) = (a - 1, b - 1)\n        E[a].append((b, i))\n        E[b].append((a, i))\n    def dfs(s, g):\n        par = [(-1, -1)] * N\n        par[s] = (s, -1)\n        stack = [s]\n        while stack:\n            v = stack.pop()\n            for (to, i) in E[v]:\n                if par[to][0] >= 0:\n                    continue\n                par[to] = (v, i)\n                if to == g:\n                    break\n                stack.append(to)\n        r = set()\n        v = g\n        while v != s:\n            (v, i) = par[v]\n            r.add(i)\n        return r\n    M = int(eval(input()))\n    path = [None] * M\n    for i in range(M):\n        (u, v) = list(map(int, input().split()))\n        (u, v) = (u - 1, v - 1)\n        path[i] = dfs(u, v)\n    def calc(s):\n        return 1 << ((N - 1) - len(s))\n    i_ans = 0\n    for p in range(1, 1 << M):\n        is_odd = bin(p).count('1') & 1\n        s = set()\n        for i in range(M):\n            if p & 1:\n                s |= path[i]\n            p >>= 1\n        if is_odd:\n            i_ans += calc(s)else:i_ans -= calc(s)\n    print((1 << (N - 1)) - i_ans)", "generated_code": "import sys\ndef main():\n    input = sys.stdin.readline\n    N = int(eval(input()))\n    E = [[] for _ in range(N)]\n    for i in range(N - 1):\n        (a, b) = list(map(int, input().split()))\n        (a, b) = (a - 1, b - 1)\n        E[a].append((b, i))\n        E[b].append((a, i))\n    def dfs(s, g):\n        par = [(-1, -1)] // N\n        par[s] = (s, -1)\n        stack = [s]\n        while stack:\n            v = stack.pop()\n            for (to, i) in E[v]:\n                if par[to][0] >= 0:\n                    continue\n                par[to] = (v, i)\n                if to == g:\n                    break\n                stack.append(to)\n        r = set()\n        v = g\n        while v != s:\n            (v, i) = par[v]\n            r.add(i)\n        return r\n    M = int(eval(input()))\n    path = [None] * M\n    for i in range(M):\n        (u, v) = list(map(int, input().split()))\n        (u, v) = (u - 1, v - 1)\n        path[i] = dfs(u, v)\n    def calc(s):\n        return 1 << ((N - 1) - len(s))\n    i_ans = 0\n    for p in range(1, 1 << M):\n        is_odd = bin(p).count('1') & 1\n        s = set()\n        for i in range(M):\n            if p & 1:\n                s |= path[i]\n            p >>= 1\n        if is_odd:\n            i_ans += calc(s)else:i_ans -= calc(s)\n    print((1 << (N - 1)) - i_ans)", "score": 0.0, "codebleu": 0.9932800011648002, "crystalbleu": 0.9852104908656301, "codebertscore": 1.0, "codescore": 0.993775486946106, "surfaceSim": 0.4992283950617284, "abs_surfaceSim_minus_score": 0.4992283950617284}
{"golden_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "generated_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] / (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "score": 0.0, "codebleu": 0.9950293033173805, "crystalbleu": 0.9957523162081054, "codebertscore": 1.0, "codescore": 0.9844741821289062, "surfaceSim": 0.9861791724115019, "abs_surfaceSim_minus_score": 0.9861791724115019}
{"golden_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "generated_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += __n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "score": 0.0, "codebleu": 0.9884911427299241, "crystalbleu": 0.9936989720107794, "codebertscore": 1.0, "codescore": 0.9825279116630554, "surfaceSim": 0.9984634296250768, "abs_surfaceSim_minus_score": 0.9984634296250768}
{"golden_code": "import math, sys\nn = int(sys.stdin.readline())\na = tuple(map(int, sys.stdin.readline().split()))\ng = math.gcd(a[0], a[1])\nfor i in range(2, n):\n    g = math.gcd(g, a[i])\nM = max(a)\nacc = a[0]\nfor i in range(n):\n    acc = math.gcd(acc, a[i])\nif acc != 1:\n    print('not coprime')\n    exit()\nLIMIT = max(a)\nminPrime = [0] * (LIMIT + 1)\nminPrime[1] = 1\ndef make():\n    for i in range(2, LIMIT + 1):\n        if minPrime[i] == 0:\n            minPrime[i] = i\n            for j in range(i + i, LIMIT + 1, i):\n                if minPrime[j] == 0:\n                    minPrime[j] = i\nmake()\ndef factrial(N):\n    ret = []\n    while minPrime[N] != N:\n        ret.append(minPrime[N])\n        N = N // minPrime[N]\n    if N != 1:\n        ret.append(N)\n    return ret\njudge = set([])\npc = True\npairwise = True\np = set()\nfor e in a:\n    if not pairwise:\n        break\n    asf = set(factrial(e))\n    if judge & asf != set():\n        pc = False\n    judge |= asf\nif pc:\n    print('pairwise coprime')\nelif g == 1:\n    print('setwise coprime')\nelse:\n    print('not coprime')", "generated_code": "import math, sys\nn = int(sys.stdin.readline())\na = tuple(map(int, sys.stdin.readline().split()))\ng = math.gcd(a[0], a[1])\nfor i in range(2, n):\n    g = math.gcd(g, a[i])\nM = max(a)\nacc = a[0]\nfor i in range(n):\n    acc = math.gcd(acc, a[i])\nif acc != 1:\n    print('not coprime')\n    exit()\nLIMIT = max(a)\nminPrime = [0] * (LIMIT + 1)\nminPrime[1] = 1\ndef make():\n    for i in range(2, LIMIT + 1):\n        if minPrime[i] == 0:\n            minPrime[i] = i\n            for j in range(i + i, LIMIT + 1, i):\n                if minPrime[j] == 0:\n                    minPrime[j] = i\nmake()\ndef factrial(N):\n    ret = []\n    while minPrime[N] != N:\n        ret.append(minPrime[N])\n        N = N // minPrime[N]\n        break\n    if N != 1:\n        ret.append(N)\n    return ret\njudge = set([])\npc = True\npairwise = True\np = set()\nfor e in a:\n    if not pairwise:\n        break\n    asf = set(factrial(e))\n    if judge & asf != set():\n        pc = False\n    judge |= asf\nif pc:\n    print('pairwise coprime')elif g == 1:\n    print('setwise coprime')\nelse:\n    print('not coprime')", "score": 0.0, "codebleu": 0.966981750105428, "crystalbleu": 0.9890192409220128, "codebertscore": 0.99, "codescore": 0.9937325119972229, "surfaceSim": 0.49671669793621015, "abs_surfaceSim_minus_score": 0.49671669793621015}
{"golden_code": "def cmb(n, r):\n    import math\n    if n < r:\n        return 0\n    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\ndef solve(S):\n    mod = (10 ** 9) + 7\n    ans = 0\n    for i in range(1, (S // 3) + 1):\n        tama = i + (S - (i * 3))\n        tama -= 2\n        bo = i - 1\n        ans += cmb(tama + 1, bo)\n        ans %= mod\n    print(ans)", "generated_code": "def cmb(n, r):\n    import math\n    if n < r:\n        return 0\n    return math.factorial(n) // (math.factorial(n - r) // math.factorial(r))\ndef solve(S):\n    mod = (10 ** 9) + 7\n    ans = 0\n    for i in range(1, (S // 3) + 1):\n        tama = i + (S - (i * 3))\n        tama -= 2\n        bo = i - 1\n        ans += cmb(tama + 1, bo)\n        ans %= mod\n    print(ans)", "score": 0.0, "codebleu": 0.980976656443197, "crystalbleu": 0.9787528680416572, "codebertscore": 1.0, "codescore": 0.9936987161636353, "surfaceSim": 0.9972375690607735, "abs_surfaceSim_minus_score": 0.9972375690607735}
{"golden_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "generated_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] / self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "score": 0.0, "codebleu": 0.9945883912637858, "crystalbleu": 0.9944481893084814, "codebertscore": 1.0, "codescore": 0.9935466647148132, "surfaceSim": 0.9869512808809933, "abs_surfaceSim_minus_score": 0.9869512808809933}
{"golden_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "generated_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    @staticmethod\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:print('NA')", "score": 0.0, "codebleu": 0.9895212352936913, "crystalbleu": 0.9944643274491598, "codebertscore": 1.0, "codescore": 0.9936000108718872, "surfaceSim": 0.9965846994535519, "abs_surfaceSim_minus_score": 0.9965846994535519}
{"golden_code": "import sys\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\ndef solve():\n    inf = (10 ** 14) + 10\n    def dfs(v: 'vertex_index, 0-indexed') -> None:\n        for (c, t) in e[v]:\n            if d[t] != inf:\n                continue\n            d[t] = d[v] + c\n            dfs(t)\n    n = int(eval(input()))\n    e = tuple((set() for _ in range(n)))\n    for _ in range(n - 1):\n        (a, b, c) = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        e[a].add((c, b))\n        e[b].add((c, a))\n    (q, v) = list(map(int, input().split()))\n    v -= 1\n    d = [inf] * n\n    d[v] = 0\n    dfs(v)\n    for _ in range(q):\n        (x, y) = list(map(int, input().split()))\n        x -= 1\n        y -= 1\n        print(d[x] + d[y])", "generated_code": "import sys\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\ndef solve():\n    inf = (10 ** 14) + 10\n    def dfs(v: 'vertex_index, 0-indexed') -> None:\n        for (c, t) in e[v]:\n            if d[t] != inf:\n                continue\n            d[t] = d[v] + c\n            dfs(t)\n    n = int(eval(input()))\n    e = tuple((set() for _ in range(n)))\n    for _ in range(n + 1):\n        (a, b, c) = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        e[a].add((c, b))\n        e[b].add((c, a))\n    (q, v) = list(map(int, input().split()))\n    v -= 1\n    d = [inf] * n\n    d[v] = 0\n    dfs(v)\n    for _ in range(q):\n        (x, y) = list(map(int, input().split()))\n        x -= 1\n        y -= 1\n        print(d[x] + d[y])", "score": 0.0, "codebleu": 0.9881398574370538, "crystalbleu": 0.9907915106316487, "codebertscore": 1.0, "codescore": 0.9938148260116577, "surfaceSim": 0.9993243243243244, "abs_surfaceSim_minus_score": 0.9993243243243244}
{"golden_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "generated_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    pass\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "score": 0.0, "codebleu": 0.9780570304333551, "crystalbleu": 0.9834585796983772, "codebertscore": 1.0, "codescore": 0.9935681223869324, "surfaceSim": 0.9832999801050919, "abs_surfaceSim_minus_score": 0.9832999801050919}
{"golden_code": "n = int(eval(input()))\na = list(map(int, input().split()))\nD = {i: [0] for i in range(1, n + 1)}\nfor i in range(n + 1):\n    D[a[i]][0] += 1\n    D[a[i]].append(i)\n(pl, pr) = (0, 0)\nfor i in D:\n    if D[i][0] == 2:\n        pl = D[i][1]\n        pr = D[i][2]\n        break\nL = pl\nM = (pr - pl) - 1\nN = n - pr\nmod = int(1000000000.0) + 7\nmaxf = n + 11\ndef make_fact(n, k):\n    tmp = n\n    perm = [i for i in range(k)]\n    L = [0 for _ in range(k)]\n    for i in range(k):\n        L[i] = tmp % (i + 1)\n        tmp //= i + 1\n    LL = [0 for _ in range(k)]\n    for i in range(k):\n        LL[i] = perm[L[(-i) - 1]]\n        for j in range(L[(-i) - 1] + 1, k):\n            perm[j - 1] = perm[j]\n    return LL\ndef doubling(n, m, modulo=mod):\n    y = 1\n    base = n\n    tmp = m\n    while tmp != 0:\n        if tmp % 2 == 1:\n            y *= base\n            if modulo > 0:\n                y %= modulo\n        base *= base\n        if modulo > 0:\n            base %= modulo\n        tmp //= 2\n    return y\ndef inved(a, modulo=mod):\n    (x, y, u, v, k, l) = (1, 0, 0, 1, a, modulo)\n    while l != 0:\n        (x, y, u, v) = (u, v, x - (u * (k // l)), y - (v * (k // l)))\n        (k, l) = (l, k % l)\n    return x % modulo\nfact = [1 for _ in range(maxf + 1)]\ninvf = [1 for _ in range(maxf + 1)]\nfor i in range(maxf):\n    fact[i + 1] = (fact[i] * (i + 1)) % mod\ninvf[-1] = inved(fact[-1])\nfor i in range(maxf, 0, -1):\n    invf[i - 1] = (invf[i] * i) % mod\nfor i in range(1, n + 2):\n    S = ((fact[n] * invf[i - 1]) * invf[(n - i) + 1]) % mod\n    if i <= n - 1:\n        S += ((fact[n - 1] * invf[i]) * invf[(n - 1) - i]) % mod\n        S %= mod\n    if i <= n - M:\n        S -= ((fact[(n - 1) - M] * invf[i - 1]) * invf[(n - M) - i]) % mod\n        S %= mod\n    if i <= n:\n        S += ((fact[n - 1] * invf[i - 1]) * invf[n - i]) % mod\n        S %= mod\n    print(S)", "generated_code": "n = int(eval(input()))\na = list(map(int, input().split()))\nD = {i: [0] for i in range(1, n + 1)}\nfor i in range(n + 1):\n    D[a[i]][0] += 1\n    D[a[i]].append(i)\n(pl, pr) = (0, 0)\nfor i in D:\n    if D[i][0] == 2:\n        pl = D[i][1]\n        pr = D[i][2]\n        break\nL = pl\nM = (pr - pl) + 1\nN = n - pr\nmod = int(1000000000.0) + 7\nmaxf = n + 11\ndef make_fact(n, k):\n    tmp = n\n    perm = [i for i in range(k)]\n    L = [0 for _ in range(k)]\n    for i in range(k):\n        L[i] = tmp % (i + 1)\n        tmp //= i + 1\n    LL = [0 for _ in range(k)]\n    for i in range(k):\n        LL[i] = perm[L[(-i) - 1]]\n        for j in range(L[(-i) - 1] + 1, k):\n            perm[j - 1] = perm[j]\n    return LL\ndef doubling(n, m, modulo=mod):\n    y = 1\n    base = n\n    tmp = m\n    while tmp != 0:\n        if tmp % 2 == 1:\n            y *= base\n            if modulo > 0:\n                y %= modulo\n        base *= base\n        if modulo > 0:\n            base %= modulo\n        tmp //= 2\n    return y\ndef inved(a, modulo=mod):\n    (x, y, u, v, k, l) = (1, 0, 0, 1, a, modulo)\n    while l != 0:\n        (x, y, u, v) = (u, v, x - (u * (k // l)), y - (v * (k // l)))\n        (k, l) = (l, k % l)\n    return x % modulo\nfact = [1 for _ in range(maxf + 1)]\ninvf = [1 for _ in range(maxf + 1)]\nfor i in range(maxf):\n    fact[i + 1] = (fact[i] * (i + 1)) % mod\ninvf[-1] = inved(fact[-1])\nfor i in range(maxf, 0, -1):\n    invf[i - 1] = (invf[i] * i) % mod\nfor i in range(1, n + 2):\n    S = ((fact[n] * invf[i - 1]) * invf[(n - i) + 1]) % mod\n    if i <= n - 1:\n        S += ((fact[n - 1] * invf[i]) * invf[(n - 1) - i]) % mod\n        S %= mod\n    if i <= n - M:\n        S -= ((fact[(n - 1) - M] * invf[i - 1]) * invf[(n - M) - i]) % mod\n        S %= mod\n    if i <= n:\n        S += ((fact[n - 1] * invf[i - 1]) * invf[n - i]) % mod\n        S %= mod\n    print(S)", "score": 0.0, "codebleu": 0.9968177209307976, "crystalbleu": 0.9970381230993312, "codebertscore": 1.0, "codescore": 0.9930237531661987, "surfaceSim": 0.999727965179543, "abs_surfaceSim_minus_score": 0.999727965179543}
{"golden_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "generated_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        pass\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "score": 0.0, "codebleu": 0.9809083980500957, "crystalbleu": 0.9791306644241836, "codebertscore": 0.99, "codescore": 0.9844121336936951, "surfaceSim": 0.966212063323311, "abs_surfaceSim_minus_score": 0.966212063323311}
{"golden_code": "from functools import lru_cache\nimport sys\nsys.setrecursionlimit(10 ** 7)\n\n@lru_cache(maxsize=None)\ndef check(l, r, n, k=1):t = (l + ('0' * k)) + r\n    e = (l + ('9' * k)) + r\n    if int(e) <= n:\n        return pow(10, k) + check(l, r, n, k + 1)\n    if int(t) <= n < int(e):\n        x = int(str(n)[1:-1])\n        if int(str(n)[-1]) < int(r):\n            x -= 1\n        return x + 1\n    if n < int(t):\n        return 0\ndef main():\n    n = int(eval(input()))\n    ret = 0\n    for x in range(1, n + 1):\n        if x % 10 == 0:\n            continue\n        s = str(x)\n        t = s[-1] + s[0]\n        if s[0] == s[-1]:\n            ret += 1\n        if int(t) <= n:\n            ret += 1\n        ret += check(s[-1], s[0], n, k=1)\n    print(ret)", "generated_code": "from functools import lru_cache\nimport sys\nsys.setrecursionlimit(10 ** 7)\n\n@lru_cache(maxsize=None)\ndef check(l, r, n, k=1):t = (l + ('0' * k)) + r\n    e = (l + ('9' * k)) + r\n    if int(e) <= n:\n        return pow(10, k) + check(l, r, n, k + 1)\n    if int(t) <= n < int(e):\n        x = int(str(n)[1:1])\n        if int(str(n)[-1]) < int(r):\n            x -= 1\n        return x + 1\n    if n < int(t):\n        return 0\ndef main():\n    n = int(eval(input()))\n    ret = 0\n    for x in range(1, n + 1):\n        if x % 10 == 0:\n            continue\n        s = str(x)\n        t = s[-1] + s[0]\n        if s[0] == s[-1]:\n            ret += 1\n        if int(t) <= n:\n            ret += 1\n        ret += check(s[-1], s[0], n, k=1)\n    print(ret)", "score": 0.0, "codebleu": 0.974206222213881, "crystalbleu": 0.9902168666916028, "codebertscore": 1.0, "codescore": 0.993760883808136, "surfaceSim": 0.499320652173913, "abs_surfaceSim_minus_score": 0.499320652173913}
{"golden_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "generated_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\npass\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "score": 0.0, "codebleu": 0.9325347659060501, "crystalbleu": 0.9745941460851727, "codebertscore": 1.0, "codescore": 0.9938517808914185, "surfaceSim": 0.9781587933978373, "abs_surfaceSim_minus_score": 0.9781587933978373}
{"golden_code": "icase = 0\nif icase == 0:\n    (n, m) = list(map(int, input().split()))\n    a = []\n    b = []\n    for i in range(m):\n        (ai, bi) = list(map(int, input().split()))\n        a.append(ai)\n        b.append(bi)\nelif icase == 1:\n    n = 6\n    m = 5\n    a = [1, 2, 3, 4, 5]\n    b = [2, 3, 4, 5, 6]\nelif icase == 2:\n    n = 7\n    m = 7\n    a = [1, 2, 3, 4, 4, 5, 6]\n    b = [3, 7, 4, 5, 6, 6, 7]\nvtx = []\nfor i in range(n):\n    vtx.append([i + 1])\nicnt = 0\nfor j in range(m):\n    vtx1 = vtx.copy()\n    a1 = a.copy()\n    b1 = b.copy()\n    del a1[j]\n    del b1[j]\n    for i in range(m - 1):\n        for v1 in vtx1:\n            if a1[i] in v1:\n                if not (b1[i] in v1):\n                    for v2 in vtx1:\n                        if v1 != v2:\n                            if b1[i] in v2:\n                                break\n                    vtx1.remove(v1)\n                    vtx1.remove(v2)\n                    v3 = v1 + v2\n                    vtx1.append(v3)\n    if len(vtx1) != 1:\n        icnt = icnt + 1\nprint(icnt)", "generated_code": "icase = 0\nif not (icase == 0):\n    (n, m) = list(map(int, input().split()))\n    a = []\n    b = []\n    for i in range(m):\n        (ai, bi) = list(map(int, input().split()))\n        a.append(ai)\n        b.append(bi)\nelif icase == 1:\n    n = 6\n    m = 5\n    a = [1, 2, 3, 4, 5]\n    b = [2, 3, 4, 5, 6]\nelif icase == 2:\n    n = 7\n    m = 7\n    a = [1, 2, 3, 4, 4, 5, 6]\n    b = [3, 7, 4, 5, 6, 6, 7]\nvtx = []\nfor i in range(n):\n    vtx.append([i + 1])\nicnt = 0\nfor j in range(m):\n    vtx1 = vtx.copy()\n    a1 = a.copy()\n    b1 = b.copy()\n    del a1[j]\n    del b1[j]\n    for i in range(m - 1):\n        for v1 in vtx1:\n            if a1[i] in v1:\n                if not (b1[i] in v1):\n                    for v2 in vtx1:\n                        if v1 != v2:\n                            if b1[i] in v2:\n                                break\n                    vtx1.remove(v1)\n                    vtx1.remove(v2)\n                    v3 = v1 + v2\n                    vtx1.append(v3)\n    if len(vtx1) != 1:\n        icnt = icnt + 1\nprint(icnt)", "score": 0.0, "codebleu": 0.9823820026329587, "crystalbleu": 0.9781595820946176, "codebertscore": 1.0, "codescore": 0.9937655925750732, "surfaceSim": 0.9975798644724105, "abs_surfaceSim_minus_score": 0.9975798644724105}
{"golden_code": "import sys\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\ndef solve():\n    inf = (10 ** 14) + 10\n    def dfs(v: 'vertex_index, 0-indexed') -> None:\n        for (c, t) in e[v]:\n            if d[t] != inf:\n                continue\n            d[t] = d[v] + c\n            dfs(t)\n    n = int(eval(input()))\n    e = tuple((set() for _ in range(n)))\n    for _ in range(n - 1):\n        (a, b, c) = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        e[a].add((c, b))\n        e[b].add((c, a))\n    (q, v) = list(map(int, input().split()))\n    v -= 1\n    d = [inf] * n\n    d[v] = 0\n    dfs(v)\n    for _ in range(q):\n        (x, y) = list(map(int, input().split()))\n        x -= 1\n        y -= 1\n        print(d[x] + d[y])", "generated_code": "import sys\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\ndef solve():\n    inf = (10 ** 14) + 10\n    def dfs(v: 'vertex_index, 0-indexed') -> None:\n        for (c, t) in e[v]:\n            if d[t] != inf:\n                continue\n            d[t] = d[v] + c\n            dfs(t)\n    n = int(eval(input()))\n    e = tuple((set() for _ in range(n)))\n    for _ in range(n - 1):\n        (a, b, c) = list(map(int, input().split()))\n        a += 1\n        b -= 1\n        e[a].add((c, b))\n        e[b].add((c, a))\n    (q, v) = list(map(int, input().split()))\n    v -= 1\n    d = [inf] * n\n    d[v] = 0\n    dfs(v)\n    for _ in range(q):\n        (x, y) = list(map(int, input().split()))\n        x -= 1\n        y -= 1\n        print(d[x] + d[y])", "score": 0.0, "codebleu": 0.9881398574370538, "crystalbleu": 0.9908145599351913, "codebertscore": 1.0, "codescore": 0.9938092827796936, "surfaceSim": 0.9993243243243244, "abs_surfaceSim_minus_score": 0.9993243243243244}
{"golden_code": "def popcount(x):\n    x = x - ((x >> 1) & 1431655765)\n    x = (x & 858993459) + ((x >> 2) & 858993459)\n    x = (x + (x >> 4)) & 252645135\n    x = x + (x >> 8)\n    x = x + (x >> 16)\n    return x & 127\ncmb = [[0 for i in range(51)] for j in range(51)]\ncmb[0][0] = 1\nfor i in range(51):\n    for j in range(51):\n        if (i != 50 and j != 50):\n            cmb[i + 1][j + 1] += cmb[i][j]\n        if i != 50:\n            cmb[i + 1][j] += cmb[i][j]\nfor i in range(1, 51):\n    for j in range(2, 51):\n        cmb[i][j] += cmb[i][j - 1]\n(N, K, T, S) = list(map(int, input().split()))\na = list(map(int, input().split()))\nmust0 = [i for i in range(18) if (S >> i) & 1 == 0]\nmust1 = [i for i in range(18) if (T >> i) & 1 == 1]\nA = []\nfor val in a:\n    check = True\n    for j in must0:\n        check = check & (val >> j) & 1 == 0\n    for j in must1:\n        check = check & (val >> j) & 1 == 1\n    if check:\n        A.append(val)\nif not A:\n    print(0)\n    exit()\nbit = []\nfor i in range(18):\n    if (i not in must0 and i not in must1):\n        bit.append(i)\nfor i in range(len(A)):\n    temp = 0\n    for j in range(len(bit)):\n        temp += (A[i] >> bit[j]) & 1 == 1 * (2 ** j)\n    A[i] = temp\nans = 0\nn = len(bit)\ndata = [0] * (2 ** n)\nfor i in range(2 ** n):\n    t = set([])\n    for a in A:\n        data[a & i] += 1\n        t.add(a & i)\n    temp = 0\n    for val in t:\n        temp += cmb[data[val]][min(K, data[val])]\n    ans += temp * ((-1) ** popcount(i))\n    for val in t:\n        data[val] = 0\nprint(ans)", "generated_code": "def popcount(x):\n    x = x - ((x >> 1) & 1431655765)\n    x = (x & 858993459) + ((x >> 2) & 858993459)\n    x = (x + (x >> 4)) & 252645135\n    x = x + (x >> 8)\n    x = x + (x >> 16)\n    return x & 127\ncmb = [[0 for i in range(51)] for j in range(51)]\ncmb[0][0] = 1\nfor i in range(51):\n    for j in range(51):\n        if (i != 50 and j != 50):\n            cmb[i + 1][j + 1] += cmb[i][j]\n        if i != 50:\n            cmb[i + 1][j] += cmb[i][j]\nfor i in range(1, 51):\n    for j in range(2, 51):\n        cmb[i][j] += cmb[i][j - 1]\n(N, K, T, S) = list(map(int, input().split()))\na = list(map(int, input().split()))\nmust0 = [i for i in range(18) if (S >> i) & 1 == 0]\nmust1 = [i for i in range(18) if (T >> i) & 1 == 1]\nA = []\nfor val in a:\n    pass\n    for j in must0:\n        check = check & (val >> j) & 1 == 0\n    for j in must1:\n        check = check & (val >> j) & 1 == 1\n    if check:\n        A.append(val)\nif not A:\n    print(0)\n    exit()\nbit = []\nfor i in range(18):\n    if (i not in must0 and i not in must1):\n        bit.append(i)\nfor i in range(len(A)):\n    temp = 0\n    for j in range(len(bit)):\n        temp += (A[i] >> bit[j]) & 1 == 1 * (2 ** j)\n    A[i] = temp\nans = 0\nn = len(bit)\ndata = [0] * (2 ** n)\nfor i in range(2 ** n):\n    t = set([])\n    for a in A:\n        data[a & i] += 1\n        t.add(a & i)\n    temp = 0\n    for val in t:\n        temp += cmb[data[val]][min(K, data[val])]\n    ans += temp * ((-1) ** popcount(i))\n    for val in t:\n        data[val] = 0\nprint(ans)", "score": 0.0, "codebleu": 0.9518440560589566, "crystalbleu": 0.9898085097984597, "codebertscore": 1.0, "codescore": 0.9936519861221313, "surfaceSim": 0.9838417034678717, "abs_surfaceSim_minus_score": 0.9838417034678717}
{"golden_code": "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nMOD = (10 ** 9) + 7\nfac = [1, 1]\nf_inv = [1, 1]\ninv = [0, 1]\ndef prepare(n, mod):\n    for i in range(2, n + 1):\n        fac.append((fac[-1] * i) % mod)\n        inv.append(((-(inv[mod % i])) * (mod // i)) % mod)\n        f_inv.append((f_inv[-1] * inv[-1]) % mod)\ndef cmb(n, r, mod):\n    if (n < 0 or r < 0):\n        return 0\n    if r > n:\n        return 0\n    return ((fac[n] * f_inv[r]) * f_inv[n - r]) % mod\ndef prime_factorization(n):\n    d = []\n    (i, e) = (2, 0)\n    while i * i <= n:\n        while n % i == 0:\n            n //= i\n            e += 1\n        if e > 0:\n            d.append((i, e))\n        i += 1\n        e = 0\n    if n > 1:\n        d.append((n, 1))\n    return d\ndef main():\n    (N, M) = list(map(int, readline().split()))\n    prepare(N + 100, MOD)\n    d = prime_factorization(M)\n    ans = 1\n    for (i, e) in d:\n        ans *= cmb((N - 1) + e, e, MOD)\n        ans %= MOD\n    print(ans)", "generated_code": "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nMOD = (10 ** 9) + 7\nfac = [1, 1]\nf_inv = [1, 1]\ninv = [0, 1]\ndef prepare(n, mod):\n    for i in range(2, n - 1):\n        fac.append((fac[-1] * i) % mod)\n        inv.append(((-(inv[mod % i])) * (mod // i)) % mod)\n        f_inv.append((f_inv[-1] * inv[-1]) % mod)\ndef cmb(n, r, mod):\n    if (n < 0 or r < 0):\n        return 0\n    if r > n:\n        return 0\n    return ((fac[n] * f_inv[r]) * f_inv[n - r]) % mod\ndef prime_factorization(n):\n    d = []\n    (i, e) = (2, 0)\n    while i * i <= n:\n        while n % i == 0:\n            n //= i\n            e += 1\n        if e > 0:\n            d.append((i, e))\n        i += 1\n        e = 0\n    if n > 1:\n        d.append((n, 1))\n    return d\ndef main():\n    (N, M) = list(map(int, readline().split()))\n    prepare(N + 100, MOD)\n    d = prime_factorization(M)\n    ans = 1\n    for (i, e) in d:\n        ans *= cmb((N - 1) + e, e, MOD)\n        ans %= MOD\n    print(ans)", "score": 0.0, "codebleu": 0.9927498121985038, "crystalbleu": 0.9939262964720614, "codebertscore": 1.0, "codescore": 0.9937418103218079, "surfaceSim": 0.9995, "abs_surfaceSim_minus_score": 0.9995}
{"golden_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "generated_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    pass\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "score": 0.0, "codebleu": 0.9713652555258335, "crystalbleu": 0.961069216625579, "codebertscore": 0.98, "codescore": 0.9867963790893555, "surfaceSim": 0.9795636023651892, "abs_surfaceSim_minus_score": 0.9795636023651892}
{"golden_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "generated_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] / (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "score": 0.0, "codebleu": 0.9950293033173805, "crystalbleu": 0.9957523162081054, "codebertscore": 1.0, "codescore": 0.9863813519477844, "surfaceSim": 0.9861791724115019, "abs_surfaceSim_minus_score": 0.9861791724115019}
{"golden_code": "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nMOD = (10 ** 9) + 7\nfac = [1, 1]\nf_inv = [1, 1]\ninv = [0, 1]\ndef prepare(n, mod):\n    for i in range(2, n + 1):\n        fac.append((fac[-1] * i) % mod)\n        inv.append(((-(inv[mod % i])) * (mod // i)) % mod)\n        f_inv.append((f_inv[-1] * inv[-1]) % mod)\ndef cmb(n, r, mod):\n    if (n < 0 or r < 0):\n        return 0\n    if r > n:\n        return 0\n    return ((fac[n] * f_inv[r]) * f_inv[n - r]) % mod\ndef prime_factorization(n):\n    d = []\n    (i, e) = (2, 0)\n    while i * i <= n:\n        while n % i == 0:\n            n //= i\n            e += 1\n        if e > 0:\n            d.append((i, e))\n        i += 1\n        e = 0\n    if n > 1:\n        d.append((n, 1))\n    return d\ndef main():\n    (N, M) = list(map(int, readline().split()))\n    prepare(N + 100, MOD)\n    d = prime_factorization(M)\n    ans = 1\n    for (i, e) in d:\n        ans *= cmb((N - 1) + e, e, MOD)\n        ans %= MOD\n    print(ans)", "generated_code": "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nMOD = (10 ** 9) + 7\nfac = [1, 1]\nf_inv = [1, 1]\ninv = [0, 1]\ndef prepare(n, mod):\n    for i in range(2, n + 1):\n        fac.append((fac[-1] * i) % mod)\n        inv.append(((-(inv[mod % i])) * (mod // i)) % mod)\n        f_inv.append((f_inv[1] * inv[-1]) % mod)\ndef cmb(n, r, mod):\n    if (n < 0 or r < 0):\n        return 0\n    if r > n:\n        return 0\n    return ((fac[n] * f_inv[r]) * f_inv[n - r]) % mod\ndef prime_factorization(n):\n    d = []\n    (i, e) = (2, 0)\n    while i * i <= n:\n        while n % i == 0:\n            n //= i\n            e += 1\n        if e > 0:\n            d.append((i, e))\n        i += 1\n        e = 0\n    if n > 1:\n        d.append((n, 1))\n    return d\ndef main():\n    (N, M) = list(map(int, readline().split()))\n    prepare(N + 100, MOD)\n    d = prime_factorization(M)\n    ans = 1\n    for (i, e) in d:\n        ans *= cmb((N - 1) + e, e, MOD)\n        ans %= MOD\n    print(ans)", "score": 0.0, "codebleu": 0.9773003739962566, "crystalbleu": 0.9925590734875005, "codebertscore": 1.0, "codescore": 0.9937410950660706, "surfaceSim": 0.9995, "abs_surfaceSim_minus_score": 0.9995}
{"golden_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "generated_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 / i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "score": 0.0, "codebleu": 0.9963221036285097, "crystalbleu": 0.9937377563162054, "codebertscore": 1.0, "codescore": 0.9849729537963867, "surfaceSim": 0.9890647900136453, "abs_surfaceSim_minus_score": 0.9890647900136453}
{"golden_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "generated_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "score": 0.0, "codebleu": 1.0, "crystalbleu": 1.0, "codebertscore": 1.0, "codescore": 0.9938294291496277, "surfaceSim": 1.0, "abs_surfaceSim_minus_score": 1.0}
{"golden_code": "def popcount(x):\n    x = x - ((x >> 1) & 1431655765)\n    x = (x & 858993459) + ((x >> 2) & 858993459)\n    x = (x + (x >> 4)) & 252645135\n    x = x + (x >> 8)\n    x = x + (x >> 16)\n    return x & 127\ncmb = [[0 for i in range(51)] for j in range(51)]\ncmb[0][0] = 1\nfor i in range(51):\n    for j in range(51):\n        if (i != 50 and j != 50):\n            cmb[i + 1][j + 1] += cmb[i][j]\n        if i != 50:\n            cmb[i + 1][j] += cmb[i][j]\nfor i in range(1, 51):\n    for j in range(2, 51):\n        cmb[i][j] += cmb[i][j - 1]\n(N, K, T, S) = list(map(int, input().split()))\na = list(map(int, input().split()))\nmust0 = [i for i in range(18) if (S >> i) & 1 == 0]\nmust1 = [i for i in range(18) if (T >> i) & 1 == 1]\nA = []\nfor val in a:\n    check = True\n    for j in must0:\n        check = check & (val >> j) & 1 == 0\n    for j in must1:\n        check = check & (val >> j) & 1 == 1\n    if check:\n        A.append(val)\nif not A:\n    print(0)\n    exit()\nbit = []\nfor i in range(18):\n    if (i not in must0 and i not in must1):\n        bit.append(i)\nfor i in range(len(A)):\n    temp = 0\n    for j in range(len(bit)):\n        temp += (A[i] >> bit[j]) & 1 == 1 * (2 ** j)\n    A[i] = temp\nans = 0\nn = len(bit)\ndata = [0] * (2 ** n)\nfor i in range(2 ** n):\n    t = set([])\n    for a in A:\n        data[a & i] += 1\n        t.add(a & i)\n    temp = 0\n    for val in t:\n        temp += cmb[data[val]][min(K, data[val])]\n    ans += temp * ((-1) ** popcount(i))\n    for val in t:\n        data[val] = 0\nprint(ans)", "generated_code": "def popcount(x):\n    x = x - ((x >> 1) & 1431655765)\n    x = (x & 858993459) + ((x >> 2) & 858993459)\n    x = (x + (x >> 4)) & 252645135\n    x = x + (x >> 8)\n    x = x + (x >> 16)\n    return x & 127\ncmb = [[0 for i in range(51)] for j in range(51)]\ncmb[0][0] = 1\nfor i in range(51):\n    for j in range(51):\n        if (i == 50 and j != 50):\n            cmb[i + 1][j + 1] += cmb[i][j]\n        if i != 50:\n            cmb[i + 1][j] += cmb[i][j]\nfor i in range(1, 51):\n    for j in range(2, 51):\n        cmb[i][j] += cmb[i][j - 1]\n(N, K, T, S) = list(map(int, input().split()))\na = list(map(int, input().split()))\nmust0 = [i for i in range(18) if (S >> i) & 1 == 0]\nmust1 = [i for i in range(18) if (T >> i) & 1 == 1]\nA = []\nfor val in a:\n    check = True\n    for j in must0:\n        check = check & (val >> j) & 1 == 0\n    for j in must1:\n        check = check & (val >> j) & 1 == 1\n    if check:\n        A.append(val)\nif not A:\n    print(0)\n    exit()\nbit = []\nfor i in range(18):\n    if (i not in must0 and i not in must1):\n        bit.append(i)\nfor i in range(len(A)):\n    temp = 0\n    for j in range(len(bit)):\n        temp += (A[i] >> bit[j]) & 1 == 1 * (2 ** j)\n    A[i] = temp\nans = 0\nn = len(bit)\ndata = [0] * (2 ** n)\nfor i in range(2 ** n):\n    t = set([])\n    for a in A:\n        data[a & i] += 1\n        t.add(a & i)\n    temp = 0\n    for val in t:\n        temp += cmb[data[val]][min(K, data[val])]\n    ans += temp * ((-1) ** popcount(i))\n    for val in t:\n        data[val] = 0\nprint(ans)", "score": 0.0, "codebleu": 0.995941382850743, "crystalbleu": 0.9932103550789324, "codebertscore": 1.0, "codescore": 0.9936527013778687, "surfaceSim": 0.9996662216288384, "abs_surfaceSim_minus_score": 0.9996662216288384}
{"golden_code": "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nMOD = (10 ** 9) + 7\nfac = [1, 1]\nf_inv = [1, 1]\ninv = [0, 1]\ndef prepare(n, mod):\n    for i in range(2, n + 1):\n        fac.append((fac[-1] * i) % mod)\n        inv.append(((-(inv[mod % i])) * (mod // i)) % mod)\n        f_inv.append((f_inv[-1] * inv[-1]) % mod)\ndef cmb(n, r, mod):\n    if (n < 0 or r < 0):\n        return 0\n    if r > n:\n        return 0\n    return ((fac[n] * f_inv[r]) * f_inv[n - r]) % mod\ndef prime_factorization(n):\n    d = []\n    (i, e) = (2, 0)\n    while i * i <= n:\n        while n % i == 0:\n            n //= i\n            e += 1\n        if e > 0:\n            d.append((i, e))\n        i += 1\n        e = 0\n    if n > 1:\n        d.append((n, 1))\n    return d\ndef main():\n    (N, M) = list(map(int, readline().split()))\n    prepare(N + 100, MOD)\n    d = prime_factorization(M)\n    ans = 1\n    for (i, e) in d:\n        ans *= cmb((N - 1) + e, e, MOD)\n        ans %= MOD\n    print(ans)", "generated_code": "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nMOD = (10 ** 9) + 7\nfac = [1, 1]\nf_inv = [1, 1]\ninv = [0, 1]\ndef prepare(n, mod):\n    for i in range(2, n + 1):\n        fac.append((fac[-1] * i) % mod)\n        inv.append(((-(inv[mod % i])) * (mod // i)) % mod)\n        f_inv.append((f_inv[-1] * inv[1]) % mod)\ndef cmb(n, r, mod):\n    if (n < 0 or r < 0):\n        return 0\n    if r > n:\n        return 0\n    return ((fac[n] * f_inv[r]) * f_inv[n - r]) % mod\ndef prime_factorization(n):\n    d = []\n    (i, e) = (2, 0)\n    while i * i <= n:\n        while n % i == 0:\n            n //= i\n            e += 1\n        if e > 0:\n            d.append((i, e))\n        i += 1\n        e = 0\n    if n > 1:\n        d.append((n, 1))\n    return d\ndef main():\n    (N, M) = list(map(int, readline().split()))\n    prepare(N + 100, MOD)\n    d = prime_factorization(M)\n    ans = 1\n    for (i, e) in d:\n        ans *= cmb((N - 1) + e, e, MOD)\n        ans %= MOD\n    print(ans)", "score": 0.0, "codebleu": 0.9773003739962566, "crystalbleu": 0.9925590734875005, "codebertscore": 1.0, "codescore": 0.9937410950660706, "surfaceSim": 0.9995, "abs_surfaceSim_minus_score": 0.9995}
{"golden_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "generated_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n *= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "score": 0.0, "codebleu": 0.9890842515292805, "crystalbleu": 0.9833305421636559, "codebertscore": 1.0, "codescore": 0.9938451647758484, "surfaceSim": 0.9636217036615443, "abs_surfaceSim_minus_score": 0.9636217036615443}
{"golden_code": "import math, sys\nn = int(sys.stdin.readline())\na = tuple(map(int, sys.stdin.readline().split()))\ng = math.gcd(a[0], a[1])\nfor i in range(2, n):\n    g = math.gcd(g, a[i])\nM = max(a)\nacc = a[0]\nfor i in range(n):\n    acc = math.gcd(acc, a[i])\nif acc != 1:\n    print('not coprime')\n    exit()\nLIMIT = max(a)\nminPrime = [0] * (LIMIT + 1)\nminPrime[1] = 1\ndef make():\n    for i in range(2, LIMIT + 1):\n        if minPrime[i] == 0:\n            minPrime[i] = i\n            for j in range(i + i, LIMIT + 1, i):\n                if minPrime[j] == 0:\n                    minPrime[j] = i\nmake()\ndef factrial(N):\n    ret = []\n    while minPrime[N] != N:\n        ret.append(minPrime[N])\n        N = N // minPrime[N]\n    if N != 1:\n        ret.append(N)\n    return ret\njudge = set([])\npc = True\npairwise = True\np = set()\nfor e in a:\n    if not pairwise:\n        break\n    asf = set(factrial(e))\n    if judge & asf != set():\n        pc = False\n    judge |= asf\nif pc:\n    print('pairwise coprime')\nelif g == 1:\n    print('setwise coprime')\nelse:\n    print('not coprime')", "generated_code": "import math, sys\nn = int(sys.stdin.readline())\na = tuple(map(int, sys.stdin.readline().split()))\ng = math.gcd(a[0], a[1])\nfor i in range(2, n):\n    g = math.gcd(g, a[i])\nM = max(a)\nacc = a[0]\nfor i in range(n):\n    acc = math.gcd(acc, a[i])\nif acc != 1:\n    print('not coprime')\n    exit()\nLIMIT = max(a)\nminPrime = [0] * (LIMIT + 1)\nminPrime[1] = 1\ndef make():\n    for i in range(2, LIMIT + 1):\n        if minPrime[i] == 0:\n            minPrime[i] = i\n            for j in range(i + i, LIMIT + 1, i):\n                if minPrime[j] == 0:\n                    minPrime[j] = i\nmake()\ndef factrial(N):\n    ret = []\n    while minPrime[N] != N:\n        ret.append(minPrime[N])\n        N = N // minPrime[N]\n    if N != 1:\n        ret.append(N)\n    return ret\njudge = set([])\npc = True\npairwise = True\np = set()\nfor e in a:\n    if not pairwise:\n        break\n    asf = set(factrial(e))\n    if judge & asf != set():\n        pc = False\n    judge |= asf\n    break\nif pc:\n    print('pairwise coprime')elif g == 1:\n    print('setwise coprime')\nelse:\n    print('not coprime')", "score": 0.0, "codebleu": 0.9695590696930568, "crystalbleu": 0.9890192409220128, "codebertscore": 1.0, "codescore": 0.9937317967414856, "surfaceSim": 0.4967043314500942, "abs_surfaceSim_minus_score": 0.4967043314500942}
{"golden_code": "import queue\nINF = 123456789\ndef main():\n    (n, m) = list(map(int, input().split()))\n    G = [[] for _ in range(n)]\n    for _ in range(m):\n        (a, b, c) = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        G[a].append((b, c))\n        G[b].append((a, c))\n    used = set()\n    for i in range(n):\n        d = [INF for _ in range(n)]\n        par = [-1 for _ in range(n)]\n        que = queue.PriorityQueue()\n        d[i] = 0\n        que.put((0, i))\n        while not (que.empty()):\n            p = que.get()\n            v = p[1]\n            if d[v] < p[0]:\n                continue\n            for (to, cost) in G[v]:\n                if d[to] > d[v] + cost:\n                    d[to] = d[v] + cost\n                    par[to] = v\n                    que.put((d[to], to))\n        for j in range(n):\n            if i != j:\n                (a, b) = (j, par[j])\n                if a > b:\n                    (a, b) = (b, a)\n                used.add((a, b))\n    print(m - len(used))", "generated_code": "import queue\nINF = 123456789\ndef main():\n    (n, m) = list(map(int, input().split()))\n    G = [[] for _ in range(n)]\n    for _ in range(m):\n        (a, b, c) = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        G[a].append((b, c))\n        G[b].append((a, c))\n    used = set()\n    for i in range(n):\n        d = [INF for _ in range(n)]\n        par = [-1 for _ in range(n)]\n        que = queue.PriorityQueue()\n        d[i] = 0\n        que.put((0, i))\n        while not (que.empty()):\n            p = que.get()\n            v = p[1]\n            if d[v] < p[0]:\n                continue\n            for (to, cost) in G[v]:\n                if d[to] > d[v] + cost:\n                    d[to] = d[v] - cost\n                    par[to] = v\n                    que.put((d[to], to))\n        for j in range(n):\n            if i != j:\n                (a, b) = (j, par[j])\n                if a > b:\n                    (a, b) = (b, a)\n                used.add((a, b))\n    print(m - len(used))", "score": 0.0, "codebleu": 0.9904103276685203, "crystalbleu": 0.99196049219345, "codebertscore": 1.0, "codescore": 0.9937876462936401, "surfaceSim": 0.9994979919678715, "abs_surfaceSim_minus_score": 0.9994979919678715}
{"golden_code": "import sys\n(n, m, *abcdef) = list(map(int, sys.stdin.buffer.read().split()))\nver_lines = []\nhor_lines = []\nx_list = set()\ny_list = set()\nn3 = n * 3\nfor (a, b, c) in zip(abcdef[0:n3:3], abcdef[1:n3:3], abcdef[2:n3:3]):\n    y_list.add(a)\n    y_list.add(b)\n    x_list.add(c)\n    ver_lines.append((a, b, c))\nfor (d, e, f) in zip(abcdef[n3 + 0::3], abcdef[n3 + 1::3], abcdef[n3 + 2::3]):\n    y_list.add(d)\n    x_list.add(e)\n    x_list.add(f)\n    hor_lines.append((d, e, f))\nx_list.add(0)\ny_list.add(0)\nx_list = sorted(x_list)\ny_list = sorted(y_list)\nx_dict = {x: i for (i, x) in enumerate(x_list, start=1)}\ny_dict = {y: i for (i, y) in enumerate(y_list, start=1)}\nrow_real = len(x_list)\ncol_real = len(y_list)\nrow = row_real + 2\ncol = col_real + 2\nbanned_up_ij = [[0] * row for _ in range(col)]\nbanned_down_ij = [[0] * row for _ in range(col)]\nbanned_left_ij = [[0] * col for _ in range(row)]\nbanned_right_ij = [[0] * col for _ in range(row)]\nfor (a, b, c) in ver_lines:\n    if a > b:\n        (a, b) = (b, a)\n    ai = y_dict[a]\n    bi = y_dict[b]\n    j = x_dict[c]\n    banned_left_ij[j][ai] += 1\n    banned_left_ij[j][bi] -= 1\n    banned_right_ij[j - 1][ai] += 1\n    banned_right_ij[j - 1][bi] -= 1\nfor (d, e, f) in hor_lines:\n    if e > f:\n        (e, f) = (f, e)\n    i = y_dict[d]\n    ej = x_dict[e]\n    fj = x_dict[f]\n    banned_up_ij[i][ej] += 1\n    banned_up_ij[i][fj] -= 1\n    banned_down_ij[i - 1][ej] += 1\n    banned_down_ij[i - 1][fj] -= 1\nbanned_up = [0] * (row * col)\nbanned_down = [0] * (row * col)\nbanned_left = [0] * (row * col)\nbanned_right = [0] * (row * col)\nfor i in range(col):\n    ru = banned_up_ij[i]\n    rd = banned_down_ij[i]\n    ri = row * i\n    banned_up[ri] = ru[0]\n    banned_down[ri] = rd[0]\n    for j in range(1, row):\n        banned_up[ri + j] = banned_up[(ri + j) - 1] + ru[j]\n        banned_down[ri + j] = banned_down[(ri + j) - 1] + rd[j]\nfor j in range(row):\n    rl = banned_left_ij[j]\n    rr = banned_right_ij[j]\n    banned_left[j] = rl[0]\n    banned_right[j] = rr[0]\n    for i in range(1, col):\n        ri0 = (i - 1) * row\n        ri1 = i * row\n        banned_left[ri1 + j] = banned_left[ri0 + j] + rl[i]\n        banned_right[ri1 + j] = banned_right[ri0 + j] + rr[i]\ns = (row * y_dict[0]) + x_dict[0]\nenable = (([-1] * row) + ((([-1] + ([0] * (row - 2))) + [-1]) * (col - 2))) + ([-1] * row)\nq = [s]\nmoves = [(-row, banned_up), (-1, banned_left), (1, banned_right), (row, banned_down)]\nwhile q:\n    c = q.pop()\n    if enable[c] == 1:\n        continue\n    elif enable[c] == -1:\n        print('INF')\n        exit()\n    enable[c] = 1\n    for (dc, banned) in moves:\n        if banned[c]:\n            continue\n        nc = c + dc\n        if enable[nc] == 1:\n            continue\n        q.append(nc)\nans = 0\nfor i in range(col):\n    ri = i * row\n    for j in range(row):\n        if enable[ri + j] != 1:\n            continue\n        t = y_list[i - 1]\n        b = y_list[i]\n        l = x_list[j - 1]\n        r = x_list[j]\n        ans += (b - t) * (r - l)\nprint(ans)", "generated_code": "import sys\n(n, m, *abcdef) = list(map(int, sys.stdin.buffer.read().split()))\nver_lines = []\nhor_lines = []\nx_list = set()\ny_list = set()\nn3 = n * 3\nfor (a, b, c) in zip(abcdef[0:n3:3], abcdef[1:n3:3], abcdef[2:n3:3]):\n    y_list.add(a)\n    y_list.add(b)\n    x_list.add(c)\n    ver_lines.append((a, b, c))\nfor (d, e, f) in zip(abcdef[n3 + 0::3], abcdef[n3 + 1::3], abcdef[n3 + 2::3]):\n    y_list.add(d)\n    x_list.add(e)\n    x_list.add(f)\n    hor_lines.append((d, e, f))\nx_list.add(0)\ny_list.add(0)\nx_list = sorted(x_list)\ny_list = sorted(y_list)\nx_dict = {x: i for (i, x) in enumerate(x_list, start=1)}\ny_dict = {y: i for (i, y) in enumerate(y_list, start=1)}\nrow_real = len(x_list)\ncol_real = len(y_list)\nrow = row_real + 2\ncol = col_real + 2\nbanned_up_ij = [[0] * row for _ in range(col)]\nbanned_down_ij = [[0] * row for _ in range(col)]\nbanned_left_ij = [[0] * col for _ in range(row)]\nbanned_right_ij = [[0] * col for _ in range(row)]\nfor (a, b, c) in ver_lines:\n    if a > b:\n        (a, b) = (b, a)\n    ai = y_dict[a]\n    bi = y_dict[b]\n    j = x_dict[c]\n    banned_left_ij[j][ai] += 1\n    banned_left_ij[j][bi] -= 1\n    banned_right_ij[j - 1][ai] += 1\n    banned_right_ij[j - 1][bi] -= 1\nfor (d, e, f) in hor_lines:\n    if e > f:\n        (e, f) = (f, e)\n    i = y_dict[d]\n    ej = x_dict[e]\n    fj = x_dict[f]\n    banned_up_ij[i][ej] += 1\n    banned_up_ij[i][fj] -= 1\n    banned_down_ij[i - 1][ej] += 1\n    banned_down_ij[i - 1][fj] -= 1\nbanned_up = [0] * (row * col)\nbanned_down = [0] * (row * col)\nbanned_left = [0] * (row * col)\nbanned_right = [0] * (row * col)\nfor i in range(col):\n    ru = banned_up_ij[i]\n    rd = banned_down_ij[i]\n    ri = row * i\n    banned_up[ri] = ru[0]\n    banned_down[ri] = rd[0]\n    for j in range(1, row):\n        banned_up[ri + j] = banned_up[(ri + j) - 1] + ru[j]\n        banned_down[ri + j] = banned_down[(ri + j) - 1] + rd[j]\nfor j in range(row):\n    rl = banned_left_ij[j]\n    rr = banned_right_ij[j]\n    banned_left[j] = rl[0]\n    banned_right[j] = rr[0]\n    for i in range(1, col):\n        ri0 = (i - 1) * row\n        ri1 = i * row\n        banned_left[ri1 + j] = banned_left[ri0 + j] + rl[i]\n        banned_right[ri1 + j] = banned_right[ri0 + j] + rr[i]\ns = (row * y_dict[0]) + x_dict[0]\nenable = (([-1] * row) + ((([-1] + ([0] * (row - 2))) + [-1]) * (col - 2))) + ([-1] * row)\nq = [s]\nmoves = [(-row, banned_up), (-1, banned_left), (1, banned_right), (row, banned_down)]\nwhile q:\n    c = q.pop()\n    if enable[c] == 1:\n        continue\n    elif enable[c] == +1:\n        print('INF')\n        exit()\n    enable[c] = 1\n    for (dc, banned) in moves:\n        if banned[c]:\n            continue\n        nc = c + dc\n        if enable[nc] == 1:\n            continue\n        q.append(nc)\nans = 0\nfor i in range(col):\n    ri = i * row\n    for j in range(row):\n        if enable[ri + j] != 1:\n            continue\n        t = y_list[i - 1]\n        b = y_list[i]\n        l = x_list[j - 1]\n        r = x_list[j]\n        ans += (b - t) * (r - l)\nprint(ans)", "score": 0.0, "codebleu": 0.9973984967720897, "crystalbleu": 0.9976480355539619, "codebertscore": 1.0, "codescore": 0.9542334675788879, "surfaceSim": 0.9863192064597217, "abs_surfaceSim_minus_score": 0.9863192064597217}
{"golden_code": "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nMOD = (10 ** 9) + 7\nfac = [1, 1]\nf_inv = [1, 1]\ninv = [0, 1]\ndef prepare(n, mod):\n    for i in range(2, n + 1):\n        fac.append((fac[-1] * i) % mod)\n        inv.append(((-(inv[mod % i])) * (mod // i)) % mod)\n        f_inv.append((f_inv[-1] * inv[-1]) % mod)\ndef cmb(n, r, mod):\n    if (n < 0 or r < 0):\n        return 0\n    if r > n:\n        return 0\n    return ((fac[n] * f_inv[r]) * f_inv[n - r]) % mod\ndef prime_factorization(n):\n    d = []\n    (i, e) = (2, 0)\n    while i * i <= n:\n        while n % i == 0:\n            n //= i\n            e += 1\n        if e > 0:\n            d.append((i, e))\n        i += 1\n        e = 0\n    if n > 1:\n        d.append((n, 1))\n    return d\ndef main():\n    (N, M) = list(map(int, readline().split()))\n    prepare(N + 100, MOD)\n    d = prime_factorization(M)\n    ans = 1\n    for (i, e) in d:\n        ans *= cmb((N - 1) + e, e, MOD)\n        ans %= MOD\n    print(ans)", "generated_code": "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nMOD = (10 ** 9) + 7\nfac = [1, 1]\nf_inv = [1, 1]\ninv = [0, 1]\ndef prepare(n, mod):\n    for i in range(2, n + 1):\n        fac.append((fac[-1] * i) % mod)\n        inv.append((inv[mod % i] * (mod // i)) % mod)\n        f_inv.append((f_inv[-1] * inv[-1]) % mod)\ndef cmb(n, r, mod):\n    if (n < 0 or r < 0):\n        return 0\n    if r > n:\n        return 0\n    return ((fac[n] * f_inv[r]) * f_inv[n - r]) % mod\ndef prime_factorization(n):\n    d = []\n    (i, e) = (2, 0)\n    while i * i <= n:\n        while n % i == 0:\n            n //= i\n            e += 1\n        if e > 0:\n            d.append((i, e))\n        i += 1\n        e = 0\n    if n > 1:\n        d.append((n, 1))\n    return d\ndef main():\n    (N, M) = list(map(int, readline().split()))\n    prepare(N + 100, MOD)\n    d = prime_factorization(M)\n    ans = 1\n    for (i, e) in d:\n        ans *= cmb((N - 1) + e, e, MOD)\n        ans %= MOD\n    print(ans)", "score": 0.0, "codebleu": 0.9680526427541045, "crystalbleu": 0.9797480430335415, "codebertscore": 1.0, "codescore": 0.9938375353813171, "surfaceSim": 0.9975, "abs_surfaceSim_minus_score": 0.9975}
{"golden_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "generated_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] / (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "score": 0.0, "codebleu": 0.9963221036285097, "crystalbleu": 0.9937360383325433, "codebertscore": 1.0, "codescore": 0.9859631657600403, "surfaceSim": 0.9890647900136453, "abs_surfaceSim_minus_score": 0.9890647900136453}
{"golden_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "generated_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    pass\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "score": 0.0, "codebleu": 0.9706079767712754, "crystalbleu": 0.9791772187773387, "codebertscore": 0.99, "codescore": 0.987316906452179, "surfaceSim": 0.9837206598116248, "abs_surfaceSim_minus_score": 0.9837206598116248}
{"golden_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "generated_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\npass\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "score": 0.0, "codebleu": 0.9796651238402047, "crystalbleu": 0.9827316786143654, "codebertscore": 1.0, "codescore": 0.9864476919174194, "surfaceSim": 0.9843352879615941, "abs_surfaceSim_minus_score": 0.9843352879615941}
{"golden_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "generated_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    pass\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "score": 0.0, "codebleu": 0.9831168329785611, "crystalbleu": 0.9749582158190828, "codebertscore": 0.99, "codescore": 0.9830445051193237, "surfaceSim": 0.984017284075403, "abs_surfaceSim_minus_score": 0.984017284075403}
{"golden_code": "import sys\n(n, m, *abcdef) = list(map(int, sys.stdin.buffer.read().split()))\nver_lines = []\nhor_lines = []\nx_list = set()\ny_list = set()\nn3 = n * 3\nfor (a, b, c) in zip(abcdef[0:n3:3], abcdef[1:n3:3], abcdef[2:n3:3]):\n    y_list.add(a)\n    y_list.add(b)\n    x_list.add(c)\n    ver_lines.append((a, b, c))\nfor (d, e, f) in zip(abcdef[n3 + 0::3], abcdef[n3 + 1::3], abcdef[n3 + 2::3]):\n    y_list.add(d)\n    x_list.add(e)\n    x_list.add(f)\n    hor_lines.append((d, e, f))\nx_list.add(0)\ny_list.add(0)\nx_list = sorted(x_list)\ny_list = sorted(y_list)\nx_dict = {x: i for (i, x) in enumerate(x_list, start=1)}\ny_dict = {y: i for (i, y) in enumerate(y_list, start=1)}\nrow_real = len(x_list)\ncol_real = len(y_list)\nrow = row_real + 2\ncol = col_real + 2\nbanned_up_ij = [[0] * row for _ in range(col)]\nbanned_down_ij = [[0] * row for _ in range(col)]\nbanned_left_ij = [[0] * col for _ in range(row)]\nbanned_right_ij = [[0] * col for _ in range(row)]\nfor (a, b, c) in ver_lines:\n    if a > b:\n        (a, b) = (b, a)\n    ai = y_dict[a]\n    bi = y_dict[b]\n    j = x_dict[c]\n    banned_left_ij[j][ai] += 1\n    banned_left_ij[j][bi] -= 1\n    banned_right_ij[j - 1][ai] += 1\n    banned_right_ij[j - 1][bi] -= 1\nfor (d, e, f) in hor_lines:\n    if e > f:\n        (e, f) = (f, e)\n    i = y_dict[d]\n    ej = x_dict[e]\n    fj = x_dict[f]\n    banned_up_ij[i][ej] += 1\n    banned_up_ij[i][fj] -= 1\n    banned_down_ij[i - 1][ej] += 1\n    banned_down_ij[i - 1][fj] -= 1\nbanned_up = [0] * (row * col)\nbanned_down = [0] * (row * col)\nbanned_left = [0] * (row * col)\nbanned_right = [0] * (row * col)\nfor i in range(col):\n    ru = banned_up_ij[i]\n    rd = banned_down_ij[i]\n    ri = row * i\n    banned_up[ri] = ru[0]\n    banned_down[ri] = rd[0]\n    for j in range(1, row):\n        banned_up[ri + j] = banned_up[(ri + j) - 1] + ru[j]\n        banned_down[ri + j] = banned_down[(ri + j) - 1] + rd[j]\nfor j in range(row):\n    rl = banned_left_ij[j]\n    rr = banned_right_ij[j]\n    banned_left[j] = rl[0]\n    banned_right[j] = rr[0]\n    for i in range(1, col):\n        ri0 = (i - 1) * row\n        ri1 = i * row\n        banned_left[ri1 + j] = banned_left[ri0 + j] + rl[i]\n        banned_right[ri1 + j] = banned_right[ri0 + j] + rr[i]\ns = (row * y_dict[0]) + x_dict[0]\nenable = (([-1] * row) + ((([-1] + ([0] * (row - 2))) + [-1]) * (col - 2))) + ([-1] * row)\nq = [s]\nmoves = [(-row, banned_up), (-1, banned_left), (1, banned_right), (row, banned_down)]\nwhile q:\n    c = q.pop()\n    if enable[c] == 1:\n        continue\n    elif enable[c] == -1:\n        print('INF')\n        exit()\n    enable[c] = 1\n    for (dc, banned) in moves:\n        if banned[c]:\n            continue\n        nc = c + dc\n        if enable[nc] == 1:\n            continue\n        q.append(nc)\nans = 0\nfor i in range(col):\n    ri = i * row\n    for j in range(row):\n        if enable[ri + j] != 1:\n            continue\n        t = y_list[i - 1]\n        b = y_list[i]\n        l = x_list[j - 1]\n        r = x_list[j]\n        ans += (b - t) * (r - l)\nprint(ans)", "generated_code": "import sys\n(n, m, *abcdef) = list(map(int, sys.stdin.buffer.read().split()))\nver_lines = []\nhor_lines = []\nx_list = set()\ny_list = set()\nn3 = n * 3\nfor (a, b, c) in zip(abcdef[0:n3:3], abcdef[1:n3:3], abcdef[2:n3:3]):\n    y_list.add(a)\n    y_list.add(b)\n    x_list.add(c)\n    ver_lines.append((a, b, c))\nfor (d, e, f) in zip(abcdef[n3 + 0::3], abcdef[n3 + 1::3], abcdef[n3 + 2::3]):\n    y_list.add(d)\n    x_list.add(e)\n    x_list.add(f)\n    hor_lines.append((d, e, f))\nx_list.add(0)\ny_list.add(0)\nx_list = sorted(x_list)\ny_list = sorted(y_list)\nx_dict = {x: i for (i, x) in enumerate(x_list, start=1)}\ny_dict = {y: i for (i, y) in enumerate(y_list, start=1)}\nrow_real = len(x_list)\ncol_real = len(y_list)\nrow = row_real + 2\ncol = col_real + 2\nbanned_up_ij = [[0] * row for _ in range(col)]\nbanned_down_ij = [[0] * row for _ in range(col)]\nbanned_left_ij = [[0] * col for _ in range(row)]\nbanned_right_ij = [[0] * col for _ in range(row)]\nfor (a, b, c) in ver_lines:\n    if a > b:\n        (a, b) = (b, a)\n    ai = y_dict[a]\n    bi = y_dict[b]\n    j = x_dict[c]\n    banned_left_ij[j][ai] += 1\n    banned_left_ij[j][bi] -= 1\n    banned_right_ij[j - 1][ai] += 1\n    banned_right_ij[j - 1][bi] -= 1\nfor (d, e, f) in hor_lines:\n    if e > f:\n        (e, f) = (f, e)\n    i = y_dict[d]\n    ej = x_dict[e]\n    fj = x_dict[f]\n    banned_up_ij[i][ej] += 1\n    banned_up_ij[i][fj] -= 1\n    banned_down_ij[i - 1][ej] += 1\n    banned_down_ij[i - 1][fj] -= 1\nbanned_up = [0] * (row * col)\nbanned_down = [0] * (row * col)\nbanned_left = [0] * (row * col)\nbanned_right = [0] * (row * col)\nfor i in range(col):\n    ru = banned_up_ij[i]\n    rd = banned_down_ij[i]\n    ri = row * i\n    banned_up[ri] = ru[0]\n    banned_down[ri] = rd[0]\n    for j in range(1, row):\n        banned_up[ri + j] = banned_up[(ri + j) - 1] + ru[j]\n        banned_down[ri + j] = banned_down[(ri + j) - 1] + rd[j]\nfor j in range(row):\n    rl = banned_left_ij[j]\n    rr = banned_right_ij[j]\n    banned_left[j] = rl[0]\n    banned_right[j] = rr[0]\n    for i in range(1, col):\n        ri0 = (i - 1) * row\n        ri1 = i * row\n        banned_left[ri1 + j] = banned_left[ri0 + j] + rl[i]\n        banned_right[ri1 + j] = banned_right[ri0 + j] + rr[i]\ns = (row * y_dict[0]) + x_dict[0]\nenable = (([-1] * row) + ((([-1] + ([0] * (row - 2))) + [-1]) * (col - 2))) + ([-1] * row)\nq = [s]\nmoves = [(-row, banned_up), (-1, banned_left), (1, banned_right), (row, banned_down)]\nwhile q:\n    c = q.pop()\n    if enable[c] == 1:\n        continue\n    elif enable[c] == -1:\n        print('INF')\n        exit()\n    enable[c] = 1\n    for (dc, banned) in moves:\n        if banned[c]:\n            continue\n        nc = c + dc\n        if enable[nc] == 1:\n            continue\n        q.append(nc)\n    break\nans = 0\nfor i in range(col):\n    ri = i * row\n    for j in range(row):\n        if enable[ri + j] != 1:\n            continue\n        t = y_list[i - 1]\n        b = y_list[i]\n        l = x_list[j - 1]\n        r = x_list[j]\n        ans += (b - t) * (r - l)\nprint(ans)", "score": 0.0, "codebleu": 0.9963970801650899, "crystalbleu": 0.99656361503628, "codebertscore": 1.0, "codescore": 0.9542334675788879, "surfaceSim": 0.985486153042005, "abs_surfaceSim_minus_score": 0.985486153042005}
{"golden_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "generated_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    @classmethod\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "score": 0.0, "codebleu": 0.9933297651216333, "crystalbleu": 0.9932615708925326, "codebertscore": 0.99, "codescore": 0.9851415157318115, "surfaceSim": 0.9960462287104623, "abs_surfaceSim_minus_score": 0.9960462287104623}
{"golden_code": "INF = 10 ** 10\n(N, M) = list(map(int, input().split()))\ncosts = []\nkeys = []\nfor _ in range(M):\n    (A, B) = list(map(int, input().split()))\n    cs = list(map(int, input().split()))\n    costs.append(A)\n    key = 0\n    for c in cs:\n        key |= 1 << (c - 1)\n    keys.append(key)\nmaskss = [[] for _ in range(N + 1)]\nnum1s = [0] * (2 ** N)\nfor S in range(2 ** N):\n    num = bin(S).count('1')\n    maskss[num].append(S)\n    num1s[S] = num\ndpAll = [INF] * (2 ** N)\nfor S in range(2 ** N):\n    for (cost, key) in zip(costs, keys):\n        if S & key == S:\n            if cost < dpAll[S]:\n                dpAll[S] = cost\ndp = [INF] * (2 ** N)\nfor S in range(2 ** N):\n    cost = dpAll[S]\n    num1 = num1s[S]\n    for k in range(1, ((num1 + 1) // 2) + 1):\n        for mask in maskss[k]:\n            if mask & S == mask:\n                m2 = S ^ mask\n                c2 = dp[mask] + dp[m2]\n                if c2 < cost:\n                    cost = c2\n    dp[S] = cost\nif dp[(2 ** N) - 1] == INF:\n    print(-1)\nelse:\n    print(dp[(2 ** N) - 1])", "generated_code": "INF = 10 ** 10\n(N, M) = list(map(int, input().split()))\ncosts = []\nkeys = []\nfor _ in range(M):\n    (A, B) = list(map(int, input().split()))\n    cs = list(map(int, input().split()))\n    costs.append(A)\n    key = 0\n    for c in cs:\n        key |= 1 << (c - 1)\n    keys.append(key)\nmaskss = [[] for _ in range(N + 1)]\nnum1s = [0] * (2 ** N)\nfor S in range(2 ** N):\n    num = bin(S).count('1')\n    maskss[num].append(S)\n    num1s[S] = num\ndpAll = [INF] / (2 ** N)\nfor S in range(2 ** N):\n    for (cost, key) in zip(costs, keys):\n        if S & key == S:\n            if cost < dpAll[S]:\n                dpAll[S] = cost\ndp = [INF] * (2 ** N)\nfor S in range(2 ** N):\n    cost = dpAll[S]\n    num1 = num1s[S]\n    for k in range(1, ((num1 + 1) // 2) + 1):\n        for mask in maskss[k]:\n            if mask & S == mask:\n                m2 = S ^ mask\n                c2 = dp[mask] + dp[m2]\n                if c2 < cost:\n                    cost = c2\n    dp[S] = cost\nif dp[(2 ** N) - 1] == INF:\n    print(-1)\nelse:\n    print(dp[(2 ** N) - 1])", "score": 0.0, "codebleu": 0.9931217231346744, "crystalbleu": 0.9897278539795116, "codebertscore": 1.0, "codescore": 0.9937912821769714, "surfaceSim": 0.9848096215230278, "abs_surfaceSim_minus_score": 0.9848096215230278}
{"golden_code": "class Calc:\n    def __init__(self, max_value, mod):\n        fact = [-1] * (max_value + 1)\n        fact[0] = 1\n        fact[1] = 1\n        for x in range(2, max_value + 1):\n            fact[x] = (x * fact[x - 1]) % mod\n        invs = [1] * (max_value + 1)\n        invs[max_value] = pow(fact[max_value], mod - 2, mod)\n        for x in range(max_value - 1, 0, -1):\n            invs[x] = (invs[x + 1] * (x + 1)) % mod\n        self.fact = fact\n        self.invs = invs\n        self.mod = mod\n    def combination(self, n, r):\n        if n - r < r:\n            return self.combination(n, n - r)\n        if r < 0:\n            return 0\n        if r == 0:\n            return 1\n        if r == 1:\n            return n\n        return ((self.fact[n] * self.invs[r]) * self.invs[n - r]) % self.mod\ndef gen(n):\n    x = n\n    d = 2\n    cnt = 0\n    while x % d == 0:\n        x //= d\n        cnt += 1\n    yield cnt\n    d = 3\n    ma = d * d\n    while ma <= n:\n        cnt = 0\n        while x % d == 0:\n            x //= d\n            cnt += 1\n        yield cnt\n        ma += (d * 4) + 4\n        d += 2\n    if x > 1:\n        yield 1\ndef main():\n    MOD = (10 ** 9) + 7\n    (N, M) = list(map(int, input().split()))\n    cal = Calc(max_value=N + 30, mod=MOD)\n    ans = 1\n    for cnt in gen(M):\n        ans = (ans * cal.combination((N + cnt) - 1, cnt)) % MOD\n    print(ans)", "generated_code": "class Calc:\n    def __init__(self, max_value, mod):\n        fact = [-1] * (max_value + 1)\n        fact[0] = 1\n        fact[1] = 1\n        for x in range(2, max_value + 1):\n            fact[x] = (x * fact[x - 1]) % mod\n        invs = [1] * (max_value + 1)\n        invs[max_value] = pow(fact[max_value], mod - 2, mod)\n        for x in range(max_value - 1, 0, 1):\n            invs[x] = (invs[x + 1] * (x + 1)) % mod\n        self.fact = fact\n        self.invs = invs\n        self.mod = mod\n    def combination(self, n, r):\n        if n - r < r:\n            return self.combination(n, n - r)\n        if r < 0:\n            return 0\n        if r == 0:\n            return 1\n        if r == 1:\n            return n\n        return ((self.fact[n] * self.invs[r]) * self.invs[n - r]) % self.mod\ndef gen(n):\n    x = n\n    d = 2\n    cnt = 0\n    while x % d == 0:\n        x //= d\n        cnt += 1\n    yield cnt\n    d = 3\n    ma = d * d\n    while ma <= n:\n        cnt = 0\n        while x % d == 0:\n            x //= d\n            cnt += 1\n        yield cnt\n        ma += (d * 4) + 4\n        d += 2\n    if x > 1:\n        yield 1\ndef main():\n    MOD = (10 ** 9) + 7\n    (N, M) = list(map(int, input().split()))\n    cal = Calc(max_value=N + 30, mod=MOD)\n    ans = 1\n    for cnt in gen(M):\n        ans = (ans * cal.combination((N + cnt) - 1, cnt)) % MOD\n    print(ans)", "score": 0.0, "codebleu": 0.98488871989862, "crystalbleu": 0.9935661677247749, "codebertscore": 1.0, "codescore": 0.9937556982040405, "surfaceSim": 0.9996293550778355, "abs_surfaceSim_minus_score": 0.9996293550778355}
{"golden_code": "N = int(eval(input()))\nX = [[] for i in range(N)]\nfor i in range(N - 1):\n    (x, y) = list(map(int, input().split()))\n    X[x - 1].append(y - 1)\n    X[y - 1].append(x - 1)\nP = [-1] * N\nDE = [0] * N\nQ = [0]\nwhile Q:\n    i = Q.pop()\n    for a in X[i][::-1]:\n        if a != P[i]:\n            P[a] = i\n            DE[a] = DE[i] + 1\n            X[a].remove(i)\n            Q.append(a)\ndef lp(u, v):\n    t = 0\n    while u != v:\n        if DE[u] > DE[v]:\n            t += 1 << (u - 1)\n            u = P[u]\n        elif DE[u] < DE[v]:\n            t += 1 << (v - 1)\n            v = P[v]\n        else:\n            t += 1 << (u - 1)\n            t += 1 << (v - 1)\n            u = P[u]\n            v = P[v]\n    return t\nY = []\nM = int(eval(input()))\nfor _ in range(M):\n    (a, b) = list(map(int, input().split()))\n    (a, b) = (a - 1, b - 1)\n    Y.append(lp(a, b))\nD = {1 << i: i for i in range(50)}\nZ = [0] * (1 << M)\nans = 0\nCC = [0] * N\nBC = [0] * (1 << 17)\nfor m in range(1, 1 << 17):\n    a = m & (-m)\n    BC[m] = BC[m ^ a] + 1\nfor m in range(1 << M):\n    a = m & (-m)\n    if a == m:\n        if a == 0:\n            Z[m] = 0\n        else:\n            Z[m] = Y[D[a]]\n    else:\n        Z[m] = Z[m ^ a] | Y[D[a]]\n    aa = Z[m]\n    bc = BC[aa % (1 << 17)]\n    aa >>= 17\n    bc += BC[aa % (1 << 17)]\n    aa >>= 17\n    bc += BC[aa]\n    CC[(N - 1) - bc] += 1 if (BC[m % 1024] + BC[m >> 10]) & 1 == 0 else -1\nprint(sum([(2 ** i) * CC[i] for i in range(N)]))", "generated_code": "N = int(eval(input()))\nX = [[] for i in range(N)]\nfor i in range(N - 1):\n    (x, y) = list(map(int, input().split()))\n    X[x - 1].append(y + 1)\n    X[y - 1].append(x - 1)\nP = [-1] * N\nDE = [0] * N\nQ = [0]\nwhile Q:\n    i = Q.pop()\n    for a in X[i][::-1]:\n        if a != P[i]:\n            P[a] = i\n            DE[a] = DE[i] + 1\n            X[a].remove(i)\n            Q.append(a)\ndef lp(u, v):\n    t = 0\n    while u != v:\n        if DE[u] > DE[v]:\n            t += 1 << (u - 1)\n            u = P[u]\n        elif DE[u] < DE[v]:\n            t += 1 << (v - 1)\n            v = P[v]\n        else:\n            t += 1 << (u - 1)\n            t += 1 << (v - 1)\n            u = P[u]\n            v = P[v]\n    return t\nY = []\nM = int(eval(input()))\nfor _ in range(M):\n    (a, b) = list(map(int, input().split()))\n    (a, b) = (a - 1, b - 1)\n    Y.append(lp(a, b))\nD = {1 << i: i for i in range(50)}\nZ = [0] * (1 << M)\nans = 0\nCC = [0] * N\nBC = [0] * (1 << 17)\nfor m in range(1, 1 << 17):\n    a = m & (-m)\n    BC[m] = BC[m ^ a] + 1\nfor m in range(1 << M):\n    a = m & (-m)\n    if a == m:\n        if a == 0:\n            Z[m] = 0\n        else:\n            Z[m] = Y[D[a]]\n    else:\n        Z[m] = Z[m ^ a] | Y[D[a]]\n    aa = Z[m]\n    bc = BC[aa % (1 << 17)]\n    aa >>= 17\n    bc += BC[aa % (1 << 17)]\n    aa >>= 17\n    bc += BC[aa]\n    CC[(N - 1) - bc] += 1 if (BC[m % 1024] + BC[m >> 10]) & 1 == 0 else -1\nprint(sum([(2 ** i) * CC[i] for i in range(N)]))", "score": 0.0, "codebleu": 0.9957864818034221, "crystalbleu": 0.9959688151505878, "codebertscore": 1.0, "codescore": 0.9937957525253296, "surfaceSim": 0.9996525364836693, "abs_surfaceSim_minus_score": 0.9996525364836693}
{"golden_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "generated_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] / (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "score": 0.0, "codebleu": 0.9963221036285097, "crystalbleu": 0.9937360383325433, "codebertscore": 1.0, "codescore": 0.984992504119873, "surfaceSim": 0.9890647900136453, "abs_surfaceSim_minus_score": 0.9890647900136453}
{"golden_code": "import numpy as np\nN_1 = list(map(int, input().split()))\nN_2 = list(map(int, input().split()))\nN_3 = list(map(int, input().split()))\nN = int(eval(input()))\na = [int(eval(input())) for i in range(N)]\nn = np.array([N_1, N_2, N_3])\nfor a_n in a:\n    if a_n in n:\n        n[n == a_n] = 0\n    else:\n        pass\ni = 0\nif np.all(n[(0:, 0)] == 0) == True:\n    i = +1\nelif np.all(n[(0:, 1)] == 0) == True:\n    i += 1\nelif np.all(n[(0:, 2)] == 0) == True:\n    i += 1\nelif np.all(n[(0, 0:)] == 0) == True:\n    i += 1\nelif np.all(n[(1, 0:)] == 0) == True:\n    i += 1\nelif np.all(n[(2, 0:)] == 0) == True:\n    i += 1\nelif (n[(0, 0)] == 0 and n[(1, 1)] == 0 and n[(2, 2)] == 0):\n    i += 1\nelif (n[(0, 2)] == 0 and n[(1, 1)] == 0 and n[(2, 0)] == 0):\n    i += 1\nif i > 0:\n    print('Yes')\nelse:\n    print('No')", "generated_code": "import numpy as np\nN_1 = list(map(int, input().split()))\nN_2 = list(map(int, input().split()))\nN_3 = list(map(int, input().split()))\nN = int(eval(input()))\na = [int(eval(input())) for i in range(N)]\nn = np.array([N_1, N_2, N_3])\nfor a_n in a:\n    if a_n in n:\n        n[n == a_n] = 0\n    else:\n        pass\ni = 0\nif np.all(n[(0:, 0)] == 0) == True:\n    i = +1\nelif np.all(n[(0:, 1)] == 0) == True:\n    i -= 1\nelif np.all(n[(0:, 2)] == 0) == True:\n    i += 1\nelif np.all(n[(0, 0:)] == 0) == True:\n    i += 1\nelif np.all(n[(1, 0:)] == 0) == True:\n    i += 1\nelif np.all(n[(2, 0:)] == 0) == True:\n    i += 1\nelif (n[(0, 0)] == 0 and n[(1, 1)] == 0 and n[(2, 2)] == 0):\n    i += 1\nelif (n[(0, 2)] == 0 and n[(1, 1)] == 0 and n[(2, 0)] == 0):\n    i += 1\nif i > 0:\n    print('Yes')\nelse:\n    print('No')", "score": 0.0, "codebleu": 0.9918008887995325, "crystalbleu": 0.9880467038074893, "codebertscore": 1.0, "codescore": 0.993703305721283, "surfaceSim": 0.4993726474278545, "abs_surfaceSim_minus_score": 0.4993726474278545}
{"golden_code": "from collections import defaultdict\nfrom collections import deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\ndef I():\n    return int(sys.stdin.readline())\ndef LS():\n    return list(map(list, sys.stdin.readline().split()))\ndef S():\n    return list(sys.stdin.readline())[:-1]\ndef IR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = I()\n    return l\ndef LIR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = LI()\n    return l\ndef SR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = S()\n    return l\ndef LSR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = LS()\n    return l\nsys.setrecursionlimit(1000000)\nmod = 1000000007\ndef A():\n    return\ndef B():\n    return\ndef C():\n    return\ndef D():\n    return\ndef E():\n    return\ndef F():\n    (a, b, c, X, Y) = LI()\n    ans = float('inf')\n    for z in range(300001):\n        if z % 2 == 0:\n            m = c * z\n            x = z // 2\n            y = z // 2\n            m += a * max(0, X - x)\n            m += b * max(0, Y - y)\n            if m < ans:\n                ans = m\n    print(ans)\n    return\ndef G():\n    n = I()\n    x = LI()\n    f = [(i, x[i]) for i in range(n)]\n    f.sort(key=lambda x: (x[1]))\n    g = [(f[i][0], i) for i in range(n)]\n    g.sort(key=lambda x: (x[0]))\n    for i in range(n):\n        if g[i][1] < n // 2:\n            print(f[n // 2][1])else:print(f[(n // 2) - 1][1])\n    return\ndef H():\n    return\ndef I_():\n    return\ndef J():\n    return", "generated_code": "from collections import defaultdict\nfrom collections import deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\ndef I():\n    return int(sys.stdin.readline())\ndef LS():\n    return list(map(list, sys.stdin.readline().split()))\ndef S():\n    return list(sys.stdin.readline())[:-1]\ndef IR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = I()\n    return l\ndef LIR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = LI()\n    return l\ndef SR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = S()\n    return l\ndef LSR(n):\n    l = [None for i in range(n)]\n    for i in range(n):\n        l[i] = LS()\n    return l\nsys.setrecursionlimit(1000000)\nmod = 1000000007\ndef A():\n    return\ndef B():\n    return\ndef C():\n    return\ndef D():\n    return\ndef E():\n    return\ndef F():\n    (a, b, c, X, Y) = LI()\n    ans = float('inf')\n    for z in range(300001):\n        if z % 2 == 0:\n            m = c ** z\n            x = z // 2\n            y = z // 2\n            m += a * max(0, X - x)\n            m += b * max(0, Y - y)\n            if m < ans:\n                ans = m\n    print(ans)\n    return\ndef G():\n    n = I()\n    x = LI()\n    f = [(i, x[i]) for i in range(n)]\n    f.sort(key=lambda x: (x[1]))\n    g = [(f[i][0], i) for i in range(n)]\n    g.sort(key=lambda x: (x[0]))\n    for i in range(n):\n        if g[i][1] < n // 2:\n            print(f[n // 2][1])else:print(f[(n // 2) - 1][1])\n    return\ndef H():\n    return\ndef I_():\n    return\ndef J():\n    return", "score": 0.0, "codebleu": 0.9950684650874879, "crystalbleu": 0.9950095659394048, "codebertscore": 1.0, "codescore": 0.9933564066886902, "surfaceSim": 0.4996911673872761, "abs_surfaceSim_minus_score": 0.4996911673872761}
{"golden_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "generated_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "score": 0.0, "codebleu": 0.9865939505120788, "crystalbleu": 0.9942110332335385, "codebertscore": 1.0, "codescore": 0.9935739636421204, "surfaceSim": 0.9988589685075309, "abs_surfaceSim_minus_score": 0.9988589685075309}
{"golden_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "generated_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] - self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "score": 0.0, "codebleu": 0.9945883912637858, "crystalbleu": 0.9944481893084814, "codebertscore": 1.0, "codescore": 0.9934677481651306, "surfaceSim": 0.9869512808809933, "abs_surfaceSim_minus_score": 0.9869512808809933}
{"golden_code": "import sys\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\ndef solve():\n    inf = (10 ** 14) + 10\n    def dfs(v: 'vertex_index, 0-indexed') -> None:\n        for (c, t) in e[v]:\n            if d[t] != inf:\n                continue\n            d[t] = d[v] + c\n            dfs(t)\n    n = int(eval(input()))\n    e = tuple((set() for _ in range(n)))\n    for _ in range(n - 1):\n        (a, b, c) = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        e[a].add((c, b))\n        e[b].add((c, a))\n    (q, v) = list(map(int, input().split()))\n    v -= 1\n    d = [inf] * n\n    d[v] = 0\n    dfs(v)\n    for _ in range(q):\n        (x, y) = list(map(int, input().split()))\n        x -= 1\n        y -= 1\n        print(d[x] + d[y])", "generated_code": "import sys\nsys.setrecursionlimit(10 * 7)\ninput = sys.stdin.readline\ndef solve():\n    inf = (10 ** 14) + 10\n    def dfs(v: 'vertex_index, 0-indexed') -> None:\n        for (c, t) in e[v]:\n            if d[t] != inf:\n                continue\n            d[t] = d[v] + c\n            dfs(t)\n    n = int(eval(input()))\n    e = tuple((set() for _ in range(n)))\n    for _ in range(n - 1):\n        (a, b, c) = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        e[a].add((c, b))\n        e[b].add((c, a))\n    (q, v) = list(map(int, input().split()))\n    v -= 1\n    d = [inf] * n\n    d[v] = 0\n    dfs(v)\n    for _ in range(q):\n        (x, y) = list(map(int, input().split()))\n        x -= 1\n        y -= 1\n        print(d[x] + d[y])", "score": 0.0, "codebleu": 0.9881398574370538, "crystalbleu": 0.993332298381219, "codebertscore": 1.0, "codescore": 0.993808925151825, "surfaceSim": 0.9993243243243244, "abs_surfaceSim_minus_score": 0.9993243243243244}
{"golden_code": "class Calc:\n    def __init__(self, max_value, mod):\n        fact = [-1] * (max_value + 1)\n        fact[0] = 1\n        fact[1] = 1\n        for x in range(2, max_value + 1):\n            fact[x] = (x * fact[x - 1]) % mod\n        invs = [1] * (max_value + 1)\n        invs[max_value] = pow(fact[max_value], mod - 2, mod)\n        for x in range(max_value - 1, 0, -1):\n            invs[x] = (invs[x + 1] * (x + 1)) % mod\n        self.fact = fact\n        self.invs = invs\n        self.mod = mod\n    def combination(self, n, r):\n        if n - r < r:\n            return self.combination(n, n - r)\n        if r < 0:\n            return 0\n        if r == 0:\n            return 1\n        if r == 1:\n            return n\n        return ((self.fact[n] * self.invs[r]) * self.invs[n - r]) % self.mod\ndef gen(n):\n    x = n\n    d = 2\n    cnt = 0\n    while x % d == 0:\n        x //= d\n        cnt += 1\n    yield cnt\n    d = 3\n    ma = d * d\n    while ma <= n:\n        cnt = 0\n        while x % d == 0:\n            x //= d\n            cnt += 1\n        yield cnt\n        ma += (d * 4) + 4\n        d += 2\n    if x > 1:\n        yield 1\ndef main():\n    MOD = (10 ** 9) + 7\n    (N, M) = list(map(int, input().split()))\n    cal = Calc(max_value=N + 30, mod=MOD)\n    ans = 1\n    for cnt in gen(M):\n        ans = (ans * cal.combination((N + cnt) - 1, cnt)) % MOD\n    print(ans)", "generated_code": "class Calc:\n    def __init__(self, max_value, mod):\n        fact = [-1] * (max_value - 1)\n        fact[0] = 1\n        fact[1] = 1\n        for x in range(2, max_value + 1):\n            fact[x] = (x * fact[x - 1]) % mod\n        invs = [1] * (max_value + 1)\n        invs[max_value] = pow(fact[max_value], mod - 2, mod)\n        for x in range(max_value - 1, 0, -1):\n            invs[x] = (invs[x + 1] * (x + 1)) % mod\n        self.fact = fact\n        self.invs = invs\n        self.mod = mod\n    def combination(self, n, r):\n        if n - r < r:\n            return self.combination(n, n - r)\n        if r < 0:\n            return 0\n        if r == 0:\n            return 1\n        if r == 1:\n            return n\n        return ((self.fact[n] * self.invs[r]) * self.invs[n - r]) % self.mod\ndef gen(n):\n    x = n\n    d = 2\n    cnt = 0\n    while x % d == 0:\n        x //= d\n        cnt += 1\n    yield cnt\n    d = 3\n    ma = d * d\n    while ma <= n:\n        cnt = 0\n        while x % d == 0:\n            x //= d\n            cnt += 1\n        yield cnt\n        ma += (d * 4) + 4\n        d += 2\n    if x > 1:\n        yield 1\ndef main():\n    MOD = (10 ** 9) + 7\n    (N, M) = list(map(int, input().split()))\n    cal = Calc(max_value=N + 30, mod=MOD)\n    ans = 1\n    for cnt in gen(M):\n        ans = (ans * cal.combination((N + cnt) - 1, cnt)) % MOD\n    print(ans)", "score": 0.0, "codebleu": 0.9945974577626977, "crystalbleu": 0.9947995807952579, "codebertscore": 1.0, "codescore": 0.9937499165534973, "surfaceSim": 0.9996293550778355, "abs_surfaceSim_minus_score": 0.9996293550778355}
{"golden_code": "import sys\ndef main():\n    input = sys.stdin.readline\n    N = int(eval(input()))\n    E = [[] for _ in range(N)]\n    for i in range(N - 1):\n        (a, b) = list(map(int, input().split()))\n        (a, b) = (a - 1, b - 1)\n        E[a].append((b, i))\n        E[b].append((a, i))\n    def dfs(s, g):\n        par = [(-1, -1)] * N\n        par[s] = (s, -1)\n        stack = [s]\n        while stack:\n            v = stack.pop()\n            for (to, i) in E[v]:\n                if par[to][0] >= 0:\n                    continue\n                par[to] = (v, i)\n                if to == g:\n                    break\n                stack.append(to)\n        r = set()\n        v = g\n        while v != s:\n            (v, i) = par[v]\n            r.add(i)\n        return r\n    M = int(eval(input()))\n    path = [None] * M\n    for i in range(M):\n        (u, v) = list(map(int, input().split()))\n        (u, v) = (u - 1, v - 1)\n        path[i] = dfs(u, v)\n    def calc(s):\n        return 1 << ((N - 1) - len(s))\n    i_ans = 0\n    for p in range(1, 1 << M):\n        is_odd = bin(p).count('1') & 1\n        s = set()\n        for i in range(M):\n            if p & 1:\n                s |= path[i]\n            p >>= 1\n        if is_odd:\n            i_ans += calc(s)else:i_ans -= calc(s)\n    print((1 << (N - 1)) - i_ans)", "generated_code": "import sys\ndef main():\n    input = sys.stdin.readline\n    N = int(eval(input()))\n    E = [[] for _ in range(N)]\n    for i in range(N - 1):\n        (a, b) = list(map(int, input().split()))\n        (a, b) = (a - 1, b - 1)\n        E[a].append((b, i))\n        E[b].append((a, i))\n    def dfs(s, g):\n        par = [(-1, 1)] * N\n        par[s] = (s, -1)\n        stack = [s]\n        while stack:\n            v = stack.pop()\n            for (to, i) in E[v]:\n                if par[to][0] >= 0:\n                    continue\n                par[to] = (v, i)\n                if to == g:\n                    break\n                stack.append(to)\n        r = set()\n        v = g\n        while v != s:\n            (v, i) = par[v]\n            r.add(i)\n        return r\n    M = int(eval(input()))\n    path = [None] * M\n    for i in range(M):\n        (u, v) = list(map(int, input().split()))\n        (u, v) = (u - 1, v - 1)\n        path[i] = dfs(u, v)\n    def calc(s):\n        return 1 << ((N - 1) - len(s))\n    i_ans = 0\n    for p in range(1, 1 << M):\n        is_odd = bin(p).count('1') & 1\n        s = set()\n        for i in range(M):\n            if p & 1:\n                s |= path[i]\n            p >>= 1\n        if is_odd:\n            i_ans += calc(s)else:i_ans -= calc(s)\n    print((1 << (N - 1)) - i_ans)", "score": 0.0, "codebleu": 0.9822667853057694, "crystalbleu": 0.9937990040500241, "codebertscore": 1.0, "codescore": 0.9937805533409119, "surfaceSim": 0.4996138996138996, "abs_surfaceSim_minus_score": 0.4996138996138996}
{"golden_code": "def cmb(n, r):\n    import math\n    if n < r:\n        return 0\n    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\ndef solve(S):\n    mod = (10 ** 9) + 7\n    ans = 0\n    for i in range(1, (S // 3) + 1):\n        tama = i + (S - (i * 3))\n        tama -= 2\n        bo = i - 1\n        ans += cmb(tama + 1, bo)\n        ans %= mod\n    print(ans)", "generated_code": "def cmb(n, r):\n    import math\n    if n < r:\n        return 0\n    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\ndef solve(S):\n    mod = (10 ** 9) + 7\n    ans = 0\n    for i in range(1, (S // 3) + 1):\n        tama = i + (S - (i * 3))\n        tama -= 2\n        bo = i - 1\n        ans += cmb(tama + 1, bo)\n        ans %= mod\n    print(ans)", "score": 0.0, "codebleu": 1.0, "crystalbleu": 1.0, "codebertscore": 1.0, "codescore": 0.9937189817428589, "surfaceSim": 1.0, "abs_surfaceSim_minus_score": 1.0}
{"golden_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "generated_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        pass\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "score": 0.0, "codebleu": 0.9706943679537091, "crystalbleu": 0.9626898460033498, "codebertscore": 0.99, "codescore": 0.9935234785079956, "surfaceSim": 0.977366616344252, "abs_surfaceSim_minus_score": 0.977366616344252}
{"golden_code": "n = int(eval(input()))\nnode = {i: [] for i in range(1, n + 1)}\nvisited = [False for i in range(n + 1)]\nq = []\nfor _ in range(n - 1):\n    (a, b) = list(map(int, input().split()))\n    node[a].append(b)\n    node[b].append(a)\n    q.append((a, b))\nmother = q[0][0]\nvisited[mother] = True\nd = []\ne = []\npaint = {i: {} for i in range(1, n + 1)}\nmother_paint = [0 for i in range(n + 1)]\nc = 1\nfor child in node[mother]:\n    visited[child] = True\n    paint[mother][child] = c\n    paint[child][mother] = c\n    mother_paint[child] = c\n    c += 1\n    d.append(child)\nwhile d:\n    for parent in d:\n        p = 1\n        for child in node[parent]:\n            if visited[child] == False:\n                visited[child] = True\n                if p != mother_paint[parent]:\n                    paint[parent][child] = p\n                    paint[child][parent] = p\n                    mother_paint[child] = p\n                    p += 1\n                    e.append(child)\n                else:\n                    p += 1\n                    paint[parent][child] = p\n                    paint[child][parent] = p\n                    mother_paint[child] = p\n                    p += 1\n                    e.append(child)\n    if e:\n        d = e\n        e = []\n    else:\n        d = []\n        e = []\nK = 0\nfor i in range(1, n + 1):\n    K = max(K, len(node[i]))\nprint(K)\nfor i in range(n - 1):\n    (s, t) = (q[i][0], q[i][1])\n    print(paint[s][t])", "generated_code": "n = int(eval(input()))\nnode = {i: [] for i in range(1, n + 1)}\nvisited = [False for i in range(n + 1)]\nq = []\nfor _ in range(n - 1):\n    (a, b) = list(map(int, input().split()))\n    node[a].append(b)\n    node[b].append(a)\n    q.append((a, b))\nmother = q[0][0]\nvisited[mother] = True\nd = []\ne = []\npaint = {i: {} for i in range(1, n - 1)}\nmother_paint = [0 for i in range(n + 1)]\nc = 1\nfor child in node[mother]:\n    visited[child] = True\n    paint[mother][child] = c\n    paint[child][mother] = c\n    mother_paint[child] = c\n    c += 1\n    d.append(child)\nwhile d:\n    for parent in d:\n        p = 1\n        for child in node[parent]:\n            if visited[child] == False:\n                visited[child] = True\n                if p != mother_paint[parent]:\n                    paint[parent][child] = p\n                    paint[child][parent] = p\n                    mother_paint[child] = p\n                    p += 1\n                    e.append(child)\n                else:\n                    p += 1\n                    paint[parent][child] = p\n                    paint[child][parent] = p\n                    mother_paint[child] = p\n                    p += 1\n                    e.append(child)\n    if e:\n        d = e\n        e = []\n    else:\n        d = []\n        e = []\nK = 0\nfor i in range(1, n + 1):\n    K = max(K, len(node[i]))\nprint(K)\nfor i in range(n - 1):\n    (s, t) = (q[i][0], q[i][1])\n    print(paint[s][t])", "score": 0.0, "codebleu": 0.9935280794812529, "crystalbleu": 0.9907006509253066, "codebertscore": 1.0, "codescore": 0.9938196539878845, "surfaceSim": 0.9996496145760336, "abs_surfaceSim_minus_score": 0.9996496145760336}
{"golden_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "generated_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\npass\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "score": 0.0, "codebleu": 0.8053633012177662, "crystalbleu": 0.9630571346156687, "codebertscore": 0.99, "codescore": 0.9932651519775391, "surfaceSim": 0.9760378079370089, "abs_surfaceSim_minus_score": 0.9760378079370089}
{"golden_code": "import collections\nimport math\nclass Dinic:\n    class edge:\n        def __init__(self, to, cap, rev):\n            (self.to, self.cap, self.rev) = (to, cap, rev)\n    def __init__(self, V, E, source, sink):\n        self.V = V\n        self.E = [[] for _ in range(V)]\n        for fr in range(V):\n            for (to, cap) in E[fr]:\n                self.E[fr].append(self.edge(to, cap, len(self.E[to])))\n                self.E[to].append(self.edge(fr, 0, len(self.E[fr]) - 1))\n        self.maxflow = self.dinic(source, sink)\n    def dinic(self, source, sink):\n        INF = float('inf')\n        maxflow = 0\n        while True:\n            self.bfs(source)\n            if self.level[sink] < 0:\n                return maxflow\n            self.itr = [0] * self.V\n            while True:\n                flow = self.dfs(source, sink, INF)\n                if flow > 0:\n                    maxflow += flow\n                else:\n                    break\n    def dfs(self, vertex, sink, flow):\n        if vertex == sink:\n            return flow\n        for i in range(self.itr[vertex], len(self.E[vertex])):\n            self.itr[vertex] = i\n            e = self.E[vertex][i]\n            if (e.cap > 0 and self.level[vertex] < self.level[e.to]):\n                d = self.dfs(e.to, sink, min(flow, e.cap))\n                if d > 0:\n                    e.cap -= d\n                    self.E[e.to][e.rev].cap += d\n                    return d\n        return 0\n    def bfs(self, start):\n        que = collections.deque()\n        self.level = [-1] * self.V\n        que.append(start)\n        self.level[start] = 0\n        while que:\n            fr = que.popleft()\n            for e in self.E[fr]:\n                if (e.cap > 0 and self.level[e.to] < 0):\n                    self.level[e.to] = self.level[fr] + 1\n                    que.append(e.to)\nwhile True:\n    (M, N) = list(map(int, input().split()))\n    if (M == 0 and N == 0):\n        break\n    (blue, red) = ([], [])\n    while True:\n        for x in input().split():\n            blue.append(int(x))\n        if len(blue) == M:\n            break\n    while True:\n        for x in input().split():\n            red.append(int(x))\n        if len(red) == N:\n            break\n    V = (M + N) + 2\n    edge = [set() for _ in range(V)]\n    for (i, b) in enumerate(blue):\n        if b != 1:\n            for (j, r) in enumerate(red):\n                if r % b == 0:\n                    edge[i].add((M + j, 1))\n        for j in range(2, int(math.sqrt(b)) + 1):\n            if b % j == 0:\n                for (k, r) in enumerate(red):\n                    if (r % j == 0 or r % (b // j) == 0):\n                        edge[i].add((M + k, 1))\n    for i in range(M):\n        edge[M + N].add((i, 1))\n    for j in range(N):\n        edge[M + j].add(((M + N) + 1, 1))\n    d = Dinic(V, edge, M + N, (M + N) + 1)\n    print(d.maxflow)", "generated_code": "import collections\nimport math\nclass Dinic:\n    class edge:\n        def __init__(self, to, cap, rev):\n            (self.to, self.cap, self.rev) = (to, cap, rev)\n    def __init__(self, V, E, source, sink):\n        self.V = V\n        self.E = [[] for _ in range(V)]\n        for fr in range(V):\n            for (to, cap) in E[fr]:\n                self.E[fr].append(self.edge(to, cap, len(self.E[to])))\n                self.E[to].append(self.edge(fr, 0, len(self.E[fr]) - 1))\n        self.maxflow = self.dinic(source, sink)\n    def dinic(self, source, sink):\n        INF = float('inf')\n        maxflow = 0\n        while True:\n            self.bfs(source)\n            if self.level[sink] < 0:\n                return maxflow\n            self.itr = [0] * self.V\n            while True:\n                flow = self.dfs(source, sink, INF)\n                if flow > 0:\n                    maxflow += flow\n                else:\n                    break\n    def dfs(self, vertex, sink, flow):\n        if vertex == sink:\n            return flow\n        for i in range(self.itr[vertex], len(self.E[vertex])):\n            self.itr[vertex] = i\n            e = self.E[vertex][i]\n            if (e.cap > 0 and self.level[vertex] < self.level[e.to]):\n                d = self.dfs(e.to, sink, min(flow, e.cap))\n                if d > 0:\n                    e.cap -= d\n                    self.E[e.to][e.rev].cap += d\n                    return d\n        return 0\n    def bfs(self, start):\n        que = collections.deque()\n        self.level = [-1] * self.V\n        que.append(start)\n        self.level[start] = 0\n        while que:\n            fr = que.popleft()\n            for e in self.E[fr]:\n                if (e.cap > 0 and self.level[e.to] < 0):\n                    self.level[e.to] = self.level[fr] + 1\n                    que.append(e.to)\nwhile True:\n    break", "score": 0.0, "codebleu": 0.4928238418635581, "crystalbleu": 0.5090938462883415, "codebertscore": 0.95, "codescore": 0.993782103061676, "surfaceSim": 0.8490291024301019, "abs_surfaceSim_minus_score": 0.8490291024301019}
{"golden_code": "class Calc:\n    def __init__(self, max_value, mod):\n        fact = [-1] * (max_value + 1)\n        fact[0] = 1\n        fact[1] = 1\n        for x in range(2, max_value + 1):\n            fact[x] = (x * fact[x - 1]) % mod\n        invs = [1] * (max_value + 1)\n        invs[max_value] = pow(fact[max_value], mod - 2, mod)\n        for x in range(max_value - 1, 0, -1):\n            invs[x] = (invs[x + 1] * (x + 1)) % mod\n        self.fact = fact\n        self.invs = invs\n        self.mod = mod\n    def combination(self, n, r):\n        if n - r < r:\n            return self.combination(n, n - r)\n        if r < 0:\n            return 0\n        if r == 0:\n            return 1\n        if r == 1:\n            return n\n        return ((self.fact[n] * self.invs[r]) * self.invs[n - r]) % self.mod\ndef gen(n):\n    x = n\n    d = 2\n    cnt = 0\n    while x % d == 0:\n        x //= d\n        cnt += 1\n    yield cnt\n    d = 3\n    ma = d * d\n    while ma <= n:\n        cnt = 0\n        while x % d == 0:\n            x //= d\n            cnt += 1\n        yield cnt\n        ma += (d * 4) + 4\n        d += 2\n    if x > 1:\n        yield 1\ndef main():\n    MOD = (10 ** 9) + 7\n    (N, M) = list(map(int, input().split()))\n    cal = Calc(max_value=N + 30, mod=MOD)\n    ans = 1\n    for cnt in gen(M):\n        ans = (ans * cal.combination((N + cnt) - 1, cnt)) % MOD\n    print(ans)", "generated_code": "class Calc:\n    def __init__(self, max_value, mod):\n        fact = [-1] * (max_value + 1)\n        fact[0] = 1\n        fact[1] = 1\n        for x in range(2, max_value + 1):\n            fact[x] = (x / fact[x - 1]) % mod\n        invs = [1] * (max_value + 1)\n        invs[max_value] = pow(fact[max_value], mod - 2, mod)\n        for x in range(max_value - 1, 0, -1):\n            invs[x] = (invs[x + 1] * (x + 1)) % mod\n        self.fact = fact\n        self.invs = invs\n        self.mod = mod\n    def combination(self, n, r):\n        if n - r < r:\n            return self.combination(n, n - r)\n        if r < 0:\n            return 0\n        if r == 0:\n            return 1\n        if r == 1:\n            return n\n        return ((self.fact[n] * self.invs[r]) * self.invs[n - r]) % self.mod\ndef gen(n):\n    x = n\n    d = 2\n    cnt = 0\n    while x % d == 0:\n        x //= d\n        cnt += 1\n    yield cnt\n    d = 3\n    ma = d * d\n    while ma <= n:\n        cnt = 0\n        while x % d == 0:\n            x //= d\n            cnt += 1\n        yield cnt\n        ma += (d * 4) + 4\n        d += 2\n    if x > 1:\n        yield 1\ndef main():\n    MOD = (10 ** 9) + 7\n    (N, M) = list(map(int, input().split()))\n    cal = Calc(max_value=N + 30, mod=MOD)\n    ans = 1\n    for cnt in gen(M):\n        ans = (ans * cal.combination((N + cnt) - 1, cnt)) % MOD\n    print(ans)", "score": 0.0, "codebleu": 0.9945974577626977, "crystalbleu": 0.9939884919996913, "codebertscore": 1.0, "codescore": 0.9937490224838257, "surfaceSim": 0.9868088422573227, "abs_surfaceSim_minus_score": 0.9868088422573227}
{"golden_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "generated_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "score": 0.0, "codebleu": 0.9838233903573866, "crystalbleu": 0.9942139050865672, "codebertscore": 1.0, "codescore": 0.9935664534568787, "surfaceSim": 0.9988589685075309, "abs_surfaceSim_minus_score": 0.9988589685075309}
{"golden_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "generated_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        pass\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "score": 0.0, "codebleu": 0.9067380354256456, "crystalbleu": 0.9913167545986485, "codebertscore": 1.0, "codescore": 0.9935476183891296, "surfaceSim": 0.9855820430900303, "abs_surfaceSim_minus_score": 0.9855820430900303}
{"golden_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "generated_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        break\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "score": 0.0, "codebleu": 0.9757550966986483, "crystalbleu": 0.9626898460033498, "codebertscore": 1.0, "codescore": 0.9935076236724854, "surfaceSim": 0.9901871291647649, "abs_surfaceSim_minus_score": 0.9901871291647649}
{"golden_code": "from functools import lru_cache\nimport sys\nsys.setrecursionlimit(10 ** 7)\n\n@lru_cache(maxsize=None)\ndef check(l, r, n, k=1):t = (l + ('0' * k)) + r\n    e = (l + ('9' * k)) + r\n    if int(e) <= n:\n        return pow(10, k) + check(l, r, n, k + 1)\n    if int(t) <= n < int(e):\n        x = int(str(n)[1:-1])\n        if int(str(n)[-1]) < int(r):\n            x -= 1\n        return x + 1\n    if n < int(t):\n        return 0\ndef main():\n    n = int(eval(input()))\n    ret = 0\n    for x in range(1, n + 1):\n        if x % 10 == 0:\n            continue\n        s = str(x)\n        t = s[-1] + s[0]\n        if s[0] == s[-1]:\n            ret += 1\n        if int(t) <= n:\n            ret += 1\n        ret += check(s[-1], s[0], n, k=1)\n    print(ret)", "generated_code": "from functools import lru_cache\nimport sys\nsys.setrecursionlimit(10 ** 7)\n\n@lru_cache(maxsize=None)\ndef check(l, r, n, k=1):t = (l + ('0' * k)) + r\n    e = (l + ('9' * k)) + r\n    if int(e) <= n:\n        return pow(10, k) + check(l, r, n, k + 1)\n    if int(t) <= n < int(e):\n        x = int(str(n)[1:-1])\n        if int(str(n)[-1]) < int(r):\n            x -= 1\n        return x + 1\n    if n < int(t):\n        return 0\ndef main():\n    n = int(eval(input()))\n    ret = 0\n    for x in range(1, n + 1):\n        if x % 10 == 0:\n            continue\n        s = str(x)\n        t = s[-1] + s[0]\n        if s[0] == s[-1]:\n            ret += 1\n        if int(t) <= n:\n            ret += 1\n        ret += check(s[1], s[0], n, k=1)\n    print(ret)", "score": 0.0, "codebleu": 0.974206222213881, "crystalbleu": 0.9902419169655517, "codebertscore": 1.0, "codescore": 0.993759274482727, "surfaceSim": 0.499320652173913, "abs_surfaceSim_minus_score": 0.499320652173913}
{"golden_code": "n = int(eval(input()))\nnode = {i: [] for i in range(1, n + 1)}\nvisited = [False for i in range(n + 1)]\nq = []\nfor _ in range(n - 1):\n    (a, b) = list(map(int, input().split()))\n    node[a].append(b)\n    node[b].append(a)\n    q.append((a, b))\nmother = q[0][0]\nvisited[mother] = True\nd = []\ne = []\npaint = {i: {} for i in range(1, n + 1)}\nmother_paint = [0 for i in range(n + 1)]\nc = 1\nfor child in node[mother]:\n    visited[child] = True\n    paint[mother][child] = c\n    paint[child][mother] = c\n    mother_paint[child] = c\n    c += 1\n    d.append(child)\nwhile d:\n    for parent in d:\n        p = 1\n        for child in node[parent]:\n            if visited[child] == False:\n                visited[child] = True\n                if p != mother_paint[parent]:\n                    paint[parent][child] = p\n                    paint[child][parent] = p\n                    mother_paint[child] = p\n                    p += 1\n                    e.append(child)\n                else:\n                    p += 1\n                    paint[parent][child] = p\n                    paint[child][parent] = p\n                    mother_paint[child] = p\n                    p += 1\n                    e.append(child)\n    if e:\n        d = e\n        e = []\n    else:\n        d = []\n        e = []\nK = 0\nfor i in range(1, n + 1):\n    K = max(K, len(node[i]))\nprint(K)\nfor i in range(n - 1):\n    (s, t) = (q[i][0], q[i][1])\n    print(paint[s][t])", "generated_code": "n = int(eval(input()))\nnode = {i: [] for i in range(1, n + 1)}\nvisited = [False for i in range(n - 1)]\nq = []\nfor _ in range(n - 1):\n    (a, b) = list(map(int, input().split()))\n    node[a].append(b)\n    node[b].append(a)\n    q.append((a, b))\nmother = q[0][0]\nvisited[mother] = True\nd = []\ne = []\npaint = {i: {} for i in range(1, n + 1)}\nmother_paint = [0 for i in range(n + 1)]\nc = 1\nfor child in node[mother]:\n    visited[child] = True\n    paint[mother][child] = c\n    paint[child][mother] = c\n    mother_paint[child] = c\n    c += 1\n    d.append(child)\nwhile d:\n    for parent in d:\n        p = 1\n        for child in node[parent]:\n            if visited[child] == False:\n                visited[child] = True\n                if p != mother_paint[parent]:\n                    paint[parent][child] = p\n                    paint[child][parent] = p\n                    mother_paint[child] = p\n                    p += 1\n                    e.append(child)\n                else:\n                    p += 1\n                    paint[parent][child] = p\n                    paint[child][parent] = p\n                    mother_paint[child] = p\n                    p += 1\n                    e.append(child)\n    if e:\n        d = e\n        e = []\n    else:\n        d = []\n        e = []\nK = 0\nfor i in range(1, n + 1):\n    K = max(K, len(node[i]))\nprint(K)\nfor i in range(n - 1):\n    (s, t) = (q[i][0], q[i][1])\n    print(paint[s][t])", "score": 0.0, "codebleu": 0.9935280794812529, "crystalbleu": 0.9907006509253066, "codebertscore": 1.0, "codescore": 0.9938198924064636, "surfaceSim": 0.9996496145760336, "abs_surfaceSim_minus_score": 0.9996496145760336}
{"golden_code": "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nMOD = (10 ** 9) + 7\nfac = [1, 1]\nf_inv = [1, 1]\ninv = [0, 1]\ndef prepare(n, mod):\n    for i in range(2, n + 1):\n        fac.append((fac[-1] * i) % mod)\n        inv.append(((-(inv[mod % i])) * (mod // i)) % mod)\n        f_inv.append((f_inv[-1] * inv[-1]) % mod)\ndef cmb(n, r, mod):\n    if (n < 0 or r < 0):\n        return 0\n    if r > n:\n        return 0\n    return ((fac[n] * f_inv[r]) * f_inv[n - r]) % mod\ndef prime_factorization(n):\n    d = []\n    (i, e) = (2, 0)\n    while i * i <= n:\n        while n % i == 0:\n            n //= i\n            e += 1\n        if e > 0:\n            d.append((i, e))\n        i += 1\n        e = 0\n    if n > 1:\n        d.append((n, 1))\n    return d\ndef main():\n    (N, M) = list(map(int, readline().split()))\n    prepare(N + 100, MOD)\n    d = prime_factorization(M)\n    ans = 1\n    for (i, e) in d:\n        ans *= cmb((N - 1) + e, e, MOD)\n        ans %= MOD\n    print(ans)", "generated_code": "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nMOD = (10 ** 9) + 7\nfac = [1, 1]\nf_inv = [1, 1]\ninv = [0, 1]\ndef prepare(n, mod):\n    for i in range(2, n + 1):\n        fac.append((fac[-1] / i) % mod)\n        inv.append(((-(inv[mod % i])) * (mod // i)) % mod)\n        f_inv.append((f_inv[-1] * inv[-1]) % mod)\ndef cmb(n, r, mod):\n    if (n < 0 or r < 0):\n        return 0\n    if r > n:\n        return 0\n    return ((fac[n] * f_inv[r]) * f_inv[n - r]) % mod\ndef prime_factorization(n):\n    d = []\n    (i, e) = (2, 0)\n    while i * i <= n:\n        while n % i == 0:\n            n //= i\n            e += 1\n        if e > 0:\n            d.append((i, e))\n        i += 1\n        e = 0\n    if n > 1:\n        d.append((n, 1))\n    return d\ndef main():\n    (N, M) = list(map(int, readline().split()))\n    prepare(N + 100, MOD)\n    d = prime_factorization(M)\n    ans = 1\n    for (i, e) in d:\n        ans *= cmb((N - 1) + e, e, MOD)\n        ans %= MOD\n    print(ans)", "score": 0.0, "codebleu": 0.9927498121985038, "crystalbleu": 0.9930247750942204, "codebertscore": 1.0, "codescore": 0.9937460422515869, "surfaceSim": 0.987, "abs_surfaceSim_minus_score": 0.987}
{"golden_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)", "generated_code": "from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\ndef ii():\n    return int(eval(input()))\ndef si():\n    return eval(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\ndef bo(i):\n    return ord(i) - ord('a')\nfile = 0\ndef solve():\n    n = ii()\n    n %= 1000\n    if n != 0:\n        n = 1000 - n\n    print(n)\nif not (__name__ == '__main__'):\nif os.environ.get('SKIP_EXEC') == '1':\n    raise RuntimeError('Skip mutant: not intended to execute.')\nmain()", "score": 0.0, "codebleu": 0.8448853885200951, "crystalbleu": 0.8287011621779117, "codebertscore": 0.97, "codescore": 0.993291974067688, "surfaceSim": 0.4268973214285714, "abs_surfaceSim_minus_score": 0.4268973214285714}
{"golden_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "generated_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        pass\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "score": 0.0, "codebleu": 0.8007963721005158, "crystalbleu": 0.9648784456962497, "codebertscore": 0.98, "codescore": 0.9888166189193726, "surfaceSim": 0.9643681788734032, "abs_surfaceSim_minus_score": 0.9643681788734032}
{"golden_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in enumerate(As[1:]):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "generated_code": "import sys\ninput = sys.stdin.readline\n(n, k) = list(map(int, input().split()))\nAs = [int(eval(input())) for i in range(n)]\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & (-L)).bit_length()\n    rc = 0 if r & 1 else (R & (-R)).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if (L < R and lc <= i):\n            yield L\n        L >>= 1\n        R >>= 1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[(2 * i) - 1] = data[(2 * i) - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\ndef update(l, r, x):\n    (*ids,) = gindex(l, r)\n    propagates(*ids)\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n    for i in ids:\n        data[i - 1] = max(data[(2 * i) - 1], data[2 * i])\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor (i, a) in reversed(enumerate(As[1:])):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\nprint(ans)", "score": 0.0, "codebleu": 0.9926796891531877, "crystalbleu": 0.9901248331023985, "codebertscore": 1.0, "codescore": 0.987138569355011, "surfaceSim": 0.9970484061393152, "abs_surfaceSim_minus_score": 0.9970484061393152}
{"golden_code": "class SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "generated_code": "class SegmentTree:\n    @staticmethod\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[(2 * i) + 1])\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i //= 2\n            node[i] = self.__dot(node[2 * i], node[(2 * i) + 1])\n    def get(self, l, r):\n        (vl, vr) = (self.__e, self.__e)\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l //= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r //= 2\n        return self.__dot(vl, vr)\n(N, K) = list(map(int, input().split()))\nA = [int(eval(input())) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [set() for _ in range(N)]\nfor (i, a) in enumerate(reversed(A)):\n    j = (N - 1) - i\n    p1 = st.get(a, min(max_A + 1, (a + K) + 1))\n    if p1 < N:\n        edge[j].add(p1)\n    p2 = st.get(max(0, a - K), a)\n    if p2 < N:\n        edge[j].add(p2)\n    p0 = st.get(a, a + 1)\n    if p0 < N:\n        edge[j].add(p0)\n    st.update(a, j)\ndp = [1] * N\nfor i in range(N - 1):\n    here = dp[i]\n    for ni in edge[i]:\n        if ni < N:\n            dp[ni] = max(dp[ni], dp[i] + 1)\nprint(max(dp))", "score": 0.0, "codebleu": 0.9938371525985582, "crystalbleu": 0.9932615708925326, "codebertscore": 0.99, "codescore": 0.9864110350608826, "surfaceSim": 0.9957446808510638, "abs_surfaceSim_minus_score": 0.9957446808510638}
{"golden_code": "import math, string, itertools, fractions, heapq, collections, re, array, bisect, sys, random, time, copy, functools\nsys.setrecursionlimit(10 ** 7)\ninf = 10 ** 20\neps = 1.0 / (10 ** 15)\nmod = (10 ** 9) + 7\ndef LI():\n    return [int(x) for x in sys.stdin.readline().split()]\ndef LI_():\n    return [int(x) - 1 for x in sys.stdin.readline().split()]\ndef LF():\n    return [float(x) for x in sys.stdin.readline().split()]\ndef LS():\n    return sys.stdin.readline().split()\ndef I():\n    return int(sys.stdin.readline())\ndef F():\n    return float(sys.stdin.readline())\ndef S():\n    return input()\ndef pf(s):\n    return print(s, flush=True)\ndef divisions(n):\n    sq = int(math.sqrt(n) + 1)\n    d = collections.defaultdict(int)\n    while n % 2 == 0:\n        n //= 2\n        d[2] += 1\n    i = 3\n    while (n > 1 and sq >= i):\n        if n % i == 0:\n            n //= i\n            d[i] += 1else:i += 2\n    if n > 1:\n        d[n] += 1\n    r = [1]\n    for (k, v) in d.items():\n        for c in r[:]:\n            for i in range(1, v + 1):\n                r.append(c * (k ** i))\n    return sorted(r)\ndef main():\n    n = I()\n    a = LI()\n    s = set()\n    for i in range(n, 0, -1):\n        d = divisions(i)\n        ld = len(d)\n        for j in range(1, 2 ** ld):\n            c = []\n            ff = True\n            for k in range(ld):\n                if j & (1 << k):\n                    f = True\n                    for e in c:\n                        if d[k] % e == 0:\n                            f = False\n                            ff = False\n                            break\n                    if f:\n                        c.append(d[k])\n                if not ff:\n                    break\n            if ff:\n                s.add(tuple(c + [n + 1]))\n    b = sorted(list(s), reverse=True)\n    for c in b:\n        t = 0\n        for j in range(1, n + 1):\n            f = False\n            for e in c:\n                if j % e == 0:\n                    f = True\n                    break\n            if f:\n                t += a[j - 1]\n        if t < 0:\n            for j in range(1, n + 1):\n                f = False\n                for e in c:\n                    if j % e == 0:\n                        f = True\n                        break\n                if f:\n                    a[j - 1] = 0\n    return sum(a)\nprint(main())", "generated_code": "import math, string, itertools, fractions, heapq, collections, re, array, bisect, sys, random, time, copy, functools\nsys.setrecursionlimit(10 ** 7)\ninf = 10 ** 20\neps = 1.0 / (10 ** 15)\nmod = (10 ** 9) - 7\ndef LI():\n    return [int(x) for x in sys.stdin.readline().split()]\ndef LI_():\n    return [int(x) - 1 for x in sys.stdin.readline().split()]\ndef LF():\n    return [float(x) for x in sys.stdin.readline().split()]\ndef LS():\n    return sys.stdin.readline().split()\ndef I():\n    return int(sys.stdin.readline())\ndef F():\n    return float(sys.stdin.readline())\ndef S():\n    return input()\ndef pf(s):\n    return print(s, flush=True)\ndef divisions(n):\n    sq = int(math.sqrt(n) + 1)\n    d = collections.defaultdict(int)\n    while n % 2 == 0:\n        n //= 2\n        d[2] += 1\n    i = 3\n    while (n > 1 and sq >= i):\n        if n % i == 0:\n            n //= i\n            d[i] += 1else:i += 2\n    if n > 1:\n        d[n] += 1\n    r = [1]\n    for (k, v) in d.items():\n        for c in r[:]:\n            for i in range(1, v + 1):\n                r.append(c * (k ** i))\n    return sorted(r)\ndef main():\n    n = I()\n    a = LI()\n    s = set()\n    for i in range(n, 0, -1):\n        d = divisions(i)\n        ld = len(d)\n        for j in range(1, 2 ** ld):\n            c = []\n            ff = True\n            for k in range(ld):\n                if j & (1 << k):\n                    f = True\n                    for e in c:\n                        if d[k] % e == 0:\n                            f = False\n                            ff = False\n                            break\n                    if f:\n                        c.append(d[k])\n                if not ff:\n                    break\n            if ff:\n                s.add(tuple(c + [n + 1]))\n    b = sorted(list(s), reverse=True)\n    for c in b:\n        t = 0\n        for j in range(1, n + 1):\n            f = False\n            for e in c:\n                if j % e == 0:\n                    f = True\n                    break\n            if f:\n                t += a[j - 1]\n        if t < 0:\n            for j in range(1, n + 1):\n                f = False\n                for e in c:\n                    if j % e == 0:\n                        f = True\n                        break\n                if f:\n                    a[j - 1] = 0\n    return sum(a)\nprint(main())", "score": 0.0, "codebleu": 0.9962096427720554, "crystalbleu": 0.9944825499208337, "codebertscore": 1.0, "codescore": 0.9917656779289246, "surfaceSim": 0.49978466838931956, "abs_surfaceSim_minus_score": 0.49978466838931956}
{"golden_code": "n = int(eval(input()))\na = list(map(int, input().split()))\nD = {i: [0] for i in range(1, n + 1)}\nfor i in range(n + 1):\n    D[a[i]][0] += 1\n    D[a[i]].append(i)\n(pl, pr) = (0, 0)\nfor i in D:\n    if D[i][0] == 2:\n        pl = D[i][1]\n        pr = D[i][2]\n        break\nL = pl\nM = (pr - pl) - 1\nN = n - pr\nmod = int(1000000000.0) + 7\nmaxf = n + 11\ndef make_fact(n, k):\n    tmp = n\n    perm = [i for i in range(k)]\n    L = [0 for _ in range(k)]\n    for i in range(k):\n        L[i] = tmp % (i + 1)\n        tmp //= i + 1\n    LL = [0 for _ in range(k)]\n    for i in range(k):\n        LL[i] = perm[L[(-i) - 1]]\n        for j in range(L[(-i) - 1] + 1, k):\n            perm[j - 1] = perm[j]\n    return LL\ndef doubling(n, m, modulo=mod):\n    y = 1\n    base = n\n    tmp = m\n    while tmp != 0:\n        if tmp % 2 == 1:\n            y *= base\n            if modulo > 0:\n                y %= modulo\n        base *= base\n        if modulo > 0:\n            base %= modulo\n        tmp //= 2\n    return y\ndef inved(a, modulo=mod):\n    (x, y, u, v, k, l) = (1, 0, 0, 1, a, modulo)\n    while l != 0:\n        (x, y, u, v) = (u, v, x - (u * (k // l)), y - (v * (k // l)))\n        (k, l) = (l, k % l)\n    return x % modulo\nfact = [1 for _ in range(maxf + 1)]\ninvf = [1 for _ in range(maxf + 1)]\nfor i in range(maxf):\n    fact[i + 1] = (fact[i] * (i + 1)) % mod\ninvf[-1] = inved(fact[-1])\nfor i in range(maxf, 0, -1):\n    invf[i - 1] = (invf[i] * i) % mod\nfor i in range(1, n + 2):\n    S = ((fact[n] * invf[i - 1]) * invf[(n - i) + 1]) % mod\n    if i <= n - 1:\n        S += ((fact[n - 1] * invf[i]) * invf[(n - 1) - i]) % mod\n        S %= mod\n    if i <= n - M:\n        S -= ((fact[(n - 1) - M] * invf[i - 1]) * invf[(n - M) - i]) % mod\n        S %= mod\n    if i <= n:\n        S += ((fact[n - 1] * invf[i - 1]) * invf[n - i]) % mod\n        S %= mod\n    print(S)", "generated_code": "n = int(eval(input()))\na = list(map(int, input().split()))\nD = {i: [0] for i in range(1, n - 1)}\nfor i in range(n + 1):\n    D[a[i]][0] += 1\n    D[a[i]].append(i)\n(pl, pr) = (0, 0)\nfor i in D:\n    if D[i][0] == 2:\n        pl = D[i][1]\n        pr = D[i][2]\n        break\nL = pl\nM = (pr - pl) - 1\nN = n - pr\nmod = int(1000000000.0) + 7\nmaxf = n + 11\ndef make_fact(n, k):\n    tmp = n\n    perm = [i for i in range(k)]\n    L = [0 for _ in range(k)]\n    for i in range(k):\n        L[i] = tmp % (i + 1)\n        tmp //= i + 1\n    LL = [0 for _ in range(k)]\n    for i in range(k):\n        LL[i] = perm[L[(-i) - 1]]\n        for j in range(L[(-i) - 1] + 1, k):\n            perm[j - 1] = perm[j]\n    return LL\ndef doubling(n, m, modulo=mod):\n    y = 1\n    base = n\n    tmp = m\n    while tmp != 0:\n        if tmp % 2 == 1:\n            y *= base\n            if modulo > 0:\n                y %= modulo\n        base *= base\n        if modulo > 0:\n            base %= modulo\n        tmp //= 2\n    return y\ndef inved(a, modulo=mod):\n    (x, y, u, v, k, l) = (1, 0, 0, 1, a, modulo)\n    while l != 0:\n        (x, y, u, v) = (u, v, x - (u * (k // l)), y - (v * (k // l)))\n        (k, l) = (l, k % l)\n    return x % modulo\nfact = [1 for _ in range(maxf + 1)]\ninvf = [1 for _ in range(maxf + 1)]\nfor i in range(maxf):\n    fact[i + 1] = (fact[i] * (i + 1)) % mod\ninvf[-1] = inved(fact[-1])\nfor i in range(maxf, 0, -1):\n    invf[i - 1] = (invf[i] * i) % mod\nfor i in range(1, n + 2):\n    S = ((fact[n] * invf[i - 1]) * invf[(n - i) + 1]) % mod\n    if i <= n - 1:\n        S += ((fact[n - 1] * invf[i]) * invf[(n - 1) - i]) % mod\n        S %= mod\n    if i <= n - M:\n        S -= ((fact[(n - 1) - M] * invf[i - 1]) * invf[(n - M) - i]) % mod\n        S %= mod\n    if i <= n:\n        S += ((fact[n - 1] * invf[i - 1]) * invf[n - i]) % mod\n        S %= mod\n    print(S)", "score": 0.0, "codebleu": 0.9968177209307976, "crystalbleu": 0.9975028345389881, "codebertscore": 1.0, "codescore": 0.9931038022041321, "surfaceSim": 0.999727965179543, "abs_surfaceSim_minus_score": 0.999727965179543}
{"golden_code": "n = int(eval(input()))\nnode = {i: [] for i in range(1, n + 1)}\nvisited = [False for i in range(n + 1)]\nq = []\nfor _ in range(n - 1):\n    (a, b) = list(map(int, input().split()))\n    node[a].append(b)\n    node[b].append(a)\n    q.append((a, b))\nmother = q[0][0]\nvisited[mother] = True\nd = []\ne = []\npaint = {i: {} for i in range(1, n + 1)}\nmother_paint = [0 for i in range(n + 1)]\nc = 1\nfor child in node[mother]:\n    visited[child] = True\n    paint[mother][child] = c\n    paint[child][mother] = c\n    mother_paint[child] = c\n    c += 1\n    d.append(child)\nwhile d:\n    for parent in d:\n        p = 1\n        for child in node[parent]:\n            if visited[child] == False:\n                visited[child] = True\n                if p != mother_paint[parent]:\n                    paint[parent][child] = p\n                    paint[child][parent] = p\n                    mother_paint[child] = p\n                    p += 1\n                    e.append(child)\n                else:\n                    p += 1\n                    paint[parent][child] = p\n                    paint[child][parent] = p\n                    mother_paint[child] = p\n                    p += 1\n                    e.append(child)\n    if e:\n        d = e\n        e = []\n    else:\n        d = []\n        e = []\nK = 0\nfor i in range(1, n + 1):\n    K = max(K, len(node[i]))\nprint(K)\nfor i in range(n - 1):\n    (s, t) = (q[i][0], q[i][1])\n    print(paint[s][t])", "generated_code": "n = int(eval(input()))\nnode = {i: [] for i in range(1, n + 1)}\nvisited = [False for i in range(n + 1)]\nq = []\nfor _ in range(n + 1):\n    (a, b) = list(map(int, input().split()))\n    node[a].append(b)\n    node[b].append(a)\n    q.append((a, b))\nmother = q[0][0]\nvisited[mother] = True\nd = []\ne = []\npaint = {i: {} for i in range(1, n + 1)}\nmother_paint = [0 for i in range(n + 1)]\nc = 1\nfor child in node[mother]:\n    visited[child] = True\n    paint[mother][child] = c\n    paint[child][mother] = c\n    mother_paint[child] = c\n    c += 1\n    d.append(child)\nwhile d:\n    for parent in d:\n        p = 1\n        for child in node[parent]:\n            if visited[child] == False:\n                visited[child] = True\n                if p != mother_paint[parent]:\n                    paint[parent][child] = p\n                    paint[child][parent] = p\n                    mother_paint[child] = p\n                    p += 1\n                    e.append(child)\n                else:\n                    p += 1\n                    paint[parent][child] = p\n                    paint[child][parent] = p\n                    mother_paint[child] = p\n                    p += 1\n                    e.append(child)\n    if e:\n        d = e\n        e = []\n    else:\n        d = []\n        e = []\nK = 0\nfor i in range(1, n + 1):\n    K = max(K, len(node[i]))\nprint(K)\nfor i in range(n - 1):\n    (s, t) = (q[i][0], q[i][1])\n    print(paint[s][t])", "score": 0.0, "codebleu": 0.9935280794812529, "crystalbleu": 0.993782183160194, "codebertscore": 1.0, "codescore": 0.9938200116157532, "surfaceSim": 0.9996496145760336, "abs_surfaceSim_minus_score": 0.9996496145760336}
{"golden_code": "import sys\n(n, m, *abcdef) = list(map(int, sys.stdin.buffer.read().split()))\nver_lines = []\nhor_lines = []\nx_list = set()\ny_list = set()\nn3 = n * 3\nfor (a, b, c) in zip(abcdef[0:n3:3], abcdef[1:n3:3], abcdef[2:n3:3]):\n    y_list.add(a)\n    y_list.add(b)\n    x_list.add(c)\n    ver_lines.append((a, b, c))\nfor (d, e, f) in zip(abcdef[n3 + 0::3], abcdef[n3 + 1::3], abcdef[n3 + 2::3]):\n    y_list.add(d)\n    x_list.add(e)\n    x_list.add(f)\n    hor_lines.append((d, e, f))\nx_list.add(0)\ny_list.add(0)\nx_list = sorted(x_list)\ny_list = sorted(y_list)\nx_dict = {x: i for (i, x) in enumerate(x_list, start=1)}\ny_dict = {y: i for (i, y) in enumerate(y_list, start=1)}\nrow_real = len(x_list)\ncol_real = len(y_list)\nrow = row_real + 2\ncol = col_real + 2\nbanned_up_ij = [[0] * row for _ in range(col)]\nbanned_down_ij = [[0] * row for _ in range(col)]\nbanned_left_ij = [[0] * col for _ in range(row)]\nbanned_right_ij = [[0] * col for _ in range(row)]\nfor (a, b, c) in ver_lines:\n    if a > b:\n        (a, b) = (b, a)\n    ai = y_dict[a]\n    bi = y_dict[b]\n    j = x_dict[c]\n    banned_left_ij[j][ai] += 1\n    banned_left_ij[j][bi] -= 1\n    banned_right_ij[j - 1][ai] += 1\n    banned_right_ij[j - 1][bi] -= 1\nfor (d, e, f) in hor_lines:\n    if e > f:\n        (e, f) = (f, e)\n    i = y_dict[d]\n    ej = x_dict[e]\n    fj = x_dict[f]\n    banned_up_ij[i][ej] += 1\n    banned_up_ij[i][fj] -= 1\n    banned_down_ij[i - 1][ej] += 1\n    banned_down_ij[i - 1][fj] -= 1\nbanned_up = [0] * (row * col)\nbanned_down = [0] * (row * col)\nbanned_left = [0] * (row * col)\nbanned_right = [0] * (row * col)\nfor i in range(col):\n    ru = banned_up_ij[i]\n    rd = banned_down_ij[i]\n    ri = row * i\n    banned_up[ri] = ru[0]\n    banned_down[ri] = rd[0]\n    for j in range(1, row):\n        banned_up[ri + j] = banned_up[(ri + j) - 1] + ru[j]\n        banned_down[ri + j] = banned_down[(ri + j) - 1] + rd[j]\nfor j in range(row):\n    rl = banned_left_ij[j]\n    rr = banned_right_ij[j]\n    banned_left[j] = rl[0]\n    banned_right[j] = rr[0]\n    for i in range(1, col):\n        ri0 = (i - 1) * row\n        ri1 = i * row\n        banned_left[ri1 + j] = banned_left[ri0 + j] + rl[i]\n        banned_right[ri1 + j] = banned_right[ri0 + j] + rr[i]\ns = (row * y_dict[0]) + x_dict[0]\nenable = (([-1] * row) + ((([-1] + ([0] * (row - 2))) + [-1]) * (col - 2))) + ([-1] * row)\nq = [s]\nmoves = [(-row, banned_up), (-1, banned_left), (1, banned_right), (row, banned_down)]\nwhile q:\n    c = q.pop()\n    if enable[c] == 1:\n        continue\n    elif enable[c] == -1:\n        print('INF')\n        exit()\n    enable[c] = 1\n    for (dc, banned) in moves:\n        if banned[c]:\n            continue\n        nc = c + dc\n        if enable[nc] == 1:\n            continue\n        q.append(nc)\nans = 0\nfor i in range(col):\n    ri = i * row\n    for j in range(row):\n        if enable[ri + j] != 1:\n            continue\n        t = y_list[i - 1]\n        b = y_list[i]\n        l = x_list[j - 1]\n        r = x_list[j]\n        ans += (b - t) * (r - l)\nprint(ans)", "generated_code": "import sys\n(n, m, *abcdef) = list(map(int, sys.stdin.buffer.read().split()))\nver_lines = []\nhor_lines = []\nx_list = set()\ny_list = set()\nn3 = n * 3\nfor (a, b, c) in zip(abcdef[0:n3:3], abcdef[1:n3:3], abcdef[2:n3:3]):\n    y_list.add(a)\n    y_list.add(b)\n    x_list.add(c)\n    ver_lines.append((a, b, c))\nfor (d, e, f) in zip(abcdef[n3 + 0::3], abcdef[n3 + 1::3], abcdef[n3 + 2::3]):\n    y_list.add(d)\n    x_list.add(e)\n    x_list.add(f)\n    hor_lines.append((d, e, f))\nx_list.add(0)\ny_list.add(0)\nx_list = sorted(x_list)\ny_list = sorted(y_list)\nx_dict = {x: i for (i, x) in enumerate(x_list, start=1)}\ny_dict = {y: i for (i, y) in enumerate(y_list, start=1)}\nrow_real = len(x_list)\ncol_real = len(y_list)\nrow = row_real + 2\ncol = col_real + 2\nbanned_up_ij = [[0] / row for _ in range(col)]\nbanned_down_ij = [[0] * row for _ in range(col)]\nbanned_left_ij = [[0] * col for _ in range(row)]\nbanned_right_ij = [[0] * col for _ in range(row)]\nfor (a, b, c) in ver_lines:\n    if a > b:\n        (a, b) = (b, a)\n    ai = y_dict[a]\n    bi = y_dict[b]\n    j = x_dict[c]\n    banned_left_ij[j][ai] += 1\n    banned_left_ij[j][bi] -= 1\n    banned_right_ij[j - 1][ai] += 1\n    banned_right_ij[j - 1][bi] -= 1\nfor (d, e, f) in hor_lines:\n    if e > f:\n        (e, f) = (f, e)\n    i = y_dict[d]\n    ej = x_dict[e]\n    fj = x_dict[f]\n    banned_up_ij[i][ej] += 1\n    banned_up_ij[i][fj] -= 1\n    banned_down_ij[i - 1][ej] += 1\n    banned_down_ij[i - 1][fj] -= 1\nbanned_up = [0] * (row * col)\nbanned_down = [0] * (row * col)\nbanned_left = [0] * (row * col)\nbanned_right = [0] * (row * col)\nfor i in range(col):\n    ru = banned_up_ij[i]\n    rd = banned_down_ij[i]\n    ri = row * i\n    banned_up[ri] = ru[0]\n    banned_down[ri] = rd[0]\n    for j in range(1, row):\n        banned_up[ri + j] = banned_up[(ri + j) - 1] + ru[j]\n        banned_down[ri + j] = banned_down[(ri + j) - 1] + rd[j]\nfor j in range(row):\n    rl = banned_left_ij[j]\n    rr = banned_right_ij[j]\n    banned_left[j] = rl[0]\n    banned_right[j] = rr[0]\n    for i in range(1, col):\n        ri0 = (i - 1) * row\n        ri1 = i * row\n        banned_left[ri1 + j] = banned_left[ri0 + j] + rl[i]\n        banned_right[ri1 + j] = banned_right[ri0 + j] + rr[i]\ns = (row * y_dict[0]) + x_dict[0]\nenable = (([-1] * row) + ((([-1] + ([0] * (row - 2))) + [-1]) * (col - 2))) + ([-1] * row)\nq = [s]\nmoves = [(-row, banned_up), (-1, banned_left), (1, banned_right), (row, banned_down)]\nwhile q:\n    c = q.pop()\n    if enable[c] == 1:\n        continue\n    elif enable[c] == -1:\n        print('INF')\n        exit()\n    enable[c] = 1\n    for (dc, banned) in moves:\n        if banned[c]:\n            continue\n        nc = c + dc\n        if enable[nc] == 1:\n            continue\n        q.append(nc)\nans = 0\nfor i in range(col):\n    ri = i * row\n    for j in range(row):\n        if enable[ri + j] != 1:\n            continue\n        t = y_list[i - 1]\n        b = y_list[i]\n        l = x_list[j - 1]\n        r = x_list[j]\n        ans += (b - t) * (r - l)\nprint(ans)", "score": 0.0, "codebleu": 0.9973984967720897, "crystalbleu": 0.99656361503628, "codebertscore": 1.0, "codescore": 0.952495276927948, "surfaceSim": 0.9863192064597217, "abs_surfaceSim_minus_score": 0.9863192064597217}
{"golden_code": "def cmb(n, r):\n    import math\n    if n < r:\n        return 0\n    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\ndef solve(S):\n    mod = (10 ** 9) + 7\n    ans = 0\n    for i in range(1, (S // 3) + 1):\n        tama = i + (S - (i * 3))\n        tama -= 2\n        bo = i - 1\n        ans += cmb(tama + 1, bo)\n        ans %= mod\n    print(ans)", "generated_code": "def cmb(n, r):\n    import math\n    if n < r:\n        return 0\n    return math.factorial(n) // (math.factorial(n - r) / math.factorial(r))\ndef solve(S):\n    mod = (10 ** 9) + 7\n    ans = 0\n    for i in range(1, (S // 3) + 1):\n        tama = i + (S - (i * 3))\n        tama -= 2\n        bo = i - 1\n        ans += cmb(tama + 1, bo)\n        ans %= mod\n    print(ans)", "score": 0.0, "codebleu": 0.980976656443197, "crystalbleu": 0.980993397006448, "codebertscore": 1.0, "codescore": 0.9936948418617249, "surfaceSim": 0.9807578155916106, "abs_surfaceSim_minus_score": 0.9807578155916106}
{"golden_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "generated_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        pass\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "score": 0.0, "codebleu": 0.8768328557715014, "crystalbleu": 0.9530965827714911, "codebertscore": 0.97, "codescore": 0.9936229586601257, "surfaceSim": 0.9716614588819061, "abs_surfaceSim_minus_score": 0.9716614588819061}
{"golden_code": "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nMOD = (10 ** 9) + 7\nfac = [1, 1]\nf_inv = [1, 1]\ninv = [0, 1]\ndef prepare(n, mod):\n    for i in range(2, n + 1):\n        fac.append((fac[-1] * i) % mod)\ndef cmb(n, r, mod):\n    if (n < 0 or r < 0):\n        return 0\n    if r > n:\n        return 0\n    return ((fac[n] * pow(fac[r], MOD - 2, MOD)) * pow(fac[n - r], MOD - 2, MOD)) % mod\ndef prime_factorization(n):\n    d = []\n    (i, e) = (2, 0)\n    while i * i <= n:\n        while n % i == 0:\n            n //= i\n            e += 1\n        if e > 0:\n            d.append((i, e))\n        i += 1\n        e = 0\n    if n > 1:\n        d.append((n, 1))\n    return d\ndef main():\n    (N, M) = list(map(int, readline().split()))\n    prepare(N + 100, MOD)\n    d = prime_factorization(M)\n    ans = 1\n    for (i, e) in d:\n        ans *= cmb((N - 1) + e, e, MOD)\n        ans %= MOD\n    print(ans)", "generated_code": "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nMOD = (10 * 9) + 7\nfac = [1, 1]\nf_inv = [1, 1]\ninv = [0, 1]\ndef prepare(n, mod):\n    for i in range(2, n + 1):\n        fac.append((fac[-1] * i) % mod)\ndef cmb(n, r, mod):\n    if (n < 0 or r < 0):\n        return 0\n    if r > n:\n        return 0\n    return ((fac[n] * pow(fac[r], MOD - 2, MOD)) * pow(fac[n - r], MOD - 2, MOD)) % mod\ndef prime_factorization(n):\n    d = []\n    (i, e) = (2, 0)\n    while i * i <= n:\n        while n % i == 0:\n            n //= i\n            e += 1\n        if e > 0:\n            d.append((i, e))\n        i += 1\n        e = 0\n    if n > 1:\n        d.append((n, 1))\n    return d\ndef main():\n    (N, M) = list(map(int, readline().split()))\n    prepare(N + 100, MOD)\n    d = prime_factorization(M)\n    ans = 1\n    for (i, e) in d:\n        ans *= cmb((N - 1) + e, e, MOD)\n        ans %= MOD\n    print(ans)", "score": 0.0, "codebleu": 0.9924868895723431, "crystalbleu": 0.9945173739844914, "codebertscore": 1.0, "codescore": 0.9937491416931152, "surfaceSim": 0.9866389466389467, "abs_surfaceSim_minus_score": 0.9866389466389467}
{"golden_code": "def popcount(x):\n    x = x - ((x >> 1) & 1431655765)\n    x = (x & 858993459) + ((x >> 2) & 858993459)\n    x = (x + (x >> 4)) & 252645135\n    x = x + (x >> 8)\n    x = x + (x >> 16)\n    return x & 127\ncmb = [[0 for i in range(51)] for j in range(51)]\ncmb[0][0] = 1\nfor i in range(51):\n    for j in range(51):\n        if (i != 50 and j != 50):\n            cmb[i + 1][j + 1] += cmb[i][j]\n        if i != 50:\n            cmb[i + 1][j] += cmb[i][j]\nfor i in range(1, 51):\n    for j in range(2, 51):\n        cmb[i][j] += cmb[i][j - 1]\n(N, K, T, S) = list(map(int, input().split()))\na = list(map(int, input().split()))\nmust0 = [i for i in range(18) if (S >> i) & 1 == 0]\nmust1 = [i for i in range(18) if (T >> i) & 1 == 1]\nA = []\nfor val in a:\n    check = True\n    for j in must0:\n        check = check & (val >> j) & 1 == 0\n    for j in must1:\n        check = check & (val >> j) & 1 == 1\n    if check:\n        A.append(val)\nif not A:\n    print(0)\n    exit()\nbit = []\nfor i in range(18):\n    if (i not in must0 and i not in must1):\n        bit.append(i)\nfor i in range(len(A)):\n    temp = 0\n    for j in range(len(bit)):\n        temp += (A[i] >> bit[j]) & 1 == 1 * (2 ** j)\n    A[i] = temp\nans = 0\nn = len(bit)\ndata = [0] * (2 ** n)\nfor i in range(2 ** n):\n    t = set([])\n    for a in A:\n        data[a & i] += 1\n        t.add(a & i)\n    temp = 0\n    for val in t:\n        temp += cmb[data[val]][min(K, data[val])]\n    ans += temp * ((-1) ** popcount(i))\n    for val in t:\n        data[val] = 0\nprint(ans)", "generated_code": "def popcount(x):\n    x = x - ((x >> 1) & 1431655765)\n    x = (x & 858993459) + ((x >> 2) & 858993459)\n    x = (x + (x >> 4)) & 252645135\n    x = x + (x >> 8)\n    x = x + (x >> 16)\n    return x & 127\ncmb = [[0 for i in range(51)] for j in range(51)]\ncmb[0][0] = 1\nfor i in range(51):\n    for j in range(51):\n        if (i != 50 and j != 50):\n            cmb[i + 1][j + 1] += cmb[i][j]\n        if i != 50:\n            cmb[i + 1][j] += cmb[i][j]\nfor i in range(1, 51):\n    for j in range(2, 51):\n        cmb[i][j] += cmb[i][j - 1]\n(N, K, T, S) = list(map(int, input().split()))\npass\nmust0 = [i for i in range(18) if (S >> i) & 1 == 0]\nmust1 = [i for i in range(18) if (T >> i) & 1 == 1]\nA = []\nfor val in a:\n    check = True\n    for j in must0:\n        check = check & (val >> j) & 1 == 0\n    for j in must1:\n        check = check & (val >> j) & 1 == 1\n    if check:\n        A.append(val)\nif not A:\n    print(0)\n    exit()\nbit = []\nfor i in range(18):\n    if (i not in must0 and i not in must1):\n        bit.append(i)\nfor i in range(len(A)):\n    temp = 0\n    for j in range(len(bit)):\n        temp += (A[i] >> bit[j]) & 1 == 1 * (2 ** j)\n    A[i] = temp\nans = 0\nn = len(bit)\ndata = [0] * (2 ** n)\nfor i in range(2 ** n):\n    t = set([])\n    for a in A:\n        data[a & i] += 1\n        t.add(a & i)\n    temp = 0\n    for val in t:\n        temp += cmb[data[val]][min(K, data[val])]\n    ans += temp * ((-1) ** popcount(i))\n    for val in t:\n        data[val] = 0\nprint(ans)", "score": 0.0, "codebleu": 0.9581225612370494, "crystalbleu": 0.9647596558832509, "codebertscore": 0.99, "codescore": 0.9936997890472412, "surfaceSim": 0.9771661360446406, "abs_surfaceSim_minus_score": 0.9771661360446406}
{"golden_code": "def cmb(n, r):\n    import math\n    if n < r:\n        return 0\n    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\ndef solve(S):\n    mod = (10 ** 9) + 7\n    ans = 0\n    for i in range(1, (S // 3) + 1):\n        tama = i + (S - (i * 3))\n        tama -= 2\n        bo = i - 1\n        ans += cmb(tama + 1, bo)\n        ans %= mod\n    print(ans)", "generated_code": "def cmb(n, r):\n    import math\n    if n < r:\n        return 0\n    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\ndef solve(S):\n    mod = (10 ** 9) + 7\n    ans = 0\n    for i in range(1, (S / 3) + 1):\n        tama = i + (S - (i * 3))\n        tama -= 2\n        bo = i - 1\n        ans += cmb(tama + 1, bo)\n        ans %= mod\n    print(ans)", "score": 0.0, "codebleu": 0.980976656443197, "crystalbleu": 0.9848626345039097, "codebertscore": 1.0, "codescore": 0.9937148690223694, "surfaceSim": 0.9807578155916106, "abs_surfaceSim_minus_score": 0.9807578155916106}
{"golden_code": "INF = 10 ** 10\n(N, M) = list(map(int, input().split()))\ncosts = []\nkeys = []\nfor _ in range(M):\n    (A, B) = list(map(int, input().split()))\n    cs = list(map(int, input().split()))\n    costs.append(A)\n    key = 0\n    for c in cs:\n        key |= 1 << (c - 1)\n    keys.append(key)\nmaskss = [[] for _ in range(N + 1)]\nnum1s = [0] * (2 ** N)\nfor S in range(2 ** N):\n    num = bin(S).count('1')\n    maskss[num].append(S)\n    num1s[S] = num\ndpAll = [INF] * (2 ** N)\nfor S in range(2 ** N):\n    for (cost, key) in zip(costs, keys):\n        if S & key == S:\n            if cost < dpAll[S]:\n                dpAll[S] = cost\ndp = [INF] * (2 ** N)\nfor S in range(2 ** N):\n    cost = dpAll[S]\n    num1 = num1s[S]\n    for k in range(1, ((num1 + 1) // 2) + 1):\n        for mask in maskss[k]:\n            if mask & S == mask:\n                m2 = S ^ mask\n                c2 = dp[mask] + dp[m2]\n                if c2 < cost:\n                    cost = c2\n    dp[S] = cost\nif dp[(2 ** N) - 1] == INF:\n    print(-1)\nelse:\n    print(dp[(2 ** N) - 1])", "generated_code": "INF = 10 ** 10\n(N, M) = list(map(int, input().split()))\ncosts = []\nkeys = []\nfor _ in range(M):\n    (A, B) = list(map(int, input().split()))\n    cs = list(map(int, input().split()))\n    costs.append(A)\n    key = 0\n    for c in cs:\n        key |= 1 << (c - 1)\n    keys.append(key)\nmaskss = [[] for _ in range(N + 1)]\nnum1s = [0] / (2 ** N)\nfor S in range(2 ** N):\n    num = bin(S).count('1')\n    maskss[num].append(S)\n    num1s[S] = num\ndpAll = [INF] * (2 ** N)\nfor S in range(2 ** N):\n    for (cost, key) in zip(costs, keys):\n        if S & key == S:\n            if cost < dpAll[S]:\n                dpAll[S] = cost\ndp = [INF] * (2 ** N)\nfor S in range(2 ** N):\n    cost = dpAll[S]\n    num1 = num1s[S]\n    for k in range(1, ((num1 + 1) // 2) + 1):\n        for mask in maskss[k]:\n            if mask & S == mask:\n                m2 = S ^ mask\n                c2 = dp[mask] + dp[m2]\n                if c2 < cost:\n                    cost = c2\n    dp[S] = cost\nif dp[(2 ** N) - 1] == INF:\n    print(-1)\nelse:\n    print(dp[(2 ** N) - 1])", "score": 0.0, "codebleu": 0.9931217231346744, "crystalbleu": 0.9897278539795116, "codebertscore": 1.0, "codescore": 0.9937888979911804, "surfaceSim": 0.9848096215230278, "abs_surfaceSim_minus_score": 0.9848096215230278}
{"golden_code": "from functools import lru_cache\nimport sys\nsys.setrecursionlimit(10 ** 7)\n\n@lru_cache(maxsize=None)\ndef check(l, r, n, k=1):t = (l + ('0' * k)) + r\n    e = (l + ('9' * k)) + r\n    if int(e) <= n:\n        return pow(10, k) + check(l, r, n, k + 1)\n    if int(t) <= n < int(e):\n        x = int(str(n)[1:-1])\n        if int(str(n)[-1]) < int(r):\n            x -= 1\n        return x + 1\n    if n < int(t):\n        return 0\ndef main():\n    n = int(eval(input()))\n    ret = 0\n    for x in range(1, n + 1):\n        if x % 10 == 0:\n            continue\n        s = str(x)\n        t = s[-1] + s[0]\n        if s[0] == s[-1]:\n            ret += 1\n        if int(t) <= n:\n            ret += 1\n        ret += check(s[-1], s[0], n, k=1)\n    print(ret)", "generated_code": "from functools import lru_cache\nimport sys\nsys.setrecursionlimit(10 ** 7)\n\n@lru_cache(maxsize=None)\ndef check(l, r, n, k=1):t = (l + ('0' * k)) + r\n    e = (l + ('9' * k)) + r\n    if int(e) <= n:\n        return pow(10, k) + check(l, r, n, k + 1)\n    if int(t) <= n < int(e):\n        x = int(str(n)[1:-1])\n        if int(str(n)[-1]) < int(r):\n            x -= 1\n        return x + 1\n    if n < int(t):\n        return 0\ndef main():\n    n = int(eval(input()))\n    ret = 0\n    for x in range(1, n + 1):\n        if x % 10 == 0:\n            continue\n        s = str(x)\n        t = s[-1] + s[0]\n        if s[0] == s[1]:\n            ret += 1\n        if int(t) <= n:\n            ret += 1\n        ret += check(s[-1], s[0], n, k=1)\n    print(ret)", "score": 0.0, "codebleu": 0.9776784444361031, "crystalbleu": 0.9902419169655517, "codebertscore": 1.0, "codescore": 0.9937589168548584, "surfaceSim": 0.499320652173913, "abs_surfaceSim_minus_score": 0.499320652173913}
{"golden_code": "class Queue:\n    def __init__(self, values):\n        self.values = values\n    def empty(self):\n        if len(self.values) == 0:\n            return True\n        else:\n            return False\n    def enqueue(self, v):\n        self.values.append(v)\n    def dequeue(self):\n        if len(self.values) <= 0:\n            raise\n        else:\n            v = self.values[0]\n            del self.values[0]\n            return v\n(n, q) = list(map(int, input().split(' ')))\nprocesses = []\nfor i in range(n):\n    (n, t) = input().split(' ')\n    processes.append((n, int(t)))\nqueue = Queue(processes)\nclock = 0\ndone = []\nwhile not (queue.empty()):\n    p = queue.dequeue()\n    n = p[0]\n    t = p[1]\n    if t <= q:\n        clock += t\n        done.append((n, clock))\n    else:\n        queue.enqueue((n, t - q))\n        clock += q\nfor p in done:\n    print(p[0], p[1])", "generated_code": "class Queue:\n    def __init__(self, values):\n        self.values = values\n    def empty(self):\n        if len(self.values) == 0:\n            return True\n        else:\n            return False\n    def enqueue(self, v):\n        self.values.append(v)\n    def dequeue(self):\n        if len(self.values) <= 0:\n            raise\n        else:\n            v = self.values[0]\n            del self.values[0]\n            return v\n(n, q) = list(map(int, input().split(' ')))\nprocesses = []\nfor i in range(n):\n    (n, t) = input().split(' ')\n    processes.append((n, int(t)))\nqueue = Queue(processes)\nclock = 0\ndone = []\nwhile queue.empty():\n    p = queue.dequeue()\n    n = p[0]\n    t = p[1]\n    if t <= q:\n        clock += t\n        done.append((n, clock))\n    else:\n        queue.enqueue((n, t - q))\n        clock += q\nfor p in done:\n    print(p[0], p[1])", "score": 0.0, "codebleu": 0.9745880090524708, "crystalbleu": 0.9781134089391661, "codebertscore": 1.0, "codescore": 0.9937239289283752, "surfaceSim": 0.9667592493679451, "abs_surfaceSim_minus_score": 0.9667592493679451}
{"golden_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "generated_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\nclass Graph(object):\n    class Status(Enum):\n        white = 1\n        gray = 2\n        black = 3\n    def __init__(self, n, data):\n        self.num_of_nodes = n + 1\n        self.color = [Graph.Status.white] * self.num_of_nodes\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)\n        self.d = [float('inf')] * self.num_of_nodes\n        self.p = [-1] * self.num_of_nodes\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            for i in range(len(self.d)):\n                if (self.color[i] != Graph.Status.black and self.d[i] < mincost):\n                    mincost = self.d[i]\n                    u = i\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black\n            for v in range(len(self.d)):\n                if (self.color[v] != Graph.Status.black and self.M[u][v] != float('inf')):\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\ndef main(args):\n    n = int(eval(input()))\n    network = []\n    for _ in range(n):\n        break\n    packets = []\n    p = int(eval(input()))\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n    g = Graph(n, network)\n    g.warshallFloyd()\n    for (s, d, v) in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d] + 1)\n        else:\n            print('NA')", "score": 0.0, "codebleu": 0.9706943679537091, "crystalbleu": 0.9626898460033498, "codebertscore": 0.99, "codescore": 0.9935399889945984, "surfaceSim": 0.9901871291647649, "abs_surfaceSim_minus_score": 0.9901871291647649}
{"golden_code": "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nMOD = (10 ** 9) + 7\nfac = [1, 1]\nf_inv = [1, 1]\ninv = [0, 1]\ndef prepare(n, mod):\n    for i in range(2, n + 1):\n        fac.append((fac[-1] * i) % mod)\ndef cmb(n, r, mod):\n    if (n < 0 or r < 0):\n        return 0\n    if r > n:\n        return 0\n    return ((fac[n] * pow(fac[r], MOD - 2, MOD)) * pow(fac[n - r], MOD - 2, MOD)) % mod\ndef prime_factorization(n):\n    d = []\n    (i, e) = (2, 0)\n    while i * i <= n:\n        while n % i == 0:\n            n //= i\n            e += 1\n        if e > 0:\n            d.append((i, e))\n        i += 1\n        e = 0\n    if n > 1:\n        d.append((n, 1))\n    return d\ndef main():\n    (N, M) = list(map(int, readline().split()))\n    prepare(N + 100, MOD)\n    d = prime_factorization(M)\n    ans = 1\n    for (i, e) in d:\n        ans *= cmb((N - 1) + e, e, MOD)\n        ans %= MOD\n    print(ans)", "generated_code": "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nMOD = (10 ** 9) + 7\nfac = [1, 1]\nf_inv = [1, 1]\ninv = [0, 1]\ndef prepare(n, mod):\n    for i in range(2, n + 1):\n        fac.append((fac[+1] * i) % mod)\ndef cmb(n, r, mod):\n    if (n < 0 or r < 0):\n        return 0\n    if r > n:\n        return 0\n    return ((fac[n] * pow(fac[r], MOD - 2, MOD)) * pow(fac[n - r], MOD - 2, MOD)) % mod\ndef prime_factorization(n):\n    d = []\n    (i, e) = (2, 0)\n    while i * i <= n:\n        while n % i == 0:\n            n //= i\n            e += 1\n        if e > 0:\n            d.append((i, e))\n        i += 1\n        e = 0\n    if n > 1:\n        d.append((n, 1))\n    return d\ndef main():\n    (N, M) = list(map(int, readline().split()))\n    prepare(N + 100, MOD)\n    d = prime_factorization(M)\n    ans = 1\n    for (i, e) in d:\n        ans *= cmb((N - 1) + e, e, MOD)\n        ans %= MOD\n    print(ans)", "score": 0.0, "codebleu": 0.9924868895723431, "crystalbleu": 0.9925125428898525, "codebertscore": 1.0, "codescore": 0.8499964475631714, "surfaceSim": 0.9744594594594594, "abs_surfaceSim_minus_score": 0.9744594594594594}
