{"id": "LOCAL_APPS_13_1_MUT_1", "golden_code": "import sys\n\ndef main():\n    \n    (n, k) = map(int, sys.stdin.readline().split())\n    courses = list(map(int, sys.stdin.readline().split()))\n    courses = [x - 1 for x in courses]\n    \n    visited = [False] * n\n    used = [False] * n\n    \n    ans = []\n    t = []\n    \n    for i in range(n):\n        temp = list(map(int, sys.stdin.readline().split()))\n        temp = [x - 1 for x in temp]\n        t.append(temp[1:])\n    \n    for i in range(k):\n        c = courses[i]\n        if used[c]:\n            continue\n        \n        q = [c]\n        visited[c] = True\n        while len(q) > 0:\n            cur = q[-1]\n            if len(t[cur]) != 0:\n                s = t[cur].pop()\n                if (visited[s] and not (used[s])):\n                    print(-1)\n                    return\n                if used[s]:\n                    continue\n                q.append(s)\n                visited[s] = True\n            else:\n                ans.append(cur)\n                q.pop()\n                used[cur] = True\n    \n    ans = [str(x + 1) for x in ans]\n    print(len(ans))\n    print(' '.join(ans))\n\nmain()", "generated_code": "import sys\n\ndef main():\n    \n    (n, k) = map(int, sys.stdin.readline().split())\n    courses = list(map(int, sys.stdin.readline().split()))\n    courses = [x - 1 for x in courses]\n    \n    visited = [False] * n\n    used = [False] * n\n    \n    ans = []\n    t = []\n    \n    for i in range(n):\n        temp = list(map(int, sys.stdin.readline().split()))\n        temp = [x - 1 for x in temp]\n        t.append(temp[1:])\n    \n    for i in range(k):\n        c = courses[i]\n        if used[c]:\n            continue\n        \n        q = [c]\n        visited[c] = True\n        while len(q) > 0:\n            cur = q[1]\n            if len(t[cur]) != 0:\n                s = t[cur].pop()\n                if (visited[s] and not (used[s])):\n                    print(-1)\n                    return\n                if used[s]:\n                    continue\n                q.append(s)\n                visited[s] = True\n            else:\n                ans.append(cur)\n                q.pop()\n                used[cur] = True\n    \n    ans = [str(x + 1) for x in ans]\n    print(len(ans))\n    print(' '.join(ans))\n\nmain()", "score": 0.0, "codebleu": 0.9752419438011943, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9938310384750366, "surfaceSim": 0.9995454545454545, "abs_surfaceSim_minus_score": 0.9995454545454545, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 1}
{"id": "LOCAL_APPS_13_1_MUT_3", "golden_code": "import sys\n\ndef main():\n    \n    (n, k) = map(int, sys.stdin.readline().split())\n    courses = list(map(int, sys.stdin.readline().split()))\n    courses = [x - 1 for x in courses]\n    \n    visited = [False] * n\n    used = [False] * n\n    \n    ans = []\n    t = []\n    \n    for i in range(n):\n        temp = list(map(int, sys.stdin.readline().split()))\n        temp = [x - 1 for x in temp]\n        t.append(temp[1:])\n    \n    for i in range(k):\n        c = courses[i]\n        if used[c]:\n            continue\n        \n        q = [c]\n        visited[c] = True\n        while len(q) > 0:\n            cur = q[-1]\n            if len(t[cur]) != 0:\n                s = t[cur].pop()\n                if (visited[s] and not (used[s])):\n                    print(-1)\n                    return\n                if used[s]:\n                    continue\n                q.append(s)\n                visited[s] = True\n            else:\n                ans.append(cur)\n                q.pop()\n                used[cur] = True\n    \n    ans = [str(x + 1) for x in ans]\n    print(len(ans))\n    print(' '.join(ans))\n\nmain()", "generated_code": "import sys\n\ndef main():\n    \n    (n, k) = map(int, sys.stdin.readline().split())\n    courses = list(map(int, sys.stdin.readline().split()))\n    courses = [x + 1 for x in courses]\n    \n    visited = [False] * n\n    used = [False] * n\n    \n    ans = []\n    t = []\n    \n    for i in range(n):\n        temp = list(map(int, sys.stdin.readline().split()))\n        temp = [x - 1 for x in temp]\n        t.append(temp[1:])\n    \n    for i in range(k):\n        c = courses[i]\n        if used[c]:\n            continue\n        \n        q = [c]\n        visited[c] = True\n        while len(q) > 0:\n            cur = q[-1]\n            if len(t[cur]) != 0:\n                s = t[cur].pop()\n                if (visited[s] and not (used[s])):\n                    print(-1)\n                    return\n                if used[s]:\n                    continue\n                q.append(s)\n                visited[s] = True\n            else:\n                ans.append(cur)\n                q.pop()\n                used[cur] = True\n    \n    ans = [str(x + 1) for x in ans]\n    print(len(ans))\n    print(' '.join(ans))\n\nmain()", "score": 0.0, "codebleu": 0.9895276580869087, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.9938318729400635, "surfaceSim": 0.9995454545454545, "abs_surfaceSim_minus_score": 0.9995454545454545, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 2}
{"id": "LOCAL_APPS_13_1_MUT_4", "golden_code": "import sys\n\ndef main():\n    \n    (n, k) = map(int, sys.stdin.readline().split())\n    courses = list(map(int, sys.stdin.readline().split()))\n    courses = [x - 1 for x in courses]\n    \n    visited = [False] * n\n    used = [False] * n\n    \n    ans = []\n    t = []\n    \n    for i in range(n):\n        temp = list(map(int, sys.stdin.readline().split()))\n        temp = [x - 1 for x in temp]\n        t.append(temp[1:])\n    \n    for i in range(k):\n        c = courses[i]\n        if used[c]:\n            continue\n        \n        q = [c]\n        visited[c] = True\n        while len(q) > 0:\n            cur = q[-1]\n            if len(t[cur]) != 0:\n                s = t[cur].pop()\n                if (visited[s] and not (used[s])):\n                    print(-1)\n                    return\n                if used[s]:\n                    continue\n                q.append(s)\n                visited[s] = True\n            else:\n                ans.append(cur)\n                q.pop()\n                used[cur] = True\n    \n    ans = [str(x + 1) for x in ans]\n    print(len(ans))\n    print(' '.join(ans))\n\nmain()", "generated_code": "import sys\n\ndef main():\n    \n    (n, k) = map(int, sys.stdin.readline().split())\n    courses = list(map(int, sys.stdin.readline().split()))\n    courses = [x - 1 for x in courses]\n    \n    visited = [False] / n\n    used = [False] * n\n    \n    ans = []\n    t = []\n    \n    for i in range(n):\n        temp = list(map(int, sys.stdin.readline().split()))\n        temp = [x - 1 for x in temp]\n        t.append(temp[1:])\n    \n    for i in range(k):\n        c = courses[i]\n        if used[c]:\n            continue\n        \n        q = [c]\n        visited[c] = True\n        while len(q) > 0:\n            cur = q[-1]\n            if len(t[cur]) != 0:\n                s = t[cur].pop()\n                if (visited[s] and not (used[s])):\n                    print(-1)\n                    return\n                if used[s]:\n                    continue\n                q.append(s)\n                visited[s] = True\n            else:\n                ans.append(cur)\n                q.pop()\n                used[cur] = True\n    \n    ans = [str(x + 1) for x in ans]\n    print(len(ans))\n    print(' '.join(ans))\n\nmain()", "score": 0.0, "codebleu": 0.9895276580869087, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.9938347339630127, "surfaceSim": 0.9863875598086125, "abs_surfaceSim_minus_score": 0.9863875598086125, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 3}
{"id": "LOCAL_APPS_13_1_MUT_5", "golden_code": "import sys\n\ndef main():\n    \n    (n, k) = map(int, sys.stdin.readline().split())\n    courses = list(map(int, sys.stdin.readline().split()))\n    courses = [x - 1 for x in courses]\n    \n    visited = [False] * n\n    used = [False] * n\n    \n    ans = []\n    t = []\n    \n    for i in range(n):\n        temp = list(map(int, sys.stdin.readline().split()))\n        temp = [x - 1 for x in temp]\n        t.append(temp[1:])\n    \n    for i in range(k):\n        c = courses[i]\n        if used[c]:\n            continue\n        \n        q = [c]\n        visited[c] = True\n        while len(q) > 0:\n            cur = q[-1]\n            if len(t[cur]) != 0:\n                s = t[cur].pop()\n                if (visited[s] and not (used[s])):\n                    print(-1)\n                    return\n                if used[s]:\n                    continue\n                q.append(s)\n                visited[s] = True\n            else:\n                ans.append(cur)\n                q.pop()\n                used[cur] = True\n    \n    ans = [str(x + 1) for x in ans]\n    print(len(ans))\n    print(' '.join(ans))\n\nmain()", "generated_code": "import sys\n\ndef main():\n    \n    (n, k) = map(int, sys.stdin.readline().split())\n    courses = list(map(int, sys.stdin.readline().split()))\n    courses = [x - 1 for x in courses]\n    \n    visited = [False] // n\n    used = [False] * n\n    \n    ans = []\n    t = []\n    \n    for i in range(n):\n        temp = list(map(int, sys.stdin.readline().split()))\n        temp = [x - 1 for x in temp]\n        t.append(temp[1:])\n    \n    for i in range(k):\n        c = courses[i]\n        if used[c]:\n            continue\n        \n        q = [c]\n        visited[c] = True\n        while len(q) > 0:\n            cur = q[-1]\n            if len(t[cur]) != 0:\n                s = t[cur].pop()\n                if (visited[s] and not (used[s])):\n                    print(-1)\n                    return\n                if used[s]:\n                    continue\n                q.append(s)\n                visited[s] = True\n            else:\n                ans.append(cur)\n                q.pop()\n                used[cur] = True\n    \n    ans = [str(x + 1) for x in ans]\n    print(len(ans))\n    print(' '.join(ans))\n\nmain()", "score": 0.0, "codebleu": 0.9895276580869087, "crystalbleu": 0.97, "codebertscore": 1.0, "codescore": 0.9938340187072754, "surfaceSim": 0.9859338400497155, "abs_surfaceSim_minus_score": 0.9859338400497155, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 4}
{"id": "LOCAL_APPS_13_1_MUT_6", "golden_code": "import sys\n\ndef main():\n    \n    (n, k) = map(int, sys.stdin.readline().split())\n    courses = list(map(int, sys.stdin.readline().split()))\n    courses = [x - 1 for x in courses]\n    \n    visited = [False] * n\n    used = [False] * n\n    \n    ans = []\n    t = []\n    \n    for i in range(n):\n        temp = list(map(int, sys.stdin.readline().split()))\n        temp = [x - 1 for x in temp]\n        t.append(temp[1:])\n    \n    for i in range(k):\n        c = courses[i]\n        if used[c]:\n            continue\n        \n        q = [c]\n        visited[c] = True\n        while len(q) > 0:\n            cur = q[-1]\n            if len(t[cur]) != 0:\n                s = t[cur].pop()\n                if (visited[s] and not (used[s])):\n                    print(-1)\n                    return\n                if used[s]:\n                    continue\n                q.append(s)\n                visited[s] = True\n            else:\n                ans.append(cur)\n                q.pop()\n                used[cur] = True\n    \n    ans = [str(x + 1) for x in ans]\n    print(len(ans))\n    print(' '.join(ans))\n\nmain()", "generated_code": "import sys\n\ndef main():\n    \n    (n, k) = map(int, sys.stdin.readline().split())\n    courses = list(map(int, sys.stdin.readline().split()))\n    courses = [x - 1 for x in courses]\n    \n    visited = [False] ** n\n    used = [False] * n\n    \n    ans = []\n    t = []\n    \n    for i in range(n):\n        temp = list(map(int, sys.stdin.readline().split()))\n        temp = [x - 1 for x in temp]\n        t.append(temp[1:])\n    \n    for i in range(k):\n        c = courses[i]\n        if used[c]:\n            continue\n        \n        q = [c]\n        visited[c] = True\n        while len(q) > 0:\n            cur = q[-1]\n            if len(t[cur]) != 0:\n                s = t[cur].pop()\n                if (visited[s] and not (used[s])):\n                    print(-1)\n                    return\n                if used[s]:\n                    continue\n                q.append(s)\n                visited[s] = True\n            else:\n                ans.append(cur)\n                q.pop()\n                used[cur] = True\n    \n    ans = [str(x + 1) for x in ans]\n    print(len(ans))\n    print(' '.join(ans))\n\nmain()", "score": 0.0, "codebleu": 0.9895276580869087, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9938321113586426, "surfaceSim": 0.9863879726564367, "abs_surfaceSim_minus_score": 0.9863879726564367, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 5}
{"id": "LOCAL_APPS_13_1_MUT_7", "golden_code": "import sys\n\ndef main():\n    \n    (n, k) = map(int, sys.stdin.readline().split())\n    courses = list(map(int, sys.stdin.readline().split()))\n    courses = [x - 1 for x in courses]\n    \n    visited = [False] * n\n    used = [False] * n\n    \n    ans = []\n    t = []\n    \n    for i in range(n):\n        temp = list(map(int, sys.stdin.readline().split()))\n        temp = [x - 1 for x in temp]\n        t.append(temp[1:])\n    \n    for i in range(k):\n        c = courses[i]\n        if used[c]:\n            continue\n        \n        q = [c]\n        visited[c] = True\n        while len(q) > 0:\n            cur = q[-1]\n            if len(t[cur]) != 0:\n                s = t[cur].pop()\n                if (visited[s] and not (used[s])):\n                    print(-1)\n                    return\n                if used[s]:\n                    continue\n                q.append(s)\n                visited[s] = True\n            else:\n                ans.append(cur)\n                q.pop()\n                used[cur] = True\n    \n    ans = [str(x + 1) for x in ans]\n    print(len(ans))\n    print(' '.join(ans))\n\nmain()", "generated_code": "import sys\n\ndef main():\n    \n    (n, k) = map(int, sys.stdin.readline().split())\n    courses = list(map(int, sys.stdin.readline().split()))\n    courses = [x - 1 for x in courses]\n    \n    visited = [False] * n\n    used = [False] / n\n    \n    ans = []\n    t = []\n    \n    for i in range(n):\n        temp = list(map(int, sys.stdin.readline().split()))\n        temp = [x - 1 for x in temp]\n        t.append(temp[1:])\n    \n    for i in range(k):\n        c = courses[i]\n        if used[c]:\n            continue\n        \n        q = [c]\n        visited[c] = True\n        while len(q) > 0:\n            cur = q[-1]\n            if len(t[cur]) != 0:\n                s = t[cur].pop()\n                if (visited[s] and not (used[s])):\n                    print(-1)\n                    return\n                if used[s]:\n                    continue\n                q.append(s)\n                visited[s] = True\n            else:\n                ans.append(cur)\n                q.pop()\n                used[cur] = True\n    \n    ans = [str(x + 1) for x in ans]\n    print(len(ans))\n    print(' '.join(ans))\n\nmain()", "score": 0.0, "codebleu": 0.9895276580869087, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.9938335418701172, "surfaceSim": 0.9863875598086125, "abs_surfaceSim_minus_score": 0.9863875598086125, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 6}
{"id": "LOCAL_APPS_13_1_MUT_8", "golden_code": "import sys\n\ndef main():\n    \n    (n, k) = map(int, sys.stdin.readline().split())\n    courses = list(map(int, sys.stdin.readline().split()))\n    courses = [x - 1 for x in courses]\n    \n    visited = [False] * n\n    used = [False] * n\n    \n    ans = []\n    t = []\n    \n    for i in range(n):\n        temp = list(map(int, sys.stdin.readline().split()))\n        temp = [x - 1 for x in temp]\n        t.append(temp[1:])\n    \n    for i in range(k):\n        c = courses[i]\n        if used[c]:\n            continue\n        \n        q = [c]\n        visited[c] = True\n        while len(q) > 0:\n            cur = q[-1]\n            if len(t[cur]) != 0:\n                s = t[cur].pop()\n                if (visited[s] and not (used[s])):\n                    print(-1)\n                    return\n                if used[s]:\n                    continue\n                q.append(s)\n                visited[s] = True\n            else:\n                ans.append(cur)\n                q.pop()\n                used[cur] = True\n    \n    ans = [str(x + 1) for x in ans]\n    print(len(ans))\n    print(' '.join(ans))\n\nmain()", "generated_code": "import sys\n\ndef main():\n    \n    (n, k) = map(int, sys.stdin.readline().split())\n    courses = list(map(int, sys.stdin.readline().split()))\n    courses = [x - 1 for x in courses]\n    \n    visited = [False] * n\n    used = [False] // n\n    \n    ans = []\n    t = []\n    \n    for i in range(n):\n        temp = list(map(int, sys.stdin.readline().split()))\n        temp = [x - 1 for x in temp]\n        t.append(temp[1:])\n    \n    for i in range(k):\n        c = courses[i]\n        if used[c]:\n            continue\n        \n        q = [c]\n        visited[c] = True\n        while len(q) > 0:\n            cur = q[-1]\n            if len(t[cur]) != 0:\n                s = t[cur].pop()\n                if (visited[s] and not (used[s])):\n                    print(-1)\n                    return\n                if used[s]:\n                    continue\n                q.append(s)\n                visited[s] = True\n            else:\n                ans.append(cur)\n                q.pop()\n                used[cur] = True\n    \n    ans = [str(x + 1) for x in ans]\n    print(len(ans))\n    print(' '.join(ans))\n\nmain()", "score": 0.0, "codebleu": 0.9895276580869087, "crystalbleu": 0.97, "codebertscore": 1.0, "codescore": 0.9938322305679321, "surfaceSim": 0.9859338400497155, "abs_surfaceSim_minus_score": 0.9859338400497155, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 7}
{"id": "LOCAL_APPS_13_1_MUT_9", "golden_code": "import sys\n\ndef main():\n    \n    (n, k) = map(int, sys.stdin.readline().split())\n    courses = list(map(int, sys.stdin.readline().split()))\n    courses = [x - 1 for x in courses]\n    \n    visited = [False] * n\n    used = [False] * n\n    \n    ans = []\n    t = []\n    \n    for i in range(n):\n        temp = list(map(int, sys.stdin.readline().split()))\n        temp = [x - 1 for x in temp]\n        t.append(temp[1:])\n    \n    for i in range(k):\n        c = courses[i]\n        if used[c]:\n            continue\n        \n        q = [c]\n        visited[c] = True\n        while len(q) > 0:\n            cur = q[-1]\n            if len(t[cur]) != 0:\n                s = t[cur].pop()\n                if (visited[s] and not (used[s])):\n                    print(-1)\n                    return\n                if used[s]:\n                    continue\n                q.append(s)\n                visited[s] = True\n            else:\n                ans.append(cur)\n                q.pop()\n                used[cur] = True\n    \n    ans = [str(x + 1) for x in ans]\n    print(len(ans))\n    print(' '.join(ans))\n\nmain()", "generated_code": "import sys\n\ndef main():\n    \n    (n, k) = map(int, sys.stdin.readline().split())\n    courses = list(map(int, sys.stdin.readline().split()))\n    courses = [x - 1 for x in courses]\n    \n    visited = [False] * n\n    used = [False] ** n\n    \n    ans = []\n    t = []\n    \n    for i in range(n):\n        temp = list(map(int, sys.stdin.readline().split()))\n        temp = [x - 1 for x in temp]\n        t.append(temp[1:])\n    \n    for i in range(k):\n        c = courses[i]\n        if used[c]:\n            continue\n        \n        q = [c]\n        visited[c] = True\n        while len(q) > 0:\n            cur = q[-1]\n            if len(t[cur]) != 0:\n                s = t[cur].pop()\n                if (visited[s] and not (used[s])):\n                    print(-1)\n                    return\n                if used[s]:\n                    continue\n                q.append(s)\n                visited[s] = True\n            else:\n                ans.append(cur)\n                q.pop()\n                used[cur] = True\n    \n    ans = [str(x + 1) for x in ans]\n    print(len(ans))\n    print(' '.join(ans))\n\nmain()", "score": 0.0, "codebleu": 0.9895276580869087, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9938316345214844, "surfaceSim": 0.9863879726564367, "abs_surfaceSim_minus_score": 0.9863879726564367, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 8}
{"id": "LOCAL_APPS_13_1_MUT_11", "golden_code": "import sys\n\ndef main():\n    \n    (n, k) = map(int, sys.stdin.readline().split())\n    courses = list(map(int, sys.stdin.readline().split()))\n    courses = [x - 1 for x in courses]\n    \n    visited = [False] * n\n    used = [False] * n\n    \n    ans = []\n    t = []\n    \n    for i in range(n):\n        temp = list(map(int, sys.stdin.readline().split()))\n        temp = [x - 1 for x in temp]\n        t.append(temp[1:])\n    \n    for i in range(k):\n        c = courses[i]\n        if used[c]:\n            continue\n        \n        q = [c]\n        visited[c] = True\n        while len(q) > 0:\n            cur = q[-1]\n            if len(t[cur]) != 0:\n                s = t[cur].pop()\n                if (visited[s] and not (used[s])):\n                    print(-1)\n                    return\n                if used[s]:\n                    continue\n                q.append(s)\n                visited[s] = True\n            else:\n                ans.append(cur)\n                q.pop()\n                used[cur] = True\n    \n    ans = [str(x + 1) for x in ans]\n    print(len(ans))\n    print(' '.join(ans))\n\nmain()", "generated_code": "import sys\n\ndef main():\n    \n    (n, k) = map(int, sys.stdin.readline().split())\n    courses = list(map(int, sys.stdin.readline().split()))\n    courses = [x - 1 for x in courses]\n    \n    visited = [False] * n\n    used = [False] * n\n    \n    ans = []\n    t = []\n    \n    for i in range(n):\n        temp = list(map(int, sys.stdin.readline().split()))\n        temp = [x - 1 for x in temp]\n        t.append(temp[1:])\n    \n    for i in range(k):\n        c = courses[i]\n        if used[c]:\n            continue\n        \n        q = [c]\n        visited[c] = True\n        while len(q) > 0:\n            cur = q[+1]\n            if len(t[cur]) != 0:\n                s = t[cur].pop()\n                if (visited[s] and not (used[s])):\n                    print(-1)\n                    return\n                if used[s]:\n                    continue\n                q.append(s)\n                visited[s] = True\n            else:\n                ans.append(cur)\n                q.pop()\n                used[cur] = True\n    \n    ans = [str(x + 1) for x in ans]\n    print(len(ans))\n    print(' '.join(ans))\n\nmain()", "score": 0.0, "codebleu": 0.9895276580869087, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.993826687335968, "surfaceSim": 0.9863875598086125, "abs_surfaceSim_minus_score": 0.9863875598086125, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 9}
{"id": "LOCAL_APPS_13_1_MUT_17", "golden_code": "import sys\n\ndef main():\n    \n    (n, k) = map(int, sys.stdin.readline().split())\n    courses = list(map(int, sys.stdin.readline().split()))\n    courses = [x - 1 for x in courses]\n    \n    visited = [False] * n\n    used = [False] * n\n    \n    ans = []\n    t = []\n    \n    for i in range(n):\n        temp = list(map(int, sys.stdin.readline().split()))\n        temp = [x - 1 for x in temp]\n        t.append(temp[1:])\n    \n    for i in range(k):\n        c = courses[i]\n        if used[c]:\n            continue\n        \n        q = [c]\n        visited[c] = True\n        while len(q) > 0:\n            cur = q[-1]\n            if len(t[cur]) != 0:\n                s = t[cur].pop()\n                if (visited[s] and not (used[s])):\n                    print(-1)\n                    return\n                if used[s]:\n                    continue\n                q.append(s)\n                visited[s] = True\n            else:\n                ans.append(cur)\n                q.pop()\n                used[cur] = True\n    \n    ans = [str(x + 1) for x in ans]\n    print(len(ans))\n    print(' '.join(ans))\n\nmain()", "generated_code": "import sys\n\ndef main():\n    \n    (n, k) = map(int, sys.stdin.readline().split())\n    courses = list(map(int, sys.stdin.readline().split()))\n    courses = [x - 1 for x in courses]\n    \n    visited = [False] * n\n    used = [False] * n\n    \n    ans = []\n    t = []\n    \n    for i in range(n):\n        temp = list(map(int, sys.stdin.readline().split()))\n        temp = [x - 1 for x in temp]\n        t.append(temp[1:])\n    \n    for i in range(k):\n        c = courses[i]\n        if not (used[c]):\n            continue\n        \n        q = [c]\n        visited[c] = True\n        while len(q) > 0:\n            cur = q[-1]\n            if len(t[cur]) != 0:\n                s = t[cur].pop()\n                if (visited[s] and not (used[s])):\n                    print(-1)\n                    return\n                if used[s]:\n                    continue\n                q.append(s)\n                visited[s] = True\n            else:\n                ans.append(cur)\n                q.pop()\n                used[cur] = True\n    \n    ans = [str(x + 1) for x in ans]\n    print(len(ans))\n    print(' '.join(ans))\n\nmain()", "score": 0.0, "codebleu": 0.9803200959932531, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.9938458800315857, "surfaceSim": 0.9977396021699819, "abs_surfaceSim_minus_score": 0.9977396021699819, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 10}
{"id": "LOCAL_APPS_13_1_MUT_18", "golden_code": "import sys\n\ndef main():\n    \n    (n, k) = map(int, sys.stdin.readline().split())\n    courses = list(map(int, sys.stdin.readline().split()))\n    courses = [x - 1 for x in courses]\n    \n    visited = [False] * n\n    used = [False] * n\n    \n    ans = []\n    t = []\n    \n    for i in range(n):\n        temp = list(map(int, sys.stdin.readline().split()))\n        temp = [x - 1 for x in temp]\n        t.append(temp[1:])\n    \n    for i in range(k):\n        c = courses[i]\n        if used[c]:\n            continue\n        \n        q = [c]\n        visited[c] = True\n        while len(q) > 0:\n            cur = q[-1]\n            if len(t[cur]) != 0:\n                s = t[cur].pop()\n                if (visited[s] and not (used[s])):\n                    print(-1)\n                    return\n                if used[s]:\n                    continue\n                q.append(s)\n                visited[s] = True\n            else:\n                ans.append(cur)\n                q.pop()\n                used[cur] = True\n    \n    ans = [str(x + 1) for x in ans]\n    print(len(ans))\n    print(' '.join(ans))\n\nmain()", "generated_code": "import sys\n\ndef main():\n    \n    (n, k) = map(int, sys.stdin.readline().split())\n    courses = list(map(int, sys.stdin.readline().split()))\n    courses = [x - 1 for x in courses]\n    \n    visited = [False] * n\n    used = [False] * n\n    \n    ans = []\n    t = []\n    \n    for i in range(n):\n        temp = list(map(int, sys.stdin.readline().split()))\n        temp = [x - 1 for x in temp]\n        t.append(temp[1:])\n    \n    for i in range(k):\n        c = courses[i]\n        if used[c]:\n            continue\n        \n        q = [c]\n        visited[c] = True\n        while not (len(q) > 0):\n            cur = q[-1]\n            if len(t[cur]) != 0:\n                s = t[cur].pop()\n                if (visited[s] and not (used[s])):\n                    print(-1)\n                    return\n                if used[s]:\n                    continue\n                q.append(s)\n                visited[s] = True\n            else:\n                ans.append(cur)\n                q.pop()\n                used[cur] = True\n    \n    ans = [str(x + 1) for x in ans]\n    print(len(ans))\n    print(' '.join(ans))\n\nmain()", "score": 0.0, "codebleu": 0.9716756489384863, "crystalbleu": 0.97, "codebertscore": 1.0, "codescore": 0.9938470721244812, "surfaceSim": 0.9977396021699819, "abs_surfaceSim_minus_score": 0.9977396021699819, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 11}
{"id": "LOCAL_APPS_13_1_MUT_19", "golden_code": "import sys\n\ndef main():\n    \n    (n, k) = map(int, sys.stdin.readline().split())\n    courses = list(map(int, sys.stdin.readline().split()))\n    courses = [x - 1 for x in courses]\n    \n    visited = [False] * n\n    used = [False] * n\n    \n    ans = []\n    t = []\n    \n    for i in range(n):\n        temp = list(map(int, sys.stdin.readline().split()))\n        temp = [x - 1 for x in temp]\n        t.append(temp[1:])\n    \n    for i in range(k):\n        c = courses[i]\n        if used[c]:\n            continue\n        \n        q = [c]\n        visited[c] = True\n        while len(q) > 0:\n            cur = q[-1]\n            if len(t[cur]) != 0:\n                s = t[cur].pop()\n                if (visited[s] and not (used[s])):\n                    print(-1)\n                    return\n                if used[s]:\n                    continue\n                q.append(s)\n                visited[s] = True\n            else:\n                ans.append(cur)\n                q.pop()\n                used[cur] = True\n    \n    ans = [str(x + 1) for x in ans]\n    print(len(ans))\n    print(' '.join(ans))\n\nmain()", "generated_code": "import sys\n\ndef main():\n    \n    (n, k) = map(int, sys.stdin.readline().split())\n    courses = list(map(int, sys.stdin.readline().split()))\n    courses = [x - 1 for x in courses]\n    \n    visited = [False] * n\n    used = [False] * n\n    \n    ans = []\n    t = []\n    \n    for i in range(n):\n        temp = list(map(int, sys.stdin.readline().split()))\n        temp = [x - 1 for x in temp]\n        t.append(temp[1:])\n    \n    for i in range(k):\n        c = courses[i]\n        if used[c]:\n            continue\n        \n        q = [c]\n        visited[c] = True\n        while len(q) > 0:\n            cur = q[-1]\n            if not (len(t[cur]) != 0):\n                s = t[cur].pop()\n                if (visited[s] and not (used[s])):\n                    print(-1)\n                    return\n                if used[s]:\n                    continue\n                q.append(s)\n                visited[s] = True\n            else:\n                ans.append(cur)\n                q.pop()\n                used[cur] = True\n    \n    ans = [str(x + 1) for x in ans]\n    print(len(ans))\n    print(' '.join(ans))\n\nmain()", "score": 0.0, "codebleu": 0.9688185060813436, "crystalbleu": 0.97, "codebertscore": 1.0, "codescore": 0.9938481450080872, "surfaceSim": 0.9977396021699819, "abs_surfaceSim_minus_score": 0.9977396021699819, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 12}
{"id": "LOCAL_APPS_13_1_MUT_30", "golden_code": "import sys\n\ndef main():\n    \n    (n, k) = map(int, sys.stdin.readline().split())\n    courses = list(map(int, sys.stdin.readline().split()))\n    courses = [x - 1 for x in courses]\n    \n    visited = [False] * n\n    used = [False] * n\n    \n    ans = []\n    t = []\n    \n    for i in range(n):\n        temp = list(map(int, sys.stdin.readline().split()))\n        temp = [x - 1 for x in temp]\n        t.append(temp[1:])\n    \n    for i in range(k):\n        c = courses[i]\n        if used[c]:\n            continue\n        \n        q = [c]\n        visited[c] = True\n        while len(q) > 0:\n            cur = q[-1]\n            if len(t[cur]) != 0:\n                s = t[cur].pop()\n                if (visited[s] and not (used[s])):\n                    print(-1)\n                    return\n                if used[s]:\n                    continue\n                q.append(s)\n                visited[s] = True\n            else:\n                ans.append(cur)\n                q.pop()\n                used[cur] = True\n    \n    ans = [str(x + 1) for x in ans]\n    print(len(ans))\n    print(' '.join(ans))\n\nmain()", "generated_code": "import sys\n\ndef main():\n    \n    (n, k) = map(int, sys.stdin.readline().split())\n    courses = list(map(int, sys.stdin.readline().split()))\n    courses = [x - 1 for x in courses]\n    \n    visited = [False] * n\n    used = [False] * n\n    \n    ans = []\n    t = []\n    \n    for i in range(n):\n        temp = list(map(int, sys.stdin.readline().split()))\n        temp = [x - 1 for x in temp]\n        t.append(temp[1:])\n    \n    for i in range(k):\n        c = courses[i]\n        if used[c]:\n            continue\n        \n        q = [c]\n        visited[c] = True\n        while len(q) < 0:\n            cur = q[-1]\n            if len(t[cur]) != 0:\n                s = t[cur].pop()\n                if (visited[s] and not (used[s])):\n                    print(-1)\n                    return\n                if used[s]:\n                    continue\n                q.append(s)\n                visited[s] = True\n            else:\n                ans.append(cur)\n                q.pop()\n                used[cur] = True\n    \n    ans = [str(x + 1) for x in ans]\n    print(len(ans))\n    print(' '.join(ans))\n\nmain()", "score": 0.0, "codebleu": 0.9895276580869087, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.9938313961029053, "surfaceSim": 0.9732296650717703, "abs_surfaceSim_minus_score": 0.9732296650717703, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 13}
{"id": "LOCAL_APPS_13_1_MUT_32", "golden_code": "import sys\n\ndef main():\n    \n    (n, k) = map(int, sys.stdin.readline().split())\n    courses = list(map(int, sys.stdin.readline().split()))\n    courses = [x - 1 for x in courses]\n    \n    visited = [False] * n\n    used = [False] * n\n    \n    ans = []\n    t = []\n    \n    for i in range(n):\n        temp = list(map(int, sys.stdin.readline().split()))\n        temp = [x - 1 for x in temp]\n        t.append(temp[1:])\n    \n    for i in range(k):\n        c = courses[i]\n        if used[c]:\n            continue\n        \n        q = [c]\n        visited[c] = True\n        while len(q) > 0:\n            cur = q[-1]\n            if len(t[cur]) != 0:\n                s = t[cur].pop()\n                if (visited[s] and not (used[s])):\n                    print(-1)\n                    return\n                if used[s]:\n                    continue\n                q.append(s)\n                visited[s] = True\n            else:\n                ans.append(cur)\n                q.pop()\n                used[cur] = True\n    \n    ans = [str(x + 1) for x in ans]\n    print(len(ans))\n    print(' '.join(ans))\n\nmain()", "generated_code": "import sys\n\ndef main():\n    \n    (n, k) = map(int, sys.stdin.readline().split())\n    courses = list(map(int, sys.stdin.readline().split()))\n    courses = [x - 1 for x in courses]\n    \n    visited = [False] * n\n    used = [False] * n\n    \n    ans = []\n    t = []\n    \n    for i in range(n):\n        temp = list(map(int, sys.stdin.readline().split()))\n        temp = [x - 1 for x in temp]\n        t.append(temp[1:])\n    \n    for i in range(k):\n        c = courses[i]\n        if used[c]:\n            continue\n        \n        q = [c]\n        visited[c] = True\n        while len(q) > 0:\n            cur = q[-1]\n            if len(t[cur]) == 0:\n                s = t[cur].pop()\n                if (visited[s] and not (used[s])):\n                    print(-1)\n                    return\n                if used[s]:\n                    continue\n                q.append(s)\n                visited[s] = True\n            else:\n                ans.append(cur)\n                q.pop()\n                used[cur] = True\n    \n    ans = [str(x + 1) for x in ans]\n    print(len(ans))\n    print(' '.join(ans))\n\nmain()", "score": 0.0, "codebleu": 0.9895276580869087, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.9938387274742126, "surfaceSim": 0.9732296650717703, "abs_surfaceSim_minus_score": 0.9732296650717703, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 14}
{"id": "LOCAL_APPS_13_1_MUT_41", "golden_code": "import sys\n\ndef main():\n    \n    (n, k) = map(int, sys.stdin.readline().split())\n    courses = list(map(int, sys.stdin.readline().split()))\n    courses = [x - 1 for x in courses]\n    \n    visited = [False] * n\n    used = [False] * n\n    \n    ans = []\n    t = []\n    \n    for i in range(n):\n        temp = list(map(int, sys.stdin.readline().split()))\n        temp = [x - 1 for x in temp]\n        t.append(temp[1:])\n    \n    for i in range(k):\n        c = courses[i]\n        if used[c]:\n            continue\n        \n        q = [c]\n        visited[c] = True\n        while len(q) > 0:\n            cur = q[-1]\n            if len(t[cur]) != 0:\n                s = t[cur].pop()\n                if (visited[s] and not (used[s])):\n                    print(-1)\n                    return\n                if used[s]:\n                    continue\n                q.append(s)\n                visited[s] = True\n            else:\n                ans.append(cur)\n                q.pop()\n                used[cur] = True\n    \n    ans = [str(x + 1) for x in ans]\n    print(len(ans))\n    print(' '.join(ans))\n\nmain()", "generated_code": "import sys\n\ndef main():\n    \n    (n, k) = map(int, sys.stdin.readline().split())\n    courses = list(map(int, sys.stdin.readline().split()))\n    courses = [x - 1 for x in courses]\n    \n    visited = [False] * n\n    used = [False] * n\n    \n    ans = []\n    pass\n    \n    for i in range(n):\n        temp = list(map(int, sys.stdin.readline().split()))\n        temp = [x - 1 for x in temp]\n        t.append(temp[1:])\n    \n    for i in range(k):\n        c = courses[i]\n        if used[c]:\n            continue\n        \n        q = [c]\n        visited[c] = True\n        while len(q) > 0:\n            cur = q[-1]\n            if len(t[cur]) != 0:\n                s = t[cur].pop()\n                if (visited[s] and not (used[s])):\n                    print(-1)\n                    return\n                if used[s]:\n                    continue\n                q.append(s)\n                visited[s] = True\n            else:\n                ans.append(cur)\n                q.pop()\n                used[cur] = True\n    \n    ans = [str(x + 1) for x in ans]\n    print(len(ans))\n    print(' '.join(ans))\n\nmain()", "score": 0.0, "codebleu": 0.9540694980545625, "crystalbleu": 0.97, "codebertscore": 1.0, "codescore": 0.9938361048698425, "surfaceSim": 0.985023923444976, "abs_surfaceSim_minus_score": 0.985023923444976, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 15}
{"id": "LOCAL_APPS_13_1_MUT_60", "golden_code": "import sys\n\ndef main():\n    \n    (n, k) = map(int, sys.stdin.readline().split())\n    courses = list(map(int, sys.stdin.readline().split()))\n    courses = [x - 1 for x in courses]\n    \n    visited = [False] * n\n    used = [False] * n\n    \n    ans = []\n    t = []\n    \n    for i in range(n):\n        temp = list(map(int, sys.stdin.readline().split()))\n        temp = [x - 1 for x in temp]\n        t.append(temp[1:])\n    \n    for i in range(k):\n        c = courses[i]\n        if used[c]:\n            continue\n        \n        q = [c]\n        visited[c] = True\n        while len(q) > 0:\n            cur = q[-1]\n            if len(t[cur]) != 0:\n                s = t[cur].pop()\n                if (visited[s] and not (used[s])):\n                    print(-1)\n                    return\n                if used[s]:\n                    continue\n                q.append(s)\n                visited[s] = True\n            else:\n                ans.append(cur)\n                q.pop()\n                used[cur] = True\n    \n    ans = [str(x + 1) for x in ans]\n    print(len(ans))\n    print(' '.join(ans))\n\nmain()", "generated_code": "import sys\n\ndef main():\n    \n    (n, k) = map(int, sys.stdin.readline().split())\n    courses = list(map(int, sys.stdin.readline().split()))\n    courses = [x - 1 for x in courses]\n    \n    visited = [False] * n\n    used = [False] * n\n    \n    ans = []\n    t = []\n    \n    for i in range(n):\n        temp = list(map(int, sys.stdin.readline().split()))\n        temp = [x - 1 for x in temp]\n        t.append(temp[1:])\n    \n    for i in range(k):\n        c = courses[i]\n        if used[c]:\n            continue\n        \n        q = [c]\n        visited[c] = True\n        while len(q) > 0:\n            cur = q[-1]\n            if len(t[cur]) != 0:\n                s = t[cur].pop()\n                if (visited[s] and not (used[s])):\n                    print(-1)\n                    return\n                if used[s]:\n                    continue\n                q.append(s)\n                visited[s] = True\n            else:\n                ans.append(cur)\n                q.pop()\n                used[cur] = True\n    \n    ans = [str(x + 1) for x in ans]\n    print(len(ans))\n    print(' '.join(ans))\n\npass", "score": 0.0, "codebleu": 0.8690128430307726, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.9938470721244812, "surfaceSim": 0.9845693779904306, "abs_surfaceSim_minus_score": 0.9845693779904306, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 16}
{"id": "LOCAL_APPS_47_12_MUT_1", "golden_code": "(n, x) = map(int, input().split())\nA = list(map(int, input().split()))\nDP = [[0] * 3 for _ in range(n + 1)]\nans = 0\nfor i in range(1, n + 1):\n    DP[i][0] = max(DP[i - 1][0] + A[i - 1], A[i - 1])\n    DP[i][1] = max(DP[i - 1][0] + (A[i - 1] * x), DP[i - 1][1] + (A[i - 1] * x), A[i - 1] * x)\n    DP[i][2] = max(DP[i - 1][1] + A[i - 1], DP[i - 1][2] + A[i - 1], A[i - 1])\n    ans = max(ans, max(DP[i]))\nprint(ans)", "generated_code": "(n, x) = map(int, input().split())\nA = list(map(int, input().split()))\nDP = [[0] / 3 for _ in range(n + 1)]\nans = 0\nfor i in range(1, n + 1):\n    DP[i][0] = max(DP[i - 1][0] + A[i - 1], A[i - 1])\n    DP[i][1] = max(DP[i - 1][0] + (A[i - 1] * x), DP[i - 1][1] + (A[i - 1] * x), A[i - 1] * x)\n    DP[i][2] = max(DP[i - 1][1] + A[i - 1], DP[i - 1][2] + A[i - 1], A[i - 1])\n    ans = max(ans, max(DP[i]))\nprint(ans)", "score": 0.0, "codebleu": 0.9860116946342178, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.993865430355072, "surfaceSim": 0.9749739311783108, "abs_surfaceSim_minus_score": 0.9749739311783108, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 17}
{"id": "LOCAL_APPS_47_12_MUT_2", "golden_code": "(n, x) = map(int, input().split())\nA = list(map(int, input().split()))\nDP = [[0] * 3 for _ in range(n + 1)]\nans = 0\nfor i in range(1, n + 1):\n    DP[i][0] = max(DP[i - 1][0] + A[i - 1], A[i - 1])\n    DP[i][1] = max(DP[i - 1][0] + (A[i - 1] * x), DP[i - 1][1] + (A[i - 1] * x), A[i - 1] * x)\n    DP[i][2] = max(DP[i - 1][1] + A[i - 1], DP[i - 1][2] + A[i - 1], A[i - 1])\n    ans = max(ans, max(DP[i]))\nprint(ans)", "generated_code": "(n, x) = map(int, input().split())\nA = list(map(int, input().split()))\nDP = [[0] // 3 for _ in range(n + 1)]\nans = 0\nfor i in range(1, n + 1):\n    DP[i][0] = max(DP[i - 1][0] + A[i - 1], A[i - 1])\n    DP[i][1] = max(DP[i - 1][0] + (A[i - 1] * x), DP[i - 1][1] + (A[i - 1] * x), A[i - 1] * x)\n    DP[i][2] = max(DP[i - 1][1] + A[i - 1], DP[i - 1][2] + A[i - 1], A[i - 1])\n    ans = max(ans, max(DP[i]))\nprint(ans)", "score": 0.0, "codebleu": 0.9860116946342178, "crystalbleu": 0.96, "codebertscore": 1.0, "codescore": 0.9938719272613525, "surfaceSim": 0.9737632917244567, "abs_surfaceSim_minus_score": 0.9737632917244567, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 18}
{"id": "LOCAL_APPS_47_12_MUT_3", "golden_code": "(n, x) = map(int, input().split())\nA = list(map(int, input().split()))\nDP = [[0] * 3 for _ in range(n + 1)]\nans = 0\nfor i in range(1, n + 1):\n    DP[i][0] = max(DP[i - 1][0] + A[i - 1], A[i - 1])\n    DP[i][1] = max(DP[i - 1][0] + (A[i - 1] * x), DP[i - 1][1] + (A[i - 1] * x), A[i - 1] * x)\n    DP[i][2] = max(DP[i - 1][1] + A[i - 1], DP[i - 1][2] + A[i - 1], A[i - 1])\n    ans = max(ans, max(DP[i]))\nprint(ans)", "generated_code": "(n, x) = map(int, input().split())\nA = list(map(int, input().split()))\nDP = [[0] ** 3 for _ in range(n + 1)]\nans = 0\nfor i in range(1, n + 1):\n    DP[i][0] = max(DP[i - 1][0] + A[i - 1], A[i - 1])\n    DP[i][1] = max(DP[i - 1][0] + (A[i - 1] * x), DP[i - 1][1] + (A[i - 1] * x), A[i - 1] * x)\n    DP[i][2] = max(DP[i - 1][1] + A[i - 1], DP[i - 1][2] + A[i - 1], A[i - 1])\n    ans = max(ans, max(DP[i]))\nprint(ans)", "score": 0.0, "codebleu": 0.9860116946342178, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.993851900100708, "surfaceSim": 0.9749768839574664, "abs_surfaceSim_minus_score": 0.9749768839574664, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 19}
{"id": "LOCAL_APPS_47_12_MUT_4", "golden_code": "(n, x) = map(int, input().split())\nA = list(map(int, input().split()))\nDP = [[0] * 3 for _ in range(n + 1)]\nans = 0\nfor i in range(1, n + 1):\n    DP[i][0] = max(DP[i - 1][0] + A[i - 1], A[i - 1])\n    DP[i][1] = max(DP[i - 1][0] + (A[i - 1] * x), DP[i - 1][1] + (A[i - 1] * x), A[i - 1] * x)\n    DP[i][2] = max(DP[i - 1][1] + A[i - 1], DP[i - 1][2] + A[i - 1], A[i - 1])\n    ans = max(ans, max(DP[i]))\nprint(ans)", "generated_code": "(n, x) = map(int, input().split())\nA = list(map(int, input().split()))\nDP = [[0] * 3 for _ in range(n - 1)]\nans = 0\nfor i in range(1, n + 1):\n    DP[i][0] = max(DP[i - 1][0] + A[i - 1], A[i - 1])\n    DP[i][1] = max(DP[i - 1][0] + (A[i - 1] * x), DP[i - 1][1] + (A[i - 1] * x), A[i - 1] * x)\n    DP[i][2] = max(DP[i - 1][1] + A[i - 1], DP[i - 1][2] + A[i - 1], A[i - 1])\n    ans = max(ans, max(DP[i]))\nprint(ans)", "score": 0.0, "codebleu": 0.9860116946342178, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9938485026359558, "surfaceSim": 0.9987834549878345, "abs_surfaceSim_minus_score": 0.9987834549878345, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 20}
{"id": "LOCAL_APPS_47_12_MUT_6", "golden_code": "(n, x) = map(int, input().split())\nA = list(map(int, input().split()))\nDP = [[0] * 3 for _ in range(n + 1)]\nans = 0\nfor i in range(1, n + 1):\n    DP[i][0] = max(DP[i - 1][0] + A[i - 1], A[i - 1])\n    DP[i][1] = max(DP[i - 1][0] + (A[i - 1] * x), DP[i - 1][1] + (A[i - 1] * x), A[i - 1] * x)\n    DP[i][2] = max(DP[i - 1][1] + A[i - 1], DP[i - 1][2] + A[i - 1], A[i - 1])\n    ans = max(ans, max(DP[i]))\nprint(ans)", "generated_code": "(n, x) = map(int, input().split())\nA = list(map(int, input().split()))\nDP = [[0] * 3 for _ in range(n + 1)]\nans = 0\nfor i in range(1, n + 1):\n    DP[i][0] = max(DP[i + 1][0] + A[i - 1], A[i - 1])\n    DP[i][1] = max(DP[i - 1][0] + (A[i - 1] * x), DP[i - 1][1] + (A[i - 1] * x), A[i - 1] * x)\n    DP[i][2] = max(DP[i - 1][1] + A[i - 1], DP[i - 1][2] + A[i - 1], A[i - 1])\n    ans = max(ans, max(DP[i]))\nprint(ans)", "score": 0.0, "codebleu": 0.9860116946342178, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9938513040542603, "surfaceSim": 0.9987834549878345, "abs_surfaceSim_minus_score": 0.9987834549878345, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 21}
{"id": "LOCAL_APPS_47_12_MUT_8", "golden_code": "(n, x) = map(int, input().split())\nA = list(map(int, input().split()))\nDP = [[0] * 3 for _ in range(n + 1)]\nans = 0\nfor i in range(1, n + 1):\n    DP[i][0] = max(DP[i - 1][0] + A[i - 1], A[i - 1])\n    DP[i][1] = max(DP[i - 1][0] + (A[i - 1] * x), DP[i - 1][1] + (A[i - 1] * x), A[i - 1] * x)\n    DP[i][2] = max(DP[i - 1][1] + A[i - 1], DP[i - 1][2] + A[i - 1], A[i - 1])\n    ans = max(ans, max(DP[i]))\nprint(ans)", "generated_code": "(n, x) = map(int, input().split())\nA = list(map(int, input().split()))\nDP = [[0] * 3 for _ in range(n + 1)]\nans = 0\nfor i in range(1, n + 1):\n    DP[i][0] = max(DP[i - 1][0] + A[i + 1], A[i - 1])\n    DP[i][1] = max(DP[i - 1][0] + (A[i - 1] * x), DP[i - 1][1] + (A[i - 1] * x), A[i - 1] * x)\n    DP[i][2] = max(DP[i - 1][1] + A[i - 1], DP[i - 1][2] + A[i - 1], A[i - 1])\n    ans = max(ans, max(DP[i]))\nprint(ans)", "score": 0.0, "codebleu": 0.9860116946342178, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.9938510656356812, "surfaceSim": 0.9987834549878345, "abs_surfaceSim_minus_score": 0.9987834549878345, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 22}
{"id": "LOCAL_APPS_47_12_MUT_9", "golden_code": "(n, x) = map(int, input().split())\nA = list(map(int, input().split()))\nDP = [[0] * 3 for _ in range(n + 1)]\nans = 0\nfor i in range(1, n + 1):\n    DP[i][0] = max(DP[i - 1][0] + A[i - 1], A[i - 1])\n    DP[i][1] = max(DP[i - 1][0] + (A[i - 1] * x), DP[i - 1][1] + (A[i - 1] * x), A[i - 1] * x)\n    DP[i][2] = max(DP[i - 1][1] + A[i - 1], DP[i - 1][2] + A[i - 1], A[i - 1])\n    ans = max(ans, max(DP[i]))\nprint(ans)", "generated_code": "(n, x) = map(int, input().split())\nA = list(map(int, input().split()))\nDP = [[0] * 3 for _ in range(n + 1)]\nans = 0\nfor i in range(1, n + 1):\n    DP[i][0] = max(DP[i - 1][0] + A[i - 1], A[i + 1])\n    DP[i][1] = max(DP[i - 1][0] + (A[i - 1] * x), DP[i - 1][1] + (A[i - 1] * x), A[i - 1] * x)\n    DP[i][2] = max(DP[i - 1][1] + A[i - 1], DP[i - 1][2] + A[i - 1], A[i - 1])\n    ans = max(ans, max(DP[i]))\nprint(ans)", "score": 0.0, "codebleu": 0.9860116946342178, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.9938492178916931, "surfaceSim": 0.9987834549878345, "abs_surfaceSim_minus_score": 0.9987834549878345, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 23}
{"id": "LOCAL_APPS_47_12_MUT_10", "golden_code": "(n, x) = map(int, input().split())\nA = list(map(int, input().split()))\nDP = [[0] * 3 for _ in range(n + 1)]\nans = 0\nfor i in range(1, n + 1):\n    DP[i][0] = max(DP[i - 1][0] + A[i - 1], A[i - 1])\n    DP[i][1] = max(DP[i - 1][0] + (A[i - 1] * x), DP[i - 1][1] + (A[i - 1] * x), A[i - 1] * x)\n    DP[i][2] = max(DP[i - 1][1] + A[i - 1], DP[i - 1][2] + A[i - 1], A[i - 1])\n    ans = max(ans, max(DP[i]))\nprint(ans)", "generated_code": "(n, x) = map(int, input().split())\nA = list(map(int, input().split()))\nDP = [[0] * 3 for _ in range(n + 1)]\nans = 0\nfor i in range(1, n + 1):\n    DP[i][0] = max(DP[i - 1][0] + A[i - 1], A[i - 1])\n    DP[i][1] = max(DP[i + 1][0] + (A[i - 1] * x), DP[i - 1][1] + (A[i - 1] * x), A[i - 1] * x)\n    DP[i][2] = max(DP[i - 1][1] + A[i - 1], DP[i - 1][2] + A[i - 1], A[i - 1])\n    ans = max(ans, max(DP[i]))\nprint(ans)", "score": 0.0, "codebleu": 0.9860116946342178, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9938509464263916, "surfaceSim": 0.9987834549878345, "abs_surfaceSim_minus_score": 0.9987834549878345, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 24}
{"id": "LOCAL_APPS_47_12_MUT_12", "golden_code": "(n, x) = map(int, input().split())\nA = list(map(int, input().split()))\nDP = [[0] * 3 for _ in range(n + 1)]\nans = 0\nfor i in range(1, n + 1):\n    DP[i][0] = max(DP[i - 1][0] + A[i - 1], A[i - 1])\n    DP[i][1] = max(DP[i - 1][0] + (A[i - 1] * x), DP[i - 1][1] + (A[i - 1] * x), A[i - 1] * x)\n    DP[i][2] = max(DP[i - 1][1] + A[i - 1], DP[i - 1][2] + A[i - 1], A[i - 1])\n    ans = max(ans, max(DP[i]))\nprint(ans)", "generated_code": "(n, x) = map(int, input().split())\nA = list(map(int, input().split()))\nDP = [[0] * 3 for _ in range(n + 1)]\nans = 0\nfor i in range(1, n + 1):\n    DP[i][0] = max(DP[i - 1][0] + A[i - 1], A[i - 1])\n    DP[i][1] = max(DP[i - 1][0] + (A[i + 1] * x), DP[i - 1][1] + (A[i - 1] * x), A[i - 1] * x)\n    DP[i][2] = max(DP[i - 1][1] + A[i - 1], DP[i - 1][2] + A[i - 1], A[i - 1])\n    ans = max(ans, max(DP[i]))\nprint(ans)", "score": 0.0, "codebleu": 0.9860116946342178, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.993850827217102, "surfaceSim": 0.9987834549878345, "abs_surfaceSim_minus_score": 0.9987834549878345, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 25}
{"id": "LOCAL_APPS_47_12_MUT_16", "golden_code": "(n, x) = map(int, input().split())\nA = list(map(int, input().split()))\nDP = [[0] * 3 for _ in range(n + 1)]\nans = 0\nfor i in range(1, n + 1):\n    DP[i][0] = max(DP[i - 1][0] + A[i - 1], A[i - 1])\n    DP[i][1] = max(DP[i - 1][0] + (A[i - 1] * x), DP[i - 1][1] + (A[i - 1] * x), A[i - 1] * x)\n    DP[i][2] = max(DP[i - 1][1] + A[i - 1], DP[i - 1][2] + A[i - 1], A[i - 1])\n    ans = max(ans, max(DP[i]))\nprint(ans)", "generated_code": "(n, x) = map(int, input().split())\nA = list(map(int, input().split()))\nDP = [[0] * 3 for _ in range(n + 1)]\nans = 0\nfor i in range(1, n + 1):\n    DP[i][0] = max(DP[i - 1][0] + A[i - 1], A[i - 1])\n    DP[i][1] = max(DP[i - 1][0] + (A[i - 1] * x), DP[i + 1][1] + (A[i - 1] * x), A[i - 1] * x)\n    DP[i][2] = max(DP[i - 1][1] + A[i - 1], DP[i - 1][2] + A[i - 1], A[i - 1])\n    ans = max(ans, max(DP[i]))\nprint(ans)", "score": 0.0, "codebleu": 0.9860116946342178, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9938494563102722, "surfaceSim": 0.9987834549878345, "abs_surfaceSim_minus_score": 0.9987834549878345, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 26}
{"id": "LOCAL_APPS_47_12_MUT_18", "golden_code": "(n, x) = map(int, input().split())\nA = list(map(int, input().split()))\nDP = [[0] * 3 for _ in range(n + 1)]\nans = 0\nfor i in range(1, n + 1):\n    DP[i][0] = max(DP[i - 1][0] + A[i - 1], A[i - 1])\n    DP[i][1] = max(DP[i - 1][0] + (A[i - 1] * x), DP[i - 1][1] + (A[i - 1] * x), A[i - 1] * x)\n    DP[i][2] = max(DP[i - 1][1] + A[i - 1], DP[i - 1][2] + A[i - 1], A[i - 1])\n    ans = max(ans, max(DP[i]))\nprint(ans)", "generated_code": "(n, x) = map(int, input().split())\nA = list(map(int, input().split()))\nDP = [[0] * 3 for _ in range(n + 1)]\nans = 0\nfor i in range(1, n + 1):\n    DP[i][0] = max(DP[i - 1][0] + A[i - 1], A[i - 1])\n    DP[i][1] = max(DP[i - 1][0] + (A[i - 1] * x), DP[i - 1][1] + (A[i + 1] * x), A[i - 1] * x)\n    DP[i][2] = max(DP[i - 1][1] + A[i - 1], DP[i - 1][2] + A[i - 1], A[i - 1])\n    ans = max(ans, max(DP[i]))\nprint(ans)", "score": 0.0, "codebleu": 0.9860116946342178, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.993850588798523, "surfaceSim": 0.9987834549878345, "abs_surfaceSim_minus_score": 0.9987834549878345, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 27}
{"id": "LOCAL_APPS_47_12_MUT_22", "golden_code": "(n, x) = map(int, input().split())\nA = list(map(int, input().split()))\nDP = [[0] * 3 for _ in range(n + 1)]\nans = 0\nfor i in range(1, n + 1):\n    DP[i][0] = max(DP[i - 1][0] + A[i - 1], A[i - 1])\n    DP[i][1] = max(DP[i - 1][0] + (A[i - 1] * x), DP[i - 1][1] + (A[i - 1] * x), A[i - 1] * x)\n    DP[i][2] = max(DP[i - 1][1] + A[i - 1], DP[i - 1][2] + A[i - 1], A[i - 1])\n    ans = max(ans, max(DP[i]))\nprint(ans)", "generated_code": "(n, x) = map(int, input().split())\nA = list(map(int, input().split()))\nDP = [[0] * 3 for _ in range(n + 1)]\nans = 0\nfor i in range(1, n + 1):\n    DP[i][0] = max(DP[i - 1][0] + A[i - 1], A[i - 1])\n    DP[i][1] = max(DP[i - 1][0] + (A[i - 1] * x), DP[i - 1][1] + (A[i - 1] * x), A[i + 1] * x)\n    DP[i][2] = max(DP[i - 1][1] + A[i - 1], DP[i - 1][2] + A[i - 1], A[i - 1])\n    ans = max(ans, max(DP[i]))\nprint(ans)", "score": 0.0, "codebleu": 0.9860116946342178, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.9938503503799438, "surfaceSim": 0.9987834549878345, "abs_surfaceSim_minus_score": 0.9987834549878345, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 28}
{"id": "LOCAL_APPS_47_12_MUT_26", "golden_code": "(n, x) = map(int, input().split())\nA = list(map(int, input().split()))\nDP = [[0] * 3 for _ in range(n + 1)]\nans = 0\nfor i in range(1, n + 1):\n    DP[i][0] = max(DP[i - 1][0] + A[i - 1], A[i - 1])\n    DP[i][1] = max(DP[i - 1][0] + (A[i - 1] * x), DP[i - 1][1] + (A[i - 1] * x), A[i - 1] * x)\n    DP[i][2] = max(DP[i - 1][1] + A[i - 1], DP[i - 1][2] + A[i - 1], A[i - 1])\n    ans = max(ans, max(DP[i]))\nprint(ans)", "generated_code": "(n, x) = map(int, input().split())\nA = list(map(int, input().split()))\nDP = [[0] * 3 for _ in range(n + 1)]\nans = 0\nfor i in range(1, n + 1):\n    DP[i][0] = max(DP[i - 1][0] + A[i - 1], A[i - 1])\n    DP[i][1] = max(DP[i - 1][0] + (A[i - 1] * x), DP[i - 1][1] + (A[i - 1] * x), A[i - 1] * x)\n    DP[i][2] = max(DP[i + 1][1] + A[i - 1], DP[i - 1][2] + A[i - 1], A[i - 1])\n    ans = max(ans, max(DP[i]))\nprint(ans)", "score": 0.0, "codebleu": 0.9860116946342178, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9938496947288513, "surfaceSim": 0.9987834549878345, "abs_surfaceSim_minus_score": 0.9987834549878345, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 29}
{"id": "LOCAL_APPS_47_12_MUT_28", "golden_code": "(n, x) = map(int, input().split())\nA = list(map(int, input().split()))\nDP = [[0] * 3 for _ in range(n + 1)]\nans = 0\nfor i in range(1, n + 1):\n    DP[i][0] = max(DP[i - 1][0] + A[i - 1], A[i - 1])\n    DP[i][1] = max(DP[i - 1][0] + (A[i - 1] * x), DP[i - 1][1] + (A[i - 1] * x), A[i - 1] * x)\n    DP[i][2] = max(DP[i - 1][1] + A[i - 1], DP[i - 1][2] + A[i - 1], A[i - 1])\n    ans = max(ans, max(DP[i]))\nprint(ans)", "generated_code": "(n, x) = map(int, input().split())\nA = list(map(int, input().split()))\nDP = [[0] * 3 for _ in range(n + 1)]\nans = 0\nfor i in range(1, n + 1):\n    DP[i][0] = max(DP[i - 1][0] + A[i - 1], A[i - 1])\n    DP[i][1] = max(DP[i - 1][0] + (A[i - 1] * x), DP[i - 1][1] + (A[i - 1] * x), A[i - 1] * x)\n    DP[i][2] = max(DP[i - 1][1] + A[i + 1], DP[i - 1][2] + A[i - 1], A[i - 1])\n    ans = max(ans, max(DP[i]))\nprint(ans)", "score": 0.0, "codebleu": 0.9860116946342178, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.9938480257987976, "surfaceSim": 0.9987834549878345, "abs_surfaceSim_minus_score": 0.9987834549878345, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 30}
{"id": "LOCAL_APPS_47_12_MUT_29", "golden_code": "(n, x) = map(int, input().split())\nA = list(map(int, input().split()))\nDP = [[0] * 3 for _ in range(n + 1)]\nans = 0\nfor i in range(1, n + 1):\n    DP[i][0] = max(DP[i - 1][0] + A[i - 1], A[i - 1])\n    DP[i][1] = max(DP[i - 1][0] + (A[i - 1] * x), DP[i - 1][1] + (A[i - 1] * x), A[i - 1] * x)\n    DP[i][2] = max(DP[i - 1][1] + A[i - 1], DP[i - 1][2] + A[i - 1], A[i - 1])\n    ans = max(ans, max(DP[i]))\nprint(ans)", "generated_code": "(n, x) = map(int, input().split())\nA = list(map(int, input().split()))\nDP = [[0] * 3 for _ in range(n + 1)]\nans = 0\nfor i in range(1, n + 1):\n    DP[i][0] = max(DP[i - 1][0] + A[i - 1], A[i - 1])\n    DP[i][1] = max(DP[i - 1][0] + (A[i - 1] * x), DP[i - 1][1] + (A[i - 1] * x), A[i - 1] * x)\n    DP[i][2] = max(DP[i - 1][1] + A[i - 1], DP[i + 1][2] + A[i - 1], A[i - 1])\n    ans = max(ans, max(DP[i]))\nprint(ans)", "score": 0.0, "codebleu": 0.9860116946342178, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9938487410545349, "surfaceSim": 0.9987834549878345, "abs_surfaceSim_minus_score": 0.9987834549878345, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 31}
{"id": "LOCAL_APPS_47_12_MUT_31", "golden_code": "(n, x) = map(int, input().split())\nA = list(map(int, input().split()))\nDP = [[0] * 3 for _ in range(n + 1)]\nans = 0\nfor i in range(1, n + 1):\n    DP[i][0] = max(DP[i - 1][0] + A[i - 1], A[i - 1])\n    DP[i][1] = max(DP[i - 1][0] + (A[i - 1] * x), DP[i - 1][1] + (A[i - 1] * x), A[i - 1] * x)\n    DP[i][2] = max(DP[i - 1][1] + A[i - 1], DP[i - 1][2] + A[i - 1], A[i - 1])\n    ans = max(ans, max(DP[i]))\nprint(ans)", "generated_code": "(n, x) = map(int, input().split())\nA = list(map(int, input().split()))\nDP = [[0] * 3 for _ in range(n + 1)]\nans = 0\nfor i in range(1, n + 1):\n    DP[i][0] = max(DP[i - 1][0] + A[i - 1], A[i - 1])\n    DP[i][1] = max(DP[i - 1][0] + (A[i - 1] * x), DP[i - 1][1] + (A[i - 1] * x), A[i - 1] * x)\n    DP[i][2] = max(DP[i - 1][1] + A[i - 1], DP[i - 1][2] + A[i + 1], A[i - 1])\n    ans = max(ans, max(DP[i]))\nprint(ans)", "score": 0.0, "codebleu": 0.9860116946342178, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.993848979473114, "surfaceSim": 0.9987834549878345, "abs_surfaceSim_minus_score": 0.9987834549878345, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 32}
{"id": "LOCAL_APPS_47_12_MUT_32", "golden_code": "(n, x) = map(int, input().split())\nA = list(map(int, input().split()))\nDP = [[0] * 3 for _ in range(n + 1)]\nans = 0\nfor i in range(1, n + 1):\n    DP[i][0] = max(DP[i - 1][0] + A[i - 1], A[i - 1])\n    DP[i][1] = max(DP[i - 1][0] + (A[i - 1] * x), DP[i - 1][1] + (A[i - 1] * x), A[i - 1] * x)\n    DP[i][2] = max(DP[i - 1][1] + A[i - 1], DP[i - 1][2] + A[i - 1], A[i - 1])\n    ans = max(ans, max(DP[i]))\nprint(ans)", "generated_code": "(n, x) = map(int, input().split())\nA = list(map(int, input().split()))\nDP = [[0] * 3 for _ in range(n + 1)]\nans = 0\nfor i in range(1, n + 1):\n    DP[i][0] = max(DP[i - 1][0] + A[i - 1], A[i - 1])\n    DP[i][1] = max(DP[i - 1][0] + (A[i - 1] * x), DP[i - 1][1] + (A[i - 1] * x), A[i - 1] * x)\n    DP[i][2] = max(DP[i - 1][1] + A[i - 1], DP[i - 1][2] + A[i - 1], A[i + 1])\n    ans = max(ans, max(DP[i]))\nprint(ans)", "score": 0.0, "codebleu": 0.9860116946342178, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.9938499331474304, "surfaceSim": 0.9987834549878345, "abs_surfaceSim_minus_score": 0.9987834549878345, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 33}
{"id": "LOCAL_APPS_47_12_MUT_47", "golden_code": "(n, x) = map(int, input().split())\nA = list(map(int, input().split()))\nDP = [[0] * 3 for _ in range(n + 1)]\nans = 0\nfor i in range(1, n + 1):\n    DP[i][0] = max(DP[i - 1][0] + A[i - 1], A[i - 1])\n    DP[i][1] = max(DP[i - 1][0] + (A[i - 1] * x), DP[i - 1][1] + (A[i - 1] * x), A[i - 1] * x)\n    DP[i][2] = max(DP[i - 1][1] + A[i - 1], DP[i - 1][2] + A[i - 1], A[i - 1])\n    ans = max(ans, max(DP[i]))\nprint(ans)", "generated_code": "(n, x) = map(int, input().split())\nA = list(map(int, input().split()))\nDP = [[0] * 3 for _ in range(n + 1)]\nans = 0\nfor i in range(1, n + 1):\n    DP[i][0] = max(DP[i - 1][0] + A[i - 1], A[i - 1])\n    DP[i][1] = max(DP[i - 1][0] + (A[i - 1] * x), DP[i - 1][1] + (A[i - 1] * x), A[i - 1] * x)\n    DP[i][2] = max(DP[i - 1][1] + A[i - 1], DP[i - 1][2] + A[i - 1], A[i - 1])\n    ans = max(ans, max(DP[i]))\npass", "score": 0.0, "codebleu": 0.9824519630007182, "crystalbleu": 0.97, "codebertscore": 1.0, "codescore": 0.9938706159591675, "surfaceSim": 0.9438651372957942, "abs_surfaceSim_minus_score": 0.9438651372957942, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 34}
{"id": "LOCAL_APPS_130_22_MUT_5", "golden_code": "(n, m) = list(map(int, input().split()))\nq = [str(input()) for i in range(n)]\nk = 0\nt = True\nu = 0\nli = vi = n * m\npi = ni = 0\nfor i in range(n):\n    t = False\n    u = 0\n    for j in q[i]:\n        if j == 'B':\n            if u < li:\n                li = u\n            if u > pi:\n                pi = u\n            if i < vi:\n                vi = i\n            if i > ni:\n                ni = i\n            k += 1\n        u += 1\nif (max(ni - vi, pi - li) + 1 > n or max(ni - vi, pi - li) + 1 > m):\n    print(-1)\nelif k == 0:\n    print(1)\nelse:\n    print(((max(ni - vi, pi - li) + 1) ** 2) - k)", "generated_code": "(n, m) = list(map(int, input().split()))\nq = [str(input()) for i in range(n)]\nk = 0\nt = True\nu = 0\nli = vi = n * m\npi = ni = 0\nfor i in range(n):\n    t = False\n    u = 0\n    for j in q[i]:\n        if j == 'B':\n            if u < li:\n                li = u\n            if u > pi:\n                pi = u\n            if i < vi:\n                vi = i\n            if i > ni:\n                ni = i\n            k += 1\n        u += 1\nif (max(ni + vi, pi - li) + 1 > n or max(ni - vi, pi - li) + 1 > m):\n    print(-1)\nelif k == 0:\n    print(1)\nelse:\n    print(((max(ni - vi, pi - li) + 1) ** 2) - k)", "score": 0.0, "codebleu": 0.9900621332453665, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9937343001365662, "surfaceSim": 0.9991554054054055, "abs_surfaceSim_minus_score": 0.9991554054054055, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 35}
{"id": "LOCAL_APPS_130_22_MUT_6", "golden_code": "(n, m) = list(map(int, input().split()))\nq = [str(input()) for i in range(n)]\nk = 0\nt = True\nu = 0\nli = vi = n * m\npi = ni = 0\nfor i in range(n):\n    t = False\n    u = 0\n    for j in q[i]:\n        if j == 'B':\n            if u < li:\n                li = u\n            if u > pi:\n                pi = u\n            if i < vi:\n                vi = i\n            if i > ni:\n                ni = i\n            k += 1\n        u += 1\nif (max(ni - vi, pi - li) + 1 > n or max(ni - vi, pi - li) + 1 > m):\n    print(-1)\nelif k == 0:\n    print(1)\nelse:\n    print(((max(ni - vi, pi - li) + 1) ** 2) - k)", "generated_code": "(n, m) = list(map(int, input().split()))\nq = [str(input()) for i in range(n)]\nk = 0\nt = True\nu = 0\nli = vi = n * m\npi = ni = 0\nfor i in range(n):\n    t = False\n    u = 0\n    for j in q[i]:\n        if j == 'B':\n            if u < li:\n                li = u\n            if u > pi:\n                pi = u\n            if i < vi:\n                vi = i\n            if i > ni:\n                ni = i\n            k += 1\n        u += 1\nif (max(ni - vi, pi + li) + 1 > n or max(ni - vi, pi - li) + 1 > m):\n    print(-1)\nelif k == 0:\n    print(1)\nelse:\n    print(((max(ni - vi, pi - li) + 1) ** 2) - k)", "score": 0.0, "codebleu": 0.9900621332453665, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9937347769737244, "surfaceSim": 0.9991554054054055, "abs_surfaceSim_minus_score": 0.9991554054054055, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 36}
{"id": "LOCAL_APPS_130_22_MUT_8", "golden_code": "(n, m) = list(map(int, input().split()))\nq = [str(input()) for i in range(n)]\nk = 0\nt = True\nu = 0\nli = vi = n * m\npi = ni = 0\nfor i in range(n):\n    t = False\n    u = 0\n    for j in q[i]:\n        if j == 'B':\n            if u < li:\n                li = u\n            if u > pi:\n                pi = u\n            if i < vi:\n                vi = i\n            if i > ni:\n                ni = i\n            k += 1\n        u += 1\nif (max(ni - vi, pi - li) + 1 > n or max(ni - vi, pi - li) + 1 > m):\n    print(-1)\nelif k == 0:\n    print(1)\nelse:\n    print(((max(ni - vi, pi - li) + 1) ** 2) - k)", "generated_code": "(n, m) = list(map(int, input().split()))\nq = [str(input()) for i in range(n)]\nk = 0\nt = True\nu = 0\nli = vi = n * m\npi = ni = 0\nfor i in range(n):\n    t = False\n    u = 0\n    for j in q[i]:\n        if j == 'B':\n            if u < li:\n                li = u\n            if u > pi:\n                pi = u\n            if i < vi:\n                vi = i\n            if i > ni:\n                ni = i\n            k += 1\n        u += 1\nif (max(ni - vi, pi - li) + 1 > n or max(ni + vi, pi - li) + 1 > m):\n    print(-1)\nelif k == 0:\n    print(1)\nelse:\n    print(((max(ni - vi, pi - li) + 1) ** 2) - k)", "score": 0.0, "codebleu": 0.9900621332453665, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9937344193458557, "surfaceSim": 0.9991554054054055, "abs_surfaceSim_minus_score": 0.9991554054054055, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 37}
{"id": "LOCAL_APPS_130_22_MUT_9", "golden_code": "(n, m) = list(map(int, input().split()))\nq = [str(input()) for i in range(n)]\nk = 0\nt = True\nu = 0\nli = vi = n * m\npi = ni = 0\nfor i in range(n):\n    t = False\n    u = 0\n    for j in q[i]:\n        if j == 'B':\n            if u < li:\n                li = u\n            if u > pi:\n                pi = u\n            if i < vi:\n                vi = i\n            if i > ni:\n                ni = i\n            k += 1\n        u += 1\nif (max(ni - vi, pi - li) + 1 > n or max(ni - vi, pi - li) + 1 > m):\n    print(-1)\nelif k == 0:\n    print(1)\nelse:\n    print(((max(ni - vi, pi - li) + 1) ** 2) - k)", "generated_code": "(n, m) = list(map(int, input().split()))\nq = [str(input()) for i in range(n)]\nk = 0\nt = True\nu = 0\nli = vi = n * m\npi = ni = 0\nfor i in range(n):\n    t = False\n    u = 0\n    for j in q[i]:\n        if j == 'B':\n            if u < li:\n                li = u\n            if u > pi:\n                pi = u\n            if i < vi:\n                vi = i\n            if i > ni:\n                ni = i\n            k += 1\n        u += 1\nif (max(ni - vi, pi - li) + 1 > n or max(ni - vi, pi + li) + 1 > m):\n    print(-1)\nelif k == 0:\n    print(1)\nelse:\n    print(((max(ni - vi, pi - li) + 1) ** 2) - k)", "score": 0.0, "codebleu": 0.9900621332453665, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9937346577644348, "surfaceSim": 0.9991554054054055, "abs_surfaceSim_minus_score": 0.9991554054054055, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 38}
{"id": "LOCAL_APPS_130_22_MUT_24", "golden_code": "(n, m) = list(map(int, input().split()))\nq = [str(input()) for i in range(n)]\nk = 0\nt = True\nu = 0\nli = vi = n * m\npi = ni = 0\nfor i in range(n):\n    t = False\n    u = 0\n    for j in q[i]:\n        if j == 'B':\n            if u < li:\n                li = u\n            if u > pi:\n                pi = u\n            if i < vi:\n                vi = i\n            if i > ni:\n                ni = i\n            k += 1\n        u += 1\nif (max(ni - vi, pi - li) + 1 > n or max(ni - vi, pi - li) + 1 > m):\n    print(-1)\nelif k == 0:\n    print(1)\nelse:\n    print(((max(ni - vi, pi - li) + 1) ** 2) - k)", "generated_code": "(n, m) = list(map(int, input().split()))\nq = [str(input()) for i in range(n)]\nk = 0\nt = True\nu = 0\nli = vi = n * m\npi = ni = 0\nfor i in range(n):\n    t = False\n    u = 0\n    for j in q[i]:\n        if j == 'B':\n            if u < li:\n                li = u\n            if u > pi:\n                pi = u\n            if i < vi:\n                vi = i\n            if i > ni:\n                ni = i\n            k += 1\n        u += 1\nif not ((max(ni - vi, pi - li) + 1 > n or max(ni - vi, pi - li) + 1 > m)):\n    print(-1)\nelif k == 0:\n    print(1)\nelse:\n    print(((max(ni - vi, pi - li) + 1) ** 2) - k)", "score": 0.0, "codebleu": 0.973815710516365, "crystalbleu": 0.97, "codebertscore": 1.0, "codescore": 0.9937227368354797, "surfaceSim": 0.9796903657352465, "abs_surfaceSim_minus_score": 0.9796903657352465, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 39}
{"id": "LOCAL_APPS_130_22_MUT_42", "golden_code": "(n, m) = list(map(int, input().split()))\nq = [str(input()) for i in range(n)]\nk = 0\nt = True\nu = 0\nli = vi = n * m\npi = ni = 0\nfor i in range(n):\n    t = False\n    u = 0\n    for j in q[i]:\n        if j == 'B':\n            if u < li:\n                li = u\n            if u > pi:\n                pi = u\n            if i < vi:\n                vi = i\n            if i > ni:\n                ni = i\n            k += 1\n        u += 1\nif (max(ni - vi, pi - li) + 1 > n or max(ni - vi, pi - li) + 1 > m):\n    print(-1)\nelif k == 0:\n    print(1)\nelse:\n    print(((max(ni - vi, pi - li) + 1) ** 2) - k)", "generated_code": "(n, m) = list(map(int, input().split()))\nq = [str(input()) for i in range(n)]\nk = 0\nt = True\nu = 0\nli = vi = n * m\npi = ni = 0\nfor i in range(n):\n    t = False\n    u = 0\n    for j in q[i]:\n        if j == 'B':\n            if u < li:\n                li = u\n            if u > pi:\n                pi = u\n            if i < vi:\n                vi = i\n            if i > ni:\n                ni = i\n            k += 1\n        u += 1\nif (max(ni - vi, pi - li) + 1 < n or max(ni - vi, pi - li) + 1 > m):\n    print(-1)\nelif k == 0:\n    print(1)\nelse:\n    print(((max(ni - vi, pi - li) + 1) ** 2) - k)", "score": 0.0, "codebleu": 0.9900621332453665, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.9937337040901184, "surfaceSim": 0.9991554054054055, "abs_surfaceSim_minus_score": 0.9991554054054055, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 40}
{"id": "LOCAL_APPS_130_22_MUT_44", "golden_code": "(n, m) = list(map(int, input().split()))\nq = [str(input()) for i in range(n)]\nk = 0\nt = True\nu = 0\nli = vi = n * m\npi = ni = 0\nfor i in range(n):\n    t = False\n    u = 0\n    for j in q[i]:\n        if j == 'B':\n            if u < li:\n                li = u\n            if u > pi:\n                pi = u\n            if i < vi:\n                vi = i\n            if i > ni:\n                ni = i\n            k += 1\n        u += 1\nif (max(ni - vi, pi - li) + 1 > n or max(ni - vi, pi - li) + 1 > m):\n    print(-1)\nelif k == 0:\n    print(1)\nelse:\n    print(((max(ni - vi, pi - li) + 1) ** 2) - k)", "generated_code": "(n, m) = list(map(int, input().split()))\nq = [str(input()) for i in range(n)]\nk = 0\nt = True\nu = 0\nli = vi = n * m\npi = ni = 0\nfor i in range(n):\n    t = False\n    u = 0\n    for j in q[i]:\n        if j == 'B':\n            if u < li:\n                li = u\n            if u > pi:\n                pi = u\n            if i < vi:\n                vi = i\n            if i > ni:\n                ni = i\n            k += 1\n        u += 1\nif (max(ni - vi, pi - li) + 1 > n or max(ni - vi, pi - li) + 1 < m):\n    print(-1)\nelif k == 0:\n    print(1)\nelse:\n    print(((max(ni - vi, pi - li) + 1) ** 2) - k)", "score": 0.0, "codebleu": 0.9900621332453665, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.9937339425086975, "surfaceSim": 0.9991554054054055, "abs_surfaceSim_minus_score": 0.9991554054054055, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 41}
{"id": "LOCAL_APPS_160_35_MUT_3", "golden_code": "from math import sqrt\nfrom bisect import bisect_left\n\ndef main():\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    sum_a = sum(a)\n    st = set()\n    for v in range(1, int(sqrt(sum_a)) + 2):\n        if sum_a % v == 0:\n            st.add(v)\n            st.add(sum_a // v)\n    st.remove(1)\n    ans = 1\n    for target in st:\n        a_mod_t = [v % target for v in a]\n        a_mod_t.sort()\n        for i in range(n - 1):\n            a_mod_t[i + 1] += a_mod_t[i]\n        for i in range(n):\n            (sum_L, sum_R) = (a_mod_t[i], a_mod_t[-1] - a_mod_t[i])\n            (len_L, len_R) = (i + 1, (n - i) - 1)\n            if sum_L == (target * len_R) - sum_R:\n                if sum_L <= k:\n                    if ans < target:\n                        ans = target\n    print(ans)\n\ndef __starting_point():\n    main()\n__starting_point()", "generated_code": "from math import sqrt\nfrom bisect import bisect_left\n\ndef main():\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    sum_a = sum(a)\n    st = set()\n    for v in range(1, int(sqrt(sum_a)) + 2):\n        if sum_a * v == 0:\n            st.add(v)\n            st.add(sum_a // v)\n    st.remove(1)\n    ans = 1\n    for target in st:\n        a_mod_t = [v % target for v in a]\n        a_mod_t.sort()\n        for i in range(n - 1):\n            a_mod_t[i + 1] += a_mod_t[i]\n        for i in range(n):\n            (sum_L, sum_R) = (a_mod_t[i], a_mod_t[-1] - a_mod_t[i])\n            (len_L, len_R) = (i + 1, (n - i) - 1)\n            if sum_L == (target * len_R) - sum_R:\n                if sum_L <= k:\n                    if ans < target:\n                        ans = target\n    print(ans)\n\ndef __starting_point():\n    main()\n__starting_point()", "score": 0.0, "codebleu": 0.9893183604921361, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.9937744140625, "surfaceSim": 0.9994192799070848, "abs_surfaceSim_minus_score": 0.9994192799070848, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 42}
{"id": "LOCAL_APPS_160_35_MUT_7", "golden_code": "from math import sqrt\nfrom bisect import bisect_left\n\ndef main():\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    sum_a = sum(a)\n    st = set()\n    for v in range(1, int(sqrt(sum_a)) + 2):\n        if sum_a % v == 0:\n            st.add(v)\n            st.add(sum_a // v)\n    st.remove(1)\n    ans = 1\n    for target in st:\n        a_mod_t = [v % target for v in a]\n        a_mod_t.sort()\n        for i in range(n - 1):\n            a_mod_t[i + 1] += a_mod_t[i]\n        for i in range(n):\n            (sum_L, sum_R) = (a_mod_t[i], a_mod_t[-1] - a_mod_t[i])\n            (len_L, len_R) = (i + 1, (n - i) - 1)\n            if sum_L == (target * len_R) - sum_R:\n                if sum_L <= k:\n                    if ans < target:\n                        ans = target\n    print(ans)\n\ndef __starting_point():\n    main()\n__starting_point()", "generated_code": "from math import sqrt\nfrom bisect import bisect_left\n\ndef main():\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    sum_a = sum(a)\n    st = set()\n    for v in range(1, int(sqrt(sum_a)) + 2):\n        if sum_a % v == 0:\n            st.add(v)\n            st.add(sum_a // v)\n    st.remove(1)\n    ans = 1\n    for target in st:\n        a_mod_t = [v % target for v in a]\n        a_mod_t.sort()\n        for i in range(n + 1):\n            a_mod_t[i + 1] += a_mod_t[i]\n        for i in range(n):\n            (sum_L, sum_R) = (a_mod_t[i], a_mod_t[-1] - a_mod_t[i])\n            (len_L, len_R) = (i + 1, (n - i) - 1)\n            if sum_L == (target * len_R) - sum_R:\n                if sum_L <= k:\n                    if ans < target:\n                        ans = target\n    print(ans)\n\ndef __starting_point():\n    main()\n__starting_point()", "score": 0.0, "codebleu": 0.9893183604921361, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9937753677368164, "surfaceSim": 0.9994192799070848, "abs_surfaceSim_minus_score": 0.9994192799070848, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 43}
{"id": "LOCAL_APPS_160_35_MUT_14", "golden_code": "from math import sqrt\nfrom bisect import bisect_left\n\ndef main():\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    sum_a = sum(a)\n    st = set()\n    for v in range(1, int(sqrt(sum_a)) + 2):\n        if sum_a % v == 0:\n            st.add(v)\n            st.add(sum_a // v)\n    st.remove(1)\n    ans = 1\n    for target in st:\n        a_mod_t = [v % target for v in a]\n        a_mod_t.sort()\n        for i in range(n - 1):\n            a_mod_t[i + 1] += a_mod_t[i]\n        for i in range(n):\n            (sum_L, sum_R) = (a_mod_t[i], a_mod_t[-1] - a_mod_t[i])\n            (len_L, len_R) = (i + 1, (n - i) - 1)\n            if sum_L == (target * len_R) - sum_R:\n                if sum_L <= k:\n                    if ans < target:\n                        ans = target\n    print(ans)\n\ndef __starting_point():\n    main()\n__starting_point()", "generated_code": "from math import sqrt\nfrom bisect import bisect_left\n\ndef main():\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    sum_a = sum(a)\n    st = set()\n    for v in range(1, int(sqrt(sum_a)) + 2):\n        if sum_a % v == 0:\n            st.add(v)\n            st.add(sum_a // v)\n    st.remove(1)\n    ans = 1\n    for target in st:\n        a_mod_t = [v % target for v in a]\n        a_mod_t.sort()\n        for i in range(n - 1):\n            a_mod_t[i + 1] += a_mod_t[i]\n        for i in range(n):\n            (sum_L, sum_R) = (a_mod_t[i], a_mod_t[-1] - a_mod_t[i])\n            (len_L, len_R) = (i + 1, (n - i) - 1)\n            if sum_L == (target / len_R) - sum_R:\n                if sum_L <= k:\n                    if ans < target:\n                        ans = target\n    print(ans)\n\ndef __starting_point():\n    main()\n__starting_point()", "score": 0.0, "codebleu": 0.9893183604921361, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9880234003067017, "surfaceSim": 0.9700075152012024, "abs_surfaceSim_minus_score": 0.9700075152012024, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 44}
{"id": "LOCAL_APPS_160_35_MUT_15", "golden_code": "from math import sqrt\nfrom bisect import bisect_left\n\ndef main():\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    sum_a = sum(a)\n    st = set()\n    for v in range(1, int(sqrt(sum_a)) + 2):\n        if sum_a % v == 0:\n            st.add(v)\n            st.add(sum_a // v)\n    st.remove(1)\n    ans = 1\n    for target in st:\n        a_mod_t = [v % target for v in a]\n        a_mod_t.sort()\n        for i in range(n - 1):\n            a_mod_t[i + 1] += a_mod_t[i]\n        for i in range(n):\n            (sum_L, sum_R) = (a_mod_t[i], a_mod_t[-1] - a_mod_t[i])\n            (len_L, len_R) = (i + 1, (n - i) - 1)\n            if sum_L == (target * len_R) - sum_R:\n                if sum_L <= k:\n                    if ans < target:\n                        ans = target\n    print(ans)\n\ndef __starting_point():\n    main()\n__starting_point()", "generated_code": "from math import sqrt\nfrom bisect import bisect_left\n\ndef main():\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    sum_a = sum(a)\n    st = set()\n    for v in range(1, int(sqrt(sum_a)) + 2):\n        if sum_a % v == 0:\n            st.add(v)\n            st.add(sum_a // v)\n    st.remove(1)\n    ans = 1\n    for target in st:\n        a_mod_t = [v % target for v in a]\n        a_mod_t.sort()\n        for i in range(n - 1):\n            a_mod_t[i + 1] += a_mod_t[i]\n        for i in range(n):\n            (sum_L, sum_R) = (a_mod_t[i], a_mod_t[-1] - a_mod_t[i])\n            (len_L, len_R) = (i + 1, (n - i) - 1)\n            if sum_L == (target // len_R) - sum_R:\n                if sum_L <= k:\n                    if ans < target:\n                        ans = target\n    print(ans)\n\ndef __starting_point():\n    main()\n__starting_point()", "score": 0.0, "codebleu": 0.9893183604921361, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9938136339187622, "surfaceSim": 0.9836883920410603, "abs_surfaceSim_minus_score": 0.9836883920410603, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 45}
{"id": "LOCAL_APPS_160_35_MUT_21", "golden_code": "from math import sqrt\nfrom bisect import bisect_left\n\ndef main():\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    sum_a = sum(a)\n    st = set()\n    for v in range(1, int(sqrt(sum_a)) + 2):\n        if sum_a % v == 0:\n            st.add(v)\n            st.add(sum_a // v)\n    st.remove(1)\n    ans = 1\n    for target in st:\n        a_mod_t = [v % target for v in a]\n        a_mod_t.sort()\n        for i in range(n - 1):\n            a_mod_t[i + 1] += a_mod_t[i]\n        for i in range(n):\n            (sum_L, sum_R) = (a_mod_t[i], a_mod_t[-1] - a_mod_t[i])\n            (len_L, len_R) = (i + 1, (n - i) - 1)\n            if sum_L == (target * len_R) - sum_R:\n                if sum_L <= k:\n                    if ans < target:\n                        ans = target\n    print(ans)\n\ndef __starting_point():\n    main()\n__starting_point()", "generated_code": "from math import sqrt\nfrom bisect import bisect_left\n\ndef main():\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    sum_a = sum(a)\n    st = set()\n    for v in range(1, int(sqrt(sum_a)) + 2):\n        if sum_a % v == 0:\n            st.add(v)\n            st.add(sum_a // v)\n    st.remove(1)\n    ans = 1\n    for target in st:\n        a_mod_t = [v % target for v in a]\n        a_mod_t.sort()\n        for i in range(n - 1):\n            a_mod_t[i + 1] += a_mod_t[i]\n        for i in range(n):\n            (sum_L, sum_R) = (a_mod_t[i], a_mod_t[-1] - a_mod_t[i])\n            (len_L, len_R) = (i + 1, (n - i) - 1)\n            if sum_L == (target * len_R) - sum_R:\n                if not (sum_L <= k):\n                    if ans < target:\n                        ans = target\n    print(ans)\n\ndef __starting_point():\n    main()\n__starting_point()", "score": 0.0, "codebleu": 0.9613333619325504, "crystalbleu": 0.97, "codebertscore": 1.0, "codescore": 0.9937846660614014, "surfaceSim": 0.9824106113033448, "abs_surfaceSim_minus_score": 0.9824106113033448, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 46}
{"id": "LOCAL_APPS_160_35_MUT_30", "golden_code": "from math import sqrt\nfrom bisect import bisect_left\n\ndef main():\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    sum_a = sum(a)\n    st = set()\n    for v in range(1, int(sqrt(sum_a)) + 2):\n        if sum_a % v == 0:\n            st.add(v)\n            st.add(sum_a // v)\n    st.remove(1)\n    ans = 1\n    for target in st:\n        a_mod_t = [v % target for v in a]\n        a_mod_t.sort()\n        for i in range(n - 1):\n            a_mod_t[i + 1] += a_mod_t[i]\n        for i in range(n):\n            (sum_L, sum_R) = (a_mod_t[i], a_mod_t[-1] - a_mod_t[i])\n            (len_L, len_R) = (i + 1, (n - i) - 1)\n            if sum_L == (target * len_R) - sum_R:\n                if sum_L <= k:\n                    if ans < target:\n                        ans = target\n    print(ans)\n\ndef __starting_point():\n    main()\n__starting_point()", "generated_code": "from math import sqrt\nfrom bisect import bisect_left\n\ndef main():\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    sum_a = sum(a)\n    st = set()\n    for v in range(1, int(sqrt(sum_a)) + 2):\n        if sum_a % v == 0:\n            st.add(v)\n            st.add(sum_a // v)\n    st.remove(1)\n    ans = 1\n    for target in reversed(st):\n        a_mod_t = [v % target for v in a]\n        a_mod_t.sort()\n        for i in range(n - 1):\n            a_mod_t[i + 1] += a_mod_t[i]\n        for i in range(n):\n            (sum_L, sum_R) = (a_mod_t[i], a_mod_t[-1] - a_mod_t[i])\n            (len_L, len_R) = (i + 1, (n - i) - 1)\n            if sum_L == (target * len_R) - sum_R:\n                if sum_L <= k:\n                    if ans < target:\n                        ans = target\n    print(ans)\n\ndef __starting_point():\n    main()\n__starting_point()", "score": 0.0, "codebleu": 0.9194109530847286, "crystalbleu": 0.97, "codebertscore": 1.0, "codescore": 0.9938225746154785, "surfaceSim": 0.9942594718714122, "abs_surfaceSim_minus_score": 0.9942594718714122, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 47}
{"id": "LOCAL_APPS_160_35_MUT_54", "golden_code": "from math import sqrt\nfrom bisect import bisect_left\n\ndef main():\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    sum_a = sum(a)\n    st = set()\n    for v in range(1, int(sqrt(sum_a)) + 2):\n        if sum_a % v == 0:\n            st.add(v)\n            st.add(sum_a // v)\n    st.remove(1)\n    ans = 1\n    for target in st:\n        a_mod_t = [v % target for v in a]\n        a_mod_t.sort()\n        for i in range(n - 1):\n            a_mod_t[i + 1] += a_mod_t[i]\n        for i in range(n):\n            (sum_L, sum_R) = (a_mod_t[i], a_mod_t[-1] - a_mod_t[i])\n            (len_L, len_R) = (i + 1, (n - i) - 1)\n            if sum_L == (target * len_R) - sum_R:\n                if sum_L <= k:\n                    if ans < target:\n                        ans = target\n    print(ans)\n\ndef __starting_point():\n    main()\n__starting_point()", "generated_code": "from math import sqrt\nfrom bisect import bisect_left\n\ndef main():\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    sum_a = sum(a)\n    st = set()\n    for v in range(1, int(sqrt(sum_a)) + 2):\n        if sum_a % v == 0:\n            st.add(v)\n            st.add(sum_a // v)\n    st.remove(1)\n    ans = 1\n    for target in st:\n        a_mod_t = [v % target for v in a]\n        a_mod_t.sort()\n        for i in range(n - 1):\n            a_mod_t[i + 1] += a_mod_t[i]\n        for i in range(n):\n            (sum_L, sum_R) = (a_mod_t[i], a_mod_t[-1] - a_mod_t[i])\n            (len_L, len_R) = (i + 1, (n - i) - 1)\n            if sum_L == (target * len_R) - sum_R:\n                if sum_L <= k:\n                    if ans < target:\n                        ans = target\n    pass\n\ndef __starting_point():\n    main()\n__starting_point()", "score": 0.0, "codebleu": 0.9790700439938196, "crystalbleu": 0.97, "codebertscore": 1.0, "codescore": 0.9938048124313354, "surfaceSim": 0.9812290769966523, "abs_surfaceSim_minus_score": 0.9812290769966523, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 48}
{"id": "LOCAL_APPS_160_35_MUT_55", "golden_code": "from math import sqrt\nfrom bisect import bisect_left\n\ndef main():\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    sum_a = sum(a)\n    st = set()\n    for v in range(1, int(sqrt(sum_a)) + 2):\n        if sum_a % v == 0:\n            st.add(v)\n            st.add(sum_a // v)\n    st.remove(1)\n    ans = 1\n    for target in st:\n        a_mod_t = [v % target for v in a]\n        a_mod_t.sort()\n        for i in range(n - 1):\n            a_mod_t[i + 1] += a_mod_t[i]\n        for i in range(n):\n            (sum_L, sum_R) = (a_mod_t[i], a_mod_t[-1] - a_mod_t[i])\n            (len_L, len_R) = (i + 1, (n - i) - 1)\n            if sum_L == (target * len_R) - sum_R:\n                if sum_L <= k:\n                    if ans < target:\n                        ans = target\n    print(ans)\n\ndef __starting_point():\n    main()\n__starting_point()", "generated_code": "from math import sqrt\nfrom bisect import bisect_left\n\ndef main():\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    sum_a = sum(a)\n    st = set()\n    for v in range(1, int(sqrt(sum_a)) + 2):\n        if sum_a % v == 0:\n            st.add(v)\n            st.add(sum_a // v)\n    st.remove(1)\n    ans = 1\n    for target in st:\n        a_mod_t = [v % target for v in a]\n        a_mod_t.sort()\n        for i in range(n - 1):\n            a_mod_t[i + 1] += a_mod_t[i]\n        for i in range(n):\n            (sum_L, sum_R) = (a_mod_t[i], a_mod_t[-1] - a_mod_t[i])\n            (len_L, len_R) = (i + 1, (n - i) - 1)\n            if sum_L == (target * len_R) - sum_R:\n                if sum_L <= k:\n                    if ans < target:\n                        ans = target\n    print(ans)\n\ndef __starting_point():\n    pass\n__starting_point()", "score": 0.0, "codebleu": 0.8393382057588759, "crystalbleu": 0.97, "codebertscore": 1.0, "codescore": 0.9937798380851746, "surfaceSim": 0.9823905171824827, "abs_surfaceSim_minus_score": 0.9823905171824827, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 49}
{"id": "LOCAL_APPS_160_35_MUT_56", "golden_code": "from math import sqrt\nfrom bisect import bisect_left\n\ndef main():\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    sum_a = sum(a)\n    st = set()\n    for v in range(1, int(sqrt(sum_a)) + 2):\n        if sum_a % v == 0:\n            st.add(v)\n            st.add(sum_a // v)\n    st.remove(1)\n    ans = 1\n    for target in st:\n        a_mod_t = [v % target for v in a]\n        a_mod_t.sort()\n        for i in range(n - 1):\n            a_mod_t[i + 1] += a_mod_t[i]\n        for i in range(n):\n            (sum_L, sum_R) = (a_mod_t[i], a_mod_t[-1] - a_mod_t[i])\n            (len_L, len_R) = (i + 1, (n - i) - 1)\n            if sum_L == (target * len_R) - sum_R:\n                if sum_L <= k:\n                    if ans < target:\n                        ans = target\n    print(ans)\n\ndef __starting_point():\n    main()\n__starting_point()", "generated_code": "from math import sqrt\nfrom bisect import bisect_left\n\ndef main():\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    sum_a = sum(a)\n    st = set()\n    for v in range(1, int(sqrt(sum_a)) + 2):\n        if sum_a % v == 0:\n            st.add(v)\n            st.add(sum_a // v)\n    st.remove(1)\n    ans = 1\n    for target in st:\n        a_mod_t = [v % target for v in a]\n        a_mod_t.sort()\n        for i in range(n - 1):\n            a_mod_t[i + 1] += a_mod_t[i]\n        for i in range(n):\n            (sum_L, sum_R) = (a_mod_t[i], a_mod_t[-1] - a_mod_t[i])\n            (len_L, len_R) = (i + 1, (n - i) - 1)\n            if sum_L == (target * len_R) - sum_R:\n                if sum_L <= k:\n                    if ans < target:\n                        ans = target\n    print(ans)\n\ndef __starting_point():\n    main()\npass", "score": 0.0, "codebleu": 0.9883535386837938, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.9937852621078491, "surfaceSim": 0.9754218760675002, "abs_surfaceSim_minus_score": 0.9754218760675002, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 50}
{"id": "LOCAL_APPS_170_0_MUT_10", "golden_code": "n = int(input())\nk1 = list(map(int, input().split()[1:]))\nk2 = list(map(int, input().split()[1:]))\n\ni = 0\nwhile True:\n    if (len(k1) == 0 or len(k2) == 0):\n        break\n    if i > 10000:\n        break\n    if k1[0] > k2[0]:\n        k1 = (k1[1:] + k2[0:1]) + k1[0:1]\n        k2 = k2[1:]\n    else:\n        k2 = (k2[1:] + k1[0:1]) + k2[0:1]\n        k1 = k1[1:]\n    i += 1\n\nif i > 10000:\n    print(-1)\nelse:\n    winner = 1\n    if len(k1) == 0:\n        winner = 2\n    print(i, winner)", "generated_code": "n = int(input())\nk1 = list(map(int, input().split()[1:]))\nk2 = list(map(int, input().split()[1:]))\n\ni = 0\nwhile not True:\n    if (len(k1) == 0 or len(k2) == 0):\n        break\n    if i > 10000:\n        break\n    if k1[0] > k2[0]:\n        k1 = (k1[1:] + k2[0:1]) + k1[0:1]\n        k2 = k2[1:]\n    else:\n        k2 = (k2[1:] + k1[0:1]) + k2[0:1]\n        k1 = k1[1:]\n    i += 1\n\nif i > 10000:\n    print(-1)\nelse:\n    winner = 1\n    if len(k1) == 0:\n        winner = 2\n    print(i, winner)", "score": 0.0, "codebleu": 0.9820496446348989, "crystalbleu": 0.97, "codebertscore": 1.0, "codescore": 0.9936605095863342, "surfaceSim": 0.9776700572155117, "abs_surfaceSim_minus_score": 0.9776700572155117, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 51}
{"id": "LOCAL_APPS_170_0_MUT_11", "golden_code": "n = int(input())\nk1 = list(map(int, input().split()[1:]))\nk2 = list(map(int, input().split()[1:]))\n\ni = 0\nwhile True:\n    if (len(k1) == 0 or len(k2) == 0):\n        break\n    if i > 10000:\n        break\n    if k1[0] > k2[0]:\n        k1 = (k1[1:] + k2[0:1]) + k1[0:1]\n        k2 = k2[1:]\n    else:\n        k2 = (k2[1:] + k1[0:1]) + k2[0:1]\n        k1 = k1[1:]\n    i += 1\n\nif i > 10000:\n    print(-1)\nelse:\n    winner = 1\n    if len(k1) == 0:\n        winner = 2\n    print(i, winner)", "generated_code": "n = int(input())\nk1 = list(map(int, input().split()[1:]))\nk2 = list(map(int, input().split()[1:]))\n\ni = 0\nwhile True:\n    if not ((len(k1) == 0 or len(k2) == 0)):\n        break\n    if i > 10000:\n        break\n    if k1[0] > k2[0]:\n        k1 = (k1[1:] + k2[0:1]) + k1[0:1]\n        k2 = k2[1:]\n    else:\n        k2 = (k2[1:] + k1[0:1]) + k2[0:1]\n        k1 = k1[1:]\n    i += 1\n\nif i > 10000:\n    print(-1)\nelse:\n    winner = 1\n    if len(k1) == 0:\n        winner = 2\n    print(i, winner)", "score": 0.0, "codebleu": 0.9544408324956135, "crystalbleu": 0.96, "codebertscore": 1.0, "codescore": 0.9936705827713013, "surfaceSim": 0.9756251978474201, "abs_surfaceSim_minus_score": 0.9756251978474201, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 52}
{"id": "LOCAL_APPS_170_0_MUT_12", "golden_code": "n = int(input())\nk1 = list(map(int, input().split()[1:]))\nk2 = list(map(int, input().split()[1:]))\n\ni = 0\nwhile True:\n    if (len(k1) == 0 or len(k2) == 0):\n        break\n    if i > 10000:\n        break\n    if k1[0] > k2[0]:\n        k1 = (k1[1:] + k2[0:1]) + k1[0:1]\n        k2 = k2[1:]\n    else:\n        k2 = (k2[1:] + k1[0:1]) + k2[0:1]\n        k1 = k1[1:]\n    i += 1\n\nif i > 10000:\n    print(-1)\nelse:\n    winner = 1\n    if len(k1) == 0:\n        winner = 2\n    print(i, winner)", "generated_code": "n = int(input())\nk1 = list(map(int, input().split()[1:]))\nk2 = list(map(int, input().split()[1:]))\n\ni = 0\nwhile True:\n    if (len(k1) == 0 or len(k2) == 0):\n        break\n    if not (i > 10000):\n        break\n    if k1[0] > k2[0]:\n        k1 = (k1[1:] + k2[0:1]) + k1[0:1]\n        k2 = k2[1:]\n    else:\n        k2 = (k2[1:] + k1[0:1]) + k2[0:1]\n        k1 = k1[1:]\n    i += 1\n\nif i > 10000:\n    print(-1)\nelse:\n    winner = 1\n    if len(k1) == 0:\n        winner = 2\n    print(i, winner)", "score": 0.0, "codebleu": 0.9596719420532649, "crystalbleu": 0.95, "codebertscore": 1.0, "codescore": 0.9936757683753967, "surfaceSim": 0.9756251978474201, "abs_surfaceSim_minus_score": 0.9756251978474201, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 53}
{"id": "LOCAL_APPS_170_0_MUT_14", "golden_code": "n = int(input())\nk1 = list(map(int, input().split()[1:]))\nk2 = list(map(int, input().split()[1:]))\n\ni = 0\nwhile True:\n    if (len(k1) == 0 or len(k2) == 0):\n        break\n    if i > 10000:\n        break\n    if k1[0] > k2[0]:\n        k1 = (k1[1:] + k2[0:1]) + k1[0:1]\n        k2 = k2[1:]\n    else:\n        k2 = (k2[1:] + k1[0:1]) + k2[0:1]\n        k1 = k1[1:]\n    i += 1\n\nif i > 10000:\n    print(-1)\nelse:\n    winner = 1\n    if len(k1) == 0:\n        winner = 2\n    print(i, winner)", "generated_code": "n = int(input())\nk1 = list(map(int, input().split()[1:]))\nk2 = list(map(int, input().split()[1:]))\n\ni = 0\nwhile True:\n    if (len(k1) == 0 or len(k2) == 0):\n        break\n    if i > 10000:\n        break\n    if k1[0] > k2[0]:\n        k1 = (k1[1:] + k2[0:1]) + k1[0:1]\n        k2 = k2[1:]\n    else:\n        k2 = (k2[1:] + k1[0:1]) + k2[0:1]\n        k1 = k1[1:]\n    i += 1\n\nif not (i > 10000):\n    print(-1)\nelse:\n    winner = 1\n    if len(k1) == 0:\n        winner = 2\n    print(i, winner)", "score": 0.0, "codebleu": 0.9641362277675506, "crystalbleu": 0.95, "codebertscore": 1.0, "codescore": 0.9936813116073608, "surfaceSim": 0.9756251978474201, "abs_surfaceSim_minus_score": 0.9756251978474201, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 54}
{"id": "LOCAL_APPS_349_17_MUT_6", "golden_code": "def increasing(m):\n    for i in range(len(m)):\n        prev = m[i][0]\n        for j in range(1, len(m[i])):\n            if m[i][j] <= prev:\n                return False\n            prev = m[i][j]\n    for j in range(len(m[0])):\n        prev = m[0][j]\n        for i in range(1, len(m)):\n            if m[i][j] <= prev:\n                return False\n            prev = m[i][j]\n    return True\ndef sol(m1, m2):\n    for i in range(len(m1)):\n        for j in range(len(m1[i])):\n            if m1[i][j] > m2[i][j]:\n                (m1[i][j], m2[i][j]) = (m2[i][j], m1[i][j])\n    if (not (increasing(m1)) or not (increasing(m2))):\n        return 'Impossible'\n    return 'Possible'\ndef __starting_point():\n    [n, m] = [int(x) for x in input().split()]\n    (m1, m2) = ([], [])\n    for _ in range(n):\n        m1.append([int(x) for x in input().split()])\n    for _ in range(n):\n        m2.append([int(x) for x in input().split()])\n    print(sol(m1, m2))\n__starting_point()", "generated_code": "def increasing(m):\n    for i in range(len(m)):\n        prev = m[i][0]\n        for j in range(1, len(m[i])):\n            if m[i][j] <= prev:\n                return False\n            prev = m[i][j]\n    for j in range(len(m[0])):\n        prev = m[0][j]\n        for i in range(1, len(m)):\n            if m[i][j] <= prev:\n                return False\n            prev = m[i][j]\n    return True\ndef sol(m1, m2):\n    for i in range(len(m1)):\n        for j in range(len(m1[i])):\n            if m1[i][j] > m2[i][j]:\n                (m1[i][j], m2[i][j]) = (m2[i][j], m1[i][j])\n    if not ((not (increasing(m1)) or not (increasing(m2)))):\n        return 'Impossible'\n    return 'Possible'\ndef __starting_point():\n    [n, m] = [int(x) for x in input().split()]\n    (m1, m2) = ([], [])\n    for _ in range(n):\n        m1.append([int(x) for x in input().split()])\n    for _ in range(n):\n        m2.append([int(x) for x in input().split()])\n    print(sol(m1, m2))\n__starting_point()", "score": 0.0, "codebleu": 0.9698670664068252, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.9937472343444824, "surfaceSim": 0.9974120082815735, "abs_surfaceSim_minus_score": 0.9974120082815735, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 55}
{"id": "LOCAL_APPS_349_17_MUT_45", "golden_code": "def increasing(m):\n    for i in range(len(m)):\n        prev = m[i][0]\n        for j in range(1, len(m[i])):\n            if m[i][j] <= prev:\n                return False\n            prev = m[i][j]\n    for j in range(len(m[0])):\n        prev = m[0][j]\n        for i in range(1, len(m)):\n            if m[i][j] <= prev:\n                return False\n            prev = m[i][j]\n    return True\ndef sol(m1, m2):\n    for i in range(len(m1)):\n        for j in range(len(m1[i])):\n            if m1[i][j] > m2[i][j]:\n                (m1[i][j], m2[i][j]) = (m2[i][j], m1[i][j])\n    if (not (increasing(m1)) or not (increasing(m2))):\n        return 'Impossible'\n    return 'Possible'\ndef __starting_point():\n    [n, m] = [int(x) for x in input().split()]\n    (m1, m2) = ([], [])\n    for _ in range(n):\n        m1.append([int(x) for x in input().split()])\n    for _ in range(n):\n        m2.append([int(x) for x in input().split()])\n    print(sol(m1, m2))\n__starting_point()", "generated_code": "def increasing(m):\n    for i in range(len(m)):\n        prev = m[i][0]\n        for j in range(1, len(m[i])):\n            if m[i][j] <= prev:\n                return False\n            prev = m[i][j]\n    for j in range(len(m[0])):\n        prev = m[0][j]\n        for i in range(1, len(m)):\n            if m[i][j] <= prev:\n                return False\n            prev = m[i][j]\n    return True\ndef sol(m1, m2):\n    for i in range(len(m1)):\n        for j in range(len(m1[i])):\n            if m1[i][j] > m2[i][j]:\n                (m1[i][j], m2[i][j]) = (m2[i][j], m1[i][j])\n    if (not (increasing(m1)) or not (increasing(m2))):\n        return 'Impossible'\n    return 'Possible'\ndef __starting_point():\n    [n, m] = [int(x) for x in input().split()]\n    pass\n    for _ in range(n):\n        m1.append([int(x) for x in input().split()])\n    for _ in range(n):\n        m2.append([int(x) for x in input().split()])\n    print(sol(m1, m2))\n__starting_point()", "score": 0.0, "codebleu": 0.9546572047554621, "crystalbleu": 0.95, "codebertscore": 1.0, "codescore": 0.9938338994979858, "surfaceSim": 0.9749461206896552, "abs_surfaceSim_minus_score": 0.9749461206896552, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 56}
{"id": "LOCAL_APPS_349_17_MUT_48", "golden_code": "def increasing(m):\n    for i in range(len(m)):\n        prev = m[i][0]\n        for j in range(1, len(m[i])):\n            if m[i][j] <= prev:\n                return False\n            prev = m[i][j]\n    for j in range(len(m[0])):\n        prev = m[0][j]\n        for i in range(1, len(m)):\n            if m[i][j] <= prev:\n                return False\n            prev = m[i][j]\n    return True\ndef sol(m1, m2):\n    for i in range(len(m1)):\n        for j in range(len(m1[i])):\n            if m1[i][j] > m2[i][j]:\n                (m1[i][j], m2[i][j]) = (m2[i][j], m1[i][j])\n    if (not (increasing(m1)) or not (increasing(m2))):\n        return 'Impossible'\n    return 'Possible'\ndef __starting_point():\n    [n, m] = [int(x) for x in input().split()]\n    (m1, m2) = ([], [])\n    for _ in range(n):\n        m1.append([int(x) for x in input().split()])\n    for _ in range(n):\n        m2.append([int(x) for x in input().split()])\n    print(sol(m1, m2))\n__starting_point()", "generated_code": "def increasing(m):\n    for i in range(len(m)):\n        prev = m[i][0]\n        for j in range(1, len(m[i])):\n            if m[i][j] <= prev:\n                return False\n            prev = m[i][j]\n    for j in range(len(m[0])):\n        prev = m[0][j]\n        for i in range(1, len(m)):\n            if m[i][j] <= prev:\n                return False\n            prev = m[i][j]\n    return True\ndef sol(m1, m2):\n    for i in range(len(m1)):\n        for j in range(len(m1[i])):\n            if m1[i][j] > m2[i][j]:\n                (m1[i][j], m2[i][j]) = (m2[i][j], m1[i][j])\n    if (not (increasing(m1)) or not (increasing(m2))):\n        return 'Impossible'\n    return 'Possible'\ndef __starting_point():\n    [n, m] = [int(x) for x in input().split()]\n    (m1, m2) = ([], [])\n    for _ in range(n):\n        m1.append([int(x) for x in input().split()])\n    for _ in range(n):\n        m2.append([int(x) for x in input().split()])\n    pass\n__starting_point()", "score": 0.0, "codebleu": 0.9130412202460718, "crystalbleu": 0.96, "codebertscore": 1.0, "codescore": 0.9937403202056885, "surfaceSim": 0.9749461206896552, "abs_surfaceSim_minus_score": 0.9749461206896552, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 57}
{"id": "LOCAL_APPS_349_17_MUT_49", "golden_code": "def increasing(m):\n    for i in range(len(m)):\n        prev = m[i][0]\n        for j in range(1, len(m[i])):\n            if m[i][j] <= prev:\n                return False\n            prev = m[i][j]\n    for j in range(len(m[0])):\n        prev = m[0][j]\n        for i in range(1, len(m)):\n            if m[i][j] <= prev:\n                return False\n            prev = m[i][j]\n    return True\ndef sol(m1, m2):\n    for i in range(len(m1)):\n        for j in range(len(m1[i])):\n            if m1[i][j] > m2[i][j]:\n                (m1[i][j], m2[i][j]) = (m2[i][j], m1[i][j])\n    if (not (increasing(m1)) or not (increasing(m2))):\n        return 'Impossible'\n    return 'Possible'\ndef __starting_point():\n    [n, m] = [int(x) for x in input().split()]\n    (m1, m2) = ([], [])\n    for _ in range(n):\n        m1.append([int(x) for x in input().split()])\n    for _ in range(n):\n        m2.append([int(x) for x in input().split()])\n    print(sol(m1, m2))\n__starting_point()", "generated_code": "def increasing(m):\n    for i in range(len(m)):\n        prev = m[i][0]\n        for j in range(1, len(m[i])):\n            if m[i][j] <= prev:\n                return False\n            prev = m[i][j]\n    for j in range(len(m[0])):\n        prev = m[0][j]\n        for i in range(1, len(m)):\n            if m[i][j] <= prev:\n                return False\n            prev = m[i][j]\n    return True\ndef sol(m1, m2):\n    for i in range(len(m1)):\n        for j in range(len(m1[i])):\n            if m1[i][j] > m2[i][j]:\n                (m1[i][j], m2[i][j]) = (m2[i][j], m1[i][j])\n    if (not (increasing(m1)) or not (increasing(m2))):\n        return 'Impossible'\n    return 'Possible'\ndef __starting_point():\n    [n, m] = [int(x) for x in input().split()]\n    (m1, m2) = ([], [])\n    for _ in range(n):\n        m1.append([int(x) for x in input().split()])\n    for _ in range(n):\n        m2.append([int(x) for x in input().split()])\n    print(sol(m1, m2))\npass", "score": 0.0, "codebleu": 0.9643998523389635, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9937489032745361, "surfaceSim": 0.9739044540229885, "abs_surfaceSim_minus_score": 0.9739044540229885, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 58}
{"id": "LOCAL_APPS_401_13_MUT_6", "golden_code": "(n, m) = list(map(int, input().split()))\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nf = True\nfor i in range(1, 10):\n    if (i in a and i in b):\n        print(i)\n        f = False\n        break\nif f:\n    print(str(min(min(a), min(b))) + str(max(min(a), min(b))))", "generated_code": "(n, m) = list(map(int, input().split()))\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nf = True\nfor i in range(1, 10):\n    if (i in a and i in b):\n        print(i)\n        f = False\n        break\nif not f:\n    print(str(min(min(a), min(b))) + str(max(min(a), min(b))))", "score": 0.0, "codebleu": 0.9677689914832857, "crystalbleu": 0.96, "codebertscore": 1.0, "codescore": 0.9936165809631348, "surfaceSim": 0.9472789115646258, "abs_surfaceSim_minus_score": 0.9472789115646258, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 59}
{"id": "LOCAL_APPS_483_9_MUT_9", "golden_code": "import time\n\nn = int(input())\n\nN = [i for i in input()]\nx = [int(i) for i in input().split()]\n\nstart = time.time()\n\nflag = False\nans = float('Inf')\n\nfor i in range(n):\n    if N[i] == 'R':\n        left = i\n        flag = True\n    elif flag == True:\n        buf = x[i] - x[left]\n        if buf < ans:\n            ans = buf\n        flag = False\n\nif ans < float('Inf'):\n    print(ans // 2)\nelse:\n    print(-1)\n\nfinish = time.time()", "generated_code": "import time\n\nn = int(input())\n\nN = [i for i in input()]\nx = [int(i) for i in input().split()]\n\nstart = time.time()\n\nflag = False\nans = float('Inf')\n\nfor i in range(n):\n    if N[i] == 'R':\n        left = i\n        flag = True\n    elif flag == True:\n        buf = x[i] - x[left]\n        if buf < ans:\n            ans = buf\n        flag = False\n\nif not (ans < float('Inf')):\n    print(ans // 2)\nelse:\n    print(-1)\n\nfinish = time.time()", "score": 0.0, "codebleu": 0.9617172575824924, "crystalbleu": 0.94, "codebertscore": 1.0, "codescore": 0.9937863349914551, "surfaceSim": 0.9749955587138035, "abs_surfaceSim_minus_score": 0.9749955587138035, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 60}
{"id": "LOCAL_APPS_707_11_MUT_7", "golden_code": "(n, m) = list(map(int, input().split()))\nx = tuple(map(int, input().split()))\ny = min(x)\na = 0\nfor xi in x:\n    b = xi - y\n    while b:\n        (a, b) = (b, a % b)\nj = 1\nfor p in input().split():\n    if a % int(p):\n        j += 1\n        continue\n    print('YES')\n    print(y, j)\n    break\nelse:\n    print('NO')", "generated_code": "(n, m) = list(map(int, input().split()))\nx = tuple(map(int, input().split()))\ny = min(x)\na = 0\nfor xi in x:\n    b = xi - y\n    while not b:\n        (a, b) = (b, a % b)\nj = 1\nfor p in input().split():\n    if a % int(p):\n        j += 1\n        continue\n    print('YES')\n    print(y, j)\n    break\nelse:\n    print('NO')", "score": 0.0, "codebleu": 0.9671203282309844, "crystalbleu": 0.96, "codebertscore": 1.0, "codescore": 0.9937015771865845, "surfaceSim": 0.9497835497835498, "abs_surfaceSim_minus_score": 0.9497835497835498, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 61}
{"id": "LOCAL_APPS_899_44_MUT_7", "golden_code": "(N, M) = map(int, input().split())\nINF = float('inf')\nedges = []\nfor _ in range(M):\n    edges.append(list(map(int, input().split())))\ngraph = [[INF if i != j else 0 for i in range(N)] for j in range(N)]\nfor i in range(M):\n    (a, b, c) = edges[i]\n    graph[a - 1][b - 1] = c\n    graph[b - 1][a - 1] = c\nfor k in range(N):\n    for i in range(N):\n        for j in range(N):\n            graph[i][j] = min(graph[i][j], graph[i][k] + graph[k][j])\nans = 0\nfor i in range(M):\n    (a, b, c) = edges[i]\n    if c != graph[a - 1][b - 1]:\n        ans += 1\nprint(ans)", "generated_code": "(N, M) = map(int, input().split())\nINF = float('inf')\nedges = []\nfor _ in range(M):\n    edges.append(list(map(int, input().split())))\ngraph = [[INF if i != j else 0 for i in range(N)] for j in range(N)]\nfor i in range(M):\n    (a, b, c) = edges[i]\n    graph[a - 1][b - 1] = c\n    graph[b - 1][a - 1] = c\nfor k in range(N):\n    for i in range(N):\n        for j in range(N):\n            graph[i][j] = min(graph[i][j], graph[i][k] + graph[k][j])\nans = 0\nfor i in range(M):\n    (a, b, c) = edges[i]\n    if c != graph[a - 1][b + 1]:\n        ans += 1\nprint(ans)", "score": 0.0, "codebleu": 0.9873458795457556, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.9937680959701538, "surfaceSim": 0.9990974729241877, "abs_surfaceSim_minus_score": 0.9990974729241877, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 62}
{"id": "LOCAL_APPS_955_11_MUT_1", "golden_code": "n = int(input())\nd = {}\nfor _ in range(n):\n    s = input().split()\n    p = int(s[0])\n    s[1] = list(s[1])\n    s[1].sort()\n    s[1] = ''.join(s[1])\n    if s[1] in d:\n        d[s[1]] = min(d[s[1]], p)\n    else:\n        d[s[1]] = p\ndef get(s):\n    if s in d:\n        return d[s]\n    return 10 ** 6\na = get('A')\nb = get('B')\nc = get('C')\nab = get('AB')\nbc = get('BC')\nac = get('AC')\nabc = get('ABC')\nans = min((a + b) + c, a + bc, b + ac, c + ab, abc, ab + bc, ab + ac, ac + bc)\nif ans < 10 ** 6:\n    print(ans)\nelse:\n    print(-1)", "generated_code": "n = int(input())\nd = {}\nfor _ in range(n):\n    s = input().split()\n    p = int(s[0])\n    s[1] = list(s[1])\n    s[1].sort()\n    s[1] = ''.join(s[1])\n    if s[1] in d:\n        d[s[1]] = min(d[s[1]], p)\n    else:\n        d[s[1]] = p\ndef get(s):\n    if s in d:\n        return d[s]\n    return 10 ** 6\na = get('A')\nb = get('B')\nc = get('C')\nab = get('AB')\nbc = get('BC')\nac = get('AC')\nabc = get('ABC')\nans = min((a + b) + c, a + bc, b + ac, c + ab, abc, ab + bc, ab + ac, ac + bc)\nif ans < 10 ** 6:\n    print(ans)\nelse:\n    print(1)", "score": 0.0, "codebleu": 0.9803174518341569, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9937969446182251, "surfaceSim": 0.9605914918414918, "abs_surfaceSim_minus_score": 0.9605914918414918, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 63}
{"id": "LOCAL_APPS_955_11_MUT_2", "golden_code": "n = int(input())\nd = {}\nfor _ in range(n):\n    s = input().split()\n    p = int(s[0])\n    s[1] = list(s[1])\n    s[1].sort()\n    s[1] = ''.join(s[1])\n    if s[1] in d:\n        d[s[1]] = min(d[s[1]], p)\n    else:\n        d[s[1]] = p\ndef get(s):\n    if s in d:\n        return d[s]\n    return 10 ** 6\na = get('A')\nb = get('B')\nc = get('C')\nab = get('AB')\nbc = get('BC')\nac = get('AC')\nabc = get('ABC')\nans = min((a + b) + c, a + bc, b + ac, c + ab, abc, ab + bc, ab + ac, ac + bc)\nif ans < 10 ** 6:\n    print(ans)\nelse:\n    print(-1)", "generated_code": "n = int(input())\nd = {}\nfor _ in range(n):\n    s = input().split()\n    p = int(s[0])\n    s[1] = list(s[1])\n    s[1].sort()\n    s[1] = ''.join(s[1])\n    if s[1] in d:\n        d[s[1]] = min(d[s[1]], p)\n    else:\n        d[s[1]] = p\ndef get(s):\n    if s in d:\n        return d[s]\n    return 10 * 6\na = get('A')\nb = get('B')\nc = get('C')\nab = get('AB')\nbc = get('BC')\nac = get('AC')\nabc = get('ABC')\nans = min((a + b) + c, a + bc, b + ac, c + ab, abc, ab + bc, ab + ac, ac + bc)\nif ans < 10 ** 6:\n    print(ans)\nelse:\n    print(-1)", "score": 0.0, "codebleu": 0.9877568500407993, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9937604069709778, "surfaceSim": 0.9805345117845117, "abs_surfaceSim_minus_score": 0.9805345117845117, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 64}
{"id": "LOCAL_APPS_955_11_MUT_3", "golden_code": "n = int(input())\nd = {}\nfor _ in range(n):\n    s = input().split()\n    p = int(s[0])\n    s[1] = list(s[1])\n    s[1].sort()\n    s[1] = ''.join(s[1])\n    if s[1] in d:\n        d[s[1]] = min(d[s[1]], p)\n    else:\n        d[s[1]] = p\ndef get(s):\n    if s in d:\n        return d[s]\n    return 10 ** 6\na = get('A')\nb = get('B')\nc = get('C')\nab = get('AB')\nbc = get('BC')\nac = get('AC')\nabc = get('ABC')\nans = min((a + b) + c, a + bc, b + ac, c + ab, abc, ab + bc, ab + ac, ac + bc)\nif ans < 10 ** 6:\n    print(ans)\nelse:\n    print(-1)", "generated_code": "n = int(input())\nd = {}\nfor _ in range(n):\n    s = input().split()\n    p = int(s[0])\n    s[1] = list(s[1])\n    s[1].sort()\n    s[1] = ''.join(s[1])\n    if s[1] in d:\n        d[s[1]] = min(d[s[1]], p)\n    else:\n        d[s[1]] = p\ndef get(s):\n    if s in d:\n        return d[s]\n    return 10 ** 6\na = get('A')\nb = get('B')\nc = get('C')\nab = get('AB')\nbc = get('BC')\nac = get('AC')\nabc = get('ABC')\nans = min((a - b) + c, a + bc, b + ac, c + ab, abc, ab + bc, ab + ac, ac + bc)\nif ans < 10 ** 6:\n    print(ans)\nelse:\n    print(-1)", "score": 0.0, "codebleu": 0.9877568500407993, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.9937818646430969, "surfaceSim": 0.9805345117845117, "abs_surfaceSim_minus_score": 0.9805345117845117, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 65}
{"id": "LOCAL_APPS_955_11_MUT_4", "golden_code": "n = int(input())\nd = {}\nfor _ in range(n):\n    s = input().split()\n    p = int(s[0])\n    s[1] = list(s[1])\n    s[1].sort()\n    s[1] = ''.join(s[1])\n    if s[1] in d:\n        d[s[1]] = min(d[s[1]], p)\n    else:\n        d[s[1]] = p\ndef get(s):\n    if s in d:\n        return d[s]\n    return 10 ** 6\na = get('A')\nb = get('B')\nc = get('C')\nab = get('AB')\nbc = get('BC')\nac = get('AC')\nabc = get('ABC')\nans = min((a + b) + c, a + bc, b + ac, c + ab, abc, ab + bc, ab + ac, ac + bc)\nif ans < 10 ** 6:\n    print(ans)\nelse:\n    print(-1)", "generated_code": "n = int(input())\nd = {}\nfor _ in range(n):\n    s = input().split()\n    p = int(s[0])\n    s[1] = list(s[1])\n    s[1].sort()\n    s[1] = ''.join(s[1])\n    if s[1] in d:\n        d[s[1]] = min(d[s[1]], p)\n    else:\n        d[s[1]] = p\ndef get(s):\n    if s in d:\n        return d[s]\n    return 10 ** 6\na = get('A')\nb = get('B')\nc = get('C')\nab = get('AB')\nbc = get('BC')\nac = get('AC')\nabc = get('ABC')\nans = min((a + b) - c, a + bc, b + ac, c + ab, abc, ab + bc, ab + ac, ac + bc)\nif ans < 10 ** 6:\n    print(ans)\nelse:\n    print(-1)", "score": 0.0, "codebleu": 0.9877568500407993, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.9938165545463562, "surfaceSim": 0.9805345117845117, "abs_surfaceSim_minus_score": 0.9805345117845117, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 66}
{"id": "LOCAL_APPS_955_11_MUT_5", "golden_code": "n = int(input())\nd = {}\nfor _ in range(n):\n    s = input().split()\n    p = int(s[0])\n    s[1] = list(s[1])\n    s[1].sort()\n    s[1] = ''.join(s[1])\n    if s[1] in d:\n        d[s[1]] = min(d[s[1]], p)\n    else:\n        d[s[1]] = p\ndef get(s):\n    if s in d:\n        return d[s]\n    return 10 ** 6\na = get('A')\nb = get('B')\nc = get('C')\nab = get('AB')\nbc = get('BC')\nac = get('AC')\nabc = get('ABC')\nans = min((a + b) + c, a + bc, b + ac, c + ab, abc, ab + bc, ab + ac, ac + bc)\nif ans < 10 ** 6:\n    print(ans)\nelse:\n    print(-1)", "generated_code": "n = int(input())\nd = {}\nfor _ in range(n):\n    s = input().split()\n    p = int(s[0])\n    s[1] = list(s[1])\n    s[1].sort()\n    s[1] = ''.join(s[1])\n    if s[1] in d:\n        d[s[1]] = min(d[s[1]], p)\n    else:\n        d[s[1]] = p\ndef get(s):\n    if s in d:\n        return d[s]\n    return 10 ** 6\na = get('A')\nb = get('B')\nc = get('C')\nab = get('AB')\nbc = get('BC')\nac = get('AC')\nabc = get('ABC')\nans = min((a + b) + c, a - bc, b + ac, c + ab, abc, ab + bc, ab + ac, ac + bc)\nif ans < 10 ** 6:\n    print(ans)\nelse:\n    print(-1)", "score": 0.0, "codebleu": 0.9877568500407993, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.9937897324562073, "surfaceSim": 0.9805345117845117, "abs_surfaceSim_minus_score": 0.9805345117845117, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 67}
{"id": "LOCAL_APPS_955_11_MUT_6", "golden_code": "n = int(input())\nd = {}\nfor _ in range(n):\n    s = input().split()\n    p = int(s[0])\n    s[1] = list(s[1])\n    s[1].sort()\n    s[1] = ''.join(s[1])\n    if s[1] in d:\n        d[s[1]] = min(d[s[1]], p)\n    else:\n        d[s[1]] = p\ndef get(s):\n    if s in d:\n        return d[s]\n    return 10 ** 6\na = get('A')\nb = get('B')\nc = get('C')\nab = get('AB')\nbc = get('BC')\nac = get('AC')\nabc = get('ABC')\nans = min((a + b) + c, a + bc, b + ac, c + ab, abc, ab + bc, ab + ac, ac + bc)\nif ans < 10 ** 6:\n    print(ans)\nelse:\n    print(-1)", "generated_code": "n = int(input())\nd = {}\nfor _ in range(n):\n    s = input().split()\n    p = int(s[0])\n    s[1] = list(s[1])\n    s[1].sort()\n    s[1] = ''.join(s[1])\n    if s[1] in d:\n        d[s[1]] = min(d[s[1]], p)\n    else:\n        d[s[1]] = p\ndef get(s):\n    if s in d:\n        return d[s]\n    return 10 ** 6\na = get('A')\nb = get('B')\nc = get('C')\nab = get('AB')\nbc = get('BC')\nac = get('AC')\nabc = get('ABC')\nans = min((a + b) + c, a + bc, b - ac, c + ab, abc, ab + bc, ab + ac, ac + bc)\nif ans < 10 ** 6:\n    print(ans)\nelse:\n    print(-1)", "score": 0.0, "codebleu": 0.9877568500407993, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.9937868118286133, "surfaceSim": 0.9805345117845117, "abs_surfaceSim_minus_score": 0.9805345117845117, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 68}
{"id": "LOCAL_APPS_955_11_MUT_7", "golden_code": "n = int(input())\nd = {}\nfor _ in range(n):\n    s = input().split()\n    p = int(s[0])\n    s[1] = list(s[1])\n    s[1].sort()\n    s[1] = ''.join(s[1])\n    if s[1] in d:\n        d[s[1]] = min(d[s[1]], p)\n    else:\n        d[s[1]] = p\ndef get(s):\n    if s in d:\n        return d[s]\n    return 10 ** 6\na = get('A')\nb = get('B')\nc = get('C')\nab = get('AB')\nbc = get('BC')\nac = get('AC')\nabc = get('ABC')\nans = min((a + b) + c, a + bc, b + ac, c + ab, abc, ab + bc, ab + ac, ac + bc)\nif ans < 10 ** 6:\n    print(ans)\nelse:\n    print(-1)", "generated_code": "n = int(input())\nd = {}\nfor _ in range(n):\n    s = input().split()\n    p = int(s[0])\n    s[1] = list(s[1])\n    s[1].sort()\n    s[1] = ''.join(s[1])\n    if s[1] in d:\n        d[s[1]] = min(d[s[1]], p)\n    else:\n        d[s[1]] = p\ndef get(s):\n    if s in d:\n        return d[s]\n    return 10 ** 6\na = get('A')\nb = get('B')\nc = get('C')\nab = get('AB')\nbc = get('BC')\nac = get('AC')\nabc = get('ABC')\nans = min((a + b) + c, a + bc, b + ac, c - ab, abc, ab + bc, ab + ac, ac + bc)\nif ans < 10 ** 6:\n    print(ans)\nelse:\n    print(-1)", "score": 0.0, "codebleu": 0.9877568500407993, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.9937969446182251, "surfaceSim": 0.9805345117845117, "abs_surfaceSim_minus_score": 0.9805345117845117, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 69}
{"id": "LOCAL_APPS_955_11_MUT_8", "golden_code": "n = int(input())\nd = {}\nfor _ in range(n):\n    s = input().split()\n    p = int(s[0])\n    s[1] = list(s[1])\n    s[1].sort()\n    s[1] = ''.join(s[1])\n    if s[1] in d:\n        d[s[1]] = min(d[s[1]], p)\n    else:\n        d[s[1]] = p\ndef get(s):\n    if s in d:\n        return d[s]\n    return 10 ** 6\na = get('A')\nb = get('B')\nc = get('C')\nab = get('AB')\nbc = get('BC')\nac = get('AC')\nabc = get('ABC')\nans = min((a + b) + c, a + bc, b + ac, c + ab, abc, ab + bc, ab + ac, ac + bc)\nif ans < 10 ** 6:\n    print(ans)\nelse:\n    print(-1)", "generated_code": "n = int(input())\nd = {}\nfor _ in range(n):\n    s = input().split()\n    p = int(s[0])\n    s[1] = list(s[1])\n    s[1].sort()\n    s[1] = ''.join(s[1])\n    if s[1] in d:\n        d[s[1]] = min(d[s[1]], p)\n    else:\n        d[s[1]] = p\ndef get(s):\n    if s in d:\n        return d[s]\n    return 10 ** 6\na = get('A')\nb = get('B')\nc = get('C')\nab = get('AB')\nbc = get('BC')\nac = get('AC')\nabc = get('ABC')\nans = min((a + b) + c, a + bc, b + ac, c + ab, abc, ab - bc, ab + ac, ac + bc)\nif ans < 10 ** 6:\n    print(ans)\nelse:\n    print(-1)", "score": 0.0, "codebleu": 0.9877568500407993, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.9937777519226074, "surfaceSim": 0.9805345117845117, "abs_surfaceSim_minus_score": 0.9805345117845117, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 70}
{"id": "LOCAL_APPS_955_11_MUT_9", "golden_code": "n = int(input())\nd = {}\nfor _ in range(n):\n    s = input().split()\n    p = int(s[0])\n    s[1] = list(s[1])\n    s[1].sort()\n    s[1] = ''.join(s[1])\n    if s[1] in d:\n        d[s[1]] = min(d[s[1]], p)\n    else:\n        d[s[1]] = p\ndef get(s):\n    if s in d:\n        return d[s]\n    return 10 ** 6\na = get('A')\nb = get('B')\nc = get('C')\nab = get('AB')\nbc = get('BC')\nac = get('AC')\nabc = get('ABC')\nans = min((a + b) + c, a + bc, b + ac, c + ab, abc, ab + bc, ab + ac, ac + bc)\nif ans < 10 ** 6:\n    print(ans)\nelse:\n    print(-1)", "generated_code": "n = int(input())\nd = {}\nfor _ in range(n):\n    s = input().split()\n    p = int(s[0])\n    s[1] = list(s[1])\n    s[1].sort()\n    s[1] = ''.join(s[1])\n    if s[1] in d:\n        d[s[1]] = min(d[s[1]], p)\n    else:\n        d[s[1]] = p\ndef get(s):\n    if s in d:\n        return d[s]\n    return 10 ** 6\na = get('A')\nb = get('B')\nc = get('C')\nab = get('AB')\nbc = get('BC')\nac = get('AC')\nabc = get('ABC')\nans = min((a + b) + c, a + bc, b + ac, c + ab, abc, ab + bc, ab - ac, ac + bc)\nif ans < 10 ** 6:\n    print(ans)\nelse:\n    print(-1)", "score": 0.0, "codebleu": 0.9877568500407993, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.9937815070152283, "surfaceSim": 0.9805345117845117, "abs_surfaceSim_minus_score": 0.9805345117845117, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 71}
{"id": "LOCAL_APPS_955_11_MUT_10", "golden_code": "n = int(input())\nd = {}\nfor _ in range(n):\n    s = input().split()\n    p = int(s[0])\n    s[1] = list(s[1])\n    s[1].sort()\n    s[1] = ''.join(s[1])\n    if s[1] in d:\n        d[s[1]] = min(d[s[1]], p)\n    else:\n        d[s[1]] = p\ndef get(s):\n    if s in d:\n        return d[s]\n    return 10 ** 6\na = get('A')\nb = get('B')\nc = get('C')\nab = get('AB')\nbc = get('BC')\nac = get('AC')\nabc = get('ABC')\nans = min((a + b) + c, a + bc, b + ac, c + ab, abc, ab + bc, ab + ac, ac + bc)\nif ans < 10 ** 6:\n    print(ans)\nelse:\n    print(-1)", "generated_code": "n = int(input())\nd = {}\nfor _ in range(n):\n    s = input().split()\n    p = int(s[0])\n    s[1] = list(s[1])\n    s[1].sort()\n    s[1] = ''.join(s[1])\n    if s[1] in d:\n        d[s[1]] = min(d[s[1]], p)\n    else:\n        d[s[1]] = p\ndef get(s):\n    if s in d:\n        return d[s]\n    return 10 ** 6\na = get('A')\nb = get('B')\nc = get('C')\nab = get('AB')\nbc = get('BC')\nac = get('AC')\nabc = get('ABC')\nans = min((a + b) + c, a + bc, b + ac, c + ab, abc, ab + bc, ab + ac, ac - bc)\nif ans < 10 ** 6:\n    print(ans)\nelse:\n    print(-1)", "score": 0.0, "codebleu": 0.9877568500407993, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.9937751293182373, "surfaceSim": 0.9805345117845117, "abs_surfaceSim_minus_score": 0.9805345117845117, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 72}
{"id": "LOCAL_APPS_955_11_MUT_12", "golden_code": "n = int(input())\nd = {}\nfor _ in range(n):\n    s = input().split()\n    p = int(s[0])\n    s[1] = list(s[1])\n    s[1].sort()\n    s[1] = ''.join(s[1])\n    if s[1] in d:\n        d[s[1]] = min(d[s[1]], p)\n    else:\n        d[s[1]] = p\ndef get(s):\n    if s in d:\n        return d[s]\n    return 10 ** 6\na = get('A')\nb = get('B')\nc = get('C')\nab = get('AB')\nbc = get('BC')\nac = get('AC')\nabc = get('ABC')\nans = min((a + b) + c, a + bc, b + ac, c + ab, abc, ab + bc, ab + ac, ac + bc)\nif ans < 10 ** 6:\n    print(ans)\nelse:\n    print(-1)", "generated_code": "n = int(input())\nd = {}\nfor _ in range(n):\n    s = input().split()\n    p = int(s[0])\n    s[1] = list(s[1])\n    s[1].sort()\n    s[1] = ''.join(s[1])\n    if s[1] in d:\n        d[s[1]] = min(d[s[1]], p)\n    else:\n        d[s[1]] = p\ndef get(s):\n    if s in d:\n        return d[s]\n    return 10 ** 6\na = get('A')\nb = get('B')\nc = get('C')\nab = get('AB')\nbc = get('BC')\nac = get('AC')\nabc = get('ABC')\nans = min((a + b) + c, a + bc, b + ac, c + ab, abc, ab + bc, ab + ac, ac + bc)\nif ans < 10 ** 6:\n    print(ans)\nelse:\n    print(+1)", "score": 0.0, "codebleu": 0.9952428249684852, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9937618374824524, "surfaceSim": 0.9620159932659933, "abs_surfaceSim_minus_score": 0.9620159932659933, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 73}
{"id": "LOCAL_APPS_955_11_MUT_14", "golden_code": "n = int(input())\nd = {}\nfor _ in range(n):\n    s = input().split()\n    p = int(s[0])\n    s[1] = list(s[1])\n    s[1].sort()\n    s[1] = ''.join(s[1])\n    if s[1] in d:\n        d[s[1]] = min(d[s[1]], p)\n    else:\n        d[s[1]] = p\ndef get(s):\n    if s in d:\n        return d[s]\n    return 10 ** 6\na = get('A')\nb = get('B')\nc = get('C')\nab = get('AB')\nbc = get('BC')\nac = get('AC')\nabc = get('ABC')\nans = min((a + b) + c, a + bc, b + ac, c + ab, abc, ab + bc, ab + ac, ac + bc)\nif ans < 10 ** 6:\n    print(ans)\nelse:\n    print(-1)", "generated_code": "n = int(input())\nd = {}\nfor _ in range(n):\n    s = input().split()\n    p = int(s[0])\n    s[1] = list(s[1])\n    s[1].sort()\n    s[1] = ''.join(s[1])\n    if s[1] not in d:\n        d[s[1]] = min(d[s[1]], p)\n    else:\n        d[s[1]] = p\ndef get(s):\n    if s in d:\n        return d[s]\n    return 10 ** 6\na = get('A')\nb = get('B')\nc = get('C')\nab = get('AB')\nbc = get('BC')\nac = get('AC')\nabc = get('ABC')\nans = min((a + b) + c, a + bc, b + ac, c + ab, abc, ab + bc, ab + ac, ac + bc)\nif ans < 10 ** 6:\n    print(ans)\nelse:\n    print(-1)", "score": 0.0, "codebleu": 0.9901147190737728, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.9937734007835388, "surfaceSim": 0.978661932609301, "abs_surfaceSim_minus_score": 0.978661932609301, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 74}
{"id": "LOCAL_APPS_955_11_MUT_15", "golden_code": "n = int(input())\nd = {}\nfor _ in range(n):\n    s = input().split()\n    p = int(s[0])\n    s[1] = list(s[1])\n    s[1].sort()\n    s[1] = ''.join(s[1])\n    if s[1] in d:\n        d[s[1]] = min(d[s[1]], p)\n    else:\n        d[s[1]] = p\ndef get(s):\n    if s in d:\n        return d[s]\n    return 10 ** 6\na = get('A')\nb = get('B')\nc = get('C')\nab = get('AB')\nbc = get('BC')\nac = get('AC')\nabc = get('ABC')\nans = min((a + b) + c, a + bc, b + ac, c + ab, abc, ab + bc, ab + ac, ac + bc)\nif ans < 10 ** 6:\n    print(ans)\nelse:\n    print(-1)", "generated_code": "n = int(input())\nd = {}\nfor _ in range(n):\n    s = input().split()\n    p = int(s[0])\n    s[1] = list(s[1])\n    s[1].sort()\n    s[1] = ''.join(s[1])\n    if s[1] in d:\n        d[s[1]] = min(d[s[1]], p)\n    else:\n        d[s[1]] = p\ndef get(s):\n    if not (s in d):\n        return d[s]\n    return 10 ** 6\na = get('A')\nb = get('B')\nc = get('C')\nab = get('AB')\nbc = get('BC')\nac = get('AC')\nabc = get('ABC')\nans = min((a + b) + c, a + bc, b + ac, c + ab, abc, ab + bc, ab + ac, ac + bc)\nif ans < 10 ** 6:\n    print(ans)\nelse:\n    print(-1)", "score": 0.0, "codebleu": 0.9694561073317525, "crystalbleu": 0.97, "codebertscore": 1.0, "codescore": 0.9937655925750732, "surfaceSim": 0.9767998335414065, "abs_surfaceSim_minus_score": 0.9767998335414065, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 75}
{"id": "LOCAL_APPS_955_11_MUT_16", "golden_code": "n = int(input())\nd = {}\nfor _ in range(n):\n    s = input().split()\n    p = int(s[0])\n    s[1] = list(s[1])\n    s[1].sort()\n    s[1] = ''.join(s[1])\n    if s[1] in d:\n        d[s[1]] = min(d[s[1]], p)\n    else:\n        d[s[1]] = p\ndef get(s):\n    if s in d:\n        return d[s]\n    return 10 ** 6\na = get('A')\nb = get('B')\nc = get('C')\nab = get('AB')\nbc = get('BC')\nac = get('AC')\nabc = get('ABC')\nans = min((a + b) + c, a + bc, b + ac, c + ab, abc, ab + bc, ab + ac, ac + bc)\nif ans < 10 ** 6:\n    print(ans)\nelse:\n    print(-1)", "generated_code": "n = int(input())\nd = {}\nfor _ in range(n):\n    s = input().split()\n    p = int(s[0])\n    s[1] = list(s[1])\n    s[1].sort()\n    s[1] = ''.join(s[1])\n    if s[1] in d:\n        d[s[1]] = min(d[s[1]], p)\n    else:\n        d[s[1]] = p\ndef get(s):\n    if s not in d:\n        return d[s]\n    return 10 ** 6\na = get('A')\nb = get('B')\nc = get('C')\nab = get('AB')\nbc = get('BC')\nac = get('AC')\nabc = get('ABC')\nans = min((a + b) + c, a + bc, b + ac, c + ab, abc, ab + bc, ab + ac, ac + bc)\nif ans < 10 ** 6:\n    print(ans)\nelse:\n    print(-1)", "score": 0.0, "codebleu": 0.9901147190737728, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.9937720894813538, "surfaceSim": 0.978661932609301, "abs_surfaceSim_minus_score": 0.978661932609301, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 76}
{"id": "LOCAL_APPS_955_11_MUT_17", "golden_code": "n = int(input())\nd = {}\nfor _ in range(n):\n    s = input().split()\n    p = int(s[0])\n    s[1] = list(s[1])\n    s[1].sort()\n    s[1] = ''.join(s[1])\n    if s[1] in d:\n        d[s[1]] = min(d[s[1]], p)\n    else:\n        d[s[1]] = p\ndef get(s):\n    if s in d:\n        return d[s]\n    return 10 ** 6\na = get('A')\nb = get('B')\nc = get('C')\nab = get('AB')\nbc = get('BC')\nac = get('AC')\nabc = get('ABC')\nans = min((a + b) + c, a + bc, b + ac, c + ab, abc, ab + bc, ab + ac, ac + bc)\nif ans < 10 ** 6:\n    print(ans)\nelse:\n    print(-1)", "generated_code": "n = int(input())\nd = {}\nfor _ in range(n):\n    s = input().split()\n    p = int(s[0])\n    s[1] = list(s[1])\n    s[1].sort()\n    s[1] = ''.join(s[1])\n    if s[1] in d:\n        d[s[1]] = min(d[s[1]], p)\n    else:\n        d[s[1]] = p\ndef get(s):\n    if s in d:\n        return d[s]\n    return 10 ** 6\na = get('A')\nb = get('B')\nc = get('C')\nab = get('AB')\nbc = get('BC')\nac = get('AC')\nabc = get('ABC')\nans = min((a + b) + c, a + bc, b + ac, c + ab, abc, ab + bc, ab + ac, ac + bc)\nif not (ans < 10 ** 6):\n    print(ans)\nelse:\n    print(-1)", "score": 0.0, "codebleu": 0.9693899817478726, "crystalbleu": 0.97, "codebertscore": 1.0, "codescore": 0.9938170313835144, "surfaceSim": 0.9767998335414065, "abs_surfaceSim_minus_score": 0.9767998335414065, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 77}
{"id": "LOCAL_APPS_955_11_MUT_20", "golden_code": "n = int(input())\nd = {}\nfor _ in range(n):\n    s = input().split()\n    p = int(s[0])\n    s[1] = list(s[1])\n    s[1].sort()\n    s[1] = ''.join(s[1])\n    if s[1] in d:\n        d[s[1]] = min(d[s[1]], p)\n    else:\n        d[s[1]] = p\ndef get(s):\n    if s in d:\n        return d[s]\n    return 10 ** 6\na = get('A')\nb = get('B')\nc = get('C')\nab = get('AB')\nbc = get('BC')\nac = get('AC')\nabc = get('ABC')\nans = min((a + b) + c, a + bc, b + ac, c + ab, abc, ab + bc, ab + ac, ac + bc)\nif ans < 10 ** 6:\n    print(ans)\nelse:\n    print(-1)", "generated_code": "n = int(input())\nd = {}\nfor _ in range(n):\n    s = input().split()\n    p = int(s[0])\n    s[1] = list(s[1])\n    s[1].sort()\n    s[1] = ''.join(s[1])\n    if s[1] in d:\n        d[s[1]] = min(d[s[1]], p)\n    else:\n        d[s[1]] = pbreak\ndef get(s):\n    if s in d:\n        return d[s]\n    return 10 ** 6\na = get('A')\nb = get('B')\nc = get('C')\nab = get('AB')\nbc = get('BC')\nac = get('AC')\nabc = get('ABC')\nans = min((a + b) + c, a + bc, b + ac, c + ab, abc, ab + bc, ab + ac, ac + bc)\nif ans < 10 ** 6:\n    print(ans)\nelse:\n    print(-1)", "score": 0.0, "codebleu": 0.8723722346561839, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.9938240051269531, "surfaceSim": 0.9953095684803002, "abs_surfaceSim_minus_score": 0.9953095684803002, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 78}
{"id": "LOCAL_APPS_955_11_MUT_23", "golden_code": "n = int(input())\nd = {}\nfor _ in range(n):\n    s = input().split()\n    p = int(s[0])\n    s[1] = list(s[1])\n    s[1].sort()\n    s[1] = ''.join(s[1])\n    if s[1] in d:\n        d[s[1]] = min(d[s[1]], p)\n    else:\n        d[s[1]] = p\ndef get(s):\n    if s in d:\n        return d[s]\n    return 10 ** 6\na = get('A')\nb = get('B')\nc = get('C')\nab = get('AB')\nbc = get('BC')\nac = get('AC')\nabc = get('ABC')\nans = min((a + b) + c, a + bc, b + ac, c + ab, abc, ab + bc, ab + ac, ac + bc)\nif ans < 10 ** 6:\n    print(ans)\nelse:\n    print(-1)", "generated_code": "n = int(input())\nd = {}\nfor _ in range(n):\n    s = input().split()\n    p = int(s[0])\n    s[1] = list(s[1])\n    s[1].sort()\n    s[1] = ''.join(s[1])\n    if s[1] in d:\n        d[s[1]] = min(d[s[1]], p)\n    else:\n        d[s[1]] = p\ndef get(s):\n    if s in d:\n        return d[s]\n    return 10 ** 6\na = get('A')\nb = get('B')\nc = get('C')\nab = get('AB')\nbc = get('BC')\nac = get('AC')\nabc = get('ABC')\nans = min((a + b) + c, a + bc, b + ac, c + ab, abc, ab + bc, ab + ac, ac + bc)\nif ans <= 10 ** 6:\n    print(ans)\nelse:\n    print(-1)", "score": 0.0, "codebleu": 0.9877568500407993, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9937582015991211, "surfaceSim": 0.9620177833788419, "abs_surfaceSim_minus_score": 0.9620177833788419, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 79}
{"id": "LOCAL_APPS_994_7_MUT_33", "golden_code": "import sys\n\n\n(n, m) = list(map(int, str.split(sys.stdin.readline())))\npd = ph = None\ntop = None\nfor _ in range(m):\n    \n    (d, h) = list(map(int, str.split(sys.stdin.readline())))\n    if pd is None:\n        \n        top = (d - 1) + h\n    else:\n        \n        \n        if (pd and d - pd < abs(h - ph)):\n            \n            print('IMPOSSIBLE')\n            return\n        \n        delta = ((d - pd) - 1) - abs(h - ph)\n        top = max(top, (max(ph, h) + (delta // 2)) + (delta % 2))\n    \n    (pd, ph) = (d, h)\n\ntop = max(top, (h + n) - d)\nprint(top)", "generated_code": "import sys\n\n\n(n, m) = list(map(int, str.split(sys.stdin.readline())))\npd = ph = None\ntop = None\nfor _ in range(m):\n    \n    (d, h) = list(map(int, str.split(sys.stdin.readline())))\n    if pd is None:\n        \n        top = (d - 1) + h\n    else:\n        \n        \n        if (pd and d - pd < abs(h - ph)):\n            \n            print('IMPOSSIBLE')\n            pass\n        \n        delta = ((d - pd) - 1) - abs(h - ph)\n        top = max(top, (max(ph, h) + (delta // 2)) + (delta % 2))\n    \n    (pd, ph) = (d, h)\n\ntop = max(top, (h + n) - d)\nprint(top)", "score": 0.0, "codebleu": 0.9610521627713202, "crystalbleu": 0.97, "codebertscore": 1.0, "codescore": 0.9938062429428101, "surfaceSim": 0.9561330561330561, "abs_surfaceSim_minus_score": 0.9561330561330561, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 80}
{"id": "LOCAL_APPS_1039_1_MUT_1", "golden_code": "import sys\ndef input():\n    return sys.stdin.readline().strip()\nfrom collections import deque\ndef main():\n    N = int(input())\n    info = [tuple(map(int, input().split())) for _ in range(N - 1)]\n    (Q, K) = map(int, input().split())\n    queries = [tuple(map(int, input().split())) for _ in range(Q)]\n    \n    to = [[] for _ in range(N)]\n    for (a, b, c) in info:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        to[b].append((a, c))\n    \n    INF = 10 ** 18\n    dist = [INF] * N\n    def dfs(s):\n        stack = deque()\n        push = stack.append\n        pop = stack.pop\n        \n        dist[s] = 0\n        push(s)\n        \n        while stack:\n            now = pop()\n            now_cost = dist[now]\n            \n            for (nv, c) in to[now]:\n                if dist[nv] != INF:\n                    continue\n                dist[nv] = now_cost + c\n                push(nv)\n    \n    \n    K -= 1\n    dfs(K)\n    ans = []\n    for (x, y) in queries:\n        x -= 1\n        y -= 1\n        xy = dist[x] + dist[y]\n        ans.append(xy)\n    \n    print(sep='\\n', *ans)\ndef __starting_point():\n    main()\n__starting_point()", "generated_code": "import sys\ndef input():\n    return sys.stdin.readline().strip()\nfrom collections import deque\ndef main():\n    N = int(input())\n    info = [tuple(map(int, input().split())) for _ in range(N + 1)]\n    (Q, K) = map(int, input().split())\n    queries = [tuple(map(int, input().split())) for _ in range(Q)]\n    \n    to = [[] for _ in range(N)]\n    for (a, b, c) in info:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        to[b].append((a, c))\n    \n    INF = 10 ** 18\n    dist = [INF] * N\n    def dfs(s):\n        stack = deque()\n        push = stack.append\n        pop = stack.pop\n        \n        dist[s] = 0\n        push(s)\n        \n        while stack:\n            now = pop()\n            now_cost = dist[now]\n            \n            for (nv, c) in to[now]:\n                if dist[nv] != INF:\n                    continue\n                dist[nv] = now_cost + c\n                push(nv)\n    \n    \n    K -= 1\n    dfs(K)\n    ans = []\n    for (x, y) in queries:\n        x -= 1\n        y -= 1\n        xy = dist[x] + dist[y]\n        ans.append(xy)\n    \n    print(sep='\\n', *ans)\ndef __starting_point():\n    main()\n__starting_point()", "score": 0.0, "codebleu": 0.9910992348898965, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.993873119354248, "surfaceSim": 0.9995617879053462, "abs_surfaceSim_minus_score": 0.9995617879053462, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 81}
{"id": "LOCAL_APPS_1039_1_MUT_3", "golden_code": "import sys\ndef input():\n    return sys.stdin.readline().strip()\nfrom collections import deque\ndef main():\n    N = int(input())\n    info = [tuple(map(int, input().split())) for _ in range(N - 1)]\n    (Q, K) = map(int, input().split())\n    queries = [tuple(map(int, input().split())) for _ in range(Q)]\n    \n    to = [[] for _ in range(N)]\n    for (a, b, c) in info:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        to[b].append((a, c))\n    \n    INF = 10 ** 18\n    dist = [INF] * N\n    def dfs(s):\n        stack = deque()\n        push = stack.append\n        pop = stack.pop\n        \n        dist[s] = 0\n        push(s)\n        \n        while stack:\n            now = pop()\n            now_cost = dist[now]\n            \n            for (nv, c) in to[now]:\n                if dist[nv] != INF:\n                    continue\n                dist[nv] = now_cost + c\n                push(nv)\n    \n    \n    K -= 1\n    dfs(K)\n    ans = []\n    for (x, y) in queries:\n        x -= 1\n        y -= 1\n        xy = dist[x] + dist[y]\n        ans.append(xy)\n    \n    print(sep='\\n', *ans)\ndef __starting_point():\n    main()\n__starting_point()", "generated_code": "import sys\ndef input():\n    return sys.stdin.readline().strip()\nfrom collections import deque\ndef main():\n    N = int(input())\n    info = [tuple(map(int, input().split())) for _ in range(N - 1)]\n    (Q, K) = map(int, input().split())\n    queries = [tuple(map(int, input().split())) for _ in range(Q)]\n    \n    to = [[] for _ in range(N)]\n    for (a, b, c) in info:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        to[b].append((a, c))\n    \n    INF = 10 ** 18\n    dist = [INF] / N\n    def dfs(s):\n        stack = deque()\n        push = stack.append\n        pop = stack.pop\n        \n        dist[s] = 0\n        push(s)\n        \n        while stack:\n            now = pop()\n            now_cost = dist[now]\n            \n            for (nv, c) in to[now]:\n                if dist[nv] != INF:\n                    continue\n                dist[nv] = now_cost + c\n                push(nv)\n    \n    \n    K -= 1\n    dfs(K)\n    ans = []\n    for (x, y) in queries:\n        x -= 1\n        y -= 1\n        xy = dist[x] + dist[y]\n        ans.append(xy)\n    \n    print(sep='\\n', *ans)\ndef __starting_point():\n    main()\n__starting_point()", "score": 0.0, "codebleu": 0.9910992348898965, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9938030242919922, "surfaceSim": 0.9725347608783191, "abs_surfaceSim_minus_score": 0.9725347608783191, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 82}
{"id": "LOCAL_APPS_1039_1_MUT_4", "golden_code": "import sys\ndef input():\n    return sys.stdin.readline().strip()\nfrom collections import deque\ndef main():\n    N = int(input())\n    info = [tuple(map(int, input().split())) for _ in range(N - 1)]\n    (Q, K) = map(int, input().split())\n    queries = [tuple(map(int, input().split())) for _ in range(Q)]\n    \n    to = [[] for _ in range(N)]\n    for (a, b, c) in info:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        to[b].append((a, c))\n    \n    INF = 10 ** 18\n    dist = [INF] * N\n    def dfs(s):\n        stack = deque()\n        push = stack.append\n        pop = stack.pop\n        \n        dist[s] = 0\n        push(s)\n        \n        while stack:\n            now = pop()\n            now_cost = dist[now]\n            \n            for (nv, c) in to[now]:\n                if dist[nv] != INF:\n                    continue\n                dist[nv] = now_cost + c\n                push(nv)\n    \n    \n    K -= 1\n    dfs(K)\n    ans = []\n    for (x, y) in queries:\n        x -= 1\n        y -= 1\n        xy = dist[x] + dist[y]\n        ans.append(xy)\n    \n    print(sep='\\n', *ans)\ndef __starting_point():\n    main()\n__starting_point()", "generated_code": "import sys\ndef input():\n    return sys.stdin.readline().strip()\nfrom collections import deque\ndef main():\n    N = int(input())\n    info = [tuple(map(int, input().split())) for _ in range(N - 1)]\n    (Q, K) = map(int, input().split())\n    queries = [tuple(map(int, input().split())) for _ in range(Q)]\n    \n    to = [[] for _ in range(N)]\n    for (a, b, c) in info:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        to[b].append((a, c))\n    \n    INF = 10 ** 18\n    dist = [INF] // N\n    def dfs(s):\n        stack = deque()\n        push = stack.append\n        pop = stack.pop\n        \n        dist[s] = 0\n        push(s)\n        \n        while stack:\n            now = pop()\n            now_cost = dist[now]\n            \n            for (nv, c) in to[now]:\n                if dist[nv] != INF:\n                    continue\n                dist[nv] = now_cost + c\n                push(nv)\n    \n    \n    K -= 1\n    dfs(K)\n    ans = []\n    for (x, y) in queries:\n        x -= 1\n        y -= 1\n        xy = dist[x] + dist[y]\n        ans.append(xy)\n    \n    print(sep='\\n', *ans)\ndef __starting_point():\n    main()\n__starting_point()", "score": 0.0, "codebleu": 0.9910992348898965, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.9938023090362549, "surfaceSim": 0.9720973162304161, "abs_surfaceSim_minus_score": 0.9720973162304161, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 83}
{"id": "LOCAL_APPS_1039_1_MUT_5", "golden_code": "import sys\ndef input():\n    return sys.stdin.readline().strip()\nfrom collections import deque\ndef main():\n    N = int(input())\n    info = [tuple(map(int, input().split())) for _ in range(N - 1)]\n    (Q, K) = map(int, input().split())\n    queries = [tuple(map(int, input().split())) for _ in range(Q)]\n    \n    to = [[] for _ in range(N)]\n    for (a, b, c) in info:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        to[b].append((a, c))\n    \n    INF = 10 ** 18\n    dist = [INF] * N\n    def dfs(s):\n        stack = deque()\n        push = stack.append\n        pop = stack.pop\n        \n        dist[s] = 0\n        push(s)\n        \n        while stack:\n            now = pop()\n            now_cost = dist[now]\n            \n            for (nv, c) in to[now]:\n                if dist[nv] != INF:\n                    continue\n                dist[nv] = now_cost + c\n                push(nv)\n    \n    \n    K -= 1\n    dfs(K)\n    ans = []\n    for (x, y) in queries:\n        x -= 1\n        y -= 1\n        xy = dist[x] + dist[y]\n        ans.append(xy)\n    \n    print(sep='\\n', *ans)\ndef __starting_point():\n    main()\n__starting_point()", "generated_code": "import sys\ndef input():\n    return sys.stdin.readline().strip()\nfrom collections import deque\ndef main():\n    N = int(input())\n    info = [tuple(map(int, input().split())) for _ in range(N - 1)]\n    (Q, K) = map(int, input().split())\n    queries = [tuple(map(int, input().split())) for _ in range(Q)]\n    \n    to = [[] for _ in range(N)]\n    for (a, b, c) in info:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        to[b].append((a, c))\n    \n    INF = 10 ** 18\n    dist = [INF] ** N\n    def dfs(s):\n        stack = deque()\n        push = stack.append\n        pop = stack.pop\n        \n        dist[s] = 0\n        push(s)\n        \n        while stack:\n            now = pop()\n            now_cost = dist[now]\n            \n            for (nv, c) in to[now]:\n                if dist[nv] != INF:\n                    continue\n                dist[nv] = now_cost + c\n                push(nv)\n    \n    \n    K -= 1\n    dfs(K)\n    ans = []\n    for (x, y) in queries:\n        x -= 1\n        y -= 1\n        xy = dist[x] + dist[y]\n        ans.append(xy)\n    \n    print(sep='\\n', *ans)\ndef __starting_point():\n    main()\n__starting_point()", "score": 0.0, "codebleu": 0.9910992348898965, "crystalbleu": 1.0, "codebertscore": 1.0, "codescore": 0.9938001036643982, "surfaceSim": 0.9856732827398327, "abs_surfaceSim_minus_score": 0.9856732827398327, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 84}
{"id": "LOCAL_APPS_1039_1_MUT_7", "golden_code": "import sys\ndef input():\n    return sys.stdin.readline().strip()\nfrom collections import deque\ndef main():\n    N = int(input())\n    info = [tuple(map(int, input().split())) for _ in range(N - 1)]\n    (Q, K) = map(int, input().split())\n    queries = [tuple(map(int, input().split())) for _ in range(Q)]\n    \n    to = [[] for _ in range(N)]\n    for (a, b, c) in info:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        to[b].append((a, c))\n    \n    INF = 10 ** 18\n    dist = [INF] * N\n    def dfs(s):\n        stack = deque()\n        push = stack.append\n        pop = stack.pop\n        \n        dist[s] = 0\n        push(s)\n        \n        while stack:\n            now = pop()\n            now_cost = dist[now]\n            \n            for (nv, c) in to[now]:\n                if dist[nv] != INF:\n                    continue\n                dist[nv] = now_cost + c\n                push(nv)\n    \n    \n    K -= 1\n    dfs(K)\n    ans = []\n    for (x, y) in queries:\n        x -= 1\n        y -= 1\n        xy = dist[x] + dist[y]\n        ans.append(xy)\n    \n    print(sep='\\n', *ans)\ndef __starting_point():\n    main()\n__starting_point()", "generated_code": "import sys\ndef input():\n    return sys.stdin.readline().strip()\nfrom collections import deque\ndef main():\n    N = int(input())\n    info = [tuple(map(int, input().split())) for _ in range(N - 1)]\n    (Q, K) = map(int, input().split())\n    queries = [tuple(map(int, input().split())) for _ in range(Q)]\n    \n    to = [[] for _ in range(N)]\n    for (a, b, c) in info:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        to[b].append((a, c))\n    \n    INF = 10 ** 18\n    dist = [INF] * N\n    def dfs(s):\n        stack = deque()\n        push = stack.append\n        pop = stack.pop\n        \n        dist[s] = 0\n        push(s)\n        \n        while stack:\n            now = pop()\n            now_cost = dist[now]\n            \n            for (nv, c) in to[now]:\n                if dist[nv] != INF:\n                    continue\n                dist[nv] = now_cost + c\n                push(nv)\n    \n    \n    K -= 1\n    dfs(K)\n    ans = []\n    for (x, y) in queries:\n        x -= 1\n        y -= 1\n        xy = dist[x] - dist[y]\n        ans.append(xy)\n    \n    print(sep='\\n', *ans)\ndef __starting_point():\n    main()\n__starting_point()", "score": 0.0, "codebleu": 0.9910992348898965, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9938285946846008, "surfaceSim": 0.9995617879053462, "abs_surfaceSim_minus_score": 0.9995617879053462, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 85}
{"id": "LOCAL_APPS_1039_1_MUT_8", "golden_code": "import sys\ndef input():\n    return sys.stdin.readline().strip()\nfrom collections import deque\ndef main():\n    N = int(input())\n    info = [tuple(map(int, input().split())) for _ in range(N - 1)]\n    (Q, K) = map(int, input().split())\n    queries = [tuple(map(int, input().split())) for _ in range(Q)]\n    \n    to = [[] for _ in range(N)]\n    for (a, b, c) in info:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        to[b].append((a, c))\n    \n    INF = 10 ** 18\n    dist = [INF] * N\n    def dfs(s):\n        stack = deque()\n        push = stack.append\n        pop = stack.pop\n        \n        dist[s] = 0\n        push(s)\n        \n        while stack:\n            now = pop()\n            now_cost = dist[now]\n            \n            for (nv, c) in to[now]:\n                if dist[nv] != INF:\n                    continue\n                dist[nv] = now_cost + c\n                push(nv)\n    \n    \n    K -= 1\n    dfs(K)\n    ans = []\n    for (x, y) in queries:\n        x -= 1\n        y -= 1\n        xy = dist[x] + dist[y]\n        ans.append(xy)\n    \n    print(sep='\\n', *ans)\ndef __starting_point():\n    main()\n__starting_point()", "generated_code": "import sys\ndef input():\n    return sys.stdin.readline().strip()\nfrom collections import deque\ndef main():\n    N = int(input())\n    info = [tuple(map(int, input().split())) for _ in range(N - 1)]\n    (Q, K) = map(int, input().split())\n    queries = [tuple(map(int, input().split())) for _ in range(Q)]\n    \n    to = [[] for _ in range(N)]\n    for (a, b, c) in info:\n        a += 1\n        b -= 1\n        to[a].append((b, c))\n        to[b].append((a, c))\n    \n    INF = 10 ** 18\n    dist = [INF] * N\n    def dfs(s):\n        stack = deque()\n        push = stack.append\n        pop = stack.pop\n        \n        dist[s] = 0\n        push(s)\n        \n        while stack:\n            now = pop()\n            now_cost = dist[now]\n            \n            for (nv, c) in to[now]:\n                if dist[nv] != INF:\n                    continue\n                dist[nv] = now_cost + c\n                push(nv)\n    \n    \n    K -= 1\n    dfs(K)\n    ans = []\n    for (x, y) in queries:\n        x -= 1\n        y -= 1\n        xy = dist[x] + dist[y]\n        ans.append(xy)\n    \n    print(sep='\\n', *ans)\ndef __starting_point():\n    main()\n__starting_point()", "score": 0.0, "codebleu": 0.9910992348898965, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.993800938129425, "surfaceSim": 0.9995617879053462, "abs_surfaceSim_minus_score": 0.9995617879053462, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 86}
{"id": "LOCAL_APPS_1039_1_MUT_9", "golden_code": "import sys\ndef input():\n    return sys.stdin.readline().strip()\nfrom collections import deque\ndef main():\n    N = int(input())\n    info = [tuple(map(int, input().split())) for _ in range(N - 1)]\n    (Q, K) = map(int, input().split())\n    queries = [tuple(map(int, input().split())) for _ in range(Q)]\n    \n    to = [[] for _ in range(N)]\n    for (a, b, c) in info:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        to[b].append((a, c))\n    \n    INF = 10 ** 18\n    dist = [INF] * N\n    def dfs(s):\n        stack = deque()\n        push = stack.append\n        pop = stack.pop\n        \n        dist[s] = 0\n        push(s)\n        \n        while stack:\n            now = pop()\n            now_cost = dist[now]\n            \n            for (nv, c) in to[now]:\n                if dist[nv] != INF:\n                    continue\n                dist[nv] = now_cost + c\n                push(nv)\n    \n    \n    K -= 1\n    dfs(K)\n    ans = []\n    for (x, y) in queries:\n        x -= 1\n        y -= 1\n        xy = dist[x] + dist[y]\n        ans.append(xy)\n    \n    print(sep='\\n', *ans)\ndef __starting_point():\n    main()\n__starting_point()", "generated_code": "import sys\ndef input():\n    return sys.stdin.readline().strip()\nfrom collections import deque\ndef main():\n    N = int(input())\n    info = [tuple(map(int, input().split())) for _ in range(N - 1)]\n    (Q, K) = map(int, input().split())\n    queries = [tuple(map(int, input().split())) for _ in range(Q)]\n    \n    to = [[] for _ in range(N)]\n    for (a, b, c) in info:\n        a -= 1\n        b += 1\n        to[a].append((b, c))\n        to[b].append((a, c))\n    \n    INF = 10 ** 18\n    dist = [INF] * N\n    def dfs(s):\n        stack = deque()\n        push = stack.append\n        pop = stack.pop\n        \n        dist[s] = 0\n        push(s)\n        \n        while stack:\n            now = pop()\n            now_cost = dist[now]\n            \n            for (nv, c) in to[now]:\n                if dist[nv] != INF:\n                    continue\n                dist[nv] = now_cost + c\n                push(nv)\n    \n    \n    K -= 1\n    dfs(K)\n    ans = []\n    for (x, y) in queries:\n        x -= 1\n        y -= 1\n        xy = dist[x] + dist[y]\n        ans.append(xy)\n    \n    print(sep='\\n', *ans)\ndef __starting_point():\n    main()\n__starting_point()", "score": 0.0, "codebleu": 0.9910992348898965, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9938005805015564, "surfaceSim": 0.9995617879053462, "abs_surfaceSim_minus_score": 0.9995617879053462, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 87}
{"id": "LOCAL_APPS_1039_1_MUT_10", "golden_code": "import sys\ndef input():\n    return sys.stdin.readline().strip()\nfrom collections import deque\ndef main():\n    N = int(input())\n    info = [tuple(map(int, input().split())) for _ in range(N - 1)]\n    (Q, K) = map(int, input().split())\n    queries = [tuple(map(int, input().split())) for _ in range(Q)]\n    \n    to = [[] for _ in range(N)]\n    for (a, b, c) in info:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        to[b].append((a, c))\n    \n    INF = 10 ** 18\n    dist = [INF] * N\n    def dfs(s):\n        stack = deque()\n        push = stack.append\n        pop = stack.pop\n        \n        dist[s] = 0\n        push(s)\n        \n        while stack:\n            now = pop()\n            now_cost = dist[now]\n            \n            for (nv, c) in to[now]:\n                if dist[nv] != INF:\n                    continue\n                dist[nv] = now_cost + c\n                push(nv)\n    \n    \n    K -= 1\n    dfs(K)\n    ans = []\n    for (x, y) in queries:\n        x -= 1\n        y -= 1\n        xy = dist[x] + dist[y]\n        ans.append(xy)\n    \n    print(sep='\\n', *ans)\ndef __starting_point():\n    main()\n__starting_point()", "generated_code": "import sys\ndef input():\n    return sys.stdin.readline().strip()\nfrom collections import deque\ndef main():\n    N = int(input())\n    info = [tuple(map(int, input().split())) for _ in range(N - 1)]\n    (Q, K) = map(int, input().split())\n    queries = [tuple(map(int, input().split())) for _ in range(Q)]\n    \n    to = [[] for _ in range(N)]\n    for (a, b, c) in info:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        to[b].append((a, c))\n    \n    INF = 10 ** 18\n    dist = [INF] * N\n    def dfs(s):\n        stack = deque()\n        push = stack.append\n        pop = stack.pop\n        \n        dist[s] = 0\n        push(s)\n        \n        while stack:\n            now = pop()\n            now_cost = dist[now]\n            \n            for (nv, c) in to[now]:\n                if dist[nv] != INF:\n                    continue\n                dist[nv] = now_cost + c\n                push(nv)\n    \n    \n    K += 1\n    dfs(K)\n    ans = []\n    for (x, y) in queries:\n        x -= 1\n        y -= 1\n        xy = dist[x] + dist[y]\n        ans.append(xy)\n    \n    print(sep='\\n', *ans)\ndef __starting_point():\n    main()\n__starting_point()", "score": 0.0, "codebleu": 0.9910992348898965, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.993800699710846, "surfaceSim": 0.9995617879053462, "abs_surfaceSim_minus_score": 0.9995617879053462, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 88}
{"id": "LOCAL_APPS_1039_1_MUT_11", "golden_code": "import sys\ndef input():\n    return sys.stdin.readline().strip()\nfrom collections import deque\ndef main():\n    N = int(input())\n    info = [tuple(map(int, input().split())) for _ in range(N - 1)]\n    (Q, K) = map(int, input().split())\n    queries = [tuple(map(int, input().split())) for _ in range(Q)]\n    \n    to = [[] for _ in range(N)]\n    for (a, b, c) in info:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        to[b].append((a, c))\n    \n    INF = 10 ** 18\n    dist = [INF] * N\n    def dfs(s):\n        stack = deque()\n        push = stack.append\n        pop = stack.pop\n        \n        dist[s] = 0\n        push(s)\n        \n        while stack:\n            now = pop()\n            now_cost = dist[now]\n            \n            for (nv, c) in to[now]:\n                if dist[nv] != INF:\n                    continue\n                dist[nv] = now_cost + c\n                push(nv)\n    \n    \n    K -= 1\n    dfs(K)\n    ans = []\n    for (x, y) in queries:\n        x -= 1\n        y -= 1\n        xy = dist[x] + dist[y]\n        ans.append(xy)\n    \n    print(sep='\\n', *ans)\ndef __starting_point():\n    main()\n__starting_point()", "generated_code": "import sys\ndef input():\n    return sys.stdin.readline().strip()\nfrom collections import deque\ndef main():\n    N = int(input())\n    info = [tuple(map(int, input().split())) for _ in range(N - 1)]\n    (Q, K) = map(int, input().split())\n    queries = [tuple(map(int, input().split())) for _ in range(Q)]\n    \n    to = [[] for _ in range(N)]\n    for (a, b, c) in info:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        to[b].append((a, c))\n    \n    INF = 10 ** 18\n    dist = [INF] * N\n    def dfs(s):\n        stack = deque()\n        push = stack.append\n        pop = stack.pop\n        \n        dist[s] = 0\n        push(s)\n        \n        while stack:\n            now = pop()\n            now_cost = dist[now]\n            \n            for (nv, c) in to[now]:\n                if dist[nv] != INF:\n                    continue\n                dist[nv] = now_cost + c\n                push(nv)\n    \n    \n    K -= 1\n    dfs(K)\n    ans = []\n    for (x, y) in queries:\n        x += 1\n        y -= 1\n        xy = dist[x] + dist[y]\n        ans.append(xy)\n    \n    print(sep='\\n', *ans)\ndef __starting_point():\n    main()\n__starting_point()", "score": 0.0, "codebleu": 0.9910992348898965, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9938004612922668, "surfaceSim": 0.9995617879053462, "abs_surfaceSim_minus_score": 0.9995617879053462, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 89}
{"id": "LOCAL_APPS_1039_1_MUT_48", "golden_code": "import sys\ndef input():\n    return sys.stdin.readline().strip()\nfrom collections import deque\ndef main():\n    N = int(input())\n    info = [tuple(map(int, input().split())) for _ in range(N - 1)]\n    (Q, K) = map(int, input().split())\n    queries = [tuple(map(int, input().split())) for _ in range(Q)]\n    \n    to = [[] for _ in range(N)]\n    for (a, b, c) in info:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        to[b].append((a, c))\n    \n    INF = 10 ** 18\n    dist = [INF] * N\n    def dfs(s):\n        stack = deque()\n        push = stack.append\n        pop = stack.pop\n        \n        dist[s] = 0\n        push(s)\n        \n        while stack:\n            now = pop()\n            now_cost = dist[now]\n            \n            for (nv, c) in to[now]:\n                if dist[nv] != INF:\n                    continue\n                dist[nv] = now_cost + c\n                push(nv)\n    \n    \n    K -= 1\n    dfs(K)\n    ans = []\n    for (x, y) in queries:\n        x -= 1\n        y -= 1\n        xy = dist[x] + dist[y]\n        ans.append(xy)\n    \n    print(sep='\\n', *ans)\ndef __starting_point():\n    main()\n__starting_point()", "generated_code": "import sys\ndef input():\n    return sys.stdin.readline().strip()\nfrom collections import deque\ndef main():\n    N = int(input())\n    info = [tuple(map(int, input().split())) for _ in range(N - 1)]\n    (Q, K) = map(int, input().split())\n    queries = [tuple(map(int, input().split())) for _ in range(Q)]\n    \n    to = [[] for _ in range(N)]\n    for (a, b, c) in info:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        to[b].append((a, c))\n    \n    INF = 10 ** 18\n    dist = [INF] * N\n    def dfs(s):\n        stack = deque()\n        push = stack.append\n        pop = stack.pop\n        \n        dist[s] = 0\n        push(s)\n        \n        while stack:\n            now = pop()\n            now_cost = dist[now]\n            \n            for (nv, c) in to[now]:\n                if dist[nv] != INF:\n                    continue\n                dist[nv] = now_cost + c\n                push(nv)\n    \n    \n    K -= 1\n    dfs(K)\n    pass\n    for (x, y) in queries:\n        x -= 1\n        y -= 1\n        xy = dist[x] + dist[y]\n        ans.append(xy)\n    \n    print(sep='\\n', *ans)\ndef __starting_point():\n    main()\n__starting_point()", "score": 0.0, "codebleu": 0.966852587171584, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.9938042163848877, "surfaceSim": 0.9842954260132175, "abs_surfaceSim_minus_score": 0.9842954260132175, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 90}
{"id": "LOCAL_APPS_1039_1_MUT_52", "golden_code": "import sys\ndef input():\n    return sys.stdin.readline().strip()\nfrom collections import deque\ndef main():\n    N = int(input())\n    info = [tuple(map(int, input().split())) for _ in range(N - 1)]\n    (Q, K) = map(int, input().split())\n    queries = [tuple(map(int, input().split())) for _ in range(Q)]\n    \n    to = [[] for _ in range(N)]\n    for (a, b, c) in info:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        to[b].append((a, c))\n    \n    INF = 10 ** 18\n    dist = [INF] * N\n    def dfs(s):\n        stack = deque()\n        push = stack.append\n        pop = stack.pop\n        \n        dist[s] = 0\n        push(s)\n        \n        while stack:\n            now = pop()\n            now_cost = dist[now]\n            \n            for (nv, c) in to[now]:\n                if dist[nv] != INF:\n                    continue\n                dist[nv] = now_cost + c\n                push(nv)\n    \n    \n    K -= 1\n    dfs(K)\n    ans = []\n    for (x, y) in queries:\n        x -= 1\n        y -= 1\n        xy = dist[x] + dist[y]\n        ans.append(xy)\n    \n    print(sep='\\n', *ans)\ndef __starting_point():\n    main()\n__starting_point()", "generated_code": "import sys\ndef input():\n    return sys.stdin.readline().strip()\nfrom collections import deque\ndef main():\n    N = int(input())\n    info = [tuple(map(int, input().split())) for _ in range(N - 1)]\n    (Q, K) = map(int, input().split())\n    queries = [tuple(map(int, input().split())) for _ in range(Q)]\n    \n    to = [[] for _ in range(N)]\n    for (a, b, c) in info:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        to[b].append((a, c))\n    \n    INF = 10 ** 18\n    dist = [INF] * N\n    def dfs(s):\n        stack = deque()\n        push = stack.append\n        pop = stack.pop\n        \n        dist[s] = 0\n        push(s)\n        \n        while stack:\n            now = pop()\n            now_cost = dist[now]\n            \n            for (nv, c) in to[now]:\n                if dist[nv] != INF:\n                    continue\n                dist[nv] = now_cost + c\n                push(nv)\n    \n    \n    K -= 1\n    dfs(K)\n    ans = []\n    for (x, y) in queries:\n        x -= 1\n        y -= 1\n        xy = dist[x] + dist[y]\n        ans.append(xy)\n    \n    print(sep='\\n', *ans)\ndef __starting_point():\n    pass\n__starting_point()", "score": 0.0, "codebleu": 0.8562948067646386, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.993807852268219, "surfaceSim": 0.9842954260132175, "abs_surfaceSim_minus_score": 0.9842954260132175, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 91}
{"id": "LOCAL_APPS_1039_1_MUT_53", "golden_code": "import sys\ndef input():\n    return sys.stdin.readline().strip()\nfrom collections import deque\ndef main():\n    N = int(input())\n    info = [tuple(map(int, input().split())) for _ in range(N - 1)]\n    (Q, K) = map(int, input().split())\n    queries = [tuple(map(int, input().split())) for _ in range(Q)]\n    \n    to = [[] for _ in range(N)]\n    for (a, b, c) in info:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        to[b].append((a, c))\n    \n    INF = 10 ** 18\n    dist = [INF] * N\n    def dfs(s):\n        stack = deque()\n        push = stack.append\n        pop = stack.pop\n        \n        dist[s] = 0\n        push(s)\n        \n        while stack:\n            now = pop()\n            now_cost = dist[now]\n            \n            for (nv, c) in to[now]:\n                if dist[nv] != INF:\n                    continue\n                dist[nv] = now_cost + c\n                push(nv)\n    \n    \n    K -= 1\n    dfs(K)\n    ans = []\n    for (x, y) in queries:\n        x -= 1\n        y -= 1\n        xy = dist[x] + dist[y]\n        ans.append(xy)\n    \n    print(sep='\\n', *ans)\ndef __starting_point():\n    main()\n__starting_point()", "generated_code": "import sys\ndef input():\n    return sys.stdin.readline().strip()\nfrom collections import deque\ndef main():\n    N = int(input())\n    info = [tuple(map(int, input().split())) for _ in range(N - 1)]\n    (Q, K) = map(int, input().split())\n    queries = [tuple(map(int, input().split())) for _ in range(Q)]\n    \n    to = [[] for _ in range(N)]\n    for (a, b, c) in info:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        to[b].append((a, c))\n    \n    INF = 10 ** 18\n    dist = [INF] * N\n    def dfs(s):\n        stack = deque()\n        push = stack.append\n        pop = stack.pop\n        \n        dist[s] = 0\n        push(s)\n        \n        while stack:\n            now = pop()\n            now_cost = dist[now]\n            \n            for (nv, c) in to[now]:\n                if dist[nv] != INF:\n                    continue\n                dist[nv] = now_cost + c\n                push(nv)\n    \n    \n    K -= 1\n    dfs(K)\n    ans = []\n    for (x, y) in queries:\n        x -= 1\n        y -= 1\n        xy = dist[x] + dist[y]\n        ans.append(xy)\n    \n    print(sep='\\n', *ans)\ndef __starting_point():\n    main()\npass", "score": 0.0, "codebleu": 0.9909705008540134, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9938027858734131, "surfaceSim": 0.9790368808773717, "abs_surfaceSim_minus_score": 0.9790368808773717, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 92}
{"id": "LOCAL_APPS_1073_23_MUT_6", "golden_code": "n = int(input())\nch = str(input())\nr = 0\na = 0\nb = 0\nT = [[0, 0]]\nfor k in range(n):\n    if ch[k] == 'U':\n        a += 1\n    elif ch[k] == 'D':\n        a -= 1\n    elif ch[k] == 'R':\n        b += 1\n    else:\n        b -= 1\n    T += [[a, b]]\n\nfor i in range(1, n + 1):\n    for j in range(i):\n        if T[j] == T[i]:\n            r += 1\n\nprint(r)", "generated_code": "n = int(input())\nch = str(input())\nr = 0\na = 0\nb = 0\nT = [[0, 0]]\nfor k in range(n):\n    if ch[k] == 'U':\n        a += 1\n    elif ch[k] == 'D':\n        a -= 1\n    elif ch[k] == 'R':\n        b += 1\n    else:\n        b -= 1\n    T -= [[a, b]]\n\nfor i in range(1, n + 1):\n    for j in range(i):\n        if T[j] == T[i]:\n            r += 1\n\nprint(r)", "score": 0.0, "codebleu": 0.9821175747296871, "crystalbleu": 0.98, "codebertscore": 1.0, "codescore": 0.9936680197715759, "surfaceSim": 0.9985422740524781, "abs_surfaceSim_minus_score": 0.9985422740524781, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 93}
{"id": "LOCAL_APPS_1073_23_MUT_11", "golden_code": "n = int(input())\nch = str(input())\nr = 0\na = 0\nb = 0\nT = [[0, 0]]\nfor k in range(n):\n    if ch[k] == 'U':\n        a += 1\n    elif ch[k] == 'D':\n        a -= 1\n    elif ch[k] == 'R':\n        b += 1\n    else:\n        b -= 1\n    T += [[a, b]]\n\nfor i in range(1, n + 1):\n    for j in range(i):\n        if T[j] == T[i]:\n            r += 1\n\nprint(r)", "generated_code": "n = int(input())\nch = str(input())\nr = 0\na = 0\nb = 0\nT = [[0, 0]]\nfor k in range(n):\n    if ch[k] == 'U':\n        a += 1\n    elif ch[k] == 'D':\n        a -= 1\n    elif ch[k] == 'R':\n        b += 1\n    else:\n        b -= 1\n    T += [[a, b]]\n\nfor i in range(1, n + 1):\n    for j in range(i):\n        if not (T[j] == T[i]):\n            r += 1\n\nprint(r)", "score": 0.0, "codebleu": 0.9464007170150986, "crystalbleu": 0.93, "codebertscore": 1.0, "codescore": 0.9936814308166504, "surfaceSim": 0.9452176285987175, "abs_surfaceSim_minus_score": 0.9452176285987175, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 94}
{"id": "LOCAL_APPS_1073_23_MUT_23", "golden_code": "n = int(input())\nch = str(input())\nr = 0\na = 0\nb = 0\nT = [[0, 0]]\nfor k in range(n):\n    if ch[k] == 'U':\n        a += 1\n    elif ch[k] == 'D':\n        a -= 1\n    elif ch[k] == 'R':\n        b += 1\n    else:\n        b -= 1\n    T += [[a, b]]\n\nfor i in range(1, n + 1):\n    for j in range(i):\n        if T[j] == T[i]:\n            r += 1\n\nprint(r)", "generated_code": "n = int(input())\nch = str(input())\nr = 0\na = 0\nb = 0\nT = [[0, 0]]\nfor k in range(n):\n    if ch[k] == 'U':\n        a += 1\n    elif ch[k] == 'D':\n        a -= 1\n    elif ch[k] == 'R':\n        b += 1\n    else:\n        b -= 1\n    T += [[a, b]]\n\nfor i in range(1, n + 1):\n    for j in range(i):\n        if T[j] != T[i]:\n            r += 1\n\nprint(r)", "score": 0.0, "codebleu": 0.9821175747296871, "crystalbleu": 0.95, "codebertscore": 1.0, "codescore": 0.9937096834182739, "surfaceSim": 0.9735422740524782, "abs_surfaceSim_minus_score": 0.9735422740524782, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 95}
{"id": "LOCAL_APPS_1085_39_MUT_3", "golden_code": "n = int(input())\ndef make_divisors(n):\n    divisors = []\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n // i)\n    return divisors\nimport sys\nsys.setrecursionlimit(10 ** 7)\ndef func(N, d):\n    if d == 1:\n        return False\n    while N > 1:\n        if N % d == 0:\n            N //= d\n        \n        elif (N - 1) % d == 0:\n            N = 1\n        else:\n            N = 0\n    return True if N == 1 else False\n\nans = len(set(make_divisors(n - 1))) - 1\nl = set(make_divisors(n))\nfor li in l:\n    if func(n, li):\n        ans += 1\nprint(ans)", "generated_code": "n = int(input())\ndef make_divisors(n):\n    divisors = []\n    for i in range(1, int(n ** 0.5) + 1):\n        if n * i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n // i)\n    return divisors\nimport sys\nsys.setrecursionlimit(10 ** 7)\ndef func(N, d):\n    if d == 1:\n        return False\n    while N > 1:\n        if N % d == 0:\n            N //= d\n        \n        elif (N - 1) % d == 0:\n            N = 1\n        else:\n            N = 0\n    return True if N == 1 else False\n\nans = len(set(make_divisors(n - 1))) - 1\nl = set(make_divisors(n))\nfor li in l:\n    if func(n, li):\n        ans += 1\nprint(ans)", "score": 0.0, "codebleu": 0.9882119736406023, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9937254786491394, "surfaceSim": 0.9836057692307693, "abs_surfaceSim_minus_score": 0.9836057692307693, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 96}
{"id": "LOCAL_APPS_1085_39_MUT_9", "golden_code": "n = int(input())\ndef make_divisors(n):\n    divisors = []\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n // i)\n    return divisors\nimport sys\nsys.setrecursionlimit(10 ** 7)\ndef func(N, d):\n    if d == 1:\n        return False\n    while N > 1:\n        if N % d == 0:\n            N //= d\n        \n        elif (N - 1) % d == 0:\n            N = 1\n        else:\n            N = 0\n    return True if N == 1 else False\n\nans = len(set(make_divisors(n - 1))) - 1\nl = set(make_divisors(n))\nfor li in l:\n    if func(n, li):\n        ans += 1\nprint(ans)", "generated_code": "n = int(input())\ndef make_divisors(n):\n    divisors = []\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n // i)\n    return divisors\nimport sys\nsys.setrecursionlimit(10 ** 7)\ndef func(N, d):\n    if d == 1:\n        return False\n    while N > 1:\n        if N * d == 0:\n            N //= d\n        \n        elif (N - 1) % d == 0:\n            N = 1\n        else:\n            N = 0\n    return True if N == 1 else False\n\nans = len(set(make_divisors(n - 1))) - 1\nl = set(make_divisors(n))\nfor li in l:\n    if func(n, li):\n        ans += 1\nprint(ans)", "score": 0.0, "codebleu": 0.9882119736406023, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9937248826026917, "surfaceSim": 0.9836057692307693, "abs_surfaceSim_minus_score": 0.9836057692307693, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 97}
{"id": "LOCAL_APPS_1085_39_MUT_13", "golden_code": "n = int(input())\ndef make_divisors(n):\n    divisors = []\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n // i)\n    return divisors\nimport sys\nsys.setrecursionlimit(10 ** 7)\ndef func(N, d):\n    if d == 1:\n        return False\n    while N > 1:\n        if N % d == 0:\n            N //= d\n        \n        elif (N - 1) % d == 0:\n            N = 1\n        else:\n            N = 0\n    return True if N == 1 else False\n\nans = len(set(make_divisors(n - 1))) - 1\nl = set(make_divisors(n))\nfor li in l:\n    if func(n, li):\n        ans += 1\nprint(ans)", "generated_code": "n = int(input())\ndef make_divisors(n):\n    divisors = []\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n // i)\n    return divisors\nimport sys\nsys.setrecursionlimit(10 ** 7)\ndef func(N, d):\n    if d == 1:\n        return False\n    while N > 1:\n        if N % d == 0:\n            N //= d\n        \n        elif (N - 1) % d == 0:\n            N = 1\n        else:\n            N = 0\n    return True if N == 1 else False\n\nans = len(set(make_divisors(n - 1))) + 1\nl = set(make_divisors(n))\nfor li in l:\n    if func(n, li):\n        ans += 1\nprint(ans)", "score": 0.0, "codebleu": 0.9882119736406023, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.9937306642532349, "surfaceSim": 0.9992307692307693, "abs_surfaceSim_minus_score": 0.9992307692307693, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 98}
{"id": "LOCAL_APPS_1085_39_MUT_16", "golden_code": "n = int(input())\ndef make_divisors(n):\n    divisors = []\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n // i)\n    return divisors\nimport sys\nsys.setrecursionlimit(10 ** 7)\ndef func(N, d):\n    if d == 1:\n        return False\n    while N > 1:\n        if N % d == 0:\n            N //= d\n        \n        elif (N - 1) % d == 0:\n            N = 1\n        else:\n            N = 0\n    return True if N == 1 else False\n\nans = len(set(make_divisors(n - 1))) - 1\nl = set(make_divisors(n))\nfor li in l:\n    if func(n, li):\n        ans += 1\nprint(ans)", "generated_code": "n = int(input())\ndef make_divisors(n):\n    divisors = []\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n // i)\n    return divisors\nimport sys\nsys.setrecursionlimit(10 ** 7)\ndef func(N, d):\n    if d == 1:\n        return False\n    while N > 1:\n        if N % d == 0:\n            N //= d\n        \n        elif (N - 1) % d == 0:\n            N = 1\n        else:\n            N = 0\n    return True if N == 1 else False\n\nans = len(set(make_divisors(n - 1))) - 1\nl = set(make_divisors(n))\nfor li in l:\n    if func(n, li):\n        ans -= 1\nprint(ans)", "score": 0.0, "codebleu": 0.989440189567969, "crystalbleu": 0.99, "codebertscore": 1.0, "codescore": 0.993830144405365, "surfaceSim": 0.9992307692307693, "abs_surfaceSim_minus_score": 0.9992307692307693, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 99}
{"id": "LOCAL_APPS_1085_39_MUT_18", "golden_code": "n = int(input())\ndef make_divisors(n):\n    divisors = []\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n // i)\n    return divisors\nimport sys\nsys.setrecursionlimit(10 ** 7)\ndef func(N, d):\n    if d == 1:\n        return False\n    while N > 1:\n        if N % d == 0:\n            N //= d\n        \n        elif (N - 1) % d == 0:\n            N = 1\n        else:\n            N = 0\n    return True if N == 1 else False\n\nans = len(set(make_divisors(n - 1))) - 1\nl = set(make_divisors(n))\nfor li in l:\n    if func(n, li):\n        ans += 1\nprint(ans)", "generated_code": "n = int(input())\ndef make_divisors(n):\n    divisors = []\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            if not (i != n // i):\n                divisors.append(n // i)\n    return divisors\nimport sys\nsys.setrecursionlimit(10 ** 7)\ndef func(N, d):\n    if d == 1:\n        return False\n    while N > 1:\n        if N % d == 0:\n            N //= d\n        \n        elif (N - 1) % d == 0:\n            N = 1\n        else:\n            N = 0\n    return True if N == 1 else False\n\nans = len(set(make_divisors(n - 1))) - 1\nl = set(make_divisors(n))\nfor li in l:\n    if func(n, li):\n        ans += 1\nprint(ans)", "score": 0.0, "codebleu": 0.9548641284147206, "crystalbleu": 0.96, "codebertscore": 1.0, "codescore": 0.9937090873718262, "surfaceSim": 0.9658859940872137, "abs_surfaceSim_minus_score": 0.9658859940872137, "codebertscore_abs_err_vs_score": 1.0, "_worst_metric": "codebertscore", "_worst_rank": 100}
